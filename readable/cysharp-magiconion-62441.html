<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Cysharp/MagicOnion - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Cysharp/MagicOnion - linksfor.dev(s)"/>
    <meta property="og:description" content="Unified Realtime/API Engine for .NET Core and Unity. - Cysharp/MagicOnion"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/Cysharp/MagicOnion"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Cysharp/MagicOnion</title>
<div class="readable">
        <h1>Cysharp/MagicOnion</h1>
            <div>Reading time: 63-80 minutes</div>
        <div>Posted here: 04 Jun 2020</div>
        <p><a href="https://github.com/Cysharp/MagicOnion">https://github.com/Cysharp/MagicOnion</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    
      <div>
        <article itemprop="text">
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/Cysharp/MagicOnion/workflows/build-debug/badge.svg"><img src="https://github.com/Cysharp/MagicOnion/workflows/build-debug/badge.svg" alt="build-debug"></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/Cysharp/MagicOnion/workflows/build-canary/badge.svg"><img src="https://github.com/Cysharp/MagicOnion/workflows/build-canary/badge.svg" alt="build-canary"></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/Cysharp/MagicOnion/workflows/build-release/badge.svg"><img src="https://github.com/Cysharp/MagicOnion/workflows/build-release/badge.svg" alt="build-release"></a> <a href="https://github.com/Cysharp/MagicOnion/releases"><img src="https://camo.githubusercontent.com/4a87e74b735a9d8b7282c8a1327b82711aa3c61e/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652f437973686172702f4d616769634f6e696f6e2e737667" alt="Releases" data-canonical-src="https://img.shields.io/github/release/Cysharp/MagicOnion.svg"></a></p>
<p>Unified Realtime/API Engine for .NET Core and Unity.</p>
<p><a href="#-table-of-contents"><g-emoji alias="book" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d6.png">ðŸ“–</g-emoji> Table of contents</a></p>
<h2>What is it?</h2>
<p>MagicOnion is an Realtime Network Engine like <a href="https://github.com/aspnet/AspNetCore/tree/master/src/SignalR">SignalR</a>, <a href="https://socket.io/" rel="nofollow">Socket.io</a> and RPC-Web API Framework like any web-framework.</p>
<p>MagicOnion is built on <a href="https://grpc.io/" rel="nofollow">gRPC</a> so fast(HTTP/2) and compact(binary) network transport. It does not requires <code>.proto</code> and generate unlike plain gRPC. Protocol schema can share a C# interface and classes.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/46207/50965239-c4fdb000-1514-11e9-8365-304c776ffd77.png"><img src="https://user-images.githubusercontent.com/46207/50965239-c4fdb000-1514-11e9-8365-304c776ffd77.png" alt="image"></a></p>
<blockquote>
<p>Share interface as schema and request as API Service seems like normal C# code</p>
</blockquote>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/46207/50965825-7bae6000-1516-11e9-9501-dc91582f4d1b.png"><img src="https://user-images.githubusercontent.com/46207/50965825-7bae6000-1516-11e9-9501-dc91582f4d1b.png" alt="image"></a></p>
<blockquote>
<p>StreamingHub realtime service, broadcast data to many connected clients</p>
</blockquote>
<p>MagicOnion is for Microservices(communicate between .NET Core Servers like Orleans, ServiceFabric, AMBROSIA), API Service(for WinForms/WPF like WCF, ASP.NET Core MVC), Native Clientâ€™s API(for Xamarin, Unity) and Realtime Server that replacement like Socket.io, SignalR, Photon, UNet, etc.</p>
<h2>Quick Start</h2>
<p>for .NET 4.6, 4.7 and .NET Standard 2.0(.NET Core) available in NuGet. Unity supports see <a href="#unity-client-supports">Unity client Supports</a> section. HttpGateway + Swagger Intergarion supports see <a href="#swagger">Swagger</a> section.</p>
<pre><code>Install-Package MagicOnion
</code></pre>
<p>MagicOnion has two sides, <code>Service</code> for like web-api and <code>StreamingHub</code> for realtime communication. At first, see define <code>Service</code>.</p>
<div><pre><span>using</span> <span>Grpc</span>.<span>Core</span>;
<span>using</span> <span>MagicOnion</span>;
<span>using</span> <span>MagicOnion</span>.<span>Server</span>;
<span>using</span> <span>System</span>;

<span><span>//</span> define interface as Server/Client IDL.</span>
<span><span>//</span> implements T : IService&lt;T&gt; and share this type between server and client.</span>
<span>public</span> <span>interface</span> <span>IMyFirstService</span> : <span>IService</span>&lt;<span>IMyFirstService</span>&gt;
{
    <span><span>//</span> Return type must be `UnaryResult&lt;T&gt;` or `Task&lt;UnaryResult&lt;T&gt;&gt;`.</span>
    <span><span>//</span> If you can use C# 7.0 or newer, recommend to use `UnaryResult&lt;T&gt;`.</span>
    <span>UnaryResult</span>&lt;<span>int</span>&gt; <span>SumAsync</span>(<span>int</span> <span>x</span>, <span>int</span> <span>y</span>);
}

<span><span>//</span> implement RPC service to Server Project.</span>
<span><span>//</span> inehrit ServiceBase&lt;interface&gt;, interface</span>
<span>public</span> <span>class</span> <span>MyFirstService</span> : <span>ServiceBase</span>&lt;<span>IMyFirstService</span>&gt;, <span>IMyFirstService</span>
{
    <span><span>//</span> You can use async syntax directly.</span>
    <span>public</span> <span>async</span> <span>UnaryResult</span>&lt;<span>int</span>&gt; <span>SumAsync</span>(<span>int</span> <span>x</span>, <span>int</span> <span>y</span>)
    {
        <span>Logger</span>.<span>Debug</span>(<span><span>$"</span>Received:{<span>x</span>}, {<span>y</span>}<span>"</span></span>);

        <span>return</span> <span>x</span> <span>+</span> <span>y</span>;
    }
}</pre></div>
<p>and, launch the server.</p>
<div><pre><span>class</span> <span>Program</span>
{
    <span>static</span> <span>void</span> <span>Main</span>(<span>string</span>[] <span>args</span>)
    {
        <span>GrpcEnvironment</span>.<span>SetLogger</span>(<span>new</span> <span>Grpc</span>.<span>Core</span>.<span>Logging</span>.<span>ConsoleLogger</span>());

        <span><span>//</span> setup MagicOnion and option.</span>
        <span>var</span> <span>service</span> <span>=</span> <span>MagicOnionEngine</span>.<span>BuildServerServiceDefinition</span>(<span>isReturnExceptionStackTraceInErrorDetail</span>: <span>true</span>);

        <span>var</span> <span>server</span> <span>=</span> <span>new</span> <span>global</span>::<span>Grpc</span>.<span>Core</span>.<span>Server</span>
        {
            <span>Services</span> <span>=</span> { <span>service</span> },
            <span>Ports</span> <span>=</span> { <span>new</span> <span>ServerPort</span>(<span><span>"</span>localhost<span>"</span></span>, <span>12345</span>, <span>ServerCredentials</span>.<span>Insecure</span>) }
        };
        
        <span><span>//</span> launch gRPC Server.</span>
        <span>server</span>.<span>Start</span>();

        <span><span>//</span> and wait.</span>
        <span>Console</span>.<span>ReadLine</span>();
    }
}</pre></div>
<p>write the client.</p>
<div><pre><span><span>//</span> standard gRPC channel</span>
<span>var</span> <span>channel</span> <span>=</span> <span>new</span> <span>Channel</span>(<span><span>"</span>localhost<span>"</span></span>, <span>12345</span>, <span>ChannelCredentials</span>.<span>Insecure</span>);

<span><span>//</span> get MagicOnion dynamic client proxy</span>
<span>var</span> <span>client</span> <span>=</span> <span>MagicOnionClient</span>.<span>Create</span>&lt;<span>IMyFirstService</span>&gt;(<span>channel</span>);

<span><span>//</span> call method.</span>
<span>var</span> <span>result</span> <span>=</span> <span>await</span> <span>client</span>.<span>SumAsync</span>(<span>100</span>, <span>200</span>);
<span>Console</span>.<span>WriteLine</span>(<span><span>"</span>Client Received:<span>"</span></span> <span>+</span> <span>result</span>);</pre></div>
<p>MagicOnion allows primitive, multiple request value. Complex type is serialized by LZ4 Compressed MsgPack by <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a> so type should follow MessagePack for C# rules.</p>
<blockquote>
<p>for Server Hosting, We recommend to use <code>MagicOnion.Hosting</code>, it is easy to host and wait terminate signal, load from config, support DI, etc. see <a href="#server-host">Server host</a> section.</p>
</blockquote>
<h2><g-emoji alias="book" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d6.png">ðŸ“–</g-emoji> Table of contents</h2>
<ul>
<li><a href="#what-is-it">What is it?</a></li>
<li><a href="#quick-start">Quick Start</a></li>
<li>Fundamentals
<ul>
<li><a href="#streaminghub">StreamingHub</a></li>
<li><a href="#filter">Filter</a></li>
<li><a href="#clientfilter">ClientFilter</a></li>
<li><a href="#servicecontext-and-lifecycle">ServiceContext and Lifecycle</a></li>
<li><a href="#exceptionhandling-and-statuscode">ExceptionHandling and StatusCode</a></li>
<li><a href="#group-and-groupconfiguration">Group and GroupConfiguration</a></li>
<li><a href="#project-structure">Project Structure</a></li>
<li><a href="#dependency-injection">Dependency Injection</a></li>
</ul>
</li>
<li>Client and Server
<ul>
<li><a href="#unity-client-supports">Unity client supports</a>
<ul>
<li><a href="#ios-build-with-grpc">iOS build with grpc</a></li>
<li><a href="#stripping-debug-symbols-from-ioslibgrpca">Stripping debug symbols from ios/libgrpc.a</a></li>
</ul>
</li>
<li><a href="#server-host">Server Host</a>
<ul>
<li><a href="#server-host-options">Server Host options</a></li>
</ul>
</li>
<li><a href="#grpc-keepalive">gRPC Keepalive</a></li>
</ul>
</li>
<li>Deployment
<ul>
<li><a href="#host-in-docker">Host in Docker</a></li>
<li><a href="#ssltls">SSL/TLS</a></li>
</ul>
</li>
<li>Integrations
<ul>
<li><a href="#swagger">Swagger</a></li>
<li><a href="#telemetry">Telemetry</a></li>
</ul>
</li>
<li>Advanced
<ul>
<li><a href="#magiconionoptionlogging">MagicOnionOption/Logging</a></li>
<li><a href="#raw-grpc-apis">Raw gRPC APIs</a></li>
<li><a href="#zero-deserialization-mapping">Zero deserialization mapping</a></li>
</ul>
</li>
<li><a href="#author-info">Author Info</a></li>
<li><a href="#license">License</a></li>
</ul>
<h2>Fundamentals</h2>
<h3>StreamingHub</h3>
<p>StreamingHub is a fully-typed realtime server&lt;-&gt;client communication framework.</p>
<p>This sample is for Unity(use Vector3, GameObject, etc) but StreamingHub supports .NET Core, too.</p>
<div><pre><span><span>//</span> Server -&gt; Client definition</span>
<span>public</span> <span>interface</span> <span>IGamingHubReceiver</span>
{
    <span><span>//</span> return type shuold be `void` or `Task`, parameters are free.</span>
    <span>void</span> <span>OnJoin</span>(<span>Player</span> <span>player</span>);
    <span>void</span> <span>OnLeave</span>(<span>Player</span> <span>player</span>);
    <span>void</span> <span>OnMove</span>(<span>Player</span> <span>player</span>);
}
 
<span><span>//</span> Client -&gt; Server definition</span>
<span><span>//</span> implements `IStreamingHub&lt;TSelf, TReceiver&gt;`  and share this type between server and client.</span>
<span>public</span> <span>interface</span> <span>IGamingHub</span> : <span>IStreamingHub</span>&lt;<span>IGamingHub</span>, <span>IGamingHubReceiver</span>&gt;
{
    <span><span>//</span> return type shuold be `Task` or `Task&lt;T&gt;`, parameters are free.</span>
    <span>Task</span>&lt;<span>Player</span>[]&gt; <span>JoinAsync</span>(<span>string</span> <span>roomName</span>, <span>string</span> <span>userName</span>, <span>Vector3</span> <span>position</span>, <span>Quaternion</span> <span>rotation</span>);
    <span>Task</span> <span>LeaveAsync</span>();
    <span>Task</span> <span>MoveAsync</span>(<span>Vector3</span> <span>position</span>, <span>Quaternion</span> <span>rotation</span>);
}
 
<span><span>//</span> for example, request object by MessagePack.</span>
[<span>MessagePackObject</span>]
<span>public</span> <span>class</span> <span>Player</span>
{
    [<span>Key</span>(<span>0</span>)]
    <span>public</span> <span>string</span> <span>Name</span> { <span>get</span>; <span>set</span>; }
    [<span>Key</span>(<span>1</span>)]
    <span>public</span> <span>Vector3</span> <span>Position</span> { <span>get</span>; <span>set</span>; }
    [<span>Key</span>(<span>2</span>)]
    <span>public</span> <span>Quaternion</span> <span>Rotation</span> { <span>get</span>; <span>set</span>; }
}</pre></div>
<div><pre><span><span>//</span> Server implementation</span>
<span><span>//</span> implements : StreamingHubBase&lt;THub, TReceiver&gt;, THub</span>
<span>public</span> <span>class</span> <span>GamingHub</span> : <span>StreamingHubBase</span>&lt;<span>IGamingHub</span>, <span>IGamingHubReceiver</span>&gt;, <span>IGamingHub</span>
{
    <span><span>//</span> this class is instantiated per connected so fields are cache area of connection.</span>
    <span>IGroup</span> <span>room</span>;
    <span>Player</span> <span>self</span>;
    <span>IInMemoryStorage</span>&lt;<span>Player</span>&gt; <span>storage</span>;

    <span>public</span> <span>async</span> <span>Task</span>&lt;<span>Player</span>[]&gt; <span>JoinAsync</span>(<span>string</span> <span>roomName</span>, <span>string</span> <span>userName</span>, <span>Vector3</span> <span>position</span>, <span>Quaternion</span> <span>rotation</span>)
    {
        <span>self</span> <span>=</span> <span>new</span> <span>Player</span>() { <span>Name</span> <span>=</span> <span>userName</span>, <span>Position</span> <span>=</span> <span>position</span>, <span>Rotation</span> <span>=</span> <span>rotation</span> };

        <span><span>//</span> Group can bundle many connections and it has inmemory-storage so add any type per group. </span>
        (<span>room</span>, <span>storage</span>) <span>=</span> <span>await</span> <span>Group</span>.<span>AddAsync</span>(<span>roomName</span>, <span>self</span>);

        <span><span>//</span> Typed Server-&gt;Client broadcast.</span>
        <span>Broadcast</span>(<span>room</span>).<span>OnJoin</span>(<span>self</span>);

        <span>return</span> <span>storage</span>.<span>AllValues</span>.<span>ToArray</span>();
    }

    <span>public</span> <span>async</span> <span>Task</span> <span>LeaveAsync</span>()
    {
        <span>await</span> <span>room</span>.<span>RemoveAsync</span>(<span>this</span>.<span>Context</span>);
        <span>Broadcast</span>(<span>room</span>).<span>OnLeave</span>(<span>self</span>);
    }

    <span>public</span> <span>async</span> <span>Task</span> <span>MoveAsync</span>(<span>Vector3</span> <span>position</span>, <span>Quaternion</span> <span>rotation</span>)
    {
        <span>self</span>.<span>Position</span> <span>=</span> <span>position</span>;
        <span>self</span>.<span>Rotation</span> <span>=</span> <span>rotation</span>;
        <span>Broadcast</span>(<span>room</span>).<span>OnMove</span>(<span>self</span>);
    }

    <span><span>//</span> You can hook OnConnecting/OnDisconnected by override.</span>
    <span>protected</span> <span>override</span> <span>async</span> <span>ValueTask</span> <span>OnDisconnected</span>()
    {
        <span><span>//</span> on disconnecting, if automatically removed this connection from group.</span>
        <span>return</span> <span>CompletedTask</span>;
    }
}</pre></div>
<p>You can write client like this.</p>
<div><pre><span>public</span> <span>class</span> <span>GamingHubClient</span> : <span>IGamingHubReceiver</span>
{
    <span>Dictionary</span>&lt;<span>string</span>, <span>GameObject</span>&gt; <span>players</span> <span>=</span> <span>new</span> <span>Dictionary</span>&lt;<span>string</span>, <span>GameObject</span>&gt;();
 
    <span>IGamingHub</span> <span>client</span>;
 
    <span>public</span> <span>async</span> <span>Task</span>&lt;<span>GameObject</span>&gt; <span>ConnectAsync</span>(<span>Channel</span> <span>grpcChannel</span>, <span>string</span> <span>roomName</span>, <span>string</span> <span>playerName</span>)
    {
        <span>var</span> <span>client</span> <span>=</span> <span>StreamingHubClient</span>.<span>Connect</span>&lt;<span>IGamingHub</span>, <span>IGamingHubReceiver</span>&gt;(<span>grpcChannel</span>, <span>this</span>);
 
        <span>var</span> <span>roomPlayers</span> <span>=</span> <span>await</span> <span>client</span>.<span>JoinAsync</span>(<span>roomName</span>, <span>playerName</span>, <span>Vector3</span>.<span>zero</span>, <span>Quaternion</span>.<span>identity</span>);
        <span>foreach</span> (<span>var</span> <span>player</span> <span>in</span> <span>roomPlayers</span>)
        {
            (<span>this</span> <span>as</span> <span>IGamingHubReceiver</span>).<span>OnJoin</span>(<span>player</span>);
        }
 
        <span>return</span> <span>players</span>[<span>playerName</span>];
    }
 
    <span><span>//</span> methods send to server.</span>
 
    <span>public</span> <span>Task</span> <span>LeaveAsync</span>()
    {
        <span>return</span> <span>client</span>.<span>LeaveAsync</span>();
    }
 
    <span>public</span> <span>Task</span> <span>MoveAsync</span>(<span>Vector3</span> <span>position</span>, <span>Quaternion</span> <span>rotation</span>)
    {
        <span>return</span> <span>client</span>.<span>MoveAsync</span>(<span>position</span>, <span>rotation</span>);
    }
 
    <span><span>//</span> dispose client-connection before channel.ShutDownAsync is important!</span>
    <span>public</span> <span>Task</span> <span>DisposeAsync</span>()
    {
        <span>return</span> <span>client</span>.<span>DisposeAsync</span>();
    }
 
    <span><span>//</span> You can watch connection state, use this for retry etc.</span>
    <span>public</span> <span>Task</span> <span>WaitForDisconnect</span>()
    {
        <span>return</span> <span>client</span>.<span>WaitForDisconnect</span>();
    }
 
    <span><span>//</span> Receivers of message from server.</span>
 
    void IGamingHubReceiver.<span>OnJoin</span>(<span>Player</span> <span>player</span>)
    {
        <span>Debug</span>.<span>Log</span>(<span><span>"</span>Join Player:<span>"</span></span> <span>+</span> <span>player</span>.<span>Name</span>);
 
        <span>var</span> <span>cube</span> <span>=</span> <span>GameObject</span>.<span>CreatePrimitive</span>(<span>PrimitiveType</span>.<span>Cube</span>);
        <span>cube</span>.<span>name</span> <span>=</span> <span>player</span>.<span>Name</span>;
        <span>cube</span>.<span>transform</span>.<span>SetPositionAndRotation</span>(<span>player</span>.<span>Position</span>, <span>player</span>.<span>Rotation</span>);
        <span>players</span>[<span>player</span>.<span>Name</span>] <span>=</span> <span>cube</span>;
    }
 
    void IGamingHubReceiver.<span>OnLeave</span>(<span>Player</span> <span>player</span>)
    {
        <span>Debug</span>.<span>Log</span>(<span><span>"</span>Leave Player:<span>"</span></span> <span>+</span> <span>player</span>.<span>Name</span>);
 
        <span>if</span> (<span>players</span>.<span>TryGetValue</span>(<span>player</span>.<span>Name</span>, <span>out</span> <span>var</span> <span>cube</span>))
        {
            <span>GameObject</span>.<span>Destroy</span>(<span>cube</span>);
        }
    }
 
    void IGamingHubReceiver.<span>OnMove</span>(<span>Player</span> <span>player</span>)
    {
        <span>Debug</span>.<span>Log</span>(<span><span>"</span>Move Player:<span>"</span></span> <span>+</span> <span>player</span>.<span>Name</span>);
 
        <span>if</span> (<span>players</span>.<span>TryGetValue</span>(<span>player</span>.<span>Name</span>, <span>out</span> <span>var</span> <span>cube</span>))
        {
            <span>cube</span>.<span>transform</span>.<span>SetPositionAndRotation</span>(<span>player</span>.<span>Position</span>, <span>player</span>.<span>Rotation</span>);
        }
    }
}</pre></div>
<h3>Filter</h3>
<p>MagicOnion filter is powerful feature to hook before-after invoke. It is useful than gRPC server interceptor.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/46207/50969421-cb465900-1521-11e9-8824-8a34cc52bbe4.png"><img src="https://user-images.githubusercontent.com/46207/50969421-cb465900-1521-11e9-8824-8a34cc52bbe4.png" alt="image"></a></p>
<div><pre><span><span>//</span> You can attach per class/method like [SampleFilter]</span>
<span><span>//</span> for StreamingHub methods, implement StreamingHubFilterAttribute instead.</span>
<span>public</span> <span>class</span> <span>SampleFilterAttribute</span> : <span>MagicOnionFilterAttribute</span>
{
    <span>public</span> <span>override</span> <span>async</span> <span>ValueTask</span> <span>Invoke</span>(<span>ServiceContext</span> <span>context</span>, <span>Func</span>&lt;<span>ServiceContext</span>, <span>ValueTask</span>&gt; <span>next</span>)
    {
        <span>try</span>
        {
            <span><span>/*</span> on before <span>*/</span></span>
            <span>await</span> <span>next</span>(<span>context</span>); <span><span>//</span> next</span>
            <span><span>/*</span> on after <span>*/</span></span>
        }
        <span>catch</span>
        {
            <span><span>/*</span> on exception <span>*/</span></span>
            <span>throw</span>;
        }
        <span>finally</span>
        {
            <span><span>/*</span> on finally <span>*/</span></span>
        }
    }
}</pre></div>
<p>Here is example of what kind of filter can be stacked.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/46207/50969539-2bd59600-1522-11e9-84ab-15dd85e3dcac.png"><img src="https://user-images.githubusercontent.com/46207/50969539-2bd59600-1522-11e9-84ab-15dd85e3dcac.png" alt="image"></a></p>
<p>GlobalFilter can attach to MagicOnionOptions.</p>
<p>MagicOnion filters supports <a href="#dependency-injection">DI</a> by <a href="#server-host">MagicOnion.Hosting</a>.</p>
<div><pre><span>public</span> <span>class</span> <span>MyStreamingHubFilterAttribute</span> : <span>StreamingHubFilterAttribute</span>
{
    <span>private</span> <span>readonly</span> <span>ILogger</span> <span>_logger</span>;

    <span><span>//</span> the `logger` parameter will be injected at instantiating.</span>
    <span>public</span> <span>MyStreamingHubFilterAttribute</span>(<span>ILogger</span>&lt;<span>MyStreamingHubFilterAttribute</span>&gt; <span>logger</span>)
    {
        <span>_logger</span> <span>=</span> <span>logger</span>;
    }

    <span>public</span> <span>override</span> <span>async</span> <span>ValueTask</span> <span>Invoke</span>(<span>StreamingHubContext</span> <span>context</span>, <span>Func</span>&lt;<span>StreamingHubContext</span>, <span>ValueTask</span>&gt; <span>next</span>)
    {
        <span>_logger</span>.<span>LogInformation</span>(<span><span>$"</span>MyStreamingHubFilter Begin: {<span>context</span>.<span>Path</span>}<span>"</span></span>);
        <span>await</span> <span>next</span>(<span>context</span>);
        <span>_logger</span>.<span>LogInformation</span>(<span><span>$"</span>MyStreamingHubFilter End: {<span>context</span>.<span>Path</span>}<span>"</span></span>);
    }
}</pre></div>
<p>Register filters using attributes with constructor injection(you can use <code>[FromTypeFilter]</code> and <code>[FromServiceFilter]</code>).</p>
<pre><code>[FromTypeFilter(typeof(MyFilterAttribute))]
public class MyService : ServiceBase&lt;IMyService&gt;, IMyService
{
    // The filter will instantiate from type.
    [FromTypeFilter(typeof(MySecondFilterAttribute))]
    public UnaryResult&lt;int&gt; Foo()
    {
        return UnaryResult(0);
    }

    // The filter will instantiate from type with some arguments. if the arguments are missing, it will be obtained from `IServiceLocator` 
    [FromTypeFilter(typeof(MyThirdFilterAttribute), Arguments = new object[] { "foo", 987654 })]
    public UnaryResult&lt;int&gt; Bar()
    {
        return UnaryResult(0);
    }

    // The filter instance will be provided via `IServiceLocator`.
    [FromServiceFilter(typeof(MyFourthFilterAttribute))]
    public UnaryResult&lt;int&gt; Baz()
    {
        return UnaryResult(0);
    }
}
</code></pre>
<h3>ClientFilter</h3>
<p>MagicOnion client-filter is a powerful feature to hook before-after invoke. It is useful than gRPC client interceptor.</p>
<blockquote>
<p>Currently only suppots on Unary.</p>
</blockquote>
<div><pre><span><span>//</span> you can attach in MagicOnionClient.Create.</span>
<span>var</span> <span>client</span> <span>=</span> <span>MagicOnionClient</span>.<span>Create</span>&lt;<span>ICalcService</span>&gt;(<span>channel</span>, <span>new</span> <span>IClientFilter</span>[]
{
    <span>new</span> <span>LoggingFilter</span>(),
    <span>new</span> <span>AppendHeaderFilter</span>(),
    <span>new</span> <span>RetryFilter</span>()
});</pre></div>
<p>You can create custom client-filter by implements <code>IClientFilter.SendAsync</code>.</p>
<div><pre><span>public</span> <span>class</span> <span>IDemoFilter</span> : <span>IClientFilter</span>
{
    <span>public</span> <span>async</span> <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt; <span>SendAsync</span>(<span>RequestContext</span> <span>context</span>, <span>Func</span>&lt;<span>RequestContext</span>, <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt;&gt; <span>next</span>)
    {
        <span>try</span>
        {
            <span><span>/*</span> Before Request, context.MethodPath/CallOptions/Items, etc <span>*/</span></span>

            <span>var</span> <span>response</span> <span>=</span> <span>await</span> <span>next</span>(<span>context</span>); <span><span>/*</span> Call next filter or method body <span>*/</span></span>

            <span><span>/*</span> After Request, response.GetStatus/GetTrailers/GetResponseAs&lt;T&gt;, etc <span>*/</span></span>

            <span>return</span> <span>response</span>;
        }
        <span>catch</span> (<span>RpcException</span> <span>ex</span>)
        {
            <span><span>/*</span> Get gRPC Error Response <span>*/</span></span>
            <span>throw</span>;
        }
        <span>catch</span> (<span>OperationCanceledException</span> <span>ex</span>)
        {
            <span><span>/*</span> If canceled <span>*/</span></span>
            <span>throw</span>;
        }
        <span>catch</span> (<span>Exception</span> <span>ex</span>)
        {
            <span><span>/*</span> Other Exception <span>*/</span></span>
            <span>throw</span>;
        }
        <span>finally</span>
        {
            <span><span>/*</span> Common Finalize <span>*/</span></span>
        }
    }
}</pre></div>
<p>Here is the sample filters, you can imagine what you can do.</p>
<div><pre><span>public</span> <span>class</span> <span>AppendHeaderFilter</span> : <span>IClientFilter</span>
{
    <span>public</span> <span>async</span> <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt; <span>SendAsync</span>(<span>RequestContext</span> <span>context</span>, <span>Func</span>&lt;<span>RequestContext</span>, <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt;&gt; <span>next</span>)
    {
        <span><span>//</span> add the common header(like authentcation).</span>
        <span>var</span> <span>header</span> <span>=</span> <span>context</span>.<span>CallOptions</span>.<span>Headers</span>;
        <span>header</span>.<span>Add</span>(<span><span>"</span>x-foo<span>"</span></span>, <span><span>"</span>abcdefg<span>"</span></span>);
        <span>header</span>.<span>Add</span>(<span><span>"</span>x-bar<span>"</span></span>, <span><span>"</span>hijklmn<span>"</span></span>);

        <span>return</span> <span>await</span> <span>next</span>(<span>context</span>);
    }
}

<span>public</span> <span>class</span> <span>LoggingFilter</span> : <span>IClientFilter</span>
{
    <span>public</span> <span>async</span> <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt; <span>SendAsync</span>(<span>RequestContext</span> <span>context</span>, <span>Func</span>&lt;<span>RequestContext</span>, <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt;&gt; <span>next</span>)
    {
        <span>Console</span>.<span>WriteLine</span>(<span><span>"</span>Request Begin:<span>"</span></span> <span>+</span> <span>context</span>.<span>MethodPath</span>); <span><span>//</span> Debug.Log in Unity.</span>

        <span>var</span> <span>sw</span> <span>=</span> <span>Stopwatch</span>.<span>StartNew</span>();
        <span>var</span> <span>response</span> <span>=</span> <span>await</span> <span>next</span>(<span>context</span>);
        <span>sw</span>.<span>Stop</span>();

        <span>Console</span>.<span>WriteLine</span>(<span><span>"</span>Request Completed:<span>"</span></span> <span>+</span> <span>context</span>.<span>MethodPath</span> <span>+</span> <span><span>"</span>, Elapsed:<span>"</span></span> <span>+</span> <span>sw</span>.<span>Elapsed</span>.<span>TotalMilliseconds</span> <span>+</span> <span><span>"</span>ms<span>"</span></span>);

        <span>return</span> <span>response</span>;
    }
}

<span>public</span> <span>class</span> <span>ResponseHandlingFilter</span> : <span>IClientFilter</span>
{
    <span>public</span> <span>async</span> <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt; <span>SendAsync</span>(<span>RequestContext</span> <span>context</span>, <span>Func</span>&lt;<span>RequestContext</span>, <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt;&gt; <span>next</span>)
    {
        <span>var</span> <span>response</span> <span>=</span> <span>await</span> <span>next</span>(<span>context</span>);

        <span>if</span> (<span>context</span>.<span>MethodPath</span> <span>==</span> <span><span>"</span>ICalc/Sum<span>"</span></span>)
        {
            <span><span>//</span> You can cast response type.</span>
            <span>var</span> <span>sumResult</span> <span>=</span> <span>await</span> <span>response</span>.<span>GetResponseAs</span>&lt;<span>int</span>&gt;();
            <span>Console</span>.<span>WriteLine</span>(<span><span>"</span>Called Sum, Result:<span>"</span></span> <span>+</span> <span>sumResult</span>);
        }

        <span>return</span> <span>response</span>;
    }
}

<span>public</span> <span>class</span> <span>MockRequestFilter</span> : <span>IClientFilter</span>
{
    <span>public</span> <span>async</span> <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt; <span>SendAsync</span>(<span>RequestContext</span> <span>context</span>, <span>Func</span>&lt;<span>RequestContext</span>, <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt;&gt; <span>next</span>)
    {
        <span>if</span> (<span>context</span>.<span>MethodPath</span> <span>==</span> <span><span>"</span>ICalc/Sum<span>"</span></span>)
        {
            <span><span>//</span> don't call next, return mock result.</span>
            <span>return</span> <span>new</span> <span>ResponseContext</span>&lt;<span>int</span>&gt;(<span>9999</span>);
        }

        <span>return</span> <span>await</span> <span>next</span>(<span>context</span>);
    }
}

<span>public</span> <span>class</span> <span>RetryFilter</span> : <span>IClientFilter</span>
{
    <span>public</span> <span>async</span> <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt; <span>SendAsync</span>(<span>RequestContext</span> <span>context</span>, <span>Func</span>&lt;<span>RequestContext</span>, <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt;&gt; <span>next</span>)
    {
        <span>Exception</span> <span>lastException</span> <span>=</span> <span>null</span>;
        <span>var</span> <span>retryCount</span> <span>=</span> <span>0</span>;
        <span>while</span> (<span>retryCount</span> <span>!=</span> <span>3</span>)
        {
            <span>try</span>
            {
                <span><span>//</span> using same CallOptions so be careful to add duplicate headers or etc.</span>
                <span>return</span> <span>await</span> <span>next</span>(<span>context</span>);
            }
            <span>catch</span> (<span>Exception</span> <span>ex</span>)
            {
                <span>lastException</span> <span>=</span> <span>ex</span>;
            }
            <span>retryCount</span><span>++</span>;
        }

        <span>throw</span> <span>new</span> <span>Exception</span>(<span><span>"</span>Retry failed<span>"</span></span>, <span>lastException</span>);
    }
}

<span>public</span> <span>class</span> <span>EncryptFilter</span> : <span>IClientFilter</span>
{
    <span>public</span> <span>async</span> <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt; <span>SendAsync</span>(<span>RequestContext</span> <span>context</span>, <span>Func</span>&lt;<span>RequestContext</span>, <span>ValueTask</span>&lt;<span>ResponseContext</span>&gt;&gt; <span>next</span>)
    {
        <span>context</span>.<span>SetRequestMutator</span>(<span>bytes</span> <span>=&gt;</span> <span>Encrypt</span>(<span>bytes</span>));
        <span>context</span>.<span>SetResponseMutator</span>(<span>bytes</span> <span>=&gt;</span> <span>Decrypt</span>(<span>bytes</span>));
        
        <span>return</span> <span>await</span> <span>next</span>(<span>context</span>);
    }
}</pre></div>
<h3>ServiceContext and Lifecycle</h3>
<p>Service/StreamingHub's method or <code>MagicOnionFilter</code> can access <code>this.Context</code> it is</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ConcurrentDictionary&lt;string, object&gt;</code> Items</td>
<td>Object storage per request/connection.</td>
</tr>
<tr>
<td><code>Guid</code> ContextId</td>
<td>Unieuq ID per request(Service)/connection(StreamingHub).</td>
</tr>
<tr>
<td><code>DateTime</code> Timestamp</td>
<td>Timestamp that request/connection is started time.</td>
</tr>
<tr>
<td><code>Type</code> ServiceType</td>
<td>Invoked Class.</td>
</tr>
<tr>
<td><code>MethodInfo</code> MethodInfo</td>
<td>Invoked Method.</td>
</tr>
<tr>
<td>`ILookup&lt;Type, Attribute&gt; AttributeLookup</td>
<td>Cached Attributes that merged both service and method.</td>
</tr>
<tr>
<td><code>ServerCallContext</code> CallContext</td>
<td>Raw gRPC Context.</td>
</tr>
<tr>
<td><code>IFormatterResolver</code> FormatterResolver</td>
<td>Using MessagePack resolver.</td>
</tr>
<tr>
<td><code>IServiceLocator</code> ServiceLocator</td>
<td>Get the registered service.</td>
</tr>
</tbody>
</table>
<p><code>Items</code> is useful, for example authentication filter add UserId to Items and take out from service method.</p>
<blockquote>
<p>If using StreamingHub, ServiceContext means per connected context so <code>Items</code> is not per method invoke. <code>StreamingHubContext.Items</code> supports per streaming hub method request but currently can not take from streaming hub method(only use in StreamingHubFilter). <a href="https://github.com/Cysharp/MagicOnion/issues/67">Issue:#67</a>, it will fix.</p>
</blockquote>
<p>MagicOnion supports get current context globaly like HttpContext.Current. <code>ServiceContext.Current</code> can get it but it requires <code>MagicOnionOptions.EnableCurrentContext = true</code>, default is false.</p>
<p>Lifecycle image of ServiceBase</p>
<pre><code>gRPC In(
    var context = new ServiceContext();
    Filter.Invoke(context, 
        var service = new ServiceImpl();
        service.ServiceContext = context;
        service.MethodInvoke(
            /* method impl */
        )
    )
)
</code></pre>
<p>Lifecycle image of StreamingHub(StreamingHub is inherited from ServiceBase)</p>
<pre><code>gRPC In(
    var context = new ServiceContext();
    Filter.Invoke(context, 
        var hub = new StreamingHubImpl();
        hub.ServiceContext = context;
        hub.Connect(
            while (connecting) {
                Streaming In(
                    var streamingHubContext = new StreamingHubContext(context);
                    StreamingHubFilter.Invoke(streamingHubContext,
                        hub.MethodInvoke(
                            /* method impl */
                        )
                    )
                )
            }
        )
    )
)
</code></pre>
<p>StreamingHub instance is shared while connecting so StreamingHub's field can use cache area of connection.</p>
<h3>ExceptionHandling and StatusCode</h3>
<p>If you are return custom status code from server to client, you can use <code>throw new ReturnStatusException</code>.</p>
<div><pre><span>public</span> <span>Task</span> <span>SendMessageAsync</span>(<span>string</span> <span>message</span>)
{
    <span>if</span> (<span>message</span>.<span>Contains</span>(<span><span>"</span>foo<span>"</span></span>))
    {
        <span><span>//</span></span>
        <span>throw</span> <span>new</span> <span>ReturnStatusException</span>((<span>Grpc</span>.<span>Core</span>.<span>StatusCode</span>)<span>99</span>, <span><span>"</span>invalid<span>"</span></span>);
    }

    <span><span>//</span> ....</span></pre></div>
<p>Client can receive exception as gRPC's <code>RpcException</code>. If performance centric to avoid exception throw, you can use raw gRPC CallContext.Status(<code>ServiceContext.CallCaontext.Status</code>) and set status directly.</p>
<p>MagicOnion's engine catched exception(except ReturnStatusException), set <code>StatusCode.Unknown</code> and client received gRPC's <code>RpcException</code>. If <code>MagicOnionOption.IsReturnExceptionStackTraceInErrorDetail</code> is true, client can receive StackTrace of server exception, it is very useful for debugging but has critical issue about sercurity so should only to enable debug build.</p>
<h3>Group and GroupConfiguration</h3>
<p>StreamingHub's broadcast system is called Group. It can get from StreamingHub impl method, <code>this.Group</code>(this.Group type is <code>HubGroupRepository</code>, not <code>IGroup</code>).</p>
<p>Current connection can add to group by <code>this.Group.AddAsync(string groupName)</code>, return value(<code>IGroup</code>) is joined group broadcaster so cache to field. It is enable per connection(if disconnected, automaticaly leaved from group). If you want to use some restriction, you can use <code>TryAddAsync(string groupName, int incluciveLimitCount, bool createIfEmpty)</code>.</p>
<p><code>IGroup</code> can pass to StreamingHub.<code>Broadcast</code>, <code>BroadcastExceptSelf</code>, <code>BroadcastExcept</code> and calls client proxy.</p>
<div><pre><span>public</span> <span>class</span> <span>ChatHub</span> : <span>StreamingHubBase</span>&lt;<span>IChatHub</span>, <span>IMessageReceiver</span>&gt;, <span>IChatHub</span>
{
    <span>string</span> <span>userName</span>;
    <span>IGroup</span> <span>room</span>;

    <span>public</span> <span>async</span> <span>Task</span> <span>JoinAsync</span>(<span>string</span> <span>userName</span>, <span>string</span> <span>roomName</span>)
    {
        <span>this</span>.<span>userName</span> <span>=</span> <span>userName</span>;
        <span>this</span>.<span>room</span> <span>=</span> <span>await</span> <span>Group</span>.<span>AddAsync</span>(<span>roomName</span>);
    }

    <span>public</span> <span>async</span> <span>Task</span> <span>SendMessageAsync</span>(<span>string</span> <span>message</span>)
    {
        <span>Broadcast</span>(<span>room</span>).<span>OnReceiveMessage</span>(<span>userName</span>, <span>message</span>);
    }
}</pre></div>
<blockquote>
<p>GroupRepository is created per StreamingHub type</p>
</blockquote>
<blockquote>
<p>If you want to create ServerSide loop and broadcast out of StreamingHub, you can pass Broadcast(room) result but it is unnatural, I'll add support kit of create server-side loop</p>
</blockquote>
<p>Group has in-memory storage, it can store extra data to group member. It can set <code>Group.AddAsync(string groupName, TStorage data)</code> instead of standard AddAsync.</p>
<p>Data is can get from <code>group.GetInMemoryStorage&lt;T&gt;</code> and can invoke <code>AllValues</code>, <code>Set(Guid connectionId, T Value)</code>, <code>Get(Guid connectionId)</code>.</p>
<blockquote>
<p>StreamingHub's ConnectionId is ServiceContext.ContextId</p>
</blockquote>
<p>Default MagicOnion's group is inmemory and using <code>ImmutableArrayGroup</code>. This group implementation is tuned for small room, not enter/leave frequently. If large room and enter/leave frequently design, you can use <code>ConcurrentDictionaryGroup</code>. It can configure by <code>GroupConfigurationAttribute</code> or <code>MagicOnionOptions.DefaultGroupRepositoryFactory</code>.</p>
<div><pre><span><span>//</span> use ***GroupRepositoryFactory type.</span>
[<span>GroupConfiguration</span>(<span>typeof</span>(<span>ConcurrentDictionaryGroupRepositoryFactory</span>))]
<span>public</span> <span>class</span> <span>ChatHub</span> : <span>StreamingHubBase</span>&lt;<span>IChatHub</span>, <span>IMessageReceiver</span>&gt;, <span>IChatHub</span>
{
    <span><span>//</span> ...</span>
}</pre></div>
<p>MagicOnion has distribute system called redis-backplane for group broadcast.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/46207/50974777-5f6aed00-152f-11e9-97f3-ba2a0c97f0eb.png"><img src="https://user-images.githubusercontent.com/46207/50974777-5f6aed00-152f-11e9-97f3-ba2a0c97f0eb.png" alt="image"></a></p>
<ul>
<li>Install-Package MagicOnion.Redis</li>
</ul>
<div><pre><span><span>//</span> set RedisGroupRepositoryFactory</span>
[<span>GroupConfiguration</span>(<span>typeof</span>(<span>RedisGroupRepositoryFactory</span>))]
<span>public</span> class ...
{
}

<span><span>//</span> configure ConnectionMultiplexer(StackExchange.Redis) to MagicOnionOption.ServiceLocator</span>
<span>var</span> <span>option</span> <span>=</span> <span>new</span> <span>MagicOnionOption</span>();
<span>option</span>.<span>ServiceLocator</span>.<span>Register</span>(<span>new</span> <span>ConnectionMultiplexer</span>(...));</pre></div>
<h3>Project Structure</h3>
<p>If creates Server-Client project, I recommend make three projects. <code>Server</code>, <code>ServerDefinition</code>, <code>Client</code>.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://cloud.githubusercontent.com/assets/46207/21081857/e0f6dfce-c012-11e6-850d-358c5b928a82.png"><img src="https://cloud.githubusercontent.com/assets/46207/21081857/e0f6dfce-c012-11e6-850d-358c5b928a82.png" alt="image"></a></p>
<p>ServerDefinition is only defined interface(<code>IService&lt;&gt;</code>, <code>IStreamingHub&lt;,&gt;</code>)(and some share request/response types).</p>
<p>If debugging, I recommend use <a href="https://marketplace.visualstudio.com/items?itemName=vs-publisher-141975.SwitchStartupProjectforVS2017" rel="nofollow">SwitchStartupProject</a> exteinson of VisualStudio and launch both Server and Client.</p>
<div><pre><span><span>"</span>MultiProjectConfigurations<span>"</span></span>: {
    <span><span>"</span>Server + Client<span>"</span></span>: {
        <span><span>"</span>Projects<span>"</span></span>: {
            <span><span>"</span>FooService<span>"</span></span>: {},
            <span><span>"</span>FooClient<span>"</span></span>: {}
        }
    }
}</pre></div>
<p>It can step-in/out seamlessly in server and client.</p>
<p>for Unity, you can't share by DLL(because can't share <code>IServer&lt;&gt;</code> because it is different reference both Unity and Server). It is slightly complex so we provides sample project and explanation.</p>
<p>see: <a href="https://github.com/Cysharp/MagicOnion/tree/master/samples">samples</a> page and ReadMe.</p>
<h3>Dependency Injection</h3>
<p>You can use DI(constructor injection) by GenericHost.</p>
<div><pre><span>static</span> <span>async</span> <span>Task</span> <span>Main</span>(<span>string</span>[] <span>args</span>)
{
    <span>await</span> <span>MagicOnionHost</span>.<span>CreateDefaultBuilder</span>()
        .<span>ConfigureServices</span>((<span>hostContext</span>, <span>services</span>) <span>=&gt;</span>
        {
            <span><span>//</span> DI, you can register types on this section.</span>

            <span><span>//</span> mapping config json to IOption&lt;MyConfig&gt;</span>
            <span><span>//</span> requires "Microsoft.Extensions.Options.ConfigurationExtensions" package</span>
            <span>services</span>.<span>Configure</span>&lt;<span>MyConfig</span>&gt;(<span>hostContext</span>.<span>Configuration</span>);
        })
        .<span>RunConsoleAsync</span>();
}

<span>public</span> <span>class</span> <span>MyFirstService</span> : <span>ServiceBase</span>&lt;<span>IMyFirstService</span>&gt;, <span>IMyFirstService</span>
{
    <span>IOptions</span>&lt;<span>MyConfig</span>&gt; <span>config</span>;
    <span>ILogger</span>&lt;<span>MyFirstService</span>&gt; <span>logger</span>;

    <span>public</span> <span>MyFirstService</span>(<span>IOptions</span>&lt;<span>MyConfig</span>&gt; <span>config</span>, <span>ILogger</span>&lt;<span>MyFirstService</span>&gt; <span>logger</span>)
    {
        <span>this</span>.<span>config</span> <span>=</span> <span>config</span>;
        <span>this</span>.<span>logger</span> <span>=</span> <span>logger</span>;
    }

    <span><span>//</span> ...</span>
}</pre></div>
<h2>Server and Clients</h2>
<h3>Unity client Supports</h3>
<p>You can download <code>MagicOnion.Client.Unity.package</code> and <code>moc.zip</code>(MagicOnionCompiler) in the <a href="https://github.com/cysharp/MagicOnion/releases">releases page</a>. But MagicOnion has no dependency so download gRPC lib from <a href="https://packages.grpc.io/" rel="nofollow">gRPC daily builds</a>, click Build ID and download <code>grpc_unity_package.*.*.*-dev.zip</code>. One more, requires MessagePack for C# for serialization, you can download <code>MessagePack.Unity.*.*.*.unitypackage</code> from <a href="https://github.com/neuecc/MessagePack-CSharp/releases">MessagePack-CSharp/releases</a>.</p>
<p>MagicOnion only supports <code>.NET 4.x</code> runtime and recommend to supports C# 7.0(Unity 2018.3) version.</p>
<p>Default MagicOnion's Unity client works well on Unity Editor or not IL2CPP env. But for IL2CPP environment, you need client code generation. <code>moc</code> is cross-platform standalone application but it requires <a href="https://dotnet.microsoft.com/download" rel="nofollow">.NET Core 3.1 Runtime</a>.</p>
<pre><code>argument list:
-i, -input: Input path of analyze csproj or directory.
-o, -output: Output path(file) or directory base(in separated mode).
-u, -unuseUnityAttr: [default=False]Unuse UnityEngine's RuntimeInitializeOnLoadMethodAttribute on MagicOnionInitializer.
-n, -namespace: [default=MagicOnion]Set namespace root name.
-c, -conditionalSymbol: [default=null]Conditional compiler symbols, split with ','.
</code></pre>
<p>You also need MessagePack-CSharp code generation, please see <a href="https://github.com/neuecc/MessagePack-CSharp#aot-code-generation-to-support-unityxamarin">MessagePack-CSharp AOT Code Generation (to support Unity/Xamarin)
</a> section.</p>
<p>Other than download moc.zip, you can install <code>MagicOnion.Generator</code> as .NET Core Tools or use <code>MagicOnion.MSBuild.Tasks</code> to prebuild hook.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools" rel="nofollow">.NET Core Global Tools</a> is easiest way to use moc directly.</p>
<pre><code>dotnet tool install --global MagicOnion.Generator
</code></pre>
<pre><code>dotnet moc -h
</code></pre>
<p><code>MagicOnion.MSBuild.Tasks</code> is easy way of generate code that target to shared project. We're mostly recommended to use this way. For example, PostCompile sample.</p>
<div><pre><span>&lt;</span><span>!</span><span>--</span> <span>in</span> <span>Shared</span>.<span>csproj</span> <span>--</span><span>&gt;</span>

<span>&lt;</span><span>ItemGroup</span><span>&gt;</span>
    <span>&lt;</span><span>!</span><span>--</span> <span>Install</span> <span>MSBuild</span> <span>Task</span>(<span>with</span> <span>PrivateAssets</span><span>=</span><span><span>"</span>All<span>"</span></span>, <span>it</span> <span>means</span> <span>to</span> <span>use</span> <span>dependency</span> <span>only</span> <span>in</span> <span>build</span> <span>time</span>). --&gt;
    &lt;PackageReference Include="MessagePack.MSBuild.Tasks" Version="*" PrivateAssets="All" /&gt;
    &lt;PackageReference Include="MagicOnion.MSBuild.Tasks" Version="*" PrivateAssets="All" /&gt;
&lt;/ItemGroup&gt;

&lt;!-- Call code generator after compile successfully. --&gt;
&lt;Target Name="GenerateMessagePack" AfterTargets="Compile"&gt;
    &lt;MessagePackGenerator Input="$(ProjectPath)" Output="..\UnityClient\Assets\Scripts\Generated\MessagePack.Generated.cs" /&gt;
&lt;/Target&gt;
&lt;Target Name="GenerateMagicOnion" AfterTargets="Compile"&gt;
    &lt;MagicOnionGenerator Input="$(ProjectPath)" Output="..\UnityClient\Assets\Scripts\Generated\MagicOnion.Generated.cs" /&gt;
&lt;/Target&gt;</pre></div>
<p>Full options are below.</p>
<div><pre>&lt;<span>MagicOnionGenerator</span>
    <span>Input</span>=<span><span>"</span>string:required<span>"</span></span>
    <span>Output</span>=<span><span>"</span>string:required<span>"</span></span>
    <span>ConditionalSymbol</span>=<span><span>"</span>string:optional<span>"</span></span>
    <span>ResolverName</span>=<span><span>"</span>string:optional<span>"</span></span>
    <span>Namespace</span>=<span><span>"</span>string:optional<span>"</span></span>
    <span>UnuseUnityAttr</span>=<span><span>"</span>bool:optional<span>"</span></span>
/&gt;</pre></div>
<p>Project structure and code generation sample, see <a href="https://github.com/Cysharp/MagicOnion/tree/master/samples">samples</a> page and ReadMe.</p>
<h3>iOS build with grpc</h3>
<p>Grpc iOS build require two additional operation on build.</p>
<ol>
<li>Disable Bitcode</li>
<li>Add libz.tbd</li>
</ol>
<p>We introduce OnPostProcessingBuild sample <a href="https://github.com/Cysharp/MagicOnion/blob/master/samples/ChatApp/ChatApp.Unity/Assets/Editor/BuildeIos.cs">BuildIos.cs</a> for ChatApp.Unity to automate these steps.</p>
<div><pre>#<span>if</span> <span>UNITY_IPHONE</span>
<span>using</span> <span>System</span>.<span>IO</span>;
<span>using</span> <span>UnityEngine</span>;
<span>using</span> <span>UnityEditor</span>;
<span>using</span> <span>UnityEditor</span>.<span>Callbacks</span>;
<span>using</span> <span>UnityEditor</span>.<span>iOS</span>.<span>Xcode</span>;

<span>public</span> <span>class</span> <span>BuildIos</span>
{
    <span><span>///</span> &lt;<span><span>summary</span></span>&gt;</span>
    <span><span>///</span> Handle libgrpc project settings.</span>
    <span><span>///</span> &lt;/<span><span>summary</span></span>&gt;</span>
    <span><span>///</span> &lt;<span><span>param</span></span> <span><span>name</span></span>=<span><span>"</span>target<span>"</span></span>&gt;&lt;/<span><span>param</span></span>&gt;</span>
    <span><span>///</span> &lt;<span><span>param</span></span> <span><span>name</span></span>=<span><span>"</span>path<span>"</span></span>&gt;&lt;/<span><span>param</span></span>&gt;</span>
    [<span>PostProcessBuild</span>(<span>1</span>)]
    <span>public</span> <span>static</span> <span>void</span> <span>OnPostProcessBuild</span>(<span>BuildTarget</span> <span>target</span>, <span>string</span> <span>path</span>)
    {
        <span>var</span> <span>projectPath</span> <span>=</span> <span>PBXProject</span>.<span>GetPBXProjectPath</span>(<span>path</span>);
        <span>var</span> <span>project</span> <span>=</span> <span>new</span> <span>PBXProject</span>();
        <span>project</span>.<span>ReadFromString</span>(<span>File</span>.<span>ReadAllText</span>(<span>projectPath</span>));
        <span>var</span> <span>targetGuid</span> <span>=</span> <span>project</span>.<span>TargetGuidByName</span>(<span>PBXProject</span>.<span>GetUnityTargetName</span>());

        <span><span>//</span> libz.tbd for grpc ios build</span>
        <span>project</span>.<span>AddFrameworkToProject</span>(<span>targetGuid</span>, <span><span>"</span>libz.tbd<span>"</span></span>, <span>false</span>);

        <span><span>//</span> libgrpc_csharp_ext missing bitcode. as BITCODE exand binary size to 250MB.</span>
        <span>project</span>.<span>SetBuildProperty</span>(<span>targetGuid</span>, <span><span>"</span>ENABLE_BITCODE<span>"</span></span>, <span><span>"</span>NO<span>"</span></span>);
        
        <span>File</span>.<span>WriteAllText</span>(<span>projectPath</span>, <span>project</span>.<span>WriteToString</span>());
    }
}
#<span>endif</span></pre></div>
<h3>Stripping debug symbols from ios/libgrpc.a</h3>
<p>When you download grpc daily build and extract Native Libararies for Unity, you will find file size of Plugins/Grpc.Core/runtime/ios/libgrpc.a beyonds 100MB. GitHub will reject commit when file size is over 100MB, therefore libgrpc.a often become unwelcome for gif-low.
The reason of libgrpc.a file size is because it includes debug symbols for 3 architectures, arm64, armv7 and x86_64.</p>
<p>We introduce strip debug symbols and generate reduced size <code>libgrpc_stripped.a</code>, it's about 17MB.
This may useful for whom want commit <code>libgrpc.a</code> to GitHub, and understanding stripped library missing debug symbols.</p>
<p><strong>How to strip</strong></p>
<p>Download gRPC lib <code>grpc_unity_package.*.*.*-dev.zip</code> from <a href="https://packages.grpc.io/" rel="nofollow">gRPC daily builds</a> and extract it, copy Plugins folder to Unity's Assets path.</p>
<p>Open terminal on <code>Plugins/Grpc.Core/runtimes/ios/</code> and execute following will generate <code>libgrpc_stripped.a</code> and replace original libgrpc.a with stripped version.</p>
<div><pre>$ <span>cd</span> <span>${UNITY_PATH}</span>/Plugins/Grpc.Core/runtimes/ios
$ strip -S -x libgrpc.a -o libgrpc_stripped.a
$ rm libgrpc.a <span>&amp;&amp;</span> mv libgrpc_stripped.a libgrpc.a</pre></div>
<p>Make sure you can build app with iOS and works fine.</p>
<h3>Server host</h3>
<p>I've recommend to use <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.2" rel="nofollow">.NET Generic Host</a> to host .NET Core app. <code>MagicOnion.Hosting</code> package helps to build to use MagicOnion.</p>
<ul>
<li>Install-Package MagicOnion.Hosting</li>
</ul>
<div><pre><span><span>//</span> using MagicOnion.Hosting</span>
<span>static</span> <span>async</span> <span>Task</span> <span>Main</span>(<span>string</span>[] <span>args</span>)
{
    <span><span>//</span> you can use new HostBuilder() instead of CreateDefaultBuilder</span>
    <span>await</span> <span>new</span> <span>HostBuilder</span>()
        .<span>UseMagicOnion</span>()
        .<span>RunConsoleAsync</span>();
}</pre></div>
<p>If you can want to load configuration, set logging, etc, see .NET Generic Host documantation.</p>
<p>CreateDefaultBuilder's setup details is same as <a href="https://github.com/Cysharp/MicroBatchFramework">MicroBatchFramework</a>, it is similar as <code>WebHost.CreateDefaultBuilder</code> on ASP.NET Core. for the details, see <a href="https://github.com/Cysharp/MicroBatchFramework#configure-configuration">MicroBatchFramework#configure-configuration</a></p>
<h3>Server host options</h3>
<p>Configure MagicOnion hosting using <code>Microsoft.Extensions.Options</code> that align to .NET Core way. In many real use cases, Using setting files (ex. appsettings.json), environment variables, etc ... to configure an application.</p>
<p>For example, We have Production and Development configurations and have some differences about listening ports, certificates and others.</p>
<p>This example makes hosting MagicOnion easier and configurations moved to external files, environment variables. appsettings.json looks like below.</p>
<div><pre>{
  <span><span>"</span>MagicOnion<span>"</span></span>: {
    <span><span>"</span>Service<span>"</span></span>: {
      <span><span>"</span>IsReturnExceptionStackTraceInErrorDetail<span>"</span></span>: <span>false</span>
    },
    <span><span>"</span>ChannelOptions<span>"</span></span>: {
      <span><span>"</span>grpc.primary_user_agent<span>"</span></span>: <span><span>"</span>MagicOnion/1.0 (Development)<span>"</span></span>,
      <span><span>"</span>grpc.max_receive_message_length<span>"</span></span>: <span>4194304</span>
    },
    <span><span>"</span>ServerPorts<span>"</span></span>: [
      {
        <span><span>"</span>Host<span>"</span></span>: <span><span>"</span>localhost<span>"</span></span>,
        <span><span>"</span>Port<span>"</span></span>: <span>12345</span>,
        <span><span>"</span>UseInsecureConnection<span>"</span></span>: <span>false</span>,
        <span><span>"</span>ServerCredentials<span>"</span></span>: [
          {
            <span><span>"</span>CertificatePath<span>"</span></span>: <span><span>"</span>./server.crt<span>"</span></span>,
            <span><span>"</span>KeyPath<span>"</span></span>: <span><span>"</span>./server.key<span>"</span></span>
          }
        ]
      }
    ]
  }}</pre></div>
<p>An application setting files is not required by default. You can simply call UseMagicOnion() then it starts service on localhost:12345 (Insecure connection).</p>
<div><pre><span>class</span> <span>Program</span>
{
   <span>static</span> <span>async</span> <span>Task</span> <span>Main</span>(<span>string</span>[] <span>args</span>)
   {
       <span>await</span> <span>MagicOnionHost</span>.<span>CreateDefaultBuilder</span>()
           .<span>UseMagicOnion</span>()
           .<span>RunConsoleAsync</span>();
   }
}</pre></div>
<p>Of course, you can also flexibly configure hosting by code. During configuration, you can access <code>IHostingEnvironment</code> / <code>IConfiguration</code> instances and configure
<code>MagicOnionOptions</code>.</p>
<div><pre><span>class</span> <span>Program</span>
{
    <span>static</span> <span>async</span> <span>Task</span> <span>Main</span>(<span>string</span>[] <span>args</span>)
    {
        <span>await</span> <span>MagicOnionHost</span>.<span>CreateDefaultBuilder</span>()
            .<span>UseMagicOnion</span>()
            .<span>ConfigureServices</span>((<span>hostContext</span>, <span>services</span>) <span>=&gt;</span>
            {
                <span>services</span>.<span>Configure</span>&lt;<span>MagicOnionHostingOptions</span>&gt;(<span>options</span> <span>=&gt;</span>
                {
                    <span>if</span> (<span>hostContext</span>.<span>HostingEnvironment</span>.<span>IsDevelopment</span>())
                    {
                        <span>options</span>.<span>Service</span>.<span>GlobalFilters</span> <span>=</span> <span>new</span>[] { <span>new</span> <span>MyFilterAttribute</span>(<span>null</span>) };
                    }
                    <span>options</span>.<span>ChannelOptions</span>.<span>MaxReceiveMessageLength</span> <span>=</span> <span>1024</span> <span>*</span> <span>1024</span> <span>*</span> <span>10</span>;
                });
            })
            .<span>RunConsoleAsync</span>();
    }
}</pre></div>
<p>This configuration method supports multiple MagicOnion hosting scenarios.</p>
<div><pre>{
  <span><span>"</span>MagicOnion<span>"</span></span>: {
    <span><span>"</span>ServerPorts<span>"</span></span>: [
      {
        <span><span>"</span>Host<span>"</span></span>: <span><span>"</span>localhost<span>"</span></span>,
        <span><span>"</span>Port<span>"</span></span>: <span>12345</span>,
        <span><span>"</span>UseInsecureConnection<span>"</span></span>: <span>true</span>
      }
    ]
  },
  <span><span>"</span>MagicOnion-Management<span>"</span></span>: {
    <span><span>"</span>ServerPorts<span>"</span></span>: [
      {
        <span><span>"</span>Host<span>"</span></span>: <span><span>"</span>localhost<span>"</span></span>,
        <span><span>"</span>Port<span>"</span></span>: <span>23456</span>,
        <span><span>"</span>UseInsecureConnection<span>"</span></span>: <span>true</span>
      }
    ]
  }
}</pre></div>
<div><pre><span>class</span> <span>Program</span>
{
    <span>static</span> <span>async</span> <span>Task</span> <span>Main</span>(<span>string</span>[] <span>args</span>)
    {
        <span>await</span> <span>MagicOnionHost</span>.<span>CreateDefaultBuilder</span>()
            .<span>UseMagicOnion</span>(<span>types</span>: <span>new</span>[] { <span>typeof</span>(<span>MyService</span>) })
            .<span>UseMagicOnion</span>(<span>configurationName</span>: <span><span>"</span>MagicOnion-Management<span>"</span></span>, <span>types</span>: <span>new</span>[] { <span>typeof</span>(<span>ManagementService</span>) })
            .<span>ConfigureServices</span>((<span>hostContext</span>, <span>services</span>) <span>=&gt;</span>
            {
                <span>services</span>.<span>Configure</span>&lt;<span>MagicOnionHostingOptions</span>&gt;(<span>options</span> <span>=&gt;</span>
                {
                    <span>options</span>.<span>ChannelOptions</span>.<span>MaxReceiveMessageLength</span> <span>=</span> <span>1024</span> <span>*</span> <span>1024</span> <span>*</span> <span>10</span>;
                });
                <span>services</span>.<span>Configure</span>&lt;<span>MagicOnionHostingOptions</span>&gt;(<span><span>"</span>MagicOnion-Management<span>"</span></span>, <span>options</span> <span>=&gt;</span>
                {
                    <span>if</span> (<span>hostContext</span>.<span>HostingEnvironment</span>.<span>IsDevelopment</span>())
                    {
                        <span>options</span>.<span>Service</span>.<span>GlobalFilters</span> <span>=</span> <span>new</span>[] { <span>new</span> <span>MyFilterAttribute</span>(<span>null</span>) };
                    }
                });
            })
            .<span>RunConsoleAsync</span>();
    }
}</pre></div>
<h3>gRPC Keepalive</h3>
<p>When you want detect network termination on Client or vice-versa, you can configure gRPC Keepalive.
It's nothing special, just follow to the <a href="https://github.com/grpc/grpc/blob/master/doc/keepalive.md">Keepalive UserGuide for gRPC Core</a> but let's see how in actual.</p>
<p>MagicOnion offers two ways to configure gRPC Core Keepalive, <code>ChannelOption</code> and <code>MagicOnionOption</code>.</p>
<p><strong>ChannelOption</strong></p>
<p>ChannelOptions is primitive way to configure options.
Below uses <code>ChannelOption</code> and offer keepalive for every 10 second even RPC is not called.</p>
<div><pre><span><span>//</span> If you want configure KEEP_ALIVE interval, then....</span>
<span><span>//</span> * set same value for `grpc.keepalive_time_ms` and `grpc.http2.min_time_between_pings_ms`</span>
<span><span>//</span> * keep `grpc.http2.min_ping_interval_without_data_ms &lt; grpc.http2.min_time_between_pings_ms`</span>
<span>var</span> <span>options</span> <span>=</span> <span>new</span>[]
{
    <span><span>//</span> send keepalive ping every 10 second, default is 2 hours</span>
    <span>new</span> <span>ChannelOption</span>(<span><span>"</span>grpc.keepalive_time_ms<span>"</span></span>, <span>10000</span>),
    <span><span>//</span> keepalive ping time out after 5 seconds, default is 20 seoncds</span>
    <span>new</span> <span>ChannelOption</span>(<span><span>"</span>grpc.keepalive_timeout_ms<span>"</span></span>, <span>5000</span>),
    <span><span>//</span> allow grpc pings from client every 10 seconds</span>
    <span>new</span> <span>ChannelOption</span>(<span><span>"</span>grpc.http2.min_time_between_pings_ms<span>"</span></span>, <span>10000</span>),
    <span><span>//</span> allow unlimited amount of keepalive pings without data</span>
    <span>new</span> <span>ChannelOption</span>(<span><span>"</span>grpc.http2.max_pings_without_data<span>"</span></span>, <span>0</span>),
    <span><span>//</span> allow keepalive pings when there's no gRPC calls</span>
    <span>new</span> <span>ChannelOption</span>(<span><span>"</span>grpc.keepalive_permit_without_calls<span>"</span></span>, <span>1</span>),
    <span><span>//</span> allow grpc pings from client without data every 5 seconds</span>
    <span>new</span> <span>ChannelOption</span>(<span><span>"</span>grpc.http2.min_ping_interval_without_data_ms<span>"</span></span>, <span>5000</span>),
};</pre></div>
<p>Pass this options to Channel on Client, or to <code>IHostBuilder.UseMagicOnion</code> on Server will configure Keepalive.</p>
<div><pre><span><span>//</span> Client</span>
<span>this</span>.<span>channel</span> <span>=</span> <span>new</span> <span>Channel</span>(<span><span>"</span>localhost<span>"</span></span>, <span>12345</span>, <span>ChannelCredentials</span>.<span>Insecure</span>, <span>options</span>);</pre></div>
<div><pre><span><span>//</span> Server (Program.cs)</span>
<span>await</span> <span>MagicOnionHost</span>.<span>CreateDefaultBuilder</span>()
    .<span>UseMagicOnion</span>(<span>new</span> <span>MagicOnionOptions</span>(<span>isReturnExceptionStackTraceInErrorDetail</span>: <span>true</span>), <span>new</span> <span>ServerPort</span>(<span><span>"</span>0.0.0.0<span>"</span></span>, <span>12345</span>, <span>ServerCredentials</span>.<span>Insecure</span>), <span>grpcOptions</span>)
    .<span>RunConsoleAsync</span>();</pre></div>
<p><strong>MagicOnionOption</strong></p>
<p>Here's another option <code>MagicOnionOption</code>. With MagicOnionOption, you can use appsettings.json to configure grpc parameters for Serverside MagicOnion!
Let's translate same grpc options in json.</p>
<div><pre>{
    <span><span>"</span>MagicOnion<span>"</span></span>: {
        <span><span>"</span>ServerPorts<span>"</span></span>: [
            {
                <span><span>"</span>Host<span>"</span></span>: <span><span>"</span>0.0.0.0<span>"</span></span>,
                <span><span>"</span>Port<span>"</span></span>: <span>12345</span>,
                <span><span>"</span>UseInsecureConnection<span>"</span></span>: <span>true</span>
            }
        ],
        <span><span>"</span>ChannelOptions<span>"</span></span>: {
            <span><span>"</span>grpc.keepalive_time_ms<span>"</span></span>: <span><span>"</span>10000<span>"</span></span>,
            <span><span>"</span>grpc.keepalive_timeout_ms<span>"</span></span>: <span><span>"</span>5000<span>"</span></span>,
            <span><span>"</span>grpc.http2.min_time_between_pings_ms<span>"</span></span>: <span><span>"</span>10000<span>"</span></span>,
            <span><span>"</span>grpc.http2.max_pings_without_data<span>"</span></span>: <span><span>"</span>0<span>"</span></span>,
            <span><span>"</span>grpc.keepalive_permit_without_calls<span>"</span></span>: <span><span>"</span>1<span>"</span></span>,
            <span><span>"</span>grpc.http2.min_ping_interval_without_data_ms<span>"</span></span>: <span><span>"</span>5000<span>"</span></span>
        }
    }
}</pre></div>
<p>All you need to do on Program.cs is just call <code>.UseMagicOnion</code>.</p>
<div><pre><span>await</span> <span>MagicOnionHost</span>.<span>CreateDefaultBuilder</span>()
    .<span>UseMagicOnion</span>()
    .<span>RunConsoleAsync</span>();</pre></div>
<p>Now you can detect client network disconnection on serverside, let's override <code>OnDisconnected</code> and set debugger, disconnect Client network and wait for interval sec!</p>
<h2>Deployment</h2>
<h3>Host in Docker</h3>
<p>If you hosting the samples on a server, recommend to use container. Add Dockerfile like below.</p>
<div><pre><span>FROM</span> mcr.microsoft.com/dotnet/core/sdk:2.2 AS sdk
<span>COPY</span> . ./workspace

<span>RUN</span> dotnet publish ./workspace/samples/ChatApp/ChatApp.Server/ChatApp.Server.csproj -c Release -o /app

<span>FROM</span> mcr.microsoft.com/dotnet/core/runtime:2.2
<span>COPY</span> --from=sdk /app .
<span>ENTRYPOINT</span> [<span>"dotnet"</span>, <span>"ChatApp.Server.dll"</span>]

<span><span>#</span> Expose ports.</span>
<span>EXPOSE</span> 12345</pre></div>
<p>And docker build, send to any container registory.</p>
<p>Here is the sample of deploy AWS <a href="https://us-east-2.console.aws.amazon.com/ecr/" rel="nofollow">ECR</a> and <a href="https://us-east-2.console.aws.amazon.com/ecs" rel="nofollow">ECS</a> by CircleCI.</p>
<div><pre><span>version</span>: <span>2.1</span>
<span>orbs</span>:
<span><span>#</span> see: https://circleci.com/orbs/registry/orb/circleci/aws-ecr</span>
<span><span>#</span> use Environment Variables : AWS_ECR_ACCOUNT_URL</span>
<span><span>#</span>                             AWS_ACCESS_KEY_ID	</span>
<span><span>#</span>                             AWS_SECRET_ACCESS_KEY</span>
<span><span>#</span>                             AWS_REGION  </span>
  <span>aws-ecr</span>: <span>circleci/aws-ecr@4.0.1</span>
<span><span>#</span> see: https://circleci.com/orbs/registry/orb/circleci/aws-ecs</span>
<span><span>#</span> use Environment Variables : AWS_ACCESS_KEY_ID	</span>
<span><span>#</span>                             AWS_SECRET_ACCESS_KEY</span>
<span><span>#</span>                             AWS_REGION</span>
  <span>aws-ecs</span>: <span>circleci/aws-ecs@0.0.7</span>
<span>workflows</span>:
  <span>build-push</span>:
    <span>jobs</span>:
      - <span>aws-ecr/build_and_push_image</span>:
          <span>repo</span>: <span>sample-magiconion</span>
      - <span>aws-ecs/deploy-service-update</span>:
          <span>requires</span>:
            - <span>aws-ecr/build_and_push_image</span>
          <span>family</span>: <span><span>'</span>sample-magiconion-service<span>'</span></span>
          <span>cluster-name</span>: <span><span>'</span>sample-magiconion-cluster<span>'</span></span>
          <span>container-image-name-updates</span>: <span><span>'</span>container=sample-magiconion-service,tag=latest<span>'</span></span>
          </pre></div>
<p>Here is the sample of deploy <a href="https://console.cloud.google.com/" rel="nofollow">Google Cloud Platform(GCP)</a> by CircleCI.</p>
<div><pre><span>version</span>: <span>2.1</span>
<span>orbs</span>:
  <span><span>#</span> see: https://circleci.com/orbs/registry/orb/circleci/gcp-gcr</span>
  <span><span>#</span> use Environment Variables : GCLOUD_SERVICE_KEY</span>
  <span><span>#</span>                             GOOGLE_PROJECT_ID</span>
  <span><span>#</span>                             GOOGLE_COMPUTE_ZONE</span>
    <span>gcp-gcr</span>: <span>circleci/gcp-gcr@0.6.0</span>
<span>workflows</span>:
    <span>build_and_push_image</span>:
        <span>jobs</span>:
            - <span>gcp-gcr/build-and-push-image</span>:
                <span>image</span>: <span>sample-magiconion</span>
                <span>registry-url</span>: <span>asia.gcr.io </span><span><span>#</span> other: gcr.io, eu.gcr.io, us.gcr.io</span></pre></div>
<p>Depending on the registration information of each environment and platform, fine tuning may be necessary, so please refer to the platform documentation and customize your own.</p>
<h3>SSL/TLS</h3>
<p>As <a href="https://grpc.io/docs/guides/auth/" rel="nofollow">official gRPC doc</a> notes gRPC supports SSL/TLS, and MagicOnion also support SSL/TLS.</p>
<blockquote>
<p>gRPC has SSL/TLS integration and promotes the use of SSL/TLS to authenticate the server, and to encrypt all the data exchanged between the client and the server. Optional mechanisms are available for clients to provide certificates for mutual authentication</p>
</blockquote>
<p>I will explain how to setup "SSL/TLS MagicOnion on localhost" with following 4 steps.</p>
<ul>
<li><a href="#generate-certificate">generate certificate</a></li>
<li><a href="#simulate-dummy-domain-on-localhost">simulate dummy domain on localhost</a></li>
<li><a href="#server-configuration">server configuration</a></li>
<li><a href="#client-configuration">client configuration</a></li>
</ul>
<p>Let's use <a href="https://github.com/Cysharp/MagicOnion/tree/master/samples/ChatApp/ChatApp.Server">samples/ChatApp/ChatApp.Server</a> for server project, and <a href="https://github.com/Cysharp/MagicOnion/tree/master/samples/ChatApp/ChatApp.Unity">samples/ChatApp/ChatApp.Unity</a> for client project.</p>
<h4>generate certificate</h4>
<p>Certificates are required to establish SSL/TLS with Server/Client channel connection.
Let's use <a href="https://github.com/openssl/openssl">OpenSSL</a> to create required certificates.</p>
<p>Following command will create 3 files <code>server.csr</code>, <code>server.key</code> and <code>server.crt</code>.
gRPC/MagicOnion Server requires server.crt and server.key, and Client require server.crt.</p>
<div><pre><span><span>#</span> move to your server project</span>
$ <span>cd</span> MagicOnion/samples/ChatApp/ChatApp.Server

<span><span>#</span> generate certificates</span>
<span><span>#</span> NOTE: CN=xxxx should match domain name to magic onion server pointing domain name</span>
$ openssl genrsa 2048 <span>&gt;</span> server.key
$ openssl req -new -sha256 -key server.key -out server.csr -subj <span><span>"</span>/C=JP/ST=Tokyo/L=Tokyo/O=MagicOnion Demo/OU=Dev/CN=*.example.com<span>"</span></span>
$ openssl x509 -req -in server.csr -signkey server.key -out server.crt -days 7300 -extensions server

<span><span>#</span> server will use server.crt and server.key, leave generated certificates.</span>

<span><span>#</span> client will use server.crt, copy certificate to StreamingAssets folder.</span>
$ mkdir ../ChatApp.Unity/Assets/StreamingAssets
$ cp server.crt ../ChatApp.Unity/Assets/StreamingAssets/server.crt</pre></div>
<p>Please modify <code>/C=JP/ST=Tokyo/L=Tokyo/O=MagicOnion Demo/OU=Dev/CN=*.example.com</code> as you need.
Make sure <code>CN=xxxx</code> should match to domain that your MagicOnion Server will recieve request from your client.</p>
<blockquote>
<p>ATTENTION: Make sure <strong>server.key</strong> is very sensitive file, while <strong>server.crt</strong> can be public. DO NOT COPY server.key to your client.</p>
</blockquote>
<h4>simulate dummy domain on localhost</h4>
<p>Editting <code>hosts</code> file is the simple way to redirect dummy domain request to your localhost.</p>
<p>Let's set your CN to you hosts, example is <code>dummy.example.com</code>.
Open hosts file and add your entry.</p>
<div><pre><span><span>#</span> NOTE: edit hosts to test on localhost</span>
<span><span>#</span> Windows: (use scoop to install sudo, or open elevated cmd or notepad.)</span>
PS<span>&gt;</span> sudo notepad c:<span>\w</span>indows<span>\s</span>ystem32<span>\d</span>rivers<span>\e</span>tc<span>\h</span>osts
<span><span>#</span> macos:</span>
$ sudo vim /private/etc/hosts
<span><span>#</span> Linux:</span>
$ sudo vim /etc/hosts</pre></div>
<p>Entry format would be similar to this, please follow to your platform hosts rule.</p>
<div><pre>127.0.0.1	dummy.example.com</pre></div>
<p>After modifying hosts, <code>ping</code> to your dummy domain and confirm localhost is responding.</p>
<div><pre>$ ping dummy.example.com

pinging to dummy.example.com [127.0.0.1] 32 bytes data:
127.0.0.1 response: bytecount =32 <span>time</span> <span>&lt;</span>1ms TTL=128</pre></div>
<h4>server configuration</h4>
<blockquote>
<p>NOTE: Server will use <strong>server.crt</strong> and <strong>server.key</strong>, if you didn't copy OpenSSL generated <code>server.crt</code> and <code>server.key</code>, please back to <a href="#generate-certificate">generate certificate</a> section and copy them.</p>
</blockquote>
<p>Open <code>samples/ChatApp/ChatApp.Server/ChatApp.Server.csproj</code> and add folloging lines before <code>&lt;/Project&gt;</code>.</p>
<div><pre>  &lt;<span>ItemGroup</span>&gt;
    &lt;<span>Folder</span> <span>Include</span>=<span><span>"</span>LinkFromUnity\<span>"</span></span> /&gt;
  &lt;/<span>ItemGroup</span>&gt;

  <span><span>&lt;!--</span> FOR SSL/TLS SUPPORT <span>--&gt;</span></span>
  &lt;<span>ItemGroup</span>&gt;
    &lt;<span>None</span> <span>Update</span>=<span><span>"</span>server.crt<span>"</span></span>&gt;
      &lt;<span>CopyToOutputDirectory</span>&gt;PreserveNewest&lt;/<span>CopyToOutputDirectory</span>&gt;
    &lt;/<span>None</span>&gt;
    &lt;<span>None</span> <span>Update</span>=<span><span>"</span>server.key<span>"</span></span>&gt;
      &lt;<span>CopyToOutputDirectory</span>&gt;PreserveNewest&lt;/<span>CopyToOutputDirectory</span>&gt;
    &lt;/<span>None</span>&gt;
  &lt;/<span>ItemGroup</span>&gt;

&lt;/<span>Project</span>&gt;</pre></div>
<p>Open <code>samples/ChatApp/ChatApp.Server/Program.cs</code>, there are default Insecure channel definition with <code>ServerCredentials.Insecure</code>.
What you need is change this line to use <code>SslServerCredentials</code>.</p>
<div><pre><span>new</span> <span>ServerPort</span>(<span><span>"</span>localhost<span>"</span></span>, <span>12345</span>, <span>ServerCredentials</span>.<span>Insecure</span>))</pre></div>
<p>Add following lines before <code>await MagicOnionHost.CreateDefaultBuilder()</code></p>
<div><pre><span>var</span> <span>config</span> <span>=</span> <span>new</span> <span>ConfigurationBuilder</span>().<span>AddEnvironmentVariables</span>().<span>Build</span>();
<span>var</span> <span>certificates</span> <span>=</span> <span>new</span> <span>System</span>.<span>Collections</span>.<span>Generic</span>.<span>List</span>&lt;<span>KeyCertificatePair</span>&gt; { <span>new</span> <span>KeyCertificatePair</span>(<span>System</span>.<span>IO</span>.<span>File</span>.<span>ReadAllText</span>(<span><span>"</span>server.crt<span>"</span></span>), <span>System</span>.<span>IO</span>.<span>File</span>.<span>ReadAllText</span>(<span><span>"</span>server.key<span>"</span></span>)) };
<span>var</span> <span>credential</span> <span>=</span> <span>new</span> <span>SslServerCredentials</span>(<span>certificates</span>);</pre></div>
<p>You may required following using namespaces.</p>
<div><pre><span>using</span> <span>Microsoft</span>.<span>Extensions</span>.<span>Configuration</span>;
<span>using</span> <span>System</span>.<span>Collections</span>.<span>Generic</span>;
<span>using</span> <span>System</span>.<span>IO</span>;</pre></div>
<p>Replace existing <code>new ServerPort("localhost", 12345, ServerCredentials.Insecure))</code> line with following.</p>
<div><pre><span>new</span> <span>ServerPort</span>(<span>config</span>.<span>GetValue</span>&lt;<span>string</span>&gt;(<span><span>"</span>MAGICONION_HOST<span>"</span></span>, <span><span>"</span>127.0.0.1<span>"</span></span>), <span>12345</span>, <span>credential</span>))</pre></div>
<blockquote>
<p>NOTE: Replace <code>localhost</code> to <code>127.0.0.1</code> enforce IPv4 connection.</p>
</blockquote>
<p>Debug run server on Visual Studio, any IDE or docker.</p>
<div><pre>D0729 11:08:21.767387 Grpc.Core.Internal.NativeExtension gRPC native library loaded successfully.
Application started. Press Ctrl+C to shut down.
Hosting environment: Production</pre></div>
<h4>client configuration</h4>
<blockquote>
<p>NOTE: Client will use <strong>server.crt</strong>, if you didn't copy OpenSSL generated <code>server.crt</code> and <code>server.key</code>, please back to <a href="#generate-certificate">generate certificate</a> section and copy it.</p>
</blockquote>
<p>Open <code>samples/ChatApp/ChatApp.Unity/Assets/ChatComponent.cs</code>, channel creation is defined as <code>ChannelCredentials.Insecure</code> in <code>InitializeClient()</code>.
What you need tois change this line to use <code>SslCredentials</code>.</p>
<div><pre><span>this</span>.<span>channel</span> <span>=</span> <span>new</span> <span>Channel</span>(<span><span>"</span>localhost<span>"</span></span>, <span>12345</span>, <span>ChannelCredentials</span>.<span>Insecure</span>);</pre></div>
<p>Replace this line to following.</p>
<div><pre><span>var</span> <span>serverCred</span> <span>=</span> <span>new</span> <span>SslCredentials</span>(<span>File</span>.<span>ReadAllText</span>(<span>Path</span>.<span>Combine</span>(<span>Application</span>.<span>streamingAssetsPath</span>, <span><span>"</span>server.crt<span>"</span></span>)));
<span>this</span>.<span>channel</span> <span>=</span> <span>new</span> <span>Channel</span>(<span><span>"</span>dummy.example.com<span>"</span></span>, <span>12345</span>, <span>serverCred</span>);</pre></div>
<p>Play on Unity Editor and confirm Unity MagicOnion Client can connect to MagicOnion Server.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/3856350/62017554-1be97f00-b1f2-11e9-9769-70464fe6d425.png"><img src="https://user-images.githubusercontent.com/3856350/62017554-1be97f00-b1f2-11e9-9769-70464fe6d425.png" alt="image"></a></p>
<blockquote>
<p>NOTE: If there are any trouble establish SSL/TLS connection, Unity Client will show <code>disconnected server.</code> log.</p>
</blockquote>
<h2>Integrations</h2>
<h3>Swagger</h3>
<p>MagicOnion has built-in Http1 JSON Gateway and <a href="http://swagger.io/" rel="nofollow">Swagger</a> integration for Unary operation. It can execute and debug RPC-API easily.</p>
<ul>
<li>Install-Package MagicOnion.HttpGateway</li>
</ul>
<p>HttpGateway is built on ASP.NET Core. for example, with <code>Microsoft.AspNetCore.Server.WebListener</code>.</p>
<div><pre><span><span>//</span> using MagicOnion.Hosting;</span>
<span><span>//</span> using Microsoft.Extensions.DependencyInjection;</span>
<span><span>//</span> using Microsoft.Extensions.Hosting;</span>

<span>class</span> <span>Program</span>
{
    <span>static</span> <span>async</span> <span>Task</span> <span>Main</span>(<span>string</span>[] <span>args</span>)
    {
        <span><span>//</span> setup MagicOnion hosting.</span>
        <span>var</span> <span>magicOnionHost</span> <span>=</span> <span>MagicOnionHost</span>.<span>CreateDefaultBuilder</span>()
            .<span>UseMagicOnion</span>(
                <span>new</span> <span>MagicOnionOptions</span>(<span>isReturnExceptionStackTraceInErrorDetail</span>: <span>true</span>),
                <span>new</span> <span>ServerPort</span>(<span><span>"</span>localhost<span>"</span></span>, <span>12345</span>, <span>ServerCredentials</span>.<span>Insecure</span>))
            .<span>UseConsoleLifetime</span>()
            .<span>Build</span>();

        <span><span>//</span> NuGet: Microsoft.AspNetCore.Server.Kestrel</span>
        <span>var</span> <span>webHost</span> <span>=</span> <span>new</span> <span>WebHostBuilder</span>()
            .<span>ConfigureServices</span>(<span>collection</span> <span>=&gt;</span>
            {
                <span><span>//</span> Add MagicOnionServiceDefinition for reference from Startup.</span>
                <span>collection</span>.<span>AddSingleton</span>&lt;<span>MagicOnionServiceDefinition</span>&gt;(<span>magicOnionHost</span>.<span>Services</span>.<span>GetService</span>&lt;<span>MagicOnionHostedServiceDefinition</span>&gt;().<span>ServiceDefinition</span>);
            })
            .<span>UseKestrel</span>()
            .<span>UseStartup</span>&lt;<span>Startup</span>&gt;()
            .<span>UseUrls</span>(<span><span>"</span>http://localhost:5432<span>"</span></span>)
            .<span>Build</span>();

        <span><span>//</span> Run and wait both.</span>
        <span>await</span> <span>Task</span>.<span>WhenAll</span>(<span>webHost</span>.<span>RunAsync</span>(), <span>magicOnionHost</span>.<span>RunAsync</span>());
    }
}

<span><span>//</span> WebAPI Startup configuration.</span>
<span>public</span> <span>class</span> <span>Startup</span>
{
    <span><span>//</span> Inject MagicOnionServiceDefinition from DIl</span>
    <span>public</span> <span>void</span> <span>Configure</span>(<span>IApplicationBuilder</span> <span>app</span>, <span>MagicOnionServiceDefinition</span> <span>magicOnion</span>)
    {
        <span><span>//</span> Optional:Add Summary to Swagger</span>
        <span><span>//</span> var xmlName = "Sandbox.NetCoreServer.xml";</span>
        <span><span>//</span> var xmlPath = Path.Combine(Path.GetDirectoryName(Assembly.GetEntryAssembly().Location), xmlName);</span>

        <span><span>//</span> HttpGateway requires two middlewares.</span>
        <span><span>//</span> One is SwaggerView(MagicOnionSwaggerMiddleware)</span>
        <span><span>//</span> One is Http1-JSON to gRPC-MagicOnion gateway(MagicOnionHttpGateway)</span>
        <span>app</span>.<span>UseMagicOnionSwagger</span>(<span>magicOnion</span>.<span>MethodHandlers</span>, <span>new</span> <span>SwaggerOptions</span>(<span><span>"</span>MagicOnion.Server<span>"</span></span>, <span><span>"</span>Swagger Integration Test<span>"</span></span>, <span><span>"</span>/<span>"</span></span>)
        {
            <span><span>//</span> XmlDocumentPath = xmlPath</span>
        });
        <span>app</span>.<span>UseMagicOnionHttpGateway</span>(<span>magicOnion</span>.<span>MethodHandlers</span>, <span>new</span> <span>Channel</span>(<span><span>"</span>localhost:12345<span>"</span></span>, <span>ChannelCredentials</span>.<span>Insecure</span>));
    }
}</pre></div>
<p>Open <code>http://localhost:5432</code>, you can see swagger view.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://cloud.githubusercontent.com/assets/46207/21295663/6a9d3e28-c59d-11e6-8081-18d14e359567.png"><img src="https://cloud.githubusercontent.com/assets/46207/21295663/6a9d3e28-c59d-11e6-8081-18d14e359567.png" alt="image"></a></p>
<h3>Telemetry</h3>
<p>You can configure Telemetry for MagicOnion with <code>MagicOnion.OpenTelemetry</code> package.
Let's see overview and how to try on localhost.</p>
<ul>
<li>overview</li>
<li>examples of implementation</li>
<li>try visualization on localhost</li>
<li>metrics customization</li>
<li>implement your own metrics</li>
</ul>
<h4>overview</h4>
<p>MagicOnion.OpenTelemetry is implementation of <a href="https://github.com/open-telemetry/opentelemetry-dotnet">open-telemetry/opentelemetry-dotnet: OpenTelemetry .NET SDK</a>, so you can use any OpenTelemetry exporter, like <a href="https://prometheus.io/" rel="nofollow">Prometheus</a>, <a href="https://cloud.google.com/stackdriver/pricing" rel="nofollow">StackDriver</a>, <a href="https://zipkin.io/" rel="nofollow">Zipkin</a> and others.</p>
<p>You can collect telemetry and use exporter on MagicOnion Serverside.</p>
<h4>examples of implementation</h4>
<p>What you need to do for Telemetry is followings.</p>
<ul>
<li>add reference to the MagicOnion.OpenTelemetry.</li>
<li>configuration for OpenTelemery.</li>
<li>configure DI for OpenTelemetry-dotnet.</li>
<li>(optional) add PrometheusExporterMetricsService for prometheus exporter.</li>
<li>configure filters/logger for telemetry.</li>
<li>try your telemetry.</li>
</ul>
<p>Let's follow the steps.</p>
<p><strong>add reference to the MagicOnion.OpenTelemetry</strong></p>
<p>Add nuget.config to reference opentelemetry-dotnet MyGet v3 endpoint.</p>

<p>add package sources reference.</p>
<div><pre>&lt;?<span>xml</span><span> version</span>=<span><span>"</span>1.0<span>"</span></span><span> encoding</span>=<span><span>"</span>utf-8<span>"</span></span>?&gt;
&lt;<span>configuration</span>&gt;
  &lt;<span>packageRestore</span>&gt;
    &lt;<span>add</span> <span>key</span>=<span><span>"</span>enabled<span>"</span></span> <span>value</span>=<span><span>"</span>true<span>"</span></span> /&gt;
    &lt;<span>add</span> <span>key</span>=<span><span>"</span>automatic<span>"</span></span> <span>value</span>=<span><span>"</span>true<span>"</span></span> /&gt;
  &lt;/<span>packageRestore</span>&gt;
  &lt;<span>packageSources</span>&gt;
    <span><span>&lt;!--</span>To inherit the global NuGet package sources remove the &lt;clear/&gt; line below <span>--&gt;</span></span>
    &lt;<span>clear</span> /&gt;
    &lt;<span>add</span> <span>key</span>=<span><span>"</span>nuget<span>"</span></span> <span>value</span>=<span><span>"</span>https://api.nuget.org/v3/index.json<span>"</span></span> /&gt;
    &lt;<span>add</span> <span>key</span>=<span><span>"</span>myget.org opentelemetry<span>"</span></span> <span>value</span>=<span><span>"</span>https://www.myget.org/F/opentelemetry/api/v3/index.json<span>"</span></span> /&gt;
  &lt;/<span>packageSources</span>&gt;
&lt;/<span>configuration</span>&gt;
</pre></div>
<p>Add <a href="https://www.nuget.org/packages/MagicOnion.OpenTelemetry" rel="nofollow">MagicOnion.OpenTelemetry</a> nuget package to your MagicOnion server project.</p>
<div><pre>dotnet add package MagicOnion.OpenTelemetry</pre></div>
<p>You are ready to configure MagicOnion Filter &amp; Logger for OpenTelemetry.</p>
<p><strong>configuration for OpenTelemetry</strong></p>
<p>MagicOnion.OpenTelemetry offers configuration binder.
Default configuration key is <code>MagicOnion:OpenTelemery</code>.</p>
<ul>
<li><code>ServiceName</code>: Configure Tracer ServiceName</li>
<li><code>MetricsExporterEndpoint</code>: Configure your metrics exporter's push endpoint. (e.g. Prometheus)</li>
<li><code>TracerExporterEndpoint</code>: Configure your tracer exporter's push endpoint. (e.g. Zipkin)</li>
</ul>
<div><pre>{
  <span><span>"</span>MagicOnion<span>"</span></span>: {
    <span><span>"</span>OpenTelemetry<span>"</span></span>: {
      <span><span>"</span>ServiceName<span>"</span></span>: <span><span>"</span>ChatApp.Server<span>"</span></span>,
      <span><span>"</span>MetricsExporterEndpoint<span>"</span></span>: <span><span>"</span>http://127.0.0.1:9184/metrics/<span>"</span></span>,
      <span><span>"</span>TracerExporterEndpoint<span>"</span></span>: <span><span>"</span>http://127.0.0.1:9411/api/v2/spans<span>"</span></span>
    }
  }
}</pre></div>
<p><strong>configure DI for OpenTelemetry-dotnet</strong></p>
<p>MagicOnion.OpenTelemetry offers extensions for IServiceCollection, <code>AddMagicOnionOpenTelemetry</code>.
Register <code>MagicOnionOpenTelemetryOptions</code>, <code>Action&lt;MagicOnionOpenTelemetryMeterFactoryOption&gt;</code> and <code>Action&lt;TracerBuilder&gt;</code> to configure MeterFactory &amp; TracerFactory.</p>
<blockquote>
<p>TIPS: <code>AddMagicOnionOpenTelemetry</code> register MagicOnionOpenTelemetryOptions, MeterFactory and TracerFactory as Singleton for you.</p>
</blockquote>
<div><pre><span>await</span> <span>MagicOnionHost</span>.<span>CreateDefaultBuilder</span>()
    .<span>UseMagicOnion</span>()
    .<span>ConfigureServices</span>((<span>hostContext</span>, <span>services</span>) <span>=&gt;</span>
    {
        <span>services</span>.<span>AddMagicOnionOpenTelemetry</span>((<span>options</span>, <span>meterOptions</span>) <span>=&gt;</span>
        {
            <span><span>//</span> open-telemetry with Prometheus exporter</span>
            <span>meterOptions</span>.<span>MetricExporter</span> <span>=</span> <span>new</span> <span>PrometheusExporter</span>(<span>new</span> <span>PrometheusExporterOptions</span>() { <span>Url</span> <span>=</span> <span>options</span>.<span>MetricsExporterEndpoint</span> });
        },
        (<span>options</span>, <span>tracerBuilder</span>) <span>=&gt;</span>
        {
            <span><span>//</span> open-telemetry with Zipkin exporter</span>
            <span>tracerBuilder</span>.<span>UseZipkin</span>(<span>o</span> <span>=&gt;</span>
            {
                <span>o</span>.<span>ServiceName</span> <span>=</span> <span>options</span>.<span>ServiceName</span>;
                <span>o</span>.<span>Endpoint</span> <span>=</span> <span>new</span> <span>Uri</span>(<span>options</span>.<span>TracerExporterEndpoint</span>);
            });
        });
    })</pre></div>
<p><strong>(optional) add PrometheusExporterMetricsService for prometheus exporter.</strong></p>
<p>If you use Prometheus Exporter and require Prometheus Server to recieve pull request from Prometheus Collector Server, see sample IHostedService implementation.</p>
<blockquote>
<p><a href="https://github.com/Cysharp/MagicOnion/blob/master/samples/ChatApp/ChatApp.Server.Telemery/PrometheusExporterMetricsService.cs">PrometheusExporterMetricsService</a>
<a href="https://github.com/Cysharp/MagicOnion/blob/master/samples/ChatApp/ChatApp.Server.Telemery/PrometheusExporterMetricsHttpServerCustom.cs">PrometheusExporterMetricsHttpServerCustom</a></p>
</blockquote>
<div><pre># Program.cs
.<span>ConfigureServices</span>((<span>hostContext</span>, <span>services</span>) <span>=&gt;</span>
{
    <span>services</span>.<span>AddMagicOnionOpenTelemetry</span>((<span>options</span>, <span>meterOptions</span>) <span>=&gt;</span>
    {
        <span><span>//</span> your metrics exporter implementation.</span>
    },
    (<span>options</span>, <span>tracerBuilder</span>) <span>=&gt;</span>
    {
        <span><span>//</span> your tracer exporter implementation.</span>
    });
    <span><span>//</span> host your prometheus metrics server</span>
    <span>services</span>.<span>AddHostedService</span>&lt;<span>PrometheusExporterMetricsService</span>&gt;();
})</pre></div>
<p><strong>configure filters/logger for telemetry</strong></p>
<p>You can collect MagicOnion metrics with <code>MagicOnionFilter</code>. MagicOnion.OpenTelemetry offers <code>OpenTelemetryCollectorFilter</code> and <code>OpenTelemetryHubCollectorFilter</code> for you.
You can trace Unary and StreamingHub API by register MagicOnionLogger on each hook point prepared via <code>IMagicOnionLogger</code>. MagicOnion.OpenTelemetry offers <code>OpenTelemetryCollectorLogger</code> for you.</p>
<div><pre><span>await</span> <span>MagicOnionHost</span>.<span>CreateDefaultBuilder</span>()
    .<span>UseMagicOnion</span>()
    .<span>ConfigureServices</span>((<span>hostContext</span>, <span>services</span>) <span>=&gt;</span>
    {
        <span>services</span>.<span>AddMagicOnionOpenTelemetry</span>((<span>options</span>, <span>meterOptions</span>) <span>=&gt;</span>
        {
            <span><span>//</span> your metrics exporter implementation.</span>
        },
        (<span>options</span>, <span>tracerBuilder</span>) <span>=&gt;</span>
        {
            <span><span>//</span> your tracer exporter implementation.</span>
        });
    })
    .<span>ConfigureServices</span>((<span>hostContext</span>, <span>services</span>) <span>=&gt;</span>
    {
        <span>var</span> <span>meterFactory</span> <span>=</span> <span>services</span>.<span>BuildServiceProvider</span>().<span>GetService</span>&lt;<span>MeterFactory</span>&gt;();
        <span>services</span>.<span>Configure</span>&lt;<span>MagicOnionHostingOptions</span>&gt;(<span>options</span> <span>=&gt;</span>
        {
            <span>options</span>.<span>Service</span>.<span>GlobalFilters</span>.<span>Add</span>(<span>new</span> <span>OpenTelemetryCollectorFilterAttribute</span>());
            <span>options</span>.<span>Service</span>.<span>GlobalStreamingHubFilters</span>.<span>Add</span>(<span>new</span> <span>OpenTelemetryHubCollectorFilterAttribute</span>());
            <span>options</span>.<span>Service</span>.<span>MagicOnionLogger</span> <span>=</span> <span>new</span> <span>OpenTelemetryCollectorLogger</span>(<span>meterFactory</span>);
        });
    })
    .<span>RunConsoleAsync</span>();</pre></div>
<p><strong>try your telemetry</strong></p>
<p>All implementation is done, let's Debug run MagicOnion and confirm you can see metrics and tracer.</p>
<p>SampleApp <code>ChatApp.Server.Telemery</code> offers sample for Prometheus Metrics exporter and Zipkin Tracer exporter.</p>
<p>Run Zipkin on Docker to recieve tracer from ChatApp.Server.Telemery.</p>
<div><pre>docker run --rm -p 9411:9411 openzipkin/zipkin</pre></div>
<ul>
<li>Prometheus metrics wlll show on <a href="http://localhost:9184/metrics" rel="nofollow">http://localhost:9184/metrics</a>.</li>
<li>Zipkin tracer will show on <a href="http://localhost:9411/zipkin/" rel="nofollow">http://localhost:9411/zipkin/</a></li>
</ul>
<p>Zipkin tracer will be shown as below.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/3856350/82529117-3b80d800-9b75-11ea-9e70-4bf15411becc.png"><img src="https://user-images.githubusercontent.com/3856350/82529117-3b80d800-9b75-11ea-9e70-4bf15411becc.png" alt="image"></a></p>
<p>Prometheus Metrics will be shown as like follows.</p>
<pre lang="txt"><code># HELP magiconion_buildservicedefinition_duration_millisecondsMagicOnionmagiconion_buildservicedefinition_duration_milliseconds
# TYPE magiconion_buildservicedefinition_duration_milliseconds summary
magiconion_buildservicedefinition_duration_milliseconds_sum{method="EndBuildServiceDefinition"} 0 1591066746669
magiconion_buildservicedefinition_duration_milliseconds_count{method="EndBuildServiceDefinition"} 0 1591066746669
magiconion_buildservicedefinition_duration_milliseconds{method="EndBuildServiceDefinition",quantile="0"} 1.7976931348623157E+308 1591066746669
magiconion_buildservicedefinition_duration_milliseconds{method="EndBuildServiceDefinition",quantile="1"} -1.7976931348623157E+308 1591066746669
# HELP magiconion_broadcast_request_sizeMagicOnionmagiconion_broadcast_request_size
# TYPE magiconion_broadcast_request_size summary
magiconion_broadcast_request_size_sum{GroupName="SampleRoom"} 0 1591066746669
magiconion_broadcast_request_size_count{GroupName="SampleRoom"} 0 1591066746669
magiconion_broadcast_request_size{GroupName="SampleRoom",quantile="0"} 9.223372036854776E+18 1591066746669
magiconion_broadcast_request_size{GroupName="SampleRoom",quantile="1"} -9.223372036854776E+18 1591066746669
# HELP magiconion_streaminghub_elapsed_millisecondsMagicOnionmagiconion_streaminghub_elapsed_milliseconds
# TYPE magiconion_streaminghub_elapsed_milliseconds summary
magiconion_streaminghub_elapsed_milliseconds_sum{methodType="DuplexStreaming"} 0 1591066746669
magiconion_streaminghub_elapsed_milliseconds_count{methodType="DuplexStreaming"} 0 1591066746669
magiconion_streaminghub_elapsed_milliseconds{methodType="DuplexStreaming",quantile="0"} 1.7976931348623157E+308 1591066746669
magiconion_streaminghub_elapsed_milliseconds{methodType="DuplexStreaming",quantile="1"} -1.7976931348623157E+308 1591066746670
# HELP magiconion_unary_response_sizeMagicOnionmagiconion_unary_response_size
# TYPE magiconion_unary_response_size summary
magiconion_unary_response_size_sum{method="/IChatService/GenerateException"} 0 1591066746669
magiconion_unary_response_size_count{method="/IChatService/GenerateException"} 0 1591066746669
magiconion_unary_response_size{method="/IChatService/GenerateException",quantile="0"} 9.223372036854776E+18 1591066746669
magiconion_unary_response_size{method="/IChatService/GenerateException",quantile="1"} -9.223372036854776E+18 1591066746669
magiconion_unary_response_size_sum{methodType="Unary"} 0 1591066746669
magiconion_unary_response_size_count{methodType="Unary"} 0 1591066746669
magiconion_unary_response_size{methodType="Unary",quantile="0"} 9.223372036854776E+18 1591066746669
magiconion_unary_response_size{methodType="Unary",quantile="1"} -9.223372036854776E+18 1591066746669
</code></pre>
<p>You may find <code>MagicOnion/measure/BuildServiceDefinition{MagicOnion_keys_Method="EndBuildServiceDefinition",quantile="0"}</code> are collected, and other metrics will shown as #HELP.
They will export when Unary/StreamingHub request is comming.</p>
<p><strong>tips</strong></p>
<ul>
<li>Want insert your own tag to default metrics.</li>
</ul>
<p>Add defaultTags when register <code>OpenTelemetryCollectorLogger</code>.</p>
<ul>
<li>Want replace magiconion metrics prefix to my magiconion metrics.</li>
</ul>
<p>Set metricsPrefix when register <code>OpenTelemetryCollectorLogger</code>.
If you pass <code>yourprefix</code>, then metrics prefix will change to followings.</p>
<pre><code>yourprefix_buildservicedefinition_duration_milliseconds_sum{method="EndBuildServiceDefinition"} 66.7148 1591066185908
</code></pre>
<ul>
<li>Want contain <code>version</code> tag to your metrics.</li>
</ul>
<p>Add version when register <code>OpenTelemetryCollectorLogger</code>.</p>
<p>This should output like follows, however current opentelemetry-dotnet Prometheus exporter not respect version tag.</p>
<pre><code>magiconion_buildservicedefinition_duration_milliseconds_sum{method="EndBuildServiceDefinition",version="1.0.0"} 66.7148 1591066185908
</code></pre>
<h4>try visualization on localhost</h4>
<p>You can try Prometheus collecter and visualize metrics on Grafana, all these operation can be done by docker-compose.
Please follow the steps.</p>
<ul>
<li>
<p>Apply above <code>examples of implementation</code> settings to the <a href="https://github.com/Cysharp/MagicOnion/tree/master/samples/ChatApp/ChatApp.Server">MagicOnion/samples/ChatApp/ChatApp.Server</a>.</p>
</li>
<li>
<p>Copy all items in <a href="https://github.com/Cysharp/MagicOnion/tree/master/docs/telemetry">MagicOnion/docs/telemetry</a> directory to [MagicOnion/samples/ChatApp].</p>
</li>
</ul>
<div><pre><span><span>#</span> Windows</span>
<span>&gt;</span> xcopy MagicOnion<span>\d</span>ocs<span>\t</span>elemetry MagicOnion<span>\s</span>amples<span>\C</span>hatApp /H /E
<span><span>#</span> Bash</span>
$ cp -rT MagicOnion/docs/telemetry MagicOnion/samples/ChatApp</pre></div>
<ul>
<li>Build &amp; Launch docker-compose, you are all systems are up and running on your localhost.</li>
</ul>
<div><pre>$ <span>cd</span> MagicOnion/samples/ChatApp
$ docker-compose build
$ docker-compose up

Creating network <span><span>"</span>chatapp_default<span>"</span></span> with the default driver
Creating alertmanager         ... <span>done</span>
Creating prometheus           ... <span>done</span>
Creating chatapp_magiconion_1 ... <span>done</span>
Creating cAdvisor             ... <span>done</span>
Creating grafana              ... <span>done</span></pre></div>
<p>When you launch docker-compose, followings set of service will launch for you.</p>
<ul>
<li><strong>MagicOnion</strong> stats export on <a href="http://localhost:9182/metrics/" rel="nofollow">http://localhost:9182/metrics/</a>.</li>
<li><strong>cAdvisor</strong> launch on <a href="http://localhost:8080/" rel="nofollow">http://localhost:8080</a>.</li>
<li><strong>Prometheus</strong> launch on <a href="http://localhost:9090/" rel="nofollow">http://localhost:9090</a>.</li>
<li><strong>Grafana</strong> launch on <a href="http://localhost:3000/" rel="nofollow">http://localhost:3000</a>. (default username: <code>admin</code>, password: <code>admin</code>)</li>
<li><strong>Alertmanager</strong> to notify alert to Slack.</li>
<li>optional: if you want <strong>node_exporter</strong>, uncomment in <code>docker-compose.yml</code> and it launch on <a href="http://localhost:9100/" rel="nofollow">http://localhost:9100</a>. make sure host volume is mounted to container.</li>
</ul>
<p>To configure Grafana dashboard, follow the steps.</p>
<ul>
<li>add DataSource: Data Souces&gt; add &gt; Prometheus (prometheus URL will be <a href="http://prometheus:9090/" rel="nofollow">http://prometheus:9090</a>)</li>
<li>add Dashboard:
<ul>
<li><strong>Prometheus 2.0 Stats</strong> dashboard: open Data Source &gt; prometheus &gt; dashboard tab &gt; add Prometheus 2.0 Stats</li>
<li><strong>Docker and Host Monitoring w/ Prometheus</strong> dashboard (cAdvisor): open Dashboard &gt; Manage &gt; Import &gt; <a href="https://grafana.com/grafana/dashboards/179" rel="nofollow">https://grafana.com/grafana/dashboards/179</a></li>
<li><strong>MagicOnion Overview</strong> dashboard (MagicOnion &amp; cAdvisor): open Dashboard &gt; Manage &gt; Import &gt; <a href="https://grafana.com/grafana/dashboards/10584" rel="nofollow">https://grafana.com/grafana/dashboards/10584</a></li>
<li>optional: <strong>node_exporter 1.8</strong> dashboard: open Dashboard &gt; Manage &gt; Import &gt; <a href="https://grafana.com/grafana/dashboards/1860" rel="nofollow">https://grafana.com/grafana/dashboards/1860</a></li>
</ul>
</li>
</ul>
<p>Now you can observe MagicOnion metrics through Grafana.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/3856350/61683238-c58ec300-ad4f-11e9-9057-1cfb9c30cd67.png"><img src="https://user-images.githubusercontent.com/3856350/61683238-c58ec300-ad4f-11e9-9057-1cfb9c30cd67.png" alt="image"></a></p>
<p>To configure alert eather, modify <code>prometheus/config/alert.rules</code> and set slack incoming url on <code>alertmanager/config.yml</code>.</p>
<h4>implement your own metrics</h4>
<p>Implement <code>IMagicOnionLogger</code> to configure your metrics. You can collect metrics when following callbacks are invoked by filter.</p>
<div><pre><span>namespace</span> <span>MagicOnion</span>.<span>Server</span>
{
    <span>public</span> <span>interface</span> <span>IMagicOnionLogger</span>
    {
        <span>void</span> <span>BeginBuildServiceDefinition</span>();
        <span>void</span> <span>BeginInvokeHubMethod</span>(<span>StreamingHubContext</span> <span>context</span>, <span>ArraySegment</span>&lt;<span>byte</span>&gt; <span>request</span>, <span>Type</span> <span>type</span>);
        <span>void</span> <span>BeginInvokeMethod</span>(<span>ServiceContext</span> <span>context</span>, <span>byte</span>[] <span>request</span>, <span>Type</span> <span>type</span>);
        <span>void</span> <span>EndBuildServiceDefinition</span>(<span>double</span> <span>elapsed</span>);
        <span>void</span> <span>EndInvokeHubMethod</span>(<span>StreamingHubContext</span> <span>context</span>, <span>int</span> <span>responseSize</span>, <span>Type</span> <span>type</span>, <span>double</span> <span>elapsed</span>, <span>bool</span> <span>isErrorOrInterrupted</span>);
        <span>void</span> <span>EndInvokeMethod</span>(<span>ServiceContext</span> <span>context</span>, <span>byte</span>[] <span>response</span>, <span>Type</span> <span>type</span>, <span>double</span> <span>elapsed</span>, <span>bool</span> <span>isErrorOrInterrupted</span>);
        <span>void</span> <span>InvokeHubBroadcast</span>(<span>string</span> <span>groupName</span>, <span>int</span> <span>responseSize</span>, <span>int</span> <span>broadcastGroupCount</span>);
        <span>void</span> <span>ReadFromStream</span>(<span>ServiceContext</span> <span>context</span>, <span>byte</span>[] <span>readData</span>, <span>Type</span> <span>type</span>, <span>bool</span> <span>complete</span>);
        <span>void</span> <span>WriteToStream</span>(<span>ServiceContext</span> <span>context</span>, <span>byte</span>[] <span>writeData</span>, <span>Type</span> <span>type</span>);
    }
}</pre></div>
<p>When implement your own metrics, define <code>IView</code> and register it <code>Stats.ViewManager.RegisterView(YOUR_VIEW);</code>, then send metrics.</p>
<p>There are several way to send metrics.</p>
<blockquote>
<p>Send each metrics each line.</p>
</blockquote>
<div><pre><span>statsRecorder</span>.<span>NewMeasureMap</span>().<span>Put</span>(<span>YOUR_METRICS</span>, <span>1</span>).<span>Record</span>(<span>TagContext</span>);</pre></div>
<blockquote>
<p>Put many metrics and send at once:</p>
</blockquote>
<div><pre><span>var</span> <span>map</span> <span>=</span> <span>statsRecorder</span>.<span>NewMeasureMap</span>(); <span>map</span>.<span>Put</span>(<span>YOUR_METRICS</span>, <span>1</span>);
<span>map</span>.<span>Put</span>(<span>YOUR_METRICS2</span>, <span>2</span>);
<span>map</span>.<span>Put</span>(<span>YOUR_METRICS3</span>, <span>10</span>);
<span>if</span> (<span>isErrorOrInterrupted</span>)
{
    <span>map</span>.<span>Put</span>(<span>YOUR_METRICS4</span>, <span>3</span>);
}

<span>map</span>.<span>Record</span>(<span>TagContext</span>);</pre></div>
<blockquote>
<p>create tag scope and set number of metrics.</p>
</blockquote>
<div><pre><span>var</span> <span>tagContextBuilder</span> <span>=</span> <span>Tagger</span>.<span>CurrentBuilder</span>.<span>Put</span>(<span>FrontendKey</span>, <span>TagValue</span>.<span>Create</span>(<span><span>"</span>mobile-ios9.3.5<span>"</span></span>));
<span>using</span> (<span>var</span> <span>scopedTags</span> <span>=</span> <span>tagContextBuilder</span>.<span>BuildScoped</span>())
{
    <span>StatsRecorder</span>.<span>NewMeasureMap</span>().<span>Put</span>(<span>YOUR_METRICS</span>, 1).<span>Record</span>();
    <span>StatsRecorder</span>.<span>NewMeasureMap</span>().<span>Put</span>(<span>YOUR_METRICS2</span>, <span>2</span>).<span>Record</span>();
    <span>StatsRecorder</span>.<span>NewMeasureMap</span>().<span>Put</span>(<span>YOUR_METRICS3</span>, <span>10</span>).<span>Record</span>();
}</pre></div>
<p>Make sure your View's column, and metrics TagKey is matched. Otherwise none of metrics will shown.</p>
<h2>Advanced</h2>
<h3>MagicOnionOption/Logging</h3>
<p><code>MagicOnionOption</code> can pass to <code>MagicOnionEngine.BuildServerServiceDefinition(MagicOnionOptions option)</code>.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IMagicOnionLogger</code> MagicOnionLogger</td>
<td>Set the diagnostics info logger.</td>
</tr>
<tr>
<td><code>IList&lt;MagicOnionFilterDescriptor&gt;</code> GlobalFilters</td>
<td>Global MagicOnion filters.</td>
</tr>
<tr>
<td><code>bool</code> EnableCurrentContext</td>
<td>Enable ServiceContext.Current option by AsyncLocal, default is false.</td>
</tr>
<tr>
<td><code>IList&lt;StreamingHubFilterDescriptor&gt;</code> Global StreamingHub filters.</td>
<td>GlobalStreamingHubFilters</td>
</tr>
<tr>
<td><code>IGroupRepositoryFactory</code> DefaultGroupRepositoryFactory</td>
<td>Default GroupRepository factory for StreamingHub, default is ``.</td>
</tr>
<tr>
<td><code>IServiceLocator</code> ServiceLocator</td>
<td>Add the extra typed option.</td>
</tr>
<tr>
<td><code>bool</code> IsReturnExceptionStackTraceInErrorDetail</td>
<td>If true, MagicOnion handles exception ownself and send to message. If false, propagate to gRPC engine. Default is false.</td>
</tr>
<tr>
<td><code>IFormatterResolver</code> FormatterResolver</td>
<td>MessagePack serialization resolver. Default is used ambient default(MessagePackSerialzier.Default).</td>
</tr>
</tbody>
</table>
<p><code>IMagicOnionLogger</code> is structured logger of MagicOnion. Implements your custom logging code and append it, default is <code>NullMagicOnionLogger</code>(do nothing). MagicOnion has some built in logger, <code>MagicOnionLogToGrpcLogger</code> that structured log to string log and send to <code>GrpcEnvironment.Logger</code>. <code>MagicOnionLogToGrpcLoggerWithDataDump</code> is includes data dump it is useful for debugging(but slightly heavy, recommended to only use debugging). <code>MagicOnionLogToGrpcLoggerWithNamedDataDump</code> is more readable than simple WithDataDump logger.</p>
<p>If you want to add many loggers, you can use <code>CompositeLogger</code>(for gRPC logging), <code>CompositeMagicOnionLogger</code>(for MagicOnion structured logging) to composite many loggers.</p>
<h3>Raw gRPC APIs</h3>
<p>MagicOnion can define and use primitive gRPC APIs(ClientStreaming, ServerStreaming, DuplexStreaming). Especially DuplexStreaming is used underlying StreamingHub. If there is no reason, we recommend using StreamingHub.</p>
<div><pre><span><span>//</span> Definitions</span>
<span>public</span> <span>interface</span> <span>IMyFirstService</span> : <span>IService</span>&lt;<span>IMyFirstService</span>&gt;
{
    <span>UnaryResult</span>&lt;<span>string</span>&gt; <span>SumAsync</span>(<span>int</span> <span>x</span>, <span>int</span> <span>y</span>);
    <span>Task</span>&lt;<span>UnaryResult</span>&lt;<span>string</span>&gt;&gt; <span>SumLegacyTaskAsync</span>(<span>int</span> <span>x</span>, <span>int</span> <span>y</span>);
    <span>Task</span>&lt;<span>ClientStreamingResult</span>&lt;<span>int</span>, <span>string</span>&gt;&gt; <span>ClientStreamingSampleAsync</span>();
    <span>Task</span>&lt;<span>ServerStreamingResult</span>&lt;<span>string</span>&gt;&gt; <span>ServertSreamingSampleAsync</span>(<span>int</span> <span>x</span>, <span>int</span> <span>y</span>, <span>int</span> <span>z</span>);
    <span>Task</span>&lt;<span>DuplexStreamingResult</span>&lt;<span>int</span>, <span>string</span>&gt;&gt; <span>DuplexStreamingSampleAync</span>();
}

<span><span>//</span> Server</span>
<span>public</span> <span>class</span> <span>MyFirstService</span> : <span>ServiceBase</span>&lt;<span>IMyFirstService</span>&gt;, <span>IMyFirstService</span>
{
    <span><span>//</span> VisualStudio 2017(C# 7.0), Unity 2018.3 supports return `async UnaryResult` directly</span>
    <span><span>//</span> I recommend disable async-warning on project level. &lt;NoWarn&gt;1998&lt;/NoWarn&gt;</span>
    <span>public</span> <span>async</span> <span>UnaryResult</span>&lt;<span>string</span>&gt; <span>SumAsync</span>(<span>int</span> <span>x</span>, <span>int</span> <span>y</span>)
    {
        <span>Logger</span>.<span>Debug</span>(<span><span>$"</span>Called SumAsync - x:{<span>x</span>} y:{<span>y</span>}<span>"</span></span>);

        <span>return</span> (<span>x</span> <span>+</span> <span>y</span>).<span>ToString</span>();
    }

    <span><span>//</span> VS2015(C# 6.0), Unity 2018.2 use Task</span>
    <span>public</span> <span>async</span> <span>Task</span>&lt;<span>UnaryResult</span>&lt;<span>string</span>&gt;&gt; <span>SumLegacyTaskAsync</span>(<span>int</span> <span>x</span>, <span>int</span> <span>y</span>)
    {
        <span>Logger</span>.<span>Debug</span>(<span><span>$"</span>Called SumAsync - x:{<span>x</span>} y:{<span>y</span>}<span>"</span></span>);

        <span><span>//</span> use UnaryResult method.</span>
        <span>return</span> <span>UnaryResult</span>((<span>x</span> <span>+</span> <span>y</span>).<span>ToString</span>());
    }

    <span>public</span> <span>async</span> <span>Task</span>&lt;<span>ClientStreamingResult</span>&lt;<span>int</span>, <span>string</span>&gt;&gt; <span>ClientStreamingSampleAsync</span>()
    {
        <span>Logger</span>.<span>Debug</span>(<span><span>$"</span>Called ClientStreamingSampleAsync<span>"</span></span>);

        <span><span>//</span> If ClientStreaming, use GetClientStreamingContext.</span>
        <span>var</span> <span>stream</span> <span>=</span> <span>GetClientStreamingContext</span>&lt;<span>int</span>, <span>string</span>&gt;();

        <span><span>//</span> receive from client asynchronously</span>
        <span>await</span> <span>stream</span>.<span>ForEachAsync</span>(<span>x</span> <span>=&gt;</span>
        {
            <span>Logger</span>.<span>Debug</span>(<span><span>"</span>Client Stream Received:<span>"</span></span> <span>+</span> <span>x</span>);
        });

        <span><span>//</span> StreamingContext.Result() for result value.</span>
        <span>return</span> <span>stream</span>.<span>Result</span>(<span><span>"</span>finished<span>"</span></span>);
    }

    <span>public</span> <span>async</span> <span>Task</span>&lt;<span>ServerStreamingResult</span>&lt;<span>string</span>&gt;&gt; <span>ServertSreamingSampleAsync</span>(<span>int</span> <span>x</span>, <span>int</span> <span>y</span>, <span>int</span> <span>z</span>)
    {
        <span>Logger</span>.<span>Debug</span>(<span><span>$"</span>Called ServertSreamingSampleAsync - x:{<span>x</span>} y:{<span>y</span>} z:{<span>z</span>}<span>"</span></span>);

        <span>var</span> <span>stream</span> <span>=</span> <span>GetServerStreamingContext</span>&lt;<span>string</span>&gt;();

        <span>var</span> <span>acc</span> <span>=</span> <span>0</span>;
        <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>z</span>; <span>i</span><span>++</span>)
        {
            <span>acc</span> <span>=</span> <span>acc</span> <span>+</span> <span>x</span> <span>+</span> <span>y</span>;
            <span>await</span> <span>stream</span>.<span>WriteAsync</span>(<span>acc</span>.<span>ToString</span>());
        }

        <span>return</span> <span>stream</span>.<span>Result</span>();
    }

    <span>public</span> <span>async</span> <span>Task</span>&lt;<span>DuplexStreamingResult</span>&lt;<span>int</span>, <span>string</span>&gt;&gt; <span>DuplexStreamingSampleAync</span>()
    {
        <span>Logger</span>.<span>Debug</span>(<span><span>$"</span>Called DuplexStreamingSampleAync<span>"</span></span>);

        <span><span>//</span> DuplexStreamingContext represents both server and client streaming.</span>
        <span>var</span> <span>stream</span> <span>=</span> <span>GetDuplexStreamingContext</span>&lt;<span>int</span>, <span>string</span>&gt;();

        <span>var</span> <span>waitTask</span> <span>=</span> <span>Task</span>.<span>Run</span>(<span>async</span> () <span>=&gt;</span>
        {
            <span><span>//</span> ForEachAsync(MoveNext, Current) can receive client streaming.</span>
            <span>await</span> <span>stream</span>.<span>ForEachAsync</span>(<span>x</span> <span>=&gt;</span>
            {
                <span>Logger</span>.<span>Debug</span>(<span><span>$"</span>Duplex Streaming Received:<span>"</span></span> <span>+</span> <span>x</span>);
            });
        });

        <span><span>//</span> WriteAsync is ServerStreaming.</span>
        <span>await</span> <span>stream</span>.<span>WriteAsync</span>(<span><span>"</span>test1<span>"</span></span>);
        <span>await</span> <span>stream</span>.<span>WriteAsync</span>(<span><span>"</span>test2<span>"</span></span>);
        <span>await</span> <span>stream</span>.<span>WriteAsync</span>(<span><span>"</span>finish<span>"</span></span>);

        <span>await</span> <span>waitTask</span>;

        <span>return</span> <span>stream</span>.<span>Result</span>();
    }
}</pre></div>
<p>Client sample.</p>
<div><pre><span>static</span> <span>async</span> <span>Task</span> <span>UnaryRun</span>(<span>IMyFirstService</span> <span>client</span>)
{
    <span><span>//</span> await(C# 7.0, Unity 2018.3)</span>
    <span>var</span> <span>vvvvv</span> <span>=</span> <span>await</span> <span>client</span>.<span>SumAsync</span>(<span>10</span>, <span>20</span>);
    <span>Console</span>.<span>WriteLine</span>(<span><span>"</span>SumAsync:<span>"</span></span> <span>+</span> <span>vvvvv</span>);
    
    <span><span>//</span> if use Task&lt;UnaryResult&gt;(Unity 2018.2), use await await</span>
    <span>var</span> <span>vvvv2</span> <span>=</span> <span>await</span> <span>await</span> <span>client</span>.<span>SumLegacyTaskAsync</span>(<span>10</span>, <span>20</span>);
}

<span>static</span> <span>async</span> <span>Task</span> <span>ClientStreamRun</span>(<span>IMyFirstService</span> <span>client</span>)
{
    <span>var</span> <span>stream</span> <span>=</span> <span>await</span> <span>client</span>.<span>ClientStreamingSampleAsync</span>();

    <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>3</span>; <span>i</span><span>++</span>)
    {
        <span>await</span> <span>stream</span>.<span>RequestStream</span>.<span>WriteAsync</span>(<span>i</span>);
    }
    <span>await</span> <span>stream</span>.<span>RequestStream</span>.<span>CompleteAsync</span>();

    <span>var</span> <span>response</span> <span>=</span> <span>await</span> <span>stream</span>.<span>ResponseAsync</span>;

    <span>Console</span>.<span>WriteLine</span>(<span><span>"</span>Response:<span>"</span></span> <span>+</span> <span>response</span>);
}

<span>static</span> <span>async</span> <span>Task</span> <span>ServerStreamRun</span>(<span>IMyFirstService</span> <span>client</span>)
{
    <span>var</span> <span>stream</span> <span>=</span> <span>await</span> <span>client</span>.<span>ServertSreamingSampleAsync</span>(<span>10</span>, <span>20</span>, <span>3</span>);

    <span>await</span> <span>stream</span>.<span>ResponseStream</span>.<span>ForEachAsync</span>(<span>x</span> <span>=&gt;</span>
    {
        <span>Console</span>.<span>WriteLine</span>(<span><span>"</span>ServerStream Response:<span>"</span></span> <span>+</span> <span>x</span>);
    });
}

<span>static</span> <span>async</span> <span>Task</span> <span>DuplexStreamRun</span>(<span>IMyFirstService</span> <span>client</span>)
{
    <span>var</span> <span>stream</span> <span>=</span> <span>await</span> <span>client</span>.<span>DuplexStreamingSampleAync</span>();

    <span>var</span> <span>count</span> <span>=</span> <span>0</span>;
    <span>await</span> <span>stream</span>.<span>ResponseStream</span>.<span>ForEachAsync</span>(<span>async</span> <span>x</span> <span>=&gt;</span>
    {
        <span>Console</span>.<span>WriteLine</span>(<span><span>"</span>DuplexStream Response:<span>"</span></span> <span>+</span> <span>x</span>);

        <span>await</span> <span>stream</span>.<span>RequestStream</span>.<span>WriteAsync</span>(<span>count</span><span>++</span>);
        <span>if</span> (<span>x</span> <span>==</span> <span><span>"</span>finish<span>"</span></span>)
        {
            <span>await</span> <span>stream</span>.<span>RequestStream</span>.<span>CompleteAsync</span>();
        }
    });
}</pre></div>
<h3>Zero deserialization mapping</h3>
<p>In RPC, especially in real-time communication involving frequent transmission of data, it is often the serialization process where data is converted before being sent that limits the performance. In MagicOnion, serialization is done by my MessagePack for C#, which is the fastest binary serializer for C#, so it cannot be a limiting factor. Also, in addition to performance, it also provides flexibility regarding data in that variables of any type can be sent as long as they can be serialized by MessagePack for C#.</p>
<p>Also, taking advantage of the fact that both the client and the server run on C# and data stored on internal memory are expected to share the same layout, I added an option to do mapping through memory copy without serialization/deserialization in case of a value-type variable.</p>
<p>Especially in Unity, this is can combinate with <code>MessagePack.UnityShims</code> package of NuGet.</p>
<div><pre><span><span>//</span> It supports standard struct-type variables that are provided by Unity, such as Vector3, and arrays containing them, as well as custom struct-type variables and their arrays.</span>
<span><span>//</span> I recommend doing this explicitly using [StructLayout(LayoutKind.Explicit)] to accurately match the size.</span>
<span>public</span> <span>struct</span> <span>CustomStruct</span>
{
    <span>public</span> <span>long</span> <span>Id</span>;
    <span>public</span> <span>int</span> <span>Hp</span>;
    <span>public</span> <span>int</span> <span>Mp</span>;
    <span>public</span> <span>byte</span> <span>Status</span>;
}
 
<span><span>//</span> ---- Register the following code when initializing.</span>
 
<span><span>//</span> By registering it, T and T[] can be handled using zero deserialization mapping.</span>
<span>UnsafeDirectBlitResolver</span>.<span>Register</span>&lt;<span>CustomStruct</span>&gt;();
 
<span><span>//</span> The struct-type above as well as Unity-provided struct-types (Vector2, Rect, etc.), and their arrays are registered as standards.</span>
<span>CompositeResolver</span>.<span>RegisterAndSetAsDefault</span>(
    <span>UnsafeDirectBlitResolver</span>.<span>Instance</span>,
    <span>MessagePack</span>.<span>Unity</span>.<span>Extension</span>.<span>UnityBlitResolver</span>.<span>Instance</span>
    );
 
<span><span>//</span> --- Now the communication will be in the format above when they are used for transmission.</span>
<span>await</span> <span>client</span>.<span>SendAsync</span>(<span>new</span> <span>CustomStruct</span> { <span>Hp</span> <span>=</span> <span>99</span> });</pre></div>
<p>Nothing needs to be processed here, so it promises the best performance theoretically possible in terms of transmission speed. However, since these struct-type variables need to be copied, I recommend handling everything as ref as a rule when you need to define a large struct-type, or it might slow down the process.</p>
<p>I believe that this can be easily and effectively applied to sending a large number of Transforms, such as an array of Vector3 variables.</p>
<h2>Author Info</h2>
<p>This library is mainly developed by Yoshifumi Kawai(a.k.a. neuecc).<br>
He is the CEO/CTO of Cysharp which is a subsidiary of <a href="https://www.cygames.co.jp/en/" rel="nofollow">Cygames</a>.<br>
He is awarding Microsoft MVP for Developer Technologies(C#) since 2011.<br>
He is known as the creator of <a href="https://github.com/neuecc/UniRx/">UniRx</a> and <a href="https://github.com/neuecc/MessagePack-CSharp/">MessagePack for C#</a>.</p>
<h2>License</h2>
<p>This library is under the MIT License.</p>
</article>
      </div>
  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>