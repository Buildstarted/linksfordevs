<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Languages Which Almost Became CSS - Eager Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The Languages Which Almost Became CSS - Eager Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Eager"/>
    <meta property="og:description" content="The history of all the languages which almost became CSS."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://eager.io/blog/the-languages-which-almost-were-css/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The Languages Which Almost Became CSS - Eager Blog</title>
<div class="readable">
        <h1>The Languages Which Almost Became CSS - Eager Blog</h1>
            <div>by Eager</div>
            <div>Reading time: 20-25 minutes</div>
        <div>Posted here: 13 Aug 2020</div>
        <p><a href="https://eager.io/blog/the-languages-which-almost-were-css/">https://eager.io/blog/the-languages-which-almost-were-css/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><blockquote>
<p>
In fact, it has been a constant source of delight for me over the past year to
get to continually tell hordes (literally) of people who want to – strap
yourselves in, here it comes – control what their documents look like in ways
that would be trivial in TeX, Microsoft Word, and every other common text
processing environment: “<strong>Sorry, you’re screwed.</strong>”
</p>
<p>
— Marc Andreessen <a href="http://1997.webhistory.org/www.lists/www-talk.1994q1/0648.html"><code>1994</code></a>
</p>
</blockquote>

<p>When HTML was announced by Tim Berners-Lee in 1991 there was no method of
styling pages.  How given HTML tags were rendered was determined by the browser,
often with significant input from the user’s preferences.  It seemed, however,
like a good idea to create a standard way for pages to ‘suggest’ how they
might prefer to be rendered stylistically.</p>
<p>But CSS wouldn’t be introduced for five years, and wouldn’t be
fully implemented for ten.  This was a period of intense work and innovation
which resulted in more than a few competing styling methods which just as easily
could have become the standard.</p>
<p>While these languages are obviously not in common use today, I find it
fascinating to think about the world that might have been.  Even more surprisingly,
it happens that many of these other options include features which developers
would love to see appear in CSS even today.</p>
<h3 id="the-first-proposal">The First Proposal</h3>
<p>In early 1993 the Mosaic browser had not yet reached 1.0 and those browsers
that did exist dealt solely with HTML.  There was no method of specifying the
style of HTML whatsoever, meaning whatever the browser decided an <code>&lt;h1&gt;</code> should
look like, that’s what you got.</p>
<p>In June of that year, Robert Raisch made <a href="http://1997.webhistory.org/www.lists/www-talk.1993q2/0445.html">a
proposal</a> to
the www-talk mailing list to create a “an easily parsable format to deliver
stylistic information along with Web documents” which would be called RRP.</p>
<pre data-lang="css"><span>@BODY</span> <span>fo</span>(<span>fa</span>=<span>he</span>,<span>si</span>=<span>18</span>)
</pre>
<p>You would be forgiven for having no idea what this code is doing.  In the era
before gzipping, and with connection speeds hovering around 14.4k, it made
sense to make the content of this new format as terse as was possible.  This
particular rule is setting the font family (<code>fa</code>) to helvetica (<code>he</code>), and the
font size (<code>si</code>) to 18 points.</p>
<p>Some interesting things missing from this proposal were any mention of units,
all numbers being interpreted based on their context (font sizes were always in
points for example).  This could be attributed to RRP being designed more as a
“set of HINTS or SUGGESTIONS to the renderer” rather than a specification.
This was considered necessary because the same stylesheet needed to function
for both the common line-mode browsers (like
<a href="https://en.wikipedia.org/wiki/Lynx_(web_browser">Lynx</a>), and the graphical
browsers which were becoming increasingly popular.</p>
<p><img src="https://eager.io/blog/the-languages-which-almost-were-css/images/lynx.png" alt="Lynx browser screenshot"></p>
<p>Interestingly, RRP did include a method of specifying a columnar layout, a
feature which wouldn’t make it to CSS until 2011.  For example, three columns,
each of width ‘80 units’ would look like this:</p>
<pre data-lang="css"><span>@P</span> <span>co</span>(<span>nu</span>=<span>3</span>,<span>wi</span>=<span>80</span>)
</pre>
<p>It’s a little hard to parse, but not much worse than <code>white-space: nowrap</code> perhaps.</p>
<p>It’s worth noting that RRP did not support any of the ‘cascading’ we associate
with stylesheets today.  A given document could only have one active stylesheet
at a time, which is a logical way to think about styling a document, even if
it’s foreign to us today.</p>
<p>Marc Andreessen (the creator of Mosaic, which would become the most popular
browser) was
<a href="http://www.webhistory.org/www.lists/www-talk.1993q4/0266.html">aware</a> of the
RRP proposal, but it was never implemented by Mosaic.  Instead, Mosaic quickly
moved (somewhat tragically) down the path of using HTML tags to define style,
introducing tags like <code>&lt;FONT&gt;</code> and <code>&lt;CENTER&gt;</code>.</p>
<h3 id="viola-and-the-proto-browser-wars">Viola and the Proto-Browser Wars</h3>
<blockquote>
<blockquote>
<p>Then why don't you just implement one of the many style sheet
proposals that are on the table. This would pretty much solve the
problem if done correctly.</p>
</blockquote>
<p>So then I get to tell people, "Well, you get to learn <em>this</em> language
to write your document, and then you get to learn <em>that</em> language for
actually making your document look like you want it to." Oh, they'll
love that.</p>
<p>— Marc Andreessen <a href="http://1997.webhistory.org/www.lists/www-talk.1994q1/0683.html"><code>1994</code></a></p>
</blockquote>
<p>Contrary to popular perception, Mosaic was not the first graphical browser.  It
was predated by <a href="https://en.wikipedia.org/wiki/ViolaWWW">ViolaWWW</a>, a graphical
browser originally written by Pei-Yuan Wei in just four days.</p>
<p><img src="https://eager.io/blog/the-languages-which-almost-were-css/images/viola.png" alt="Viola browser screenshot"></p>
<p>Pei-Yuan created a <a href="http://1997.webhistory.org/www.lists/www-talk.1993q4/0264.html">stylesheet
language</a> which
supports a form of the nested structure we are used to in CSS today:</p>
<pre data-lang="scheme"><span>(</span><span>BODY</span> <span>fontSize=normal</span>
      <span>BGColor=white</span>
      <span>FGColor=black</span>
  <span>(</span><span>H1</span>   <span>fontSize=largest</span>
        <span>BGColor=red</span>
        <span>FGColor=white</span><span>)</span>
<span>)</span>
</pre>
<p>In this case we are applying color selections to the body and specifically
styling <code>H1</code>s which appear within the body.  Rather than using repeated selectors
to handle the nesting, PWP used a parenthesis system which is evocative of the
indentation systems used by languages like Stylus and SASS which are preferred
by some developers to CSS today.  This makes PWP’s syntax potentially better in
at least one way than the CSS language which would eventually become the lingua
franca of the web.</p>
<p>PWP is also notable for introducing the method of referring to external
stylesheets we still use today:</p>
<pre data-lang="htmlmixed"><span>&lt;</span><span>LINK</span> <span>REL</span>=<span>"STYLE"</span> <span>HREF</span>=<span>"URL_to_a_stylesheet"</span><span>&gt;</span>
</pre>
<p>ViolaWWW was unfortunately written to work chiefly with the <a href="https://en.wikipedia.org/wiki/X_Window_System">X Windowing
System</a> which was only popular
on Unix systems.  When Mosaic was ported to Windows it quickly left Viola in
the dust.</p>
<h3 id="stylesheets-before-the-web">Stylesheets Before the Web</h3>
<blockquote>
<p>HTML is the kind of thing that can
only be loved by a computer scientist. Yes, it expresses the underlying
structure of a document, but documents are more than just structured text
databases; they have visual impact. HTML totally eliminates any visual
creativity that a document’s designer might have.</p>
<p>— Roy Smith <a href="http://1997.webhistory.org/www.lists/www-talk.1993q3/0238.html"><code>1993</code></a></p>
</blockquote>
<p>The need for a language to express the style of documents long predates the
Internet.</p>
<p>As you may know, HTML as we know it was originally based on a pre-Internet
language called SGML.  In 1987 the US Department of Defense decided to study if
SGML could be used to make it easier to store and transmit the huge volume of
documentation they deal with.  Like any good government project, they wasted no
time coming up with a name.  The team was originally called the Computer-Aided
Logistics Support team, then the Computer-aided Acquisition and Logistics
Support team, then finally the Continuous Acquisition and Life-cycle Support
initiative.  In any case, the initials were CALS.</p>
<p>The CALS team created a language for styling SGML documents called FOSI which
is an initialism which undoubtedly stands for some combination of four words.
They published <a href="http://people.opera.com/howcome/2006/phd/archive/www.dt.navy.mil/tot-shi-sys/tec-inf-sys/cal-std/doc/28001C.pdf">a
specification</a>
for the language which is as comprehensive as it is incomprehensible.  It does
include one of my favorite <a href="http://people.opera.com/howcome/2006/phd/i/fosi.png">nonsensical
infographics</a> to ever
exist on the web.</p>
<p>One inviolate rule of the Internet is: more will always get done if you can
prove someone wrong in the process. In 1993, just four days after Pei-Yuan’s
proposal, Steven Heaney
<a href="http://1997.webhistory.org/www.lists/www-talk.1993q4/0295.html">proposed</a> that
rather than “re-inventing the wheel,” it was best to use a variant of FOSI to
style the web.</p>
<p>A FOSI document is itself written in SGML, which is actually a somewhat logical
move given web developers existing familiarity with the SGML variant HTML.  An
example document looks like this:</p>
<pre data-lang="xml"><span>&lt;</span><span>outspec</span><span>&gt;</span>
  <span>&lt;</span><span>docdesc</span><span>&gt;</span>
    <span>&lt;</span><span>charlist</span><span>&gt;</span>
      <span>&lt;</span><span>font</span> <span>size</span>=<span>"12pt"</span> <span>bckcol</span>=<span>"white"</span> <span>fontcol</span>=<span>"black"</span><span>&gt;</span>
    <span>&lt;/</span><span>charlist</span><span>&gt;</span>
  <span>&lt;/</span><span>docdesc</span><span>&gt;</span>
  <span>&lt;</span><span>e-i-c</span> <span>gi</span>=<span>"h1"</span><span>&gt;</span><span>&lt;</span><span>font</span> <span>size</span>=<span>"24pt"</span> <span>bckcol</span>=<span>"red"</span><span>,</span> <span>fontcol</span>=<span>"white"</span><span>&gt;</span><span>&lt;/</span><span>e-i-c</span><span>&gt;</span>
  <span>&lt;</span><span>e-i-c</span> <span>gi</span>=<span>"h2"</span><span>&gt;</span><span>&lt;</span><span>font</span> <span>size</span>=<span>"20pt"</span> <span>bckcol</span>=<span>"red"</span><span>,</span> <span>fgcol</span>=<span>"white"</span><span>&gt;</span><span>&lt;/</span><span>e-i-c</span><span>&gt;</span>
  <span>&lt;</span><span>e-i-c</span> <span>gi</span>=<span>"a"</span><span>&gt;</span><span>&lt;</span><span>font</span> <span>fgcol</span>=<span>"red"</span><span>&gt;</span><span>&lt;/</span><span>e-i-c</span><span>&gt;</span>
  <span>&lt;</span><span>e-i-c</span> <span>gi</span>=<span>"cmd kbd screen listing example"</span><span>&gt;</span><span>&lt;</span><span>font</span> <span>style</span>=<span>"monoser"</span><span>&gt;</span><span>&lt;/</span><span>e-i-c</span><span>&gt;</span>
<span>&lt;/</span><span>outspec</span><span>&gt;</span>
</pre>
<p>If you’re a bit confused what a <code>docdesc</code> or <code>charlist</code> are, so were the
members of <code>www-talk</code>.  The only contextual information given was that <code>e-i-c</code>
means ‘element in context’.  FOSI is notable however for introducing the <code>em</code>
unit which has now become the preferred method for people who know more about
CSS than you to style things.</p>
<p>The language conflict which was playing out was actually as old as programming
itself.  It was the battle of functional ‘lisp-style’ syntax vs the syntax of more
declarative languages.  Pei-Yuan himself
<a href="http://1997.webhistory.org/www.lists/www-talk.1993q4/0297.html">described</a> his
syntax as “LISP’ish,” but it was only a matter of time until a true LISP
variant entered the stage.</p>
<h3 id="the-turing-complete-stylesheet">The Turing-Complete Stylesheet</h3>
<p>For all its complexity, FOSI was actually perceived to be an <a href="http://xml.coverpages.org/kennDSSSLInt.html">interim
solution</a> to the problem of
formatting documents.  The long-term plan was to create a language based on the
functional programming language Scheme which could enable the most powerful
document transformations you could imagine.  This language was called DSSSL.
In the words of contributor Jon Bosak:</p>
<blockquote>
<p>It’s a mistake to put DSSSL into the same bag as scripting languages. Yes,
DSSSL is Turing-complete; yes, it’s a programming language. But a script
language (at least the way I use the term) is procedural; DSSSL very definitely
is not. DSSSL is entirely functional and entirely side-effect-free. Nothing
ever happens in a DSSSL stylesheet. The stylesheet is one giant function whose
value is an abstract, device-independent, nonprocedural description of the
formatted document that gets fed as a specification (a declaration, if you
will) of display areas to downstream rendering processes.</p>
</blockquote>
<p>At its simplest, DSSSL is actually a pretty reasonable styling language:</p>
<pre data-lang="scheme"><span>(</span><span>element</span> <span>H1</span>
  <span>(</span><span>make</span> <span>paragraph</span>
    <span>font-size:</span> <span>14pt</span>
    <span>font-weight:</span> <span>'</span><span>bold</span><span>)</span><span>)</span>
</pre>
<p>As it was a programming language, you could even define functions:</p>
<pre data-lang="scheme"><span>(</span><span>define</span> <span>(</span><span>create-heading</span> <span>heading-font-size</span><span>)</span>
  <span>(</span><span>make</span> <span>paragraph</span>
    <span>font-size:</span> <span>heading-font-size</span>
    <span>font-weight:</span> <span>'</span><span>bold</span><span>)</span><span>)</span>

<span>(</span><span>element</span> <span>h1</span> <span>(</span><span>create-heading</span> <span>24pt</span><span>)</span><span>)</span>
<span>(</span><span>element</span> <span>h2</span> <span>(</span><span>create-heading</span> <span>18pt</span><span>)</span><span>)</span>
</pre>
<p>And use mathematical constructs in your styling, for example to ‘stripe’ the rows of a table:</p>
<pre data-lang="scheme"><span>(</span><span>element</span> <span>TR</span>
  <span>(</span><span>if</span> <span>(</span><span>=</span> <span>(</span><span>modulo</span> <span>(</span><span>child-number</span><span>)</span> <span>2</span><span>)</span>
        <span>0</span><span>)</span>
    <span>...</span>   
    <span>...</span><span>)</span><span>)</span> 
</pre>
<p>As a final way of kindling your jealousy, DSSSL could treat inherited values as
variables, and do math on them:</p>
<pre data-lang="scheme"><span>(</span><span>element</span> <span>H1</span>
  <span>(</span><span>make</span> <span>paragraph</span>
    <span>font-size:</span> <span>(</span><span>+</span> <span>4pt</span> <span>(</span><span>inherited-font-size</span><span>)</span><span>)</span><span>)</span><span>)</span>
</pre>
<p>DSSSL did, unfortunately, have the fatal flaw which would plague all
Scheme-like languages: too many parenthesis.  Additionally, it was arguably
<em>too complete</em> of a spec when it was finally published, making it intimidating
to browser developers.  The DSSSL spec included over 210 separate styleable
properties.</p>
<p>The team did go on to create <a href="https://en.wikipedia.org/wiki/XSL">XSL</a>, a
language for document transformation which is no less confusing, but which
would be decidedly more popular.</p>
<h3 id="why-did-the-stylesheet-cross-the-wire">Why Did The Stylesheet Cross The Wire</h3>
<p>CSS does not include parent selectors (a method of styling a parent based on
what children it contains).  This fact has been
<a href="http://stackoverflow.com/questions/1014861/is-there-a-css-parent-selector">long</a>
<a href="http://stackoverflow.com/questions/45004/complex-css-selector-for-parent-of-active-child?lq=1">bemoaned</a>
<a href="http://stackoverflow.com/questions/2000582/css-selector-for-foo-that-contains-bar?lq=1">by</a>
<a href="http://stackoverflow.com/questions/4220327/css-selector-element-with-a-given-child?lq=1">Stack</a>
<a href="http://stackoverflow.com/questions/21252551/apply-style-to-parent-if-it-has-child-with-css?lq=1">Overflow</a>
posters, but it turns out there is a very good reason for its absence.
Particularly in the early days of the Internet, it was considered critically
important that the page be renderable before the document has been fully
loaded.  In other words, we want to be able to render the beginning of the HTML
to the page before the HTML which will form the bottom of the page has been
fully downloaded.</p>
<p>A parent selector would mean that styles would have to be updated as the HTML
document loads.  Languages like DSSSL were completely out, as they could
perform operations on the document itself, which would not be entirely
available when the rendering is to begin.</p>
<p>The first contributor to bring up this issue and
<a href="http://people.opera.com/howcome/2006/phd/archive/odur.let.rug.nl/~bert/stylesheets.html">propose</a>
a workable language was Bert Bos in March of 1995.  His proposal also contains
an early edition of the ‘smiley’ emoticon :-).</p>
<p>The language itself was somewhat ‘object-oriented’ in syntax:</p>
<pre data-lang=""><code>*LI.prebreak: 0.5
*LI.postbreak: 0.5
*OL.LI.label: 1
*OL*OL.LI.label: A
</code></pre><p>Using <code>.</code> to signify direct children, and <code>*</code> to specify ancestors.</p>
<p>His language also has the cool property of defining how features like links
work in the stylesheet itself:</p>
<pre data-lang=""><code>*A.anchor: !HREF
</code></pre><p>In this case we specified that the destination of the link element is the value
of its <code>HREF</code> attribute.  This idea, that the behavior of elements like links
should be controllable, was popular in several proposals.  In the era
pre-JavaScript, there was not an existing way of controlling such things, so it
seemed logical to include it in these new proposals.</p>
<p>One functional
<a href="http://people.opera.com/howcome/2006/phd/archive/tigger.cc.uic.edu/~cmsmcq/style-primitives.html">proposal</a>,
introduced in 1994 by a gentleman with the name ‘C.M.
Sperberg-McQueen’, includes the same behavior functionally:</p>
<pre data-lang="scheme"><span>(</span><span>style</span> <span>a</span>
  <span>(</span><span>block</span> <span>#f</span><span>)</span>     
  <span>(</span><span>color</span> <span>blue</span><span>)</span>   
  <span>(</span><span>click</span> <span>(</span><span>follow</span> <span>(</span><span>attval</span> <span>'</span><span>href</span><span>)</span><span>)</span><span>)</span>  
</pre>
<p>His language also introduced the <code>content</code> keyword as a way of controlling the
content of an HTML element from the stylesheet, a concept which was later
introduced into CSS 2.1.</p>
<h3 id="what-might-have-been">What Might Have Been</h3>
<p>Before I talk about the language which actually became CSS, it’s worth
mentioning one other language proposal if only because it is in some ways the
thing of an early web developer’s dreams.</p>
<p>PSL96 was, in the naming convention of the time, the 1996 edition of the
“Presentation Specification Language.”  At its core, PSL looks like CSS:</p>
<pre data-lang="css"><span>H1</span> {
  <span>fontSize</span>: <span>20</span>;
}
</pre>
<p>It quickly gets more interesting however.  For example, you could express
element position based on not just the sizes specified for them (<code>Width</code>), but
the actual (<code>Actual Width</code>) sizes the browser rendered them as:</p>
<pre data-lang="css"><span>LI</span> {
  <span>VertPos</span>: <span>Top</span> = <span>LeftSib</span> . <span>Actual</span> <span>Bottom</span>;
}
</pre>
<p>You’ll also notice you can use the elements left sibling as a constraint.</p>
<p>You can also add logical expressions to your styles.  For example to style only
anchor elements which have <code>hrefs</code>:</p>
<pre data-lang="css"><span>A</span> {
  <span>if</span> (<span>getAttribute</span>(<span>self</span>, <span>"href"</span>) <span>!</span>= <span>""</span>) <span>then</span>
    <span>fgColor</span> = <span>"blue"</span>;
    <span>underlineNumber</span> = <span>1</span>;
  <span>endif</span>
}
</pre>
<p>That styling could be extended to do all manner of things we resort to classes today to accomplish:</p>
<pre data-lang="css"><span>LI</span> {
  <span>if</span> (<span>ChildNum</span>(<span>Self</span>) == <span>round</span>(<span>NumChildren</span>(<span>Parent</span>) / <span>2</span> + <span>1</span>)) <span>then</span>
    <span>VertPos</span>: <span>Top</span> = <span>Parent</span><span>.Top</span>;
    <span>HorizPos</span>: <span>Left</span> = <span>LeftSib</span><span>.Left</span> + <span>Self</span><span>.Width</span>;
  <span>else</span>
    <span>VertPos</span>: <span>Top</span> = <span>LeftSib</span><span>.Actual</span> <span>Bottom</span>;
    <span>HorizPos</span>: <span>Left</span> = <span>LeftSib</span><span>.Left</span>;
  <span>endif</span>
}
</pre>
<p>Support for functionality like this could have perhaps truly enabled the
dream of separating content from style.  Unfortunately this language was
plagued by being a bit too extensible, meaning it would have been very possible
for its implementation to vary considerably from browser to browser.
Additionally, it was published in a series of papers in the academic world,
rather than on the www-talk mailing list where most of the functional work was
being done.  It was never integrated into a mainstream browser.</p>
<h3 id="the-ghost-of-css-past">The Ghost of CSS Past</h3>
<p>The language which, at least in name, would directly lead to CSS was called
CHSS (Cascading HTML Style Sheets),
<a href="http://people.opera.com/howcome/2006/phd/archive/www.w3.org/People/howcome/p/cascade.html">proposed</a>
in 1994 by Håkon W Lie.</p>
<p>Like most good ideas, the original proposal was pretty nutty.</p>
<pre data-lang="css"><span>h1</span><span>.font</span><span>.size</span> = <span>24pt</span> <span>100%</span>
<span>h2</span><span>.font</span><span>.size</span> = <span>20pt</span> <span>40%</span>
</pre>
<p>Note the percentages at the end of rules.  This percentage referred to how much
‘ownership’ the current stylesheet was taking over this value.  For example, if
a previous stylesheet had defined the <code>h2</code> font size as <code>30pt</code>, with <code>60%</code>
ownership, and this stylesheet styled <code>h2</code>s as <code>20px 40%</code>,
the two values would be combined based on their ownership percentage
to get some value around <code>26pt</code>.</p>
<p>It is pretty clear how this proposal was made in the era of document-based HTML
pages, as there is no way compromise-based design would work in our
app-oriented world.  Nevertheless, it did include the fundamental idea that
stylesheets should cascade.  In other words, it should be possible for multiple
stylesheets to be applied to the same page.</p>
<p>It its original formulation, this idea was generally considered important
because it gave the end user control over what they saw.  The
original page would have one stylesheet, and the web user would have his or her
own stylesheet, and the two would be combined to render the page.  Supporting
multiple stylesheets was
viewed as a method of maintaining the personal-freedom of the web, not as a way
of supporting developers (who were still coding individual HTML pages by hand).</p>
<p>The user would even be able to control how much control they gave to the
suggestions of the page’s author, as expressed in an ASCII diagram in the proposal:</p>
<pre data-lang=""><code>       User                   Author
Font   o-----x--------------o 64%
Color  o-x------------------o 90%
Margin o-------------x------o 37%
Volume o---------x----------o 50%
</code></pre><p>Like many of these proposals, it included features which would not make it into
CSS for decades, if ever.  For example, it was possible to write logical
expressions based on the user’s environment:</p>
<pre data-lang=""><code>AGE &gt; 3d ? background.color = pale_yellow : background.color = white
DISPLAY_HEIGHT &gt; 30cm ? http://NYT.com/style : http://LeMonde.fr/style
</code></pre><p>In a somewhat optimistic sci-fi vision of the future, it was believed your
browser would know how relevant a given piece of content was to you, allowing
it to show it to you at a larger size:</p>
<pre data-lang=""><code>RELEVANCE &gt; 80 ? h1.font.size *= 1.5
</code></pre><h3 id="you-know-what-happened-next">You Know What Happened Next</h3>
<blockquote>
<p>Microsoft is absolutely committed to open standards, especially on the Internet.</p>
<p>— John Ludeman <a href="http://1997.webhistory.org/www.lists/www-talk.1994q4/0003.html"><code>1994</code></a></p>
</blockquote>
<p>Håkon Lie went on to simplify his proposal and, working with Bert Bos,
published the first version of the CSS spec in December of 1996.  Ultimately he would
write his doctoral thesis on the creation of CSS, <a href="http://people.opera.com/howcome/2006/phd/">a
document</a> which was heroically
helpful to me in writing this.</p>
<p>Compared to many of the other proposals, one notable fact of CSS is its
simplicity.  It can be easily parsed, easily written, and easily read.  As with
many other examples over the history of the Internet, it was the technology
which was easiest for a beginner to pick up which won, rather than those which
were most powerful for an expert.</p>
<p>It is itself a reminder of how incidental much of this innovation can be.  For
example, support for contextual selectors (<code>body ol li</code>) was only added because
Netscape already had a method for removing borders from images that were
hyperlinks, and it seemed necessary to implement everything the popular browser
could do.  The functionality itself added a significant delay to the
implementation of CSS, as at the time most browsers didn’t keep a ‘stack’ of
tags as they parsed HTML.  This meant the parsers had to be redesigned to
support CSS fully.</p>
<p>Challenges like this (and the widespread use of non-standard HTML tags to
define style) meant CSS was not usable until 1997, and was not fully supported
by any single browser until March of 2000.  As any developer can tell you,
browser support wasn’t anywhere close to standards compliant until just a few
years ago, more than fifteen years after CSS’ release.</p>
<h3 id="the-final-boss">The Final Boss</h3>
<blockquote>
<p>If Netscape 4 ignored CSS rules applied to the <code>&lt;body&gt;</code> element and added random
amounts of whitespace to every structural element on your page, and if IE4 got
<code>&lt;body&gt;</code> right but bungled padding, what kind of CSS was safe to write? Some
developers chose not to write CSS at all. Others wrote one style sheet to
compensate for IE4’s flaws and a different style sheet to compensate for the
blunders of Netscape 4.</p>
<p>— Jeffrey Zeldman</p>
</blockquote>
<p>Internet Explorer 3 famously launched with (somewhat terrible) CSS support. To
compete, it was decided that Netscape 4 should also have support for the
language.  Rather than doubling down on this third (considering HTML and
JavaScript) language though, it was decided it should be implemented by
converting the CSS into JavaScript, and executing it.  Even better, it
was decided this ‘JavaScript Style Sheet’ intermediary language should be
<a href="https://web.archive.org/web/19970709133056/http://home.netscape.com/comprod/products/communicator/guide.html">accessible to web developers</a>.</p>
<p>The syntax is
straight JavaScript, with the addition of some styling-specific
APIs:</p>
<pre data-lang="javascript"><span>tags</span>.<span>H1</span>.<span>color</span> <span>=</span> <span>"blue"</span>;
<span>tags</span>.<span>p</span>.<span>fontSize</span> <span>=</span> <span>"14pt"</span>;
<span>with</span> (<span>tags</span>.<span>H3</span>) {
  <span>color</span> <span>=</span> <span>"green"</span>;
}

<span>classes</span>.<span>punk</span>.<span>all</span>.<span>color</span> <span>=</span> <span>"#00FF00"</span>
<span>ids</span>.<span>z098y</span>.<span>letterSpacing</span> <span>=</span> <span>"0.3em"</span>
</pre>
<p>You could even define functions which would be evaluated <em>every time the tag
was encountered</em>:</p>
<pre data-lang="javascript"><span>evaluate_style</span>() {
  <span>if</span> (<span>color</span> <span>==</span> <span>"red"</span>){
    <span>fontStyle</span> <span>=</span> <span>"italic"</span>;
  } <span>else</span> {
    <span>fontWeight</span> <span>=</span> <span>"bold"</span>;
  }
}

<span>tag</span>.<span>UL</span>.<span>apply</span> <span>=</span> <span>evaluate_style</span>();
</pre>
<p>The idea that we should simplify the dividing line between styles and scripts
is certainly reasonable,
and is now even experiencing a resurgance of sorts in the <a href="https://facebook.github.io/react/tips/inline-styles.html">React community</a>.</p>
<p>JavaScript was itself a very new language at this time, but via some
reverse engineering Internet Explorer had already added support for
it into IE3 (as “JScript”).  The bigger issue was the community had
already rallied around CSS, and Netscape was, at this time, viewed as
<a href="https://lists.w3.org/Archives/Public/www-style/1996Jun/0068.html">bullies</a>
by much of the standards community.  When Netscape did <a href="https://www.w3.org/Submission/1996/1/WD-jsss-960822">submit</a> JSSS to
the standards committee, it fell on deaf ears.  Three years later, Netscape 6 dropped support
for JSSS and it died a (mostly) quiet death.</p>
<h3 id="what-might-have-been">What Might Have Been</h3>
<p>Thanks to some <a href="https://www.w3.org/Style/CSS/Test/CSS1/current/">public shaming</a> by the W3C
, Internet Explorer 5.5 launched with
nearly complete CSS1 support in the year 2000.  Of course, as we now know, browser
CSS implementations were heroically buggy and difficult to work with for at least
another decade.  Today the situation has fortunately improved dramatically,
allowing developers to finally realize the dream of writing code once and
trusting it will function (almost) the same from browser to browser.</p>
<p>My personal conclusion from all of this is the realization of just how arbitrary and contextual
many of the decisions which govern our current tools were.  If CSS was designed
the way it is just to satisfy the constraints of 1996, then maybe that gives
us permission 20 years later to do things a little differently.</p>
<hr>

<p>In our next blog post we expose the tremendous innovation that allowed a copper wire to
evolve from morse code to 10 Gbps Cat6 ethernet. Subscribe below
to be notified when it’s released.</p>
</div></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>