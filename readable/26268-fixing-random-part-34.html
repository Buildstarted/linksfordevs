<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Fixing Random, part&#xA0;34 -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Fixing Random, part&#xA0;34</h1>
    <div class="entry-content"> <p><a href="https://ericlippert.com/2019/06/03/fixing-random-part-33/">Last time on FAIC</a> we implemented a better technique for estimating the expected value of a function <code>f</code> applied to samples from a distribution <code>p</code>:</p>
<ul>
<li>Compute the total area (including negative areas) under the function <code>x =&gt; f(x) * p.Weight(x)</code></li>
<li>Compute the total area under <code>x =&gt; p.Weight(x)</code>
<ul>
<li>This is 1.0 for a normalized PDF, or the normalizing constant of a non-normalized PDF; if we already know it, we don&#x2019;t have to compute it.</li>
</ul>
</li>
<li>The quotient of these areas is the expected value</li>
</ul>
<p>Essentially our technique was to use quadrature to get an approximate numerical solution to an integral calculus problem.</p>
<p>However, we also noted that it seems like there might still be room for improvement, in two main areas:</p>
<ul>
<li>This technique only works when we have a good bound on the support of the distribution; for my contrived example I chose a &#x201C;profit function&#x201D; and a distribution where I said that I was only interested in the region from 0.0 to 1.0.</li>
<li>Our initial intuition that implementing an estimate of &#x201C;average of many samples&#x201D; by, you know, <em>averaging many samples,</em> seems like it was on the right track; can we get back there?</li>
</ul>
<p>In this episode I&#x2019;m going to stick to the restriction to distributions with support over 0.0 to 1.0 for pedagogic reasons, but our aim is to find a technique that gets us back to sampling over arbitrary distributions.</p>
<p>The argument that I&#x2019;m going to make here (several times!) is: <em>two things that are both equal to the same third thing are also equal to each other.</em></p>
<p>Recall that we arrived at our quadrature implementation by estimating that our continuous distribution&#x2019;s expected value is close to the expected value of a very similar discrete distribution. I&#x2019;m going to make my argument a little bit more general here by removing the assumption that <code>p</code> is a normalized distribution. That means that we&#x2019;ll need to know the normalizing factor <code>np</code>, which as we&#x2019;ve noted is <code>Area(p.Weight)</code>.</p>
<p>We said that we could estimate the expected value like this:</p>
<ul>
<li>Imagine that we create a 1000 sided &#x201C;unfair die&#x201D; discrete distribution.</li>
<li>Each side corresponds to a 0.001 wide slice from the range 0.0 to 1.0; let&#x2019;s say that we have a variable <code>x</code> that takes on values 0.000, 0.001, 0.002, and so on, corresponding to the 1000 sides.</li>
<li>The <em>weight</em> of each side is the probability of choosing this slice: <code>p.Weight(x) / 1000 / np</code></li>
<li>The <em>value</em> of each side is the &#x201C;profit function&#x201D; <code>f(x)</code></li>
<li>The expected value of &#x201C;rolling this die&#x201D; is <em>the sum of (value times weight)</em>: the sum of <code>f(x) * (p.Weight(x) / 1000 / np)</code>over our thousand values of <code>x</code></li>
</ul>
<p>Here&#x2019;s the trick:</p>
<ul>
<li>Consider the standard continuous uniform distribution <code>u</code>. That&#x2019;s a perfectly good distribution with support 0.0 to 1.0.</li>
<li>Consider the function <code>w(x)</code> which is <code>x =&gt; f(x) * p.Weight(x) / np</code>.&#xA0; That&#x2019;s a perfectly good function from double to double.</li>
<li>Question: <em>What is an estimate of the expected value of <code>w</code><span> over samples from </span><code>u</code><span>?</span></em></li>
</ul>
<p>We can use the same technique:</p>
<ul>
<li>Imagine we create a 1000-sided &#x201C;unfair die&#x201D; discrete distribution</li>
<li><code>x</code> is as before</li>
<li>The weight of each side is the probability of choosing that slice, but since this is a uniform distribution, every weight is the same &#x2014; so, turns out, it is not an unfair die! The <em>weight</em> of each side is 0.001.</li>
<li>&#xA0;The <em>value</em> of each side is our function <code>w(x)</code></li>
<li>The expected value of rolling this die is <em>the sum of (value times weight):</em> the sum of <code>(f(x) * p.Weight(x) / np) * 0.001</code> over our thousand values of x</li>
</ul>
<p>But compare those two expressions; we are computing exactly the same sum both times. These two expected values must be the same value.</p>
<p>Things equal to the same are equal to each other, which implies this conclusion:</p>
<p><strong>If we can compute an estimate of the expected value of <code>w</code> applied to samples from&#xA0;<code>u</code> by any technique then we have also computed an estimate of the expected value of <code>f</code>&#xA0;applied to samples from&#xA0;<code>p</code>.</strong></p>
<p>Why is this important?</p>
<p>The problem with the na&#xEF;ve algorithm in our original case was that there was a &#x201C;black swan&#x201D; &#x2014; a region of large (negative) area that is sampled only one time in <em>1400</em> samples. But that region is sampled one time in about <em>14</em> samples when we sample from a uniform distribution, so we will get a much better and more consistent estimate of the expected value if we use the na&#xEF;ve technique over the uniform distribution.</p>
<p><strong>In order to get 100x times as many samples in the black swan region, we do not have to do 100x times as many samples overall. We can just sample from a helper distribution that targets that important region more often.</strong></p>
<p>Let&#x2019;s try it! (Code can be found <a href="https://github.com/ericlippert/probability/tree/episode34">here</a>.)</p>
<p>In order to not get confused here, I&#x2019;m going to rename some of our methods so that they&#x2019;re not all called <code>ExpectedValue</code>. The one that just takes any distribution and averages a bunch of samples is now <code>ExpectedValueBySampling</code>&#xA0;and the one that computes two areas and takes their quotient is <code>ExpectedValueByQuadrature</code>.</p>
<p><span><span>var</span><span>&#xA0;</span><span>p</span><span>&#xA0;</span><span>=</span><span>&#xA0;</span><span>Normal</span><span>.</span><span>Distribution</span><span>(</span><span>0.75</span><span>,</span><span>&#xA0;</span><span>0.09</span><span>);</span><br>
<span>double</span><span>&#xA0;</span><span>f</span><span>(</span><span>double</span><span>&#xA0;</span><span>x</span><span>)</span><span>&#xA0;</span><span>=&gt;</span><span>&#xA0;</span><span>Atan</span><span>(</span><span>1000</span><span>&#xA0;</span><span>*</span><span>&#xA0;</span><span>(</span><span>x</span><span>&#xA0;</span><span>&#x2013;</span><span>&#xA0;</span><span>.45</span><span>))</span><span>&#xA0;</span><span>*</span><span>&#xA0;</span><span>20</span><span>&#xA0;</span><span>&#x2013;</span><span>&#xA0;</span><span>31.2</span><span>;</span><br>
<span>var</span><span>&#xA0;</span><span>u</span><span>&#xA0;</span><span>=</span><span>&#xA0;</span><span>StandardContinuousUniform</span><span>.</span><span>Distribution</span><span>;</span><br>
<span>double</span><span>&#xA0;</span><span>np</span><span>&#xA0;</span><span>=</span><span>&#xA0;</span><span>1.0</span><span>;</span><span>&#xA0;</span><span>//&#xA0;p&#xA0;is&#xA0;normalized</span><br>
<span>double</span><span>&#xA0;w</span><span>(</span><span>double</span><span>&#xA0;</span><span>x</span><span>)</span><span>&#xA0;</span><span>=&gt;</span><span>&#xA0;</span><span>f</span><span>(</span><span>x</span><span>)</span><span>&#xA0;</span><span>*</span><span>&#xA0;</span><span>p</span><span>.</span><span>Weight</span><span>(</span><span>x</span><span>)</span><span>&#xA0;</span><span>/</span><span>&#xA0;</span><span>np</span><span>;</span><br>
<span>for</span><span>&#xA0;</span><span>(</span><span>int</span><span>&#xA0;</span><span>i</span><span>&#xA0;</span><span>=</span><span>&#xA0;</span><span>0</span><span>;</span><span>&#xA0;</span><span>i</span><span>&#xA0;</span><span>&lt;</span><span>&#xA0;</span><span>100</span><span>;</span><span>&#xA0;</span><span>++</span><span>i</span><span>)</span><br>
<span>&#xA0; </span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>$&#x201D;</span><span>{</span><span>u</span><span>.</span><span>ExpectedValueBySampling</span><span>(w</span><span>):</span><span>0.###</span><span>}</span><span>&#x201C;</span><span>);</span></span></p>
<p>Remember, the correct answer that we computed by quadrature is <code>0.113</code>. When sampling <code>p</code>&#xA0;directly we got values ranging from <code>0.7</code> to <code>0.14</code>. But now we get:</p>
<pre>0.114, 0.109, 0.109, 0.118, 0.111, 0.107, 0.113, 0.112, ...</pre>
<p>So much better!</p>
<p>This is awesome, but wait, <em>it gets more awesome.</em> What is so special about the uniform distribution? Nothing, that&#x2019;s what. I&#x2019;m going to do this argument one more time:</p>
<p>Suppose I have distribution <code>q</code>, any distribution whatsoever, so long as its support is the same as <code>p</code> &#x2014; in this case, 0.0 to 1.0. In particular, suppose that <code>q</code> is not necessarily a normalized distribution, but that again, <em>we know its normalization factor.</em> Call it <code>nq</code>.&#xA0; Recall that the normalization factor can be computed by <code>nq = Area(q.Weight)</code>.</p>
<p>Our special function <code>g(x)</code> is this oddity:</p>
<p><code>x =&gt; (f(x) * (p.Weight(x) / q.Weight(x)) * (nq / np)</code></p>
<p>What is the expected value of <code>g</code> over distribution <code>q</code>?&#xA0; One more time:</p>
<ul>
<li>Create a 1000-sided unfair die, <code>x</code> as before.</li>
<li>The <strong>weight</strong> of each side is the probability of choosing that side, which is <code>(q.Weight(x) / 1000) / nq</code></li>
<li>The <strong>value</strong> of each side is <code>g(x)</code>.</li>
<li>The expected value is the sum of <code>g(x) * (q.Weight(x) / 1000) / nq</code> but if you work that out, of course that is the sum of <code>f(x) * p.Weight(x) / np / 1000</code></li>
</ul>
<p>And once again, we&#x2019;ve gotten back to the same sum by clever choice of function. <strong>If we can compute the expected value of <code>g</code>evaluated on samples from&#xA0;<code>q</code>, then we know the expected value of <code>f</code> evaluated on samples from&#xA0;<code>p</code>!</strong></p>
<p>This means that we can choose our helper distribution <code>q</code> so that it is highly likely to pick values in regions we consider important. Let&#x2019;s look at our graph of <code>p.Weight</code>&#xA0;and&#xA0;<code>f*p.Weight</code>again:</p>
<p><img class="alignnone size-full wp-image-6303" src="https://ericlippert.files.wordpress.com/2019/06/screen-shot-2019-05-21-at-9.17.06-am.png?w=502" alt="Screen Shot 2019-05-21 at 9.17.06 AM" srcset="https://ericlippert.files.wordpress.com/2019/06/screen-shot-2019-05-21-at-9.17.06-am.png 502w, https://ericlippert.files.wordpress.com/2019/06/screen-shot-2019-05-21-at-9.17.06-am.png?w=150 150w, https://ericlippert.files.wordpress.com/2019/06/screen-shot-2019-05-21-at-9.17.06-am.png?w=300 300w" sizes="(max-width: 502px) 100vw, 502px"></p>
<p>There are segments of the graph where the area under the blue line is very small but the area under the orange line is large, and that&#x2019;s our black swan; <strong>what we want is a distribution that samples from regions where the orange area is large, and if possible skips regions where it is small.</strong> That is, we consider the large-area regions <em>important</em> contributors to the expected value, and the small-area regions <em>unimportant</em> contributors; we wish to target our samples so that no important regions are ignored. That&#x2019;s why<strong> this technique for computing expected value is called &#x201C;importance sampling&#x201D;.</strong></p> <p><strong>Exercise:&#xA0;</strong>The uniform distribution is pretty good on the key requirement that it never be small when the area under the orange line is large, because it is always the same size from 0.0 to 1.0; that&#x2019;s why it is the <em>uniform</em> distribution, after all. It&#x2019;s not great on our second measure; it spends around 30% of its time sampling from regions where the orange line has essentially no area under it.</p>
<p>Write some code that tries different distributions. For example, implement the distribution that has weight function <code>x =&gt; (0 &lt;= x || 1 &lt;= x) ? x : 0</code></p>
<p>(Remember that this is not a normalized distribution, so you&#x2019;ll have to compute <code>nq</code>.)</p>
<p>Does that give us an even better estimate of the expected value of <code>f</code>?</p>
<p>Something to ponder while you&#x2019;re working on that: <em>what would be the ideal choice of distribution?</em></p> <p><strong>Summing up:</strong></p>
<ul>
<li>Suppose we have a weighted distribution of doubles <code>p</code> and a function from double to double <code>f</code>.</li>
<li>We wish to accurately estimate the average value of <code>f</code> when it is applied to a large set of samples from <code>p</code>; this is the <em>expected value.</em></li>
<li>However, there may be &#x201C;black swan&#x201D; regions where the value of <code>f</code> is important to the average, but the probability of sampling from that region is low, so our average could require a huge number of samples to get an accurate average.</li>
<li>We can fix the problem by choosing any weighted distribution <code>q</code> that has the same support as <code>p</code>but is more likely to sample from important regions.</li>
<li>The expected value of <code>g</code>&#xA0;(given above) over samples drawn from <code>q</code> is the same as the expected value of <code>f</code>over samples from&#xA0;<code>p</code>.</li>
</ul>
<p>This is great, and I don&#x2019;t know if you noticed, but I removed any restriction there that <code>p</code> or <code>q</code> be distributions only on 0.0 to 1.0; this technique works for weighted distributions of doubles over any support!</p> <p><strong>Aside:</strong> We can weaken our restriction that <code>q</code> have the same support as <code>p</code>; if we decide that <code>q</code> can have zero weight for particularly unimportant regions, where, say, we know that <code>f(x)*p.Weight(x)</code>&#xA0;is very small, then that&#x2019;s still going to produce a good estimate.</p>
<p><strong>Aside:</strong> Something I probably should have mentioned before is that all of the techniques I&#x2019;m describing in this series for estimating expected values require that the expected value <em>exists</em>! Not all functions applied to probability distributions have an expected value because the average value of the function computed on a group of samples might not converge as the size of the group gets larger. An easy example is, suppose we have a standard normal distribution as our <code>p</code>&#x200B; and <code>x =&gt; 1.0 / p.Weight(x)</code>&#xA0;as our <code>f</code>. The more samples from <code>p</code> we take, the more likely it is that the average value of <code>f</code> gets <em>larger</em>!</p> <p>However, it&#x2019;s not all sunshine and roses. We still have two problems, and they&#x2019;re pretty big ones:</p>
<ul>
<li>How do we find a good-quality <code>q</code> distribution?</li>
<li><strong>We need to know the normalization constants for both distributions.</strong> If we do not know them ahead of time (because, say, we have special knowledge that the continuous uniform distribution is normalized) then how are we going to compute them?&#xA0; <code>Area(p.Weight)</code>&#xA0;or <code>Area(q.Weight)</code> might be expensive or difficult to compute.It seems like in the general case we still have to solve the calculus problem. &#x1F626;</li>
</ul> <p><strong>Aside:</strong> The boldface sentence in my last bullet point contains a small but important error. What is it? Leave your guesses in the comments; the answer will be in an upcoming episode.</p> <p>I&#x2019;m not going to implement a general-purpose importance sampling algorithm until we&#x2019;ve made at least some headway on these remaining problems.</p>
<p><strong>Next time on FAIC:&#xA0; </strong>It&#x2019;s Groundhog Day! I&#x2019;m going to do this entire episode over again; we&#x2019;re going to make a similar argument &#x2014; things equal to the same are equal to each other &#x2014; but starting from a different place. We&#x2019;ll end up with the same result, and deduce that importance sampling works.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>