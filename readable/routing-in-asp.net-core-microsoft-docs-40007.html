<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    
    <meta property="article:author" content="Buildstarted"/>
    <meta property="og:site_name" content="linksfor.dev(s)" />
    <meta property="og:title" content="linksfor.dev(s)" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="A curated list of sources of development information including c#, c++, and other dev related links." />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">ðŸŽ‰</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Routing in ASP.NET Core</title>
<div class="readable">
        <h1>Routing in ASP.NET Core</h1>
        <p>
by Rick-Anderson <br/>Reading time: 97-123 minutes        </p>
        <p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing</a></p>
        <hr/>
<div id="readability-page-1" class="page">


	<div data-bi-name="body">

		<div>

			

			<section>
				<div>


				<div id="main-column">

					<main id="main" role="main" data-bi-name="content" lang="en-us" dir="ltr">



						

						<ul data-bi-name="page info" lang="en-us" dir="ltr">
							<li>
								<time role="presentation" datetime="2019-12-13T00:00:00.000Z" data-article-date-source="ms.date">12/13/2019</time>
							</li>
								<li>83 minutes to read</li>
							<li>
								<a href="https://github.com/aspnet/AspNetCore.Docs/blob/master/aspnetcore/fundamentals/routing.md" title="27 Contributors" aria-label="27 Contributors">
									
								</a>
							</li>

						</ul>

						<nav id="center-doc-outline" data-bi-name="intopic toc" role="navigation" aria-label="Article Outline">
							<h3>In this article</h3>
						<ol><li><a href="#routing-basics">Routing basics</a></li><li><a href="#endpoint-routing">Endpoint routing</a></li><li><a href="#endpoint-routing-differences-from-earlier-versions-of-routing">Endpoint routing differences from earlier versions of routing</a></li><li><a href="#use-routing-middleware">Use Routing Middleware</a></li><li><a href="#route-template-reference">Route template reference</a></li><li><a href="#reserved-routing-names">Reserved routing names</a></li><li><a href="#route-constraint-reference">Route constraint reference</a></li><li><a href="#regular-expressions">Regular expressions</a></li><li><a href="#custom-route-constraints">Custom Route Constraints</a></li><li><a href="#parameter-transformer-reference">Parameter transformer reference</a></li><li><a href="#url-generation-reference">URL generation reference</a></li><li><a href="#complex-segments">Complex segments</a></li><li><a href="#configuring-endpoint-metadata">Configuring endpoint metadata</a></li><li><a href="#host-matching-in-routes-with-requirehost">Host matching in routes with RequireHost</a></li></ol></nav>


						<!-- <content> -->
							
<p>By <a href="https://github.com/rynowak" data-linktype="external">Ryan Nowak</a>, <a href="https://ardalis.com/" data-linktype="external">Steve Smith</a>, and <a href="https://twitter.com/RickAndMSFT" data-linktype="external">Rick Anderson</a></p>
<div data-moniker="aspnetcore-3.0 aspnetcore-3.1">
<p>Routing is responsible for mapping request URIs to endpoints and dispatching incoming requests to those endpoints. Routes are defined in the app and configured when the app starts. A route can optionally extract values from the URL contained in the request, and these values can then be used for request processing. Using route information from the app, routing is also able to generate URLs that map to endpoints. Many apps don't need to add routes beyond what the templates provide. The ASP.NET Core templates for controllers and Razor pages configure route endpoints. If you need to add custom route endpoints, the custom endpoints can be configured alongside template generated route endpoints.</p>

<p><a href="https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples" data-linktype="external">View or download sample code</a> (<a href="https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-3.1#how-to-download-a-sample" data-linktype="relative-path">how to download</a>)</p>
<h2 id="routing-basics">Routing basics<a href="#routing-basics" aria-labelledby="routing-basics"></a></h2>
<p>Most apps should choose a basic and descriptive routing scheme so that URLs are readable and meaningful. The default conventional route <code>{controller=Home}/{action=Index}/{id?}</code>:</p>
<ul>
<li>Supports a basic and descriptive routing scheme.</li>
<li>Is a useful starting point for UI-based apps.</li>
</ul>
<p>Developers commonly add additional terse routes to high-traffic areas of an app in specialized situations (for example, blog and ecommerce endpoints) using <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-3.1#attribute-routing" data-linktype="relative-path">attribute routing</a> or dedicated conventional routes.</p>
<p>Web APIs should use attribute routing to model the app's functionality as a set of resources where operations are represented by HTTP verbs. This means that many operations (for example, GET, POST) on the same logical resource will use the same URL. Attribute routing provides a level of control that's needed to carefully design an API's public endpoint layout.</p>
<p>Razor Pages apps use default conventional routing to serve named resources in the <em>Pages</em> folder of an app. Additional conventions are available that allow you to customize Razor Pages routing behavior. For more information, see <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.1" data-linktype="relative-path">Introduction to Razor Pages in ASP.NET Core</a> and <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/razor-pages-conventions?view=aspnetcore-3.1" data-linktype="relative-path">Razor Pages route and app conventions in ASP.NET Core</a>.</p>
<p>URL generation support allows the app to be developed without hard-coding URLs to link the app together. This support allows for starting with a basic routing configuration and modifying the routes after the app's resource layout is determined.</p>
<p>Routing uses <em>endpoints</em> (<code>Endpoint</code>) to represent logical endpoints in an app.</p>
<p>An endpoint defines a delegate to process requests and a collection of arbitrary metadata. The metadata is used to implement cross-cutting concerns based on policies and configuration attached to each endpoint.</p>
<p>The routing system has the following characteristics:</p>
<ul>
<li><p>Route template syntax is used to define routes with tokenized route parameters.</p>
</li>
<li><p>Conventional-style and attribute-style endpoint configuration is permitted.</p>
</li>
<li><p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> is used to determine whether a URL parameter contains a valid value for a given endpoint constraint.</p>
</li>
<li><p>App models, such as MVC/Razor Pages, register all of their endpoints, which have a predictable implementation of routing scenarios.</p>
</li>
<li><p>The routing implementation makes routing decisions wherever desired in the middleware pipeline.</p>
</li>
<li><p>Middleware that appears after a Routing Middleware can inspect the result of the Routing Middleware's endpoint decision for a given request URI.</p>
</li>
<li><p>It's possible to enumerate all of the endpoints in the app anywhere in the middleware pipeline.</p>
</li>
<li><p>An app can use routing to generate URLs (for example, for redirection or links) based on endpoint information and thus avoid hard-coded URLs, which helps maintainability.</p>
</li>
<li><p>URL generation is based on addresses, which support arbitrary extensibility:</p>
<ul>
<li>The Link Generator API (<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a>) can be resolved anywhere using <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1" data-linktype="relative-path">dependency injection (DI)</a> to generate URLs.</li>
<li>Where the Link Generator API isn't available via DI, <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper" data-linktype="absolute-path">IUrlHelper</a> offers methods to build URLs.</li>
</ul>
</li>
</ul>
<div>
<p><span aria-hidden="true"></span> Note</p>
<p>Endpoint linking is limited to MVC/Razor Pages actions and pages. The expansions of endpoint-linking capabilities is planned for future releases.</p>
</div>
<p>Routing is connected to the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-3.1" data-linktype="relative-path">middleware</a> pipeline by the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.routermiddleware" data-linktype="absolute-path">RouterMiddleware</a> class. <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/overview?view=aspnetcore-3.1" data-linktype="relative-path">ASP.NET Core MVC</a> adds routing to the middleware pipeline as part of its configuration and handles routing in MVC and Razor Pages apps. To learn how to use routing as a standalone component, see the <a href="#use-routing-middleware" data-linktype="self-bookmark">Use Routing Middleware</a> section.</p>
<h3 id="url-matching">URL matching<a href="#url-matching" aria-labelledby="url-matching"></a></h3>
<p>URL matching is the process by which routing dispatches an incoming request to an <em>endpoint</em>. This process is based on data in the URL path but can be extended to consider any data in the request. The ability to dispatch requests to separate handlers is key to scaling the size and complexity of an app.</p>
<p>When a Routing Middleware executes, it sets an endpoint (<code>Endpoint</code>) and route values to a feature on the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext" data-linktype="absolute-path">HttpContext</a>. For the current request:</p>
<ul>
<li>Calling <code>HttpContext.GetEndpoint</code> gets the endpoint.</li>
<li><code>HttpRequest.RouteValues</code> gets the collection of route values.</li>
</ul>
<p>Middleware running after the Routing Middleware can see the endpoint and take action. For example, an Authorization Middleware can interrogate the endpoint's metadata collection for an authorization policy. After all of the middleware in the request processing pipeline is executed, the selected endpoint's delegate is invoked.</p>
<p>The routing system in endpoint routing is responsible for all dispatching decisions. Since the middleware applies policies based on the selected endpoint, it's important that any decision that can affect dispatching or the application of security policies is made inside the routing system.</p>
<p>When the endpoint delegate is executed, the properties of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routecontext.routedata#Microsoft_AspNetCore_Routing_RouteContext_RouteData" data-linktype="absolute-path">RouteContext.RouteData</a> are set to appropriate values based on the request processing performed thus far.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.values" data-linktype="absolute-path">RouteData.Values</a> is a dictionary of <em>route values</em> produced from the route. These values are usually determined by tokenizing the URL and can be used to accept user input or to make further dispatching decisions inside the app.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.datatokens" data-linktype="absolute-path">RouteData.DataTokens</a> is a property bag of additional data related to the matched route. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.datatokens" data-linktype="absolute-path">DataTokens</a> are provided to support associating state data with each route so that the app can make decisions based on which route matched. These values are developer-defined and do <strong>not</strong> affect the behavior of routing in any way. Additionally, values stashed in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.datatokens" data-linktype="absolute-path">RouteData.DataTokens</a> can be of any type, in contrast to <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.values#Microsoft_AspNetCore_Routing_RouteData_Values" data-linktype="absolute-path">RouteData.Values</a>, which must be convertible to and from strings.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">RouteData.Routers</a> is a list of the routes that took part in successfully matching the request. Routes can be nested inside of one another. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">Routers</a> property reflects the path through the logical tree of routes that resulted in a match. Generally, the first item in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">Routers</a> is the route collection and should be used for URL generation. The last item in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">Routers</a> is the route handler that matched.</p>

<h3 id="url-generation-with-linkgenerator">URL generation with LinkGenerator<a href="#url-generation-with-linkgenerator" aria-labelledby="url-generation-with-linkgenerator"></a></h3>
<p>URL generation is the process by which routing can create a URL path based on a set of route values. This allows for a logical separation between your endpoints and the URLs that access them.</p>
<p>Endpoint routing includes the Link Generator API (<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a>). <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> is a singleton service that can be retrieved from DI. The API can be used outside of the context of an executing request. MVC's <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper" data-linktype="absolute-path">IUrlHelper</a> and scenarios that rely on <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper" data-linktype="absolute-path">IUrlHelper</a>, such as <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-3.1" data-linktype="relative-path">Tag Helpers</a>, HTML Helpers, and <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/actions?view=aspnetcore-3.1" data-linktype="relative-path">Action Results</a>, use the link generator to provide link generating capabilities.</p>
<p>The link generator is backed by the concept of an <em>address</em> and <em>address schemes</em>. An address scheme is a way of determining the endpoints that should be considered for link generation. For example, the route name and route values scenarios many users are familiar with from MVC/Razor Pages are implemented as an address scheme.</p>
<p>The link generator can link to MVC/Razor Pages actions and pages via the following extension methods:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.controllerlinkgeneratorextensions.getpathbyaction" data-linktype="absolute-path">GetPathByAction</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.controllerlinkgeneratorextensions.geturibyaction" data-linktype="absolute-path">GetUriByAction</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.pagelinkgeneratorextensions.getpathbypage" data-linktype="absolute-path">GetPathByPage</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.pagelinkgeneratorextensions.geturibypage" data-linktype="absolute-path">GetUriByPage</a></li>
</ul>
<p>An overload of these methods accepts arguments that include the <code>HttpContext</code>. These methods are functionally equivalent to <code>Url.Action</code> and <code>Url.Page</code> but offer additional flexibility and options.</p>
<p>The <code>GetPath*</code> methods are most similar to <code>Url.Action</code> and <code>Url.Page</code> in that they generate a URI containing an absolute path. The <code>GetUri*</code> methods always generate an absolute URI containing a scheme and host. The methods that accept an <code>HttpContext</code> generate a URI in the context of the executing request. The ambient route values, URL base path, scheme, and host from the executing request are used unless overridden.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> is called with an address. Generating a URI occurs in two steps:</p>
<ol>
<li>An address is bound to a list of endpoints that match the address.</li>
<li>Each endpoint's <code>RoutePattern</code> is evaluated until a route pattern that matches the supplied values is found. The resulting output is combined with the other URI parts supplied to the link generator and returned.</li>
</ol>
<p>The methods provided by <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> support standard link generation capabilities for any type of address. The most convenient way to use the link generator is through extension methods that perform operations for a specific address type.</p>

<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Pay attention to the following implications of calling <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> methods:</p>
<ul>
<li><p>Use <code>GetUri*</code> extension methods with caution in an app configuration that doesn't validate the <code>Host</code> header of incoming requests. If the <code>Host</code> header of incoming requests isn't validated, untrusted request input can be sent back to the client in URIs in a view/page. We recommend that all production apps configure their server to validate the <code>Host</code> header against known valid values.</p>
</li>
<li><p>Use <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> with caution in middleware in combination with <code>Map</code> or <code>MapWhen</code>. <code>Map*</code> changes the base path of the executing request, which affects the output of link generation. All of the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> APIs allow specifying a base path. Always specify an empty base path to undo <code>Map*</code>'s affect on link generation.</p>
</li>
</ul>
</div>
<h2 id="endpoint-routing">Endpoint routing<a href="#endpoint-routing" aria-labelledby="endpoint-routing"></a></h2>
<ul>
<li>A route endpoint has a template, metadata, and a request delegate that serves the endpoint's response. The metadata is used to implement cross-cutting concerns based on policies and configuration attached to each endpoint. For example, an authorization middleware can interrogate the endpoint's metadata collection for an <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-3.1#applying-policies-to-mvc-controllers" data-linktype="relative-path">authorization policy</a>.</li>
<li>Endpoint routing integrates with middleware using two extension methods:
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.userouting" data-linktype="absolute-path">UseRouting</a> adds route matching to the middleware pipeline. It must come before any route-aware middleware such as authorization, endpoint execution, etc.</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.useendpoints" data-linktype="absolute-path">UseEndpoints</a> adds endpoint execution to the middleware pipeline. It runs the request delegate that serves the endpoint's response.
<code>UseEndpoints</code> is also where route endpoints are configured that can be matched and executed by the app. For example, <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.razorpagesendpointroutebuilderextensions.maprazorpages" data-linktype="absolute-path">MapRazorPages</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollers" data-linktype="absolute-path">MapControllers</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a>, and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutebuilderextensions.mappost" data-linktype="absolute-path">MapPost</a>.</li>
</ul>
</li>
<li>Apps use ASP.NET Core's helper methods to configure their routes. ASP.NET Core frameworks provide helper methods like <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.razorpagesendpointroutebuilderextensions.maprazorpages" data-linktype="absolute-path">MapRazorPages</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollers" data-linktype="absolute-path">MapControllers</a> and <code>MapHub&lt;THub&gt;</code>. There are also helper methods for configuring your own custom route endpoints: <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutebuilderextensions.mappost" data-linktype="absolute-path">MapPost</a>, and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutebuilderextensions" data-linktype="absolute-path">MapVerb</a>.</li>
<li>Endpoint routing also supports endpoints changing after an application has started up. To support this in your app or ASP.NET Core framework, a custom <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.endpointdatasource" data-linktype="absolute-path">EndpointDataSource</a> must be created and registered. This is an advanced feature, and usually not needed. Endpoints are typically configured at startup and are static for the lifetime of the app. Loading route configuration from a file or database at startup is not dynamic.</li>
</ul>
<p>The following code shows a basic example of endpoint routing:</p>
<pre tabindex="0"><code data-author-content="public void Configure(IApplicationBuilder app)
{
    // Matches request to an endpoint.
    app.UseRouting();

    // Endpoint aware middleware. 
    // Middleware can use metadata from the matched endpoint.
    app.UseAuthorization();

    // Execute the matched endpoint.
    app.UseEndpoints(endpoints =>
    {
        // Configuration of app endpoints.
        endpoints.MapRazorPages();
        endpoints.MapGet(&quot;/&quot;, context => context.Response.WriteAsync(&quot;Hello world&quot;));
        endpoints.MapHealthChecks(&quot;/healthz&quot;);
    });
}
">public void Configure(IApplicationBuilder app)
{
    // Matches request to an endpoint.
    app.UseRouting();

    // Endpoint aware middleware. 
    // Middleware can use metadata from the matched endpoint.
    app.UseAuthorization();

    // Execute the matched endpoint.
    app.UseEndpoints(endpoints =&gt;
    {
        // Configuration of app endpoints.
        endpoints.MapRazorPages();
        endpoints.MapGet("/", context =&gt; context.Response.WriteAsync("Hello world"));
        endpoints.MapHealthChecks("/healthz");
    });
}
</code></pre>
<p>See <a href="#url-matching" data-linktype="self-bookmark">URL matching</a> in this document for more information on endpoint routing.</p>
<h2 id="endpoint-routing-differences-from-earlier-versions-of-routing">Endpoint routing differences from earlier versions of routing<a href="#endpoint-routing-differences-from-earlier-versions-of-routing" aria-labelledby="endpoint-routing-differences-from-earlier-versions-of-routing"></a></h2>
<p>A few differences exist between endpoint routing and versions of routing earlier than in ASP.NET Core 2.2:</p>
<ul>
<li><p>The endpoint routing system doesn't support <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter" data-linktype="absolute-path">IRouter</a>-based extensibility, including inheriting from <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a>.</p>
</li>
<li><p>Endpoint routing doesn't support <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.WebApiCompatShim" data-linktype="external">WebApiCompatShim</a>. Use the 2.1 <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/compatibility-version?view=aspnetcore-3.1" data-linktype="relative-path">compatibility version</a> (<code>.SetCompatibilityVersion(CompatibilityVersion.Version_2_1)</code>) to continue using the compatibility shim.</p>
</li>
<li><p>Endpoint Routing has different behavior for the casing of generated URIs when using conventional routes.</p>
<p>Consider the following default route template:</p>
<pre tabindex="0"><code data-author-content="app.UseMvc(routes =>
{
    routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
});
">app.UseMvc(routes =&gt;
{
    routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
});
</code></pre>
<p>Suppose you generate a link to an action using the following route:</p>
<pre tabindex="0"><code data-author-content="var link = Url.Action(&quot;ReadPost&quot;, &quot;blog&quot;, new { id = 17, });
">var link = Url.Action("ReadPost", "blog", new { id = 17, });
</code></pre>
<p>With <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter" data-linktype="absolute-path">IRouter</a>-based routing, this code generates a URI of <code>/blog/ReadPost/17</code>, which respects the casing of the provided route value. Endpoint routing in ASP.NET Core 2.2 or later produces <code>/Blog/ReadPost/17</code> ("Blog" is capitalized). Endpoint routing provides the <code>IOutboundParameterTransformer</code> interface that can be used to customize this behavior globally or to apply different conventions for mapping URLs.</p>
<p>For more information, see the <a href="#parameter-transformer-reference" data-linktype="self-bookmark">Parameter transformer reference</a> section.</p>
</li>
<li><p>Link Generation used by MVC/Razor Pages with conventional routes behaves differently when attempting to link to an controller/action or page that doesn't exist.</p>
<p>Consider the following default route template:</p>
<pre tabindex="0"><code data-author-content="app.UseMvc(routes =>
{
    routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
});
">app.UseMvc(routes =&gt;
{
    routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
});
</code></pre>
<p>Suppose you generate a link to an action using the default template with the following:</p>
<pre tabindex="0"><code data-author-content="var link = Url.Action(&quot;ReadPost&quot;, &quot;Blog&quot;, new { id = 17, });
">var link = Url.Action("ReadPost", "Blog", new { id = 17, });
</code></pre>
<p>With <code>IRouter</code>-based routing, the result is always <code>/Blog/ReadPost/17</code>, even if the <code>BlogController</code> doesn't exist or doesn't have a <code>ReadPost</code> action method. As expected, endpoint routing in ASP.NET Core 2.2 or later produces <code>/Blog/ReadPost/17</code> if the action method exists. <em>However, endpoint routing produces an empty string if the action doesn't exist.</em> Conceptually, endpoint routing doesn't assume that the endpoint exists if the action doesn't exist.</p>
</li>
<li><p>The link generation <em>ambient value invalidation algorithm</em> behaves differently when used with endpoint routing.</p>
<p><em>Ambient value invalidation</em> is the algorithm that decides which route values from the currently executing request (the ambient values) can be used in link generation operations. Conventional routing always invalidated extra route values when linking to a different action. Attribute routing didn't have this behavior prior to the release of ASP.NET Core 2.2. In earlier versions of ASP.NET Core, links to another action that use the same route parameter names resulted in link generation errors. In ASP.NET Core 2.2 or later, both forms of routing invalidate values when linking to another action.</p>
<p>Consider the following example in ASP.NET Core 2.1 or earlier. When linking to another action (or another page), route values can be reused in undesirable ways.</p>
<p>In <em>/Pages/Store/Product.cshtml</em>:</p>
<pre tabindex="0"><code data-author-content="@page &quot;{id}&quot;
@Url.Page(&quot;/Login&quot;)
">@page "{id}"
@Url.Page("/Login")
</code></pre>
<p>In <em>/Pages/Login.cshtml</em>:</p>
<pre tabindex="0"><code data-author-content="@page &quot;{id?}&quot;
">@page "{id?}"
</code></pre>
<p>If the URI is <code>/Store/Product/18</code> in ASP.NET Core 2.1 or earlier, the link generated on the Store/Info page by <code>@Url.Page("/Login")</code> is <code>/Login/18</code>. The <code>id</code> value of 18 is reused, even though the link destination is different part of the app entirely. The <code>id</code> route value in the context of the <code>/Login</code> page is probably a user ID value, not a store product ID value.</p>
<p>In endpoint routing with ASP.NET Core 2.2 or later, the result is <code>/Login</code>. Ambient values aren't reused when the linked destination is a different action or page.</p>
</li>
<li><p>Round-tripping route parameter syntax: Forward slashes aren't encoded when using a double-asterisk (<code>**</code>) catch-all parameter syntax.</p>
<p>During link generation, the routing system encodes the value captured in a double-asterisk (<code>**</code>) catch-all parameter (for example, <code>{**myparametername}</code>) except the forward slashes. The double-asterisk catch-all is supported with <code>IRouter</code>-based routing in ASP.NET Core 2.2 or later.</p>
<p>The single asterisk catch-all parameter syntax in prior versions of ASP.NET Core (<code>{*myparametername}</code>) remains supported, and forward slashes are encoded.</p>

</li>
</ul>
<h3 id="middleware-example">Middleware example<a href="#middleware-example" aria-labelledby="middleware-example"></a></h3>
<p>In the following example, a middleware uses the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> API to create link to an action method that lists store products. Using the link generator by injecting it into a class and calling <code>GenerateLink</code> is available to any class in an app.</p>
<pre tabindex="0"><code data-author-content="using Microsoft.AspNetCore.Routing;

public class ProductsLinkMiddleware
{
    private readonly LinkGenerator _linkGenerator;

    public ProductsLinkMiddleware(RequestDelegate next, LinkGenerator linkGenerator)
    {
        _linkGenerator = linkGenerator;
    }

    public async Task InvokeAsync(HttpContext httpContext)
    {
        var url = _linkGenerator.GetPathByAction(&quot;ListProducts&quot;, &quot;Store&quot;);

        httpContext.Response.ContentType = &quot;text/plain&quot;;

        await httpContext.Response.WriteAsync($&quot;Go to {url} to see our products.&quot;);
    }
}
">using Microsoft.AspNetCore.Routing;

public class ProductsLinkMiddleware
{
    private readonly LinkGenerator _linkGenerator;

    public ProductsLinkMiddleware(RequestDelegate next, LinkGenerator linkGenerator)
    {
        _linkGenerator = linkGenerator;
    }

    public async Task InvokeAsync(HttpContext httpContext)
    {
        var url = _linkGenerator.GetPathByAction("ListProducts", "Store");

        httpContext.Response.ContentType = "text/plain";

        await httpContext.Response.WriteAsync($"Go to {url} to see our products.");
    }
}
</code></pre>
<h3 id="create-routes">Create routes<a href="#create-routes" aria-labelledby="create-routes"></a></h3>
<p>Most apps create routes by calling <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> or one of the similar extension methods defined on <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iroutebuilder" data-linktype="absolute-path">IRouteBuilder</a>. Any of the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iroutebuilder" data-linktype="absolute-path">IRouteBuilder</a> extension methods create an instance of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> and add it to the route collection.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> doesn't accept a route handler parameter. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> only adds routes that are handled by the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routebuilder.defaulthandler" data-linktype="absolute-path">DefaultHandler</a>. To learn more about routing in MVC, see <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-3.1" data-linktype="relative-path">Routing to controller actions in ASP.NET Core</a>.</p>
<p>The following code example is an example of a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> call used by a typical ASP.NET Core MVC route definition:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<p>This template matches a URL path and extracts the route values. For example, the path <code>/Products/Details/17</code> generates the following route values: <code>{ controller = Products, action = Details, id = 17 }</code>.</p>
<p>Route values are determined by splitting the URL path into segments and matching each segment with the <em>route parameter</em> name in the route template. Route parameters are named. The parameters defined by enclosing the parameter name in braces <code>{ ... }</code>.</p>
<p>The preceding template could also match the URL path <code>/</code> and produce the values <code>{ controller = Home, action = Index }</code>. This occurs because the <code>{controller}</code> and <code>{action}</code> route parameters have default values and the <code>id</code> route parameter is optional. An equals sign (<code>=</code>) followed by a value after the route parameter name defines a default value for the parameter. A question mark (<code>?</code>) after the route parameter name defines an optional parameter.</p>
<p>Route parameters with a default value <em>always</em> produce a route value when the route matches. Optional parameters don't produce a route value if there was no corresponding URL path segment. See the <a href="#route-template-reference" data-linktype="self-bookmark">Route template reference</a> section for a thorough description of route template scenarios and syntax.</p>
<p>In the following example, the route parameter definition <code>{id:int}</code> defines a <a href="#route-constraint-reference" data-linktype="self-bookmark">route constraint</a> for the <code>id</code> route parameter:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id:int}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id:int}");
</code></pre>
<p>This template matches a URL path like <code>/Products/Details/17</code> but not <code>/Products/Details/Apples</code>. Route constraints implement <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> and inspect route values to verify them. In this example, the route value <code>id</code> must be convertible to an integer. See <a href="#route-constraint-reference" data-linktype="self-bookmark">route-constraint-reference</a> for an explanation of route constraints provided by the framework.</p>
<p>Additional overloads of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> accept values for <code>constraints</code>, <code>dataTokens</code>, and <code>defaults</code>. The typical usage of these parameters is to pass an anonymously typed object, where the property names of the anonymous type match route parameter names.</p>
<p>The following <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> examples create equivalent routes:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default_route&quot;,
    template: &quot;{controller}/{action}/{id?}&quot;,
    defaults: new { controller = &quot;Home&quot;, action = &quot;Index&quot; });

routes.MapRoute(
    name: &quot;default_route&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default_route",
    template: "{controller}/{action}/{id?}",
    defaults: new { controller = "Home", action = "Index" });

routes.MapRoute(
    name: "default_route",
    template: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>The inline syntax for defining constraints and defaults can be convenient for simple routes. However, there are scenarios, such as data tokens, that aren't supported by inline syntax.</p>
</div>
<p>The following example demonstrates a few additional scenarios:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;blog&quot;,
    template: &quot;Blog/{**article}&quot;,
    defaults: new { controller = &quot;Blog&quot;, action = &quot;ReadArticle&quot; });
">routes.MapRoute(
    name: "blog",
    template: "Blog/{**article}",
    defaults: new { controller = "Blog", action = "ReadArticle" });
</code></pre>
<p>The preceding template matches a URL path like <code>/Blog/All-About-Routing/Introduction</code> and extracts the values <code>{ controller = Blog, action = ReadArticle, article = All-About-Routing/Introduction }</code>. The default route values for <code>controller</code> and <code>action</code> are produced by the route even though there are no corresponding route parameters in the template. Default values can be specified in the route template. The <code>article</code> route parameter is defined as a <em>catch-all</em> by the appearance of an double asterisk (<code>**</code>) before the route parameter name. Catch-all route parameters capture the remainder of the URL path and can also match the empty string.</p>
<p>The following example adds route constraints and data tokens:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;us_english_products&quot;,
    template: &quot;en-US/Products/{id}&quot;,
    defaults: new { controller = &quot;Products&quot;, action = &quot;Details&quot; },
    constraints: new { id = new IntRouteConstraint() },
    dataTokens: new { locale = &quot;en-US&quot; });
">routes.MapRoute(
    name: "us_english_products",
    template: "en-US/Products/{id}",
    defaults: new { controller = "Products", action = "Details" },
    constraints: new { id = new IntRouteConstraint() },
    dataTokens: new { locale = "en-US" });
</code></pre>
<p>The preceding template matches a URL path like <code>/en-US/Products/5</code> and extracts the values <code>{ controller = Products, action = Details, id = 5 }</code> and the data tokens <code>{ locale = en-US }</code>.</p>
<p><img src="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing/_static/tokens.png?view=aspnetcore-3.1" alt="Locals Windows tokens" data-linktype="relative-path"></p>
<h3 id="route-class-url-generation">Route class URL generation<a href="#route-class-url-generation" aria-labelledby="route-class-url-generation"></a></h3>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> class can also perform URL generation by combining a set of route values with its route template. This is logically the reverse process of matching the URL path.</p>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>To better understand URL generation, imagine what URL you want to generate and then think about how a route template would match that URL. What values would be produced? This is the rough equivalent of how URL generation works in the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> class.</p>
</div>
<p>The following example uses a general ASP.NET Core MVC default route:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<p>With the route values <code>{ controller = Products, action = List }</code>, the URL <code>/Products/List</code> is generated. The route values are substituted for the corresponding route parameters to form the URL path. Since <code>id</code> is an optional route parameter, the URL is successfully generated without a value for <code>id</code>.</p>
<p>With the route values <code>{ controller = Home, action = Index }</code>, the URL <code>/</code> is generated. The provided route values match the default values, and the segments corresponding to the default values are safely omitted.</p>
<p>Both URLs generated round-trip with the following route definition (<code>/Home/Index</code> and <code>/</code>) produce the same route values that were used to generate the URL.</p>
<div>
<p><span aria-hidden="true"></span> Note</p>
<p>An app using ASP.NET Core MVC should use <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routing.urlhelper" data-linktype="absolute-path">UrlHelper</a> to generate URLs instead of calling into routing directly.</p>
</div>
<p>For more information on URL generation, see the <a href="#url-generation-reference" data-linktype="self-bookmark">Url generation reference</a> section.</p>
<h2 id="use-routing-middleware">Use Routing Middleware<a href="#use-routing-middleware" aria-labelledby="use-routing-middleware"></a></h2>
<p>Reference the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/metapackage-app?view=aspnetcore-3.1" data-linktype="relative-path">Microsoft.AspNetCore.App metapackage</a> in the app's project file.</p>
<p>Add routing to the service container in <code>Startup.ConfigureServices</code>:</p>
<pre tabindex="0"><code highlight-lines="3" data-author-content="public void ConfigureServices(IServiceCollection services)
{
    services.AddRouting();
}
">public void ConfigureServices(IServiceCollection services)
{
    services.AddRouting();
}
</code></pre>
<p>Routes must be configured in the <code>Startup.Configure</code> method. The sample app uses the following APIs:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routebuilder" data-linktype="absolute-path">RouteBuilder</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a> â€“ Matches only HTTP GET requests.</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.routingbuilderextensions.userouter" data-linktype="absolute-path">UseRouter</a></li>
</ul>
<pre tabindex="0"><code data-author-content="var trackPackageRouteHandler = new RouteHandler(context =>
{
    var routeValues = context.GetRouteData().Values;
    return context.Response.WriteAsync(
        $&quot;Hello! Route values: {string.Join(&quot;, &quot;, routeValues)}&quot;);
});

var routeBuilder = new RouteBuilder(app, trackPackageRouteHandler);

routeBuilder.MapRoute(
    &quot;Track Package Route&quot;,
    &quot;package/{operation:regex(^track|create$)}/{id:int}&quot;);

routeBuilder.MapGet(&quot;hello/{name}&quot;, context =>
{
    var name = context.GetRouteValue(&quot;name&quot;);
    // The route handler when HTTP GET &quot;hello/<anything>&quot; matches
    // To match HTTP GET &quot;hello/<anything>/<anything>, 
    // use routeBuilder.MapGet(&quot;hello/{*name}&quot;
    return context.Response.WriteAsync($&quot;Hi, {name}!&quot;);
});

var routes = routeBuilder.Build();
app.UseRouter(routes);
">var trackPackageRouteHandler = new RouteHandler(context =&gt;
{
    var routeValues = context.GetRouteData().Values;
    return context.Response.WriteAsync(
        $"Hello! Route values: {string.Join(", ", routeValues)}");
});

var routeBuilder = new RouteBuilder(app, trackPackageRouteHandler);

routeBuilder.MapRoute(
    "Track Package Route",
    "package/{operation:regex(^track|create$)}/{id:int}");

routeBuilder.MapGet("hello/{name}", context =&gt;
{
    var name = context.GetRouteValue("name");
    // The route handler when HTTP GET "hello/&lt;anything&gt;" matches
    // To match HTTP GET "hello/&lt;anything&gt;/&lt;anything&gt;, 
    // use routeBuilder.MapGet("hello/{*name}"
    return context.Response.WriteAsync($"Hi, {name}!");
});

var routes = routeBuilder.Build();
app.UseRouter(routes);
</code></pre>
<p>The following table shows the responses with the given URIs.</p>

<p>The framework provides a set of extension methods for creating routes (<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions" data-linktype="absolute-path">RequestDelegateRouteBuilderExtensions</a>):</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapdelete" data-linktype="absolute-path">MapDelete</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewaredelete" data-linktype="absolute-path">MapMiddlewareDelete</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareget" data-linktype="absolute-path">MapMiddlewareGet</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewarepost" data-linktype="absolute-path">MapMiddlewarePost</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareput" data-linktype="absolute-path">MapMiddlewarePut</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareroute" data-linktype="absolute-path">MapMiddlewareRoute</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareverb" data-linktype="absolute-path">MapMiddlewareVerb</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mappost" data-linktype="absolute-path">MapPost</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapput" data-linktype="absolute-path">MapPut</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapverb" data-linktype="absolute-path">MapVerb</a></li>
</ul>
<p>The <code>Map[Verb]</code> methods use constraints to limit the route to the HTTP Verb in the method name. For example, see <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapverb" data-linktype="absolute-path">MapVerb</a>.</p>
<h2 id="route-template-reference">Route template reference<a href="#route-template-reference" aria-labelledby="route-template-reference"></a></h2>
<p>Tokens within curly braces (<code>{ ... }</code>) define <em>route parameters</em> that are bound if the route is matched. You can define more than one route parameter in a route segment, but they must be separated by a literal value. For example, <code>{controller=Home}{action=Index}</code> isn't a valid route, since there's no literal value between <code>{controller}</code> and <code>{action}</code>. These route parameters must have a name and may have additional attributes specified.</p>
<p>Literal text other than route parameters (for example, <code>{id}</code>) and the path separator <code>/</code> must match the text in the URL. Text matching is case-insensitive and based on the decoded representation of the URLs path. To match a literal route parameter delimiter (<code>{</code> or <code>}</code>), escape the delimiter by repeating the character (<code>{{</code> or <code>}}</code>).</p>
<p>URL patterns that attempt to capture a file name with an optional file extension have additional considerations. For example, consider the template <code>files/{filename}.{ext?}</code>. When values for both <code>filename</code> and <code>ext</code> exist, both values are populated. If only a value for <code>filename</code> exists in the URL, the route matches because the trailing period (<code>.</code>) is  optional. The following URLs match this route:</p>
<ul>
<li><code>/files/myFile.txt</code></li>
<li><code>/files/myFile</code></li>
</ul>
<p>You can use an asterisk (<code>*</code>) or double asterisk (<code>**</code>) as a prefix to a route parameter to bind to the rest of the URI. These are called a <em>catch-all</em> parameters. For example, <code>blog/{**slug}</code> matches any URI that starts with <code>/blog</code> and has any value following it, which is assigned to the <code>slug</code> route value. Catch-all parameters can also match the empty string.</p>
<p>The catch-all parameter escapes the appropriate characters when the route is used to generate a URL, including path separator (<code>/</code>) characters. For example, the route <code>foo/{*path}</code> with route values <code>{ path = "my/path" }</code> generates <code>foo/my%2Fpath</code>. Note the escaped forward slash. To round-trip path separator characters, use the <code>**</code> route parameter prefix. The route <code>foo/{**path}</code> with <code>{ path = "my/path" }</code> generates <code>foo/my/path</code>.</p>
<p>Route parameters may have <em>default values</em> designated by specifying the default value after the parameter name separated by an equals sign (<code>=</code>). For example, <code>{controller=Home}</code> defines <code>Home</code> as the default value for <code>controller</code>. The default value is used if no value is present in the URL for the parameter. Route parameters are made optional by appending a question mark (<code>?</code>) to the end of the parameter name, as in <code>id?</code>. The difference between optional values and default route parameters is that a route parameter with a default value always produces a valueâ€”an optional parameter has a value only when a value is provided by the request URL.</p>
<p>Route parameters may have constraints that must match the route value bound from the URL. Adding a colon (<code>:</code>) and constraint name after the route parameter name specifies an <em>inline constraint</em> on a route parameter. If the constraint requires arguments, they're enclosed in parentheses (<code>(...)</code>) after the constraint name. Multiple inline constraints can be specified by appending another colon (<code>:</code>) and constraint name.</p>
<p>The constraint name and arguments are passed to the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iinlineconstraintresolver" data-linktype="absolute-path">IInlineConstraintResolver</a> service to create an instance of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> to use in URL processing. For example, the route template <code>blog/{article:minlength(10)}</code> specifies a <code>minlength</code> constraint with the argument <code>10</code>. For more information on route constraints and a list of the constraints provided by the framework, see the <a href="#route-constraint-reference" data-linktype="self-bookmark">Route constraint reference</a> section.</p>
<p>Route parameters may also have parameter transformers, which transform a parameter's value when generating links and matching actions and pages to URLs. Like constraints, parameter transformers can be added inline to a route parameter by adding a colon (<code>:</code>) and transformer name after the route parameter name. For example, the route template <code>blog/{article:slugify}</code> specifies a <code>slugify</code> transformer. For more information on parameter transformers, see the <a href="#parameter-transformer-reference" data-linktype="self-bookmark">Parameter transformer reference</a> section.</p>
<p>The following table demonstrates example route templates and their behavior.</p>

<p>Using a template is generally the simplest approach to routing. Constraints and defaults can also be specified outside the route template.</p>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>Enable <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-3.1" data-linktype="relative-path">Logging</a> to see how the built-in routing implementations, such as <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a>, match requests.</p>
</div>
<h2 id="reserved-routing-names">Reserved routing names<a href="#reserved-routing-names" aria-labelledby="reserved-routing-names"></a></h2>
<p>The following keywords are reserved names and can't be used as route names or parameters:</p>
<ul>
<li><code>action</code></li>
<li><code>area</code></li>
<li><code>controller</code></li>
<li><code>handler</code></li>
<li><code>page</code></li>
</ul>
<h2 id="route-constraint-reference">Route constraint reference<a href="#route-constraint-reference" aria-labelledby="route-constraint-reference"></a></h2>
<p>Route constraints execute when a match has occurred to the incoming URL and the URL path is tokenized into route values. Route constraints generally inspect the route value associated via the route template and make a yes/no decision about whether or not the value is acceptable. Some route constraints use data outside the route value to consider whether the request can be routed. For example, the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.constraints.httpmethodrouteconstraint" data-linktype="absolute-path">HttpMethodRouteConstraint</a> can accept or reject a request based on its HTTP verb. Constraints are used in routing requests and link generation.</p>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Don't use constraints for <strong>input validation</strong>. If constraints are used for <strong>input validation</strong>, invalid input results in a <em>404 - Not Found</em> response instead of a <em>400 - Bad Request</em> with an appropriate error message. Route constraints are used to <strong>disambiguate</strong> similar routes, not to validate the inputs for a particular route.</p>
</div>
<p>The following table demonstrates example route constraints and their expected behavior.</p>

<p>Multiple, colon-delimited constraints can be applied to a single parameter. For example, the following constraint restricts a parameter to an integer value of 1 or greater:</p>
<pre tabindex="0"><code data-author-content="[Route(&quot;users/{id:int:min(1)}&quot;)]
public User GetUserById(int id) { }
">[Route("users/{id:int:min(1)}")]
public User GetUserById(int id) { }
</code></pre>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Route constraints that verify the URL and are converted to a CLR type (such as <code>int</code> or <code>DateTime</code>) always use the invariant culture. These constraints assume that the URL is non-localizable. The framework-provided route constraints don't modify the values stored in route values. All route values parsed from the URL are stored as strings. For example, the <code>float</code> constraint attempts to convert the route value to a float, but the converted value is used only to verify it can be converted to a float.</p>
</div>
<h2 id="regular-expressions">Regular expressions<a href="#regular-expressions" aria-labelledby="regular-expressions"></a></h2>
<p>The ASP.NET Core framework adds <code>RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant</code> to the regular expression constructor. See <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions" data-linktype="absolute-path">RegexOptions</a> for a description of these members.</p>
<p>Regular expressions use delimiters and tokens similar to those used by Routing and the C# language. Regular expression tokens must be escaped. To use the regular expression <code>^\d{3}-\d{2}-\d{4}$</code> in routing, the expression must have the <code>\</code> (single backslash) characters provided in the string as <code>\\</code> (double backslash) characters in the C# source file in order to escape the <code>\</code> string escape character (unless using <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string" data-linktype="absolute-path">verbatim string literals</a>). To escape routing parameter delimiter characters (<code>{</code>, <code>}</code>, <code>[</code>, <code>]</code>), double the characters in the expression (<code>{{</code>, <code>}</code>, <code>[[</code>, <code>]]</code>). The following table shows a regular expression and the escaped version.</p>

<p>Regular expressions used in routing often start with the caret (<code>^</code>) character and match starting position of the string. The expressions often end with the dollar sign (<code>$</code>) character and match end of the string. The <code>^</code> and <code>$</code> characters ensure that the regular expression match the entire route parameter value. Without the <code>^</code> and <code>$</code> characters, the regular expression match any substring within the string, which is often undesirable. The following table provides examples and explains why they match or fail to match.</p>

<p>For more information on regular expression syntax, see <a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference" data-linktype="absolute-path">.NET Framework Regular Expressions</a>.</p>
<p>To constrain a parameter to a known set of possible values, use a regular expression. For example, <code>{action:regex(^(list|get|create)$)}</code> only matches the <code>action</code> route value to <code>list</code>, <code>get</code>, or <code>create</code>. If passed into the constraints dictionary, the string <code>^(list|get|create)$</code> is equivalent. Constraints that are passed in the constraints dictionary (not inline within a template) that don't match one of the known constraints are also treated as regular expressions.</p>
<h2 id="custom-route-constraints">Custom Route Constraints<a href="#custom-route-constraints" aria-labelledby="custom-route-constraints"></a></h2>
<p>In addition to the built-in route constraints, custom route constraints can be created by implementing the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> interface. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> interface contains a single method, <code>Match</code>, which returns <code>true</code> if the constraint is satisfied and <code>false</code> otherwise.</p>
<p>To use a custom <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a>, the route constraint type must be registered with the app's <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> in the app's service container. A <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> is a dictionary that maps route constraint keys to <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> implementations that validate those constraints. An app's <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> can be updated in <code>Startup.ConfigureServices</code> either as part of a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.routingservicecollectionextensions.addrouting" data-linktype="absolute-path">services.AddRouting</a> call or by configuring <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions" data-linktype="absolute-path">RouteOptions</a> directly with <code>services.Configure&lt;RouteOptions&gt;</code>. For example:</p>
<pre tabindex="0"><code data-author-content="services.AddRouting(options =>
{
    options.ConstraintMap.Add(&quot;customName&quot;, typeof(MyCustomConstraint));
});
">services.AddRouting(options =&gt;
{
    options.ConstraintMap.Add("customName", typeof(MyCustomConstraint));
});
</code></pre>
<p>The constraint can then be applied to routes in the usual manner, using the name specified when registering the constraint type. For example:</p>
<pre tabindex="0"><code data-author-content="[HttpGet(&quot;{id:customName}&quot;)]
public ActionResult<string> Get(string id)
">[HttpGet("{id:customName}")]
public ActionResult&lt;string&gt; Get(string id)
</code></pre>
<h2 id="parameter-transformer-reference">Parameter transformer reference<a href="#parameter-transformer-reference" aria-labelledby="parameter-transformer-reference"></a></h2>
<p>Parameter transformers:</p>
<ul>
<li>Execute when generating a link for a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a>.</li>
<li>Implement <code>Microsoft.AspNetCore.Routing.IOutboundParameterTransformer</code>.</li>
<li>Are configured using <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a>.</li>
<li>Take the parameter's route value and transform it to a new string value.</li>
<li>Result in using the transformed value in the generated link.</li>
</ul>
<p>For example, a custom <code>slugify</code> parameter transformer in route pattern <code>blog\{article:slugify}</code> with <code>Url.Action(new { article = "MyTestArticle" })</code> generates <code>blog\my-test-article</code>.</p>
<p>To use a parameter transformer in a route pattern, configure it first using <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> in <code>Startup.ConfigureServices</code>:</p>
<pre tabindex="0"><code data-author-content="services.AddRouting(options =>
{
    // Replace the type and the name used to refer to it with your own
    // IOutboundParameterTransformer implementation
    options.ConstraintMap[&quot;slugify&quot;] = typeof(SlugifyParameterTransformer);
});
">services.AddRouting(options =&gt;
{
    // Replace the type and the name used to refer to it with your own
    // IOutboundParameterTransformer implementation
    options.ConstraintMap["slugify"] = typeof(SlugifyParameterTransformer);
});
</code></pre>
<p>Parameter transformers are used by the framework to transform the URI where an endpoint resolves. For example, ASP.NET Core MVC uses parameter transformers to transform the route value used to match an <code>area</code>, <code>controller</code>, <code>action</code>, and <code>page</code>.</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller:slugify=Home}/{action:slugify=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller:slugify=Home}/{action:slugify=Index}/{id?}");
</code></pre>
<p>With the preceding route, the action <code>SubscriptionManagementController.GetAll()</code> is matched with the URI <code>/subscription-management/get-all</code>. A parameter transformer doesn't change the route values used to generate a link. For example, <code>Url.Action("GetAll", "SubscriptionManagement")</code> outputs <code>/subscription-management/get-all</code>.</p>
<p>ASP.NET Core provides API conventions for using a parameter transformers with generated routes:</p>
<ul>
<li>ASP.NET Core MVC has the <code>Microsoft.AspNetCore.Mvc.ApplicationModels.RouteTokenTransformerConvention</code> API convention. This convention applies a specified parameter transformer to all attribute routes in the app. The parameter transformer transforms attribute route tokens as they are replaced. For more information, see <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing#use-a-parameter-transformer-to-customize-token-replacement" data-linktype="absolute-path">Use a parameter transformer to customize token replacement</a>.</li>
<li>Razor Pages has the <code>Microsoft.AspNetCore.Mvc.ApplicationModels.PageRouteTransformerConvention</code> API convention. This convention applies a specified parameter transformer to all automatically discovered Razor Pages. The parameter transformer transforms the folder and file name segments of Razor Pages routes. For more information, see <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/razor-pages-conventions#use-a-parameter-transformer-to-customize-page-routes" data-linktype="absolute-path">Use a parameter transformer to customize page routes</a>.</li>
</ul>
<h2 id="url-generation-reference">URL generation reference<a href="#url-generation-reference" aria-labelledby="url-generation-reference"></a></h2>
<p>The following example shows how to generate a link to a route given a dictionary of route values and a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routecollection" data-linktype="absolute-path">RouteCollection</a>.</p>
<pre tabindex="0"><code data-author-content="app.Run(async (context) =>
{
    var dictionary = new RouteValueDictionary
    {
        { &quot;operation&quot;, &quot;create&quot; },
        { &quot;id&quot;, 123}
    };

    var vpc = new VirtualPathContext(context, null, dictionary, 
        &quot;Track Package Route&quot;);
    var path = routes.GetVirtualPath(vpc).VirtualPath;

    context.Response.ContentType = &quot;text/html&quot;;
    await context.Response.WriteAsync(&quot;Menu<hr/>&quot;);
    await context.Response.WriteAsync(
        $&quot;<a href='{path}'>Create Package 123</a><br/>&quot;);
});
">app.Run(async (context) =&gt;
{
    var dictionary = new RouteValueDictionary
    {
        { "operation", "create" },
        { "id", 123}
    };

    var vpc = new VirtualPathContext(context, null, dictionary, 
        "Track Package Route");
    var path = routes.GetVirtualPath(vpc).VirtualPath;

    context.Response.ContentType = "text/html";
    await context.Response.WriteAsync("Menu&lt;hr/&gt;");
    await context.Response.WriteAsync(
        $"&lt;a href='{path}'&gt;Create Package 123&lt;/a&gt;&lt;br/&gt;");
});
</code></pre>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata.virtualpath#Microsoft_AspNetCore_Routing_VirtualPathData_VirtualPath" data-linktype="absolute-path">VirtualPath</a> generated at the end of the preceding sample is <code>/package/create/123</code>. The dictionary supplies the <code>operation</code> and <code>id</code> route values of the "Track Package Route" template, <code>package/{operation}/{id}</code>. For details, see the sample code in the <a href="#use-routing-middleware" data-linktype="self-bookmark">Use Routing Middleware</a> section or the <a href="https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples" data-linktype="external">sample app</a>.</p>
<p>The second parameter to the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext" data-linktype="absolute-path">VirtualPathContext</a> constructor is a collection of <em>ambient values</em>. Ambient values are convenient to use because they limit the number of values a developer must specify within a request context. The current route values of the current request are considered ambient values for link generation. In an ASP.NET Core MVC app's <code>About</code> action of the <code>HomeController</code>, you don't need to specify the controller route value to link to the <code>Index</code> actionâ€”the ambient value of <code>Home</code> is used.</p>
<p>Ambient values that don't match a parameter are ignored. Ambient values are also ignored when an explicitly provided value overrides the ambient value. Matching occurs from left to right in the URL.</p>
<p>Values explicitly provided but that don't match a segment of the route are added to the query string. The following table shows the result when using the route template <code>{controller}/{action}/{id?}</code>.</p>

<p>If a route has a default value that doesn't correspond to a parameter and that value is explicitly provided, it must match the default value:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(&quot;blog_route&quot;, &quot;blog/{*slug}&quot;,
    defaults: new { controller = &quot;Blog&quot;, action = &quot;ReadPost&quot; });
">routes.MapRoute("blog_route", "blog/{*slug}",
    defaults: new { controller = "Blog", action = "ReadPost" });
</code></pre>
<p>Link generation only generates a link for this route when the matching values for <code>controller</code> and <code>action</code> are provided.</p>
<h2 id="complex-segments">Complex segments<a href="#complex-segments" aria-labelledby="complex-segments"></a></h2>
<p>Complex segments (for example <code>[Route("/x{token}y")]</code>) are processed by matching up literals from right to left in a non-greedy way. See <a href="https://github.com/dotnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293" data-linktype="external">this code</a> for a detailed explanation of how complex segments are matched. The <a href="https://github.com/dotnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293" data-linktype="external">code sample</a> is not used by ASP.NET Core, but it provides a good explanation of complex segments.</p>
<!-- While that code is no longer used by ASP.NET Core for complex segment matching, it provides a good match to the current algorithm. The [current code](https://github.com/dotnet/AspNetCore/blob/91514c9af7e0f4c44029b51f05a01c6fe4c96e4c/src/Http/Routing/src/Matching/DfaMatcherBuilder.cs#L227-L244) is too abstracted from matching to be useful for understanding complex segment matching.
-->

<p>The following links provide information on configuring endpoint metadata:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-3.1#enable-cors-with-endpoint-routing" data-linktype="relative-path">Enable Cors with endpoint routing</a></li>
<li><a href="https://github.com/dotnet/AspNetCore/tree/release/3.0/src/Security/samples/CustomPolicyProvider" data-linktype="external">IAuthorizationPolicyProvider sample</a> using a custom <code>[MinimumAgeAuthorize]</code> attribute</li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-3.1#test-identity" data-linktype="relative-path">Test authentication with the [Authorize] attribute</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.authorizationendpointconventionbuilderextensions.requireauthorization" data-linktype="absolute-path">RequireAuthorization</a></li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/limitingidentitybyscheme?view=aspnetcore-3.1#selecting-the-scheme-with-the-authorize-attribute" data-linktype="relative-path">Selecting the scheme with the [Authorize] attribute</a></li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-3.1#applying-policies-to-mvc-controllers" data-linktype="relative-path">Applying policies using the [Authorize] attribute</a></li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/roles?view=aspnetcore-3.1" data-linktype="relative-path">Role-based authorization in ASP.NET Core</a></li>
</ul>

<h2 id="host-matching-in-routes-with-requirehost">Host matching in routes with RequireHost<a href="#host-matching-in-routes-with-requirehost" aria-labelledby="host-matching-in-routes-with-requirehost"></a></h2>
<p><code>RequireHost</code> applies a constraint to the route which requires the specified host. The <code>RequireHost</code> or <code>[Host]</code> parameter can be:</p>
<ul>
<li>Host: <code>www.domain.com</code> (matches <code>www.domain.com</code> with any port)</li>
<li>Host with wildcard: <code>*.domain.com</code> (matches <code>www.domain.com</code>, <code>subdomain.domain.com</code>, or <code>www.subdomain.domain.com</code> on any port)</li>
<li>Port: <code>*:5000</code> (matches port 5000 with any host)</li>
<li>Host and port: <code>www.domain.com:5000</code>, <code>*.domain.com:5000</code> (matches host and port)</li>
</ul>
<p>Multiple parameters can be specified using <code>RequireHost</code> or <code>[Host]</code>. The constraint will match hosts valid for any of the parameters. For example, <code>[Host("domain.com", "*.domain.com")]</code> will match <code>domain.com</code>, <code>www.domain.com</code>, or <code>subdomain.domain.com</code>.</p>
<p>The following code uses <code>RequireHost</code> to require the specified host on the route:</p>
<pre tabindex="0"><code data-author-content="public void Configure(IApplicationBuilder app)
{
    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapGet(&quot;/&quot;, context => context.Response.WriteAsync(&quot;Hi Contoso!&quot;))
            .RequireHost(&quot;contoso.com&quot;);
        endpoints.MapGet(&quot;/&quot;, context => context.Response.WriteAsync(&quot;Hi AdventureWorks!&quot;))
            .RequireHost(&quot;adventure-works.com&quot;);
        endpoints.MapHealthChecks(&quot;/healthz&quot;).RequireHost(&quot;*:8080&quot;);
    });
}
">public void Configure(IApplicationBuilder app)
{
    app.UseRouting();

    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapGet("/", context =&gt; context.Response.WriteAsync("Hi Contoso!"))
            .RequireHost("contoso.com");
        endpoints.MapGet("/", context =&gt; context.Response.WriteAsync("Hi AdventureWorks!"))
            .RequireHost("adventure-works.com");
        endpoints.MapHealthChecks("/healthz").RequireHost("*:8080");
    });
}
</code></pre>
<p>The following code uses the <code>[Host]</code> attribute to require the specified host on the controller:</p>
<pre tabindex="0"><code data-author-content="[Host(&quot;contoso.com&quot;, &quot;adventure-works.com&quot;)]
public class HomeController : Controller
{
    private readonly ILogger<HomeController> _logger;

    public HomeController(ILogger<HomeController> logger)
    {
        _logger = logger;
    }

    public IActionResult Index()
    {
        return View();
    }

    [Host(&quot;example.com:8080&quot;)]
    public IActionResult Privacy()
    {
        return View();
    }

}
">[Host("contoso.com", "adventure-works.com")]
public class HomeController : Controller
{
    private readonly ILogger&lt;HomeController&gt; _logger;

    public HomeController(ILogger&lt;HomeController&gt; logger)
    {
        _logger = logger;
    }

    public IActionResult Index()
    {
        return View();
    }

    [Host("example.com:8080")]
    public IActionResult Privacy()
    {
        return View();
    }

}
</code></pre>
<p>When the <code>[Host]</code> attribute is applied to both the controller and action method:</p>
<ul>
<li>The attribute on the action is used.</li>
<li>The controller attribute is ignored.</li>
</ul>
</div>
<div data-moniker="aspnetcore-2.2">
<p>Routing is responsible for mapping request URIs to endpoints and dispatching incoming requests to those endpoints. Routes are defined in the app and configured when the app starts. A route can optionally extract values from the URL contained in the request, and these values can then be used for request processing. Using route information from the app, routing is also able to generate URLs that map to endpoints.</p>
<p>To use the latest routing scenarios in ASP.NET Core 2.2, specify the <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/compatibility-version?view=aspnetcore-3.1" data-linktype="relative-path">compatibility version</a> to the MVC services registration in <code>Startup.ConfigureServices</code>:</p>
<pre tabindex="0"><code data-author-content="services.AddMvc()
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
">services.AddMvc()
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
</code></pre>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.mvcoptions.enableendpointrouting#Microsoft_AspNetCore_Mvc_MvcOptions_EnableEndpointRouting" data-linktype="absolute-path">EnableEndpointRouting</a> option determines if routing should internally use endpoint-based logic or the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter" data-linktype="absolute-path">IRouter</a>-based logic of ASP.NET Core 2.1 or earlier. When the compatibility version is set to 2.2 or later, the default value is <code>true</code>. Set the value to <code>false</code> to use the prior routing logic:</p>
<pre tabindex="0"><code data-author-content="// Use the routing logic of ASP.NET Core 2.1 or earlier:
services.AddMvc(options => options.EnableEndpointRouting = false)
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
">// Use the routing logic of ASP.NET Core 2.1 or earlier:
services.AddMvc(options =&gt; options.EnableEndpointRouting = false)
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
</code></pre>
<p>For more information on <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter" data-linktype="absolute-path">IRouter</a>-based routing, see the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-2.1" data-linktype="absolute-path">ASP.NET Core 2.1 version of this topic</a>.</p>

<p><a href="https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples" data-linktype="external">View or download sample code</a> (<a href="https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-3.1#how-to-download-a-sample" data-linktype="relative-path">how to download</a>)</p>
<h2 data-id="routing-basics-1">Routing basics<a href="#routing-basics-1" aria-labelledby="routing-basics-1"></a></h2>
<p>Most apps should choose a basic and descriptive routing scheme so that URLs are readable and meaningful. The default conventional route <code>{controller=Home}/{action=Index}/{id?}</code>:</p>
<ul>
<li>Supports a basic and descriptive routing scheme.</li>
<li>Is a useful starting point for UI-based apps.</li>
</ul>
<p>Developers commonly add additional terse routes to high-traffic areas of an app in specialized situations (for example, blog and ecommerce endpoints) using <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-3.1#attribute-routing" data-linktype="relative-path">attribute routing</a> or dedicated conventional routes.</p>
<p>Web APIs should use attribute routing to model the app's functionality as a set of resources where operations are represented by HTTP verbs. This means that many operations (for example, GET, POST) on the same logical resource will use the same URL. Attribute routing provides a level of control that's needed to carefully design an API's public endpoint layout.</p>
<p>Razor Pages apps use default conventional routing to serve named resources in the <em>Pages</em> folder of an app. Additional conventions are available that allow you to customize Razor Pages routing behavior. For more information, see <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.1" data-linktype="relative-path">Introduction to Razor Pages in ASP.NET Core</a> and <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/razor-pages-conventions?view=aspnetcore-3.1" data-linktype="relative-path">Razor Pages route and app conventions in ASP.NET Core</a>.</p>
<p>URL generation support allows the app to be developed without hard-coding URLs to link the app together. This support allows for starting with a basic routing configuration and modifying the routes after the app's resource layout is determined.</p>
<p>Routing uses <em>endpoints</em> (<code>Endpoint</code>) to represent logical endpoints in an app.</p>
<p>An endpoint defines a delegate to process requests and a collection of arbitrary metadata. The metadata is used implement cross-cutting concerns based on policies and configuration attached to each endpoint.</p>
<p>The routing system has the following characteristics:</p>
<ul>
<li><p>Route template syntax is used to define routes with tokenized route parameters.</p>
</li>
<li><p>Conventional-style and attribute-style endpoint configuration is permitted.</p>
</li>
<li><p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> is used to determine whether a URL parameter contains a valid value for a given endpoint constraint.</p>
</li>
<li><p>App models, such as MVC/Razor Pages, register all of their endpoints, which have a predictable implementation of routing scenarios.</p>
</li>
<li><p>The routing implementation makes routing decisions wherever desired in the middleware pipeline.</p>
</li>
<li><p>Middleware that appears after a Routing Middleware can inspect the result of the Routing Middleware's endpoint decision for a given request URI.</p>
</li>
<li><p>It's possible to enumerate all of the endpoints in the app anywhere in the middleware pipeline.</p>
</li>
<li><p>An app can use routing to generate URLs (for example, for redirection or links) based on endpoint information and thus avoid hard-coded URLs, which helps maintainability.</p>
</li>
<li><p>URL generation is based on addresses, which support arbitrary extensibility:</p>
<ul>
<li>The Link Generator API (<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a>) can be resolved anywhere using <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1" data-linktype="relative-path">dependency injection (DI)</a> to generate URLs.</li>
<li>Where the Link Generator API isn't available via DI, <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper" data-linktype="absolute-path">IUrlHelper</a> offers methods to build URLs.</li>
</ul>
</li>
</ul>
<div>
<p><span aria-hidden="true"></span> Note</p>
<p>With the release of endpoint routing in ASP.NET Core 2.2, endpoint linking is limited to MVC/Razor Pages actions and pages. The expansions of endpoint-linking capabilities is planned for future releases.</p>
</div>
<p>Routing is connected to the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-3.1" data-linktype="relative-path">middleware</a> pipeline by the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.routermiddleware" data-linktype="absolute-path">RouterMiddleware</a> class. <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/overview?view=aspnetcore-3.1" data-linktype="relative-path">ASP.NET Core MVC</a> adds routing to the middleware pipeline as part of its configuration and handles routing in MVC and Razor Pages apps. To learn how to use routing as a standalone component, see the <a href="#use-routing-middleware" data-linktype="self-bookmark">Use Routing Middleware</a> section.</p>
<h3 data-id="url-matching-1">URL matching<a href="#url-matching-1" aria-labelledby="url-matching-1"></a></h3>
<p>URL matching is the process by which routing dispatches an incoming request to an <em>endpoint</em>. This process is based on data in the URL path but can be extended to consider any data in the request. The ability to dispatch requests to separate handlers is key to scaling the size and complexity of an app.</p>
<p>The routing system in endpoint routing is responsible for all dispatching decisions. Since the middleware applies policies based on the selected endpoint, it's important that any decision that can affect dispatching or the application of security policies is made inside the routing system.</p>
<p>When the endpoint delegate is executed, the properties of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routecontext.routedata#Microsoft_AspNetCore_Routing_RouteContext_RouteData" data-linktype="absolute-path">RouteContext.RouteData</a> are set to appropriate values based on the request processing performed thus far.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.values" data-linktype="absolute-path">RouteData.Values</a> is a dictionary of <em>route values</em> produced from the route. These values are usually determined by tokenizing the URL and can be used to accept user input or to make further dispatching decisions inside the app.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.datatokens" data-linktype="absolute-path">RouteData.DataTokens</a> is a property bag of additional data related to the matched route. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.datatokens" data-linktype="absolute-path">DataTokens</a> are provided to support associating state data with each route so that the app can make decisions based on which route matched. These values are developer-defined and do <strong>not</strong> affect the behavior of routing in any way. Additionally, values stashed in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.datatokens" data-linktype="absolute-path">RouteData.DataTokens</a> can be of any type, in contrast to <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.values#Microsoft_AspNetCore_Routing_RouteData_Values" data-linktype="absolute-path">RouteData.Values</a>, which must be convertible to and from strings.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">RouteData.Routers</a> is a list of the routes that took part in successfully matching the request. Routes can be nested inside of one another. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">Routers</a> property reflects the path through the logical tree of routes that resulted in a match. Generally, the first item in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">Routers</a> is the route collection and should be used for URL generation. The last item in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">Routers</a> is the route handler that matched.</p>

<h3 data-id="url-generation-with-linkgenerator-1">URL generation with LinkGenerator<a href="#url-generation-with-linkgenerator-1" aria-labelledby="url-generation-with-linkgenerator-1"></a></h3>
<p>URL generation is the process by which routing can create a URL path based on a set of route values. This allows for a logical separation between your endpoints and the URLs that access them.</p>
<p>Endpoint routing includes the Link Generator API (<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a>). <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> is a singleton service that can be retrieved from DI. The API can be used outside of the context of an executing request. MVC's <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper" data-linktype="absolute-path">IUrlHelper</a> and scenarios that rely on <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper" data-linktype="absolute-path">IUrlHelper</a>, such as <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-3.1" data-linktype="relative-path">Tag Helpers</a>, HTML Helpers, and <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/actions?view=aspnetcore-3.1" data-linktype="relative-path">Action Results</a>, use the link generator to provide link generating capabilities.</p>
<p>The link generator is backed by the concept of an <em>address</em> and <em>address schemes</em>. An address scheme is a way of determining the endpoints that should be considered for link generation. For example, the route name and route values scenarios many users are familiar with from MVC/Razor Pages are implemented as an address scheme.</p>
<p>The link generator can link to MVC/Razor Pages actions and pages via the following extension methods:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.controllerlinkgeneratorextensions.getpathbyaction" data-linktype="absolute-path">GetPathByAction</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.controllerlinkgeneratorextensions.geturibyaction" data-linktype="absolute-path">GetUriByAction</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.pagelinkgeneratorextensions.getpathbypage" data-linktype="absolute-path">GetPathByPage</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.pagelinkgeneratorextensions.geturibypage" data-linktype="absolute-path">GetUriByPage</a></li>
</ul>
<p>An overload of these methods accepts arguments that include the <code>HttpContext</code>. These methods are functionally equivalent to <code>Url.Action</code> and <code>Url.Page</code> but offer additional flexibility and options.</p>
<p>The <code>GetPath*</code> methods are most similar to <code>Url.Action</code> and <code>Url.Page</code> in that they generate a URI containing an absolute path. The <code>GetUri*</code> methods always generate an absolute URI containing a scheme and host. The methods that accept an <code>HttpContext</code> generate a URI in the context of the executing request. The ambient route values, URL base path, scheme, and host from the executing request are used unless overridden.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> is called with an address. Generating a URI occurs in two steps:</p>
<ol>
<li>An address is bound to a list of endpoints that match the address.</li>
<li>Each endpoint's <code>RoutePattern</code> is evaluated until a route pattern that matches the supplied values is found. The resulting output is combined with the other URI parts supplied to the link generator and returned.</li>
</ol>
<p>The methods provided by <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> support standard link generation capabilities for any type of address. The most convenient way to use the link generator is through extension methods that perform operations for a specific address type.</p>

<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Pay attention to the following implications of calling <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> methods:</p>
<ul>
<li><p>Use <code>GetUri*</code> extension methods with caution in an app configuration that doesn't validate the <code>Host</code> header of incoming requests. If the <code>Host</code> header of incoming requests isn't validated, untrusted request input can be sent back to the client in URIs in a view/page. We recommend that all production apps configure their server to validate the <code>Host</code> header against known valid values.</p>
</li>
<li><p>Use <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> with caution in middleware in combination with <code>Map</code> or <code>MapWhen</code>. <code>Map*</code> changes the base path of the executing request, which affects the output of link generation. All of the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> APIs allow specifying a base path. Always specify an empty base path to undo <code>Map*</code>'s affect on link generation.</p>
</li>
</ul>
</div>
<h2 data-id="differences-from-earlier-versions-of-routing">Differences from earlier versions of routing<a href="#differences-from-earlier-versions-of-routing" aria-labelledby="differences-from-earlier-versions-of-routing"></a></h2>
<p>A few differences exist between endpoint routing in ASP.NET Core 2.2 or later and earlier versions of routing in ASP.NET Core:</p>
<ul>
<li><p>The endpoint routing system doesn't support <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter" data-linktype="absolute-path">IRouter</a>-based extensibility, including inheriting from <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a>.</p>
</li>
<li><p>Endpoint routing doesn't support <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.WebApiCompatShim" data-linktype="external">WebApiCompatShim</a>. Use the 2.1 <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/compatibility-version?view=aspnetcore-3.1" data-linktype="relative-path">compatibility version</a> (<code>.SetCompatibilityVersion(CompatibilityVersion.Version_2_1)</code>) to continue using the compatibility shim.</p>
</li>
<li><p>Endpoint Routing has different behavior for the casing of generated URIs when using conventional routes.</p>
<p>Consider the following default route template:</p>
<pre tabindex="0"><code data-author-content="app.UseMvc(routes =>
{
    routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
});
">app.UseMvc(routes =&gt;
{
    routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
});
</code></pre>
<p>Suppose you generate a link to an action using the following route:</p>
<pre tabindex="0"><code data-author-content="var link = Url.Action(&quot;ReadPost&quot;, &quot;blog&quot;, new { id = 17, });
">var link = Url.Action("ReadPost", "blog", new { id = 17, });
</code></pre>
<p>With <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter" data-linktype="absolute-path">IRouter</a>-based routing, this code generates a URI of <code>/blog/ReadPost/17</code>, which respects the casing of the provided route value. Endpoint routing in ASP.NET Core 2.2 or later produces <code>/Blog/ReadPost/17</code> ("Blog" is capitalized). Endpoint routing provides the <code>IOutboundParameterTransformer</code> interface that can be used to customize this behavior globally or to apply different conventions for mapping URLs.</p>
<p>For more information, see the <a href="#parameter-transformer-reference" data-linktype="self-bookmark">Parameter transformer reference</a> section.</p>
</li>
<li><p>Link Generation used by MVC/Razor Pages with conventional routes behaves differently when attempting to link to an controller/action or page that doesn't exist.</p>
<p>Consider the following default route template:</p>
<pre tabindex="0"><code data-author-content="app.UseMvc(routes =>
{
    routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
});
">app.UseMvc(routes =&gt;
{
    routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
});
</code></pre>
<p>Suppose you generate a link to an action using the default template with the following:</p>
<pre tabindex="0"><code data-author-content="var link = Url.Action(&quot;ReadPost&quot;, &quot;Blog&quot;, new { id = 17, });
">var link = Url.Action("ReadPost", "Blog", new { id = 17, });
</code></pre>
<p>With <code>IRouter</code>-based routing, the result is always <code>/Blog/ReadPost/17</code>, even if the <code>BlogController</code> doesn't exist or doesn't have a <code>ReadPost</code> action method. As expected, endpoint routing in ASP.NET Core 2.2 or later produces <code>/Blog/ReadPost/17</code> if the action method exists. <em>However, endpoint routing produces an empty string if the action doesn't exist.</em> Conceptually, endpoint routing doesn't assume that the endpoint exists if the action doesn't exist.</p>
</li>
<li><p>The link generation <em>ambient value invalidation algorithm</em> behaves differently when used with endpoint routing.</p>
<p><em>Ambient value invalidation</em> is the algorithm that decides which route values from the currently executing request (the ambient values) can be used in link generation operations. Conventional routing always invalidated extra route values when linking to a different action. Attribute routing didn't have this behavior prior to the release of ASP.NET Core 2.2. In earlier versions of ASP.NET Core, links to another action that use the same route parameter names resulted in link generation errors. In ASP.NET Core 2.2 or later, both forms of routing invalidate values when linking to another action.</p>
<p>Consider the following example in ASP.NET Core 2.1 or earlier. When linking to another action (or another page), route values can be reused in undesirable ways.</p>
<p>In <em>/Pages/Store/Product.cshtml</em>:</p>
<pre tabindex="0"><code data-author-content="@page &quot;{id}&quot;
@Url.Page(&quot;/Login&quot;)
">@page "{id}"
@Url.Page("/Login")
</code></pre>
<p>In <em>/Pages/Login.cshtml</em>:</p>
<pre tabindex="0"><code data-author-content="@page &quot;{id?}&quot;
">@page "{id?}"
</code></pre>
<p>If the URI is <code>/Store/Product/18</code> in ASP.NET Core 2.1 or earlier, the link generated on the Store/Info page by <code>@Url.Page("/Login")</code> is <code>/Login/18</code>. The <code>id</code> value of 18 is reused, even though the link destination is different part of the app entirely. The <code>id</code> route value in the context of the <code>/Login</code> page is probably a user ID value, not a store product ID value.</p>
<p>In endpoint routing with ASP.NET Core 2.2 or later, the result is <code>/Login</code>. Ambient values aren't reused when the linked destination is a different action or page.</p>
</li>
<li><p>Round-tripping route parameter syntax: Forward slashes aren't encoded when using a double-asterisk (<code>**</code>) catch-all parameter syntax.</p>
<p>During link generation, the routing system encodes the value captured in a double-asterisk (<code>**</code>) catch-all parameter (for example, <code>{**myparametername}</code>) except the forward slashes. The double-asterisk catch-all is supported with <code>IRouter</code>-based routing in ASP.NET Core 2.2 or later.</p>
<p>The single asterisk catch-all parameter syntax in prior versions of ASP.NET Core (<code>{*myparametername}</code>) remains supported, and forward slashes are encoded.</p>

</li>
</ul>
<h3 data-id="middleware-example-1">Middleware example<a href="#middleware-example-1" aria-labelledby="middleware-example-1"></a></h3>
<p>In the following example, a middleware uses the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.linkgenerator" data-linktype="absolute-path">LinkGenerator</a> API to create link to an action method that lists store products. Using the link generator by injecting it into a class and calling <code>GenerateLink</code> is available to any class in an app.</p>
<pre tabindex="0"><code data-author-content="using Microsoft.AspNetCore.Routing;

public class ProductsLinkMiddleware
{
    private readonly LinkGenerator _linkGenerator;

    public ProductsLinkMiddleware(RequestDelegate next, LinkGenerator linkGenerator)
    {
        _linkGenerator = linkGenerator;
    }

    public async Task InvokeAsync(HttpContext httpContext)
    {
        var url = _linkGenerator.GetPathByAction(&quot;ListProducts&quot;, &quot;Store&quot;);

        httpContext.Response.ContentType = &quot;text/plain&quot;;

        await httpContext.Response.WriteAsync($&quot;Go to {url} to see our products.&quot;);
    }
}
">using Microsoft.AspNetCore.Routing;

public class ProductsLinkMiddleware
{
    private readonly LinkGenerator _linkGenerator;

    public ProductsLinkMiddleware(RequestDelegate next, LinkGenerator linkGenerator)
    {
        _linkGenerator = linkGenerator;
    }

    public async Task InvokeAsync(HttpContext httpContext)
    {
        var url = _linkGenerator.GetPathByAction("ListProducts", "Store");

        httpContext.Response.ContentType = "text/plain";

        await httpContext.Response.WriteAsync($"Go to {url} to see our products.");
    }
}
</code></pre>
<h3 data-id="create-routes-1">Create routes<a href="#create-routes-1" aria-labelledby="create-routes-1"></a></h3>
<p>Most apps create routes by calling <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> or one of the similar extension methods defined on <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iroutebuilder" data-linktype="absolute-path">IRouteBuilder</a>. Any of the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iroutebuilder" data-linktype="absolute-path">IRouteBuilder</a> extension methods create an instance of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> and add it to the route collection.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> doesn't accept a route handler parameter. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> only adds routes that are handled by the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routebuilder.defaulthandler" data-linktype="absolute-path">DefaultHandler</a>. To learn more about routing in MVC, see <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-3.1" data-linktype="relative-path">Routing to controller actions in ASP.NET Core</a>.</p>
<p>The following code example is an example of a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> call used by a typical ASP.NET Core MVC route definition:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<p>This template matches a URL path and extracts the route values. For example, the path <code>/Products/Details/17</code> generates the following route values: <code>{ controller = Products, action = Details, id = 17 }</code>.</p>
<p>Route values are determined by splitting the URL path into segments and matching each segment with the <em>route parameter</em> name in the route template. Route parameters are named. The parameters defined by enclosing the parameter name in braces <code>{ ... }</code>.</p>
<p>The preceding template could also match the URL path <code>/</code> and produce the values <code>{ controller = Home, action = Index }</code>. This occurs because the <code>{controller}</code> and <code>{action}</code> route parameters have default values and the <code>id</code> route parameter is optional. An equals sign (<code>=</code>) followed by a value after the route parameter name defines a default value for the parameter. A question mark (<code>?</code>) after the route parameter name defines an optional parameter.</p>
<p>Route parameters with a default value <em>always</em> produce a route value when the route matches. Optional parameters don't produce a route value if there was no corresponding URL path segment. See the <a href="#route-template-reference" data-linktype="self-bookmark">Route template reference</a> section for a thorough description of route template scenarios and syntax.</p>
<p>In the following example, the route parameter definition <code>{id:int}</code> defines a <a href="#route-constraint-reference" data-linktype="self-bookmark">route constraint</a> for the <code>id</code> route parameter:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id:int}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id:int}");
</code></pre>
<p>This template matches a URL path like <code>/Products/Details/17</code> but not <code>/Products/Details/Apples</code>. Route constraints implement <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> and inspect route values to verify them. In this example, the route value <code>id</code> must be convertible to an integer. See <a href="#route-constraint-reference" data-linktype="self-bookmark">route-constraint-reference</a> for an explanation of route constraints provided by the framework.</p>
<p>Additional overloads of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> accept values for <code>constraints</code>, <code>dataTokens</code>, and <code>defaults</code>. The typical usage of these parameters is to pass an anonymously typed object, where the property names of the anonymous type match route parameter names.</p>
<p>The following <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> examples create equivalent routes:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default_route&quot;,
    template: &quot;{controller}/{action}/{id?}&quot;,
    defaults: new { controller = &quot;Home&quot;, action = &quot;Index&quot; });

routes.MapRoute(
    name: &quot;default_route&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default_route",
    template: "{controller}/{action}/{id?}",
    defaults: new { controller = "Home", action = "Index" });

routes.MapRoute(
    name: "default_route",
    template: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>The inline syntax for defining constraints and defaults can be convenient for simple routes. However, there are scenarios, such as data tokens, that aren't supported by inline syntax.</p>
</div>
<p>The following example demonstrates a few additional scenarios:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;blog&quot;,
    template: &quot;Blog/{**article}&quot;,
    defaults: new { controller = &quot;Blog&quot;, action = &quot;ReadArticle&quot; });
">routes.MapRoute(
    name: "blog",
    template: "Blog/{**article}",
    defaults: new { controller = "Blog", action = "ReadArticle" });
</code></pre>
<p>The preceding template matches a URL path like <code>/Blog/All-About-Routing/Introduction</code> and extracts the values <code>{ controller = Blog, action = ReadArticle, article = All-About-Routing/Introduction }</code>. The default route values for <code>controller</code> and <code>action</code> are produced by the route even though there are no corresponding route parameters in the template. Default values can be specified in the route template. The <code>article</code> route parameter is defined as a <em>catch-all</em> by the appearance of an double asterisk (<code>**</code>) before the route parameter name. Catch-all route parameters capture the remainder of the URL path and can also match the empty string.</p>
<p>The following example adds route constraints and data tokens:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;us_english_products&quot;,
    template: &quot;en-US/Products/{id}&quot;,
    defaults: new { controller = &quot;Products&quot;, action = &quot;Details&quot; },
    constraints: new { id = new IntRouteConstraint() },
    dataTokens: new { locale = &quot;en-US&quot; });
">routes.MapRoute(
    name: "us_english_products",
    template: "en-US/Products/{id}",
    defaults: new { controller = "Products", action = "Details" },
    constraints: new { id = new IntRouteConstraint() },
    dataTokens: new { locale = "en-US" });
</code></pre>
<p>The preceding template matches a URL path like <code>/en-US/Products/5</code> and extracts the values <code>{ controller = Products, action = Details, id = 5 }</code> and the data tokens <code>{ locale = en-US }</code>.</p>
<p><img src="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing/_static/tokens.png?view=aspnetcore-3.1" alt="Locals Windows tokens" data-linktype="relative-path"></p>
<h3 data-id="route-class-url-generation-1">Route class URL generation<a href="#route-class-url-generation-1" aria-labelledby="route-class-url-generation-1"></a></h3>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> class can also perform URL generation by combining a set of route values with its route template. This is logically the reverse process of matching the URL path.</p>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>To better understand URL generation, imagine what URL you want to generate and then think about how a route template would match that URL. What values would be produced? This is the rough equivalent of how URL generation works in the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> class.</p>
</div>
<p>The following example uses a general ASP.NET Core MVC default route:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<p>With the route values <code>{ controller = Products, action = List }</code>, the URL <code>/Products/List</code> is generated. The route values are substituted for the corresponding route parameters to form the URL path. Since <code>id</code> is an optional route parameter, the URL is successfully generated without a value for <code>id</code>.</p>
<p>With the route values <code>{ controller = Home, action = Index }</code>, the URL <code>/</code> is generated. The provided route values match the default values, and the segments corresponding to the default values are safely omitted.</p>
<p>Both URLs generated round-trip with the following route definition (<code>/Home/Index</code> and <code>/</code>) produce the same route values that were used to generate the URL.</p>
<div>
<p><span aria-hidden="true"></span> Note</p>
<p>An app using ASP.NET Core MVC should use <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routing.urlhelper" data-linktype="absolute-path">UrlHelper</a> to generate URLs instead of calling into routing directly.</p>
</div>
<p>For more information on URL generation, see the <a href="#url-generation-reference" data-linktype="self-bookmark">Url generation reference</a> section.</p>
<h2 data-id="use-routing-middleware-1">Use Routing Middleware<a href="#use-routing-middleware-1" aria-labelledby="use-routing-middleware-1"></a></h2>
<p>Reference the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/metapackage-app?view=aspnetcore-3.1" data-linktype="relative-path">Microsoft.AspNetCore.App metapackage</a> in the app's project file.</p>
<p>Add routing to the service container in <code>Startup.ConfigureServices</code>:</p>
<pre tabindex="0"><code highlight-lines="3" data-author-content="public void ConfigureServices(IServiceCollection services)
{
    services.AddRouting();
}
">public void ConfigureServices(IServiceCollection services)
{
    services.AddRouting();
}
</code></pre>
<p>Routes must be configured in the <code>Startup.Configure</code> method. The sample app uses the following APIs:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routebuilder" data-linktype="absolute-path">RouteBuilder</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a> â€“ Matches only HTTP GET requests.</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.routingbuilderextensions.userouter" data-linktype="absolute-path">UseRouter</a></li>
</ul>
<pre tabindex="0"><code data-author-content="var trackPackageRouteHandler = new RouteHandler(context =>
{
    var routeValues = context.GetRouteData().Values;
    return context.Response.WriteAsync(
        $&quot;Hello! Route values: {string.Join(&quot;, &quot;, routeValues)}&quot;);
});

var routeBuilder = new RouteBuilder(app, trackPackageRouteHandler);

routeBuilder.MapRoute(
    &quot;Track Package Route&quot;,
    &quot;package/{operation:regex(^track|create$)}/{id:int}&quot;);

routeBuilder.MapGet(&quot;hello/{name}&quot;, context =>
{
    var name = context.GetRouteValue(&quot;name&quot;);
    // The route handler when HTTP GET &quot;hello/<anything>&quot; matches
    // To match HTTP GET &quot;hello/<anything>/<anything>, 
    // use routeBuilder.MapGet(&quot;hello/{*name}&quot;
    return context.Response.WriteAsync($&quot;Hi, {name}!&quot;);
});

var routes = routeBuilder.Build();
app.UseRouter(routes);
">var trackPackageRouteHandler = new RouteHandler(context =&gt;
{
    var routeValues = context.GetRouteData().Values;
    return context.Response.WriteAsync(
        $"Hello! Route values: {string.Join(", ", routeValues)}");
});

var routeBuilder = new RouteBuilder(app, trackPackageRouteHandler);

routeBuilder.MapRoute(
    "Track Package Route",
    "package/{operation:regex(^track|create$)}/{id:int}");

routeBuilder.MapGet("hello/{name}", context =&gt;
{
    var name = context.GetRouteValue("name");
    // The route handler when HTTP GET "hello/&lt;anything&gt;" matches
    // To match HTTP GET "hello/&lt;anything&gt;/&lt;anything&gt;, 
    // use routeBuilder.MapGet("hello/{*name}"
    return context.Response.WriteAsync($"Hi, {name}!");
});

var routes = routeBuilder.Build();
app.UseRouter(routes);
</code></pre>
<p>The following table shows the responses with the given URIs.</p>

<p>The framework provides a set of extension methods for creating routes (<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions" data-linktype="absolute-path">RequestDelegateRouteBuilderExtensions</a>):</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapdelete" data-linktype="absolute-path">MapDelete</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewaredelete" data-linktype="absolute-path">MapMiddlewareDelete</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareget" data-linktype="absolute-path">MapMiddlewareGet</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewarepost" data-linktype="absolute-path">MapMiddlewarePost</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareput" data-linktype="absolute-path">MapMiddlewarePut</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareroute" data-linktype="absolute-path">MapMiddlewareRoute</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareverb" data-linktype="absolute-path">MapMiddlewareVerb</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mappost" data-linktype="absolute-path">MapPost</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapput" data-linktype="absolute-path">MapPut</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapverb" data-linktype="absolute-path">MapVerb</a></li>
</ul>
<p>The <code>Map[Verb]</code> methods use constraints to limit the route to the HTTP Verb in the method name. For example, see <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapverb" data-linktype="absolute-path">MapVerb</a>.</p>
<h2 data-id="route-template-reference-1">Route template reference<a href="#route-template-reference-1" aria-labelledby="route-template-reference-1"></a></h2>
<p>Tokens within curly braces (<code>{ ... }</code>) define <em>route parameters</em> that are bound if the route is matched. You can define more than one route parameter in a route segment, but they must be separated by a literal value. For example, <code>{controller=Home}{action=Index}</code> isn't a valid route, since there's no literal value between <code>{controller}</code> and <code>{action}</code>. These route parameters must have a name and may have additional attributes specified.</p>
<p>Literal text other than route parameters (for example, <code>{id}</code>) and the path separator <code>/</code> must match the text in the URL. Text matching is case-insensitive and based on the decoded representation of the URLs path. To match a literal route parameter delimiter (<code>{</code> or <code>}</code>), escape the delimiter by repeating the character (<code>{{</code> or <code>}}</code>).</p>
<p>URL patterns that attempt to capture a file name with an optional file extension have additional considerations. For example, consider the template <code>files/{filename}.{ext?}</code>. When values for both <code>filename</code> and <code>ext</code> exist, both values are populated. If only a value for <code>filename</code> exists in the URL, the route matches because the trailing period (<code>.</code>) is  optional. The following URLs match this route:</p>
<ul>
<li><code>/files/myFile.txt</code></li>
<li><code>/files/myFile</code></li>
</ul>
<p>You can use an asterisk (<code>*</code>) or double asterisk (<code>**</code>) as a prefix to a route parameter to bind to the rest of the URI. These are called a <em>catch-all</em> parameters. For example, <code>blog/{**slug}</code> matches any URI that starts with <code>/blog</code> and has any value following it, which is assigned to the <code>slug</code> route value. Catch-all parameters can also match the empty string.</p>
<p>The catch-all parameter escapes the appropriate characters when the route is used to generate a URL, including path separator (<code>/</code>) characters. For example, the route <code>foo/{*path}</code> with route values <code>{ path = "my/path" }</code> generates <code>foo/my%2Fpath</code>. Note the escaped forward slash. To round-trip path separator characters, use the <code>**</code> route parameter prefix. The route <code>foo/{**path}</code> with <code>{ path = "my/path" }</code> generates <code>foo/my/path</code>.</p>
<p>Route parameters may have <em>default values</em> designated by specifying the default value after the parameter name separated by an equals sign (<code>=</code>). For example, <code>{controller=Home}</code> defines <code>Home</code> as the default value for <code>controller</code>. The default value is used if no value is present in the URL for the parameter. Route parameters are made optional by appending a question mark (<code>?</code>) to the end of the parameter name, as in <code>id?</code>. The difference between optional values and default route parameters is that a route parameter with a default value always produces a valueâ€”an optional parameter has a value only when a value is provided by the request URL.</p>
<p>Route parameters may have constraints that must match the route value bound from the URL. Adding a colon (<code>:</code>) and constraint name after the route parameter name specifies an <em>inline constraint</em> on a route parameter. If the constraint requires arguments, they're enclosed in parentheses (<code>(...)</code>) after the constraint name. Multiple inline constraints can be specified by appending another colon (<code>:</code>) and constraint name.</p>
<p>The constraint name and arguments are passed to the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iinlineconstraintresolver" data-linktype="absolute-path">IInlineConstraintResolver</a> service to create an instance of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> to use in URL processing. For example, the route template <code>blog/{article:minlength(10)}</code> specifies a <code>minlength</code> constraint with the argument <code>10</code>. For more information on route constraints and a list of the constraints provided by the framework, see the <a href="#route-constraint-reference" data-linktype="self-bookmark">Route constraint reference</a> section.</p>
<p>Route parameters may also have parameter transformers, which transform a parameter's value when generating links and matching actions and pages to URLs. Like constraints, parameter transformers can be added inline to a route parameter by adding a colon (<code>:</code>) and transformer name after the route parameter name. For example, the route template <code>blog/{article:slugify}</code> specifies a <code>slugify</code> transformer. For more information on parameter transformers, see the <a href="#parameter-transformer-reference" data-linktype="self-bookmark">Parameter transformer reference</a> section.</p>
<p>The following table demonstrates example route templates and their behavior.</p>

<p>Using a template is generally the simplest approach to routing. Constraints and defaults can also be specified outside the route template.</p>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>Enable <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-3.1" data-linktype="relative-path">Logging</a> to see how the built-in routing implementations, such as <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a>, match requests.</p>
</div>
<h2 data-id="reserved-routing-names-1">Reserved routing names<a href="#reserved-routing-names-1" aria-labelledby="reserved-routing-names-1"></a></h2>
<p>The following keywords are reserved names and can't be used as route names or parameters:</p>
<ul>
<li><code>action</code></li>
<li><code>area</code></li>
<li><code>controller</code></li>
<li><code>handler</code></li>
<li><code>page</code></li>
</ul>
<h2 data-id="route-constraint-reference-1">Route constraint reference<a href="#route-constraint-reference-1" aria-labelledby="route-constraint-reference-1"></a></h2>
<p>Route constraints execute when a match has occurred to the incoming URL and the URL path is tokenized into route values. Route constraints generally inspect the route value associated via the route template and make a yes/no decision about whether or not the value is acceptable. Some route constraints use data outside the route value to consider whether the request can be routed. For example, the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.constraints.httpmethodrouteconstraint" data-linktype="absolute-path">HttpMethodRouteConstraint</a> can accept or reject a request based on its HTTP verb. Constraints are used in routing requests and link generation.</p>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Don't use constraints for <strong>input validation</strong>. If constraints are used for <strong>input validation</strong>, invalid input results in a <em>404 - Not Found</em> response instead of a <em>400 - Bad Request</em> with an appropriate error message. Route constraints are used to <strong>disambiguate</strong> similar routes, not to validate the inputs for a particular route.</p>
</div>
<p>The following table demonstrates example route constraints and their expected behavior.</p>

<p>Multiple, colon-delimited constraints can be applied to a single parameter. For example, the following constraint restricts a parameter to an integer value of 1 or greater:</p>
<pre tabindex="0"><code data-author-content="[Route(&quot;users/{id:int:min(1)}&quot;)]
public User GetUserById(int id) { }
">[Route("users/{id:int:min(1)}")]
public User GetUserById(int id) { }
</code></pre>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Route constraints that verify the URL and are converted to a CLR type (such as <code>int</code> or <code>DateTime</code>) always use the invariant culture. These constraints assume that the URL is non-localizable. The framework-provided route constraints don't modify the values stored in route values. All route values parsed from the URL are stored as strings. For example, the <code>float</code> constraint attempts to convert the route value to a float, but the converted value is used only to verify it can be converted to a float.</p>
</div>
<h2 data-id="regular-expressions-1">Regular expressions<a href="#regular-expressions-1" aria-labelledby="regular-expressions-1"></a></h2>
<p>The ASP.NET Core framework adds <code>RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant</code> to the regular expression constructor. See <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions" data-linktype="absolute-path">RegexOptions</a> for a description of these members.</p>
<p>Regular expressions use delimiters and tokens similar to those used by Routing and the C# language. Regular expression tokens must be escaped. To use the regular expression <code>^\d{3}-\d{2}-\d{4}$</code> in routing, the expression must have the <code>\</code> (single backslash) characters provided in the string as <code>\\</code> (double backslash) characters in the C# source file in order to escape the <code>\</code> string escape character (unless using <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string" data-linktype="absolute-path">verbatim string literals</a>). To escape routing parameter delimiter characters (<code>{</code>, <code>}</code>, <code>[</code>, <code>]</code>), double the characters in the expression (<code>{{</code>, <code>}</code>, <code>[[</code>, <code>]]</code>). The following table shows a regular expression and the escaped version.</p>

<p>Regular expressions used in routing often start with the caret (<code>^</code>) character and match starting position of the string. The expressions often end with the dollar sign (<code>$</code>) character and match end of the string. The <code>^</code> and <code>$</code> characters ensure that the regular expression match the entire route parameter value. Without the <code>^</code> and <code>$</code> characters, the regular expression match any substring within the string, which is often undesirable. The following table provides examples and explains why they match or fail to match.</p>

<p>For more information on regular expression syntax, see <a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference" data-linktype="absolute-path">.NET Framework Regular Expressions</a>.</p>
<p>To constrain a parameter to a known set of possible values, use a regular expression. For example, <code>{action:regex(^(list|get|create)$)}</code> only matches the <code>action</code> route value to <code>list</code>, <code>get</code>, or <code>create</code>. If passed into the constraints dictionary, the string <code>^(list|get|create)$</code> is equivalent. Constraints that are passed in the constraints dictionary (not inline within a template) that don't match one of the known constraints are also treated as regular expressions.</p>
<h2 data-id="custom-route-constraints-1">Custom Route Constraints<a href="#custom-route-constraints-1" aria-labelledby="custom-route-constraints-1"></a></h2>
<p>In addition to the built-in route constraints, custom route constraints can be created by implementing the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> interface. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> interface contains a single method, <code>Match</code>, which returns <code>true</code> if the constraint is satisfied and <code>false</code> otherwise.</p>
<p>To use a custom <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a>, the route constraint type must be registered with the app's <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> in the app's service container. A <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> is a dictionary that maps route constraint keys to <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> implementations that validate those constraints. An app's <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> can be updated in <code>Startup.ConfigureServices</code> either as part of a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.routingservicecollectionextensions.addrouting" data-linktype="absolute-path">services.AddRouting</a> call or by configuring <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions" data-linktype="absolute-path">RouteOptions</a> directly with <code>services.Configure&lt;RouteOptions&gt;</code>. For example:</p>
<pre tabindex="0"><code data-author-content="services.AddRouting(options =>
{
    options.ConstraintMap.Add(&quot;customName&quot;, typeof(MyCustomConstraint));
});
">services.AddRouting(options =&gt;
{
    options.ConstraintMap.Add("customName", typeof(MyCustomConstraint));
});
</code></pre>
<p>The constraint can then be applied to routes in the usual manner, using the name specified when registering the constraint type. For example:</p>
<pre tabindex="0"><code data-author-content="[HttpGet(&quot;{id:customName}&quot;)]
public ActionResult<string> Get(string id)
">[HttpGet("{id:customName}")]
public ActionResult&lt;string&gt; Get(string id)
</code></pre>
<h2 data-id="parameter-transformer-reference-1">Parameter transformer reference<a href="#parameter-transformer-reference-1" aria-labelledby="parameter-transformer-reference-1"></a></h2>
<p>Parameter transformers:</p>
<ul>
<li>Execute when generating a link for a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a>.</li>
<li>Implement <code>Microsoft.AspNetCore.Routing.IOutboundParameterTransformer</code>.</li>
<li>Are configured using <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a>.</li>
<li>Take the parameter's route value and transform it to a new string value.</li>
<li>Result in using the transformed value in the generated link.</li>
</ul>
<p>For example, a custom <code>slugify</code> parameter transformer in route pattern <code>blog\{article:slugify}</code> with <code>Url.Action(new { article = "MyTestArticle" })</code> generates <code>blog\my-test-article</code>.</p>
<p>To use a parameter transformer in a route pattern, configure it first using <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> in <code>Startup.ConfigureServices</code>:</p>
<pre tabindex="0"><code data-author-content="services.AddRouting(options =>
{
    // Replace the type and the name used to refer to it with your own
    // IOutboundParameterTransformer implementation
    options.ConstraintMap[&quot;slugify&quot;] = typeof(SlugifyParameterTransformer);
});
">services.AddRouting(options =&gt;
{
    // Replace the type and the name used to refer to it with your own
    // IOutboundParameterTransformer implementation
    options.ConstraintMap["slugify"] = typeof(SlugifyParameterTransformer);
});
</code></pre>
<p>Parameter transformers are used by the framework to transform the URI where an endpoint resolves. For example, ASP.NET Core MVC uses parameter transformers to transform the route value used to match an <code>area</code>, <code>controller</code>, <code>action</code>, and <code>page</code>.</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller:slugify=Home}/{action:slugify=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller:slugify=Home}/{action:slugify=Index}/{id?}");
</code></pre>
<p>With the preceding route, the action <code>SubscriptionManagementController.GetAll()</code> is matched with the URI <code>/subscription-management/get-all</code>. A parameter transformer doesn't change the route values used to generate a link. For example, <code>Url.Action("GetAll", "SubscriptionManagement")</code> outputs <code>/subscription-management/get-all</code>.</p>
<p>ASP.NET Core provides API conventions for using a parameter transformers with generated routes:</p>
<ul>
<li>ASP.NET Core MVC has the <code>Microsoft.AspNetCore.Mvc.ApplicationModels.RouteTokenTransformerConvention</code> API convention. This convention applies a specified parameter transformer to all attribute routes in the app. The parameter transformer transforms attribute route tokens as they are replaced. For more information, see <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing#use-a-parameter-transformer-to-customize-token-replacement" data-linktype="absolute-path">Use a parameter transformer to customize token replacement</a>.</li>
<li>Razor Pages has the <code>Microsoft.AspNetCore.Mvc.ApplicationModels.PageRouteTransformerConvention</code> API convention. This convention applies a specified parameter transformer to all automatically discovered Razor Pages. The parameter transformer transforms the folder and file name segments of Razor Pages routes. For more information, see <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/razor-pages-conventions#use-a-parameter-transformer-to-customize-page-routes" data-linktype="absolute-path">Use a parameter transformer to customize page routes</a>.</li>
</ul>
<h2 data-id="url-generation-reference-1">URL generation reference<a href="#url-generation-reference-1" aria-labelledby="url-generation-reference-1"></a></h2>
<p>The following example shows how to generate a link to a route given a dictionary of route values and a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routecollection" data-linktype="absolute-path">RouteCollection</a>.</p>
<pre tabindex="0"><code data-author-content="app.Run(async (context) =>
{
    var dictionary = new RouteValueDictionary
    {
        { &quot;operation&quot;, &quot;create&quot; },
        { &quot;id&quot;, 123}
    };

    var vpc = new VirtualPathContext(context, null, dictionary, 
        &quot;Track Package Route&quot;);
    var path = routes.GetVirtualPath(vpc).VirtualPath;

    context.Response.ContentType = &quot;text/html&quot;;
    await context.Response.WriteAsync(&quot;Menu<hr/>&quot;);
    await context.Response.WriteAsync(
        $&quot;<a href='{path}'>Create Package 123</a><br/>&quot;);
});
">app.Run(async (context) =&gt;
{
    var dictionary = new RouteValueDictionary
    {
        { "operation", "create" },
        { "id", 123}
    };

    var vpc = new VirtualPathContext(context, null, dictionary, 
        "Track Package Route");
    var path = routes.GetVirtualPath(vpc).VirtualPath;

    context.Response.ContentType = "text/html";
    await context.Response.WriteAsync("Menu&lt;hr/&gt;");
    await context.Response.WriteAsync(
        $"&lt;a href='{path}'&gt;Create Package 123&lt;/a&gt;&lt;br/&gt;");
});
</code></pre>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata.virtualpath#Microsoft_AspNetCore_Routing_VirtualPathData_VirtualPath" data-linktype="absolute-path">VirtualPath</a> generated at the end of the preceding sample is <code>/package/create/123</code>. The dictionary supplies the <code>operation</code> and <code>id</code> route values of the "Track Package Route" template, <code>package/{operation}/{id}</code>. For details, see the sample code in the <a href="#use-routing-middleware" data-linktype="self-bookmark">Use Routing Middleware</a> section or the <a href="https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples" data-linktype="external">sample app</a>.</p>
<p>The second parameter to the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext" data-linktype="absolute-path">VirtualPathContext</a> constructor is a collection of <em>ambient values</em>. Ambient values are convenient to use because they limit the number of values a developer must specify within a request context. The current route values of the current request are considered ambient values for link generation. In an ASP.NET Core MVC app's <code>About</code> action of the <code>HomeController</code>, you don't need to specify the controller route value to link to the <code>Index</code> actionâ€”the ambient value of <code>Home</code> is used.</p>
<p>Ambient values that don't match a parameter are ignored. Ambient values are also ignored when an explicitly provided value overrides the ambient value. Matching occurs from left to right in the URL.</p>
<p>Values explicitly provided but that don't match a segment of the route are added to the query string. The following table shows the result when using the route template <code>{controller}/{action}/{id?}</code>.</p>

<p>If a route has a default value that doesn't correspond to a parameter and that value is explicitly provided, it must match the default value:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(&quot;blog_route&quot;, &quot;blog/{*slug}&quot;,
    defaults: new { controller = &quot;Blog&quot;, action = &quot;ReadPost&quot; });
">routes.MapRoute("blog_route", "blog/{*slug}",
    defaults: new { controller = "Blog", action = "ReadPost" });
</code></pre>
<p>Link generation only generates a link for this route when the matching values for <code>controller</code> and <code>action</code> are provided.</p>
<h2 data-id="complex-segments-1">Complex segments<a href="#complex-segments-1" aria-labelledby="complex-segments-1"></a></h2>
<p>Complex segments (for example <code>[Route("/x{token}y")]</code>) are processed by matching up literals from right to left in a non-greedy way. See <a href="https://github.com/dotnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293" data-linktype="external">this code</a> for a detailed explanation of how complex segments are matched. The <a href="https://github.com/dotnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293" data-linktype="external">code sample</a> is not used by ASP.NET Core, but it provides a good explanation of complex segments.</p>
<!-- While that code is no longer used by ASP.NET Core for complex segment matching, it provides a good match to the current algorithm. The [current code](https://github.com/dotnet/AspNetCore/blob/91514c9af7e0f4c44029b51f05a01c6fe4c96e4c/src/Http/Routing/src/Matching/DfaMatcherBuilder.cs#L227-L244) is too abstracted from matching to be useful for understanding complex segment matching.
-->
</div>
<div data-moniker="aspnetcore-2.1">
<p>Routing is responsible for mapping request URIs to route handlers and dispatching an incoming requests. Routes are defined in the app and configured when the app starts. A route can optionally extract values from the URL contained in the request, and these values can then be used for request processing. Using configured routes from the app, routing is able to generate URLs that map to route handlers.</p>
<p>To use the latest routing scenarios in ASP.NET Core 2.1, specify the <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/compatibility-version?view=aspnetcore-3.1" data-linktype="relative-path">compatibility version</a> to the MVC services registration in <code>Startup.ConfigureServices</code>:</p>
<pre tabindex="0"><code data-author-content="services.AddMvc()
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
">services.AddMvc()
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
</code></pre>

<p><a href="https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples" data-linktype="external">View or download sample code</a> (<a href="https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-3.1#how-to-download-a-sample" data-linktype="relative-path">how to download</a>)</p>
<h2 data-id="routing-basics-2">Routing basics<a href="#routing-basics-2" aria-labelledby="routing-basics-2"></a></h2>
<p>Most apps should choose a basic and descriptive routing scheme so that URLs are readable and meaningful. The default conventional route <code>{controller=Home}/{action=Index}/{id?}</code>:</p>
<ul>
<li>Supports a basic and descriptive routing scheme.</li>
<li>Is a useful starting point for UI-based apps.</li>
</ul>
<p>Developers commonly add additional terse routes to high-traffic areas of an app in specialized situations (for example, blog and ecommerce endpoints) using <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-3.1#attribute-routing" data-linktype="relative-path">attribute routing</a> or dedicated conventional routes.</p>
<p>Web APIs should use attribute routing to model the app's functionality as a set of resources where operations are represented by HTTP verbs. This means that many operations (for example, GET, POST) on the same logical resource will use the same URL. Attribute routing provides a level of control that's needed to carefully design an API's public endpoint layout.</p>
<p>Razor Pages apps use default conventional routing to serve named resources in the <em>Pages</em> folder of an app. Additional conventions are available that allow you to customize Razor Pages routing behavior. For more information, see <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.1" data-linktype="relative-path">Introduction to Razor Pages in ASP.NET Core</a> and <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/razor-pages-conventions?view=aspnetcore-3.1" data-linktype="relative-path">Razor Pages route and app conventions in ASP.NET Core</a>.</p>
<p>URL generation support allows the app to be developed without hard-coding URLs to link the app together. This support allows for starting with a basic routing configuration and modifying the routes after the app's resource layout is determined.</p>
<p>Routing uses <em>routes</em> (implementations of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter" data-linktype="absolute-path">IRouter</a>) to:</p>
<ul>
<li>Map incoming requests to <em>route handlers</em>.</li>
<li>Generate the URLs used in responses.</li>
</ul>
<p>By default, an app has a single collection of routes. When a request arrives, the routes in the collection are processed in the order that they exist in the collection. The framework attempts to match an incoming request URL to a route in the collection by calling the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter.routeasync" data-linktype="absolute-path">RouteAsync</a> method on each route in the collection. A response can use routing to generate URLs (for example, for redirection or links) based on route information and thus avoid hard-coded URLs, which helps maintainability.</p>
<p>The routing system has the following characteristics:</p>
<ul>
<li>Route template syntax is used to define routes with tokenized route parameters.</li>
<li>Conventional-style and attribute-style endpoint configuration is permitted.</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> is used to determine whether a URL parameter contains a valid value for a given endpoint constraint.</li>
<li>App models, such as MVC/Razor Pages, register all of their routes, which have a predictable implementation of routing scenarios.</li>
<li>A response can use routing to generate URLs (for example, for redirection or links) based on route information and thus avoid hard-coded URLs, which helps maintainability.</li>
<li>URL generation is based on routes, which support arbitrary extensibility. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper" data-linktype="absolute-path">IUrlHelper</a> offers methods to build URLs.</li>
</ul>
<p>Routing is connected to the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-3.1" data-linktype="relative-path">middleware</a> pipeline by the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.routermiddleware" data-linktype="absolute-path">RouterMiddleware</a> class. <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/overview?view=aspnetcore-3.1" data-linktype="relative-path">ASP.NET Core MVC</a> adds routing to the middleware pipeline as part of its configuration and handles routing in MVC and Razor Pages apps. To learn how to use routing as a standalone component, see the <a href="#use-routing-middleware" data-linktype="self-bookmark">Use Routing Middleware</a> section.</p>
<h3 data-id="url-matching-2">URL matching<a href="#url-matching-2" aria-labelledby="url-matching-2"></a></h3>
<p>URL matching is the process by which routing dispatches an incoming request to a <em>handler</em>. This process is based on data in the URL path but can be extended to consider any data in the request. The ability to dispatch requests to separate handlers is key to scaling the size and complexity of an app.</p>
<p>Incoming requests enter the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.routermiddleware" data-linktype="absolute-path">RouterMiddleware</a>, which calls the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter.routeasync" data-linktype="absolute-path">RouteAsync</a> method on each route in sequence. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter" data-linktype="absolute-path">IRouter</a> instance chooses whether to <em>handle</em> the request by setting the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routecontext.handler" data-linktype="absolute-path">RouteContext.Handler</a> to a non-null <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.requestdelegate" data-linktype="absolute-path">RequestDelegate</a>. If a route sets a handler for the request, route processing stops, and the handler is invoked to process the request. If no route handler is found to process the request, the middleware hands the request off to the next middleware in the request pipeline.</p>
<p>The primary input to <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter.routeasync" data-linktype="absolute-path">RouteAsync</a> is the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routecontext.httpcontext" data-linktype="absolute-path">RouteContext.HttpContext</a> associated with the current request. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routecontext.handler#Microsoft_AspNetCore_Routing_RouteContext_Handler" data-linktype="absolute-path">RouteContext.Handler</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routecontext.routedata" data-linktype="absolute-path">RouteContext.RouteData</a> are outputs set after a route is matched.</p>
<p>A match that calls <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter.routeasync" data-linktype="absolute-path">RouteAsync</a> also sets the properties of the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routecontext.routedata#Microsoft_AspNetCore_Routing_RouteContext_RouteData" data-linktype="absolute-path">RouteContext.RouteData</a> to appropriate values based on the request processing performed thus far.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.values" data-linktype="absolute-path">RouteData.Values</a> is a dictionary of <em>route values</em> produced from the route. These values are usually determined by tokenizing the URL and can be used to accept user input or to make further dispatching decisions inside the app.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.datatokens" data-linktype="absolute-path">RouteData.DataTokens</a> is a property bag of additional data related to the matched route. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.datatokens" data-linktype="absolute-path">DataTokens</a> are provided to support associating state data with each route so that the app can make decisions based on which route matched. These values are developer-defined and do <strong>not</strong> affect the behavior of routing in any way. Additionally, values stashed in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.datatokens" data-linktype="absolute-path">RouteData.DataTokens</a> can be of any type, in contrast to <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.values#Microsoft_AspNetCore_Routing_RouteData_Values" data-linktype="absolute-path">RouteData.Values</a>, which must be convertible to and from strings.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">RouteData.Routers</a> is a list of the routes that took part in successfully matching the request. Routes can be nested inside of one another. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">Routers</a> property reflects the path through the logical tree of routes that resulted in a match. Generally, the first item in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">Routers</a> is the route collection and should be used for URL generation. The last item in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.routers#Microsoft_AspNetCore_Routing_RouteData_Routers" data-linktype="absolute-path">Routers</a> is the route handler that matched.</p>

<h3 data-id="url-generation">URL generation<a href="#url-generation" aria-labelledby="url-generation"></a></h3>
<p>URL generation is the process by which routing can create a URL path based on a set of route values. This allows for a logical separation between route handlers and the URLs that access them.</p>
<p>URL generation follows a similar iterative process, but it starts with user or framework code calling into the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter.getvirtualpath" data-linktype="absolute-path">GetVirtualPath</a> method of the route collection. Each <em>route</em> has its <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter.getvirtualpath" data-linktype="absolute-path">GetVirtualPath</a> method called in sequence until a non-null <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata" data-linktype="absolute-path">VirtualPathData</a> is returned.</p>
<p>The primary inputs to <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter.getvirtualpath" data-linktype="absolute-path">GetVirtualPath</a> are:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext.httpcontext#Microsoft_AspNetCore_Routing_VirtualPathContext_HttpContext" data-linktype="absolute-path">VirtualPathContext.HttpContext</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext.values#Microsoft_AspNetCore_Routing_VirtualPathContext_Values" data-linktype="absolute-path">VirtualPathContext.Values</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext.ambientvalues#Microsoft_AspNetCore_Routing_VirtualPathContext_AmbientValues" data-linktype="absolute-path">VirtualPathContext.AmbientValues</a></li>
</ul>
<p>Routes primarily use the route values provided by <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext.values#Microsoft_AspNetCore_Routing_VirtualPathContext_Values" data-linktype="absolute-path">Values</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext.ambientvalues#Microsoft_AspNetCore_Routing_VirtualPathContext_AmbientValues" data-linktype="absolute-path">AmbientValues</a> to decide whether it's possible to generate a URL and what values to include. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext.ambientvalues#Microsoft_AspNetCore_Routing_VirtualPathContext_AmbientValues" data-linktype="absolute-path">AmbientValues</a> are the set of route values that were produced from matching the current request. In contrast, <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext.values#Microsoft_AspNetCore_Routing_VirtualPathContext_Values" data-linktype="absolute-path">Values</a> are the route values that specify how to generate the desired URL for the current operation. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext.httpcontext#Microsoft_AspNetCore_Routing_VirtualPathContext_HttpContext" data-linktype="absolute-path">HttpContext</a> is provided in case a route should obtain services or additional data associated with the current context.</p>

<p>The output of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter.getvirtualpath" data-linktype="absolute-path">GetVirtualPath</a> is a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata" data-linktype="absolute-path">VirtualPathData</a>. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata" data-linktype="absolute-path">VirtualPathData</a> is a parallel of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata" data-linktype="absolute-path">RouteData</a>. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata" data-linktype="absolute-path">VirtualPathData</a> contains the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata.virtualpath#Microsoft_AspNetCore_Routing_VirtualPathData_VirtualPath" data-linktype="absolute-path">VirtualPath</a> for the output URL and some additional properties that should be set by the route.</p>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata.virtualpath" data-linktype="absolute-path">VirtualPathData.VirtualPath</a> property contains the <em>virtual path</em> produced by the route. Depending on your needs, you may need to process the path further. If you want to render the generated URL in HTML, prepend the base path of the app.</p>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata.router" data-linktype="absolute-path">VirtualPathData.Router</a> is a reference to the route that successfully generated the URL.</p>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata.datatokens" data-linktype="absolute-path">VirtualPathData.DataTokens</a> properties is a dictionary of additional data related to the route that generated the URL. This is the parallel of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routedata.datatokens" data-linktype="absolute-path">RouteData.DataTokens</a>.</p>
<h3 data-id="create-routes-2">Create routes<a href="#create-routes-2" aria-labelledby="create-routes-2"></a></h3>
<p>Routing provides the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> class as the standard implementation of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter" data-linktype="absolute-path">IRouter</a>. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> uses the <em>route template</em> syntax to define patterns to match against the URL path when <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter.routeasync" data-linktype="absolute-path">RouteAsync</a> is called. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> uses the same route template to generate a URL when <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouter.getvirtualpath" data-linktype="absolute-path">GetVirtualPath</a> is called.</p>
<p>Most apps create routes by calling <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> or one of the similar extension methods defined on <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iroutebuilder" data-linktype="absolute-path">IRouteBuilder</a>. Any of the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iroutebuilder" data-linktype="absolute-path">IRouteBuilder</a> extension methods create an instance of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> and add it to the route collection.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> doesn't accept a route handler parameter. <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> only adds routes that are handled by the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routebuilder.defaulthandler" data-linktype="absolute-path">DefaultHandler</a>. The default handler is an <code>IRouter</code>, and the handler might not handle the request. For example, ASP.NET Core MVC is typically configured as a default handler that only handles requests that match an available controller and action. To learn more about routing in MVC, see <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-3.1" data-linktype="relative-path">Routing to controller actions in ASP.NET Core</a>.</p>
<p>The following code example is an example of a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> call used by a typical ASP.NET Core MVC route definition:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<p>This template matches a URL path and extracts the route values. For example, the path <code>/Products/Details/17</code> generates the following route values: <code>{ controller = Products, action = Details, id = 17 }</code>.</p>
<p>Route values are determined by splitting the URL path into segments and matching each segment with the <em>route parameter</em> name in the route template. Route parameters are named. The parameters defined by enclosing the parameter name in braces <code>{ ... }</code>.</p>
<p>The preceding template could also match the URL path <code>/</code> and produce the values <code>{ controller = Home, action = Index }</code>. This occurs because the <code>{controller}</code> and <code>{action}</code> route parameters have default values and the <code>id</code> route parameter is optional. An equals sign (<code>=</code>) followed by a value after the route parameter name defines a default value for the parameter. A question mark (<code>?</code>) after the route parameter name defines an optional parameter.</p>
<p>Route parameters with a default value <em>always</em> produce a route value when the route matches. Optional parameters don't produce a route value if there was no corresponding URL path segment. See the <a href="#route-template-reference" data-linktype="self-bookmark">Route template reference</a> section for a thorough description of route template scenarios and syntax.</p>
<p>In the following example, the route parameter definition <code>{id:int}</code> defines a <a href="#route-constraint-reference" data-linktype="self-bookmark">route constraint</a> for the <code>id</code> route parameter:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id:int}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id:int}");
</code></pre>
<p>This template matches a URL path like <code>/Products/Details/17</code> but not <code>/Products/Details/Apples</code>. Route constraints implement <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> and inspect route values to verify them. In this example, the route value <code>id</code> must be convertible to an integer. See <a href="#route-constraint-reference" data-linktype="self-bookmark">route-constraint-reference</a> for an explanation of route constraints provided by the framework.</p>
<p>Additional overloads of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> accept values for <code>constraints</code>, <code>dataTokens</code>, and <code>defaults</code>. The typical usage of these parameters is to pass an anonymously typed object, where the property names of the anonymous type match route parameter names.</p>
<p>The following <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.maprouteroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a> examples create equivalent routes:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default_route&quot;,
    template: &quot;{controller}/{action}/{id?}&quot;,
    defaults: new { controller = &quot;Home&quot;, action = &quot;Index&quot; });

routes.MapRoute(
    name: &quot;default_route&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default_route",
    template: "{controller}/{action}/{id?}",
    defaults: new { controller = "Home", action = "Index" });

routes.MapRoute(
    name: "default_route",
    template: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>The inline syntax for defining constraints and defaults can be convenient for simple routes. However, there are scenarios, such as data tokens, that aren't supported by inline syntax.</p>
</div>
<p>The following example demonstrates a few additional scenarios:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;blog&quot;,
    template: &quot;Blog/{*article}&quot;,
    defaults: new { controller = &quot;Blog&quot;, action = &quot;ReadArticle&quot; });
">routes.MapRoute(
    name: "blog",
    template: "Blog/{*article}",
    defaults: new { controller = "Blog", action = "ReadArticle" });
</code></pre>
<p>The preceding template matches a URL path like <code>/Blog/All-About-Routing/Introduction</code> and extracts the values <code>{ controller = Blog, action = ReadArticle, article = All-About-Routing/Introduction }</code>. The default route values for <code>controller</code> and <code>action</code> are produced by the route even though there are no corresponding route parameters in the template. Default values can be specified in the route template. The <code>article</code> route parameter is defined as a <em>catch-all</em> by the appearance of an asterisk (<code>*</code>) before the route parameter name. Catch-all route parameters capture the remainder of the URL path and can also match the empty string.</p>
<p>The following example adds route constraints and data tokens:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;us_english_products&quot;,
    template: &quot;en-US/Products/{id}&quot;,
    defaults: new { controller = &quot;Products&quot;, action = &quot;Details&quot; },
    constraints: new { id = new IntRouteConstraint() },
    dataTokens: new { locale = &quot;en-US&quot; });
">routes.MapRoute(
    name: "us_english_products",
    template: "en-US/Products/{id}",
    defaults: new { controller = "Products", action = "Details" },
    constraints: new { id = new IntRouteConstraint() },
    dataTokens: new { locale = "en-US" });
</code></pre>
<p>The preceding template matches a URL path like <code>/en-US/Products/5</code> and extracts the values <code>{ controller = Products, action = Details, id = 5 }</code> and the data tokens <code>{ locale = en-US }</code>.</p>
<p><img src="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing/_static/tokens.png?view=aspnetcore-3.1" alt="Locals Windows tokens" data-linktype="relative-path"></p>
<h3 data-id="route-class-url-generation-2">Route class URL generation<a href="#route-class-url-generation-2" aria-labelledby="route-class-url-generation-2"></a></h3>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> class can also perform URL generation by combining a set of route values with its route template. This is logically the reverse process of matching the URL path.</p>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>To better understand URL generation, imagine what URL you want to generate and then think about how a route template would match that URL. What values would be produced? This is the rough equivalent of how URL generation works in the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a> class.</p>
</div>
<p>The following example uses a general ASP.NET Core MVC default route:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(
    name: &quot;default&quot;,
    template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
">routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
</code></pre>
<p>With the route values <code>{ controller = Products, action = List }</code>, the URL <code>/Products/List</code> is generated. The route values are substituted for the corresponding route parameters to form the URL path. Since <code>id</code> is an optional route parameter, the URL is successfully generated without a value for <code>id</code>.</p>
<p>With the route values <code>{ controller = Home, action = Index }</code>, the URL <code>/</code> is generated. The provided route values match the default values, and the segments corresponding to the default values are safely omitted.</p>
<p>Both URLs generated round-trip with the following route definition (<code>/Home/Index</code> and <code>/</code>) produce the same route values that were used to generate the URL.</p>
<div>
<p><span aria-hidden="true"></span> Note</p>
<p>An app using ASP.NET Core MVC should use <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routing.urlhelper" data-linktype="absolute-path">UrlHelper</a> to generate URLs instead of calling into routing directly.</p>
</div>
<p>For more information on URL generation, see the <a href="#url-generation-reference" data-linktype="self-bookmark">Url generation reference</a> section.</p>
<h2 data-id="use-routing-middleware-2">Use Routing Middleware<a href="#use-routing-middleware-2" aria-labelledby="use-routing-middleware-2"></a></h2>
<p>Reference the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/metapackage-app?view=aspnetcore-3.1" data-linktype="relative-path">Microsoft.AspNetCore.App metapackage</a> in the app's project file.</p>
<p>Add routing to the service container in <code>Startup.ConfigureServices</code>:</p>
<pre tabindex="0"><code highlight-lines="3" data-author-content="public void ConfigureServices(IServiceCollection services)
{
    services.AddRouting();
}
">public void ConfigureServices(IServiceCollection services)
{
    services.AddRouting();
}
</code></pre>
<p>Routes must be configured in the <code>Startup.Configure</code> method. The sample app uses the following APIs:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routebuilder" data-linktype="absolute-path">RouteBuilder</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a> â€“ Matches only HTTP GET requests.</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.routingbuilderextensions.userouter" data-linktype="absolute-path">UseRouter</a></li>
</ul>
<pre tabindex="0"><code data-author-content="var trackPackageRouteHandler = new RouteHandler(context =>
{
    var routeValues = context.GetRouteData().Values;
    return context.Response.WriteAsync(
        $&quot;Hello! Route values: {string.Join(&quot;, &quot;, routeValues)}&quot;);
});

var routeBuilder = new RouteBuilder(app, trackPackageRouteHandler);

routeBuilder.MapRoute(
    &quot;Track Package Route&quot;,
    &quot;package/{operation:regex(^track|create$)}/{id:int}&quot;);

routeBuilder.MapGet(&quot;hello/{name}&quot;, context =>
{
    var name = context.GetRouteValue(&quot;name&quot;);
    // The route handler when HTTP GET &quot;hello/<anything>&quot; matches
    // To match HTTP GET &quot;hello/<anything>/<anything>, 
    // use routeBuilder.MapGet(&quot;hello/{*name}&quot;
    return context.Response.WriteAsync($&quot;Hi, {name}!&quot;);
});

var routes = routeBuilder.Build();
app.UseRouter(routes);
">var trackPackageRouteHandler = new RouteHandler(context =&gt;
{
    var routeValues = context.GetRouteData().Values;
    return context.Response.WriteAsync(
        $"Hello! Route values: {string.Join(", ", routeValues)}");
});

var routeBuilder = new RouteBuilder(app, trackPackageRouteHandler);

routeBuilder.MapRoute(
    "Track Package Route",
    "package/{operation:regex(^track|create$)}/{id:int}");

routeBuilder.MapGet("hello/{name}", context =&gt;
{
    var name = context.GetRouteValue("name");
    // The route handler when HTTP GET "hello/&lt;anything&gt;" matches
    // To match HTTP GET "hello/&lt;anything&gt;/&lt;anything&gt;, 
    // use routeBuilder.MapGet("hello/{*name}"
    return context.Response.WriteAsync($"Hi, {name}!");
});

var routes = routeBuilder.Build();
app.UseRouter(routes);
</code></pre>
<p>The following table shows the responses with the given URIs.</p>

<p>If you're configuring a single route, call <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.routingbuilderextensions.userouter" data-linktype="absolute-path">UseRouter</a> passing in an <code>IRouter</code> instance. You won't need to use <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routebuilder" data-linktype="absolute-path">RouteBuilder</a>.</p>
<p>The framework provides a set of extension methods for creating routes (<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions" data-linktype="absolute-path">RequestDelegateRouteBuilderExtensions</a>):</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapdelete" data-linktype="absolute-path">MapDelete</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewaredelete" data-linktype="absolute-path">MapMiddlewareDelete</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareget" data-linktype="absolute-path">MapMiddlewareGet</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewarepost" data-linktype="absolute-path">MapMiddlewarePost</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareput" data-linktype="absolute-path">MapMiddlewarePut</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareroute" data-linktype="absolute-path">MapMiddlewareRoute</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapmiddlewareverb" data-linktype="absolute-path">MapMiddlewareVerb</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mappost" data-linktype="absolute-path">MapPost</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapput" data-linktype="absolute-path">MapPut</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapverb" data-linktype="absolute-path">MapVerb</a></li>
</ul>
<p>Some of listed methods, such as <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a>, require a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.requestdelegate" data-linktype="absolute-path">RequestDelegate</a>. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.requestdelegate" data-linktype="absolute-path">RequestDelegate</a> is used as the <em>route handler</em> when the route matches. Other methods in this family allow configuring a middleware pipeline for use as the route handler. If the <code>Map*</code> method doesn't accept a handler, such as <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.maproute" data-linktype="absolute-path">MapRoute</a>, it uses the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routebuilder.defaulthandler" data-linktype="absolute-path">DefaultHandler</a>.</p>
<p>The <code>Map[Verb]</code> methods use constraints to limit the route to the HTTP Verb in the method name. For example, see <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapget" data-linktype="absolute-path">MapGet</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.requestdelegateroutebuilderextensions.mapverb" data-linktype="absolute-path">MapVerb</a>.</p>
<h2 data-id="route-template-reference-2">Route template reference<a href="#route-template-reference-2" aria-labelledby="route-template-reference-2"></a></h2>
<p>Tokens within curly braces (<code>{ ... }</code>) define <em>route parameters</em> that are bound if the route is matched. You can define more than one route parameter in a route segment, but they must be separated by a literal value. For example, <code>{controller=Home}{action=Index}</code> isn't a valid route, since there's no literal value between <code>{controller}</code> and <code>{action}</code>. These route parameters must have a name and may have additional attributes specified.</p>
<p>Literal text other than route parameters (for example, <code>{id}</code>) and the path separator <code>/</code> must match the text in the URL. Text matching is case-insensitive and based on the decoded representation of the URLs path. To match a literal route parameter delimiter (<code>{</code> or <code>}</code>), escape the delimiter by repeating the character (<code>{{</code> or <code>}}</code>).</p>
<p>URL patterns that attempt to capture a file name with an optional file extension have additional considerations. For example, consider the template <code>files/{filename}.{ext?}</code>. When values for both <code>filename</code> and <code>ext</code> exist, both values are populated. If only a value for <code>filename</code> exists in the URL, the route matches because the trailing period (<code>.</code>) is  optional. The following URLs match this route:</p>
<ul>
<li><code>/files/myFile.txt</code></li>
<li><code>/files/myFile</code></li>
</ul>
<p>You can use the asterisk (<code>*</code>) as a prefix to a route parameter to bind to the rest of the URI. This is called a <em>catch-all</em> parameter. For example, <code>blog/{*slug}</code> matches any URI that starts with <code>/blog</code> and has any value following it, which is assigned to the <code>slug</code> route value. Catch-all parameters can also match the empty string.</p>
<p>The catch-all parameter escapes the appropriate characters when the route is used to generate a URL, including path separator (<code>/</code>) characters. For example, the route <code>foo/{*path}</code> with route values <code>{ path = "my/path" }</code> generates <code>foo/my%2Fpath</code>. Note the escaped forward slash.</p>
<p>Route parameters may have <em>default values</em> designated by specifying the default value after the parameter name separated by an equals sign (<code>=</code>). For example, <code>{controller=Home}</code> defines <code>Home</code> as the default value for <code>controller</code>. The default value is used if no value is present in the URL for the parameter. Route parameters are made optional by appending a question mark (<code>?</code>) to the end of the parameter name, as in <code>id?</code>. The difference between optional values and default route parameters is that a route parameter with a default value always produces a valueâ€”an optional parameter has a value only when a value is provided by the request URL.</p>
<p>Route parameters may have constraints that must match the route value bound from the URL. Adding a colon (<code>:</code>) and constraint name after the route parameter name specifies an <em>inline constraint</em> on a route parameter. If the constraint requires arguments, they're enclosed in parentheses (<code>(...)</code>) after the constraint name. Multiple inline constraints can be specified by appending another colon (<code>:</code>) and constraint name.</p>
<p>The constraint name and arguments are passed to the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.iinlineconstraintresolver" data-linktype="absolute-path">IInlineConstraintResolver</a> service to create an instance of <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> to use in URL processing. For example, the route template <code>blog/{article:minlength(10)}</code> specifies a <code>minlength</code> constraint with the argument <code>10</code>. For more information on route constraints and a list of the constraints provided by the framework, see the <a href="#route-constraint-reference" data-linktype="self-bookmark">Route constraint reference</a> section.</p>
<p>The following table demonstrates example route templates and their behavior.</p>

<p>Using a template is generally the simplest approach to routing. Constraints and defaults can also be specified outside the route template.</p>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>Enable <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-3.1" data-linktype="relative-path">Logging</a> to see how the built-in routing implementations, such as <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.route" data-linktype="absolute-path">Route</a>, match requests.</p>
</div>
<h2 data-id="reserved-routing-names-2">Reserved routing names<a href="#reserved-routing-names-2" aria-labelledby="reserved-routing-names-2"></a></h2>
<p>The following keywords are reserved names and can't be used as route names or parameters:</p>
<ul>
<li><code>action</code></li>
<li><code>area</code></li>
<li><code>controller</code></li>
<li><code>handler</code></li>
<li><code>page</code></li>
</ul>
<h2 data-id="route-constraint-reference-2">Route constraint reference<a href="#route-constraint-reference-2" aria-labelledby="route-constraint-reference-2"></a></h2>
<p>Route constraints execute when a match has occurred to the incoming URL and the URL path is tokenized into route values. Route constraints generally inspect the route value associated via the route template and make a yes/no decision about whether or not the value is acceptable. Some route constraints use data outside the route value to consider whether the request can be routed. For example, the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.constraints.httpmethodrouteconstraint" data-linktype="absolute-path">HttpMethodRouteConstraint</a> can accept or reject a request based on its HTTP verb. Constraints are used in routing requests and link generation.</p>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Don't use constraints for <strong>input validation</strong>. If constraints are used for <strong>input validation</strong>, invalid input results in a <em>404 - Not Found</em> response instead of a <em>400 - Bad Request</em> with an appropriate error message. Route constraints are used to <strong>disambiguate</strong> similar routes, not to validate the inputs for a particular route.</p>
</div>
<p>The following table demonstrates example route constraints and their expected behavior.</p>

<p>Multiple, colon-delimited constraints can be applied to a single parameter. For example, the following constraint restricts a parameter to an integer value of 1 or greater:</p>
<pre tabindex="0"><code data-author-content="[Route(&quot;users/{id:int:min(1)}&quot;)]
public User GetUserById(int id) { }
">[Route("users/{id:int:min(1)}")]
public User GetUserById(int id) { }
</code></pre>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Route constraints that verify the URL and are converted to a CLR type (such as <code>int</code> or <code>DateTime</code>) always use the invariant culture. These constraints assume that the URL is non-localizable. The framework-provided route constraints don't modify the values stored in route values. All route values parsed from the URL are stored as strings. For example, the <code>float</code> constraint attempts to convert the route value to a float, but the converted value is used only to verify it can be converted to a float.</p>
</div>
<h2 data-id="regular-expressions-2">Regular expressions<a href="#regular-expressions-2" aria-labelledby="regular-expressions-2"></a></h2>
<p>The ASP.NET Core framework adds <code>RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant</code> to the regular expression constructor. See <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions" data-linktype="absolute-path">RegexOptions</a> for a description of these members.</p>
<p>Regular expressions use delimiters and tokens similar to those used by Routing and the C# language. Regular expression tokens must be escaped. To use the regular expression <code>^\d{3}-\d{2}-\d{4}$</code> in routing, the expression must have the <code>\</code> (single backslash) characters provided in the string as <code>\\</code> (double backslash) characters in the C# source file in order to escape the <code>\</code> string escape character (unless using <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string" data-linktype="absolute-path">verbatim string literals</a>). To escape routing parameter delimiter characters (<code>{</code>, <code>}</code>, <code>[</code>, <code>]</code>), double the characters in the expression (<code>{{</code>, <code>}</code>, <code>[[</code>, <code>]]</code>). The following table shows a regular expression and the escaped version.</p>

<p>Regular expressions used in routing often start with the caret (<code>^</code>) character and match starting position of the string. The expressions often end with the dollar sign (<code>$</code>) character and match end of the string. The <code>^</code> and <code>$</code> characters ensure that the regular expression match the entire route parameter value. Without the <code>^</code> and <code>$</code> characters, the regular expression match any substring within the string, which is often undesirable. The following table provides examples and explains why they match or fail to match.</p>

<p>For more information on regular expression syntax, see <a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference" data-linktype="absolute-path">.NET Framework Regular Expressions</a>.</p>
<p>To constrain a parameter to a known set of possible values, use a regular expression. For example, <code>{action:regex(^(list|get|create)$)}</code> only matches the <code>action</code> route value to <code>list</code>, <code>get</code>, or <code>create</code>. If passed into the constraints dictionary, the string <code>^(list|get|create)$</code> is equivalent. Constraints that are passed in the constraints dictionary (not inline within a template) that don't match one of the known constraints are also treated as regular expressions.</p>
<h2 data-id="custom-route-constraints-2">Custom Route Constraints<a href="#custom-route-constraints-2" aria-labelledby="custom-route-constraints-2"></a></h2>
<p>In addition to the built-in route constraints, custom route constraints can be created by implementing the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> interface. The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> interface contains a single method, <code>Match</code>, which returns <code>true</code> if the constraint is satisfied and <code>false</code> otherwise.</p>
<p>To use a custom <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a>, the route constraint type must be registered with the app's <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> in the app's service container. A <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> is a dictionary that maps route constraint keys to <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.irouteconstraint" data-linktype="absolute-path">IRouteConstraint</a> implementations that validate those constraints. An app's <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions.constraintmap#Microsoft_AspNetCore_Routing_RouteOptions_ConstraintMap" data-linktype="absolute-path">ConstraintMap</a> can be updated in <code>Startup.ConfigureServices</code> either as part of a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.routingservicecollectionextensions.addrouting" data-linktype="absolute-path">services.AddRouting</a> call or by configuring <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routeoptions" data-linktype="absolute-path">RouteOptions</a> directly with <code>services.Configure&lt;RouteOptions&gt;</code>. For example:</p>
<pre tabindex="0"><code data-author-content="services.AddRouting(options =>
{
    options.ConstraintMap.Add(&quot;customName&quot;, typeof(MyCustomConstraint));
});
">services.AddRouting(options =&gt;
{
    options.ConstraintMap.Add("customName", typeof(MyCustomConstraint));
});
</code></pre>
<p>The constraint can then be applied to routes in the usual manner, using the name specified when registering the constraint type. For example:</p>
<pre tabindex="0"><code data-author-content="[HttpGet(&quot;{id:customName}&quot;)]
public ActionResult<string> Get(string id)
">[HttpGet("{id:customName}")]
public ActionResult&lt;string&gt; Get(string id)
</code></pre>
<h2 data-id="url-generation-reference-2">URL generation reference<a href="#url-generation-reference-2" aria-labelledby="url-generation-reference-2"></a></h2>
<p>The following example shows how to generate a link to a route given a dictionary of route values and a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.routecollection" data-linktype="absolute-path">RouteCollection</a>.</p>
<pre tabindex="0"><code data-author-content="app.Run(async (context) =>
{
    var dictionary = new RouteValueDictionary
    {
        { &quot;operation&quot;, &quot;create&quot; },
        { &quot;id&quot;, 123}
    };

    var vpc = new VirtualPathContext(context, null, dictionary, 
        &quot;Track Package Route&quot;);
    var path = routes.GetVirtualPath(vpc).VirtualPath;

    context.Response.ContentType = &quot;text/html&quot;;
    await context.Response.WriteAsync(&quot;Menu<hr/>&quot;);
    await context.Response.WriteAsync(
        $&quot;<a href='{path}'>Create Package 123</a><br/>&quot;);
});
">app.Run(async (context) =&gt;
{
    var dictionary = new RouteValueDictionary
    {
        { "operation", "create" },
        { "id", 123}
    };

    var vpc = new VirtualPathContext(context, null, dictionary, 
        "Track Package Route");
    var path = routes.GetVirtualPath(vpc).VirtualPath;

    context.Response.ContentType = "text/html";
    await context.Response.WriteAsync("Menu&lt;hr/&gt;");
    await context.Response.WriteAsync(
        $"&lt;a href='{path}'&gt;Create Package 123&lt;/a&gt;&lt;br/&gt;");
});
</code></pre>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathdata.virtualpath#Microsoft_AspNetCore_Routing_VirtualPathData_VirtualPath" data-linktype="absolute-path">VirtualPath</a> generated at the end of the preceding sample is <code>/package/create/123</code>. The dictionary supplies the <code>operation</code> and <code>id</code> route values of the "Track Package Route" template, <code>package/{operation}/{id}</code>. For details, see the sample code in the <a href="#use-routing-middleware" data-linktype="self-bookmark">Use Routing Middleware</a> section or the <a href="https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples" data-linktype="external">sample app</a>.</p>
<p>The second parameter to the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.routing.virtualpathcontext" data-linktype="absolute-path">VirtualPathContext</a> constructor is a collection of <em>ambient values</em>. Ambient values are convenient to use because they limit the number of values a developer must specify within a request context. The current route values of the current request are considered ambient values for link generation. In an ASP.NET Core MVC app's <code>About</code> action of the <code>HomeController</code>, you don't need to specify the controller route value to link to the <code>Index</code> actionâ€”the ambient value of <code>Home</code> is used.</p>
<p>Ambient values that don't match a parameter are ignored. Ambient values are also ignored when an explicitly provided value overrides the ambient value. Matching occurs from left to right in the URL.</p>
<p>Values explicitly provided but that don't match a segment of the route are added to the query string. The following table shows the result when using the route template <code>{controller}/{action}/{id?}</code>.</p>

<p>If a route has a default value that doesn't correspond to a parameter and that value is explicitly provided, it must match the default value:</p>
<pre tabindex="0"><code data-author-content="routes.MapRoute(&quot;blog_route&quot;, &quot;blog/{*slug}&quot;,
    defaults: new { controller = &quot;Blog&quot;, action = &quot;ReadPost&quot; });
">routes.MapRoute("blog_route", "blog/{*slug}",
    defaults: new { controller = "Blog", action = "ReadPost" });
</code></pre>
<p>Link generation only generates a link for this route when the matching values for <code>controller</code> and <code>action</code> are provided.</p>
<h2 data-id="complex-segments-2">Complex segments<a href="#complex-segments-2" aria-labelledby="complex-segments-2"></a></h2>
<p>Complex segments (for example <code>[Route("/x{token}y")]</code>) are processed by matching up literals from right to left in a non-greedy way. See <a href="https://github.com/dotnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293" data-linktype="external">this code</a> for a detailed explanation of how complex segments are matched. The <a href="https://github.com/dotnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293" data-linktype="external">code sample</a> is not used by ASP.NET Core, but it provides a good explanation of complex segments.</p>
<!-- While that code is no longer used by ASP.NET Core for complex segment matching, it provides a good match to the current algorithm. The [current code](https://github.com/dotnet/AspNetCore/blob/91514c9af7e0f4c44029b51f05a01c6fe4c96e4c/src/Http/Routing/src/Matching/DfaMatcherBuilder.cs#L227-L244) is too abstracted from matching to be useful for understanding complex segment matching.
-->
</div>

						<!-- </content> -->

						</main>

						<!-- recommended content page section -->

							<nav data-bi-name="recommendation-bottom" hidden="" id="recommended-content-center" aria-labelledby="recommended-content-center-title">
								<h3 id="recommended-content-center-title">Related Articles</h3>
							</nav>

						<!-- end recommended content page section -->

						<!-- rating mobile section -->
								
						<!-- end rating mobile section -->

						<!-- feedback section -->



<section data-bi-name="feedback-section">

	<h2 id="feedback">Feedback</h2>

	

	

	

	<div data-tab-group-independent="" hidden="" data-bi-name="tab-group">
		<ul role="tablist">
			<li role="presentation">
				<a href="#tabpanel-issues-open" role="tab" aria-controls="tabpanel-issues-open" data-tab="issues-open" data-bi-name="tab" aria-selected="true" tabindex="0"></a>
			</li>
			<li role="presentation">
				<a href="#tabpanel-issues-closed" role="tab" aria-controls="tabpanel-issues-closed" data-tab="issues-closed" data-bi-name="tab" aria-selected="false" tabindex="-1"></a>
			</li>
		</ul>
		<section id="tabpanel-issues-open" role="tabpanel" data-tab="issues-open">
			
			<ul aria-label="Open Issues"></ul>
		</section>
		<section id="tabpanel-issues-closed" role="tabpanel" data-tab="issues-closed" hidden="hidden" aria-hidden="true">
			<div>There are no closed issues</div>
			<ul aria-label="Closed Issues"></ul>
		</section>
	</div>
	
</section>

						<!-- end feedback section -->

						<!-- feedback report section -->
						<!-- end feedback report section -->

						
					</div>

					

					<!--end of div.columns -->
				</div>

			<!--end of .primary-holder -->
			</section>

			
		</div>

		<!--end of .mainContainer -->
	</div>

	

	

	


</div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>