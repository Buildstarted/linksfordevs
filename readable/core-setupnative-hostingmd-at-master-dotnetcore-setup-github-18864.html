<!DOCTYPE html>
<html lang="en">
<head>
    <title>
dotnet/core-setup - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="dotnet/core-setup - linksfor.dev(s)"/>
    <meta property="og:description" content="Installer packages for the .NET Core runtime and libraries - dotnet/core-setup"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/native-hosting.md"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - dotnet/core-setup</title>
<div class="readable">
        <h1>dotnet/core-setup</h1>
            <div>Reading time: 33-42 minutes</div>
        <div>Posted here: 30 Apr 2019</div>
        <p><a href="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/native-hosting.md">https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/native-hosting.md</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    <article itemprop="text">
<p>Native hosting is the ability to host the .NET Core runtime in an arbitrary process, one which didn't start from .NET Core produced binaries.</p>
<h4>Terminology</h4>
<ul>
<li>"native host" - the code which uses the proposed APIs. Can be any non .NET Core application (.NET Core applications have easier ways to perform these scenarios).</li>
<li>"hosting components" - shorthand for .NET Core hosting components. Typically refers to <code>hostfxr</code> and <code>hostpolicy</code>. Sometimes also referred to simply as "host".</li>
<li>"host context" - state which <code>hostfxr</code> creates and maintains and represents a logical operation on the hosting components.</li>
</ul>
<h2>Scenarios</h2>
<ul>
<li><strong>Hosting managed components</strong>
Native host which wants to load managed assembly and call into it for some functionality. Must support loading multiple such components side by side.</li>
<li><strong>Hosting managed apps</strong>
Native host which wants to run a managed app in-proc. Basically a different implementation of the existing .NET Core hosts (<code>dotnet.exe</code> or <code>apphost</code>). The intent is the ability to modify how the runtime starts and how the managed app is executed (and where it starts from).</li>
<li><strong>App using other .NET Core hosting services</strong>
App (native or .NET Core both) which needs to use some of the other services provided by the .NET Core hosting layer. For example the ability to locate available SDKs and so on.</li>
</ul>
<h2>Existing support</h2>
<ul>
<li><strong>C-style ABI in <code>coreclr</code></strong>
<code>coreclr</code> exposes ABI to host the .NET Core runtime and run managed code already using C-style APIs. See this <a href="https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h">header file</a> for the exposed functions.
This API requires the native host to locate the runtime and to fully specify all startup parameters for the runtime. There's no inherent interoperability between these APIs and the .NET Core SDK.</li>
<li><strong>COM-style ABI in <code>coreclr</code></strong>
<code>coreclr</code> exposes COM-style ABI to host the .NET Core runtime and perform a wide range of operations on it. See this <a href="https://github.com/dotnet/coreclr/blob/master/src/pal/prebuilt/inc/mscoree.h">header file</a> for more details.
Similarly to the C-style ABI the COM-style ABI also requires the native host to locate the runtime and to fully specify all startup parameters.
There's no inherent interoperability between these APIs and the .NET Core SDK.
The COM-style ABI is deprecated and should not be used going forward.</li>
<li><strong><code>hostfxr</code> and <code>hostpolicy</code> APIs</strong>
The hosting layer of .NET Core already exposes some functionality as C-style ABI on either the <code>hostfxr</code> or <code>hostpolicy</code> libraries. These can execute application, determine available SDKs, determine native dependency locations, resolve component dependencies and so on.
Unlike the above <code>coreclr</code> based APIs these don't require the caller to fully specify all startup parameters, instead these APIs understand artifacts produced by .NET Core SDK making it much easier to consume SDK produced apps/libraries.
The native host is still required to locate the <code>hostfxr</code> or <code>hostpolicy</code> libraries. These APIs are also designed for specific narrow scenarios, any usage outside of these bounds is typically not possible.</li>
</ul>
<h2>Scope</h2>
<p>This document focuses on hosting which cooperates with the .NET Core SDK and consumes the artifacts produced by building the managed app/libraries directly. It completely ignores the COM-style ABI as it's hard to use from some programming languages.</p>
<p>As such the document explicitly excludes any hosting based on directly loading <code>coreclr</code>. Instead it focuses on using the existing .NET Core hosting layer in new ways. For details on the .NET Core hosting components see <a href="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/host-components.md">this document</a>.</p>
<h2>High-level proposal</h2>
<p>In .NET Core 3.0 the hosting layer (see <a href="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/host-components.md">here</a>) ships with several hosts. These are binaries which act as the entry points to the .NET Core hosting/runtime:</p>
<ul>
<li>The "muxer" (<code>dotnet.exe</code>)</li>
<li>The <code>apphost</code> (<code>.exe</code> which is part of the app)</li>
<li>The <code>comhost</code> (<code>.dll</code> which is part of the app and acts as COM server)</li>
<li>The <code>ijwhost</code> (<code>.dll</code> consumed via <code>.lib</code> used by IJW assemblies)</li>
</ul>
<p>Every one of these hosts serve different scenario and expose different APIs. The one thing they have in common is that their main purpose is to find the right <code>hostfxr</code>, load it and call into it to execute the desired scenario. For the most part all these hosts are basically just wrappers around functionality provided by <code>hostfxr</code>.</p>
<p>The proposal is to add a new host library <code>nethost</code> which can be used by native host to easily locate <code>hostfxr</code>. Going forward the library could also include easy-to-use APIs for common scenarios - basically just a simplification of the <code>hostfxr</code> API surface.</p>
<p>At the same time add the ability to pass additional runtime properties when starting the runtime through the hosting entry points (starting app, loading component). This can be used by the native host to:</p>
<ul>
<li>Register startup hook without modifying environment variables (which are inherited by child processes)</li>
<li>Introduce new runtime knobs which are only available for native hosts without the need to update the hosting APIs every time.</li>
</ul>
<p><em>Technical note: All strings in the proposed APIs are using the <code>char_t</code> in this document for simplicity. In real implementation they are of the type <code>pal::char_t</code>. In particular:</em></p>
<ul>
<li><em>On Windows - they are <code>WCHAR *</code> using <code>UTF16</code> encoding</em></li>
<li><em>On Linux/macOS - they are <code>char *</code> using <code>UTF8</code> encoding</em></li>
</ul>
<h2>New host binary for finding <code>hostfxr</code></h2>
<p>New library <code>nethost</code> which provides a way to locate the right <code>hostfxr</code>.
This is a dynamically loaded library (<code>.dll</code>, <code>.so</code>, <code>.dylib</code>). For ease of use there is a header file for C/C++ apps as well as <code>.lib</code> for easy linking on Windows.
Native hosts ship this library as part of the app. Unlike the <code>apphost</code>, <code>comhost</code> and <code>ijwhost</code>, the <code>nethost</code> will not be directly supported by the .NET Core SDK since it's target usage is not from .NET Core apps.</p>
<p>The <code>nethost</code> is part of the <code>Microsoft.NETCore.DotNetAppHost</code> package. Users are expected to either download the package directly or rely on .NET SDK to pull it down.</p>
<p>The binary itself should be signed by Microsoft as there will be no support for modifying the binary as part of custom application build (unlike <code>apphost</code>).</p>
<h3>Locate <code>hostfxr</code></h3>
<div><pre><span>struct</span> <span>get_hostfxr_parameters</span> {
    <span>size_t</span> size;
    <span>const</span> <span>char_t</span> * assembly_path;
    <span>const</span> <span>char_t</span> * dotnet_root;
};

<span>int</span> <span>get_hostfxr_path</span>(
    <span>char_t</span> * result_buffer,
    <span>size_t</span> * buffer_size,
    <span>const</span> get_hostfxr_parameters * parameters);</pre></div>
<p>This API locates the <code>hostfxr</code> library and returns its path by populating <code>result_buffer</code>.</p>
<ul>
<li><code>result_buffer</code> - Buffer that will be populated with the hostfxr path, including a null terminator.</li>
<li><code>buffer_size</code> - On input this points to the size of the <code>result_buffer</code> in <code>char_t</code> units. On output this points to the number of <code>char_t</code> units used from the <code>result_buffer</code> (including the null terminator). If <code>result_buffer</code> is <code>nullptr</code> the input value is ignored and only the minimum required size in <code>char_t</code> units is set on output.</li>
<li><code>parameters</code> - Optional. Additional parameters that modify the behaviour for locating the <code>hostfxr</code> library. If <code>nullptr</code>, <code>hostfxr</code> is located using the environment variable or global registration
<ul>
<li><code>size</code> - Size of the structure. This is used for versioning and should be set to <code>sizeof(get_hostfxr_parameters)</code>.</li>
<li><code>assembly_path</code> - Optional. Path to the application or to the component's assembly.
<ul>
<li>If specified, <code>hostfxr</code> is located as if the <code>assembly_path</code> is an application with <code>apphost</code></li>
</ul>
</li>
<li><code>dotnet_root</code> - Optional. Path to the root of a .NET Core installation (i.e. folder containing the dotnet executable).
<ul>
<li>If specified, <code>hostfxr</code> is located as if an application is started using <code>dotnet app.dll</code>, which means it will be searched for under the <code>dotnet_root</code> path and the <code>assembly_path</code> is ignored.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>nethost</code> library uses the <code>__stdcall</code> calling convention.</p>
<h2>Improve API to run application and load components</h2>
<h3>Goals</h3>
<ul>
<li>All hosts should be able to use the new API (whether they will is a separate question as the old API has to be kept for backward compat reasons)</li>
<li>Hide implementation details as much as possible
<ul>
<li>Make the API generally easier to use/understand</li>
<li>Give the implementation more freedom</li>
<li>Allow future improvements without breaking the API</li>
<li>Consider explicitly documenting types of behaviors which nobody should take dependency on (specifically failure scenarios)</li>
</ul>
</li>
<li>Extensible
<ul>
<li>It should allow additional parameters to some of the operations without a need to add new exported APIs</li>
<li>It should allow additional interactions with the host - for example modifying how the runtime is initialized via some new options, without a need for a completely new set of APIs</li>
</ul>
</li>
</ul>
<h3>New scenarios</h3>
<p>The API should allow these scenarios:</p>
<ul>
<li>Runtime properties
<ul>
<li>Specify additional runtime properties from the native host</li>
<li>Implement conflict resolution for runtime properties</li>
<li>Inspect calculated runtime properties (the ones calculated by <code>hostfxr</code>/<code>hostpolicy</code>)</li>
</ul>
</li>
<li>Loading managed components
<ul>
<li>From native app start the runtime and load an assembly</li>
<li>The assembly is loaded in isolation and with all its dependencies as directed by <code>.deps.json</code></li>
<li>The native app can get back a native function pointer which calls specified managed method</li>
</ul>
</li>
</ul>
<p>It should be possible to ship with only some of these supported, then enable more scenarios later on.</p>
<p>All the proposed APIs will be exports of the <code>hostfxr</code> library and will use the same calling convention and name mangling as existing <code>hostfxr</code> exports.</p>
<h3>Initialize host context</h3>
<p>All the "initialize" functions will</p>
<ul>
<li>Process the <code>.runtimeconfig.json</code></li>
<li>Resolve framework references and find actual frameworks</li>
<li>Find the root framework (<code>Microsoft.NETCore.App</code>) and load the <code>hostpolicy</code> from it</li>
<li>The <code>hostpolicy</code> will then process all relevant <code>.deps.json</code> files and produce the list of assemblies, native search paths and other artifacts needed to initialize the runtime.</li>
</ul>
<p>The functions will NOT load the CoreCLR runtime. They just prepare everything to the point where it can be loaded.</p>
<p>The functions return a handle to a new host context:</p>
<ul>
<li>The handle must be closed via <code>hostfxr_close</code>.</li>
<li>The handle is not thread safe - the consumer should only call functions on it from one thread at a time.</li>
</ul>
<p>The <code>hostfxr</code> will also track active runtime in the process. Due to limitations (and to simplify implementation) this tracking will actually not look at the actual <code>coreclr</code> module (or try to communicate with the runtime in any way). Instead <code>hostfxr</code> itself will track the host context initialization. The first host context initialization in the process will represent the "loaded runtime". It is only possible to have one "loaded runtime" in the process. Any subsequent host context initialization will just "attach" to the "loaded runtime" instead of creating a new one.</p>
<div><pre><span>typedef</span> <span>void</span>* hostfxr_handle;

<span>struct</span> hostfxr_initialize_parameters
{
    <span>size_t</span> size;
    <span>const</span> <span>char_t</span> * host_path;
    <span>const</span> <span>char_t</span> * dotnet_root;
};</pre></div>
<p>The <code>hostfxr_initialize_parameters</code> structure stores parameters which are common to all forms of initialization.</p>
<ul>
<li><code>size</code> - the size of the structure. This is used for versioning. Should be set to <code>sizeof(hostfxr_initialize_parameters)</code>.</li>
<li><code>host_path</code> - path to the native host (typically the <code>.exe</code>). This value is not used for anything by the hosting components. It's just passed to the CoreCLR as the path to the executable. It can point to a file which is not executable itself, if such file doesn't exist (for example in COM activation scenarios this points to the <code>comhost.dll</code>). This is used by PAL to initialize internal command line structures, process name and so on.</li>
<li><code>dotnet_root</code> - path to the root of the .NET Core installation in use. This typically points to the install location from which the <code>hostfxr</code> has been loaded. For example on Windows this would typically point to <code>C:\Program Files\dotnet</code>. The path is used to search for shared frameworks and potentially SDKs.</li>
</ul>
<div><pre><span>int</span> <span>hostfxr_initialize_for_dotnet_command_line</span>(
    <span>int</span> argc,
    <span>const</span> <span>char_t</span> * argv[],
    <span>const</span> hostfxr_initialize_parameters * parameters,
    hostfxr_handle * host_context_handle
);</pre></div>
<p>Initializes the hosting components for running a managed application.
The command line is parsed to determine the app path. The app path will be used to locate the <code>.runtimeconfig.json</code> and the <code>.deps.json</code> which will be used to load the application and its dependent frameworks.</p>
<ul>
<li><code>argc</code> and <code>argv</code> - the command line for running a managed application. These represent the arguments which would have been passed to the muxer if the app was being run from the command line.</li>
<li><code>parameters</code> - additional parameters - see <code>hostfxr_initialize_parameters</code> for details. (Could be made optional potentially)</li>
<li><code>host_context_handle</code> - output parameter. On success receives an opaque value which identifies the initialized host context. The handle should be closed by calling <code>hostfxr_close</code>.</li>
</ul>
<p>This function only supports arguments for running an application as through the muxer. It does not support SDK commands.</p>
<p>This function can only be called once per-process. It's not supported to run multiple apps in one process (even sequentially).</p>
<p>This function will fail if there already is a CoreCLR running in the process as it's not possible to run two apps in a single process.</p>
<p><em>Note: This is effectively a replacement for <code>hostfxr_main_startupinfo</code> and <code>hostfxr_main</code>. Currently it is not a goal to fully replace these APIs because they also support SDK commands which are special in lot of ways and don't fit well with the rest of the native hosting. There's no scenario right now which would require the ability to issue SDK commands from a native host. That said nothing in this proposal should block enabling even SDK commands through these APIs.</em></p>
<div><pre><span>int</span> <span>hostfxr_initialize_for_runtime_config</span>(
    <span>const</span> <span>char_t</span> * runtime_config_path,
    <span>const</span> hostfxr_initialize_parameters * parameters,
    hostfxr_handle * host_context_handle
);</pre></div>
<p>This function would load the specified <code>.runtimeconfig.json</code>, resolve all frameworks, resolve all the assets from those frameworks and then prepare runtime initialization where the TPA contains only frameworks. Note that this case does NOT consume any <code>.deps.json</code> from the app/component (only processes the framework's <code>.deps.json</code>). This entry point is intended for <code>comhost</code>/<code>ijwhost</code>/<code>nethost</code> and similar scenarios.</p>
<ul>
<li><code>runtime_config_path</code> - path to the <code>.runtimeconfig.json</code> file to process. Unlike with <code>hostfxr_initialize_for_dotnet_command_line</code>, any <code>.deps.json</code> from the app/component will not be processed by the hosting layers.</li>
<li><code>parameters</code> - additional parameters - see <code>hostfxr_initialize_parameters</code> for details. (Could be made optional potentially)</li>
<li><code>host_context_handle</code> - output parameter. On success receives an opaque value which identifies the initialized host context. The handle should be closed by calling <code>hostfxr_close</code>.</li>
</ul>
<p>This function can be called multiple times in a process.</p>
<ul>
<li>If it's called when no runtime is present, it will run through the steps to "initialize" the runtime (resolving frameworks and so on).</li>
<li>If it's called when there already is CoreCLR in the process (loaded through the <code>hostfxr</code>, direct usage of <code>coreclr</code> is not supported), then the function determines if the specified runtime configuration is compatible with the existing runtime and frameworks. If it is, it returns a valid handle, otherwise it fails.</li>
</ul>
<p>It needs to be possible to call this function simultaneously from multiple threads at the same time.
It also needs to be possible to call this function while there is an active host context created by <code>hostfxr_initialize_for_dotnet_command_line</code> and running inside the <code>hostfxr_run_app</code>.</p>
<p>The function returns specific return code for the first initialized host context, and a different one for any subsequent one. Both return codes are considered "success". If there already was initialized host context in the process then the returned host context has these limitations:</p>
<ul>
<li>It won't allow setting runtime properties.</li>
<li>The initialization will compare the runtime properties from the <code>.runtimeconfig.json</code> specified in the <code>runtime_config_path</code> with those already set to the runtime in the process
<ul>
<li>If all properties from the new runtime config are already set and have the exact same values (case sensitive string comparison), the initialization succeeds with no additional consequences. (Note that this is the most typical case where the runtime config have no properties in it.)</li>
<li>If there are either new properties which are not set in the runtime or ones which have different values, the initialization will return a special return code - a "warning". It's not a full on failure as initialized context will be returned.</li>
<li>In both cases only the properties specified by the new runtime config will be reported on the host context. This is to allow the native host to decide in the "warning" case if it's OK to let the component run or not.</li>
<li>In both cases the returned host context can still be used to get a runtime delegate, the properties from the new runtime config will be ignored (as there's no way to modify those in the runtime).</li>
</ul>
</li>
</ul>
<h3>Inspect and modify host context</h3>
<h4>Runtime properties</h4>
<p>These functions allow the native host to inspect and modify runtime properties.</p>
<ul>
<li>If the <code>host_context_handle</code> represents the first initialized context in the process, these functions expose all properties from runtime configurations as well as those computed by the hosting layer components. These functions will allow modification of the properties via <code>hostfxr_set_runtime_property_value</code>.</li>
<li>If the <code>host_context_handle</code> represents any other context (so not the first one), these functions expose only properties from runtime configuration. These functions won't allow modification of the properties.</li>
</ul>
<p>It is possible to access runtime properties of the first initialized context in the process at any time (for reading only), by specifying <code>nullptr</code> as the <code>host_context_handle</code>.</p>
<div><pre><span>int</span> <span>hostfxr_get_runtime_property_value</span>(
    <span>const</span> hostfxr_handle host_context_handle,
    <span>const</span> <span>char_t</span> * name,
    <span>const</span> <span>char_t</span> ** value);</pre></div>
<p>Returns the value of a runtime property specified by its name.</p>
<ul>
<li><code>host_context_handle</code> - the initialized host context. If set to <code>nullptr</code> the function will operate on runtime properties of the first host context in the process.</li>
<li><code>name</code> - the name of the runtime property to get. Must not be <code>nullptr</code>.</li>
<li><code>value</code> - returns a pointer to a buffer with the property value. The buffer is owned by the host context. The caller should make a copy of it if it needs to store it for anything longer than immediate consumption. The lifetime is only guaranteed until any of the below happens:
<ul>
<li>one of the "run" methods is called on the host context</li>
<li>the host context is closed via <code>hostfxr_close</code></li>
<li>the value of the property is changed via <code>hostfxr_set_runtime_property_value</code></li>
</ul>
</li>
</ul>
<p>Trying to get a property which doesn't exist is an error and will return an appropriate error code.</p>
<p>We're proposing a fix in <code>hostpolicy</code> which will make sure that there are no duplicates possible after initialization (see <a href="https://github.com/dotnet/core-setup/issues/5529">dotnet/core-setup#5529</a>). With that <code>hostfxr_get_runtime_property_value</code> will work always (as there can only be one value).</p>
<div><pre><span>int</span> <span>hostfxr_set_runtime_property_value</span>(
    <span>const</span> hostfxr_handle host_context_handle,
    <span>const</span> <span>char_t</span> * name,
    <span>const</span> <span>char_t</span> * value);</pre></div>
<p>Sets the value of a property.</p>
<ul>
<li><code>host_context_handle</code> - the initialized host context. (Must not be <code>nullptr</code>)</li>
<li><code>name</code> - the name of the runtime property to set. Must not be <code>nullptr</code>.</li>
<li><code>value</code> - the value of the property to set. If the property already has a value in the host context, this function will overwrite it. When set to <code>nullptr</code> and if the property already has a value then the property is "unset" - removed from the runtime property collection.</li>
</ul>
<p>Setting properties is only supported on the first host context in the process. This is really a limitation of the runtime for which the runtime properties are immutable. Once the first host context is initialized and starts a runtime there's no way to change these properties. For now we will not consider the scenario where the host context is initialized but the runtime hasn't started yet, mainly for simplicity of implementation and lack of requirements.</p>
<div><pre><span>int</span> <span>hostfxr_get_runtime_properties</span>(
    <span>const</span> hostfxr_handle host_context_handle,
    <span>size_t</span> * count,
    <span>const</span> <span>char_t</span> **keys,
    <span>const</span> <span>char_t</span> **values);</pre></div>
<p>Returns the full set of all runtime properties for the specified host context.</p>
<ul>
<li><code>host_context_handle</code> - the initialized host context. If set to <code>nullptr</code> the function will operate on runtime properties of the first host context in the process.</li>
<li><code>count</code> - in/out parameter which must not be <code>nullptr</code>. On input it specifies the size of the the <code>keys</code> and <code>values</code> buffers. On output it contains the number of entries used from <code>keys</code> and <code>values</code> buffers - the number of properties returned. If the size of the buffers is too small, the function returns a specific error code and fill the <code>count</code> with the number of available properties. If <code>keys</code> or <code>values</code> is <code>nullptr</code> the function ignores the input value of <code>count</code> and just returns the number of properties.</li>
<li><code>keys</code> - buffer which acts as an array of pointers to buffers with keys for the runtime properties.</li>
<li><code>values</code> - buffer which acts as an array of pointer to buffers with values for the runtime properties.</li>
</ul>
<p><code>keys</code> and <code>values</code> store pointers to buffers which are owned by the host context. The caller should make a copy of it if it needs to store it for anything longer than immediate consumption. The lifetime is only guaranteed until any of the below happens:</p>
<ul>
<li>one of the "run" methods is called on the host context</li>
<li>the host context is closed via <code>hostfxr_close</code></li>
<li>the value or existence of any property is changed via <code>hostfxr_set_runtime_property_value</code></li>
</ul>
<p>Note that <code>hostfxr_set_runtime_property_value</code> can remove or add new properties, so the number of properties returned is only valid as long as no properties were added/removed.</p>
<h3>Start the runtime</h3>
<h4>Running an application</h4>
<div><pre><span>int</span> <span>hostfxr_run_app</span>(<span>const</span> hostfxr_handle host_context_handle);</pre></div>
<p>Runs the application specified by the <code>hostfxr_initialize_for_dotnet_command_line</code>. It is illegal to try to use this function when the host context was initialized through any other way.</p>
<ul>
<li><code>host_context_handle</code> - handle to the initialized host context.</li>
</ul>
<p>The function will return only once the managed application exits.</p>
<p><code>hostfxr_run_app</code> cannot be used in combination with any other "run" function. It can also only be called once.</p>
<h4>Getting a delegate for runtime functionality</h4>
<div><pre><span>int</span> <span>hostfxr_get_runtime_delegate</span>(<span>const</span> hostfxr_handle host_context_handle, hostfxr_delegate_type type, <span>void</span> ** delegate);</pre></div>
<p>Starts the runtime and returns a function pointer to specified functionality of the runtime.</p>
<ul>
<li><code>host_context_handle</code> - handle to the initialized host context.</li>
<li><code>type</code> - the type of runtime functionality requested
<ul>
<li><code>hdt_load_assembly_and_get_function_pointer</code> - entry point which loads an assembly (with dependencies) and returns function pointer for a specified static method. See below for details (Loading managed components)</li>
<li><code>hdt_com_activation</code>, <code>hdt_com_register</code>, <code>hdt_com_unregister</code> - COM activation entry-points - see <a href="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/COM-activation.md">COM activation</a> for more details.</li>
<li><code>hdt_load_in_memory_assembly</code> - IJW entry-point - see <a href="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/IJW-activation.md">IJW activation</a> for more details.</li>
<li><code>hdt_winrt_activation</code> - WinRT activation entry-point - see <a href="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/WinRT-activation.md">WinRT activation</a> for more details.</li>
</ul>
</li>
<li><code>delegate</code> - when successful, the native function pointer to the requested runtime functionality.</li>
</ul>
<p>Initially the function will only work if <code>hostfxr_initialize_for_runtime_config</code> was used to initialize the host context. Later on this could be relaxed to allow being used in combination with <code>hostfxr_initialize_for_dotnet_command_line</code>.</p>
<p>Initially there might be a limitation of calling this function only once on a given host context to simplify the implementation. Currently we don't have a scenario where it would be absolutely required to support multiple calls.</p>
<h3>Cleanup</h3>
<div><pre><span>int</span> <span>hostfxr_close</span>(<span>const</span> hostfxr_handle host_context_handle);</pre></div>
<p>Closes a host context.</p>
<ul>
<li><code>host_context_handle</code> - handle to the initialized host context to close.</li>
</ul>
<h3>Loading managed components</h3>
<p>To load managed components from native app directly (not using COM or WinRT) the hosting layer exposes a new runtime helper/delegate <code>hdt_load_assembly_and_get_function_pointer</code>. Calling the <code>hostfxr_get_runtime_delegate(handle, hdt_load_assembly_and_get_function_pointer, &amp;helper)</code> returns a function pointer to the runtime helper with this signature:</p>
<div><pre><span>int</span> <span>load_assembly_and_get_function_pointer_fn</span>(
    <span>const</span> <span>char_t</span> *assembly_path,
    <span>const</span> <span>char_t</span> *type_name,
    <span>const</span> <span>char_t</span> *method_name,
    <span>const</span> <span>char_t</span> *delegate_type_name,
    <span>void</span>         *reserved,
    <span><span>/*</span>out<span>*/</span></span> <span>void</span> **delegate)</pre></div>
<p>Calling this function will load the specified assembly in isolation (into its own <code>AssemblyLoadContext</code>) and it will use <code>AssemblyDependencyResolver</code> on it to provide dependency resolution. Once loaded it will find the specified type and method and return a native function pointer to that method. The method's signature can be specified via the delegate type name.</p>
<ul>
<li><code>assembly_path</code> - Path to the assembly to load. In case of complex component, this should be the main assembly of the component (the one with the <code>.deps.json</code> next to it). Note that this does not have to be the assembly from which the <code>type_name</code> and <code>method_name</code> are.</li>
<li><code>type_name</code> - Assembly qualified type name to find</li>
<li><code>method_name</code> - Name of the method on the <code>type_name</code> to find. The method must be <code>static</code> and must match the signature of <code>delegate_type_name</code>.</li>
<li><code>delegate_type_name</code> - Assembly qualified delegate type name for the method signature, or null. If this is null, the method signature is assumed to be:</li>
</ul>
<div><pre><span>public</span> <span>delegate</span> <span>int</span> <span>ComponentEntryPoint</span>(<span>IntPtr</span> <span>args</span>, <span>int</span> <span>sizeBytes</span>);</pre></div>
<p>This maps to native signature:</p>
<div><pre><span>int</span> <span>component_entry_point_fn</span>(<span>void</span> *arg, <span>int32_t</span> arg_size_in_bytes);</pre></div>
<ul>
<li><code>reserved</code> - parameter reserved for future extensibility, currently unused and must be <code>0</code>.</li>
<li><code>delegate</code> - out parameter which receives the native function pointer to the requested managed method.</li>
</ul>
<p>It is allowed to call the returned runtime helper many times for different assemblies or different methods from the same assembly. It is not required to get the helper every time. The implementation of the helper will cache loaded assemblies, so requests to load the same assembly twice will load it only once and reuse it from that point onward. Ideally components should not take a dependency on this behavior, which means components should not have global state. Global state in components is typically just cause for problems. For example it may create ordering issues or unintended side effects and so on.</p>
<p>The returned native function pointer to managed method has the lifetime of the process and can be used to call the method many times over. Currently there's no way to unload the managed component or otherwise free the native function pointer. Such support may come in future releases.</p>
<h3>Multiple host contexts interactions</h3>
<p>It is important to correctly synchronize some of these operations to achieve the desired API behavior as well as thread safety requirements. The following behaviors will be used to achieve this.</p>
<h4>Terminology</h4>
<ul>
<li><code>first host context</code> is the one which is used to load and initialize the CoreCLR runtime in the process. At any given time there can only be one <code>first host context</code>.</li>
<li><code>secondary host context</code> is any other initialized host context when <code>first host context</code> already exists in the process.</li>
</ul>
<h4>Synchronization</h4>
<ul>
<li>If there's no <code>first host context</code> in the process the first call to <code>hostfxr_initialize_...</code> will create a new <code>first host context</code>. There can only be one <code>first host context</code> in existence at any point in time.</li>
<li>Calling <code>hostfxr_initialize...</code> when <code>first host context</code> already exists will always return a <code>secondary host context</code>.</li>
<li>The <code>first host context</code> blocks creation of any other host context until it is used to load and initialize the CoreCLR runtime. This means that <code>hostfxr_initialize...</code> and subsequently one of the "run" methods must be called on the <code>first host context</code> to unblock creation of <code>secondary host contexts</code>.</li>
<li>Calling <code>hostfxr_initialize...</code> will block until the <code>first host context</code> is initialized, a "run" method is called on it and the CoreCLR is loaded and initialized. The <code>hostfxr_initialize...</code> will block potentially indefinitely. The method will block very early on. All of the operations done by the initialize will only happen once it's unblocked.</li>
<li><code>first host context</code> can fail to initialize the runtime (or anywhere up to that point). If this happens, it's marked as failed and is not considered a <code>first host context</code> anymore. This unblocks the potentially waiting <code>hostfxr_initialize...</code> calls. In this case the first <code>hostfxr_initialize...</code> after the failure will create a new <code>first host context</code>.</li>
<li><code>first host context</code> can be closed using <code>hostfxr_close</code> before it is used to initialize the CoreCLR runtime. This is similar to the failure above, the host context is marked as "closed/failed" and is not considered <code>first host context</code> anymore. This unblocks any waiting <code>hostfxr_initialize...</code> calls.</li>
<li>Once the <code>first host context</code> successfully initialized the CoreCLR runtime it is permanently marked as "successful" and will remain the <code>first host context</code> for the lifetime of the process. Such host context should still be closed once not needed via <code>hostfxr_close</code>.</li>
</ul>
<h4>Invalid usage</h4>
<ul>
<li>It is invalid to initialize a host context via <code>hostfxr_initialize...</code> and then never call <code>hostfxr_close</code> on it. An initialized but not closed host context is considered abandoned. Abandoned <code>first host context</code> will cause infinite blocking of any future <code>hostfxr_initialize...</code> calls.</li>
</ul>
<h4>Important scenarios</h4>
<p>The above behaviors should make sure that some important scenarios are possible and work reliably.</p>
<p>One such scenario is a COM host on multiple threads. The app is not running any .NET Core yet (no CoreCLR loaded). On two threads in parallel COM activation is invoked which leads to two invocations into the <code>comhost</code> to active .NET Core objects. The <code>comhost</code> will use the <code>hostfxr_initialize...</code> and <code>hostfxr_get_runtime_delegate</code> APIs on two threads in parallel then. Only one of them can load and initialize the runtime (and also perform full framework resolution and determine the framework versions and assemblies to load). The other has to become a <code>secondary host context</code> and try to conform to the first one. The above behavior of <code>hostfxr_initialize...</code> blocking until the <code>first host context</code> is done initializing the runtime will make sure of the correct behavior in this case.</p>
<p>At the same time it gives the native app (<code>comhost</code> in this case) the ability to query and modify runtime properties in between the <code>hostfxr_initialize...</code> and <code>hostfxr_get_runtime_delegate</code> calls on the <code>first host context</code>.</p>
<h3>API usage</h3>
<p>The <code>hostfxr</code> exports are defined in the <a href="https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/hostfxr.h">hostfxr.h</a> header file.
The runtime helper and method signatures for loading managed components are defined in <a href="https://github.com/dotnet/core-setup/blob/master/src/corehost/cli/coreclr_delegates.h">coreclr_delegates.h</a> header file.</p>
<p>Currently we don't plan to ship these files, but it's possible to take them from the repo and use it.</p>
<h3>Support for older versions</h3>
<p>Since <code>hostfxr</code> and the other components of hosting layers are versioned independently there are several interesting cases of version mismatches:</p>
<h4>muxer/<code>apphost</code> versus <code>hostfxr</code></h4>
<p>For muxer it should almost always match, but <code>apphost</code> can be different. That is, it's perfectly valid to use older 2.* <code>apphost</code> with a new 3.0 <code>hostfxr</code>. The opposite should be rare, but in theory can happen as well. To keep the code simple both muxer and <code>apphost</code> will keep using the existing 2.* APIs on <code>hostfxr</code> even in situation where both are 3.0 and thus could start using the new APIs.</p>
<p><code>hostfxr</code> must be backward compatible and support 2.* APIs.</p>
<p>Potentially we could switch just <code>apphost</code> to use the new APIs (since it doesn't have the same compatibility burden as the muxer), but it's probably safer to not do that.</p>
<h4><code>hostfxr</code> versus <code>hostpolicy</code></h4>
<p>It should really only happen that <code>hostfxr</code> is equal or newer than <code>hostpolicy</code>. The opposite should be very rare. In any case <code>hostpolicy</code> should support existing 2.* APIs and thus the rare case will keep working anyway.</p>
<p>The interesting case is 3.0 <code>hostfxr</code> using 2.* <code>hostpolicy</code>. This will be very common, basically any 2.* app running on a machine with 3.0 installed will be in that situation. This case has two sub-cases:</p>
<ul>
<li><code>hostfxr</code> is invoked using one of the 2.* APIs. In this case the simple solution is to keep using the 2.* <code>hostpolicy</code> APIs always.</li>
<li><code>hostfxr</code> is invoked using one of the new 3.0 APIs (like <code>hostfxr_initialize...</code>). In this case it's not possible to completely support the new APIs, since they require new functionality from <code>hostpolicy</code>. For now the <code>hostfxr</code> should simply fail.
It is in theory possible to support some kind of emulation mode where for some scenarios the new APIs would work even with old <code>hostpolicy</code>, but for simplicity it's better to start with just failing.</li>
</ul>
<h4>Implementation of existing 2.* APIs in <code>hostfxr</code></h4>
<p>The existing 2.* APIs in <code>hostfxr</code> could switch to internally use the new functionality and in turn use the new 3.0 <code>hostpolicy</code> APIs. The tricky bit here is scenario like this:</p>
<ul>
<li>3.0 App is started via <code>apphost</code> or muxer which as mentioned above will keep on using the 2.* <code>hostfxr</code> APIs. This will load CoreCLR into the process.</li>
<li>COM component is activated in the same process. This will go through the new 3.0 <code>hostfxr</code> APIs, and to work correctly will require the internal representation of the <code>first host context</code>.</li>
</ul>
<p>If the 2.* <code>hostfxr</code> APIs would continue to use the old 2.* <code>hostpolicy</code> APIs even if <code>hostpolicy</code> is new, then the above scenario will be hard to achieve as there will be no <code>first host context</code>. <code>hostpolicy</code> could somehow "emulate" the <code>first host context</code>, but without <code>hostpolicy</code> cooperation this would be hard.</p>
<p>On the other hand switching to use the new <code>hostpolicy</code> APIs even in 2.* <code>hostfxr</code> APIs is risky for backward compatibility. This will have to be decided during implementation.</p>
<h3>Samples</h3>
<p>All samples assume that the native host has found the <code>hostfxr</code>, loaded it and got the exports (possibly by using the <code>nethost</code>).
Samples in general ignore error handling.</p>
<h4>Running app with additional runtime properties</h4>
<div><pre>hostfxr_initialize_parameters params;
params.size = <span>sizeof</span>(params);
params.host_path = get_path_to_the_host_exe(); <span><span>//</span> Path to the current executable</span>
params.dotnet_root = get_directory(get_directory(get_directory(hostfxr_path))); <span><span>//</span> Three levels up from hostfxr typically</span>

hostfxr_handle host_context_handle;
<span>hostfxr_initialize_for_dotnet_command_line</span>(
    _argc_,
    _argv_,
    &amp;params,
    &amp;host_context_handle);

<span>size_t</span> buffer_used = <span>0</span>;
<span>if</span> (hostfxr_get_runtime_property(host_context_handle, <span><span>"</span>TEST_PROPERTY<span>"</span></span>, <span>nullptr</span>, <span>0</span>, &amp;buffer_used) == HostApiMissingProperty)
{
    <span>hostfxr_set_runtime_property</span>(host_context_handle, <span><span>"</span>TEST_PROPERTY<span>"</span></span>, <span><span>"</span>TRUE<span>"</span></span>);
}

<span>hostfxr_run_app</span>(host_context_handle);

<span>hostfxr_close</span>(host_context_handle);</pre></div>
<h4>Getting a function pointer to call a managed method</h4>
<div><pre><span>using</span> load_assembly_and_get_function_pointer_fn = <span>int</span> (STDMETHODCALLTYPE *)(
    <span>const</span> <span>char_t</span> *assembly_path,
    <span>const</span> <span>char_t</span> *type_name,
    <span>const</span> <span>char_t</span> *method_name,
    <span>const</span> <span>char_t</span> *delegate_type_name,
    <span>void</span> *reserved,
    <span>void</span> **delegate);

hostfxr_handle host_context_handle;
<span>hostfxr_initialize_for_runtime_config</span>(config_path, <span>nullptr</span>, &amp;host_context_handle);

load_assembly_and_get_function_pointer_fn runtime_delegate = <span>nullptr</span>;
<span>hostfxr_get_runtime_delegate</span>(
    host_context_handle,
    hostfxr_delegate_type::load_assembly_and_get_function_pointer,
    (<span>void</span> **)&amp;runtime_delegate);

<span>using</span> managed_entry_point_fn = <span>int</span> (STDMETHODCALLTYPE *)(<span>void</span> *arg, <span>int</span> argSize);

managed_entry_point_fn entry_point = <span>nullptr</span>;
<span>runtime_delegate</span>(assembly_path,
                 type_name,
                 method_name,
                 <span>nullptr</span>,
                 <span>nullptr</span>,
                 (<span>void</span> **)&amp;entry_point);

ArgStruct arg;
<span>entry_point</span>(&amp;arg, <span>sizeof</span>(ArgStruct));

<span>hostfxr_close</span>(host_context_handle);</pre></div>
<h2>Impact on hosting components</h2>
<p>The exact impact on the <code>hostfxr</code>/<code>hostpolicy</code> interface needs to be investigated. The assumption is that new APIs will have to be added to <code>hostpolicy</code> to implement the proposed functionality.</p>
<p>Part if this investigation will also be compatibility behavior. Currently "any" version of <code>hostfxr</code> needs to be able to use "any" version of <code>hostpolicy</code>. But the proposed functionality will need both new <code>hostfxr</code> and new <code>hostpolicy</code> to work. It is likely the proposed APIs will fail if the app resolves to a framework with old <code>hostpolicy</code> without the necessary new APIs. Part of the investigation will be if it's feasible to use the new <code>hostpolicy</code> APIs to implement existing old <code>hostfxr</code> APIs.</p>

<ul>
<li>Maybe add <code>apphost_get_hostfxr_path</code> on the existing <code>apphost</code> - this is to make it even easier to implement custom hosting for entire managed app as the custom host would not need to carry a <code>nethost</code> and would get a 100% compatible behavior by using the same <code>apphost</code> as the app itself.</li>
</ul>
</article>
  </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>