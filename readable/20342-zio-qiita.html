<!DOCTYPE html>
<html lang="en">
<head>
    <title>
ZIO&#x3067;&#x306E;&#x7E70;&#x308A;&#x8FD4;&#x3057;&#x3068;&#x30EA;&#x30C8;&#x30E9;&#x30A4;&#x51E6;&#x7406; - Qiita -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>ZIOでの繰り返しとリトライ処理 - Qiita</h1><div><div><h1><span id="schedulea-b" class="fragment"></span><a href="#schedulea-b"><i class="fa fa-link"></i></a><code>Schedule[A, B]</code></h1><p>ZIOは繰り返しとリトライ処理を<code>Schedule[A, B]</code>という型で抽象化し同等に扱います。</p><p><code>Schedule[A, B]</code><sup>a</sup>は以下を表現する不変な値です。</p><ul><li><code>A</code>型の値を入力として受け取り<code>B</code>型の値を出力する。</li><li>入力に基づいて計算を終了するか、遅延を挟んで継続するか決定する。</li></ul><p><code>Schedule[A, B]</code>を導入すると、繰り返しは計算の成功結果<code>S</code>を入力として受け取る<code>Schedule[S, B]</code>として、リトライ処理は計算の失敗理由<code>E</code>を入力として受け取る<code>Schedule[E, B]</code>として表現できます。</p><p>計算の<code>repeat</code>と<code>retry</code>メソッドに<code>Schedule</code>の値を渡すと、その計算の繰り返しとリトライ処理を設定することができます。</p><h1><span id="基本的なscheduleb" class="fragment"></span><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AAscheduleb"><i class="fa fa-link"></i></a>基本的な<code>Schedule</code><a href="#%E8%A3%9C%E8%B6%B3"><sup>b</sup></a></h1><h2><span id="never" class="fragment"></span><a href="#never"><i class="fa fa-link"></i></a><code>never</code></h2><p>計算を実行しなくします。</p><p>以下のコードは"Hello"を表示せず終了しません。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"Schedule.never"</span><span class="n">should</span><span class="o">{</span><span class="s">"never execute the effect"</span><span class="n">in</span><span class="o">{</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">)).</span><span class="py">repeat</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">never</span><span class="o">))</span><span class="o">}</span><span class="o">}</span></pre></div></div><h2><span id="forever-and-identity" class="fragment"></span><a href="#forever-and-identity"><i class="fa fa-link"></i></a><code>forever</code> and <code>identity</code></h2><p><code>forever</code>と<code>identity</code>は計算を制限なく繰り返します。</p><p>1番目のケースでは1秒間"Hello"を繰り返し表示します。<a href="#%E8%A3%9C%E8%B6%B3"><sup>c</sup></a></p><p>2番目のケースでは成功するまでリクエストを繰り返します。</p><p>3番目のケースでは<code>repeat(forever)</code>として制限なく繰り返すように指定しています。2番目のケース<code>retry(forever)</code>で見たように<code>retry</code>は最初の成功の時点で計算が終了し、<code>repeat</code>は最初の失敗の時点で計算が終了します。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"Schedule.forever"</span><span class="n">should</span><span class="o">{</span><span class="s">"repeat the successful effect forever"</span><span class="n">in</span><span class="o">{</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">)).</span><span class="py">repeat</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">forever</span><span class="o">)</span><span class="o">.</span><span class="py">race</span><span class="o">(</span><span class="nc">UIO</span><span class="o">(</span><span class="s">"done"</span><span class="o">).</span><span class="py">delay</span><span class="o">(</span><span class="nc">Duration</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="nv">TimeUnit</span><span class="o">.</span><span class="py">SECONDS</span><span class="o">)))</span><span class="o">)</span><span class="o">}</span><span class="s">"retry the effect until succeed"</span><span class="n">in</span><span class="o">{</span><span class="k">val</span><span class="nv">service</span><span class="k">=</span><span class="k">new</span><span class="nc">StubService</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="nv">service</span><span class="o">.</span><span class="py">request</span><span class="o">()).</span><span class="py">retry</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">forever</span><span class="o">)</span><span class="o">&gt;&gt;=</span><span class="o">(</span><span class="n">s</span><span class="k">=&gt;</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span><span class="o">)</span><span class="o">}</span><span class="s">"repeat does not repeat failed effect"</span><span class="n">in</span><span class="o">{</span><span class="k">val</span><span class="nv">service</span><span class="k">=</span><span class="k">new</span><span class="nc">StubService</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="n">assertThrows</span><span class="o">[</span><span class="kt">FiberFailure</span><span class="o">]</span><span class="o">{</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="nv">service</span><span class="o">.</span><span class="py">request</span><span class="o">()).</span><span class="py">repeat</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">forever</span><span class="o">)</span><span class="o">&gt;&gt;=</span><span class="o">(</span><span class="n">s</span><span class="k">=&gt;</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span><span class="o">)</span><span class="o">}</span><span class="o">}</span><span class="o">}</span></pre></div></div><p><code>identity</code>は<code>forever</code>と同じく制限なく繰り返す<code>Schedule</code>です。<code>identity</code>は<code>Schedule[A, A]</code>型で入力をそのまま出力するのに対して、<code>forever</code>は<code>Schedule[Any, Int]</code>型で入力を破棄して現在の繰り返しの回数を出力します。出力の違いは後述の<a href="#Schedule%E3%81%AE%E5%90%88%E6%88%90">Scheduleの合成</a>で意味を持つことになります。</p><h2><span id="recurse-and-once" class="fragment"></span><a href="#recurse-and-once"><i class="fa fa-link"></i></a><code>recurse</code> and <code>once</code></h2><p>繰り返しの回数を指定する場合には<code>recurse</code>を使用します。</p><p><code>recurse</code>で指定する"繰り返しの回数"は、最初の計算の実行回数を含みません。そのため<code>repeat</code>に<code>recurse</code>を渡したとき実際に計算は<code>recurse</code>で指定した回数＋１になります。同様に<code>retry</code>に渡したときも<code>recurse</code>は、リクエストの回数ではなくリトライの回数になります。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"Schedule recurse"</span><span class="n">should</span><span class="o">{</span><span class="s">"repeat the effect for specified numbers"</span><span class="n">in</span><span class="o">{</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">)).</span><span class="py">repeat</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">recurs</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span><span class="o">)</span><span class="c1">// prints out "Hello" three times:</span><span class="c1">// Hello</span><span class="c1">// Hello</span><span class="c1">// Hello</span><span class="o">}</span><span class="s">"retry the effect for specified numbers"</span><span class="n">in</span><span class="o">{</span><span class="k">val</span><span class="nv">service</span><span class="k">=</span><span class="k">new</span><span class="nc">StubService</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="nv">service</span><span class="o">.</span><span class="py">request</span><span class="o">()).</span><span class="py">retry</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">recurs</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span><span class="o">&gt;&gt;=</span><span class="o">(</span><span class="n">s</span><span class="k">=&gt;</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span><span class="c1">// prints out: Succeeded at 2 attempt</span><span class="o">)</span><span class="o">}</span><span class="o">}</span></pre></div></div><p><code>once</code>は<code>recurse(1)</code>と同等です。</p><h2><span id="dowhile-and-dountil" class="fragment"></span><a href="#dowhile-and-dountil"><i class="fa fa-link"></i></a><code>doWhile</code> and <code>doUntil</code></h2><p>入力値に基づいて計算の継続か終了を判定するためには<code>doWhile</code>や<code>doUntil</code>を使用します。</p><p><code>doWhile</code>は入力値に対する述語を受け取り、"その述語が真である間"計算を継続します。</p><p>リピートの回数やエラーの種類によって、繰り返し、またはリトライ処理を継続するか判定できます。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"Schedule doWhile"</span><span class="n">should</span><span class="o">{</span><span class="s">"repeat an effect while a predicate is satisfied"</span><span class="n">in</span><span class="o">{</span><span class="k">var</span><span class="n">i</span><span class="k">=</span><span class="mi">0</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">UIO</span><span class="o">{</span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">}.</span><span class="py">repeat</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">doWhile</span><span class="o">(</span><span class="k">_</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">))</span><span class="o">&gt;&gt;=</span><span class="o">(</span><span class="n">n</span><span class="k">=&gt;</span><span class="nc">UIO</span><span class="o">(</span><span class="n">n</span><span class="o">))</span><span class="o">)</span><span class="n">shouldBe</span><span class="mi">3</span><span class="o">}</span><span class="s">"retry an effect while a predicate is satisfied"</span><span class="n">in</span><span class="o">{</span><span class="k">val</span><span class="nv">service</span><span class="k">=</span><span class="k">new</span><span class="nc">StubService</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="nv">service</span><span class="o">.</span><span class="py">request</span><span class="o">()).</span><span class="py">retry</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">doWhile</span><span class="o">{(</span><span class="n">e</span><span class="k">:</span><span class="kt">Throwable</span><span class="o">)</span><span class="k">=&gt;</span><span class="n">e</span><span class="k">match</span><span class="o">{</span><span class="k">case</span><span class="nc">NonFatal</span><span class="o">(</span><span class="k">_</span><span class="o">)</span><span class="k">=&gt;</span><span class="kc">true</span><span class="o">}}).</span><span class="py">either</span><span class="o">)</span><span class="n">shouldBe</span><span class="n">a</span><span class="o">[</span><span class="kt">Right</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]]</span><span class="o">}</span><span class="o">}</span></pre></div></div><p><code>doUntil</code>は入力値に対する述語を受け取り、"その述語が真になるまで"計算を継続します。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"Schedule doUntil"</span><span class="n">should</span><span class="o">{</span><span class="c1">// doUntil is equivalent to doWhile negated</span><span class="s">"repeat an effect until a predicate is satisfied"</span><span class="n">in</span><span class="o">{</span><span class="k">var</span><span class="n">i</span><span class="k">=</span><span class="mi">0</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">UIO</span><span class="o">{</span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">}.</span><span class="py">repeat</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">doUntil</span><span class="o">(</span><span class="k">_</span><span class="o">&gt;=</span><span class="mi">3</span><span class="o">))</span><span class="o">&gt;&gt;=</span><span class="o">(</span><span class="n">n</span><span class="k">=&gt;</span><span class="nc">UIO</span><span class="o">(</span><span class="n">n</span><span class="o">))</span><span class="o">)</span><span class="n">shouldBe</span><span class="mi">3</span><span class="o">}</span><span class="s">"retry an effect while a predicate is satisfied"</span><span class="n">in</span><span class="o">{</span><span class="k">val</span><span class="nv">service</span><span class="k">=</span><span class="k">new</span><span class="nc">StubService</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="nv">service</span><span class="o">.</span><span class="py">request</span><span class="o">()).</span><span class="py">retry</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">doUntil</span><span class="o">{(</span><span class="n">e</span><span class="k">:</span><span class="kt">Throwable</span><span class="o">)</span><span class="k">=&gt;</span><span class="n">e</span><span class="k">match</span><span class="o">{</span><span class="k">case</span><span class="nc">NonFatal</span><span class="o">(</span><span class="k">_</span><span class="o">)</span><span class="k">=&gt;</span><span class="kc">false</span><span class="o">}}).</span><span class="py">either</span><span class="o">)</span><span class="n">shouldBe</span><span class="n">a</span><span class="o">[</span><span class="kt">Right</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]]</span><span class="o">}</span><span class="o">}</span></pre></div></div><h2><span id="spaced-linear-fibonacci-and-exponential" class="fragment"></span><a href="#spaced-linear-fibonacci-and-exponential"><i class="fa fa-link"></i></a><code>spaced</code>, <code>linear</code>, <code>fibonacci</code>, and <code>exponential</code></h2><p>繰り返しやリトライの間隔を指定できます。</p><p><code>spaced</code>は指定された間隔で等間隔で計算を繰り返します。100ミリ秒ごとに"Hello"を表示するプログラムは以下のように書けます。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"Schedule spaced"</span><span class="n">should</span><span class="o">{</span><span class="s">"repeat an effect "</span><span class="n">in</span><span class="o">{</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">))</span><span class="o">.</span><span class="py">repeat</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">spaced</span><span class="o">(</span><span class="nc">Duration</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span><span class="nv">TimeUnit</span><span class="o">.</span><span class="py">MILLISECONDS</span><span class="o">)))</span><span class="o">.</span><span class="py">race</span><span class="o">(</span><span class="nc">UIO</span><span class="o">(()).</span><span class="py">delay</span><span class="o">(</span><span class="nc">Duration</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="nv">TimeUnit</span><span class="o">.</span><span class="py">SECONDS</span><span class="o">)))</span><span class="o">)</span><span class="o">}</span><span class="o">}</span></pre></div></div><p><code>linear</code>、<code>fibonacci</code>、<code>exponential</code>は、初期の間隔を受け取り繰り返し毎に間隔を増加させていきます。100msecを初期の間隔とした場合の実行の間隔は以下のグラフのように推移します。</p><p><a href="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F12045%2F4c8c3640-07e9-2378-dc5f-8d6775026b63.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=e8c5fcb87deb6e3976b5a105ca4a4ebf" target="_blank" rel="nofollow noopener"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F12045%2F4c8c3640-07e9-2378-dc5f-8d6775026b63.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;s=e8c5fcb87deb6e3976b5a105ca4a4ebf" alt="chart.png" data-canonical-src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/12045/4c8c3640-07e9-2378-dc5f-8d6775026b63.png" srcset="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F12045%2F4c8c3640-07e9-2378-dc5f-8d6775026b63.png?ixlib=rb-1.2.2&amp;auto=format&amp;gif-q=60&amp;q=75&amp;w=1400&amp;fit=max&amp;s=d24ca562017fd25f01f4f488972b8445 1x" loading="lazy"></a></p><h1><span id="scheduleの合成" class="fragment"></span><a href="#schedule%E3%81%AE%E5%90%88%E6%88%90"><i class="fa fa-link"></i></a><code>Schedule</code>の合成</h1><p>複数の<code>Schedule</code>から新しい<code>Schedule</code>を合成できます。</p><h2><span id="積と和" class="fragment"></span><a href="#%E7%A9%8D%E3%81%A8%E5%92%8C"><i class="fa fa-link"></i></a>積(&amp;&amp;)と和(||)</h2><p><code>Schedule</code>には積と和の演算が定義されています。</p><table><thead><tr><th></th><th><code>s1</code></th><th><code>s2</code></th><th><code>s1 &amp;&amp; s2</code></th><th><code>s1 or s2</code><sup>※</sup></th></tr></thead><tbody><tr><td>継続または終了</td><td>s1の条件</td><td>s2の条件</td><td>s1とs2の条件の論理積</td><td>s1とs2の条件の論理和</td></tr><tr><td>間隔</td><td>s1の間隔</td><td>s2の間隔</td><td>s1とs2の間隔のmax</td><td>s1とs2の間隔のmin</td></tr><tr><td>結果</td><td>s1の結果</td><td>s2の結果</td><td>s1とs2の結果の<code>pair: (B1, B2)</code></td><td>s1とs2の結果の<code>pair: (B1, B2)</code></td></tr></tbody></table><p>100msecの等間隔(<code>s1 = spaced(100msec)</code>)で3回繰り返す(<code>s2 = recurse(3)</code>)スケジュールは以下のようになります。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"Schedule operator"</span><span class="n">should</span><span class="o">{</span><span class="s">"compose multiple schedules"</span><span class="n">in</span><span class="o">{</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">))</span><span class="o">.</span><span class="py">repeat</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">spaced</span><span class="o">(</span><span class="nc">Duration</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span><span class="nv">TimeUnit</span><span class="o">.</span><span class="py">MILLISECONDS</span><span class="o">))</span><span class="o">&amp;&amp;</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">recurs</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span><span class="o">)</span><span class="o">}</span><span class="o">}</span></pre></div></div><p>2日おき、または、毎週繰り返すスケジュールは和で定義できます。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"Union"</span><span class="n">should</span><span class="o">{</span><span class="s">"execute computation when either one of schedules triggers"</span><span class="n">in</span><span class="o">{</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="c1">// prints "Hello" every two days or every week</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">))</span><span class="o">.</span><span class="py">repeat</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">spaced</span><span class="o">(</span><span class="nc">Duration</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="nv">TimeUnit</span><span class="o">.</span><span class="py">DAYS</span><span class="o">))</span><span class="o">||</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">spaced</span><span class="o">(</span><span class="nc">Duration</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span><span class="nv">TimeUnit</span><span class="o">.</span><span class="py">DAYS</span><span class="o">)))</span><span class="o">)</span><span class="o">}</span><span class="o">}</span></pre></div></div><p>積には合成した<code>Schedule</code>の結果を無視する<code>*&gt;</code>と<code>&lt;*</code>という演算子もあります。</p><h2><span id="andthen-and-andtheneither" class="fragment"></span><a href="#andthen-and-andtheneither"><i class="fa fa-link"></i></a><code>andThen</code> and <code>andThenEither</code></h2><p>1つ目の<code>Schedule</code>の完了後に2つ目の<code>Schedule</code>に移行する<code>Schedule</code>を定義するために<code>andThen</code>を使用します。</p><p>最初の4回の繰り返しは指数関数的に間隔を広げていき（1つ目の<code>Schedule</code>)、そのあと等間隔に繰り返す（2つ目の<code>Schedule</code>）をスケジュールは以下のように書けます。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"andThen"</span><span class="n">should</span><span class="o">{</span><span class="s">"complete the first schedule and then execute the second"</span><span class="n">in</span><span class="o">{</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">))</span><span class="o">.</span><span class="py">repeat</span><span class="o">(</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">exponential</span><span class="o">(</span><span class="nc">Duration</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span><span class="nv">TimeUnit</span><span class="o">.</span><span class="py">MILLISECONDS</span><span class="o">))</span><span class="o">&amp;&amp;</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">recurs</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span><span class="nf">andThen</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">spaced</span><span class="o">(</span><span class="nc">Duration</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="nv">TimeUnit</span><span class="o">.</span><span class="py">SECONDS</span><span class="o">))</span><span class="o">&amp;&amp;</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">recurs</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span><span class="o">)</span><span class="o">)</span><span class="o">}</span><span class="o">}</span></pre></div></div><p><code>andThen</code>は1つ目の<code>Schedule</code>の結果と2つ目の<code>Schedule</code>の結果をマージして、どちらの<code>Schedule</code>の結果か区別できなくなります。<code>andThenEither</code>で<code>Schedule</code>を合成すると1つめの結果を<code>Left</code>に2つ目の結果を<code>Right</code>に格納する<code>Either</code>型の結果を返します。</p><h1><span id="その他" class="fragment"></span><a href="#%E3%81%9D%E3%81%AE%E4%BB%96"><i class="fa fa-link"></i></a>その他</h1><h2><span id="jittered" class="fragment"></span><a href="#jittered"><i class="fa fa-link"></i></a><code>jittered</code></h2><p><code>Schedule</code>の間隔をランダムに調整します。</p><p><code>c</code>番目のリトライの間隔が$d \in [0, ベース間隔 \times (2^c - 1)]$になるような<a href="https://en.wikipedia.org/wiki/Exponential_backoff" rel="nofollow noopener" target="_blank">EthernetのExponential Backoffアルゴリズム</a>は以下のように書けます。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"Ethernet protocol"</span><span class="n">should</span><span class="o">{</span><span class="s">"avoid collision by exponential backoff"</span><span class="n">in</span><span class="o">{</span><span class="k">val</span><span class="nv">base</span><span class="k">=</span><span class="nc">Duration</span><span class="o">(</span><span class="mi">51200</span><span class="o">,</span><span class="nv">TimeUnit</span><span class="o">.</span><span class="py">NANOSECONDS</span><span class="o">)</span><span class="k">val</span><span class="nv">backOffPolicy</span><span class="k">=</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">exponential</span><span class="o">(</span><span class="n">base</span><span class="o">).</span><span class="py">jittered</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">))</span><span class="o">.</span><span class="py">repeat</span><span class="o">(</span><span class="n">backOffPolicy</span><span class="o">)</span><span class="o">)</span><span class="o">}</span><span class="o">}</span></pre></div></div><h2><span id="loginput-and-logoutput" class="fragment"></span><a href="#loginput-and-logoutput"><i class="fa fa-link"></i></a><code>logInput</code> and <code>logOutput</code></h2><p>計算の実行結果やエラー情報のログを出力したいときに使用するのが<code>logInput</code>と<code>logOutput</code>です。</p><p><code>logInput</code>で<code>Schedule</code>の入力を、<code>logOutput</code>で出力を受け取ることができます。<code>retry</code>はScheduleの入力にエラー情報を渡すため、以下のように<code>logInput</code>と組み合わせるとエラー情報をログに出力できます。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="s">"logInput"</span><span class="n">should</span><span class="o">{</span><span class="s">"log every input"</span><span class="n">in</span><span class="o">{</span><span class="k">val</span><span class="nv">service</span><span class="k">=</span><span class="k">new</span><span class="nc">StubService</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span><span class="nf">unsafeRun</span><span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="nv">service</span><span class="o">.</span><span class="py">request</span><span class="o">())</span><span class="o">.</span><span class="py">retry</span><span class="o">(</span><span class="nv">Schedule</span><span class="o">.</span><span class="py">recurs</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span><span class="o">.</span><span class="py">logInput</span><span class="o">((</span><span class="n">e</span><span class="k">:</span><span class="kt">Throwable</span><span class="o">)</span><span class="k">=&gt;</span><span class="nc">UIO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">e</span><span class="o">))))</span><span class="o">)</span><span class="o">}</span><span class="o">}</span></pre></div></div><h1><span id="終わりに" class="fragment"></span><a href="#%E7%B5%82%E3%82%8F%E3%82%8A%E3%81%AB"><i class="fa fa-link"></i></a>終わりに</h1><p>ZIOの<code>Schedule</code>は繰り返し処理とリトライ処理の仕様を表現する不変な値です。ZIOに用意されている基本的な<code>Schedule</code>と組み合わせ操作によって複雑な仕様も表現可能です。</p><h1><span id="参考" class="fragment"></span><a href="#%E5%8F%82%E8%80%83"><i class="fa fa-link"></i></a>参考</h1><p><a href="https://www.slideshare.net/jdegoes/zio-schedule-conquering-flakiness-recurrence-with-pure-functional-programming-119932802" rel="nofollow noopener" target="_blank">ZIO Schedule: Conquering Flakiness &amp; Recurrence with Pure Functional Programming</a></p><h1><span id="補足" class="fragment"></span><a href="#%E8%A3%9C%E8%B6%B3"><i class="fa fa-link"></i></a>補足</h1><p>a.<code>Schedule[A, B]</code>は<code>ZSchedule[R, A, B]</code>の環境<code>R</code>を<code>Any</code>に固定したエイリアス。</p><p>b. サンプルコード中の<code>StubService</code>の定義。指定した回数の間はリクエストを失敗して例外を投げる。</p><div class="code-frame" data-lang="scala"><div class="highlight"><pre><span class="k">class</span><span class="nc">StubService</span><span class="o">(</span><span class="k">val</span><span class="nv">failUntil</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="o">{</span><span class="k">var</span><span class="n">current</span><span class="k">=</span><span class="mi">0</span><span class="k">def</span><span class="nf">request</span><span class="o">()</span><span class="k">:</span><span class="kt">String</span><span class="o">=</span><span class="o">{</span><span class="n">current</span><span class="o">+=</span><span class="mi">1</span><span class="nf">if</span><span class="o">(</span><span class="n">current</span><span class="o">&gt;=</span><span class="n">failUntil</span><span class="o">)</span><span class="o">{</span><span class="n">s</span><span class="s">"Succeed at $current attempt"</span><span class="o">}</span><span class="k">else</span><span class="o">{</span><span class="k">throw</span><span class="k">new</span><span class="nc">Exception</span><span class="o">(</span><span class="n">s</span><span class="s">"failed at $current attempt"</span><span class="o">)</span><span class="o">}</span><span class="o">}</span><span class="o">}</span></pre></div></div><p>c. <code>race</code>については<a href="https://qiita.com/MitsutakaTakeda/items/0eabe12c5270d7eeaa02" id="reference-571ff19e7c18abd6f024">以前の記事</a>を参照。</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>