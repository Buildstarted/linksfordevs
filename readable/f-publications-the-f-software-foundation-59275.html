<!DOCTYPE html>
<html lang="en">
<head>
    <title>
F# Publications | The F# Software Foundation - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="F# Publications | The F# Software Foundation - linksfor.dev(s)"/>
    <meta property="og:description" content="F# is about clarity of thinking and expression - &#x201C;computational thinking made manifest&#x201D; - and is loved by academics and researchers&#xA;for bringing clear, concise problem solving techniques developed in academia into practice. &#xA;F# is both based on academic research and acts as an inspiration for thousands of &#xA;students and researchers worldwide. Many standard F# features (including active patterns and asynchronous workflows) &#xA;have been described in academic literature, and many&#xA;research projects build on top of F#."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://fsharp.org/teaching/research.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - F# Publications | The F# Software Foundation</title>
<div class="readable">
        <h1>F# Publications | The F# Software Foundation</h1>
            <div>Reading time: 33-42 minutes</div>
        <div>Posted here: 04 Mar 2020</div>
        <p><a href="https://fsharp.org/teaching/research.html">https://fsharp.org/teaching/research.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="main">
        
        <div>
            <p>F# is about clarity of thinking and expression - “computational thinking made manifest” - and is loved by academics and researchers
for bringing clear, concise problem solving techniques developed in academia into practice. 
F# is both based on academic research and acts as an inspiration for thousands of 
students and researchers worldwide. Many standard F# features (including <em>active patterns</em> and <em>asynchronous workflows</em>) 
have been described in academic literature, and many
research projects build on top of F#.</p>

<p><a href="http://blogs.msdn.com/b/dsyme/archive/2012/07/11/how-to-reference-for-f-in-a-research-paper.aspx">How to reference F# in a research paper</a>.</p>

<p>To add a paper to this list, log on to GitHub, <a href="https://github.com/fsharp/fsfoundation/edit/gh-pages/teaching/research.md">edit this page</a> and submit a pull request.</p>

<ul>
  <li>
    <p><strong><a href="#information-rich-programming">Information-rich programming</a></strong> - publications related to F# type providers, a novel mechanism
  that integrates large-scale data into statically typed function programming language.</p>
  </li>
  <li>
    <p><strong><a href="#asynchronous-concurrent-and-reactive-programming">Asynchronous, Concurrent and Reactive programming</a></strong> - publications
about F# <em>asynchronous workflows</em>, the asynchronous programming model used in F#,
event-based programming and “joinads”, a research extension of F# <em>computation expression</em> syntax
for concurrent, reactive and parallel programming patterns.</p>
  </li>
  <li>
    <p><strong><a href="#distributed-and-parallel-programming">Parallel, Distributed and Cloud programming</a></strong> - publications
related to parallel and distributed programming using F#.</p>
  </li>
  <li>
    <p><strong><a href="#functional-programming">Functional programming</a></strong> - publications
 about core F# language features including <em>active patterns</em> and intialization of 
 mutually recursive values.</p>
  </li>
  <li>
    <p><strong><a href="#dsls-and-meta-programming">DSLs and Meta-programming</a></strong> - publications related to DSL and 
meta-programming in F#.</p>
  </li>
  <li>
    <p><strong><a href="#units-of-measure">Units of Measure</a></strong> - publications related to the Units of Measure feature of F#.</p>
  </li>
  <li>
    <p><strong><a href="#web-programming">Web programming</a></strong> - publications related to web programming with F#.</p>
  </li>
  <li>
    <p><strong><a href="#security-and-verification-research">Security and Verification Research</a></strong> - variations of F# and their use in security and verification research.</p>
  </li>
  <li>
    <p><strong><a href="#applications">Applications</a></strong> - publications and academic presentations describing applications of F#.</p>
  </li>
</ul>

<hr>

<h2 id="information-rich-programming">Information-rich programming</h2>

<h3 id="types-from-data-making-structured-data-first-class-citizens-in-f"><a href="http://conf.researchr.org/event/pldi-2016/pldi-2016-papers-types-from-data-making-structured-data-first-class-citizens-in-f-">Types from data: Making structured data first-class citizens in F#</a></h3>

<p>Tomas Petricek, Don Syme, Gustavo Guerra<br>
<a href="http://conf.researchr.org/home/pldi-2016">Distinguished Paper Award, <em>PLDI 2016</em></a></p>

<p>Most modern applications interact with external services and access data in structured formats such as XML, JSON and CSV. Static type systems do not understand such formats, often making data access more cumbersome. Should we give up and leave the messy world of external data to dynamic typing and runtime checks? Of course, not!</p>

<p>In this paper, we integrate external structured data into F# programming. As most real-world data does not come with an explicit schema, we develop a shape inference algorithm that infers a shape from representative sample documents and transforms the shape into F# types using type providers. We present a formalization and a relative type soundness theorem for a simplified version of this process.</p>

<p>Our library significantly reduces the amount of data access code and it provides additional safety guarantees when contrasted with the widely used weakly typed techniques.</p>

<h3 id="f-30---strongly-typed-language-support-for-internet-scale-information-sources"><a href="http://research.microsoft.com/apps/pubs/default.aspx?id=173076">F# 3.0 - Strongly-Typed Language Support for Internet-Scale Information Sources</a></h3>

<p>Don Syme et al.<br>
<em>MSR Technical Report</em></p>

<p>A growing trend in both the theory and practice of programming is the interaction between 
programming and rich information spaces. From databases to web services to the semantic 
web to cloud-based data, the need to integrate programming with heterogeneous, connected, 
richly structured, streaming and evolving information sources is ever-increasing. 
Most modern applications incorporate one or more external information sources as integral components.</p>

<p>Providing strongly typed access to these sources is a key consideration for strongly-typed 
programming languages, to insure low impedance mismatch in information access. At this scale, 
information integration strategies based on library design and code generation are manual, 
clumsy, and do not handle the internet-scale information sources now encountered in 
enterprise, web and cloud environments.</p>

<p>In this report we describe the design and implementation 
of the type provider mechanism in F# 3.0 and its applications to typed programming 
with web ontologies, web-services, systems management information, database mappings, 
data markets, content management systems, economic data and hosted scripting. Type soundness 
becomes relative to the soundness of the type providers and the schema change in 
information sources, but the role of types in information-rich programming tasks is 
massively expanded, especially through tooling that benefits from rich types in explorative programming.</p>

<h3 id="themes-in-information-rich-functional-programming-for-internet-scale-data-sources"><a href="http://tomasp.net/academic/papers/inforich/">Themes in Information-Rich Functional Programming for Internet-Scale Data Sources</a></h3>

<p>Don Syme et al.<br>
<em>DDFP 2013</em></p>

<p>The F# language includes a feature called F# 3.0 Type Providers to support the integration of internet-scale information sources into a strongly typed functional-first programming environment. In this position paper we describe the key themes in information-rich functional programming that we have observed during this work. Our contribution is to document these themes and highlight future challenges and opportunities, in the context of a recently released, practical, open-source system for information-rich functional programming. We believe that this area is rich in excellent opportunities for future language and tooling research, information-space integration and schematization techniques.</p>

<hr>

<h2 id="asynchronous-concurrent-and-reactive-programming">Asynchronous, Concurrent and Reactive programming</h2>

<h3 id="the-f-asynchronous-programming-model"><a href="http://blogs.msdn.com/b/dsyme/archive/2010/10/21/the-f-asynchronous-programming-model-padl-2010-pre-publication-draft.aspx">The F# Asynchronous Programming Model</a></h3>

<p>Don Syme, Tomas Petricek, Dmitry Lomov<br>
<em>Proceedings of PADL 2011</em></p>

<p>We describe the asynchronous programming model in F#, and its applications to reactive, 
parallel and concurrent programming. The key feature combines a core language with a 
non-blocking modality to author lightweight asynchronous tasks, where the modality has 
control flow constructs that are syntactically a superset of the core language and are given
an asynchronous semantic interpretation. This allows smooth transitions between 
synchronous and asynchronous code and eliminates callback-style treatments of inversion 
of control, without disturbing the foundation of CPU-intensive programming that allows F# to 
interoperate smoothly and compile efficiently to .NET and native code.</p>

<h3 id="collecting-hollywoods-garbage-avoiding-space-leaks-in-composite-events"><a href="http://tomasp.net/academic/papers/hollywood/">Collecting Hollywood’s Garbage: Avoiding Space-Leaks in Composite Events</a></h3>

<p>Tomas Petricek, Don Syme<br>
<em>Proceedings of ISMM 2010</em></p>

<p>The reactive programming model is largely different to what we’re used to as we don’t 
have full control over the application’s control flow. If we mix the declarative and 
imperative programming style, which is usual in the ML family of languages, the situation is 
even more complex. It becomes easy to introduce patterns where the usual garbage collector 
for objects cannot automatically dispose all components that we intuitively consider garbage.</p>

<p>In this paper we discuss a duality between the definitions of garbage for objects and events. 
We combine them into a single one, to specify the notion of garbage for reactive programming 
model in a mixed functional/imperative language and we present a formal algorithm for 
collecting garbage in this environment.</p>

<p>Building on top of the theoretical model, we implement a library for reactive programming 
that does not cause leaks when used in the mixed declarative/imperative model. The library 
allows us to safely combine both of the reactive programming patterns. As a result, we can 
take advantage of the clarity and simplicity of the declarative approach as well as the 
expressivity of the imperative model.</p>

<hr>

<h2 id="functional-programming">Functional programming</h2>

<h3 id="extensible-pattern-matching-via-a-lightweight-language-extension"><a href="http://research.microsoft.com/pubs/79947/p29-syme.pdf">Extensible pattern matching via a lightweight language extension</a></h3>

<p>Don Syme, Gregory Neverov, James Margetson
<em>Proceedings of ICFP 2007</em></p>

<p>Pattern matching of algebraic data types (ADTs) is a standard feature in typed functional 
programming languages, but it is well known that it interacts poorly with abstraction. While 
several partial solutions to this problem have been proposed, few have been implemented or 
used. This paper describes an extension to the .NET language F# called active patterns, 
which supports pattern matching over abstract representations of generic heterogeneous data 
such as XML and term structures, including where these are represented via object models in 
other .NET languages. Our design is the first to incorporate both ad hoc pattern matching 
functions for partial decompositions and “views” for total decompositions, and yet remains 
a simple and lightweight extension. We give a description of the language extension along 
with numerous motivating examples. Finally we describe how this feature would interact with 
other reasonable and related language extensions: existential types quantified at data 
discrimination tags, GADTs, and monadic generalizations of pattern matching.</p>

<h3 id="initializing-mutually-referential-abstract-objects-the-value-recursion-challenge"><a href="http://research.microsoft.com/pubs/79951/valrec-final-ml-workshop.pdf">Initializing Mutually Referential Abstract Objects: The Value Recursion Challenge</a></h3>

<p>Don Syme<br>
<em>Proceedings of ML Workshop 2006</em></p>

<p>Mutual dependencies between objects arise frequently in programs, and programmers must 
typically solve this value recursion by manually filling “initialization holes” to help 
construct the corresponding object graphs, i.e. null values and/or explicitly mutable locations. 
This paper aims to augment ongoing theoretical work on value recursion with a description 
of a semi-safe mechanism for a generalized form of value recursion in an ML-like language, 
where initialization corresponds to a graph of lazy computations whose nodes are sequentially 
forced, requiring runtime checks for soundness during initialization in the style of Russo. 
Our primary contribution is to use the mechanism to develop compelling examples of how the 
absence of value recursion leads to real problems in the presence of abstraction boundaries, 
and give micro-examples that characterize how initialization graphs permit more programs to 
be expressed in the mutation-free fragment of ML. Finally we argue that in heterogeneous 
programming environments semi-safe variations on value-recursion may be appropriate for 
ML-like languages, because initialization effects from external libraries are difficult to 
characterize, document and control.</p>

<h3 id="extending-monads-with-pattern-matching"><a href="http://tomasp.net/academic/papers/docase/">Extending Monads with Pattern Matching</a></h3>

<p>Tomas Petricek, Alan Mycroft and Don Syme<br>
<em>Proceedings of Haskell Symposium 2011</em></p>

<p>Sequencing of effectful computations can be neatly captured using monads and elegantly 
written using <code>do</code> notation. In practice such monads often allow additional ways of 
composing computations, which have to be written explicitly using combinators.</p>

<p>We identify joinads, an abstract notion of computation that is stronger than monads 
and captures many such ad-hoc extensions. In particular, joinads are monads with three 
additional operations: one of type <code>m a -&gt; m b -&gt; m (a, b)</code> captures various forms of 
parallel composition, one of type <code>m a -&gt; m a -&gt; m a</code> that is inspired by choice and one 
of type <code>m a -&gt; m (m a)</code> that captures aliasing of computations. Algebraically, the first 
two operations form a near-semiring with commutative multiplication.</p>

<p>We introduce <code>docase</code> notation that can be viewed as a monadic version of <code>case</code>. Joinad 
laws make it possible to prove various syntactic equivalences of programs written using 
<code>docase</code> that are analogous to equivalences about <code>case</code>. Examples of joinads that benefit 
from the notation include speculative parallelism, waiting for a combination of user 
interface events, but also encoding of validation rules using the intersection of parsers.</p>

<h3 id="try-joinads-demonstrator"><a href="http://tryjoinads.org/">Try Joinads Demonstrator</a></h3>

<p>Joinads is a general-purpose research extension of the F# computation expression syntax (also 
called <em>monadic syntax</em>) in F# and is mainly useful for concurrent, parallal and reactive 
programming. The extension adds a new piece of notation, written <code>match!</code> that can be 
used to compose computations using non-deterministic choice, parallel composition and aliasing.</p>

<p>The best way to experiment with Joinads is to visit the <a href="http://tryjoinads.org/">TryJoinads.org</a>
web site, which contains a number of tutorials that can be tested in web browser capable
of running Silverlight (MacOS and Windows).</p>

<h3 id="evaluation-strategies-for-monadic-computations"><a href="http://tomasp.net/academic/papers/malias/">Evaluation strategies for monadic computations</a></h3>

<p>Tomas Petricek<br>
<em>Proceedings of MSFP 2012</em></p>

<p>Monads have become a powerful tool for structuring effectful computations in functional 
programming, because they make the order of effects explicit. When translating pure code to a 
monadic version, we need to specify evaluation order explicitly. This requires us to choose 
between <em>call-by-value</em> or <em>call-by-name</em> style. The two translations give programs with 
different semantics, structure and also different types.</p>

<p>In this paper, we translate pure code to monadic using an additional operation <code>malias</code> 
that abstracts out the evaluation strategy. The <code>malias</code> operation is based on <em>computational comonads</em>; 
we use a categorical framework to specify the laws that are required to hold about the operation.</p>

<p>We show two implementations of <code>malias</code> for any monad that give <em>call-by-value</em> and 
<em>call-by-name</em> semantics. Although we do not give <em>call-by-need</em> semantics for any monad, we 
show how to turn any monad into an extended monad with <em>call-by-need</em> semantics, which partly 
answers a standing open question. Moreover, using our unified translation, it is possible to 
change the evaluation strategy of functional code translated to the monadic form without 
changing its structure or types.</p>

<h3 id="joinads-a-retargetable-control-flow-construct-for-reactive-parallel-and-concurrent-programming"><a href="http://tomasp.net/academic/papers/joinads/">Joinads: a retargetable control-flow construct for reactive, parallel and concurrent programming</a></h3>

<p>Tomas Petricek and Don Syme<br>
<em>Proceedings of PADL 2011</em></p>

<p>Modern challenges led to a design of a wide range of programming models for reactive,
parallel and concurrent programming, but these are often difficult to encode in general 
purpose languages. We present an abstract type of computations called <em>joinads</em> together 
with a syntactic language extension that aims to make it easier to use joinads in 
modern functional languages.</p>

<p>Our extension generalizes pattern matching to work on abstract computations. It keeps a 
familiar syntax and semantics of pattern matching making it easy to reason about code, 
even in a non-standard programming model. We demonstrate our extension using three important 
programming models – a reactive model based on events; a concurrent model based on join 
calculus and a parallel model using futures. All three models are implemented as libraries 
that benefit from our syntactic extension. This makes them easier to use and also opens 
space for exploring new useful programming models.</p>

<h3 id="the-f-computation-expression-zoo"><a href="http://tomasp.net/academic/papers/computation-zoo/">The F# Computation Expression Zoo</a></h3>

<p>Tomas Petricek, Don Syme<br>
<em>Proceedings of PADL 2014</em></p>

<p>Many computations can be structured using abstract computation types such as monoids, monad transformers or applicative functors. Functional programmers use those abstractions directly while main-stream languages often integrate concrete instances as language features - e.g. generators in Python or asynchronous computations in C# 5.0. The question is, is there a sweet spot between convenient, hardwired language features, and an inconvenient but flexible libraries?</p>

<p>F# computation expressions answer this question in the affirmative. Unlike the do notation in Haskell, computation expressions are not tied to a single kind of abstraction. They support a wide range of computations, depending on what operations are available. They also provide greater syntactic flexibility leading to a more intuitive syntax, without resorting to full macro-based meta-programming.</p>

<p>We show that computation expressions can structure well-known computations including monoidal list comprehensions, monadic parsers, applicative formlets and asynchronous sequences based on the list monad transformer. We also present typing rules for computation expressions that are capable of capturing all these applications.</p>

<h3 id="classes-for-the-masses"><a href="http://www.mlworkshop.org/2016-7.pdf">Classes for the Masses</a></h3>

<p>Claudio Russo, Matthew Windsor, Don Syme, Rupert Horlick, James Clarke
<em>Proceedings of ML 2016</em></p>

<p>Type classes are an immensely popular and productive feature of Haskell. They have since been adopted in, 
and adapted to, numerous other languages, including theorem provers. 
We show that type classes have a natural and efﬁcient representation in .NET that paves
the way for the extension of F#, C# and other .NET languages with type classes. 
Our encoding is type preserving and promises easy and safe cross-language inter-operation. 
We have extended the open source C# compiler and language service, Roslyn,
with pervasive support for type classes and have prototyped a more minimalist design for F#.</p>

<hr>



<h3 id="leveraging-net-meta-programming-components-from-f-integrated-queries-and-interoperable-heterogeneous-execution"><a href="http://dl.acm.org/citation.cfm?doid=1159876.1159884">Leveraging .NET meta-programming components from F#: integrated queries and interoperable heterogeneous execution</a></h3>

<p>Don Syme<br>
<em>Proceedings of the 2006 workshop on ML</em></p>

<p>Language-integrated meta-programming and extensible compilation have been recurring themes of 
programming languages since the invention of LISP. A recent real-world application of these 
techniques is the use of small meta-programs to specify database queries, as used in the<br>
LINQ extensions for .NET. It is important that .NET languages such as F# are able to leverage 
the functionality provided by LINQ and related components for heterogeneous execution, both 
for pragmatic reasons and as a first step toward applying more disciplined, formal approaches 
to these problems. This paper explores the use of a modest meta-programming extension to F# to 
access and leverage the functionality of LINQ and other components. We do this by demonstrating 
an implementation of language integrated SQL queries using the LINQ/SQLMetal libraries. We also 
sketch two other applications: the execution of data-parallel quoted F# programs on a GPU via the 
Accelerator libraries, and dynamic native-code compilation via LINQ.</p>

<h3 id="the-f-computation-expression-zoo-1"><a href="http://tomasp.net/academic/papers/computation-zoo/">The F# Computation Expression Zoo</a></h3>

<p>Tomas Petricek and Don Syme
<em>In proceedings of PADL 2014</em></p>

<p>Many computations can be structured using abstract computation types such as monoids, monad 
transformers or applicative functors. Functional programmers use those abstractions directly while 
main-stream languages often integrate concrete instances as language features - e.g. generators in 
Python or asynchronous computations in C# 5.0. The question is, is there a sweet spot between 
convenient, hardwired language features, and an inconvenient but flexible libraries?</p>

<p>F# computation expressions answer this question in the affirmative. Unlike the do notation in Haskell, 
computation expressions are not tied to a single kind of abstraction. They support a wide range of 
computations, depending on what operations are available. They also provide greater syntactic 
flexibility leading to a more intuitive syntax, without resorting to full macro-based meta-programming.</p>

<p>We show that computation expressions can structure well-known computations including monoidal list 
comprehensions, monadic parsers, applicative formlets and asynchronous sequences based on the list 
monad transformer. We also present typing rules for computation expressions that are capable of 
capturing all these applications.</p>

<h3 id="rapid-prototyping-of-dsls-with-f"><a href="http://academic.research.microsoft.com/Publication/39281456/rapid-prototyping-of-dsls-with-f#">Rapid Prototyping of DSLs with F#</a></h3>

<p>Adam Granicz
<em>Central European Functional Programming School (CEFP)</em></p>

<p>In these lecture notes we present the F# implementation of a small programming language we call Simply. 
We give the parser implementation using active patterns, F#’s unique feature for extensible pattern matching, 
which as we demonstrate provide an elegant and type-safe mechanism to embed parsers as an alternative approach 
to parser generators. We also build an evaluator, and extend the core Simply language with Logo-like 
primitives and build a graphical shell environment around it. As a warm-up, we give a rudimentary survey 
of some notable F# features, including sequence expressions and active patterns.</p>

<hr>

<h2 id="distributed-and-parallel-programming">Parallel and Distributed programming</h2>

<h3 id="mbrace-cloud-computing-with-monads"><a href="http://dl.acm.org/citation.cfm?id=2525531&amp;dl=ACM&amp;coll=DL&amp;CFID=454202220&amp;CFTOKEN=25283533">MBrace: cloud computing with monads</a></h3>

<p>Jan Dzik, Nick Palladinos, Konstantinos Rontogiannis, Eirik Tsarpalis, Nikolaos Vathis
<em>In pre-proceedings of PLOS ‘13 Seventh Workshop on Programming Languages and Operating Systems Article No. 7</em></p>

<p>As cloud computing and big data gain prominence in today’s economic landscape, the challenge of effectively articulating complex algorithms in distributed environments becomes ever more important. In this paper we describe MBrace; a novel programming model/framework for performing large scale computation in the cloud. Based on the .NET software stack, it utilizes the power of the F# programming language. MBrace introduces a declarative style for specifying and composing parallelism patterns, in what is known as cloud workflows or a cloud monad. MBrace is also a distributed execution runtime that handles orchestration of cloud workflows in the data centre.</p>

<h3 id="implementation-of-mbrace-for-large-scale-cloud-computing"><a href="https://github.com/krontogiannis/MBrace.Azure/raw/thesis/docs/mbrace-thesis-en.pdf">Implementation of MBrace for large-scale cloud computing</a></h3>

<p>Konstantinos Rontogiannis
<em>Diploma Thesis, National Technical University of Athens, School of Electrical and Computer Engineering, 2015</em></p>

<p>The purpose of this diploma dissertation is on one hand the description of MBrace; a programming
model for performing large scale distributed computations, and on the other hand the implementation
of MBrace on the Microsoft Azure cloud computing platform.</p>

<p>In the era of big data and cloud computing, the need for efficient and effective orchestration of distributed
computations becomes a necessity. Cloud computing providers make it easy for someone to
get access to computational resources needed.</p>

<p>Programming large scale distributed systems is a remarkably difficult task, that requires the management
and orchestration of multiple concurrent processes, software and hardware failures, scalability
and elasticity.</p>

<p>In this diploma dissertation we describe MBrace; a programming model for large scale cloud computing.
Based on the F# programming language and the .NET framework stack, MBrace provides a
declarative, expressive and rich model for creating and composing distributed computations. This
pattern is also known as cloud workflows, or cloud monad. Finally, we have implemented this model
on top of the Microsoft Azure platform, providing MBrace.Azure: a distributed execution runtime for
cloud computations.</p>

<h3 id="specifying-and-executing-optimizations-for-parallel-programs"><a href="http://web.engr.illinois.edu/~mansky1/exec.pdf">Specifying and Executing Optimizations for Parallel Programs</a></h3>

<p>William Mansky, Dennis Griffith, Elsa L. Gunter
<em>In pre-proceedings of GRAPHITE ‘14</em></p>

<p>Compiler optimizations, usually expressed as rewrites on program graphs, are a core part of all modern compilers. However, even production compilers have bugs, and these bugs are difficult to detect and resolve. The problem only becomes more complex when compiling parallel programs; from the choice of graph representation to the possibility of race conditions, optimization designers have a range of factors to consider that do not appear when dealing with single-threaded programs. In this paper we present PTRANS, a domain-specific language for formal specification of compiler transformations, and describe its executable semantics. The fundamental approach of PTRANS is to describe program transformations as rewrites on control flow graphs with temporal logic side conditions. The syntax of PTRANS allows cleaner, more comprehensible specification of program optimizations; its executable semantics allows these specifications to act as prototypes for the optimizations themselves, so that candidate optimizations can be tested and refined before going on to include them in a compiler. We demonstrate the use of PTRANS to state, test, and refine the specification of a redundant store elimination optimization on parallel programs.</p>

<h3 id="prajna-cloud-service-and-interactive-big-data-analytics"><a href="http://msrccs.github.io/Prajna/">Prajna: Cloud Service and Interactive Big Data Analytics</a></h3>

<p>Jin Li, Sanjeev Mehrotra and Weirong Zhu</p>

<p>In this paper, we describe Prajna, a distributed functional
programming platform. Prajna is built on top of .Net and F#,
and is open source released. Prajna not only
supports (and extends) in-memory data analytics on large
clusters like that of Spark, but also supports development
and deployment of cloud services. Moreover, we show that
Prajna can harmonize cloud service and data analytical service,
and add rich data analytics on any existing cloud service/application.
Prajna supports running of cloud service and interactive data analytics in both managed code and unmanaged
code, and supports running of remote code with significant data components (e.g., a recognition model that is hundreds of megabytes in size).</p>

<hr>

<h2 id="units-of-measure">Units of Measure</h2>

<h3 id="relational-parametricity-and-units-of-measure"><a href="http://dl.acm.org/citation.cfm?id=263761">Relational parametricity and units of measure</a></h3>

<p>Type systems for programming languages with numeric
types can be extended to support the checking of units
of measure. Quantification over units then introduces
a new kind of parametric polymorphism with a corresponding
Reynolds-style representation independence
principle: that the behaviour of programs is invariant
under changes to the units used. We prove this ‘dimensional
invariance’ result and describe four consequences.
The first is that the type of an expression can be used to
derive equations which describe its properties with respect
to scaling (akin to Wadler’s ‘theorems for free’ for
System F). Secondly there are certain types which are
inhabited only by trivial terms. For example, we prove
that a fully polymorphic square root function cannot
be written using just the usual arithmetic primitives.
Thirdly we exhibit interesting isomorphisms between
types and for first-order types relate these to the central
theorem of classical dimensional analysis. Finally
we suggest that for any expression whose behaviour is
dimensionally invariant there exists some equivalent expression
whose type reflects this behaviour, a consequence
of which would be a full abstraction result for
a model of the language.</p>

<h3 id="programming-languages-and-dimensions"><a href="http://academic.research.microsoft.com/Publication/1387457/programming-languages-and-dimensions">Programming Languages and Dimensions</a></h3>

<p>Andrew Kennedy
<em>PhD Thesis, University of Cambridge, 1995</em></p>

<h3 id="types-for-units-of-measure-theory-and-practice"><a href="http://research.microsoft.com/en-us/um/people/akenn/units/cefp09typesforunitsofmeasure.pdf">Types for Units-of-Measure: Theory and Practice</a></h3>

<p>Andrew Kennedy
<em>Lecture notes , for CEFP’09, Revised July 2010</em></p>

<hr>

<h2 id="web-programming">Web programming</h2>

<h3 id="visualizing-data-in-the-web"><a href="http://dl.acm.org/citation.cfm?id=2429376">Visualizing Data in the Web</a></h3>

<p>Loic Denuziere, Adam Granicz, Anton Tayanovskyy
<em>Data Driven Functional Programming 2013 (DDFP)</em></p>

<h3 id="composing-reactive-guis-in-f-using-websharper"><a href="http://link.springer.com/content/pdf/10.1007/978-3-642-24276-2_13">Composing Reactive GUIs in F# Using WebSharper</a></h3>

<p>Joel Bjornson, Anton Tayanovskyy, and Adam Granicz
<em>The 22nd Symposium on Implementation and Application of Functional Languages (IFL)</em></p>

<p>We present a generic library for constructing composable
and interactive user interfaces in a declarative style. The paper introduces
flowlets, an extension of formlets providing interactivity. Realworld
examples are given using the current implementation that compiles
flowlets defined in F# to JavaScript with WebSharper</p>

<hr>

<h2 id="security-and-verification-research">Security and Verification Research</h2>

<p>The experimental <a href="http://research.microsoft.com/en-us/projects/fstar/">FStar language</a> is inspired by F#. 
Some of the publications about FStar are below.</p>

<ul>
  <li>
    <p>Verifying Higher-order Programs with the Dijkstra Monad, Nikhil Swamy, Joel Weinberger, Cole Schlesinger, 
Juan Chen, and Benjamin Livshits, in ACM Programming Language Design and Implementation (PLDI) 2013, ACM, June 2013</p>
  </li>
  <li>
    <p>Self-Certification: Bootstrapping Certified Typecheckers in FStar with Coq, Pierre-Yves Strub, Nikhil Swamy, 
Cedric Fournet, and Juan Chen, in In Proceedings of the ACM Symposium on Principles on Programming Languages, 
ACM, January 2012</p>
  </li>
  <li>
    <p>Secure Distributed Programming with Value-dependent Types, Nikhil Swamy, Juan Chen, Cedric Fournet, Pierre-Yves Strub, Karthikeyan Bharagavan, and Jean Yang, 
in The 16th ACM SIGPLAN International Conference on Functional Programming (ICFP 2011), ACM SIGPLAN, September 2011</p>
  </li>
  <li>
    <p>Verified Security for Browser Extensions, Arjun Guha, Matthew Fredrikson, Benjamin Livshits, and Nikhil Swamy, 
in Proceedings of the IEEE Symposium on Security and Privacy (Oakland), IEEE, 22 May 2011</p>
  </li>
  <li>
    <p>Mechanized soundness proofs for FStar, Pierre-Yves Strub, Cedric Fournet, and Nikhil Swamy, 1 April 2011</p>
  </li>
  <li>
    <p>Secure Distributed Programming with Value-Dependent Types, Nikhil Swamy, Juan Chen, Cedric Fournet, 
Pierre-Yves Strub, Karthikeyan Bharagavan, and Jean Yang, no. MSR-TR-2011-37, 24 March 2011</p>
  </li>
</ul>

<hr>

<h2 id="applications">Applications</h2>

<p>For more applications of F#, see the <a href="https://fsharp.org/testimonials/">Testimonials</a> page. Below are some peer-reviewed publications or academic presentations related to applications of F#.</p>

<h3 id="learning-with-f"><a href="http://dl.acm.org/citation.cfm?id=1362709">Learning with F#</a></h3>

<p>Phil Trelford, <em>Commercial Users of Funnctional Programming</em>, 2006. This talk describes how the Applied Games Group at Microsoft Research Cambridge uses F#. This group consists of seven people, and specializes in the application of statistical machine learning, especially ranking problems. The ranking systems they have developed are used by the XBox Live team to do server-side analysis of game logs, and they recently entered an internal competition to improve “click-through” prediction rates on Microsoft adCenter, a multi-million dollar industry for the company. The amount of data analysed by the tools is astounding: e.g. 3TB in one case, with programs running continuously over four weeks of training data and occupying all the physical memory on the 64-bit 16GB machines we use.</p>

<p>F# plays a crucial role in helping the group process this data efficiently and develop smart algorithms that extract essential features from the data and represent the information using the latest statistical technique called “factor graphs”. Our use of F# in conjunction with SQL Server 2005 is especially interesting: we use novel compilation techniques to express the primary schema in F# and then use SQL Server as a data slave.</p>

<h3 id="developing-an-f-bioinformatics-application-with-html5-visualization"><a href="http://cufp.org/videos/developing-f-bioinformatics-application-html5-visualization">Developing an F# Bioinformatics Application with HTML5 Visualization</a></h3>

<p>Adam Granicz, IntelliFactory
<em>Commercial Users of Functional Programming (CUFP) 2012</em></p>

<p>With proprietary plugin-based containers like Flash or Silverlight gradually losing ground, an increasing 
number of web applications are beginning to seek web standards compliance, and to utilize HTML5 to deliver 
rich and interactive client-side functionality and end-user experience. Indeed, modern browsers continue 
to invest heavily in establishing standard support for various HTML5 features, making HTML5 an appropriate 
choice for an ever-growing crowd of web developers.</p>

<p>Earlier this year at IntelliFactory, we completed a pilot project missioned to create a custom, 
innovative, and highly interactive bioinformatics web application using F# and our WebSharper technology. 
This application set out to serve the bioinformatics research community, and to deliver, among others, 
an interactive visualization of the gene sequence of a particular bacterium, with various mutations 
available for further research and laboratory use. The application consumed a large amount of bio data 
and integrated various advanced HTML5 visualizations, such as full functional gene ontology, a KEGG 
orthology, and a phenotype map, making it a useful web resource for researchers and laboratory staff alike.</p>

<p>I will present our experience report on developing this bioinformatics application, the 
practices and guidelines related to client-based visualization projects we distilled while developing it, 
the challenges we met on the way, and how we solved these challenges. Many bioinformatics algorithms 
are amenable to functional programming, but as a full-blown web application with advanced visualization
this project yielded a great deal of details that we hope will be useful for other attendees.</p>

<h3 id="bumblebee-a-transformation-environment-for-spreadsheet-formulae"><a href="http://scholar.google.nl/citations?view_op=view_citation&amp;hl=en&amp;user=Kzy5f1IAAAAJ&amp;citation_for_view=Kzy5f1IAAAAJ:LkGwnXOMwfcC">BumbleBee: A Transformation Environment for Spreadsheet Formulae</a></h3>

<p>Felienne Hermans, Danny Dig</p>

<p>Spreadsheets are widely used in industry. It is estimated that end-user 
programmers outnumber regular programmers by a factor of 5. However, spreadsheets are 
error-prone: several reports exist of companies which have lost money because of 
spreadsheet errors. We assert that a contributing factor to these problems is the difficulty of 
consistent editing of spreadsheet formulas.</p>

<h3 id="the-first-substantial-line-of-business-application-in-f-video"><a href="http://dl.acm.org/citation.cfm?id=1668117">The First Substantial Line of Business Application in F#</a>, <a href="http://cufp.org/videos/first-substantial-line-business-application-f">video</a></h3>

<p>Adam Granicz, IntelliFactory, Alex Peake, Veracentra
<em>Commercial Users of Functional Programming (CUFP) 2009</em></p>

<p>We have developed MarketingPlatform™ a marketing automation solution delivered as Software as a Service 
with F# as the primary language. MarketingPlatform™ is a solution for marketers in direct marketing and 
in channel marketing who would like to gain a timely and deep understanding of what is working and what 
is not working in their marketing campaigns. Marketers are than facilitated in the execution and delivery
of campaigns, using this insight to create relevant communications to each individual. It is divided into 
four tightly integrated campaign management steps of Measure, Analyze, Design and Execute.</p>

<h3 id="applying-functional-programming-to-build-platform-independent-mobile-applications"><a href="http://cufp.org/conference/sessions/2011/applying-functional-programming-build-platform-ind">Applying Functional Programming to Build Platform-Independent Mobile Applications</a></h3>

<p>Adam Granicz, IntelliFactory
<em>Commercial Users of Functional Programming (CUFP) 2011</em></p>

<p>Native mobile applications enjoyed tremendous success in recent years, and looking at various mobile 
application stores such as Apple’s App Store or Google’s Android Market reveals a staggering number of 
native mobile applications. As technologies to build these applications mature and the market saturates, 
mobile OS vendors are struggling to find ways to keep up with and secure the exponential market growth. 
Inhibiting factors include platform-specific development environments, programming languages, and 
building blocks for applications; developer-unfriendly licensing, policies and subscriptions; and 
controlled channels of application distribution.</p>

<p>These problems have given rise to many promising alternatives and technologies that aim to bridge 
across various mobile platforms and enable sharing some or all the code in between versions of 
applications for different mobile OSs. Two main directions unfolded: targeting mobile code generation 
from mainstream languages such as C# and Java, and embracing web applications with platform-independent 
UI abstractions and enhanced access to the capabilities of the underlying device. While the technologies
that enabled the former are an interesting topic, we believe that the latter has implications not only 
for mobile applications but also for their desktop counterparts, and finding ways to utilize functional 
programming in the development of these web-based applications has an immense impact on mobiles and desktops alike.</p>

<p>In this talk I will highlight some of the work we are doing at IntelliFactory to enable building 
platform-independent mobile applications in F#. This work leverages our commercially available WebSharper
framework, the premiere functional web development framework for F# with thousands of active users and 
partner companies, and utilizes some key functional programming abstractions that enable modeling 
first-class, type-safe, composable web applications and user interfaces. I will briefly outline the 
metaprogramming infrastructure that enables us to enlist arbitrary JavaScript libraries into the 
type-safe discipline of F#, and the underlying CoreJS language that is more amenable to reasoning about 
and applying code transformations and optimizations.</p>

<p>At the end of the talk, I will briefly touch upon our upcoming F# in the Cloud support and how that 
helps to seamlessly scale into the cloud desktop and mobile web applications with immense server computation needs.</p>

<h3 id="glr-based-abstract-parsing-video-in-russian"><a href="http://dl.acm.org/citation.cfm?id=2556616&amp;dl=ACM&amp;coll=DL">GLR-based abstract parsing</a>, <a href="http://vimeo.com/79442837">video (in russian)</a></h3>

<p>Semen Grigorev, Saint Petersburg State University, Iakov Kirilenko, Saint Petersburg State University</p>

<p><em>Central &amp; Eastern European Software Engineering Conference in Russia (CEE-SECR ‘13) 2013</em></p>

<p>Abstract parsing is an important step of the processing of dynamically constructed statements or string-embedded 
languages (such as embedded or dynamic SQL). Existing LALR-based algorithms have performance issues. To increase performance we propose 
to use a GLR-algorithm as a base for abstract parsing and to reuse graph-structured stack and shared packed parse forest. 
RNGLR-algorithm modification for abstract parsing is presented.</p>

        </div>
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>