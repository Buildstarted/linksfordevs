<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Some SQL Tricks of an Application DBA - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Some SQL Tricks of an Application DBA - linksfor.dev(s)"/>
    <meta property="article:author" content="Haki Benita"/>
    <meta property="og:description" content="Non-trivial tips for database development"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://hakibenita.com/sql-tricks-application-dba"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Some SQL Tricks of an Application DBA</title>
<div class="readable">
        <h1>Some SQL Tricks of an Application DBA</h1>
            <div>by Haki Benita</div>
            <div>Reading time: 36-46 minutes</div>
        <div>Posted here: 28 Jul 2020</div>
        <p><a href="https://hakibenita.com/sql-tricks-application-dba">https://hakibenita.com/sql-tricks-application-dba</a></p>
        <hr/>
<div id="readability-page-1" class="page"><article data-progress-indicator="">
        <hr>
<p>When I started my career in development, my first job was a DBA. Back then, before AWS RDS, Azure, Google Cloud and the rest of them cloud services, there were two types of DBAs:</p>
<p><strong>The Infrastructure DBA</strong> was in charge of setting up the database, configuring the storage and taking care of backups and replication. After setting up the database, the infrastructure DBA would pop up from time to time and do some "instance tuning", things like sizing caches.</p>
<p><strong>The Application DBA</strong> got a clean database from the infrastructure DBA, and was in charge of schema design: creating tables, indexes, constraints, and tuning SQL. The application DBA was also the one who implemented ETL processes and data migrations. In teams that used stored procedures, the application DBA would maintain those as well.</p>
<p>Application DBAs were usually part of the development team. They would possess deep domain knowledge so normally they would work on just one or two projects. Infrastructure DBAs would usually be part of some IT team, and would work on many projects simultaneously.</p>
<p><strong>I'm an Application DBA</strong></p>
<p>I never had any desire to fiddle with backups or tune storage (I'm sure it's fascinating!). Until this day I like to say I'm a DBA that knows how to develop applications, and not a developer that knows his way around the database.</p>
<p><strong>In this article I share some non-trivial tips about database development I gathered along the way.</strong></p>
<figure><img alt="Be that guy...<br>Image by <a href=&quot;https://www.commitstrip.com/en/2014/08/01/when-i-help-a-rookie-coder-fix-his-queries&quot;>CommitStrip</a>" src="https://hakibenita.com/images/00-sql-tricks-dba.jpg"><figcaption>Be that guy...<br>Image by <a href="https://www.commitstrip.com/en/2014/08/01/when-i-help-a-rookie-coder-fix-his-queries">CommitStrip</a></figcaption>
</figure>
<details open="">
    <summary>Table of Contents</summary>

</details>
<hr>
<h2 id="update-only-what-needs-updating"><a href="#update-only-what-needs-updating">Update Only What Needs Updating</a></h2>
<p><code>UPDATE</code> is a relatively expensive operation. To speed up an <code>UPDATE</code> command it's best to make sure you only update what needs updating.</p>
<p>Take this query for example that normalizes an email column:</p>
<div><pre><span></span><span>db=#</span> <span>UPDATE</span> <span>users</span> <span>SET</span> <span>email</span> <span>=</span> <span>lower</span><span>(</span><span>email</span><span>);</span>
<span>UPDATE 1010000</span>
<span>Time: 1583.935 ms (00:01.584)</span>
</pre></div>


<p>Looks innocent, right? the query updated emails of 1,010,000 users. But, did all rows really needed to update?</p>
<div><pre><span></span><span>db=#</span> <span>UPDATE</span> <span>users</span> <span>SET</span> <span>email</span> <span>=</span> <span>lower</span><span>(</span><span>email</span><span>)</span>
<span><span>db-#</span> <span>WHERE</span> <span>email</span> <span>!=</span> <span>lower</span><span>(</span><span>email</span><span>);</span>
</span><span>UPDATE 10000</span>
<span>Time: 299.470 ms</span>
</pre></div>


<p>Only 10,000 rows needed to update. By reducing the amount of affected rows, the execution time went down from 1.5 seconds to just less than 300ms. Updating fewer rows also saves the database maintenance later on.</p>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 248.6 124" width="20em"><path d="M10 11l32-2-2 27H9" fill="#f41d92"></path><path d="M10 9c12-1 21 1 32 3m-31-2h29m1 2c-2 7 0 13 2 23m-2-25l1 24m1 2H9m32-1H9m2 0c-2-6-1-14-1-27M9 35V9" stroke="currentColor" fill="none"></path><path d="M166 10l29 2v25l-29-1" fill="#e08fff"></path><path d="M166 10c10 1 24 3 30 0m-32 2l32-1m-2 1c2 4 3 10 0 23m3-23l-1 24m1 1l-33-1m33 0c-10-1-20 0-32 1m-1 0l2-24m-1 24V11" stroke="currentColor" fill="none"></path><path d="M204 9l31 3-1 25-29-3" fill="#daaeff"></path><path d="M203 11l33-1m-33-1c9 1 16 0 31 2m-1 1l2 24m-1-25l1 25m-1-1h-31m30 0l-29 1m0 0c-3-6 1-14-2-27m2 26c-2-7-1-13-1-25" stroke="currentColor" fill="none"></path><path d="M45 11l33-2-2 28-29-1" fill="#f41d92"></path><path d="M47 12h32m-34-1c12-2 23 0 33-1m0 0c-2 10-1 19-2 28m1-29l1 26m1 2c-12-3-23 0-33-1m32 0l-31-1m0-1c0-7-1-11 1-22m-2 24V10" stroke="currentColor" fill="none"></path><path d="M83 9l34 3 1 24-35-1" fill="#f41d92"></path><path d="M86 12l31-2m-32 0c8 1 14 1 31-1m-1 2c1 10 0 19 3 26m-1-27v26m0 1l-31-3m31 2H85m0-1c-1-10 1-16-1-26m0 26l2-25" stroke="currentColor" fill="none"></path><path d="M124 10l34 1-1 25-34-1" fill="#f41d92"></path><path d="M123 13h33m-30-1l30-1m1 0c-1 9 0 16-3 25m2-24c-1 6 1 15 1 25m1 1c-14-2-24-1-34-3m32 2h-31m0-2c-1-8 2-16 0-25m1 27c-2-6-1-14 0-25" stroke="currentColor" fill="none"></path><path d="M13 89l31-1 1 26-29-1" fill="#f41d92"></path><path d="M16 87c10 0 17 2 30-1m-33 2c13 0 26-2 32 0m1 1c-2 4 2 9 2 23m-2-24v25m1-2c-13 2-20 3-31 3m29-2c-8-1-20 0-32 1m0-1c3-9 1-15 3-25m-2 26c1-8 0-15-1-25" stroke="currentColor" fill="none"></path><g><path d="M52 87l31 2-1 23-31 2" fill="#f41d92"></path><path d="M50 86c14 2 24 3 32 1m-31 0l32 1m0 1l-1 25m0-26v26m0-1c-10 1-21 0-32-2m31 1l-31 1m0 0c2-5 1-13 2-24m-1 24l1-26" stroke="currentColor" fill="none"></path></g><g><path d="M89 89l33-1-2 25H91" fill="#f41d92"></path><path d="M88 89c12-3 22-1 32-3m-31 1l32 1m2 0c-1 9-2 20-1 25m0-26v26m-1 1c-6 0-15-2-33-2m32 0H90m-1 2c2-8 0-13 2-28m-2 27V88" stroke="currentColor" fill="none"></path></g><g><path d="M131 90l30-2v27l-31-1" fill="#f41d92"></path><path d="M131 89c9 2 23-1 28 1m-30-2l32 2m0 1v24m-1-26l1 24m1 2c-6-1-14-3-34-2m32 0l-31 1m2 1c-2-11 0-19-3-25m2 23V89" stroke="currentColor" fill="none"></path></g><g><path d="M168 90l32-2-2 26-27 1" fill="#f41d92"></path><path d="M167 90h33m-31-2h30m2 1v25m-2-26v26m1 1l-32-3m31 1l-31 1m3 1c-2-8 0-20-2-28m-1 27c2-10 0-17 0-26" stroke="currentColor" fill="none"></path></g><g><path d="M209 88l31 2v22l-34 2" fill="#f41d92"></path><path d="M208 89c7-1 15-3 30-2m-30 2c10-1 22-2 30-1m3 1c-2 6-3 10-4 24m1-26c-1 7 0 13 1 26m-2 1c-4 1-14 1-28-1m29 0l-31 1m2 0c-2-8-2-11-1-25m-1 25V87" stroke="currentColor" fill="none"></path></g><g><path d="M183 46l1 36m-2-37l1 36M177 64l6 16m-7-17c1 3 2 8 7 17M190 64c-1 4-5 8-7 16m5-18l-5 18" stroke="currentColor" fill="none"></path></g><g><path d="M221 44l3 37m-1-35v37M215 67c3 1 4 7 7 16m-4-16c1 6 3 13 5 16M228 67l-6 16m8-16l-7 16" stroke="currentColor" fill="none"></path></g></svg>
<figcaption>Update Only What Needs Updating</figcaption>
</figure>

<p>This type of large updates are very common in data migration scripts. So the next time you write a migration script, make sure to only update what needs updating.</p>
<hr>
<h2 id="disable-constraints-and-indexes-during-bulk-loads"><a href="#disable-constraints-and-indexes-during-bulk-loads">Disable Constraints and Indexes During Bulk Loads</a></h2>
<p>Constraints are an important part of relational databases: they keep the data consistent and reliable. Their benefits come at a cost though, and it's most noticeable when loading or updating a lot of rows.</p>
<p>To demonstrate, set up a small schema for a store:</p>
<div><pre><span></span><span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span>product</span> <span>CASCADE</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> <span>product</span> <span>(</span>
    <span>id</span> <span>serial</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    <span>name</span> <span>TEXT</span> <span>NOT</span> <span>NULL</span><span>,</span>
    <span>price</span> <span>INT</span> <span>NOT</span> <span>NULL</span>
<span>);</span>
<span>INSERT</span> <span>INTO</span> <span>product</span> <span>(</span><span>name</span><span>,</span> <span>price</span><span>)</span>
    <span>SELECT</span> <span>random</span><span>()::</span><span>text</span><span>,</span> <span>(</span><span>random</span><span>()</span> <span>*</span> <span>1000</span><span>)::</span><span>int</span>
    <span>FROM</span> <span>generate_series</span><span>(</span><span>0</span><span>,</span> <span>10000</span><span>);</span>


<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span>customer</span> <span>CASCADE</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> <span>customer</span> <span>(</span>
    <span>id</span> <span>serial</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    <span>name</span> <span>TEXT</span> <span>NOT</span> <span>NULL</span>
<span>);</span>
<span>INSERT</span> <span>INTO</span> <span>customer</span> <span>(</span><span>name</span><span>)</span>
    <span>SELECT</span> <span>random</span><span>()::</span><span>text</span>
    <span>FROM</span> <span>generate_series</span><span>(</span><span>0</span><span>,</span> <span>100000</span><span>);</span>


<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span>sale</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> <span>sale</span> <span>(</span>
    <span>id</span> <span>serial</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    <span>created</span> <span>timestamptz</span> <span>NOT</span> <span>NULL</span><span>,</span>
    <span>product_id</span> <span>int</span> <span>NOT</span> <span>NULL</span><span>,</span>
    <span>customer_id</span> <span>int</span> <span>NOT</span> <span>NULL</span>
<span>);</span>
</pre></div>


<p>The schema defines different types of constraints such as "not null" and unique constraints.</p>
<p>To set a baseline, start by adding foreign keys to the <code>sale</code> table, and then load some data into it:</p>
<div><pre><span></span><span>db=#</span> <span>ALTER</span> <span>TABLE</span> <span>sale</span> <span>ADD</span> <span>CONSTRAINT</span> <span>sale_product_fk</span>
<span>db-#</span> <span>FOREIGN</span> <span>KEY</span> <span>(</span><span>product_id</span><span>)</span> <span>REFERENCES</span> <span>product</span><span>(</span><span>id</span><span>);</span>
<span>ALTER TABLE</span>
<span>Time: 18.413 ms</span>

<span>db=#</span> <span>ALTER</span> <span>TABLE</span> <span>sale</span> <span>ADD</span> <span>CONSTRAINT</span> <span>sale_customer_fk</span>
<span>db-#</span> <span>FOREIGN</span> <span>KEY</span> <span>(</span><span>customer_id</span><span>)</span> <span>REFERENCES</span> <span>customer</span><span>(</span><span>id</span><span>);</span>
<span>ALTER TABLE</span>
<span>Time: 5.464 ms</span>

<span>db=#</span> <span>CREATE</span> <span>INDEX</span> <span>sale_created_ix</span> <span>ON</span> <span>sale</span><span>(</span><span>created</span><span>);</span>
<span>CREATE INDEX</span>
<span>Time: 12.605 ms</span>

<span>db=#</span> <span>INSERT</span> <span>INTO</span> <span>SALE</span> <span>(</span><span>created</span><span>,</span> <span>product_id</span><span>,</span> <span>customer_id</span><span>)</span>
<span>db-#</span> <span>SELECT</span>
<span>db-#</span>    <span>now</span><span>()</span> <span>-</span> <span>interval</span> <span>'1 hour'</span> <span>*</span> <span>random</span><span>()</span> <span>*</span> <span>1000</span><span>,</span>
<span>db-#</span>    <span>(</span><span>random</span><span>()</span> <span>*</span> <span>10000</span><span>)</span><span>::</span><span>int</span> <span>+</span> <span>1</span><span>,</span>
<span>db-#</span>    <span>(</span><span>random</span><span>()</span> <span>*</span> <span>100000</span><span>)</span><span>::</span><span>int</span> <span>+</span> <span>1</span>
<span>db-#</span> <span>FROM</span> <span>generate_series</span><span>(</span><span>1</span><span>,</span> <span>1000000</span><span>);</span>
<span>INSERT 0 1000000</span>
<span>Time: 15410.234 ms (00:15.410)</span>
</pre></div>


<p>After defining constraints and indexes, loading a million rows to the table took ~15.4s.</p>
<p>Next, try to load the data into the table first, and only then add constraints and indexes:</p>
<div><pre><span></span><span>db=#</span> <span>INSERT</span> <span>INTO</span> <span>SALE</span> <span>(</span><span>created</span><span>,</span> <span>product_id</span><span>,</span> <span>customer_id</span><span>)</span>
<span>db-#</span> <span>SELECT</span>
<span>db-#</span>    <span>now</span><span>()</span> <span>-</span> <span>interval</span> <span>'1 hour'</span> <span>*</span> <span>random</span><span>()</span> <span>*</span> <span>1000</span><span>,</span>
<span>db-#</span>    <span>(</span><span>random</span><span>()</span> <span>*</span> <span>10000</span><span>)</span><span>::</span><span>int</span> <span>+</span> <span>1</span><span>,</span>
<span>db-#</span>    <span>(</span><span>random</span><span>()</span> <span>*</span> <span>100000</span><span>)</span><span>::</span><span>int</span> <span>+</span> <span>1</span>
<span>db-#</span> <span>FROM</span> <span>generate_series</span><span>(</span><span>1</span><span>,</span> <span>1000000</span><span>);</span>
<span>INSERT 0 1000000</span>
<span>Time: 2277.824 ms (00:02.278)</span>

<span>db=#</span> <span>ALTER</span> <span>TABLE</span> <span>sale</span> <span>ADD</span> <span>CONSTRAINT</span> <span>sale_product_fk</span>
<span>db-#</span> <span>FOREIGN</span> <span>KEY</span> <span>(</span><span>product_id</span><span>)</span> <span>REFERENCES</span> <span>product</span><span>(</span><span>id</span><span>);</span>
<span>ALTER TABLE</span>
<span>Time: 169.193 ms</span>

<span>db=#</span> <span>ALTER</span> <span>TABLE</span> <span>sale</span> <span>ADD</span> <span>CONSTRAINT</span> <span>sale_customer_fk</span>
<span>db-#</span> <span>FOREIGN</span> <span>KEY</span> <span>(</span><span>customer_id</span><span>)</span> <span>REFERENCES</span> <span>customer</span><span>(</span><span>id</span><span>);</span>
<span>ALTER TABLE</span>
<span>Time: 185.633 ms</span>

<span>db=#</span> <span>CREATE</span> <span>INDEX</span> <span>sale_created_ix</span> <span>ON</span> <span>sale</span><span>(</span><span>created</span><span>);</span>
<span>CREATE INDEX</span>
<span>Time: 484.244 ms</span>
</pre></div>


<p>Loading data into a table without indexes and constraints was much faster, 2.27s compared to 15.4s before. Creating the indexes and constraints after the data was loaded into the table took a bit longer, but overall the entire process was much faster, 3.1s compared to 15.4s.</p>
<p>Unfortunately, for indexes PostgreSQL does not provide an easy way of doing this other than dropping and re-creating the indexes. In other databases such as Oracle, you can <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/ALTER-INDEX.html#GUID-D8F648E7-8C07-4C89-BB71-862512536558" rel="noopener">disable and enable indexes</a> without having to re-create them.</p>
<hr>

<p>When you modify data in PostgreSQL, the changes are written to the <a href="https://www.postgresql.org/docs/current/wal-intro.html" rel="noopener">write ahead log (WAL)</a>. The WAL is used to maintain integrity, to fast forward the database during recovery and to maintain replication.</p>
<p>Writing to the WAL is often needed, but there are some circumstances where you might be willing to give up some of its uses to make things a bit faster. One example is intermediate tables.</p>
<p>Intermediate tables are disposable tables that stores temporary data used to implement some process. For example, a very common pattern in ETL processes is to load data from a CSV file to an intermediate table, clean the data, and then load it to the target table. In this use-case, the intermediate table is disposable and there is no use for it in backups or replicas.</p>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 321.1 91.4" width="25em"><path d="M100 53l128-1" stroke="currentColor" stroke-width="1.5" fill="none" stroke-dasharray="12 8"></path><path d="M200 61c8 0 18-6 27-10M200 41c7 6 18 7 27 10" stroke="currentColor" stroke-width="1.5" fill="none"></path><path d="M13 24h69l-4 59-65-6" fill="#f41d92"></path><path d="M11 25c20-1 35 1 69-3m-68 3c26 0 46 2 70-1m-2 4c4 19 3 44 0 50m1-53c-2 19-3 39-1 57m0 2c-13-4-32-2-70 0m69-5c-14 1-29 4-67 3m0-2c-2-10 2-23 4-55m-4 58l3-57" stroke="currentColor" fill="none"></path><path d="M236 25l68 1-5 47-58 6" fill="#e08fff"></path><path d="M239 30c24-6 40-6 59-7m-59 5l61-2m6-2c-5 11 0 26-6 48m2-44c-1 17 1 37 1 48m-3 2c-13-3-39 0-62-6m65 4l-67-1m4-2c0-15-4-26 0-48m-1 50V27" stroke="currentColor" fill="none"></path><g><g stroke-opacity=".7" fill-opacity=".7" fill-rule="evenodd"><path d="M13 24l14-9 13-6 22 6 25 5-71 10" fill="#f41d92"></path><path d="M15 27c5-3 13-16 25-17 11-1 48 9 44 11-3 3-55 3-67 4m-5 0c5-3 15-12 27-12s49 9 44 11-62 1-73 2" stroke="currentColor" fill="none"></path></g></g><g><g stroke-opacity=".8" fill-opacity=".8" fill-rule="evenodd"><path d="M236 24l13-12 9 6 29-2 23 7-76 7" fill="#e08fff"></path><path d="M240 29c3-3 7-15 18-15 11-1 51 9 47 11-3 2-56 3-67 3m-1-1c5-2 13-9 26-10 12-1 52 3 48 4l-72 2" stroke="currentColor" fill="none"></path></g></g><g><path d="M134 30l32 43m-35-38l33 35" stroke="#d30101" stroke-width="4" fill="none"></path></g><g><path d="M131 67l31-32m-27 37c6-6 28-34 32-41" stroke="#d30101" stroke-width="4" fill="none"></path></g></svg>
<figcaption>UNLOGGED table</figcaption>
</figure>

<p>Intermediate tables that don't need to be restored in case of disaster, and are not needed in replicas, can be set as <a href="https://www.postgresql.org/docs/current/sql-createtable.html#SQL-CREATETABLE-UNLOGGED" rel="noopener">UNLOGGED</a>:</p>
<div><pre><span></span><span>CREATE</span> <span>UNLOGGED</span> <span>TABLE</span> <span>staging_table</span> <span>(</span> <span>/* table definition */</span> <span>);</span>
</pre></div>


<p><strong>BEWARE</strong>: Before using <code>UNLOGGED</code> make sure you understand its full implications.</p>
<hr>
<h2 id="implement-complete-processes-using-with-and-returning"><a href="#implement-complete-processes-using-with-and-returning">Implement Complete Processes Using <code>WITH</code> and <code>RETURNING</code></a></h2>
<p>Say you have a users table, and you find that you have some duplicates in the table:</p>
<details>
<summary>Table setup</summary>
<div><pre><span></span><span>CREATE</span> <span>TABLE</span> <span>users</span> <span>(</span>
    <span>id</span> <span>SERIAL</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    <span>email</span> <span>TEXT</span> <span>UNIQUE</span>
<span>);</span>

<span>CREATE</span> <span>TABLE</span> <span>orders</span> <span>(</span>
    <span>id</span> <span>SERIAL</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    <span>user_id</span> <span>INT</span><span>,</span>
    <span>CONSTRAINT</span> <span>orders_user_fk</span>
        <span>FOREIGN</span> <span>KEY</span> <span>(</span><span>user_id</span><span>)</span>
        <span>REFERENCES</span> <span>USERS</span><span>(</span><span>id</span><span>)</span>
<span>);</span>

<span>INSERT</span> <span>INTO</span> <span>users</span> <span>(</span><span>email</span><span>)</span> <span>VALUES</span>
    <span>(</span><span>'foo@bar.baz'</span><span>),</span>
    <span>(</span><span>'me@hakibenita.com'</span><span>),</span>
    <span>(</span><span>'ME@hakibenita.com'</span><span>);</span>

<span>INSERT</span> <span>INTO</span> <span>orders</span> <span>(</span><span>user_id</span><span>)</span> <span>VALUES</span>
    <span>(</span><span>1</span><span>),</span>
    <span>(</span><span>1</span><span>),</span>
    <span>(</span><span>2</span><span>),</span>
    <span>(</span><span>3</span><span>),</span>
    <span>(</span><span>3</span><span>);</span>
</pre></div>


</details>
<div><pre><span></span><span>db</span><span>=#</span> <span>SELECT</span> <span>u</span><span>.</span><span>id</span><span>,</span> <span>u</span><span>.</span><span>email</span><span>,</span> <span>o</span><span>.</span><span>id</span> <span>as</span> <span>order_id</span>
<span>FROM</span> <span>orders</span> <span>o</span> <span>JOIN</span> <span>users</span> <span>u</span> <span>ON</span> <span>o</span><span>.</span><span>user_id</span> <span>=</span> <span>u</span><span>.</span><span>id</span><span>;</span>

 <span>id</span> <span>|</span>       <span>email</span>       <span>|</span> <span>order_id</span>
<span>----+-------------------+----------</span>
  <span>1</span> <span>|</span> <span>foo</span><span>@</span><span>bar</span><span>.</span><span>baz</span>       <span>|</span>        <span>1</span>
  <span>1</span> <span>|</span> <span>foo</span><span>@</span><span>bar</span><span>.</span><span>baz</span>       <span>|</span>        <span>2</span>
<span>  <span>2</span> <span>|</span> <span>me</span><span>@</span><span>hakibenita</span><span>.</span><span>com</span> <span>|</span>        <span>3</span>
</span><span>  <span>3</span> <span>|</span> <span>ME</span><span>@</span><span>hakibenita</span><span>.</span><span>com</span> <span>|</span>        <span>4</span>
</span><span>  <span>3</span> <span>|</span> <span>ME</span><span>@</span><span>hakibenita</span><span>.</span><span>com</span> <span>|</span>        <span>5</span>
</span></pre></div>


<p>The user <em>haki benita</em> registered twice, once with the email <code>ME@hakibenita.com</code> and again with <code>me@hakibenita.com</code>. Because we didn't normalize the emails when we inserted them into the table, we now have to deal with duplication.</p>
<p>To consolidate the duplicate users, we want to:</p>
<ol>
<li>Identify duplicate users by lower case email</li>
<li>Update orders to reference one of the duplicate users</li>
<li>Remove the duplicate users from the users table</li>
</ol>
<p>One way to consolidate duplicate users is to use an intermediate table:</p>
<div><pre><span></span><span>db=#</span> <span>CREATE</span> <span>UNLOGGED</span> <span>TABLE</span> <span>duplicate_users</span> <span>AS</span>
<span>db-#</span>     <span>SELECT</span>
<span>db-#</span>         <span>lower</span><span>(</span><span>email</span><span>)</span> <span>AS</span> <span>normalized_email</span><span>,</span>
<span>db-#</span>         <span>min</span><span>(</span><span>id</span><span>)</span> <span>AS</span> <span>convert_to_user</span><span>,</span>
<span>db-#</span>         <span>array_remove</span><span>(</span><span>ARRAY_AGG</span><span>(</span><span>id</span><span>),</span> <span>min</span><span>(</span><span>id</span><span>))</span> <span>as</span> <span>convert_from_users</span>
<span>db-#</span>     <span>FROM</span>
<span>db-#</span>         <span>users</span>
<span>db-#</span>     <span>GROUP</span> <span>BY</span>
<span>db-#</span>         <span>normalized_email</span>
<span>db-#</span>     <span>HAVING</span>
<span>db-#</span>         <span>count</span><span>(</span><span>*</span><span>)</span> <span>&gt;</span> <span>1</span><span>;</span>
<span>CREATE TABLE</span>

<span>db=#</span> <span>SELECT</span> <span>*</span> <span>FROM</span> <span>duplicate_users</span><span>;</span>
<span> normalized_email  | convert_to_user | convert_from_users</span>
<span>-------------------+-----------------+--------------------</span>
<span> me@hakibenita.com |               2 | {3}</span>
</pre></div>


<p>The intermediate table holds a mapping of duplicate users. For each user that appears more than once with the same normalized email address, we define the user with the min ID as the user we convert all duplicates to. The other users are kept in an array column, and all the references to these users will be updated.</p>
<p>Using the intermediate table, we update references of duplicate users in the <code>orders</code> table:</p>
<div><pre><span></span><span>db=#</span> <span>UPDATE</span>
<span>db-#</span>    <span>orders</span> <span>o</span>
<span>db-#</span> <span>SET</span>
<span>db-#</span>    <span>user_id</span> <span>=</span> <span>du</span><span>.</span><span>convert_to_user</span>
<span>db-#</span> <span>FROM</span>
<span>db-#</span>    <span>duplicate_users</span> <span>du</span>
<span>db-#</span> <span>WHERE</span>
<span>db-#</span>    <span>o</span><span>.</span><span>user_id</span> <span>=</span> <span>ANY</span><span>(</span><span>du</span><span>.</span><span>convert_from_users</span><span>);</span>
<span>UPDATE 2</span>
</pre></div>


<p>Now that there are no more references, we can safely delete the duplicate users from the <code>users</code> table:</p>
<div><pre><span></span><span>db=#</span> <span>DELETE</span> <span>FROM</span>
<span>db-#</span>    <span>users</span>
<span>db-#</span> <span>WHERE</span>
<span>db-#</span>    <span>id</span> <span>IN</span> <span>(</span>
<span>db(#</span>        <span>SELECT</span> <span>unnest</span><span>(</span><span>convert_from_users</span><span>)</span>
<span>db(#</span>        <span>FROM</span> <span>duplicate_users</span>
<span>db(#</span>    <span>);</span>
<span>DELETE 1</span>
</pre></div>


<p>Notice that we used the function <a href="https://www.postgresql.org/docs/current/functions-array.html#ARRAY-FUNCTIONS-TABLE" rel="noopener"><code>unnest</code></a> to "transpose" the array, that is, turn each array element into a row.</p>
<p>This is the result:</p>
<div><pre><span></span><span>db=#</span> <span>SELECT</span> <span>u</span><span>.</span><span>id</span><span>,</span> <span>u</span><span>.</span><span>email</span><span>,</span> <span>o</span><span>.</span><span>id</span> <span>as</span> <span>order_id</span>
<span>db-#</span> <span>FROM</span> <span>orders</span> <span>o</span> <span>JOIN</span> <span>users</span> <span>u</span> <span>ON</span> <span>o</span><span>.</span><span>user_id</span> <span>=</span> <span>u</span><span>.</span><span>id</span><span>;</span>
<span> id |       email       | order_id</span>
<span>----+-------------------+----------</span>
<span>  1 | foo@bar.baz       |        1</span>
<span>  1 | foo@bar.baz       |        2</span>
<span><span>  2 | me@hakibenita.com |        3</span>
</span><span><span>  2 | me@hakibenita.com |        4</span>
</span><span><span>  2 | me@hakibenita.com |        5</span>
</span></pre></div>


<p>Nice, all occurrences of user 3 (ME@hakibenita.com) are converted to user 2 (me@hakibenita.com).</p>
<p>We can also verify that the duplicate users were deleted from the <code>users</code> table:</p>
<div><pre><span></span><span>db=#</span> <span>SELECT</span> <span>*</span> <span>FROM</span> <span>users</span><span>;</span>
<span> id |       email</span>
<span>----+-------------------</span>
<span>  1 | foo@bar.baz</span>
<span>  2 | me@hakibenita.com</span>
</pre></div>


<p>Now we can get rid of the intermediate table:</p>
<div><pre><span></span><span>db=#</span> <span>DROP</span> <span>TABLE</span> <span>duplicate_users</span><span>;</span>
<span>DROP TABLE</span>
</pre></div>


<p>This is fine, but very long and needs cleaning up! Is there a better way?</p>
<p><strong>Using Common Table Expressions (CTE)</strong></p>
<p>Using <a href="https://www.postgresql.org/docs/current/queries-with.html" rel="noopener">Common Table Expressions</a>, also known as the <code>WITH</code> clause, we can perform the entire process with just one SQL statement:</p>
<div><pre><span></span><span>WITH</span> <span>duplicate_users</span> <span>AS</span> <span>(</span>
    <span>SELECT</span>
        <span>min</span><span>(</span><span>id</span><span>)</span> <span>AS</span> <span>convert_to_user</span><span>,</span>
        <span>array_remove</span><span>(</span><span>ARRAY_AGG</span><span>(</span><span>id</span><span>),</span> <span>min</span><span>(</span><span>id</span><span>))</span> <span>as</span> <span>convert_from_users</span>
    <span>FROM</span>
        <span>users</span>
    <span>GROUP</span> <span>BY</span>
        <span>lower</span><span>(</span><span>email</span><span>)</span>
    <span>HAVING</span>
        <span>count</span><span>(</span><span>*</span><span>)</span> <span>&gt;</span> <span>1</span>
<span>),</span>

<span>update_orders_of_duplicate_users</span> <span>AS</span> <span>(</span>
    <span>UPDATE</span>
        <span>orders</span> <span>o</span>
    <span>SET</span>
        <span>user_id</span> <span>=</span> <span>du</span><span>.</span><span>convert_to_user</span>
    <span>FROM</span>
        <span>duplicate_users</span> <span>du</span>
    <span>WHERE</span>
        <span>o</span><span>.</span><span>user_id</span> <span>=</span> <span>ANY</span><span>(</span><span>du</span><span>.</span><span>convert_from_users</span><span>)</span>
<span>)</span>

<span>DELETE</span> <span>FROM</span>
    <span>users</span>
<span>WHERE</span>
    <span>id</span> <span>IN</span> <span>(</span>
        <span>SELECT</span>
            <span>unnest</span><span>(</span><span>convert_from_users</span><span>)</span>
        <span>FROM</span>
            <span>duplicate_users</span>
    <span>);</span>
</pre></div>


<p>Instead of creating the intermediate table, we create a common table expression and reuse it multiple times.</p>
<p><strong>Returning Results From CTE</strong></p>
<p>A nice feature of executing DML inside a <code>WITH</code> clause, is that you can return data from it using the <a href="https://www.postgresql.org/docs/current/dml-returning.html" rel="noopener"><code>RETURNING</code> keyword</a>. For example, let's report the number of updated and deleted rows:</p>
<div><pre><span></span><span>WITH</span> <span>duplicate_users</span> <span>AS</span> <span>(</span>
    <span>SELECT</span>
        <span>min</span><span>(</span><span>id</span><span>)</span> <span>AS</span> <span>convert_to_user</span><span>,</span>
        <span>array_remove</span><span>(</span><span>ARRAY_AGG</span><span>(</span><span>id</span><span>),</span> <span>min</span><span>(</span><span>id</span><span>))</span> <span>as</span> <span>convert_from_users</span>
    <span>FROM</span>
        <span>users</span>
    <span>GROUP</span> <span>BY</span>
        <span>lower</span><span>(</span><span>email</span><span>)</span>
    <span>HAVING</span>
        <span>count</span><span>(</span><span>*</span><span>)</span> <span>&gt;</span> <span>1</span>
<span>),</span>

<span>update_orders_of_duplicate_users</span> <span>AS</span> <span>(</span>
    <span>UPDATE</span>
        <span>orders</span> <span>o</span>
    <span>SET</span>
        <span>user_id</span> <span>=</span> <span>du</span><span>.</span><span>convert_to_user</span>
    <span>FROM</span>
        <span>duplicate_users</span> <span>du</span>
    <span>WHERE</span>
        <span>o</span><span>.</span><span>user_id</span> <span>=</span> <span>ANY</span><span>(</span><span>du</span><span>.</span><span>convert_from_users</span><span>)</span>
<span>    <span>RETURNING</span> <span>o</span><span>.</span><span>id</span>
</span><span>),</span>

<span>delete_duplicate_user</span> <span>AS</span> <span>(</span>
    <span>DELETE</span> <span>FROM</span>
        <span>users</span>
    <span>WHERE</span>
        <span>id</span> <span>IN</span> <span>(</span>
            <span>SELECT</span> <span>unnest</span><span>(</span><span>convert_from_users</span><span>)</span>
            <span>FROM</span> <span>duplicate_users</span>
        <span>)</span>
<span>        <span>RETURNING</span> <span>id</span>
</span><span>)</span>

<span>SELECT</span>
<span>    <span>(</span><span>SELECT</span> <span>count</span><span>(</span><span>*</span><span>)</span> <span>FROM</span> <span>update_orders_of_duplicate_users</span><span>)</span> <span>AS</span> <span>orders_updated</span><span>,</span>
</span><span>    <span>(</span><span>SELECT</span> <span>count</span><span>(</span><span>*</span><span>)</span> <span>FROM</span> <span>delete_duplicate_user</span><span>)</span> <span>AS</span> <span>users_deleted</span>
</span><span>;</span>
</pre></div>


<p>This is the result:</p>
<div><pre><span></span> <span>orders_updated</span> <span>|</span> <span>users_deleted</span>
<span>----------------+---------------</span>
              <span>2</span> <span>|</span>             <span>1</span>
</pre></div>


<p>The main appeal of this approach is that the entire process is executed in a single command, so no need to manage a transaction or worry about cleaning up the intermediate table if the process fails.</p>
<p><strong>CAUTION</strong>: <a href="https://www.reddit.com/r/programming/comments/hyv0xh/some_sql_tricks_of_an_application_dba/fzhqzw5?utm_source=share&amp;utm_medium=web2x" rel="noopener">A reader on Reddit</a> pointed me to a possibly <a href="https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-MODIFYING" rel="noopener">unpredictable behavior of executing DML in common table expressions</a>:</p>
<blockquote>
<p>The sub-statements in WITH are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in WITH, the order in which the specified updates actually happen is unpredictable</p>
</blockquote>
<p>This means you cannot rely on the order in which independent sub-statements are executed. It seems that when there is a dependency between sub-statements, like in the example above, you can rely on a dependent sub-statement to execute before it is being used.</p>
<hr>
<h2 id="avoid-indexes-on-columns-with-low-selectivity"><a href="#avoid-indexes-on-columns-with-low-selectivity">Avoid Indexes on Columns With Low Selectivity</a></h2>
<p>Say you have a registration process where users sign up with an email address. To activate the account, they have to verify their email. Your table can look like this:</p>
<div><pre><span></span><span>db=#</span> <span>CREATE</span> <span>TABLE</span> <span>users</span> <span>(</span>
<span>db-#</span>    <span>id</span> <span>serial</span><span>,</span>
<span>db-#</span>    <span>username</span> <span>text</span><span>,</span>
<span>db-#</span>    <span>activated</span> <span>boolean</span>
<span>db-#</span><span>);</span>
<span>CREATE TABLE</span>
</pre></div>


<p>Most of your users are good citizens, they sign up with a valid email and immediately activate the account. Let's populate the table with user data, where roughly 90% of the users are activated:</p>
<div><pre><span></span><span>db=#</span> <span>INSERT</span> <span>INTO</span> <span>users</span> <span>(</span><span>username</span><span>,</span> <span>activated</span><span>)</span>
<span>db-#</span> <span>SELECT</span>
<span>db-#</span>     <span>md5</span><span>(</span><span>random</span><span>()</span><span>::</span><span>text</span><span>)</span> <span>AS</span> <span>username</span><span>,</span>
<span>db-#</span>     <span>random</span><span>()</span> <span>&lt;</span> <span>0.9</span> <span>AS</span> <span>activated</span>
<span>db-#</span> <span>FROM</span>
<span>db-#</span>     <span>generate_series</span><span>(</span><span>1</span><span>,</span> <span>1000000</span><span>);</span>
<span>INSERT 0 1000000</span>

<span>db=#</span> <span>SELECT</span> <span>activated</span><span>,</span> <span>count</span><span>(</span><span>*</span><span>)</span> <span>FROM</span> <span>users</span> <span>GROUP</span> <span>BY</span> <span>activated</span><span>;</span>
<span> activated | count</span>
<span>-----------+--------</span>
<span> f         | 102567</span>
<span> t         | 897433</span>

<span>db=#</span> <span>VACUUM</span> <span>ANALYZE</span> <span>users</span><span>;</span>
<span>VACUUM</span>
</pre></div>


<p>To query for activated and unactivated users, you might be tempted to create an index on the column <code>activated</code>:</p>
<div><pre><span></span><span>db=#</span> <span>CREATE</span> <span>INDEX</span> <span>users_activated_ix</span> <span>ON</span> <span>users</span><span>(</span><span>activated</span><span>);</span>
<span>CREATE INDEX</span>
</pre></div>


<p>When you try to query <em>unactivated users</em>, the database is using the index:</p>
<div><pre><span></span><span>db=#</span> <span>EXPLAIN</span> <span>SELECT</span> <span>*</span> <span>FROM</span> <span>users</span> <span>WHERE</span> <span>NOT</span> <span>activated</span><span>;</span>
<span>                                      QUERY PLAN</span>
<span>--------------------------------------------------------------------------------------</span>
<span> Bitmap Heap Scan on users  (cost=1923.32..11282.99 rows=102567 width=38)</span>
<span>   Filter: (NOT activated)</span>
<span><span>   -&gt;  Bitmap Index Scan on users_activated_ix  (cost=0.00..1897.68 rows=102567 width=0)</span>
</span><span>         Index Cond: (activated = false)</span>
</pre></div>


<p>The database estimated that the filter will result in 102,567 which are roughly 10% of the table. This is consistent with the data we populated, so the database has a good sense of the data.</p>
<p>However, when you try to query for <em>activated users</em> you find that the database decided <em>not to use the index</em>:</p>
<div><pre><span></span><span>db=#</span> <span>EXPLAIN</span> <span>SELECT</span> <span>*</span> <span>FROM</span> <span>users</span> <span>WHERE</span> <span>activated</span><span>;</span>
<span>                          QUERY PLAN</span>
<span>---------------------------------------------------------------</span>
<span> Seq Scan on users  (cost=0.00..18334.00 rows=897433 width=38)</span>
<span>   Filter: activated</span>
</pre></div>


<p>Many developers are often baffled when they the database is not using an index. One way of explaining why an index is not always the best choice is this: <strong>if you had to read the entire table, would you use the index?</strong></p>
<p>The answer is probably no, because why would you? Reading from disk is expensive and you want to read as little as possible. If for example, a table is 10MB and the index is 1MB, to read the entire table you would have to read 10MB from disk. To read the table using the index you would have to read 11MB from disk. This is wasteful.</p>
<p>With this understanding, let's have a look at the statistics PostgreSQL gather on the table:</p>
<div><pre><span></span><span>db=#</span> <span>SELECT</span> <span>attname</span><span>,</span> <span>n_distinct</span><span>,</span> <span>most_common_vals</span><span>,</span> <span>most_common_freqs</span>
<span>db-#</span> <span>FROM</span> <span>pg_stats</span>
<span>db-#</span> <span>WHERE</span> <span>tablename</span> <span>=</span> <span>'users'</span> <span>AND</span> <span>attname</span><span>=</span><span>'activated'</span><span>;</span>
<span>------------------+------------------------</span>
<span>attname           | activated</span>
<span>n_distinct        | 2</span>
<span>most_common_vals  | {t,f}</span>
<span>most_common_freqs | {0.89743334,0.10256667}</span>
</pre></div>


<p>When PostgreSQL analyzed the table it found that the column <code>activated</code> has two distinct values. The value <code>t</code> in the <code>most_common_vals</code> column corresponds to the frequency <code>0.89743334</code> in the column <code>most_common_freqs</code>, and the value <code>f</code> corresponds to the frequency <code>0.10256667</code>. This means that after analyzing the table, the database estimates that 89.74% of the table are activated users, and the rest 10.26% are unactivated users.</p>
<p>With these stats, PostgreSQL decided it's best to scan the entire table if it expects 90% of the rows to satisfy the condition. The threshold after which the database may decide to use or not to use the index depends on many factors, and there is no rule of thumb you can use.</p>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 457.6 174.8" width="40em"><path d="M108 56l27 28m-28-26c4 5 22 20 27 24M156 105c4 5 24 21 29 26m-27-27l26 28M49 107l-19 24m18-25l-16 24M144 105l-18 24m17-22l-17 23M66 105l15 23m-13-23l15 24M97 61L70 78m26-15L73 76" stroke="currentColor" fill="none"></path><path d="M10 133l30 1v25H10" fill="#f41d92"></path><path d="M8 133c10-1 13 2 34-1m-31 1l30 1m-2 0c2 7 3 11 4 27m-1-27l-1 25m1 2c-13-3-26-3-34-2m32 0l-30 1m-2 0l4-27m-2 26c0-8-1-16 1-25" stroke="currentColor" fill="none"></path><path d="M69 132h29l1 26H68" fill="#f41d92"></path><path d="M69 133c11-2 22 0 31 1m-31-2h30m0 0c0 6 2 18 0 25m-1-26l2 26m-3-2c-11 1-22 2-28 4m30-1c-10-2-18 0-30 0m0-2c-1-8 0-19-3-25m2 25l-1-25" stroke="currentColor" fill="none"></path><path d="M112 131l30-1 3 28h-32" fill="#f41d92"></path><path d="M114 131c12-1 23 1 31 1m-33 0h31m1 1v25m-1-26c1 6 2 11 0 25m0 1c-5 0-13 1-32-3m33 3c-11-2-22-1-31 0m1 0c-2-9-2-14-1-28m0 27l-1-26" stroke="currentColor" fill="none"></path><path d="M168 134l30-1 1 26-33 1" fill="#f41d92"></path><path d="M168 131c7 2 19 2 30 3m-32-1l33 1m-3 0c0 8 3 19 1 23m1-24l-1 25m-1 1h-31m32-1c-7-1-15 1-30 1m-2-3c3-5 2-17 1-22m1 25v-25" stroke="currentColor" fill="none"></path><path d="M43 79l32-2 1 28-33-2" fill="#f41d92"></path><path d="M44 80c7-3 13-1 32-3m-32 0h32m-1 1c-1 7-2 15 2 27m-2-28v26m-1 2l-28-1m30-1H43m3-1l-3-26m1 26l1-23" stroke="currentColor" fill="none"></path><path d="M129 79l34 2v25l-32-1" fill="#f41d92"></path><path d="M132 80c4-2 12-1 31-2m-32 2h32m-1 1c-2 5 1 15 1 25m-1-26v25m0-1c-5 2-14 1-32-1m32 2h-31m0 0V80m-1 25l1-26" stroke="currentColor" fill="none"></path><path d="M85 36l29-1-1 25-29 1" fill="#f41d92"></path><path d="M85 35c10-2 20-2 29-1m-31 0h32m-1 1c1 5 3 12 2 26m-2-26l1 25m0-1c-10-1-19 1-31 2m31-1H84m-2 1c4-9 2-18 1-27m1 26V34M354 62l29 27m-27-27l27 26M404 111l28 27m-29-27l29 25M297 112l-18 24m17-24l-18 22M392 112l-20 23m19-24l-19 25M316 109l13 26m-14-26l13 24M344 67l-25 15m23-16l-24 17" stroke="currentColor" fill="none"></path><path d="M256 134l30-1v27h-32" fill="#f41d92"></path><path d="M257 133c11-1 21-1 32 2m-33-2l31 1m1-2c0 12-1 22-3 27m2-25v24m1 1c-8 0-16 2-32 0m30 0c-9 0-20-1-29 1m-2 0c0-10 3-19 2-27m0 27l-1-26" stroke="currentColor" fill="none"></path><path d="M315 134h33l-1 25-31 3" fill="#fc54ee"></path><path d="M314 136l34-2m-31 1l29 1m1 1v22m-1-24c2 5 2 11 1 25m2 0h-32m31 0l-33 1m3 1c-2-8-2-13-2-26m-1 25c0-10 0-20 2-27" stroke="currentColor" fill="none"></path><path d="M334 41l29-3 2 26-33 2" fill="#fc54ee"></path><path d="M334 40l30-3m-32 2h32m0 1l-1 27m1-28v25m0 1c-10-1-17 0-31-2m31 2l-32-1m2 0c-2-6 0-9-1-24m1 24c-2-8 0-19-1-26" stroke="currentColor" fill="none"></path><g><path d="M359 134l28 2 1 23-29 1" fill="#e08fff"></path><path d="M359 134l28 1m-30-1h32m0-1c-1 10-1 18 2 27m-3-26v26m1-1c-8 2-14 0-33 2m33 0c-11-2-21-2-32-2m0 0c0-7 2-15 1-23m-1 23v-24" stroke="currentColor" fill="none"></path></g><g><path d="M380 85h34l-2 27-31-1" fill="#f071ff"></path><path d="M381 85c8 0 16-1 32 2m-32-1h31m0 0c0 7-1 18 1 27m-1-28v26m0 0c-6 1-16-1-29 1m30-1h-32m0 0l2-25m-2 26l1-25" stroke="currentColor" fill="none"></path></g><g><path d="M289 86l32-2 2 26-33-1" fill="#f938c5"></path><path d="M290 84l32 2m-31-2l31 1m-1-1c0 7 3 16 2 27m-2-27v25m0 2c-9-2-20 0-30-1m30-1l-30 1m-1 0c2-8 1-16 1-24m0 24V84" stroke="currentColor" fill="none"></path></g><g><path d="M418 138l29 3 1 23-32 1" fill="#daaeff"></path><path d="M416 138c11 0 23 2 33 1m-33 1h32m-1-1c-1 11 1 18 2 26m-2-25v25m2 0c-12-2-21 0-32-1m30 1h-30m0 1l1-25m-1 23l-1-25" stroke="currentColor" fill="none"></path></g><g><path d="M180 11c5 0 12 4 16 8 3 4 6 10 5 15 0 5-2 10-6 14-3 4-9 7-14 8s-11 1-16-2c-4-2-9-8-11-12-2-5-1-11 1-16 2-4 6-11 10-13 5-3 13-2 16-2s0 1 0 1m-9-2c5-1 13 2 18 5 4 2 8 7 9 11 2 5 1 13-1 17-2 5-5 10-10 12s-12 4-17 3c-6-1-11-6-14-10s-4-10-3-15c0-5 1-11 4-15 4-4 12-8 15-9 2-1 0 2 0 3" fill="#D30101"></path><path d="M169 12c4-2 12-2 17 0s8 6 11 11c2 4 4 9 4 14-1 5-5 12-9 15-3 4-9 6-15 6-5 0-11-2-15-6-5-3-8-10-9-15s-1-11 2-15 12-9 15-11c4-2 5-1 5-1m9 2c5 1 10 3 12 7 3 4 5 12 4 17 0 5-4 10-7 13-4 3-10 7-15 7-4 1-10 0-14-3s-9-10-11-15c-1-4 0-9 2-13 2-5 7-11 12-14 4-2 13-1 15-1 3 0 2 2 1 3" stroke="currentColor" fill="none"></path></g><g><path d="M167 21l20 25m-22-26l21 28" stroke="#fff" fill="none"></path></g><g><path d="M189 26l-21 19m20-20l-18 21" stroke="#fff" stroke-width="2" fill="none"></path></g><g><path d="M426 18c5 0 12 4 15 8 4 4 6 10 6 15-1 5-3 12-7 16-3 3-9 6-14 7-6 1-12 0-16-2-4-3-9-9-10-13-2-5-1-12 1-16 1-5 4-9 9-11s16-2 21-2l4 2m-1-2c4 2 7 7 9 12 2 4 3 12 1 17-1 5-5 10-9 12-4 3-11 5-17 5-5-1-10-4-14-8l-7-17c0-5 2-10 6-14 3-4 9-9 14-10s13 4 15 4l2 1" fill="#51950F"></path><path d="M431 20c5 1 9 7 11 11s5 9 4 14-5 11-9 15c-4 3-10 6-15 5-5 0-12-3-16-7-4-3-6-8-7-13s-1-12 2-16c3-5 9-9 14-11 6-1 15 2 18 2 4 1 3 3 3 3m-4-2c4 2 10 7 12 12 2 4 3 11 2 15-1 5-5 10-10 13-4 3-12 6-17 5s-10-5-13-9c-4-4-7-10-8-15 0-5 3-9 6-13s8-11 12-12c5-1 14 4 16 5 3 0 0-2 0-1" stroke="currentColor" fill="none"></path></g><g><path d="M439 32l-21 18m20-19l-20 17" stroke="#fff" stroke-width="2" fill="none"></path></g><g><path d="M408 42l12 9m-11-11l10 9" stroke="#fff" stroke-width="2" fill="none"></path></g></svg>
<figcaption>Index for a column with low selectivity vs. high selectivity</figcaption>
</figure>

<hr>
<h2 id="use-partial-indexes"><a href="#use-partial-indexes">Use Partial Indexes</a></h2>
<p>In the previous section we created an index on a boolean column where ~90% of the of the values were true (activated user). When we tried to query for active users, the database did not use the index. However, when we queried unactivated users the database did use the index.</p>
<p>This brings us to the next question.... if the database is not going to use the index to filter active users, why should we index them in the first place?</p>
<p>Before we answer this question let's look at how much the full index on the <code>activated</code> column weighs:</p>
<div><pre><span></span><span>db=#</span> <span>\di+</span> <span>users_activated_ix</span>

<span> Schema |      Name          | Type  | Owner | Table | Size</span>
<span>--------+--------------------+-------+-------+-------+------</span>
<span> public | users_activated_ix | index | haki  | users | 21 MB</span>
</pre></div>


<p>The index is 21MB. Just for reference, the <code>users</code> table is 65MB. This means the index weighs ~32% the size of the table. We also know that ~90% of the index is likely not going to be used.</p>
<p>In PostgreSQL, there is a way to create an index on only a part of the table, using whats called a <a href="https://www.postgresql.org/docs/current/indexes-partial.html" rel="noopener">partial index</a>:</p>
<div><pre><span></span><span>db=#</span> <span>CREATE</span> <span>INDEX</span> <span>users_unactivated_partial_ix</span> <span>ON</span> <span>users</span><span>(</span><span>id</span><span>)</span>
<span><span>db-#</span> <span>WHERE</span> <span>not</span> <span>activated</span><span>;</span>
</span><span>CREATE INDEX</span>
</pre></div>


<p>Using a <code>WHERE</code> clause, we restrict the rows indexed by the index. Let's first make sure it works:</p>
<div><pre><span></span><span>db=#</span> <span>EXPLAIN</span> <span>SELECT</span> <span>*</span> <span>FROM</span> <span>users</span> <span>WHERE</span> <span>not</span> <span>activated</span><span>;</span>
<span>                                           QUERY PLAN</span>
<span>------------------------------------------------------------------------------------------------</span>
<span> Index Scan using users_unactivated_partial_ix on users  (cost=0.29..3493.60 rows=102567 width=38)</span>
</pre></div>


<p>Amazing, the database was smart enough to understand that the predicate we used in the query can be satisfied by the partial index.</p>
<p>There is another benefit to using partial indexes:</p>
<div><pre><span></span><span>db=#</span> <span>\di+</span> <span>users_unactivated_partial_ix</span>
<span>                                 List of relations</span>
<span> Schema |           Name               | Type  | Owner | Table |  Size</span>
<span>--------+------------------------------+-------+-------+-------+---------</span>
<span> public | users_unactivated_partial_ix | index | haki  | users | 2216 kB</span>
</pre></div>


<p>The partial index weighs only 2.2MB. The full index on the column weighed 21MB. The partial index is exactly 10% the size of the full index, which matches the ratio of inactive users in the table.</p>
<hr>
<h2 id="always-load-sorted-data"><a href="#always-load-sorted-data">Always Load Sorted Data</a></h2>
<p>This is one of the things I comment most about in code reviews. It's not as intuitive as the other tips and it can have a huge impact on performance.</p>
<p>Say you have a large sales fact table:</p>
<div><pre><span></span><span>db=#</span> <span>CREATE</span> <span>TABLE</span> <span>sale_fact</span> <span>(</span><span>id</span> <span>serial</span><span>,</span> <span>username</span> <span>text</span><span>,</span> <span>sold_at</span> <span>date</span><span>);</span>
<span>CREATE TABLE</span>
</pre></div>


<p>Every night, during some ETL process, you load data into the table:</p>
<div><pre><span></span><span>db=#</span> <span>INSERT</span> <span>INTO</span> <span>sale_fact</span> <span>(</span><span>username</span><span>,</span> <span>sold_at</span><span>)</span>
<span>db-#</span> <span>SELECT</span>
<span>db-#</span>     <span>md5</span><span>(</span><span>random</span><span>()</span><span>::</span><span>text</span><span>)</span> <span>AS</span> <span>username</span><span>,</span>
<span>db-#</span>     <span>'2020-01-01'</span><span>::</span><span>date</span> <span>+</span> <span>(</span><span>interval</span> <span>'1 day'</span><span>)</span> <span>*</span> <span>round</span><span>(</span><span>random</span><span>()</span> <span>*</span> <span>365</span> <span>*</span> <span>2</span><span>)</span> <span>AS</span> <span>sold_at</span>
<span>db-#</span> <span>FROM</span>
<span>db-#</span>     <span>generate_series</span><span>(</span><span>1</span><span>,</span> <span>100000</span><span>);</span>
<span>INSERT 0 100000</span>

<span>db=#</span> <span>VACUUM</span> <span>ANALYZE</span> <span>sale_fact</span><span>;</span>
<span>VACUUM</span>
</pre></div>


<p>To fake a loading process we used random data. We inserted 100K rows with random username, and sale dates from 2020-01-01 to two years forward.</p>
<p>The table is used mostly to produce summary sales reports. Most reports filter by date to get the sales at a specific period. To speed up range scans you create an index on <code>sold_at</code>:</p>
<div><pre><span></span><span>db=#</span> <span>CREATE</span> <span>INDEX</span> <span>sale_fact_sold_at_ix</span> <span>ON</span> <span>sale_fact</span><span>(</span><span>sold_at</span><span>);</span>
<span>CREATE INDEX</span>
</pre></div>


<p>Let's look at the execution plan of a query to fetch all sales made in June 2020:</p>
<div><pre><span></span><span>db=#</span> <span>EXPLAIN</span> <span>(</span><span>ANALYZE</span><span>)</span>
<span>db-#</span> <span>SELECT</span> <span>*</span>
<span>db-#</span> <span>FROM</span> <span>sale_fact</span>
<span>db-#</span> <span>WHERE</span> <span>sold_at</span> <span>BETWEEN</span> <span>'2020-07-01'</span> <span>AND</span> <span>'2020-07-31'</span><span>;</span>

<span>                            QUERY PLAN</span>
<span>-----------------------------------------------------------------------------------------------</span>
<span> Bitmap Heap Scan on sale_fact  (cost=108.30..1107.69 rows=4293 width=41)</span>
<span>   Recheck Cond: ((sold_at &gt;= '2020-07-01'::date) AND (sold_at &lt;= '2020-07-31'::date))</span>
<span>   Heap Blocks: exact=927</span>
<span>   -&gt;  Bitmap Index Scan on sale_fact_sold_at_ix  (cost=0.00..107.22 rows=4293 width=0)</span>
<span>         Index Cond: ((sold_at &gt;= '2020-07-01'::date) AND (sold_at &lt;= '2020-07-31'::date))</span>
<span> Planning Time: 0.191 ms</span>
<span> Execution Time: 5.906 ms</span>
</pre></div>


<p>After executing the query several times to warm up the cache, the timing settled at ~6ms.</p>
<p><strong>Bitmap Scan</strong></p>
<p>Looking at the execution plan, we can see that the database used a bitmap scan. A bitmap scan works in two stages:</p>
<ul>
<li><code>Bitmap Index Scan</code>: Go through the entire index <code>sale_fact_sold_at_ix</code> and map all the table pages that contain relevant rows.</li>
<li><code>Bitmap Heap Scan</code>: Read the pages that contain relevant rows, and find the rows inside these pages that satisfy the condition.</li>
</ul>
<p>Pages can contain multiple rows. The first step uses the index to find <em>pages</em>. The second step check for <em>rows</em> inside these pages, hence the "Recheck Cond" operation in the execution plan.</p>
<p>At this point many DBAs and developers will call it a day and move on to the next query. BUT, there's a way to make this query better.</p>
<p><strong>Index Scan</strong></p>
<p>To make things better, we'll make a small change in how we load the data.</p>
<div><pre><span></span><span>db=#</span> <span>TRUNCATE</span> <span>sale_fact</span><span>;</span>
<span>TRUNCATE TABLE</span>

<span>db=#</span> <span>INSERT</span> <span>INTO</span> <span>sale_fact</span> <span>(</span><span>username</span><span>,</span> <span>sold_at</span><span>)</span>
<span>db-#</span> <span>SELECT</span>
<span>db-#</span>     <span>md5</span><span>(</span><span>random</span><span>()</span><span>::</span><span>text</span><span>)</span> <span>AS</span> <span>username</span><span>,</span>
<span>db-#</span>     <span>'2020-01-01'</span><span>::</span><span>date</span> <span>+</span> <span>(</span><span>interval</span> <span>'1 day'</span><span>)</span> <span>*</span> <span>round</span><span>(</span><span>random</span><span>()</span> <span>*</span> <span>365</span> <span>*</span> <span>2</span><span>)</span> <span>AS</span> <span>sold_at</span>
<span>db-#</span> <span>FROM</span>
<span>db-#</span>     <span>generate_series</span><span>(</span><span>1</span><span>,</span> <span>100000</span><span>)</span>
<span><span>db-#</span> <span>ORDER</span> <span>BY</span> <span>sold_at</span><span>;</span>
</span><span>INSERT 0 100000</span>

<span>db=#</span> <span>VACUUM</span> <span>ANALYZE</span> <span>sale_fact</span><span>;</span>
<span>VACUUM</span>
</pre></div>


<p>This time, we loaded the data sorted by the <code>sold_at</code>.</p>
<p>Let's see what the execution plan for the exact same query looks like now:</p>
<div><pre><span></span><span>db=#</span> <span>EXPLAIN</span> <span>(</span><span>ANALYZE</span><span>)</span>
<span>db-#</span> <span>SELECT</span> <span>*</span>
<span>db-#</span> <span>FROM</span> <span>sale_fact</span>
<span>db-#</span> <span>WHERE</span> <span>sold_at</span> <span>BETWEEN</span> <span>'2020-07-01'</span> <span>AND</span> <span>'2020-07-31'</span><span>;</span>

<span>                           QUERY PLAN</span>
<span>---------------------------------------------------------------------------------------------</span>
<span> Index Scan using sale_fact_sold_at_ix on sale_fact (cost=0.29..184.73 rows=4272 width=41)</span>
<span>   Index Cond: ((sold_at &gt;= '2020-07-01'::date) AND (sold_at &lt;= '2020-07-31'::date))</span>
<span> Planning Time: 0.145 ms</span>
<span> Execution Time: 2.294 ms</span>
</pre></div>


<p>After running the query several times we get a stable timing at round 2.3ms. Compared to the previous query that took ~6ms, we get a consistent saving of ~60%.</p>
<p>Another thing we can see right away, is that the database did not use a bitmap scan this time, but a "regular" index scan. Why is that?</p>
<p><strong>Correlation</strong></p>
<p>When the database is analyzing a table it collects all sort of statistics. One of those statistics is <a href="https://www.postgresql.org/docs/current/view-pg-stats.html" rel="noopener"><strong>correlation</strong></a>:</p>
<blockquote>
<p>Statistical correlation between physical row ordering and logical ordering of the column values. This ranges from -1 to +1. When the value is near -1 or +1, an index scan on the column will be estimated to be cheaper than when it is near zero, due to reduction of random access to the disk.</p>
</blockquote>
<p>As the official documentation explains, the correlation measures how "sorted" values of a specific column are on disk.</p>
<figure>
   <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 228.4 231.6" width="20em"><path d="M117 33l28 26m-26-28l25 26M166 81l28 28m-29-29l28 27M59 82l-18 25m20-26l-20 24M154 82l-18 24m16-24l-17 22M78 81l14 23M77 80l14 25M107 38L80 54m26-17L82 52" stroke="currentColor" fill="none"></path><path d="M19 103h30l1 27H18" fill="#f41d92"></path><path d="M17 105h34m-33-2c11 1 22 2 32 1m1-1c-3 12 0 20-3 28m2-27l-1 25m1 1c-8 1-19 0-31-2m31 1H19m-1-1c0-6 1-13-1-25m1 27l1-26" stroke="currentColor" fill="none"></path><path d="M77 105l32 1 1 25-31-2" fill="#fc54ee"></path><path d="M79 105c11 2 23 3 32 2m-33-2l32 1m-1-2c3 12 2 20 2 27m-2-26c0 6-1 10 1 26m0 2c-8-2-19-1-33-1m32-1H78m-1-1l1-22m1 23l-1-25" stroke="currentColor" fill="none"></path><path d="M95 9l32 1-1 26-32-2" fill="#fc54ee"></path><path d="M94 10h34m-33 0l32 1m-2 1c2 8 0 18 1 21m0-23l1 25m1 2l-32-3m31 1l-32 1m0-1c1-7-1-11 2-24m-2 25l1-27" stroke="currentColor" fill="none"></path><path d="M119 105l33-1v24l-34 1" fill="#e08fff"></path><path d="M120 106h31m-31-2c10 2 18 2 32 2m1 0c-1 7 0 16-4 23m2-24v26m2-1l-34 1m32-1l-30-1m-1 2c-1-8 0-11 1-25m0 25l-2-26" stroke="currentColor" fill="none"></path><path d="M144 57h31l-2 23-31 3" fill="#f071ff"></path><path d="M145 58l31-2m-33 2l33-1m0 1c-3 7-2 10-2 24m1-26c-1 8 0 15 1 26m-1 0h-31m31 0c-8-1-16 1-32-1m2-1c-2-4 1-7 0-25m0 26l-1-25" stroke="currentColor" fill="none"></path><path d="M53 54l32-1-2 26H54" fill="#f938c5"></path><path d="M54 57l30-3m-30 2l31-1m0-1c1 6-2 11-1 26m-1-26l1 26m0 1c-13 0-25 0-31-2m31 1l-31-1m-1 0c1-4 3-11 0-23m1 24V55" stroke="currentColor" fill="none"></path><path d="M179 106l29-2 1 29-31-1" fill="#daaeff"></path><path d="M181 107l28-2m-29 1c10 1 21 0 30-1m-1 3l1 22m-1-24c1 8 2 16 1 26m1-2c-12 0-24 2-33 1m32 0h-32m0 0c3-5 2-15 2-25m-1 25v-25" stroke="currentColor" fill="none"></path><path d="M11 196l30-1-1 28-28-1" fill="#f41d92"></path><path d="M10 197l31-2m-31 0h32m0 2l-1 23m0-23l-1 24m0 2c-4-2-12 0-31-2m31 0l-30 1m1-1c-3-8 0-17-3-23m1 23l1-24" stroke="currentColor" fill="none"></path><path d="M81 196l30-1 2 28-31-3" fill="#fc54ee"></path><path d="M82 195h29m-31 1h31m1 1l-2 23m2-24v25m2 2c-10-2-15-2-34-1m31-1l-30 1m-1-2c0-3-1-10 3-25m-3 27l1-25" stroke="currentColor" fill="none"></path><g><path d="M148 196l31 2 3 25-34-3" fill="#e08fff"></path><path d="M147 197c13 0 26-2 32 1m-30-1l31-1m1 0l-3 25m2-24l-1 24m2 0c-13 3-25 0-31 0m30 0h-31m-2 0c3-9 0-13 1-24m1 25v-26" stroke="currentColor" fill="none"></path></g><g><path d="M114 194l34 3-1 22-34 2" fill="#f071ff"></path><path d="M115 194l33 1m-33 1l31-1m0 1c-1 8-2 15-1 26m2-27l-2 26m0-1l-30 2m30-2l-31 1m1 0c-2-11 2-19 1-25m0 25c-2-6 0-11-1-26" stroke="currentColor" fill="none"></path></g><g><path d="M44 198l34-1-3 23-30 3" fill="#f938c5"></path><path d="M44 197c12-2 22 1 32-1m-30 1c7-2 13-1 30 0m1-1c-1 7-3 16 1 24m-2-23c-1 8-1 16 1 24m-1 2l-30-3m30 1c-7 1-14-1-31 1m1-2c-2-3-2-11 0-25m-1 26v-25" stroke="currentColor" fill="none"></path></g><g><path d="M189 197l31-3-3 27-28 1" fill="#daaeff"></path><path d="M188 195c5 0 15 1 30-1m-31 3c7-2 16-2 32-1m-1 0l-1 26m2-27l-1 27m2-2c-13 2-24 2-34 0m32 1h-30m-3-2c4-4 3-7 1-24m0 26c2-7 1-15 1-26" stroke="currentColor" fill="none"></path></g><g><path d="M38 139l-4 44m3-45l-4 46M29 164l3 19m-4-22l6 23M44 165c-4 4-7 9-12 18m11-20l-9 21" stroke="currentColor" fill="none"></path></g><g><path d="M88 142l-23 44m25-45l-26 46M70 162c-5 8-3 16-7 25m5-25l-4 25M85 171c-10 5-13 10-22 16m21-16l-20 16" stroke="currentColor" fill="none"></path></g><g><path d="M141 142l27 43m-28-44l27 46M149 172c3 1 7 5 16 13m-17-16l20 17M164 163l1 22m-2-24l5 25" stroke="currentColor" fill="none"></path></g><g><path d="M198 144l6 39m-7-37l9 38M194 166c3 7 10 14 13 17m-12-17l10 19M207 163v20m2-20l-4 22" stroke="currentColor" fill="none"></path></g></svg>
    <figcaption>correlation = 1</figcaption>
</figure>

<p>When the correlation is 1, or close to 1, it means the pages in the tables are stored on disk in roughly the same order as the rows in the table. This is actually very common. For example, auto incrementing ID's will usually have a correlation close to 1. Date and timestamp columns that keeps track of when rows were created will also usually have a correlation close to 1.</p>
<p>When the correlation is -1, the pages of the table are sorted in reverse order relative to the column.</p>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 238.1 229.4" width="20em"><path d="M158 192l32-4v29l-31-1" fill="#f41d92"></path><path d="M158 191c6-2 16 1 31 1m-31-2h31m0 2c-2 5-1 12 1 24m-1-26l-1 26m2-2c-9 0-18 3-34 4m34-3h-33m0 1c2-7-1-14 2-26m-2 25c2-5 1-9 0-25" stroke="currentColor" fill="none"></path><path d="M47 195h28l3 25-33-1" fill="#fc54ee"></path><path d="M46 193c9 2 23 1 32 0m-33 0c10 2 20 1 31 1m3-2c-2 10-2 21-2 28m0-27v26m-2 0c-12-1-20-1-27 1m28-1H45m1 2l-1-29m0 28v-26" stroke="currentColor" fill="none"></path><path d="M11 192l31 3v24H10" fill="#e08fff"></path><path d="M9 193c10 3 18 2 31 1m-31-1l32 2m-2-1l3 25m-2-26l1 27m-1-2c-8 3-17 3-29 1m30 1l-31-2m1 2c-3-8 0-16-3-26m3 25c0-8-2-17-1-24" stroke="currentColor" fill="none"></path><path d="M120 191h35l-2 24-31-1" fill="#f071ff"></path><path d="M121 191l33-2m-32 2h32m-1-1v26m0-26l1 25m-2-1c-9 0-20 2-31 1m33 0l-33 1m2-2l-1-23m0 25l1-25" stroke="currentColor" fill="none"></path><path d="M198 191l31-1-1 25-32 2" fill="#f938c5"></path><path d="M198 192l29-1m-29-1h31m-2 0c2 11 2 20 2 25m-1-24v25m-1 1c-7 0-12-3-31 0m32-1l-31-1m-2 1c3-9 0-16 3-28m-1 28v-27" stroke="currentColor" fill="none"></path><path d="M86 193l29-1v24l-29 3" fill="#daaeff"></path><path d="M86 192c7-2 14-1 30 0m-32 0c7-1 16 1 32 1m0 0l-1 24m1-26v26m1-1c-8 2-19 1-31 0m30 1H84m1 1l-2-28m2 26c-1-9 0-18-2-24M118 32l27 28m-29-29l28 27M165 81l29 27m-27-27l26 28M59 83l-19 24m18-25l-19 24M153 81l-18 24m17-25l-17 26M76 81l15 24M75 81l15 26M106 37L81 52m25-16L80 53" stroke="currentColor" fill="none"></path><path d="M18 105l31-1 1 27-32-3" fill="#f41d92"></path><path d="M18 103c8 2 19 1 31 0m-31 2l31-2m0 1c-2 11-1 21 2 25m-3-26c2 9 1 17 1 26m-1 2l-31-3m32 1H17m1-1c-1-8 2-13-1-22m0 24l1-25" stroke="currentColor" fill="none"></path><path d="M78 106h31l2 25-35-1" fill="#fc54ee"></path><path d="M76 105c15 2 26 1 31 1m-29 0l30 1m0-3c2 6 2 14 0 28m0-26l1 25m1-1c-10 2-20 0-34 1m33 0H77m-1 0c1-6 4-16 4-25m-2 25v-25" stroke="currentColor" fill="none"></path><path d="M95 10l31 2-1 22-32 1" fill="#fc54ee"></path><path d="M94 11l32-2m-31 1l32-1m-3 2c1 9 3 17 2 26m1-27c-2 8-1 16-1 25m-1 2c-7-1-18-3-31-3m32 1H95m-1-1c3-2 0-7 1-23m-1 24l1-25" stroke="currentColor" fill="none"></path><g><path d="M120 106l33-1-4 24-30 2" fill="#e08fff"></path><path d="M120 106c9-1 17-1 29 1m-29-2l30 1m2-2c-1 10-2 16 0 27m-2-26l1 25m1 1c-8-2-18-1-34 0m33 0c-9-1-17 0-32-2m-1 3c4-10 4-16 3-26m-2 24l1-25" stroke="currentColor" fill="none"></path></g><g><path d="M144 59l30-4-1 27-29-2" fill="#f071ff"></path><path d="M144 57c7-2 14-2 32-1m-32 1h31m-2 0c3 6 2 15 2 24m-1-25v25m1 2c-13-2-24-2-31-2m31 1h-33m3 2c-3-5-2-11 0-29m-3 27l1-25" stroke="currentColor" fill="none"></path></g><g><path d="M54 55l28-2 1 28-32-2" fill="#f938c5"></path><path d="M52 55c7 0 16 2 31 1m-30-1h31m0 1c-1 5 1 10-2 23m1-24v26m1-2c-10 1-18 2-32 1m31 0c-10 1-20 0-31-1m2 0c1-6 0-11-3-23m1 24l1-25" stroke="currentColor" fill="none"></path></g><g><path d="M178 104l30 2 2 24-33 3" fill="#daaeff"></path><path d="M179 105l32 1m-33-1h31m2 0l-3 28m1-27l1 25m-2-1l-30 2m31-1h-32m1 2l1-28m0 27v-25" stroke="currentColor" fill="none"></path></g><g><path d="M37 140l145 43M36 139l145 43M151 184c13-1 23-4 32-4m-33 4l31-2M157 164l26 16m-27-16l25 18" stroke="currentColor" fill="none"></path></g><g><path d="M88 141l-24 46m23-47l-23 46M67 161l-5 26m5-28c-1 9-3 16-3 27M83 169l-21 18m21-20l-19 19" stroke="currentColor" fill="none"></path></g><g><path d="M140 142L20 185m119-44L19 186M43 167c-10 5-16 12-23 19m21-19l-22 18" stroke="currentColor" fill="none"></path><path d="M50 187c-13-3-21-3-30-1m28 0c-7 0-15 1-29-1" stroke="currentColor" fill="none"></path></g><g><path d="M197 145L91 185m105-40L90 186M113 166l-23 20m23-19l-24 19M121 185c-12 3-21 3-31 1m30 0H89" stroke="currentColor" fill="none"></path></g></svg>
<figcaption>correlation ~ 0</figcaption>
</figure>

<p>When the correlation is close to 0, it mean the values in the column have no or very little correlation to how the pages of the table are stored.</p>
<p>Going back to our <code>sale_fact</code> table, when we loaded the data into the table without sorting it first, these were the correlations:</p>
<div><pre><span></span><span>db=#</span> <span>SELECT</span> <span>tablename</span><span>,</span> <span>attname</span><span>,</span> <span>correlation</span>
<span>db-#</span> <span>FROM</span> <span>pg_stats</span>
<span>db=#</span> <span>WHERE</span> <span>tablename</span> <span>=</span> <span>'sale_fact'</span><span>;</span>

<span> tablename | attname  | correlation</span>
<span>-----------+----------+--------------</span>
<span> sale      | id       |            1</span>
<span> sale      | username | -0.005344716</span>
<span><span> sale      | sold_at  | -0.011389783</span>
</span></pre></div>


<p>The auto generated column <code>id</code> has a correlation of 1. The <code>sold_at</code> column has a very low correlation: consecutive values are scattered across the entire table.</p>
<p>When we loaded sorted data into the table, these were the correlations calculated by the database:</p>
<div><pre><span></span> <span>tablename</span> <span>|</span> <span>attname</span>  <span>|</span>  <span>correlation</span>
<span>-----------+----------+----------------</span>
 <span>sale_fact</span> <span>|</span> <span>id</span>       <span>|</span>              <span>1</span>
 <span>sale_fact</span> <span>|</span> <span>username</span> <span>|</span> <span>-</span><span>0.00041992788</span>
<span> <span>sale_fact</span> <span>|</span> <span>sold_at</span>  <span>|</span>              <span>1</span>
</span></pre></div>


<p>The correlation for <code>sold_at</code> is now 1.</p>
<p>So why did the database use a bitmap scan when the correlation was low, and an index scan when the correlation was close to 1?</p>
<ul>
<li>When the correlation was 1, the database estimated that rows in the requested range are likely to be in consecutive pages. In this case, an index scan is likely to read very few pages.</li>
<li>When the correlation was close to 0, the database estimated that rows in the requested range are likely to be scattered across the entire table. In this case, it makes sense to use a bitmap scan to map the table pages in which rows exist, and only then fetch them and apply the condition.</li>
</ul>
<p>The next time you load data into a table, think about how the data is going to be queried, and make sure you sort it in a way that indexes used for range scan can benefit from.</p>
<p><strong><code>CLUSTER</code> Command</strong></p>
<p>Another way of "sorting a table on disk" by a specific index is to use the <a href="https://www.postgresql.org/docs/current/sql-cluster.html" rel="noopener"><code>CLUSTER</code> command</a>.</p>
<p>For example:</p>
<div><pre><span></span><span>db=#</span> <span>TRUNCATE</span> <span>sale_fact</span><span>;</span>
<span>TRUNCATE TABLE</span>

<span>-- Insert rows without sorting</span>
<span>db=#</span> <span>INSERT</span> <span>INTO</span> <span>sale_fact</span> <span>(</span><span>username</span><span>,</span> <span>sold_at</span><span>)</span>
<span>db-#</span> <span>SELECT</span>
<span>db-#</span>     <span>md5</span><span>(</span><span>random</span><span>()</span><span>::</span><span>text</span><span>)</span> <span>AS</span> <span>username</span><span>,</span>
<span>db-#</span>     <span>'2020-01-01'</span><span>::</span><span>date</span> <span>+</span> <span>(</span><span>interval</span> <span>'1 day'</span><span>)</span> <span>*</span> <span>round</span><span>(</span><span>random</span><span>()</span> <span>*</span> <span>365</span> <span>*</span> <span>2</span><span>)</span> <span>AS</span> <span>sold_at</span>
<span>db-#</span> <span>FROM</span>
<span>db-#</span>     <span>generate_series</span><span>(</span><span>1</span><span>,</span> <span>100000</span><span>)</span>
<span>INSERT</span> <span>0</span> <span>100000</span>

<span>db=#</span> <span>ANALYZE</span> <span>sale_fact</span><span>;</span>
<span>ANALYZE</span>

<span>db=#</span> <span>SELECT</span> <span>tablename</span><span>,</span> <span>attname</span><span>,</span> <span>correlation</span>
<span>db-#</span> <span>FROM</span> <span>pg_stats</span>
<span>db-#</span> <span>WHERE</span> <span>tablename</span> <span>=</span> <span>'sale_fact'</span><span>;</span>

<span>  tablename | attname  |  correlation</span>
<span>-----------+-----------+----------------</span>
<span><span> sale_fact | sold_at   | -5.9702674e-05</span>
</span><span> sale_fact | id        |              1</span>
<span> sale_fact | username  |    0.010033822</span>
</pre></div>


<p>We loaded data into the table in random order and as a result the correlation of <code>sold_at</code> is close to zero.</p>
<p>To "rearrange" the table by <code>sold_at</code>, we used the <code>CLUSTER</code> command to sort the table on disk according to the index <code>sale_fact_sold_at_ix</code>:</p>
<div><pre><span></span><span><span>db=#</span> <span>CLUSTER</span> <span>sale_fact</span> <span>USING</span> <span>sale_fact_sold_at_ix</span><span>;</span>
</span><span>CLUSTER</span>

<span>db=#</span> <span>ANALYZE</span> <span>sale_fact</span><span>;</span>
<span>ANALYZE</span>

<span>db=#</span> <span>SELECT</span> <span>tablename</span><span>,</span> <span>attname</span><span>,</span> <span>correlation</span>
<span>db-#</span> <span>FROM</span> <span>pg_stats</span>
<span>db-#</span> <span>WHERE</span> <span>tablename</span> <span>=</span> <span>'sale_fact'</span><span>;</span>

<span> tablename | attname  | correlation</span>
<span>-----------+----------+--------------</span>
<span><span> sale_fact | sold_at  |            1</span>
</span><span> sale_fact | id       | -0.002239401</span>
<span> sale_fact | username |  0.013389298</span>
</pre></div>


<p>After the table was clustered we can see that the correlation for <code>sold_at</code> is 1.</p>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 231 130.3" width="20em"><path d="M83 10l29 1 2 27-30-3" fill="#f41d92"></path><path d="M81 10c10 1 22 2 31-1m-31 2l32-1m1 0c-1 8-2 15-1 27m-1-27c1 9 0 14 2 26m1 2l-31-2m29 0c-8-1-19 0-31 1m0-3l-1-22m2 25c-2-11-1-21 0-27" stroke="currentColor" fill="none"></path><path d="M46 11l31-1v28l-29 1" fill="#fc54ee"></path><path d="M49 13c11-2 23-1 31-3m-32 1c10 1 19 0 31 2m-2-1c2 7 0 14 3 24m-2-23v25m-1 1c-10-3-22-4-30-3m32 0l-31 1m-2 0c2-7 2-9 2-25m0 25V12" stroke="currentColor" fill="none"></path><path d="M9 10h31l3 27-31 2" fill="#e08fff"></path><path d="M12 12h28M9 13c14-2 26-2 33-2m-1 1l-1 24m2-25v27m1 0L9 36m32 1l-31-1m0 1c-2-7 2-13 0-24m0 24V11" stroke="currentColor" fill="none"></path><path d="M114 9l32 2 1 26-29-2" fill="#f071ff"></path><path d="M116 9c11 1 24-1 31 3m-30-2h30m0 0c-2 6 2 11-1 26m1-27c0 10-1 19 1 26m0 0c-6-1-15 0-33 1m32-2l-32 1m1-2l1-21m-2 22c2-5 2-11 0-24" stroke="currentColor" fill="none"></path><path d="M151 11l29-2 3 27h-30" fill="#f938c5"></path><path d="M153 10c7-1 21 0 28 1m-31-1c8-1 15 0 32 1m0-3v29m1-27v25m0 1c-12-1-26 1-34-1m34 0l-31-1m0 0c-3-6 1-14-2-24m1 26V10" stroke="currentColor" fill="none"></path><path d="M187 13l31 1-1 24-30-2" fill="#daaeff"></path><path d="M185 10c13 1 25 3 34 2m-33 0h30m0-1c2 6 2 14 3 27m-1-27c-2 8-2 16-2 25m1 0c-13 1-22 2-32 0m32 0l-31 2m-2-2c1-6 3-9 3-24m0 25c-2-6-1-14-1-26" stroke="currentColor" fill="none"></path><path d="M13 92l35 4-3 23H15" fill="#f41d92"></path><path d="M14 92c10 0 20 0 31 3m-30-2l30 2m0-2c0 12 0 20 3 25m-2-24v25m0-1c-6 2-15 1-33 3m33-1H14m1 1l-1-28m1 27V94" stroke="currentColor" fill="none"></path><g><path d="M84 96l35-3-2 26-32 2" fill="#fc54ee"></path><path d="M84 94c10 1 20-1 34-1m-33 2h33m-2-1c2 7 1 18-1 24m1-25l1 26m-2 2c-6-1-15-3-28 0m30-1c-11 1-21-1-31-1m1 1c-3-6-2-12-2-27m1 27l-1-27" stroke="currentColor" fill="none"></path></g><g><path d="M156 96l28-2 1 25-30 1" fill="#e08fff"></path><path d="M153 93c12 0 22 3 31 1m-30 1h32m-2 0c0 7 2 12 0 24m0-24l1 24m2 1h-31m30-1h-33m1-1l-2-24m2 26c0-9 1-16-1-26" stroke="currentColor" fill="none"></path></g><g><path d="M122 92l29 1-1 27-30-3" fill="#f071ff"></path><path d="M118 94c7-2 18-2 32-1m-30 1c7-2 16 0 31-1m1-1c-1 9-3 12-1 25m1-24l-1 26m0 0c-9-2-16 1-30 1m29-1l-31-1m-1 0l1-25m1 25l-1-24" stroke="currentColor" fill="none"></path></g><g><path d="M48 94h33l1 26-34-2" fill="#f938c5"></path><path d="M50 93c5 3 11 1 31 0m-30 1h30m-1 0c2 5-1 13-1 25m2-24c0 6-1 12 1 25m-1 0H52m30 0H49m1-1c-1-10-2-19 0-26m0 26c0-9-1-18 1-24" stroke="currentColor" fill="none"></path></g><g><path d="M190 95l30 1 1 23-32 2" fill="#daaeff"></path><path d="M188 94c11-1 17 1 32-1m-31 1c11 2 21 1 31 1m1 1c-2 4 0 10-1 23m2-24l-1 25m0-2c-10 4-23 4-31 3m31-1l-31 1m-1-2V96m0 25c0-9 0-14 2-27" stroke="currentColor" fill="none"></path></g><g><path d="M115 50l2 33m-3-34l2 35M110 68c0 6 3 10 6 18m-8-17l7 15M121 67c-3 6-3 11-5 19m4-17l-5 15" stroke="currentColor" fill="none"></path></g></svg>
<figcaption>CLUSTER command</figcaption>
</figure>

<p>Some things to note about the <code>CLUSTER</code> command:</p>
<ul>
<li>Clustering the table by a specific column may affect the correlation of other column. See for example the correlation of the column <code>id</code> after we clustered the table by <code>sold_at</code>.</li>
<li><code>CLUSTER</code> is a heavy, blocking operation, so make sure you don't execute it on a live table.</li>
</ul>
<p>For these two reason it's best to insert the data sorted and not rely on <code>CLUSTER</code>.</p>
<hr>
<h2 id="index-columns-with-high-correlation-using-brin"><a href="#index-columns-with-high-correlation-using-brin">Index Columns With High Correlation Using BRIN</a></h2>
<p>When talking about indexes, most developers will think about B-Tree indexes. But, PostgreSQL provides other types of indexes such as <a href="https://www.postgresql.org/docs/current/brin.html" rel="noopener">BRIN</a>:</p>
<blockquote>
<p>BRIN is designed for handling very large tables in which certain columns have some natural correlation with their physical location within the table</p>
</blockquote>
<p>BRIN stands for Block Range Index. According to the documentation, a BRIN index works best for columns with high correlation. As we've already seen in previous sections, some fields such as auto incrementing IDs and timestamps are naturally correlated with the physical structure of the table, hence they are good candidates for a BRIN index.</p>
<p>Under some circumstances, a BRIN index can provide a better "value for money" in terms of size and performance compared to a similar B-Tree index.</p>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 408.4 132.1" width="35em"><path d="M9 96l29 1 1 22-29 2" fill="#f41d92"></path><path d="M12 97c9 0 18 2 26 1m-28 0c11-2 22-1 28-1m-1 0c-1 9 1 18-1 21m2-21v22m1 2c-9-3-18-1-31-2m30 1l-29-1m0 1c-1-6 1-10 1-22m0 22c1-8 0-14-1-23" stroke="currentColor" fill="none"></path><path d="M101 99l28 1v21l-26-1" fill="#fc54ee"></path><path d="M101 100c10-2 23-1 29 1m-28-2l27 1m0-3c1 8 1 11-1 23m1-21l-1 22m2 0l-29-1m29 1h-29m1-2c-1-5 0-13 1-20m-1 23l-1-23" stroke="currentColor" fill="none"></path><path d="M234 99l29-1-2 25h-29" fill="#e08fff"></path><path d="M234 98c5 2 12 2 29 0m-29 0h28m-3 1c3 5 0 8 1 23m1-24v23m0-1c-9 2-15 1-29 0m29 1h-28m-2 0c3-6 2-13 3-24m0 24l-1-23" stroke="currentColor" fill="none"></path><path d="M199 99l27-1 2 20-27 3" fill="#f071ff"></path><path d="M198 97c14 1 24 3 28 0m-28 1c9 0 16 1 28-1m1 2v20m-1-21l1 22m-2-1c-8 0-18 0-27 2m29-2l-28 2m0 0c1-7 1-12-2-24m2 23c1-8 0-15-1-22" stroke="currentColor" fill="none"></path><path d="M73 99l26 2-2 22-25-3" fill="#f938c5"></path><path d="M70 101l28-3m-26 1c10 1 21 0 26-1m2 2c-3 5-3 14-2 22m1-23c1 7 0 15-1 23m-1 0c-10-1-20-2-25 0m26-1H71m1 2c-1-8 0-19-2-23m1 22V99" stroke="currentColor" fill="none"></path><path d="M267 98l30-2v25l-31-2" fill="#daaeff"></path><path d="M269 98c9 2 17-1 25 1m-26-1h26m2-2c-2 5 0 10 0 25m-1-22c-1 6 0 13 1 22m0-2c-9-1-18 2-28 2m27-1c-7-1-15 0-28 1m2-1c0-4-3-10-1-20m0 20V99" stroke="currentColor" fill="none"></path><path d="M72 9l91 1 1 39-93 3" fill="#ced4da"></path><path d="M74 12l90-2m-92 0l92-1m1 1c1 17-1 31-3 41m2-41v41m1 0c-21-2-43-1-92-2m91 1c-26 2-53 0-93 1m2-2c-1-10-3-24-2-37m1 39V11" stroke="transparent" fill="none"></path><path d="M258 12l90 2 1 38-94 1" fill="#ced4da"></path><path d="M257 11c32 1 67 2 93 0m-3 1l4 43m-2-1c-35 0-70-3-92 1m2-2c-4-11-2-17-1-42" stroke="transparent" stroke-width="1.5" fill="none" stroke-dasharray="3 6"></path><path d="M79 20l34-1v27H80" fill="#f41d92"></path><path d="M78 20l34-1m-32-1c12 2 21 1 31 0m0 1c0 10 1 15-1 26m1-25v24m0-2c-10 2-20 1-31 1m31 1c-12 1-22-1-32 1m0 0c3-10 0-22-1-27m3 26l-1-25" stroke="currentColor" fill="none"></path><path d="M120 21l32 1 2 22-31 2" fill="#fc54ee"></path><path d="M121 20c7-1 16 1 31 1m-30-1h30m2-2c-1 7-3 13 0 28m-1-27v25m-2-1c-4 3-12 2-31 2m32 0l-31 1m2-2l-2-23m0 23l1-25" stroke="currentColor" fill="none"></path><g><path d="M264 18l29-1 1 28-31-3" fill="#f071ff"></path><path d="M264 17c5 3 15 1 29 1m-31 0c10 0 21 0 32 2m0 1c0 3-1 10 1 23m-1-26v27m0-3c-9 3-19 0-31 0m30 1l-31 2m0 0l3-25m-3 25c2-10 0-21 0-26" stroke="currentColor" fill="none"></path></g><g><path d="M308 21h29l1 24-28 1" fill="#daaeff"></path><path d="M309 19c8 2 14 1 30 2m-32-1h33m1 1c-3 6-1 10-1 24m0-24v24m-2-1c-12 2-22 1-31 0m31 3c-9-2-20-1-30-2m1 2c-1-8-2-17-1-26m-1 24c2-8 1-16 1-25" stroke="currentColor" fill="none"></path></g><g><path d="M42 101h26l-2 21-25 1" fill="#fc54ee"></path><path d="M41 102c6-2 12-1 28-4m-30 3c10-2 20-1 29-1m-2 1l3 23m-2-25v22m2 1c-11-1-22 1-31-1m30 1l-29-1m0 3c-1-9 0-15 1-26m0 25l-1-22" stroke="currentColor" fill="none"></path></g><g><path d="M131 97h28v23l-24-2" fill="#f41d92"></path><path d="M133 97c8-1 12-1 28 1m-28 0l27-1m2 2c-3 8 0 17 1 21m-3-22l1 21m-1 0c-7-1-18-1-25 2m26 0h-28m-1 0c0-6 1-12-1-21m2 20V99" stroke="currentColor" fill="none"></path></g><g><path d="M166 100l26-2 1 24-27-1" fill="#fc54ee"></path><path d="M164 98l30-1m-29 1l26 1m0 0c2 7 1 10-1 21m2-22l1 24m0 1c-9 0-14-3-27-1m27-1l-29-1m0 1c0-5 2-15 0-22m1 22l-1-22" stroke="currentColor" fill="none"></path></g><g><path d="M337 99l26 1 1 20-25-1" fill="#e08fff"></path><path d="M337 98c7 1 14-1 26 1m-26-2c8 2 17 0 27 1m0 0c2 6-1 13 1 20m-1-21v24m0 0l-27 1m27-1c-9 0-18 0-27-2m1 0c-1-8 0-13-3-20m2 22l-1-23" stroke="currentColor" fill="none"></path></g><g><path d="M303 96l29 1-3 25-29-1" fill="#f071ff"></path><path d="M302 96l29 1m-29 1h28m0 1l-2 21m1-23l1 23m0 2c-10-1-21-2-26-1m26-2l-29 1m-1 1c0-9 2-20 3-23m0 22l-1-22" stroke="currentColor" fill="none"></path></g><g><path d="M369 99l29-2 2 21-28 1" fill="#daaeff"></path><path d="M370 99c8-2 18 0 28-1m-27 0l28-1m1-1c-3 8-1 17-1 25m-1-23l1 23m1 0c-9 0-19 0-28-2m26 1c-8 0-17-1-27 1m0-3c1-4-2-10 0-22m0 25V98" stroke="currentColor" fill="none"></path></g><g><path d="M20 88c0-4-14-18-1-20 14-1 67 12 82 11 16-1 7-17 9-16 2 0-8 16 3 18 11 1 49-11 61-9 12 3 9 19 11 22M19 87c0-3-15-20-1-21 15-1 70 15 86 15 15-1 5-18 7-18 1 0-7 17 4 18 11 2 48-11 60-9s8 17 10 21" stroke="#ced4da" fill="none"></path></g><g><path d="M214 88c0-3-15-16 0-17s73 11 90 10c16-1 5-16 7-16 1 0-8 17 4 19 12 1 54-12 66-10s7 18 8 22m-174-5c0-4-17-20-2-22 14-1 74 14 90 14 17-1 6-18 8-17 1 0-9 17 3 18 11 1 53-12 65-11 13 2 8 18 10 22" stroke="#ced4da" fill="none"></path></g></svg>
<figcaption>BRIN Index</figcaption>
</figure>

<p>A BRIN index works by keeping the range of values within a number of adjacent pages in the table. Say we have these values in a column, each is single table page:</p>
<div><pre><span></span>1, 2, 3, 4, 5, 6, 7, 8, 9
</pre></div>


<p>A BRIN index works on ranges of adjacent pages in the table. If the number of adjacent pages is set to 3, the index will divide the table into the following ranges:</p>
<div><pre><span></span>[1,2,3], [4,5,6], [7,8,9]
</pre></div>


<p>For each range, the BRIN index <strong>keeps the minimum and maximum value</strong>:</p>



<p>Using the index above, try to search for the value 5:</p>
<ul>
<li><code>[13]</code> - Definitely not here</li>
<li><code>[46]</code> - Might be here</li>
<li><code>[79]</code> - Definitely not here</li>
</ul>
<p>Using the BRIN index we managed to limit our search to blocks 46.</p>
<p>Let's take another example, this time the values in the column will have a correlation close to zero, meaning they are <em>not</em> sorted:</p>
<div><pre><span></span>[2,9,5], [1,4,7], [3,8,6]
</pre></div>


<p>Indexing 3 adjacent blocks produces the following ranges:</p>



<p>Let's try to search for the value 5:</p>
<ul>
<li><code>[29]</code> - Might be here</li>
<li><code>[17]</code> - Might be here</li>
<li><code>[38]</code> - Might be here</li>
</ul>
<p>In this case the index is not limiting the search <em>at all</em>, hence it is useless.</p>
<p><strong>Understanding <code>pages_per_range</code></strong></p>
<p>The number of adjacent pages is determined by the parameter <code>pages_per_range</code>. The number of pages per range effects the size and accuracy of the BRIN index:</p>
<ul>
<li>A large <code>pages_per_range</code> will produce a small and less accurate index</li>
<li>A small <code>pages_per_range</code> will produce a bigger and more accurate index</li>
</ul>
<p>The default <code>pages_per_range</code> is 128.</p>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 408.4 135.6" width="35em"><path d="M10 100l27 2 1 21-27-1" fill="#f41d92"></path><path d="M8 102c12-1 21 0 28-4m-26 2l29 1m-3-1c3 7 1 12 0 23m2-22c0 5-1 10 1 22m0 1l-29-1m28 0H10m1-1c1-5 0-8-2-22m1 24V99" stroke="currentColor" fill="none"></path><path d="M101 102l29 1-1 23h-29" fill="#fc54ee"></path><path d="M103 102c10-1 21 0 24 2m-26-2h28m0 1v21m1-21c-2 6-2 14-1 22m1 1c-10-2-17-1-28-1m27-1h-27m-1 3c0-7 2-16 0-26m1 24l-2-22" stroke="currentColor" fill="none"></path><path d="M233 103l29-1v21l-27 1" fill="#e08fff"></path><path d="M233 103c9 0 20-3 29-1m-29 0h28m1 1c-2 5-3 8-2 21m1-23l1 23m0 0c-12 1-22 1-28-1m26 0c-7 2-15 2-27 1m2 0l-3-20m2 21v-23" stroke="currentColor" fill="none"></path><path d="M200 102h26l-1 23h-27" fill="#f071ff"></path><path d="M200 100c6 0 9 3 26 3m-28-2c10 2 20 0 28 0m1 0c1 3 0 9-1 22m0-22v24m0-2l-29 1m28 0h-26m0 1c2-10 0-19 1-25m0 23c-2-5-2-11-2-22" stroke="currentColor" fill="none"></path><path d="M72 102l28-1v23l-28-1" fill="#f938c5"></path><path d="M69 104c11-4 24-2 31-1m-29-1h27m0 2v22m1-24l1 24m-2 0c-9-1-19-2-27-1m28 1H71m2 1c-3-8-3-13-3-25m1 23v-22" stroke="currentColor" fill="none"></path><path d="M267 102l27 1v22l-28-3" fill="#daaeff"></path><path d="M269 100c4 3 12 3 27 0m-29 2l27-1m2-1v26m-2-24l2 23m0-1c-10 0-22-1-29 1m29-1h-28m1-1c-2-9 0-18-2-20m0 21c-1-8 0-16 1-22" stroke="currentColor" fill="none"></path><path d="M26 15h78l-1 33-79 1" fill="#ced4da"></path><path d="M24 14c30 1 58 2 77 1m-75 1h76m-1 0c0 11 0 24 3 34m-1-34v34m-1 0c-22-1-46 0-75-2m75 2l-77 1m-1-1c0-9 0-21 3-33m-1 32V16" stroke="transparent" fill="none"></path><path d="M216 12h85v35l-85 2" fill="#ced4da"></path><path d="M215 13c18 1 37-2 85-2m2-1c-2 9-3 20 0 40m-1-2c-22-1-42 2-84 0m-1 2l2-38" stroke="transparent" stroke-width="1.5" fill="none" stroke-dasharray="3 6"></path><path d="M34 23l25-1-2 21-25 1" fill="#f41d92"></path><path d="M33 23c10 1 17 0 24-1m-25 1h27m-2 0c0 9 3 16 0 21m2-21l-1 21m0-1l-28 1m28 0l-26 1m-1 1c0-11 3-17 3-24m-2 22l1-21" stroke="currentColor" fill="none"></path><path d="M66 25l25-3 1 23-26 1" fill="#fc54ee"></path><path d="M66 25c7-3 12-2 26-2m-26 0c10 1 22 2 26 1m0-1v20m1-18l-1 20m-1 0c-7 1-16-2-24 2m25-2l-25 1m1-3c-2-2-1-6-3-20m1 22c2-6 1-13 0-20" stroke="currentColor" fill="none"></path><path d="M223 16h26l1 24-27 2" fill="#f071ff"></path><path d="M224 18c3-1 9-2 25 1m-28-3c11 2 21 1 30 1m-2 1c3 7 0 13 0 24m2-24l-1 23m0-1h-26m26 1l-27-1m-2 0c3-6 3-15 0-22m1 23l1-24" stroke="currentColor" fill="none"></path><path d="M262 17l29 2 1 23h-27" fill="#daaeff"></path><path d="M264 17l30 3m-32-1h29m2 2c-1 3-2 8 1 20m-2-22v23m0 1c-11-3-18 0-29-1m30 0h-30m0 1c1-5-1-13 1-26m0 25l-1-23" stroke="currentColor" fill="none"></path><path d="M38 102l30 1v24H40" fill="#fc54ee"></path><path d="M38 102c9 0 16 3 30 0m-28 2l28-1m1 1c-3 5-3 14-2 22m1-22v22m1-2c-10 2-13 1-29 1m27 2l-27-2m1 1c1-10-2-17-3-23m2 23v-24" stroke="currentColor" fill="none"></path><path d="M132 101l28 1 2 22-27-1" fill="#f41d92"></path><path d="M132 100c10 1 23 2 27 0m-26 2l27-1m1-1c-1 6 2 12 1 24m-1-23v22m-2-1c-6 3-15 2-27 2m30 0l-30 1m2 1c-2-8-1-14-1-25m0 23l-1-24" stroke="currentColor" fill="none"></path><g><path d="M165 102l28 1v23l-29-3" fill="#fc54ee"></path><path d="M164 101c9 3 20 0 28-1m-27 1l27 1m-1-1l1 25m0-25v23m-2 0c-4 0-14-1-25 1m27 0l-26-1m1-1c-3-4-4-10-3-22m1 23l-1-23" stroke="currentColor" fill="none"></path></g><g><path d="M337 102h29v21h-30" fill="#e08fff"></path><path d="M336 101c9 2 13 0 27-1m-27 2h28m0-2c2 10 1 20 2 25m-2-23v22m0 2c-10-2-20-2-27-1m28 0l-29-1m-1-1c2-9 2-16 1-20m0 22v-23" stroke="currentColor" fill="none"></path></g><g><path d="M303 103h27l-1 20-28 1" fill="#f071ff"></path><path d="M301 103c9-3 15-4 27-2m-25-1l27 2m-2 1l3 22m-1-24v23m1-1h-28m28 0l-29 1m-1 0c-1-8 0-16 3-22m-1 21c0-7-2-13-1-22" stroke="currentColor" fill="none"></path></g><g><path d="M372 101l28-1-3 22h-25" fill="#daaeff"></path><path d="M373 102c4-2 10-3 25 0m-28-1h29m1-1v24m-1-23v22m-1 1l-28 1m28-2c-8 2-17 0-27 1m0-3c0-7-1-14 1-20m-1 23v-23" stroke="currentColor" fill="none"></path></g><g><path d="M17 91c0-4-8-19-2-21 6-1 32 12 39 11 8 0 4-14 5-13 1 0-3 15 2 16s24-12 30-10c5 2 3 18 4 22m-79-6c1-3-5-17 1-18 7-2 33 11 39 10 7-1 3-17 3-16 1 0-4 16 1 18s23-10 29-8c6 3 5 19 6 22" stroke="#ced4da" fill="none"></path></g><g><path d="M213 90c0-3-8-19-1-20s35 13 43 13c9-1 5-16 6-15 1 0-5 16 1 18 5 1 26-12 32-10 7 2 5 18 6 21m-88-5c0-3-9-20-2-21 8-2 39 14 48 13 8-1 3-19 4-18 1 0-4 19 2 20 5 2 25-13 31-11 6 1 5 17 5 21" stroke="#ced4da" fill="none"></path></g><g><path d="M123 14l76-1v35h-78" fill="#ced4da"></path><path d="M122 16c18-3 40-1 79-2m-78 1h77m2-1c-4 10-4 19-1 34m-1-33v35m0-2c-16-1-33 0-76 2m76-1l-77-1m1 1c1-10-1-19-1-32m0 32V15" stroke="transparent" fill="none"></path></g><g><path d="M129 21l26 2 2 20h-28" fill="#fc54ee"></path><path d="M131 23c5-1 15 2 25 0m-25 1h23m2-2l-3 18m2-18v20m1-1c-8-2-13 2-25-2m23 2h-23m-2-1c0-5 3-9 2-17m0 17l-1-17" stroke="currentColor" fill="none"></path></g><g><path d="M163 25l27-3v19l-26-1" fill="#fc54ee"></path><path d="M166 24c4-1 12 0 27 1m-29-1l27-1m-2-1c1 6 3 14 1 18m1-16v18m0-2c-7 3-12 0-26 3m26-1l-27-1m1 1l-2-19m1 19c-1-5 0-8 1-18" stroke="currentColor" fill="none"></path></g><g><path d="M312 11h87l-3 38-81-2" fill="#ced4da"></path><path d="M314 11c25-2 49-2 83-1m-1 1c2 8 3 16 1 36m2 2c-31-4-58-3-86-3m2 1c-1-12 0-24-3-36" stroke="transparent" stroke-width="1.5" fill="none" stroke-dasharray="3 6"></path></g><g><path d="M318 17h28l3 22h-30" fill="#f071ff"></path><path d="M320 15h27m-27 1h27m2-1c-4 10-3 16-3 25m1-24l1 22m-2 3c-7-2-18-2-27-1m29-2c-9 2-17 1-30 2m1-2l2-22m-2 22c0-4-1-9 1-23" stroke="currentColor" fill="none"></path></g><g><path d="M361 16l29 3-1 21-29-1" fill="#daaeff"></path><path d="M360 16h28m-27 1l28 1m-1-3c2 8 0 15 2 24m-1-22c1 8-1 15-1 24m3 0c-13-1-23-2-30-1m27 0h-27m-2 0c2-6 1-11 1-25m0 25V17" stroke="currentColor" fill="none"></path></g><g><path d="M111 87c0-3-8-16-2-17 7-2 33 11 41 10 7 0 2-14 3-14s-2 14 3 16c5 1 23-11 28-9 6 2 4 19 5 22m-79-6c0-4-5-20 1-21 7-1 31 14 38 14 7-1 3-18 4-18 2 0-3 16 2 18 6 1 25-12 30-10 6 2 4 19 4 22" stroke="#ced4da" fill="none"></path></g><g><path d="M319 90c0-4-6-21 0-22 6-2 30 13 37 12 6-1 2-18 3-18s-2 18 4 20c5 1 22-13 28-10 5 2 3 19 4 23m-77-6c0-4-6-21 0-23 7-2 33 13 40 12 7 0 0-16 1-16 1 1-2 18 3 20 5 1 22-14 27-11 5 2 2 22 3 26" stroke="#ced4da" fill="none"></path></g></svg>
<figcaption>BRIN index with lower `pages_per_range`</figcaption>
</figure>

<p>To demonstrate, let's create a BRIN index on ranges of 2 adjacent pages and search for the value 5:</p>
<ul>
<li><code>[12]</code> - Definitely not here</li>
<li><code>[34]</code> - Definitely not here</li>
<li><code>[56]</code> - Might be here</li>
<li><code>[78]</code> - Definitely not here</li>
<li><code>[9]</code> - Definitely not here</li>
</ul>
<p>Using the index with 2 pages per range we were able to limit the search to blocks 5 and 6. When the range was 3 pages, the index limited the search to blocks 4,5 and 6.</p>
<p>Another difference between the two indexes is that when the range was 3 we only had to keep 3 ranges. When the range was 2 we had to keep 5 ranges so the index was bigger.</p>
<p><strong>Creating a BRIN Index</strong></p>
<p>Using the <code>sales_fact</code> from before, let's create a BRIN index on the column <code>sold_at</code>:</p>
<div><pre><span></span><span>db=#</span> <span>CREATE</span> <span>INDEX</span> <span>sale_fact_sold_at_bix</span> <span>ON</span> <span>sale_fact</span>
<span><span>db-#</span> <span>USING</span> <span>BRIN</span><span>(</span><span>sold_at</span><span>)</span> <span>WITH</span> <span>(</span><span>pages_per_range</span> <span>=</span> <span>128</span><span>);</span>
</span><span>CREATE INDEX</span>
</pre></div>


<p>This creates a BRIN index with the default <code>pages_per_range = 128</code>.</p>
<p>Let's try to query for a range of sale dates:</p>
<div><pre><span></span><span>db=#</span> <span>EXPLAIN</span> <span>(</span><span>ANALYZE</span><span>)</span>
<span>db-#</span> <span>SELECT</span> <span>*</span>
<span>db-#</span> <span>FROM</span> <span>sale_fact</span>
<span>db-#</span> <span>WHERE</span> <span>sold_at</span> <span>BETWEEN</span> <span>'2020-07-01'</span> <span>AND</span> <span>'2020-07-31'</span><span>;</span>
<span>                                    QUERY PLAN</span>
<span>--------------------------------------------------------------------------------------------</span>
<span> Bitmap Heap Scan on sale_fact  (cost=13.11..1135.61 rows=4319 width=41)</span>
<span>   Recheck Cond: ((sold_at &gt;= '2020-07-01'::date) AND (sold_at &lt;= '2020-07-31'::date))</span>
<span><span>   Rows Removed by Index Recheck: 23130</span>
</span><span>   Heap Blocks: lossy=256</span>
<span>   -&gt;  Bitmap Index Scan on sale_fact_sold_at_bix  (cost=0.00..12.03 rows=12500 width=0)</span>
<span>         Index Cond: ((sold_at &gt;= '2020-07-01'::date) AND (sold_at &lt;= '2020-07-31'::date))</span>
<span> Execution Time: 8.877 ms</span>
</pre></div>


<p>The database used our BRIN index to get a range of sale dates, but that's not the interesting part...</p>
<p><strong>Optimizing <code>pages_per_range</code></strong></p>
<p>According to the execution plan, the database removed 23,130 rows from the pages it found using the index. This may indicate that the range we set for the index it too large for this particular query. Let's try to create an index with less pages per range:</p>
<div><pre><span></span><span>db=#</span> <span>CREATE</span> <span>INDEX</span> <span>sale_fact_sold_at_bix64</span> <span>ON</span> <span>sale_fact</span>
<span><span>db-#</span> <span>USING</span> <span>BRIN</span><span>(</span><span>sold_at</span><span>)</span> <span>WITH</span> <span>(</span><span>pages_per_range</span> <span>=</span> <span>64</span><span>);</span>
</span><span>CREATE INDEX</span>

<span>db=#</span> <span>EXPLAIN</span> <span>(</span><span>ANALYZE</span><span>)</span>
<span>db</span><span>-</span> <span>SELECT</span> <span>*</span>
<span>db</span><span>-</span> <span>FROM</span> <span>sale_fact</span>
<span>db</span><span>-</span> <span>WHERE</span> <span>sold_at</span> <span>BETWEEN</span> <span>'2020-07-01'</span> <span>AND</span> <span>'2020-07-31'</span><span>;</span>
<span>                                        QUERY PLAN</span>
<span>---------------------------------------------------------------------------------------------</span>
<span> Bitmap Heap Scan on sale_fact  (cost=13.10..1048.10 rows=4319 width=41)</span>
<span>   Recheck Cond: ((sold_at &gt;= '2020-07-01'::date) AND (sold_at &lt;= '2020-07-31'::date))</span>
<span><span>   Rows Removed by Index Recheck: 9434</span>
</span><span>   Heap Blocks: lossy=128</span>
<span>   -&gt;  Bitmap Index Scan on sale_fact_sold_at_bix64  (cost=0.00..12.02 rows=6667 width=0)</span>
<span>         Index Cond: ((sold_at &gt;= '2020-07-01'::date) AND (sold_at &lt;= '2020-07-31'::date))</span>
<span> Execution Time: 5.491 ms</span>
</pre></div>


<p>With 64 pages per range the database removed less rows from the pages it found using the the index, only 9,434 were removed compared with 23,130 when the the range was 128 pages. This means the database had to do less IO and the query was slightly faster, ~5.5ms compared to ~8.9ms.</p>
<p>Testing the index with different values for <code>pages_per_range</code> produced the following results:</p>
<table>
<thead>
<tr>
<th>pages_per_range</th>
<th>Rows Removed by Index Recheck</th>
</tr>
</thead>
<tbody>
<tr>
<td>128</td>
<td>23,130</td>
</tr>
<tr>
<td>64</td>
<td>9,434</td>
</tr>
<tr>
<td>8</td>
<td>874</td>
</tr>
<tr>
<td>4</td>
<td>446</td>
</tr>
<tr>
<td>2</td>
<td>446</td>
</tr>
</tbody>
</table>
<p>We can see that as we decrease <code>pages_per_range</code>, the index is more accurate and less rows are removed from the pages found using the index.</p>
<p>Note that we optimized the query for a very specific query. This is fine for demonstration purposes, but in real life it's best to use values that meet the needs of most queries.</p>
<p><strong>Evaluating Index Size</strong></p>
<p>Another big selling point for BRIN indexes is their size. In previous sections we created a B-Tree index on the <code>sold_at</code> field. The size of the index was 2224kB. The size a BRIN index with <code>pages_per_range=128</code> is only 48kb. That's 46 times smaller than the B-Tree index.</p>
<div><pre><span></span> Schema |         Name          | Type  | Owner |   Table   | Size
--------+-----------------------+-------+-------+-----------+-------
 public | sale_fact_sold_at_bix | index | haki  | sale_fact | 48 kB
 public | sale_fact_sold_at_ix  | index | haki  | sale_fact | 2224 kB
</pre></div>


<p>The size of a BRIN index is also affected by <code>pages_per_range</code>. For example, a BRIN index with <code>pages_per_range=2</code> weighs 56kb, which is only slightly bigger than 48kb.</p>
<hr>
<h2 id="make-indexes-invisible"><a href="#make-indexes-invisible">Make Indexes "Invisible"</a></h2>
<p>PostgreSQL has a nice feature called <a href="https://wiki.postgresql.org/wiki/Transactional_DDL_in_PostgreSQL:_A_Competitive_Analysis#Transactional_DDL" rel="noopener">transactional DDL</a>. After years of using Oracle, I got used to DDL commands such as <code>CREATE</code>, <code>DROP</code> and <code>ALTER</code> ending a transaction. However, in PostgreSQL you can perform DDL commands inside a transaction, and changes will take effect only when the transaction is committed.</p>
<p>As I <a href="https://twitter.com/be_haki/status/1282585977668751360?s=20" rel="noopener">recently discovered</a>, using transactional DDL you can make indexes invisible! This comes in handy when you want to see what an execution plan looks like without some index.</p>
<p>For example, in the <code>sale_fact</code> table from the previous section we created an index on <code>sold_at</code>. The execution plan for fetching sales made in July looked like this:</p>
<div><pre><span></span><span>db=#</span> <span>EXPLAIN</span>
<span>db-#</span> <span>SELECT</span> <span>*</span>
<span>db-#</span> <span>FROM</span> <span>sale_fact</span>
<span>db-#</span> <span>WHERE</span> <span>sold_at</span> <span>BETWEEN</span> <span>'2020-07-01'</span> <span>AND</span> <span>'2020-07-31'</span><span>;</span>
<span>                                         QUERY PLAN</span>
<span>--------------------------------------------------------------------------------------------</span>
<span><span> Index Scan using sale_fact_sold_at_ix on sale_fact  (cost=0.42..182.80 rows=4319 width=41)</span>
</span><span>   Index Cond: ((sold_at &gt;= '2020-07-01'::date) AND (sold_at &lt;= '2020-07-31'::date))P</span>
</pre></div>


<p>To see what the execution plan would be if the index <code>sale_fact_sold_at_ix</code> did not exist, we can drop the index inside a transaction and immediately rollback:</p>
<div><pre><span></span><span><span>db=#</span> <span>BEGIN</span><span>;</span>
</span><span>BEGIN</span>

<span>db=#</span> <span>DROP</span> <span>INDEX</span> <span>sale_fact_sold_at_ix</span><span>;</span>
<span>DROP INDEX</span>

<span>db=#</span> <span>EXPLAIN</span>
<span>db-#</span> <span>SELECT</span> <span>*</span>
<span>db-#</span> <span>FROM</span> <span>sale_fact</span>
<span>db-#</span> <span>WHERE</span> <span>sold_at</span> <span>BETWEEN</span> <span>'2020-07-01'</span> <span>AND</span> <span>'2020-07-31'</span><span>;</span>
<span>                                   QUERY PLAN</span>
<span>---------------------------------------------------------------------------------</span>
<span><span> Seq Scan on sale_fact  (cost=0.00..2435.00 rows=4319 width=41)</span>
</span><span>   Filter: ((sold_at &gt;= '2020-07-01'::date) AND (sold_at &lt;= '2020-07-31'::date))</span>

<span><span>db=#</span> <span>ROLLBACK</span><span>;</span>
</span><span>ROLLBACK</span>
</pre></div>


<p>We first start a transaction using <code>BEGIN</code>. Then we drop the index and generate an execution plan. Notice that the execution plan now uses a full table scan, as if the index does not exist. At this point the transaction is still in progress, so the index is not dropped yet. To finish the transaction without dropping the index we rollback the transaction using the <code>ROLLBACK</code> command.</p>
<p>Now, make sure the index still exists:</p>
<div><pre><span></span><span>db=#</span> <span>\di+</span> <span>sale_fact_sold_at_ix</span>
<span>                                 List of relations</span>
<span> Schema |         Name         | Type  | Owner |   Table   |  Size</span>
<span>--------+----------------------+-------+-------+-----------+---------</span>
<span> public | sale_fact_sold_at_ix | index | haki  | sale_fact | 2224 kB</span>
</pre></div>


<p>Other database that don't support transactional DDL provide other ways to achieve the same goal. For example, Oracle let's you mark an index as <a href="https://docs.oracle.com/cd/B28359_01/server.111/b28310/indexes003.htm#ADMIN12317" rel="noopener">invisible</a>, which will cause the optimizer to ignore it.</p>
<p><strong>CAUTION</strong>: Dropping an index inside a transaction will lock out concurrent selects, inserts, updates, and deletes on the table while the transaction is active. Use with caution in test environments, and avoid on production databases.</p>
<hr>
<h2 id="dont-schedule-long-running-processes-at-round-hours"><a href="#dont-schedule-long-running-processes-at-round-hours">Don't Schedule Long Running Processes at Round Hours</a></h2>
<p>It's a known fact among investors that weird things can happen when a stock's price reaches a nice round number such as 10$, 100$, 1000$. As <a href="https://www.investopedia.com/trading/support-and-resistance-basics/#mntl-sc-block_1-0-38" rel="noopener">the following article</a> explains:</p>
<blockquote>
<p>[...] asset's price may have a difficult time moving beyond a round number, such as $50 or $100 per share. Most inexperienced <strong>traders tend to buy or sell assets when the price is at a whole number</strong> because they are more likely to feel that a stock is fairly valued at such levels.</p>
</blockquote>
<p>Developers in this sense are not all that different than the investors. When they need to schedule a long running process, they will usually schedule it at a round hour.</p>
<figure>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 370 138.4" width="30em"><path d="M42 120l318-1m-316 0l315-1M332 129l27-12m-28 12l29-11M332 108c9 3 15 8 27 9m-28-9l29 10" stroke="currentColor" fill="none"></path><path d="M48 90l15 4-1 18-14 2" fill="#f41d92"></path><path d="M48 91h15m-14 2h14m-1-2c1 5-1 9 1 20m-1-19l1 20m-1 0c-2 2-8 1-12-1m12 2H48m0 1c0-11-2-16 2-22m-2 20V92" stroke="currentColor" fill="none"></path><path d="M65 90l18-1-2 24H69" fill="#f41d92"></path><path d="M66 90h14m-12 0l13-1m-2 1v23m2-24l-1 24m0 1l-14-1m15 0c-3-1-7 0-14 1m2-2c-4-6-1-8-2-21m0 22V89" stroke="currentColor" fill="none"></path><path d="M88 32l13-2v84l-14-1" fill="#f41d92"></path><path d="M88 31c4 0 11-1 14 1m-15-1l14-1m2 0c-2 16-1 33-2 83m1-83l-1 82m2 1c-7-1-11-2-16-1m15 1l-14-1m-2-1c-1-25 3-53 2-79m-1 81V30" stroke="currentColor" fill="none"></path><path d="M108 89l12 1 2 20-14 2" fill="#f41d92"></path><path d="M106 89h16m-15 1l13-1m0 0c-1 8-1 12 1 20m-1-18v20m2-1c-6 2-11 0-16 1m15-1l-15 1m-1-3c2-1 1-8 3-19m-1 22c0-7 0-13-2-21" stroke="currentColor" fill="none"></path><path d="M125 87l14 2v23l-12-1" fill="#f41d92"></path><path d="M125 87c3-1 7 1 13 1m-12-1h12m0-1c2 5 1 12 0 25m2-24v24m-1 0l-13-1m12 1h-12m-3 0c4-10 4-17 2-24m1 24V88" stroke="currentColor" fill="none"></path><path d="M143 94h14v18l-13-3" fill="#f41d92"></path><path d="M144 94c3 0 10-1 12 1m-12-1h11m-1 1c0 5 2 10 1 15m1-16l-1 16m0 2h-12m13-1h-12m0 2V93m0 17V94" stroke="currentColor" fill="none"></path><path d="M159 93h12l1 19h-14" fill="#f41d92"></path><path d="M160 91l12 1m-12 0h10m2-2c-2 8-2 12-2 22m1-21c0 5 1 11-1 21m2-2l-12 2m11-1h-11m1 0l-3-20m1 20V91" stroke="currentColor" fill="none"></path><path d="M197 87l13 2-1 20h-13" fill="#f41d92"></path><path d="M194 88c6-2 9 0 16 0m-15-1h14m-2 0c2 5 1 12 2 23m-1-23l2 25m-2-1l-12 1m13 0l-14-2m0 2c1-6 0-12-1-23m1 22V87" stroke="currentColor" fill="none"></path><path d="M213 95h14l-3 17-12 1" fill="#f41d92"></path><path d="M214 95h12m-13-1h12m0 1v17m0-18l1 17m-1 0l-11-1m12 1h-13m2 1c-2-6-3-13 0-16m-2 14V95" stroke="currentColor" fill="none"></path><path d="M230 93l11-3v20l-10 2" fill="#f41d92"></path><path d="M230 91c3 2 7 1 11 1m-12-1h11m1 0c-1 7 0 14 1 21m-2-19v19m0 0h-12m12 0h-11m2-1c-2-9-3-14 0-19m-3 20c2-5 1-10 2-20" stroke="currentColor" fill="none"></path><path d="M247 88h11v25l-11-3" fill="#f41d92"></path><path d="M245 88h15m-14 0h13m0 0l1 24m1-24c-2 6-1 10-1 25m0-2c-3 1-6-1-13 1m13-1l-14 1m-1-1c-1-7 2-11 2-25m-1 26V88" stroke="currentColor" fill="none"></path><path d="M265 93h12l1 19-15 1" fill="#f41d92"></path><path d="M265 96l12-1m-13-1h13m-1 0v16m0-16l1 17m-2 1h-10m11 0h-11m-1-2c0-3 2-10-1-15m2 16V95" stroke="currentColor" fill="none"></path><g><path d="M279 93l11 1 2 17-10 3" fill="#f41d92"></path><path d="M281 93c4 0 8 0 11-2m-12 2l11-1m0 0c0 8 1 14-1 19m1-18c2 4 1 10 0 19m1 0c-3-1-6 0-11 1m11-1h-12m-1-1c3-5 2-15 2-19m-1 20l1-19" stroke="currentColor" fill="none"></path></g><g><path d="M298 34l16 3-3 76-12-1" fill="#f41d92"></path><path d="M298 37l13-2m-13 1l14 1m0-1c2 20 0 36-1 74m2-73l-1 74m1 1c-7 0-11 0-14-2m13 1l-14 1m-1 1c2-21-1-41 0-79m0 77l1-76" stroke="currentColor" fill="none"></path></g><g><path d="M177 9l15 2-1 100-14-1" fill="#f41d92"></path><path d="M176 10l14-1m-15 1h15m1 0c-2 31-2 65-1 100m1-99l-1 101m1-1l-15 2m15-1l-15-1m0-1c0-25-3-50 2-101m-2 103c1-29-1-58-1-101" stroke="currentColor" fill="none"></path></g><g><path d="M12 115l-1 12m3-13l-4 11" stroke="currentColor" fill="none"></path></g><g><path d="M15 115l7 13m-9-11l11 10" stroke="currentColor" fill="none"></path></g><g><path d="M21 123H10m11 0H10" stroke="currentColor" fill="none"></path></g><g><path d="M27 114l-1 14m3-15l-1 13" stroke="currentColor" fill="none"></path></g><g><path d="M27 114l5 7m-4-5l3 7" stroke="currentColor" fill="none"></path></g><g><path d="M36 115l-3 4m2-4l-2 5" stroke="currentColor" fill="none"></path></g><g><path d="M34 118l3 7m-2-8l4 6" stroke="currentColor" fill="none"></path></g><g><path d="M94 115l1 11m-1-11l1 11" stroke="currentColor" fill="none"></path></g><g><path d="M184 114v11m0-11v11" stroke="currentColor" fill="none"></path></g><g><path d="M305 114l1 11m-1-11l1 11" stroke="currentColor" fill="none"></path></g></svg>
<figcaption>Typical load on a system during the night</figcaption>
</figure>

<p>This tendency to schedule tasks at round hours can cause some unusual loads during these times. So, if you need to schedule some long running process, you have a better chance of finding a system at rest if you schedule at another time.</p>
<p>Another good idea is to apply a random delay to the task's schedule, so it doesn't run at the same time every time. This way, even if another task is scheduled to run at the same time, it won't be a big problem. If you use <code>systemd</code> timer units to schedule your tasks, you can use the <a href="https://www.freedesktop.org/software/systemd/man/systemd.timer.html#RandomizedDelaySec=" rel="noopener">RandomizedDelaySec</a> option for this.</p>
<hr>
<h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2>
<p>This article covers some trivial and non-trivial tips from my own experience. Some of these tips are easy to implement, and some require a deeper understanding of how the database works. Databases are the backbone of most modern systems, so taking some time to understand how they work is a good investment for any developer!</p>
<p><em>This article was reviewed by the great team at <a href="https://www.pgmustard.com/" rel="noopener">pgMustard</a></em></p>
    </article></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>