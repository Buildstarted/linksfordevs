<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Take C# 8.0 for a spin -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Take C# 8.0 for a spin</h1><div><div class="entry-content col-12 sharepostcontent"><h1 class="entry-title">Take C# 8.0 for a spin</h1><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/02/MadsTorgersen.jpeg" width="58" height="58" alt="Mads Torgersen - MSFT" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 alignnone photo"><p>Mads</p></div></div></div><p>December 5th, 2018</p><h1>Take C# 8.0 for a spin</h1><p>Yesterday we announced the first preview of both Visual Studio 2019 (<a href="https://blogs.msdn.microsoft.com/visualstudio/2018/12/04/making-every-developer-more-productive-with-visual-studio-2019/">Making every developer more productive with Visual Studio 2019</a>) and .NET Core 3.0 (<a href="https://blogs.msdn.microsoft.com/dotnet/2018/12/04/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/">Announcing .NET Core 3 Preview 1 and Open Sourcing Windows Desktop Frameworks</a>). One of the exciting aspects of that is that you get to play with some of the features coming in C# 8.0! Here I am going to take you on a little guided tour through three new C# features you can try out in the preview. Not all C# 8.0 features are available yet. If you want an overview of all the major features, go read the recent post <a href="https://blogs.msdn.microsoft.com/dotnet/2018/11/12/building-c-8-0/">Building C# 8.0</a>, or check the short (13 mins) video “What’s new in C# 8.0” on <a href="https://channel9.msdn.com/events/Connect/Microsoft-Connect--2018/D140">Channel 9</a> or <a href="https://www.youtube.com/watch?v=VdC0aoa7ung&amp;list=PLReL099Y5nRcDayMMgYIA6q7lMbqXz_Gv&amp;index=16">YouTube</a>.</p><h1>Getting ready</h1><p>First of all, download and install <a href="https://aka.ms/netcore3download">Preview 1 of .NET Core 3.0</a> and <a href="https://visualstudio.microsoft.com/vs/preview/">Preview 1 of Visual Studio 2019</a>. In Visual Studio, make sure you select the workload “.NET Core cross-platform development” (if you forgot, you can just add it later by opening the Visual Studio Installer and clicking “Modify” on the Visual Studio 2019 Preview channel). Launch Visual Studio 2019 Preview, Create a new project, and select “Console App (.NET Core)” as the project type. Once the project is up and running, change its target framework to .NET Core 3.0 (right click the project in Solution Explorer, select Properties and use the drop down menu on the Application tab). Then select C# 8.0 as the language version (on the Build tab of the project page click “Advanced…” and select “C# 8.0 (beta)”). Now you have all the language features and the supporting framework types ready at your fingertips!</p><h1>Nullable reference types</h1><p>The nullable reference types feature intends to warn you about null-unsafe behavior in the code. Since we didn’t do that before, it would be a breaking change to just start now! To avoid that, you need to opt in to the feature. Before we do turn it on, though, let’s write some really bad code:</p><pre class="lang:default decode:true">using static System.Console;

class Program
{
    static void Main(string[] args)
    {
        string s = null;
        WriteLine($"The first letter of {s} is {s[0]}");
    }
}
</pre><p>If you run it you get, of course, a null reference exception. You’ve fallen into the black hole! How were you supposed to know not to dereference <code>s</code> in that particular place? Well duh, because null was assigned to it on the previous line. But in real life, it’s not on the previous line, but in somebody else’s assembly running on the other side of the planet three years after you wrote your line of code. <em>How could you have known not to write that?</em></p><p>That’s the question that nullable reference types set out to answer! So let’s turn them on! For a new project you should just turn them on right away. In fact I think they should probably be on by default in new projects, but we didn’t do that in the preview. The way to turn them on is to add the following line to your .csproj file, e.g. right after the LanguageVersion that was just inserted when you switched to C# 8.0 above:</p><pre class="lang:default decode:true">&lt;Nullable&gt;enable&lt;/Nullable&gt;
</pre><p>Save the .csproj file and return to your program: What happened? You got two warnings! Each represents one “half” of the feature. Let’s look at them in turn. The first one is on the <code>null</code> in this line:</p><pre class="lang:default decode:true">string s = null;
</pre><p>It complains that you are assigning null to a “non-nullable type”: Whaaat?!? When the feature is turned on <em>nulls are no longer welcome in ordinary reference types</em> such as <code>string</code>! Because, you know what, <em>null is not a string</em>! We’ve been pretending for the last fifty years of object-oriented programming, but actually null is in fact not an object: That’s why everything explodes whenever you try to treat it like one! So no more of that: null is verboten, unless you ask for it.</p><p>How <em>do</em> you ask for it? By using a nullable reference type, such as <code>string?</code>. The trailing question mark signals that null is allowed:</p><pre class="lang:default decode:true">string? s = null;
</pre><p>The warning goes away: we have explicitly expressed the intent for this variable to hold null, so now it’s fine.</p><p>Until the next line of code! On the line</p><pre class="lang:default decode:true">WriteLine($"The first letter of {s} is {s[0]}");
</pre><p>It complains about the <code>s</code> in <code>s[0]</code> that you may be dereferencing a null reference. And sure enough: you are! Well done, compiler! How do you fix it, though? Well that’s pretty much up to you – whichever way you would always have fixed it! Let’s try for starters to only execute the line when <code>s</code> is not null:</p><pre class="lang:default decode:true">if (s != null) WriteLine($"The first letter of {s} is {s[0]}");
</pre><p>The warning goes away! Why? Because the compiler can see that you only go to the offending code when <code>s</code> is <em>not</em> null. It actually does a full flow analysis, tracking every variable across every line of code to keep tabs on where it might be null and where it probably won’t be. It watches your tests and assignments, and does the bookkeeping. Let’s try another version:</p><pre class="lang:default decode:true">WriteLine($"The first letter of {s} is {s?[0] ?? '?'}");
</pre><p>This uses the null conditional indexing operator <code>s?[0]</code> which avoids the dereference and produces a null if <code>s</code> is null. Now we have a nullable <code>char?</code>, but the null-coalescing operator <code>?? '?'</code> replaces a null value with the <code>char</code><code>'?'</code>. So all null dereferences are avoided. The compiler is happy, and no warnings are given.</p><p>As you can see, the feature keeps you honest while you code: it forces you to express your intent whenever you want null in the system, by using a nullable reference type. And once null is there, it forces you to deal with it responsibly, making you check whenever there’s a risk that a null value may be dereferenced to trigger a null reference exception.</p><p>Are you completely null-safe now? No. There are a couple of ways in which a null may slip through and cause a null reference exception:</p><ul><li>If you call code that didn’t have the nullable reference types feature on (maybe it was compiled before the feature even existed), then we cannot know what the intent of that code was: it doesn’t distinguish between nullable and nonnullable – we say that it is “null-oblivious”. So we give it a pass; we simply don’t warn on such calls.</li><li>The analysis itself has certain holes. Most of them are a trade-off between safety and convenience; if we complained, it would be really hard to fix. For instance, when you write <code>new string[10]</code>, we create an array full of nulls, typed as non-null <code>string</code>s. We don’t warn on that, because how would the compiler keep track of you initializing all the array elements?</li></ul><p>But on the whole, if you use the feature extensively (i.e. turn it on everywhere) it should take care of the vast majority of null dereferences.</p><p>It is definitely our intention that you should start using the feature on existing code! Once you turn it on, you may get a lot of warnings. Some of these actually represent a problem: Yay, you found a bug! Some of them are maybe a bit annoying; your code is clearly null safe, you just didn’t have the tools to express your intent when you wrote it: you didn’t have nullable reference types! For instance, the line we started out with:</p><pre class="lang:default decode:true">string s = null;
</pre><p>That’s going to be super common in existing code! And as you saw, we did get a warning on the next line, too, where we tried to dereference it. So the assignment warning here is strictly speaking superfluous from a safety standpoint: It keeps you honest in <em>new</em> code, but fixing all occurences in <em>existing</em> code would not make it any safer. For that kind of situation we are working on a mode where certain warnings are turned off, when it doesn’t impact the null safety, so that it is less daunting to upgrade existing code.</p><p>Another feature to help upgrade is that you can turn the feature on or off “locally” in your code, using compiler directives <code>#nullable enable</code> and <code>#nullable disable</code>. That way you can go through your project and deal with annotations and warnings gradually, piece by piece.</p><p>To learn more about nullable reference types check out the <a href="https://docs.microsoft.com/dotnet/csharp/nullable-references">Overview of Nullable types</a> and the <a href="https://docs.microsoft.com/dotnet/csharp/tutorials/nullable-reference-types">Introduction to nullable tutorial</a> on <a href="https://docs.microsoft.com">docs.microsoft.com</a>. For a deeper design rationale, last year I wrote a post <a href="https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/">Introducing Nullable Reference Types in C#</a>. If you want to immerse yourself in the day-to-day of the design work, look at the <a href="https://github.com/dotnet/csharplang/blob/master/meetings/2018/README.md">Language Design Notes</a> on GitHub, or follow along as I try to put together a <a href="https://github.com/dotnet/csharplang">Nullable Reference Types Specification</a>.</p><h1>Ranges and indices</h1><p>C# is getting more expressiveness around working with indexed data structures. Ever wanted simple syntax for slicing out a part of an array, string or span? Now you can! Go ahead and change your program to the following:</p><pre class="lang:c# decode:true">using System.Collections.Generic;
using static System.Console;

class Program
{
    static void Main(string[] args)
    {
        foreach (var name in GetNames())
        {
            WriteLine(name);
        }
    }

    static IEnumerable&lt;string&gt; GetNames()
    {
        string[] names =
        {
            "Archimedes", "Pythagoras", "Euclid", "Socrates", "Plato"
        };
        foreach (var name in names)
        {
            yield return name;
        }
    }
}
</pre><p>Let’s go to that bit of code that iterates over the array of names. Modify the <code>foreach</code> as follows:</p><pre class="lang:default decode:true">foreach (var name in names[1..4])
</pre><p>It looks like we’re iterating over names 1 to 4. And indeed when you run it that’s what happens! The endpoint is <em>exclusive</em>, i.e. element 4 is not included. <code>1..4</code> is actually a range expression, and it doesn’t have to occur like here, as part of an indexing operation. It has a type of its own, called <code>Range</code>. If we wanted, we could pull it out into its own variable, and it would work the same:</p><pre class="lang:default decode:true">Range range = 1..4; 
        foreach (var name in names[range])
</pre><p>The endpoints of a range expression don’t have to be ints. In fact they’re of a type, <code>Index</code>, that non-negative ints convert to. But you can also create an <code>Index</code> with a new <code>^</code> operator, meaning “from end”. So <code>^1</code> is one from the end:</p><pre class="lang:default decode:true">foreach (var name in names[1..^1])
</pre><p>This lobs off an element at each end of the array, producing an array with the middle three elements. Range expressions can be open at either or both ends. <code>..^1</code> means the same as <code>0..^1</code>. <code>1..</code> means the same as <code>1..^0</code>. And <code>..</code> means the same as <code>0..^0</code>: beginning to end. Try them all out and see! Try mixing and matching “from beginning” and “from end” <code>Index</code>es at either end of a <code>Range</code> and see what happens.</p><p>Ranges aren’t just meant for use in indexers. For instance, we plan to have overloads of <code>string.SubString</code>, <code>Span&lt;T&gt;.Slice</code> and the <code>AsSpan</code> extension methods that take a <code>Range</code>. Those aren’t in this Preview of .NET Core 3.0 though.</p><h1>Asynchronous streams</h1><p><code>IEnumerable&lt;T&gt;</code> plays a special role in C#. “IEnumerables” represent all kinds of different sequences of data, and the language has special constructs for consuming and producing them. As we see in our current program, they are consumed through the <code>foreach</code> statement, which deals with the drudgery of obtaining an enumerator, advancing it repeatedly, extracting the elements along the way, and finally disposing the enumerator. And they can be produced with <em>iterators</em>: Methods that <code>yield return</code> their elements as they are being asked for by a consumer.</p><p>Both are synchronous, though: the results better be ready when they are asked for, or the thread blocks! <code>async</code> and <code>await</code> were added to C# to deal with results that are <em>not</em> necessarily ready when you ask for them. They can be asynchronously <code>await</code>ed, and the thread can go do other stuff until they become available. But that works only for single values, not sequences that are gradually and asynchronously produced over time, such as for instance measurements from an IoT sensor or streaming data from a service. Asynchronous streams bring async and enumerables together in C#! Let’s see how, by gradually “async’ifying” our current program.</p><p>First, let’s add another <code>using</code> directive at the top of the file:</p><pre class="lang:default decode:true">using System.Threading.Tasks;
</pre><p>Now let’s simulate that <code>GetNames</code> does some asynchronous work by adding an asynchronous delay before the name is <code>yield return</code>ed:</p><pre class="lang:default decode:true">await Task.Delay(1000);
            yield return name;
</pre><p>Of course we get an error that you can only <code>await</code> in an <code>async</code> method. So let’s make it async:</p><pre class="lang:default decode:true">static async IEnumerable&lt;string&gt; GetNames()
</pre><p>Now we’re told that we’re not returning the right type for an async method, which is fair. But there’s a new candidate on the list of types it <em>can</em> return besides the usual <code>Task</code> stuff: <code>IAsyncEnumerable&lt;T&gt;</code>. <em>This is our async version of <code>IEnumerable&lt;T&gt;</code></em>! Let’s return that:</p><pre class="lang:default decode:true">static async IAsyncEnumerable&lt;string&gt; GetNames()
</pre><p>Just like that we’ve produced an asynchronous stream of strings! In accordance with naming guidelines, let’s rename <code>GetNames</code> to <code>GetNamesAsync</code>.</p><pre class="lang:default decode:true">static async IAsyncEnumerable&lt;string&gt; GetNamesAsync()
</pre><p>Now we get an error on this line in the <code>Main</code> method:</p><pre class="lang:default decode:true">foreach (var name in GetNamesAsync())
</pre><p>Which doesn’t know how to foreach over an <code>IAsyncEnumerable&lt;T&gt;</code>. That’s because foreach’ing over asynchronous streams requires explicit use of the <code>await</code> keyword:</p><pre class="lang:default decode:true">await foreach (var name in GetNamesAsync())
</pre><p>It’s the version of foreach that takes an async stream and awaits every element! Of course it can only do that in an async method, so we have to make our <code>Main</code> method async. Fortunately C# 7.2 added support for that:</p><pre class="lang:default decode:true">static async Task Main(string[] args)
</pre><p>Now all the squiggles are gone, and the program is correct. But if you try compiling and running it, you get an embarassing number of errors. That’s because we messed up a bit, and didn’t get the previews of .NET Core 3.0 and Visual Studio 2019 perfectly aligned. Specifically, there’s an implementation type that async iterators leverage that’s different from what the compiler expects. You can fix this by adding a separate source file to your project, containing <a href="https://github.com/dotnet/coreclr/issues/21379#issuecomment-444473061">this bridging code</a>. Compile again, and everything should work just fine.</p><h1>Next steps</h1><p>Please let us know what you think! If you try these features and have ideas for how to improve them, please use the feedback button in the Visual Studio 2019 Preview. The whole purpose of a preview is to have a last chance to course correct, based on how the features play out in the hands of real life users, so <em>please let us know!</em></p><p>Happy hacking,</p><p>Mads Torgersen, Design Lead for C#</p><div class="authorinfoarea"></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>