<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Intel Processor Trace Part3. Analyzing performance glitches. -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Intel Processor Trace Part3. Analyzing performance glitches.</h1><div><div class="notebody"><p><strong>Contents:</strong></p><hr><p><strong>Subscribe to my <a href="/blog/2019/09/06/Intel-PT-part3#mc_embed_signup">mailing list</a> and support me on <a href="https://www.patreon.com/dendibakh">Patreon</a>.</strong></p><hr><p>This is the third part of my series about Intel Processor Traces (PT). In the <a href="https://easyperf.net/blog/2019/08/23/Intel-Processor-Trace">first part</a> of this series I showed the underlying mechanics of this HW feature. In the <a href="https://easyperf.net/blog/2019/08/30/Intel-PT-part2">second part</a> I showed 2 ways how PT can enhance your debugging experience.</p><p>Here is the list of all parts in the series of posts about Intel PT:</p><ol><li>Part1: <a href="https://easyperf.net/blog/2019/08/23/Intel-Processor-Trace">Introduction to Intel Processor Trace</a>.</li><li>Part2: <a href="https://easyperf.net/blog/2019/08/30/Intel-PT-part2">Better debugging experience with Intel PT</a>.</li><li>Part3: Analyzing performance glitches with Intel PT (this article).</li><li>Part4: <a href="https://easyperf.net/blog/2019/09/13/Intel-PT-part4">Better profiling experience with Intel PT</a>.</li></ol><p>In this article we will focus more on the performance side of this CPU feature.</p><h3 id="analyzing-performance-glitches">Analyzing performance glitches</h3><p>Imagine a situation when you’re a developer of an application. Everything works smoothly in general, besides one little thing. Users of the application claim that sometimes they observe glitches in the application performance. Often times this is quite hard to fix, since it won’t be exposed as a hotspot when you profile the app. Also, it’s hard to isolate and extract it to the standalone benchmark, since performance glitches happen rarely, and the root cause may be not obvious. <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p><p>To demonstrate how Intel PT can help in this case, I created a small example in which I calculate the <a href="https://cseweb.ucsd.edu/groups/tatami/kumo/exs/sum/">sum of the first N natural numbers</a>. There is intentionally fast and slow path of the algorithm. Here is the code:</p><p>a.cpp:</p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="cp">#include &lt;random&gt;
</span><span class="kt">int</span><span class="nf">goFastPath</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="n">arr</span><span class="p">,</span><span class="kt">int</span><span class="n">n</span><span class="p">);</span><span class="kt">int</span><span class="nf">goSlowPath</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="n">arr</span><span class="p">,</span><span class="kt">int</span><span class="n">n</span><span class="p">);</span><span class="kt">int</span><span class="nf">main</span><span class="p">()</span><span class="p">{</span><span class="kt">int</span><span class="n">arr</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="p">{</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="p">}</span><span class="k">const</span><span class="kt">int</span><span class="n">min</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="k">const</span><span class="kt">int</span><span class="n">max</span><span class="o">=</span><span class="mi">999</span><span class="p">;</span><span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span><span class="n">generator</span><span class="p">;</span><span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">distribution</span><span class="p">(</span><span class="n">min</span><span class="p">,</span><span class="n">max</span><span class="p">);</span><span class="c1">// counting sum up to N</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="p">{</span><span class="kt">int</span><span class="n">random_int</span><span class="o">=</span><span class="n">distribution</span><span class="p">(</span><span class="n">generator</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="n">random_int</span><span class="o">&lt;</span><span class="mi">999</span><span class="p">)</span><span class="n">goFastPath</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">random_int</span><span class="p">);</span><span class="k">else</span><span class="n">goSlowPath</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">random_int</span><span class="p">);</span><span class="p">}</span><span class="k">return</span><span class="mi">0</span><span class="p">;</span><span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure><p>b.cpp:</p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="kt">int</span><span class="nf">goFastPath</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="n">arr</span><span class="p">,</span><span class="kt">int</span><span class="n">n</span><span class="p">)</span><span class="p">{</span><span class="k">return</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="p">}</span><span class="kt">int</span><span class="nf">goSlowPath</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="n">arr</span><span class="p">,</span><span class="kt">int</span><span class="n">n</span><span class="p">)</span><span class="p">{</span><span class="kt">int</span><span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">res</span><span class="o">+=</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="k">return</span><span class="n">res</span><span class="p">;</span><span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure><p>The idea is that 99.9% of the time we are using the fast path which only takes a few CPU cycles. But in 0.1% of the time we will fall back to the slow path which can take as much as 1000 cycles. <sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup></p><p>Here is how I build the executable: <sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup></p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>g++ a.cpp <span class="nt">-c</span><span class="nt">-O2</span><span class="nt">-g</span><span class="nv">$ </span>g++ b.cpp <span class="nt">-c</span><span class="nt">-O2</span><span class="nt">-g</span><span class="nv">$ </span>g++ a.o b.o
<span class="nv">$ </span><span class="nb">time</span> ./a.out
real	0m0.007s
user	0m0.007s
sys	0m0.000s
</code></pre></div></div><p>Now let’s collect the traces:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>perf record <span class="nt">-e</span> intel_pt/cyc<span class="o">=</span>1/u ./a.out
<span class="o">[</span> perf record: Woken up 1 <span class="nb">times </span>to write data <span class="o">]</span><span class="o">[</span> perf record: Captured and wrote 0.548 MB perf.data <span class="o">]</span></code></pre></div></div><p>Notice that I used <code class="language-plaintext highlighter-rouge">cyc=1</code> to have the finest granularity available. This option asks the CPU to produce timing packets every cycle. <sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup></p><p>To decode the traces into human readable form use the command below:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>perf script <span class="nt">--ns</span><span class="nt">--itrace</span><span class="o">=</span>i1t <span class="nt">-F</span> +srcline,+srccode <span class="o">&gt;</span> decoded.dump
</code></pre></div></div><p>Before going into the output, let me explain what those options mean. Option <code class="language-plaintext highlighter-rouge">--ns</code> will show the timestamps in nanoseconds. Option <code class="language-plaintext highlighter-rouge">-F +srcline,+srccode</code> will add source line and source code for each decoded assembly instruction. Option <code class="language-plaintext highlighter-rouge">--trace=i1t</code> is a little more difficult to explain. This option specifies a period on which decoder will sample our traces. In my case I asked to sample every clocktick, i.e. it will output each instruction separately and put a timestamp for it. See <code class="language-plaintext highlighter-rouge">man perf script</code> for more details and footnotes<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup> for more examples.</p><p>Here is what the decoded output (in <code class="language-plaintext highlighter-rouge">decoded.dump</code>) might look like: <sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proc   PID   CPU    timestamp       sym+off          srcline   srccode
...
a.out  3172 [007]   253.555413143:  std::uniform_int_distribution&lt;...&gt; &gt;+0xc2  uniform_int_dist.h:281
a.out  3172 [007]   253.555413143:  main+0x78        a.cpp:21  if (random_int &lt; 999)
a.out  3172 [007]   253.555413143:  main+0x7d        a.cpp:22    goFastPath(arr, random_int);
a.out  3172 [007]   253.555413143:  main+0x7f        a.cpp:22
a.out  3172 [007]   253.555413143:  main+0x82        a.cpp:21  if (random_int &lt; 999)
a.out  3172 [007]   253.555413143:  main+0x84        a.cpp:24    goSlowPath(arr, random_int);
a.out  3172 [007]   253.555413143:  goSlowPath+0x0   b.cpp:7   for (int i = 0; i &lt;= n; i++)
a.out  3172 [007]   253.555413143:  goSlowPath+0x2   b.cpp:7
a.out  3172 [007]   253.555413143:  goSlowPath+0x4   b.cpp:7
a.out  3172 [007]   253.555413143:  goSlowPath+0x7   b.cpp:6   int res = 0;
a.out  3172 [007]   253.555413143:  goSlowPath+0x9   b.cpp:6
a.out  3172 [007]   253.555413143:  goSlowPath+0xe   b.cpp:6
a.out  3172 [007]   253.555413143:  goSlowPath+0x10  b.cpp:8     res += arr[i];
a.out  3172 [007]   253.555413143:  goSlowPath+0x12  b.cpp:8
a.out  3172 [007]   253.555413143:  goSlowPath+0x16  b.cpp:7   for (int i = 0; i &lt;= n; i++)
a.out  3172 [007]   253.555413143:  goSlowPath+0x19  b.cpp:7
a.out  3172 [007]   253.555413143:  goSlowPath+0x10  b.cpp:8   res += arr[i];
a.out  3172 [007]   253.555413143:  goSlowPath+0x12  b.cpp:8
a.out  3172 [007]   253.555413143:  goSlowPath+0x16  b.cpp:7   for (int i = 0; i &lt;= n; i++)
a.out  3172 [007]   253.555413143:  goSlowPath+0x19  b.cpp:7
&lt;loop iterations&gt;
a.out  3172 [007]   253.555413508:  goSlowPath+0x19  b.cpp:7
a.out  3172 [007]   253.555413508:  goSlowPath+0x1b  b.cpp:7
a.out  3172 [007]   253.555413508:  main+0x89        a.cpp:19  for (int i = 0; i &lt; 100000; i++) {
...
</code></pre></div></div><p><strong>Having such a trace is very helpful for any kind of analysis</strong>. It allows you to zoom in the exact invocation where the glitch happened and analyze it in isolation. You may further use the timestamp to align it with the other event that was happening at the same moment in the system. Also, you can compare two different invocations of the same function: the one that was fast and the one that was slow. You may then go back in time and compare what was happening before the glitch in both cases and hopefully will find the thing that was different.</p><p>Decoded processor traces won’t be able to show the values of different variables <sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup> but you will get precise control flow. With this information you will know exactly what lead you here and hopefully it will sched some light on what might be causing performance issues. I’m not showing the history here since in our case it’s obvious what caused the glitch of 365ns.</p><p>But… There is a caveat. When adding either <code class="language-plaintext highlighter-rouge">+srcline</code> or <code class="language-plaintext highlighter-rouge">+srccode</code> to output, decoding gets extremely slow. For this workload that runs for only 7ns and generated traces of less than 1MB, decoding took more than a day! <sup id="fnref:8"><a href="#fn:8" class="footnote">8</a></sup> I know this is nuts for most of the users. I’m not entirely sure why that happens, but I suspect the implementation might not be optimal.</p><p>The good news is that there is a workaround. You don’t have to decode the whole trace in advance and can do it lazily. First you can decode without adding <code class="language-plaintext highlighter-rouge">+srcline</code> or <code class="language-plaintext highlighter-rouge">+srccode</code> to the <code class="language-plaintext highlighter-rouge">perf script</code> command. Then look at the time range that you care about and then only decode this time range using <code class="language-plaintext highlighter-rouge">--time start,stop</code> option. For example:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>perf script <span class="nt">--ns</span><span class="nt">--itrace</span><span class="o">=</span>i1t <span class="nt">-F</span> +srcline,+srccode <span class="nt">--time</span> 253.555413140,253.555413520 <span class="o">&gt;</span> time_range.dump
</code></pre></div></div><p>If you’re also interested in assembly instructions, you can do this with the command:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>perf script <span class="nt">--ns</span><span class="nt">--itrace</span><span class="o">=</span>i1t <span class="nt">-F</span> +insn | ../xed <span class="nt">-F</span> insn: <span class="nt">-I</span><span class="nt">-64</span><span class="o">&gt;</span> decoded_insn.dump
</code></pre></div></div><p>This type of decoding is much faster. Note that I also used <code class="language-plaintext highlighter-rouge">xed</code><sup id="fnref:9"><a href="#fn:9" class="footnote">9</a></sup> to decode the raw bytes into instructions. Here is what the decoded output (in <code class="language-plaintext highlighter-rouge">decoded_insn.dump</code>) might look like:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proc   PID   CPU    timestamp       sym+off          instruction
...
a.out  3172 [007]   253.555413143:  main+0x78        cmp eax, 0x3e6
a.out  3172 [007]   253.555413143:  main+0x7d        mov esi, eax
a.out  3172 [007]   253.555413143:  main+0x7f        mov rdi, r12
a.out  3172 [007]   253.555413143:  main+0x82        jle 0x556830247700
a.out  3172 [007]   253.555413143:  main+0x84        call 0x556830247a80
a.out  3172 [007]   253.555413143:  goSlowPath+0x0   test esi, esi		&lt;== enter goSlowPath()
a.out  3172 [007]   253.555413143:  goSlowPath+0x2   js 0x556830247aa0
a.out  3172 [007]   253.555413143:  goSlowPath+0x4   movsxd rsi, esi
a.out  3172 [007]   253.555413143:  goSlowPath+0x7   xor eax, eax
a.out  3172 [007]   253.555413143:  goSlowPath+0x9   lea rdx, ptr [rdi+rsi*4+0x4]
a.out  3172 [007]   253.555413143:  goSlowPath+0xe   data16 nop
a.out  3172 [007]   253.555413143:  goSlowPath+0x10  add eax, dword ptr [rdi]
a.out  3172 [007]   253.555413143:  goSlowPath+0x12  add rdi, 0x4
a.out  3172 [007]   253.555413143:  goSlowPath+0x16  cmp rdi, rdx
a.out  3172 [007]   253.555413143:  goSlowPath+0x19  jnz 0x556830247a90
a.out  3172 [007]   253.555413143:  goSlowPath+0x10  add eax, dword ptr [rdi]
a.out  3172 [007]   253.555413143:  goSlowPath+0x12  add rdi, 0x4
a.out  3172 [007]   253.555413143:  goSlowPath+0x16  cmp rdi, rdx
a.out  3172 [007]   253.555413143:  goSlowPath+0x19  jnz 0x556830247a90
&lt;loop iterations&gt;
a.out  3172 [007]   253.555413508:  goSlowPath+0x16  cmp rdi, rdx
a.out  3172 [007]   253.555413508:  goSlowPath+0x19  jnz 0x556830247a90
a.out  3172 [007]   253.555413508:  goSlowPath+0x1b  ret			&lt;== exit goSlowPath()
a.out  3172 [007]   253.555413508:  main+0x89        sub ebx, 0x1
...
</code></pre></div></div><p>If you want combined output, use:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>perf script <span class="nt">--ns</span><span class="nt">--itrace</span><span class="o">=</span>i1t <span class="nt">-F</span><span class="nb">comm</span>,tid,pid,time,cpu,ip,sym,symoff,srcline,srccode,insn | ../xed <span class="nt">-F</span> insn: <span class="nt">-I</span><span class="nt">-64</span><span class="o">&gt;</span> decoded_combined.dump
</code></pre></div></div><p>This is the output that you might see:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proc   PID   CPU    timestamp       sym+off          srcline   instruction      srccode
...
a.out  3172 [007]   253.555413143:  main+0x84        a.cpp:24  call 0x35c       goSlowPath(arr, random_int);
a.out  3172 [007]   253.555413143:  goSlowPath+0x0   b.cpp:7   test esi, esi    for (int i = 0; i &lt;= n; i++)
a.out  3172 [007]   253.555413143:  goSlowPath+0x2   b.cpp:7   js 0x1e
a.out  3172 [007]   253.555413143:  goSlowPath+0x4   b.cpp:7   movsxd rsi, esi
...
</code></pre></div></div><p>Finally, we can also calculate interesting statistics like “How much times we called goSlowPath function?”:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">grep </span>goSlowPath decoded_insn.dump <span class="o">&gt;</span> slow.trace
<span class="nv">$ </span><span class="nb">grep </span>ret slow.trace <span class="nt">-c</span>
93
</code></pre></div></div><p>Note that this is <strong>exact</strong> number of calls! This is not a wild guess. We know precisely that <code class="language-plaintext highlighter-rouge">goSlowPath</code> was called 93 times.</p><p>We can calculate average time for one invocation of <code class="language-plaintext highlighter-rouge">goSlowPath</code> function:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">grep</span><span class="s2">"test esi"</span> slow.trace | <span class="nb">cut</span><span class="nt">-f1</span><span class="nt">-d</span><span class="s2">":"</span><span class="o">&gt;</span> start.dump
<span class="nv">$ </span><span class="nb">grep</span><span class="s2">"ret"</span> slow.trace | <span class="nb">cut</span><span class="nt">-f1</span><span class="nt">-d</span><span class="s2">":"</span><span class="o">&gt;</span> end.dump
<span class="nv">$ </span><span class="nb">paste</span><span class="nt">-d-</span> end.dump start.dump | bc <span class="nt">-l</span><span class="o">&gt;</span> func.times
<span class="nv">$ </span><span class="nb">awk</span><span class="s1">'{ total += $1; count++ } END { printf("%.9f",total/count)}'</span> func.times
0.000001092
</code></pre></div></div><p>And there are many other ways how to extract useful information from the Intel PT traces.</p><p>That’s it. Hope that you find this article useful and maybe will apply it in your analysis someday. I agree that there are not many tools that support Intel PT, and even those tools don’t perfectly handle all the cases. Anyway, I hope it will get better in the future.</p><hr></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>