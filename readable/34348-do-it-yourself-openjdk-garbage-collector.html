<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Do It Yourself (OpenJDK) Garbage Collector -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Do It Yourself (OpenJDK) Garbage Collector</h1><div><div class="sectionbody"><p>As it might be too daunting to read <a href="https://shipilev.net/jvm/diy-gc/webrev.03/">the entire implementation</a>, this section tries to introduce it piece by piece.</p><div class="sect2"><h3 id="_prologue"><a class="anchor" href="#_prologue"></a>3.1. Prologue</h3><p>GC usually needs to do a few things in preparation for GC. Read the comments, they should be self-explanatory:</p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">{
  GCTraceTime(Info, gc) time("Step 0: Prologue", NULL);

  // Commit marking bitmap memory. There are several upsides of doing this
  // before the cycle: no memory is taken if GC is not happening, the memory
  // is "cleared" on first touch, and untouched parts of bitmap are mapped
  // to zero page, boosting performance on sparse heaps.
  if (!os::commit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size(), false)) {
    log_warning(gc)("Could not commit native memory for marking bitmap, GC failed");
    return;
  }

  // We do not need parsable heap for this algorithm to work, but we want
  // threads to give up their TLABs.
  ensure_parsability(true);

  // Tell various parts of runtime we are doing GC.
  CodeCache::gc_prologue();
  BiasedLocking::preserve_marks();

  // Derived pointers would be re-discovered during the mark.
  // Clear and activate the table for them.
  DerivedPointerTable::clear();
}</code></pre></div></div><p>Since we are going to use a marking bitmap to track what objects are reachable, we need to clean it up before using it. Or, in this case, as we pursue the goal of never taking resources until the GC cycle hits, we need to <a href="https://www.codeproject.com/Articles/1255908/Allocating-Memory-on-Linux-and-Windows">commit the bitmap to memory</a> first. This comes with a few interesting advantages, at least on Linux, where most of the bitmap would be mapped to zero page, especially for sparse heap.</p><p>Threads need to give up their TLABs and ask GC for new ones after GC finishes. </p><p>Some parts of runtime, especially those parts that deal with references to Java heap, get broken by GC, so we need to notify them that GC is about to act. This would let those subsystems to prepare/save parts of their state before impending GC moves.</p></div><div class="sect2"><h3 id="_marking"><a class="anchor" href="#_marking"></a>3.2. Marking</h3><p>Stop-the-world marking is quite simple once we have all the pieces ready to go. Marking is pretty generic, and it would normally be the first step in many GC implementations.</p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">{
  GCTraceTime(Info, gc) time("Step 1: Mark", NULL);

  // Marking stack and the closure that does most of the work. The closure
  // would scan the outgoing references, mark them, and push newly-marked
  // objects to stack for further processing.
  EpsilonMarkStack stack;
  EpsilonScanOopClosure cl(&amp;stack, &amp;_bitmap);

  // Seed the marking with roots.
  process_roots(&amp;cl);
  stat_reachable_roots = stack.size();

  // Scan the rest of the heap until we run out of objects. Termination is
  // guaranteed, because all reachable objects would be marked eventually.
  while (!stack.is_empty()) {
    oop obj = stack.pop();
    obj-&gt;oop_iterate(&amp;cl);
    stat_reachable_heap++;
  }

  // No more derived pointers discovered after marking is done.
  DerivedPointerTable::set_active(false);
}</code></pre></div></div><p>It is like every other graph walking problem: you start from the initial set of reachable vertices, walk all outbound edges, recording which vertices you visited, and do this until you run out of unvisited verticies. In GC, "vertexes" are the objects, and "edges" are the references between them.</p><p>Technically, we could have just used recursion to walk the object graph, but it is a bad idea for arbitrary graphs, which can have very large diameters. Think about walking the linked list with 1 billion nodes in it. So, to limit the recursion depth, we use marking stack that records objects discovered.</p><p>The initial set of reachable objects comes from GC roots. Donâ€™t dwell on what <code>process_roots</code> does for now, we will visit it later. So far, assume it walks all references reachable from the VM side.</p><p>The marking bitmap serves both as the thing that tracks the <em>marking wavefront</em> (the set of already visited objects), and in the end gives us the desired output: the set of all reachable objects. The actual work in done in the <code>EpsilonScanOopClosure</code>, that would be applied to all interesting objects, and which iterates all references in a given object, and here it is:</p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">class EpsilonScanOopClosure : public BasicOopIterateClosure {
private:
  EpsilonMarkStack* const _stack;
  MarkBitMap* const _bitmap;

  template &lt;class T&gt;
  void do_oop_work(T* p) {
    // p is the pointer to memory location where oop is, load the value
    // from it, unpack the compressed reference, if needed:
    T o = RawAccess&lt;&gt;::oop_load(p);
    if (!CompressedOops::is_null(o)) {
      oop obj = CompressedOops::decode_not_null(o);

      // Object is discovered. See if it is marked already. If not,
      // mark and push it on mark stack for further traversal. Non-atomic
      // check and set would do, as this closure is called by single thread.
      if (!_bitmap-&gt;is_marked(obj)) {
        _bitmap-&gt;mark((HeapWord*)obj);
        _stack-&gt;push(obj);
      }
    }
  }
};</code></pre></div></div><p>After this step is done, <code>_bitmap</code> contains the bits set at the locations where alive objects are. This gives us the opportunity to walk all live objects, like this:</p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">// Walk the marking bitmap and call object closure on every marked object.
// This is much faster that walking a (very sparse) parsable heap, but it
// takes up to 1/64-th of heap size for the bitmap.
void EpsilonHeap::walk_bitmap(ObjectClosure* cl) {
   HeapWord* limit = _space-&gt;top();
   HeapWord* addr = _bitmap.get_next_marked_addr(_space-&gt;bottom(), limit);
   while (addr &lt; limit) {
     oop obj = oop(addr);
     assert(_bitmap.is_marked(obj), "sanity");
     cl-&gt;do_object(obj);
     addr += 1;
     if (addr &lt; limit) {
       addr = _bitmap.get_next_marked_addr(addr, limit);
     }
   }
}</code></pre></div></div></div><div class="sect2"><h3 id="_calculating_new_locations"><a class="anchor" href="#_calculating_new_locations"></a>3.3. Calculating New Locations</h3><p>This part is also quite simple, and it implements what the algorithm says.</p><p><span class="image"><img src="calc-new.jpg" alt="calc new"></span></p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">// We are going to store forwarding information (where the new copy resides)
// in mark words. Some of those mark words need to be carefully preserved.
// This is an utility that maintains the list of those special mark words.
PreservedMarks preserved_marks;

// New top of the allocated space.
HeapWord* new_top;

{
  GCTraceTime(Info, gc) time("Step 2: Calculate new locations", NULL);

  // Walk all alive objects, compute their new addresses and store those
  // addresses in mark words. Optionally preserve some marks.
  EpsilonCalcNewLocationObjectClosure cl(_space-&gt;bottom(), &amp;preserved_marks);
  walk_bitmap(&amp;cl);

  // After addresses are calculated, we know the new top for the allocated
  // space. We cannot set it just yet, because some asserts check that objects
  // are "in heap" based on current "top".
  new_top = cl.compact_point();

  stat_preserved_marks = preserved_marks.size();
}</code></pre></div></div><p>The only wrinkle here is that we store the new addresses in the mark words of the Java objects, and these mark words could be busy with something else, for example, locking information. Luckily, those non-trivial mark words are rare, and we can just store them separately if needed: that is what <code>PreservedMarks</code> would do for us.</p><p>The actual <code>EpsilonCalcNewLocationObjectClosure</code> does what the algorithm step wants:</p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">class EpsilonCalcNewLocationObjectClosure : public ObjectClosure {
private:
  HeapWord* _compact_point;
  PreservedMarks* const _preserved_marks;

public:
  EpsilonCalcNewLocationObjectClosure(HeapWord* start, PreservedMarks* pm) :
                                      _compact_point(start),
                                      _preserved_marks(pm) {}

  void do_object(oop obj) {
    // Record the new location of the object: it is current compaction point.
    // If object stays at the same location (which is true for objects in
    // dense prefix, that we would normally get), do not bother recording the
    // move, letting downstream code ignore it.
    if ((HeapWord*)obj != _compact_point) {
      markOop mark = obj-&gt;mark_raw();
      if (mark-&gt;must_be_preserved(obj)) {
        _preserved_marks-&gt;push(obj, mark);
      }
      obj-&gt;forward_to(oop(_compact_point));
    }
    _compact_point += obj-&gt;size();
  }

  HeapWord* compact_point() {
    return _compact_point;
  }
};</code></pre></div></div><p><code>forward_to</code> is the critical part here: it stores the "forwarding address" in the objectâ€™s mark word. We are going to need it in the later steps.</p></div><div class="sect2"><h3 id="_adjusting_the_pointers"><a class="anchor" href="#_adjusting_the_pointers"></a>3.4. Adjusting The Pointers</h3><p>Walk the heap again and rewrite all references to their new locations, as per algorithm:</p><p><span class="image"><img src="adjust-refs.jpg" alt="adjust refs"></span></p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">{
  GCTraceTime(Info, gc) time("Step 3: Adjust pointers", NULL);

  // Walk all alive objects _and their reference fields_, and put "new
  // addresses" there. We know the new addresses from the forwarding data
  // in mark words. Take care of the heap objects first.
  EpsilonAdjustPointersObjectClosure cl;
  walk_bitmap(&amp;cl);

  // Now do the same, but for all VM roots, which reference the objects on
  // their own: their references should also be updated.
  EpsilonAdjustPointersOopClosure cli;
  process_roots(&amp;cli);

  // Finally, make sure preserved marks know the objects are about to move.
  preserved_marks.adjust_during_full_gc();
}</code></pre></div></div><p>There are two sets of references to our moved objects; from other objects in the heap itself and from the GC roots. We need to update both. Some preserved marks have recorded the object references too, so we need to ask them to update themselves. <code>PreservedMarks</code> knows what to do, because it expects "forwarding data" in the same location we have recorded it at, in object mark word.</p><p>The closures are now coming in two types: one that accepts the objects and walks its contents, and the other one that updates the locations. Here is a little performance optimization: if an object is not forwarded, it does not move, so we can spare quite a few heap writes:</p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">class EpsilonAdjustPointersOopClosure : public BasicOopIterateClosure {
private:
  template &lt;class T&gt;
  void do_oop_work(T* p) {
    // p is the pointer to memory location where oop is, load the value
    // from it, unpack the compressed reference, if needed:
    T o = RawAccess&lt;&gt;::oop_load(p);
    if (!CompressedOops::is_null(o)) {
      oop obj = CompressedOops::decode_not_null(o);

      // Rewrite the current pointer to the object with its forwardee.
      // Skip the write if update is not needed.
      if (obj-&gt;is_forwarded()) {
        oop fwd = obj-&gt;forwardee();
        assert(fwd != NULL, "just checking");
        RawAccess&lt;&gt;::oop_store(p, fwd);
      }
    }
  }
};

class EpsilonAdjustPointersObjectClosure : public ObjectClosure {
private:
  EpsilonAdjustPointersOopClosure _cl;
public:
  void do_object(oop obj) {
    // Apply the updates to all references reachable from current object:
    obj-&gt;oop_iterate(&amp;_cl);
  }
};</code></pre></div></div><p>After this step is done, the heap is basically corrupted: references point to "wrong" locations, where objects have not been moved yet. Letâ€™s rectify that!</p></div><div class="sect2"><h3 id="_moving_the_objects"><a class="anchor" href="#_moving_the_objects"></a>3.5. Moving The Objects</h3><p>Time to move the objects into their new locations, as per algorithm step:</p><p><span class="image"><img src="move-objects.jpg" alt="move objects"></span></p><p>Walk the heap again and apply the <code>EpsilonMoveObjectsObjectClosure</code> closure to all live objects:</p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">{
  GCTraceTime(Info, gc) time("Step 4: Move objects", NULL);

  // Move all alive objects to their new locations. All the references are
  // already adjusted at previous step.
  EpsilonMoveObjectsObjectClosure cl;
  walk_bitmap(&amp;cl);
  stat_moved = cl.moved();

  // Now we moved all objects to their relevant locations, we can retract
  // the "top" of the allocation space to the end of the compacted prefix.
  _space-&gt;set_top(new_top);
}</code></pre></div></div><p>After this is done, we can retract the allocated space to the compaction point, letting the allocation path allocate from there after GC cycle is over.</p><p>Note that sliding GC means we can <em>overwrite</em> the contents of existing objects, but since we are scanning in one direction, that means the object we are overwriting is already copied out to its proper location.  So, the closure itself just moves the forwarded objects to their new locations:</p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">class EpsilonMoveObjectsObjectClosure : public ObjectClosure {
public:
  void do_object(oop obj) {
    // Copy the object to its new location, if needed. This is final step,
    // so we have to re-initialize its new mark word, dropping the forwardee
    // data from it.
    if (obj-&gt;is_forwarded()) {
      oop fwd = obj-&gt;forwardee();
      assert(fwd != NULL, "just checking");
      Copy::aligned_conjoint_words((HeapWord*)obj, (HeapWord*)fwd, obj-&gt;size());
      fwd-&gt;init_mark_raw();
    }
  }
};</code></pre></div></div></div><div class="sect2"><h3 id="_epilogue"><a class="anchor" href="#_epilogue"></a>3.6. Epilogue</h3><p>GC is over, the heap is now almost consistent again, we just need a few finishing touches:</p><div class="listingblock"><div class="content"><pre class="prettyprint highlight"><code class="language-c++" data-lang="c++">{
  GCTraceTime(Info, gc) time("Step 5: Epilogue", NULL);

  // Restore all special mark words.
  preserved_marks.restore();

  // Tell the rest of runtime we have finished the GC.
  DerivedPointerTable::update_pointers();
  BiasedLocking::restore_marks();
  CodeCache::gc_epilogue();
  JvmtiExport::gc_epilogue();

  // Marking bitmap is not needed anymore
  if (!os::uncommit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size())) {
    log_warning(gc)("Could not uncommit native memory for marking bitmap");
  }

  // Return all memory back if so requested. On large heaps, this would
  // take a while.
  if (EpsilonUncommit) {
    _virtual_space.shrink_by((_space-&gt;end() - new_top) * HeapWordSize);
    _space-&gt;set_end((HeapWord*)_virtual_space.high());
  }
}</code></pre></div></div><p>Notify other parts of runtime to make their post-GC cleanups/fixups. Restore the special mark words we saved before. Kiss the marking bitmap bye-bye, we do not need it anymore.</p><p>And, if we are so inclined, we can retract the committed space to the new allocation point, thus returning memory to the OS!</p></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>