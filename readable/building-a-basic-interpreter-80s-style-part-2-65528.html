<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Building a BASIC Interpreter, &#x27;80s Style, Part 2 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Building a BASIC Interpreter, &#x27;80s Style, Part 2 - linksfor.dev(s)"/>
    <meta property="article:author" content="Kerri Shotts"/>
    <meta property="og:description" content="If you recall from part one of the series, we only really delved into Retroputer BASIC&#x2019;s first phase of parsing &#x2014; namely, converting the entered line into uppercase and checking if quotes were prop..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://able.bio/kerrishotts/building-a-basic-interpreter-80s-style-part-2--e91250f1"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Building a BASIC Interpreter, &#x27;80s Style, Part 2</title>
<div class="readable">
        <h1>Building a BASIC Interpreter, &#x27;80s Style, Part 2</h1>
            <div>by Kerri Shotts</div>
            <div>Reading time: 21-26 minutes</div>
        <div>Posted here: 11 Aug 2020</div>
        <p><a href="https://able.bio/kerrishotts/building-a-basic-interpreter-80s-style-part-2--e91250f1">https://able.bio/kerrishotts/building-a-basic-interpreter-80s-style-part-2--e91250f1</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>If you recall from <a href="https://able.bio/kerrishotts/building-a-basic-interpreter-80s-style--79a9d703" rel="noopener nofollow noreferrer">part one of the series</a>, we only really delved into Retroputer BASIC’s first phase of parsing — namely, converting the entered line into uppercase and checking if quotes were properly matched. (Note: it should be mentioned that we could do additional checks there too — like matching parentheses, but we don’t at the moment.)</p>
<p>I also mentioned that I wanted to address how much we take even fairly limited standard libraries for granted today (especially in relationship to JavaScript). Nothing described here is <em>magic</em>, but sometimes we take our tools for granted, and I find it useful to understand what’s going underneath the hood.</p>
<h2 id="tokenizing-user-input">Tokenizing User Input</h2>
<p>As mentioned in the last post, a common tactic used by BASICs of the era was that of tokenization. In order to save space and increase execution speed, keywords were “crunched” into single byte token (or two bytes if you needed more keywords).</p>
<p>Let’s imagine that you have a simple line of code that clears the screen and prints the now common greeting, like the following.</p>
<pre><code><span>CLS</span>: PRINT <span>"Hello, World"</span>
</code></pre>
<p>While this doesn’t take up a lot of memory on its own, if you write a long program, a lot of the words in that program will be keywords. If we crunched them (tokenized them), we could save a decent amount of space. For example, after tokenizing the line above, you’d see something more like this in memory:</p>
<pre><code><span>8A</span> <span>E3</span> <span>B5</span> <span>FC</span> <span>Hello,</span> <span>World</span> <span>00</span> <span>00</span>
</code></pre>
<p>It doesn’t take too much effort to map this back to our original statement:</p>
<table>
<tbody><tr>
<th>
<p>Byte</p>
</th>
<th>
<p>Keyword</p>
</th>
<th>
<p>Notes</p>
</th>
</tr>
<tr>
<td>
<p>8A</p>
</td>
<td>
<p>CLS</p>
</td>
<td>

</td>
</tr>
<tr>
<td>
<p>E3</p>
</td>
<td>
<p>“:”</p>
</td>
<td>
<p>End of Statement</p>
</td>
</tr>
<tr>
<td>
<p>32</p>
</td>
<td>
<p>“ “</p>
</td>
<td>
<p>We store up to one space</p>
</td>
</tr>
<tr>
<td>
<p>B5</p>
</td>
<td>
<p>PRINT</p>
</td>
<td>

</td>
</tr>
<tr>
<td>
<p>FB</p>
</td>
<td>
<p>String-in-code</p>
</td>
<td>
<p>String literal follows</p>
</td>
</tr>
<tr>
<td>
<p>Hello, World, 00</p>
</td>
<td>

</td>
<td>
<p>Strings are NUL-terminated</p>
</td>
</tr>
<tr>
<td>
<p>00</p>
</td>
<td>
<p>End Of Line</p>
</td>
<td>
<p>Lines are also NUL-terminated</p>
</td>
</tr>
</tbody></table>
<p>This may seem like a lot of work, but the space savings can be significant. It’s not a lot <em>here</em>, but even so, you should be able to imagine how it could quickly add up. In this case, our crunched result is 19 bytes. The original text is 26 bytes (counting a terminating NUL).</p>
<p>Saving some space becomes important if you’re a BASIC interpreter running on a machine with very limited RAM. Some BASICs had less than a kilobyte of RAM for user programs, so this crunching was indeed very important, and is something that would have been appealing even if it came with no additional benefits.</p>
<p>OK — so just how do we go about tokenizing something like this? It initially seems fairly trivial in JavaScript. Given an array of strings, you could easily do a quick replace of each keyword with the corresponding token. Right?</p>
<p>Sounds like a job for <code>String#replace</code>, right? Naively, we might try the following:</p>
<pre><code><span>const</span> tokens = [<span>"CLS"</span>, <span>"PRINT"</span>, <span>":"</span> ];
<span><span>function</span> <span>tokenize</span> (<span>inStr</span>) </span>{
    <span>const</span> newStr = inStr;
    tokens.forEach(<span>(<span>token, idx</span>) =&gt;</span> newStr = newStr.replace(
        <span>new</span> <span>RegExp</span>(token, <span>"g"</span>), <span>String</span>.fromCharCode(<span>128</span>+idx)
    );
    <span>return</span> newStr;
}
</code></pre>
<p>Unfortunately, it all comes crashing down when you realize that we can’t go about replacing tokens inside of string literals. This means we need to proceed character by character, keeping the context in mind, in order to avoid crunching things that aren’t actually keywords.</p>
<p>This new algorithm much more closely matches that of the assembly language code in Retroputer — but JS still makes things a lot easier. Here’s the start of that JS code (we’ll fill it in throughout the post):</p>
<pre><code><span>const</span> tokens = [<span>"CLS"</span>, <span>"PRINT"</span>, <span>":"</span> ];

<span><span>function</span> <span>tokenize</span>(<span>inStr</span>) </span>{
    <span>let</span> out = [];                    
    <span>let</span> idx = <span>0</span>;                     
    <span>let</span> ch = <span>""</span>;                     
    <span>while</span> (idx &lt; inStr.length) {
        ch = inStr.charCodeAt(idx);  
        
        

        out.push(ch);                
        idx++;                       
    }
    out.push(<span>0</span>);                     
    <span>return</span> out;
}
</code></pre>
<p>We’re starting with a very simplified token list, as no one wants to see the entire table in this format (<a href="https://github.com/kerrishotts/retroputer/blob/building-a-basic-interpreter-part2/asm/kernel/basic/tokens.js" rel="noopener nofollow noreferrer">it’s long, and Retroputer actually builds its token tables from a JS file!</a>), but this should be enough for our purposes here. The idea here is that when we see a token, we’ll record its index in an output array.</p>
<p>At this point we have a function that, for now, just converts a string into its equivalent character codes. It doesn’t do much useful at this point, but can serve as useful scaffolding.</p>
<p>Our assembly language version is pretty similar to the above as well.</p>
<pre><code>  <span>do</span> {
    <span>call</span> _get-<span>source</span>-<span>index</span>     
    dl := &lt;BP+<span>source</span>&gt;,y        
    <span>call</span> _adv-<span>source</span>-<span>index</span>     
    <span>call</span> _get-target-<span>index</span>     
    &lt;BP+target&gt;,y := dl        
    <span>call</span> _adv-target-<span>index</span>     
    cmp dl, <span>0</span>                  
  } <span>while</span> !z
</code></pre>
<p>I’ve not included <code>_get-source-index</code> or the other functions above because they do what they say on the tin, and are simply getting, setting, or advancing our source and target index. One thing of note is that unlike in JS, we don’t have dynamically allocated arrays in assembly language, and so this algorithm pre-allocates a reasonably-sized buffer. As we advance through the input string, we have to know where to write the next token to the target buffer, and that’s what the target index is doing above. Each one of the functions we’re calling above returns the index in <code>Y</code>. For example, The <code>_adv-target-index</code> function advances the target index by one (equivalent to <code>y++</code>).</p>
<h2 id="careful-with-literals">Careful with Literals</h2>
<p>One thing that we should be careful of is that string literals could confuse our tokenizer — we can’t just replace every string of characters that matches a keyword with a token value. If we see a string literal with “CLS” in it, we shouldn’t try to tokenize that. It’s not intended to be executable, and if we print it… well, we’d print the byte corresponding with the token instead. Not likely what the developer wanted.</p>
<p>Number literals, on the other hand, shouldn’t have the same problem since BASIC doesn’t have any numbers as keywords. Even so, there’s zero point in doing a keyword search if we’re looking at a number — why waste time?</p>
<h3 id="tokenizing-string-literals">Tokenizing String Literals</h3>
<p>So, first, let’s check if we’re starting a string — that’s not <em>too</em> hard to do in JS:</p>
<pre><code><span>if</span> (ch === <span>34</span>) {
  out.push (<span>0xFB</span>);             
  idx++;
  ch = inStr.charCodeAt(idx);  
  <span>while</span> (ch !== <span>34</span> &amp;&amp; idx &lt; inStr.length) {
    out.push(ch);
    idx++;
    ch = inStr.charCodeAt(idx);
  };
  idx++;                       
  out.push(<span>0</span>);                 
  <span>continue</span>;
}
</code></pre>
<p>A double quote is represented as character code 34. Other programming languages recognize many more quote styles (such as JS or C), but BASIC is simple here: double quotes or bust.</p>
<p>Once we see that we’re starting a string, we can simply consume the remaining characters and add them to our return array until we see another quote.</p>
<p>When we’ve read in the whole string, we need to add a NUL byte, since Retroputer BASIC uses C-style strings. If we wanted to use Pascal-style strings, we could have maintained a counter and made sure to insert the length of the string literal. Not a big deal either way. The only reason I went with NUL-terminated strings is because that’s super easy to deal with in assembly language since we can just compare against the NUL byte instead of maintaining a counter.</p>
<p>Ok, so that JavaScript wasn’t too hard. Most of us, I think, would reach for something a bit more abstract, like a regular expression. It makes the intent a little more obvious, I think.</p>
<pre><code><span>if</span> (ch === <span>34</span>) {
  out.push (<span>0xFB</span>);             
  <span>const</span> stringLiteral = inStr.substr(idx+<span>1</span>).match(<span>/^[^"]*/</span>)[<span>0</span>];
  idx += stringLiteral.length+<span>1</span>;
  out.push(...Array.from(stringLiteral, ch =&gt; ch.charCodeAt(<span>0</span>)));
  idx++;                       
  out.push(<span>0</span>);                 
  <span>continue</span>;
}
</code></pre>
<p>The above does very much the same thing — but instead of us having to do the work of checking character by character, we let JS do it instead with <code>match</code>. We know we’ll get a match (we’re in a string), so we don’t really even need to bother with checking if we get a successful match. Then we just increment our index past the length of the string and copy the characters into our return array. To <em>me</em>, anyway, this is much easier to follow (but does assume you understand regular expressions along with some ES6 syntax like <code>…</code> and arrow functions).</p>
<p>Of course, in assembly language we have to do the work that JS is doing for us. This yields a very similar result to our first JS attempt:</p>
<pre><code>  cmp dl, constants.QUOTE         
  brs !Z not-a-string             

  <span>call</span> _get-target-<span>index</span>          
  dl := brodata.TOK_CODE_STRING   
  &lt;bp+target&gt;,y := dl             
  <span>call</span> _adv-target-<span>index</span>

still-a-<span>string</span>:
  <span>call</span> _get-<span>source</span>-<span>index</span>
  dl := &lt;bp+<span>source</span>&gt;,y             
  <span>call</span> _adv-<span>source</span>-<span>index</span>
  cmp dl, constants.QUOTE         
  <span>if</span> Z { 
    dl := <span>0</span> 
  }
  <span>call</span> _get-target-<span>index</span>
  &lt;bp+target&gt;,y := dl             
  <span>call</span> _adv-target-<span>index</span>
  cmp dl, <span>0</span>                       
  brs !Z still-a-<span>string</span>           
  continue                        
<span>not</span>-a-<span>string</span>:
</code></pre>
<p>One thing to note about Retroputer’s assembly language parser — it has some very basic support for higher-level constructs, like blocks and loops. So <code>if Z {…}</code> will execute the contents inside the block if the zero flag is set, and <code>continue</code> can be used to branch back to the top of a block (<code>break</code> also works to exit the block). This is translated to various compare and branch instructions by the assembler, so the CPU doesn’t see any of the high level bits. But it makes writing code just a little easier.</p>
<h3 id="tokenizing-numbers">Tokenizing Numbers</h3>
<p>There’s also no point in trying to search for our numbers in our list of keywords, and so we may as well skip past those. Most BASICs would do something very similar to the string routine above — as long as the character it read was a digit, it would be concatenated to the output, and the cruncher would carry on.</p>
<p>Retroputer BASIC (and a few other BASICs, like Atari BASIC) goes one step further: it converts the number into the corresponding binary format. This is very easy to do — if you see a digit, multiply an accumulator by 10 and add the digit, and repeat that as long as you see a digit. (I should note, however, that Retroputer BASIC is currently an integer-only affair. Adding floating point is on the todo list, though.)</p>
<p>(I should note that Retroputer BASIC currently does <em>nothing</em> when it comes to integer overflows, signed or otherwise. Once I add floating point, Retroputer will convert to a floating point representation instead.)</p>
<p>Retroputer BASIC also goes another step further: it’ll recognize hexadecimal numbers as well and convert them to their binary equivalent. It uses <code>0x</code> (just like JS) as the signifier, and has some additional logic to make sure that specifying multiple <code>x</code> characters is considered an error.</p>
<p>In assembly language, checking if a character is a digit isn’t <em>hard</em>, but it is a little verbose, involving a couple of comparisons to see if the character code is between <code>0x30</code> and <code>0x39</code>. (These are the character codes for “0” and “9”, respectively.)</p>
<p>Once we have a digit charachter, we can take advantage of another nicety of the character set. <code>0x30</code> is the character code for “0”, <code>0x31</code> is the code for “1”, and so on. We could subtract <code>0x30</code> if we wanted to, but we have an easier way: just drop the top four bits:</p>
<pre><code><span>and</span> dl, 0b0000_1111
</code></pre>
<p>Unfortunately this <em>doesn’t</em> work if we need to handle hexadecimal numbers. For that, we can subtract and then compare to 10, and then adjust down by 7 again if we were greater than 10 (assuming the hexadecimal digits are uppercase “A”-”Z”).</p>
<p>In JS, we can use regular expressions again to see if we are looking at a number, and then once we have the matched number, we can call <code>Number()</code>, which also gives us another perk: hexadecimal numbers are trivial to convert as well, since <code>Number()</code> will do it automatically if the number starts with <code>0x</code>.</p>
<p>So what does this look like in JavaScript?</p>
<pre><code><span>if</span> (ch &gt;= <span>48</span> &amp;&amp; ch &lt;= <span>57</span>) {
  out.push (<span>0xFD</span>);           
  <span>const</span> numberLiteralStr = inStr.substr(idx).match(<span>/^[\d|A-F|a-f|x|X]+/</span>)[<span>0</span>];
  idx += numberLiteralStr.length;
  <span>const</span> numberLiteral = <span>Number</span>(numberLiteralStr);
  <span>const</span> bytes = <span>new</span> <span>Uint8Array</span>(<span>new</span> <span>Uint16Array</span>([numberLiteral]).buffer);
  out.push(...bytes)
  <span>continue</span>;
}
</code></pre>
<p>The regular expression allows any combination of digits or hexadecimal digits (plus an <code>x</code> to get us into hexadecimal mode). This expression isn’t perfect — it’ll allow multiple <code>x</code>s, for example, but it’s good enough for now.</p>
<p>The bit in the above that raises some eyebrows is converting the number into bytes. <code>Number()</code> did the hard work of turning a string of digits into a number that JavaScript can work with, but now we need it to be represented as a series of bytes. We could do the conversion using some math:</p>
<pre><code><span>const</span> <span>hiByte</span> <span>=</span> <span>(numberLiteral</span> <span>&amp;</span> <span>0xFF00</span><span>)</span> <span>&gt;&gt;</span> <span>8</span><span>;</span>
<span>const</span> <span>loByte</span> <span>=</span> <span>(numberLiteral</span> <span>&amp;</span> <span>0x00FF</span><span>);</span>
</code></pre>
<p>… and for an integer, that’s easy to do. But by using JS’s typed arrays, we can skip the math, and also set ourselves up to handling floating point numbers in the future (we’d just swap <code>Uint16Array</code> for <code>Float64Array</code>.</p>
<p>The <a href="https://github.com/kerrishotts/retroputer/blob/building-a-basic-interpreter-part2/asm/kernel/basic/tokenizer.asm#L204-L269" rel="noopener nofollow noreferrer">assembly language code for accomplishing this is a bit longer</a>, but it’s also doing a little bit more work. Retroputer takes another optimization: if the number is small, it gets stored in a smaller format. This means that 0-255 can be stored in a single byte, while larger numbers take up two.</p>
<h2 id="looking-up-keywords">Looking up Keywords</h2>
<p>Okay, so we’ve done a lot of work and we’ve still not actually crunched a keyword. Well, with the number and string literals out of the way, we can be pretty sure that whatever we’re looking at is either a keyword or a variable name. (It could also be a space, but that’s easy to check.)</p>
<p>In BASIC, keywords don’t always start with an alphabetical character — operators and separators also count as tokens. But variables also start with an alphabetical character. So we can’t immediately tell if what we’re about to crunch is a keyword or a variable. That’s OK—if we don’t find a match in our token list, we can assume it’s a variable instead.</p>
<p>So how do we actually check to see if our potential keyword is really a keyword? If we were writing JavaScript, we’d probably reach for the <code>Array#findIndex</code> method.</p>
<pre><code><span>const</span> tokenMatch = tokens.findIndex(<span><span>token</span> =&gt;</span> 
  inStr.substr(idx).startsWith(token));
<span>if</span> (tokenMatch &gt; <span>-1</span>) {
  out.push(tokenMatch + <span>128</span>);
  idx += tokens[tokenMatch].length;
  <span>continue</span>;
}
</code></pre>
<p>The <code>Array#findIndex</code> method will iterate over the <code>tokens</code> array, and we can test to see if <code>inStr</code> (at the current <code>idx</code>) starts with the token we’re checking. With our simplified token list, we’ll do something like this (let’s imagine <code>inStr.substr(idx)===”PRINT”</code>:</p>
<table>
<tbody><tr>
<th>
<p>token</p>
</th>
<th>
<p>.startsWith(token)?</p>
</th>
<th>
<p>Index</p>
</th>
</tr>
<tr>
<td>
<p>CLS</p>
</td>
<td>
<p>false</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>PRINT</p>
</td>
<td>
<p>true</p>
</td>
<td>
<p>1</p>
</td>
</tr>
</tbody></table>
<p>Note: Like <code>indexOf</code> in JS, if nothing is found, we’d get a <code>-1</code> for our troubles.</p>
<p>If we find a match, we can store the index in our return array. But how can we later know the difference between a token and a character? Easy: turn the high bit on, and we can do this by adding 128 to the token value.</p>
<p>(Note: if we needed to have more than 128 tokens, we’d have to use two bytes for some tokens. This makes things a <em>little</em> bit more complicated, but not by much. Some BASICs do this—various flavors of Microsoft BASIC, for example)</p>
<p>So, we’ve done the work in JavaScript, but how in the world can we do this in assembly language?</p>
<p>Well, it turns out, we do it pretty much the same way, but it gets a lot more wordy.</p>
<pre><code>search-keywords:
  bl := [d, x]                 
  cmp bl, constants.NUL        
  brs Z exit-keyword-search    
  clr Z                        
  <span>call</span> [vectors.STRCMP]        
                               
                               
  <span>if</span> !Z {
    <span>do</span> {                       
      inc x                    
      bl := [d, x]             
      cmp bl, constants.NUL    
    } <span>while</span> !z
    inc x                      
    inc x                      
    brs <span>search</span>-keywords        
  }
  clr c                        
  <span>add</span> x, c                     
  inc x                        
  bl := [d, x]                 
  <span>call</span> _get-target-<span>index</span>
  &lt;bp+target&gt;,y := bl          
  <span>call</span> _adv-target-<span>index</span>
  <span>call</span> _get-<span>source</span>-<span>index</span>       
  clr c
  <span>add</span> y, c                     
  <span>dec</span> y                        
  <span>call</span> _set-<span>source</span>-<span>index</span>
  continue
</code></pre>
<p>Okay, that doesn’t look <em>too</em> bad. It’s pretty much the exact same algorithm except that our token table in assembly language is structured a little differently. Namely, it looks something like this:</p>
<pre><code>CLS   00 80
PRINT 00 81
:     00 82
</code></pre>
<p>Each keyword is NUL-terminated, and then is followed by the token’s number.</p>
<p>We’re leaving something important out here, though — that is, how in the world did we do the string comparison? Retroputer’s kernel has a <code>STRCMP</code> routine which we can use, but what does that look like?</p>
<pre><code><span>strcmp</span>: <span>{</span>
  <span>enter</span> <span>0x00</span>
  <span>push</span> <span>a</span>
  <span>push</span> <span>b</span>
  <span>push</span> <span>d</span>
  <span>push</span> <span>y</span>
  <span>pushf</span>
  <span>if</span> <span>Z {</span>
    <span>bl</span> :<span>= 0x00                  # Checking for full equality</span>
  <span>}</span> <span>else {</span>
    <span>bl</span> :<span>= 0x01                  # only checking for partial equality</span>
  <span>}</span>
<span>_main</span>:<span></span>
  <span>y</span> :<span>= 0                        # start of string</span>
<span>top</span>:<span></span>
  <span>cl</span> :<span>= [d, x, y]               # character in string A</span>
  <span>al</span> :<span>= &lt;bp+4&gt;,y                # character in string B</span>
  <span>cmp</span> <span>bl, 0x01                  # check if we're doing full equality</span>
  <span>if</span> <span>Z {</span>
    <span>cmp</span> <span>cl, 0                   # we're not, so check for an early nul</span>

    <span>brs</span> <span>Z strings-are-equal     # if it's NUL, we calling them equal</span>
  <span>}</span>
  <span>cmp</span> <span>cl, al                    # check character</span>
  <span>if</span> <span>Z {</span>
    <span>cmp</span> <span>cl, 0                   # equal, but check for NUL</span>
    <span>brs</span> <span>Z strings-are-equal     # NUL reached, strings are equal</span>
    <span>inc</span> <span>y                       # next character</span>
    <span>brs</span> <span>top                     # not NUL, so keep going...</span>
  <span>}</span>

  <span>if</span> <span>N {</span>
    <span>popf</span>                        <span># string is less than</span>
    <span>set</span> <span>N</span>
    <span>clr</span> <span>Z</span>
    <span>brs</span> <span>_out</span>
  <span>}</span> <span>else {</span>
    <span>popf</span>                        <span># string is greater than</span>
    <span>clr</span> <span>N</span>
    <span>clr</span> <span>Z</span>
    <span>brs</span> <span>_out</span>
  <span>}</span>
<span>strings-are-equal</span>:<span></span>
  <span>popf</span>
  <span>clr</span> <span>N                         # Not less than</span>
  <span>set</span> <span>Z                         # but Equal</span>
<span>_out</span>:<span></span>
  <span>c</span> :<span>= y                        # make sure we know how many chars</span>

  <span>pop</span> <span>y</span>
  <span>pop</span> <span>d</span>
  <span>pop</span> <span>b</span>
  <span>pop</span> <span>a</span>
  <span>exit</span> <span>0x00</span>
  <span>ret</span>
<span>}</span>
</code></pre>
<p>I don’t know about you, but I’m loving JS’s <code>String#startsWith</code> method more and more. It does the same thing, granted, but I didn’t have to write its internal logic!</p>
<h2 id="handling-variables">Handling Variables</h2>
<p>We could be done at this point — the work of crunching our keywords is complete. Retroputer BASIC does one more step, which is to tokenize the variables. I believe only very few BASICs of the ‘80s and ‘90s did this because it could actually hurt in limited memory conditions. But if you have lots of memory, tokenizing your variables can help with performance.</p>
<p>Here’s what Retroputer BASIC does:</p>
<ul>
<li>It reads up to the first two characters of the variable name. (This was a common affectation of BASICs of the time due to memory constraints.)</li>
<li>From these two characters, it determines a variable index. “A” is variable zero, “A0” is variable 53, etc. The equation isn’t difficult, but not really the point here.</li>
<li>BASIC continues to scan for the variable’s type sigil. In BASIC, <code>$</code> signifies a string variable, for example. The variable type is stored in a couple of bits high in the variable index.</li>
<li>BASIC then writes the type and index to the output, and then writes the variable name’s length in addition to the variable name itself. This is where we lose space savings!</li>
</ul>
<p>(Note: when Retroputer BASIC can allocate variables dynamically, the index will be replaced with a pointer to the variable instead. Another thing on the todo list!)</p>
<p>This makes variable lookup during execution extremely fast: you don’t have to parse the variable name and calculate the index each time you encounter the variable. In a tight loop, that savings can add up. But it also comes at a huge cost: we have to store the pointer and the variable name together, and so we tack on an extra four bytes in the output for every variable we see.</p>
<p>It’s up to you to decide if that’s worth it.</p>
<p>Regardless, determining if what’s left is indeed a variable in our character stream is also easy in JavaScript:</p>
<pre><code><span>const</span> variableMatch = inStr.substr(idx).match(/^[A-Z]+[A-Z0-<span>9</span>]*[\$]*/);
<span>if</span> (variableMatch) {
  <span>const</span> variableName = variableMatch[<span>0</span>];
  idx += variableName.length;
  
  <span>continue</span>;
}
</code></pre>
<p>I’m not going to go into the <a href="https://github.com/kerrishotts/retroputer/blob/building-a-basic-interpreter-part2/asm/kernel/basic/tokenizer.asm#L407-L512" rel="noopener nofollow noreferrer">code Retroputer does at this point to tokenize variables</a> — it’s very wordy, but not particularly interesting… yet. When I add dynamic variable allocation, I’ll revisit this.</p>
<h2 id="tokenization-complete">Tokenization Complete</h2>
<p>Now, if you test our JS code, you’ll get an array of bytes similar to what Retroputer BASIC uses internally:</p>
<pre><code><span>console.log(toHex(tokenize(`CLS:</span> <span>PRINT</span> <span>"Hello, World"</span><span>`)));</span>
<span>//</span> <span>80</span> <span>82</span> <span>20</span> <span>81</span> <span>20</span> <span>FB</span> <span>48</span> <span>65</span> <span>6C</span> <span>6C</span> <span>6F</span> <span>2C</span> <span>20</span> <span>57</span> <span>6F</span> <span>72</span> <span>6C</span> <span>64</span> <span>00</span> <span>00</span> 
</code></pre>
<p>Wow — so that was a lot of work for a few bytes worth of savings. But if you’ve only got a couple kilobytes of free memory, it’s worth it! But that’s not the <em>only</em> benefit we get from crunching the user’s input. We get fast execution times as well.</p>
<p>To explain that, we’re going to need to look at how Retroputer executes code. I’m not going into all the details <em>yet</em>, but the short story is that we can do the following to execute code:</p>
<ul>
<li>Get a byte from memory</li>
<li>If the byte has the high bit set, it’s a token — otherwise it’s a syntax error (or NUL — in which case, we’re done with the program line)</li>
<li>Look the token’s handler up in an array — this array has pointers to the actual functions that operate on the token</li>
<li>Call the handler (the handler is responsible for consuming arguments and the like)</li>
<li>Repeat</li>
</ul>
<p>This is the other reason why we tokenize keywords — it becomes trivial to execute the logic for the keyword simply by looking up an address in an array and calling it.</p>
<p>We’ll cover the execution aspect in more details, but I wanted to note that although tokenization is important for space savings, it also improves the execution speed.</p>
<p>For example, in JS, an execution loop could be something like this:</p>
<pre><code><span>const</span> handlers = [ cls, print, endOfStmt ];
bytes.forEach(<span><span>byte</span> =&gt;</span> handlers[byte] &amp;&amp; handlers[byte]());
</code></pre>
<p>Of course it’s not quite that simple — there’s a lot more that goes into it, but that’s for another post!</p>
<hr>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://gist.github.com/kerrishotts/5f109729a66526db707bf1ab82af94f7" rel="noopener nofollow noreferrer">Full JavaScript code for this post</a></li>
<li><a href="https://github.com/kerrishotts/retroputer/releases/tag/building-a-basic-interpreter-part2" rel="noopener nofollow noreferrer">Retroputer Source (at this point in history)</a></li>
<li><a href="https://able.bio/kerrishotts/building-a-basic-interpreter-80s-style-redux--4323d1db" rel="noopener nofollow noreferrer">List of resources I’ve been using for this project</a> (from the redux to part 1 of this series)</li>
</ul>
<p>‌</p>
<h2 id="revisions">Revisions</h2>
<ul>
<li>August 11, 2020: Added a <a href="https://able.bio/kerrishotts/building-a-basic-interpreter-80s-style-redux--4323d1db" rel="noopener nofollow noreferrer">link</a> to the redux to part 1 of this series, which has more resources that I’ve been using.</li>
<li>August 9, 2020: Added some links to resources</li>
</ul>
<p>‌</p>
                    </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>