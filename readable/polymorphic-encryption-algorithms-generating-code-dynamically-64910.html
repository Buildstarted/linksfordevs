<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Polymorphic Encryption Algorithms &#x2014; Generating Code Dynamically - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Polymorphic Encryption Algorithms &#x2014; Generating Code Dynamically - linksfor.dev(s)"/>
    <meta property="article:author" content="Bartosz W&#xF3;jcik"/>
    <meta property="og:description" content="Polymorphic encryption of code, an article presenting all the concepts and steps involved in creating a polymorphic engine in C&#x2B;&#x2B;."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.pelock.com/articles/polymorphic-encryption-algorithms"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Polymorphic Encryption Algorithms &#x2014; Generating Code Dynamically</title>
<div class="readable">
        <h1>Polymorphic Encryption Algorithms &#x2014; Generating Code Dynamically</h1>
            <div>by Bartosz W&#xF3;jcik</div>
            <div>Reading time: 29-37 minutes</div>
        <div>Posted here: 28 Jul 2020</div>
        <p><a href="https://www.pelock.com/articles/polymorphic-encryption-algorithms">https://www.pelock.com/articles/polymorphic-encryption-algorithms</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>

<section itemprop="articleBody" id="contents">

	<figure>
		<a href="https://www.pelock.com/img/en/articles/polymorphic-encryption-algorithms/dna.jpg" data-lightbox="image-1" data-title="DNA Structure" title="DNA Structure">
			<img src="https://www.pelock.com/img/en/articles/polymorphic-encryption-algorithms/dna.jpg" alt="DNA Structure" itemprop="image">
		</a>
	</figure>

<section itemprop="articleSection" id="introduction">

	<p itemprop="description">This article explains all the steps needed to write a C++ program which dynamically generates encryption algorithms in x86 assembly code.</p>

</section>

<section itemprop="articleSection">

	<h2 id="off-the-shelf-encryption-algorithms"><a href="#off-the-shelf-encryption-algorithms" aria-label="Anchor link for: off the shelf encryption algorithms" data-anchorjs-icon=""></a>Off-the-shelf encryption algorithms</h2>
		<p>There is a wide variety of encryption algorithms available. The advantage of these algorithms is that they are heavily studied and their strengths and weaknesses are known. The first type are block cipher algorithms (data is encrypted in blocks of fixed size), including:</p>
		<ul>
		<li><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" rel="nofollow">AES (Rijndael)</a></li>
		<li><a href="https://en.wikipedia.org/wiki/Blowfish_%28cipher%29" rel="nofollow">Blowfish</a></li>
		<li><a href="https://en.wikipedia.org/wiki/Twofish" rel="nofollow">Twofish</a></li>
		<li><a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard" rel="nofollow">DES</a></li>
		<li><a href="https://en.wikipedia.org/wiki/Serpent_%28cipher%29" rel="nofollow">Serpent</a></li>
		<li><a href="https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm" rel="nofollow">TEA – Tiny Encryption Algorithm</a></li>
		<li><a href="https://en.wikipedia.org/wiki/RC5" rel="nofollow">RC5</a>, <a href="https://en.wikipedia.org/wiki/RC6" rel="nofollow">RC6</a></li>
	</ul>
		<p>There are also stream cipher algorithms (which encrypt data one byte at a time), such as the popular <em><a href="https://en.wikipedia.org/wiki/RC4" rel="nofollow">RC4</a></em> algorithm. Most encryption algorithms are symmetric, which means that the same key is used for both encrypting and decrypting data. However, there are a number of asymmetric encryption functions, based on public key infrastructure. This group of algorithms includes:</p>
		<ul>
		<li><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" rel="nofollow">RSA</a></li>
		<li><a href="https://en.wikipedia.org/wiki/ElGamal_encryption" rel="nofollow">ElGamal</a></li>
		<li><a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography" rel="nofollow">ECC</a></li>
	</ul>
		<p>The encryption component of these algorithms uses a <em>public key</em>, while the decryption component requires a <em>private key</em>. As the name implies, public keys can be safely published on the Internet (like the keys in the <em><a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy" rel="nofollow">PGP</a></em> encryption system). Unlike symmetric encryption algorithms, where a leaked key means anyone can read the message, asymmetric encryption algorithms ensure that only the holder of the private key can decrypt the message. Since the public and private keys are mathematically related, it is theoretically possible to “crack” a public key and obtain the private key, however there are no known practical ways of doing this. In the case of RSA, cracking the public key involves splitting it into its two prime factors (RSA public keys are the product of two very large prime numbers). This factoring process currently takes an enormous time. The <em>RSA</em> company even organized a <a href="https://en.wikipedia.org/wiki/RSA_Factoring_Challenge" rel="nofollow">public challenge to break <em>RSA</em> keys</a>, where the largest prize was $US200,000 for cracking a 2048-bit key.</p>
		<p>All the above algorithms are extensively documented, and implementations can easily be found for many programming languages.</p>

</section>
<section itemprop="articleSection">

	<h2 id="polymorphic-engines"><a href="#polymorphic-engines" aria-label="Anchor link for: polymorphic engines" data-anchorjs-icon=""></a>Polymorphic engines</h2>

	<p>Polymorphism has several meanings in the software world. In this case, we are referring to unique, dynamically-generated code (i.e. computer instructions). This technique has its roots in computer viruses. Already in the days of <em>MS-DOS</em>, some computer viruses were encrypted by their creators in order to evade detection by antivirus software. Of course, the viruses needed to contain decryption routines, and these were quickly added to virus signature databases. Soon, virus creators developed decryption algorithms whose code was uniquely generated every time, which allowed viruses to be created which could not be detected using static signatures. The first recorded polymorphic engines date back to the year 1990.</p>

	<p>In time, polymorphic algorithms evolved and became ever more sophisticated, in order to make it as difficult as possible for antivirus programs to analyze viruses and run them in an emulated environment. Some well-known algorithms included:</p>

	<ul>
		<li>KME – <em>Kewl Mutation Engine</em> (by z0mbie and Vecna) – an engine which requires no input data and writes the decrypted code to the stack. Rather than running a decryption algorithm on some encrypted data, the decryption routine is specially constructed to generate the original data every time. This means there is no buffer of encrypted data to be found.</li>
		<li>MMXE – <em>MultiMedia eXtensions Engine</em> (by Billy Belcebu) – a polymorphic engine which generates MMX code</li>
		<li>TUAREG – <em>Tameless Unpredictable Anarchic Relentless Encryption Generator</em> (by Mental Driller) – introduces nonlinear data decryption and many innovative methods into the polymorphic engine</li>
		<li>PPE-II – <em>Prizzy Polymorphic Engine</em> (by Prizzy) – a polymorphic engine which exploits <em>MMX</em> and <em>FPU</em> code, as well as intentional <em>brute-force</em> calculations in its code, so as to slow down operation of emulation strategies used by antivirus software</li>
	</ul>

	<p>In most cases, this type of encryption was used in executable file infectors. Due to the level of complexity of polymorphic engines, and the necessity of an in-depth understanding of assembly language for their creation, these days polymorphic engines are rarely used (one exception to this is <em>Virut</em> which, I'd like to point out, is strongly suspected of being Polish in origin!)</p>

	<p>However, polymorphic engines have found another use: software protection systems, or <em>exe-protectors</em>, such as <em><a href="https://www.pelock.com/products/pelock">PELock</a></em>, <em>ASProtect</em>, <em>EnigmaProtector</em>, <em>Themida</em>, and <em>Obsidium</em>. They are used to make it more difficult for an application's code to be analyzed by <em>crackers</em> (i.e. people who try to break software protection), and to make it harder for automated <em>unpackers</em> to be created (i.e. tools which remove software protection). If you possess any <em>shareware</em> program which is protected by an <em>exe-protector</em>, there is a 99% chance that it uses a polymorphic encryption engine.</p>

</section>

<section itemprop="articleSection">

	<h2 id="our-own-polymorphic-engine"><a href="#our-own-polymorphic-engine" aria-label="Anchor link for: our own polymorphic engine" data-anchorjs-icon=""></a>Our own polymorphic engine</h2>

	<p>In this article, we will cover all the steps necessary to create a simple polymorphic engine, which will serve to encrypt any supplied data, and generate a unique decryption procedure, with the encrypted data embedded within it.</p>

	<p>To create this engine, we'll use the C++ language and the <em>AsmJit</em> library, which allows dynamic generation of assembly code. <em>AsmJit</em> makes it possible to create assembly code at the C++ level, as if you were writing it by hand. It is possible to create 32- or 64-bit instructions, and even pseudoinstructions. Thanks to this, the library can be used to target code for 32- and 64-bit environments. In our case we'll stick with 32-bit code.</p>

	<p><span>Listing 1.</span>Pseudocode in C++ for the decryption function that we will generate.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text"><span>DWORD <span>DecryptionProc</span><span>(PDWORD lpdwOutput)</span>
</span>{
  
  DWORD dwDecryptionKey = <span>0xA39383D</span>;

  
  
  PDWORD lpdwInput = <span>reinterpret_cast</span>&lt;PDWORD&gt;(&amp;cEncryptedData);

  
  
  <span>for</span> (DWORD i = <span>0</span>; i &lt; NUM_BLOCKS; i++)
  {
    DWORD dwInputBlock = lpdwInput[i];

    dwInputBlock ^= <span>0x453BC</span>;
    dwInputBlock += dwDecryptionKey;
    ...

    lpdwOutput[i] = dwInputBlock;
  }

  
  
  <span>return</span> DECRYPTED_DATA_SIZE;

  
  
  BYTE cEncryptedData[] = { <span>0xAB</span>, <span>0xBA</span>... };
}</code></pre>

	<p>Our decryption function will take just one parameter: a pointer to the output buffer where the decrypted data will go. The function will return the size of the decrypted data. Sound simple? Then let's get to work!</p>

<section itemprop="articleSection">

	<h2 id="random-register-selection"><a href="#random-register-selection" aria-label="Anchor link for: random register selection" data-anchorjs-icon=""></a>Random register selection</h2>

	<p>Our decryption function will use the standard 32-bit processor registers, and will obtain its one parameter from the stack using the stack frame pointer in the <code>EBP</code> register. The registers used for decryption, for holding a pointer to the encrypted data, and for holding a pointer to the output buffer, will be selected randomly each time the decryption routine is generated.</p>

	<p><span>Listing 2.</span>Random selection of registers for the decryption function.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">





<span>void</span> CMutagenSPE::RandomizeRegisters()
{
  
  AsmJit::GPReg cRegsGeneral[] = { eax, ecx, ebx, edx, esi, edi };

  
  mixup_array(cRegsGeneral, _countof(cRegsGeneral));

  
  
  regSrc = cRegsGeneral[<span>0</span>];

  
  
  
  regDst = cRegsGeneral[<span>1</span>];

  
  
  regSize = cRegsGeneral[<span>2</span>];

  
  
  regKey = cRegsGeneral[<span>3</span>];

  
  
  
  regData = cRegsGeneral[<span>4</span>];

  
  
  AsmJit::GPReg cRegsSafe[] = { esi, edi, ebx };

  
  mixup_array(cRegsSafe, _countof(cRegsSafe));

  regSafe1 = cRegsSafe[<span>0</span>];
  regSafe2 = cRegsSafe[<span>1</span>];
  regSafe3 = cRegsSafe[<span>2</span>];
}</code></pre>

	<p>This random choice of registers will contribute to the generated code being different each time.</p>

</section>

<section itemprop="articleSection">

	<h2 id="prologue-of-the-decryption-function"><a href="#prologue-of-the-decryption-function" aria-label="Anchor link for: prologue of the decryption function" data-anchorjs-icon=""></a>Prologue of the decryption function</h2>

	<p>The prologue of the decryption function is simply the first section of the function, which contains some standard elements like setting up the stack frame and preserving registers. The stack frame is a special region reserved on the stack for holding local variables (if the function needs any) as well as holding the parameters supplied to the function. In our case the one parameter will be a pointer to the buffer where we will store the decrypted data.</p>

	<figure>
		

		<figcaption><span>Figure 1.</span>Structure of the stack frame once the function is invoked</figcaption>
	</figure>

	<p><span>Listing 3.</span>Generating the prologue.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">





<span>void</span> CMutagenSPE::GeneratePrologue()
{
  
  
  
  <span>if</span> (rnd_bin() == <span>0</span>)
  {
    a.push(ebp);
    a.mov(ebp,esp);
  }
  <span>else</span>
  {
    
    
    
    a.enter(imm(<span>0</span>), imm(<span>0</span>));
  }

  
  
  
  
  a.push(regSafe1);
  a.push(regSafe2);
  a.push(regSafe3);

  
  
  
  
  a.mov(regDst, dword_ptr(ebp, <span>0x08</span> + (<span>4</span> * <span>0</span>)));
}</code></pre>

</section>

<section itemprop="articleSection">

	<h2 id="address-of-the-encrypted-data"><a href="#address-of-the-encrypted-data" aria-label="Anchor link for: address of the encrypted data" data-anchorjs-icon=""></a>Address of the encrypted data</h2>

	<p>Our dynamically generated code can be located anywhere in memory and launched from there (assuming the memory region has the appropriate executable flags set). In such cases we cannot refer to parts of the function using absolute memory addresses, because we simply don't know where the function will reside. The encrypted data is located just after the end of the decryption routine, and we don't know its address in advance either. We will need to determine its address at runtime, through the use of relative addressing.</p>

	<p>We will employ the <em>delta offset</em> technique for this purpose. It depends on the use of the <code>call</code> assembly instruction, normally used to call a function. We take advantage of the fact that this instruction stores a return address on the stack before jumping to a chosen memory address.</p>

	<p><span>Listing 4.</span>Obtaining the current code address through the use of the delta offset technique.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">Decryptor proc <span>near</span>


	<span>push</span>	<span>ebp</span>


	<span>call</span>	delta_offset
<span>delta_offset:</span>



	<span>pop</span>	<span>ebp</span>



	<span>lea</span>	<span>eax</span>,[<span>ebp</span> + (var_1 - delta_offset)]



	<span>cmp</span>	<span>dword</span> <span>ptr</span>[<span>eax</span>],<span>0DEADC0DEh</span>
	<span>sete</span>	<span>al</span>
	<span>movzx</span>   <span>eax</span>,<span>al</span>


	<span>pop</span>	<span>ebp</span>

	<span>ret</span>



	var_1   <span>dd</span> <span>0DEADC0DEh</span>

Decryptor endp</code></pre>

	<p>The return address generated by <code>call delta_offset</code> will refer to the next instruction, in this case <code>pop ebp</code>. Once we know the memory address of this instruction, we can work out the address of anything else in our function. In our case, we work out the location of our "encrypted" data by adding the number of bytes between the <code>delta_offset:</code> label and the end of the function.</p>

	<p>An interesting alternative for calculating a <em>delta offset</em> address involves the use of the <em>FPU</em> instruction <code>fnstenv</code>, which stores the environment state of the FPU. Among other things, this contains the memory location of the most recently executed FPU instruction. Like <code>call</code>, this allows us to obtain the location of an instruction in our function and we can use a similar <em>delta offset</em> calculation to refer to data stored after the function.</p>

	<p><span>Listing 5.</span>Using FPU instructions to calculate a delta offset address.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">DeltaOffsetFPUTest proc uses <span>esi</span>


	local	fpEnvironment[<span>32</span>]:<span>byte</span>


	<span>finit</span>



<span>delta_offset:</span>
	<span>fldpi</span>


	<span>lea</span>	<span>eax</span>,fpEnvironment
	<span>fnstenv</span> <span>byte</span> <span>ptr</span>[<span>eax</span>]





	<span>mov</span>	<span>esi</span>,<span>dword</span> <span>ptr</span>[<span>eax</span>+<span>12</span>]



	<span>fistp</span>   <span>dword</span> <span>ptr</span>[<span>esp</span>-<span>4</span>]



	<span>lea</span>	<span>eax</span>,[<span>esi</span> + (var_1 - delta_offset)]



	<span>cmp</span>	<span>dword</span> <span>ptr</span>[<span>eax</span>],<span>0ABBAh</span>
	<span>sete</span>	<span>al</span>
	<span>movzx</span>   <span>eax</span>,<span>al</span>

	<span>ret</span>


	var_1   <span>dd</span> <span>0ABBAh</span>

DeltaOffsetFPUTest endp</code></pre>

	<p>This approach to the delta offset calculation is sometimes used in <em>exploits</em>, e.g. in the <em><a href="https://www.metasploit.com/" rel="nofollow">Metasploit</a></em> framework. A similar technique is also used in debugger detection, where the <code>fnstenv</code> instruction will reveal that the most recently executed FPU instruction is <em>not</em> part of our program, but refers to some other FPU instruction, which is directly or indirectly executed by the debugger. In this way, it is possible to discover tracing of our code by debuggers including <em><a href="http://www.ollydbg.de/" rel="nofollow">OllyDbg</a></em>.</p>

	<p><em>Delta offset</em> calculations can rouse the suspicions of antivirus programs, since normal applications do not have a need for this kind of thing. The combination of <code>call</code> and <code>pop r32</code> can cause the application to be suspected of containing malware. In order to prevent this, we must generate extra code between these two instructions, and utilize a different means of getting values from the stack.</p>

<p><span>Listing 6.</span>Generating code for relative addressing.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">





<span>void</span> CMutagenSPE::GenerateDeltaOffset()
{
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  lblDeltaOffset = a.newLabel();

  
  a.call(lblDeltaOffset);

  <span>sysint_t</span> posUnusedCodeStart = a.getOffset();

  
  
  
  
  
  
  
  <span>if</span> (rnd_bin() == <span>0</span>)
  {
    a.mov(eax, imm(<span>1</span>));
  }
  <span>else</span>
  {
    a.xor_(eax,eax);
  }

  a.leave();
  a.ret(<span>1</span> * <span>sizeof</span>(DWORD));

  
  
  
  
  dwUnusedCodeSize = <span>static_cast</span>&lt;DWORD&gt;(a.getOffset() - posUnusedCodeStart);

  
  a.bind(lblDeltaOffset);

  posDeltaOffset = a.getOffset();

  
  
  
  

  
  a.mov(regSrc, dword_ptr(esp));
  a.add(esp, imm(<span>sizeof</span>(DWORD)));

  
  
  
  
  
  
  
  
  a.add(regSrc, imm(<span>987654321</span>));

  
  
  
  posSrcPtr = a.getOffset() - <span>sizeof</span>(DWORD);
}</code></pre>

	<p>At the moment, we don't know the size of the remainder of the decryption function, which is why we will need to update this value later, once we have generated all the other instructions of the decryption function.</p>

</section>

<section itemprop="articleSection">

	<h2 id="encryption"><a href="#encryption" aria-label="Anchor link for: encryption" data-anchorjs-icon=""></a>Encryption</h2>

	<p>The encryption of the data will occur in 4-byte blocks. The data can be smaller than this (it will be rounded up to a multiple of 4). Pseudoinstructions will be randomly generated for the encryption process, and they will later be used to generate the decryption code.</p>

	<p><span>Listing 7.</span>Encryption.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">






<span>void</span> CMutagenSPE::EncryptInputBuffer(PBYTE lpInputBuffer, \
                                     DWORD dwInputBuffer, \
                                     DWORD dwMinInstr, \
                                     DWORD dwMaxInstr)
{
  
  dwEncryptionKey = rnd_dword();

  
  DWORD dwAlignedSize = align_dword(dwInputBuffer);

  
  
  
  dwEncryptedBlocks = dwAlignedSize / <span>sizeof</span>(DWORD);

  PDWORD lpdwInputBuffer = <span>reinterpret_cast</span>&lt;PDWORD&gt;(lpInputBuffer);

  
  
  
  di_valloc(&amp;diEncryptedData, dwAlignedSize);

  PDWORD lpdwOutputBuffer = <span>reinterpret_cast</span>&lt;PDWORD&gt;(diEncryptedData.lpPtr);

  
  dwCryptOpsCount = rnd_range(dwMinInstr, dwMaxInstr);

  
  
  
  di_valloc(&amp;diCryptOps, dwCryptOpsCount * <span>sizeof</span>(SPE_CRYPT_OP));

  
  
  lpcoCryptOps = <span>reinterpret_cast</span>&lt;P_SPE_CRYPT_OP&gt;(diCryptOps.lpPtr);

  
  <span>for</span> (DWORD i = <span>0</span>; i &lt; dwCryptOpsCount; i++)
  {
    
    
    lpcoCryptOps[i].bCryptWithReg = rnd_bool();

    
    lpcoCryptOps[i].regDst = regData;

    
    
    
    <span>if</span> (lpcoCryptOps[i].bCryptWithReg == FALSE)
    {
      lpcoCryptOps[i].dwCryptValue = rnd_dword();
    }
    <span>else</span>
    {
      lpcoCryptOps[i].regSrc = regKey;
    }

    
    lpcoCryptOps[i].cCryptOp = <span>static_cast</span>&lt;BYTE&gt;(rnd_range(SPE_CRYPT_OP_ADD, SPE_CRYPT_OP_NEG));
  }

  
  
  <span>for</span> (DWORD i = <span>0</span>, dwInitialEncryptionKey = dwEncryptionKey; \
       i &lt; dwEncryptedBlocks; i++)
  {
    
    DWORD dwInputBlock = lpdwInputBuffer[i];

    
    
    <span>for</span> (DWORD j = <span>0</span>, dwCurrentEncryptionKey; j &lt; dwCryptOpsCount; j++)
    {
      <span>if</span> (lpcoCryptOps[j].bCryptWithReg == FALSE)
      {
        dwCurrentEncryptionKey = lpcoCryptOps[j].dwCryptValue;
      }
      <span>else</span>
      {
        dwCurrentEncryptionKey = dwInitialEncryptionKey;
      }

      
      
      
      <span>switch</span>(lpcoCryptOps[j].cCryptOp)
      {
      <span>case</span> SPE_CRYPT_OP_ADD:
        dwInputBlock += dwCurrentEncryptionKey;
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_SUB:
        dwInputBlock -= dwCurrentEncryptionKey;
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_XOR:
        dwInputBlock ^= dwCurrentEncryptionKey;
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_NOT:
        dwInputBlock = ~dwInputBlock;
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_NEG:
        dwInputBlock = <span>0L</span> - dwInputBlock;
        <span>break</span>;
      }
    }

    
    lpdwOutputBuffer[i] = dwInputBlock;
  }
}</code></pre>

</section>

<section itemprop="articleSection">

	<h2 id="setting-up-the-decryption-keys"><a href="#setting-up-the-decryption-keys" aria-label="Anchor link for: setting up the decryption keys" data-anchorjs-icon=""></a>Setting up the decryption keys</h2>

	<p>Our algorithm will use a randomly generated encryption key, but to prevent the key appearing directly in the code, we will encrypt it with a second, random key. At the start of the decryption function we will load the encrypted key into <code>regKey</code>, and then decrypt it.</p>

	<p><span>Listing 8.</span>Generating initialization code for the regKey register.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">





<span>void</span> CMutagenSPE::SetupDecryptionKeys()
{
  
  
  DWORD dwKeyModifier = rnd_dword();

  
  
  <span>switch</span>(rnd_max(<span>2</span>))
  {
  
  
  <span>case</span> <span>0</span>:
    a.mov(regKey, imm(dwEncryptionKey - dwKeyModifier));
    a.add(regKey, imm(dwKeyModifier));
    <span>break</span>;

  
  
  <span>case</span> <span>1</span>:
    a.mov(regKey, imm(dwEncryptionKey + dwKeyModifier));
    a.sub(regKey, imm(dwKeyModifier));
    <span>break</span>;

  
  
  <span>case</span> <span>2</span>:
    a.mov(regKey, imm(dwEncryptionKey ^ dwKeyModifier));
    a.xor_(regKey, imm(dwKeyModifier));
    <span>break</span>;
  }
}</code></pre>

</section>

<section itemprop="articleSection">

	<h2 id="decryption"><a href="#decryption" aria-label="Anchor link for: decryption" data-anchorjs-icon=""></a>Decryption</h2>

	<p>Using the pseudoinstructions we generated earlier and which we used to encrypt the data, we will now generate instructions which perform the encryption process in reverse, and place them in a loop that repeats this process on each input block. Before the loop we will initialize the register we have called <code>regSize</code> with the number of blocks which need to be decrypted.</p>

	<p><span>Listing 9.</span>Generating the code of the decryption loop.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">





<span>void</span> CMutagenSPE::GenerateDecryption()
{
  
  
  a.mov(regSize, imm(dwEncryptedBlocks));

  
  
  Label lblDecryptionLoop = a.newLabel();

  a.bind(lblDecryptionLoop);

  
  
  a.mov(regData, dword_ptr(regSrc));

  
  
  
  
  <span>for</span> (DWORD i = dwCryptOpsCount - <span>1</span>; i != <span>-1</span>L; i--)
  {
    
    
    
    
    <span>if</span> (lpcoCryptOps[i].bCryptWithReg == FALSE)
    {
      DWORD dwDecryptionKey = lpcoCryptOps[i].dwCryptValue;

      <span>switch</span>(lpcoCryptOps[i].cCryptOp)
      {
      <span>case</span> SPE_CRYPT_OP_ADD:
        a.sub(lpcoCryptOps[i].regDst, imm(dwDecryptionKey));
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_SUB:
        a.add(lpcoCryptOps[i].regDst, imm(dwDecryptionKey));
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_XOR:
        a.xor_(lpcoCryptOps[i].regDst, imm(dwDecryptionKey));
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_NOT:
        a.not_(lpcoCryptOps[i].regDst);
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_NEG:
        a.neg(lpcoCryptOps[i].regDst);
        <span>break</span>;
      }
    }
    <span>else</span>
    {
      <span>switch</span>(lpcoCryptOps[i].cCryptOp)
      {
      <span>case</span> SPE_CRYPT_OP_ADD:
        a.sub(lpcoCryptOps[i].regDst, lpcoCryptOps[i].regSrc);
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_SUB:
        a.add(lpcoCryptOps[i].regDst, lpcoCryptOps[i].regSrc);
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_XOR:
        a.xor_(lpcoCryptOps[i].regDst, lpcoCryptOps[i].regSrc);
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_NOT:
        a.not_(lpcoCryptOps[i].regDst);
        <span>break</span>;
      <span>case</span> SPE_CRYPT_OP_NEG:
        a.neg(lpcoCryptOps[i].regDst);
        <span>break</span>;
      }
    }
  }

  
  
  a.mov(dword_ptr(regDst), regData);

  
  
  a.add(regSrc, imm(<span>sizeof</span>(DWORD)));
  a.add(regDst, imm(<span>sizeof</span>(DWORD)));

  
  
  a.dec(regSize);

  
  
  a.jne(lblDecryptionLoop);
}</code></pre>

	<p>The loop takes successive encrypted blocks of data from the buffer at the end of the function, then carries out all the decryption instructions on each block, and writes the result to the output buffer. After decrypting a data block, the pointers to the encrypted data and the decrypted data buffer are updated, and the loop counter which indicates the number of blocks remaining is decremented. If it has not reached 0, the loop is repeated.</p>

</section>

<section itemprop="articleSection">

	<h2 id="setting-final-register-values"><a href="#setting-final-register-values" aria-label="Anchor link for: setting final register values" data-anchorjs-icon=""></a>Setting final register values</h2>

	<p>Our decryption function will return a value of type <code>DWORD</code> (a 32-bit value corresponding to <code>unsigned int</code>), which indicates the size of the decrypted data. This value will be returned in the <code>EAX</code> register.</p>

	<p><span>Listing 10.</span>Setting up the return value of the decryption function (the size of the decrypted data) as well as any other final values we wish to place in registers.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">





<span>void</span> CMutagenSPE::SetupOutputRegisters(SPE_OUTPUT_REGS *regOutput, DWORD dwCount)
{
  
  
  <span>if</span> ((regOutput == <span>NULL</span>) || (dwCount == <span>0</span>))
  {
    <span>return</span>;
  }

  
  
  mixup_array(regOutput, dwCount);

  
  
  
  <span>for</span> (DWORD i = <span>0</span>; i &lt; dwCount; i++)
  {
    a.mov(regOutput[i].regDst, imm(regOutput[i].dwValue));
  }
}</code></pre>

	<p>Our polymorphic engine allows any set of output registers to be defined (that is, we are not limited to setting the value returned in <code>EAX</code>). This makes it possible for the function to output extra values.</p>

</section>

<section itemprop="articleSection">

	<h2 id="function-epilogue"><a href="#function-epilogue" aria-label="Anchor link for: function epilogue" data-anchorjs-icon=""></a>Function epilogue</h2>

	<p>The epilogue, in other words, the last portion of the function, is where the original value of the <code>EBP</code> register is restored, and if necessary, the sensitive registers <code>ESI EDI EBX</code>, whose state must be preserved across function calls according to the <em>stdcall</em> convention.</p>

	<p><span>Listing 11.</span>Generating the epilogue of the decryption function.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">





<span>void</span> CMutagenSPE::GenerateEpilogue(DWORD dwParamCount)
{
  
  
  a.pop(regSafe3);
  a.pop(regSafe2);
  a.pop(regSafe1);

  
  <span>if</span> (rnd_bin() == <span>0</span>)
  {
    a.leave();
  }
  <span>else</span>
  {
    
    a.mov(esp,ebp);
    a.pop(ebp);
  }

  
  
  
  
  a.ret(imm(dwParamCount * <span>sizeof</span>(DWORD)));
}</code></pre>

</section>

<section itemprop="articleSection">

	<h2 id="alignment"><a href="#alignment" aria-label="Anchor link for: alignment" data-anchorjs-icon=""></a>Alignment</h2>

	<p>Instructions which access memory are faster if the data they read or write is <em>aligned</em>, i.e. divisible by the size of the block of memory being accessed. For instance, our encrypted data is accessed in 32-bit blocks (since we are using 32-bit registers), which means memory addresses should be divisible by 4. This is due to processor cache effects. If memory addresses are correctly aligned, the data can be stored in the fast memory attached to the processor known as <em>L1 cache</em>. Non-aligned addresses will be read from the slower <em>L2 cache</em> or directly from the computer's RAM. For small blocks of data, this does not create a noticeable difference, but for large buffers the performance reduction can be significant and should be taken into account.</p>

	<p><span>Listing 12.</span>Aligning the size of the decryption function to the specified granularity.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">






<span>void</span> CMutagenSPE::AlignDecryptorBody(DWORD dwAlignment)
{
  
  DWORD dwCurrentSize = a.getCodeSize();

  
  
  
  DWORD dwAlignmentSize = align_bytes(dwCurrentSize, dwAlignment) - dwCurrentSize;

  
  <span>if</span> (dwAlignmentSize == <span>0</span>)
  {
    <span>return</span>;
  }

  
  <span>if</span> (rnd_bin() == <span>0</span>)
  {
    <span>while</span> (dwAlignmentSize--) a.int3();
  }
  <span>else</span>
  {
    <span>while</span> (dwAlignmentSize--) a.nop();
  }
}</code></pre>

	<p>Alignment between functions is normally achieved with the 1-byte instruction <code>nop</code> (<em>no-operation</em>) or <code>int3</code> (an interrupt for the purpose of trapping into a debugger). Alignment is also performed for the beginning of loops, using instructions which have the same effect as <code>nop</code> but have a longer binary encoding, such as <code>lea eax,[eax*8+eax+00000000]</code>. In our case we won't bother with this level of optimization.</p>

</section>

<section itemprop="articleSection">

	<h2 id="fixing-up-delta-offset-addresses"><a href="#fixing-up-delta-offset-addresses" aria-label="Anchor link for: fixing up delta offset addresses" data-anchorjs-icon=""></a>Fixing up delta offset addresses</h2>

	<p>Having generated the entire code of the decryption function, we can now correct any relative addresses used earlier, which in our case is just the address of the encrypted data.</p>

	<p><span>Listing 13.</span>Correcting the address of the encrypted data in previously generated code.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">






<span>void</span> CMutagenSPE::UpdateDeltaOffsetAddressing()
{
  DWORD dwAdjustSize = <span>static_cast</span>&lt;DWORD&gt;(a.getOffset() - posDeltaOffset);

  
  
  
  
  
  
  
  
  a.setDWordAt(posSrcPtr, dwAdjustSize + dwUnusedCodeSize);
}</code></pre>

</section>

<section itemprop="articleSection">

	<h2 id="appending-the-encrypted-data"><a href="#appending-the-encrypted-data" aria-label="Anchor link for: appending the encrypted data" data-anchorjs-icon=""></a>Appending the encrypted data</h2>

	<p>Now that the entire code of the function has been generated, we can write out the encrypted data block, so it will follow the code of the function.</p>

	<p><span>Listing 14.</span>Place the encrypted data block after the end of the decryption function.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">






<span>void</span> CMutagenSPE::AppendEncryptedData()
{
  PDWORD lpdwEncryptedData = <span>reinterpret_cast</span>&lt;PDWORD&gt;(diEncryptedData.lpPtr);

  
  
  
  <span>for</span> (DWORD i = <span>0</span>; i &lt; dwEncryptedBlocks; i++)
  {
    a._emitDWord(lpdwEncryptedData[i]);
  }
}</code></pre>

</section>

<section itemprop="articleSection">

	<h2 id="our-entire-polymorphic-engine"><a href="#our-entire-polymorphic-engine" aria-label="Anchor link for: our entire polymorphic engine" data-anchorjs-icon=""></a>Our entire polymorphic engine</h2>

	<p>Now that you have seen the successive elements of the operation of our polymorphic engine, it's time to bring it all together. I have included the class header below, followed by the implementation of the main function which generates the polymorphic code.</p>

	<p><span>Listing 15.</span>Definition of the polymorphic engine class.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text"><span>#<span>include</span> <span>"mutagen.h"</span></span>

<span>class</span> CMutagenSPE : <span>private</span> CMutagen
{
<span>public</span>:
  CMutagenSPE(<span>void</span>);
  ~CMutagenSPE(<span>void</span>);

  
  
  
  CMutagen::<span>erCodes <span>PolySPE</span><span>(PBYTE lpInputBuffer, \
                            DWORD dwInputBuffer, \
                            PBYTE *lpOutputBuffer, \
                            PDWORD lpdwOutputSize)</span></span>;

<span>private</span>:

  
  
  <span>typedef</span> <span>struct</span> _SPE_OUTPUT_REGS {

    
    AsmJit::GPReg regDst;

    
    DWORD dwValue;

  } SPE_OUTPUT_REGS, *P_SPE_OUTPUT_REGS;

  
  <span>typedef</span> <span>struct</span> _SPE_CRYPT_OP {

    
    
    
    
    BOOL bCryptWithReg;

    AsmJit::GPReg regDst;
    AsmJit::GPReg regSrc;

    
    BYTE cCryptOp;

    
    DWORD dwCryptValue;

  } SPE_CRYPT_OP, *P_SPE_CRYPT_OP;

  <span>enum</span>
  {
    SPE_CRYPT_OP_ADD = <span>0</span>,
    SPE_CRYPT_OP_SUB,
    SPE_CRYPT_OP_XOR,
    SPE_CRYPT_OP_NOT,
    SPE_CRYPT_OP_NEG,
  };

  
  DATA_ITEM diCryptOps;

  
  
  P_SPE_CRYPT_OP lpcoCryptOps;

  
  DWORD dwCryptOpsCount;

  
  DATA_ITEM diEncryptedData;

  
  DWORD dwEncryptedBlocks;

  
  DWORD dwEncryptionKey;

  
  Assembler a;

  
  
  AsmJit::GPReg regSrc;

  
  
  AsmJit::GPReg regDst;

  
  
  AsmJit::GPReg regSize;

  
  AsmJit::GPReg regKey;

  
  
  AsmJit::GPReg regData;

  
  AsmJit::GPReg regSafe1, regSafe2, regSafe3;

  
  Label lblDeltaOffset;

  
  <span>sysint_t</span> posDeltaOffset;

  
  <span>sysint_t</span> posSrcPtr;

  
  
  
  DWORD dwUnusedCodeSize;

  
  <span><span>void</span> <span>RandomizeRegisters</span><span>()</span></span>;
  <span><span>void</span> <span>GeneratePrologue</span><span>()</span></span>;
  <span><span>void</span> <span>GenerateDeltaOffset</span><span>()</span></span>;
  <span><span>void</span> <span>EncryptInputBuffer</span><span>(PBYTE lpInputBuffer, \
                          DWORD dwInputBuffer, \
                          DWORD dwMinInstr, \
                          DWORD dwMaxInstr)</span></span>;
  <span><span>void</span> <span>SetupDecryptionKeys</span><span>()</span></span>;
  <span><span>void</span> <span>GenerateDecryption</span><span>()</span></span>;
  <span><span>void</span> <span>SetupOutputRegisters</span><span>(SPE_OUTPUT_REGS *regOutput, \
                            DWORD dwCount)</span></span>;
  <span><span>void</span> <span>GenerateEpilogue</span><span>(DWORD dwParamCount)</span></span>;
  <span><span>void</span> <span>AlignDecryptorBody</span><span>(DWORD dwAlignment)</span></span>;
  <span><span>void</span> <span>AppendEncryptedData</span><span>()</span></span>;
  <span><span>void</span> <span>UpdateDeltaOffsetAddressing</span><span>()</span></span>;
};</code></pre>

	<p><span>Listing 16.</span>The main function, which performs the encryption and generates the polymorphic code.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">






CMutagen::erCodes CMutagenSPE::PolySPE(PBYTE lpInputBuffer, \
                                       DWORD dwInputBuffer, \
                                       PBYTE *lpOutputBuffer, \
                                       PDWORD lpdwOutputSize)
{
  
  
  
  
  

  <span>if</span> ( (lpInputBuffer == <span>NULL</span>) || (dwInputBuffer == <span>0</span>) || \
       (lpOutputBuffer == <span>NULL</span>) || (lpdwOutputSize == <span>NULL</span>) )
  {
    <span>return</span> CMutagen::MUTAGEN_ERR_PARAMS;
  }

  
  RandomizeRegisters();

  
  
  
  
  

  
  GeneratePrologue();

  
  
  GenerateDeltaOffset();

  
  
  
  
  
  
  
  EncryptInputBuffer(lpInputBuffer, dwInputBuffer, <span>3</span>, <span>5</span>);

  
  SetupDecryptionKeys();

  
  GenerateDecryption();

  
  SPE_OUTPUT_REGS regOutput[] = { { eax, dwInputBuffer } };

  SetupOutputRegisters(regOutput, _countof(regOutput));

  
  GenerateEpilogue(<span>1L</span>);

  
  
  AlignDecryptorBody(rnd_bin() == <span>0</span> ? <span>4L</span> : <span>16L</span>);

  
  UpdateDeltaOffsetAddressing();

  
  AppendEncryptedData();

  
  
  
  
  

  
  di_vfree(&amp;diEncryptedData);

  
  di_vfree(&amp;diCryptOps);

  
  
  
  
  

  DWORD dwOutputSize = a.getCodeSize();

  
  
  PVOID lpPolymorphicCode = a.make();

  
  DATA_ITEM diOutput;

  
  
  di_valloc(&amp;diOutput, dwOutputSize);

  
  <span>if</span> (diOutput.lpPtr != <span>NULL</span>)
  {
    
    <span>memcpy</span>(diOutput.lpPtr, lpPolymorphicCode, dwOutputSize);

    
    
    *lpOutputBuffer = diOutput.lpPtr;
    *lpdwOutputSize = dwOutputSize;

    MemoryManager::getGlobal()-&gt;<span>free</span>(lpPolymorphicCode);
  }
  <span>else</span>
  {
    MemoryManager::getGlobal()-&gt;<span>free</span>(lpPolymorphicCode);

    <span>return</span> CMutagen::MUTAGEN_ERR_MEMORY;
  }

  
  
  
  
  

  <span>return</span> CMutagen::MUTAGEN_ERR_SUCCESS;
}</code></pre>

</section>

<section itemprop="articleSection">

	<h2 id="test"><a href="#test" aria-label="Anchor link for: test" data-anchorjs-icon=""></a>Test</h2>

	<p>In order to test out the code, we will encrypt a text string with our engine and then call the generated code of the decryption function. It's important to remember that the memory where the code is found should be allocated with the correct executable flags. Otherwise, the operating system's protection mechanisms, like e.g. Windows' <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366553%28v=vs.85%29.aspx" rel="nofollow"><em>DEP</em> (<em>Data Execution Prevention</em>) feature</a> will throw an exception if you attempt to call the function.</p>

	<p><span>Listing 17.</span>Testing the polymorphic engine.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text"><span>#<span>include</span> <span>&lt;conio.h&gt;</span></span>
<span>#<span>include</span> <span>"mutagen\mutagen.h"</span></span>
<span>#<span>include</span> <span>"mutagen\mutagen_spe.h"</span></span>


<span><span>typedef</span> <span>DWORD</span><span>(__stdcall *DecryptionProc)</span><span>(PVOID)</span></span>;

<span>int</span> __<span>cdecl <span>main</span><span>()</span>
</span>{
  
  
  <span>char</span> szHelloWorld[] = <span>"Hello world!"</span>;

  
  
  CMutagenSPE *speEngine = <span>new</span> CMutagenSPE();

  
  
  PBYTE lpcDecryptionProc = <span>NULL</span>;

  
  
  DWORD dwDecryptionProcSize = <span>0</span>;

  
  
  speEngine-&gt;PolySPE(<span>reinterpret_cast</span>&lt;PBYTE&gt;(szHelloWorld), \
                     <span>sizeof</span>(szHelloWorld), \
                     &amp;lpcDecryptionProc, \
                     &amp;dwDecryptionProcSize);

  
  FILE *hFile = fopen(<span>"polymorphic_code.bin"</span>, <span>"wb"</span>);

  <span>if</span> (hFile != <span>NULL</span>)
  {
    fwrite(lpDecryptionProc, dwDecryptionProcSize, <span>1</span>, hFile);
    fclose(hFile);
  }

  
  DecryptionProc lpDecryptionProc = <span>reinterpret_cast</span>&lt;DecryptionProc&gt;(lpcDecryptionProc);

  
  <span>char</span> szOutputBuffer[<span>128</span>] = { <span>0xCC</span> };

  
  
  DWORD dwOutputSize = lpDecryptionProc(szOutputBuffer);

  
  
  <span>printf</span>(szOutputBuffer);

  <span>return</span> <span>0</span>;
}</code></pre>

<section itemprop="articleSection">

	<h2 id="what-does-the-generated-code-look-like"><a href="#what-does-the-generated-code-look-like" aria-label="Anchor link for: what does the generated code look like" data-anchorjs-icon=""></a>What does the generated code look like?</h2>

	<p>The generated code will look different each time. This is the main goal of a polymorphic engine, after all! I have included two different decryption functions below, both generated by our engine from the same input data.</p>

	<p><span>Listing 18.</span>Decryption function.</p>

<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">
	<span>enter</span>   <span>0</span>, <span>0</span>


	<span>push</span>	<span>esi</span>
	<span>push</span>	<span>ebx</span>
	<span>push</span>	<span>edi</span>


	<span>mov</span>	<span>ecx</span>, [<span>ebp</span>+<span>8</span>]

	<span>call</span>	delta_offset


	<span>xor</span>	<span>eax</span>, <span>eax</span>
	<span>leave</span>
	<span>retn</span>	<span>4</span>
<span>
delta_offset:</span>


	<span>mov</span>	<span>ebx</span>, [<span>esp</span>]
	<span>add</span>	<span>esp</span>, <span>4</span>


	<span>add</span>	<span>ebx</span>, <span>51h</span>


	<span>mov</span>	<span>edx</span>, <span>918D3D1Bh</span>
	<span>add</span>	<span>edx</span>, <span>78170F2Ah</span>


	<span>mov</span>	<span>eax</span>, <span>4</span>
<span>
decryption_loop:</span>


	<span>mov</span>	<span>esi</span>, [<span>ebx</span>]


	<span>xor</span>	<span>esi</span>, <span>138E6781h</span>
	<span>sub</span>	<span>esi</span>, <span>edx</span>
	<span>not</span>	<span>esi</span>
	<span>xor</span>	<span>esi</span>, <span>edx</span>


	<span>mov</span>	[<span>ecx</span>], <span>esi</span>

	<span>add</span>	<span>ebx</span>, <span>4</span>
	<span>add</span>	<span>ecx</span>, <span>4</span>
	<span>dec</span>	<span>eax</span>
	<span>jnz</span>	short decryption_loop



	<span>mov</span>	<span>eax</span>, <span>0Dh</span>


	<span>pop</span>	<span>edi</span>
	<span>pop</span>	<span>ebx</span>
	<span>pop</span>	<span>esi</span>
	<span>leave</span>
	<span>retn</span>	<span>4</span>


	<span>db</span> <span>5</span> dup(<span>90h</span>)


	<span>db</span> <span>0B6h</span>, <span>044h</span>, <span>052h</span>, <span>0B0h</span>, <span>09Bh</span>, <span>087h</span>, <span>05Eh</span>, <span>0B1h</span>
	<span>db</span> <span>08Ch</span>, <span>04Bh</span>, <span>06Ah</span>, <span>0F3h</span>, <span>07Eh</span>, <span>0ACh</span>, <span>0B5h</span>, <span>057h</span></code></pre>

	<p><span>Listing 19.</span>Decryption function in another variant.</p>

	<pre itemscope="" itemtype="https://schema.org/Code"><code itemprop="text">
	<span>push</span>	<span>ebp</span>
	<span>mov</span>	<span>ebp</span>, <span>esp</span>


	<span>push</span>	<span>edi</span>
	<span>push</span>	<span>ebx</span>
	<span>push</span>	<span>esi</span>


	<span>mov</span>	<span>esi</span>, [<span>ebp</span>+<span>8</span>]

	<span>call</span>	delta_offset


	<span>xor</span>	<span>eax</span>, <span>eax</span>
	<span>leave</span>
	<span>retn</span>	<span>4</span>
<span>
delta_offset:</span>


	<span>mov</span>	<span>ecx</span>, [<span>esp</span>]
	<span>add</span>	<span>esp</span>, <span>4</span>


	<span>add</span>	<span>ecx</span>, <span>4Ah</span>


	<span>mov</span>	<span>ebx</span>, <span>76F71EBFh</span>
	<span>sub</span>	<span>ebx</span>, <span>50531439h</span>


	<span>mov</span>	<span>edi</span>, <span>4</span>


<span>decryption_loop:</span>


	<span>mov</span>	<span>eax</span>, [<span>ecx</span>]


	<span>neg</span>	<span>eax</span>
	<span>sub</span>	<span>eax</span>, <span>4B1A7C17h</span>
	<span>not</span>	<span>eax</span>
	<span>xor</span>	<span>eax</span>, <span>ebx</span>
	<span>neg</span>	<span>eax</span>


	<span>mov</span>	[<span>esi</span>], <span>eax</span>

	<span>add</span>	<span>ecx</span>, <span>4</span>
	<span>add</span>	<span>esi</span>, <span>4</span>
	<span>dec</span>	<span>edi</span>
	<span>jnz</span>	short decryption_loop



	<span>mov</span>	<span>eax</span>, <span>0Dh</span>


	<span>pop</span>	<span>esi</span>
	<span>pop</span>	<span>ebx</span>
	<span>pop</span>	<span>edi</span>
	<span>leave</span>
	<span>retn</span>	<span>4</span>


	<span>db</span> <span>5</span> dup(<span>0CCh</span>)


	<span>db</span> <span>028h</span>, <span>014h</span>, <span>01Dh</span>, <span>06Ah</span>, <span>001h</span>, <span>059h</span>, <span>012h</span>, <span>06Bh</span>
	<span>db</span> <span>0F2h</span>, <span>01Ch</span>, <span>025h</span>, <span>0ADh</span>, <span>070h</span>, <span>0C2h</span>, <span>07Ch</span>, <span>0CAh</span></code></pre>

</section>

<section itemprop="articleSection">

<h2 id="what-next"><a href="#what-next" aria-label="Anchor link for: what next" data-anchorjs-icon=""></a>What next?</h2>

<p>Our polymorphic engine is pretty simple at the moment. We could add additional features, such as:</p>

<ul>
	<li>generating spurious instructions, known as <em>junks</em> – these are simply blocks of code which make the code more difficult to analyze in a debugger or disassembler</li>
	<li>generating white noise – that is, instructions which don't affect the operation of the function (e.g. adding a value to a random register and then taking it away again)</li>
	<li>generating equivalent instructions (code mutations) in various forms, joined by random comparisons and jumps</li>
	<li>generating additional helper functions, e.g. returning values which were originally put in place by code in the main decryption function</li>
	<li>changes to the calling convention used, e.g. using <em>cdecl</em> instead of <em>stdcall</em></li>
	<li>adding jumps to the code so the instructions are not executed linearly</li>
	<li>and, most advanced – multilayer encryption, that is, generated code which in turn contains another layer of decryptor</li>
</ul>

<p>This can all be taken quite a long way, especially making use of a library like <em>AsmJit</em>, which greatly simplifies the dynamic generation of assembly code, including the use of all current extensions of x86 and x64 processors.</p>

</section>

<section itemprop="articleSection">



</section>

<section itemprop="articleSection">

<h2 id="references"><a href="#references" aria-label="Anchor link for: references" data-anchorjs-icon=""></a>References</h2>



</section>

<section itemprop="articleSection">

	

</section>

<!-- article body -->
</section>

</section></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>