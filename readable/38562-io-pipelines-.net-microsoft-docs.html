<!DOCTYPE html>
<html lang="en">
<head>
    <title>
I/O pipelines - .NET | Microsoft Docs -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>I/O pipelines - .NET | Microsoft Docs</h1><div><div id="main" class="content "><p><a href="/en-us/dotnet/api/system.io.pipelines" data-linktype="absolute-path">System.IO.Pipelines</a> is a new library that is designed to make it easier to do high-performance I/O in .NET. It’s a library targeting .NET Standard that works on all .NET implementations.</p><h2 id="what-problem-does-systemiopipelines-solve">What problem does System.IO.Pipelines solve</h2><p>Apps that parse streaming data are composed of boilerplate code having many specialized and unusual code flows. The boilerplate and special case code is complex and difficult to maintain.</p><p><code>System.IO.Pipelines</code> was architected to:</p><ul><li>Have high performance parsing streaming data.</li><li>Reduce code complexity.</li></ul><p>The following code is typical for a TCP server that receives line-delimited messages (delimited by <code>'\n'</code>) from a client:</p><pre><code class="lang-csharp">async Task ProcessLinesAsync(NetworkStream stream)
{
    var buffer = new byte[1024];
    await stream.ReadAsync(buffer, 0, buffer.Length);

    // Process a single line from the buffer
    ProcessLine(buffer);
}
</code></pre><p>The preceding code has several problems:</p><ul><li>The entire message (end of line) might not be received in a single call to <code>ReadAsync</code>.</li><li>It's ignoring the result of <code>stream.ReadAsync</code>. <code>stream.ReadAsync</code> returns how much data was read.</li><li>It doesn't handle the case where multiple lines are read in a single <code>ReadAsync</code> call.</li><li>It allocates a <code>byte</code> array with each read.</li></ul><p>To fix the preceding problems, the following changes are required:</p><ul><li><p>Buffer the incoming data until a new line is found.</p></li><li><p>Parse all the lines returned in the buffer.</p></li><li><p>It's possible that the line is bigger than 1 KB (1024 bytes). The code needs to resize the input buffer until the delimiter is found in order to fit the complete line inside the buffer.</p><ul><li>If the buffer is resized, more buffer copies are made as longer lines appear in the input.</li><li>To reduce wasted space, compact the buffer used for reading lines.</li></ul></li><li><p>Consider using buffer pooling to avoid allocating memory repeatedly.</p></li><li><p>The following code addresses some of these problems:</p></li></ul><pre><code class="lang-csharp">async Task ProcessLinesAsync(NetworkStream stream)
{
    byte[] buffer = ArrayPool&lt;byte&gt;.Shared.Rent(1024);
    var bytesBuffered = 0;
    var bytesConsumed = 0;

    while (true)
    {
        // Calculate the amount of bytes remaining in the buffer.
        var bytesRemaining = buffer.Length - bytesBuffered;

        if (bytesRemaining == 0)
        {
            // Double the buffer size and copy the previously buffered data into the new buffer.
            var newBuffer = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length * 2);
            Buffer.BlockCopy(buffer, 0, newBuffer, 0, buffer.Length);
            // Return the old buffer to the pool.
            ArrayPool&lt;byte&gt;.Shared.Return(buffer);
            buffer = newBuffer;
            bytesRemaining = buffer.Length - bytesBuffered;
        }

        var bytesRead = await stream.ReadAsync(buffer, bytesBuffered, bytesRemaining);
        if (bytesRead == 0)
        {
            // EOF
            break;
        }

        // Keep track of the amount of buffered bytes.
        bytesBuffered += bytesRead;
        var linePosition = -1;

        do
        {
            // Look for a EOL in the buffered data.
            linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed,
                                         bytesBuffered - bytesConsumed);

            if (linePosition &gt;= 0)
            {
                // Calculate the length of the line based on the offset.
                var lineLength = linePosition - bytesConsumed;

                // Process the line.
                ProcessLine(buffer, bytesConsumed, lineLength);

                // Move the bytesConsumed to skip past the line consumed (including \n).
                bytesConsumed += lineLength + 1;
            }
        }
        while (linePosition &gt;= 0);
    }
}
</code></pre><p>The previous code is complex and doesn't address all the problems identified. High-performance networking usually means writing very complex code to maximize performance. <code>System.IO.Pipelines</code> was designed to make writing this type of code easier.</p><h2 id="pipe">Pipe</h2><p>The <a href="/en-us/dotnet/api/system.io.pipelines.pipe" data-linktype="absolute-path">Pipe</a> class can be used to create a <code>PipeWriter/PipeReader</code> pair. All data written into the <code>PipeWriter</code> is available in the <code>PipeReader</code>:</p><pre><code class="lang-csharp">var pipe = new Pipe();
PipeReader reader = pipe.Reader;
PipeWriter writer = pipe.Writer;
</code></pre><h3 id="pipe-basic-usage">Pipe basic usage</h3><pre><code class="lang-csharp">async Task ProcessLinesAsync(Socket socket)
{
    var pipe = new Pipe();
    Task writing = FillPipeAsync(socket, pipe.Writer);
    Task reading = ReadPipeAsync(pipe.Reader);

    await Task.WhenAll(reading, writing);
}

async Task FillPipeAsync(Socket socket, PipeWriter writer)
{
    const int minimumBufferSize = 512;

    while (true)
    {
        // Allocate at least 512 bytes from the PipeWriter.
        Memory&lt;byte&gt; memory = writer.GetMemory(minimumBufferSize);
        try
        {
            int bytesRead = await socket.ReceiveAsync(memory, SocketFlags.None);
            if (bytesRead == 0)
            {
                break;
            }
            // Tell the PipeWriter how much was read from the Socket.
            writer.Advance(bytesRead);
        }
        catch (Exception ex)
        {
            LogError(ex);
            break;
        }

        // Make the data available to the PipeReader.
        FlushResult result = await writer.FlushAsync();

        if (result.IsCompleted)
        {
            break;
        }
    }

     // By completing PipeWriter, tell the PipeReader that there's no more data coming.
    await writer.CompleteAsync();
}

async Task ReadPipeAsync(PipeReader reader)
{
    while (true)
    {
        ReadResult result = await reader.ReadAsync();
        ReadOnlySequence&lt;byte&gt; buffer = result.Buffer;

        while (TryReadLine(ref buffer, out ReadOnlySequence&lt;byte&gt; line))
        {
            // Process the line.
            ProcessLine(line);
        }

        // Tell the PipeReader how much of the buffer has been consumed.
        reader.AdvanceTo(buffer.Start, buffer.End);

        // Stop reading if there's no more data coming.
        if (result.IsCompleted)
        {
            break;
        }
    }

    // Mark the PipeReader as complete.
    await reader.CompleteAsync();
}

bool TryReadLine(ref ReadOnlySequence&lt;byte&gt; buffer, out ReadOnlySequence&lt;byte&gt; line)
{
    // Look for a EOL in the buffer.
    SequencePosition? position = buffer.PositionOf((byte)'\n');

    if (position == null)
    {
        line = default;
        return false;
    }

    // Skip the line + the \n.
    line = buffer.Slice(0, position.Value);
    buffer = buffer.Slice(buffer.GetPosition(1, position.Value));
    return true;
}
</code></pre><p>There are two loops:</p><ul><li><code>FillPipeAsync</code> reads from the <code>Socket</code> and writes to the <code>PipeWriter</code>.</li><li><code>ReadPipeAsync</code> reads from the <code>PipeReader</code> and parses incoming lines.</li></ul><p>There are no explicit buffers allocated. All buffer management is delegated to the <code>PipeReader</code> and <code>PipeWriter</code> implementations. Delegating buffer management makes it easier for consuming code to focus solely on the business logic.</p><p>In the first loop:</p><p>In the second loop, the <code>PipeReader</code> consumes the buffers written by <code>PipeWriter</code>. The buffers come from the socket. The call to <code>PipeReader.ReadAsync</code>:</p><ul><li><p>Returns a <a href="/en-us/dotnet/api/system.io.pipelines.readresult" data-linktype="absolute-path">ReadResult</a> that contains two important pieces of information:</p><ul><li>The data that was read in the form of <code>ReadOnlySequence&lt;byte&gt;</code>.</li><li>A boolean <code>IsCompleted</code> that indicates if the end of data (EOF) has been reached.</li></ul></li></ul><p>After finding the end of line (EOL) delimiter and parsing the line:</p><ul><li>The logic processes the buffer to skip what's already processed.</li><li><code>PipeReader.AdvanceTo</code> is called to tell the <code>PipeReader</code> how much data has been consumed and examined.</li></ul><p>The reader and writer loops end by calling <code>Complete</code>. <code>Complete</code> lets the underlying Pipe release the memory it allocated.</p><h3 id="backpressure-and-flow-control">Backpressure and flow control</h3><p>Ideally, reading and parsing work together:</p><ul><li>The writing thread consumes data from the network and puts it in buffers.</li><li>The parsing thread is responsible for constructing the appropriate data structures.</li></ul><p>Typically, parsing takes more time than just copying blocks of data from the network:</p><ul><li>The reading thread gets ahead of the parsing thread.</li><li>The reading thread has to either slow down or allocate more memory to store the data for the parsing thread.</li></ul><p>For optimal performance, there's a balance between frequent pauses and allocating more memory.</p><p>To solve the preceding problem, the <code>Pipe</code> has two settings to control the flow of data:</p><p><img src="media/pipelines/resume-pause.png" alt="Diagram with ResumeWriterThreshold and PauseWriterThreshold" data-linktype="relative-path"></p><p><a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.flushasync" data-linktype="absolute-path">PipeWriter.FlushAsync</a>:</p><ul><li>Returns an incomplete <code>ValueTask&lt;FlushResult&gt;</code> when the amount of data in the <code>Pipe</code> crosses <code>PauseWriterThreshold</code>.</li><li>Completes <code>ValueTask&lt;FlushResult&gt;</code> when it becomes lower than <code>ResumeWriterThreshold</code>.</li></ul><p>Two values are used to prevent rapid cycling, which can occur if one value is used.</p><h3 id="examples">Examples</h3><pre><code class="lang-csharp">// The Pipe will start returning incomplete tasks from FlushAsync until
// the reader examines at least 5 bytes.
var options = new PipeOptions(pauseWriterThreshold: 10, resumeWriterThreshold: 5);
var pipe = new Pipe(options);
</code></pre><h3 id="pipescheduler">PipeScheduler</h3><p>Typically when using <code>async</code> and <code>await</code>, asynchronous code resumes on either on a <a href="/en-us/dotnet/api/system.threading.tasks.taskscheduler" data-linktype="absolute-path">TaskScheduler</a> or on the current  <a href="/en-us/dotnet/api/system.threading.synchronizationcontext" data-linktype="absolute-path">SynchronizationContext</a>.</p><p>When doing I/O, it's important to have fine-grained control over where the I/O is performed. This control allows taking advantage of CPU caches effectively. Efficient caching is critical for high-performance apps like web servers. <a href="/en-us/dotnet/api/system.io.pipelines.pipescheduler" data-linktype="absolute-path">PipeScheduler</a> provides control over where asynchronous callbacks run. By default:</p><ul><li>The current <a href="/en-us/dotnet/api/system.threading.synchronizationcontext" data-linktype="absolute-path">SynchronizationContext</a> is used.</li><li>If there's no <code>SynchronizationContext</code>, it uses the thread pool to run callbacks.</li></ul><pre><code class="lang-csharp">public static void Main(string[] args)
{
    var writeScheduler = new SingleThreadPipeScheduler();
    var readScheduler = new SingleThreadPipeScheduler();

    // Tell the Pipe what schedulers to use and disable the SynchronizationContext.
    var options = new PipeOptions(readerScheduler: readScheduler,
                                  writerScheduler: writeScheduler,
                                  useSynchronizationContext: false);
    var pipe = new Pipe(options);
}

// This is a sample scheduler that async callbacks on a single dedicated thread.
public class SingleThreadPipeScheduler : PipeScheduler
{
    private readonly BlockingCollection&lt;(Action&lt;object&gt; Action, object State)&gt; _queue =
     new BlockingCollection&lt;(Action&lt;object&gt; Action, object State)&gt;();
    private readonly Thread _thread;

    public SingleThreadPipeScheduler()
    {
        _thread = new Thread(DoWork);
        _thread.Start();
    }

    private void DoWork()
    {
        foreach (var item in _queue.GetConsumingEnumerable())
        {
            item.Action(item.State);
        }
    }

    public override void Schedule(Action&lt;object&gt; action, object state)
    {
        _queue.Add((action, state));
    }
}
</code></pre><p><a href="/en-us/dotnet/api/system.io.pipelines.pipescheduler.threadpool#System_IO_Pipelines_PipeScheduler_ThreadPool" data-linktype="absolute-path">PipeScheduler.ThreadPool</a> is the <a href="/en-us/dotnet/api/system.io.pipelines.pipescheduler" data-linktype="absolute-path">PipeScheduler</a> implementation that queues callbacks to the thread pool. <code>PipeScheduler.ThreadPool</code> is the default and generally the best choice. <a href="/en-us/dotnet/api/system.io.pipelines.pipescheduler.inline#System_IO_Pipelines_PipeScheduler_Inline" data-linktype="absolute-path">PipeScheduler.Inline</a> can cause unintended consequences such as deadlocks.</p><h3 id="pipe-reset">Pipe reset</h3><p>It's frequently efficient to reuse the <code>Pipe</code> object. To reset the pipe, call <a href="/en-us/dotnet/api/system.io.pipelines.pipereader" data-linktype="absolute-path">PipeReader</a><a href="/en-us/dotnet/api/system.io.pipelines.pipe.reset" data-linktype="absolute-path">Reset</a> when both the <code>PipeReader</code> and <code>PipeWriter</code> are complete.</p><h2 id="pipereader">PipeReader</h2><p><a href="/en-us/dotnet/api/system.io.pipelines.pipereader" data-linktype="absolute-path">PipeReader</a> manages memory on the caller's behalf. <strong>Always</strong> call <a href="/en-us/dotnet/api/system.io.pipelines.pipereader.advanceto" data-linktype="absolute-path">PipeReader.AdvanceTo</a> after calling <a href="/en-us/dotnet/api/system.io.pipelines.pipereader.readasync" data-linktype="absolute-path">PipeReader.ReadAsync</a>. This lets the <code>PipeReader</code> know when the caller is done with the memory so that it can be tracked. The <code>ReadOnlySequence&lt;byte&gt;</code> returned from <code>PipeReader.ReadAsync</code> is only valid until the call the <code>PipeReader.AdvanceTo</code>. It's illegal to use <code>ReadOnlySequence&lt;byte&gt;</code> after calling <code>PipeReader.AdvanceTo</code>.</p><p><code>PipeReader.AdvanceTo</code> takes two <a href="/en-us/dotnet/api/system.sequenceposition" data-linktype="absolute-path">SequencePosition</a> arguments:</p><ul><li>The first argument determines how much memory was consumed.</li><li>The second argument determines how much of the buffer was observed.</li></ul><p>Marking data as consumed means that the pipe can return the memory to the underlying buffer pool. Marking data as observed controls what the next call to <code>PipeReader.ReadAsync</code> does. Marking everything as observed means that the next call to <code>PipeReader.ReadAsync</code> won't return until there's more data written to the pipe. Any other value will make the next call to <code>PipeReader.ReadAsync</code> return immediately with the observed <em>and</em> unobserved data, but data that has already been consumed.</p><h3 id="read-streaming-data-scenarios">Read streaming data scenarios</h3><p>There are a couple of typical patterns that emerge when trying to read streaming data:</p><ul><li>Given a stream of data, parse a single message.</li><li>Given a stream of data, parse all available messages.</li></ul><p>The following examples use the <code>TryParseMessage</code> method for parsing messages from a <code>ReadOnlySequence&lt;byte&gt;</code>. <code>TryParseMessage</code> parses a single message and update the input buffer to trim the parsed message from the buffer. <code>TryParseMessage</code> is not part of .NET, it's a user written method used in the following sections.</p><pre><code class="lang-csharp">bool TryParseMessage(ref ReadOnlySequence&lt;byte&gt; buffer, out Message message);
</code></pre><h3 id="read-a-single-message">Read a single message</h3><p>The following code reads a single message from a <code>PipeReader</code> and returns it to the caller.</p><pre><code class="lang-csharp" name="ReadSingleMsg">async ValueTask&lt;Message&gt; ReadSingleMessageAsync(PipeReader reader,
 CancellationToken cancellationToken = default)
{
    while (true)
    {
        ReadResult result = await reader.ReadAsync(cancellationToken);
        ReadOnlySequence&lt;byte&gt; buffer = result.Buffer;

        // In the event that no message is parsed successfully, mark consumed 
        // as nothing and examined as the entire buffer.
        SequencePosition consumed = buffer.Start;
        SequencePosition examined = buffer.End;

        try
        {
            if (TryParseMessage(ref buffer, out Message message))
            {
                // A single message was successfully parsed so mark the start as the 
                // parsed buffer as consumed. TryParseMessage trims the buffer to 
                // point to the data after the message was parsed.
                consumed = buffer.Start;

                // Examined is marked the same as consumed here, so the next call 
                // to ReadSingleMessageAsync will process the next message if there's 
                // one.
                examined = consumed;

                return message;
            }

            // There's no more data to be processed.
            if (result.IsCompleted)
            {
                if (buffer.Length &gt; 0)
                {
                    // The message is incomplete and there's no more data to process.
                    throw new InvalidDataException("Incomplete message.");
                }

                break;
            }
        }
        finally
        {
            reader.AdvanceTo(consumed, examined);
        }
    }

    return null;
}
</code></pre><p>The preceding code:</p><ul><li>Parses a single message.</li><li>Updates the consumed <code>SequencePosition</code> and examined <code>SequencePosition</code> to point to the start of the trimmed input buffer.</li></ul><p>The two <code>SequencePosition</code> arguments are updated because <code>TryParseMessage</code> removes the parsed message from the input buffer. Generally, when parsing a single message from the buffer, the examined position should be one of the following:</p><ul><li>The end of the message.</li><li>The end of the received buffer if no message was found.</li></ul><p>The single message case has the most potential for errors. Passing the wrong values to <em>examined</em> can result in an out of memory exception or an infinite loop. For more information, see the <a href="#gotchas" data-linktype="self-bookmark">PipeReader common problems</a> section in this article.</p><h3 id="reading-multiple-messages">Reading multiple messages</h3><p>The following code reads all messages from a <code>PipeReader</code> and calls <code>ProcessMessageAsync</code> on each.</p><pre><code class="lang-csharp" name="MyConnection1">async Task ProcessMessagesAsync(PipeReader reader, CancellationToken cancellationToken = default)
{
    try
    {
        while (true)
        {
            ReadResult result = await reader.ReadAsync(cancellationToken);
            ReadOnlySequence&lt;byte&gt; buffer = result.Buffer;

            try
            {
                // Process all messages from the buffer, modifying the input buffer on each 
                // iteration.
                while (TryParseMessage(ref buffer, out Message message))
                {
                    await ProcessMessageAsync(message);
                }

                // There's no more data to be processed.
                if (result.IsCompleted)
                {
                    if (buffer.Length &gt; 0)
                    {
                        // The message is incomplete and there's no more data to process.
                        throw new InvalidDataException("Incomplete message.");
                    }
                    break;
                }
            }
            finally
            {
                // Since all messages in the buffer are being processed, you can use the 
                // remaining buffer's Start and End position to determine consumed and examined.
                reader.AdvanceTo(buffer.Start, buffer.End);
            }
        }
    }
    finally
    {
        await reader.CompleteAsync();
    }
}
</code></pre><h3 id="cancellation">Cancellation</h3><p><code>PipeReader.ReadAsync</code>:</p><ul><li>Supports passing a <a href="/en-us/dotnet/api/system.threading.cancellationtoken" data-linktype="absolute-path">CancellationToken</a>.</li><li>Throws an <a href="/en-us/dotnet/api/system.operationcanceledexception" data-linktype="absolute-path">OperationCanceledException</a> if the <code>CancellationToken</code> is canceled while there's a read pending.</li><li>Supports a way to cancel the current read operation via <a href="/en-us/dotnet/api/system.io.pipelines.pipereader.cancelpendingread" data-linktype="absolute-path">PipeReader.CancelPendingRead</a>, which avoids raising an exception. Calling <code>PipeReader.CancelPendingRead</code> causes the current or next call to <code>PipeReader.ReadAsync</code> to return a <a href="/en-us/dotnet/api/system.io.pipelines.readresult" data-linktype="absolute-path">ReadResult</a> with <code>IsCanceled</code> set to <code>true</code>. This can be useful for halting the existing read loop in a non-destructive and non-exceptional way.</li></ul><pre><code class="lang-csharp" name="MyConnection">private PipeReader reader;

public MyConnection(PipeReader reader)
{
    this.reader = reader;
}

public void Abort()
{
    // Cancel the pending read so the process loop ends without an exception.
    reader.CancelPendingRead();
}

public async Task ProcessMessagesAsync()
{
    try
    {
        while (true)
        {
            ReadResult result = await reader.ReadAsync();
            ReadOnlySequence&lt;byte&gt; buffer = result.Buffer;

            try
            {
                if (result.IsCanceled)
                {
                    // The read was canceled. You can quit without reading the existing data.
                    break;
                }

                // Process all messages from the buffer, modifying the input buffer on each 
                // iteration.
                while (TryParseMessage(ref buffer, out Message message))
                {
                    await ProcessMessageAsync(message);
                }

                // There's no more data to be processed.
                if (result.IsCompleted)
                {
                    break;
                }
            }
            finally
            {
                // Since all messages in the buffer are being processed, you can use the 
                // remaining buffer's Start and End position to determine consumed and examined.
                reader.AdvanceTo(buffer.Start, buffer.End);
            }
        }
    }
    finally
    {
        await reader.CompleteAsync();
    }
}
</code></pre><h3 id="pipereader-common-problems">PipeReader common problems</h3><ul><li><p>Passing the wrong values to <code>consumed</code> or <code>examined</code> may result in reading already read data.</p></li><li><p>Passing <code>buffer.End</code> as examined may result in:</p><ul><li>Stalled data</li><li>Possibly an eventual Out of Memory (OOM) exception if data isn't consumed. For example, <code>PipeReader.AdvanceTo(position, buffer.End)</code> when processing a single message at a time from the buffer.</li></ul></li><li><p>Passing the wrong values to <code>consumed</code> or <code>examined</code> may result in an infinite loop. For example, <code>PipeReader.AdvanceTo(buffer.Start)</code> if <code>buffer.Start</code> hasn't changed will cause the next call to <code>PipeReader.ReadAsync</code> to return immediately before new data arrives.</p></li><li><p>Passing the wrong values to <code>consumed</code> or <code>examined</code> may result in infinite buffering (eventual OOM).</p></li><li><p>Using the <code>ReadOnlySequence&lt;byte&gt;</code> after calling <code>PipeReader.AdvanceTo</code> may result in memory corruption (use after free).</p></li><li><p>Failing to call <code>PipeReader.Complete/CompleteAsync</code> may result in a memory leak.</p></li><li><p>Checking <a href="/en-us/dotnet/api/system.io.pipelines.readresult.iscompleted#System_IO_Pipelines_ReadResult_IsCompleted" data-linktype="absolute-path">ReadResult.IsCompleted</a> and exiting the reading logic before processing the buffer results in data loss. The loop exit condition should be based on <code>ReadResult.Buffer.IsEmpty</code> and <code>ReadResult.IsCompleted</code>. Doing this incorrectly could result in an infinite loop.</p></li></ul><h4 id="problematic-code">Problematic code</h4><p>❌ <strong>Data loss</strong></p><p>The <code>ReadResult</code> can return the final segment of data when <code>IsCompleted</code> is set to <code>true</code>. Not reading that data before exiting the read loop will result in data loss.</p><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><pre><code class="lang-csharp" name="DoNotUse#1">Environment.FailFast("This code is terrible, don't use it!");
while (true)
{
    ReadResult result = await reader.ReadAsync(cancellationToken);
    ReadOnlySequence&lt;byte&gt; dataLossBuffer = result.Buffer;

    if (result.IsCompleted)
    {
        break;
    }

    Process(ref dataLossBuffer, out Message message);

    reader.AdvanceTo(dataLossBuffer.Start, dataLossBuffer.End);
}
</code></pre><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><p>❌ <strong>Infinite loop</strong></p><p>The following logic may result in an infinite loop if the <code>Result.IsCompleted</code> is <code>true</code> but there's never a complete message in the buffer.</p><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><pre><code class="lang-csharp" name="DoNotUse#2">Environment.FailFast("This code is terrible, don't use it!");
while (true)
{
    ReadResult result = await reader.ReadAsync(cancellationToken);
    ReadOnlySequence&lt;byte&gt; infiniteLoopBuffer = result.Buffer;
    if (result.IsCompleted &amp;&amp; infiniteLoopBuffer.IsEmpty)
    {
        break;
    }

    Process(ref infiniteLoopBuffer, out Message message);

    reader.AdvanceTo(infiniteLoopBuffer.Start, infiniteLoopBuffer.End);
}
</code></pre><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><p>Here's another piece of code with the same problem. It's checking for a non-empty buffer before checking <code>ReadResult.IsCompleted</code>. Because it's in an <code>else if</code>, it will loop forever if there's never a complete message in the buffer.</p><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><pre><code class="lang-csharp" name="DoNotUse#3">Environment.FailFast("This code is terrible, don't use it!");
while (true)
{
    ReadResult result = await reader.ReadAsync(cancellationToken);
    ReadOnlySequence&lt;byte&gt; infiniteLoopBuffer = result.Buffer;

    if (!infiniteLoopBuffer.IsEmpty)
    {
        Process(ref infiniteLoopBuffer, out Message message);
    }
    else if (result.IsCompleted)
    {
        break;
    }

    reader.AdvanceTo(infiniteLoopBuffer.Start, infiniteLoopBuffer.End);
}
</code></pre><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><p>❌ <strong>Unexpected Hang</strong></p><p>Unconditionally calling <code>PipeReader.AdvanceTo</code> with <code>buffer.End</code> in the <code>examined</code> position may result in hangs when parsing a single message. The next call to <code>PipeReader.AdvanceTo</code> won't return until:</p><ul><li>There's more data written to the pipe.</li><li>And the new data wasn't previously examined.</li></ul><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><pre><code class="lang-csharp" name="DoNotUse#4">Environment.FailFast("This code is terrible, don't use it!");
while (true)
{
    ReadResult result = await reader.ReadAsync(cancellationToken);
    ReadOnlySequence&lt;byte&gt; hangBuffer = result.Buffer;

    Process(ref hangBuffer, out Message message);

    if (result.IsCompleted)
    {
        break;
    }

    reader.AdvanceTo(hangBuffer.Start, hangBuffer.End);

    if (message != null)
    {
        return message;
    }
}
</code></pre><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><p>❌ <strong>Out of Memory (OOM)</strong></p><p>With the following conditions, the following code keeps buffering until an <a href="/en-us/dotnet/api/system.outofmemoryexception" data-linktype="absolute-path">OutOfMemoryException</a> occurs:</p><ul><li>There's no maximum message size.</li><li>The data returned from the <code>PipeReader</code> doesn't make a complete message. For example, it doesn't make a complete message because the other side is writing a large message (For example, a 4-GB message).</li></ul><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><pre><code class="lang-csharp" name="DoNotUse#5">Environment.FailFast("This code is terrible, don't use it!");
while (true)
{
    ReadResult result = await reader.ReadAsync(cancellationToken);
    ReadOnlySequence&lt;byte&gt; thisCouldOutOfMemory = result.Buffer;

    Process(ref thisCouldOutOfMemory, out Message message);

    if (result.IsCompleted)
    {
        break;
    }

    reader.AdvanceTo(thisCouldOutOfMemory.Start, thisCouldOutOfMemory.End);

    if (message != null)
    {
        return message;
    }
}
</code></pre><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><p>❌ <strong>Memory Corruption</strong></p><p>When writing helpers that read the buffer, any returned payload should be copied before calling <code>Advance</code>. The following example will return memory that the <code>Pipe</code> has discarded and may reuse it for the next operation (read/write).</p><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><pre><code class="lang-csharp" name="DoNotUse#Message">public class Message
{
    public ReadOnlySequence&lt;byte&gt; CorruptedPayload { get; set; }
}
</code></pre><pre><code class="lang-csharp" name="DoNotUse#6">    Environment.FailFast("This code is terrible, don't use it!");
    Message message = null;

    while (true)
    {
        ReadResult result = await reader.ReadAsync(cancellationToken);
        ReadOnlySequence&lt;byte&gt; buffer = result.Buffer;

        ReadHeader(ref buffer, out int length);

        if (length &lt;= buffer.Length)
        {
            message = new Message
            {
                // Slice the payload from the existing buffer
                CorruptedPayload = buffer.Slice(0, length)
            };

            buffer = buffer.Slice(length);
        }

        if (result.IsCompleted)
        {
            break;
        }

        reader.AdvanceTo(buffer.Start, buffer.End);

        if (message != null)
        {
            // This code is broken since reader.AdvanceTo() was called with a position *after* the buffer 
            // was captured.
            break;
        }
    }

    return message;
}
</code></pre><div class="WARNING"><p>Warning</p><p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p></div><h2 id="pipewriter">PipeWriter</h2><p>The <a href="/en-us/dotnet/api/system.io.pipelines.pipewriter" data-linktype="absolute-path">PipeWriter</a> manages buffers for writing on the caller's behalf. <code>PipeWriter</code> implements <a href="/en-us/dotnet/api/system.buffers.ibufferwriter-1" data-linktype="absolute-path"><code>IBufferWriter&lt;byte&gt;</code></a>. <code>IBufferWriter&lt;byte&gt;</code> makes it possible to get access to buffers to perform writes without additional buffer copies.</p><pre><code class="lang-csharp" name="MyPipeWriter">async Task WriteHelloAsync(PipeWriter writer, CancellationToken cancellationToken = default)
{
    // Request at least 5 bytes from the PipeWriter.
    Memory&lt;byte&gt; memory = writer.GetMemory(5);

    // Write directly into the buffer.
    int written = Encoding.ASCII.GetBytes("Hello".AsSpan(), memory.Span);

    // Tell the writer how many bytes were written.
    writer.Advance(written);

    await writer.FlushAsync(cancellationToken);
}
</code></pre><p>The previous code:</p><ul><li>Requests a buffer of at least 5 bytes from the <code>PipeWriter</code> using <a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.getmemory" data-linktype="absolute-path">GetMemory</a>.</li><li>Writes bytes for the ASCII string <code>"Hello"</code> to the returned <code>Memory&lt;byte&gt;</code>.</li><li>Calls <a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.advance" data-linktype="absolute-path">Advance</a> to indicate how many bytes were written to the buffer.</li><li>Flushes the <code>PipeWriter</code>, which sends the bytes to the underlying device.</li></ul><p>The previous method of writing uses the buffers provided by the <code>PipeWriter</code>. Alternatively, <a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.writeasync" data-linktype="absolute-path">PipeWriter.WriteAsync</a>:</p><ul><li>Copies the existing buffer to the <code>PipeWriter</code>.</li><li>Calls <code>GetSpan</code>, <code>Advance</code> as appropriate and calls <a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.flushasync" data-linktype="absolute-path">FlushAsync</a>.</li></ul><pre><code class="lang-csharp" name="MyPipeWriter#2">async Task WriteHelloAsync(PipeWriter writer, CancellationToken cancellationToken = default)
{
    byte[] helloBytes = Encoding.ASCII.GetBytes("Hello");

    // Write helloBytes to the writer, there's no need to call Advance here 
    // (Write does that).
    await writer.WriteAsync(helloBytes, cancellationToken);
}
</code></pre><h3 id="cancellation-1">Cancellation</h3><p><a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.flushasync" data-linktype="absolute-path">FlushAsync</a> supports passing a <a href="/en-us/dotnet/api/system.threading.cancellationtoken" data-linktype="absolute-path">CancellationToken</a>. Passing a <code>CancellationToken</code> results in an <code>OperationCanceledException</code> if the token is canceled while there's a flush pending. <code>PipeWriter.FlushAsync</code> supports a way to cancel the current flush operation via <a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.cancelpendingflush" data-linktype="absolute-path">PipeWriter.CancelPendingFlush</a> without raising an exception. Calling <code>PipeWriter.CancelPendingFlush</code> causes the current or next call to <code>PipeWriter.FlushAsync</code> or <code>PipeWriter.WriteAsync</code> to return a <a href="/en-us/dotnet/api/system.io.pipelines.flushresult" data-linktype="absolute-path">FlushResult</a> with <code>IsCanceled</code> set to <code>true</code>. This can be useful for halting the yielding flush in a non-destructive and non-exceptional way.</p><h3 id="pipewriter-common-problems">PipeWriter common problems</h3><ul><li><a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.getspan" data-linktype="absolute-path">GetSpan</a> and <a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.getmemory" data-linktype="absolute-path">GetMemory</a> return a buffer with at least the requested amount of memory. <strong>Don't</strong> assume exact buffer sizes.</li><li>There's no guarantee that successive calls will return the same buffer or the same-sized buffer.</li><li>A new buffer must be requested after calling <a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.advance" data-linktype="absolute-path">Advance</a> to continue writing more data. The previously acquired buffer can't be written to.</li><li>Calling <code>GetMemory</code> or <code>GetSpan</code> while there's an incomplete call to <code>FlushAsync</code> isn't safe.</li><li>Calling <code>Complete</code> or <code>CompleteAsync</code> while there's unflushed data can result in memory corruption.</li></ul><h2 id="iduplexpipe">IDuplexPipe</h2><p>The <a href="/en-us/dotnet/api/system.io.pipelines.iduplexpipe" data-linktype="absolute-path">IDuplexPipe</a> is a contract for types that support both reading and writing. For example, a network connection would be represented by an <code>IDuplexPipe</code>.</p><p>Unlike <code>Pipe</code> which contains a <code>PipeReader</code> and a <code>PipeWriter</code>, <code>IDuplexPipe</code> represents a single side of a full duplex connection. That means what is written to the <code>PipeWriter</code> will not be read from the <code>PipeReader</code>.</p><h2 id="streams">Streams</h2><p>When reading or writing stream data, you typically read data using a de-serializer and write data using a serializer. Most of these read and write stream APIs have a <code>Stream</code> parameter. To make it easier to integrate with these existing APIs, <code>PipeReader</code> and <code>PipeWriter</code> expose an <a href="/en-us/dotnet/api/system.io.pipelines.pipereader.asstream" data-linktype="absolute-path">AsStream</a>.  <a href="/en-us/dotnet/api/system.io.pipelines.pipewriter.asstream" data-linktype="absolute-path">AsStream</a> returns a <code>Stream</code> implementation around the <code>PipeReader</code> or <code>PipeWriter</code>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>