<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Ext4 Disk Layout - Ext4 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Ext4 Disk Layout - Ext4 - linksfor.dev(s)"/>
    <meta property="og:description" content="This document attempts to describe the on-disk format for ext4 filesystems.  The same general ideas should apply to ext2/3 filesystems as well, though they do not support all the features that ext4 supports, and the fields will be shorter."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Ext4 Disk Layout - Ext4</title>
<div class="readable">
        <h1>Ext4 Disk Layout - Ext4</h1>
            <div>Reading time: 86-110 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout">https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="mw-content-text" lang="en" dir="ltr"><table>
<tbody><tr>
<th><b>NOTICE</b>: This page has been moved to the kernel documentation tree; current versions can be found here: <a rel="nofollow" href="https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html">https://www.kernel.org/doc/html/latest/filesystems/ext4/index.html</a> .  Please send documentation updates to the linux-ext4@vger.kernel.org mailing list.
</th></tr></tbody></table>
<p>This document attempts to describe the on-disk format for ext4 filesystems.  The same general ideas should apply to ext2/3 filesystems as well, though they do not support all the features that ext4 supports, and the fields will be shorter.
</p><p><b>NOTE</b>: This is a work in progress, based on notes that the author (djwong) made while picking apart a filesystem by hand.  The data structure definitions should be current as of Linux 4.12 and e2fsprogs-1.43.  All comments and corrections are welcome, since there is undoubtedly plenty of lore that might not be reflected in freshly created demonstration filesystems.
</p>


<p>ext4 divides a storage device into an array of logical blocks both to reduce bookkeeping overhead and to increase throughput by forcing larger transfer sizes.  Generally, the block size will be 4KiB (the same size as pages on x86 and the block layer's default block size), though the actual size is calculated as 2 ^ (10 + <code>sb.s_log_block_size</code>) bytes.  Throughout this document, disk locations are given in terms of these logical blocks, not raw LBAs, and not 1024-byte blocks.  For the sake of convenience, the logical block size will be referred to as <code>$block_size</code> throughout the rest of the document.
</p><p>When referenced in <code>preformatted text</code> blocks, <code>sb</code> refers to fields in the super block, and <code>inode</code> refers to fields in an inode table entry.
</p>

<p>An ext4 file system is split into a series of block groups.  To reduce performance difficulties due to fragmentation, the block allocator tries very hard to keep each file's blocks within the same group, thereby reducing seek times.  The size of a block group is specified in <code>sb.s_blocks_per_group</code> blocks, though it can also calculated as 8 * <code>block_size_in_bytes</code>.  With the default block size of 4KiB, each group will contain 32,768 blocks, for a length of 128MiB.  The number of block groups is the size of the device divided by the size of a block group.
</p><p>All fields in ext4 are written to disk in little-endian order.  HOWEVER, all fields in jbd2 (the journal) are written to disk in big-endian order.
</p>
<h2> <span id="Blocks"> Blocks </span></h2>
<p>ext4 allocates storage space in units of "blocks".  A block is a group of sectors between 1KiB and 64KiB, and the number of sectors must be an integral power of 2.  Blocks are in turn grouped into larger units called block groups.  Block size is specified at mkfs time and typically is 4KiB.  You may experience mounting problems if block size is greater than page size (i.e. 64KiB blocks on a i386 which only has 4KiB memory pages).  By default a filesystem can contain 2^32 blocks; if the '64bit' feature is enabled, then a filesystem can have 2^64 blocks.
</p>
<table>
<caption>File System Maximums
</caption>
<tbody><tr>
<td>
</td>
<td colspan="4">32-bit mode
</td></tr>
<tr>
<th>Item</th>
<th>1KiB</th>
<th>2KiB</th>
<th>4KiB</th>
<th>64KiB
</th></tr>
<tr>
<td>Blocks</td>
<td>2^32</td>
<td>2^32</td>
<td>2^32</td>
<td>2^32
</td></tr>
<tr>
<td>Inodes</td>
<td>2^32</td>
<td>2^32</td>
<td>2^32</td>
<td>2^32
</td></tr>
<tr>
<td>File System Size</td>
<td>4TiB</td>
<td>8TiB</td>
<td>16TiB</td>
<td>256PiB
</td></tr>
<tr>
<td>Blocks Per Block Group</td>
<td>8,192</td>
<td>16,384</td>
<td>32,768</td>
<td>524,288
</td></tr>
<tr>
<td>Inodes Per Block Group</td>
<td>8,192</td>
<td>16,384</td>
<td>32,768</td>
<td>524,288
</td></tr>
<tr>
<td>Block Group Size</td>
<td>8MiB</td>
<td>32MiB</td>
<td>128MiB</td>
<td>32GiB
</td></tr>
<tr>
<td>Blocks Per File, Extents</td>
<td>2^32</td>
<td>2^32</td>
<td>2^32</td>
<td>2^32
</td></tr>
<tr>
<td>Blocks Per File, Block Maps</td>
<td>16,843,020</td>
<td>134,480,396</td>
<td>1,074,791,436</td>
<td>4,398,314,962,956 (really 2^32 due to field size limitations)
</td></tr>
<tr>
<td>File Size, Extents</td>
<td>4TiB</td>
<td>8TiB</td>
<td>16TiB</td>
<td>256TiB
</td></tr>
<tr>
<td>File Size, Block Maps</td>
<td>16GiB</td>
<td>256GiB</td>
<td>4TiB</td>
<td>256TiB
</td></tr></tbody></table>
<table>
<caption>File System Maximums
</caption>
<tbody><tr>
<td>
</td>
<td colspan="4">64-bit mode
</td></tr>
<tr>
<th>Item</th>
<th>1KiB</th>
<th>2KiB</th>
<th>4KiB</th>
<th>64KiB
</th></tr>
<tr>
<td>Blocks</td>
<td>2^64</td>
<td>2^64</td>
<td>2^64</td>
<td>2^64
</td></tr>
<tr>
<td>Inodes</td>
<td>2^32</td>
<td>2^32</td>
<td>2^32</td>
<td>2^32
</td></tr>
<tr>
<td>File System Size</td>
<td>16ZiB</td>
<td>32ZiB</td>
<td>64ZiB</td>
<td>1YiB
</td></tr>
<tr>
<td>Blocks Per Block Group</td>
<td>8,192</td>
<td>16,384</td>
<td>32,768</td>
<td>524,288
</td></tr>
<tr>
<td>Inodes Per Block Group</td>
<td>8,192</td>
<td>16,384</td>
<td>32,768</td>
<td>524,288
</td></tr>
<tr>
<td>Block Group Size</td>
<td>8MiB</td>
<td>32MiB</td>
<td>128MiB</td>
<td>32GiB
</td></tr>
<tr>
<td>Blocks Per File, Extents</td>
<td>2^32</td>
<td>2^32</td>
<td>2^32</td>
<td>2^32
</td></tr>
<tr>
<td>Blocks Per File, Block Maps</td>
<td>16,843,020</td>
<td>134,480,396</td>
<td>1,074,791,436</td>
<td>4,398,314,962,956 (really 2^32 due to field size limitations)
</td></tr>
<tr>
<td>File Size, Extents</td>
<td>4TiB</td>
<td>8TiB</td>
<td>16TiB</td>
<td>256TiB
</td></tr>
<tr>
<td>File Size, Block Maps</td>
<td>16GiB</td>
<td>256GiB</td>
<td>4TiB</td>
<td>256TiB
</td></tr></tbody></table>
<p>Note: Files not using extents (i.e. files using block maps) must be placed within the first 2^32 blocks of a filesystem.  Files with extents must be placed within the first 2^48 blocks of a filesystem.  It's not clear what happens with larger filesystems.
</p>
<h2> <span id="Layout"> Layout </span></h2>
<p>The layout of a standard block group is approximately as follows (each of these fields is discussed in a separate section below):
</p>
<table>
<tbody><tr>
<td>Group 0 Padding </td>
<td> ext4 Super Block </td>
<td> Group Descriptors</td>
<td>Reserved GDT Blocks</td>
<td>Data Block Bitmap</td>
<td>inode Bitmap</td>
<td>inode Table</td>
<td>Data Blocks
</td></tr>
<tr>
<td>1024 bytes</td>
<td>1 block</td>
<td>many blocks</td>
<td>many blocks</td>
<td>1 block</td>
<td>1 block</td>
<td>many blocks</td>
<td>many more blocks
</td></tr></tbody></table>
<p>For the special case of block group 0, the first 1024 bytes are unused, to allow for the installation of x86 boot sectors and other oddities.  The superblock will start at offset 1024 bytes, whichever block that happens to be (usually 0).  However, if for some reason the block size = 1024, then block 0 is marked in use and the superblock goes in block 1.  For all other block groups, there is no padding.
</p><p>The ext4 driver primarily works with the superblock and the group descriptors that are found in block group 0.  Redundant copies of the superblock and group descriptors are written to some of the block groups across the disk in case the beginning of the disk gets trashed, though not all block groups necessarily host a redundant copy (see following paragraph for more details).  If the group does not have a redundant copy, the block group begins with the data block bitmap.  Note also that when the filesystem is freshly formatted, mkfs will allocate "reserve GDT block" space after the block group descriptors and before the start of the block bitmaps to allow for future expansion of the filesystem.  By default, a filesystem is allowed to increase in size by a factor of 1024x over the original filesystem size.
</p><p>The location of the inode table is given by <code>grp.bg_inode_table_*</code>.  It is continuous range of blocks large enough to contain <code>sb.s_inodes_per_group * sb.s_inode_size</code> bytes.
</p><p>As for the ordering of items in a block group, it is generally established that the super block and the group descriptor table, if present, will be at the beginning of the block group.  The bitmaps and the inode table can be anywhere, and it is quite possible for the bitmaps to come after the inode table, or for both to be in different groups (flex_bg).  Leftover space is used for file data blocks, indirect block maps, extent tree blocks, and extended attributes.
</p>
<h2> <span id="Flexible_Block_Groups"> Flexible Block Groups </span></h2>
<p>Starting in ext4, there is a new feature called flexible block groups (flex_bg).  In a flex_bg, several block groups are tied together as one logical block group; the bitmap spaces and the inode table space in the first block group of the flex_bg are expanded to include the bitmaps and inode tables of all other block groups in the flex_bg.  For example, if the flex_bg size is 4, then group 0 will contain (in order) the superblock, group descriptors, data block bitmaps for groups 0-3, inode bitmaps for groups 0-3, inode tables for groups 0-3, and the remaining space in group 0 is for file data.  The effect of this is to group the block metadata close together for faster loading, and to enable large files to be continuous on disk.  Backup copies of the superblock and group descriptors are always at the beginning of block groups, even if flex_bg is enabled.  The number of block groups that make up a flex_bg is given by 2 ^ <code>sb.s_log_groups_per_flex</code>.
</p>
<h2> <span id="Meta_Block_Groups"> Meta Block Groups </span></h2>
<p>Without the option META_BG, for safety concerns, all block group descriptors copies are kept in the first block group. Given the default 128MiB(2^27 bytes) block group size and 64-byte group descriptors, ext4 can have at most 2^27/64 = 2^21 block groups. This limits the entire filesystem size to 2^21 âˆ— 2^27 = 2^48bytes or 256TiB.
</p><p>The solution to this problem is to use the metablock group feature (META_BG), which is already in ext3 for all 2.6 releases. With the META_BG feature, ext4 filesystems are partitioned into many metablock groups. Each metablock group is a cluster of block groups whose group descriptor structures can be stored in a single disk block. For ext4 filesystems with 4 KB block size, a single metablock group partition includes 64 block groups, or 8 GiB of disk space. The metablock group feature moves the location of the group descriptors from the congested first block group of the whole filesystem into the first group of each metablock group itself. The backups are in the second and last group of each metablock group. This increases the 2^21 maximum block groups limit to the hard limit 2^32, allowing support for a 512PiB filesystem.
</p><p>The change in the filesystem format replaces the current scheme where the superblock is followed by a variable-length set of block group descriptors. Instead, the superblock and a single block group descriptor block is placed at the beginning of the first, second, and last block groups in a meta-block group. A meta-block group is a collection of block groups which can be described by a single block group descriptor block. Since the size of the block group descriptor structure is 32 bytes, a meta-block group contains 32 block groups for filesystems with a 1KB block size, and 128 block groups for filesystems with a 4KB blocksize. Filesystems can either be created using this new block group descriptor layout, or existing filesystems can be resized on-line, and the field s_first_meta_bg in the superblock will indicate the first block group using this new layout.
</p><p>Please see an important note about <code>BLOCK_UNINIT</code> in the section about block and inode bitmaps.
</p>
<h2> <span id="Lazy_Block_Group_Initialization"> Lazy Block Group Initialization </span></h2>
<p>A new feature for ext4 are three block group descriptor flags that enable mkfs to skip initializing other parts of the block group metadata.  Specifically, the INODE_UNINIT and BLOCK_UNINIT flags mean that the inode and block bitmaps for that group can be calculated and therefore the on-disk bitmap blocks are not initialized.  This is generally the case for an empty block group or a block group containing only fixed-location block group metadata.  The INODE_ZEROED flag means that the inode table has been initialized; mkfs will unset this flag and rely on the kernel to initialize the inode tables in the background.
</p><p>By not writing zeroes to the bitmaps and inode table, mkfs time is reduced considerably.  Note the feature flag is RO_COMPAT_GDT_CSUM, but the dumpe2fs output prints this as "uninit_bg".  They are the same thing.
</p>
<h2> <span id="Special_inodes"> Special inodes </span></h2>
<p>ext4 reserves some inode for special features, as follows:
</p>
<table>
<tbody><tr>
<th>inode</th>
<th>Purpose
</th></tr>
<tr>
<td>0</td>
<td>Doesn't exist; there is no inode 0.
</td></tr>
<tr>
<td>1</td>
<td>List of defective blocks.
</td></tr>
<tr>
<td>2</td>
<td>Root directory.
</td></tr>
<tr>
<td>3</td>
<td>User quota.
</td></tr>
<tr>
<td>4</td>
<td>Group quota.
</td></tr>
<tr>
<td>5</td>
<td>Boot loader.
</td></tr>
<tr>
<td>6</td>
<td>Undelete directory.
</td></tr>
<tr>
<td>7</td>
<td>Reserved group descriptors inode. ("resize inode")
</td></tr>
<tr>
<td>8</td>
<td>Journal inode.
</td></tr>
<tr>
<td>9</td>
<td>The "exclude" inode, for snapshots(?)
</td></tr>
<tr>
<td>10</td>
<td>Replica inode, used for some non-upstream feature?
</td></tr>
<tr>
<td>11</td>
<td>Traditional first non-reserved inode.  Usually this is the lost+found directory.  See s_first_ino in the superblock.
</td></tr></tbody></table>
<h2> <span id="Block_and_Inode_Allocation_Policy"> Block and Inode Allocation Policy </span></h2>
<p>ext4 recognizes (better than ext3, anyway) that data locality is generally a desirably quality of a filesystem.  On a spinning disk, keeping related blocks near each other reduces the amount of movement that the head actuator and disk must perform to access a data block, thus speeding up disk IO.  On an SSD there of course are no moving parts, but locality can increase the size of each transfer request while reducing the total number of requests.  This locality may also have the effect of concentrating writes on a single erase block, which can speed up file rewrites significantly.  Therefore, it is useful to reduce fragmentation whenever possible.
</p><p>The first tool that ext4 uses to combat fragmentation is the multi-block allocator.  When a file is first created, the block allocator speculatively allocates 8KiB of disk space to the file on the assumption that the space will get written soon.  When the file is closed, the unused speculative allocations are of course freed, but if the speculation is correct (typically the case for full writes of small files) then the file data gets written out in a single multi-block extent.  A second related trick that ext4 uses is delayed allocation.  Under this scheme, when a file needs more blocks to absorb file writes, the filesystem defers deciding the exact placement on the disk until all the dirty buffers are being written out to disk.  By not committing to a particular placement until it's absolutely necessary (the commit timeout is hit, or sync() is called, or the kernel runs out of memory), the hope is that the filesystem can make better location decisions.
</p><p>The third trick that ext4 (and ext3) uses is that it tries to keep a file's data blocks in the same block group as its inode.  This cuts down on the seek penalty when the filesystem first has to read a file's inode to learn where the file's data blocks live and then seek over to the file's data blocks to begin I/O operations.
</p><p>The fourth trick is that all the inodes in a directory are placed in the same block group as the directory, when feasible.  The working assumption here is that all the files in a directory might be related, therefore it is useful to try to keep them all together.
</p><p>The fifth trick is that the disk volume is cut up into 128MB block groups; these mini-containers are used as outlined above to try to maintain data locality.  However, there is a deliberate quirk -- when a directory is created in the root directory, the inode allocator scans the block groups and puts that directory into the least heavily loaded block group that it can find.  This encourages directories to spread out over a disk; as the top-level directory/file blobs fill up one block group, the allocators simply move on to the next block group.  Allegedly this scheme evens out the loading on the block groups, though the author suspects that the directories which are so unlucky as to land towards the end of a spinning drive get a raw deal performance-wise.
</p><p>Of course if all of these mechanisms fail, one can always use e4defrag to defragment files.
</p>
<h2> <span id="Checksums"> Checksums </span></h2>
<p>Starting in early 2012, metadata checksums were added to all major ext4 and jbd2 data structures.  The associated feature flag is metadata_csum.  The desired checksum algorithm is indicated in the superblock, though as of October 2012 the only supported algorithm is crc32c.  Some data structures did not have space to fit a full 32-bit checksum, so only the lower 16 bits are stored.  Enabling the 64bit feature increases the data structure size so that full 32-bit checksums can be stored for many data structures.  However, existing 32-bit filesystems cannot be extended to enable 64bit mode, at least not without the experimental resize2fs patches to do so.
</p><p>Existing filesystems can have checksumming added by running <code>tune2fs -O metadata_csum</code> against the underlying device.  If tune2fs encounters directory blocks that lack sufficient empty space to add a checksum, it will request that you run <code>e2fsck -D</code> to have the directories rebuilt with checksums.  This has the added benefit of removing slack space from the directory files and rebalancing the htree indexes.  If you _ignore_ this step, your directories will not be protected by a checksum!
</p><p>The following table describes the data elements that go into each type of checksum.  The checksum function is whatever the superblock describes (crc32c as of October 2013) unless noted otherwise.
</p>
<table>
<tbody><tr>
<th>Metadata</th>
<th>Length</th>
<th>Ingredients
</th></tr>
<tr>
<td>Superblock</td>
<td>__le32</td>
<td>The entire superblock up to the checksum field.  The UUID lives inside the superblock.
</td></tr>
<tr>
<td>MMP</td>
<td>__le32</td>
<td>UUID + the entire MMP block up to the checksum field.
</td></tr>
<tr>
<td>Extended Attributes</td>
<td>__le32</td>
<td>UUID + the entire extended attribute block.  The checksum field is set to zero.
</td></tr>
<tr>
<td>Directory Entries</td>
<td>__le32</td>
<td>UUID + inode number + inode generation + the directory block up to the fake entry enclosing the checksum field.
</td></tr>
<tr>
<td>HTREE Nodes</td>
<td>__le32</td>
<td>UUID + inode number + inode generation + all valid extents + HTREE tail.  The checksum field is set to zero.
</td></tr>
<tr>
<td>Extents</td>
<td>__le32</td>
<td>UUID + inode number + inode generation + the entire extent block up to the checksum field.
</td></tr>
<tr>
<td>Bitmaps</td>
<td>__le32 or __le16</td>
<td>UUID + the entire bitmap.  Checksums are stored in the group descriptor, and truncated if the group descriptor size is 32 bytes (i.e. ^64bit)
</td></tr>
<tr>
<td>Inodes</td>
<td>__le32</td>
<td>UUID + inode number + inode generation + the entire inode.  The checksum field is set to zero.  Each inode has its own checksum.
</td></tr>
<tr>
<td>Group Descriptors</td>
<td>__le16</td>
<td>If metadata_csum, then UUID + group number + the entire descriptor; else if gdt_csum, then crc16(UUID + group number + the entire descriptor).  In all cases, only the lower 16 bits are stored.
</td></tr></tbody></table>
<h2> <span id="Bigalloc"> Bigalloc </span></h2>
<p>At the moment, the default size of a block is 4KiB, which is a commonly supported page size on most MMU-capable hardware.  This is fortunate, as ext4 code is not prepared to handle the case where the block size exceeds the page size.  However, for a filesystem of mostly huge files, it is desirable to be able to allocate disk blocks in units of multiple blocks to reduce both fragmentation and metadata overhead.  The <a href="https://ext4.wiki.kernel.org/index.php/Bigalloc" title="Bigalloc">bigalloc</a> feature provides exactly this ability.  The administrator can set a block cluster size at mkfs time (which is stored in the s_log_cluster_size field in the superblock); from then on, the block bitmaps track clusters, not individual blocks.  This means that block groups can be several gigabytes in size (instead of just 128MiB); however, the minimum allocation unit becomes a cluster, not a block, even for directories.  TaoBao had a patchset to extend the "use units of clusters instead of blocks" to the extent tree, though it is not clear where those patches went-- they eventually morphed into "extent tree v2" but that code has not landed as of May 2015.
</p>
<h2> <span id="Inline_Data"> Inline Data </span></h2>
<p>The inline data feature was designed to handle the case that a file's data is so tiny that it readily fits inside the inode, which (theoretically) reduces disk block consumption and reduces seeks.  If the file is smaller than 60 bytes, then the data are stored inline in <code>inode.i_block</code>.  If the rest of the file would fit inside the extended attribute space, then it might be found as an extended attribute "system.data" within the inode body ("ibody EA").  This of course constrains the amount of extended attributes one can attach to an inode.  If the data size increases beyond i_block + ibody EA, a regular block is allocated and the contents moved to that block.
</p><p>Pending a change to compact the extended attribute key used to store inline data, one ought to be able to store 160 bytes of data in a 256-byte inode (as of June 2015, when i_extra_isize is 28).  Prior to that, the limit was 156 bytes due to inefficient use of inode space.
</p><p>The inline data feature requires the presence of an extended attribute for "system.data", even if the attribute value is zero length.
</p>
<h3> <span id="Inline_Directories"> Inline Directories </span></h3>
<p>The first four bytes of i_block are the inode number of the parent directory.  Following that is a 56-byte space for an array of directory entries; see <code>struct ext4_dir_entry</code>.  If there is a "system.data" attribute in the inode body, the EA value is an array of <code>struct ext4_dir_entry</code> as well.  Note that for inline directories, the i_block and EA space are treated as separate dirent blocks; directory entries cannot span the two.
</p><p>Inline directory entries are not checksummed, as the inode checksum should protect all inline data contents.
</p>
<h2> <span id="Orphan_File_.5BPROPOSED.5D"> Orphan File [PROPOSED] </span></h2>
<p>Proposed by Jan Kara in early 2015, the orphan file feature aims to reduce locking contention during delete operations by replacing the singly linked orphan inode list (and lock) with a file containing multiple blocks.  Each CPU ought to be able to claim its own block, which implies that the orphan list can be updated locklessly.  Each block contains a list of orphaned inodes; recovery involves iterating all blocks of the orphan file looking for non-zero inode numbers to erase.  This feature will come with a rocompat feature flag to indicate the ability to use an orphan file and a compat flag indicating that the orphan file actually contains orphaned inode records.  The format of an orphan file block is as follows:
</p>
<table>
<tbody><tr>
<th>Field</th>
<th>Length</th>
<th>Description
</th></tr>
<tr>
<td>inodes</td>
<td>__le32[]</td>
<td>A list of orphaned inodes.  0 means the entry is empty.  The length of the array is the size of the block minus the tail.
</td></tr>
<tr>
<td>magic</td>
<td>__le32</td>
<td>Magic number of orphan file blocks, 0x0B10CA04.
</td></tr>
<tr>
<td>checksum</td>
<td>__le32</td>
<td>Checksum of the UUID + inode number + inode generation + the orphan block up to but not including the footer.
</td></tr></tbody></table>
<p>The inode number of the orphan file itself has not been settled; as of May 2015 the test patches re-use inode #9.
</p>
<h2> <span id="Large_Extended_Attribute_Values"> Large Extended Attribute Values </span></h2>
<p>To enable ext4 to store extended attribute values that do not fit in the inode or in the single extended attribute block attached to an inode, the EA_INODE feature allows us to store the value in the data blocks of a regular file inode.  This "EA inode" is linked only from the extended attribute name index and must not appear in a directory entry.  The inode's i_atime field is used to store a checksum of the xattr value; and i_ctime/i_version store a 64-bit reference count, which enables sharing of large xattr values between multiple owning inodes.  For backward compatibility with older versions of this feature, the i_mtime/i_generation <i>may</i> store a back-reference to the inode number and i_generation of the <b>one</b> owning inode (in cases where the EA inode is not referenced by multiple inodes) to verify that the EA inode is the correct one being accessed.
</p>

<p>The superblock records various information about the enclosing filesystem, such as block counts, inode counts, supported features, maintenance information, and more.
</p><p>If the sparse_super feature flag is set, redundant copies of the superblock and group descriptors are kept only in the groups whose group number is either 0 or a power of 3, 5, or 7.  If the flag is not set, redundant copies are kept in all groups.
</p><p>The superblock checksum is calculated against the superblock structure, which includes the FS UUID.
</p><p>The ext4 superblock is laid out as follows in <code>struct ext4_super_block</code>:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>s_inodes_count</td>
<td>Total inode count.
</td></tr>
<tr>
<td>0x4</td>
<td>__le32</td>
<td>s_blocks_count_lo</td>
<td>Total block count.
</td></tr>
<tr>
<td>0x8</td>
<td>__le32</td>
<td>s_r_blocks_count_lo</td>
<td>This number of blocks can only be allocated by the super-user.
</td></tr>
<tr>
<td>0xC</td>
<td>__le32</td>
<td>s_free_blocks_count_lo</td>
<td>Free block count.
</td></tr>
<tr>
<td>0x10</td>
<td>__le32</td>
<td>s_free_inodes_count</td>
<td>Free inode count.
</td></tr>
<tr>
<td>0x14</td>
<td>__le32</td>
<td>s_first_data_block</td>
<td>First data block.  This must be at least 1 for 1k-block filesystems and is typically 0 for all other block sizes.
</td></tr>
<tr>
<td>0x18</td>
<td>__le32</td>
<td>s_log_block_size</td>
<td>Block size is 2 ^ (10 + s_log_block_size).
</td></tr>
<tr>
<td>0x1C</td>
<td>__le32</td>
<td>s_log_cluster_size</td>
<td>Cluster size is (2 ^ s_log_cluster_size) blocks if bigalloc is enabled. Otherwise s_log_cluster_size must equal s_log_block_size.
</td></tr>
<tr>
<td>0x20</td>
<td>__le32</td>
<td>s_blocks_per_group</td>
<td>Blocks per group.
</td></tr>
<tr>
<td>0x24</td>
<td>__le32</td>
<td>s_clusters_per_group</td>
<td>Clusters per group, if bigalloc is enabled. Otherwise s_clusters_per_group must equal s_blocks_per_group.
</td></tr>
<tr>
<td>0x28</td>
<td>__le32</td>
<td>s_inodes_per_group</td>
<td>Inodes per group.
</td></tr>
<tr>
<td>0x2C</td>
<td>__le32</td>
<td>s_mtime</td>
<td>Mount time, in seconds since the epoch.
</td></tr>
<tr>
<td>0x30</td>
<td>__le32</td>
<td>s_wtime</td>
<td>Write time, in seconds since the epoch.
</td></tr>
<tr>
<td>0x34</td>
<td>__le16</td>
<td>s_mnt_count</td>
<td>Number of mounts since the last fsck.
</td></tr>
<tr>
<td>0x36</td>
<td>__le16</td>
<td>s_max_mnt_count</td>
<td>Number of mounts beyond which a fsck is needed.
</td></tr>
<tr>
<td>0x38</td>
<td>__le16</td>
<td>s_magic</td>
<td>Magic signature, 0xEF53
</td></tr>
<tr>
<td>0x3A</td>
<td>__le16</td>
<td>s_state</td>
<td>File system state.  Valid values are:
<table>
<tbody><tr>
<td>0x0001</td>
<td>Cleanly umounted
</td></tr>
<tr>
<td>0x0002</td>
<td>Errors detected
</td></tr>
<tr>
<td>0x0004</td>
<td>Orphans being recovered
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x3C</td>
<td>__le16</td>
<td>s_errors</td>
<td>Behaviour when detecting errors.  One of:
<table>
<tbody><tr>
<td>1</td>
<td>Continue
</td></tr>
<tr>
<td>2</td>
<td>Remount read-only
</td></tr>
<tr>
<td>3</td>
<td>Panic
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x3E</td>
<td>__le16</td>
<td>s_minor_rev_level</td>
<td>Minor revision level.
</td></tr>
<tr>
<td>0x40</td>
<td>__le32</td>
<td>s_lastcheck</td>
<td>Time of last check, in seconds since the epoch.
</td></tr>
<tr>
<td>0x44</td>
<td>__le32</td>
<td>s_checkinterval</td>
<td>Maximum time between checks, in seconds.
</td></tr>
<tr>
<td>0x48</td>
<td>__le32</td>
<td>s_creator_os</td>
<td>OS.  One of:
<table>
<tbody><tr>
<td>0</td>
<td>Linux
</td></tr>
<tr>
<td>1</td>
<td>Hurd
</td></tr>
<tr>
<td>2</td>
<td>Masix
</td></tr>
<tr>
<td>3</td>
<td>FreeBSD
</td></tr>
<tr>
<td>4</td>
<td>Lites
</td></tr>
</tbody></table>
</td></tr>
<tr>
<td>0x4C</td>
<td>__le32</td>
<td>s_rev_level</td>
<td>Revision level.  One of:
<table>
<tbody><tr>
<td>0</td>
<td>Original format
</td></tr>
<tr>
<td>1</td>
<td>v2 format w/ dynamic inode sizes
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x50</td>
<td>__le16</td>
<td>s_def_resuid</td>
<td>Default uid for reserved blocks.
</td></tr>
<tr>
<td>0x52</td>
<td>__le16</td>
<td>s_def_resgid</td>
<td>Default gid for reserved blocks.
</td></tr>
<tr>
<td colspan="4">These fields are for EXT4_DYNAMIC_REV superblocks only.
<p>Note: the difference between the compatible feature set and
the incompatible feature set is that if there is a bit set
in the incompatible feature set that the kernel doesn't
know about, it should refuse to mount the filesystem.
</p><p>e2fsck's requirements are more strict; if it doesn't know
about a feature in either the compatible or incompatible
feature set, it must abort and not try to meddle with
things it doesn't understand...
</p>
</td></tr>
<tr>
<td>0x54</td>
<td>__le32</td>
<td>s_first_ino</td>
<td>First non-reserved inode.
</td></tr>
<tr>
<td>0x58</td>
<td>__le16</td>
<td>s_inode_size</td>
<td>Size of inode structure, in bytes.
</td></tr>
<tr>
<td>0x5A</td>
<td>__le16</td>
<td>s_block_group_nr</td>
<td>Block group # of this superblock.
</td></tr>
<tr>
<td>0x5C</td>
<td>__le32</td>
<td>s_feature_compat</td>
<td>Compatible feature set flags.  Kernel can still read/write this fs even if it doesn't understand a flag; e2fsck will not attempt to fix a filesystem with any unknown COMPAT flags.  Any of:
<table>
<tbody><tr>
<td>0x1</td>
<td>Directory preallocation (COMPAT_DIR_PREALLOC).
</td></tr>
<tr>
<td>0x2</td>
<td>"imagic inodes". Used by AFS to indicate inodes that are not linked into the directory namespace.  Inodes marked with this flag will not be added to lost+found by e2fsck. (COMPAT_IMAGIC_INODES).
</td></tr>
<tr>
<td>0x4</td>
<td>Has a journal (COMPAT_HAS_JOURNAL).
</td></tr>
<tr>
<td>0x8</td>
<td>Supports extended attributes (COMPAT_EXT_ATTR).
</td></tr>
<tr>
<td>0x10</td>
<td>Has reserved GDT blocks for filesystem expansion. Requires RO_COMPAT_SPARSE_SUPER. (COMPAT_RESIZE_INODE).
</td></tr>
<tr>
<td>0x20</td>
<td>Has indexed directories. (COMPAT_DIR_INDEX).
</td></tr>
<tr>
<td>0x40</td>
<td>"Lazy BG".  Not in Linux kernel, seems to have been for uninitialized block groups? (COMPAT_LAZY_BG).
</td></tr>
<tr>
<td>0x80</td>
<td>"Exclude inode".  Intended for filesystem snapshot feature, but not used. (COMPAT_EXCLUDE_INODE).
</td></tr>
<tr>
<td>0x100</td>
<td>"Exclude bitmap".  Seems to be used to indicate the presence of snapshot-related exclude bitmaps?  Not defined in kernel or used in e2fsprogs.  (COMPAT_EXCLUDE_BITMAP).
</td></tr>
<tr>
<td>0x200</td>
<td>Sparse Super Block, v2.  If this flag is set, the SB field s_backup_bgs points to the two block groups that contain backup superblocks. (COMPAT_SPARSE_SUPER2).
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x60</td>
<td>__le32</td>
<td>s_feature_incompat</td>
<td>Incompatible feature set.  If the kernel or e2fsck doesn't understand one of these bits, it will refuse to mount or attempt to repair the filesystem.  Any of:
<table>
<tbody><tr>
<td>0x1</td>
<td>Compression.  Not implemented. (INCOMPAT_COMPRESSION).
</td></tr>
<tr>
<td>0x2</td>
<td>Directory entries record the file type.  See ext4_dir_entry_2 below. (INCOMPAT_FILETYPE).
</td></tr>
<tr>
<td>0x4</td>
<td>Filesystem needs journal recovery. (INCOMPAT_RECOVER).
</td></tr>
<tr>
<td>0x8</td>
<td>Filesystem has a separate journal device. (INCOMPAT_JOURNAL_DEV).
</td></tr>
<tr>
<td>0x10</td>
<td>Meta block groups.  See the earlier discussion of this feature. (INCOMPAT_META_BG).
</td></tr>
<tr>
<td>0x40</td>
<td>Files in this filesystem use extents. (INCOMPAT_EXTENTS).
</td></tr>
<tr>
<td>0x80</td>
<td>Enable a filesystem size over 2^32 blocks. (INCOMPAT_64BIT).
</td></tr>
<tr>
<td>0x100</td>
<td>Multiple mount protection.  Prevent multiple hosts from mounting the filesystem concurrently by updating a reserved block periodically while mounted and checking this at mount time to determine if the filesystem is in use on another host. (INCOMPAT_MMP).
</td></tr>
<tr>
<td>0x200</td>
<td>Flexible block groups.  See the earlier discussion of this feature. (INCOMPAT_FLEX_BG).
</td></tr>
<tr>
<td>0x400</td>
<td>Inodes can be used to store large extended attribute values (INCOMPAT_EA_INODE).
</td></tr>
<tr>
<td>0x1000</td>
<td>Data in directory entry.  Allow additional data fields to be stored in each dirent, after struct ext4_dirent.  The presence of extra data is indicated by flags in the high bits of ext4_dirent file type flags (above EXT4_FT_MAX).  The flag EXT4_DIRENT_LUFID = 0x10 is used to store a 128-bit File Identifier for Lustre.  The flag EXT4_DIRENT_IO64 = 0x20 is used to store the high word of 64-bit inode numbers.  <a rel="nofollow" href="https://patchwork.ozlabs.org/patch/868541/">Feature still in development</a>. (INCOMPAT_DIRDATA).
</td></tr>
<tr>
<td>0x2000</td>
<td>Metadata checksum seed is stored in the superblock.  This feature enables the administrator to change the UUID of a metadata_csum filesystem while the filesystem is mounted; without it, the checksum definition requires all metadata blocks to be rewritten. (INCOMPAT_CSUM_SEED).
</td></tr>
<tr>
<td>0x4000</td>
<td>Large directory &gt;2GB or 3-level htree.  Prior to this feature, directories could not be larger than 4GiB and could not have an htree more than 2 levels deep.  If this feature is enabled, directories can be larger than 4GiB and have a maximum htree depth of 3.  (INCOMPAT_LARGEDIR).
</td></tr>
<tr>
<td>0x8000</td>
<td>Data in inode.  Small files or directories are stored directly in the inode i_blocks and/or xattr space.  (INCOMPAT_INLINE_DATA).
</td></tr>
<tr>
<td>0x10000</td>
<td>Encrypted inodes are present on the filesystem (INCOMPAT_ENCRYPT).
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x64</td>
<td>__le32</td>
<td>s_feature_ro_compat</td>
<td>Readonly-compatible feature set.  If the kernel doesn't understand one of these bits, it can still mount read-only, but e2fsck will refuse to modify the filesystem.  Any of:
<table>
<tbody><tr>
<td>0x1</td>
<td>Sparse superblocks.  See the earlier discussion of this feature. (RO_COMPAT_SPARSE_SUPER).
</td></tr>
<tr>
<td>0x2</td>
<td>Allow storing files larger than 2GiB (RO_COMPAT_LARGE_FILE).
</td></tr>
<tr>
<td>0x4</td>
<td>Was intended for use with htree directories, but was not needed. Not used in kernel or e2fsprogs (RO_COMPAT_BTREE_DIR).
</td></tr>
<tr>
<td>0x8</td>
<td>This filesystem has files whose space usage is stored in i_blocks in units of filesystem blocks, not 512-byte sectors.  Inodes using this feature will be marked with EXT4_INODE_HUGE_FILE. (RO_COMPAT_HUGE_FILE)
</td></tr>
<tr>
<td>0x10</td>
<td>Group descriptors have checksums.  In addition to detecting corruption, this is useful for lazy formatting with uninitialized groups (RO_COMPAT_GDT_CSUM).
</td></tr>
<tr>
<td>0x20</td>
<td>Indicates that the old ext3 32,000 subdirectory limit no longer applies.  A directory's i_links_count will be set to 1 if it is incremented past 64,999. (RO_COMPAT_DIR_NLINK).
</td></tr>
<tr>
<td>0x40</td>
<td>Indicates that large inodes exist on this filesystem, storing extra fields after EXT2_GOOD_OLD_INODE_SIZE. (RO_COMPAT_EXTRA_ISIZE).
</td></tr>
<tr>
<td>0x80</td>
<td>This filesystem has a snapshot.  Not implemented in ext4. (RO_COMPAT_HAS_SNAPSHOT).
</td></tr>
<tr>
<td>0x100</td>
<td><a href="https://ext4.wiki.kernel.org/index.php/Quota" title="Quota">Quota</a> is handled transactionally with the journal (RO_COMPAT_QUOTA).
</td></tr>
<tr>
<td>0x200</td>
<td>This filesystem supports "bigalloc", which means that filesystem block allocation bitmaps are tracked in units of clusters (of blocks) instead of blocks (RO_COMPAT_BIGALLOC).
</td></tr>
<tr>
<td>0x400</td>
<td>This filesystem supports metadata checksumming. (RO_COMPAT_METADATA_CSUM; implies RO_COMPAT_GDT_CSUM, though GDT_CSUM must not be set)
</td></tr>
<tr>
<td>0x800</td>
<td>Filesystem supports replicas.  This feature is neither in the kernel nor e2fsprogs. (RO_COMPAT_REPLICA).
</td></tr>
<tr>
<td>0x1000</td>
<td>Read-only filesystem image; the kernel will not mount this image read-write and most tools will refuse to write to the image. (RO_COMPAT_READONLY).
</td></tr>
<tr>
<td>0x2000</td>
<td>Filesystem tracks project quotas. (RO_COMPAT_PROJECT)
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x68</td>
<td>__u8</td>
<td>s_uuid[16]</td>
<td>128-bit UUID for volume.
</td></tr>
<tr>
<td>0x78</td>
<td>char</td>
<td>s_volume_name[16]</td>
<td>Volume label.
</td></tr>
<tr>
<td>0x88</td>
<td>char</td>
<td>s_last_mounted[64]</td>
<td>Directory where filesystem was last mounted.
</td></tr>
<tr>
<td>0xC8 </td>
<td>__le32</td>
<td>s_algorithm_usage_bitmap</td>
<td>For compression (Not used in e2fsprogs/Linux)
</td></tr>
<tr>
<td colspan="4">Performance hints.  Directory preallocation should only happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.
</td></tr>
<tr>
<td>0xCC</td>
<td>__u8</td>
<td>s_prealloc_blocks</td>
<td># of blocks to try to preallocate for ... files? (Not used in e2fsprogs/Linux)
</td></tr>
<tr>
<td>0xCD</td>
<td>__u8</td>
<td>s_prealloc_dir_blocks</td>
<td># of blocks to preallocate for directories. (Not used in e2fsprogs/Linux)
</td></tr>
<tr>
<td>0xCE</td>
<td>__le16</td>
<td>s_reserved_gdt_blocks</td>
<td>Number of reserved GDT entries for future filesystem expansion.
</td></tr>
<tr>
<td colspan="4">Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.
</td></tr>
<tr>
<td>0xD0</td>
<td>__u8</td>
<td>s_journal_uuid[16]</td>
<td>UUID of journal superblock
</td></tr>
<tr>
<td>0xE0</td>
<td>__le32</td>
<td>s_journal_inum</td>
<td>inode number of journal file.
</td></tr>
<tr>
<td>0xE4</td>
<td>__le32</td>
<td>s_journal_dev</td>
<td>Device number of journal file, if the external journal feature flag is set.
</td></tr>
<tr>
<td>0xE8</td>
<td>__le32</td>
<td>s_last_orphan</td>
<td>Start of list of orphaned inodes to delete.
</td></tr>
<tr>
<td>0xEC</td>
<td>__le32</td>
<td>s_hash_seed[4]</td>
<td>HTREE hash seed.
</td></tr>
<tr>
<td>0xFC</td>
<td>__u8</td>
<td>s_def_hash_version</td>
<td>Default hash algorithm to use for directory hashes.  One of:
<table>
<tbody><tr>
<td>0x0</td>
<td>Legacy.
</td></tr>
<tr>
<td>0x1</td>
<td>Half MD4.
</td></tr>
<tr>
<td>0x2</td>
<td>Tea.
</td></tr>
<tr>
<td>0x3</td>
<td>Legacy, unsigned.
</td></tr>
<tr>
<td>0x4</td>
<td>Half MD4, unsigned.
</td></tr>
<tr>
<td>0x5</td>
<td>Tea, unsigned.
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0xFD</td>
<td>__u8</td>
<td>s_jnl_backup_type</td>
<td>If this value is 0 or EXT3_JNL_BACKUP_BLOCKS (1), then the <code>s_jnl_blocks</code> field contains a duplicate copy of the inode's <code>i_block[]</code> array and <code>i_size</code>.
</td></tr>
<tr>
<td>0xFE</td>
<td>__le16</td>
<td>s_desc_size</td>
<td>Size of group descriptors, in bytes, if the 64bit incompat feature flag is set.
</td></tr>
<tr>
<td>0x100</td>
<td>__le32</td>
<td>s_default_mount_opts</td>
<td>Default mount options.  Any of:
<table>
<tbody><tr>
<td>0x0001</td>
<td>Print debugging info upon (re)mount. (EXT4_DEFM_DEBUG)
</td></tr>
<tr>
<td>0x0002</td>
<td>New files take the gid of the containing directory (instead of the fsgid of the current process). (EXT4_DEFM_BSDGROUPS)
</td></tr>
<tr>
<td>0x0004</td>
<td>Support userspace-provided extended attributes. (EXT4_DEFM_XATTR_USER)
</td></tr>
<tr>
<td>0x0008</td>
<td>Support POSIX access control lists (ACLs). (EXT4_DEFM_ACL)
</td></tr>
<tr>
<td>0x0010</td>
<td>Do not support 32-bit UIDs. (EXT4_DEFM_UID16)
</td></tr>
<tr>
<td>0x0020</td>
<td>All data and metadata are commited to the journal. (EXT4_DEFM_JMODE_DATA)
</td></tr>
<tr>
<td>0x0040</td>
<td>All data are flushed to the disk before metadata are committed to the journal. (EXT4_DEFM_JMODE_ORDERED)
</td></tr>
<tr>
<td>0x0060</td>
<td>Data ordering is not preserved; data may be written after the metadata has been written. (EXT4_DEFM_JMODE_WBACK)
</td></tr>
<tr>
<td>0x0100</td>
<td>Disable write flushes. (EXT4_DEFM_NOBARRIER)
</td></tr>
<tr>
<td>0x0200</td>
<td>Track which blocks in a filesystem are metadata and therefore should not be used as data blocks.  This option will be enabled by default on 3.18, hopefully. (EXT4_DEFM_BLOCK_VALIDITY)
</td></tr>
<tr>
<td>0x0400</td>
<td>Enable DISCARD support, where the storage device is told about blocks becoming unused. (EXT4_DEFM_DISCARD)
</td></tr>
<tr>
<td>0x0800</td>
<td>Disable delayed allocation. (EXT4_DEFM_NODELALLOC)
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x104</td>
<td>__le32</td>
<td>s_first_meta_bg</td>
<td>First metablock block group, if the meta_bg feature is enabled.
</td></tr>
<tr>
<td>0x108</td>
<td>__le32</td>
<td>s_mkfs_time</td>
<td>When the filesystem was created, in seconds since the epoch.
</td></tr>
<tr>
<td>0x10C</td>
<td>__le32</td>
<td>s_jnl_blocks[17]</td>
<td>Backup copy of the journal inode's <code>i_block[]</code> array in the first 15 elements and i_size_high and i_size in the 16th and 17th elements, respectively.
</td></tr>
<tr>
<td colspan="4">64bit support valid if EXT4_FEATURE_COMPAT_64BIT
</td></tr>
<tr>
<td>0x150</td>
<td>__le32</td>
<td>s_blocks_count_hi</td>
<td>High 32-bits of the block count.
</td></tr>
<tr>
<td>0x154</td>
<td>__le32</td>
<td>s_r_blocks_count_hi</td>
<td>High 32-bits of the reserved block count.
</td></tr>
<tr>
<td>0x158</td>
<td>__le32</td>
<td>s_free_blocks_count_hi</td>
<td>High 32-bits of the free block count.
</td></tr>
<tr>
<td>0x15C</td>
<td>__le16</td>
<td>s_min_extra_isize</td>
<td>All inodes have at least # bytes.
</td></tr>
<tr>
<td>0x15E</td>
<td>__le16</td>
<td>s_want_extra_isize</td>
<td>New inodes should reserve # bytes.
</td></tr>
<tr>
<td>0x160</td>
<td>__le32</td>
<td>s_flags</td>
<td>Miscellaneous flags.  Any of:
<table>
<tbody><tr>
<td>0x0001</td>
<td>Signed directory hash in use.
</td></tr>
<tr>
<td>0x0002</td>
<td>Unsigned directory hash in use.
</td></tr>
<tr>
<td>0x0004</td>
<td>To test development code.
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x164</td>
<td>__le16</td>
<td>s_raid_stride</td>
<td>RAID stride.  This is the number of logical blocks read from or written to the disk before moving to the next disk.  This affects the placement of filesystem metadata, which will hopefully make RAID storage faster.
</td></tr>
<tr>
<td>0x166</td>
<td>__le16</td>
<td>s_mmp_interval</td>
<td># seconds to wait in multi-mount prevention (MMP) checking.  In theory, MMP is a mechanism to record in the superblock which host and device have mounted the filesystem, in order to prevent multiple mounts.  This feature does not seem to be implemented...
</td></tr>
<tr>
<td>0x168</td>
<td>__le64</td>
<td>s_mmp_block</td>
<td>Block # for multi-mount protection data.
</td></tr>
<tr>
<td>0x170</td>
<td>__le32</td>
<td>s_raid_stripe_width</td>
<td>RAID stripe width.  This is the number of logical blocks read from or written to the disk before coming back to the current disk.  This is used by the block allocator to try to reduce the number of read-modify-write operations in a RAID5/6.
</td></tr>
<tr>
<td>0x174</td>
<td>__u8</td>
<td>s_log_groups_per_flex</td>
<td>Size of a flexible block group is 2 ^ <code>s_log_groups_per_flex</code>.
</td></tr>
<tr>
<td>0x175</td>
<td>__u8</td>
<td>s_checksum_type</td>
<td>Metadata checksum algorithm type.  The only valid value is 1 (crc32c).
</td></tr>
<tr>
<td>0x176</td>
<td>__le16</td>
<td>s_reserved_pad</td>
<td>
</td></tr>
<tr>
<td>0x178</td>
<td>__le64</td>
<td>s_kbytes_written</td>
<td>Number of KiB written to this filesystem over its lifetime.
</td></tr>
<tr>
<td>0x180</td>
<td>__le32</td>
<td>s_snapshot_inum</td>
<td>inode number of active snapshot. (Not used in e2fsprogs/Linux.)
</td></tr>
<tr>
<td>0x184</td>
<td>__le32</td>
<td>s_snapshot_id</td>
<td>Sequential ID of active snapshot. (Not used in e2fsprogs/Linux.)
</td></tr>
<tr>
<td>0x188</td>
<td>__le64</td>
<td>s_snapshot_r_blocks_count</td>
<td>Number of blocks reserved for active snapshot's future use. (Not used in e2fsprogs/Linux.)
</td></tr>
<tr>
<td>0x190</td>
<td>__le32</td>
<td>s_snapshot_list</td>
<td>inode number of the head of the on-disk snapshot list. (Not used in e2fsprogs/Linux.)
</td></tr>
<tr>
<td>0x194</td>
<td>__le32</td>
<td>s_error_count</td>
<td>Number of errors seen.
</td></tr>
<tr>
<td>0x198</td>
<td>__le32</td>
<td>s_first_error_time</td>
<td>First time an error happened, in seconds since the epoch.
</td></tr>
<tr>
<td>0x19C</td>
<td>__le32</td>
<td>s_first_error_ino</td>
<td>inode involved in first error.
</td></tr>
<tr>
<td>0x1A0</td>
<td>__le64</td>
<td>s_first_error_block</td>
<td>Number of block involved of first error.
</td></tr>
<tr>
<td>0x1A8</td>
<td>__u8</td>
<td>s_first_error_func[32]</td>
<td>Name of function where the error happened.
</td></tr>
<tr>
<td>0x1C8</td>
<td>__le32</td>
<td>s_first_error_line</td>
<td>Line number where error happened.
</td></tr>
<tr>
<td>0x1CC</td>
<td>__le32</td>
<td>s_last_error_time</td>
<td>Time of most recent error, in seconds since the epoch.
</td></tr>
<tr>
<td>0x1D0</td>
<td>__le32</td>
<td>s_last_error_ino</td>
<td>inode involved in most recent error.
</td></tr>
<tr>
<td>0x1D4</td>
<td>__le32</td>
<td>s_last_error_line</td>
<td>Line number where most recent error happened.
</td></tr>
<tr>
<td>0x1D8</td>
<td>__le64</td>
<td>s_last_error_block</td>
<td>Number of block involved in most recent error.
</td></tr>
<tr>
<td>0x1E0</td>
<td>__u8</td>
<td>s_last_error_func[32]</td>
<td>Name of function where the most recent error happened.
</td></tr>
<tr>
<td>0x200</td>
<td>__u8</td>
<td>s_mount_opts[64]</td>
<td>ASCIIZ string of mount options.
</td></tr>
<tr>
<td>0x240</td>
<td>__le32</td>
<td>s_usr_quota_inum</td>
<td>Inode number of user <a href="https://ext4.wiki.kernel.org/index.php/Quota" title="Quota">quota</a> file.
</td></tr>
<tr>
<td>0x244</td>
<td>__le32</td>
<td>s_grp_quota_inum</td>
<td>Inode number of group <a href="https://ext4.wiki.kernel.org/index.php/Quota" title="Quota">quota</a> file.
</td></tr>
<tr>
<td>0x248</td>
<td>__le32</td>
<td>s_overhead_blocks</td>
<td>Overhead blocks/clusters in fs. (Huh? This field is always zero, which means that the kernel calculates it dynamically.)
</td></tr>
<tr>
<td>0x24C</td>
<td>__le32</td>
<td>s_backup_bgs[2]</td>
<td>Block groups containing superblock backups (if sparse_super2)
</td></tr>
<tr>
<td>0x254</td>
<td>__u8</td>
<td>s_encrypt_algos[4]</td>
<td>Encryption algorithms in use.  There can be up to four algorithms in use at any time; valid algorithm codes are given below:
<table>
<tbody><tr>
<td>0</td>
<td>Invalid algorithm (ENCRYPTION_MODE_INVALID).
</td></tr>
<tr>
<td>1</td>
<td>256-bit AES in XTS mode (ENCRYPTION_MODE_AES_256_XTS).
</td></tr>
<tr>
<td>2</td>
<td>256-bit AES in GCM mode (ENCRYPTION_MODE_AES_256_GCM).
</td></tr>
<tr>
<td>3</td>
<td>256-bit AES in CBC mode (ENCRYPTION_MODE_AES_256_CBC).
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x258</td>
<td>__u8</td>
<td>s_encrypt_pw_salt[16]</td>
<td>Salt for the string2key algorithm for encryption.
</td></tr>
<tr>
<td>0x268</td>
<td>__le32</td>
<td>s_lpf_ino</td>
<td>Inode number of lost+found
</td></tr>
<tr>
<td>0x26C</td>
<td>__le32</td>
<td>s_prj_quota_inum</td>
<td>Inode that tracks project quotas.
</td></tr>
<tr>
<td>0x270</td>
<td>__le32</td>
<td>s_checksum_seed</td>
<td>Checksum seed used for metadata_csum calculations.  This value is crc32c(~0, $orig_fs_uuid).
</td></tr>
<tr>
<td>0x274</td>
<td>__le32</td>
<td>s_reserved[98]</td>
<td>Padding to the end of the block.
</td></tr>
<tr>
<td>0x3FC</td>
<td>__le32</td>
<td>s_checksum</td>
<td>Superblock checksum.
</td></tr></tbody></table>
<p>Total size is 1024 bytes.
</p>

<p>Each block group on the filesystem has one of these descriptors associated with it.  As noted in the Layout section above, the group descriptors (if present) are the second item in the block group.  The standard configuration is for each block group to contain a full copy of the block group descriptor table unless the sparse_super feature flag is set.
</p><p>Notice how the group descriptor records the location of both bitmaps and the inode table (i.e. they can float).  This means that within a block group, the only data structures with fixed locations are the superblock and the group descriptor table.  The flex_bg mechanism uses this property to group several block groups into a flex group and lay out all of the groups' bitmaps and inode tables into one long run in the first group of the flex group.
</p><p>If the meta_bg feature flag is set, then several block groups are grouped together into a meta group.  Note that in the meta_bg case, however, the first and last two block groups within the larger meta group contain only group descriptors for the groups inside the meta group.
</p><p>flex_bg and meta_bg do not appear to be mutually exclusive features.
</p><p>In ext2, ext3, and ext4 (when the 64bit feature is not enabled), the block group descriptor was only 32 bytes long and therefore ends at bg_checksum.  On an ext4 filesystem with the 64bit feature enabled, the block group descriptor expands to at least the 64 bytes described below; the size is stored in the superblock.
</p><p>If gdt_csum is set and metadata_csum is not set, the block group checksum is the crc16 of the FS UUID, the group number, and the group descriptor structure.  If metadata_csum is set, then the block group checksum is the lower 16 bits of the checksum of the FS UUID, the group number, and the group descriptor structure.  Both block and inode bitmap checksums are calculated against the FS UUID, the group number, and the entire bitmap.
</p><p>The block group descriptor is laid out in <code>struct ext4_group_desc</code>.
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>bg_block_bitmap_lo</td>
<td>Lower 32-bits of location of block bitmap.
</td></tr>
<tr>
<td>0x4</td>
<td>__le32</td>
<td>bg_inode_bitmap_lo</td>
<td>Lower 32-bits of location of inode bitmap.
</td></tr>
<tr>
<td>0x8</td>
<td>__le32</td>
<td>bg_inode_table_lo</td>
<td>Lower 32-bits of location of inode table.
</td></tr>
<tr>
<td>0xC</td>
<td>__le16</td>
<td>bg_free_blocks_count_lo</td>
<td>Lower 16-bits of free block count.
</td></tr>
<tr>
<td>0xE</td>
<td>__le16</td>
<td>bg_free_inodes_count_lo</td>
<td>Lower 16-bits of free inode count.
</td></tr>
<tr>
<td>0x10</td>
<td>__le16</td>
<td>bg_used_dirs_count_lo</td>
<td>Lower 16-bits of directory count.
</td></tr>
<tr>
<td>0x12</td>
<td>__le16</td>
<td>bg_flags</td>
<td>Block group flags.  Any of:
<table>
<tbody><tr>
<td>0x1</td>
<td>inode table and bitmap are not initialized (EXT4_BG_INODE_UNINIT).
</td></tr>
<tr>
<td>0x2</td>
<td>block bitmap is not initialized (EXT4_BG_BLOCK_UNINIT).
</td></tr>
<tr>
<td>0x4</td>
<td>inode table is zeroed (EXT4_BG_INODE_ZEROED).
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x14</td>
<td>__le32</td>
<td>bg_exclude_bitmap_lo</td>
<td>Lower 32-bits of location of snapshot exclusion bitmap.
</td></tr>
<tr>
<td>0x18</td>
<td>__le16</td>
<td>bg_block_bitmap_csum_lo</td>
<td>Lower 16-bits of the block bitmap checksum.
</td></tr>
<tr>
<td>0x1A</td>
<td>__le16</td>
<td>bg_inode_bitmap_csum_lo</td>
<td>Lower 16-bits of the inode bitmap checksum.
</td></tr>
<tr>
<td>0x1C</td>
<td>__le16</td>
<td>bg_itable_unused_lo</td>
<td>Lower 16-bits of unused inode count.  If set, we needn't scan past the <code>(sb.s_inodes_per_group - gdt.bg_itable_unused)</code>th entry in the inode table for this group.
</td></tr>
<tr>
<td>0x1E</td>
<td>__le16</td>
<td>bg_checksum</td>
<td>Group descriptor checksum; crc16(sb_uuid+group+desc) if the RO_COMPAT_GDT_CSUM feature is set, or crc32c(sb_uuid+group_desc) &amp; 0xFFFF if the RO_COMPAT_METADATA_CSUM feature is set.
</td></tr>
<tr>
<td colspan="4">These fields only exist if the 64bit feature is enabled and s_desc_size &gt; 32.
</td></tr>
<tr>
<td>0x20</td>
<td>__le32</td>
<td>bg_block_bitmap_hi</td>
<td>Upper 32-bits of location of block bitmap.
</td></tr>
<tr>
<td>0x24</td>
<td>__le32</td>
<td>bg_inode_bitmap_hi</td>
<td>Upper 32-bits of location of inodes bitmap.
</td></tr>
<tr>
<td>0x28</td>
<td>__le32</td>
<td>bg_inode_table_hi</td>
<td>Upper 32-bits of location of inodes table.
</td></tr>
<tr>
<td>0x2C</td>
<td>__le16</td>
<td>bg_free_blocks_count_hi</td>
<td>Upper 16-bits of free block count.
</td></tr>
<tr>
<td>0x2E</td>
<td>__le16</td>
<td>bg_free_inodes_count_hi</td>
<td>Upper 16-bits of free inode count.
</td></tr>
<tr>
<td>0x30</td>
<td>__le16</td>
<td>bg_used_dirs_count_hi</td>
<td>Upper 16-bits of directory count.
</td></tr>
<tr>
<td>0x32</td>
<td>__le16</td>
<td>bg_itable_unused_hi</td>
<td>Upper 16-bits of unused inode count.
</td></tr>
<tr>
<td>0x34</td>
<td>__le32</td>
<td>bg_exclude_bitmap_hi</td>
<td>Upper 32-bits of location of snapshot exclusion bitmap.
</td></tr>
<tr>
<td>0x38</td>
<td>__le16</td>
<td>bg_block_bitmap_csum_hi</td>
<td>Upper 16-bits of the block bitmap checksum.
</td></tr>
<tr>
<td>0x3A</td>
<td>__le16</td>
<td>bg_inode_bitmap_csum_hi</td>
<td>Upper 16-bits of the inode bitmap checksum.
</td></tr>
<tr>
<td>0x3C</td>
<td>__u32</td>
<td>bg_reserved</td>
<td>Padding to 64 bytes.
</td></tr></tbody></table>
<p>Total size is 64 bytes.
</p>

<p>The data block bitmap tracks the usage of data blocks within the block group.
</p><p>The inode bitmap records which entries in the inode table are in use.
</p><p>As with most bitmaps, one bit represents the usage status of one data block or inode table entry.  This implies a block group size of 8 * number_of_bytes_in_a_logical_block.
</p><p>NOTE: If <code>BLOCK_UNINIT</code> is set for a given block group, various parts of the kernel and e2fsprogs code pretends that the block bitmap contains zeros (i.e. all blocks in the group are free).  However, it is not necessarily the case that no blocks are in use -- if <code>meta_bg</code> is set, the bitmaps and group descriptor live inside the group.  Unfortunately, ext2fs_test_block_bitmap2() will return '0' for those locations, which produces confusing debugfs output.
</p>

<p>In a regular UNIX filesystem, the inode stores all the metadata pertaining to the file (time stamps, block maps, extended attributes, etc), not the directory entry.  To find the information associated with a file, one must traverse the directory files to find the directory entry associated with a file, then load the inode to find the metadata for that file.  ext4 appears to cheat (for performance reasons) a little bit by storing a copy of the file type (normally stored in the inode) in the directory entry.  (Compare all this to FAT, which stores all the file information directly in the directory entry, but does not support hard links and is in general more seek-happy than ext4 due to its simpler block allocator and extensive use of linked lists.)
</p><p>The inode table is a linear array of <code>struct ext4_inode</code>.  The table is sized to have enough blocks to store at least <code>sb.s_inode_size * sb.s_inodes_per_group</code> bytes.  The number of the block group containing an inode can be calculated as <code>(inode_number - 1) / sb.s_inodes_per_group</code>, and the offset into the group's table is <code>(inode_number - 1)&nbsp;% sb.s_inodes_per_group</code>.  There is no inode 0.
</p><p>The inode checksum is calculated against the FS UUID, the inode number, and the inode structure itself.
</p><p>The inode table entry is laid out in <code>struct ext4_inode</code>.
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le16</td>
<td>i_mode</td>
<td>File mode.  Any of:
<table>
<tbody><tr>
<td>0x1</td>
<td>S_IXOTH (Others may execute)
</td></tr>
<tr>
<td>0x2</td>
<td>S_IWOTH (Others may write)
</td></tr>
<tr>
<td>0x4</td>
<td>S_IROTH (Others may read)
</td></tr>
<tr>
<td>0x8</td>
<td>S_IXGRP (Group members may execute)
</td></tr>
<tr>
<td>0x10</td>
<td>S_IWGRP (Group members may write)
</td></tr>
<tr>
<td>0x20</td>
<td>S_IRGRP (Group members may read)
</td></tr>
<tr>
<td>0x40</td>
<td>S_IXUSR (Owner may execute)
</td></tr>
<tr>
<td>0x80</td>
<td>S_IWUSR (Owner may write)
</td></tr>
<tr>
<td>0x100</td>
<td>S_IRUSR (Owner may read)
</td></tr>
<tr>
<td>0x200</td>
<td>S_ISVTX (Sticky bit)
</td></tr>
<tr>
<td>0x400</td>
<td>S_ISGID (Set GID)
</td></tr>
<tr>
<td>0x800</td>
<td>S_ISUID (Set UID)
</td></tr>
<tr>
<td colspan="2">These are mutually-exclusive file types:
</td></tr>
<tr>
<td>0x1000</td>
<td>S_IFIFO (FIFO)
</td></tr>
<tr>
<td>0x2000</td>
<td>S_IFCHR (Character device)
</td></tr>
<tr>
<td>0x4000</td>
<td>S_IFDIR (Directory)
</td></tr>
<tr>
<td>0x6000</td>
<td>S_IFBLK (Block device)
</td></tr>
<tr>
<td>0x8000</td>
<td>S_IFREG (Regular file)
</td></tr>
<tr>
<td>0xA000</td>
<td>S_IFLNK (Symbolic link)
</td></tr>
<tr>
<td>0xC000</td>
<td>S_IFSOCK (Socket)
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x2</td>
<td>__le16</td>
<td>i_uid</td>
<td>Lower 16-bits of Owner UID.
</td></tr>
<tr>
<td>0x4</td>
<td>__le32</td>
<td>i_size_lo</td>
<td>Lower 32-bits of size in bytes.
</td></tr>
<tr>
<td>0x8</td>
<td>__le32</td>
<td>i_atime</td>
<td>Last access time, in seconds since the epoch.  However, if the EA_INODE inode flag is set, this inode stores an extended attribute value and this field contains the checksum of the value.
</td></tr>
<tr>
<td>0xC</td>
<td>__le32</td>
<td>i_ctime</td>
<td>Last inode change time, in seconds since the epoch.  However, if the EA_INODE inode flag is set, this inode stores an extended attribute value and this field contains the lower 32 bits of the attribute value's reference count.
</td></tr>
<tr>
<td>0x10</td>
<td>__le32</td>
<td>i_mtime</td>
<td>Last data modification time, in seconds since the epoch.  However, if the EA_INODE inode flag is set, this inode stores an extended attribute value and this field contains the number of the inode that owns the extended attribute.
</td></tr>
<tr>
<td>0x14</td>
<td>__le32</td>
<td>i_dtime</td>
<td>Deletion Time, in seconds since the epoch.
</td></tr>
<tr>
<td>0x18</td>
<td>__le16</td>
<td>i_gid</td>
<td>Lower 16-bits of GID.
</td></tr>
<tr>
<td>0x1A</td>
<td>__le16</td>
<td>i_links_count</td>
<td>Hard link count.  Normally, ext4 does not permit an inode to have more than 65,000 hard links.  This applies to files as well as directories, which means that there cannot be more than 64,998 subdirectories in a directory (each subdirectory's '..' entry counts as a hard link, as does the '.' entry in the directory itself).  With the DIR_NLINK feature enabled, ext4 supports more than 64,998 subdirectories by setting this field to 1 to indicate that the number of hard links is not known.
</td></tr>
<tr>
<td>0x1C</td>
<td>__le32</td>
<td>i_blocks_lo</td>
<td>Lower 32-bits of "block" count.  If the huge_file feature flag is not set on the filesystem, the file consumes <code>i_blocks_lo</code> 512-byte blocks on disk.  If huge_file is set and EXT4_HUGE_FILE_FL is NOT set in <code>inode.i_flags</code>, then the file consumes <code>i_blocks_lo + (i_blocks_hi &lt;&lt; 32)</code> 512-byte blocks on disk.  If huge_file is set and EXT4_HUGE_FILE_FL IS set in <code>inode.i_flags</code>, then this file consumes (<code>i_blocks_lo + i_blocks_hi</code> &lt;&lt; 32) filesystem blocks on disk.
</td></tr>
<tr>
<td>0x20</td>
<td>__le32</td>
<td>i_flags</td>
<td>Inode flags.  Any of:
<table>
<tbody><tr>
<td>0x1</td>
<td>This file requires secure deletion (EXT4_SECRM_FL).  (not implemented)
</td></tr>
<tr>
<td>0x2</td>
<td>This file should be preserved, should undeletion be desired (EXT4_UNRM_FL).  (not implemented)
</td></tr>
<tr>
<td>0x4</td>
<td>File is compressed (EXT4_COMPR_FL).  (not really implemented)
</td></tr>
<tr>
<td>0x8</td>
<td>All writes to the file must be synchronous (EXT4_SYNC_FL).
</td></tr>
<tr>
<td>0x10</td>
<td>File is immutable (EXT4_IMMUTABLE_FL).
</td></tr>
<tr>
<td>0x20</td>
<td>File can only be appended (EXT4_APPEND_FL).
</td></tr>
<tr>
<td>0x40</td>
<td>The dump(1) utility should not dump this file (EXT4_NODUMP_FL).
</td></tr>
<tr>
<td>0x80</td>
<td>Do not update access time (EXT4_NOATIME_FL).
</td></tr>
<tr>
<td>0x100</td>
<td>Dirty compressed file (EXT4_DIRTY_FL).  (not used)
</td></tr>
<tr>
<td>0x200</td>
<td>File has one or more compressed clusters (EXT4_COMPRBLK_FL).  (not used)
</td></tr>
<tr>
<td>0x400</td>
<td>Do not compress file (EXT4_NOCOMPR_FL). (not used)
</td></tr>
<tr>
<td>0x800</td>
<td>Encrypted inode (EXT4_ENCRYPT_FL).  This bit value previously was EXT4_ECOMPR_FL (compression error), which was never used.
</td></tr>
<tr>
<td>0x1000</td>
<td>Directory has hashed indexes (EXT4_INDEX_FL).
</td></tr>
<tr>
<td>0x2000</td>
<td>AFS magic directory (EXT4_IMAGIC_FL).
</td></tr>
<tr>
<td>0x4000</td>
<td>File data must always be written through the journal (EXT4_JOURNAL_DATA_FL).
</td></tr>
<tr>
<td>0x8000</td>
<td>File tail should not be merged (EXT4_NOTAIL_FL). (not used by ext4)
</td></tr>
<tr>
<td>0x10000</td>
<td>All directory entry data should be written synchronously (see <code>dirsync</code>) (EXT4_DIRSYNC_FL).
</td></tr>
<tr>
<td>0x20000</td>
<td>Top of directory hierarchy (EXT4_TOPDIR_FL).
</td></tr>
<tr>
<td>0x40000</td>
<td>This is a huge file (EXT4_HUGE_FILE_FL).
</td></tr>
<tr>
<td>0x80000</td>
<td>Inode uses extents (EXT4_EXTENTS_FL).
</td></tr>
<tr>
<td>0x200000</td>
<td>Inode stores a large extended attribute value in its data blocks (EXT4_EA_INODE_FL).
</td></tr>
<tr>
<td>0x400000</td>
<td>This file has blocks allocated past EOF (EXT4_EOFBLOCKS_FL). (deprecated)
</td></tr>
<tr>
<td>0x01000000</td>
<td>Inode is a snapshot (<code>EXT4_SNAPFILE_FL</code>). (not in mainline)
</td></tr>
<tr>
<td>0x04000000</td>
<td>Snapshot is being deleted (<code>EXT4_SNAPFILE_DELETED_FL</code>). (not in mainline)
</td></tr>
<tr>
<td>0x08000000</td>
<td>Snapshot shrink has completed (<code>EXT4_SNAPFILE_SHRUNK_FL</code>). (not in mainline)
</td></tr>
<tr>
<td>0x10000000</td>
<td>Inode has inline data (EXT4_INLINE_DATA_FL).
</td></tr>
<tr>
<td>0x20000000</td>
<td>Create children with the same project ID (EXT4_PROJINHERIT_FL).
</td></tr>
<tr>
<td>0x80000000</td>
<td>Reserved for ext4 library (EXT4_RESERVED_FL).
</td></tr>
<tr>
<td colspan="2">Aggregate flags:
</td></tr>
<tr>
<td>0x4BDFFF</td>
<td>User-visible flags.
</td></tr>
<tr>
<td>0x4B80FF</td>
<td>User-modifiable flags.  Note that while EXT4_JOURNAL_DATA_FL and EXT4_EXTENTS_FL can be set with setattr, they are not in the kernel's EXT4_FL_USER_MODIFIABLE mask, since it needs to handle the setting of these flags in a special manner and they are masked out of the set of flags that are saved directly to i_flags.
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x24</td>
<td>4 bytes</td>
<td colspan="2">
<p>Union osd1:
</p>
<table>
<tbody><tr>
<th>Tag</th>
<th>Contents
</th></tr>
<tr>
<td>linux1</td>
<td>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>l_i_version</td>
<td>Inode version.  However, if the EA_INODE inode flag is set, this inode stores an extended attribute value and this field contains the upper 32 bits of the attribute value's reference count.
</td></tr></tbody></table>
</td></tr>
<tr>
<td>hurd1</td>
<td>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>h_i_translator</td>
<td>??
</td></tr></tbody></table>
</td></tr>
<tr>
<td>masix1</td>
<td>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>m_i_reserved</td>
<td>??
</td></tr></tbody></table>
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x28</td>
<td>60 bytes</td>
<td>i_block[EXT4_N_BLOCKS=15]</td>
<td>Block map or extent tree.  See the section "The Contents of inode.i_block".
</td></tr>
<tr>
<td>0x64</td>
<td>__le32</td>
<td>i_generation</td>
<td>File version (for NFS).
</td></tr>
<tr>
<td>0x68</td>
<td>__le32</td>
<td>i_file_acl_lo</td>
<td>Lower 32-bits of extended attribute block.  ACLs are of course one of many possible extended attributes; I think the name of this field is a result of the first use of extended attributes being for ACLs.
</td></tr>
<tr>
<td>0x6C</td>
<td>__le32</td>
<td>i_size_high / i_dir_acl</td>
<td>Upper 32-bits of file/directory size.  In ext2/3 this field was named i_dir_acl, though it was usually set to zero and never used.
</td></tr>
<tr>
<td>0x70</td>
<td>__le32</td>
<td>i_obso_faddr</td>
<td>(Obsolete) fragment address.
</td></tr>
<tr>
<td>0x74</td>
<td>12 bytes</td>
<td colspan="2">
<p>Union osd2:
</p>
<table>
<tbody><tr>
<th>Tag</th>
<th>Contents
</th></tr>
<tr>
<td>linux2</td>
<td>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le16</td>
<td>l_i_blocks_high</td>
<td>Upper 16-bits of the block count.  Please see the note attached to i_blocks_lo.
</td></tr>
<tr>
<td>0x2</td>
<td>__le16</td>
<td>l_i_file_acl_high</td>
<td>Upper 16-bits of the extended attribute block (historically, the file ACL location).  See the Extended Attributes section below.
</td></tr>
<tr>
<td>0x4</td>
<td>__le16</td>
<td>l_i_uid_high</td>
<td>Upper 16-bits of the Owner UID.
</td></tr>
<tr>
<td>0x6</td>
<td>__le16</td>
<td>l_i_gid_high</td>
<td>Upper 16-bits of the GID.
</td></tr>
<tr>
<td>0x8</td>
<td>__le16</td>
<td>l_i_checksum_lo</td>
<td>Lower 16-bits of the inode checksum.
</td></tr>
<tr>
<td>0xA</td>
<td>__le16</td>
<td>l_i_reserved</td>
<td>Unused.
</td></tr></tbody></table>
</td></tr>
<tr>
<td>hurd2</td>
<td>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le16</td>
<td>h_i_reserved1</td>
<td>??
</td></tr>
<tr>
<td>0x2</td>
<td>__u16</td>
<td>h_i_mode_high</td>
<td>Upper 16-bits of the file mode.
</td></tr>
<tr>
<td>0x4</td>
<td>__le16</td>
<td>h_i_uid_high</td>
<td>Upper 16-bits of the Owner UID.
</td></tr>
<tr>
<td>0x6</td>
<td>__le16</td>
<td>h_i_gid_high</td>
<td>Upper 16-bits of the GID.
</td></tr>
<tr>
<td>0x8</td>
<td>__u32</td>
<td>h_i_author</td>
<td>Author code?
</td></tr></tbody></table>
</td></tr>
<tr>
<td>masix2</td>
<td>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le16</td>
<td>h_i_reserved1</td>
<td>??
</td></tr>
<tr>
<td>0x2</td>
<td>__u16</td>
<td>m_i_file_acl_high</td>
<td>Upper 16-bits of the extended attribute block (historically, the file ACL location).
</td></tr>
<tr>
<td>0x4</td>
<td>__u32</td>
<td>m_i_reserved2[2]</td>
<td>??
</td></tr></tbody></table>
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x80</td>
<td>__le16</td>
<td>i_extra_isize</td>
<td>Size of this inode - 128.  Alternately, the size of the extended inode fields beyond the original ext2 inode, including this field.
</td></tr>
<tr>
<td>0x82</td>
<td>__le16</td>
<td>i_checksum_hi</td>
<td>Upper 16-bits of the inode checksum.
</td></tr>
<tr>
<td>0x84</td>
<td>__le32</td>
<td>i_ctime_extra</td>
<td>Extra change time bits.  This provides sub-second precision.  See Inode Timestamps section.
</td></tr>
<tr>
<td>0x88</td>
<td>__le32</td>
<td>i_mtime_extra</td>
<td>Extra modification time bits.  This provides sub-second precision.
</td></tr>
<tr>
<td>0x8C</td>
<td>__le32</td>
<td>i_atime_extra</td>
<td>Extra access time bits.  This provides sub-second precision.
</td></tr>
<tr>
<td>0x90</td>
<td>__le32</td>
<td>i_crtime</td>
<td>File creation time, in seconds since the epoch.
</td></tr>
<tr>
<td>0x94</td>
<td>__le32</td>
<td>i_crtime_extra</td>
<td>Extra file creation time bits.  This provides sub-second precision.
</td></tr>
<tr>
<td>0x98</td>
<td>__le32</td>
<td>i_version_hi</td>
<td>Upper 32-bits for version number.
</td></tr>
<tr>
<td>0x9C</td>
<td>__le32</td>
<td>i_projid</td>
<td>Project ID.
</td></tr></tbody></table>
<h2> <span id="Inode_Size"> Inode Size </span></h2>
<p>In ext2 and ext3, the inode structure size was fixed at 128 bytes (<code>EXT2_GOOD_OLD_INODE_SIZE</code>) and each inode had a disk record size of 128 bytes.  Starting with ext4, it is possible to allocate a larger on-disk inode at format time for all inodes in the filesystem to provide space beyond the end of the original ext2 inode.  The on-disk inode record size is recorded in the superblock as <code>s_inode_size</code>.  The number of bytes actually used by struct ext4_inode beyond the original 128-byte ext2 inode is recorded in the <code>i_extra_isize</code> field for each inode, which allows struct ext4_inode to grow for a new kernel without having to upgrade all of the on-disk inodes.  Access to fields beyond EXT2_GOOD_OLD_INODE_SIZE should be verified to be within <code>i_extra_isize</code>.  By default, ext4 inode records are 256 bytes, and (as of October 2013) the inode structure is 156 bytes (<code>i_extra_isize = 28</code>).  The extra space between the end of the inode structure and the end of the inode record can be used to store extended attributes.  Each inode record can be as large as the filesystem block size, though this is not terribly efficient.
</p>
<h2> <span id="Finding_an_Inode"> Finding an Inode </span></h2>
<p>Each block group contains <code>sb-&gt;s_inodes_per_group</code> inodes.  Because inode 0 is defined not to exist, this formula can be used to find the block group that an inode lives in: <code>bg = (inode_num - 1) / sb-&gt;s_inodes_per_group</code>.  The particular inode can be found within the block group's inode table at <code>index = (inode_num - 1)&nbsp;% sb-&gt;s_inodes_per_group</code>.  To get the byte address within the inode table, use <code>offset = index * sb-&gt;s_inode_size</code>.
</p>
<h2> <span id="Inode_Timestamps"> Inode Timestamps </span></h2>
<p>Four timestamps are recorded in the lower 128 bytes of the inode structure -- inode change time (ctime), access time (atime), data modification time (mtime), and deletion time (dtime).  The four fields are 32-bit signed integers that represent seconds since the Unix epoch (1970-01-01 00:00:00 GMT), which means that the fields will overflow in January 2038.  For inodes that are not linked from any directory but are still open (orphan inodes), the dtime field is overloaded for use with the orphan list.  The superblock field <code>s_last_orphan</code> points to the first inode in the orphan list; dtime is then the number of the next orphaned inode, or zero if there are no more orphans.
</p><p>If the inode structure size <code>sb-&gt;s_inode_size</code> is larger than 128 bytes and the <code>i_inode_extra</code> field is large enough to encompass the respective <code>i_[cma]time_extra</code> field, the ctime, atime, and mtime inode fields are widened to 64 bits.  Within this "extra" 32-bit field, the lower two bits are used to extend the 32-bit seconds field to be 34 bit wide; the upper 30 bits are used to provide nanosecond timestamp accuracy.  Therefore, timestamps should not overflow until May 2446.  dtime was not widened.  There is also a fifth timestamp to record inode creation time (crtime); this field is 64-bits wide and decoded in the same manner as 64-bit [cma]time.  Neither crtime nor dtime are accessible through the regular stat() interface, though debugfs will report them.
</p><p>We use the 32-bit signed time value plus (2^32 * (extra epoch bits)).  In other words:
</p>
<table>
<tbody><tr>
<th>Extra epoch bits</th>
<th>MSB of 32-bit time</th>
<th>Adjustment for signed 32-bit to 64-bit tv_sec</th>
<th>Decoded 64-bit tv_sec</th>
<th>valid time range
</th></tr>
<tr>
<td>0 0</td>
<td>1</td>
<td>0</td>
<td><code>-0x80000000 - -0x00000001</code></td>
<td>1901-12-13 to 1969-12-31
</td></tr>
<tr>
<td>0 0</td>
<td>0</td>
<td>0</td>
<td><code>0x000000000 - 0x07fffffff</code></td>
<td>1970-01-01 to 2038-01-19
</td></tr>
<tr>
<td>0 1</td>
<td>1</td>
<td>0x100000000</td>
<td><code>0x080000000 - 0x0ffffffff</code></td>
<td>2038-01-19 to 2106-02-07
</td></tr>
<tr>
<td>0 1</td>
<td>0</td>
<td>0x100000000</td>
<td><code>0x100000000 - 0x17fffffff</code></td>
<td>2106-02-07 to 2174-02-25
</td></tr>
<tr>
<td>1 0</td>
<td>1</td>
<td>0x200000000</td>
<td><code>0x180000000 - 0x1ffffffff</code></td>
<td>2174-02-25 to 2242-03-16
</td></tr>
<tr>
<td>1 0</td>
<td>0</td>
<td>0x200000000</td>
<td><code>0x200000000 - 0x27fffffff</code></td>
<td>2242-03-16 to 2310-04-04
</td></tr>
<tr>
<td>1 1</td>
<td>1</td>
<td>0x300000000</td>
<td><code>0x280000000 - 0x2ffffffff</code></td>
<td>2310-04-04 to 2378-04-22
</td></tr>
<tr>
<td>1 1</td>
<td>0</td>
<td>0x300000000</td>
<td><code>0x300000000 - 0x37fffffff</code></td>
<td>2378-04-22 to 2446-05-10
</td></tr></tbody></table>
<p>This is a somewhat odd encoding since there are effectively seven times as many positive values as negative values.  There have also been long-standing bugs decoding and encoding dates beyond 2038, which don't seem to be fixed as of kernel 3.12 and e2fsprogs 1.42.8.  64-bit kernels incorrectly use the extra epoch bits 1,1 for dates between 1901 and 1970.  At some point the kernel will be fixed and e2fsck will fix this situation, assuming that it is run before 2310.
</p>

<p>Depending on the type of file an inode describes, the 60 bytes of storage in <code>inode.i_block</code> can be used in different ways.  In general, regular files and directories will use it for file block indexing information, and special files will use it for special purposes.
</p>
<h2> <span id="Symbolic_Links"> Symbolic Links </span></h2>
<p>The target of a symbolic link will be stored in this field if the target string is less than 60 bytes long.  Otherwise, either extents or block maps will be used to allocate data blocks to store the link target.
</p>
<h2> <span id="Direct.2FIndirect_Block_Addressing"> Direct/Indirect Block Addressing </span></h2>
<p>In ext2/3, file block numbers were mapped to logical block numbers by means of an (up to) three level 1-1 block map.  To find the logical block that stores a particular file block, the code would navigate through this increasingly complicated structure.  Notice that there is neither a magic number nor a checksum to provide any level of confidence that the block isn't full of garbage.
</p>
<table>
<tbody><tr>
<th>i.i_block Offset</th>
<th>Where It Points
</th></tr>
<tr>
<td>0 to 11</td>
<td>Direct map to file blocks 0 to 11.
</td></tr>
<tr>
<td>12</td>
<td>Indirect block: (file blocks 12 to (<code>$block_size</code> / 4) + 11, or 12 to 1035 if 4KiB blocks)
<table>
<tbody><tr>
<th>Indirect Block Offset</th>
<th>Where It Points
</th></tr>
<tr>
<td>0 to (<code>$block_size</code> / 4)</td>
<td>Direct map to (<code>$block_size</code> / 4) blocks (1024 if 4KiB blocks)
</td></tr></tbody></table>
</td></tr>
<tr>
<td>13</td>
<td>Double-indirect block: (file blocks <code>$block_size</code>/4 + 12 to (<code>$block_size</code> / 4) ^ 2 + (<code>$block_size</code> / 4) + 11, or 1036 to 1049611 if 4KiB blocks)
<table>
<tbody><tr>
<th>Double Indirect Block Offset</th>
<th>Where It Points
</th></tr>
<tr>
<td>0 to (<code>$block_size</code> / 4)</td>
<td>Map to (<code>$block_size</code> / 4) indirect blocks (1024 if 4KiB blocks)
<table>
<tbody><tr>
<th>Indirect Block Offset</th>
<th>Where It Points
</th></tr>
<tr>
<td>0 to (<code>$block_size</code> / 4)</td>
<td>Direct map to (<code>$block_size</code> / 4) blocks (1024 if 4KiB blocks)
</td></tr></tbody></table>
</td></tr></tbody></table>
</td></tr>
<tr>
<td>14</td>
<td>Triple-indirect block: (file blocks (<code>$block_size</code> / 4) ^ 2 + (<code>$block_size</code> / 4) + 12 to (<code>$block_size</code> / 4) ^ 3 + (<code>$block_size</code> / 4) ^ 2 + (<code>$block_size</code> / 4) + 12, or 1049612 to 1074791436 if 4KiB blocks)
<table>
<tbody><tr>
<th>Triple Indirect Block Offset</th>
<th>Where It Points
</th></tr>
<tr>
<td>0 to (<code>$block_size</code> / 4)</td>
<td>Map to (<code>$block_size</code> / 4) double indirect blocks (1024 if 4KiB blocks)
<table>
<tbody><tr>
<th>Double Indirect Block Offset</th>
<th>Where It Points
</th></tr>
<tr>
<td>0 to (<code>$block_size</code> / 4)</td>
<td>Map to (<code>$block_size</code> / 4) indirect blocks (1024 if 4KiB blocks)
<table>
<tbody><tr>
<th>Indirect Block Offset</th>
<th>Where It Points
</th></tr>
<tr>
<td>0 to (<code>$block_size</code> / 4)</td>
<td>Direct map to (<code>$block_size</code> / 4) blocks (1024 if 4KiB blocks)
</td></tr></tbody></table>
</td></tr></tbody></table>
</td></tr></tbody></table>
</td></tr></tbody></table>
<p>Note that with this block mapping scheme, it is necessary to fill out a lot of mapping data even for a large contiguous file!  This inefficiency led to the creation of the extent mapping scheme, discussed below.
</p><p>Notice also that a file using this mapping scheme cannot be placed higher than 2^32 blocks.
</p>
<h2> <span id="Extent_Tree"> Extent Tree </span></h2>
<p>In ext4, the file to logical block map has been replaced with an extent tree.  Under the old scheme, allocating a contiguous run of 1,000 blocks requires an indirect block to map all 1,000 entries; with extents, the mapping is reduced to a single <code>struct ext4_extent</code> with <code>ee_len = 1000</code>.  If flex_bg is enabled, it is possible to allocate very large files with a single extent, at a considerable reduction in metadata block use, and some improvement in disk efficiency.  The inode must have the extents flag (0x80000) flag set for this feature to be in use.
</p><p>Extents are arranged as a tree.  Each node of the tree begins with a <code>struct ext4_extent_header</code>.  If the node is an interior node (<code>eh.eh_depth</code> &gt; 0), the header is followed by <code>eh.eh_entries</code> instances of <code>struct ext4_extent_idx</code>; each of these index entries points to a block containing more nodes in the extent tree.  If the node is a leaf node (<code>eh.eh_depth == 0</code>), then the header is followed by <code>eh.eh_entries</code> instances of <code>struct ext4_extent</code>; these instances point to the file's data blocks.  The root node of the extent tree is stored in <code>inode.i_block</code>, which allows for the first four extents to be recorded without the use of extra metadata blocks.
</p><p>The extent tree header is recorded in <code>struct ext4_extent_header</code>, which is 12 bytes long:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le16</td>
<td>eh_magic</td>
<td>Magic number, 0xF30A.
</td></tr>
<tr>
<td>0x2</td>
<td>__le16</td>
<td>eh_entries</td>
<td>Number of valid entries following the header.
</td></tr>
<tr>
<td>0x4</td>
<td>__le16</td>
<td>eh_max</td>
<td>Maximum number of entries that could follow the header.
</td></tr>
<tr>
<td>0x6</td>
<td>__le16</td>
<td>eh_depth</td>
<td>Depth of this extent node in the extent tree.  0 = this extent node points to data blocks; otherwise, this extent node points to other extent nodes.  The extent tree can be at most 5 levels deep: a logical block number can be at most <code>2^32</code>, and the smallest <code>n</code> that satisfies <code>4*(((blocksize - 12)/12)^n) &gt;= 2^32</code> is 5.
</td></tr>
<tr>
<td>0x8</td>
<td>__le32</td>
<td>eh_generation</td>
<td>Generation of the tree. (Used by Lustre, but not standard ext4).
</td></tr></tbody></table>
<p>Internal nodes of the extent tree, also known as index nodes, are recorded as <code>struct ext4_extent_idx</code>, and are 12 bytes long:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>ei_block</td>
<td>This index node covers file blocks from 'block' onward.
</td></tr>
<tr>
<td>0x4</td>
<td>__le32</td>
<td>ei_leaf_lo</td>
<td>Lower 32-bits of the block number of the extent node that is the next level lower in the tree.  The tree node pointed to can be either another internal node or a leaf node, described below.
</td></tr>
<tr>
<td>0x8</td>
<td>__le16</td>
<td>ei_leaf_hi</td>
<td>Upper 16-bits of the previous field.
</td></tr>
<tr>
<td>0xA</td>
<td>__u16</td>
<td>ei_unused</td>
<td>
</td></tr></tbody></table>
<p>Leaf nodes of the extent tree are recorded as <code>struct ext4_extent</code>, and are also 12 bytes long:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>ee_block</td>
<td>First file block number that this extent covers.
</td></tr>
<tr>
<td>0x4</td>
<td>__le16</td>
<td>ee_len</td>
<td>Number of blocks covered by extent.  If the value of this field is &lt;= 32768, the extent is initialized.  If the value of the field is &gt; 32768, the extent is uninitialized and the actual extent length is <code>ee_len</code> - 32768.  Therefore, the maximum length of a initialized extent is 32768 blocks, and the maximum length of an uninitialized extent is 32767.
</td></tr>
<tr>
<td>0x6</td>
<td>__le16</td>
<td>ee_start_hi</td>
<td>Upper 16-bits of the block number to which this extent points.
</td></tr>
<tr>
<td>0x8</td>
<td>__le32</td>
<td>ee_start_lo</td>
<td>Lower 32-bits of the block number to which this extent points.
</td></tr></tbody></table>
<p>Prior to the introduction of metadata checksums, the extent header + extent entries always left at least 4 bytes of unallocated space at the end of each extent tree data block (because (2^x&nbsp;% 12) &gt;= 4).  Therefore, the 32-bit checksum is inserted into this space.  The 4 extents in the inode do not need checksumming, since the inode is already checksummed.  The checksum is calculated against the FS UUID, the inode number, the inode generation, and the entire extent block leading up to (but not including) the checksum itself.
</p><p><code>struct ext4_extent_tail</code> is 4 bytes long:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>eb_checksum</td>
<td>Checksum of the extent block, crc32c(uuid+inum+igeneration+extentblock)
</td></tr></tbody></table>
<h2> <span id="Inline_Data_2"> Inline Data </span></h2>
<p>If the inline data feature is enabled for the filesystem and the flag is set for the inode, it is possible that the first 60 bytes of the file data are stored here.
</p>

<p>In an ext4 filesystem, a directory is more or less a flat file that maps an arbitrary byte string (usually ASCII) to an inode number on the filesystem.  There can be many directory entries across the filesystem that reference the same inode number--these are known as hard links, and that is why hard links cannot reference files on other filesystems.  As such, directory entries are found by reading the data block(s) associated with a directory file for the particular directory entry that is desired.
</p>
<h2> <span id="Linear_.28Classic.29_Directories"> Linear (Classic) Directories </span></h2>
<p>By default, each directory lists its entries in an "almost-linear" array.  I write "almost" because it's not a linear array in the memory sense because directory entries are not split across filesystem blocks.  Therefore, it is more accurate to say that a directory is a series of data blocks and that each block contains a linear array of directory entries.  The end of each  per-block array is signified by reaching the end of the block; the last entry in the block has a record length that takes it all the way to the end of the block.  The end of the entire directory is of course signified by reaching the end of the file.  Unused directory entries are signified by inode = 0.  By default the filesystem uses <code>struct ext4_dir_entry_2</code> for directory entries unless the "filetype" feature flag is not set, in which case it uses <code>struct ext4_dir_entry</code>.
</p><p>The original directory entry format is <code>struct ext4_dir_entry</code>, which is at most 263 bytes long, though on disk you'll need to reference <code>dirent.rec_len</code> to know for sure.
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>inode</td>
<td>Number of the inode that this directory entry points to.
</td></tr>
<tr>
<td>0x4</td>
<td>__le16</td>
<td>rec_len</td>
<td>Length of this directory entry. Must be a multiple of 4.
</td></tr>
<tr>
<td>0x6</td>
<td>__le16</td>
<td>name_len</td>
<td>Length of the file name.
</td></tr>
<tr>
<td>0x8</td>
<td>char</td>
<td>name[EXT4_NAME_LEN]</td>
<td>File name.
</td></tr></tbody></table>
<p>Since file names cannot be longer than 255 bytes, the new directory entry format shortens the rec_len field and uses the space for a file type flag, probably to avoid having to load every inode during directory tree traversal.  This format is <code>ext4_dir_entry_2</code>, which is at most 263 bytes long, though on disk you'll need to reference <code>dirent.rec_len</code> to know for sure.
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>inode</td>
<td>Number of the inode that this directory entry points to.
</td></tr>
<tr>
<td>0x4</td>
<td>__le16</td>
<td>rec_len</td>
<td>Length of this directory entry.
</td></tr>
<tr>
<td>0x6</td>
<td>__u8</td>
<td>name_len</td>
<td>Length of the file name.
</td></tr>
<tr>
<td>0x7</td>
<td>__u8</td>
<td>file_type</td>
<td>File type code, one of:
<table>
<tbody><tr>
<td>0x0</td>
<td>Unknown.
</td></tr>
<tr>
<td>0x1</td>
<td>Regular file.
</td></tr>
<tr>
<td>0x2</td>
<td>Directory.
</td></tr>
<tr>
<td>0x3</td>
<td>Character device file.
</td></tr>
<tr>
<td>0x4</td>
<td>Block device file.
</td></tr>
<tr>
<td>0x5</td>
<td>FIFO.
</td></tr>
<tr>
<td>0x6</td>
<td>Socket.
</td></tr>
<tr>
<td>0x7</td>
<td>Symbolic link.
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x8</td>
<td>char</td>
<td>name[EXT4_NAME_LEN]</td>
<td>File name.
</td></tr></tbody></table>
<p>In order to add checksums to these classic directory blocks, a phony <code>struct ext4_dir_entry</code> is placed at the end of each leaf block to hold the checksum.  The directory entry is 12 bytes long.  The inode number and name_len fields are set to zero to fool old software into ignoring an apparently empty directory entry, and the checksum is stored in the place where the name normally goes.  The structure is <code>struct ext4_dir_entry_tail</code>:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Size</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>det_reserved_zero1</td>
<td>Inode number, which must be zero.
</td></tr>
<tr>
<td>0x4</td>
<td>__le16</td>
<td>det_rec_len</td>
<td>Length of this directory entry, which must be 12.
</td></tr>
<tr>
<td>0x6</td>
<td>__u8</td>
<td>det_reserved_zero2</td>
<td>Length of the file name, which must be zero.
</td></tr>
<tr>
<td>0x7</td>
<td>__u8</td>
<td>det_reserved_ft</td>
<td>File type, which must be 0xDE.
</td></tr>
<tr>
<td>0x8</td>
<td>__le32</td>
<td>det_checksum</td>
<td>Directory leaf block checksum.
</td></tr></tbody></table>
<p>The leaf directory block checksum is calculated against the FS UUID, the directory's inode number, the directory's inode generation number, and the entire directory entry block up to (but not including) the fake directory entry.
</p>
<h2> <span id="Hash_Tree_Directories"> Hash Tree Directories </span></h2>
<p>A linear array of directory entries isn't great for performance, so a new feature was added to ext3 to provide a faster (but peculiar) balanced tree keyed off a hash of the directory entry name.  If the EXT4_INDEX_FL (0x1000) flag is set in the inode, this directory uses a hashed btree (htree) to organize and find directory entries.  For backwards read-only compatibility with ext2, this tree is actually hidden inside the directory file, masquerading as "empty" directory data blocks!  It was stated previously that the end of the linear directory entry table was signified with an entry pointing to inode 0; this is (ab)used to fool the old linear-scan algorithm into thinking that the rest of the directory block is empty so that it moves on.
</p><p>The root of the tree always lives in the first data block of the directory.  By ext2 custom, the '.' and '..' entries must appear at the beginning of this first block, so they are put here as two <code>struct ext4_dir_entry_2</code>s and not stored in the tree.  The rest of the root node contains metadata about the tree and finally a hash-&gt;block map to find nodes that are lower in the htree.  If <code>dx_root.info.indirect_levels</code> is non-zero then the htree has two levels; the data block pointed to by the root node's map is an interior node, which is indexed by a minor hash.  Interior nodes in this tree contains a zeroed out <code>struct ext4_dir_entry_2</code> followed by a minor_hash-&gt;block map to find leafe nodes.  Leaf nodes contain a linear array of all <code>struct ext4_dir_entry_2</code>; all of these entries (presumably) hash to the same value.  If there is an overflow, the entries simply overflow into the next leaf node, and the least-significant bit of the hash (in the interior node map) that gets us to this next leaf node is set.
</p><p>To traverse the directory as a htree, the code calculates the hash of the desired file name and uses it to find the corresponding block number.  If the tree is flat, the block is a linear array of directory entries that can be searched; otherwise, the minor hash of the file name is computed and used against this second block to find the corresponding third block number.  That third block number will be a linear array of directory entries.
</p><p>To traverse the directory as a linear array (such as the old code does), the code simply reads every data block in the directory.  The blocks used for the htree will appear to have no entries (aside from '.' and '..') and so only the leaf nodes will appear to have any interesting content.
</p><p>The root of the htree is in <code>struct dx_root</code>, which is the full length of a data block:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>dot.inode</td>
<td>inode number of this directory.
</td></tr>
<tr>
<td>0x4</td>
<td>__le16</td>
<td>dot.rec_len</td>
<td>Length of this record, 12.
</td></tr>
<tr>
<td>0x6</td>
<td>u8</td>
<td>dot.name_len</td>
<td>Length of the name, 1.
</td></tr>
<tr>
<td>0x7</td>
<td>u8</td>
<td>dot.file_type</td>
<td>File type of this entry, 0x2 (directory) (if the feature flag is set).
</td></tr>
<tr>
<td>0x8</td>
<td>char</td>
<td>dot.name[4]</td>
<td>".\0\0\0"
</td></tr>
<tr>
<td>0xC</td>
<td>__le32</td>
<td>dotdot.inode</td>
<td>inode number of parent directory.
</td></tr>
<tr>
<td>0x10</td>
<td>__le16</td>
<td>dotdot.rec_len</td>
<td>block_size - 12.  The record length is long enough to cover all htree data.
</td></tr>
<tr>
<td>0x12</td>
<td>u8</td>
<td>dotdot.name_len</td>
<td>Length of the name, 2.
</td></tr>
<tr>
<td>0x13</td>
<td>u8</td>
<td>dotdot.file_type</td>
<td>File type of this entry, 0x2 (directory) (if the feature flag is set).
</td></tr>
<tr>
<td>0x14</td>
<td>char</td>
<td>dotdot_name[4]</td>
<td>"..\0\0"
</td></tr>
<tr>
<td>0x18</td>
<td>__le32</td>
<td>struct dx_root_info.reserved_zero</td>
<td>Zero.
</td></tr>
<tr>
<td>0x1C</td>
<td>u8</td>
<td>struct dx_root_info.hash_version</td>
<td>Hash version, one of:
<table>
<tbody><tr>
<td>0x0</td>
<td>Legacy.
</td></tr>
<tr>
<td>0x1</td>
<td>Half MD4.
</td></tr>
<tr>
<td>0x2</td>
<td>Tea.
</td></tr>
<tr>
<td>0x3</td>
<td>Legacy, unsigned.
</td></tr>
<tr>
<td>0x4</td>
<td>Half MD4, unsigned.
</td></tr>
<tr>
<td>0x5</td>
<td>Tea, unsigned.
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x1D</td>
<td>u8</td>
<td>struct dx_root_info.info_length</td>
<td>Length of the tree information, 0x8.
</td></tr>
<tr>
<td>0x1E</td>
<td>u8</td>
<td>struct dx_root_info.indirect_levels</td>
<td>Depth of the htree.  Cannot be larger than 3 if the INCOMPAT_LARGEDIR feature is set; cannot be larger than 2 otherwise.
</td></tr>
<tr>
<td>0x1F</td>
<td>u8</td>
<td>struct dx_root_info.unused_flags</td>
<td>
</td></tr>
<tr>
<td>0x20</td>
<td>__le16</td>
<td>limit</td>
<td>Maximum number of dx_entries that can follow this header, plus 1 for the header itself.
</td></tr>
<tr>
<td>0x22</td>
<td>__le16</td>
<td>count</td>
<td>Actual number of dx_entries that follow this header, plus 1 for the header itself.
</td></tr>
<tr>
<td>0x24</td>
<td>__le32</td>
<td>block</td>
<td>The block number (within the directory file) that goes with hash=0.
</td></tr>
<tr>
<td>0x28</td>
<td>struct dx_entry</td>
<td>entries[0]</td>
<td>As many 8-byte <code>struct dx_entry</code> as fits in the rest of the data block.
</td></tr></tbody></table>
<p>Interior nodes of an htree are recorded as <code>struct dx_node</code>, which is also the full length of a data block:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>fake.inode</td>
<td>Zero, to make it look like this entry is not in use.
</td></tr>
<tr>
<td>0x4</td>
<td>__le16</td>
<td>fake.rec_len</td>
<td>The size of the block, in order to hide all of the dx_node data.
</td></tr>
<tr>
<td>0x6</td>
<td>u8</td>
<td>name_len</td>
<td>Zero.  There is no name for this "unused" directory entry.
</td></tr>
<tr>
<td>0x7</td>
<td>u8</td>
<td>file_type</td>
<td>Zero.  There is no file type for this "unused" directory entry.
</td></tr>
<tr>
<td>0x8</td>
<td>__le16</td>
<td>limit</td>
<td>Maximum number of dx_entries that can follow this header, plus 1 for the header itself.
</td></tr>
<tr>
<td>0xA</td>
<td>__le16</td>
<td>count</td>
<td>Actual number of dx_entries that follow this header, plus 1 for the header itself.
</td></tr>
<tr>
<td>0xE</td>
<td>__le32</td>
<td>block</td>
<td>The block number (within the directory file) that goes with the lowest hash value of this block.  This value is stored in the parent block.
</td></tr>
<tr>
<td>0x12</td>
<td>struct dx_entry</td>
<td>entries[0]</td>
<td>As many 8-byte <code>struct dx_entry</code> as fits in the rest of the data block.
</td></tr></tbody></table>
<p>The hash maps that exist in both <code>struct dx_root</code> and <code>struct dx_node</code> are recorded as <code>struct dx_entry</code>, which is 8 bytes long:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>hash</td>
<td>Hash code.
</td></tr>
<tr>
<td>0x4</td>
<td>__le32</td>
<td>block</td>
<td>Block number (within the directory file, not filesystem blocks) of the next node in the htree.
</td></tr></tbody></table>
<p>(If you think this is all quite clever and peculiar, so does the author.)
</p><p>If metadata checksums are enabled, the last 8 bytes of the directory block (precisely the length of one dx_entry) are used to store a <code>struct dx_tail</code>, which contains the checksum.  The <code>limit</code> and <code>count</code> entries in the dx_root/dx_node structures are adjusted as necessary to fit the dx_tail into the block.  If there is no space for the dx_tail, the user is notified to run e2fsck -D to rebuild the directory index (which will ensure that there's space for the checksum.  The dx_tail structure is 8 bytes long and looks like this:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>u32</td>
<td>dt_reserved
</td></tr>
<tr>
<td>0x4</td>
<td>__le32</td>
<td>dt_checksum</td>
<td>Checksum of the htree directory block.
</td></tr></tbody></table>
<p>The checksum is calculated against the FS UUID, the htree index header (dx_root or dx_node), all of the htree indices (dx_entry) that are in use, and the tail block (dx_tail).
</p>

<p>Extended attributes (xattrs) are typically stored in a separate data block on the disk and referenced from inodes via <code>inode.i_file_acl*</code>.  The first use of extended attributes seems to have been for storing file ACLs and other security data (selinux).  With the <code>user_xattr</code> mount option it is possible for users to store extended attributes so long as all attribute names begin with "user"; this restriction seems to have disappeared as of Linux 3.0.
</p><p>There are two places where extended attributes can be found.  The first place is between the end of each inode entry and the beginning of the next inode entry.  For example, if inode.i_extra_isize = 28 and sb.inode_size = 256, then there are 256 - (128 + 28) = 100 bytes available for in-inode extended attribute storage.  The second place where extended attributes can be found is in the block pointed to by <code>inode.i_file_acl</code>.  As of Linux 3.11, it is not possible for this block to contain a pointer to a second extended attribute block (or even the remaining blocks of a cluster).  In theory it is possible for each attribute's value to be stored in a separate data block, though as of Linux 3.11 the code does not permit this.
</p><p>Keys are generally assumed to be ASCIIZ strings, whereas values can be strings or binary data.
</p><p>Extended attributes, when stored after the inode, have a header <code>ext4_xattr_ibody_header</code> that is 4 bytes long:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>h_magic</td>
<td>Magic number for identification, 0xEA020000.  This value is set by the Linux driver, though e2fsprogs doesn't seem to check it(?)
</td></tr></tbody></table>
<p>The beginning of an extended attribute block is in <code>struct ext4_xattr_header</code>, which is 32 bytes long:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>h_magic</td>
<td>Magic number for identification, 0xEA020000.
</td></tr>
<tr>
<td>0x4</td>
<td>__le32</td>
<td>h_refcount</td>
<td>Reference count.
</td></tr>
<tr>
<td>0x8</td>
<td>__le32</td>
<td>h_blocks</td>
<td>Number of disk blocks used.
</td></tr>
<tr>
<td>0xC</td>
<td>__le32</td>
<td>h_hash</td>
<td>Hash value of all attributes.
</td></tr>
<tr>
<td>0x10</td>
<td>__le32</td>
<td>h_checksum</td>
<td>Checksum of the extended attribute block.
</td></tr>
<tr>
<td>0x14</td>
<td>__u32</td>
<td>h_reserved[2]
</td></tr></tbody></table>
<p>The checksum is calculated against the FS UUID, the 64-bit block number of the extended attribute block, and the entire block (header + entries).
</p><p>Following the <code>struct ext4_xattr_header</code> or <code>struct ext4_xattr_ibody_header</code> is an array of <code>struct ext4_xattr_entry</code>; each of these entries is at least 16 bytes long.  When stored in an external block, the <code>struct ext4_xattr_entry</code> entries must be stored in sorted order.  The sort order is <code>e_name_index</code>, then <code>e_name_len</code>, and finally <code>e_name</code>.  Attributes stored inside an inode do not need be stored in sorted order.
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__u8</td>
<td>e_name_len</td>
<td>Length of name.
</td></tr>
<tr>
<td>0x1</td>
<td>__u8</td>
<td>e_name_index</td>
<td>Attribute name index.  There is a discussion of this below.
</td></tr>
<tr>
<td>0x2</td>
<td>__le16</td>
<td>e_value_offs</td>
<td>Location of this attribute's value on the disk block where it is stored.  Multiple attributes can share the same value.  For an inode attribute this value is relative to the start of the first entry; for a block this value is relative to the start of the block (i.e. the header).
</td></tr>
<tr>
<td>0x4</td>
<td>__le32</td>
<td>e_value_inum</td>
<td>The inode where the value is stored.  Zero indicates the value is in the same block as this entry.  This field is only used if the INCOMPAT_EA_INODE feature is enabled.
</td></tr>
<tr>
<td>0x8</td>
<td>__le32</td>
<td>e_value_size</td>
<td>Length of attribute value.
</td></tr>
<tr>
<td>0xC</td>
<td>__le32</td>
<td>e_hash</td>
<td>Hash value of attribute name and attribute value.  The kernel doesn't update the hash for in-inode attributes, so for that case this value must be zero, because e2fsck validates any non-zero hash regardless of where the xattr lives.
</td></tr>
<tr>
<td>0x10</td>
<td>char</td>
<td>e_name[e_name_len]</td>
<td>Attribute name.  Does not include trailing NULL.
</td></tr></tbody></table>
<p>Attribute values can follow the end of the entry table.  There appears to be a requirement that they be aligned to 4-byte boundaries.  The values are stored starting at the end of the block and grow towards the xattr_header/xattr_entry table.  When the two collide, the overflow is put into a separate disk block.  If the disk block fills up, the filesystem returns -ENOSPC.
</p><p>The first four fields of the <code>ext4_xattr_entry</code> are set to zero to mark the end of the key list.
</p>
<h3> <span id="Attribute_Name_Indices"> Attribute Name Indices </span></h3>
<p>Logically speaking, extended attributes are a series of key=value pairs.  The keys are assumed to be NULL-terminated strings.  To reduce the amount of on-disk space that the keys consume, the beginning of the key string is matched against the attribute name index.  If a match is found, the attribute name index field is set, and matching string is removed from the key name.  Here is a map of name index values to key prefixes:
</p>
<table>
<tbody><tr>
<th>Name Index</th>
<th>Key Prefix
</th></tr>
<tr>
<td>0</td>
<td>(no prefix)
</td></tr>
<tr>
<td>1</td>
<td>"user."
</td></tr>
<tr>
<td>2</td>
<td>"system.posix_acl_access"
</td></tr>
<tr>
<td>3</td>
<td>"system.posix_acl_default"
</td></tr>
<tr>
<td>4</td>
<td>"trusted."
</td></tr>
<tr>
<td>6</td>
<td>"security."
</td></tr>
<tr>
<td>7</td>
<td>"system." (inline_data only?)
</td></tr>
<tr>
<td>8</td>
<td>"system.richacl" (SuSE kernels only?)
</td></tr></tbody></table>
<p>For example, if the attribute key is "user.fubar", the attribute name index is set to 1 and the "fubar" name is recorded on disk.
</p>
<h3> <span id="POSIX_ACLs"> POSIX ACLs </span></h3>
<p>POSIX ACLs are stored in a reduced version of the Linux kernel (and libacl's) internal ACL format.  The key difference is that the version number is different (1) and the <code>e_id</code> field is only stored for named user and group ACLs.
</p>

<p>Multiple mount protection (MMP) is a feature that protects the filesystem against multiple hosts trying to use the filesystem simultaneously.  When a filesystem is opened (for mounting, or fsck, etc.), the MMP code running on the node (call it node A) checks a sequence number.  If the sequence number is EXT4_MMP_SEQ_CLEAN, the open continues.  If the sequence number is EXT4_MMP_SEQ_FSCK, then fsck is (hopefully) running, and open fails immediately.  Otherwise, the open code will wait for twice the specified MMP check interval and check the sequence number again.  If the sequence number has changed, then the filesystem is active on another machine and the open fails.  If the MMP code passes all of those checks, a new MMP sequence number is generated and written to the MMP block, and the mount proceeds.
</p><p>While the filesystem is live, the kernel sets up a timer to re-check the MMP block at the specified MMP check interval.  To perform the re-check, the MMP sequence number is re-read; if it does not match the in-memory MMP sequence number, then another node (node B) has mounted the filesystem, and node A remounts the filesystem read-only.  If the sequence numbers match, the sequence number is incremented both in memory and on disk, and the re-check is complete.
</p><p>The hostname and device filename are written into the MMP block whenever an open operation succeeds.  The MMP code does not use these values; they are provided purely for informational purposes.
</p><p>The checksum is calculated against the FS UUID and the MMP structure.  The MMP structure (<code>struct mmp_struct</code>) is as follows:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__le32</td>
<td>mmp_magic</td>
<td>Magic number for MMP, 0x004D4D50 ("MMP").
</td></tr>
<tr>
<td>0x4</td>
<td>__le32</td>
<td>mmp_seq</td>
<td>Sequence number, updated periodically.
</td></tr>
<tr>
<td>0x8</td>
<td>__le64</td>
<td>mmp_time</td>
<td>Time that the MMP block was last updated.
</td></tr>
<tr>
<td>0x10</td>
<td>char[64]</td>
<td>mmp_nodename</td>
<td>Hostname of the node that opened the filesystem.
</td></tr>
<tr>
<td>0x50</td>
<td>char[32]</td>
<td>mmp_bdevname</td>
<td>Block device name of the filesystem.
</td></tr>
<tr>
<td>0x70</td>
<td>__le16</td>
<td>mmp_check_interval</td>
<td>The MMP re-check interval, in seconds.
</td></tr>
<tr>
<td>0x72</td>
<td>__le16</td>
<td>mmp_pad1
</td></tr>
<tr>
<td>0x74</td>
<td>__le32[226]</td>
<td>mmp_pad2
</td></tr>
<tr>
<td>0x3FC</td>
<td>__le32</td>
<td>mmp_checksum</td>
<td>Checksum of the MMP block.
</td></tr></tbody></table>

<p>Introduced in ext3, the ext4 filesystem employs a journal to protect the filesystem against corruption in the case of a system crash.  A small continuous region of disk (default 128MiB) is reserved inside the filesystem as a place to land "important" data writes on-disk as quickly as possible.  Once the important data transaction is fully written to the disk and flushed from the disk write cache, a record of the data being committed is also written to the journal.  At some later point in time, the journal code writes the transactions to their final locations on disk (this could involve a lot of seeking or a lot of small read-write-erases) before erasing the commit record.  Should the system crash during the second slow write, the journal can be replayed all the way to the latest commit record, guaranteeing the atomicity of whatever gets written through the journal to the disk.  The effect of this is to guarantee that the filesystem does not become stuck midway through a metadata update.
</p><p>For performance reasons, ext4 by default only writes filesystem metadata through the journal.  This means that file data blocks are /not/ guaranteed to be in any consistent state after a crash.  If this default guarantee level (<code>data=ordered</code>) is not satisfactory, there is a mount option to control journal behavior.  If <code>data=journal</code>, all data and metadata are written to disk through the journal.  This is slower but safest.  If <code>data=writeback</code>, dirty data blocks are not flushed to the disk before the metadata are written to disk through the journal.
</p><p>The journal inode is typically inode 8.  The first 68 bytes of the journal inode are replicated in the ext4 superblock.  The journal itself is normal (but hidden) file within the filesystem.  The file usually consumes an entire block group, though mke2fs tries to put it in the middle of the disk.
</p><p>All fields in jbd2 are written to disk in big-endian order.  This is the opposite of ext4.
</p><p>NOTE: Both ext4 and ocfs2 use jbd2.
</p><p>The maximum size of a journal embedded in an ext4 filesystem is 2^32 blocks.  jbd2 itself does not seem to care.
</p>
<h2> <span id="Layout_2"> Layout </span></h2>
<p>Generally speaking, the journal has this format:
</p>
<table>
<tbody><tr>
<td>Superblock</td>
<td>descriptor_block (data_blocks or revocation_block) [more data or revocations] commmit_block</td>
<td>[more transactions...]
</td></tr>
<tr>
<td></td>
<td> One transaction</td>
<td>
</td></tr></tbody></table>
<p>Notice that a transaction begins with either a descriptor and some data, or a block revocation list.  A finished transaction always ends with a commit.  If there is no commit record (or the checksums don't match), the transaction will be discarded during replay.
</p>
<h2> <span id="External_Journal"> External Journal </span></h2>
<p>Optionally, an ext4 filesystem can be created with an external journal device (as opposed to an internal journal, which uses a reserved inode).  In this case, on the filesystem device, <code>s_journal_inum</code> should be zero and <code>s_journal_uuid</code> should be set.  On the journal device there will be an ext4 super block in the usual place, with a matching UUID.  The journal superblock will be in the next full block after the superblock.
</p>
<table>
<tbody><tr>
<td>1024 bytes of padding</td>
<td>ext4 Superblock</td>
<td>Journal Superblock</td>
<td>descriptor_block (data_blocks or revocation_block) [more data or revocations] commmit_block</td>
<td>[more transactions...]
</td></tr>
<tr>
<td></td>
<td></td>
<td></td>
<td> One transaction</td>
<td>
</td></tr></tbody></table>
<h2> </h2>
<p>Every block in the journal starts with a common 12-byte header <code>struct journal_header_s</code>:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__be32</td>
<td>h_magic</td>
<td>jbd2 magic number, 0xC03B3998.
</td></tr>
<tr>
<td>0x4</td>
<td>__be32</td>
<td>h_blocktype</td>
<td>Description of what this block contains.  One of:
<table>
<tbody><tr>
<td>1</td>
<td>Descriptor.  This block precedes a series of data blocks that were written through the journal during a transaction.
</td></tr>
<tr>
<td>2</td>
<td>Block commit record.  This block signifies the completion of a transaction.
</td></tr>
<tr>
<td>3</td>
<td>Journal superblock, v1.
</td></tr>
<tr>
<td>4</td>
<td>Journal superblock, v2.
</td></tr>
<tr>
<td>5</td>
<td>Block revocation records.  This speeds up recovery by enabling the journal to skip writing blocks that were subsequently rewritten.
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x8</td>
<td>__be32</td>
<td>h_sequence</td>
<td>The transaction ID that goes with this block.
</td></tr></tbody></table>
<h2> <span id="Super_Block"> Super Block </span></h2>
<p>The super block for the journal is much simpler as compared to ext4's.  The key data kept within are size of the journal, and where to find the start of the log of transactions.
</p><p>The journal superblock is recorded as <code>struct journal_superblock_s</code>, which is 1024 bytes long:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>journal_header_t (12 bytes)</td>
<td>s_header</td>
<td>Common header identifying this as a superblock.
</td></tr>
<tr>
<td colspan="4">Static information describing the journal.
</td></tr>
<tr>
<td>0xC</td>
<td>__be32</td>
<td>s_blocksize</td>
<td>Journal device block size.
</td></tr>
<tr>
<td>0x10</td>
<td>__be32</td>
<td>s_maxlen</td>
<td>Total number of blocks in this journal.
</td></tr>
<tr>
<td>0x14</td>
<td>__be32</td>
<td>s_first</td>
<td>First block of log information.
</td></tr>
<tr>
<td colspan="4">Dynamic information describing the current state of the log.
</td></tr>
<tr>
<td>0x18</td>
<td>__be32</td>
<td>s_sequence</td>
<td>First commit ID expected in log.
</td></tr>
<tr>
<td>0x1C</td>
<td>__be32</td>
<td>s_start</td>
<td>Block number of the start of log.  Contrary to the comments, this field being zero does not imply that the journal is clean!
</td></tr>
<tr>
<td>0x20</td>
<td>__be32</td>
<td>s_errno</td>
<td>Error value, as set by jbd2_journal_abort().
</td></tr>
<tr>
<td colspan="4">The remaining fields are only valid in a version 2 superblock.
</td></tr>
<tr>
<td>0x24</td>
<td>__be32</td>
<td>s_feature_compat;</td>
<td>Compatible feature set.  Any of:
<table>
<tbody><tr>
<td>0x1</td>
<td>Journal maintains checksums on the data blocks. (JBD2_FEATURE_COMPAT_CHECKSUM)
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x28</td>
<td>__be32</td>
<td>s_feature_incompat</td>
<td>Incompatible feature set.  Any of:
<table>
<tbody><tr>
<td>0x1</td>
<td>Journal has block revocation records. (JBD2_FEATURE_INCOMPAT_REVOKE)
</td></tr>
<tr>
<td>0x2</td>
<td>Journal can deal with 64-bit block numbers. (JBD2_FEATURE_INCOMPAT_64BIT)
</td></tr>
<tr>
<td>0x4</td>
<td>Journal commits asynchronously. (JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)
</td></tr>
<tr>
<td>0x8</td>
<td>This journal uses v2 of the checksum on-disk format.  Each journal metadata block gets its own checksum, and the block tags in the descriptor table contain checksums for each of the data blocks in the journal. (JBD2_FEATURE_INCOMPAT_CSUM_V2)
</td></tr>
<tr>
<td>0x10</td>
<td>This journal uses v3 of the checksum on-disk format.  This is the same as v2, but the journal block tag size is fixed regardless of the size of block numbers. (JBD2_FEATURE_INCOMPAT_CSUM_V3)
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x2C</td>
<td>__be32</td>
<td>s_feature_ro_compat</td>
<td>Read-only compatible feature set.  There aren't any of these currently.
</td></tr>
<tr>
<td>0x30</td>
<td>__u8</td>
<td>s_uuid[16]</td>
<td>128-bit uuid for journal.  This is compared against the copy in the ext4 super block at mount time.
</td></tr>
<tr>
<td>0x40</td>
<td>__be32</td>
<td>s_nr_users</td>
<td>Number of file systems sharing this journal.
</td></tr>
<tr>
<td>0x44</td>
<td>__be32</td>
<td>s_dynsuper</td>
<td>Location of dynamic super block copy. (Not used?)
</td></tr>
<tr>
<td>0x48</td>
<td>__be32</td>
<td>s_max_transaction</td>
<td>Limit of journal blocks per transaction.  (Not used?)
</td></tr>
<tr>
<td>0x4C</td>
<td>__be32</td>
<td>s_max_trans_data</td>
<td>Limit of data blocks per transaction.  (Not used?)
</td></tr>
<tr>
<td>0x50</td>
<td>__u8</td>
<td>s_checksum_type</td>
<td>Checksum algorithm used for the journal.  1 = crc32, 2 = md5, 3 = sha1, 4 = crc32c.  1 or 4 are the most likely choices.
</td></tr>
<tr>
<td>0x51</td>
<td>__u8[3]</td>
<td>s_padding2</td>
<td>
</td></tr>
<tr>
<td>0x54</td>
<td>__u32</td>
<td>s_padding[42]</td>
<td>
</td></tr>
<tr>
<td>0xFC</td>
<td>__be32</td>
<td>s_checksum</td>
<td>Checksum of the entire superblock, with this field set to zero.
</td></tr>
<tr>
<td>0x100</td>
<td>__u8</td>
<td>s_users[16*48]</td>
<td>ids of all file systems sharing the log.  e2fsprogs/Linux don't allow shared external journals, but I imagine Lustre (or ocfs2?), which use the jbd2 code, might.
</td></tr></tbody></table>
<h2> <span id="Descriptor_Block"> Descriptor Block </span></h2>
<p>The descriptor block contains an array of journal block tags that describe the final locations of the data blocks that follow in the journal.  Descriptor blocks are open-coded instead of being completely described by a data structure, but here is the block structure anyway.  Descriptor blocks consume at least 36 bytes, but use a full block:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Descriptor
</th></tr>
<tr>
<td>0x0</td>
<td>journal_header_t</td>
<td>(open coded)</td>
<td>Common block header.
</td></tr>
<tr>
<td>0xC</td>
<td>struct journal_block_tag_s</td>
<td>open coded array[]</td>
<td>Enough tags either to fill up the block or to describe all the data blocks that follow this descriptor block.
</td></tr></tbody></table>
<p>Journal block tags have any of the following formats, depending on which journal feature and block tag flags are set.
</p><p>If JBD2_FEATURE_INCOMPAT_CSUM_V3 is set, the journal block tag is defined as <code>struct journal_block_tag3_s</code>, which looks like the following.  The size is 16 or 32 bytes.
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Descriptor
</th></tr>
<tr>
<td>0x0</td>
<td>__be32</td>
<td>t_blocknr</td>
<td>Lower 32-bits of the location of where the corresponding data block should end up on disk.
</td></tr>
<tr>
<td>0x4</td>
<td>__be32</td>
<td>t_flags</td>
<td>Flags that go with the descriptor.  Any of:
<table>
<tbody><tr>
<td>0x1</td>
<td>On-disk block is escaped.  The first four bytes of the data block just happened to match the jbd2 magic number.
</td></tr>
<tr>
<td>0x2</td>
<td>This block has the same UUID as previous, therefore the UUID field is omitted.
</td></tr>
<tr>
<td>0x4</td>
<td>The data block was deleted by the transaction.  (Not used?)
</td></tr>
<tr>
<td>0x8</td>
<td>This is the last tag in this descriptor block.
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0x8</td>
<td>__be32</td>
<td>t_blocknr_high</td>
<td>Upper 32-bits of the location of where the corresponding data block should end up on disk.  This is zero if JBD2_FEATURE_INCOMPAT_64BIT is not enabled.
</td></tr>
<tr>
<td>0xC</td>
<td>__be32</td>
<td>t_checksum</td>
<td>Checksum of the journal UUID, the sequence number, and the data block.
</td></tr>
<tr>
<td colspan="4">This field appears to be open coded.  It always comes at the end of the tag, after <code>t_checksum</code>.  This field is not present if the "same UUID" flag is set.
</td></tr>
<tr>
<td>0x8 or 0xC</td>
<td>char</td>
<td>uuid[16]</td>
<td>A UUID to go with this tag.  This field appears to be copied from the <code>j_uuid</code> field in <code>struct journal_s</code>, but only tune2fs touches that field.
</td></tr></tbody></table>
<p>If JBD2_FEATURE_INCOMPAT_CSUM_V3 is NOT set, the journal block tag is defined as <code>struct journal_block_tag_s</code>, which looks like the following.  The size is 8, 12, 24, or 28 bytes:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Descriptor
</th></tr>
<tr>
<td>0x0</td>
<td>__be32</td>
<td>t_blocknr</td>
<td>Lower 32-bits of the location of where the corresponding data block should end up on disk.
</td></tr>
<tr>
<td>0x4</td>
<td>__be16</td>
<td>t_checksum</td>
<td>Checksum of the journal UUID, the sequence number, and the data block.  Note that only the lower 16 bits are stored.
</td></tr>
<tr>
<td>0x6</td>
<td>__be16</td>
<td>t_flags</td>
<td>Flags that go with the descriptor.  Any of:
<table>
<tbody><tr>
<td>0x1</td>
<td>On-disk block is escaped.  The first four bytes of the data block just happened to match the jbd2 magic number.
</td></tr>
<tr>
<td>0x2</td>
<td>This block has the same UUID as previous, therefore the UUID field is omitted.
</td></tr>
<tr>
<td>0x4</td>
<td>The data block was deleted by the transaction.  (Not used?)
</td></tr>
<tr>
<td>0x8</td>
<td>This is the last tag in this descriptor block.
</td></tr></tbody></table>
</td></tr>
<tr>
<td colspan="4">This next field is only present if the super block indicates support for 64-bit block numbers.
</td></tr>
<tr>
<td>0x8</td>
<td>__be32</td>
<td>t_blocknr_high</td>
<td>Upper 32-bits of the location of where the corresponding data block should end up on disk.
</td></tr>
<tr>
<td colspan="4">This field appears to be open coded.  It always comes at the end of the tag, after <code>t_flags</code> or <code>t_blocknr_high</code>.  This field is not present if the "same UUID" flag is set.
</td></tr>
<tr>
<td>0x8 or 0xC</td>
<td>char</td>
<td>uuid[16]</td>
<td>A UUID to go with this tag.  This field appears to be copied from the <code>j_uuid</code> field in <code>struct journal_s</code>, but only tune2fs touches that field.
</td></tr></tbody></table>
<p>If JBD2_FEATURE_INCOMPAT_CSUM_V2 or JBD2_FEATURE_INCOMPAT_CSUM_V3 are set, the end of the block is a <code>struct jbd2_journal_block_tail</code>, which looks like this:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Descriptor
</th></tr>
<tr>
<td>0x0</td>
<td>__be32</td>
<td>t_checksum</td>
<td>Checksum of the journal UUID + the descriptor block, with this field set to zero.
</td></tr></tbody></table>
<h2> <span id="Data_Block"> Data Block </span></h2>
<p>In general, the data blocks being written to disk through the journal are written verbatim into the journal file after the descriptor block.  However, if the first four bytes of the block match the jbd2 magic number then those four bytes are replaced with zeroes and the "escaped" flag is set in the descriptor block tag.
</p>
<h2> <span id="Revocation_Block"> Revocation Block </span></h2>
<p>A revocation block is used to prevent replay of a block in an earlier transaction.  This is used to mark blocks that were journalled at one time but are no longer journalled.  Typically this happens if a metadata block is freed and re-allocated as a file data block; in this case, a journal replay after the file block was written to disk will cause corruption.
</p><p><b>NOTE</b>: This mechanism is NOT used to express "this journal block is superseded by this other journal block", as the author (djwong) mistakenly thought.  Any block being added to a transaction will cause the removal of all existing revocation records for that block.
</p><p>Revocation blocks are described in <code>struct jbd2_journal_revoke_header_s</code>, are at least 16 bytes in length, but use a full block:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>journal_header_t</td>
<td>r_header</td>
<td>Common block header.
</td></tr>
<tr>
<td>0xC</td>
<td>__be32</td>
<td>r_count</td>
<td>Number of bytes used in this block.
</td></tr>
<tr>
<td>0x10</td>
<td>__be32 or __be64</td>
<td>blocks[0]</td>
<td>Blocks to revoke.
</td></tr></tbody></table>
<p>After r_count is a linear array of block numbers that are effectively revoked by this transaction.  The size of each block number is 8 bytes if the superblock advertises 64-bit block number support, or 4 bytes otherwise.
</p><p>If JBD2_FEATURE_INCOMPAT_CSUM_V2 or JBD2_FEATURE_INCOMPAT_CSUM_V3 are set, the end of the revocation block is a <code>struct jbd2_journal_revoke_tail</code>, which has this format:
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Description
</th></tr>
<tr>
<td>0x0</td>
<td>__be32</td>
<td>r_checksum</td>
<td>Checksum of the journal UUID + revocation block
</td></tr></tbody></table>
<h2> <span id="Commit_Block"> Commit Block </span></h2>
<p>The commit block is a sentry that indicates that a transaction has been completely written to the journal.  Once this commit block reaches the journal, the data stored with this transaction can be written to their final locations on disk.
</p><p>The commit block is described by <code>struct commit_header</code>, which is 32 bytes long (but uses a full block):
</p>
<table>
<tbody><tr>
<th>Offset</th>
<th>Type</th>
<th>Name</th>
<th>Descriptor
</th></tr>
<tr>
<td>0x0</td>
<td>journal_header_s</td>
<td>(open coded)</td>
<td>Common block header.
</td></tr>
<tr>
<td>0xC</td>
<td>unsigned char</td>
<td>h_chksum_type</td>
<td>The type of checksum to use to verify the integrity of the data blocks in the transaction.  One of:
<table>
<tbody><tr>
<td>1</td>
<td>CRC32
</td></tr>
<tr>
<td>2</td>
<td>MD5
</td></tr>
<tr>
<td>3</td>
<td>SHA1
</td></tr>
<tr>
<td>4</td>
<td>CRC32C
</td></tr></tbody></table>
</td></tr>
<tr>
<td>0xD</td>
<td>unsigned char</td>
<td>h_chksum_size</td>
<td>The number of bytes used by the checksum.  Most likely 4.
</td></tr>
<tr>
<td>0xE</td>
<td>unsigned char</td>
<td>h_padding[2]</td>
<td>
</td></tr>
<tr>
<td>0x10</td>
<td>__be32</td>
<td>h_chksum[JBD2_CHECKSUM_BYTES]</td>
<td>32 bytes of space to store checksums.  If JBD2_FEATURE_INCOMPAT_CSUM_V2 or JBD2_FEATURE_INCOMPAT_CSUM_V3 are set, the first <code>__be32</code> is the checksum of the journal UUID and the entire commit block, with this field zeroed.  If JBD2_FEATURE_COMPAT_CHECKSUM is set, the first <code>__be32</code> is the crc32 of all the blocks already written to the transaction.
</td></tr>
<tr>
<td>0x30</td>
<td>__be64</td>
<td>h_commit_sec</td>
<td>The time that the transaction was committed, in seconds since the epoch.
</td></tr>
<tr>
<td>0x38</td>
<td>__be32</td>
<td>h_commit_nsec</td>
<td>Nanoseconds component of the above timestamp.
</td></tr></tbody></table>

<p>New patchsets to track with regards to changes in on-disk formats (in no particular order):
</p>
<ul><li> Amir's ext4 snapshot work (dead as of Oct. 2013?)
</li></ul>

<p>Also see <a rel="nofollow" href="http://www.nongnu.org/ext2-doc/">http://www.nongnu.org/ext2-doc/</a> for quite a collection of information about ext2/3.
Here's another old reference: <a rel="nofollow" href="http://wiki.osdev.org/Ext2">http://wiki.osdev.org/Ext2</a>
</p>
<!-- 
NewPP limit report
Preprocessor node count: 179/1000000
Postâ€expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key korg_mediawiki_ext4:pcache:idhash:1422-0!*!0!!en!*!* and timestamp 20200216075643 -->
</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>