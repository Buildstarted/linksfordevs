<!DOCTYPE html>
<html lang="en">
<head>
    <title>
0xd4d/iced: x86/x64 disassembler, assembler, decoder, encoder -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>0xd4d/iced: x86/x64 disassembler, assembler, decoder, encoder</h1><div><div id="" class="markdown-body entry-content p-5"><h1><a id="user-content-iced---" class="anchor" aria-hidden="true" href="#iced---"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Iced <a href="https://www.nuget.org/packages/Iced/" rel="nofollow"><img src="https://camo.githubusercontent.com/7799648a23f75331edc894fd76de1ba20da30d72/68747470733a2f2f696d672e736869656c64732e696f2f6e756765742f762f496365642e737667" alt="NuGet" data-canonical-src="https://img.shields.io/nuget/v/Iced.svg"></a><a href="https://github.com/0xd4d/iced/actions"><img src="https://github.com/0xd4d/iced/workflows/GitHub%20CI/badge.svg" alt="GitHub builds"></a><a href="https://codecov.io/gh/0xd4d/iced" rel="nofollow"><img src="https://camo.githubusercontent.com/f65e0dbf9949cba9882bafe264b73831cde773e3/68747470733a2f2f636f6465636f762e696f2f67682f30786434642f696365642f6272616e63682f6d61737465722f67726170682f62616467652e737667" alt="codecov" data-canonical-src="https://codecov.io/gh/0xd4d/iced/branch/master/graph/badge.svg"></a></h1><p><a target="_blank" rel="noopener noreferrer" href="/0xd4d/iced/blob/master/logo.png"><img align="right" width="160px" height="160px" src="/0xd4d/iced/raw/master/logo.png"></a></p><p>Iced is a high performance x86 (16/32/64-bit) instruction decoder, disassembler and assembler written in C#. It can be used for static analysis of x86/x64 binaries, to rewrite code (eg. remove garbage instructions), to relocate code or as a disassembler.</p><ul><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>Supports all Intel and AMD instructions</li><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>High level <a href="#assemble-instructions">Assembler</a> providing a simple and lean syntax (e.g <code>asm.mov(eax, edx)</code>))</li><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji><a href="#disassemble-decode-and-format-instructions">Decoding</a> and disassembler support:
<ul><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>The decoder doesn't allocate any memory; the C# code is 2x-5x+ faster than other similar libraries written in C or C#</li><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>Small decoded instructions, only 32 bytes</li><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>The formatter supports masm, nasm, gas (AT&amp;T), Intel (XED) and there are many options to customize the output</li></ul></li><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>Encoding support:
<ul><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>The encoder can be used to re-encode decoded instructions at any address</li><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>The block encoder encodes a list of instructions and optimizes branches to short, near or 'long' (64-bit: 1 or more instructions)</li></ul></li><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>API to get instruction info, eg. read/written registers, memory and rflags bits; CPUID feature flag, flow control info, etc</li><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>All instructions are tested (decode, encode, format, instruction info)</li><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>Supports <code>.NET Standard 2.0/2.1+</code> and <code>.NET Framework 4.5+</code></li><li><g-emoji class="g-emoji" alias="heavy_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png">✔️</g-emoji>License: MIT</li></ul><h1><a id="user-content-classes" class="anchor" aria-hidden="true" href="#classes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Classes</h1><p>See below for some examples. All classes are in the <code>Iced.Intel</code> namespace.</p><p>Decoder:</p><ul><li><code>Decoder</code></li><li><code>Instruction</code> (and <code>Instruction.Create()</code> methods)</li><li><code>CodeReader</code><ul><li><code>ByteArrayCodeReader</code></li><li><code>StreamCodeReader</code></li></ul></li><li><code>InstructionList</code></li><li><code>ConstantOffsets</code></li><li><code>IcedFeatures.Initialize()</code></li></ul><p>Formatters:</p><ul><li><code>Formatter</code><ul><li><code>MasmFormatter</code></li><li><code>NasmFormatter</code></li><li><code>GasFormatter</code></li><li><code>IntelFormatter</code></li></ul></li><li><code>FormatterOptions</code></li><li><code>FormatterOutput</code></li><li><code>ISymbolResolver</code></li><li><code>IFormatterOptionsProvider</code></li></ul><p>Assembler:</p><ul><li><code>Assembler</code></li><li><code>Label</code></li><li><code>AssemblerRegisters</code> (use <code>using static</code> to have access directly to registers e.g <code>eax</code>, <code>rdi</code>, <code>xmm1</code>...)</li></ul><p>Encoder:</p><ul><li><code>Encoder</code></li><li><code>BlockEncoder</code></li><li><code>CodeWriter</code></li><li><code>ConstantOffsets</code></li><li><code>OpCodeInfo</code> (<code>Instruction.OpCode</code> and <code>Code.ToOpCode()</code>)</li></ul><p>Instruction info:</p><ul><li><code>InstructionInfo</code></li><li><code>InstructionInfoFactory</code></li><li><code>InstructionInfoExtensions</code></li><li><code>MemorySizeExtensions</code></li><li><code>RegisterExtensions</code></li></ul><h1><a id="user-content-how-tos" class="anchor" aria-hidden="true" href="#how-tos"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How-tos</h1><h2><a id="user-content-disassemble-decode-and-format-instructions" class="anchor" aria-hidden="true" href="#disassemble-decode-and-format-instructions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disassemble (decode and format instructions)</h2><div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span><span class="pl-en">System</span>;
<span class="pl-k">using</span><span class="pl-en">Iced</span>.<span class="pl-en">Intel</span>;

<span class="pl-k">static</span><span class="pl-k">class</span><span class="pl-en">HowTo_Disassemble</span> {
    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * This method produces the following output:</span><span class="pl-c">00007FFAC46ACDA4 48895C2410           mov       [rsp+10h],rbx</span><span class="pl-c">00007FFAC46ACDA9 4889742418           mov       [rsp+18h],rsi</span><span class="pl-c">00007FFAC46ACDAE 55                   push      rbp</span><span class="pl-c">00007FFAC46ACDAF 57                   push      rdi</span><span class="pl-c">00007FFAC46ACDB0 4156                 push      r14</span><span class="pl-c">00007FFAC46ACDB2 488DAC2400FFFFFF     lea       rbp,[rsp-100h]</span><span class="pl-c">00007FFAC46ACDBA 4881EC00020000       sub       rsp,200h</span><span class="pl-c">00007FFAC46ACDC1 488B0518570A00       mov       rax,[rel 7FFA`C475`24E0h]</span><span class="pl-c">00007FFAC46ACDC8 4833C4               xor       rax,rsp</span><span class="pl-c">00007FFAC46ACDCB 488985F0000000       mov       [rbp+0F0h],rax</span><span class="pl-c">00007FFAC46ACDD2 4C8B052F240A00       mov       r8,[rel 7FFA`C474`F208h]</span><span class="pl-c">00007FFAC46ACDD9 488D05787C0400       lea       rax,[rel 7FFA`C46F`4A58h]</span><span class="pl-c">00007FFAC46ACDE0 33FF                 xor       edi,edi</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Example</span>() {
        <span class="pl-c"><span class="pl-c">//</span> You can also pass in a hex string, eg. "90 91 929394", or you can use your own CodeReader</span><span class="pl-c"><span class="pl-c">//</span> reading data from a file or memory etc</span><span class="pl-k">var</span><span class="pl-smi">codeBytes</span><span class="pl-k">=</span><span class="pl-smi">exampleCode</span>;
        <span class="pl-k">var</span><span class="pl-smi">codeReader</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ByteArrayCodeReader</span>(<span class="pl-smi">codeBytes</span>);
        <span class="pl-k">var</span><span class="pl-smi">decoder</span><span class="pl-k">=</span><span class="pl-smi">Decoder</span>.<span class="pl-en">Create</span>(<span class="pl-smi">exampleCodeBitness</span>, <span class="pl-smi">codeReader</span>);
        <span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">=</span><span class="pl-smi">exampleCodeRIP</span>;
        <span class="pl-k">ulong</span><span class="pl-smi">endRip</span><span class="pl-k">=</span><span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">+</span> (<span class="pl-k">uint</span>)<span class="pl-smi">codeBytes</span>.<span class="pl-smi">Length</span>;

        <span class="pl-c"><span class="pl-c">//</span> This list is faster than List&lt;Instruction&gt; since it uses refs to the Instructions</span><span class="pl-c"><span class="pl-c">//</span> instead of copying them (each Instruction is 32 bytes in size). It has a ref indexer,</span><span class="pl-c"><span class="pl-c">//</span> and a ref iterator. Add() uses 'in' (ref readonly).</span><span class="pl-k">var</span><span class="pl-smi">instructions</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">InstructionList</span>();
        <span class="pl-k">while</span> (<span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">&lt;</span><span class="pl-smi">endRip</span>) {
            <span class="pl-c"><span class="pl-c">//</span> The method allocates an uninitialized element at the end of the list and</span><span class="pl-c"><span class="pl-c">//</span> returns a reference to it which is initialized by Decode().</span><span class="pl-smi">decoder</span>.<span class="pl-en">Decode</span>(<span class="pl-k">out</span><span class="pl-smi">instructions</span>.<span class="pl-en">AllocUninitializedElement</span>());
        }

        <span class="pl-c"><span class="pl-c">//</span> Formatters: Masm*, Nasm*, Gas* (AT&amp;T) and Intel* (XED)</span><span class="pl-k">var</span><span class="pl-smi">formatter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">NasmFormatter</span>();
        <span class="pl-smi">formatter</span>.<span class="pl-smi">Options</span>.<span class="pl-smi">DigitSeparator</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>`<span class="pl-pds">"</span></span>;
        <span class="pl-smi">formatter</span>.<span class="pl-smi">Options</span>.<span class="pl-smi">FirstOperandCharIndex</span><span class="pl-k">=</span><span class="pl-c1">10</span>;
        <span class="pl-k">var</span><span class="pl-smi">output</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StringOutput</span>();
        <span class="pl-c"><span class="pl-c">//</span> Use InstructionList's ref iterator (C# 7.3) to prevent copying 32 bytes every iteration</span><span class="pl-k">foreach</span> (<span class="pl-smi">ref</span><span class="pl-k">var</span><span class="pl-smi">instr</span><span class="pl-k">in</span><span class="pl-smi">instructions</span>) {
            <span class="pl-c"><span class="pl-c">//</span> Don't use instr.ToString(), it allocates more, uses masm syntax and default options</span><span class="pl-smi">formatter</span>.<span class="pl-en">Format</span>(<span class="pl-smi">instr</span>, <span class="pl-smi">output</span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">Write</span>(<span class="pl-smi">instr</span>.<span class="pl-smi">IP</span>.<span class="pl-en">ToString</span>(<span class="pl-s"><span class="pl-pds">"</span>X16<span class="pl-pds">"</span></span>));
            <span class="pl-smi">Console</span>.<span class="pl-en">Write</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
            <span class="pl-k">int</span><span class="pl-smi">instrLen</span><span class="pl-k">=</span><span class="pl-smi">instr</span>.<span class="pl-smi">Length</span>;
            <span class="pl-k">int</span><span class="pl-smi">byteBaseIndex</span><span class="pl-k">=</span> (<span class="pl-k">int</span>)(<span class="pl-smi">instr</span>.<span class="pl-smi">IP</span><span class="pl-k">-</span><span class="pl-smi">exampleCodeRIP</span>);
            <span class="pl-k">for</span> (<span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>; <span class="pl-smi">i</span><span class="pl-k">&lt;</span><span class="pl-smi">instrLen</span>; <span class="pl-smi">i</span><span class="pl-k">++</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">Write</span>(<span class="pl-smi">codeBytes</span>[<span class="pl-smi">byteBaseIndex</span><span class="pl-k">+</span><span class="pl-smi">i</span>].<span class="pl-en">ToString</span>(<span class="pl-s"><span class="pl-pds">"</span>X2<span class="pl-pds">"</span></span>));
            <span class="pl-k">int</span><span class="pl-smi">missingBytes</span><span class="pl-k">=</span><span class="pl-smi">HEXBYTES_COLUMN_BYTE_LENGTH</span><span class="pl-k">-</span><span class="pl-smi">instrLen</span>;
            <span class="pl-k">for</span> (<span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>; <span class="pl-smi">i</span><span class="pl-k">&lt;</span><span class="pl-smi">missingBytes</span>; <span class="pl-smi">i</span><span class="pl-k">++</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">Write</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">Write</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-smi">output</span>.<span class="pl-en">ToStringAndReset</span>());
        }
    }

    <span class="pl-k">const</span><span class="pl-k">int</span><span class="pl-smi">HEXBYTES_COLUMN_BYTE_LENGTH</span><span class="pl-k">=</span><span class="pl-c1">10</span>;
    <span class="pl-k">const</span><span class="pl-k">int</span><span class="pl-smi">exampleCodeBitness</span><span class="pl-k">=</span><span class="pl-c1">64</span>;
    <span class="pl-k">const</span><span class="pl-k">ulong</span><span class="pl-smi">exampleCodeRIP</span><span class="pl-k">=</span><span class="pl-c1">0x00007FFAC46ACDA4</span>;
    <span class="pl-k">static</span><span class="pl-k">readonly</span><span class="pl-k">byte</span>[] <span class="pl-smi">exampleCode</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">byte</span>[] {
        <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x5C</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x10</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x74</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x18</span>, <span class="pl-c1">0x55</span>, <span class="pl-c1">0x57</span>, <span class="pl-c1">0x41</span>, <span class="pl-c1">0x56</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8D</span>,
        <span class="pl-c1">0xAC</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x81</span>, <span class="pl-c1">0xEC</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x02</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8B</span>, <span class="pl-c1">0x05</span>,
        <span class="pl-c1">0x18</span>, <span class="pl-c1">0x57</span>, <span class="pl-c1">0x0A</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x33</span>, <span class="pl-c1">0xC4</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x85</span>, <span class="pl-c1">0xF0</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x4C</span>, <span class="pl-c1">0x8B</span>,
        <span class="pl-c1">0x05</span>, <span class="pl-c1">0x2F</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x0A</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8D</span>, <span class="pl-c1">0x05</span>, <span class="pl-c1">0x78</span>, <span class="pl-c1">0x7C</span>, <span class="pl-c1">0x04</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x33</span>, <span class="pl-c1">0xFF</span>
    };
}</pre></div><h2><a id="user-content-assemble-instructions" class="anchor" aria-hidden="true" href="#assemble-instructions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Assemble instructions</h2><div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span><span class="pl-en">System</span>;
<span class="pl-k">using</span><span class="pl-en">System</span>.<span class="pl-en">IO</span>;
<span class="pl-k">using</span><span class="pl-en">Iced</span>.<span class="pl-en">Intel</span>;
<span class="pl-k">using</span><span class="pl-k">static</span><span class="pl-k">Iced</span>.<span class="pl-k">Intel</span>.<span class="pl-en">AssemblerRegisters</span>;

<span class="pl-k">static</span><span class="pl-k">class</span><span class="pl-en">HowTo_Assemble</span> {
    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * This method produces the following output:</span><span class="pl-c">1234567810000000 = push r15</span><span class="pl-c">1234567810000002 = add rax,r15</span><span class="pl-c">1234567810000005 = mov rax,[rax]</span><span class="pl-c">1234567810000008 = mov rax,[rax]</span><span class="pl-c">123456781000000B = cmp dword ptr [rax+rcx*8+10h],0FFFFFFFFh</span><span class="pl-c">1234567810000010 = jne short 123456781000003Dh</span><span class="pl-c">1234567810000012 = inc rax</span><span class="pl-c">1234567810000015 = lea rcx,[1234567810000040h]</span><span class="pl-c">123456781000001C = rep stosd</span><span class="pl-c">123456781000001E = xacquire lock add qword ptr [rax+rcx],7Bh</span><span class="pl-c">1234567810000025 = vaddpd zmm1{k3}{z},zmm2,zmm3 {rz-sae}</span><span class="pl-c">123456781000002B = vunpcklps xmm2{k5}{z},xmm6,dword bcst [rax]</span><span class="pl-c">1234567810000031 = inc rax</span><span class="pl-c">1234567810000034 = je short 1234567810000031h</span><span class="pl-c">1234567810000036 = inc rcx</span><span class="pl-c">1234567810000039 = je short 123456781000003Ch</span><span class="pl-c">123456781000003B = nop</span><span class="pl-c">123456781000003C = nop</span><span class="pl-c">123456781000003D = pop r15</span><span class="pl-c">123456781000003F = ret</span><span class="pl-c">1234567810000040 = pause</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">MemoryStream</span><span class="pl-en">Example</span>() {
        <span class="pl-c"><span class="pl-c">//</span> The assembler supports all modes: 16-bit, 32-bit and 64-bit.</span><span class="pl-k">var</span><span class="pl-smi">c</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Assembler</span>(<span class="pl-c1">64</span>);

        <span class="pl-k">var</span><span class="pl-smi">label1</span><span class="pl-k">=</span><span class="pl-smi">c</span>.<span class="pl-en">CreateLabel</span>();
        <span class="pl-k">var</span><span class="pl-smi">data1</span><span class="pl-k">=</span><span class="pl-smi">c</span>.<span class="pl-en">CreateLabel</span>();

        <span class="pl-smi">c</span>.<span class="pl-en">push</span>(<span class="pl-smi">r15</span>);
        <span class="pl-smi">c</span>.<span class="pl-en">add</span>(<span class="pl-smi">rax</span>, <span class="pl-smi">r15</span>);

        <span class="pl-c"><span class="pl-c">//</span> If the memory operand can only have one size, __[] can be used. The assembler ignores</span><span class="pl-c"><span class="pl-c">//</span> the memory size unless it's an ambiguous instruction, eg. 'add [mem],123'</span><span class="pl-smi">c</span>.<span class="pl-en">mov</span>(<span class="pl-smi">rax</span>, <span class="pl-smi">__</span>[<span class="pl-smi">rax</span>]);
        <span class="pl-smi">c</span>.<span class="pl-en">mov</span>(<span class="pl-smi">rax</span>, <span class="pl-smi">__qword_ptr</span>[<span class="pl-smi">rax</span>]);

        <span class="pl-c"><span class="pl-c">//</span> The assembler must know the memory size to pick the correct instruction</span><span class="pl-smi">c</span>.<span class="pl-en">cmp</span>(<span class="pl-smi">__dword_ptr</span>[<span class="pl-smi">rax</span><span class="pl-k">+</span><span class="pl-smi">rcx</span><span class="pl-k">*</span><span class="pl-c1">8</span><span class="pl-k">+</span><span class="pl-c1">0x10</span>], <span class="pl-k">-</span><span class="pl-c1">1</span>);
        <span class="pl-smi">c</span>.<span class="pl-en">jne</span>(<span class="pl-smi">label1</span>); <span class="pl-c"><span class="pl-c">//</span> Jump to Label1</span><span class="pl-smi">c</span>.<span class="pl-en">inc</span>(<span class="pl-smi">rax</span>);

        <span class="pl-c"><span class="pl-c">//</span> Labels can be referenced by memory operands (64-bit only) and call/jmp/jcc/loopcc instructions</span><span class="pl-smi">c</span>.<span class="pl-en">lea</span>(<span class="pl-smi">rcx</span>, <span class="pl-smi">__</span>[<span class="pl-smi">data1</span>]);

        <span class="pl-c"><span class="pl-c">//</span> The assembler has prefix properties that will be added to the following instruction</span><span class="pl-smi">c</span>.<span class="pl-smi">rep</span>.<span class="pl-en">stosd</span>();
        <span class="pl-smi">c</span>.<span class="pl-smi">xacquire</span>.<span class="pl-smi">@lock</span>.<span class="pl-en">add</span>(<span class="pl-smi">__qword_ptr</span>[<span class="pl-smi">rax</span><span class="pl-k">+</span><span class="pl-smi">rcx</span>], <span class="pl-c1">123</span>);

        <span class="pl-c"><span class="pl-c">//</span> The assembler defaults to VEX instructions. If you need EVEX instructions, set PreferVex=false</span><span class="pl-smi">c</span>.<span class="pl-smi">PreferVex</span><span class="pl-k">=</span><span class="pl-c1">false</span>;
        <span class="pl-c"><span class="pl-c">//</span> AVX-512 decorators are properties on the memory and register operands</span><span class="pl-smi">c</span>.<span class="pl-en">vaddpd</span>(<span class="pl-smi">zmm1</span>.<span class="pl-smi">k3</span>.<span class="pl-smi">z</span>, <span class="pl-smi">zmm2</span>, <span class="pl-smi">zmm3</span>.<span class="pl-smi">rz_sae</span>);
        <span class="pl-c"><span class="pl-c">//</span> To broadcast memory, use the __dword_bcst/__qword_bcst memory types</span><span class="pl-smi">c</span>.<span class="pl-en">vunpcklps</span>(<span class="pl-smi">xmm2</span>.<span class="pl-smi">k5</span>.<span class="pl-smi">z</span>, <span class="pl-smi">xmm6</span>, <span class="pl-smi">__dword_bcst</span>[<span class="pl-smi">rax</span>]);

        <span class="pl-c"><span class="pl-c">//</span> You can create anonymous labels, just like in eg. masm, @@, @F and @B</span><span class="pl-smi">c</span>.<span class="pl-en">AnonymousLabel</span>(); <span class="pl-c"><span class="pl-c">//</span> same as @@: in masm</span><span class="pl-smi">c</span>.<span class="pl-en">inc</span>(<span class="pl-smi">rax</span>);
        <span class="pl-smi">c</span>.<span class="pl-en">je</span>(<span class="pl-smi">c</span>.<span class="pl-smi">@B</span>); <span class="pl-c"><span class="pl-c">//</span> reference the previous anonymous label</span><span class="pl-smi">c</span>.<span class="pl-en">inc</span>(<span class="pl-smi">rcx</span>);
        <span class="pl-smi">c</span>.<span class="pl-en">je</span>(<span class="pl-smi">c</span>.<span class="pl-smi">@F</span>); <span class="pl-c"><span class="pl-c">//</span> reference the next anonymous label</span><span class="pl-smi">c</span>.<span class="pl-en">nop</span>();
        <span class="pl-smi">c</span>.<span class="pl-en">AnonymousLabel</span>();
        <span class="pl-smi">c</span>.<span class="pl-en">nop</span>();

        <span class="pl-c"><span class="pl-c">//</span> Emit label1:</span><span class="pl-smi">c</span>.<span class="pl-en">Label</span>(<span class="pl-k">ref</span><span class="pl-smi">label1</span>);
        <span class="pl-smi">c</span>.<span class="pl-en">pop</span>(<span class="pl-smi">r15</span>);
        <span class="pl-smi">c</span>.<span class="pl-en">ret</span>();
        <span class="pl-smi">c</span>.<span class="pl-en">Label</span>(<span class="pl-k">ref</span><span class="pl-smi">data1</span>);
        <span class="pl-smi">c</span>.<span class="pl-en">db</span>(<span class="pl-c1">0xF3</span>, <span class="pl-c1">0x90</span>); <span class="pl-c"><span class="pl-c">//</span> pause</span><span class="pl-k">const</span><span class="pl-k">ulong</span><span class="pl-smi">RIP</span><span class="pl-k">=</span><span class="pl-c1">0x1234_5678_1000_0000</span>;
        <span class="pl-k">var</span><span class="pl-smi">stream</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">MemoryStream</span>();
        <span class="pl-smi">c</span>.<span class="pl-en">Assemble</span>(<span class="pl-k">new</span><span class="pl-en">StreamCodeWriter</span>(<span class="pl-smi">stream</span>), <span class="pl-smi">RIP</span>);

        <span class="pl-c"><span class="pl-c">//</span> Disassemble the result</span><span class="pl-smi">stream</span>.<span class="pl-smi">Position</span><span class="pl-k">=</span><span class="pl-c1">0</span>;
        <span class="pl-k">var</span><span class="pl-smi">reader</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StreamCodeReader</span>(<span class="pl-smi">stream</span>);
        <span class="pl-k">var</span><span class="pl-smi">decoder</span><span class="pl-k">=</span><span class="pl-smi">Decoder</span>.<span class="pl-en">Create</span>(<span class="pl-c1">64</span>, <span class="pl-smi">reader</span>);
        <span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">=</span><span class="pl-smi">RIP</span>;
        <span class="pl-k">while</span> (<span class="pl-smi">stream</span>.<span class="pl-smi">Position</span><span class="pl-k">&lt;</span><span class="pl-smi">stream</span>.<span class="pl-smi">Length</span>) {
            <span class="pl-smi">decoder</span>.<span class="pl-en">Decode</span>(<span class="pl-k">out</span><span class="pl-k">var</span><span class="pl-smi">instr</span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>{<span class="pl-smi">instr</span>.<span class="pl-smi">IP</span>:<span class="pl-smi">X</span>} = {<span class="pl-smi">instr</span>}<span class="pl-pds">"</span></span>);
        }

        <span class="pl-k">return</span><span class="pl-smi">stream</span>;
    }
}</pre></div><h2><a id="user-content-disassemble-with-a-symbol-resolver" class="anchor" aria-hidden="true" href="#disassemble-with-a-symbol-resolver"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disassemble with a symbol resolver</h2><div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span><span class="pl-en">System</span>;
<span class="pl-k">using</span><span class="pl-en">System</span>.<span class="pl-en">Collections</span>.<span class="pl-en">Generic</span>;
<span class="pl-k">using</span><span class="pl-en">Iced</span>.<span class="pl-en">Intel</span>;

<span class="pl-k">static</span><span class="pl-k">class</span><span class="pl-en">HowTo_SymbolResolver</span> {
    <span class="pl-k">sealed</span><span class="pl-k">class</span><span class="pl-en">SymbolResolver</span> : <span class="pl-en">ISymbolResolver</span> {
        <span class="pl-k">readonly</span><span class="pl-en">Dictionary</span>&lt;<span class="pl-k">ulong</span>, <span class="pl-k">string</span>&gt; <span class="pl-smi">symbolDict</span>;

        <span class="pl-k">public</span><span class="pl-en">SymbolResolver</span>(<span class="pl-en">Dictionary</span>&lt;<span class="pl-k">ulong</span>, <span class="pl-k">string</span>&gt; <span class="pl-smi">symbolDict</span>) {
            <span class="pl-k">this</span>.<span class="pl-smi">symbolDict</span><span class="pl-k">=</span><span class="pl-smi">symbolDict</span>;
        }

        <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryGetSymbol</span>(<span class="pl-k">in</span><span class="pl-en">Instruction</span><span class="pl-smi">instruction</span>, <span class="pl-k">int</span><span class="pl-smi">operand</span>, <span class="pl-k">int</span><span class="pl-smi">instructionOperand</span>,
            <span class="pl-k">ulong</span><span class="pl-smi">address</span>, <span class="pl-k">int</span><span class="pl-smi">addressSize</span>, <span class="pl-k">out</span><span class="pl-en">SymbolResult</span><span class="pl-smi">symbol</span>) {
            <span class="pl-k">if</span> (<span class="pl-smi">symbolDict</span>.<span class="pl-en">TryGetValue</span>(<span class="pl-smi">address</span>, <span class="pl-k">out</span><span class="pl-k">var</span><span class="pl-smi">symbolText</span>)) {
                <span class="pl-c"><span class="pl-c">//</span> The 'address' arg is the address of the symbol and doesn't have to be identical</span><span class="pl-c"><span class="pl-c">//</span> to the 'address' arg passed to TryGetSymbol(). If it's different from the input</span><span class="pl-c"><span class="pl-c">//</span> address, the formatter will add +N or -N, eg. '[rax+symbol+123]'</span><span class="pl-smi">symbol</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">SymbolResult</span>(<span class="pl-smi">address</span>, <span class="pl-smi">symbolText</span>);
                <span class="pl-k">return</span><span class="pl-c1">true</span>;
            }
            <span class="pl-smi">symbol</span><span class="pl-k">=</span><span class="pl-smi">default</span>;
            <span class="pl-k">return</span><span class="pl-c1">false</span>;
        }
    }

    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Example</span>() {
        <span class="pl-k">var</span><span class="pl-smi">symbols</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Dictionary</span>&lt;<span class="pl-k">ulong</span>, <span class="pl-k">string</span>&gt; {
            { <span class="pl-c1">0x5AA55AA5UL</span>, <span class="pl-s"><span class="pl-pds">"</span>my_data<span class="pl-pds">"</span></span> },
        };
        <span class="pl-k">var</span><span class="pl-smi">symbolResolver</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">SymbolResolver</span>(<span class="pl-smi">symbols</span>);
        <span class="pl-k">var</span><span class="pl-smi">decoder</span><span class="pl-k">=</span><span class="pl-smi">Decoder</span>.<span class="pl-en">Create</span>(<span class="pl-c1">64</span>, <span class="pl-k">new</span><span class="pl-en">ByteArrayCodeReader</span>(<span class="pl-s"><span class="pl-pds">"</span>488B8AA55AA55A<span class="pl-pds">"</span></span>));
        <span class="pl-smi">decoder</span>.<span class="pl-en">Decode</span>(<span class="pl-k">out</span><span class="pl-k">var</span><span class="pl-smi">instr</span>);

        <span class="pl-k">var</span><span class="pl-smi">formatter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">GasFormatter</span>(<span class="pl-smi">symbolResolver</span>);
        <span class="pl-k">var</span><span class="pl-smi">output</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StringOutput</span>();
        <span class="pl-smi">formatter</span>.<span class="pl-en">Format</span>(<span class="pl-smi">instr</span>, <span class="pl-smi">output</span>);
        <span class="pl-c"><span class="pl-c">//</span> Prints: mov my_data(%rdx),%rcx</span><span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-smi">output</span>.<span class="pl-en">ToStringAndReset</span>());
    }
}</pre></div><h2><a id="user-content-disassemble-with-colorized-text" class="anchor" aria-hidden="true" href="#disassemble-with-colorized-text"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disassemble with colorized text</h2><div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span><span class="pl-en">System</span>;
<span class="pl-k">using</span><span class="pl-en">System</span>.<span class="pl-en">Collections</span>.<span class="pl-en">Generic</span>;
<span class="pl-k">using</span><span class="pl-en">Iced</span>.<span class="pl-en">Intel</span>;

<span class="pl-k">static</span><span class="pl-k">class</span><span class="pl-en">HowTo_ColorizedText</span> {
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Example</span>() {
        <span class="pl-k">var</span><span class="pl-smi">codeReader</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ByteArrayCodeReader</span>(<span class="pl-smi">exampleCode</span>);
        <span class="pl-k">var</span><span class="pl-smi">decoder</span><span class="pl-k">=</span><span class="pl-smi">Decoder</span>.<span class="pl-en">Create</span>(<span class="pl-smi">exampleCodeBitness</span>, <span class="pl-smi">codeReader</span>);
        <span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">=</span><span class="pl-smi">exampleCodeRIP</span>;

        <span class="pl-k">var</span><span class="pl-smi">formatter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">MasmFormatter</span>();
        <span class="pl-k">var</span><span class="pl-smi">output</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">FormatterOutputImpl</span>();
        <span class="pl-k">while</span> (<span class="pl-smi">codeReader</span>.<span class="pl-smi">CanReadByte</span>) {
            <span class="pl-smi">decoder</span>.<span class="pl-en">Decode</span>(<span class="pl-k">out</span><span class="pl-k">var</span><span class="pl-smi">instr</span>);
            <span class="pl-smi">output</span>.<span class="pl-smi">List</span>.<span class="pl-en">Clear</span>();
            <span class="pl-smi">formatter</span>.<span class="pl-en">Format</span>(<span class="pl-smi">instr</span>, <span class="pl-smi">output</span>);
            <span class="pl-k">foreach</span> (<span class="pl-k">var</span> (<span class="pl-en">text</span>, <span class="pl-en">kind</span>) <span class="pl-k">in</span><span class="pl-smi">output</span>.<span class="pl-smi">List</span>) {
                <span class="pl-smi">Console</span>.<span class="pl-smi">ForegroundColor</span><span class="pl-k">=</span><span class="pl-en">GetColor</span>(<span class="pl-smi">kind</span>);
                <span class="pl-smi">Console</span>.<span class="pl-en">Write</span>(<span class="pl-smi">text</span>);
            }
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>();
        }
        <span class="pl-smi">Console</span>.<span class="pl-en">ResetColor</span>();
    }

    <span class="pl-k">sealed</span><span class="pl-k">class</span><span class="pl-en">FormatterOutputImpl</span> : <span class="pl-en">FormatterOutput</span> {
        <span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-en">List</span>&lt;(<span class="pl-k">string</span><span class="pl-en">text</span>, <span class="pl-en">FormatterTextKind</span><span class="pl-en">kind</span>)&gt; <span class="pl-smi">List</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">List</span>&lt;(<span class="pl-k">string</span><span class="pl-en">text</span>, <span class="pl-en">FormatterTextKind</span><span class="pl-en">kind</span>)&gt;();
        <span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">void</span><span class="pl-en">Write</span>(<span class="pl-k">string</span><span class="pl-smi">text</span>, <span class="pl-en">FormatterTextKind</span><span class="pl-smi">kind</span>) <span class="pl-k">=&gt;</span><span class="pl-smi">List</span>.<span class="pl-en">Add</span>((<span class="pl-smi">text</span>, <span class="pl-smi">kind</span>));
    }

    <span class="pl-k">static</span><span class="pl-en">ConsoleColor</span><span class="pl-en">GetColor</span>(<span class="pl-en">FormatterTextKind</span><span class="pl-smi">kind</span>) {
        <span class="pl-k">switch</span> (<span class="pl-smi">kind</span>) {
        <span class="pl-k">case</span><span class="pl-smi">FormatterTextKind</span>.<span class="pl-smi">Directive</span>:
        <span class="pl-k">case</span><span class="pl-smi">FormatterTextKind</span>.<span class="pl-smi">Keyword</span>:
            <span class="pl-k">return</span><span class="pl-smi">ConsoleColor</span>.<span class="pl-smi">Yellow</span>;

        <span class="pl-k">case</span><span class="pl-smi">FormatterTextKind</span>.<span class="pl-smi">Prefix</span>:
        <span class="pl-k">case</span><span class="pl-smi">FormatterTextKind</span>.<span class="pl-smi">Mnemonic</span>:
            <span class="pl-k">return</span><span class="pl-smi">ConsoleColor</span>.<span class="pl-smi">Red</span>;

        <span class="pl-k">case</span><span class="pl-smi">FormatterTextKind</span>.<span class="pl-smi">Register</span>:
            <span class="pl-k">return</span><span class="pl-smi">ConsoleColor</span>.<span class="pl-smi">Magenta</span>;

        <span class="pl-k">case</span><span class="pl-smi">FormatterTextKind</span>.<span class="pl-smi">Number</span>:
            <span class="pl-k">return</span><span class="pl-smi">ConsoleColor</span>.<span class="pl-smi">Green</span>;

        <span class="pl-k">default</span>:
            <span class="pl-k">return</span><span class="pl-smi">ConsoleColor</span>.<span class="pl-smi">White</span>;
        }
    }

    <span class="pl-k">const</span><span class="pl-k">int</span><span class="pl-smi">exampleCodeBitness</span><span class="pl-k">=</span><span class="pl-c1">64</span>;
    <span class="pl-k">const</span><span class="pl-k">ulong</span><span class="pl-smi">exampleCodeRIP</span><span class="pl-k">=</span><span class="pl-c1">0x00007FFAC46ACDA4</span>;
    <span class="pl-k">static</span><span class="pl-k">readonly</span><span class="pl-k">byte</span>[] <span class="pl-smi">exampleCode</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">byte</span>[] {
        <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x5C</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x10</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x74</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x18</span>, <span class="pl-c1">0x55</span>, <span class="pl-c1">0x57</span>, <span class="pl-c1">0x41</span>, <span class="pl-c1">0x56</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8D</span>,
        <span class="pl-c1">0xAC</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x81</span>, <span class="pl-c1">0xEC</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x02</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8B</span>, <span class="pl-c1">0x05</span>,
        <span class="pl-c1">0x18</span>, <span class="pl-c1">0x57</span>, <span class="pl-c1">0x0A</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x33</span>, <span class="pl-c1">0xC4</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x85</span>, <span class="pl-c1">0xF0</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x4C</span>, <span class="pl-c1">0x8B</span>,
        <span class="pl-c1">0x05</span>, <span class="pl-c1">0x2F</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x0A</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8D</span>, <span class="pl-c1">0x05</span>, <span class="pl-c1">0x78</span>, <span class="pl-c1">0x7C</span>, <span class="pl-c1">0x04</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x33</span>, <span class="pl-c1">0xFF</span>
    };
}</pre></div><h2><a id="user-content-move-code-in-memory-eg-hook-a-function" class="anchor" aria-hidden="true" href="#move-code-in-memory-eg-hook-a-function"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Move code in memory (eg. hook a function)</h2><div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span><span class="pl-en">System</span>;
<span class="pl-k">using</span><span class="pl-en">System</span>.<span class="pl-en">Collections</span>.<span class="pl-en">Generic</span>;
<span class="pl-k">using</span><span class="pl-en">System</span>.<span class="pl-en">Diagnostics</span>;
<span class="pl-k">using</span><span class="pl-en">Iced</span>.<span class="pl-en">Intel</span>;

<span class="pl-k">static</span><span class="pl-k">class</span><span class="pl-en">HowTo_MoveCode</span> {
    <span class="pl-c"><span class="pl-c">//</span> Decodes instructions from some address, then encodes them starting at some</span><span class="pl-c"><span class="pl-c">//</span> other address. This can be used to hook a function. You decode enough instructions</span><span class="pl-c"><span class="pl-c">//</span> until you have enough bytes to add a JMP instruction that jumps to your code.</span><span class="pl-c"><span class="pl-c">//</span> Your code will then conditionally jump to the original code that you re-encoded.</span><span class="pl-c"><span class="pl-c">//</span></span><span class="pl-c"><span class="pl-c">//</span> This code uses the BlockEncoder which will help with some things, eg. converting</span><span class="pl-c"><span class="pl-c">//</span> short branches to longer branches if the target is too far away.</span><span class="pl-c"><span class="pl-c">//</span></span><span class="pl-c"><span class="pl-c">//</span> 64-bit mode also supports RIP relative addressing, but the encoder can't rewrite</span><span class="pl-c"><span class="pl-c">//</span> those to use a longer displacement. If any of the moved instructions have RIP</span><span class="pl-c"><span class="pl-c">//</span> relative addressing and it tries to access data too far away, the encoder will fail.</span><span class="pl-c"><span class="pl-c">//</span> The easiest solution is to use OS alloc functions that allocate memory close to the</span><span class="pl-c"><span class="pl-c">//</span> original code (+/-2GB).</span><span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * This method produces the following output:</span><span class="pl-c">Original code:</span><span class="pl-c">00007FFAC46ACDA4 mov [rsp+10h],rbx</span><span class="pl-c">00007FFAC46ACDA9 mov [rsp+18h],rsi</span><span class="pl-c">00007FFAC46ACDAE push rbp</span><span class="pl-c">00007FFAC46ACDAF push rdi</span><span class="pl-c">00007FFAC46ACDB0 push r14</span><span class="pl-c">00007FFAC46ACDB2 lea rbp,[rsp-100h]</span><span class="pl-c">00007FFAC46ACDBA sub rsp,200h</span><span class="pl-c">00007FFAC46ACDC1 mov rax,[rel 7FFAC47524E0h]</span><span class="pl-c">00007FFAC46ACDC8 xor rax,rsp</span><span class="pl-c">00007FFAC46ACDCB mov [rbp+0F0h],rax</span><span class="pl-c">00007FFAC46ACDD2 mov r8,[rel 7FFAC474F208h]</span><span class="pl-c">00007FFAC46ACDD9 lea rax,[rel 7FFAC46F4A58h]</span><span class="pl-c">00007FFAC46ACDE0 xor edi,edi</span><span class="pl-c"></span><span class="pl-c">Original + patched code:</span><span class="pl-c">00007FFAC46ACDA4 mov rax,123456789ABCDEF0h</span><span class="pl-c">00007FFAC46ACDAE jmp rax</span><span class="pl-c">00007FFAC46ACDB0 push r14</span><span class="pl-c">00007FFAC46ACDB2 lea rbp,[rsp-100h]</span><span class="pl-c">00007FFAC46ACDBA sub rsp,200h</span><span class="pl-c">00007FFAC46ACDC1 mov rax,[rel 7FFAC47524E0h]</span><span class="pl-c">00007FFAC46ACDC8 xor rax,rsp</span><span class="pl-c">00007FFAC46ACDCB mov [rbp+0F0h],rax</span><span class="pl-c">00007FFAC46ACDD2 mov r8,[rel 7FFAC474F208h]</span><span class="pl-c">00007FFAC46ACDD9 lea rax,[rel 7FFAC46F4A58h]</span><span class="pl-c">00007FFAC46ACDE0 xor edi,edi</span><span class="pl-c"></span><span class="pl-c">Moved code:</span><span class="pl-c">00007FFAC48ACDA4 mov [rsp+10h],rbx</span><span class="pl-c">00007FFAC48ACDA9 mov [rsp+18h],rsi</span><span class="pl-c">00007FFAC48ACDAE push rbp</span><span class="pl-c">00007FFAC48ACDAF push rdi</span><span class="pl-c">00007FFAC48ACDB0 jmp 00007FFAC46ACDB0h</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Example</span>() {
        <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">"</span>Original code:<span class="pl-pds">"</span></span>);
        <span class="pl-en">Disassemble</span>(<span class="pl-smi">exampleCode</span>, <span class="pl-smi">exampleCodeRIP</span>);

        <span class="pl-k">var</span><span class="pl-smi">codeReader</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ByteArrayCodeReader</span>(<span class="pl-smi">exampleCode</span>);
        <span class="pl-k">var</span><span class="pl-smi">decoder</span><span class="pl-k">=</span><span class="pl-smi">Decoder</span>.<span class="pl-en">Create</span>(<span class="pl-smi">exampleCodeBitness</span>, <span class="pl-smi">codeReader</span>);
        <span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">=</span><span class="pl-smi">exampleCodeRIP</span>;

        <span class="pl-c"><span class="pl-c">//</span> In 64-bit mode, we need 12 bytes to jump to any address:</span><span class="pl-c"><span class="pl-c">//</span>      mov rax,imm64   // 10</span><span class="pl-c"><span class="pl-c">//</span>      jmp rax         // 2</span><span class="pl-c"><span class="pl-c">//</span> We overwrite rax because it's probably not used by the called function.</span><span class="pl-c"><span class="pl-c">//</span> In 32-bit mode, a normal JMP is just 5 bytes</span><span class="pl-k">const</span><span class="pl-k">uint</span><span class="pl-smi">requiredBytes</span><span class="pl-k">=</span><span class="pl-c1">10</span><span class="pl-k">+</span><span class="pl-c1">2</span>;
        <span class="pl-k">uint</span><span class="pl-smi">totalBytes</span><span class="pl-k">=</span><span class="pl-c1">0</span>;
        <span class="pl-k">var</span><span class="pl-smi">origInstructions</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">InstructionList</span>();
        <span class="pl-k">while</span> (<span class="pl-smi">codeReader</span>.<span class="pl-smi">CanReadByte</span>) {
            <span class="pl-smi">decoder</span>.<span class="pl-en">Decode</span>(<span class="pl-k">out</span><span class="pl-k">var</span><span class="pl-smi">instr</span>);
            <span class="pl-smi">origInstructions</span>.<span class="pl-en">Add</span>(<span class="pl-smi">instr</span>);
            <span class="pl-smi">totalBytes</span><span class="pl-k">+=</span> (<span class="pl-k">uint</span>)<span class="pl-smi">instr</span>.<span class="pl-smi">Length</span>;
            <span class="pl-k">if</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">Code</span><span class="pl-k">==</span><span class="pl-smi">Code</span>.<span class="pl-smi">INVALID</span>)
                <span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">Exception</span>(<span class="pl-s"><span class="pl-pds">"</span>Found garbage<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">totalBytes</span><span class="pl-k">&gt;=</span><span class="pl-smi">requiredBytes</span>)
                <span class="pl-k">break</span>;

            <span class="pl-k">switch</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">FlowControl</span>) {
            <span class="pl-k">case</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">Next</span>:
                <span class="pl-k">break</span>;

            <span class="pl-k">case</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">UnconditionalBranch</span>:
                <span class="pl-k">if</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">Op0Kind</span><span class="pl-k">==</span><span class="pl-smi">OpKind</span>.<span class="pl-smi">NearBranch64</span>) {
                    <span class="pl-k">var</span><span class="pl-smi">target</span><span class="pl-k">=</span><span class="pl-smi">instr</span>.<span class="pl-smi">NearBranchTarget</span>;
                    <span class="pl-c"><span class="pl-c">//</span> You could check if it's just jumping forward a few bytes and follow it</span><span class="pl-c"><span class="pl-c">//</span> but this is a simple example so we'll fail.</span>
                }
                <span class="pl-k">goto</span><span class="pl-k">default</span>;

            <span class="pl-k">case</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">IndirectBranch</span>:<span class="pl-c"><span class="pl-c">//</span> eg. jmp reg/mem</span><span class="pl-k">case</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">ConditionalBranch</span>:<span class="pl-c"><span class="pl-c">//</span> eg. je, jno, etc</span><span class="pl-k">case</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">Return</span>:<span class="pl-c"><span class="pl-c">//</span> eg. ret</span><span class="pl-k">case</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">Call</span>:<span class="pl-c"><span class="pl-c">//</span> eg. call method</span><span class="pl-k">case</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">IndirectCall</span>:<span class="pl-c"><span class="pl-c">//</span> eg. call reg/mem</span><span class="pl-k">case</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">Interrupt</span>:<span class="pl-c"><span class="pl-c">//</span> eg. int n</span><span class="pl-k">case</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">XbeginXabortXend</span>:
            <span class="pl-k">case</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">Exception</span>:<span class="pl-c"><span class="pl-c">//</span> eg. ud0</span><span class="pl-k">default</span>:
                <span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">Exception</span>(<span class="pl-s"><span class="pl-pds">"</span>Not supported by this simple example<span class="pl-pds">"</span></span>);
            }
        }
        <span class="pl-k">if</span> (<span class="pl-smi">totalBytes</span><span class="pl-k">&lt;</span><span class="pl-smi">requiredBytes</span>)
            <span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">Exception</span>(<span class="pl-s"><span class="pl-pds">"</span>Not enough bytes!<span class="pl-pds">"</span></span>);
        <span class="pl-smi">Debug</span>.<span class="pl-en">Assert</span>(<span class="pl-smi">origInstructions</span>.<span class="pl-smi">Count</span><span class="pl-k">&gt;</span><span class="pl-c1">0</span>);
        <span class="pl-c"><span class="pl-c">//</span> Create a JMP instruction that branches to the original code, except those instructions</span><span class="pl-c"><span class="pl-c">//</span> that we'll re-encode. We don't need to do it if it already ends in 'ret'</span><span class="pl-k">ref</span><span class="pl-k">readonly</span><span class="pl-k">var</span><span class="pl-smi">lastInstr</span><span class="pl-k">=</span><span class="pl-k">ref</span><span class="pl-smi">origInstructions</span>[<span class="pl-smi">origInstructions</span>.<span class="pl-smi">Count</span><span class="pl-k">-</span><span class="pl-c1">1</span>];
        <span class="pl-k">if</span> (<span class="pl-smi">lastInstr</span>.<span class="pl-smi">FlowControl</span><span class="pl-k">!=</span><span class="pl-smi">FlowControl</span>.<span class="pl-smi">Return</span>)
            <span class="pl-smi">origInstructions</span>.<span class="pl-en">Add</span>(<span class="pl-smi">Instruction</span>.<span class="pl-en">CreateBranch</span>(<span class="pl-smi">Code</span>.<span class="pl-smi">Jmp_rel32_64</span>, <span class="pl-smi">lastInstr</span>.<span class="pl-smi">NextIP</span>));

        <span class="pl-c"><span class="pl-c">//</span> Relocate the code to some new location. It can fix short/near branches and</span><span class="pl-c"><span class="pl-c">//</span> convert them to short/near/long forms if needed. This also works even if it's a</span><span class="pl-c"><span class="pl-c">//</span> jrcxz/loop/loopcc instruction which only have short forms.</span><span class="pl-c"><span class="pl-c">//</span></span><span class="pl-c"><span class="pl-c">//</span> It can currently only fix RIP relative operands if the new location is within 2GB</span><span class="pl-c"><span class="pl-c">//</span> of the target data location.</span><span class="pl-c"><span class="pl-c">//</span></span><span class="pl-c"><span class="pl-c">//</span> Note that a block is not the same thing as a basic block. A block can contain any</span><span class="pl-c"><span class="pl-c">//</span> number of instructions, including any number of branch instructions. One block</span><span class="pl-c"><span class="pl-c">//</span> should be enough unless you must relocate different blocks to different locations.</span><span class="pl-k">var</span><span class="pl-smi">codeWriter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">CodeWriterImpl</span>();
        <span class="pl-k">ulong</span><span class="pl-smi">relocatedBaseAddress</span><span class="pl-k">=</span><span class="pl-smi">exampleCodeRIP</span><span class="pl-k">+</span><span class="pl-c1">0x200000</span>;
        <span class="pl-k">var</span><span class="pl-smi">block</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">InstructionBlock</span>(<span class="pl-smi">codeWriter</span>, <span class="pl-smi">origInstructions</span>, <span class="pl-smi">relocatedBaseAddress</span>);
        <span class="pl-c"><span class="pl-c">//</span> This method can also encode more than one block but that's rarely needed, see above comment.</span><span class="pl-k">bool</span><span class="pl-smi">success</span><span class="pl-k">=</span><span class="pl-smi">BlockEncoder</span>.<span class="pl-en">TryEncode</span>(<span class="pl-smi">decoder</span>.<span class="pl-smi">Bitness</span>, <span class="pl-smi">block</span>, <span class="pl-k">out</span><span class="pl-k">var</span><span class="pl-smi">errorMessage</span>, <span class="pl-k">out</span><span class="pl-c1">_</span>);
        <span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-smi">success</span>) {
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>ERROR: {<span class="pl-smi">errorMessage</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">return</span>;
        }
        <span class="pl-k">var</span><span class="pl-smi">newCode</span><span class="pl-k">=</span><span class="pl-smi">codeWriter</span>.<span class="pl-en">ToArray</span>();

        <span class="pl-c"><span class="pl-c">//</span> Patch the original code. Pretend that we use some OS API to write to memory...</span><span class="pl-c"><span class="pl-c">//</span> We could use the BlockEncoder/Encoder for this but it's easy to do yourself too.</span><span class="pl-c"><span class="pl-c">//</span> This is 'mov rax,imm64; jmp rax'</span><span class="pl-k">const</span><span class="pl-k">ulong</span><span class="pl-smi">YOUR_FUNC</span><span class="pl-k">=</span><span class="pl-c1">0x123456789ABCDEF0</span>;<span class="pl-c"><span class="pl-c">//</span> Address of your code</span><span class="pl-smi">exampleCode</span>[<span class="pl-c1">0</span>] <span class="pl-k">=</span><span class="pl-c1">0x48</span>;<span class="pl-c"><span class="pl-c">//</span> \ 'MOV RAX,imm64'</span><span class="pl-smi">exampleCode</span>[<span class="pl-c1">1</span>] <span class="pl-k">=</span><span class="pl-c1">0xB8</span>;<span class="pl-c"><span class="pl-c">//</span> /</span><span class="pl-k">ulong</span><span class="pl-smi">v</span><span class="pl-k">=</span><span class="pl-smi">YOUR_FUNC</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>; <span class="pl-smi">i</span><span class="pl-k">&lt;</span><span class="pl-c1">8</span>; <span class="pl-smi">i</span><span class="pl-k">++</span>, <span class="pl-smi">v</span><span class="pl-k">&gt;&gt;=</span><span class="pl-c1">8</span>)
            <span class="pl-smi">exampleCode</span>[<span class="pl-c1">2</span><span class="pl-k">+</span><span class="pl-smi">i</span>] <span class="pl-k">=</span> (<span class="pl-smi">byte</span>)<span class="pl-smi">v</span>;
        <span class="pl-smi">exampleCode</span>[<span class="pl-c1">10</span>] <span class="pl-k">=</span><span class="pl-c1">0xFF</span>;<span class="pl-c"><span class="pl-c">//</span> \ JMP RAX</span><span class="pl-smi">exampleCode</span>[<span class="pl-c1">11</span>] <span class="pl-k">=</span><span class="pl-c1">0xE0</span>;<span class="pl-c"><span class="pl-c">//</span> /</span><span class="pl-c"><span class="pl-c">//</span> Disassemble it</span><span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">"</span>Original + patched code:<span class="pl-pds">"</span></span>);
        <span class="pl-k">var</span><span class="pl-smi">formatter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">NasmFormatter</span>();
        <span class="pl-k">var</span><span class="pl-smi">output</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StringOutput</span>();
        <span class="pl-smi">codeReader</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ByteArrayCodeReader</span>(<span class="pl-smi">exampleCode</span>);
        <span class="pl-smi">decoder</span><span class="pl-k">=</span><span class="pl-smi">Decoder</span>.<span class="pl-en">Create</span>(<span class="pl-smi">exampleCodeBitness</span>, <span class="pl-smi">codeReader</span>);
        <span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">=</span><span class="pl-smi">exampleCodeRIP</span>;
        <span class="pl-k">while</span> (<span class="pl-smi">codeReader</span>.<span class="pl-smi">CanReadByte</span>) {
            <span class="pl-en">Instruction</span><span class="pl-smi">instr</span>;
            <span class="pl-k">if</span> (<span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">==</span><span class="pl-smi">exampleCodeRIP</span><span class="pl-k">+</span><span class="pl-smi">requiredBytes</span><span class="pl-k">&amp;&amp;</span><span class="pl-smi">lastInstr</span>.<span class="pl-smi">NextIP</span><span class="pl-k">-</span><span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">!=</span><span class="pl-c1">0</span>) {
                <span class="pl-c"><span class="pl-c">//</span> The instruction was partially overwritten, so just show it as a 'db x,y,z' instead of garbage</span><span class="pl-k">var</span><span class="pl-smi">len</span><span class="pl-k">=</span> (<span class="pl-k">int</span>)(<span class="pl-smi">lastInstr</span>.<span class="pl-smi">NextIP</span><span class="pl-k">-</span><span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span>);
                <span class="pl-k">var</span><span class="pl-smi">index</span><span class="pl-k">=</span> (<span class="pl-k">int</span>)(<span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">-</span><span class="pl-smi">exampleCodeRIP</span>);
                <span class="pl-smi">instr</span><span class="pl-k">=</span><span class="pl-smi">Instruction</span>.<span class="pl-en">CreateDeclareByte</span>(<span class="pl-smi">exampleCode</span>, <span class="pl-smi">index</span>, <span class="pl-smi">len</span>);
                <span class="pl-smi">instr</span>.<span class="pl-smi">NextIP</span><span class="pl-k">=</span><span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span>;
                <span class="pl-k">for</span> (<span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>; <span class="pl-smi">i</span><span class="pl-k">&lt;</span><span class="pl-smi">len</span>; <span class="pl-smi">i</span><span class="pl-k">++</span>)
                    <span class="pl-smi">codeReader</span>.<span class="pl-en">ReadByte</span>();
                <span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">+=</span> (<span class="pl-k">ulong</span>)<span class="pl-smi">len</span>;
            }
            <span class="pl-k">else</span><span class="pl-smi">instr</span><span class="pl-k">=</span><span class="pl-smi">decoder</span>.<span class="pl-en">Decode</span>();
            <span class="pl-smi">formatter</span>.<span class="pl-en">Format</span>(<span class="pl-smi">instr</span>, <span class="pl-smi">output</span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>{<span class="pl-smi">instr</span>.<span class="pl-smi">IP</span>:<span class="pl-smi">X16</span>} {<span class="pl-smi">output</span>.<span class="pl-en">ToStringAndReset</span>()}<span class="pl-pds">"</span></span>);
        }
        <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>();

        <span class="pl-c"><span class="pl-c">//</span> Disassemble the moved code</span><span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">"</span>Moved code:<span class="pl-pds">"</span></span>);
        <span class="pl-en">Disassemble</span>(<span class="pl-smi">newCode</span>, <span class="pl-smi">relocatedBaseAddress</span>);
    }
    <span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Disassemble</span>(<span class="pl-k">byte</span>[] <span class="pl-smi">data</span>, <span class="pl-k">ulong</span><span class="pl-smi">ip</span>) {
        <span class="pl-k">var</span><span class="pl-smi">formatter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">NasmFormatter</span>();
        <span class="pl-k">var</span><span class="pl-smi">output</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StringOutput</span>();
        <span class="pl-k">var</span><span class="pl-smi">codeReader</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ByteArrayCodeReader</span>(<span class="pl-smi">data</span>);
        <span class="pl-k">var</span><span class="pl-smi">decoder</span><span class="pl-k">=</span><span class="pl-smi">Decoder</span>.<span class="pl-en">Create</span>(<span class="pl-smi">exampleCodeBitness</span>, <span class="pl-smi">codeReader</span>);
        <span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">=</span><span class="pl-smi">ip</span>;
        <span class="pl-k">while</span> (<span class="pl-smi">codeReader</span>.<span class="pl-smi">CanReadByte</span>) {
            <span class="pl-smi">decoder</span>.<span class="pl-en">Decode</span>(<span class="pl-k">out</span><span class="pl-k">var</span><span class="pl-smi">instr</span>);
            <span class="pl-smi">formatter</span>.<span class="pl-en">Format</span>(<span class="pl-smi">instr</span>, <span class="pl-smi">output</span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>{<span class="pl-smi">instr</span>.<span class="pl-smi">IP</span>:<span class="pl-smi">X16</span>} {<span class="pl-smi">output</span>.<span class="pl-en">ToStringAndReset</span>()}<span class="pl-pds">"</span></span>);
        }
        <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>();
    }
    <span class="pl-k">sealed</span><span class="pl-k">class</span><span class="pl-en">CodeWriterImpl</span> : <span class="pl-en">CodeWriter</span> {
        <span class="pl-k">readonly</span><span class="pl-en">List</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">allBytes</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">List</span>&lt;<span class="pl-k">byte</span>&gt;();
        <span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">void</span><span class="pl-en">WriteByte</span>(<span class="pl-k">byte</span><span class="pl-smi">value</span>) <span class="pl-k">=&gt;</span><span class="pl-smi">allBytes</span>.<span class="pl-en">Add</span>(<span class="pl-smi">value</span>);
        <span class="pl-k">public</span><span class="pl-k">byte</span>[] <span class="pl-en">ToArray</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">allBytes</span>.<span class="pl-en">ToArray</span>();
    }

    <span class="pl-k">const</span><span class="pl-k">int</span><span class="pl-smi">exampleCodeBitness</span><span class="pl-k">=</span><span class="pl-c1">64</span>;
    <span class="pl-k">const</span><span class="pl-k">ulong</span><span class="pl-smi">exampleCodeRIP</span><span class="pl-k">=</span><span class="pl-c1">0x00007FFAC46ACDA4</span>;
    <span class="pl-k">static</span><span class="pl-k">readonly</span><span class="pl-k">byte</span>[] <span class="pl-smi">exampleCode</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">byte</span>[] {
        <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x5C</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x10</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x74</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x18</span>, <span class="pl-c1">0x55</span>, <span class="pl-c1">0x57</span>, <span class="pl-c1">0x41</span>, <span class="pl-c1">0x56</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8D</span>,
        <span class="pl-c1">0xAC</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x81</span>, <span class="pl-c1">0xEC</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x02</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8B</span>, <span class="pl-c1">0x05</span>,
        <span class="pl-c1">0x18</span>, <span class="pl-c1">0x57</span>, <span class="pl-c1">0x0A</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x33</span>, <span class="pl-c1">0xC4</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x85</span>, <span class="pl-c1">0xF0</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x4C</span>, <span class="pl-c1">0x8B</span>,
        <span class="pl-c1">0x05</span>, <span class="pl-c1">0x2F</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x0A</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8D</span>, <span class="pl-c1">0x05</span>, <span class="pl-c1">0x78</span>, <span class="pl-c1">0x7C</span>, <span class="pl-c1">0x04</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x33</span>, <span class="pl-c1">0xFF</span>
    };
}</pre></div><h2><a id="user-content-get-instruction-info-eg-readwritten-regsmem-control-flow-info-etc" class="anchor" aria-hidden="true" href="#get-instruction-info-eg-readwritten-regsmem-control-flow-info-etc"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Get instruction info, eg. read/written regs/mem, control flow info, etc</h2><div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span><span class="pl-en">System</span>;
<span class="pl-k">using</span><span class="pl-en">Iced</span>.<span class="pl-en">Intel</span>;

<span class="pl-k">static</span><span class="pl-k">class</span><span class="pl-en">HowTo_InstructionInfo</span> {
    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * This method produces the following output:</span><span class="pl-c">00007FFAC46ACDA4 mov [rsp+10h],rbx</span><span class="pl-c">    OpCode: REX.W 89 /r</span><span class="pl-c">    Instruction: MOV r/m64, r64</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Mov</span><span class="pl-c">    Code: Mov_rm64_r64</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    Displacement offset = 4, size = 1</span><span class="pl-c">    Memory size: 8</span><span class="pl-c">    Op0Access: Write</span><span class="pl-c">    Op1Access: Read</span><span class="pl-c">    Op0: r64_or_mem</span><span class="pl-c">    Op1: r64_reg</span><span class="pl-c">    Used reg: RSP:Read</span><span class="pl-c">    Used reg: RBX:Read</span><span class="pl-c">    Used mem: [SS:RSP+0x10;UInt64;Write]</span><span class="pl-c">00007FFAC46ACDA9 mov [rsp+18h],rsi</span><span class="pl-c">    OpCode: REX.W 89 /r</span><span class="pl-c">    Instruction: MOV r/m64, r64</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Mov</span><span class="pl-c">    Code: Mov_rm64_r64</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    Displacement offset = 4, size = 1</span><span class="pl-c">    Memory size: 8</span><span class="pl-c">    Op0Access: Write</span><span class="pl-c">    Op1Access: Read</span><span class="pl-c">    Op0: r64_or_mem</span><span class="pl-c">    Op1: r64_reg</span><span class="pl-c">    Used reg: RSP:Read</span><span class="pl-c">    Used reg: RSI:Read</span><span class="pl-c">    Used mem: [SS:RSP+0x18;UInt64;Write]</span><span class="pl-c">00007FFAC46ACDAE push rbp</span><span class="pl-c">    OpCode: 50+ro</span><span class="pl-c">    Instruction: PUSH r64</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Push</span><span class="pl-c">    Code: Push_r64</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    SP Increment: -8</span><span class="pl-c">    Op0Access: Read</span><span class="pl-c">    Op0: r64_opcode</span><span class="pl-c">    Used reg: RBP:Read</span><span class="pl-c">    Used reg: RSP:ReadWrite</span><span class="pl-c">    Used mem: [SS:RSP+0xFFFFFFFFFFFFFFF8;UInt64;Write]</span><span class="pl-c">00007FFAC46ACDAF push rdi</span><span class="pl-c">    OpCode: 50+ro</span><span class="pl-c">    Instruction: PUSH r64</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Push</span><span class="pl-c">    Code: Push_r64</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    SP Increment: -8</span><span class="pl-c">    Op0Access: Read</span><span class="pl-c">    Op0: r64_opcode</span><span class="pl-c">    Used reg: RDI:Read</span><span class="pl-c">    Used reg: RSP:ReadWrite</span><span class="pl-c">    Used mem: [SS:RSP+0xFFFFFFFFFFFFFFF8;UInt64;Write]</span><span class="pl-c">00007FFAC46ACDB0 push r14</span><span class="pl-c">    OpCode: 50+ro</span><span class="pl-c">    Instruction: PUSH r64</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Push</span><span class="pl-c">    Code: Push_r64</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    SP Increment: -8</span><span class="pl-c">    Op0Access: Read</span><span class="pl-c">    Op0: r64_opcode</span><span class="pl-c">    Used reg: R14:Read</span><span class="pl-c">    Used reg: RSP:ReadWrite</span><span class="pl-c">    Used mem: [SS:RSP+0xFFFFFFFFFFFFFFF8;UInt64;Write]</span><span class="pl-c">00007FFAC46ACDB2 lea rbp,[rsp-100h]</span><span class="pl-c">    OpCode: REX.W 8D /r</span><span class="pl-c">    Instruction: LEA r64, m</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Lea</span><span class="pl-c">    Code: Lea_r64_m</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    Displacement offset = 4, size = 4</span><span class="pl-c">    Op0Access: Write</span><span class="pl-c">    Op1Access: NoMemAccess</span><span class="pl-c">    Op0: r64_reg</span><span class="pl-c">    Op1: mem</span><span class="pl-c">    Used reg: RBP:Write</span><span class="pl-c">    Used reg: RSP:Read</span><span class="pl-c">00007FFAC46ACDBA sub rsp,200h</span><span class="pl-c">    OpCode: REX.W 81 /5 id</span><span class="pl-c">    Instruction: SUB r/m64, imm32</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Sub</span><span class="pl-c">    Code: Sub_rm64_imm32</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    Immediate offset = 3, size = 4</span><span class="pl-c">    RFLAGS Written: OF, SF, ZF, AF, CF, PF</span><span class="pl-c">    RFLAGS Modified: OF, SF, ZF, AF, CF, PF</span><span class="pl-c">    Op0Access: ReadWrite</span><span class="pl-c">    Op1Access: Read</span><span class="pl-c">    Op0: r64_or_mem</span><span class="pl-c">    Op1: imm32sex64</span><span class="pl-c">    Used reg: RSP:ReadWrite</span><span class="pl-c">00007FFAC46ACDC1 mov rax,[7FFAC47524E0h]</span><span class="pl-c">    OpCode: REX.W 8B /r</span><span class="pl-c">    Instruction: MOV r64, r/m64</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Mov</span><span class="pl-c">    Code: Mov_r64_rm64</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    Displacement offset = 3, size = 4</span><span class="pl-c">    Memory size: 8</span><span class="pl-c">    Op0Access: Write</span><span class="pl-c">    Op1Access: Read</span><span class="pl-c">    Op0: r64_reg</span><span class="pl-c">    Op1: r64_or_mem</span><span class="pl-c">    Used reg: RAX:Write</span><span class="pl-c">    Used mem: [DS:0x7FFAC47524E0;UInt64;Read]</span><span class="pl-c">00007FFAC46ACDC8 xor rax,rsp</span><span class="pl-c">    OpCode: REX.W 33 /r</span><span class="pl-c">    Instruction: XOR r64, r/m64</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Xor</span><span class="pl-c">    Code: Xor_r64_rm64</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    RFLAGS Written: SF, ZF, PF</span><span class="pl-c">    RFLAGS Cleared: OF, CF</span><span class="pl-c">    RFLAGS Undefined: AF</span><span class="pl-c">    RFLAGS Modified: OF, SF, ZF, AF, CF, PF</span><span class="pl-c">    Op0Access: ReadWrite</span><span class="pl-c">    Op1Access: Read</span><span class="pl-c">    Op0: r64_reg</span><span class="pl-c">    Op1: r64_or_mem</span><span class="pl-c">    Used reg: RAX:ReadWrite</span><span class="pl-c">    Used reg: RSP:Read</span><span class="pl-c">00007FFAC46ACDCB mov [rbp+0F0h],rax</span><span class="pl-c">    OpCode: REX.W 89 /r</span><span class="pl-c">    Instruction: MOV r/m64, r64</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Mov</span><span class="pl-c">    Code: Mov_rm64_r64</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    Displacement offset = 3, size = 4</span><span class="pl-c">    Memory size: 8</span><span class="pl-c">    Op0Access: Write</span><span class="pl-c">    Op1Access: Read</span><span class="pl-c">    Op0: r64_or_mem</span><span class="pl-c">    Op1: r64_reg</span><span class="pl-c">    Used reg: RBP:Read</span><span class="pl-c">    Used reg: RAX:Read</span><span class="pl-c">    Used mem: [SS:RBP+0xF0;UInt64;Write]</span><span class="pl-c">00007FFAC46ACDD2 mov r8,[7FFAC474F208h]</span><span class="pl-c">    OpCode: REX.W 8B /r</span><span class="pl-c">    Instruction: MOV r64, r/m64</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Mov</span><span class="pl-c">    Code: Mov_r64_rm64</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    Displacement offset = 3, size = 4</span><span class="pl-c">    Memory size: 8</span><span class="pl-c">    Op0Access: Write</span><span class="pl-c">    Op1Access: Read</span><span class="pl-c">    Op0: r64_reg</span><span class="pl-c">    Op1: r64_or_mem</span><span class="pl-c">    Used reg: R8:Write</span><span class="pl-c">    Used mem: [DS:0x7FFAC474F208;UInt64;Read]</span><span class="pl-c">00007FFAC46ACDD9 lea rax,[7FFAC46F4A58h]</span><span class="pl-c">    OpCode: REX.W 8D /r</span><span class="pl-c">    Instruction: LEA r64, m</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Lea</span><span class="pl-c">    Code: Lea_r64_m</span><span class="pl-c">    CpuidFeature: X64</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    Displacement offset = 3, size = 4</span><span class="pl-c">    Op0Access: Write</span><span class="pl-c">    Op1Access: NoMemAccess</span><span class="pl-c">    Op0: r64_reg</span><span class="pl-c">    Op1: mem</span><span class="pl-c">    Used reg: RAX:Write</span><span class="pl-c">00007FFAC46ACDE0 xor edi,edi</span><span class="pl-c">    OpCode: o32 33 /r</span><span class="pl-c">    Instruction: XOR r32, r/m32</span><span class="pl-c">    Encoding: Legacy</span><span class="pl-c">    Mnemonic: Xor</span><span class="pl-c">    Code: Xor_r32_rm32</span><span class="pl-c">    CpuidFeature: INTEL386</span><span class="pl-c">    FlowControl: Next</span><span class="pl-c">    RFLAGS Cleared: OF, SF, CF</span><span class="pl-c">    RFLAGS Set: ZF, PF</span><span class="pl-c">    RFLAGS Undefined: AF</span><span class="pl-c">    RFLAGS Modified: OF, SF, ZF, AF, CF, PF</span><span class="pl-c">    Op0Access: Write</span><span class="pl-c">    Op1Access: None</span><span class="pl-c">    Op0: r32_reg</span><span class="pl-c">    Op1: r32_or_mem</span><span class="pl-c">    Used reg: RDI:Write</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Example</span>() {
        <span class="pl-k">var</span><span class="pl-smi">codeReader</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ByteArrayCodeReader</span>(<span class="pl-smi">exampleCode</span>);
        <span class="pl-k">var</span><span class="pl-smi">decoder</span><span class="pl-k">=</span><span class="pl-smi">Decoder</span>.<span class="pl-en">Create</span>(<span class="pl-smi">exampleCodeBitness</span>, <span class="pl-smi">codeReader</span>);
        <span class="pl-smi">decoder</span>.<span class="pl-smi">IP</span><span class="pl-k">=</span><span class="pl-smi">exampleCodeRIP</span>;

        <span class="pl-c"><span class="pl-c">//</span> Use a factory to create the instruction info if you need register and</span><span class="pl-c"><span class="pl-c">//</span> memory usage. If it's something else, eg. encoding, flags, etc, there</span><span class="pl-c"><span class="pl-c">//</span> are properties on Instruction that can be used instead.</span><span class="pl-k">var</span><span class="pl-smi">instrInfoFactory</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">InstructionInfoFactory</span>();
        <span class="pl-k">while</span> (<span class="pl-smi">codeReader</span>.<span class="pl-smi">CanReadByte</span>) {
            <span class="pl-smi">decoder</span>.<span class="pl-en">Decode</span>(<span class="pl-k">out</span><span class="pl-k">var</span><span class="pl-smi">instr</span>);

            <span class="pl-c"><span class="pl-c">//</span> Gets offsets in the instruction of the displacement and immediates and their sizes.</span><span class="pl-c"><span class="pl-c">//</span> This can be useful if there are relocations in the binary. The encoder has a similar</span><span class="pl-c"><span class="pl-c">//</span> method. This method must be called after Decode() and you must pass in the last</span><span class="pl-c"><span class="pl-c">//</span> instruction Decode() returned.</span><span class="pl-k">var</span><span class="pl-smi">offsets</span><span class="pl-k">=</span><span class="pl-smi">decoder</span>.<span class="pl-en">GetConstantOffsets</span>(<span class="pl-smi">instr</span>);

            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>{<span class="pl-smi">instr</span>.<span class="pl-smi">IP</span>:<span class="pl-smi">X16</span>} {<span class="pl-smi">instr</span>}<span class="pl-pds">"</span></span>);

            <span class="pl-k">var</span><span class="pl-smi">opCode</span><span class="pl-k">=</span><span class="pl-smi">instr</span>.<span class="pl-smi">OpCode</span>;
            <span class="pl-c"><span class="pl-c">//</span> It returns it by ref, so use `ref readonly` to avoid a useless struct copy</span><span class="pl-k">ref</span><span class="pl-k">readonly</span><span class="pl-k">var</span><span class="pl-smi">info</span><span class="pl-k">=</span><span class="pl-k">ref</span><span class="pl-smi">instrInfoFactory</span>.<span class="pl-en">GetInfo</span>(<span class="pl-smi">instr</span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    OpCode: {<span class="pl-smi">opCode</span>.<span class="pl-en">ToOpCodeString</span>()}<span class="pl-pds">"</span></span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Instruction: {<span class="pl-smi">opCode</span>.<span class="pl-en">ToInstructionString</span>()}<span class="pl-pds">"</span></span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Encoding: {<span class="pl-smi">instr</span>.<span class="pl-smi">Encoding</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Mnemonic: {<span class="pl-smi">instr</span>.<span class="pl-smi">Mnemonic</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Code: {<span class="pl-smi">instr</span>.<span class="pl-smi">Code</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    CpuidFeature: {<span class="pl-smi">string</span>.<span class="pl-en">Join</span>(<span class="pl-s"><span class="pl-pds">"</span> and <span class="pl-pds">"</span></span>, <span class="pl-smi">instr</span>.<span class="pl-smi">CpuidFeatures</span>)}<span class="pl-pds">"</span></span>);
            <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    FlowControl: {<span class="pl-smi">instr</span>.<span class="pl-smi">FlowControl</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">offsets</span>.<span class="pl-smi">HasDisplacement</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Displacement offset = {<span class="pl-smi">offsets</span>.<span class="pl-smi">DisplacementOffset</span>}, size = {<span class="pl-smi">offsets</span>.<span class="pl-smi">DisplacementSize</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">offsets</span>.<span class="pl-smi">HasImmediate</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Immediate offset = {<span class="pl-smi">offsets</span>.<span class="pl-smi">ImmediateOffset</span>}, size = {<span class="pl-smi">offsets</span>.<span class="pl-smi">ImmediateSize</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">offsets</span>.<span class="pl-smi">HasImmediate2</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Immediate #2 offset = {<span class="pl-smi">offsets</span>.<span class="pl-smi">ImmediateOffset2</span>}, size = {<span class="pl-smi">offsets</span>.<span class="pl-smi">ImmediateSize2</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">IsStackInstruction</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    SP Increment: {<span class="pl-smi">instr</span>.<span class="pl-smi">StackPointerIncrement</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">ConditionCode</span><span class="pl-k">!=</span><span class="pl-smi">ConditionCode</span>.<span class="pl-smi">None</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Condition code: {<span class="pl-smi">instr</span>.<span class="pl-smi">ConditionCode</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsRead</span><span class="pl-k">!=</span><span class="pl-smi">RflagsBits</span>.<span class="pl-smi">None</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    RFLAGS Read: {<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsRead</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsWritten</span><span class="pl-k">!=</span><span class="pl-smi">RflagsBits</span>.<span class="pl-smi">None</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    RFLAGS Written: {<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsWritten</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsCleared</span><span class="pl-k">!=</span><span class="pl-smi">RflagsBits</span>.<span class="pl-smi">None</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    RFLAGS Cleared: {<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsCleared</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsSet</span><span class="pl-k">!=</span><span class="pl-smi">RflagsBits</span>.<span class="pl-smi">None</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    RFLAGS Set: {<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsSet</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsUndefined</span><span class="pl-k">!=</span><span class="pl-smi">RflagsBits</span>.<span class="pl-smi">None</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    RFLAGS Undefined: {<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsUndefined</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">if</span> (<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsModified</span><span class="pl-k">!=</span><span class="pl-smi">RflagsBits</span>.<span class="pl-smi">None</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    RFLAGS Modified: {<span class="pl-smi">instr</span>.<span class="pl-smi">RflagsModified</span>}<span class="pl-pds">"</span></span>);
            <span class="pl-k">for</span> (<span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>; <span class="pl-smi">i</span><span class="pl-k">&lt;</span><span class="pl-smi">instr</span>.<span class="pl-smi">OpCount</span>; <span class="pl-smi">i</span><span class="pl-k">++</span>) {
                <span class="pl-k">var</span><span class="pl-smi">opKind</span><span class="pl-k">=</span><span class="pl-smi">instr</span>.<span class="pl-en">GetOpKind</span>(<span class="pl-smi">i</span>);
                <span class="pl-k">if</span> (<span class="pl-smi">opKind</span><span class="pl-k">==</span><span class="pl-smi">OpKind</span>.<span class="pl-smi">Memory</span><span class="pl-k">||</span><span class="pl-smi">opKind</span><span class="pl-k">==</span><span class="pl-smi">OpKind</span>.<span class="pl-smi">Memory64</span>) {
                    <span class="pl-k">int</span><span class="pl-smi">size</span><span class="pl-k">=</span><span class="pl-smi">instr</span>.<span class="pl-smi">MemorySize</span>.<span class="pl-en">GetSize</span>();
                    <span class="pl-k">if</span> (<span class="pl-smi">size</span><span class="pl-k">!=</span><span class="pl-c1">0</span>)
                        <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Memory size: {<span class="pl-smi">size</span>}<span class="pl-pds">"</span></span>);
                    <span class="pl-k">break</span>;
                }
            }
            <span class="pl-k">for</span> (<span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>; <span class="pl-smi">i</span><span class="pl-k">&lt;</span><span class="pl-smi">instr</span>.<span class="pl-smi">OpCount</span>; <span class="pl-smi">i</span><span class="pl-k">++</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Op{<span class="pl-smi">i</span>}Access: {<span class="pl-smi">info</span>.<span class="pl-en">GetOpAccess</span>(<span class="pl-smi">i</span>)}<span class="pl-pds">"</span></span>);
            <span class="pl-k">for</span> (<span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>; <span class="pl-smi">i</span><span class="pl-k">&lt;</span><span class="pl-smi">opCode</span>.<span class="pl-smi">OpCount</span>; <span class="pl-smi">i</span><span class="pl-k">++</span>)
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Op{<span class="pl-smi">i</span>}: {<span class="pl-smi">opCode</span>.<span class="pl-en">GetOpKind</span>(<span class="pl-smi">i</span>)}<span class="pl-pds">"</span></span>);
            <span class="pl-c"><span class="pl-c">//</span> The returned iterator is a struct, nothing is allocated unless you box it</span><span class="pl-k">foreach</span> (<span class="pl-k">var</span><span class="pl-smi">regInfo</span><span class="pl-k">in</span><span class="pl-smi">info</span>.<span class="pl-en">GetUsedRegisters</span>())
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Used reg: {<span class="pl-smi">regInfo</span>.<span class="pl-en">ToString</span>()}<span class="pl-pds">"</span></span>);
            <span class="pl-k">foreach</span> (<span class="pl-k">var</span><span class="pl-smi">memInfo</span><span class="pl-k">in</span><span class="pl-smi">info</span>.<span class="pl-en">GetUsedMemory</span>())
                <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>    Used mem: {<span class="pl-smi">memInfo</span>.<span class="pl-en">ToString</span>()}<span class="pl-pds">"</span></span>);
        }
    }

    <span class="pl-k">const</span><span class="pl-k">int</span><span class="pl-smi">exampleCodeBitness</span><span class="pl-k">=</span><span class="pl-c1">64</span>;
    <span class="pl-k">const</span><span class="pl-k">ulong</span><span class="pl-smi">exampleCodeRIP</span><span class="pl-k">=</span><span class="pl-c1">0x00007FFAC46ACDA4</span>;
    <span class="pl-k">static</span><span class="pl-k">readonly</span><span class="pl-k">byte</span>[] <span class="pl-smi">exampleCode</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">byte</span>[] {
        <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x5C</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x10</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x74</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x18</span>, <span class="pl-c1">0x55</span>, <span class="pl-c1">0x57</span>, <span class="pl-c1">0x41</span>, <span class="pl-c1">0x56</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8D</span>,
        <span class="pl-c1">0xAC</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0xFF</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x81</span>, <span class="pl-c1">0xEC</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x02</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8B</span>, <span class="pl-c1">0x05</span>,
        <span class="pl-c1">0x18</span>, <span class="pl-c1">0x57</span>, <span class="pl-c1">0x0A</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x33</span>, <span class="pl-c1">0xC4</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x89</span>, <span class="pl-c1">0x85</span>, <span class="pl-c1">0xF0</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x4C</span>, <span class="pl-c1">0x8B</span>,
        <span class="pl-c1">0x05</span>, <span class="pl-c1">0x2F</span>, <span class="pl-c1">0x24</span>, <span class="pl-c1">0x0A</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x48</span>, <span class="pl-c1">0x8D</span>, <span class="pl-c1">0x05</span>, <span class="pl-c1">0x78</span>, <span class="pl-c1">0x7C</span>, <span class="pl-c1">0x04</span>, <span class="pl-c1">0x00</span>, <span class="pl-c1">0x33</span>, <span class="pl-c1">0xFF</span>
    };
}</pre></div><h2><a id="user-content-get-the-virtual-address-of-a-memory-operand" class="anchor" aria-hidden="true" href="#get-the-virtual-address-of-a-memory-operand"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Get the virtual address of a memory operand</h2><div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span><span class="pl-en">System</span>;
<span class="pl-k">using</span><span class="pl-en">System</span>.<span class="pl-en">Diagnostics</span>;
<span class="pl-k">using</span><span class="pl-en">Iced</span>.<span class="pl-en">Intel</span>;

<span class="pl-k">static</span><span class="pl-k">class</span><span class="pl-en">HowTo_GetVirtualAddress</span> {
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Example</span>() {
        <span class="pl-c"><span class="pl-c">//</span> add [rdi+r12*8-5AA5EDCCh],esi</span><span class="pl-k">var</span><span class="pl-smi">reader</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ByteArrayCodeReader</span>(<span class="pl-s"><span class="pl-pds">"</span>4201B4E734125AA5<span class="pl-pds">"</span></span>);
        <span class="pl-k">var</span><span class="pl-smi">decoder</span><span class="pl-k">=</span><span class="pl-smi">Decoder</span>.<span class="pl-en">Create</span>(<span class="pl-c1">64</span>, <span class="pl-smi">reader</span>);
        <span class="pl-k">var</span><span class="pl-smi">instr</span><span class="pl-k">=</span><span class="pl-smi">decoder</span>.<span class="pl-en">Decode</span>();

        <span class="pl-k">var</span><span class="pl-smi">va</span><span class="pl-k">=</span><span class="pl-smi">instr</span>.<span class="pl-en">GetVirtualAddress</span>(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, (<span class="pl-smi">register</span>, <span class="pl-smi">elementIndex</span>, <span class="pl-smi">elementSize</span>) <span class="pl-k">=&gt;</span> {
            <span class="pl-k">switch</span> (<span class="pl-smi">register</span>) {
            <span class="pl-c"><span class="pl-c">//</span> The base address of ES, CS, SS and DS is always 0 in 64-bit mode</span><span class="pl-k">case</span><span class="pl-smi">Register</span>.<span class="pl-smi">ES</span>:
            <span class="pl-k">case</span><span class="pl-smi">Register</span>.<span class="pl-smi">CS</span>:
            <span class="pl-k">case</span><span class="pl-smi">Register</span>.<span class="pl-smi">SS</span>:
            <span class="pl-k">case</span><span class="pl-smi">Register</span>.<span class="pl-smi">DS</span>:
                <span class="pl-k">return</span><span class="pl-c1">0</span>;
            <span class="pl-k">case</span><span class="pl-smi">Register</span>.<span class="pl-smi">RDI</span>:
                <span class="pl-k">return</span><span class="pl-c1">0x0000_0000_1000_0000</span>;
            <span class="pl-k">case</span><span class="pl-smi">Register</span>.<span class="pl-smi">R12</span>:
                <span class="pl-k">return</span><span class="pl-c1">0x0000_0004_0000_0000</span>;
            <span class="pl-k">default</span>:
                <span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">NotImplementedException</span>();
            }
        });
        <span class="pl-smi">Debug</span>.<span class="pl-en">Assert</span>(<span class="pl-smi">va</span><span class="pl-k">==</span><span class="pl-c1">0x0000_001F_B55A_1234</span>);
    }
}</pre></div><h1><a id="user-content-license" class="anchor" aria-hidden="true" href="#license"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>License</h1><p>MIT</p><h1><a id="user-content-icon" class="anchor" aria-hidden="true" href="#icon"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Icon</h1><p>Logo <code>processor</code> by <a href="https://thenounproject.com/creativestall/" rel="nofollow">Creative Stall</a> from the Noun Project</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>