<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The&#xA0;.NET Core Journey at Criteo - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The&#xA0;.NET Core Journey at Criteo - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@chnasarre"/>
    <meta property="og:description" content="This post shows the challenges we faced during the migration to&#xA0;.NET Core on containerized Linux for our main application."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/criteo-labs/the-net-core-journey-at-criteo-1e47ed87adce"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The&#xA0;.NET Core Journey at Criteo</title>
<div class="readable">
        <h1>The&#xA0;.NET Core Journey at Criteo</h1>
            <div>by https://medium.com/@chnasarre</div>
            <div>Reading time: 11-14 minutes</div>
        <div>Posted here: 04 Aug 2020</div>
        <p><a href="https://medium.com/criteo-labs/the-net-core-journey-at-criteo-1e47ed87adce">https://medium.com/criteo-labs/the-net-core-journey-at-criteo-1e47ed87adce</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><p id="bac3" data-selectable-paragraph="">Once we got a build of all .NET Core assemblies (more on this in a forthcoming blog post), it was time to run a few applications. The first issues that we faced were related to missing features between .NET Framework and .NET Core. For example, we need cryptography support of <a href="https://github.com/dotnet/corefx/issues/4647" target="_blank" rel="noopener nofollow">3DES and AES with cypher mode CFB</a> but it is (still) not available in .NET Core for Linux. Thanks to the Open Source status of .NET Core, we were able to <a href="https://github.com/criteo-forks/corefx/tree/aes_3des_cfb_mode_implementation_unix" target="_blank" rel="noopener nofollow">add it to CoreFx</a>. However, since we did not implement it on MacOS/Windows as Microsoft requested for our change to be accepted as a Pull Request, we had to keep our Criteo-forked branch.</p><p id="a79d" data-selectable-paragraph="">The second class of runtime problems we had to solve were due to differences between Windows and Linux but also with the “containerization” of the runtime environment. Let’s take two examples involving the .NET Garbage Collector. First, our containers were using Linux cgroups to manage quotas including memory and number of CPU cores usable by applications. However, at CLR startup, the GC was counting the <strong>total</strong> count of CPU cores to compute the number of heaps to allocate instead of the one defined at the cgroup level: We ended up with instant Out Of Memory automatic killing. This time our fix was done and merged in the CLR repository.</p><p id="f94b" data-selectable-paragraph="">The second example is related to a GC optimization: During background generation 2 collections, the CLR threads working underneath are affinitized to each different CPU core to avoid locks. We were lucky enough to welcome <a href="https://twitter.com/@maoni0" target="_blank" rel="noopener nofollow">Maoni Stephens</a> (Lead Dev on the GC) in our Paris office early 2018 to share our weird allocation patterns that impacted the GC. During her stay, she was kind enough to help us investigate a behavior on our servers: When <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer" target="_blank" rel="noopener nofollow">SysInternals ProcessExplorer</a> was running, the garbage collections were taking more time than usual. Maoni found out ProcessExplore had an affinitized high priority thread conflicting with GC threads. During investigations related to longer response time on Linux compared to Windows. We realized that GC threads were not affinitized like it was the case on Windows and the issue was <a href="https://github.com/dotnet/coreclr/pull/24801" target="_blank" rel="noopener nofollow">fixed by Jan Vorlicek</a>.</p><p id="da82" data-selectable-paragraph=""><em>Here is our lesson: Sometimes fixes are merged into the official release and sometimes they are not. If your workloads are pushing .NET to its limits, you will probably have to build and manage your </em><a href="https://github.com/criteo-forks/coreclr" target="_blank" rel="noopener nofollow"><em>own Core fork</em></a><em> and make it available to your deployments.</em></p><p id="5aea" data-selectable-paragraph="">At Criteo, our Grafana dashboards measuring .NET Framework application health were based on metrics computed from Windows performance counters. Even without going to Linux, .NET Core is no more exposing performance counters so we had to entirely rebuild our metrics collection system!</p><p id="a89f" data-selectable-paragraph="">Based on Microsoft feedbacks, we decided to listen to CLR events emitted via ETW on Windows and LTTng on Linux. In addition to work for both Operating Systems, these events are also providing accurate details about thread contention, exceptions and garbage collections not available with Performance counters. Please refer to our <a target="_blank" rel="noopener" href="https://medium.com/@chnasarre/how-to-expose-your-custom-counters-in-net-core-5dcedcc2ccb6">series of blog posts</a> for more details and reusable code samples to integrate these events into your own systems.</p><p id="7c1a" data-selectable-paragraph="">Our first Linux metrics collection implementation was based on LTTng and we presented our journey during the <a href="https://www.youtube.com/watch?v=pMl9RM9h2eg&amp;list=PLuo4E47p5_7bfeZyYIyNYM-f-2tmr0neu&amp;index=6" target="_blank" rel="noopener nofollow">Tracing Summit in 2017</a>. Microsoft already built <a href="https://github.com/microsoft/perfview/blob/master/documentation/TraceEvent/TraceEventLibrary.md" target="_blank" rel="noopener nofollow">TraceEvent</a>, an assembly allowing .NET code to parse CLR events for both Windows and Linux. Unfortunately for us, the Linux part was only able to load traces files but we needed live session like on Windows where you can listen to events emitted by running applications. Since this code is Open Source, <a href="https://twitter.com/@GregoryLeocadie" target="_blank" rel="noopener nofollow">Gregory</a> was able to add the <a href="https://github.com/microsoft/perfview/pull/340" target="_blank" rel="noopener nofollow">live session feature</a> to TraceEvent.</p><p id="9c1e" data-selectable-paragraph="">With .NET Core 3.0 Microsoft provided a way to exchange events common to Linux and Windows called EventPipes. So… we moved our collection implementation from LTTng to EventPipe (look at our <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/how-to-expose-your-custom-counters-in-net-core-5dcedcc2ccb6">blog series</a> and <a href="https://www.youtube.com/watch?v=Jpoy3O6x-wM" target="_blank" rel="noopener nofollow">DotNext conference session</a> for more details and reusable code sample). With the new EventPipe implementation in the CLR came performance issues not seen by Microsoft. The reason is simple: Some of our applications are running hundreds of threads to process thousands of requests per second and allocate memory like crazy. In that kind of context, the CLR has a lot to do and so, has a lot of events to generate and emit via LTTng or EventPipes.</p><figure><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*P_gRXkTbBaDLhsQSnWDJIQ.png?q=20" width="627" height="153"></p><p><img alt="Image for post" width="627" height="153"></p></div></div></div><figcaption data-selectable-paragraph="">(Number of processed CLR events per minute; even more are emitted even with the limited gc/thread/exception keywords that we are using)</figcaption></figure><p id="2c67" data-selectable-paragraph="">The initial implementation was <a href="https://github.com/dotnet/runtime/issues/12204" target="_blank" rel="noopener nofollow">lacking some</a> filtering and too many events were generated or expensive event payload was created even though the events were not emitted. Based on our feedback, the Microsoft Diagnostic team was very responsive and quickly fixed the problem.</p><p id="53cf" data-selectable-paragraph=""><em>Microsoft did not “just” move to Open Source, the teams are working deeply integrated with the issue/pull request model of GitHub. So don’t be shy and if you find a problem, create an issue with a detailed reproduction and even better, provide a pull request with the fix. Everyone in the community will benefit!</em></p><p id="ff67" data-selectable-paragraph="">With these metrics, we started to investigate some performance differences (mostly response time) between Windows and containerized Linux.</p><figure><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*h41QfdE5wVef3pD8DZ6twA.png?q=20" width="384" height="231"></p><p><img alt="Image for post" width="384" height="231"></p></div></div></div><figcaption data-selectable-paragraph="">(The lower the better)</figcaption></figure><p id="436d" data-selectable-paragraph="">We saw a huge performance difference on Linux: Both response time (x2) and scalability (timeout increase with QPS). Our team spent a lot of time to improve the situation up to the point where it was possible to send the applications to production.</p><p id="048b" data-selectable-paragraph="">In the new containerized environment we faced the same kind of <em>noisy neighbor</em> symptoms that we had with Process Explorer. If the CPU cores are not dedicated to a container (as it was for us at the beginning), this scenario happens a lot. So we updated the scheduling system to dedicate CPU cores to containers.</p><p id="cf1f" data-selectable-paragraph="">On a totally different area, we found out that the way .NET Core handles network I/O continuation had an impact on our main application. To give a bit of context, this application has to handle a lot of requests and is response-time driven. During the processing of a request, the current thread might have to send an HTTP request before continuing its processing. Since this is done asynchronously, the thread is now available to process more incoming requests and this is good for throughput. However, it means that when the inner HTTP request comes back, all available threads might be processing new incoming requests and it will take time to complete the old one. The net effect is to increase the median response time and this is not something we want!</p><p id="8cb9" data-selectable-paragraph="">The .NET Core implementation is relying on the .NET ThreadPool that shares its threads with all the async/await magic and the incoming requests processing (The .NET Framework implementation is using a totally different implementation based on I/O completion ports on Windows). To solve the issue, <a href="https://twitter.com/KooKiz" target="_blank" rel="noopener nofollow">Kevin</a> <a href="https://github.com/criteo-forks/corefx/commit/dda2c4d80fd2d74b3dc7e0833e2a6794f1e290d3" target="_blank" rel="noopener nofollow">implemented a custom thread pool</a> to handle network I/O and we keep on <a href="https://github.com/criteo-forks/corefx/commit/2acc917aef47798243cc221afc9b360c86ed60b7" target="_blank" rel="noopener nofollow">optimizing it</a>. When you work on this kind of deep area of code-shared by so many different workloads, you realize that it is impossible to find the silver bullet.</p><p id="9a42" data-selectable-paragraph="">What would you do if something would go wrong in an application? On Windows, with Visual Studio, we are able to remote debug a rogue application to set a breakpoint, look at fields and properties or even have a high-level view of what threads are doing with the ParallelStacks view. In the worst case, SysInternals <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procdump" target="_blank" rel="noopener nofollow">procdump</a> allows us to take a snapshot of the application and analyze it on our developer’s machine with WinDBG or Visual Studio.</p><p id="bd60" data-selectable-paragraph="">In terms of remote debugging a Linux application, Microsoft provides an <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging-dotnet-core-linux-with-ssh?view=vs-2019" target="_blank" rel="noopener nofollow">SSH-based solution</a> to attach to a running application. However, for security reasons, it is not allowed to run an SSH server in our Criteo containers. <em>The solution was to implement the communication protocol with VsDbg for Linux on top of WebSockets.</em></p><figure><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*dBiRXngqIZIMqAyQQ1PryA.png?q=20" width="627" height="314"></p><p><img alt="Image for post" width="627" height="314"></p></div></div></div><figcaption data-selectable-paragraph="">The Remote Debugger sidecar application in the figure is proxying the commands from Visual Studio to VsDbg that acts as a Linux .NET debugger with the application. No need for risky SSH, only gentle HTTP.</figcaption></figure><p id="ad9e" data-selectable-paragraph="">Well… this was not enough. Hosting architecture (Marathon and Mesos in our case) ensures that applications in containers are running smoothly by sending requests to <em>health check</em> endpoints. If the application replies that everything is fine, then the container is safe. If the application does not answer as expected (including retries), then Marathon/Mesos kills the application and cleans up the container. Now think about what will happen if you set a breakpoint in the application and you dig into the data structures content in Visual Studio Watch/Quick Watch panels for a few minutes. Behind the scene, the debugger has to freeze all application threads, including the ones from the thread pool responsible to answer health checks. As you have probably guessed already, the debugging session will not end well.</p><p id="d346" data-selectable-paragraph="">This is why the previous figure shows an arrow between Marathon and the Remote Debugger which acts as a proxy for the application health check. When a debugging session starts (i.e. when the WebSockets code executes the protocol), the Remote Debugger knows that it should answer OK instead of calling the application endpoint that might never answer.</p><p id="496b" data-selectable-paragraph="">When remote debugging is not enough, how do you take a memory snapshot of the application? For example, if the health check does not answer after a series of retry, the Remote Debugger is calling the <a href="https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/xplat-minidump-generation.md" target="_blank" rel="noopener nofollow">createdump tool</a> installed with the .NET Core runtime to generate a dump file. Again, since the memory dump creation of 40+ GB applications could take several minutes, the same health check proxy mechanism has been put in place.</p><p id="3d22" data-selectable-paragraph="">Once the dump file is created, the remote debugger let Marathon kill the application. But wait! This is not enough because in that case, the container will be cleaned up and the disk storage will disappear. Not a problem, after a dump has been generated by createdump, the file is sent to a “Dump Navigator” application (one per data center). This application is providing a simple HTML user interface to get high-level details of the application state such as thread stacks or managed heap content.</p><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*jcwiOFsn6SN305A_f_vuxQ.png?q=20" width="1625" height="659"></p><p><img alt="Image for post" width="1625" height="659"></p></div></div></div></div></figure><p id="f212" data-selectable-paragraph="">On Windows, we have built our own set of <a href="https://github.com/chrisnas/DebuggingExtensions/blob/master/Documentation/gsose.md" target="_blank" rel="noopener nofollow">extension commands</a> that allow us to investigate memory, threadpool starvation, thread contention, or timer leak scenarios in a Windows memory dump with WinDBG as shown during this <a href="https://www.youtube.com/watch?v=biDJkJ4L_K8" target="_blank" rel="noopener nofollow">NDC Oslo conference session</a>. Note that they are also <a href="https://github.com/kevingosse/LLDB-LoadManaged" target="_blank" rel="noopener nofollow">usable with LLDB</a> on Linux. These commands are leveraging the <a href="https://github.com/microsoft/clrmd" target="_blank" rel="noopener nofollow">ClrMD Microsoft library</a> that gives you access to a live process or a memory dump in C#. Thanks to the Linux support that has been added to this library by Microsoft developers, it was easy to reuse the code into our Dump Navigator application. I definitively recommend to look at the API provided by ClrMD to automate and build your own tools. The <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/getting-another-view-on-thread-stacks-with-clrmd-2fd683642a73">long Criteo blog series</a> is a good start in addition to my <a href="https://www.youtube.com/watch?v=O8c5WwfbGFU" target="_blank" rel="noopener nofollow">DotNext conference session</a>.</p><p id="9d1f" data-selectable-paragraph="">Even though some of our main applications moved to .NET Core running on containerized Linux with a large set of monitoring/debugging tools, the journey is not over. We are now testing the preview of .NET Core 5.0 (like we did for 3.0) to check if it supports Criteo specific needs. If this is not the case, we will figure out why and find solutions to integrate into the code. Same for the tools: I have started to <a href="https://github.com/dotnet/diagnostics/pull/1376" target="_blank" rel="noopener nofollow">add our extension commands</a> to Microsoft dotnet-dump CLI tool used to analyze both Windows and Linux dumps.</p><p id="e841" data-selectable-paragraph="">At least we could say that we not only helped ourselves but also Microsoft to understand how far .NET Core could go and even the whole .NET Windows and Linux community. This is where Open Source shines!</p></div></div></section></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>