<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Life, part 32 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Life, part 32 - linksfor.dev(s)"/>
    <meta property="og:description" content="All right, after that excessively long introduction let&#x2019;s get into Gosper&#x2019;s algorithm, also known as &#x201C;HashLife&#x201D; for reasons that will become clear quite soon. Since the earl&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://ericlippert.com/2020/08/17/life-part-32/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Life, part 32</title>
<div class="readable">
        <h1>Life, part 32</h1>
            <div>Reading time: 10-12 minutes</div>
        <div>Posted here: 17 Aug 2020</div>
        <p><a href="https://ericlippert.com/2020/08/17/life-part-32/">https://ericlippert.com/2020/08/17/life-part-32/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
		<p>All right, after that excessively long introduction let’s get into Gosper’s algorithm, also known as “HashLife” for reasons that will become clear quite soon. Since the early days of this series I’ve mostly glossed over the code that does stuff like changing individual cells in order to load in a pattern, or the code that draws the UI, but Gosper’s algorithm is sufficiently different that I’m going to dig into every part of the implementation.</p>
<p>The first key point to understand about Gosper’s algorithm is that<em> it only has one data structure</em>. One way to describe it is:</p>
<p>A <strong>quad</strong> is an <strong>immutable complete tree</strong> where every non-leaf node has <strong>exactly four children</strong> which we call NE, NW, SE, SW, and every leaf is either <strong>alive</strong> or <strong>dead</strong>.</p>
<p>However the way I prefer to describe it is via a recursive definition:</p>
<ul>
<li>A 0-quad is either <strong>alive</strong> or <strong>dead</strong>.</li>
<li>An n-quad for n &gt; 0 is four (n-1) quads.</li>
</ul>
<p>Let’s write the code!</p>
<pre>sealed class Quad
{
  public const int MaxLevel = 60;</pre>
<p>Because there will be math to do on the width of the quad and I want to keep doing the math in longs instead of BigIntegers, I’m going to limit us to a 60-quad, max. Just because it is a nice round number less than the 64 bits we have in a long.</p>
<p>Now, I know what you’re thinking. <em>“Eric, if we built a monitor with a reasonable pixel density to display an entire 60-quad it would not fit inside the orbit of Pluto and it would have more mass than the sun</em>.” A 60-quad is big enough for <em>most</em> purposes. I feel good about this choice. However I want to be clear that in principle nothing is stopping us from doing math in a larger type and making arbitrarily large quads.</p>
<p>Here are our two 0-quads:</p>
<pre>public static readonly Quad Dead = new Quad();
public static readonly Quad Alive = new Quad();</pre>
<p>And for the non-0-quads, the child (n-1) quads:</p>
<pre>public Quad NW { get; }
public Quad NE { get; }
public Quad SE { get; }
public Quad SW { get; }</pre>
<p>We will need to access the level and width of a quad a lot, so I’m going to include the level in every quad. The width we can calculate on demand.</p>
<pre>public int Level { get; }
public long Width =&gt; 1L &lt;&lt; Level;</pre>
<p>We’ll need some constructors. There’s never a need to construct 0-quads because we have both of them already available as statics. For reasons which will become apparent later, we have a public static factory for the rest.</p>
<pre>public static Quad Make(Quad nw, Quad ne, Quad se, Quad sw)
<span>{
</span>  Debug.Assert(nw.Level == ne.Level);
  Debug.Assert(ne.Level == se.Level);
  Debug.Assert(se.Level == sw.Level);
  return new Quad(nw, ne, se, sw);
}
private Quad() =&gt; Level = 0;
private Quad(Quad nw, Quad ne, Quad se, Quad sw)
{
  NW = nw;
  NE = ne;
  SE = se;
  SW = sw;
  Level = nw.Level + 1;
}</pre>
<p>We’re going to need to add a bunch more stuff here, but this is the basics.</p>
<p>Again I know what you’re probably thinking: <strong>this is bonkers</strong>. In QuickLife, a 3-quad was an eight byte value type. In my astonishingly wasteful implementation so far, a single 0-quad is a reference type, so it is already eight bytes for the reference, and then it contains four more eight byte references and a four byte integer that is never more than 60. How is this ever going to work?</p>
<p>Through the power of <em>persistence</em>, that’s how. As I’ve discussed many times before on this blog, a <em>persistent</em> data structure is an immutable data structure where, because every part of it is immutable, you can safely re-use portions of it as you see fit. You therefore save on space.</p>
<p>Let’s look at an example. How could we represent this 2-quad?</p>
<p><a href="https://ericlippert.files.wordpress.com/2020/07/tjin4k0krdw6.jpg"><img data-attachment-id="7567" data-permalink="https://ericlippert.com/2020/07/20/life-part-25/tjin4k0krdw6/" data-orig-file="https://ericlippert.files.wordpress.com/2020/07/tjin4k0krdw6.jpg" data-orig-size="128,129" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="tjin4k0krdw6" data-image-description="" data-medium-file="https://ericlippert.files.wordpress.com/2020/07/tjin4k0krdw6.jpg?w=128" data-large-file="https://ericlippert.files.wordpress.com/2020/07/tjin4k0krdw6.jpg?w=128" src="https://ericlippert.files.wordpress.com/2020/07/tjin4k0krdw6.jpg?w=584" alt=""></a></p>
<p>Remember, we only have two 0-quads and we cannot make any more. The naïve way would be to make this tree:</p>
<p><a href="https://ericlippert.files.wordpress.com/2020/08/2020-07-27.png"><img loading="lazy" data-attachment-id="7828" data-permalink="https://ericlippert.com/2020/08/17/life-part-32/2020-07-27/" data-orig-file="https://ericlippert.files.wordpress.com/2020/08/2020-07-27.png" data-orig-size="675,673" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="2020-07-27" data-image-description="" data-medium-file="https://ericlippert.files.wordpress.com/2020/08/2020-07-27.png?w=300" data-large-file="https://ericlippert.files.wordpress.com/2020/08/2020-07-27.png?w=584" src="https://ericlippert.files.wordpress.com/2020/08/2020-07-27.png?w=584&amp;h=582" alt="" width="584" height="582" srcset="https://ericlippert.files.wordpress.com/2020/08/2020-07-27.png?w=584&amp;h=582 584w, https://ericlippert.files.wordpress.com/2020/08/2020-07-27.png?w=150&amp;h=150 150w, https://ericlippert.files.wordpress.com/2020/08/2020-07-27.png?w=300&amp;h=300 300w, https://ericlippert.files.wordpress.com/2020/08/2020-07-27.png 675w" sizes="(max-width: 584px) 100vw, 584px"></a></p>
<p>But because every one of these objects is immutable, we could instead make this tree, which has one fewer object allocation:</p>
<p><a href="https://ericlippert.files.wordpress.com/2020/08/2020-07-27-1.png"><img data-attachment-id="7829" data-permalink="https://ericlippert.com/2020/08/17/life-part-32/2020-07-27-1/" data-orig-file="https://ericlippert.files.wordpress.com/2020/08/2020-07-27-1.png" data-orig-size="522,650" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="2020-07-27 (1)" data-image-description="" data-medium-file="https://ericlippert.files.wordpress.com/2020/08/2020-07-27-1.png?w=241" data-large-file="https://ericlippert.files.wordpress.com/2020/08/2020-07-27-1.png?w=522" src="https://ericlippert.files.wordpress.com/2020/08/2020-07-27-1.png?w=584" alt="" srcset="https://ericlippert.files.wordpress.com/2020/08/2020-07-27-1.png 522w, https://ericlippert.files.wordpress.com/2020/08/2020-07-27-1.png?w=120 120w, https://ericlippert.files.wordpress.com/2020/08/2020-07-27-1.png?w=241 241w" sizes="(max-width: 522px) 100vw, 522px"></a></p>
<p>This is the second key insight to understanding how Gosper’s algorithm works: <strong>it uses a relatively enormous data structure for each cell, but it achieves compression through deduplication:</strong></p>
<ul>
<li>There are only two possible 0-quads, and we always re-use them.</li>
<li>There are 16 possible 1-quads. We could just make 16 objects and re-use them.</li>
<li>There are 65536 possible 2-quads, but <strong>the vast majority of them we never see in a given Life grid</strong>. The ones we do see, we often see over and over again. We could just make the ones we do see, and re-use them.</li>
</ul>
<p>The same goes for 3-quads and 4-quads and so on. There are exponentially more possibilities, and we see a smaller and smaller fraction of them in any board. <strong>Let’s memoize the Make function!</strong></p>
<p>We’re going to make heavy use of memoization in this algorithm and it will have performance implications later, so I’m going to make a relatively fully-featured memoizer whose behaviour can be analyzed:</p>
<pre>sealed class Memoizer&lt;A, R&gt;
{
  [Conditional("MEMOIZER_STATS")]
  private void RecordHit(A a)
  {
    if (hits == null)
      hits = new Dictionary&lt;A, int&gt;();
    if (hits.TryGetValue(a, out int c))
      hits[a] = c + 1;
    else
      hits.Add(a, 1);
  }
  private Dictionary&lt;A, R&gt; dict;
  private Dictionary&lt;A, int&gt; hits;
  public Func&lt;A, R&gt; MemoizedFunc { get; }
  public Memoizer(Func&lt;A, R&gt; f)
  {
    dict = new Dictionary&lt;A, R&gt;();
    MemoizedFunc = (A a) =&gt;
    {
      RecordHit(a);
      if (!dict.TryGetValue(a, out R r))
      {
        r = f(a);
        dict.Add(a, r);
      }
      return r;
    };
  }
  public void Clear(Dictionary&lt;A, R&gt; newDict = null)
  {
    dict = newDict ?? new Dictionary&lt;A, R&gt;();
    hits = null;
  }
  public int Count =&gt; dict.Count;
  public string Report() =&gt; 
    hits == null ? "" :
    string.Join("
", from v in hits.Values 
                      group v by v into g 
                      select $"{g.Key},{g.Count()}");
}</pre>
<p>The core logic of the memoizer is the same thing I’ve presented many times on this blog over the years: when you get a call, check to see if you’ve memoized the result; if you have not, call the original function and memoize the result, otherwise just return the result.</p>
<p>I’ve added a conditionally-compiled hit counter and a performance report that tells me how many items were hit how many times; that will give us some idea of the load that is being put on the memoizer, and we can then tune it.</p>
<p>Later in this series we’re going to need to “reset” a memoizer and optionally we’ll need to provided “pre-memoized” state, so I’ve added a “Clear” method that optionally takes a new dictionary to use.</p>
<p>The memoizer for the “Make” method can be static, global state so I’m going to make a helper class for the cache. (I did not need to; this could have been a static field of Quad. It was just convenient for me while I was developing the algorithm to put the memoizers in one central location.)</p>
<pre>static class CacheManager
{
  public static Memoizer&lt;(Quad, Quad, Quad, Quad), Quad&gt; MakeQuadMemoizer { get; set; }
}</pre>
<p>We’ll initialize it when we create our first Quad:</p>
<pre>static Quad()
{
  CacheManager.MakeQuadMemoizer = 
    new Memoizer&lt;(Quad, Quad, Quad, Quad), Quad&gt;(UnmemoizedMake);
}</pre>
<p>And we’ll redo the Make static factory:</p>
<pre>private static Quad UnmemoizedMake((Quad nw, Quad ne, Quad se, Quad sw) args)
{
  Debug.Assert(args.nw.Level == args.ne.Level);
  Debug.Assert(args.ne.Level == args.se.Level);
  Debug.Assert(args.se.Level == args.sw.Level);
  return new Quad(args.nw, args.ne, args.se, args.sw);
}

public static Quad Make(Quad nw, Quad ne, Quad se, Quad sw) =&gt;
  CacheManager.MakeQuadMemoizer.MemoizedFunc((nw, ne, se, sw));</pre>
<p>All right, we have memoized construction of arbitrarily large quads. A nice consequence of this fact is that <em>all quads can be compared for equality by reference equality</em>. In particular, we are going to do two things a lot:</p>
<ul>
<li>Create an arbitrarily large empty quad</li>
<li>Ask “is this arbitrarily large quad an empty quad”?</li>
</ul>
<p>We’re on a memoization roll here, so let’s keep that going and add a couple more methods to Quad, and another memoizer to the cache manager (not shown; you get how it goes.)</p>
<pre>private static Quad UnmemoizedEmpty(int level)
{
  Debug.Assert(level &gt;= 0);
  if (level == 0)
    return Dead;
  var q = Empty(level - 1);
  return Make(q, q, q, q);
}

public static Quad Empty(int level) =&gt; 
  CacheManager.EmptyMemoizer.MemoizedFunc(level);

public bool IsEmpty =&gt; this == Empty(this.Level);</pre>
<p>The unmemoized “construct an empty quad” function can be as inefficient as we like; it will only be called once per level. And now we can quickly tell if a quad is empty or not. Well, relatively quickly; we have to do a dictionary lookup and then a reference comparison.</p>
<p>What then is the size in memory of an empty 60-quad? It’s just 61 objects! The empty 1-quad refers to Dead four times, the empty 2-quad refers to the empty 1-quad four times, and so on.</p>
<p>Suppose we made a 3-quad with a single glider in the center; that’s a tiny handful of objects. If you then wanted to make a 53-quad completely filled with those, that only increases the number of objects by 50. Deduplication is super cheap with this data structure — provided that the duplicates are aligned on boundaries that are a power of two of course.</p>
<p>A major theme of this series is: find the characteristics of your problem that admit to optimization and take advantage of those in pursuit of asymptotic efficiency; don’t worry about the small stuff. Gosper’s algorithm is a clear embodiment of that principle. We’ve got a space-inefficient data structure, we’re doing possibly expensive dictionary lookups all over the show; but plainly we can compress down grids where portions frequently reoccur into a relatively small amount of memory at relatively low cost.</p>
<hr>
<p><strong>Next time on FAIC:</strong> There are lots more asymptotic wins to come, but before we get into those I want to explore some mundane concerns:</p>
<ul>
<li>If portions of the data structure are reused arbitrarily often then no portion of it can have a specific location. How are we going to find anything by its coordinates?</li>
<li>If the data structure is immutable, how do we set a dead cell to alive, if, say, we’re loading in a pattern?</li>
<li>How does the screen drawing algorithm work? Can we take advantage of the simplicity of this data structure to enable better zooming in the UI?</li>
</ul>


			</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>