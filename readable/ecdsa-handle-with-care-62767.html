<!DOCTYPE html>
<html lang="en">
<head>
    <title>
ECDSA: Handle with Care - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="ECDSA: Handle with Care - linksfor.dev(s)"/>
    <meta property="og:description" content="The elliptic curve digital signature algorithm (ECDSA) is a common digital signature scheme that we see in many of our code reviews. It has some desirable properties, but can also be very fragile. &#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - ECDSA: Handle with Care</title>
<div class="readable">
        <h1>ECDSA: Handle with Care</h1>
            <div>Reading time: 22-28 minutes</div>
        <div>Posted here: 11 Jun 2020</div>
        <p><a href="https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/">https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><article id="post-99991">
	<!-- .entry-header -->

	<div>
		<p>The elliptic curve digital signature algorithm (ECDSA) is a common digital signature scheme that we see in many of our code reviews. It has some desirable properties, but can also be very fragile. For example, <a href="https://eprint.iacr.org/2020/615.pdf">LadderLeak</a> was published just a couple of weeks ago, which demonstrated the feasibility of key recovery with a side channel attack that reveals less than one bit of the secret nonce.</p>
<div data-shortcode="caption" id="attachment_100001"><p><a href="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-24-at-4.19.11-pm.png"><img aria-describedby="caption-attachment-100001" data-attachment-id="100001" data-permalink="https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/screen-shot-2020-04-24-at-4-19-11-pm/" data-orig-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-24-at-4.19.11-pm.png" data-orig-size="1394,1244" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screen Shot 2020-04-24 at 4.19.11 PM" data-image-description="" data-medium-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-24-at-4.19.11-pm.png?w=300" data-large-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-24-at-4.19.11-pm.png?w=690" src="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-24-at-4.19.11-pm.png?w=300&amp;h=268" alt="" width="300" height="268" srcset="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-24-at-4.19.11-pm.png?w=300&amp;h=268 300w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-24-at-4.19.11-pm.png?w=600&amp;h=536 600w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-24-at-4.19.11-pm.png?w=150&amp;h=134 150w" sizes="(max-width: 300px) 100vw, 300px"></a></p><p id="caption-attachment-100001">ECDSA is fragile and must be handled with care</p></div>
<p>This post will walk you through:</p>
<ul>
<li>the various ways in which ECDSA nonce bias can be exploited</li>
<li>how simple it is to attack in practice when things go wrong, and</li>
<li>how to protect yourself.</li>
</ul>
<p>You’re probably familiar with attacks against ECDSA. Some attacks are trivial, and some involve advanced Fourier analysis and lattice math. Although these attacks can be complicated, I hope this post will demonstrate that they are easy to implement in practice. In fact, even if you don’t know anything about lattices, after reading this blog post you will be able to leverage a lattice attack to break ECDSA signatures produced with a very slightly faulty RNG using less than 100 lines of python code.</p>
<p><em>Math disclaimer: to read this post, you will need to be somewhat familiar with </em><a href="https://en.wikipedia.org/wiki/Group_(mathematics)"><em>mathematical groups</em></a><em>, recognizing that they have a binary operation and a group generator. You do not need to be an expert on elliptic curves; you just need to know that elliptic curves can be used to form a mathematical group (and, thus, have a concept of addition and scalar multiplication). Familiarity with other math concepts like lattices is helpful, but not required.</em></p>
<h2>DSA primer</h2>
<p>ECDSA is a specific form of the digital signature algorithm (DSA). DSA is a pretty common <a href="https://en.wikipedia.org/wiki/Digital_signature">digital signature scheme</a>, and is defined with three algorithms: key generation, signing, and verification. The key generation algorithm generates a private and public key; the private key is responsible for creating signatures; and the public key is responsible for verifying signatures. The signature algorithm takes as input a message and private key, and produces a signature. The verification algorithm takes as input a message, signature, and public key, and returns true or false, indicating whether the signature is valid.</p>
<p>DSA is defined over any mathematical group, and this scheme is secure as long as the <a href="https://en.wikipedia.org/wiki/Discrete_logarithm">discrete log</a> problem is hard over this group. The group typically used is the integers modulo a prime, <em>p</em>. Along with this group, we will have a group generator, <em>g</em>, and some cryptographically secure hash function, <em>H</em>. We can assume that <em>p</em>, <em>g</em>, and <em>H</em> will all be publicly known.</p>
<p>Key generation works by first randomly selecting a value, <em>x</em>, from the integers mod <em>p</em>. Then the value <em>y</em> = <em>g</em><em><sup>x</sup></em> mod <em>p</em> is computed. The private signing key is set to <em>x</em>, and the public key is <em>y</em>. The signing key must be kept secret, as this is what allows signatures to be made.</p>
<p>The signing algorithm produces a signature from a message, <em>m</em>, and the secret key, <em>x</em>. First, a random element of the group, <em>k</em>, is generated. This is known as the <em>nonce</em>, which is important when talking about attacks. Then, the values <em>r</em> = <em>g</em><em><sup>k</sup></em> mod <em>p</em> and <em>s</em> = (<em>k</em><sup>-1</sup>(<em>H</em>(<em>m</em>) + <em>xr</em>)) mod <em>p</em> are computed. Here <em>k</em><sup>-1</sup> is the group inverse, and <em>H</em>(<em>m</em>) is the result of computing the hash of <em>m</em> and interpreting the result as an integer mod <em>p</em>. The signature is defined to be the pair (<em>r</em>,<em>s</em>). (Note: if either of the <em>r</em> or <em>s</em> values equal 0, the algorithm restarts with a new <em>k</em> value).</p>
<p>The verification algorithm receives as input the signature, (<em>r</em>,<em>s</em>), the message, <em>m</em>, and the public key, <em>y</em>. Let <em>ŝ</em> = <em>s</em><sup>-1</sup>, then the algorithm outputs true if and only if <em>r</em>,<em>s</em> ≠ 0 and <em>r</em> = (<em>g</em><em><sup>H</sup></em><sup>(</sup><em><sup>m</sup></em><sup>)</sup><em>y</em><em><sup>r</sup></em>)<em><sup>ŝ</sup></em>. This verification check works because <em>g</em><em><sup>H</sup></em><sup>(</sup><em><sup>m</sup></em><sup>)</sup><em>y</em><em><sup>r</sup></em> = g<em><sup>H</sup></em><sup>(</sup><em><sup>m</sup></em><sup>)+</sup><em><sup>xr</sup></em> = <em>g</em><em><sup>ks</sup></em>, and so (<em>g</em><em><sup>H</sup></em><sup>(</sup><em><sup>m</sup></em><sup>)</sup><em>y</em><em><sup>r</sup></em>)<em><sup>ŝ</sup></em> = <em>g</em><em><sup>k</sup></em> = <em>r</em>.</p>
<p>A digital signature scheme is considered secure if it is <em>unforgeable</em>. Unforgeability has a formal cryptographic meaning, but on a high level it means that you cannot produce signatures without knowing the secret key (unless you have copied an already existing signature created from the secret key). DSA is proven to be unforgeable under the <a href="https://en.wikipedia.org/wiki/Discrete_logarithm">discrete log assumption</a>.</p>
<h2>ECDSA</h2>
<p>DSA is defined over a mathematical group. When DSA is used with the elliptic curve group as this mathematical group, we call this ECDSA. The elliptic curve group consists of elliptic curve points, which are pairs (<em>x</em>,<em>y</em>) that satisfy the equation <em>y</em><sup>2</sup> = <em>x</em><sup>3</sup> + <em>ax</em> + <em>b</em>, for some <em>a</em>,<em>b</em>. For this blog post, all you need to know is that, using elliptic curves, you can define a finite group, which means you obtain a group generator, <em>g </em>(an elliptic curve point), and addition and scalar multiplication operations just like you can with integers. Since they form a finite group, the generator, <em>g</em>, will have a finite order, <em>p</em>. This blog post will not explain or require you to know how these elliptic curve operations work, but If you’re curious, I encourage you to read more about them <a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">here</a>.</p>
<p>ECDSA works the same way as DSA, except with a different group. The secret key, <em>x</em>, will still be a random value from the integers mod <em>p</em>. Now, the public key, <em>y</em>, is still computed as <em>y</em> = <em>g</em><em><sup>x</sup></em>, except now <em>g</em> is an elliptic curve point. This means that <em>y</em> will also be an elliptic curve point (before, <em>y</em> was an integer mod <em>p</em>). Another difference occurs in how we compute the value <em>r</em>. We still generate a random nonce, <em>k</em>, as an integer mod <em>p</em>, just as before. We will compute <em>g</em><em><sup>k</sup></em>, but again, <em>g</em> is an elliptic curve point, and so <em>g</em><em><sup>k</sup></em> is as well. Therefore, we can compute (<em>x</em><em><sub>k</sub></em>,<em>y</em><em><sub>k</sub></em>) = <em>g</em><em><sup>k</sup></em>, and we set <em>r</em> = <em>x</em><em><sub>k</sub></em>. Now, the <em>s</em> value can be computed as before, and we obtain our signature (<em>r</em>,<em>s</em>), which will still be integers mod <em>p</em> as before. To verify, we need to adjust for the fact that we’ve computed <em>r</em> slightly differently. So, as before, we compute the value (<em>g</em><em><sup>H</sup></em><sup>(</sup><em><sup>m</sup></em><sup>)</sup><em>y</em><em><sup>r</sup></em>)<em><sup>ŝ</sup></em>, but now this value is an elliptic curve point, so we take the x-coordinate of this point and compare it against our <em>r</em> value.</p>
<h2>Recovering secret keys from reused nonces</h2>
<p>Now that we understand what ECDSA is and how it works, let’s demonstrate its fragility. Again, since it’s a digital signature scheme, it is imperative that the secret key is never revealed to anyone other than the message signer. However, if a signer ever releases a signature and also releases the nonce they used, an attacker can immediately recover the secret key. Say I release a signature (<em>r</em>,<em>s</em>) for a message <em>m</em>, and I accidentally reveal that I used the nonce <em>k</em>. Since <em>s</em> = (<em>k</em><sup>-1</sup>(<em>H</em>(<em>m</em>) + <em>xr</em>)), we can easily compute the secret key:</p>
<p>s = (<em>k</em><sup>-1</sup>(<em>H</em>(<em>m</em>) + <em>xr</em>))</p>
<p><em>ks</em> = <em>H(m)</em> + <em>xr</em></p>
<p><em>ks</em> – <em>H(m)</em> = <em>xr</em></p>
<p><em>x</em> = <em>r</em><sup>-1</sup>(<em>ks</em> – <em>H</em>(<em>m</em>))</p>
<p>Therefore, not only does a signer need to keep their secret key secret, but they also must keep <strong>all</strong> of their nonces they <strong>ever</strong> generate secret.</p>
<p>Even if the signer keeps <strong>every</strong> nonce secret, if they accidentally repeat a <strong>single nonce</strong> (even for different messages), the secret key can immediately be recovered as well. Let (<em>r</em>,<em>s</em><sub>1</sub>) and (<em>r</em>,<em>s</em><sub>2</sub>) be two signatures produced on messages <em>m</em><sub>1</sub> and <em>m</em><sub>2</sub> (respectively) from the same nonce, <em>k</em>—since they have the same nonce, the <em>r</em> values will be the same, so this is very easily detected by an attacker:</p>
<p><em>s</em><sub>1</sub> = <em>k</em><sup>-1</sup>(<em>H</em>(<em>m</em><sub>1</sub>) + <em>xr</em>) and <em>s</em><sub>2</sub> = <em>k</em><sup>-1</sup>(<em>H</em>(<em>m</em><sub>2</sub>) + <em>xr</em>)</p>
<p><em>s</em><sub>1</sub> – <em>s</em><sub>2</sub> = <em>k</em><sup>-1</sup>(<em>H</em>(<em>m</em><sub>1</sub>) – <em>H</em>(<em>m</em><sub>2</sub>))</p>
<p><em>k(s</em><sub>1</sub> – <em>s</em><sub>2</sub>) = <em>H</em>(<em>m</em><sub>1</sub>) – <em>H</em>(<em>m</em><sub>2</sub>)</p>
<p><em>k</em> = (<em>s</em><sub>1</sub> – <em>s</em><sub>2</sub>)<sup>-1</sup>(<em>H</em>(<em>m</em><sub>1</sub>) – <em>H</em>(<em>m</em><sub>2</sub>))</p>
<p>Once we have recovered the nonce, <em>k</em>, using the formula above, we can then recover the secret key by performing the previously described attack.</p>
<p>Let’s take a moment to digest this.</p>
<p>If a nonce for a signature is ever revealed, the secret key can immediately be recovered, which breaks our entire signature scheme. Further, if two nonces are ever repeated, regardless of what the messages are, an attacker can easily detect this and immediately recover the secret key, again breaking our entire scheme. That is pretty fragile, and these are just the easy attacks!</p>
<h2>Attacking ECDSA from leaked and biased nonces</h2>
<p>It turns out that even leaking small parts of the nonce can also be very damaging to the signature scheme. In 1999, <a href="https://www.hpl.hp.com/techreports/1999/HPL-1999-90.pdf">work by Howgrave-Graham and Smart</a> demonstrated the feasibility of using lattice attacks to break DSA from partial nonce leakage. Later, <a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=99820DCB0DCFAEF58648F81501CF7E79?doi=10.1.1.35.1538&amp;rep=rep1&amp;type=pdf">Nguyen and Shparlinski</a> improved on their work, and were able to recover secret keys on 160-bit DSA (here 160-bit refers to <em>p</em>), and later ECDSA, by knowing only three bits of each nonce from 100 signatures.</p>
<p>Later, <a href="https://eprint.iacr.org/2013/346.pdf">Mulder et al</a> were able to perform more attacks on partial nonce leakage. They used a different, Fourier transform-based attack derived from work by Bleichenbacher. Using these techniques, and knowing only five bits of each nonce from 4,000 signatures, they were able to recover secret keys from 384-bit ECDSA, and leveraged their techniques to break 384-bit ECDSA running on a smart card.</p>
<p>You may have heard of the <a href="https://minerva.crocs.fi.muni.cz/">Minerva attack</a>: Several timing side channels were leveraged to recover partial nonce leakage, and these lattice attacks were performed on a wide variety of targets. With enough signatures, they were able to successfully attack targets even when only the size of the nonce was leaked!</p>
<p>Even worse, a few weeks back, the <a href="https://eprint.iacr.org/2020/615.pdf">LadderLeak attack</a> further improved on Fourier analysis attacks, and now ECDSA secret keys can be recovered if only 1 bit of the nonce is leaked! In fact, the single bit can be leaked with probability less than 1, so attackers technically need less than 1 bit. This was leveraged to attack a very small leakage in <a href="https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Montgomery_ladder">Montgomery ladders</a> in several OpenSSL versions.</p>
<p>Again, let’s digest this. Even when only a few bits of the nonce are leaked—or further, even if only the size of the nonce is leaked—or further, if one bit of nonce is leaked—then, most of the time, the entire signature scheme can be broken by observing enough signatures. This is incredibly fragile!</p>
<p>On top of this, even if you manage to keep all of your nonces secret and never repeat a nonce, <em>and</em> you never leak any bits of your nonce to an attacker, you still aren’t fully protected! <a href="https://eprint.iacr.org/2019/023.pdf">Work by Breitner and Heninger</a> showed that a slightly faulty random number generator (RNG) can also catastrophically break your scheme by leveraging lattice attacks. Specifically, when using 256-bit ECDSA, if your RNG introduces a bias of just 4 bits in your nonce, your signature scheme can be broken completely by a lattice attack, even if we don’t know what those biased values are.</p>
<p>These attacks involve some complicated math. Like most cryptographic attacks, they formulate a series of ECDSA signatures as another hard math problem. In this case, the problem is known as the <a href="https://www.iacr.org/archive/crypto2009/56770333/56770333.pdf">Hidden Number Problem</a>. The Hidden Number Problem has been fairly widely studied by other researchers, so there are a lot of techniques and algorithms for solving it. This means that once we figure out how to mold a series of ECDSA signatures into an instance of the Hidden Number Problem, we can then apply existing techniques to find an ECDSA secret key.</p>
<h2>Breaking ECDSA from bad nonces</h2>
<p>Now, Fourier analysis, Hidden Number Problems, and lattice attacks are more complicated than your everyday cryptography, and they seem daunting. However, the fact that these attacks involve complicated math may fool some people into thinking they’re very difficult to implement in practice. This is not the case. As I mentioned in the beginning, I will teach you how to implement these attacks using fewer than 100 lines of Python code. Moreover, to perform this attack, you actually don’t need to know anything about the Hidden Number Problem or lattices. The only lattice component we need is access to the <a href="https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm#Example">LLL algorithm</a>. However, we can treat this algorithm as a black box; we don’t need to understand how it works or what it is doing.</p>
<p>We’ll be attacking signatures produced from bad nonces (i.e., bad RNG). Specifically, these nonces will have a fixed prefix, meaning their most significant bits are always the same. (The attack still works even if the fixed bits aren’t the most significant bits, but this is the easiest to follow). When using LLL, all we have to know is that we will input a matrix of values, and the algorithm will output a matrix of new values. If we use a series of ECDSA signatures to construct a matrix in a particular way, LLL will output a matrix that will allow us to recover the ECDSA private key. More specifically, because of the way we construct this matrix, one of the rows of the output of LLL will contain all of the signatures’ nonces. (It requires more complicated math to understand why, so we won’t discuss it here, but if you’re curious, see <a href="https://eprint.iacr.org/2019/023.pdf">section 4 of this paper</a>). Once we recover the nonces, we can use the basic attack described above to recover the secret key.</p>
<p>To perform the attack we’ll need access to an ECDSA and an LLL library in python. I chose <a href="https://github.com/warner/python-ecdsa">this ECDSA library</a>, which allows us to input our own nonces (so we can input nonces from bad RNGs to test our attack), and <a href="https://github.com/orisano/olll">this LLL library</a>. We’ll perform this attack on the NIST P-256 elliptic curve, beginning with the easiest form of the attack: We are given two signatures generated from only 128-bit nonces. First, we generate our signatures.</p>
<div><div id="highlighter_288994"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p></td><td><div><p><code>import</code> <code>ecdsa</code></p><p><code>import</code> <code>random</code></p><p><code>gen </code><code>=</code> <code>ecdsa.NIST256p.generator</code></p><p><code>order </code><code>=</code> <code>gen.order()</code></p><p><code>secret </code><code>=</code> <code>random.randrange(</code><code>1</code><code>,order)</code></p><p><code>pub_key </code><code>=</code> <code>ecdsa.ecdsa.Public_key(gen, gen </code><code>*</code> <code>secret)</code></p><p><code>priv_key </code><code>=</code> <code>ecdsa.ecdsa.Private_key(pub_key, secret)</code></p><p><code>nonce1 </code><code>=</code> <code>random.randrange(</code><code>1</code><code>, </code><code>2</code><code>*</code><code>*</code><code>127</code><code>)</code></p><p><code>nonce2 </code><code>=</code> <code>random.randrange(</code><code>1</code><code>, </code><code>2</code><code>*</code><code>*</code><code>127</code><code>)</code></p><p><code>msg1 </code><code>=</code> <code>random.randrange(</code><code>1</code><code>, order)</code></p><p><code>msg2 </code><code>=</code> <code>random.randrange(</code><code>1</code><code>, order)</code></p><p><code>sig1 </code><code>=</code> <code>priv_key.sign(msg1, nonce1)</code></p><p><code>sig2 </code><code>=</code> <code>priv_key.sign(msg2, nonce2)</code></p></div></td></tr></tbody></table></div></div>
<p>Now that we have our signatures, we need to craft the matrix we’ll input into the LLL algorithm:</p>
<div>
<figure>
<div data-shortcode="caption" id="attachment_100002"><p><a href="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-2.32.39-pm.png"><img aria-describedby="caption-attachment-100002" data-attachment-id="100002" data-permalink="https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/screen-shot-2020-04-25-at-2-32-39-pm/" data-orig-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-2.32.39-pm.png" data-orig-size="428,322" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screen Shot 2020-04-25 at 2.32.39 PM" data-image-description="" data-medium-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-2.32.39-pm.png?w=300" data-large-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-2.32.39-pm.png?w=428" src="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-2.32.39-pm.png?w=690" alt="" srcset="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-2.32.39-pm.png 428w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-2.32.39-pm.png?w=150 150w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-2.32.39-pm.png?w=300 300w" sizes="(max-width: 428px) 100vw, 428px"></a></p><p id="caption-attachment-100002">Matrix that we will input into the LLL algorithm</p></div></figure>
</div>
<p>Here N is the order of NIST P-256 (ord in code snippet above), B is the upper bound on the size of our nonces (which will be 2<sup>128</sup> in this example, because both nonces are only 128 bits in size); m<sub>1</sub> and m<sub>2</sub> are the two random messages; and (r<sub>1</sub>, s<sub>1</sub>) and (r<sub>2</sub>,s<sub>2</sub>) are the two signature pairs. In our python code, our matrix will look like this (here modular_inv is a function for computing the inverse mod N):</p>
<div><div id="highlighter_715786"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></td><td><div><p><code>r1 </code><code>=</code> <code>sig1.r</code></p><p><code>s1_inv </code><code>=</code> <code>modular_inv(sig1.s, order)</code></p><p><code>r2 </code><code>=</code> <code>sig2.r</code></p><p><code>s2_inv </code><code>=</code> <code>modular_inv(sig2.s, order)</code></p><p><code>matrix </code><code>=</code> <code>[[order, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>], [</code><code>0</code><code>, order, </code><code>0</code><code>, </code><code>0</code><code>],</code></p><p><code>[r1</code><code>*</code><code>s1_inv, r2</code><code>*</code><code>s2_inv, (</code><code>2</code><code>*</code><code>*</code><code>128</code><code>) </code><code>/</code> <code>order, </code><code>0</code><code>],</code></p><p><code>[msg1</code><code>*</code><code>s1_inv, msg2</code><code>*</code><code>s2_inv, </code><code>0</code><code>, </code><code>2</code><code>*</code><code>*</code><code>128</code><code>]]</code></p></div></td></tr></tbody></table></div></div>
<p>Now we’ll input this matrix into the black-box LLL algorithm, which will return a new matrix to us. For reasons that don’t matter here, one of the rows of this returned matrix will contain the nonces used to generate the two signatures. If we knew more about what the algorithm is actually doing, we could probably predict where the nonce is going to be. But since we don’t care about the details, we are just going to check every row in the returned matrix to see if we can find the secret key. Remember, we already showed how to recover the private key once we have the nonce, <em>k</em>. Specifically, we compute <em>r</em><sup>-1</sup>(<em>ks</em> – <em>H</em>(<em>m</em>)). An attacker in the real world would have access to the public key corresponding to these signatures. Therefore, to determine if we have found the correct private key, we will compute its corresponding public key and compare it against the known public key. The attack will look like this:</p>
<div><div id="highlighter_248304"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p></td><td><div><p><code>import</code> <code>olll</code></p><p><code>new_matrix </code><code>=</code> <code>olll.reduction(matrix, </code><code>0.75</code><code>)</code></p><p><code>r1_inv </code><code>=</code> <code>modular_inv(sig1.r, order)</code></p><p><code>s1 </code><code>=</code> <code>sig1.s</code></p><p><code>for</code> <code>row </code><code>in</code> <code>new_matrix:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>potential_nonce_1 </code><code>=</code> <code>row[</code><code>0</code><code>]</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>potential_priv_key </code><code>=</code> <code>r1_inv </code><code>*</code> <code>((potential_nonce_1 </code><code>*</code> <code>s1) </code><code>-</code> <code>msg1)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>ecdsa.ecdsa.Public_key(gen, gen </code><code>*</code> <code>potential_priv_key) </code><code>=</code><code>=</code> <code>pub_key:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(</code><code>"found private key!"</code><code>)</code></p></div></td></tr></tbody></table></div></div>
<p>I should mention that there is a noticeable failure rate for this basic attack. If you run the code presented to you, you will notice this as well. But again, for the purposes of this post, don’t worry about these specifics. Also, this failure rate should decrease if you perform this same attack with more signatures.</p>
<p>Hopefully at this point I’ve shown why these attacks aren’t so complicated. We were able to recover the secret key from just two signatures, and we didn’t do anything overly complicated. That said, some of you would probably argue that being able to attack signatures with only 128-bit nonces isn’t that interesting. So let’s move on to more realistic attacks.</p>
<h2>Exploiting real-world ECDSA bugs</h2>
<p>You may have heard of a <a href="https://www.yubico.com/support/security-advisories/ysa-2019-02/#technical-details">recent bug in the randomness generated in Yubikeys</a>. Essentially, bad randomness caused as many as 80 bits of the nonce to be fixed to the same value. Attacking this real-world bug will not be much more difficult than the attack we just performed above, except we don’t know what the fixed 80-bit values are (in the previous example, we knew the fixed 128 bits were all set to 0). To overcome this, we need to add a trick to our attack.</p>
<p>Imagine we receive a collection of signatures whose nonces have 80 fixed bits. For ease of explanation, we will assume these 80 bits are the most significant bits (the attack is still feasible if this is not the case; you simply shift the fixed bits to the most significant bits by multiplying each signature by a power of 2). Even though we don’t know what these 80 bits are, we know that if we subtract any two nonces, the 80 most significant bits of their difference will all be zeros. Therefore, we are going to perform the same attack as above, except with our signature values subtracted. Specifically, given a set of <em>n</em> signatures and messages, we will build the following matrix:</p>
<div>
<figure>
<div data-shortcode="caption" id="attachment_100003"><p><a href="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-7.22.01-pm.png"><img aria-describedby="caption-attachment-100003" data-attachment-id="100003" data-permalink="https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/screen-shot-2020-04-25-at-7-22-01-pm/" data-orig-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-7.22.01-pm.png" data-orig-size="762,384" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screen Shot 2020-04-25 at 7.22.01 PM" data-image-description="" data-medium-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-7.22.01-pm.png?w=300" data-large-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-7.22.01-pm.png?w=690" src="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-7.22.01-pm.png?w=690&amp;h=348" alt="" width="690" height="348" srcset="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-7.22.01-pm.png?w=690&amp;h=348 690w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-7.22.01-pm.png?w=150&amp;h=76 150w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-7.22.01-pm.png?w=300&amp;h=151 300w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-25-at-7.22.01-pm.png 762w" sizes="(max-width: 690px) 100vw, 690px"></a></p><p id="caption-attachment-100003">Matrix that we will input into the LLL algorithm when the nonce bias is unknown</p></div></figure>
</div>
<p>This time, we will again input this matrix into LLL and receive a new matrix back. However, since we subtracted the <em>n</em><sup>th</sup> value from every entry in this matrix, instead of receiving a row full of nonces, we will actually receive a row with the difference between each nonce and the <em>n</em><sup>th</sup> nonce. In other words, the matrix returned from LLL will give us the value <em>k</em><em><sub>1</sub></em><em> – k</em><em><sub>n</sub></em>, the difference between the nonces for signatures 1 and <em>n</em>. It takes some algebraic manipulation, but we can still recover the secret key from this value using the following formula:</p>
<p><em>s</em><sub>1</sub> = <em>k<sub>1</sub></em><sup>-1</sup>(<em>m</em><sub>1</sub> + <em>xr<sub>1</sub></em>) and <em>s</em><sub>n</sub> = <em>k<sub>n</sub></em><sup>-1</sup>(<em>m</em><sub>n</sub> + <em>xr<sub>n</sub></em>)</p>
<p><em>s</em><sub>1</sub><em>k</em><sub>1</sub> = <em>m</em><sub>1</sub> + <em>xr<sub>1</sub></em> and <em>s</em><sub>n</sub><em>k<sub>n</sub></em> = <em>m</em><sub>n</sub> + <em>xr<sub>n</sub></em></p>
<p><em> k</em><sub>1</sub> = <em>s<sub>1</sub></em><sup>-1</sup>(<em>m</em><sub>1</sub> + <em>xr<sub>1</sub></em>) and <em>k</em><sub>n</sub> = <em>s<sub>n</sub></em><sup>-1</sup>(<em>m</em><sub>n</sub> + <em>xr<sub>n</sub></em>)</p>
<p><em>k</em><sub>1</sub> – <em>k</em><sub>n</sub> = <em>s</em><sub>1</sub><sup>-1</sup>(<em>m</em><sub>1</sub> + <em>xr<sub>1</sub></em>) – <em>s<sub>n</sub></em><sup>-1</sup>(<em>m</em><sub>n</sub> + <em>xr<sub>n</sub></em>)</p>
<p><em>s</em><sub>1</sub><em>s<sub>n</sub>(k</em><sub>1</sub> – <em>k</em><sub>n</sub>) = <em>s</em><sub>n</sub>(<em>m</em><sub>1</sub> + <em>xr<sub>1</sub></em>) – <em>s</em><sub>1</sub>(<em>m</em><sub>n</sub> + <em>xr<sub>n</sub></em>)</p>
<p><em>s</em><sub>1</sub><em>s<sub>n</sub>(k</em><sub>1</sub> – <em>k</em><sub>n</sub>) = <em>xs<sub>n</sub>r</em><sub>1</sub><em> – xs</em><sub>1</sub><em>r<sub>n</sub> + s<sub>n</sub>m</em><sub>1</sub><em> – s</em><sub>1</sub><em>m<sub>n</sub></em></p>
<p><em>x</em>(<em>s</em><sub>1</sub><em>r</em><sub>n</sub><em> – s</em><sub>n</sub><em>r</em><sub>1</sub>) =<em> s<sub>n</sub>m</em><sub>1</sub><em> – s</em><sub>1</sub><em>m<sub>n</sub></em> – <em><sub>&nbsp;</sub>s</em><sub>1</sub><em>s<sub>n</sub>(k</em><sub>1</sub> – <em>k</em><sub>n</sub>)</p>
<p>Secret key = x = (r<sub>n</sub>s<sub>1</sub> – r<sub>1</sub>s<sub>n</sub>)<sup>-1</sup> (s<sub>n</sub>m<sub>1</sub> – s<sub>1</sub>m<sub>n</sub> – s<sub>1</sub>s<sub>n</sub>(k<sub>1</sub> – k<sub>n</sub>))</p>
<p>With all of that context, let’s exploit the Yubikey bug. If signatures are produced from nonces with 80 fixed bits, we only need five signatures to recover the secret key. We will build the matrix above with <em>n</em> = 6 to reduce the error rate:</p>
<div><div id="highlighter_815262"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p></td><td><div><p><code>yubikey_fixed_prefix </code><code>=</code> <code>random.randrange(</code><code>2</code><code>*</code><code>*</code><code>176</code><code>, order)</code></p><p><code>msgs </code><code>=</code> <code>[random.randrange(</code><code>1</code><code>, order) </code><code>for</code> <code>i </code><code>in</code> <code>range</code><code>(</code><code>6</code><code>)]</code></p><p><code>nonces </code><code>=</code> <code>[random.randrange(</code><code>1</code><code>, </code><code>2</code><code>*</code><code>*</code><code>176</code><code>) </code><code>+</code> <code>yubikey_fixed_prefix </code><code>for</code> <code>i </code><code>in</code> <code>range</code><code>(</code><code>6</code><code>)]</code></p><p><code>sigs </code><code>=</code> <code>[priv_key.sign(msgs[i],nonces[i]) </code><code>for</code> <code>i </code><code>in</code> <code>range</code><code>(</code><code>6</code><code>)]</code></p><p><code>matrix </code><code>=</code> <code>[[order, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>],</code></p><p><code>[</code><code>0</code><code>, order, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>],</code></p><p><code>[</code><code>0</code><code>, </code><code>0</code><code>, order, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>],</code></p><p><code>[</code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>, order, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>],</code></p><p><code>[</code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>, </code><code>0</code><code>, order, </code><code>0</code><code>, </code><code>0</code><code>]]</code></p><p><code>row, row2 </code><code>=</code> <code>[], []</code></p><p><code>[msgn, rn, sn] </code><code>=</code> <code>[msgs[</code><code>-</code><code>1</code><code>], sigs[</code><code>-</code><code>1</code><code>].r, sigs[</code><code>-</code><code>1</code><code>].s]</code></p><p><code>rnsn_inv </code><code>=</code> <code>rn </code><code>*</code> <code>modular_inv(sn, order)</code></p><p><code>mnsn_inv </code><code>=</code> <code>msgn </code><code>*</code> <code>modular_inv(sn, order)</code></p><p><code>for</code> <code>i </code><code>in</code> <code>range</code><code>(</code><code>5</code><code>):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>row.append((sigs[i].r </code><code>*</code> <code>modular_inv(sigs[i].s, order)) </code><code>-</code> <code>rnsn_inv)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>row2.append((msgs[i] </code><code>*</code> <code>modular_inv(sigs[i].s, order)) </code><code>-</code> <code>mnsn_inv)</code></p><p><code>row.append((</code><code>2</code><code>*</code><code>*</code><code>176</code><code>) </code><code>/</code> <code>order)</code></p><p><code>row.append(</code><code>0</code><code>)</code></p><p><code>row2.append(</code><code>0</code><code>)</code></p><p><code>row2.append(</code><code>2</code><code>*</code><code>*</code><code>176</code><code>)</code></p><p><code>matrix.append(row)</code></p><p><code>matrix.append(row2)</code></p><p><code>new_matrix </code><code>=</code> <code>olll.reduction(matrix, </code><code>0.75</code><code>)</code></p><p><code>for</code> <code>row </code><code>in</code> <code>new_matrix:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>potential_nonce_diff </code><code>=</code> <code>row[</code><code>0</code><code>]</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>potential_priv_key </code><code>=</code> <code>(sn </code><code>*</code> <code>msgs[</code><code>0</code><code>]) </code><code>-</code> <code>(sigs[</code><code>0</code><code>].s </code><code>*</code> <code>msgn) </code><code>-</code> <code>(sigs[</code><code>0</code><code>].s </code><code>*</code> <code>sn </code><code>*</code> <code>potential_nonce_diff)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>potential_priv_key </code><code>*</code><code>=</code> <code>modular_inv((rn </code><code>*</code> <code>sigs[</code><code>0</code><code>].s) </code><code>-</code> <code>(sigs[</code><code>0</code><code>].r </code><code>*</code> <code>sn), order)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>ecdsa.ecdsa.Public_key(gen, gen </code><code>*</code> <code>potential_priv_key) </code><code>=</code><code>=</code> <code>pub_key:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(</code><code>"found private key!"</code><code>)</code></p></div></td></tr></tbody></table></div></div>
<p>That’s it! We just exploited a real-world bug in about 50 lines of python.</p>
<p>Some might further argue that although this was an actual bug, systems producing 80 fixed bits are rare. However, this attack can be much more powerful than shown in this one example! For 256-bit elliptic curves, this attack will work even if only 4 bits of the nonce are fixed. Moreover, the attack does not become more complicated to implement. You simply need to increase the dimension of your lattice—i.e., in the matrix figure above, just increase the value of <em>n</em> and repeat the attack—nothing else! This will increase the running time of your attack, but not the complexity to implement. You could copy that code snippet and recover ECDSA secret keys generated from nonces with as little as 4 bits of bias. On top of that, the attack against nonce leakage is a similar level of difficulty.</p>
<p>Hopefully, I’ve now convinced you of the fragility of ECDSA and how easily it can be broken in practice when things go wrong.</p>
<p>By the way, some of you may be wondering how we determine the value <em>n</em>. Remember, <em>n</em> is the number of signatures we need to recover the secret key. When the nonce had the first 128 bits fixed to 0, this value was 2 (this value is 3 when 128 bits are fixed, but we don’t know to what value they are fixed). When the nonce had 80 randomly fixed bits, this value was 5. If you consult the relevant publications around these attacks, you can find the exact formula and derivation of this value for a given number of fixed bits. For simplicity, I derived these values empirically by attempting this attack with different numbers of signatures on different amounts of fixed bits. I’ve compiled the results into the figure below:</p>
<div>
<figure>
<div data-shortcode="caption" id="attachment_100005"><p><a href="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png"><img aria-describedby="caption-attachment-100005" data-attachment-id="100005" data-permalink="https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/screen-shot-2020-04-27-at-9-44-49-pm/" data-orig-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png" data-orig-size="1600,695" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Screen Shot 2020-04-27 at 9.44.49 PM" data-image-description="" data-medium-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png?w=300" data-large-file="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png?w=690" src="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png?w=690&amp;h=300" alt="" width="690" height="300" srcset="https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png?w=690&amp;h=300 690w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png?w=1380&amp;h=600 1380w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png?w=150&amp;h=65 150w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png?w=300&amp;h=130 300w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png?w=768&amp;h=334 768w, https://trailofbits.files.wordpress.com/2020/06/screen-shot-2020-04-27-at-9.44.49-pm.png?w=1024&amp;h=445 1024w" sizes="(max-width: 690px) 100vw, 690px"></a></p><p id="caption-attachment-100005">The number of signatures required to use this attack for a given number of fixed nonce bits (derived empirically)</p></div></figure>
</div>
<h2>Protecting your ECDSA signatures</h2>
<p>If ECDSA is so fragile, how can users protect themselves? Ideally, we recommend that you use <a href="https://en.wikipedia.org/wiki/EdDSA">EdDSA</a> instead of ECDSA, which handles nonce generation much more safely by eliminating the use of RNGs. Further, Ed25519, which is EdDSA over <a href="https://en.wikipedia.org/wiki/Curve25519">Curve25519</a>, is designed to overcome the side-channel attacks that have targeted ECDSA, and it is currently being <a href="https://csrc.nist.gov/publications/detail/fips/186/5/draft">standardized by NIST</a>.</p>
<p>If you’re required to use ECDSA, proceed with caution and handle with care! ECDSA is fragile, but it is not broken. As we saw, it is imperative that nonces used for ECDSA signatures are never repeated, never revealed (even partially), and generated safely.</p>
<p>To protect yourself from nonce leakage, the mitigation strategy is to write the implementation to operate in “constant time.” However, guaranteeing this can be very difficult, <a href="https://eprint.iacr.org/2020/615.pdf">as we saw with OpenSSL</a>. For instance, code can appear to be constant time, but then an optimizing compiler can introduce non-constant time behavior. Further, some assembly instructions are constant time in some architectures or processor models, but not in others. (Read more about this <a href="https://www.chosenplaintext.ca/articles/beginners-guide-constant-time-cryptography.html">here</a>).</p>
<p>Another technique for mitigating nonce leakage is known as <a href="https://eprint.iacr.org/2015/801.pdf">blinding</a>, where random numbers are included in your arithmetic to randomize timing information. However, evaluating the security of your blinding implementation can be tricky, and slightly weak blinding schemes can be problematic.</p>
<p>With both of these mitigations, keep in mind that the amount of nonce leakage is on the order of a single bit, so even the slightest changes by an optimizing compiler or the slightest leakage from your blinding technique can be catastrophic to your signature scheme.</p>
<p>To ensure that nonces are generated safely, most people recommend using <a href="https://tools.ietf.org/html/rfc6979">RFC 6979</a>, which specifies a way to securely generate nonces deterministically (i.e., without an RNG), using the message and secret key as entropy. This protocol to generate nonces eliminates the problem of bad RNGs, which can be problematic for devices such as Yubikeys where generating randomness securely is difficult. The signature scheme EdDSA actually uses a similar nonce generation method by default to avoid bad RNGs.</p>
<p>If you are using ECDSA in your system, I encourage you to consider all of those recommendations. Hopefully, with enough care, your signature scheme won’t end up like this:</p>
<div>
<figure>
<div data-shortcode="caption" id="attachment_100006"><p><a href="https://trailofbits.files.wordpress.com/2020/06/pasted-image-0.png"><img aria-describedby="caption-attachment-100006" data-attachment-id="100006" data-permalink="https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/pasted-image-0-4/" data-orig-file="https://trailofbits.files.wordpress.com/2020/06/pasted-image-0.png" data-orig-size="579,380" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pasted image 0" data-image-description="" data-medium-file="https://trailofbits.files.wordpress.com/2020/06/pasted-image-0.png?w=300" data-large-file="https://trailofbits.files.wordpress.com/2020/06/pasted-image-0.png?w=579" src="https://trailofbits.files.wordpress.com/2020/06/pasted-image-0.png?w=690" alt="" srcset="https://trailofbits.files.wordpress.com/2020/06/pasted-image-0.png 579w, https://trailofbits.files.wordpress.com/2020/06/pasted-image-0.png?w=150 150w, https://trailofbits.files.wordpress.com/2020/06/pasted-image-0.png?w=300 300w" sizes="(max-width: 579px) 100vw, 579px"></a></p><p id="caption-attachment-100006">This is what happens to ECDSA when you don’t generate your nonces safely</p></div></figure>
</div>
<p>We’re always experimenting and developing tools to help you work faster and smarter. Need help with your next project? <a href="https://www.trailofbits.com/contact/">Contact us</a>!</p>
			</div><!-- .entry-content -->

	
</article></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>