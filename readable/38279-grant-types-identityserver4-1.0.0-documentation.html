<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Grant Types &#x2014; IdentityServer4 1.0.0 documentation -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Grant Types — IdentityServer4 1.0.0 documentation</h1><div><div class="section" id="grant-types"><p>The OpenID Connect and OAuth 2.0 specifications define so-called grant types (often also called flows - or protocol flows).
Grant types specify how a client can interact with the token service.</p><p>You need to specify which grant types a client can use via the <code class="docutils literal notranslate"><span class="pre">AllowedGrantTypes</span></code> property on the <code class="docutils literal notranslate"><span class="pre">Client</span></code> configuration.
This allows locking down the protocol interactions that are allowed for a given client.</p><p>A client can be configured to use more than a single grant type (e.g. Authorization Code flow for user centric operations and client credentials for server to server communication).
The <code class="docutils literal notranslate"><span class="pre">GrantTypes</span></code> class can be used to pick from typical grant type combinations:</p><div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Client</span><span class="p">.</span><span class="n">AllowedGrantTypes</span><span class="p">=</span><span class="n">GrantTypes</span><span class="p">.</span><span class="n">CodeAndClientCredentials</span><span class="p">;</span></pre></div></div><p>You can also specify the grant types list manually:</p><div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Client</span><span class="p">.</span><span class="n">AllowedGrantTypes</span><span class="p">=</span><span class="p">{</span><span class="n">GrantType</span><span class="p">.</span><span class="n">Code</span><span class="p">,</span><span class="n">GrantType</span><span class="p">.</span><span class="n">ClientCredentials</span><span class="p">,</span><span class="s">"my_custom_grant_type"</span><span class="p">};</span></pre></div></div><p>While IdentityServer supports all standard grant types, you really only need to know two of them for common application scenarios.</p><div class="section" id="machine-to-machine-communication"><h2>Machine to Machine Communication<a class="headerlink" href="#machine-to-machine-communication" title="Permalink to this headline">¶</a></h2><p>This is the simplest type of communication. Tokens are always requested on behalf of a client, no interactive user is present.</p><p>In this scenario, you send a token request to the token endpoint using the <code class="docutils literal notranslate"><span class="pre">client</span><span class="pre">credentials</span></code> grant type.
The client typically has to authenticate with the token endpoint using its client ID and secret.</p><p>See the <a class="reference internal" href="../quickstarts/1_client_credentials.html#refclientcredentialsquickstart"><span class="std std-ref">Client Credentials Quick Start</span></a> for a sample how to use it.</p></div><div class="section" id="interactive-clients"><h2>Interactive Clients<a class="headerlink" href="#interactive-clients" title="Permalink to this headline">¶</a></h2><p>This is the most common type of client scenario: web applications, SPAs or native/mobile apps with interactive users.</p><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">Feel free to skip to the summary, if you don’t care about all the technical details.</p></div><p>For this type of clients, the <code class="docutils literal notranslate"><span class="pre">authorization</span><span class="pre">code</span></code> flow was designed. That flow consists of two physical operations:</p><ul class="simple"><li>a front-channel step via the browser where all “interactive” things happen, e.g. login page, consent etc. This step results in an authorization code that represents the outcome of the front-channel operation.</li><li>a back-channel step where the authorization code from step 1 gets exchanged with the requested tokens. Confidential clients need to authenticate at this point.</li></ul><p>This flow has the following security properties:</p><ul class="simple"><li>no data (besides the authorization code which is basically a random string) gets leaked over the browser channel</li><li>authorization codes can only be used once</li><li>the authorization code can only be turned into tokens when (for confidential clients - more on that later) the client secret is known</li></ul><p>This sounds all very good - still there is one problem called <a class="reference external" href="https://nat.sakimura.org/2016/01/25/cut-and-pasted-code-attack-in-oauth-2-0-rfc6749/">code substitution attack</a>.
There are two modern mitigation techniques for this:</p><p><strong>OpenID Connect Hybrid Flow</strong></p><p>This uses a response type of <code class="docutils literal notranslate"><span class="pre">code</span><span class="pre">id_token</span></code> to add an additional identity token to the response. This token is signed and protected against substitution.
In addition it contains the hash of the code via the <code class="docutils literal notranslate"><span class="pre">c_hash</span></code> claim. This allows checking that you indeed got the right code (experts call this a detached signature).</p><p>This solves the problem but has the following down-sides:</p><ul class="simple"><li>the <code class="docutils literal notranslate"><span class="pre">id_token</span></code> gets transmitted over the front-channel and might leak additional (personal identifiable) data</li><li>all the mitigitation steps (e.g. crypto) need to be implemented by the client. This results in more complicated client library implementations.</li></ul><p><strong>RFC 7636 - Proof Key for Code Exchange (PKCE)</strong></p><p>This essentially introduces a per-request secret for code flow (please read up on the details <a class="reference external" href="https://tools.ietf.org/html/rfc7636">here</a>).
All the client has to implement for this, is creating a random string and hashing it using SHA256.</p><p>This also solves the substition problem, because the client can prove that it is the same client on front and back-channel, and has the following additional advantages:</p><ul class="simple"><li>the client implementation is very simple compared to hybrid flow</li><li>it also solves the problem of the absence of a static secret for public clients</li><li>no additional front-channel response artifacts are needed</li></ul><p><strong>Summary</strong></p><p>Interactive clients should use an authorization code-based flow. To protect against code substitution, either hybrid flow or PKCE should be used.
If PKCE is available, this is the simpler solution to the problem.</p><p>PKCE is already the official recommendation for <a class="reference external" href="https://tools.ietf.org/html/rfc8252#section-6">native</a> applications
and <a class="reference external" href="https://tools.ietf.org/html/draft-ietf-oauth-browser-based-apps-03#section-4">SPAs</a> - and with the release of ASP.NET Core 3 also by default supported in the OpenID Connect handler as well.</p><p>This is how you would configure an interactive client:</p><div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="n">client</span><span class="p">=</span><span class="k">new</span><span class="n">Client</span><span class="p">{</span><span class="n">ClientId</span><span class="p">=</span><span class="s">"..."</span><span class="p">,</span><span class="c1">// set client secret for confidential clients</span><span class="n">ClientSecret</span><span class="p">=</span><span class="p">{</span><span class="p">...</span><span class="p">},</span><span class="c1">// ...or turn off for public clients</span><span class="n">RequireClientSecret</span><span class="p">=</span><span class="k">false</span><span class="p">,</span><span class="n">AllowedGrantTypes</span><span class="p">=</span><span class="n">GrantTypes</span><span class="p">.</span><span class="n">Code</span><span class="p">,</span><span class="n">RequirePkce</span><span class="p">=</span><span class="k">true</span><span class="p">};</span></pre></div></div></div><div class="section" id="interactive-clients-without-browsers-or-with-constrained-input-devices"><h2>Interactive clients without browsers or with constrained input devices<a class="headerlink" href="#interactive-clients-without-browsers-or-with-constrained-input-devices" title="Permalink to this headline">¶</a></h2><p>This grant type is detailed <a class="reference external" href="https://tools.ietf.org/html/rfc8628">RFC 8628</a>.</p><p>This flow outsources user authentication and consent to an external device (e.g. a smart phone).
It is typically used by devices that don’t have proper keyboards (e.g. TVs, gaming consoles…) and can request both identity and API resources.</p></div><div class="section" id="custom-scenarios"><h2>Custom scenarios<a class="headerlink" href="#custom-scenarios" title="Permalink to this headline">¶</a></h2><p>Extension grants allow extending the token endpoint with new grant types. See <a class="reference internal" href="extension_grants.html#refextensiongrants"><span class="std std-ref">this</span></a> for more details.</p></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>