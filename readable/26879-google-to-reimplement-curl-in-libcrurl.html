<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Google to reimplement curl in libcrurl -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Google to reimplement curl in libcrurl</h1><div><div class="entry-content"><p>Not the entire thing, just “a subset”. It’s not stated very clearly exactly what that subset is but the easy interface is mentioned in the <a href="https://crbug.com/973603">Chrome bug about this project</a>.</p><h2>What?</h2><p>The Chromium bug states that they will create a library of their own (named libcrurl) that will offer (parts of) the libcurl API and be implemented using <a href="https://chromium.googlesource.com/chromium/src/+/master/components/cronet/">Cronet</a>.</p><p>Cronet is the networking stack of Chromium put into a library for use on mobile. The same networking stack that is used in the Chrome browser.</p><p>There’s also a mentioned possibility that “if this works”, they might also create “crurl” tool which is then their own version of the curl tool but using their own library. In itself is a pretty strong indication that their API will not be fully compatible, as if it was they could just use the existing curl tool…</p><h2>Why?</h2><blockquote class="wp-block-quote"><p>“Implementing libcurl using Cronet would allow developers to take advantage of the utility of the Chrome Network Stack, without having to learn a new interface and its corresponding workflow. This would ideally increase ease of accessibility of Cronet, and overall improve adoption of Cronet by first-party or third-party applications.”</p></blockquote><p>Logically, I suppose they then also hope that 3rd party applications can switch to this library (without having to change to another API or adapt much) and gain something and that new applications can use this library without having to learn a new API. Stick to the old established libcurl API.</p><h2>How?</h2><p>By throwing a lot of man power on it. As the primary author and developer of the libcurl API and the libcurl code, I assume that Cronet works quite differently than libcurl so there’s going to be quite a lot of wrestling of data and code flow to make this API work on that code.</p><p>The libcurl API is also very versatile and is an API that has developed over a period of almost 20 years so there’s a lot of functionality, a lot of options and a lot of subtle behavior that may or may not be easy or straight forward to mimic.</p><p>The <a href="https://chromium-review.googlesource.com/c/chromium/src/+/1664790">initial commit</a> imported the headers and examples from the curl 7.65.1 release.</p><h2>Will it work?</h2><p>Getting basic functionality for a small set of use cases should be simple and straight forward. But even if they limit the subset to number of functions and libcurl options, making them work exactly as we have them documented will be hard and time consuming.</p><p>I don’t think applications will be able to arbitrarily use either library for a very long time, if ever. libcurl has 80 public functions and <a href="https://curl.haxx.se/libcurl/c/curl_easy_setopt.html">curl_easy_setopt</a> alone takes 268 different options!</p><p>Given enough time and effort they can certainly make this work to some degree.</p><h2>Releases?</h2><p>There’s no word on API/ABI stability or how they intend to ship or version their library. It is all very early still. I suppose we will learn more details as and if this progresses.</p><h2>Flattered?</h2><p>I think this move underscores that libcurl has succeeded in becoming an almost defacto standard for network transfers.</p><p>There’s this saying about imitation and flattery but getting competition from a giant like Google is a little intimidating. If they just put <em>two</em> paid engineers on their project they already have more dedicated man power than the original libcurl project does…</p><h2>How will it affect curl?</h2><p>First off: this doesn’t seem to actually exist for real yet so it is still very early.</p><p>Ideally the team working on this from Google’s end finds and fixes issues in our code and API so curl improves. Ideally this move makes more users aware of libcurl and its API and we make it even easier for users and applications in the world to do safe and solid Internet transfers. If the engineers are magically good, they offer a library that can do things <em>better</em> than libcurl can, using the same API so application authors can just pick the library they find work the best. Let the best library win!</p><p>Unfortunately I think introducing half-baked implementations of the API will cause users grief since it will be hard for users to understand what API it is and how they differ.</p><p>Since I don’t think “libcrurl” will be able to offer a compatible API without a considerable effort, I think applications will need to be aware of which of the APIs they work with and then we have a “split world” to deal with for the foreseeable future and that will cause problems, documentation problems and users misunderstanding or just getting things wrong.</p><p>Their naming will possibly also be reason for confusion since “libcrurl” and “crurl” look so much like typos of the original names.</p><figure class="wp-block-image"><img src="https://daniel.haxx.se/blog/wp-content/uploads/2016/04/good_curl_logo-1200x459.png" alt="" class="wp-image-8936" srcset="https://daniel.haxx.se/blog/wp-content/uploads/2016/04/good_curl_logo-1200x459.png 1200w, https://daniel.haxx.se/blog/wp-content/uploads/2016/04/good_curl_logo-200x76.png 200w, https://daniel.haxx.se/blog/wp-content/uploads/2016/04/good_curl_logo-450x172.png 450w, https://daniel.haxx.se/blog/wp-content/uploads/2016/04/good_curl_logo-768x294.png 768w" sizes="(max-width: 1200px) 100vw, 1200px"></figure><p>We are determined to keep libcurl the transfer library for the internet. We support the <em>full</em> API and we offer full backwards compatibility while working the same way on a vast amount of different platforms and architectures. Why use a copy when the original is free, proven and battle-tested since years?</p><h2>Rights?</h2><p>Just to put things in perspective: yes they’re perfectly allowed and permitted to do this. Both morally and legally. curl is free and open source and licensed under the MIT license.</p><h2>Good luck!</h2><p>I wish the team working on this the best of luck!</p><h2>Updates after initial post</h2><p><strong>Discussions</strong>: <a href="https://news.ycombinator.com/item?id=20222212">the hacker news discussion</a>, <a href="https://www.reddit.com/r/programming/comments/c2fl3a/google_to_reimplement_curl_in_libcrurl/">the reddit thread</a>, <a href="https://lobste.rs/s/glknu0/google_reimplement_curl_libcrurl">the lobsters talk</a>.</p><p><strong>Rename?</strong> it seems the google library might change name to <a href="https://chromium-review.googlesource.com/c/chromium/src/+/1652540/13#message-5d833230389a6df516e6774ec26c0d9c5b6b4a26">libcurl_on_cronet</a>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>