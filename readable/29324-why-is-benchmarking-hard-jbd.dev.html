<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Why is benchmarking hard? &#xB7; jbd.dev -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Why is benchmarking hard? &#xB7; jbd.dev</h1>
    <div class="post"> <span class="post-date">Mon, Jul 8, 2019, written by Jaana B. Dogan</span> <p>Benchmarking generally mean producing some measurements
from a specific program or workload to typically understand
and compare the performance characteristics of the
benchmarked workload.</p> <p>Benchmarks can be useful for:</p> <ul>
<li>Optimizing costly workloads.</li>
<li>Understanding how the underlying platform impact the cost.</li>
</ul> <p>Benchmarking can give you insights
about your workload on various dimensions such as CPU cycles
spent or memory allocation done for a given task.
These measurements (even though they might be coming
from idealized environments) might give you some hints
about the cost. They may help you to pick the right algorithm
or optimize an overwhelmingly expensive workload.</p> <p>Benchmarking can also give you insights about the underlying
runtime, operating system, and hardware. And you might find
insights to compare how each of these elements impact your
performance even if you don&#x2019;t change the code. You might want
to run the same suite of benchmarks on a new hardware to
estimate the impact of the new hardware on certain calls.</p> <p>Benchmarking requires a deep understanding of all layers
you depend on. Consider CPU benchmarking. Any aspect below
can significantly impact your results:</p> <ul>
<li>Whether the data is available in the CPU cache or not.</li>
<li>Whether you hit a garbage collection or not.</li>
<li>Whether compiler has optimized some cases or not.</li>
<li>Whether there is concurrency or not.</li>
<li>Whether you are sharing the cores with anything else.</li>
<li>Whether your cores are virtual or physical.</li>
<li>Whether the branch detector will do the same thing or not.</li>
<li>Whether the code you are benchmarking has any side effects
or not. Compilers are really good optimizing cases if it
has no impact on the global state.</li>
</ul> <p>This is why when we talk about benchmarking, it is not
good practice to limit ourselves to the user-space code.
It can sometimes turn into a detective&#x2019;s job to design and evaluate benchmarks.
This is why complicated and long workloads
are harder to benchmark reliably. It becomes harder to
do the right accounting and figure out whether it is the
contention, context switches, caching, garbage collector,
compiler optimizations or the user-space code.</p> <p>Even though microbenchmarks can give some insights, they
cannot replicate the situations how the workload is going
to perform in production. Replicating an average production
environment for microbenchmarking purposes is almost an
impossible task. This is why microbenchmarks don&#x2019;t always
serve a <em>good starting point</em> if you want to evaluate your
production performance.</p> <p>To conclude, replicating production-like situations is not
trivial.
Understanding the impact of underlying stack requires
a lot of experience and expertise.
Designing and evaluating benchmarks are not easy.
Examining the production services and understanding
the call patterns and pointing out the hot calls
may provide better insights about your production.
In the future articles, I will cover how
we think about performance evaluation in production.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>