<!DOCTYPE html>
<html lang="en">
<head>
    <title>
C# 8.0: Understanding Using Declarations -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>C# 8.0: Understanding Using Declarations</h1><div><div id="pryc-wp-acctp-original-content"><p>In this post, I introduce a simple new language feature of C# 8 called using declarations. Based on the odd <a href="https://twitter.com/James_M_South/status/1176833825420111872" target="_blank" rel="noopener noreferrer">tweet</a> or <a href="https://twitter.com/jbogard/status/1201865417481957377" target="_blank" rel="noopener noreferrer">two</a> that I have seen pass through my Twitter feed, this feature is like Marmite (sorry, UK reference there). You either love it or you hate it. The opinions seem to be quite polarised. There’s a definite split of those who favour the feature vs those who do not. I’m on the love side of the fence!&nbsp;</p><h2>Using Statements</h2><p>Before we dive into the new syntax, let’s quickly review its predecessor, the using statement. Using statements are a convenient way to write code which ensures that an IDisposable object is correctly disposed of. It’s entirely possible to achieve this today without using statements, by manually calling the Dispose method on such objects after you are finished using them.</p><p>Using statements let us conveniently wrap the use of an IDisposable object, such that it will be automatically disposed of after use.</p><p>For example, take this simple piece of code:</p><p>This code introduces a type called TestDisposable which’ implements’ the IDisposable interface.</p><p>The Main method creates an instance of this type and calls the DoSomething method. The using statement is applied to ensure that after we’re done with the instance, it is correctly disposed. Notice that the use of the instance is inside a nested block of code.</p><p>Let’s see how that same code looks after compilation. To explore the resulting code, I’ve built the sample in release mode, then used a tool called JustPeek to inspect the DLL and decompile the source.</p><p>Focusing on just the Main method, the decompiled code helps show what the using statement has been expanded to. An instance is first created on line 3. Within a try block, its DoSomething method is called. A finally block is included which disposes of the instance. The use of the finally block ensures that the object is disposed of, even if the DoSomething method caused an exception to be thrown.</p><p><em>EDIT: 22-01-2020 – The exact behaviour of try/finally is a little more complex than I firsted describe above. Finally will run when the code in the try block returns and generally that will be true when an exception is thrown. Unhandled exceptions which can crash the application may not allow the finally code to execute before crashing. Thanks to “chucker23n” on <a href="https://www.reddit.com/r/csharp/comments/ertbu8/c_80_understanding_using_declarations_steve_gordon/ff6ohht/" target="_blank" rel="noopener noreferrer">Reddit</a> for raising a discussion about this. It’s worth also reading the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-finally" target="_blank" rel="noopener noreferrer">try/finally documentation</a> which states:</em></p><blockquote><p><em>“If the exception is not caught, execution of the <code>finally</code> block depends on whether the operating system chooses to trigger an exception unwind operation.”</em></p></blockquote><p>Pretty straight-forward code. You could certainly write it yourself if you needed to. However, it’s more verbose, and it would be possible to forget the disposal entirely or introduce a bug. In more complex code, where you use multiple IDisposable types, there would be a code explosion of try/finally blocks.</p><h2>Using Declarations</h2><p>Let’s now replace the Main method with a version that applies the new C# 8 syntax.</p><p>The main thing I hope you notice is the lack of nesting in this refactored code. With the using declaration syntax, you do not introduce an extra block of nested code. Instead, you declare the instance as you would any other, preceding it with the using keyword.</p><p>Personally, I prefer this style, especially if I have more than one IDisposable type to deal with.</p><p>“When is the object disposed of though?”, I hear some of you wondering.</p><p>When applying the using declaration syntax, the object is disposed of when you leave the scope of the code in which it was declared. In this simple case, that’s when we exit this method.</p><p>Let’s look at the resulting decompiled code for this refactored method.</p><p>This code is the same as the decompiled code in the earlier example. The object is used within a try block and disposed of from within a finally block. Nice!</p><h3>Understanding the Scope</h3><p>There’s not much else to show in regards to using declarations. It’s a small change to the syntax you use when writing your code. Before we conclude, let’s ensure that we understand how the scope affects the disposal of the object.</p><p>Here’s some slightly more complicated code:</p><p>This code snippet introduces a loop. I’ve used a while loop here, but it could just as easily be a for or foreach loop too. Other than the loop, the code is the same as before.</p><p>The question though is, when is the object disposed of? Is it at the end of the method as we saw before?</p><p>Here’s the decompiled code.</p><p>Hopefully, this is what you were expecting. Since the object was declared inside the while loop, the scope of the loop is used for the disposal of it. Each time the code loops, a new instance is created, used and disposed of. The disposal code is identical to the examples we’ve looked at before. The only change here is the scope.</p><p>What if we move the declaration outside of the while loop?</p><p>Taking a look at the decompiled code again…</p><p>Now we can see that the testDisposable instance is scoped to the method, the enclosing block, and is available for re-use within the while loop. The while loop itself moves inside the try block.</p><h3>A Real-World Example</h3><p>So far, we’ve looked at some straightforward sample code. Let me quickly show a screenshot of some real-world code where the use declaration has&nbsp; been useful. I’ve chosen to include a screenshot here because it’s more useful to show the code in its real environment.</p><p>This code comes from a message processing Worker Service. After receiving the message, it’s first validated and wrapped in a context object which maintains some state about the processing that is about to take place.</p><p>I’m using two logging scopes (_logger.BeginScope) here to enrich my log messages with some extra fields which make my log data more useful. Logging scopes remain in effect for all logs that are emitted within the scope. The scope can be ended by disposing of it.</p><p>This code makes use of using declarations to ensure the correct disposal occurs. Before C# 8, this code required two extra layers of nesting, which I found harder to read when scanning through the code.</p><h2>Summary</h2><p>As with many things in software development, there are many ways to tackle the same objective. As I mentioned; nothing is stopping you from manually disposing of all IDisposable instances in your code. Doing so requires proper use of the try/finally block to ensure that the disposal takes place, regardless of exceptions.</p><p>The using statement syntax is a common-place way to achieve the same goal, with less code. This makes it easier to read and maintain the code. The compiler is responsible for maintaining proper disposal code.</p><p>In my opinion, the using declaration syntax takes this one step further to reduce one more layer of nesting and the lines of code needed to dispose of instances correctly. I find this a little easier to read, and the scoping behaviour is pretty clear. Just look at the level of nesting (the block of code) that your using declaration is declared within. That’s the scope of its lifetime.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>