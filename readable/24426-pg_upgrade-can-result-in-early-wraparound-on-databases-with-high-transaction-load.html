<!DOCTYPE html>
<html lang="en">
<head>
    <title>
pg_upgrade can result in early wraparound on databases with high transaction load -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>pg_upgrade can result in early wraparound on databases with high
 transaction load</h1><div><div class="message-content"><p>Hello,</p><p>This week I upgraded one of my large(2.8TB), high-volume databases from 9<br>to 11. The upgrade itself went fine. About two days later, we unexpectedly<br>hit transaction ID wraparound. What was perplexing about this was that the<br>age of our oldest `datfrozenxid` was only 1.2 billion - far away from where<br>I'd expect a wraparound. Curiously, the wraparound error referred to a<br>mysterious database of `OID 0`:</p><p>UPDATE ERROR:  database is not accepting commands to avoid wraparound data<br>loss in database with OID 0</p><p>We were able to recover after a few hours by greatly speeding up our vacuum<br>on our largest table.</p><p>In a followup investigation I uncovered the reason we hit the wraparound so<br>early, and also the cause of the mysterious OID 0 message. When pg_upgrade<br>executes, it calls pg_resetwal to set the next transaction ID. Within<br>pg_resetwal is the following code:<br><a href="https://github.com/postgres/postgres/blob/6cd404b344f7e27f4d64555bb133f18a758fe851/src/bin/pg_resetwal/pg_resetwal.c#L440-L450" rel="nofollow">https://github.com/postgres/postgres/blob/6cd404b344f7e27f4d64555bb133f18a758fe851/src/bin/pg_resetwal/pg_resetwal.c#L440-L450</a></p><p>This sets the controldata to have a fake database (OID 0) on the brink of<br>transaction wraparound. Specifically, after pg_upgrade is ran, wraparound<br>will occur within around 140 million transactions (provided the autovacuum<br>doesn't finish first). I confirmed by analyzing our controldata before and<br>after the upgrade that this was the cause of our early wraparound.</p><p>Given the size and heavy volume of our database, we tend to complete a<br>vacuum in the time it takes around 250 million transactions to execute.<br>With our tunings this tends to be rather safe and we stay well away from<br>the wraparound point under normal circumstances.</p><p>Unfortunately we had no obvious way of knowing that the upgrade would place<br>our database upon the brink of wraparound. In fact, since this info is only<br>persisted in the controldata, the only way to discover this state to my<br>knowledge would be to inspect the controldata itself. Other standard means<br>of monitoring for wraparound risk involve watching `pg_database` or<br>`pg_class`, which in this case tells us nothing helpful since the fake<br>database present in the controldata is not represented in those stats.</p><p>I'd like to suggest that either the pg_upgrade-&gt;pg_resetwal behaviour be<br>adjusted, or the pg_upgrade documentation highlight this potential<br>scenario. I'm happy to contribute code and/or documentation pull requests<br>to accomplish this.</p><p>Thank you,<br>Jason Harvey<br><a href="http://reddit.com" rel="nofollow">reddit.com</a><br></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>