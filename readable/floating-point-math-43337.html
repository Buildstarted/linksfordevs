<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">🎉</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1></h1>
        <p>
Reading time: 26-33 minutes        </p>
        <p><a href="https://0.30000000000000004.com/">https://0.30000000000000004.com/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
    
    <p>
        Your language isn't broken, it's doing floating point math.
        Computers can only natively store integers,
        so they need some way of representing decimal numbers.
        This representation comes with some degree of inaccuracy.
        That's why, more often than not, <code>.1 + .2 != .3</code>.
    </p>

    <h3>Why does this happen?</h3>
    <p>
        It's actually rather interesting. When you have a base 10 system (like ours),
        it can only express fractions that use a prime factor of the base.
        The prime factors of 10 are 2 and 5. So 1/2, 1/4, 1/5, 1/8, and 1/10
        can all be expressed cleanly because the denominators all use prime factors of 10.
        In contrast, 1/3, 1/6, and 1/7 are all repeating decimals because their denominators use a prime factor of 3 or 7.
        In binary (or base 2), the only prime factor is 2. So you can only express fractions cleanly which only contain 2 as a prime factor.
        In binary, 1/2, 1/4, 1/8 would all be expressed cleanly as decimals.
        While, 1/5 or 1/10 would be repeating decimals.
        So 0.1 and 0.2 (1/10 and 1/5) while clean decimals in a base 10 system, are repeating decimals in the base 2 system the computer is operating in.
        When you do math on these repeating decimals, you end up with leftovers which carry
        over when you convert the computer's base 2 (binary) number into a more human readable base 10 number.
    </p>

    <p>
        Below are some examples of sending <code>.1 + .2</code>
        to standard output in a variety of languages.
    </p>
    <p>
        read more:
        |
        <a href="http://en.wikipedia.org/wiki/Floating_point">wikipedia</a>
        |
        <a href="https://standards.ieee.org/standard/754-2008.html">IEEE 754</a>
        |
        <a href="http://stackoverflow.com/questions/588004/is-javascripts-math-broken/588014">Stack Overflow</a>
        |
        <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>
    </p>
</div><div>
    <tbody><tr>
        <th>Language</th>
        <th>Code</th>
        <th>Result</th>
    </tr>
    
    
    <tr>
        <td>ABAP</td>
        <td>
            
                
                    <pre><code>WRITE / CONV f( '.1' + '.2' ).</code></pre>
                And
                
                    <pre><code>WRITE / CONV decfloat16( '.1' + '.2' ).</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.3</p>

                    
                
            
        </td>
    </tr>
    
    
    <tr>
        <td>APL</td>
        <td>
            
                <pre><code>0.1 + 0.2</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Ada</td>
        <td>
            
                <pre><code>with Ada.Text_IO; use Ada.Text_IO;
procedure Sum is
  A : Float := 0.1;
  B : Float := 0.2;
  C : Float := A + B;
begin
  Put_Line(Float'Image(C));
  Put_Line(Float'Image(0.1 + 0.2));
end Sum;</code></pre>
            
        </td>
        <td>
            
                <p>3.00000E-01<br>
3.00000E-01</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>AutoHotkey</td>
        <td>
            
                <pre><code>MsgBox, % 0.1 + 0.2</code></pre>
            
        </td>
        <td>
            
                <p>0.300000</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>C</td>
        <td>
            
                <pre><code>#include&lt;stdio.h&gt;
int main(int argc, char** argv) {
    printf("%.17f\n", .1+.2);
    return 0;
}</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>C#</td>
        <td>
            
                
                    <pre><code>Console.WriteLine("{0:R}", .1 + .2);</code></pre>
                And
                
                    <pre><code>Console.WriteLine("{0:R}", .1f + .2f);</code></pre>
                And
                
                    <pre><code>Console.WriteLine("{0:R}", .1m + .2m);</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.3</p>

                    And
                
                    <p>0.3</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p><a href="https://msdn.microsoft.com/en-us/library/364x0z75.aspx">C# has support for 128-bit decimal numbers</a>, with 28-29 significant digits of precision. Their range, however, is smaller than that of both the single and double precision floating point types. Decimal literals are denoted with the <code>m</code> suffix.</p>
</td>
    </tr>
    
    
    <tr>
        <td>C++</td>
        <td>
            
                <pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;
int main() {
    std::cout &lt;&lt; std::setprecision(17) &lt;&lt; 0.1 + 0.2;
}</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Clojure</td>
        <td>
            
                <pre><code>(+ 0.1 0.2)</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Clojure supports arbitrary precision and ratios. <code>(+ 0.1M 0.2M)</code> returns <code>0.3M</code>, while <code>(+ 1/10 2/10)</code> returns <code>3/10</code>.</p>
</td>
    </tr>
    
    
    <tr>
        <td>ColdFusion</td>
        <td>
            
                <pre><code>&lt;cfset foo = .1 + .2&gt;
&lt;cfoutput&gt;#foo#&lt;/cfoutput&gt;</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Common Lisp</td>
        <td>
            
                
                    <pre><code>(+ .1 .2)</code></pre>
                And
                
                    <pre><code>(+ 1/10 2/10)</code></pre>
                And
                
                    <pre><code>(+ 0.1d0 0.2d0)</code></pre>
                And
                
                    <pre><code>(- 1.2 1.0)</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.3</p>

                    And
                
                    <p>3/10</p>

                    And
                
                    <p>0.30000000000000004d0</p>

                    And
                
                    <p>0.20000005</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>CL’s spec doesn’t actually even require radix 2 floats (let alone specifically 32-bit singles and 64-bit doubles), but the high-performance implementations all seem to use IEEE floats with the usual sizes. This was tested on SBCL and ECL in particular.</p>
</td>
    </tr>
    
    
    <tr>
        <td>Crystal</td>
        <td>
            
                
                    <pre><code>puts 0.1 + 0.2</code></pre>
                And
                
                    <pre><code>puts 0.1_f32 + 0.2_f32</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.3</p>

                    
                
            
        </td>
    </tr>
    
    
    <tr>
        <td>D</td>
        <td>
            
                <pre><code>import std.stdio;

void main(string[] args) {
  writefln("%.17f", .1+.2);
  writefln("%.17f", .1f+.2f);
  writefln("%.17f", .1L+.2L);
}</code></pre>
            
        </td>
        <td>
            
                <p>0.29999999999999999<br>
0.30000001192092896<br>
0.30000000000000000</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Dart</td>
        <td>
            
                <pre><code>print(.1 + .2);</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Delphi XE5</td>
        <td>
            
                <pre><code>writeln(0.1 + 0.2);</code></pre>
            
        </td>
        <td>
            
                <p>3.00000000000000E-0001</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Elixir</td>
        <td>
            
                <pre><code>IO.puts(0.1 + 0.2)</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Elm</td>
        <td>
            
                <pre><code>0.1 + 0.2</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Emacs Lisp</td>
        <td>
            
                <pre><code>(+ .1 .2)</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Erlang</td>
        <td>
            
                <pre><code>io:format("~w~n", [0.1 + 0.2]).
io:format("~f~n", [0.1 + 0.2]).
io:format("~e~n", [0.1 + 0.2]).
io_lib:format("~.1f~n", [0.1 + 0.2]).
io_lib:format("~.2f~n", [0.1 + 0.2]).</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004
0.300000
3.00000e-1
“0.3\n”
“0.30\n”</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>FORTRAN</td>
        <td>
            
                <pre><code>program FLOATMATHTEST
  real(kind=4) :: x4, y4
  real(kind=8) :: x8, y8
  real(kind=16) :: x16, y16
  ! REAL literals are single precision, use _8 or _16
  ! if the literal should be wider.
  x4 = .1; x8 = .1_8; x16 = .1_16
  y4 = .2; y8 = .2_8; y16 = .2_16
  write (*,*) x4 + y4, x8 + y8, x16 + y16
end</code></pre>
            
        </td>
        <td>
            
                <p>0.300000012<br>
0.30000000000000004<br>
0.300000000000000000000000000000000039</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>GHC (Haskell)</td>
        <td>
            
                
                    <pre><code>* 0.1 + 0.2 :: Double</code></pre>
                And
                
                    <pre><code>* 0.1 + 0.2 :: Float</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p><code>* 0.30000000000000004</code></p>

                    And
                
                    <p><code>* 0.3</code></p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Haskell supports rational numbers. To get the math right, <code>0.1 + 0.2 :: Rational</code> returns <code>3 % 10</code>, which is exactly <code>0.3</code>.</p>

</td>
    </tr>
    
    
    <tr>
        <td>Gforth</td>
        <td>
            
                <pre><code>0.1e 0.2e f+ f.</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Go</td>
        <td>
            
                <pre><code>package main
import "fmt"
func main() {
  fmt.Println(.1 + .2)
  var a float64 = .1
  var b float64 = .2
  fmt.Println(a + b)
  fmt.Printf("%.54f\n", .1 + .2)
}</code></pre>
            
        </td>
        <td>
            
                <p>0.3<br>
0.30000000000000004<br>
0.299999999999999988897769753748434595763683319091796875</p>

            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p><a href="http://blog.golang.org/constants#TOC_8.">Go numeric constants have arbitrary precision</a>.</p>
</td>
    </tr>
    
    
    <tr>
        <td>Groovy</td>
        <td>
            
                <pre><code>println 0.1 + 0.2</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Literal decimal values in Groovy are instances of <a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html">java.math.BigDecimal</a></p>
</td>
    </tr>
    
    
    <tr>
        <td>Hugs (Haskell)</td>
        <td>
            
                <pre><code>0.1 + 0.2</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Io</td>
        <td>
            
                <pre><code>(0.1 + 0.2) print</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Java</td>
        <td>
            
                
                    <pre><code>System.out.println(.1 + .2);</code></pre>
                And
                
                    <pre><code>System.out.println(.1F + .2F);</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.3</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Java has built-in support for arbitrary precision numbers using the 
<a href="http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html">BigDecimal</a> class.</p>
</td>
    </tr>
    
    
    <tr>
        <td>JavaScript</td>
        <td>
            
                <pre><code>console.log(.1 + .2);</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>The <a href="http://mikemcl.github.io/decimal.js/">decimal.js</a> library provides an arbitrary-precision Decimal type for JavaScript.</p>
</td>
    </tr>
    
    
    <tr>
        <td>Julia</td>
        <td>
            
                <pre><code>.1 + .2</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Julia has built-in <a href="https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/#Rational-Numbers-1">rational numbers support</a> and also a built-in <a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Arbitrary-Precision-Arithmetic-1">arbitrary-precision BigFloat</a> data type. To get the math right, <code>1//10 + 2//10</code> returns <code>3//10</code>.</p>
</td>
    </tr>
    
    
    <tr>
        <td>K (Kona)</td>
        <td>
            
                <pre><code>0.1 + 0.2</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Kotlin</td>
        <td>
            
                
                    <pre><code>println(.1+.2)</code></pre>
                And
                
                    <pre><code>println(.1F+.2F)</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.3</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p><a href="https://kotlinlang.org/docs/reference/basic-types.html">Reference Docs</a></p>
</td>
    </tr>
    
    
    <tr>
        <td>Lua</td>
        <td>
            
                
                    <pre><code>print(.1 + .2)</code></pre>
                And
                
                    <pre><code>print(string.format("%0.17f", 0.1 + 0.2))</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.3</p>

                    And
                
                    <p>0.30000000000000004</p>

                    
                
            
        </td>
    </tr>
    
    
    <tr>
        <td>Mathematica</td>
        <td>
            
                <pre><code>0.1 + 0.2</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Mathematica has a fairly thorough internal mechanism for dealing with
<a href="https://reference.wolfram.com/language/tutorial/NumericalPrecision.html">numerical precision</a> and supports arbitrary precision.</p>

</td>
    </tr>
    
    
    <tr>
        <td>Matlab</td>
        <td>
            
                
                    <pre><code>0.1 + 0.2</code></pre>
                And
                
                    <pre><code>sprintf('%.17f',0.1+0.2)</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.3</p>

                    And
                
                    <p>0.30000000000000004</p>

                    
                
            
        </td>
    </tr>
    
    
    <tr>
        <td>MySQL</td>
        <td>
            
                <pre><code>SELECT .1 + .2;</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Nim</td>
        <td>
            
                <pre><code>echo(0.1 + 0.2)</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>OCaml</td>
        <td>
            
                <pre><code>0.1 +. 0.2;;</code></pre>
            
        </td>
        <td>
            
                <p>float = 0.300000000000000044</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Objective-C</td>
        <td>
            
                <pre><code>#import &lt;Foundation/Foundation.h&gt;
int main(int argc, const char * argv[]) {
  @autoreleasepool {
    NSLog(@"%.17f\n", .1+.2);
  }
  return 0;
}</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>PHP</td>
        <td>
            
                <pre><code>echo .1 + .2; 
var_dump(.1 + .2);
var_dump(bcadd(.1, .2, 1));</code></pre>
            
        </td>
        <td>
            
                <p>0.3 
float(0.30000000000000004441)
string(3) “0.3”</p>

            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>PHP <code>echo</code> converts 0.30000000000000004441 to a string and shortens it to “0.3”. To achieve the desired floating point result, adjust the precision ini setting: ini_set(“precision”, 17).</p>
</td>
    </tr>
    
    
    <tr>
        <td>Perl</td>
        <td>
            
                
                    <pre><code>perl -E 'say 0.1+0.2'</code></pre>
                And
                
                    <pre><code>perl -e 'printf q{%.17f}, 0.1+0.2'</code></pre>
                And
                
                    <pre><code>perl -MMath::BigFloat -E 'say Math::BigFloat-&gt;new(q{0.1}) + Math::BigFloat-&gt;new(q{0.2})'</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.3</p>

                    And
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.3</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>The addition of float primitives only appears to print correctly because <a href="https://github.com/perl/perl5/issues/15119">not all of the 17 digits are printed by default</a>. The core <a href="https://metacpan.org/pod/Math::BigFloat">Math::BigFloat</a> allows true arbitrary precision floating point operations by never using numeric primitives.</p>
</td>
    </tr>
    
    
    <tr>
        <td>PicoLisp</td>
        <td>
            
                
                    <pre><code>[load "frac.min.l"]  # https://gist.github.com/6016d743c4c124a1c04fc12accf7ef17</code></pre>
                And
                
                    <pre><code>[println (+ (/ 1 10) (/ 2 10))]</code></pre>
                
                
            
        </td>
        <td>
            
                <p>(/ 3 10)</p>

            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>You must <a href="https://gist.github.com/DKordic/6016d743c4c124a1c04fc12accf7ef17/raw/cde44c880c51c79ec3a93ea17b9fec93db8e149f">load file “frac.min.l”</a>.</p>
</td>
    </tr>
    
    
    <tr>
        <td>Postgres</td>
        <td>
            
                <pre><code>SELECT select 0.1::float + 0.2::float;</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Powershell</td>
        <td>
            
                <pre><code>PS C:\&gt;0.1 + 0.2</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Prolog (SWI-Prolog)</td>
        <td>
            
                <pre><code>?- X is 0.1 + 0.2.</code></pre>
            
        </td>
        <td>
            
                <p>X = 0.30000000000000004.</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Pyret</td>
        <td>
            
                
                    <pre><code>0.1 + 0.2</code></pre>
                And
                
                    <pre><code>~0.1 + ~0.2</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.3</p>

                    And
                
                    <p>~0.30000000000000004</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Pyret has built-in support for both rational numbers
and floating points. Numbers written
normally are assumed to be exact. In contrast,
<em>RoughNums</em> are represented by floating
points, and are written with
a <code>~</code> in front, to indicate that
they are not precise answers. (The
<code>~</code> is meant to visually evoke hand-waving.)
Therefore, a user who sees a computation
produce <code>~0.30000000000000004</code>
knows to treat the value with skepticism.
RoughNums also cannot be compared directly for equality;
they can only be compared up to a given tolerance.</p>
</td>
    </tr>
    
    
    <tr>
        <td>Python 2</td>
        <td>
            
                
                    <pre><code>print(.1 + .2)</code></pre>
                And
                
                    <pre><code>.1 + .2</code></pre>
                And
                
                    <pre><code>float(decimal.Decimal(".1") + decimal.Decimal(".2"))</code></pre>
                And
                
                    <pre><code>float(fractions.Fraction('0.1') + fractions.Fraction('0.2'))</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.3</p>

                    And
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.3</p>

                    And
                
                    <p>0.3</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Python 2’s “print” statement converts 0.30000000000000004 to a string and shortens it to “0.3”. To achieve the desired floating point result, use print(repr(.1 + .2)). This was fixed in Python 3 (see below).</p>
</td>
    </tr>
    
    
    <tr>
        <td>Python 3</td>
        <td>
            
                
                    <pre><code>print(.1 + .2)</code></pre>
                And
                
                    <pre><code>.1 + .2</code></pre>
                And
                
                    <pre><code>float(decimal.Decimal('.1') + decimal.Decimal('.2'))</code></pre>
                And
                
                    <pre><code>float(fractions.Fraction('0.1') + fractions.Fraction('0.2'))</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.3</p>

                    And
                
                    <p>0.3</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Python (both 2 and 3) supports decimal arithmetic with the <a href="https://docs.python.org/3/library/decimal.html">decimal</a> module, and true rational numbers with the <a href="https://docs.python.org/3.7/library/fractions.html">fractions</a> module.</p>
</td>
    </tr>
    
    
    <tr>
        <td>R</td>
        <td>
            
                
                    <pre><code>print(.1+.2)</code></pre>
                And
                
                    <pre><code>print(.1+.2, digits=18)</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.3</p>

                    And
                
                    <p>0.30000000000000004</p>

                    
                
            
        </td>
    </tr>
    
    
    <tr>
        <td>Racket (PLT Scheme)</td>
        <td>
            
                
                    <pre><code>(+ .1 .2)</code></pre>
                And
                
                    <pre><code>(+ 1/10 2/10)</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>3/10</p>

                    
                
            
        </td>
    </tr>
    
    
    <tr>
        <td>Raku</td>
        <td>
            
                
                    <pre><code>raku -e 'say 0.1 + 0.2'</code></pre>
                And
                
                    <pre><code>raku -e 'say (0.1 + 0.2).fmt("%.17f")'</code></pre>
                And
                
                    <pre><code>raku -e 'say 1/10 + 2/10'</code></pre>
                And
                
                    <pre><code>raku -e 'say 0.1e0 + 0.2e0'</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.3</p>

                    And
                
                    <p>0.3</p>

                    And
                
                    <p>0.3</p>

                    And
                
                    <p>0.30000000000000004</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p><a href="https://docs.raku.org/type/Rational">Raku uses rationals by default, so .1 is stored something like { numerator =&gt; 1, denominator =&gt; 10 }</a>.  To actually trigger the behavior, you must force the numbers to be of type Num (double in C terms) and use the base function instead of the sprintf or fmt functions (since those functions have a bug that limits the precision of the output).</p>
</td>
    </tr>
    
    
    <tr>
        <td>Ruby</td>
        <td>
            
                
                    <pre><code>puts 0.1 + 0.2</code></pre>
                And
                
                    <pre><code>puts 1/10r + 2/10r</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>3/10</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Ruby supports rational numbers in syntax with version 2.1 and newer directly. For older versions use <a href="http://ruby-doc.org/core/classes/Rational.html">Rational</a>.<br>
Ruby also has a library specifically for decimals: <a href="https://ruby-doc.org/stdlib/libdoc/bigdecimal/rdoc/BigDecimal.html">BigDecimal</a>.</p>
</td>
    </tr>
    
    
    <tr>
        <td>Rust</td>
        <td>
            
                <pre><code>extern crate num;
use num::rational::Ratio;
fn main() {
    println!("{}", 0.1 + 0.2);
    println!("1/10 + 2/10 = {}", Ratio::new(1, 10) + Ratio::new(2, 10));
}</code></pre>
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>1/10 + 2/10 = 3/10</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Rust has <a href="https://rust-num.github.io/num/num_rational/struct.Ratio.html">rational number support</a> from the <a href="https://crates.io/crates/num">num crate</a>.</p>
</td>
    </tr>
    
    
    <tr>
        <td>SageMath</td>
        <td>
            
                
                    <pre><code>.1 + .2</code></pre>
                And
                
                    <pre><code>RDF(.1) + RDF(.2)</code></pre>
                And
                
                    <pre><code>RBF('.1') + RBF('.2')</code></pre>
                And
                
                    <pre><code>QQ('1/10') + QQ('2/10')</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.3</p>

                    And
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>[“0.300000000000000 +/- 1.64e-16”]</p>

                    And
                
                    <p>3/10</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p><a href="https://www.sagemath.org/">SageMath</a> supports <a href="http://doc.sagemath.org/html/en/reference/rings_numerical/index.html">various fields</a> for arithmetic:
<a href="http://doc.sagemath.org/html/en/reference/rings_numerical/sage/rings/real_mpfr.html">Arbitrary Precision Real Numbers</a>,
<a href="http://doc.sagemath.org/html/en/reference/rings_numerical/sage/rings/real_double.html">RealDoubleField</a>,
<a href="http://doc.sagemath.org/html/en/reference/rings_numerical/sage/rings/real_arb.html">Ball Arithmetic</a>,
<a href="http://doc.sagemath.org/html/en/reference/rings_standard/sage/rings/rational_field.html">Rational Numbers</a>, etc.</p>
</td>
    </tr>
    
    
    <tr>
        <td>Smalltalk</td>
        <td>
            
                <pre><code>0.1 + 0.2.</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Swift</td>
        <td>
            
                
                    <pre><code>0.1 + 0.2</code></pre>
                And
                
                    <pre><code>Decimal(0.1) + Decimal(0.2)</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.3</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Swift supports decimal arithmetic with the <a href="https://developer.apple.com/documentation/foundation/decimal">Foundation</a> module.</p>
</td>
    </tr>
    
    
    <tr>
        <td>TCL</td>
        <td>
            
                
                    <pre><code>puts [expr .1 + .2]</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    
                
            
        </td>
    </tr>
    
    
    <tr>
        <td>Turbo Pascal 7.0</td>
        <td>
            
                <pre><code>writeln(0.1 + 0.2);</code></pre>
            
        </td>
        <td>
            
                <p>3.0000000000E-01</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Vala</td>
        <td>
            
                <pre><code>static int main(string[] args) {
  stdout.printf("%.17f\n", 0.1 + 0.2);
  return 0;
}</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>Visual Basic 6</td>
        <td>
            
                <pre><code>a# = 0.1 + 0.2: b# = 0.3
Debug.Print Format(a - b, "0." &amp; String(16, "0"))
Debug.Print a = b</code></pre>
            
        </td>
        <td>
            
                <p>0.0000000000000001<br>
False</p>

            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>Appending the identifier type character <code>#</code> to any identifier forces it to Double.</p>
</td>
    </tr>
    
    
    <tr>
        <td>WebAssembly (WAST)</td>
        <td>
            
                
                    <pre><code>(func $add_f32 (result f32)
    f32.const 0.1
    f32.const 0.2
    f32.add)
(export "add_f32" (func $add_f32))</code></pre>
                And
                
                    <pre><code>(func $add_f64 (result f64)
    f64.const 0.1
    f64.const 0.2
    f64.add)
(export "add_f64" (func $add_f64))</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000001192092896</p>

                    And
                
                    <p>0.30000000000000004</p>

                    
                
            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>https://webassembly.studio/?f=r739k6d6q4t</p>
</td>
    </tr>
    
    
    <tr>
        <td>awk</td>
        <td>
            
                <pre><code>awk 'BEGIN { print 0.1 + 0.2 }'</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>bc</td>
        <td>
            
                <pre><code>0.1 + 0.2</code></pre>
            
        </td>
        <td>
            
                <p>0.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>dc</td>
        <td>
            
                <pre><code>0.1 0.2 + p</code></pre>
            
        </td>
        <td>
            
                <p>.3</p>

            
        </td>
    </tr>
    
    
    <tr>
        <td>elvish</td>
        <td>
            
                <pre><code>+ .1 .2</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    <tr>
        <td colspan="3"><p>elvish uses Go’s <code>double</code> for numerical operations.</p>
</td>
    </tr>
    
    
    <tr>
        <td>scala</td>
        <td>
            
                
                    <pre><code>scala -e 'println(0.1 + 0.2)'</code></pre>
                And
                
                    <pre><code>scala -e 'println(0.1F + 0.2F)'</code></pre>
                And
                
                    <pre><code>scala -e 'println(BigDecimal("0.1") + BigDecimal("0.2"))'</code></pre>
                
                
            
        </td>
        <td>
            
                
                    <p>0.30000000000000004</p>

                    And
                
                    <p>0.3</p>

                    And
                
                    <p>0.3</p>

                    
                
            
        </td>
    </tr>
    
    
    <tr>
        <td>zsh</td>
        <td>
            
                <pre><code>echo "$((.1+.2))"</code></pre>
            
        </td>
        <td>
            
                <p>0.30000000000000004</p>

            
        </td>
    </tr>
    
    
</tbody></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>

</body>
</html>