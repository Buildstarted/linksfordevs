<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Software optimization resources -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Software optimization resources</h1>
    <div class="main"><a></a> <p><a href="https://www.agner.org/forum/viewforum.php?f=1">See also my blog</a></p> <h2>Contents</h2> <a></a><h2>Optimization manuals</h2> <p>This series of five manuals describes everything you need to know about optimizing code for x86 and x86-64 family microprocessors, including optimization advices for C++ and assembly language, details about the microarchitecture and instruction timings of most Intel, AMD and VIA processors, and details about different compilers and calling conventions. </p> <p> Operating systems covered: DOS, Windows, Linux, BSD, Mac OS X Intel based, 32 and 64 bits. </p> <p>Note that these manuals are not for beginners. </p> <dl> <dt><a></a>1. Optimizing software in C++: An optimization guide for Windows, Linux and Mac platforms</dt> <dd>This is an optimization manual for advanced C++ programmers. Topics include: The choice of platform and operating system. Choice of compiler and framework. Finding performance bottlenecks. The efficiency of different C++ constructs. Multi-core systems. Parallelization with vector operations. CPU dispatching. Efficient container class templates. Etc. &#xA0;<p> <u>File name</u>: optimizing_cpp.pdf, size: 1794013, last modified: 2020-Jan-17.</p><br>
<a href="optimizing_cpp.pdf">Download</a>.
<br>&#xA0;</dd> <dt><a></a>2. Optimizing subroutines in assembly language: An optimization guide for x86 platforms</dt> <dd>This is an optimization manual for advanced assembly language programmers and compiler makers. Topics include: C++ instrinsic functions, inline assembly and stand-alone assembly. Linking optimized assembly subroutines into high level language programs. Making subroutine libraries compatible with multiple compilers and operating systems. Optimizing for speed or size. Memory access. Loops. Vector programming (XMM, YMM, SIMD). CPU-specific optimization and CPU dispatching. &#xA0;<p> <u>File name</u>: optimizing_assembly.pdf, size: 1635596, last modified: 2019-Dec-30.</p><br>
<a href="optimizing_assembly.pdf">Download</a>.
<br>&#xA0;</dd> <dt><a></a>3. The microarchitecture of Intel, AMD and VIA CPUs: An optimization guide for assembly programmers and compiler makers</dt> <dd>This manual contains details about the internal working of various microprocessors from Intel, AMD and VIA. Topics include: Out-of-order execution, register renaming, pipeline structure, execution unit organization and branch prediction algorithms for each type of microprocessor. Describes many details that cannot be found in manuals from microprocessor vendors or anywhere else. The information is based on my own research and measurements rather than on official sources. This information will be useful to programmers who want to make CPU-specific optimizations as well as to compiler makers and students of microarchitecture. &#xA0;<p> <u>File name</u>: microarchitecture.pdf, size: 2175669, last modified: 2019-Dec-30.</p><br>
<a href="microarchitecture.pdf">Download</a>.
<br>&#xA0;</dd> <dt><a></a>4. Instruction tables: Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel, AMD and VIA CPUs</dt> <dd>Contains detailed lists of instruction latencies, execution unit throughputs, micro-operation breakdown and other details for all common application instructions of most microprocessors from Intel, AMD and VIA. Intended as an appendix to the preceding manuals. Available as pdf file and as spreadsheet (ods format). &#xA0;<p> <u>File name</u>: instruction_tables.pdf, size: 1214548, last modified: 2019-Aug-15.</p><br>
<a href="instruction_tables.pdf">Download</a>.
&#xA0;<p> <u>File name</u>: instruction_tables.ods, size: 438394, last modified: 2019-Aug-15.</p><br>
<a href="instruction_tables.ods">Download</a>. <br>&#xA0;</dd> <dt><a></a>5. Calling conventions for different C++ compilers and operating systems</dt> <dd>This document contains details about data representation, function calling conventions, register usage conventions, name mangling schemes, etc. for many different C++ compilers and operating systems. Discusses compatibilities and incompatibilities between different C++ compilers. Includes information that is not covered by the official Application Binary Interface standards (ABI&apos;s). The information provided here is based on my own research and therefore descriptive rather than normative. Intended as a source of reference for programmers who want to make function libraries compatible with multiple compilers or operating systems and for makers of compilers and other development tools who want their tools to be compatible with existing tools. &#xA0;<p> <u>File name</u>: calling_conventions.pdf, size: 1068828, last modified: 2019-Dec-30.</p><br>
<a href="calling_conventions.pdf">Download</a>.
<br>&#xA0;</dd> <dt>All five manuals</dt> <dd>Download all the above manuals together in one zip file. &#xA0;<p> <u>File name</u>: optimization_manuals.zip, size: 6675461, last modified: 2020-Jan-17.</p><br>
<a href="optimization_manuals.zip">Download</a>.
<br>&#xA0;</dd> </dl> <h2><a>C++ vector class library</a></h2> <p>This is a collection of C++ classes, functions and operators that makes it easier to use the the vector instructions (Single Instruction Multiple Data instructions) of modern CPUs without using assembly language. Supports the SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2, FMA, XOP, and AVX512F/BW/DQ/VL instruction sets. Includes standard mathematical functions. Can compile for different instruction sets from the same source code. <br> <a href="https://www.agner.org/optimize/vcl_manual.pdf">Description and instructions</a>.<br> <a href="https://agner.org/optimize/vectorclass/">Message board</a>.<br> <a href="https://github.com/vectorclass">Source on Github</a>.<br> <a href="https://www.youtube.com/watch?v=TKjYdLIMTrI">Nice little instruction video by WhatsaCreel</a>. </p> <p> <a href="https://github.com/vectorclass/version2/releases">Latest release</a>.<br> </p> <h2><a>Object file converter</a></h2> <p>This utility can be used for converting object files between COFF/PE, OMF, ELF and Mach-O formats for all 32-bit and 64-bit x86 platforms. Can modify symbol names in object files. Can build, modify and convert function libraries across platforms. Can dump object files and executable files. Also includes a very good disassembler supporting the SSE4, AVX, AVX2, AVX512, FMA3, FMA4, XOP and Knights Corner instruction sets. Source code included (GPL). <a href="objconv-instructions.pdf">Manual</a>. </p> <p> <u>File name</u>: objconv.zip, size: 1033450, last modified: 2018-Oct-07.<br>
<a href="objconv.zip">Download</a>.
</p> <h2><a>Subroutine library</a></h2> <p>This is a library of optimized subroutines coded in assembly language. The functions in this library can be called from C, C++ and other compiled high-level languages. Supports many different compilers under Windows, Linux, BSD and Mac OS X operating systems, 32 and 64 bits. This library contains faster versions of common C/C++ memory and string functions, fast functions for string search and string parsing, fast integer division and integer vector division, as well as several useful functions not found elsewhere. </p><p>The package contains library files in many different file formats, C++ header file and assembly language source code. Gnu general public license applies. <a href="asmlib-instructions.pdf">Manual</a>. </p> <p> <u>File name</u>: asmlib.zip, size: 883583, last modified: 2018-Apr-25.<br>
<a href="asmlib.zip">Download</a>.
</p> <h2><a>ForwardCom: An open standard instruction set for high performance microprocessors</a></h2> <p>This is a proposal and discussion of how an ideal instruction set architecture can be constructed. The proposed instruction set combines the best from the RISC and CISC principles to produce a flexible, consistent, modular, orthogonal, scalable and expansible instruction set for high performance microprocessors and large vector processors.</p><p> The ForwardCom instruction set has variable-length vector registers and a special addressing mode that allows the software to automatically adapt to different microprocessors with different maximum vector lengths and make efficient loops through arrays regardless of whether the array size is divisible by the vector length. Standardization of the corresponding ecosystem of ABI standards, function libraries, compilers, etc. makes it possible to combine different programming languages in the same program. </p> <p> Introduction: <a href="http://www.forwardcom.info/">www.forwardcom.info</a>.<br> Manual: <u>File name</u>: forwardcom.pdf, size: 769352, last modified: 2017-Nov-03.<br>
<a href="forwardcom.pdf">Download</a>.
</p> <h2><a>Test programs for measuring clock cycles and performance monitoring</a></h2> <p>Test programs that I have used for my research. Can measure clock cycles and performance monitor counters such as cache misses, branch mispredictions, resource stalls etc. in a small piece of code in C, C++ or assembly. Can also set up performance monitor counters for reading inside another program. Supports Windows and Linux, 32 and 64 bit mode, multiple threads.</p> <p> For experts only. Useful for analyzing small pieces of code but not for profiling a whole program.</p> <p> <u>File name</u>: testp.zip, size: 1095188, last modified: 2018-Aug-08.<br>
<a href="testp.zip">Download</a>.
</p> <h2><a>NAN propagation versus fault trapping in floating point code</a></h2> <p>This article discusses the use of infinity and not-a-number (NAN) values in floating code as an efficient alternative to fault trapping for detecting floating point errors. Relevant compiler optimization options are also discussed. &#xA0;<p> <u>File name</u>: nan_propagation.pdf, size: 232646, last modified: 2019-May-20.</p><br>
<a href="nan_propagation.pdf">Download</a>.
<br>&#xA0; </p> <h2><a>CPUID manipulation program for VIA</a></h2> <p>This is a program that can change the CPUID vendor string, family and model number on VIA Nano processors. See <a href="http://www.agner.org/optimize/blog/read.php?i=49#73">my blog</a> for a discussion of the purpose of this program.</p> <p> <u>File name</u>: cpuidfake.zip, size: 67593, last modified: 2010-Aug-08.<br>
<a href="cpuidfake.zip">Download</a>.
</p> <a></a> <p>Agner&apos;s CPU blog <a href="https://www.agner.org/forum/">www.agner.org/forum</a></p> <p>Masm Forum <a href="https://www.masmforum.com/">www.masmforum.com</a></p> <p>ASM Community Messageboard <a href="https://www.asmcommunity.net/forums/">www.asmcommunity.net/forums</a></p> <p>Hutch&apos;s masm pages <a href="https://www.masm32.com/">www.masm32.com</a></p> <p>CPU-id tools and information <a href="https://www.cpuid.com">www.cpuid.com</a></p> <p>Godbolt compiler explorer. Enter a piece of code and see how different compilers are coding it. <a href="https://www.godbolt.org/">www.godbolt.org</a> </p><p>likwid performance measuring tools for Linux <a href="https://github.com/RRZE-HPC/likwid">github.com/RRZE-HPC/likwid</a></p> <p>Programmer&apos;s heaven assembler zone <a href="https://programmersheaven.com/categories/x86_asm">Programmers&apos; Heaven</a></p> <p>Virtual sandpile x86 Processor information <a href="https://www.sandpile.org">www.sandpile.org</a></p> <p>Online computer books <a href="http://www.computer-books.us/assembler.php">www.computer-books.us/assembler.php</a> </p> <p>Instruction latency listings <a href="http://instlatx64.atw.hu/">instlatx64.atw.hu/</a> and <a href="https://uops.info/">uops.info</a> </p><p>NASM assembler <a href="https://www.nasm.us/">www.nasm.us/</a> </p> <p>FASM assembler and messageboard <a href="https://flatassembler.net/">flatassembler.net</a> </p> <p>JWASM assembler <a href="https://www.japheth.de/">www.japheth.de</a> </p> <p>Yeppp open source library of assembly language functions <a href="https://bitbucket.org/MDukhan/yeppp/src/default/">bitbucket.org/MDukhan/yeppp</a> </p> <p>MAQAO (Modular Assembly Quality Analyzer and Optimizer), a tool for analyzing and optimizing binary codes. <a href="http://www.maqao.org/">www.maqao.org</a> </p> <p><a href="https://groups.google.com/forum/#!forum/comp.lang.asm.x86">Newsgroup: comp.lang.asm.x86</a></p> <h3>Intel resources</h3> <p>Reference manuals and other documents can be found at Intel&apos;s web site. Intel&apos;s web site is refurnished so often that any link I could provide here to specific documents would be broken after a few months. I will therefore recommend that you use the search facilities at <a href="https://www.intel.com/content/www/us/en/design/resource-design-center.html">www.intel.com</a> and search for &quot;Software Developer&apos;s Manual&quot; and &quot;Optimization Reference Manual&quot;. </p> <h3>AMD resources</h3> <p><a href="https://developer.amd.com/resources/developer-guides-manuals/"> developer.amd.com/resources/developer-guides-manuals/</a></p> <h3>Microsoft resources</h3> <p>MASM manuals <a href="https://docs.microsoft.com/en-us/cpp/assembler/masm/microsoft-macro-assembler-reference?view=vs-2019"> Microsoft Macro Assembler reference</a> </p> <p> 2689731</p> <br> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>