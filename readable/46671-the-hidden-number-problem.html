<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Hidden Number Problem -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>The Hidden Number Problem</h1>
    <article class="markdown-body"> <p>The Hidden Number Problem (HNP) is a problem that poses the question: Are the most signficant bits of a Diffie-Hellman shared key as hard to compute as the entire secret? The original problem was defined in the paper <a href="https://crypto.stanford.edu/~dabo/pubs/abstracts/dhmsb.html">&#x201C;Hardness of computing the most significant bits of secret keys in Diffie-Hellman and related schemes&#x201D; by Dan Boneh and Ramarathnam Venkatesan</a>.</p>
<p>In this paper Boneh and Venkatesan demonstrate that a bounded number of most signifcant bits of a shared secret are as hard to compute as the entire secret itself. They also demonstrate an efficient algorithm for recovering secrets given a significant enough bit leakage. This notebook walks through some of the paper and demonstrates some of the results.</p>
<blockquote>
<p>This blog post was originally written as a Sage notebook. The original
notebook can be found <a href="https://github.com/kelbyludwig/kel.bz/blob/master/notebooks/hnp.ipynb">here</a>.</p>
</blockquote>
<h2 id="how-is-the-hnp-defined">How is the HNP defined?</h2>
<p>Like many &#x201C;hard problems&#x201D; in cryptography the HNP is defined as a game with an &#x201C;oracle&#x201D;. When the oracle is queried with a specific number, it returns a value that approximately reveals the most significant bits of the input.</p>
<p>To be concrete, the oracle depends on a $n$-bit prime number $p$ and a $k$-bit significant bit leak. The output of $MSB_{k}(x)$ defined as some value $z$ such that:</p>
<p>$$ |x - z| \lt \frac{p}{2^{k+1}}$$</p>
<p>The Hidden Number Problem oralce reveals $g^x$ and $MSB_{k}(\alpha g^{x} \pmod{p})$ for randomized values of $g^x$ and asks if you can reveal the hidden $\alpha$ value.</p>
<p>There are a few variations on this problem described in the paper, however, this &#x201C;randomized&#x201D; version of the HNP is the only version of the problem we&apos;ll focus on.</p>
<p>An implementation of the $MSB$ function can be found below.</p>
<div class="highlight"><pre><code class="language-python"><span># Some parameters of the game, chosen for simplicity.</span> <span># p - A prime number for our field.</span>
p <span>=</span> next_prime(<span>2</span><span>^</span><span>16</span>) <span># n - The number of bits in `p`.</span>
n <span>=</span> ceil(log(p, <span>2</span>)) <span># k - The number of significant bits revealed by the oracle.</span>
<span># Using parameters from Thereom 1.</span>
k <span>=</span> ceil(sqrt(n)) <span>+</span> ceil(log(n, <span>2</span>)) <span>def</span> <span>msb</span>(query): <span></span><span>&quot;&quot;&quot;</span><span>Returns the MSB of query based on the global paramters p, k.</span><span>
</span><span></span><span> </span><span>&quot;&quot;&quot;</span> <span>while</span> True: z <span>=</span> randint(<span>1</span>, p<span>-</span><span>1</span>) answer <span>=</span> abs(query <span>-</span> z) <span>if</span> answer <span>&lt;</span> p <span>/</span> <span>2</span><span>^</span>(k<span>+</span><span>1</span>): <span>break</span> <span>return</span> z <span>def</span> <span>create_oracle</span>(alpha): <span></span><span>&quot;&quot;&quot;</span><span>Returns a randomized MSB oracle using the specified alpha value.</span><span>
</span><span></span><span> </span><span>&quot;&quot;&quot;</span> alpha <span>=</span> alpha <span>def</span> <span>oracle</span>(): random_t <span>=</span> randint(<span>1</span>, p<span>-</span><span>1</span>) <span>return</span> random_t, msb((alpha <span>*</span> random_t) <span>%</span> p) <span>return</span> oracle
</code></pre></div><h2 id="what-is-the-msb-function-revealing">What is the MSB function revealing?</h2>
<p>Something worth noting about this paper is their defintion of most signficant bits. The definition of $MSB_k$ tripped me up at first as I defaulted to thinking $MSB_{k}(x)$ was intended to reveal exactly the $k$ most significant bits of $x$. If you think the same you may discover:</p>
<ul>
<li>
<p>This definition is defined for &#x201C;some value of $z$&#x201D; which means $MSB_{k}(x)$ can have multiple correct outputs!</p>
</li>
<li>
<p>This definition depends on a prime value $p$ which shouldn&apos;t affect $x$&apos;s most significant bits!</p>
</li>
</ul>
<p>These properties of $MSB$ are very unlike the properties I would expect from the most natural definition of most significant bits. This is why earlier I specified that the value revealed by the oracle <em>approximately</em> reveals the most signficant bits of the input.</p>
<p>So how do you make sense of the $MSB$ function? I found the following observations helped me grok what it was doing.</p>
<ul>
<li>
<p>$u = x$ will always be one valid solution satsifying the inequality $| x - u | \leq \frac{p}{2^{k+1}}$. Note that if $u = x$ the oracle&apos;s output would be $x$.</p>
</li>
<li>
<p>Other solutions to the inequality will &#x201C;hover&#x201D; around $x$. Plotting the function <code>f(u) = | x - u |</code> for some fixed $x$ values should convince you of this.</p>
</li>
<li>
<p>As $k$ increases, the right hand side of the inequality greatly shrinks. This reduces the set of valid $u$ solutions. This also means the set of valid $u$ values are also closer to $x$.</p>
</li>
<li>
<p>The $k$ value isn&apos;t exactly the number of bits of $x$ revealed. Instead, as $k$ increase, the possible values of $u$s become closer to $x$. The closer $u$ solutions are to $x$, the more likely $x - u$ will accurately reveal $x$&apos;s most significant bits.</p>
</li>
</ul>
<p>Another way to say it: As $k$ grows closer to the number of bits in $p$, the closer $MSB_k(x)$ will be to $x$. The closer the possible answers of $MSB_k(x)$ are to $x$ the more accurate the leaked bits are.</p>
<h2 id="when-is-the-hnp-solvable">When is the HNP solvable?</h2>
<p>In Section 3 Theorem 1 the paper shows that an adversary has an advantage in solving an instance of the randomized HNP given a $k$ value that is approximately $\sqrt{\log{p}}$ using $d = 2\sqrt{n}$ oracle queries. For this demonstration, I used a more significant $k$ value: $\sqrt{\log{p}} + \log{\log{p}} = \sqrt{n} + \log{n}$.</p>
<div class="highlight"><pre><code class="language-python"><span># d - The number of oracle queries.</span>
<span># Using parameters from Thereom 1.</span>
d <span>=</span> <span>2</span> <span>*</span> ceil(sqrt(n))
</code></pre></div><h2 id="given-a-useful-oracle-how-do-i-solve-the-hnp">Given a useful oracle, how do I solve the HNP?</h2>
<p>I&apos;m trying to summarize an otherwise dense paper, so I likely have some of this wrong. With that being said&#x2026;</p>
<p>Given $d$ oracle queries and answers, solving the HNP can be done by viewing the solution as a specific case of the <a href="https://en.wikipedia.org/wiki/Lattice_problem">Closest Vector Problem</a>. This case of CVP is easy to solve given an useful enough $MSB$ oracle and a specially selected basis.</p>
<p>This special case CVP uses a lattice with the basis vectors:</p>
<pre><code>[  p,  0, ... ,  0,   0 ]
[  0,  p, ... ,  0,   0 ]
[         ...           ]
[  0,  0, ... ,  p,   0 ]
[ t1, t2, ... , td, 1/p ]
</code></pre><p>Where $t_N$ values are randomized inputs for the $MSB$ oracle. The lattice is spanned by the rows of this matrix.</p>
<p>The vector $u$ = <code>[a1, a2, ..., ad, 0]</code> is the vector that we want to find a close lattice point to. The $a_N$ values are the outputs of the $MSB$ oracle for the respective $t_N$ values.</p>
<p>A vector with the first coefficient $\alpha t_1 \pmod{p}$ (for example) can be a valid lattice point as $\alpha$ is an integer scalar of the last row, and $\pmod{p}$ is equivalent to subtracting some integer multiple of the first row.</p>
<p>The vector $v$ is a lattice vector such that each element of $v$ is $\alpha t_n \pmod{p}$ except for the $d+1$th coefficient which is $\frac{\alpha}{p}$. Given the vector $v$, we can recover $\alpha$ easily by scaling the vector by $p$.</p>
<p>By the definition of the $MSB$ oracle, the vector $u$ is likely to be close to $v$. The paper proves this. The paper also proves that $v$ is a likely to be the only vector close to $u$.</p>
<p>Given all of this, we can use a efficient algorithm that solves approximate CVP (e.g. <a href="https://www.isical.ac.in/~shashank_r/lattice.pdf">Babai&apos;s Nearest Plane Algorithm</a>) for $u$. This is likely to find our friend $v$ which reveals $\alpha$. This means we solved a case of the HNP!</p>
<div class="highlight"><pre><code class="language-python"><span>def</span> <span>build_basis</span>(oracle_inputs): <span></span><span>&quot;&quot;&quot;</span><span>Returns a basis using the HNP game parameters and inputs to our oracle</span><span>
</span><span></span><span> </span><span>&quot;&quot;&quot;</span> basis_vectors <span>=</span> [] <span>for</span> i <span>in</span> range(d): p_vector <span>=</span> [<span>0</span>] <span>*</span> (d<span>+</span><span>1</span>) p_vector[i] <span>=</span> p basis_vectors<span>.</span>append(p_vector) basis_vectors<span>.</span>append(list(oracle_inputs) <span>+</span> [QQ(<span>1</span>)<span>/</span>QQ(p)]) <span>return</span> Matrix(QQ, basis_vectors) <span>def</span> <span>approximate_closest_vector</span>(basis, v): <span></span><span>&quot;&quot;&quot;</span><span>Returns an approximate CVP solution using Babai</span><span>&apos;</span><span>s nearest plane algorithm.</span><span>
</span><span></span><span> </span><span>&quot;&quot;&quot;</span> BL <span>=</span> basis<span>.</span>LLL() G, _ <span>=</span> BL<span>.</span>gram_schmidt() _, n <span>=</span> BL<span>.</span>dimensions() small <span>=</span> vector(ZZ, v) <span>for</span> i <span>in</span> reversed(range(n)): c <span>=</span> QQ(small <span>*</span> G[i]) <span>/</span> QQ(G[i] <span>*</span> G[i]) c <span>=</span> c<span>.</span>round() small <span>-</span><span>=</span> BL[i] <span>*</span> c <span>return</span> (v <span>-</span> small)<span>.</span>coefficients() <span># Hidden alpha scalar</span>
alpha <span>=</span> randint(<span>1</span>, p<span>-</span><span>1</span>) <span># Create a MSB oracle using the secret alpha scalar</span>
oracle <span>=</span> create_oracle(alpha) <span># Using terminology from the paper: inputs = `t` values, answers = `a` values</span>
inputs, answers <span>=</span> zip(<span>*</span>[ oracle() <span>for</span> _ <span>in</span> range(d) ]) <span># Build a basis using our oracle inputs</span>
lattice <span>=</span> build_basis(inputs)
<span>print</span>(<span></span><span>&quot;</span><span>Solving CVP using lattice with basis:</span><span>\n</span><span>%s</span><span>\n</span><span>&quot;</span> <span>%</span> str(lattice)) <span># The non-lattice vector based on the oracle&apos;s answers</span>
u <span>=</span> vector(ZZ, list(answers) <span>+</span> [<span>0</span>])
<span>print</span>(<span></span><span>&quot;</span><span>Vector of MSB oracle answers:</span><span>\n</span><span>%s</span><span>\n</span><span>&quot;</span> <span>%</span> str(u)) <span># Solve an approximate CVP to find a vector v which is likely to reveal alpha.</span>
v <span>=</span> approximate_closest_vector(lattice, u)
<span>print</span>(<span></span><span>&quot;</span><span>Closest lattice vector:</span><span>\n</span><span>%s</span><span>\n</span><span>&quot;</span> <span>%</span> str(v)) <span># Confirm the recovered value of alpha matches the expected value of alpha.</span>
recovered_alpha <span>=</span> (v[<span>-</span><span>1</span>] <span>*</span> p) <span>%</span> p
<span>assert</span> recovered_alpha <span>==</span> alpha
<span>print</span>(<span></span><span>&quot;</span><span>Recovered alpha! Alpha is </span><span>%d</span><span>&quot;</span> <span>%</span> recovered_alpha)
</code></pre></div><pre><code>Solving CVP using lattice with basis:
[  65537       0       0       0       0       0       0       0       0       0       0]
[      0   65537       0       0       0       0       0       0       0       0       0]
[      0       0   65537       0       0       0       0       0       0       0       0]
[      0       0       0   65537       0       0       0       0       0       0       0]
[      0       0       0       0   65537       0       0       0       0       0       0]
[      0       0       0       0       0   65537       0       0       0       0       0]
[      0       0       0       0       0       0   65537       0       0       0       0]
[      0       0       0       0       0       0       0   65537       0       0       0]
[      0       0       0       0       0       0       0       0   65537       0       0]
[      0       0       0       0       0       0       0       0       0   65537       0]
[  48551    1628   14964   48927   50148   53570   35147   30246   38191   58907 1/65537]

Vector of MSB oracle answers:
(18059, 60122, 7350, 9904, 22254, 10999, 28418, 1197, 4772, 55857, 0)

Closest lattice vector:
[18088, 60138, 7377, 9917, 22252, 10984, 28403, 1220, 4782, 55883, 10262/65537]

Recovered alpha! Alpha is 10262
</code></pre>
<h2 id="a-solution-using-sages-integerlattice">A solution using Sage&apos;s IntegerLattice</h2>
<p>I also wrote this originally using Sage&apos;s <code>IntegerLattice</code> module which has a <code>closest_vector</code> method. However this was non-ideal because:</p>
<ul>
<li>
<p><code>IntegerLattice</code> requires integer coefficient basis vectors but the HNP uses $\frac{1}{p}$ as one of the coefficients. This was addressable, as I just scaled the basis and the CVP vectors by a value of $p$.</p>
</li>
<li>
<p><code>IntegerLattice.closest_vector</code> is slow, as it solves a more general problem then approximate CVP.</p>
</li>
</ul>
<p>Because I may want to borrow ideas from this code in the future, I&apos;ll keep the old and slow solution around.</p>
<div class="highlight"><pre><code class="language-python"><span>from</span> sage.modules.free_module_integer <span>import</span> IntegerLattice <span>def</span> <span>build_integer_lattice</span>(oracle_inputs): basis_vectors <span>=</span> [] <span>for</span> i <span>in</span> range(d): p_vector <span>=</span> [<span>0</span>] <span>*</span> (d<span>+</span><span>1</span>) p_vector[i] <span>=</span> p<span>*</span>p basis_vectors<span>.</span>append(p_vector) scaled_answers <span>=</span> list(map(<span>lambda</span> oi: oi<span>*</span>p, oracle_inputs)) basis_vectors<span>.</span>append(scaled_answers <span>+</span> [<span>1</span>]) <span>return</span> IntegerLattice(basis_vectors) oracle <span>=</span> create_oracle(alpha)
inputs, answers <span>=</span> zip(<span>*</span>[ oracle() <span>for</span> _ <span>in</span> range(d) ]) basis <span>=</span> build_integer_lattice(inputs)
v <span>=</span> vector(ZZ, list(answers) <span>+</span> [<span>0</span>])<span>*</span>p <span># This general closest_vector method is pretty slow so I&apos;m leaving it commented out.</span>
<span># cv = lat.closest_vector(v)</span>
<span># assert cv[-1] % p == alpha</span>
<span># print(&quot;Found!&quot;)</span>
</code></pre></div> </article>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>