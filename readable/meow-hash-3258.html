<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Meow Hash</title>
<div class="readable">
        <h1>Meow Hash</h1>
        <p>
Reading time: 9-11 minutes        </p>
        <p><a href="https://mollyrocket.com/meowhash">https://mollyrocket.com/meowhash</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><div><p>The Meow hash is a high-speed hash function named after the character Meow in <a href="https://meowtheinfinite.com/">Meow the Infinite</a>.  We developed the hash function at <a href="https://mollyrocket.com/">Molly Rocket</a> for use in the asset pipeline of <a href="https://molly1935.com/">1935</a>.
</p><p>Because we have to process hundreds of gigabytes of art assets to build game packages, we wanted a fast, non-cryptographic hash for use in change detection and deduplication.  We had been using a cryptographic hash (<a href="https://en.m.wikipedia.org/wiki/SHA-1">SHA-1</a>), but it was unnecessarily slowing things down.
</p><p>To our surprise, we found a lack of published, well-optimized, large-data hash functions.  Most hash work seems to focus on small input sizes (for things like dictionary lookup) or on cryptographic quality.  We wanted the fastest possible hash that would be collision-free in practice (like SHA-1 was), and we didn‚Äôt need any cryptograhic security.
</p><p>We ended up creating Meow to fill this niche.
</p></div><div><p>It‚Äôs the fastest hash function we know of, and we have benchmarked all the ones we could find.  On modern Intel x64 CPUs, it hashes 16 bytes <i>per cycle</i> single-threaded.  This means in cache it can hash at a rate of 64 <i>gigabytes</i> per second on a 4.2gHz machine.  Out of cache, it hashes at whatever speed your main memory bus can provide to a single core, since that is usually the limiting factor on modern x64 CPUs.
</p><p>It has also now been tuned to be the fastest hash on <i>small</i> inputs, too.  Despite the fact that it is a full 128-bit hash, it <i>still outperforms</i> ‚Äúfast‚Äù 64-bit hashes across all input sizes.  So whether you have data buffers of a few bytes or a few gigabytes, Meow is the fastest hash available.
</p></div><div><p>The Meow hash is not designed for cryptography and therefore we make no claims about its security.  Assume it is <i>completely insecure</i>.
</p><p>That said, it is extremely robust for its designed purpose.  It cleanly passes every test in <a href="https://github.com/aappleby/smhasher">smhasher</a> and has produced no collisions on our large datasets as yet.  Also, unlike other ‚Äúfast hashes‚Äù, it is not a small 32-bit or 64-bit hash.  It produces a full 128 bits of usable hash every time.
</p><p>The Meow hash also passes <a href="https://github.com/aappleby/smhasher">smhasher</a> cleanly at every truncation level down to 32 bits, so you can safely truncate a Meow hash value to the size you want to store.  Both 32 bit and 64 bit truncations have been tested themselves and separate hashes, and pass smhasher cleanly.
</p></div></div><div><div><div><p><wbr>zlib <wbr>License</p><p>(<wbr>C) <wbr>Copyright <wbr><span>2018</span><wbr> <wbr>Molly <wbr>Rocket, <wbr>Inc<wbr>.</p><p><wbr>This <wbr>software <wbr>is <wbr>provided <wbr><span>'as-is'</span><wbr>, <wbr>without <wbr>any <wbr>express <wbr>or <wbr>implied <wbr>warranty<wbr>.  <wbr>In <wbr>no <wbr>event <wbr>will <wbr>the <wbr>authors <wbr>be <wbr>held <wbr>liable <wbr><span>for</span><wbr> <wbr>any <wbr>damages <wbr>arising <wbr>from <wbr>the <wbr>use <wbr>of <wbr>this <wbr>software<wbr>.</p><p><wbr>Permission <wbr>is <wbr>granted <wbr>to <wbr>anyone <wbr>to <wbr>use <wbr>this <wbr>software <wbr><span>for</span><wbr> <wbr>any <wbr>purpose, <wbr>including <wbr>commercial <wbr>applications, <wbr>and <wbr>to <wbr>alter <wbr>it <wbr>and <wbr>redistribute <wbr>it <wbr>freely, <wbr>subject <wbr>to <wbr>the <wbr>following <wbr>restrictions<wbr>:</p><p><wbr><span>1.</span><wbr> <wbr>The <wbr>origin <wbr>of <wbr>this <wbr>software <wbr>must <wbr>not <wbr>be <wbr>misrepresented; <wbr>you <wbr>must <wbr>not <wbr>claim <wbr>that <wbr>you <wbr>wrote <wbr>the <wbr>original <wbr>software<wbr>. <wbr>If <wbr>you <wbr>use <wbr>this <wbr>software <wbr>in <wbr>a <wbr>product, <wbr>an <wbr>acknowledgment <wbr>in <wbr>the <wbr>product <wbr>documentation <wbr>would <wbr>be <wbr>appreciated <wbr>but <wbr>is <wbr>not <wbr>required<wbr>.</p><p><wbr><span>2.</span><wbr> <wbr>Altered <wbr>source <wbr>versions <wbr>must <wbr>be <wbr>plainly <wbr>marked <wbr>as <wbr>such, <wbr>and <wbr>must <wbr>not <wbr>be <wbr>misrepresented <wbr>as <wbr>being <wbr>the <wbr>original <wbr>software<wbr>.</p><p><wbr><span>3.</span><wbr> <wbr>This <wbr>notice <wbr>may <wbr>not <wbr>be <wbr>removed <wbr>or <wbr>altered <wbr>from <wbr>any <wbr>source <wbr>distribution<wbr>.</p></div></div></div><div><div><p>It is a very basic license and should make it easy to use.
</p></div><div><p>The <a href="https://github.com/cmuratori/meow_hash">source code</a> includes a number of files, but only <i>meow_<wbr>hash.h</i> is actually necessary.  The rest of the files may or may not be necessary depending on how you want to use Meow.  Currently, the distribution supports x64, ARM, and vanilla C implementations.
</p><p>To use the Meow hash in a program, just <i>#include</i> the headers then call it:
</p></div></div><div><div><div><p><wbr><span>#include</span><wbr> <wbr><span>"meow_intrinsics.h"</span><wbr></p><p><wbr><span>#include</span><wbr> <wbr><span>"meow_hash.h"</span><wbr></p><p><wbr><span>// ...</span><wbr></p><p><wbr><span>// <span>NOTE</span>(casey): Hash away!</span><wbr></p><p><wbr>meow_hash <wbr>Hash <wbr>= <wbr>MeowHash_Accelerated(<wbr><span>0</span><wbr>, <wbr>Size, <wbr>Buffer);</p><p><wbr><span>// <span>NOTE</span>(casey): Extract whatever hash size you want:</span><wbr></p><p><wbr>__m128i <wbr>Hash128 <wbr>= <wbr>MeowU128From(<wbr>Hash);</p><p><wbr><span>long</span><wbr> <wbr><span>long</span><wbr> <wbr><span>unsigned</span><wbr> <wbr>Hash64 <wbr>= <wbr>MeowU64From(<wbr>Hash, <wbr><span>0</span><wbr>);</p><p><wbr><span>int</span><wbr> <wbr><span>unsigned</span><wbr> <wbr>Hash32 <wbr>= <wbr>MeowU32From(<wbr>Hash, <wbr><span>0</span><wbr>);</p><p><wbr><span>// <span>NOTE</span>(casey): Check if two hashes are equal</span><wbr></p><p><wbr><span>if</span><wbr>(<wbr>MeowHashesAreEqual(<wbr>HashA, <wbr>HashB))</p><p>{</p><p><wbr><span>// <span>NOTE</span>(casey): Do something when the hashes match</span><wbr></p><p>}</p><p><wbr><span>else</span><wbr></p><p>{</p><p><wbr><span>// <span>NOTE</span>(casey): Do something else when they don't</span><wbr></p><p>}</p></div></div></div><div><div><p>Note that there are two headers to include: <i>meow_<wbr>intrinsics.h</i> for the platform support, and <i>meow_<wbr>hash.h</i> for the function itself.  This is intentional &nbsp;‚Äî&nbsp; you <i>do not</i> need to include <i>meow_<wbr>intrinsics.h</i> if you don‚Äôt want to!  Instead, you can choose to make your own set of <i>#define</i>‚Äôs before including <i>meow_<wbr>hash.h</i>, so that you can provide the foundation pieces for Meow to use.  This can be very useful if you are trying to integrate Meow into a codebase that already has its own conventions for 128-bit SIMD.
</p></div><div><p>The Meow hash was designed for very specific scenarios.  There are two very good reasons <i>not</i> to use it:
</p><table><tbody><tr><td>‚Ä¢&nbsp;</td><td><p>Never use the Meow hash for anything involving security unless you are a cryptographer and know exactly what you are doing.  The Meow hash was not designed for cryptography and has no cryptographic security proofs or analysis whatsoever.</p></td></tr></tbody></table>
<table><tbody><tr><td>‚Ä¢&nbsp;</td><td><p>Don‚Äôt base a system on the Meow hash if your primary deployment target uses a non-AES-capable CPU.  Modern ARM and x64 cores usually have the AES instructions necessary to implement a Meow hash at high speed, but other CPUs might not.  CPUs that <i>don‚Äôt</i> have AES instructions will be signficantly slower at running the Meow hash, so you <i>do not</i> want to use it in deployments that expect to use primarily non-AES-enabled CPU cores.</p></td></tr></tbody></table>
</div><div><p>Building the entire Meow suite
</p></div><div><p>If you download the entire Meow repository, you can build it all using simple batch files on both Windows and Linux.  From the root of the repository, on Windows:
</p></div></div><div><div><p>Both will build several executables for testing.  On Linux, there will only be a CLANG build, and it will be placed in a <i>build</i> directory.  On Windows, it will attempt to build with cl into <i>build_<wbr>msvc</i> and CLANG into <i>build_<wbr>clang</i>, depending on which compilers you have installed.
</p></div><div><p>The executable <i>meow_<wbr>example.exe</i> (built from <i>meow_<wbr>example.cpp</i>) is an example of the basic ways you might use a Meow hash.  You can run it from the command line with no arguments to have it hash a random buffer, with one argument to print the hash of a file, and with two arguments to have it compare the hashes of two files.  <i>meow_<wbr>example.cpp</i> is designed to be very simple, and should provide an easy way to see how Meow hashes are used in practice.
</p></div><div><p>The executable <i>meow_<wbr>test.exe</i> will test the Meow hash build for obvious defects.  It‚Äôs not a replacement for serious testing (like <a href="https://github.com/aappleby/smhasher">smhasher</a>), but it will give you a quick sanity check that you haven‚Äôt done something horribly wrong with the build.
</p></div></div><div><div><p>It will print out a clear indication of whether or not the C and accelerated versions of the Meow hash are working on your build and CPU.
</p></div><div><p>The executable <i>meow_<wbr>bench.exe</i> will run Meow hashes on lots of different sizes and attempt to determine the maximum consistent throughput it can achieve on your system.  When run with an argument, it will also output a CSV that can be used to graph the results:
</p></div></div><div><div><div><p><wbr>build<wbr>&gt; <wbr>meow_bench <wbr>results<wbr>.<wbr>csv</p></div></div></div><div><div><p>Built-in collision checking
</p></div><div><p>The executable <i>meow_<wbr>search.exe</i> will run Meow hashes on all the files in an entire directory tree and report any collisions that it finds.  It will write a detailed collision report to a filename you supply:
</p></div></div><div><div><div><p><wbr>build<wbr>&gt; <wbr>meow_search <wbr>c<wbr>:<wbr>/ <wbr>c<wbr>:<wbr>/<wbr>meow_report<wbr>.<wbr>txt</p></div></div></div><div><div><p>Hash collisions are subject to the <a href="https://en.wikipedia.org/wiki/Birthday_problem">birthday paradox</a>, which means that once you process enough hashes, collisions are <i>expected</i> for various hash truncation levels.  You should expect to see Meow32 collisions once you reach 16 bits worth of files (32-64 thousand files), Meow64 collisions once you get 32 bits worth of files (2-4 billion files), and Meow128 collisions once‚Ä¶ well‚Ä¶ you really shouldn‚Äôt be able to amass enough files for that!  So if you find a collision with Meow128, please report it to us on the <a href="https://github.com/cmuratori/meow_hash">GitHub</a>!  We may need to look into it in more detail.
</p></div><div><p>You can also use Meow hash via a streaming API and a vanilla C API for compatibility.  These are defined in <i>meow_<wbr>more.h</i>.  To use the streaming API:
</p></div></div><div><div><div><p><wbr><span>#include</span><wbr> <wbr><span>"meow_intrinsics.h"</span><wbr></p><p><wbr><span>#include</span><wbr> <wbr><span>"meow_hash.h"</span><wbr></p><p><wbr><span>#include</span><wbr> <wbr><span>"more/meow_more.h"</span><wbr></p><p><wbr><span>// ...</span><wbr></p><p><wbr><span>// <span>NOTE</span>(casey): Begin the hash</span><wbr></p><p><wbr>meow_hash_state <wbr>State;</p><p><wbr>MeowHashBegin(<wbr>&amp;<wbr>State);</p><p><wbr><span>// <span>NOTE</span>(casey): Feed data in however you want</span><wbr></p><p><wbr><span>while</span><wbr>(<wbr>...)</p><p>{</p><p><wbr>MeowHashAbsorb(<wbr>&amp;<wbr>State, <wbr>Size, <wbr>Buffer);</p><p>}</p><p><wbr><span>// <span>NOTE</span>(casey): Complete the hash</span><wbr></p><p><wbr>meow_hash <wbr>Hash <wbr>= <wbr>MeowHashEnd(<wbr>&amp;<wbr>State, <wbr>Seed);</p></div></div></div><div><div><p>and to use the C version of the hash:
</p></div></div><div><div><div><p><wbr><span>#include</span><wbr> <wbr><span>"meow_intrinsics.h"</span><wbr></p><p><wbr><span>#include</span><wbr> <wbr><span>"meow_hash.h"</span><wbr></p><p><wbr><span>#define</span><wbr> <wbr>MEOW_INCLUDE_C <wbr><span>1</span><wbr></p><p><wbr><span>#include</span><wbr> <wbr><span>"more/meow_more.h"</span><wbr></p><p><wbr><span>// ...</span><wbr></p><p><wbr><span>// <span>NOTE</span>(casey): Hash with the (slower) C version</span><wbr></p><p><wbr>meow_hash <wbr>SlowHash <wbr>= <wbr>MeowHash_C(<wbr><span>0</span><wbr>, <wbr>Size, <wbr>Buffer);</p><p><wbr><span>// <span>NOTE</span>(casey): Hash with the (faster) CPU-specific version</span><wbr></p><p><wbr>meow_hash <wbr>FastHash <wbr>= <wbr>MeowHash_Accelerated(<wbr><span>0</span><wbr>, <wbr>Size, <wbr>Buffer);</p><p><wbr><span>// <span>NOTE</span>(casey): They should alway produce the same result</span><wbr></p><p><wbr><span>assert</span><wbr>(<wbr>MeowHashesAreEqual(<wbr>SlowHash, <wbr>FastHash));</p></div></div></div><div><div><p>Generally speaking, if you are trying to use the C version for compatibility purposes, you will need to do some kind of CPU detection appropriate to your platform and then pick whether to call <i>MeowHash_<wbr>Accelerated</i> or <i>MeowHash_<wbr>C</i>.  The proper way to detect this varies from platform to platform, and is outside the scope of Meow‚Äôs implementation, so it is expected that you will implement that part of the code yourself during the startup of your application.  An example implementation using try/catch is given in <i>meow_<wbr>more_<wbr>example.cpp</i>.
</p></div><div><p>The Meow hash is still in alpha form.  We would love to get feedback on people who can test it on their datasets, especially if you find any collisions or other problems with the hash quality.  Please <a href="https://github.com/cmuratori/meow_hash">post issues on the GitHub</a> as you find them!
</p></div></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>