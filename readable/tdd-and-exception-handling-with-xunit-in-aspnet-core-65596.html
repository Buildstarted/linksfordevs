<!DOCTYPE html>
<html lang="en">
<head>
    <title>
TDD and Exception Handling With xUnit in ASP.NET Core - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="TDD and Exception Handling With xUnit in ASP.NET Core - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@jsheridanwells_66599"/>
    <meta property="og:description" content="We continue building out an ASP.NET Core web API by adding tests with xUnit and using those to guide implementing exception handling."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/swlh/tdd-and-exception-handling-with-xunit-in-asp-net-core-f9ffe5dde800"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - TDD and Exception Handling With xUnit in ASP.NET Core</title>
<div class="readable">
        <h1>TDD and Exception Handling With xUnit in ASP.NET Core</h1>
            <div>by https://medium.com/@jsheridanwells_66599</div>
            <div>Reading time: 15-19 minutes</div>
        <div>Posted here: 13 Aug 2020</div>
        <p><a href="https://medium.com/swlh/tdd-and-exception-handling-with-xunit-in-asp-net-core-f9ffe5dde800">https://medium.com/swlh/tdd-and-exception-handling-with-xunit-in-asp-net-core-f9ffe5dde800</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><div><a rel="noopener" href="https://medium.com/@jsheridanwells_66599?source=post_page-----f9ffe5dde800----------------------"><div><p><img alt="Jeremy Wells" src="https://miro.medium.com/fit/c/96/96/1*DDWa06v2XT1hyp8Fc5sMjg.jpeg" width="48" height="48"></p></div></a></div></div></div></div></div><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*iTy3VJUyzk_T0yUjJoC-tg.jpeg?q=20" width="880" height="337"></p><p><img alt="Image for post" width="880" height="337" src="https://miro.medium.com/max/880/1*iTy3VJUyzk_T0yUjJoC-tg.jpeg" srcset="https://miro.medium.com/max/276/1*iTy3VJUyzk_T0yUjJoC-tg.jpeg 276w, https://miro.medium.com/max/552/1*iTy3VJUyzk_T0yUjJoC-tg.jpeg 552w, https://miro.medium.com/max/640/1*iTy3VJUyzk_T0yUjJoC-tg.jpeg 640w, https://miro.medium.com/max/700/1*iTy3VJUyzk_T0yUjJoC-tg.jpeg 700w" sizes="700px"></p></div></div></div></div><figcaption data-selectable-paragraph=""><strong>Photo by </strong><a href="https://unsplash.com/@nicolasthomas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener nofollow"><strong>Nicolas Thomas</strong></a><strong> on </strong><a href="https://unsplash.com/s/photos/test?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener nofollow"><strong>Unsplash</strong></a></figcaption></figure><p id="c281" data-selectable-paragraph="">In this post, we’re continuing our “walking skeleton” application where we build and deploy a minimal application with an ASP.NET Core WebApi and an Angular client. At this stage, the API is almost ready. We’ve got a controller that accepts a city location, a service that calls the third-party <a href="https://openweathermap.org/api" target="_blank" rel="noopener nofollow">OpenWeatherMap</a> API to return forecasts for that location, and in the last post we added the xUnit testing framework to describe the API. If you would like to start from the beginning, <a href="https://dev.to/jsheridanwells/starting-up-an-asp-net-core-3-webapi-1lk7" target="_blank" rel="noopener nofollow">this is the first post</a>.</p><p id="5dad" data-selectable-paragraph="">The goal of this series, and this application, is to create a bare-bones, testable, and deploy-able web application that can be used as a reference for starting similar projects. In each of these steps, I intend to describe the code we add in detail.</p><p id="4b56" data-selectable-paragraph="">If you’re starting the tutorial from this post, you can clone the following branch and continue modifying the code from there (note that you will need the <a href="https://dotnet.microsoft.com/download" target="_blank" rel="noopener nofollow">.NET Core SDK</a> installed on your machine):</p><pre><span id="4951" data-selectable-paragraph="">$ git clone -b 3_adding-tests --single-branch git@github.com:jsheridanwells/WeatherWalkingSkeleton.git<br>$ cd WeatherWalkingSkeleton<br>$ dotnet restore</span></pre><p id="d178" data-selectable-paragraph="">You’ll also need to sign up for and register an <a href="https://openweathermap.org/api" target="_blank" rel="noopener nofollow">OpenWeatherMap API key</a>. <a href="https://dev.to/jsheridanwells/setting-up-an-n-tier-asp-net-core-app-222d" target="_blank" rel="noopener nofollow">This previous post</a> contains the steps for doing that.</p><p id="f81c" data-selectable-paragraph="">In the previous step, we started with one controller method that called one service method, then we set up a testing library using <a href="https://xunit.net/" target="_blank" rel="noopener nofollow">xUnit</a> and <a href="https://github.com/moq/moq4" target="_blank" rel="noopener nofollow">Moq</a>. With our testing framework ready to go, we’ll use unit tests to guide some improvements to our API endpoint that fetches weather forecasts.</p><p id="3628" data-selectable-paragraph=""><strong>TDD</strong> stands for “Test-Driven Development”, and it’s a technique for ensuring that our code performs according to expectations, documenting the current expectations for code, and using tests to help ensure that changes aren’t breaking prior functionality, especially when deploying code to higher environments. I won’t discuss here the different types of testing, or the differing opinions on testing, but I’ve recently found <a href="https://dev.to/jackmarchant/a-practical-guide-to-test-driven-development-485g" target="_blank" rel="noopener nofollow">this article</a> which gives an excellent overview of the different software testing strategies and where they can fit into different kinds of projects.</p><p id="3bf2" data-selectable-paragraph="">Our test-driven development is going to follow a <strong>Red</strong>, <strong>Green</strong>, <strong>Refactor</strong> pattern:</p><ol><li id="37ce" data-selectable-paragraph=""><strong>Red</strong>: We will write a test and ensure that it fails. That way we’re sure that our changes are actually bringing about the behavior we want, not some unanticipated side effect.</li><li id="978a" data-selectable-paragraph=""><strong>Green</strong>: We will modify our methods so that the tests pass.</li><li id="f84a" data-selectable-paragraph=""><strong>Refactor</strong>: We will do any necessary refactoring to our changes so that the code is up to par, while making sure the test still passes.</li></ol><p id="1070" data-selectable-paragraph="">Right now, our API consists of one endpoint — <code>GET http://localhost:5000/WeatherForecast/:location</code> - that terminates at the <code>WeatherForecastController</code> and calls the <code>Get</code> method. Inside the <code>Get</code> method, the <code>OpenWeatherService.GetFiveDayForecastAsync</code> method is then called which returns a list of five forecasts for the next fifteen hours.</p><p id="d506" data-selectable-paragraph="">While manually testing this endpoint with <a href="https://www.postman.com/" target="_blank" rel="noopener nofollow">Postman</a>, and running our three current unit tests, proves that this indeed happens, our methods are very brittle right now. If an API consumer calls the endpoint without a location, or with a non-existent location, the unexpected result isn’t handled. If we deploy the API to another environment without registering the OpenWeatherMap API key, we need to handle that failure as well in a way that communicates the problem to other developers. Also, the OpenWeatherMap API might itself fail and we need to be able to communicate the source of the problem. At the moment, if anything unexpected happens a long and unhelpful <code>NullReferenceException</code> is returned from the API.</p><p id="be61" data-selectable-paragraph="">Let’s refactor the methods to handle the following scenarios:</p><ol><li id="3bad" data-selectable-paragraph=""><strong>One of our users sends a location that OpenWeatherAPI doesn’t recognize:</strong> I would expect this to happen frequently, and it wouldn’t be the result of any fault in the application, so to handle this we’ll send back a helpful message to the user without throwing an exception.</li><li id="aef1" data-selectable-paragraph=""><strong>The OpenWeatherMap API key is invalid:</strong> Right now, the application is running on our local machines with an API key configured. When we deploy to other environments, those servers will also need an API key to run. If the application gets deployed without one, or if the API key expires, we’ll need to make that clear to any developers if OpenWeatherMap returns an unauthorized response.</li><li id="2cc6" data-selectable-paragraph=""><strong>OpenWeatherMap returns its own error:</strong> Since OpenWeatherMap is a third party, we cannot guarantee that it always functions within our own application as expected. If for some reason, a request to OpenWeatherMap fails, we need to handle that scenario as well.</li></ol><p id="ebf6" data-selectable-paragraph="">We’ll modify the <code>OpenWeatherService</code> class first. Open the corresponding unit test file: <code>./WeatherWalkingSkeletonTests/Services_Tests/OpenWeatherService_Tests.cs</code>. Note, that in the previous post, we also created a static fixture class called <code>OpenWeatherResponses</code> that returns three simulated error responses from the OpenWeatherMap API: <code>NotFoundResponse</code>, <code>UnauthorizedResponse</code>, <code>InternalErrorResponse</code>. We'll use these responses to trigger the errors we could get from the third-party API.</p><p id="eca7" data-selectable-paragraph="">In <code>OpenWeatherService_Tests</code> add the following tests:</p><pre><span id="5bc6" data-selectable-paragraph="">[Fact]<br>public async Task Returns_OpenWeatherException_When_Called_With_Bad_Argument()<br>{<br>    var opts = OptionsBuilder.OpenWeatherConfig();<br>    var clientFactory = ClientBuilder.OpenWeatherClientFactory(OpenWeatherResponses.NotFoundResponse,<br>        HttpStatusCode.NotFound);<br>    var sut = new OpenWeatherService(opts, clientFactory);</span><span id="fe9a" data-selectable-paragraph="">    var result = await Assert.ThrowsAsync&lt;OpenWeatherException&gt;(() =&gt; sut.GetFiveDayForecastAsync("Westeros"));<br>    Assert.Equal(404, (int)result.StatusCode);<br>}</span><span id="dc5b" data-selectable-paragraph="">[Fact]<br>public async Task Returns_OpenWeatherException_When_Unauthorized()<br>{<br>    var opts = OptionsBuilder.OpenWeatherConfig();<br>    var clientFactory = ClientBuilder.OpenWeatherClientFactory(OpenWeatherResponses.UnauthorizedResponse,<br>        HttpStatusCode.Unauthorized);<br>    var sut = new OpenWeatherService(opts, clientFactory);</span><span id="b444" data-selectable-paragraph="">    var result = await Assert.ThrowsAsync&lt;OpenWeatherException&gt;(() =&gt; sut.GetFiveDayForecastAsync("Chicago"));<br>    Assert.Equal(401, (int)result.StatusCode);<br>}</span><span id="5162" data-selectable-paragraph="">[Fact]<br>public async Task Returns_OpenWeatherException_On_OpenWeatherInternalError()<br>{<br>    var opts = OptionsBuilder.OpenWeatherConfig();<br>    var clientFactory = ClientBuilder.OpenWeatherClientFactory(OpenWeatherResponses.InternalErrorResponse,<br>        HttpStatusCode.InternalServerError);<br>    var sut = new OpenWeatherService(opts, clientFactory);</span><span id="2721" data-selectable-paragraph="">    var result = await Assert.ThrowsAsync&lt;OpenWeatherException&gt;(() =&gt; sut.GetFiveDayForecastAsync("New York"));<br>    Assert.Equal(500, (int)result.StatusCode);<br>}</span></pre><p id="3344" data-selectable-paragraph="">The tests follow the basic setup of the previous two tests, but we’ve configured the different possible error responses from the mock API. When OpenWeatherMap returns an unexpected result, we want our service to throw a custom exception called <code>OpenWeatherException</code>. This exception will communicate to the consuming class that the failure came from the third-party API.</p><p id="e2d2" data-selectable-paragraph="">If you run the test using your IDE’s test runner, or using <code>$ dotnet test</code> in the terminal, we see our tests fail. We expected our custom exception and instead got a <code>NullReferenceException</code> since our service can't yet handle a response that it can't parse.</p><p id="683f" data-selectable-paragraph="">Open <code>./Api/Services/OpenWeatherService.cs</code> and navigate to the <code>GetFiveDayForecastAsync</code> method. Going through the method line by line, we see the point where the method waits for a response from OpenWeatherMap:</p><pre><span id="f51d" data-selectable-paragraph="">var response = await client.GetAsync(url);</span></pre><p id="3fe7" data-selectable-paragraph="">We’ll check if the response is successful, and if it is then we’ll deserialize the response as we were initially. If it’s any other result, we’ll build and throw an <code>OpenWeatherException</code> so the consuming class can respond accordingly. The <em>if/else</em> block will look like this (I'll copy the entire method further below):</p><pre><span id="2d5b" data-selectable-paragraph="">if (response.IsSuccessStatusCode)<br>{<br>    // deserialize and return an OpenWeatherResponse<br>    var json = await response.Content.ReadAsStringAsync();<br>    var openWeatherResponse = JsonSerializer.Deserialize&lt;OpenWeatherResponse&gt;(json);<br>    foreach (var forecast in openWeatherResponse.Forecasts)<br>    {<br>        forecasts.Add(new WeatherForecast<br>        {<br>            Date = new DateTime(forecast.Dt),<br>            Temp = forecast.Temps.Temp,<br>            FeelsLike = forecast.Temps.FeelsLike,<br>            TempMin = forecast.Temps.TempMin,<br>            TempMax = forecast.Temps.TempMax,<br>        });<br>    } </span><span id="3817" data-selectable-paragraph="">    return forecasts;<br>}<br>else<br>{<br>    // build an exception with information from the third-party API<br>    throw new OpenWeatherException(response.StatusCode, "Error response from OpenWeatherApi: " + response.ReasonPhrase);<br>}</span></pre><p id="02ec" data-selectable-paragraph="">The exception will contain the OpenWeatherMap HTTP status code and a simple message, then a consuming class can create logic based on that information.</p><p id="09b7" data-selectable-paragraph="">Below is what the entire <code>GetFiveDayFirecastAsync</code> method should look like:</p><pre><span id="6882" data-selectable-paragraph="">public async Task&lt;List&lt;WeatherForecast&gt;&gt; GetFiveDayForecastAsync(string location, Unit unit = Unit.Metric)<br>{<br>    string url = BuildOpenWeatherUrl("forecast", location, unit);<br>    var forecasts = new List&lt;WeatherForecast&gt;();</span><span id="4724" data-selectable-paragraph="">    var client = _httpFactory.CreateClient("OpenWeatherClient");<br>    var response = await client.GetAsync(url);</span><span id="7499" data-selectable-paragraph="">    if (response.IsSuccessStatusCode)<br>    {<br>        var json = await response.Content.ReadAsStringAsync();<br>        var openWeatherResponse = JsonSerializer.Deserialize&lt;OpenWeatherResponse&gt;(json);<br>        foreach (var forecast in openWeatherResponse.Forecasts)<br>        {<br>            forecasts.Add(new WeatherForecast<br>            {<br>                Date = new DateTime(forecast.Dt),<br>                Temp = forecast.Temps.Temp,<br>                FeelsLike = forecast.Temps.FeelsLike,<br>                TempMin = forecast.Temps.TempMin,<br>                TempMax = forecast.Temps.TempMax,<br>            });<br>        } </span><span id="8a05" data-selectable-paragraph="">        return forecasts;<br>    }<br>    else<br>    {<br>        throw new OpenWeatherException(response.StatusCode, "Error response from OpenWeatherApi: " + response.ReasonPhrase);<br>    } <br>}</span></pre><p id="9168" data-selectable-paragraph="">Run the tests again and they should all pass. At this point, we’ve done the <em>Red</em> and <em>Green</em> steps of the test process. I’ll leave it up to you to find any opportunities for refactoring this method or letting it go as is.</p><p id="088c" data-selectable-paragraph="">Our service can now graceful indicate if there was a failed response from the OpenWeatherMap API. Now we need our controller communicate these exceptions back to our API’s consuming clients.</p><p id="1719" data-selectable-paragraph="">Going back to our original three scenarios, the controller could respond to each in the following ways:</p><ol><li id="1607" data-selectable-paragraph="">If OpenWeatherMap couldn’t recognize the location, the controller can return a <code>400 BadRequest</code> response and let the consumer know the name of the location that failed. Also, if the request is made without a location, we should return a <code>400</code> before even calling the service.</li><li id="c9c4" data-selectable-paragraph="">If the OpenWeatherMap returns an <code>Unauthorized</code> response, it's due to an invalid API key and for this project that's likely from a bad configuration. We'll return a <code>500 Internal Server Error</code> with the message from the OpenWeatherMap API which will indicate if the request was not authorized.</li><li id="0395" data-selectable-paragraph="">If there is any other error, we’ll return another <code>500</code> response with the message from OpenWeatherMap. Lastly, we'll also return a <code>500</code> response for any other exception that is thrown within the application.</li></ol><p id="86e2" data-selectable-paragraph="">The responses above lead to three tests that we’ll add to <code>./Tests/Controllers_Tests/</code>:</p><pre><span id="d56b" data-selectable-paragraph="">[Fact]<br>public async Task Returns_400_Result_When_Missing_Location()<br>{<br>    var opts = OptionsBuilder.OpenWeatherConfig();<br>    var clientFactory = ClientBuilder.OpenWeatherClientFactory(OpenWeatherResponses.NotFoundResponse);<br>    var service = new OpenWeatherService(opts, clientFactory);<br>    var sut = new WeatherForecastController(new NullLogger&lt;WeatherForecastController&gt;(), service);</span><span id="7b50" data-selectable-paragraph="">    var result = await sut.Get(String.Empty) as ObjectResult;</span><span id="baec" data-selectable-paragraph="">    Assert.Equal(400, result.StatusCode);<br>}</span><span id="3996" data-selectable-paragraph="">[Fact]<br>public async Task Returns_BadRequestResult_When_Location_Not_Found()<br>{<br>    var opts = OptionsBuilder.OpenWeatherConfig();<br>    var clientFactory = ClientBuilder.OpenWeatherClientFactory(OpenWeatherResponses.NotFoundResponse,<br>        HttpStatusCode.NotFound);<br>    var service = new OpenWeatherService(opts, clientFactory);<br>    var sut = new WeatherForecastController(new NullLogger&lt;WeatherForecastController&gt;(), service);</span><span id="45ec" data-selectable-paragraph="">    var result = await sut.Get("Westworld") as ObjectResult;</span><span id="20a3" data-selectable-paragraph="">    Assert.Contains("not found", result.Value.ToString());<br>    Assert.Equal(400, result.StatusCode);<br>}</span><span id="6941" data-selectable-paragraph="">[Fact]<br>public async Task Returns_OpenWeatherException_When_Unauthorized()<br>{<br>    var opts = OptionsBuilder.OpenWeatherConfig();<br>    var clientFactory = ClientBuilder.OpenWeatherClientFactory(OpenWeatherResponses.UnauthorizedResponse,<br>        HttpStatusCode.Unauthorized);<br>    var sut = new OpenWeatherService(opts, clientFactory);</span><span id="988f" data-selectable-paragraph="">    var result = await Assert.ThrowsAsync&lt;OpenWeatherException&gt;(() =&gt; sut.GetFiveDayForecastAsync("Chicago"));<br>    Assert.Equal(401, (int)result.StatusCode);<br>}</span><span id="ca81" data-selectable-paragraph="">[Fact]<br>public async Task Returns_500_When_Api_Returns_Error()<br>{<br>    var opts = OptionsBuilder.OpenWeatherConfig();<br>    var clientFactory = ClientBuilder.OpenWeatherClientFactory(OpenWeatherResponses.UnauthorizedResponse,<br>        HttpStatusCode.Unauthorized);<br>    var service = new OpenWeatherService(opts, clientFactory);<br>    var sut = new WeatherForecastController(new NullLogger&lt;WeatherForecastController&gt;(), service);</span><span id="02bf" data-selectable-paragraph="">    var result = await sut.Get("Rio de Janeiro") as ObjectResult;</span><span id="cb93" data-selectable-paragraph="">    Assert.Contains("Error response from OpenWeatherApi: Unauthorized", result.Value.ToString());<br>    Assert.Equal(500, result.StatusCode); <br>}</span></pre><p id="251b" data-selectable-paragraph="">If we run them, they should fail.</p><p id="a130" data-selectable-paragraph="">We’ll open the class under test in <code>./Api/Controllers/WeatherForecastController.cs</code> and find the <code>Get()</code> method. Add the following as the first step of the method to check if there is a usable <code>location</code> value with the request:</p><pre><span id="be30" data-selectable-paragraph="">[HttpGet]<br>public async Task&lt;IActionResult&gt; Get(string location, Unit unit = Unit.Metric)<br>{<br>   if (string.IsNullOrEmpty(location))<br>       return BadRequest("location parameter is missing");<br>   // [ ... ] <br>}</span></pre><p id="ead3" data-selectable-paragraph="">Now, three of the four new tests should be failing.</p><p id="1969" data-selectable-paragraph="">For the rest of the tests, we can get them to pass by returning a <code>400 Bad Request</code> result if OpenWeatherMap can't find the location, or returning a <code>500 Internal Server Error</code> for any other reason, along with a helpful message. Also, we can wrap our logic in a <em>try/catch</em> block that will handle an <code>OpenWeatherException</code> as indicated above, then handle any other exception. The updated <code>Get()</code> method can now look like this:</p><pre><span id="0b6a" data-selectable-paragraph="">[HttpGet]<br>public async Task&lt;IActionResult&gt; Get(string location, Unit unit = Unit.Metric)<br>{<br>    if (string.IsNullOrEmpty(location))<br>        return BadRequest("location parameter is missing");<br>    try<br>    {<br>        var forecast = await _weatherService.GetFiveDayForecastAsync(location, unit);<br>        return Ok(forecast);<br>    }<br>    catch (OpenWeatherException e)<br>    {<br>        if (e.StatusCode == HttpStatusCode.NotFound)<br>            return BadRequest($"Location: "{ location }" not found.");<br>        else<br>            return StatusCode(500, e.Message);<br>    }<br>    catch (Exception e)<br>    {<br>        return StatusCode(500, e.Message);<br>    }<br>}</span></pre><p id="3910" data-selectable-paragraph="">Run the tests and we’re successful if we now have nine passing tests in the collection. As before, if you would like to experiment with other ways to handle exceptions from the <code>OpenWeatherService</code>, you can now refactor the method secured with its corresponding tests.</p><p id="723a" data-selectable-paragraph="">In this tutorial, we started with a project with an API endpoint that could handle a “happy path,” but could not meaningfully handle exceptions. We came up with three possible exception scenarios, then used test-driven development for describing the desired behavior for our classes, making changes until the tests passed. We now have a more robust example ASP.NET Core project. In the next tutorials, we will Docker-ize the API to support complimentary development, then scaffold an Angular project to serve as a client.</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>