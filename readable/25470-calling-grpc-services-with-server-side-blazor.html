<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Calling gRPC Services With Server-side Blazor -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Calling gRPC Services With Server-side Blazor</h1><div><div class="post-content"><p>In this post, I want to show you how you can call gRPC services using server-side Blazor. I just want to say that I've only been experimenting with gRPC for a couple of days so I'm very much still learning, but it's been a great experience so far. </p><p>Before we get into any code I want to just explain what gRPC is, for those who've not heard of it before.</p><blockquote>All of the code for this post is available on <a href="https://github.com/chrissainty/CallinggRPCServicesWithBlazor">GitHub</a>.</blockquote><h2 id="what-is-grpc">What is gRPC</h2><p>gRPC is a fast and efficient open source remote procedure call (RPC) framework initially created by Google. It's an evolution of an internal RPC technology called "Stubby". It uses HTTP/2 as its transport protocol and a technology called <a href="https://developers.google.com/protocol-buffers/docs/overview">Protocol Buffers</a>, or protobuf, to describe interfaces and messages.</p><p>Currently, gRPC stands for <strong>g</strong>RPC <strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all. I say currently as the 'g' stands for something different in every release. Previous definitions include, 'green', 'good', 'gentle' and 'gregarious'. If you're interested, you can see the full list on the <a href="https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md">main repo on GitHub</a>.</p><p>So why use it? Simply put, it's really fast and highly scaleable. Because of this, unsurprisingly, gRPC has gained a lot of traction in microservices. </p><p>When comparing REST with gRPC, it does look more limited. With REST you're limited to 4 primary functions, GET, PUT, POST and DELETE. With gRPC you can define any kind of function be that synchronous, asynchronous, uni-direction or even streams. gRPC also requires much less boilerplate code than REST. With much of the code needed on the server and the client generated automatically from protobuf files.</p><p>As I said at the start, I'm still learning about gRPC so I'm sure there's loads more good stuff to discover. But for now let's move on and look at how we can setup a simple gRPC service and configure a Blazor client.</p><h2 id="getting-setup">Getting Setup</h2><p>Everything I'm going to be showing you requires the latest <a href="https://dotnet.microsoft.com/download/dotnet-core/3.0">.NET Core 3 SDK</a> and <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2019 Preview</a>. </p><p>Microsoft are actively contributing to the <a href="https://github.com/grpc/grpc-dotnet">gRPC for .NET project</a> and as of .NET Core 3 Preview 3, there is now a template for building gRPC services. You can find it by creating a new <em>ASP.NET Core Web Application</em>.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/05/new-grpc-project.jpg" class="kg-image"></figure><h2 id="the-service">The Service</h2><p>I'm going to use the default gRPC service template as is, for this post. I'm not going to go into detail about how it's setup. But I do want to focus on <code>greet.proto</code> file, in the <em>Protos</em> folder.</p><pre><code>syntax = "proto3";

package Greet;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings.
message HelloReply {
  string message = 1;
}
</code></pre><p>This file defines the contract for the service. The Greeter service has a single interface, <code>SayHello</code>, which takes a <code>HelloRequest</code> and returns a <code>HelloReply</code>. </p><p>The message definition for <code>HelloRequest</code> specifies one field called <code>name</code>. While <code>HelloReply</code> specifies one called <code>message</code>. Fields are either <a href="https://developers.google.com/protocol-buffers/docs/proto#scalar">scalar types</a> or <a href="https://developers.google.com/protocol-buffers/docs/proto#specifying-field-types">composite types</a>. </p><p>In the example above, all fields are scalar types with a type, name and unique number. It's important that once defined, these unique numbers don't change as they're used to identify fields once in binary format.</p><p>The gRPC tooling uses this file to generate a service base class which is then used in the <code>GreeterService</code> in the <em>Services</em> folder. </p><h2 id="the-client">The Client</h2><p>Now the service is in place I'm going to add a Blazor server-side project to the solution. This is going to be the gRPC client.</p><p>To make things easier to test, I'm going to make a change to allow multiple startup projects for the solution. This is done by right clicking on the solution and selecting <em>Set Startup Projects...</em> Then setting both projects action to Start.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/05/grpc-multi-project.jpg" class="kg-image"></figure><p>I'm going to start by making a copy of <code>greet.proto</code> from the server project and adding it to the client project. </p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/05/grpc-multi-project-1.jpg" class="kg-image"></figure><p>Next I'm going to make some additions to the clients <em>csproj</em> file. </p><p>I'm going to include 3 package references for <code>Google.Protobuf</code>, <code>Grpc.Core</code> and <code>Grpc.Tools</code>. I'm also including an <code>ItemGroup</code> referencing the protobuf file so the tooling can generate the client code needed to communicate with the server. The final <em>csproj</em> file looks like this.</p><pre><code>&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt;
    &lt;LangVersion&gt;7.3&lt;/LangVersion&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;Protobuf Include="Protos\greet.proto" GrpcServices="Client" Generator="MSBuild:Compile"/&gt;
    &lt;Content Include="@(Protobuf)" /&gt;
    &lt;None Remove="@(Protobuf)" /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Google.Protobuf" Version="3.8.0-rc.1" /&gt;
    &lt;PackageReference Include="Grpc.Core" Version="1.21.0" /&gt;
    &lt;PackageReference Include="Grpc.Tools" Version="1.21.0"&gt;
      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
    &lt;/PackageReference&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre><p>I need to add a couple of using statements to my main <code>_Imports.razor</code>.</p><pre><code class="language-csharp">@using Greet
@using Grpc.Core
</code></pre><p>Finally, I'm going to replace the contents of the <code>Index.razor</code> page with the following code.</p><pre><code class="language-html">@page "/"

&lt;h1&gt;Hello, gRPC!&lt;/h1&gt;

&lt;button class="btn btn-primary" onclick="@SayHello"&gt;Say Hello&lt;/button&gt;

&lt;hr /&gt;

&lt;p&gt;@Greeting&lt;/p&gt;

@functions {

    private string Greeting;

    async Task SayHello()
    {
        var channel = new Channel("localhost:50051", ChannelCredentials.Insecure);
        var client = new Greeter.GreeterClient(channel);

        var reply = await client.SayHelloAsync(new HelloRequest { Name = "Blazor gRPC Client" });
        Greeting = reply.Message;

        await channel.ShutdownAsync();
    }

}
</code></pre><p>All the magic is happening in the <code>SayHello</code> method. </p><p>I start by creating a gRPC channel to the server. Next, I create an instance of the <code>GreeterClient</code>. This class is created by the code gen tools using the <code>greet.proto</code> file. </p><p>With an instance of the client I can call methods as defined in the proto file. I can send a <code>HelloRequest</code> specifying the clients name and await the reply.</p><p>Once I have a reply I can assign the <code>Message</code> to the <code>Greeting</code> field and then close the channel to the server.</p><p>All thats left to do is fire everything up and click the button.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/05/grpc-2.gif" class="kg-image"></figure><h2 id="summary">Summary</h2><p>This has been a high-level overview of gRPC and how you can configure server-side Blazor as a client. We started with a quick introduction to what gRPC is and why we might use it, before diving into a small sample app with a gRPC service and a server-side Blazor Client.</p><p>I have only scratched the surface with gRPC and I'm looking forward to learning more about it and trying out some more advanced scenarios.</p><hr><hr></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>