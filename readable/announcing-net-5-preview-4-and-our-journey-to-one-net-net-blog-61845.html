<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Announcing .NET 5 Preview 4 and our journey to one .NET | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Announcing .NET 5 Preview 4 and our journey to one .NET | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Scott HunterDirector Program Management, .NETFollow"/>
    <meta property="og:description" content=".NET 5 is the next version and future of .NET. We are continuing the journey of unifying the .NET platform, with a single framework that extends from cloud to desktop to mobile and beyond. Looking back, we took the best of .NET Framework and put that into .NET Core 3,"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/announcing-net-5-preview-4-and-our-journey-to-one-net/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Announcing .NET 5 Preview 4 and our journey to one .NET | .NET Blog</title>
<div class="readable">
        <h1>Announcing .NET 5 Preview 4 and our journey to one .NET | .NET Blog</h1>
            <div>by Scott HunterDirector Program Management, .NETFollow</div>
            <div>Reading time: 36-46 minutes</div>
        <div>Posted here: 19 May 2020</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/announcing-net-5-preview-4-and-our-journey-to-one-net/">https://devblogs.microsoft.com/dotnet/announcing-net-5-preview-4-and-our-journey-to-one-net/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/02/scotthunter-1-150x150.png" width="58" height="58" alt="Scott Hunter [MSFT]"></p><p>Scott</p></div></div></div><p>May 19th, 2020</p><p>.NET 5 is the next version and future of .NET. We are continuing the journey of unifying the .NET platform, with a single framework that extends from cloud to desktop to mobile and beyond. Looking back, we took the best of .NET Framework and put that into .NET Core 3, including support for WPF and Windows Forms. As we continue the journey, we will move Xamarin and .NET web assembly to use the .NET 5 libraries, and extend the dotnet tools to target mobile and web assembly in the browser. At the same time, we’ll continue to improve .NET capabilities as a leading cloud and container runtime.</p><p>You can tune in to hear Scott Hanselman and I talk about .NET 5 and beyond in our “<a href="https://aka.ms/ScottBuildSessions" rel="nofollow" target="_blank">The Journey to One .NET” talk</a> today.</p><p>We want to hear from you! Share your feedback about .NET 5 at <a href="https://aka.ms/dotnet5_feedback_blog" rel="nofollow" target="_blank">https://aka.ms/dotnet5_feedback_blog</a>. We greatly value your feedback and use it to help make decisions on the future of .NET.</p><p>Last year, <a href="https://devblogs.microsoft.com/dotnet/introducing-net-5/" rel="nofollow">we laid out our vision for one .NET and .NET 5.</a> we said we would take .NET Core and Mono/Xamarin implementations and unify them into one base class library (BCL) and toolchain (SDK). In the wake of the global health pandemic, we’ve had to adapt to the changing needs of our customers and provide the support needed to assist with their smooth operations. Our efforts continue to be anchored in helping our customers address their most urgent needs. As a result, we expect these features to be available in preview by November 2020, but the unification will be truly completed with .NET 6, our Long-Term Support (LTS) release. Our vision hasn’t changed, but our timeline has.</p><p>We remain committed to one .NET platform and will deliver a quality .NET 5 release in November this year. You’ll continue to see a wave of innovation happening with multiple previews on the journey to one .NET.</p><h2>Download Preview 4</h2><p>You can <a href="https://dotnet.microsoft.com/download/dotnet/5.0" rel="nofollow" target="_blank">download .NET 5.0 Preview 4</a>, for Windows, macOS, and Linux:</p><ul><li><a href="https://dotnet.microsoft.com/download/dotnet/5.0" rel="nofollow" target="_blank">Windows and macOS installers</a></li><li><a href="https://dotnet.microsoft.com/download/dotnet/5.0" rel="nofollow" target="_blank">.zip and tar.gz files</a></li><li><a href="https://hub.docker.com/_/microsoft-dotnet" rel="nofollow" target="_blank">Docker images</a></li><li><a href="https://snapcraft.io/dotnet-sdk" rel="nofollow" target="_blank">Snap installer</a></li></ul><p><a href="https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-5-preview-4/">ASP.NET Core</a>, and EF Core are also being released today. <a href="https://devblogs.microsoft.com/powershell/powershell-team-may-2020-update/" rel="nofollow">PowerShell has a .NET 5-based release today</a> (post will be published later today) and now releases on the .NET schedule.</p><p>You need Visual Studio 2019 16.6 or later versions to use .NET 5.0. To use .NET 5.0 with Visual Studio Code, install the latest version of the <a href="https://code.visualstudio.com/Docs/languages/csharp" rel="nofollow" target="_blank">C# extension</a>. .NET 5.0 isn’t yet supported with Visual Studio for Mac.</p><p>Release notes:</p><ul><li><a href="https://github.com/dotnet/core/tree/master/release-notes/5.0/preview" target="_blank">.NET 5.0 release notes</a></li><li><a href="https://github.com/dotnet/core/blob/master/release-notes/5.0/5.0-known-issues.md" target="_blank">.NET 5.0 known issues</a></li><li><a href="https://github.com/dotnet/core/tree/master/release-notes/5.0/preview/api-diff" target="_blank">.NET Core 3.1 -&gt; .NET 5.0 API diff</a></li><li><a href="https://github.com/dotnet/core/releases" target="_blank">GitHub release</a></li><li><a href="https://github.com/dotnet/core/issues/4607" target="_blank">GitHub tracking issue</a></li></ul><h2>.NET 5 Highlights</h2><p>Let’s take a look at some of the release highlights that we expect to deliver with .NET 5, in November. Many of these changes are included, in part or in full, in Preview 4. The highlights will paint a clearer picture on the improvements you’ll get to take advantage of in your development process and in production when you adopt .NET 5.</p><ul><li>Includes C# 9 and F# 5.</li><li>Performance — Improve <a href="https://github.com/dotnet/runtime/pulls?page=2&amp;q=is%3Apr+is%3Aclosed+label%3Atenet-performance" target="_blank">performance throughout the product</a>.<ul><li><a href="https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/" rel="nofollow">Regular expressions</a></li><li><a href="https://github.com/dotnet/runtime/pull/31968" target="_blank">Improve performance of <code><span>string</span><span>.</span><span>ToUpperInvariant</span></code>, <code><span>string</span><span>.</span><span>ToLowerInvariant</span></code>, <code><span>char</span><span>.</span><span>ToUpperInvariant</span></code>, <code><span>char</span><span>.</span><span>ToLowerInvariant</span></code>, and other related patterns</a></li><li><a href="https://github.com/dotnet/corefx/pull/41640" target="_blank">Improve HTTP 1.1 performance</a></li><li><a href="https://github.com/dotnet/runtime/pull/35694" target="_blank">Improve HTTP/2 performance</a></li><li><a href="https://github.com/dotnet/runtime/pull/32969" target="_blank">Improve tiered compilation performance</a></li><li><a href="https://github.com/dotnet/runtime/pull/32538" target="_blank">Improve stack prolog zeroing performance</a></li><li><a href="https://twitter.com/dsymetweets/status/1255077752149094400" rel="nofollow" target="_blank">Improve performance of tailcalls used by F#</a></li></ul></li><li>Consistent performance: We have increased our focus on predictably consistent performance, reducing performance cliffs and outliers, with an emphasis on P95+ latency.<ul><li><a href="https://github.com/dotnet/runtime/pull/32250" target="_blank">Improve call counting mechanism</a> used by tiered JIT compilation to smooth out performance during startup</li><li><a href="https://github.com/dotnet/runtime/pull/32270" target="_blank">Dynamic expansion of internal generic dictionary</a> that eliminate performance cliffs hit by generic code</li><li><a href="https://github.com/dotnet/runtime/pull/32283" target="_blank">Pinned object heap</a> to reduce heap fragmentation caused by pinning</li><li>Reduce GC pause times in specific situations, like <a href="https://github.com/dotnet/coreclr/pull/27776" target="_blank">Array.Copy</a>, <a href="https://github.com/dotnet/runtime/pull/35297" target="_blank">Array.Sort</a> or <a href="https://github.com/dotnet/runtime/pull/32353#issuecomment-586642480" target="_blank">object unboxing</a></li></ul></li><li>Single file applications — a new <a href="https://github.com/dotnet/runtime/issues/36590" target="_blank">single-file publish type</a> that executes your app out of a single binary (for example, can be used on read-only media).</li><li>Windows ARM64 — <a href="https://github.com/dotnet/runtime/issues/36699" target="_blank">Enable .NET to run natively on Windows ARM64</a>, supporting both development scenarios and deployment of client apps on customer machines.</li><li>ARM64 — <a href="https://github.com/dotnet/runtime/issues/35853" target="_blank">Improve ARM64 performance</a> (Linux and Windows) in the JIT and BCL libraries.</li><li>Containers — <a href="https://github.com/dotnet/dotnet-docker/issues/1814#issuecomment-625294750" target="_blank">Reduce container image size</a> and implement <a href="https://github.com/dotnet/runtime/pull/34334" target="_blank">new container APIs</a> to enable .NET to stay up-to-date with container runtime evolution.</li><li>New Target Framework — We have adopted a <a href="https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md" target="_blank">new approach for .NET TFMs</a>.</li><li>JSON APIs — Enable easier <a href="https://docs.microsoft.com/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to" rel="nofollow" target="_blank">migration from Newtonsoft.Json to System.Text.Json</a>.</li></ul><p>I’ll share some more detailed information about some of these improvements, and where we see them headed.</p><h3>.NET 5.0 Target Framework</h3><p>We are changing the approach we use for <a href="https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md" target="_blank">target frameworks with .NET 5.0</a>. The following two project file examples demonstrate using .NET Core 3.1 and .NET 5.0 target frameworks, by specifying the respective Target Framework Moniker (TFM). You can see a new, more compact, TFM for .NET 5.0:</p><p>.NET Core 3.0:</p><div><pre><span>&lt;</span><span><span>Project</span></span><span> </span><span><span>Sdk</span></span><span>=</span><span><span><span>"</span></span><span>Microsoft.NET.Sdk</span><span><span>"</span></span></span><span>&gt;</span><span>

  </span><span>&lt;</span><span><span>PropertyGroup</span></span><span>&gt;</span><span>
    </span><span>&lt;</span><span><span>OutputType</span></span><span>&gt;</span><span>Exe</span><span>&lt;/</span><span><span>OutputType</span></span><span>&gt;</span><span>
    </span><span>&lt;</span><span><span>TargetFramework</span></span><span>&gt;</span><span>netcoreapp3.1</span><span>&lt;/</span><span><span>TargetFramework</span></span><span>&gt;</span><span>
  </span><span>&lt;/</span><span><span>PropertyGroup</span></span><span>&gt;</span><span>

</span><span>&lt;/</span><span><span>Project</span></span><span>&gt;</span></pre></div><p>.NET 5.0:</p><div><pre><span>&lt;</span><span><span>Project</span></span><span> </span><span><span>Sdk</span></span><span>=</span><span><span><span>"</span></span><span>Microsoft.NET.Sdk</span><span><span>"</span></span></span><span>&gt;</span><span>

  </span><span>&lt;</span><span><span>PropertyGroup</span></span><span>&gt;</span><span>
    </span><span>&lt;</span><span><span>OutputType</span></span><span>&gt;</span><span>Exe</span><span>&lt;/</span><span><span>OutputType</span></span><span>&gt;</span><span>
    </span><span>&lt;</span><span><span>TargetFramework</span></span><span>&gt;</span><span>net5.0</span><span>&lt;/</span><span><span>TargetFramework</span></span><span>&gt;</span><span>
  </span><span>&lt;/</span><span><span>PropertyGroup</span></span><span>&gt;</span><span>

</span><span>&lt;/</span><span><span>Project</span></span><span>&gt;</span></pre></div><p>We are making several important changes to .NET TFMs for .NET 5.0, to simplify using them, reduce concepts, and to make it easier to expose operating-system-specific APIs.</p><p>Here is a quick summary:</p><p>Targeting API versions will be simpler with .NET going forward. We won’t have two families of TFMs, like: <code><span>netcoreapp3</span><span>.</span><span>1</span></code> and <code><span>netstandard2</span><span>.</span><span>0</span></code>. Instead, we’ll have just one, like: <code><span>net5</span><span>.</span><span>0</span></code>, and <code><span>net6</span><span>.</span><span>0</span></code>. That’s because there is just one .NET implementation going forward, so there is no longer a need for .NET Standard (which made libraries compatible across multiple .NET products). You’ll also be able to target operating system APIs, with a small extension to the TFM, like <code><span>net5</span><span>.</span><span>0</span><span>-</span><span>windows</span></code> and <code><span>net6</span><span>.</span><span>0</span><span>-</span><span>android</span></code>. We’ll also remove the different SDKs from new project files, like <code><span>Sdk</span><span>=</span><span>"Microsoft.NET.Sdk.WindowsDesktop"</span></code> since <code><span>net5</span><span>.</span><span>0</span><span>-</span><span>windows</span></code>, for example, will provide the same information. The biggest win is that by targeting <code><span>net5</span><span>.</span><span>0</span></code>, you get access to 100% of cross-platform APIs, not the subset that happened to be in .NET Standard. It will always be obvious which TFM to use (it’s either portable code or OS-specific), and you’ll never have to wait for APIs like <code><span>Span</span><span>&lt;</span><span>T</span><span>&gt;</span></code> to be available.</p><p>Here are the details:</p><ul><li><code><span>net5</span><span>.</span><span>0</span></code> is the new Target Framework Moniker (TFM) for .NET 5.0.</li><li><code><span>net5</span><span>.</span><span>0</span></code> combines and replaces the <code><span>netcoreapp</span></code>and <code><span>netstandard</span></code> TFMs.</li><li><code><span>net5</span><span>.</span><span>0</span></code> supports <a href="https://docs.microsoft.com/en-us/dotnet/core/porting/third-party-deps#net-framework-compatibility-mode" rel="nofollow" target="_blank">.NET Framework compatibility mode</a></li><li><code><span>net5</span><span>.</span><span>0</span><span>-</span><span>windows</span></code> will be used to expose Windows-specific functionality, like Windows Forms and WPF.</li><li>.NET 6.0 will use the same approach, with <code><span>net6</span><span>.</span><span>0</span></code> and will add <code><span>net6</span><span>.</span><span>0</span><span>-</span><span>ios</span></code> and <code><span>net6</span><span>.</span><span>0</span><span>-</span><span>android</span></code>.</li><li>The OS-specific TFMs can include <a href="https://github.com/dotnet/designs/blob/master/accepted/2020/minimum-os-version/minimum-os-version.md" target="_blank">OS version numbers</a>, like <code><span>net6</span><span>.</span><span>0</span><span>-</span><span>ios14</span></code>.</li><li>Portable frameworks, like ASP.NET Core and Xamarin.Forms, will be usable with <code><span>net5</span><span>.</span><span>0</span></code>.</li></ul><p>These changes are a result of thinking of <a href="https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/" rel="nofollow">.NET Core as the future of .NET</a>. We’ve been removing the “Core” name from various aspects of the product, including <a href="https://github.com/dotnet/runtime/issues/33680" target="_blank">APIs</a> and <a href="https://github.com/dotnet/dotnet-docker/issues/1765" target="_blank">container repos</a>. We also saw an opportunity to further simplify .NET, by removing .NET Standard as a concept, for .NET 5.0+. <a href="https://github.com/dotnet/standard" target="_blank">.NET Standard</a> has played a key role in establishing .NET Core, by creating a bridge with .NET Framework and Xamarin. The .NET Standard 2.0 version will remain relevant for many years, and we recommend you use it if you need to support .NET Framework. For apps and libraries that don’t need to run on .NET Framework, we recommend targeting the <code><span>net5</span><span>.</span><span>0</span></code> TFM, which will give you access to the largest set of cross-platform APIs. For Xamarin, .NET Standard 2.0 and 2.1 remain relevant, however, once Xamarin is integrated into .NET as part of .NET 6.0, then it will switch to <code><span>net6</span><span>.</span><span>0</span></code> TFMs, and developers will target .NET Standard 2.0 exclusively for .NET Framework compatibility.</p><p>You likely have more questions you want answered. We’ll be publishing a larger blog post on this topic before we release .NET 5.0. The following points answer some of the most obvious remaining questions:</p><ul><li><code><span>netcoreapp5</span><span>.</span><span>0</span></code> was used in earlier previews and is no longer supported, however still works.</li><li>Existing .NET Standard versions will work forever, and their continued use is supported.</li><li>We don’t expect to create any new <code><span>netstandard</span></code> versions. <a href="https://devblogs.microsoft.com/dotnet/announcing-net-standard-2-1/" rel="nofollow">.NET Standard 2.1</a> will likely be the last version.</li><li>There are no plans for a <code><span>net5</span><span>.</span><span>0</span><span>-</span><span>linux</span></code> TFM since we don’t (yet) expose any Linux-specific APIs. Also, “Linux” is not a single uniform quantity, so it is unclear which APIs would be exposed in such a TFM. We could expose the <a href="https://en.wikipedia.org/wiki/POSIX" rel="nofollow" target="_blank">POSIX standard</a>, but then we’d call it <code><span>net5</span><span>.</span><span>0</span><span>-</span><span>posix</span></code>, and it would work on operating systems other than just Linux. However, we don’t have plans for that either.</li><li>We <a href="https://github.com/dotnet/runtime/issues/33328" target="_blank">do not plan to expose a TFM for web assembly</a>, for similar reasons as described for Linux.</li><li>You cannot update the <code><span>TargetFrameworkVersion</span></code> in a .NET Framework project to 5.0 and expect it to become a .NET 5.0 project. It will not work. Instead, you need to <a href="https://docs.microsoft.com/en-us/dotnet/core/porting/" rel="nofollow" target="_blank">port your application to .NET Core</a>. For libraries, you can port to .NET Standard or .NET Core. We are <a href="https://github.com/dotnet/announcements/issues/130" target="_blank">no longer adding .NET Framework APIs to .NET Core</a>, so there is no need to wait to port your application to .NET Core.</li><li>The new TFM plan is a foundational part of the <a href="https://github.com/dotnet/designs/blob/master/accepted/2020/workloads/workloads.md" target="_blank">workloads project</a>. We will add minimal support for workloads in .NET 5.0 and then implement the complete vision in .NET 6.0.</li></ul><h3>Windows Forms Designer for .NET Core Released</h3><p>Today we’re happy to announce that the Windows Forms designer for .NET Core projects is now available as a preview in Visual Studio 2019 version 16.6! We also have a newer version of the designer available in Visual Studio 16.7 Preview 1!</p><p>To enable the designer in Visual Studio, go to Tools &gt; Options &gt; Environment &gt; Preview Features and select the Use the preview Windows Forms designer for .NET Core apps option.</p><p>The new designer supports all Windows Forms controls, except <code><span>DataGridView</span></code> and <code><span>ToolStripContainer</span></code> (coming soon). It include all other designer functionality you would expect, including: drag-and-drop, selection, move and resize, cut/copy/paste/delete of controls, integration with the Properties Window, events generation and more. Data binding and support for third party controls are coming soon.</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/05/designer-1024x692.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/05/designer-1024x692.png" alt="Image designer" width="640" height="433" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/05/designer-1024x692.png 1024w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/05/designer-300x203.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/05/designer-768x519.png 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/05/designer.png 1420w" sizes="(max-width: 640px) 100vw, 640px"> </a></p><h3>Windows ARM64</h3><p>.NET apps can now run natively on Windows ARM64. This follows the support we added for <a href="https://github.com/dotnet/runtime/issues/11042" target="_blank">Linux ARM64</a> in .NET Core 3.0. With .NET 5.0, you can develop web and UI apps on Windows ARM64 devices, and deliver your applications to users who own <a href="https://www.microsoft.com/en-us/p/surface-pro-x/8VDNRP2M6HHC" rel="nofollow" target="_blank">Surface Pro X</a> and similar devices. You can already run .NET Core and .NET Framework apps on Windows ARM64, but via x86 emulation. It’s workable, but native ARM64 execution has much better performance.</p><p>You can download and use the .NET 5.0 SDK on ARM64 with today’s preview 4 release. Currently, only Console and ASP.NET Core apps are supported. See <a href="https://github.com/dotnet/runtime/issues/36699" target="_blank">.NET 5.0 ARM64 tracking issue</a> to track progress.</p><p>The <code><span>master</span></code> branch adds support for Windows Forms. This changes may make it into Preview 5, but Preview 6 for sure. You can download a <code><span>master</span></code> branch build from <a href="https://github.com/dotnet/installer#installers-and-binaries" target="_blank">dotnet/installer</a>.</p><p>At present, you need to download and expand <code><span>.</span><span>zip</span></code> files for ARM64. We intend to add ARM64 MSIs for the final .NET 5 release.</p><p>We have been working closely with the <a href="https://github.com/powershell/powershell" target="_blank">PowerShell</a> team to validate and enable PowerShell 7.1 on Windows ARM64. The team has had Windows ARM64 “experimental” builds for some time and intends to support PowerShell 7.1 on Windows ARM64, when they release. PowerShell 7.1 is built on .NET 5.0, and should be released around the same time.</p><p>The following image demonstrate the <a href="https://github.com/dotnet/samples/tree/master/windowsforms/Conway's-Game-of-Life/VB" target="_blank">Conway’s Game of life</a> VB and Windows Forms sample running on Windows ARM64.</p><p><a href="https://user-images.githubusercontent.com/2608468/82086979-20f5bd00-96a4-11ea-8d73-abed8f2505fb.png" target="_blank" rel="noopener noreferrer" data-featherlight="image"></a><a href="https://user-images.githubusercontent.com/2608468/82086979-20f5bd00-96a4-11ea-8d73-abed8f2505fb.png" target="_blank" data-featherlight="image"> <img src="https://user-images.githubusercontent.com/2608468/82086979-20f5bd00-96a4-11ea-8d73-abed8f2505fb.png" alt="2020-05-15" width="398"> </a></p><h3>ARM64 Performance</h3><p>We’ve been investing significantly in improving ARM64 performance, for over a year. We’re committed to making ARM64 a high-performance platform with .NET. Platform portability and consistency have always been compelling characteristics of .NET. This includes offering great performance wherever you use .NET. With .NET Core 3.x, ARM64 has had functionality parity with x64 but was missing some key performance features and investments. We’re making the first big investments in ARM64 performance in .NET 5.0.</p><p>There are several categories of improvements we’re making:</p><ul><li>Tune JIT optimizations for ARM64 (<a href="https://github.com/dotnet/runtime/pull/35675" target="_blank">example</a>)</li><li>Enable and take advantage of ARM64 hardware intrinsics (<a href="https://github.com/dotnet/runtime/pull/34486" target="_blank">example</a>).</li><li>Adjust performance-critical algorithms in libraries for ARM64 (<a href="https://github.com/dotnet/runtime/issues/34198" target="_blank">example</a>).</li></ul><p>See <a href="https://github.com/dotnet/runtime/issues/35853" target="_blank">Improving ARM64 Performance in .NET 5.0</a> to track our progress.</p><p><a href="https://devblogs.microsoft.com/dotnet/hardware-intrinsics-in-net-core/" rel="nofollow">Hardware intrinsics</a> are a <a href="https://github.com/dotnet/designs/blob/master/accepted/2018/platform-intrinsics.md" target="_blank">low-level performance feature</a> we added in .NET Core 3.0. At the time, we added support for x64 instructions and chips. As part of .NET 5.0, we are extending the feature to support ARM64. Just creating the intrinsics doesn’t help performance. You need to use them in performance-critical code. We’ve <a href="https://github.com/dotnet/runtime/issues/33308" target="_blank">taken advantage of ARM64 intrinsics extensively in .NET libraries</a> in .NET 5.0. You can also do this in your own code, although you need to be be familiar with CPU instructions to do so.</p><p>I’ll explain how hardware intrinsics work with an analogy. For the most part, developers rely on types and APIs built into .NET, like <code><span>String</span><span>.</span><span>Split</span></code> or <code><span>HttpClient</span></code>. Those APIs often take advantage of native operating system APIs, via the <a href="https://docs.microsoft.com/dotnet/standard/native-interop/pinvoke" rel="nofollow" target="_blank">P/Invoke</a> feature. P/Invoke enables high-performance native interop, and is used extensively in the BCL for that purpose. You can use this same feature yourself to call native APIs. Hardware intrinsics are similar, except instead of calling operating system APIs, they enable you to directly use CPU instructions in your code. It’s roughly equivalent to a .NET version of <a href="https://en.wikipedia.org/wiki/Intrinsic_function" rel="nofollow" target="_blank">C++ intrinsics</a>. Hardware intrinsics are best thought of as a CPU hardware-acceleration feature. They provide very tangible benefits, are now a key part of the performance substrate of the .NET libraries, and responsible for many of the benefits you read about in our <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/" rel="nofollow">performance blog posts</a>. In terms of comparison to C++, when .NET intrinsics are AOT-compiled into Ready-To-Run files, the intrinics have no runtime performance penalty.</p><p>Note: The Visual C++ compiler has an analogous <a href="https://docs.microsoft.com/cpp/intrinsics/compiler-intrinsics" rel="nofollow" target="_blank">intrinsics feature</a>. You can directly compare C++ to .NET hardware intrinsics, as you can see if you search for <code><span>_mm_i32gather_epi32</span></code> at <a href="https://docs.microsoft.com/dotnet/api/system.runtime.intrinsics.x86.avx2" rel="nofollow" target="_blank">System.Runtime.Intrinsics.X86.Avx2</a>, <a href="https://docs.microsoft.com/cpp/intrinsics/x64-amd64-intrinsics-list" rel="nofollow" target="_blank">x64 (amd64) intrinsics list</a>, and <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_i32gather_epi32" rel="nofollow" target="_blank">Intel Intrinsics guide</a>. You will see a lot of similarity.</p><p>We’re making our first big investments in ARM64 performance in 5.0, but will continue this effort in subsequent releases. We work directly with engineers from <a href="https://en.wikipedia.org/wiki/Arm_Holdings" rel="nofollow" target="_blank">ARM Holdings</a> to prioritize product improvements and to design algorithms that best take advantage of the <a href="https://en.wikipedia.org/wiki/ARM_architecture#ARMv8-A" rel="nofollow" target="_blank">ARMv8 ISA</a>. Some of these improvements will accrue value to ARM32, however, we are not applying unique effort to ARM32.</p><p>Please share any performance information with us related to ARM64, either a notable improvement from 3.1 to 5.0, or performance with 5.0 that should be better.</p><h3>P95+ Latency</h3><p>We see an increasing number of large internet-facing sites and services being hosted on .NET. While there is a lot of legitimate focus on the <a href="https://twitter.com/ben_a_adams/status/1260792649625280513" rel="nofollow" target="_blank">requests per second (RPS) metric</a>, we find that very few big site owners ask us about that or require millions of RPS. We hear a lot about latency, however, specifically about improving <a href="https://docs.microsoft.com/en-us/azure/internet-analyzer/internet-analyzer-scorecard" rel="nofollow" target="_blank">P95 or P99 latency</a>. Often, the number of machines or cores that are provisioned for (and biggest cost driver of) a site are chosen based on achieving a specific P95 metric, as opposed to say P50. We think of latency as being the true “money metric”.</p><p>Our friends at StackOverflow do a great job of sharing data on their service. One of their engineers, <a href="https://twitter.com/Nick_Craver" target="_blank">Nick Craver</a>, recently shared <a href="https://twitter.com/Nick_Craver/status/1205289893674573829" rel="nofollow" target="_blank">improvements they saw to latency</a>, as a result of moving to .NET Core:</p><twitter-widget id="twitter-widget-0" data-tweet-id="1245027999034023936"></twitter-widget><p>While you can see that we’ve been making good progress on latency, we’re far from satisfied. In the (distant) past, we built features like <a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/workstation-server-gc" rel="nofollow" target="_blank">server GC</a> and <a href="https://docs.microsoft.com/dotnet/standard/garbage-collection/background-gc" rel="nofollow" target="_blank">background GC</a> to improve latency, by taking advantage of course-grained CPU features like multiple-cores and threads, respectively. Those remain very important, however, we need to get a lot more creative to significantly improve latency moving forward, at least as it relates to the GC. We have started multiple projects along those lines.</p><p>Pinned objects have been a long-term challenge for GC performance, specifically because they accelerate (or cause) memory fragmentation. We’ve added a <a href="https://github.com/dotnet/runtime/pull/32283" target="_blank">new GC heap for pinned objects</a>. The <a href="https://github.com/dotnet/runtime/blob/master/docs/design/features/PinnedHeap.md" target="_blank">pinned object heap</a> is based on the assumption that there are very few pinned objects in a process but that their presence causes disproportionate performance challenges. It makes sense to move pinned objects — particularly those created by .NET libraries as an implementation detail — to a unique area, leaving the generational GC heaps with few or no pinned objects, and with substantially higher performance as a result.</p><p>More recently, we’ve been attacking long-standing “hard problems” in the GC. <a href="https://github.com/dotnet/runtime/pull/32795" target="_blank">dotnet/runtime #2795</a> applies a new approach to GC statics scanning that avoids lock contention when it is determining liveness of GC heap objects. <a href="https://github.com/dotnet/coreclr/pull/25986" target="_blank">dotnet/coreclr #25986</a> uses a new algorithm for balancing GC work across cores during the mark phase of garbage collection, which should increase the throughput of garbage collection with large heaps, which in turn reduces latency.</p><h3>Containers</h3><p>We consider containers to be the most important cloud trend, and have been investing significantly in this modality. We are investing in containers in at least four different ways, at multiple levels of the .NET software stack.</p><p>The first is our investment in fundamentals. It’s a bit odd to claim credit for these investments, since they also benefit non-containerized workloads. What might not be obvious is that more and more of the feedback we receive that influences our fundamentals investment is coming from developers who deploy containerized apps. There is a bias to containers with these investments.</p><p>We are working on making .NET perform better in containers. We heard reports about <a href="https://github.com/dotnet/runtime/issues/622" target="_blank">poor performance related to a change in .NET Core 3.1</a> late last year (which was later reverted). We are now investigating the performance of using .NET in high-density and other configurations to help inform what we expect will be a relatively scoped set of changes that unlocks the next significant performance improvements in containers. It should be noted that <a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/" rel="nofollow">.NET Core 3.0 was a very big release for .NET and containers</a>, with the 3.1 issue being a small (and short-lived) blip.</p><p>We are always looking for opportunities to improve the images we publish. This includes <a href="https://github.com/dotnet/dotnet-docker/issues/1814#issuecomment-625294750" target="_blank">reducing image size</a>, but also extending the set of images we publish. We have decided to <a href="https://github.com/dotnet/dotnet-docker/issues/1852" target="_blank">start publishing Windows Server Core images</a> based on feedback we heard on GitHub and other sources. The following is an <a href="https://github.com/mthalman/dotnet-docker/blob/e4a2c1b8696b4b8657a775d6ee8e72d69e650a2f/5.0/runtime/windowsservercore-1909/amd64/Dockerfile" target="_blank">example Dockerfile</a> that will be used when we start publishing these images. We’ve made other changes that <a href="https://devblogs.microsoft.com/dotnet/we-made-windows-server-core-container-images-40-smaller/" rel="nofollow">reduce the size of Windows Server Core images</a>, making them more attractive to use.</p><p>Last, we are working to make it easier to work with container orchestrators and similar environments. We are adding support for <a href="https://github.com/dotnet/runtime/issues/31372" target="_blank">OpenTelemetry out of the box</a> so that you can <a href="https://opentelemetry.io/" rel="nofollow" target="_blank">capture distributed traces and metrics from your application</a>. We are also working on a new set of experimental tools in the <a href="https://github.com/dotnet/tye" target="_blank">dotnet/tye</a> repo that are intended to improve microservices developer productivity, both for development and deploying to a Kubernetes environment.</p><h3>Improving tiered compilation performance</h3><p>We’ve been working on improving <a href="https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/" rel="nofollow">tiered compilation</a> for multiple releases. We continue to see it as a critical performance feature, for both startup and steady-state performance. We’ve made two big improvements to tiered compilation this release.</p><p>The primary mechanism underlying tiered compilation is call counting. Once a method is called n times, the runtime asks the JIT to recompile the method at higher quality. From our earliest performance analyses, we knew that the call-counting mechanism was too slow (from a long-term standpoint), but didn’t see a straightforward way to resolve that. As part of .NET 5.0, we’ve <a href="https://github.com/dotnet/runtime/pull/32250" target="_blank">improved the call counting mechanism</a> used by tiered JIT compilation to smooth out performance during startup. In past releases, we’ve seen reports of unpredictable performance during the first 10-15s of process lifetime (mostly for web servers). That should now be resolved. Please test it and tell us what you see.</p><p>Another performance challenge we found was using tiered compilation for methods with loops. The fundamental problem is that you can have a cold method (only called once or a few times; &lt; n) with a loop that iterates a million times. A great example of this pathological case is the <code><span>Program</span><span>.</span><span>Main</span></code> method of an application. As a result, we disabled tiered compilation for methods with loops by default. Instead, we enabled applications to opt into using tiered compilation for methods with loops. PowerShell is an application that chose to do this, after seeing high single-digit performance improvements in some scenarios.</p><p>To address methods with loops better, we implemented <a href="https://github.com/dotnet/runtime/pull/32969" target="_blank">on-stack replacement (OSR)</a>. This is similar to a feature that the Java Virtual Machines has, of the same name. <a href="https://github.com/dotnet/runtime/blob/master/docs/design/features/OnStackReplacement.md" target="_blank">OSR</a> enables code executed by a currently running method to be re-compiled in the middle of method execution, while those methods are active “on-stack”. This feature is currently experimental and opt-in (on x64).</p><p>To use OSR, multiple features must be enabled. The <a href="https://github.com/PowerShell/PowerShell/blob/70d9ed4d551e12eebf2985b5590c7cd6e106aaeb/src/powershell-win-core/powershell-win-core.csproj#L10" target="_blank">PowerShell project file</a> is a good starting point. You will notice that tiered compilation and all quick-jit features are enabled. In addition, you need to set <code><span>COMPlus_TC_OnStackReplacement</span><span>=</span><span>1</span></code> (its an environment variable).</p><p>Alternatively, you can set the following two environment variables, assuming all other settings have their default values:</p><ul><li><code><span>COMPlus_TC_QuickJitForLoops</span><span>=</span><span>1</span></code></li><li><code><span>COMPlus_TC_OnStackReplacement</span><span>=</span><span>1</span></code></li></ul><p>We do not intend to enable OSR by default in .NET 5.0 and have not yet decided if we will support it in production. Please give us any and all feedback you have on the feature. We are actively testing it now and will share more insights on it later.</p><h3>Single file applications</h3><p>There are key scenarios where people want to use .NET where single-file distribution is a requirement, or at least preferred. We’ve been building up the key pieces that we need to enable this scenario over multiple releases, and will be including a <a href="https://github.com/dotnet/runtime/issues/36590" target="_blank">new single file publish type in .NET 5.0</a>. It’s a feature we expect to continue to refine over multiple releases.</p><p>There are two aspects that make this feature expensive to build:</p><ul><li>Accounting for different feature sets and constraints on Linux and Windows for loading executable content out of native resources.</li><li>Ensuring that the debugger provides a multi-file-like experience for single-file applications.</li></ul><p>For scoping purposes, we are supporting this feature on X64, for .NET 5.0, on Windows and Linux. It will work for ARM32/64 apps, however, we are not actively validating single files apps for the ARM architecture this release. Both <a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/" rel="nofollow" target="_blank">runtime-dependent and self-contained publish types</a> will be supported for single-file.</p><p>The experience between Windows and Linux is similar, but not the same. The differences are primarily relevant for self-contained single file applications, as described in the <a href="https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md" target="_blank">Single-file publish design doc</a>:</p><ul><li>Single-file publish Linux: <code><span>dotnet publish </span><span>-</span><span>r linux</span><span>-</span><span>x64 </span><span>/</span><span>p</span><span>:</span><span>PublishSingleFile</span><span>=</span><span>true</span></code><ul><li>Published files: <code><span>HelloWorld</span></code>, <code><span>HelloWorld</span><span>.</span><span>pdb</span></code></li></ul></li><li>Single-file publish Windows: <code><span>dotnet publish </span><span>-</span><span>r win</span><span>-</span><span>x64 </span><span>/</span><span>p</span><span>:</span><span>PublishSingleFile</span><span>=</span><span>true</span></code><ul><li>Published files: <code><span>HelloWorld</span><span>.</span><span>exe</span></code>, <code><span>HelloWorld</span><span>.</span><span>pdb</span></code>, <code><span>coreclr</span><span>.</span><span>dll</span></code>, <code><span>clrjit</span><span>.</span><span>dll</span></code>, <code><span>clrcompression</span><span>.</span><span>dll</span></code>, <code><span>mscordaccore</span><span>.</span><span>dll</span></code></li></ul></li></ul><p>As you can see, on Windows, single-file self-contained applications require four additional files beyond the app. We were not able to include these runtime files into the single file app. We do not currently have a technical plan for hiding these extra files on Windows, even though we understand that it would be preferred.</p><p>Note: <code><span>.</span><span>pdb</span></code> files are required only for debugging scenarios, and <code><span>mscordaccore</span><span>.</span><span>dll</span></code> is required to collect crash dumps, including by <a href="https://en.wikipedia.org/wiki/Windows_Error_Reporting" rel="nofollow" target="_blank">Windows Error Reporting (AKA “Watson”)</a>.</p><h3>Improving migration from NewtonSoft.Json to System.Text.Json</h3><p>We added <a href="https://devblogs.microsoft.com/dotnet/try-the-new-system-text-json-apis/" rel="nofollow">System.Text.Json</a> as part of the .NET Core 3.0 release. It provides significant performance improvements over <a href="https://www.nuget.org/packages/Newtonsoft.Json" rel="nofollow" target="_blank">Newtonsoft.Json</a>, which has been the go-to Json library for .NET for many years. In some cases, it is hard to migrate to System.Text.Json, even with the <a href="https://docs.microsoft.com/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to" rel="nofollow" target="_blank">migration guide</a> we’ve provided. We’ve been working on targeted features that enable easier migration, without giving up on the performance value proposition of System.Text.Json.</p><p>We’ve added the following migration features with .NET 5.0:</p><ul><li><a href="https://github.com/dotnet/runtime/pull/655" target="_blank">Add support for preserve references on JSON</a> – <a href="https://github.com/dotnet/runtime/issues/29900" target="_blank">Enables <code><span>ReferenceLoopHandling</span></code></a>.</li><li><a href="https://github.com/dotnet/runtime/pull/33444" target="_blank">Add <code><span>JsonConstructor</span></code> and support for deserializing with parameterized ctors</a> — Adds support for immutable classes and structs to JsonSerializer.</li><li><a href="https://github.com/dotnet/runtime/pull/34049" target="_blank">Add JsonIgnoreCondition &amp; per-property ignore logic</a> – Adds support for null value handling.</li><li><a href="https://github.com/dotnet/runtime/pull/34675" target="_blank">Add JsonIncludeAttribute &amp; support for non-public accessors</a> — Enables non-public getter usage, which is similar to the capability of the Newtonsoft.Json <code><span>JsonProperty</span></code> attribute.</li></ul><p>At the same time, we’re also improving the usability of System.Text.Json:</p><ul><li><a href="https://github.com/dotnet/runtime/pull/33459" target="_blank">Add new System.Net.Http.Json project/namespace</a> – Adds <a href="https://github.com/dotnet/runtime/issues/32937" target="_blank">new extension methods for HttpClient that allow serialization from/to JSON</a>.</li><li><a href="https://github.com/dotnet/runtime/pull/34725" target="_blank">Add copy constructor to JsonSerializerOptions</a> – Enables a library of framework to manage a <code><span>JsonSerializerOptions</span></code> instance, with specific values it sets, while the type versions over time.</li></ul><h2>WinRT Interop</h2><p>We are moving to a <a href="https://github.com/dotnet/runtime/issues/35318" target="_blank">new model for supporting WinRT APIs as part of .NET 5.0</a>. This includes calling APIs (in either direction; CLR &lt;==&gt; WinRT), marshaling of data between the two type systems, and unification of types that are intended to be treated the same across the boundary (i.e. “projected types”; <a href="https://docs.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1" rel="nofollow" target="_blank"><code><span>IEnumerable</span><span>&lt;</span><span>T</span><span>&gt;</span></code></a> and <a href="https://docs.microsoft.com/uwp/api/windows.foundation.collections.iiterable-1" target="_blank"><code><span>IIterable</span><span>&lt;</span><span>T</span><span>&gt;</span></code></a> are examples).</p><p>We will rely on a <a href="https://github.com/microsoft/CsWinRT" target="_blank">new set of WinRT tools</a> provided by the WinRT team in Windows that will generate C#-based WinRT interop assemblies. We are currently working closely with that team. The tools and the assemblies generated by them will be delivered for .NET 5.0.</p><p>There are several benefits to the new system:</p><ul><li>Can be developed and improved separate from the .NET runtime.</li><li>Symmetrical with interop systems provided for other OSes, like iOS and Android.</li><li>Can take advantage of many other .NET features (AOT, C# features, IL linking).</li><li>Simplifies the .NET runtime codebase.</li></ul><p>We will be removing the existing WinRT interop system from the .NET runtime (and any other associated components) as part of .NET 5.0. This means that apps using WinRT with .NET Core 3.x will need to be rebuilt and will not run on .NET 5.0 as-is.</p><h3>Open source project improvements</h3><p>We care a lot about open source, including enabling the .NET community to be productive on GitHub, and making .NET projects accessible to a large set of developers. We’ve been working on a variety of initiatives along those lines.</p><p><a href="https://github.com/dotnet/source-build" target="_blank">dotnet/source-build</a> enables building the entire .NET project/product from source with a single command. <a href="http://redhatloves.net/" target="_blank">Red Hat</a> uses this project to build the version of .NET Core that they distribute, and we work closely with them on that. <a href="https://fedoraproject.org/wiki/DotNet" rel="nofollow" target="_blank">Fedora also uses source-build</a> to enable .NET Core in their package repositories. We want to make it straightforward for any developer, organization or company to use source-build, and are investing significantly in the project. You can follow the <a href="https://github.com/dotnet/source-build/issues/1500" target="_blank">.NET 5.0 source-build effort</a> directly.</p><p>We started out the .NET Core project with too many GitHub repos. At its high, we had over 100 repos. That was too many to make sense to anyone, including the .NET Team. As part of the .NET 5.0 project, we decided to reduce the number of repos to a small and manageable collection. We announced our <a href="https://github.com/dotnet/announcements/issues/119" target="_blank">intention to consolidate .NET repos</a> in August, 2019, and then provided a <a href="https://github.com/dotnet/announcements/issues/127" target="_blank">final update on the plan</a> the following October. As part of that plan, we merged many repos together and almost all .NET repos are now in <a href="https://github.com/dotnet" target="_blank">dotnet org</a>, including <a href="https://github.com/dotnet/aspnetcore" target="_blank">dotnet/aspnetcore</a>. We retained repo history as part of the effort, which had some <a href="https://twitter.com/migueldeicaza/status/1219748706611798022" rel="nofollow" target="_blank">funny side-effects</a>. We continue to use the old repos for servicing the 2.1 and 3.1 product versions. <a href="https://github.com/microsoft/msbuild" target="_blank">MSBuild</a> and <a href="https://github.com/NuGet/NuGet.Client" target="_blank">NuGet client</a> repos remain in other orgs.</p><p>We are also working on <a href="https://github.com/dotnet/arcade/blob/master/Documentation/Net5Builds.md" target="_blank">reducing build times</a> for most repos. Quicker build times make everyone more productive, and enable you to see PR build results quicker. This is a longer-term effort, and a theme that will repeat in subsequent releases. You can track progress at <a href="https://github.com/dotnet/arcade/blob/master/Documentation/Net5BuildTImeReductionStatus.md" target="_blank">.NET 5 Build Time Reduction Status</a>.</p><p>We largely focus on improving the product, but are more recently turning our attention to improving the .NET open source project for contributors and other participants. We recently asked for <a href="https://github.com/dotnet/announcements/issues/154" target="_blank">feedback on improving the project and the experience participating in .NET repos</a>. It is important to us that everyone feels like they have a voice (on project-related topics) on .NET project repos, that they are treated well, and that they can accomplish their goals. That doesn’t mean we accept every PR or suggestion filed as an issue. As it relates to our approach, we intend to use clear language, be neutral to kind in our engagement, and encourage contribution. Are we getting this right? What would you like to see us do differently or better? Please give us your feedback on our <a href="https://www.surveymonkey.com/r/ZLPVNX9?SourceRepo=dotnet-blog" rel="nofollow" target="_blank">repo contribution experience survey</a>.</p><p>We have been asked multiple times to clarify and liberalize .NET Core licenses. We’ve done that, each time moving source and binary assets to the <a href="https://github.com/dotnet/core/blob/master/LICENSE.TXT" target="_blank">MIT license</a>. More recently, we’ve <a href="https://github.com/dotnet/installer/issues/7043" target="_blank">clarified the license we use for .NET Windows builds</a>. For most users, these changes won’t matter much, but for others, they do, and we’ve done our best to satisfy their needs.</p><h2>New improvements in Preview 4</h2><p>The following improvements are new in Preview 4 and not otherwise covered in the earlier highlights section.</p><h3>C# 9</h3><p>.NET 5.0 Preview 4 includes the first preview of C# 9. The C# 9 preview includes numerous features including the first preview of Records, the first preview of top-level statements, improved pattern matching, and more. Here’s a sneak peek of some of the pattern matching improvements:</p><div id="gist103125103">
    <div>
      <div>
        <div>
  <div id="file-csharp9-patterns-cs">
    

  <div itemprop="text">
      
<div><table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-csharp9-patterns-cs-L1" data-line-number="1"></td>
        <td id="file-csharp9-patterns-cs-LC1"><span>using</span> <span>System</span>;</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L2" data-line-number="2"></td>
        <td id="file-csharp9-patterns-cs-LC2">
</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L3" data-line-number="3"></td>
        <td id="file-csharp9-patterns-cs-LC3"><span>public</span> <span>enum</span> <span>LifeStage</span></td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L4" data-line-number="4"></td>
        <td id="file-csharp9-patterns-cs-LC4">{</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L5" data-line-number="5"></td>
        <td id="file-csharp9-patterns-cs-LC5">    <span>Prenatal</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L6" data-line-number="6"></td>
        <td id="file-csharp9-patterns-cs-LC6">    <span>Infant</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L7" data-line-number="7"></td>
        <td id="file-csharp9-patterns-cs-LC7">    <span>Toddler</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L8" data-line-number="8"></td>
        <td id="file-csharp9-patterns-cs-LC8">    <span>EarlyChild</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L9" data-line-number="9"></td>
        <td id="file-csharp9-patterns-cs-LC9">    <span>MiddleChild</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L10" data-line-number="10"></td>
        <td id="file-csharp9-patterns-cs-LC10">    <span>Adolescent</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L11" data-line-number="11"></td>
        <td id="file-csharp9-patterns-cs-LC11">    <span>EarlyAdult</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L12" data-line-number="12"></td>
        <td id="file-csharp9-patterns-cs-LC12">    <span>MiddleAdult</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L13" data-line-number="13"></td>
        <td id="file-csharp9-patterns-cs-LC13">    <span>LateAdult</span></td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L14" data-line-number="14"></td>
        <td id="file-csharp9-patterns-cs-LC14">}</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L15" data-line-number="15"></td>
        <td id="file-csharp9-patterns-cs-LC15">
</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L16" data-line-number="16"></td>
        <td id="file-csharp9-patterns-cs-LC16"><span>public</span> <span>class</span> <span>C</span></td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L17" data-line-number="17"></td>
        <td id="file-csharp9-patterns-cs-LC17">{</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L18" data-line-number="18"></td>
        <td id="file-csharp9-patterns-cs-LC18">    <span><span>//</span> "is not" patterns</span></td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L19" data-line-number="19"></td>
        <td id="file-csharp9-patterns-cs-LC19">    <span>public</span> <span>static</span> <span>bool</span> <span>IsNotNull</span>&lt;<span>T</span>&gt;(<span>T</span> <span>item</span>) <span>=&gt;</span> <span>item</span> <span>is</span> <span>not</span> <span>null</span>;</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L20" data-line-number="20"></td>
        <td id="file-csharp9-patterns-cs-LC20">    </td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L21" data-line-number="21"></td>
        <td id="file-csharp9-patterns-cs-LC21">    <span><span>//</span> Relational patterns</span></td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L22" data-line-number="22"></td>
        <td id="file-csharp9-patterns-cs-LC22">    <span>public</span> <span>static</span> <span>LifeStage</span> <span>LifeStageAtAge</span>(<span>int</span> <span>age</span>) <span>=&gt;</span></td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L23" data-line-number="23"></td>
        <td id="file-csharp9-patterns-cs-LC23">        <span>age</span> <span>switch</span></td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L24" data-line-number="24"></td>
        <td id="file-csharp9-patterns-cs-LC24">        {</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L25" data-line-number="25"></td>
        <td id="file-csharp9-patterns-cs-LC25">            <span>&lt;</span> <span>0</span> <span>=</span><span>&gt;</span>  <span>LifeStage</span>.<span>Prenatal</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L26" data-line-number="26"></td>
        <td id="file-csharp9-patterns-cs-LC26">            <span>&lt;</span> <span>2</span> <span>=</span><span>&gt;</span>  <span>LifeStage</span>.<span>Infant</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L27" data-line-number="27"></td>
        <td id="file-csharp9-patterns-cs-LC27">            <span>&lt;</span> <span>4</span> <span>=</span><span>&gt;</span>  <span>LifeStage</span>.<span>Toddler</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L28" data-line-number="28"></td>
        <td id="file-csharp9-patterns-cs-LC28">            <span>&lt;</span> <span>6</span> <span>=</span><span>&gt;</span>  <span>LifeStage</span>.<span>EarlyChild</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L29" data-line-number="29"></td>
        <td id="file-csharp9-patterns-cs-LC29">            <span>&lt;</span> <span>12</span> <span>=</span><span>&gt;</span> <span>LifeStage</span>.<span>MiddleChild</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L30" data-line-number="30"></td>
        <td id="file-csharp9-patterns-cs-LC30">            <span>&lt;</span> <span>20</span> <span>=</span><span>&gt;</span> <span>LifeStage</span>.<span>Adolescent</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L31" data-line-number="31"></td>
        <td id="file-csharp9-patterns-cs-LC31">            <span>&lt;</span> <span>40</span> <span>=</span><span>&gt;</span> <span>LifeStage</span>.<span>EarlyAdult</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L32" data-line-number="32"></td>
        <td id="file-csharp9-patterns-cs-LC32">            <span>&lt;</span> <span>65</span> <span>=</span><span>&gt;</span> <span>LifeStage</span>.<span>MiddleAdult</span>,</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L33" data-line-number="33"></td>
        <td id="file-csharp9-patterns-cs-LC33">            <span>_</span> <span>=&gt;</span>    <span>LifeStage</span>.<span>LateAdult</span></td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L34" data-line-number="34"></td>
        <td id="file-csharp9-patterns-cs-LC34">        };</td>
      </tr>
      <tr>
        <td id="file-csharp9-patterns-cs-L35" data-line-number="35"></td>
        <td id="file-csharp9-patterns-cs-LC35">}</td>
      </tr>
</tbody></table></div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>
<p>You can play with this same code at <a href="https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLQAdYwggdsgZgB8ABAJgEYBYAKFpIIAIJc4BbRgGQEtIBlGFADmEWgG9ajKYwAKSXLCgAbADSTpASVxgouGGprTGAFQD2AE3NKcBowFEoCJQE8AwgAtuS87ekBZbktrDy8fdSkAQXNTa2QAYxZ9cMYHJ2couCUkw39AqwgMrN8pTlgC80yYWgBfWnomckZXcWSAelbGACJuZEZcUxhOxkwYbDxkZIZGEgoANkZgUxjGDWQAOQG1zKUAHmMAPgAKY0ZubDYASkYAXn3T89Pe/pg+7YBuZLaOgCUIJVhuKYFEphlgcPhJg05lxeBABMIIDD+IIRBEYBERIduHpGAirrdkkYEYxkAB3M5xdyE6QSHJGemMHaMAAMNzuSLhKIgADo5CxFKpqQymWQ2SVYfCRNytDo9MUGdImQAWMUcyU8sxBGxC+lM+a3cXIhHc1IuELeeUKxmMCiig08I1SgJa81hOlW61kVn2iVc7lRGIoBJynVGZXeu4OznG03pCpFUOKxizACsYqj6u5zvyhWyHukAH1VYbo1LSthc5bpNUPjRajQgA==" rel="nofollow" target="_blank">Sharplab.io</a>.</p><p>Stay tuned for our blog post tomorrow that dives into all the details.</p><h3>F# 5</h3><p>Building on the <a href="https://devblogs.microsoft.com/dotnet/announcing-f-5-preview-1/" rel="nofollow">F# 5 preview released earlier this year</a>, the update to F# 5 includes support for consuming Default Interface Methods (DIMs) and some big performance improvements. Here’s a sneak peek at the DIMs support in F#:</p><div id="gist103072041">
    <div>
      <div>
        <div>
  <div id="file-dim-fsharp-fsx">
    

  <div itemprop="text">
      
<div><table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-dim-fsharp-fsx-L1" data-line-number="1"></td>
        <td id="file-dim-fsharp-fsx-LC1"><span>open</span> <span>CSharp</span></td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L2" data-line-number="2"></td>
        <td id="file-dim-fsharp-fsx-LC2">
</td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L3" data-line-number="3"></td>
        <td id="file-dim-fsharp-fsx-LC3"><span>// You can implement the interface via a class</span></td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L4" data-line-number="4"></td>
        <td id="file-dim-fsharp-fsx-LC4"><span>type</span> <span>MyType</span><span>()</span> <span>=</span></td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L5" data-line-number="5"></td>
        <td id="file-dim-fsharp-fsx-LC5">    <span>member</span> <span>_.M</span><span>()</span> <span>=</span> <span>()</span></td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L6" data-line-number="6"></td>
        <td id="file-dim-fsharp-fsx-LC6">
</td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L7" data-line-number="7"></td>
        <td id="file-dim-fsharp-fsx-LC7">    <span>interface</span> MyDim</td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L8" data-line-number="8"></td>
        <td id="file-dim-fsharp-fsx-LC8">
</td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L9" data-line-number="9"></td>
        <td id="file-dim-fsharp-fsx-LC9"><span>let</span> <span>md</span> <span>=</span> MyType<span>()</span> <span>:&gt;</span> MyDim</td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L10" data-line-number="10"></td>
        <td id="file-dim-fsharp-fsx-LC10">printfn <span><span>"</span>DIM from C#: %d<span>"</span></span> md.Z</td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L11" data-line-number="11"></td>
        <td id="file-dim-fsharp-fsx-LC11">
</td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L12" data-line-number="12"></td>
        <td id="file-dim-fsharp-fsx-LC12"><span>// You can also implement it via an object expression</span></td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L13" data-line-number="13"></td>
        <td id="file-dim-fsharp-fsx-LC13"><span>let</span> <span>md</span><span>'</span> <span>=</span> <span>{</span> <span>new</span> MyDim <span>}</span></td>
      </tr>
      <tr>
        <td id="file-dim-fsharp-fsx-L14" data-line-number="14"></td>
        <td id="file-dim-fsharp-fsx-LC14">printfn <span><span>"</span>DIM from C# but via Object Expression: %d<span>"</span></span> md'.Z</td>
      </tr>
</tbody></table></div>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>
<p>Stay tuned for a blog post tomorrow that goes over the details.</p><h3>C# Source Generators update</h3><p>This release also includes an update to the <a href="https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/" rel="nofollow">C# Source Generators preview</a>. In addition to some bug fixes, it includes support for passing an analyzerconfig, which is essentially a list of key-value pairs, to a Source Generator. This lets your source generators work differently based on the input they recieve. For example, you may want to generate source code differently if a consuming project targets .NET Framework vs. .NET 5. Using an analyzerconfig allows you to pass information like a consuming project’s TFM to allow for exactly this scenario.</p><h3>Support for ICU on Windows</h3><p>We use the <a href="http://site.icu-project.org/" rel="nofollow" target="_blank">ICU</a> library that provides Unicode and Globalization support for applications on Linux and macOS. We are now using <a href="https://docs.microsoft.com/en-us/windows/win32/intl/international-components-for-unicode--icu-" rel="nofollow" target="_blank">this same library on Windows</a>. <a href="https://github.com/dotnet/runtime/pull/34645" target="_blank">This change</a> makes the behavior of globalization APIs such as culture-specific string comparison consistent between Windows 10 and other operating systems.</p><h3>Support for cgroup v2 (for containers)</h3><p>.NET now has <a href="https://github.com/dotnet/runtime/pull/34334" target="_blank">support for cgroup v2</a>, which we expect will become an important container-related API in 2020 and beyond. Docker currently uses cgroup v1 (which is already supported by .NET). In comparison, cgroup v2 is simpler, more efficient, and more secure than cgroup v1. You can learn more about <a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/" rel="nofollow">cgroup and Docker resource limits</a> from our 2019 Docker update. Linux distros and containers runtimes are in the <a href="https://medium.com/nttlabs/cgroup-v2-596d035be4d7" rel="nofollow" target="_blank">process of adding support for cgroup v2</a>. .NET 5.0 will work correctly in cgroup v2 environments once they become more common. Credit to <a href="https://github.com/omajid" target="_blank">Omair Majid</a>, who supports .NET at Red Hat.</p><h3>Reducing the size of container images</h3><p>We are always looking for opportunities to make .NET container images smaller and easier to use. We made a change in Preview 4 that dramatically reduces the size of the aggregate images you pull in multi-stage-build scenarios (which is a very common pattern). We <a href="https://github.com/dotnet/dotnet-docker/pull/1848" target="_blank">re-based the SDK image on top of the ASP.NET image</a> instead of <a href="https://hub.docker.com/_/buildpack-deps" rel="nofollow" target="_blank">buildpack-deps</a>.</p><p>This change has the following win for multi-stage builds (example usage in <a href="https://github.com/dotnet/dotnet-docker/blob/master/samples/aspnetapp/Dockerfile" target="_blank">Dockerfile</a>):</p><p>Multi-stage build costs with <strong>Ubuntu 20.04 Focal</strong>:</p><div><table><thead><tr><th>Pull Image</th><th>Before</th><th>After</th></tr></thead><tbody><tr><td><code><span>sdk</span><span>:</span><span>5.0</span><span>-</span><span>focal</span></code></td><td>268 MB</td><td>232 MB</td></tr><tr><td><code><span>aspnet</span><span>:</span><span>5.0</span><span>-</span><span>focal</span></code></td><td>64 MB</td><td>10 KB (manifest only)</td></tr></tbody></table></div><p><em>Net download savings</em>: 100 MB (-30%)</p><p>Multi-stage build costs with <strong>Debian 10 Buster</strong>:</p><div><table><thead><tr><th>Pull Image</th><th>Before</th><th>After</th></tr></thead><tbody><tr><td><code><span>sdk</span><span>:</span><span>5.0</span></code></td><td>280 MB</td><td>218 MB</td></tr><tr><td><code><span>aspnet</span><span>:</span><span>5.0</span></code></td><td>84 MB</td><td>4 KB (manifest only)</td></tr></tbody></table></div><p><em>Net download savings</em>: 146 MB (-40%)</p><p>See <a href="https://github.com/dotnet/dotnet-docker/issues/1814#issuecomment-625294750" target="_blank">dotnet/dotnet-docker #1814</a> for more detailed information.</p><p>This change helps multi-stage builds, where the <code><span>sdk</span></code> and the <code><span>aspnet</span></code> or <code><span>runtime</span></code> image you are targeting are the same version (we expect that this is the common case). With this change, the <code><span>aspnet</span></code> pull (for example), will be a no-op, because you will have pulled the <code><span>aspnet</span></code> layers via the initial <code><span>sdk</span></code> pull.</p><p>If you want a bit more context, keep reading. For 3.1 and prior, the SDK is based on the <a href="https://hub.docker.com/_/buildpack-deps" rel="nofollow" target="_blank">buildpack-deps</a> image. When we started producing container images, we noticed other development platforms using buildpack-deps as the base of their tools/SDK images, so we followed the established pattern. We have specifically relied on the <a href="https://github.com/docker-library/buildpack-deps/blob/1bf287b61b2c02d8890f4806a9bfb2c7042b308d/focal/scm/Dockerfile" target="_blank"><code><span>scm</span></code> layer</a>, which includes source-control tools and is based on the <a href="https://github.com/docker-library/buildpack-deps/blob/1bf287b61b2c02d8890f4806a9bfb2c7042b308d/focal/curl/Dockerfile" target="_blank"><code><span>curl</span></code> layer</a>, which includes curl and similar network tools. That means that all those tools have been available to you in the SDK images. Unfortunately, this approach has come with a big tradeoff. Since Docker only allows for a single line of inheritance (each image can only have one parent), the <code><span>sdk</span></code> image needs to carry its own copy of ASP.NET, and Docker doesn’t see the actually identical ASP.NET bytes in the <code><span>sdk</span></code> image as the same as the ones in the <code><span>aspnet</span></code> image. That situation requires a lot of wasted bytes to be stored and transferred. On the other hand, people don’t want to give up using the tools provided by <code><span>buildpack</span><span>-</span><span>deps</span></code>.</p><p>As a compromise position, we re-based the <code><span>sdk</span></code> image on <code><span>aspnet</span></code>, added <a href="https://github.com/dotnet/dotnet-docker/pull/1848#issue-404674130" target="_blank">some of the tools back</a>, while retaining 90+% of the size savings.</p><p>This explanation is descriptive of what we did for Ubuntu. The story with Debian is more complicated, and responsible for the larger size win. In short, the Debian variants of <code><span>aspnet</span></code> and <code><span>runtime</span></code> are based on the <code><span>-</span><span>slim</span></code> Debian variant, while <code><span>buildpack</span><span>-</span><span>deps</span></code> is based on the non-slim Debian images. That means that for multi-stage builds with Debian, that you pull Debian twice! Even the distro layer hasn’t been shared until now.</p><p>We made similar changes for <a href="https://github.com/dotnet/dotnet-docker/pull/1832" target="_blank">Alpine and Nano Server</a>. There is no <code><span>buildpack</span><span>-</span><span>deps</span></code> image for either Alpine or Nano Server. However, the <code><span>sdk</span></code> images for Alpine and Nano Server were not previously built on top of the ASP.NET image. We fixed that. You will see significant size wins for Alpine and Nano Server as well with 5.0, for multi-stage builds.</p><p>We’ve known about these problems for a long time, but they had never been the next thing to go resolve. We decided that the 5.0 release was a good time to chase these size wins. Please tell us if there are any rough edges that we didn’t expect.</p><h2>.NET 5.0 will switch to the <code><span>dotnet</span></code> container repo</h2><p>As part of the move to “.NET” as the product name, we are now publishing .NET 5.0 Preview 4 and later images to the <a href="https://hub.docker.com/_/microsoft-dotnet" rel="nofollow" target="_blank"><code><span>mcr</span><span>.</span><span>microsoft</span><span>.</span><span>com</span><span>/</span><span>dotnet</span></code></a> family of repos, instead of <a href="https://hub.docker.com/_/microsoft-dotnet-core" rel="nofollow" target="_blank"><code><span>mcr</span><span>.</span><span>microsoft</span><span>.</span><span>com</span><span>/</span><span>dotnet</span><span>/</span><span>core</span></code></a>. Please update your <code><span>FROM</span></code> statements and scripts accordingly. .NET Core 3.1 and 2.1 will continue to be published to <a href="https://hub.docker.com/_/microsoft-dotnet-core" rel="nofollow" target="_blank"><code><span>mcr</span><span>.</span><span>microsoft</span><span>.</span><span>com</span><span>/</span><span>dotnet</span><span>/</span><span>core</span></code></a>. See <a href="https://github.com/dotnet/dotnet-docker/issues/1939" target="_blank">dotnet/dotnet-docker #1939</a>&nbsp;for more information.</p><h2>Closing</h2><p>.NET 5.0 is shaping up to be another big foundational release, much like .NET Core 1.0, 2.0 and 3.0. It includes many new improvements that should make your applications and development process better and easier. Much of the team has been working on .NET 5 since before we released .NET Core 3.0. We’ve been looking forward to releasing all these improvements in a near-final form for many months, and will now watch for your feedback as you try them out.</p><p>As you can see from the product investments we’ve chosen, we’re focused on modern scenarios, and giving you straightforward and predictable solutions that power the portfolio of applications you need, to run your business or organization. It’s critical to us that you give us feedback to help us improve the features that you’ve read about here, but also with that you’d like to see next. As you may have seen earlier in the post, we’re already deep into planning the .NET 6.0 release, so its not too early to give us future-looking feedback.</p><p>Please Share your feedback about .NET at <a href="https://aka.ms/dotnet5_feedback_blog" rel="nofollow" target="_blank">https://aka.ms/dotnet5_feedback_blog</a>.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>