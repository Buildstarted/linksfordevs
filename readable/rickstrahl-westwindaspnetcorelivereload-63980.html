<!DOCTYPE html>
<html lang="en">
<head>
    <title>
RickStrahl/Westwind.AspnetCore.LiveReload - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="RickStrahl/Westwind.AspnetCore.LiveReload - linksfor.dev(s)"/>
    <meta property="og:description" content="ASP.NET Core Live Reload Middleware that monitors file changes in your project and automatically reloads the browser&#x27;s active page - RickStrahl/Westwind.AspnetCore.LiveReload"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/RickStrahl/Westwind.AspnetCore.LiveReload"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - RickStrahl/Westwind.AspnetCore.LiveReload</title>
<div class="readable">
        <h1>RickStrahl/Westwind.AspnetCore.LiveReload</h1>
            <div>Reading time: 14-18 minutes</div>
        <div>Posted here: 08 Jul 2020</div>
        <p><a href="https://github.com/RickStrahl/Westwind.AspnetCore.LiveReload">https://github.com/RickStrahl/Westwind.AspnetCore.LiveReload</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    
      <div>
        <article itemprop="text">
<p><a href="https://www.nuget.org/packages/Westwind.AspnetCore.LiveReload/" rel="nofollow"><img src="https://camo.githubusercontent.com/5c708e48b787007664bdb70df66256899e71cc09/68747470733a2f2f696d672e736869656c64732e696f2f6e756765742f762f5765737477696e642e4173706e6574436f72652e4c69766552656c6f61642e737667" alt="NuGet" data-canonical-src="https://img.shields.io/nuget/v/Westwind.AspnetCore.LiveReload.svg"></a>
<a href="https://www.nuget.org/packages/Westwind.AspnetCore.LiveReload/" rel="nofollow"><img src="https://camo.githubusercontent.com/aadda9c7dc3adb8b01ec278eaf721d4ea876cf53/68747470733a2f2f696d672e736869656c64732e696f2f6e756765742f64742f5765737477696e642e4173706e6574436f72652e4c69766552656c6f61642e737667" alt="" data-canonical-src="https://img.shields.io/nuget/dt/Westwind.AspnetCore.LiveReload.svg"></a></p>
<ul>
<li>
<p><strong>Live Reload Middleware Component</strong><br>
Add the middleware to an existing Web UI Project to provide Live Reload functionality that causes the active page to reload if a file is changed.</p>
</li>
<li>
<p><strong><a href="https://github.com/RickStrahl/Westwind.AspnetCore.LiveReload/blob/master/LiveReloadServer%2FREADME.md">Generic Static and Razor File  Web Server with Live Reload as a Dotnet Tool</a></strong><br>
There's also a <a href="https://www.nuget.org/packages/LiveReloadServer/" rel="nofollow">Dotnet Tool</a> and <a href="https://chocolatey.org/packages/LiveReloadWebServer" rel="nofollow">Chocolatey Package</a> that provide a generic Static File and Razor Page Web Server with automatically enabled Live Reload functionality. Simply do <code>LiveReload</code> in folder with static HTML resources and you can serve the pages. Make changes and see the the changes reflected immediately. There's separate information in the <a href="https://github.com/RickStrahl/Westwind.AspnetCore.LiveReload/blob/master/LiveReloadServer/README.md">LiveReload Server</a> project.</p>
</li>
</ul>
<h2>Install the Live Reload Middleware</h2>
<p>You can install the Live Reload middleware <a href="https://www.nuget.org/packages/Westwind.AspNetCore.LiveReload" rel="nofollow">from NuGet</a>:</p>
<div><pre><span>PS</span>&gt; <span>Install-Package</span> <span>WestWind.AspnetCore.LiveReload</span></pre></div>
<p>or via the .NET Core CLI:</p>
<div><pre>dotnet add package Westwind.AspnetCore.LiveReload</pre></div>
<p>It works with:</p>
<ul>
<li>Client side static files  (HTML, CSS, JavaScript etc.)</li>
<li>ASP.NET Core Views/Pages (.cshtml)</li>
<li>Server Side compiled code updates (combined w/ <code>dotnet watch</code>)</li>
<li>Limited Blazor Support (<a href="#blazor-support">see below</a>)</li>
</ul>
<p>The Middleware is self-contained and has no external dependencies - there's nothing else to install or run. You should run <code>dotnet watch run</code> to automatically reload server side code to reload the server.  The middleware can then automatically refresh the browser. The extensions monitored for are configurable.</p>
<ul>
<li><a href="https://weblog.west-wind.com/posts/2019/Jun/03/Building-Live-Reload-Middleware-for-ASPNET-Core" rel="nofollow">Detailed blog post with Implementation Details</a></li>
<li><a href="https://www.nuget.org/packages/Westwind.AspNetCore.LiveReload" rel="nofollow">NuGet Package</a></li>
</ul>
<h4>Minimum Requirements:</h4>
<ul>
<li>ASP.NET Core 2.1</li>
</ul>
<p>Here's a short video that demonstrates some of the functionality:</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/RickStrahl/Westwind.AspnetCore.LiveReload/blob/master/Westwind.AspNetCore.LiveReload.gif?raw=true"><img src="https://github.com/RickStrahl/Westwind.AspnetCore.LiveReload/raw/master/Westwind.AspNetCore.LiveReload.gif?raw=true" alt=""></a></p>
<p>This demonstrates updating Razor Views/Pages, static CSS and HTML content, and making a source code change in a controller that affects the UI. The only thing 'running' is <code>dotnet.watch.run</code> and there are no manual updates.</p>
<h2>What does it do?</h2>
<p>This middleware monitors for file changes in your project and tries to automatically refresh your browser when a change is detected. It uses a <code>FileWatcher</code> to monitor for file changes, and a <code>WebSocket</code> 'server' that client pages connect to refresh the page. The middleware intercepts all HTML page requests and injects a block of JavaScript code that hooks up the client WebSocket interface to support the 'remote' refresh operation. When file changes are detected the server pushes the refresh requests to the pages that are listening on the WebSocket.</p>
<p>This tool uses raw WebSockets, so it's very light weight with no additional library dependencies. You can also turn off Live Reload with a configuration setting in which case the middleware is not hooked up at all.</p>
<p>In order to restart the server for server code changes you need to run your application with <code>dotnet watch run</code>. This built-in tool automatically restarts your .NET Core application anytime a code change is made. <code>dotnet watch run</code> is optional, but without it server side code changes require you to manually restart the server. Razor Views/Pages don't require <code>dotnet watch run</code> to refresh since they are dynamically compiled in development.</p>
<h3>Configuration</h3>
<p>The full configuration and run process looks like this:</p>
<ul>
<li>Add <code>services.AddLiveReload()</code> in <code>Startup.ConfigureServices()</code></li>
<li>Add <code>app.UseLiveReload()</code> in <code>Startup.Configure()</code></li>
<li>Run <code>dotnet watch run</code> to run your application</li>
</ul>
<p>Add the namespace in <code>Startup.cs</code>:</p>
<div><pre><span>using</span> <span>Westwind</span>.<span>AspNetCore</span>.<span>LiveReload</span>;</pre></div>
<h4>Startup.ConfigureServices()</h4>
<p>Start with the following in <code>Startup.ConfigureServices()</code>:</p>
<div><pre><span>services</span>.<span>AddLiveReload</span>(<span>config</span> <span>=&gt;</span>
{
    <span><span>//</span> optional - use config instead</span>
    <span><span>//</span>config.LiveReloadEnabled = true;</span>
    <span><span>//</span>config.FolderToMonitor = Path.GetFullname(Path.Combine(Env.ContentRootPath,"..")) ;</span>
});

<span><span>//</span> for ASP.NET Core 3.0 add Runtime Razor Compilation</span>
<span><span>//</span> services.AddRazorPages().AddRazorRuntimeCompilation();</span>
<span><span>//</span> services.AddMvc().AddRazorRuntimeCompilation();</span></pre></div>
<p>The <code>config</code> parameter is optional and it's actually recommended you set any values via configuration (see below).</p>
<blockquote>
<h4>Enable ASP.NET Core 3.0 Runtime Razor View Compilation</h4>
<p><strong>ASP.NET Core 3.0 by default doesn't compile Razor views at runtime</strong>, so any changes to Razor Views and Pages will not auto-reload in 3.0. You need to add the <code>Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation</code> package, and explicitly enable runtime compilation in <code>ConfigureServices()</code>:</p>
<div><pre><span>services</span>.<span>AddRazorPages</span>().<span>AddRazorRuntimeCompilation</span>();
<span>services</span>.<span>AddMvc</span>().<span>AddRazorRuntimeCompilation</span>();</pre></div>
</blockquote>
<h4>Startup.Configure()</h4>
<p>In <code>Startup.Configure()</code> add:</p>
<div><pre><span><span>//</span> Before any other output generating middleware handlers</span>
<span>app</span>.<span>UseLiveReload</span>();

<span>app</span>.<span>UseStaticFiles</span>();
<span>app</span>.<span>UseMvcWithDefaultRoute</span>();</pre></div>
<p>anywhere before the MVC route. I recommend you add this early in the middleware pipeline before any other output generating middleware runs as it needs to intercept any HTML content and inject the Live Reload script into it.</p>
<p>And you can use these configuration settings:</p>
<div><pre>{
  <span><span>"</span>LiveReload<span>"</span></span>: {
    <span><span>"</span>LiveReloadEnabled<span>"</span></span>: <span>true</span>,
    <span><span>"</span>ClientFileExtensions<span>"</span></span>: <span><span>"</span>.cshtml,.css,.js,.htm,.html,.ts,.razor,.custom<span>"</span></span>,
    <span><span>"</span>ServerRefreshTimeout<span>"</span></span>: <span>3000</span>,
    <span><span>"</span>WebSocketUrl<span>"</span></span>: <span><span>"</span>/__livereload<span>"</span></span>,
    <span><span>"</span>WebSocketHost<span>"</span></span>:<span>null</span>, 
    <span><span>"</span>FolderToMonitor<span>"</span></span>: <span><span>"</span>~/<span>"</span></span>
  }
}</pre></div>
<p>All of these settings are optional.</p>
<ul>
<li>
<p><strong>LiveReloadEnabled</strong><br>
If this flag is false live reload has no impact as it simply passes through requests.<br>
<em>The default is:</em> <code>true</code>.</p>
<blockquote>
<p>I recommend you put: <code>"LiveReloadEnabled": false</code> into <code>appsettings.json</code> and <code>"LiveReloadEnabled": true</code> into <code>appsettings.Development.json</code> so this feature isn't accidentally enabled in Production.</p>
</blockquote>
</li>
<li>
<p><strong>ClientFileExtensions</strong><br>
File extensions that the file watcher watches for in the Web project. These are files that can refresh without a server recompile, so don't include source code files here. Source code changes are handled via restarts with <code>dotnet watch run</code>.</p>
</li>
<li>
<p><strong>FileIncludeFilter</strong>
This filter allows you programmatic control over whether a file should auto-refresh or not. This allows control beyond the basic file extension mapping, and lets you explicitly handle special use cases where you might not want to refresh the page when a certain file or files are updated. This can minimize your reloads especially if you are dealing with many generated files for external tools like WebPack.</p>
<p>For example, if you want to exclude <code>_autogenerated.cshtml</code> to cause refreshes, you might want to set the filter the following way:</p>
<div><pre><span>services</span>.<span>AddLiveReload</span>(<span>cfg</span> <span>=&gt;</span> {
    <span>cfg</span>.<span>FileIncludeFilter</span> <span>=</span> <span>path</span> <span>=&gt;</span> <span>!</span><span>path</span>.<span>Contains</span>(<span><span>"</span>_autogenerated<span>"</span></span>);
})</pre></div>
</li>
<li>
<p><strong>ServerRefreshTimeout</strong>
Set this value to get a close approximation how long it takes your server to restart when <code>dotnet watch run</code> reloads your application. This minimizes how frequently the client page monitors for the Web socket to become available again after disconnecting.</p>
</li>
<li>
<p><strong>WebSocketUrl</strong><br>
The site relative URL to the Web socket handler.</p>
</li>
<li>
<p><strong>WebSocketHost</strong><br>
An explicit WebSocket host URL. Useful if you are running on HTTP2 which doesn't support WebSockets (yet) and you can point at another exposed host URL in your server that serves HTTP1.1. Don't set this unless you have to - the default uses the current host of the request. Example: <code>wss://localhost:5200</code></p>
</li>
<li>
<p><strong>FolderToMonitor</strong><br>
This is the folder that's monitored. By default it's <code>~/</code> which is the Web Project's content root (not the Web root). Other common options are: <code>~/wwwroot</code> for Web only, <code>~/../</code> for <strong>the entire solution</strong>, or <code>~/../OtherProject/</code> for <strong>another project</strong> (which works well for client side Razor).</p>
</li>
</ul>
<h2>Try it out</h2>
<p>So to check out this functionality you can run the simple stock ASP.NET Core sample project. Let's demonstrate the three common live reload scenarios:</p>
<ul>
<li>Updating Static Files</li>
<li>Updating Razor Views/Pages</li>
<li>Updating on server code changes</li>
</ul>
<h3>Update Static Files</h3>
<ul>
<li>Start the application (recommend <code>dotnet watch run</code> but not required)</li>
<li>Open the Index Page</li>
<li>Open `wwwroot/css/site.css'</li>
<li>Make a change in the CSS  (change the Font-size in the first <code>html</code> entries)</li>
<li>Save the file</li>
</ul>
<p>You should see the change reflected immediately. Sometime you may have to refresh once to get the cache to reset for CSS changes to show, but subsequent refreshes should show immediately.</p>
<h3>Update Razor Views</h3>
<ul>
<li>Start the application (recommend <code>dotnet watch run</code> but not required)</li>
<li>Open the Index Page</li>
<li>Open <code>Views/Home/Index.cshtml</code></li>
<li>Make a change in the Header text - <code>Welcome Live Reload</code></li>
<li>Save the file</li>
</ul>
<p>You should see the change reflected immediately.</p>
<h3>Server Changes</h3>
<ul>
<li>Start the application with <code>dotnet watch run</code> (required or you need to manually restart)</li>
<li>Open the Index Page</li>
<li>Open <code>Controllers/HomeController.cs</code></li>
<li>Make a change in <code>ViewBag.Message</code></li>
<li>Save the file</li>
</ul>
<p>The page will refresh but it will take a while as the server has to restart. Typically 3-5 seconds or so for a simple project, longer for more complex projects obviously.</p>
<p>You may have to tweak the <code>ServerRefreshTimeout</code> value to account for the time your server takes to restart to get a reliable refresh.</p>
<h2>HTTP2 Support</h2>
<p>If you're using this extension with HTTP2 connections make sure you set your connections to support <strong>both Http1 and Http2</strong>. WebSockets don't work over HTTP2, so you need to also expose HTTP1 endpoints.</p>
<p>To do this you you can use this in your startup Builder configuration:</p>
<div><pre><span>public</span> <span>static</span> <span>IWebHostBuilder</span> <span>CreateWebHostBuilder</span>(<span>string</span>[] <span>args</span>) <span>=&gt;</span>
    <span>WebHost</span>.<span>CreateDefaultBuilder</span>(<span>args</span>)
        .<span>ConfigureKestrel</span>(<span>options</span> <span>=&gt;</span>
        {
            <span>options</span>.<span>ConfigureEndpointDefaults</span>(<span>c</span> <span>=&gt;</span> <span>c</span>.<span>Protocols</span> <span>=</span> <span>HttpProtocols</span>.<span>Http1AndHttp2</span>);
        })
        .<span>UseStartup</span>&lt;<span>Startup</span>&gt;();</pre></div>
<p>The important bit is <code>c.Protocols = HttpProtocols.Http1AndHttp2</code>.</p>
<h2>Blazor Support?</h2>
<p>Several people have asked about Blazor support and yes this tool can provide refresh to Blazor applications and yes it can - sort of.</p>
<h3>Server Side Blazor</h3>
<p>If you are using a server side Blazor project you can just use <code>dotnet watch run</code> which automatically provides browser refresh (unreliable but it sort of works). You'll need to add:</p>
<div><pre>&lt;<span>ItemGroup</span>&gt;
    &lt;<span>Watch</span> <span>Include</span>=<span><span>"</span>***.razor<span>"</span></span> /&gt;
&lt;/<span>ItemGroup</span>&gt;</pre></div>
<p>and that should work. In my experience this is really flakey though and you can double that up with this Live Reload addin which will also refresh the page when the project restarts.</p>
<h3>Client Side Blazor</h3>
<p>For client side Blazor the story is more complex and there's no real good solution for quick auto-reload, because client side blazor has no individual page recompile, but has to completely recompile the blazor project.</p>
<p>Live Reload can work with this but it's slow as both the Blazor project has to be recompiled and the server project restarted (don't know if there's a way to just trigger a recompile of the client project on its own - if you think of a way please file an issue so we can add that!)</p>
<p>The following is based on the default project template that uses two projects for a client side blazor: The ASP.NET Core hosting project and the Blazor client project.</p>
<ul>
<li>Add LiveReload to the <strong>ASP.NET Core Server Project</strong></li>
<li>Set up monitoring for the entire solution (or the Blazor Project only)</li>
<li>Add the Blazor extension</li>
</ul>
<p>You can do this in configuration via:</p>
<div><pre>{
  <span><span>"</span>LiveReload<span>"</span></span>: {
    <span><span>"</span>LiveReloadEnabled<span>"</span></span>: <span>true</span>,
    <span><span>"</span>ClientFileExtensions<span>"</span></span>: <span><span>"</span>.css,.js,.htm,.html,.ts,.razor,.cs<span>"</span></span>,
    <span><span>"</span>FolderToMonitor<span>"</span></span>: <span><span>"</span>~/..<span>"</span></span>
  }
}</pre></div>
<p>This adds the <code>.razor,.cs</code> extensions and it basically monitors the entire Solution (<code>~/..</code>) for changes. Alternately you can also point at the Blazor project instead:</p>
<div><pre><span><span>"</span>FolderToMonitor<span>"</span></span>: <span><span>"</span>~/../MyBlazorProject<span>"</span></span></pre></div>
<p>Since Blazor projects tend to not care about the .NET Core backend that just acts as static file service you probably only need to monitor the client side project in Blazor projects. Either the entire solution or Blazor project folders work.</p>
<ul>
<li>Start the application with <code>dotnet watch run</code> (required or you need to manually restart)</li>
<li>Open the Index Page</li>
<li>Open <code>Pages/Index.razor</code></li>
<li>Make a change in the page</li>
<li>Save the file</li>
</ul>
<p>Reload will not be quick because the Blazor client project <strong>and</strong> the .NET Core project will recompile and restart. For a simple hello world it takes about 5 seconds on my local setup. For a full blown applications this may be even slower.</p>
<p>Obviously this is not ideal, but it's better than nothing. Live Reload works as it should but the underlying problem is that the actual content is not refreshing quickly enough to make this really viable.</p>
<p>We can only hope Microsoft come up with a built-in solution to trigger the recompilation of the client project or better yet recompilation of a single view as it's changed.</p>
<h2>Change Log</h2>
<h3>Version 0.2.4</h3>
<ul>
<li>
<p><strong>Better preservation of scroll position in Refresh script</strong><br>
Changed the client script to use <code>location.reload()</code> instead of a force refresh with <code>location.reload(true)</code>. The forced refresh also forces the top of the page to be displayed, while reload preserves scroll position in most browsers (Edge Chromium not for some reason)</p>
</li>
<li>
<p><strong>Add Lifecycle Management CancellationToken to Web Socket Read</strong><br>
Added the cancellation token to the <code>WebSocket.Receive()</code> operation so the socket can safely abort when the application is shut down. Previously this was causing problems in some application that used ASP.NET Core Lifecycle operations to not fire those event due to the still active WebSocket timing out before the app would shut down.</p>
</li>
<li>
<p><strong>Fix: Rendering Errors when Live Reload Enabled</strong><br>
Fix issue where rendering was failing due to a missing <code>await</code> on output generation which would intermittently cause pages to fail. Fixed.</p>
</li>
<li>
<p><strong>Fix: Errors with Concurrency for WebSocket Storage</strong><br>
Switched to ConcurrentDictionary for the Web Socket list storage.</p>
</li>
</ul>
<h3>Version 0.1.17</h3>
<ul>
<li>
<p><strong>Delay load injected WebSocket Script Code</strong><br>
Change the injected WebSocket script code so it delay loads to avoid potential page load hangs or dual updates.</p>
</li>
<li>
<p><strong>Update Response Rewrite to use IHttpResponseStreamFeature</strong><br>
Update internal code used to rewrite response data for HTML content using the recommended HTTP Features rather than rewriting the Response.Body stream directly.</p>
</li>
</ul>
<h4>Version 0.1.14</h4>
<ul>
<li>
<p><strong>Change Targeting to .NET Core 2.1 and 3.1</strong><br>
Changed targets to the LTS releases of .NET Core. Also changed dependencies to <code>Microsoft.AspNetCore.App</code> to reference all base ASP.NET Core base dependencies for better update package management support for apps integrating with this library.</p>
</li>
<li>
<p><strong>Update Samples</strong><br>
Updated the samples to be easier to use and provide links to files that can be edited so it's easier to try out the sample and see live reloading work. Also re-targeted the sample app to .NET Core 2.2 and 3.1 (two separate projects due to separate ASP.NET configuration config).</p>
</li>
</ul>
<h4>Version 0.1.07</h4>
<ul>
<li>
<p><strong>Add explicit support for .NET Core 3.0</strong><br>
Add a .NET Core 3.0 target to the NuGet package, to minimize package resolution issues.</p>
</li>
<li>
<p><strong>Add LiveReloadWebServer Chocolatey Package</strong><br>
Add support for a deployed fully self-contained <a href="https://chocolatey.org/packages/LiveReloadWebServer" rel="nofollow">Chocolatey Package</a>.</p>
</li>
</ul>
<h4>Version 0.1.5.4</h4>
<ul>
<li>
<p><strong><a href="https://github.com/RickStrahl/Westwind.AspnetCore.LiveReload/blob/master/LiveReloadServe/README.md">Add new standalone LiveReloadServer Dotnet Tool</a></strong><br>
Added a new generic live reload server that's used that can be used to serve generic static HTML content and loose Razor Pages out of a folder. It's basically a standalone static Web Server which by default has Live Reload enabled. Although meant as a local server/tool, it can also be used like any other ASP.NET Core application and run behind a Web server like IIS or NGINX.</p>
</li>
<li>
<p><strong>Fix issues with .NET Core 3.0</strong><br>
Fixed various compatibility issues related to API changes in .NET Core 3.0. Library now works with .NET Core 3.0.</p>
</li>
</ul>
<h4>Version 0.1.5.2</h4>
<ul>
<li>
<p><strong>Fix bug with Static HTML Files Content Length</strong><br>
Fix <code>Response.ContentLength</code> by setting to <code>null</code> to force contentlength be calculated. Static files set this value to a fixed length and when we re-write this breaks the length. Fixed.</p>
</li>
<li>
<p><strong>Update ASP.NET Core Packages to 2.1.1</strong><br>
Updated all core dependencies to use patched 2.1.1. Stick with</p>
</li>
</ul>
</article>
      </div>
  </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>