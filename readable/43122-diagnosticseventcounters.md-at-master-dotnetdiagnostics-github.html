<!DOCTYPE html>
<html lang="en">
<head>
    <title>
diagnostics/eventcounters.md at master &#xB7; dotnet/diagnostics &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>diagnostics/eventcounters.md at master · dotnet/diagnostics · GitHub</h1><div><div id="" class="markdown-body entry-content p-3 p-md-6"><h2><a id="user-content-introduction" class="anchor" aria-hidden="true" href="#introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction</h2><p>EventCounters are .NET Core APIs used for lightweight, cross-platform, and near real-time performance metric collection. EventCounters that were added as a cross-platform alternative to the "performance counters" on the .NET Framework on Windows. This documentation serves as a guide on what they are, how to implement them, and how to consume them.</p><p>The .NET Core runtime (CoreCLR) and few .NET libraries publish basic diagnostics information using EventCounters starting in .NET Core 3.0.</p><p>Apart from the EventCounters that are already provided by the .NET runtime or the rest of the framework (i.e. ASP.NET, gRPC, etc.), you may choose to implement your own EventCounters to keep track of various metrics for your service.</p><p>EventCounters live as a part of an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventsource?view=netcore-3.0" rel="nofollow">EventSource</a> and are automatically pushed to listener tools on a regular basis. Like any other events on an <code>EventSource</code>, they can be consumed both in-proc and out-of-proc via <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventlistener?view=netcore-3.0" rel="nofollow">EventListener</a> and EventPipe/ETW.</p><p><a target="_blank" rel="noopener noreferrer" href="/dotnet/diagnostics/blob/master/documentation/design-docs/EventCounters.jpg"><img src="/dotnet/diagnostics/raw/master/documentation/design-docs/EventCounters.jpg" alt="EventCounter"></a></p><h2><a id="user-content-runtime-counters" class="anchor" aria-hidden="true" href="#runtime-counters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Runtime Counters</h2><p>The .NET runtime (CoreCLR) publishes the following list of counters:
<code>System.Runtime</code> provider</p><ul><li>CPU usage</li><li>Working Set Size</li><li>GC Heap Size</li><li>Gen 0 GC Rate</li><li>Gen 1 GC Rate</li><li>Gen 2 GC Rate</li><li>% Time in GC</li><li>Gen 0 Heap Size</li><li>Gen 1 Heap Size</li><li>Gen 2 Heap Size</li><li>LOH Heap Size</li><li>Allocation Rate</li><li>Assembly Count</li><li>Exception Rate</li><li>ThreadPool Thread Count</li><li>Monitor Lock Contention Rate</li><li>ThreadPool Queue Length</li><li>ThreadPool Completed Items Rate</li><li>Active Timer Count</li></ul><p>Other components of .NET Core also publishes counters:
ASP.NET Core <code>Microsoft.AspNetCore.Hosting</code> provider</p><ul><li>Requests per second</li><li>Total Requests Count</li><li>Current Requests Count</li><li>Failed Requests Count</li></ul><p>SignalR <code>Microsoft.AspNetCore.Http.Connections</code> provider</p><ul><li>Total Connections Started</li><li>Total Connections Stopped</li><li>Total Connections Timed Out</li><li>Average Connection Duration</li></ul><h2><a id="user-content-eventcounters-api-overview" class="anchor" aria-hidden="true" href="#eventcounters-api-overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>EventCounters API Overview</h2><p>At a high level, there are two types of counters in terms of their <em>purpose</em> - counters for ever-increasing values (i.e. Total # of exceptions, Total # of GCs, Total # of requests, etc.) and "snapshot" values (heap usage, CPU usage, working set size, etc.). Within each of these categories of counters, there are also two types of counters depending on how they get their value - polling counters (value retrieved via a callback) and non-polling counters (value directly set on the counter). That gives us a total of 4 different counters, and each of these are implemented by <code>EventCounter</code>,  <code>PollingCounter</code>, <code>IncrementingEventCounter</code>, and <code>IncrementingPollingCounter</code>.</p><p>The runtime supports four different types of counters for different situations:</p><ol><li><p><code>EventCounter</code> records a set of values. The <code>WriteMetric()</code> method adds a new value to the set. At the end of each time interval, summary statistics for the set are computed such as the min, max, and mean. dotnet-counters will always display the mean value. EventCounter is useful to describe a discrete set of operations such as the average size in bytes of recent IO operations or the average monetary value of a set of financial transactions.</p></li><li><p><code>IncrementingEventCounter</code> records a running total. The <code>Increment()</code> method increases this total. At the end of each time period the difference between the total value for that period and the total of the previous period is reported as an increment. dotnet-counters will display this as a rate, the recorded total / time. This counter is useful to measure how frequently an action is occurring such as the number of requests processed each second.</p></li><li><p><code>PollingCounter</code> is a customizable counter that doesn't have any state and uses a callback to determine the value that is reported. At the end of each time interval the user provided callback function is invoked and whatever value it returns is reported as the current value of the counter. This counter can be used to query a metric from an external source, for example getting the current free bytes on a disk. It can also be used to report custom statistics that can be computed on demand by an application such as 95th percentile of recent request latencies or the current hit/miss ratio of a cache.</p></li><li><p><code>IncrementingPollingCounter</code> is a customizable counter that has no state and uses a callback to determine the increment that is reported. At the end of each time interval the callback is invoked and then the difference between the current invocation and the last invocation is the reported value. <code>dotnet-counters</code> always displays this as a rate, the reported value / time. This is useful to measure the rate at which some action is occurring when it isn't feasible to call an API on each occurrence, but it is possible to query the total number of times it has occurred. For example you could report the number of bytes written to a file / sec even if there is no notification each time a byte is written.</p></li></ol><h2><a id="user-content-writing-eventcounters" class="anchor" aria-hidden="true" href="#writing-eventcounters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writing EventCounters</h2><p>The following code implements a sample <code>EventSource</code> exposed as <code>Samples-EventCounterDemos-Minimal</code> provider. This source contains an <code>EventCounter</code> representing request processing time. Such a counter has a name (i.e. its unique ID in the source) and a display name both used by listener tools such as dotnet-counter.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span><span class="pl-en">System</span>;
<span class="pl-k">using</span><span class="pl-en">System</span>.<span class="pl-en">Diagnostics</span>.<span class="pl-en">Tracing</span>;

[<span class="pl-en">EventSource</span>(<span class="pl-en">Name</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Samples-EventCounterDemos-Minimal<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span><span class="pl-k">sealed</span><span class="pl-k">class</span><span class="pl-en">MinimalEventCounterSource</span> : <span class="pl-en">EventSource</span>
{
    <span class="pl-c"><span class="pl-c">//</span> define the singleton instance of the event source</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">MinimalEventCounterSource</span><span class="pl-smi">Log</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">MinimalEventCounterSource</span>();
    <span class="pl-k">public</span><span class="pl-en">EventCounter</span><span class="pl-smi">RequestTimeCounter</span>;

    <span class="pl-k">private</span><span class="pl-en">MinimalEventCounterSource</span>() : <span class="pl-k">base</span>(<span class="pl-smi">EventSourceSettings</span>.<span class="pl-smi">EtwSelfDescribingEventFormat</span>) 
    {
        <span class="pl-k">this</span>.<span class="pl-smi">RequestTimeCounter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">EventCounter</span>(<span class="pl-s"><span class="pl-pds">"</span>request-time<span class="pl-pds">"</span></span>, <span class="pl-k">this</span>)
        {
            <span class="pl-smi">DisplayName</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Request Processing Time<span class="pl-pds">"</span></span>,
            <span class="pl-smi">DisplayUnits</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>MSec<span class="pl-pds">"</span></span>
        };
    }

    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Main</span>()
    {
        <span class="pl-k">var</span><span class="pl-smi">rand</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Random</span>();
        <span class="pl-k">while</span>(<span class="pl-c1">true</span>)
        {
            <span class="pl-smi">MinimalEventCounterSource</span>.<span class="pl-smi">Log</span>.<span class="pl-smi">RequestTimeCounter</span>.<span class="pl-en">WriteMetric</span>(<span class="pl-smi">rand</span>.<span class="pl-en">NextDouble</span>());
        }
    }
}</pre></div><p>Create a new dotnet console app using the code above and run it. Then use <code>dotnet-counters ps</code> to see what its process ID is:</p><div class="highlight highlight-source-batchfile"><pre>C:\<span class="pl-k">&gt;</span>dotnet-counters ps
   <span class="pl-c1">1398652</span> dotnet     C:\Program Files\dotnet\dotnet.exe
   <span class="pl-c1">1399072</span> dotnet     C:\Program Files\dotnet\dotnet.exe
   <span class="pl-c1">1399112</span> dotnet     C:\Program Files\dotnet\dotnet.exe
   <span class="pl-c1">1401880</span> dotnet     C:\Program Files\dotnet\dotnet.exe
   <span class="pl-c1">1400180</span> sample-counters C:\sample-counters\bin\Debug\netcoreapp3.1\sample-counters.exe</pre></div><p>You need to pass the <code>EventSource</code> name as an argument to <code>--providers</code> to start monitoring your counter with the following command:</p><div class="highlight highlight-source-batchfile"><pre>C:\<span class="pl-k">&gt;</span>dotnet-counters monitor --process-id <span class="pl-c1">1400180</span> --providers Samples-EventCounterDemos-Minimal</pre></div><p>Then you will see the following screen in your console:</p><pre><code>Press p to pause, r to resume, q to quit.
    Status: Running

[Samples-EventCounterDemos-Minimal]
    Request Processing Time (MSec)                            0.445
</code></pre><p>Let's take a look at a couple of sample EventCounter implementation in the .NET Core runtime (CoreCLR). Here is the runtime implementation for the counter that tracks the working set size of the application.</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">PollingCounter</span><span class="pl-smi">workingSetCounter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">PollingCounter</span>(
    <span class="pl-s"><span class="pl-pds">"</span>working-set<span class="pl-pds">"</span></span>,
    <span class="pl-k">this</span>,
    () <span class="pl-k">=&gt;</span> (<span class="pl-k">double</span>)(<span class="pl-smi">Environment</span>.<span class="pl-smi">WorkingSet</span><span class="pl-k">/</span><span class="pl-c1">1_000_000</span>)
) 
{
    <span class="pl-smi">DisplayName</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Working Set<span class="pl-pds">"</span></span>,
    <span class="pl-smi">DisplayUnits</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>MB<span class="pl-pds">"</span></span>
};</pre></div><p>This counter reports the current working set of the app. It is a <code>PollingCounter</code>, since it captures a metric at a moment in time. The callback for polling the values is <code>() =&gt; (double)(Environment.WorkingSet / 1_000_000)</code> which is simply just a call to <code>Environment.WorkingSet</code> API. The <code>DisplayName</code> and <code>DisplayUnits</code> is an optional property that can be set to help the consumer side of the counter to display the value more easily/accurately. For example <code>dotnet-counters</code> uses these properties to display the more "pretty" version of the counter names.</p><p>And that's it! For <code>PollingCounter</code> (or <code>IncrementingPollingCounter</code>), there is nothing else that needs to be done since they poll the values themselves at the interval requested by the consumer.</p><p>Here is another example of runtime counter implemented using <code>IncrementingPollingCounter</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">IncrementingPollingCounter</span><span class="pl-smi">monitorContentionCounter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">IncrementingPollingCounter</span>(
    <span class="pl-s"><span class="pl-pds">"</span>monitor-lock-contention-count<span class="pl-pds">"</span></span>,
    <span class="pl-k">this</span>,
    () <span class="pl-k">=&gt;</span><span class="pl-smi">Monitor</span>.<span class="pl-smi">LockContentionCount</span>
)
{
    <span class="pl-smi">DisplayName</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Monitor Lock Contention Count<span class="pl-pds">"</span></span>,
    <span class="pl-smi">DisplayRateTimeScale</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">TimeSpan</span>(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>)
};</pre></div><p>This counter uses the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.monitor.lockcontentioncount?view=netcore-3.0" rel="nofollow">Monitor.LockContentionCount</a> API to report the increment of the total lock contention count. The <code>DisplayRateTimeScale</code> property is an optional <code>TimeSpan</code> which can be set to provide a hint of what time interval this counter is best displayed at. For example, the lock contention count is best displayed as <em>count per second</em>, so its <code>DisplayRateTimeScale</code> is set to 1 second. This can be adjusted for different types of rate counters.</p><p>There are more runtime counter implementation to use as a reference in the <a href="https://github.com/dotnet/runtime/blob/master/src/coreclr/src/System.Private.CoreLib/src/System/Diagnostics/Eventing/RuntimeEventSource.cs">CoreCLR</a> repo.</p><h2><a id="user-content-concurrency" class="anchor" aria-hidden="true" href="#concurrency"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Concurrency</h2><p>It is important to note that if the delegates passed to the <code>PollingCounter</code>/<code>IncrementingPollingCounter</code> instances are called by multiple threads at once, the EventCounters API does not guarantee thread safety. It is the author's responsibility to guarantee the thread-safety of the delegates being passed to the counter APIs.</p><p>For example, let's suppose we have the following <code>EventSource</code> to keep track of requests.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">RequestEventSource</span> : <span class="pl-en">EventSource</span>
{
    <span class="pl-c"><span class="pl-c">//</span> singleton instance of the eventsource.</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">RequestEventSource</span><span class="pl-smi">Log</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">RequestEventSource</span>();

    <span class="pl-k">public</span><span class="pl-en">IncrementingPollingCounter</span><span class="pl-smi">requestRateCounter</span>;
    <span class="pl-k">private</span><span class="pl-k">int</span><span class="pl-smi">_requestCnt</span>;

    <span class="pl-k">private</span><span class="pl-en">RequestEventSource</span>() : <span class="pl-k">base</span>(<span class="pl-smi">EventSourceSettings</span>.<span class="pl-smi">EtwSelfDescribingEventFormat</span>)
    {
        <span class="pl-smi">_requestCnt</span><span class="pl-k">=</span><span class="pl-c1">0</span>;
        <span class="pl-k">this</span>.<span class="pl-smi">requestRateCounter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">IncrementingPollingCounter</span>(<span class="pl-s"><span class="pl-pds">"</span>request-rate<span class="pl-pds">"</span></span>, <span class="pl-k">this</span>, () <span class="pl-k">=&gt;</span><span class="pl-smi">_requestCnt</span>)
        {
            <span class="pl-smi">DisplayName</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Request Rate<span class="pl-pds">"</span></span>,
            <span class="pl-smi">DisplayRateTimeScale</span><span class="pl-k">=</span><span class="pl-smi">TimeSpan</span>.<span class="pl-en">FromSeconds</span>(<span class="pl-c1">1</span>)
        };
    }

    <span class="pl-c"><span class="pl-c">//</span> Method being called from request handlers to log that a request happened</span><span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">AddRequest</span>()
    {
        <span class="pl-smi">_requestCnt</span><span class="pl-k">+=</span><span class="pl-c1">1</span>;
    }
}</pre></div><p><code>RequestEventSource.AddRequest()</code> can be called from a request handler, and <code>requestRateCounter</code> simply polls this value at the interval specified by the consumer of this counter. However, this method can be called by multiple threads at once, putting a race condition on <code>_requestCnt</code>.</p><p>Therefore, this method should be modified to update the value in a thread-safe way.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">AddRequest</span>()
{
    <span class="pl-smi">Interlocked</span>.<span class="pl-en">Increment</span>(<span class="pl-k">ref</span><span class="pl-smi">_requestCnt</span>);
}</pre></div><h2><a id="user-content-consuming-eventcounters" class="anchor" aria-hidden="true" href="#consuming-eventcounters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consuming EventCounters</h2><p>There are two main ways of consuming EventCounters: in-proc and out-of-proc.</p><h3><a id="user-content-consuming-in-proc" class="anchor" aria-hidden="true" href="#consuming-in-proc"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consuming in-proc</h3><p>You can consume the counter values via the <code>EventListener</code> API. <code>EventListener</code> is an in-proc way of consuming any Events written by all instances of EventSources in your application. For more details on how to use the EventListener API, refer to the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventlistener" rel="nofollow">EventListener documentation</a>.</p><p>First, the EventSource that produces the counter value needs to be enabled. To do this, you can override the <code>OnEventSourceCreated</code> method to get a notification when an EventSource is created, and if this is the correct EventSource with your EventCounters, then you can call Enable on it. Here is an example of such override:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">protected</span><span class="pl-k">override</span><span class="pl-k">void</span><span class="pl-en">OnEventSourceCreated</span>(<span class="pl-en">EventSource</span><span class="pl-smi">source</span>)
{
    <span class="pl-k">if</span> (<span class="pl-smi">source</span>.<span class="pl-smi">Name</span>.<span class="pl-en">Equals</span>(<span class="pl-s"><span class="pl-pds">"</span>System.Runtime<span class="pl-pds">"</span></span>))
    {
        <span class="pl-en">Dictionary</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">string</span>&gt; <span class="pl-smi">refreshInterval</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Dictionary</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">string</span>&gt;()
        {
            { <span class="pl-s"><span class="pl-pds">"</span>EventCounterIntervalSec<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span> }
        };
        <span class="pl-en">EnableEvents</span>(<span class="pl-smi">source</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>, <span class="pl-smi">refreshInterval</span>);
    }
}</pre></div><h4><a id="user-content-sample-code" class="anchor" aria-hidden="true" href="#sample-code"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sample Code</h4><p>This is a sample <code>EventListener</code> class that simply prints out all the counter names and values from a the .NET runtime's EventSource for publishing its internal counters (<code>System.Runtime</code>) at some interval.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">SimpleEventListener</span> : <span class="pl-en">EventListener</span>
{        
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">EventLevel</span><span class="pl-smi">_level</span><span class="pl-k">=</span><span class="pl-smi">EventLevel</span>.<span class="pl-smi">Verbose</span>;

    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-smi">EventCount</span> { <span class="pl-k">get</span>; <span class="pl-k">private</span><span class="pl-k">set</span>; } <span class="pl-k">=</span><span class="pl-c1">0</span>;

    <span class="pl-k">private</span><span class="pl-k">int</span><span class="pl-smi">_intervalSec</span>;

    <span class="pl-k">public</span><span class="pl-en">SimpleEventListener</span>(<span class="pl-k">int</span><span class="pl-smi">intervalSec</span>)
    {
        <span class="pl-smi">_intervalSec</span><span class="pl-k">=</span><span class="pl-smi">intervalSec</span>;
    }


    <span class="pl-k">protected</span><span class="pl-k">override</span><span class="pl-k">void</span><span class="pl-en">OnEventSourceCreated</span>(<span class="pl-en">EventSource</span><span class="pl-smi">source</span>)
    {
        <span class="pl-k">if</span> (<span class="pl-smi">source</span>.<span class="pl-smi">Name</span>.<span class="pl-en">Equals</span>(<span class="pl-s"><span class="pl-pds">"</span>System.Runtime<span class="pl-pds">"</span></span>))
        {
            <span class="pl-k">var</span><span class="pl-smi">refreshInterval</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Dictionary</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">string</span>&gt;();
            <span class="pl-smi">refreshInterval</span>.<span class="pl-en">Add</span>(<span class="pl-s"><span class="pl-pds">"</span>EventCounterIntervalSec<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>);
            <span class="pl-en">EnableEvents</span>(<span class="pl-smi">source</span>, <span class="pl-smi">_level</span>, (<span class="pl-en">EventKeywords</span>)(<span class="pl-k">-</span><span class="pl-c1">1</span>), <span class="pl-smi">refreshInterval</span>);
        }
    }

    <span class="pl-k">private</span> (<span class="pl-k">string</span><span class="pl-en">Name</span>, <span class="pl-k">string</span><span class="pl-en">Value</span>) <span class="pl-en">GetRelevantMetric</span>(<span class="pl-en">IDictionary</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt; <span class="pl-smi">eventPayload</span>)
    {
        <span class="pl-k">string</span><span class="pl-smi">counterName</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;
        <span class="pl-k">string</span><span class="pl-smi">counterValue</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;

        <span class="pl-k">foreach</span> ( <span class="pl-en">KeyValuePair</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt; <span class="pl-smi">payload</span><span class="pl-k">in</span><span class="pl-smi">eventPayload</span> )
        {
            <span class="pl-k">string</span><span class="pl-smi">key</span><span class="pl-k">=</span><span class="pl-smi">payload</span>.<span class="pl-smi">Key</span>;
            <span class="pl-k">string</span><span class="pl-smi">val</span><span class="pl-k">=</span><span class="pl-smi">payload</span>.<span class="pl-smi">Value</span>.<span class="pl-en">ToString</span>();

            <span class="pl-k">if</span> (<span class="pl-smi">key</span>.<span class="pl-en">Equals</span>(<span class="pl-s"><span class="pl-pds">"</span>DisplayName<span class="pl-pds">"</span></span>))
            {
                <span class="pl-smi">counterName</span><span class="pl-k">=</span><span class="pl-smi">val</span>;
            }
            <span class="pl-k">else</span><span class="pl-k">if</span> (<span class="pl-smi">key</span>.<span class="pl-en">Equals</span>(<span class="pl-s"><span class="pl-pds">"</span>Mean<span class="pl-pds">"</span></span>) <span class="pl-k">||</span><span class="pl-smi">key</span>.<span class="pl-en">Equals</span>(<span class="pl-s"><span class="pl-pds">"</span>Increment<span class="pl-pds">"</span></span>))
            {
                <span class="pl-smi">counterValue</span><span class="pl-k">=</span><span class="pl-smi">val</span>;
            }
        }
        <span class="pl-k">return</span> (<span class="pl-smi">counterName</span>, <span class="pl-smi">counterValue</span>);
    }

    <span class="pl-k">protected</span><span class="pl-k">override</span><span class="pl-k">void</span><span class="pl-en">OnEventWritten</span>(<span class="pl-en">EventWrittenEventArgs</span><span class="pl-smi">eventData</span>)
    {
        <span class="pl-k">if</span> (<span class="pl-smi">eventData</span>.<span class="pl-smi">EventName</span>.<span class="pl-en">Equals</span>(<span class="pl-s"><span class="pl-pds">"</span>EventCounters<span class="pl-pds">"</span></span>))
        {
            <span class="pl-k">for</span> (<span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>; <span class="pl-smi">i</span><span class="pl-k">&lt;</span><span class="pl-smi">eventData</span>.<span class="pl-smi">Payload</span>.<span class="pl-smi">Count</span>; <span class="pl-smi">i</span><span class="pl-k">++</span>)
            {
                <span class="pl-en">IDictionary</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt; <span class="pl-smi">eventPayload</span><span class="pl-k">=</span><span class="pl-smi">eventData</span>.<span class="pl-smi">Payload</span>[<span class="pl-smi">i</span>] <span class="pl-k">as</span><span class="pl-en">IDictionary</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt;;

                <span class="pl-k">if</span> (<span class="pl-smi">eventPayload</span><span class="pl-k">!=</span><span class="pl-c1">null</span>)
                {
                    <span class="pl-k">var</span><span class="pl-smi">counterKV</span><span class="pl-k">=</span><span class="pl-en">GetRelevantMetric</span>(<span class="pl-smi">eventPayload</span>);
                    <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>{<span class="pl-smi">counterKV</span>.<span class="pl-smi">Name</span>} : {<span class="pl-smi">counterKV</span>.<span class="pl-smi">Value</span>}<span class="pl-pds">"</span></span>);
                }
            }
        }
    }
}</pre></div><p>As shown above, you <em>must</em> make sure the <code>"EventCounterIntervalSec"</code> argument is set in the filterPayload argument when calling <code>EnableEvents</code>. Otherwise the counters will not be able to flush out values since it doesn't know at which interval it should be getting flushed out.</p><h3><a id="user-content-consuming-out-of-proc" class="anchor" aria-hidden="true" href="#consuming-out-of-proc"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consuming out-of-proc</h3><p>Consuming EventCounters out-of-proc is also possible. For those that are familiar with ETW (Event Tracing for Windows), you can use ETW to capture counter data as events and view them on your ETW trace viewer (PerfView, WPA, etc.). You may also use <code>dotnet-counters</code> to consume it cross-platform via EventPipe. You can also use TraceEvent to consume these.</p><h4><a id="user-content-dotnet-counters" class="anchor" aria-hidden="true" href="#dotnet-counters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dotnet-counters</h4><p>dotnet-counters is a cross-platform dotnet CLI tool that can be used to monitor the counter values. To find out how to use <code>dotnet-counters</code> to monitor your counters, refer to the <a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-counters-instructions.md">dotnet-counters documentation</a>.</p><h4><a id="user-content-etwperfview" class="anchor" aria-hidden="true" href="#etwperfview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ETW/PerfView</h4><p>Since EventCounter payloads are reported as <code>EventSource</code> events, you can use PerfView to collect/view these counter-data.</p><p>Here is a command that can be passed to PerfView to collect an ETW trace with the counters.</p><pre><code>PerfView.exe /onlyProviders=*Samples-EventCounterDemos-Minimal:EventCounterIntervalSec=1 collect
</code></pre><h4><a id="user-content-dotnet-trace" class="anchor" aria-hidden="true" href="#dotnet-trace"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>dotnet-trace</h4><p>Similar to how PerfView can be used to consume the counter data through ETW, dotnet-trace can be used to consume the counter data through EventPipe.</p><p>Here is an example of using dotnet-trace to get the same counter data.</p><pre><code>dotnet-trace collect --process-id &lt;pid&gt; --providers Samples-EventCounterDemos-Minimal:0:0:EventCounterIntervalSec=1
</code></pre><p>The official dotnet-trace documentation contains a <a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md#using-dotnet-trace-to-collect-counter-values-over-time">section</a> on how to do this in more detail.</p><h4><a id="user-content-traceevent" class="anchor" aria-hidden="true" href="#traceevent"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TraceEvent</h4><p>TraceEvent is a managed library that makes it easy to consume ETW and EventPipe events. For more information, refer to the <a href="https://github.com/Microsoft/perfview/blob/master/documentation/TraceEvent/TraceEventProgrammersGuide.md">TraceEvent Library Programmers Guide</a>.</p><p>For some more detailed code samples, you can also try reading <a href="https://medium.com/criteo-labs/net-core-counters-internals-how-to-integrate-counters-in-your-monitoring-pipeline-5354cd61b42e" rel="nofollow">Criteo Labs blog</a> on how to do this.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>