<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Creating an OpenID Connect server proxy with OpenIddict 3.0&#x27;s degraded mode - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Creating an OpenID Connect server proxy with OpenIddict 3.0&#x27;s degraded mode - linksfor.dev(s)"/>
    <meta property="og:description" content="In this post, discover how to create a minimalist OIDC server proxy between Steam and your own APIs."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://kevinchalet.com/2020/02/18/creating-an-openid-connect-server-proxy-with-openiddict-3-0-s-degraded-mode/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Creating an OpenID Connect server proxy with OpenIddict 3.0&#x27;s degraded mode</title>
<div class="readable">
        <h1>Creating an OpenID Connect server proxy with OpenIddict 3.0&#x27;s degraded mode</h1>
            <div>Reading time: 13-17 minutes</div>
        <div>Posted here: 19 Feb 2020</div>
        <p><a href="https://kevinchalet.com/2020/02/18/creating-an-openid-connect-server-proxy-with-openiddict-3-0-s-degraded-mode/">https://kevinchalet.com/2020/02/18/creating-an-openid-connect-server-proxy-with-openiddict-3-0-s-degraded-mode/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="container"><div><section id="main"><article id="post-creating-an-openid-connect-server-proxy-with-openiddict-3-0-s-degraded-mode" itemscope="" itemprop="blogPost"><div><header></header><div itemprop="articleBody"><p>As some of you may already know, <a href="https://github.com/openiddict/openiddict-core/issues/736" target="_blank" rel="external">I've been working on OpenIddict 3.0 for a few months now</a>. <strong>One of the main goals of this major release is to merge <a href="https://github.com/aspnet-contrib/AspNet.Security.OpenIdConnect.Server" target="_blank" rel="external">ASOS</a></strong> (a low-level OpenID Connect server middleware for ASP.NET Core) <strong>and OpenIddict</strong> (a higher-level OIDC server library designed for less advanced users) into a unified code base, that would ideally represent the best of both worlds.</p><p><strong>As part of this task, a new feature was added to OpenIddict: the degraded mode</strong> (also known as the <em>ASOS-like</em> or <em>bare</em> mode). Put simply, <strong>this mode allows using OpenIddict's server without any backing database</strong>. Once enabled, all the features that rely on the OpenIddict application, authorization, scope and token managers (contained in the <code>OpenIddict.Core</code> package) are automatically disabled, which includes things like <code>client_id</code>/<code>client_secret</code> or <code>redirect_uri</code> validation, reference tokens and token revocation support. In other words, this mode allows switching from an "all you can eat" offer to a "pay-to-play" approach.</p><p>A thread, posted on <a href="https://github.com/aspnet-contrib/AspNet.Security.OpenId.Providers/issues/50" target="_blank" rel="external">one of the aspnet-contrib repositories</a> gave me a perfect opportunity to showcase this particular feature. The question asked by the commenters was simple: how can I use an external authentication provider like Steam (that implements the legacy OpenID 2.0 protocol) with my own API endpoints?</p><p><strong>Steam doesn't issue any access token you could directly use with your API endpoints</strong>. Actually, access tokens are not even a thing in OpenID 2.0, which is a pure authentication protocol that doesn't offer any authorization capability (unlike OAuth 1.0/2.0 or OpenID Connect).</p><p>So, how do we solve this problem? <strong>The most common approach typically consists in creating your own authorization server</strong> between your frontend application and the remote authentication provider (here, Steam). This way, when the application needs to authenticate a user, the user is redirected to the authorization server, that delegates the actual authentication part to another party. Once authenticated by that party, the user is redirected back to the main authorization server, that issues an access token to the client application.</p><p><img src="https://kevinchalet.com/2020/02/18/creating-an-openid-connect-server-proxy-with-openiddict-3-0-s-degraded-mode/authorization-code-flow.png" alt="authorization-code-flow.png"></p><p>This a super common scenario, that can be implemented using standard protocols like OpenID Connect and well-known implementations like OpenIddict or IdentityServer. However, <a href="https://github.com/aspnet-contrib/AspNet.Security.OpenId.Providers/issues/50#issuecomment-586734467" target="_blank" rel="external">these options are sometimes considered "overkill" for such simple scenarios</a>. After all, why would you need a fully-fledged OIDC server – with login, registration or consent views – when all you want is to delegate the actual authentication to another server in a totally transparent and almost invisible way?</p><p>Rolling your own protocol is tempting... <a href="https://github.com/aspnet-contrib/AspNet.Security.OpenId.Providers/issues/50#issuecomment-586726240" target="_blank" rel="external">but a very bad idea</a>, as you can't benefit from all the security measures offered by standard flows like OAuth 2.0/OpenID Connect's authorization code flow, whose threat model is clearly identified for many years now. <strong>As you may have guessed by now, this is precisely where OpenIddict 3.0's degraded mode can come in handy</strong>.</p><h2 id="Implementing-a-minimalist-OpenID-Connect-server-with-OpenIddict-3-0"><a href="#Implementing-a-minimalist-OpenID-Connect-server-with-OpenIddict-3-0" title="Implementing a minimalist OpenID Connect server with OpenIddict 3.0"></a>Implementing a minimalist OpenID Connect server with OpenIddict 3.0</h2><h3 id="Add-the-Steam-authentication-integration"><a href="#Add-the-Steam-authentication-integration" title="Add the Steam authentication integration"></a>Add the Steam authentication integration</h3><p>First, we'll start by creating an ASP.NET Core 3.1 API application and by adding the aspnet-contrib Steam provider and an instance of the cookies authentication handler (that will be used to store the user identity retrieved from Steam).</p><p>For that, add the following dependency in your .csproj:</p><figure><table><tbody><tr><td><pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p></pre></td><td><pre><p><span>&lt;<span>Project</span> <span>Sdk</span>=<span>"Microsoft.NET.Sdk.Web"</span>&gt;</span></p><p><span>&lt;<span>PropertyGroup</span>&gt;</span></p><p><span>&lt;<span>TargetFramework</span>&gt;</span>netcoreapp3.1<span>&lt;/<span>TargetFramework</span>&gt;</span></p><p><span>&lt;/<span>PropertyGroup</span>&gt;</span></p><p><span>&lt;<span>ItemGroup</span>&gt;</span></p><p><span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"AspNet.Security.OpenId.Steam"</span> <span>Version</span>=<span>"3.0.0"</span> /&gt;</span></p><p><span>&lt;/<span>ItemGroup</span>&gt;</span></p><p><span>&lt;/<span>Project</span>&gt;</span></p></pre></td></tr></tbody></table></figure><p>Then, update <code>ConfigureServices</code> to register the Steam and cookies authentication handlers:</p><figure><table><tbody><tr><td><pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p></pre></td><td><pre><p><span><span>public</span> <span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection services</span>)</span></p><p>{</p><p>    services.AddControllers();</p><p>    services.AddAuthentication()</p><p>        .AddCookie()</p><p>        .AddSteam(options =&gt;</p><p>        {</p><p>            options.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;</p><p>        });</p><p>}</p></pre></td></tr></tbody></table></figure><p>You'll also need to update <code>Configure</code> to call <code>app.UseAuthentication()</code>:</p><figure><table><tbody><tr><td><pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p></pre></td><td><pre><p><span><span>public</span> <span>void</span> <span>Configure</span>(<span>IApplicationBuilder app, IWebHostEnvironment env</span>)</span></p><p>{</p><p><span>if</span> (env.IsDevelopment())</p><p>    {</p><p>        app.UseDeveloperExceptionPage();</p><p>    }</p><p>    app.UseHttpsRedirection();</p><p>    app.UseRouting();</p><p>    app.UseAuthentication();</p><p>    app.UseAuthorization();</p><p>    app.UseEndpoints(endpoints =&gt;</p><p>    {</p><p>        endpoints.MapControllers();</p><p>    });</p><p>}</p></pre></td></tr></tbody></table></figure><h3 id="Add-the-OpenIddict-server-and-JWT-validation-components"><a href="#Add-the-OpenIddict-server-and-JWT-validation-components" title="Add the OpenIddict server and JWT validation components"></a>Add the OpenIddict server and JWT validation components</h3><p>Now, we'll need to add the OpenID Connect server part. For that, add the following packages:</p><figure><table><tbody><tr><td><pre><p>1</p><p>2</p><p>3</p></pre></td><td><pre><p><span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"OpenIddict.Server.AspNetCore"</span> <span>Version</span>=<span>"3.0.0-alpha1.20116.71"</span> /&gt;</span></p><p><span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"OpenIddict.Validation.AspNetCore"</span> <span>Version</span>=<span>"3.0.0-alpha1.20116.71"</span> /&gt;</span></p><p><span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"OpenIddict.Validation.ServerIntegration"</span> <span>Version</span>=<span>"3.0.0-alpha1.20116.71"</span> /&gt;</span></p></pre></td></tr></tbody></table></figure><p>At the time of writing, OpenIddict 3.0's prelease packages are not yet available on NuGet.org. To use the nightly builds, you need to reference the dedicated OpenIddict MyGet feed: <a href="https://www.myget.org/F/openiddict/api/v3/index.json" target="_blank" rel="external">https://www.myget.org/F/openiddict/api/v3/index.json</a></p><p>Next, tweak <code>ConfigureServices</code> to register the OpenIddict ASP.NET Core server and validation services, with only the options we need: the authorization code flow allowed, the authorization and token endpoints active and the degraded mode enabled:</p><figure><table><tbody><tr><td><pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p></pre></td><td><pre><p>services.AddOpenIddict()</p><p>    .AddServer(options =&gt;</p><p>    {</p><p>        options.AddDevelopmentEncryptionCertificate()</p><p>               .AddDevelopmentSigningCertificate();</p><p>        options.AllowAuthorizationCodeFlow();</p><p>        options.SetAuthorizationEndpointUris(<span>"/connect/authorize"</span>)</p><p>               .SetTokenEndpointUris(<span>"/connect/token"</span>);</p><p>        options.EnableDegradedMode();</p><p>        options.UseAspNetCore();</p><p>    })</p><p>    .AddValidation(options =&gt;</p><p>    {</p><p>        options.UseLocalServer();</p><p>        options.UseAspNetCore();</p><p>    });</p></pre></td></tr></tbody></table></figure><p>At this point, trying to launch the application will result in an exception being thrown:</p><blockquote><p>InvalidOperationException: No custom authorization request validation handler was found. When enabling the degraded mode, a custom <code>IOpenIddictServerHandler&lt;ValidateAuthorizationRequestContext&gt;</code> must be implemented to validate authorization requests (e.g to ensure the client_id and redirect_uri are valid).</p></blockquote><p>This is expected: when using the degraded mode, you must add custom code to validate things that are normally validated for you by OpenIddict, which includes the <code>client_id</code> or <code>redirect_uri</code>, that must be checked to ensure users are not redirected to unsafe/unknown addresses.</p><p>To fix that error, we'll need to register a handler for the <code>ValidateAuthorizationRequest</code> event. Since we enabled the token endpoint, we'll also need one to validate token requests.</p><p>There are multiple ways to create and register event handlers in OpenIddict: you can create a dedicated class implementing the generic <code>IOpenIddictServerHandler&lt;TContext&gt;</code> interface – which allows using dependency injection – or you can use inline event handlers.</p><p>To keep things simple, we'll use inline event handlers (directly defined in <code>ConfigureServices</code>) and static hard-coded checks:</p><figure><table><tbody><tr><td><pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p></pre></td><td><pre><p>services.AddOpenIddict()</p><p>    .AddServer(options =&gt;</p><p>    {</p><p>        options.AddEventHandler&lt;ValidateAuthorizationRequestContext&gt;(builder =&gt;</p><p>            builder.UseInlineHandler(context =&gt;</p><p>            {</p><p><span>if</span> (!<span>string</span>.Equals(context.ClientId, <span>"console_app"</span>, StringComparison.Ordinal))</p><p>                {</p><p>                    context.Reject(</p><p>                        error: Errors.InvalidClient,</p><p>                        description: <span>"The specified 'client_id' doesn't match a registered application."</span>);</p><p><span>return</span> <span>default</span>;</p><p>                }</p><p><span>if</span> (!<span>string</span>.Equals(context.RedirectUri, <span>"http://localhost:7890/"</span>, StringComparison.Ordinal))</p><p>                {</p><p>                    context.Reject(</p><p>                        error: Errors.InvalidClient,</p><p>                        description: <span>"The specified 'redirect_uri' is not valid for this client application."</span>);</p><p><span>return</span> <span>default</span>;</p><p>                }</p><p><span>return</span> <span>default</span>;</p><p>            }));</p><p>        options.AddEventHandler&lt;ValidateTokenRequestContext&gt;(builder =&gt;</p><p>            builder.UseInlineHandler(context =&gt;</p><p>            {</p><p><span>if</span> (!<span>string</span>.Equals(context.ClientId, <span>"console_app"</span>, StringComparison.Ordinal))</p><p>                {</p><p>                    context.Reject(</p><p>                        error: Errors.InvalidClient,</p><p>                        description: <span>"The specified 'client_id' doesn't match a registered application."</span>);</p><p><span>return</span> <span>default</span>;</p><p>                }</p><p><span>return</span> <span>default</span>;</p><p>            }));</p><p>    });</p></pre></td></tr></tbody></table></figure><p><strong>Final and most interesting part: gluing everything together</strong>, so that OpenIddict can redirect users to Steam and generate an authorization response containing an authorization code that the client application will be able to use to redeem an access token. To implement that, we need to use the <code>HandleAuthorizationRequest</code> event:</p><figure><table><tbody><tr><td><pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p></pre></td><td><pre><p>options.AddEventHandler&lt;HandleAuthorizationRequestContext&gt;(builder =&gt;</p><p>    builder.UseInlineHandler(<span>async</span> context =&gt;</p><p>    {</p><p><span>var</span> request = context.Transaction.GetHttpRequest() ??</p><p><span>throw</span> <span>new</span> InvalidOperationException(<span>"The ASP.NET Core request cannot be retrieved."</span>);</p><p><span>var</span> principal = (<span>await</span> request.HttpContext.AuthenticateAsync(SteamAuthenticationDefaults.AuthenticationScheme))?.Principal;</p><p><span>if</span> (principal == <span>null</span>)</p><p>        {</p><p><span>await</span> request.HttpContext.ChallengeAsync(SteamAuthenticationDefaults.AuthenticationScheme);</p><p>            context.HandleRequest();</p><p><span>return</span>;</p><p>        }</p><p><span>var</span> identity = <span>new</span> ClaimsIdentity(TokenValidationParameters.DefaultAuthenticationType);</p><p>        identity.AddClaim(<span>new</span> Claim(Claims.Subject, principal.GetClaim(ClaimTypes.NameIdentifier)));</p><p><span>foreach</span> (<span>var</span> claim <span>in</span> identity.Claims)</p><p>        {</p><p>            claim.SetDestinations(Destinations.AccessToken);</p><p>        }</p><p>        context.Principal = <span>new</span> ClaimsPrincipal(identity);</p><p>    }));</p></pre></td></tr></tbody></table></figure><p>Adding a handler for <code>HandleTokenRequestContext</code> is not necessary: in this case, OpenIddict will automatically reuse the user identity extracted from the authorization code to produce an access token returned as part of the token response.</p><h2 id="Creating-a-NET-demo-console"><a href="#Creating-a-NET-demo-console" title="Creating a .NET demo console"></a>Creating a .NET demo console</h2><p>To test our minimalist OpenID Connect proxy, we'll now create a separate .NET Core 3.1 console referencing the <code>IdentityModel.OidcClient</code> package:</p><figure><table><tbody><tr><td><pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p></pre></td><td><pre><p><span>&lt;<span>Project</span> <span>Sdk</span>=<span>"Microsoft.NET.Sdk"</span>&gt;</span></p><p><span>&lt;<span>PropertyGroup</span>&gt;</span></p><p><span>&lt;<span>OutputType</span>&gt;</span>Exe<span>&lt;/<span>OutputType</span>&gt;</span></p><p><span>&lt;<span>TargetFramework</span>&gt;</span>netcoreapp3.1<span>&lt;/<span>TargetFramework</span>&gt;</span></p><p><span>&lt;<span>LangVersion</span>&gt;</span>8.0<span>&lt;/<span>LangVersion</span>&gt;</span></p><p><span>&lt;/<span>PropertyGroup</span>&gt;</span></p><p><span>&lt;<span>ItemGroup</span>&gt;</span></p><p><span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"IdentityModel.OidcClient"</span> <span>Version</span>=<span>"4.0.0-preview.1.3"</span> /&gt;</span></p><p><span>&lt;/<span>ItemGroup</span>&gt;</span></p><p><span>&lt;/<span>Project</span>&gt;</span></p></pre></td></tr></tbody></table></figure><p>There are typically <strong>2 ways to handle authorization responses in desktop/mobile applications</strong> (i.e applications that don't run inside a browser):</p><ul><li><p><strong>Running a local HTTP server</strong>: this works well for desktop applications, but might be hard to implement in certain enterprise environments with strict firewall configurations.</p></li><li><p><strong>Registering an application-specific URI scheme</strong> (e.g: <code>myapp://</code>): this is the best approach... and pretty much the only option on most mobile operating systems, where the first option is not always possible, for security reasons.</p></li></ul><p>Since the first option is easier to implement, it's the one we will choose for this demo client:</p><figure><table><tbody><tr><td><pre><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p></pre></td><td><pre><p><span>using</span> System;</p><p><span>using</span> System.Diagnostics;</p><p><span>using</span> System.Net;</p><p><span>using</span> System.Threading.Tasks;</p><p><span>using</span> IdentityModel.OidcClient;</p><p><span>using</span> <span>static</span> IdentityModel.OidcConstants;</p><p><span>namespace</span> <span>OpenIddictClientDemo</span></p><p>{</p><p><span>public</span> <span>static</span> <span>class</span> <span>Program</span></p><p>    {</p><p><span><span>public</span> <span>static</span> <span>async</span> Task <span>Main</span>(<span><span>string</span>[] args</span>)</span></p><p>        {</p><p>            Console.WriteLine(<span>"Press any key to start the authentication process."</span>);</p><p>            Console.ReadKey();</p><p><span>using</span> <span>var</span> listener = <span>new</span> HttpListener();</p><p>            listener.Prefixes.Add(<span>"http://localhost:7890/"</span>);</p><p>            listener.Start();</p><p><span>var</span> options = <span>new</span> OidcClientOptions</p><p>            {</p><p>                Authority = <span>"https://localhost:44322/"</span>,</p><p>                ClientId = <span>"console_app"</span>,</p><p>                LoadProfile = <span>false</span>,</p><p>                RedirectUri = <span>"http://localhost:7890/"</span>,</p><p>                Scope = StandardScopes.OpenId</p><p>            };</p><p><span>var</span> client = <span>new</span> OidcClient(options);</p><p><span>var</span> state = <span>await</span> client.PrepareLoginAsync();</p><p>            Process.Start(<span>new</span> ProcessStartInfo</p><p>            {</p><p>                FileName = state.StartUrl,</p><p>                UseShellExecute = <span>true</span></p><p>            });</p><p><span>while</span> (<span>true</span>)</p><p>            {</p><p><span>var</span> context = <span>await</span> listener.GetContextAsync();</p><p>                context.Response.StatusCode = <span>204</span>;</p><p>                context.Response.Close();</p><p><span>var</span> result = <span>await</span> client.ProcessResponseAsync(context.Request.Url.Query, state);</p><p><span>if</span> (result.IsError)</p><p>                {</p><p>                    Console.WriteLine(<span>"An error occurred: {0}"</span>, result.Error);</p><p>                }</p><p><span>else</span></p><p>                {</p><p>                    Console.WriteLine(<span>"

Claims:"</span>);</p><p><span>foreach</span> (<span>var</span> claim <span>in</span> result.User.Claims)</p><p>                    {</p><p>                        Console.WriteLine(<span>"{0}: {1}"</span>, claim.Type, claim.Value);</p><p>                    }</p><p>                    Console.WriteLine();</p><p>                    Console.WriteLine(<span>"Access token:
{0}"</span>, result.AccessToken);</p><p><span>break</span>;</p><p>                }</p><p>            }</p><p>            Console.ReadLine();</p><p>        }</p><p>    }</p><p>}</p></pre></td></tr></tbody></table></figure><h2 id="Testing-the-authentication-process"><a href="#Testing-the-authentication-process" title="Testing the authentication process"></a>Testing the authentication process</h2><p>For that, start the two applications (server and client). Once the client is started, press a key to start the authentication process. When doing so, the default browser will be launched and you'll be redirected to the authorization server. If you're not already logged in, you'll be immediately invited to authenticate using your Steam account:</p><p><img src="https://kevinchalet.com/2020/02/18/creating-an-openid-connect-server-proxy-with-openiddict-3-0-s-degraded-mode/steam.png" alt="steam.png"></p><p>After logging in, an authorization response will be returned to the client console, that will automatically send a token request to finish the process:</p><p><img src="https://kevinchalet.com/2020/02/18/creating-an-openid-connect-server-proxy-with-openiddict-3-0-s-degraded-mode/console.png" alt="console.png"></p><p>And voilà, you're now ready to create your first APIs! To accept the JWT bearer tokens issued by OpenIddict, don't forget to decorate your controllers/actions with:</p><figure><table><tbody><tr><td><pre><p>1</p></pre></td><td><pre><p>[Authorize(AuthenticationSchemes = OpenIddictValidationAspNetCoreDefaults.AuthenticationScheme)]</p></pre></td></tr></tbody></table></figure></div></div><nav id="article-nav"><a href="https://kevinchalet.com/2019/04/11/forcing-an-old-net-application-to-support-tls-1-2-without-recompiling-it/" id="article-nav-older"><strong>Older</strong><p>Forcing an old .NET application to support TLS 1.2 without recompiling it</p></a></nav></article></section></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>