<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Geting 4x Speedup With .NET Core 3.0 SIMD Intrinsics -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Geting 4x Speedup With .NET Core 3.0 SIMD Intrinsics</h1>
    <div><section class="ii ij ik il im"><div class="y in x cs cq cr"><div><div class="iz"><div class="as ar"><div><a href="https://link.medium.com/@alexyakunin?source=post_page-----5c9c31c47991----------------------"><img alt="Alex Yakunin" src="https://miro.medium.com/fit/c/96/96/1*VZigb4gz8d8uo2aBsl2nZw.jpeg" class="l eq ja jb" width="48"></a></div><div class="jc x l"><span class="br b bs bt bu bv l bw bx"><span class="br dt du bt jf jg jh ji jj jk bw"></span></span></div></div></div></div><p id="db70" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">A few weeks ago I and <a href="https://twitter.com/denplusplus" class="bb cn kc kd ke kf">Den Raskovalov</a> had a fancy conversation on C# performance, which turned into a tiny but fun coding exercise. The statement to prove or disprove was:</p><blockquote class="kg kh ki"><p id="2e78" class="jo jp fm kj jq b jr js jt ju jv jw jx jy jz ka kb"><em class="bs">&#x201C;The C++ code listed below, being translated C#, will never be close to C++ in terms of speed.&#x201D;</em></p></blockquote><figure class="kk kl km kn ko"></figure><p id="8aac" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">Assuming that:</p><ul class><li id="73eb" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb kr ks kt">We keep it single threaded</li><li id="3c3e" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">The file it reads is presumably short enough (~ 1 GB or less) to be cached in RAM &#x2014; i.e. IO bandwidth won&#x2019;t be the bottleneck here.</li></ul><p id="d7e4" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">If you don&#x2019;t want to dig into the code, here is what it does:</p><blockquote class="kg kh ki"><p id="44a1" class="jo jp fm kj jq b jr js jt ju jv jw jx jy jz ka kb"><em class="bs">The file stores a list of integer numbers in (0 &#x2026; 1,000,000) range encoded using </em><a href="https://en.wikipedia.org/wiki/Variable-length_quantity" class="bb cn kc kd ke kf"><em class="bs">Variable-Length Quantity coding scheme</em></a><em class="bs">. Compute the sum of all these integers.</em></p><p id="43e9" class="jo jp fm kj jq b jr js jt ju jv jw jx jy jz ka kb"><em class="bs">The coding scheme uses the most significant bit (MSB) in each byte to indicate whether there is a continuation of the current number&#x2019;s bit sequence (MSB=0) or not (MSB=1). </em><a href="https://en.wikipedia.org/wiki/Variable-length_quantity#Examples" class="bb cn kc kd ke kf"><em class="bs">Here is an example of similar ways to encode integers</em></a><em class="bs">.</em></p></blockquote><p id="bca8" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">So we started to improve our versions of code computing that sum to make it as fast as possible while honoring the rules stated above. Den was playing on C++ side.</p><p id="8406" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">To keep the post short, I&#x2019;ll focus mostly on C# side here, though <a href="https://github.com/alexyakunin/YetAnotherStupidBenchmark" class="bb cn kc kd ke kf">you can find both C# and C++ code here</a> (my repository, I&#x2019;ll keep it updated with the latest versions of both C# and C++ code in case of any future changes) and <a href="https://github.com/evilmucedin/yetanotherstupidbenchmark/" class="bb cn kc kd ke kf">here</a> (Den&#x2019;s repository, must up-to-date C++ code is there).</p><p id="c21c" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">The original C# code computing the sum:</p><figure class="kk kl km kn ko"></figure><p id="d319" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">High-level wrapper reading the file is common here; it gets a delegate pointing to the specific implementation of the computation logic (i.e. what has to be optimal).</p><p id="b67d" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">Performance on Core i7&#x2013;8700K, Ubuntu 19.04, gcc or .NET Core 3.0 preview 5 and ~1GB file with test data:</p><ul class><li id="4dc0" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb kr ks kt">~ 430ms for C++</li><li id="da6c" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">~ 500ms for C#</li></ul><p id="1319" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">First round of optimization was relatively straightforward:</p><ul class><li id="e527" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb kr ks kt">C++: enable a set of optimizations via compiler options (<em class="kj">-Ofast -fomit-frame-pointer -march=native -mtune=native -funroll-loops -Wno-shift-count-overflow</em>), enable PGO (profile guided optimization), use memory mapped files</li><li id="1dbc" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">C#: use unsafe pointers, unroll the main loop, add a version relying on async pipelines. I did the last part mostly to test whether there are any benefits &#x2014; the implementation I used violates the original &#x201C;single thread&#x201D; condition since the producer there reads another chunk while the consumer computes the sum; on the other hand, C++ version relying on memory-mapped files is doing something similar implicitly &#x2014; so in both cases it doesn&#x2019;t look like a plain violation of our &#x201C;single-threaded&#x201D; rule (i.e. we agreed here that file read operations might be concurrent).</li></ul><p id="f4b4" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">Updated C# code:</p><figure class="kk kl km kn ko"></figure><p id="76a6" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">The results were again pretty similar:</p><ul class><li id="e930" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb kr ks kt">394ms for C++ version</li><li id="e349" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">416ms for C# version with async pipeline</li><li id="187e" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">462ms for &#x201C;regular&#x201D; C# version</li></ul><p id="d0b4" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">I tried to implement a few other ideas &#x2014; in particular, <a href="https://github.com/alexyakunin/YetAnotherStupidBenchmark/blob/master/DotNetCore/Program.cs#L315" class="bb cn kc kd ke kf">implemented a version relying almost exclusively on non-branching instructions</a>, but none of them worked any better.</p><p id="1352" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">The next round brought almost 5x speedup: <a href="https://www.facebook.com/alexey.poyarkov.18" class="bb cn kc kd ke kf">Alexey Poyarkov</a> wrote an extremely efficient <a href="https://github.com/alexyakunin/YetAnotherStupidBenchmark/blob/master/Cpp/main.cpp#L127" class="bb cn kc kd ke kf">AVX2-based version of sum computation code</a>. I translated his code to C# line-by-line relying on .NET Core 3.0 SIMD intrinsics and made few cosmetic changes later. That&#x2019;s how the final version of C# code looks:</p><figure class="kk kl km kn ko"></figure><p id="68fc" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">The results:</p><ul class><li id="2d20" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb kr ks kt">95ms for C++ version</li><li id="881c" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">130ms for C# version</li><li id="6c1b" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">113ms for C# version with async pipeline.</li></ul><p id="112a" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">Finally, I found out it actually makes a lot of sense to use memory-mapped files in C# version on Ubuntu. I knew from my past experience they don&#x2019;t provide any benefits on Windows &#x2014; moreover, quite the opposite is true, so I didn&#x2019;t even try this as one of the initial optimizations. But seemingly it&#x2019;s the fastest way to read the file on .NET Core on Ubuntu:</p><figure class="kk kl km kn ko"></figure><p id="c0b2" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">The final standings:</p><ul class><li id="11d5" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb kr ks kt">95ms for C++ version</li><li id="383f" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">101ms for C# version</li></ul><p id="9587" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">Note that these results are nearly perfect: the baseline test computing the sum assuming it&#x2019;s a sequence of Int64 values takes nearly the same time, so CPU is not a bottleneck for this code anymore &#x2014; it&#x2019;s RAM bandwidth. And that&#x2019;s where we clearly had to stop.</p><p id="233d" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">My conclusions:</p><ul class><li id="2313" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb kr ks kt">C# is definitely a fit for similar compute-intensive tasks &#x2014; especially with .NET Core 3.0</li><li id="6057" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">If you run a similar workload at scale, the difference is expected to be even smaller: the CPU is a bottleneck on this test only while it is single-threaded. If we&#x2019;d run 4 or more similar tasks concurrently (think it&#x2019;s ~ a web server decoding UTF8 input, etc.), they&#x2019;d hit RAM bandwidth limit even on non-SIMD version.</li></ul><p id="b801" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">And here are the conclusions from Den Raskovalov (I totally agree with him as well):</p><p id="6997" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb">&#x201C;I agree with most of the conclusions Alex made, but I would like to stress your attention to a few things:</p><ul class><li id="e514" class="jo jp fm bs jq b jr js jt ju jv jw jx jy jz ka kb kr ks kt">Low-level optimization is still important even if you use modern compilers and libraries. Actually, the first version of the algorithm worked 10x slower than the final one. Compilers still suck in the optimization of IO patterns and cannot use AVX/SSE pipelining as good as an experienced engineer could.</li><li id="9649" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">The final versions of C# and C++ code are almost identical. Microsoft obviously understands the importance of leveraging low-level optimization. C# is a real tool, not a CS toy. My kudos go to MS folks here. Before we started the &#x201C;competition&#x201D;, I expected that naive C++ implementation could be improved 10x, but didn&#x2019;t expect that .NET could use the same low-level optimizations.</li><li id="36c5" class="jo jp fm bs jq b jr ku jt kv jv kw jx kx jz ky kb kr ks kt">Even in 2019 after platforms convergence, Alex had troubles with running my C++ code developed on Linux. I had troubles with running .NET code as well. Alex&#x2019;s version requires the most recent version of .NET core, even though C++ version works well with 6 years old GCC or clang.&#x201D;</li></ul></div></section></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>