<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Health Checks with gRPC and ASP.NET Core 3.0 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Health Checks with gRPC and ASP.NET Core 3.0</h1><div><div id="pryc-wp-acctp-original-content"><p>In this post, we will explore a couple of options to apply health checks to your gRPC server running on ASP.NET Core 3.0. Health checks are a common requirement. In particular, in containerised environments, they are required so that the container orchestrator and load balancers know which services are actually functioning.</p><p>This post is part of my <a href="https://www.stevejgordon.co.uk/grpc-with-asp-net-core-series">gRPC and ASP.NET Core</a> series.</p><h2>Option 1: Using the ASP.NET Core Health Check Middleware</h2><p>The first quite simple option is to leverage the exiting health check middleware which is documented within <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-3.0" target="_blank" rel="noopener noreferrer">ASP.NET Core docs</a>. This middleware supports various configurations to suit many requirements. It adds at least one health check endpoint to your application, reachable via a regular HTTP request.</p><p>For a basic health check, we can add the feature to an ASP.NET Core application by first registering the health check services within the <code>ConfigureServices</code> method.</p><p><code>services.AddHealthChecks();</code></p><p>We then map a health check endpoint under the /health path using the <code>IEndpointRouteBuilder</code>.</p><p>On line 4 of the above code, we use the <code>MapHealthChecks</code> method to register a simple health check endpoint.</p><p>When our application is running, we can make a get request to the configured endpoint. On my local machine, I can request “https://localhost:5005/health” which returns a 200-OK response with “Heathy” as the response body.</p><p>I won’t go into more advanced configurations for the health check feature in this post.</p><h2>Option 2: Using the Health Checks Library</h2><p>The gRPC framework specifies a <a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener noreferrer">gRPC health checking protocol</a>. It uses the same approach of defining a service definition as for regular gRPC services. Health checking is just another set of RPC methods.</p><p>A common service definition is available and defined using a <a href="https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto" target="_blank" rel="noopener noreferrer">proto file called health.proto</a>, in the proto package grpc.heath.v1.</p><p>The service definition includes two RPC methods currently:</p><p>‘<strong>Check</strong>‘ is a unary service method which returns a HealthCheckResponse when a HealthCheckRequest is received.</p><p>The HealthCheckRequest is defined as follows:</p><p>The request includes a single string field called ‘<strong>service</strong>‘. A gRPC server may be handling multiple gRPC service definitions. gRPC health checks support the concept of requesting a health check status for each specific service. The string is used to identify the service for which the health check status should be returned.</p><p>The ‘<strong>Check</strong>‘ method returns the appropriate HealthCheckResponse if the provided service name is known. In cases where it is not known, the response from the gRPC server will be NOT_FOUND.</p><p>The response message has the following definition:</p><p>The ‘<strong>ServingStatus</strong>‘ enum is used to define some possible statuses that may be returned. Serving indicates that the server is running and ready to handle calls for the service. NOT_SERVING identifies that the opposite i strue and that the server is not currently healthy.</p><p>The ‘<strong>Watch</strong>‘ method defines a way for the server to stream status changes for a given service. When called from a client, an immediate response will be returned indicating the current status, which may be NOT_SERVING or SERVICE_UNKNOWN, for example. The call will remain open so that if the status changes on the server, an updated response will be sent to the client.</p><p>A server can provide an implementation for this service definition to support health check RPC calls from clients and infrastructure such as load balancers. We could, of course, implement this ourselves but for basic requirements the <a href="https://www.nuget.org/packages/Grpc.HealthCheck/" target="_blank" rel="noopener noreferrer">Grpc.HealthCheck NuGet package</a>&nbsp;can be included in your server project. This package contains an implementation of the ‘<strong>Check</strong>‘ method that we can utilise.</p><p>To get started, add a package reference to your server project using your preferred approach. Once complete, you should have a PackageReference included in your project file (csproj).</p><p><code>&lt;PackageReference Include="Grpc.HealthCheck" Version="2.24.0" /&gt;</code></p><p>This package includes a partial implementation of the health.proto service definition in the class <code>HealthServiceImpl</code>. This class includes an implementation for only the <code>Check</code> method currently. The class defines three other methods.</p><ul><li><code>public void SetStatus(string service, HealthCheckResponse.Types.ServingStatus status);</code></li><li><code>public void ClearStatus(string service);</code></li><li><code>public void ClearAll();</code></li></ul><p>These methods are used to register and update the state of the various gRPC services for the server. Internally, a <code>Dictionary</code> is used to maintain the values for each registered service. Our job is to ensure we set the appropriate status(es) and maintain them.</p><p>It’s not immediately obvious how best to achieve this. In the end, I settled on using a BackgroundService, a feature of the .NET Core hosting model. We’ll use a basic approach in this post to demonstrate a way to get started.</p><p>This class extends the <code>BackgroundService</code> provided by the .NET Core hosting libraries. It supports dependency injection, and we expect two services to be injected into the constructor. The first is the <code>HealthServiceImpl</code> which comes from the Grpc.HealthCheck NuGet package we included earlier. The second is the <code>HealthCheckService</code> from the Microsoft.Extensions.Diagnostics.HealthChecks package.</p><p>In our override for the <code>ExecuteAsync</code> method, we include some logic which sets the statuses for our services. This occurs in a while loop which will exit only if the application is shutting down, signalled by the <code>CancellationToken</code>.</p><p>We use the <code>CheckHealthAsync</code> method on the <code>HealthCheckService</code> to request the general health status for the application. In more complex, real-world applications, there may be many other things which have to be checked to establish a healthy state; such as the ability to connect to a database or reach a downstream dependency. It is possible to include those checks within the broader Microsoft.Extensions.Diagnostics health checks or as additional, gRPC specific code in this method.</p><p>Based on the returned <code>HealthStatus</code> from the <code>CheckHealthAsync</code> method, we then set the appropriate <code>ServingStatus</code> on our gRPC service.</p><p>The <a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" target="_blank" rel="noopener noreferrer">gRPC Health Checking Protocol specifies</a> that the server should also return the overall server status as a response to a service name that is an empty string. We, therefore, ensure we include a status for both the “Weather” service and, for an empty string, the overall server.</p><p>Our <code>ExecuteAsync</code> code then delays (asynchronously) for 15 seconds, before the loop continues and the statuses may update. This is basic logic which ensures that the statuses are refreshed periodically.</p><h3>Registering and Mapping the gRPC Health Check Implementation</h3><p>Finally, we must register and map an endpoint to the health service. To support our approach here, we have to do some extra work. Since we need the statuses, set through the <code>HealthServiceImpl</code> class to be globally available and consistent within the application, we need to manually register this class as a singleton service with the dependency injection container. Additionally, we must register our <code>IHostedService</code> so that it is started when the application hosting begins.</p><p>We achieve this in the <code>ConfigureServices</code> method of the <code>Startup</code> class.</p><p>The first line registers the <code>HealthServiceImpl</code> as a singleton. This ensures that the same instance, with the same dictionary of statuses, is used throughout the application. Internally, the gRPC libraries, which activate the appropriate service to handle calls for an endpoint, will use an instance from the dependency injection container if one is available.</p><p>The second line uses the <code>AddHostedService</code> extension method to register our <code>StatusService</code>.</p><p>&nbsp;We can now update our endpoint registration:</p><p>On line 5, we include a call to <code>MapGrpcService</code> for the <code>HealthServiceImpl</code>. This ensures that it will be serving for calls to the health check RPC methods.</p><h3>Calling Health Checks From a Client</h3><p>Now that our server is configured for gRPC health checks, we can test it by creating a basic console client. We’ll use a new .NET Core 3.0 console application for simplicity.</p><p>After creating the console application, we can reference the same Grpc.HealthCheck NuGet library that we added to our server. This includes a client implementation also.</p><p><code>&lt;PackageReference Include="Grpc.HealthCheck" Version="2.24.0" /&gt;</code></p><p>We can now use its client to call the health check method.</p><p>This simple client implementation establishes a <code>HealthClient</code> using a gRPC channel. The <code>HealthClient</code> has been generated based upon the health.proto service definition. We can, therefore, call the <code>CheckAsync</code> method, providing a <code>HealthCheckRequest</code>, as seen on line 7 in the preceding code. We may supply a specific service name or pass an empty string to request the overall server status.</p><h2>Summary</h2><p>In this post, we’ve explored a couple of approaches to including health checks for an ASP.NET Core 3.0 application which acts as a gRPC server.</p><p>The first option leverages the existing Health Checks middleware for ASP.NET Core which responds to a GET request made to an HTTP endpoint.</p><p>The second option is slightly more complicated but supports the gRPC Health Checking Protocol. Most of this is available as part of the Grpc.HealthCheck NuGet package, although a little work is needed on our end to set the statuses and register things into dependency injection. </p><p>Both approaches may be valid, and they can also be combined within a single application if you desire.</p><p>You can find a working example of a gRPC with health checks included in my <a href="https://github.com/stevejgordon/gRPC-Demos" target="_blank" rel="noopener noreferrer">gRPC Demos GitHub Repository</a>.</p><p>For more gRPC content, you can find all of my posts that are part of my <a href="https://www.stevejgordon.co.uk/grpc-with-asp-net-core-series">gRPC and ASP.NET Core</a> series.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>