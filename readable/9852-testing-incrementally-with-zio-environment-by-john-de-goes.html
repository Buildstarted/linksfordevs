<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Testing Incrementally with ZIO Environment by John De Goes -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Testing Incrementally with ZIO Environment by John De Goes</h1><div><p>For maximum flexibility and convenience, we have defined both a&nbsp;trait&nbsp;that implements the database module, which can be mixed into other traits, and an&nbsp;object&nbsp;that extends the trait, which can be used standalone.</p><div><p>We now have all the pieces we need to replace the original '<strong>DB.lookupUser</strong>' method, whose actual implementation now resides inside our '<strong>DatabaseLive</strong>' module:</p><pre><code>object DB {
  ...
  def lookupUser(uid: UserID): ZIO[Database, Throwable, UserProfile] = 
    ZIO.accessM(_.database lookupUser uid)
  ...
}</code></pre><p>The '<strong>lookupUser</strong>' method merely delegates to the database module, by accessing the model through ZIO Environment ('<strong>ZIO.accessM</strong>').</p><p>Here we don’t use the '<strong>Webapp</strong>' type alias, because the functions in '<strong>DB</strong>' will not necessarily have the same dependencies as our web application.</p><p>However, after enough refactoring, we might introduce a new type alias in the '<strong>DB</strong>' object: '<strong>type DB[A] = ZIO[Database, Throwable, A]</strong>'. Eventually, all methods in '<strong>DB</strong>' might return effects of this type.</p><p>At this point, our refactoring is nearly complete. But we have to take care of one last detail: we have to provide our database module to the production application.</p><p>There are two main ways to provide the database module to our application. If it is inconvenient to propagate the '<strong>Webapp</strong>' type signature to the top of our application, we can always supply the production module somewhere inside our application.</p><p>In the worst case, if we are pressed for time and need to ship code today, maybe we choose to provide the production database wherever we call '<strong>inviteFriends</strong>'.</p><pre><code>inviteFriends(userId).provide(DatabaseLive)</code></pre><p>If we have a bit more time, we can push the '<strong>Webapp</strong>' type synonym to the entry point of our purely functional application, which might be the main function, or it might be where our web framework calls into our code.</p><p>In this case, instead of using the '<strong>DefaultRuntime</strong>' that ships with ZIO, we can define our own '<strong>Runtime</strong>', which provides the production database module):</p><pre><code>val myRuntime = 
  Runtime(DatabaseLive, PlatformLive)</code></pre><p>The custom runtime can be used to run many different effects that all require the same environment, so we don’t have to call '<strong>provide</strong>' on all of them before we run them.</p><p>Once we have this custom runtime, we can run our top-level effect, which will supply its required environment:</p><pre><code>myRuntime.unsafeRun(effect)</code></pre><p>At this point, we have not changed the behavior of our application at all—it will work exactly as it did before. We’ve just moved the code around a bit, so we can access a tiny effect through ZIO environment.</p><p>Now it’s time to build a database module specifically for testing.</p><p><strong>Implement Test Module</strong></p><p>We could implement the test database module using a mocking framework. However, to avoid all magic and use of reflection, in this post, we will build one from scratch.</p><p>For maximum flexibility, our test database module will track all calls to '<strong>lookupUser</strong>', and supply responses using a '<strong>Map</strong>', which can be dynamically changed by the test suite.</p><p>To support this stateful behavior, we will need a '<strong>Ref</strong>', which is a concurrent-safe ZIO data structure that models mutable references. We will also need a simple (immutable) data structure to hold the state of the test database module.</p><p>We define the following test data structure, which is capable of tracking a list of '<strong>UserID</strong>' values, and holding data that maps from '<strong>UserID</strong>' to '<strong>UserProfile</strong>'.</p><pre><code>final case class TestDatabaseState(
  lookups : List[UserID],
  data    : Map[UserID, UserProfile]
) {
  def addLookup(uid: UserID): TestDatabaseState = copy(lookups = uid :: lookups)
}</code></pre><p>Now we can define the service of our test database module. The service will require a '<strong>Ref[TestDatabaseState]</strong>', so it can not only use test data, but update the test state:</p><pre><code>final case class TestDatabaseService(ref: Ref[TestDatabaseState]) extends Database.Service {
  def lookupUser(uid: UserID): Task[UserProfile] = 
    for {
      _       &lt;- ref.update(_.addLookup uid)
      data    &lt;- ref.get.map(_.data)
      profile &lt;- Task.fromEither(data.get(uid)
                   .fold(Left(new DBErr))(
                     Right(_)))
    } yield profile
}</code></pre><p>Notice how the '<strong>lookupUser</strong>' function stores the '<strong>UserID</strong>' of every call in the '<strong>lookups</strong>' field of the '<strong>TestDatabaseState</strong>'. In addition, the function retrieves test responses from the map. If there is no response in the map, the function fails, presumably in the same way the production database would fail.</p><p>The test service must be placed in a module. In general, we should wait to create the module until the test suite, because then we will know the full set of dependencies for each test.</p><p>However, at this stage, the database service is the only dependency in our application, so we can make a helper function to create the test database module:</p><pre><code>object TestDatabase {
  def apply(ref: Ref[TestDatabaseState]): Database = 
    new Database {
      val database: Database.Service = 
        new TestDatabaseService(ref)
    }
}</code></pre><p>We now have all the pieces necessary to write a test of the '<strong>inviteFriends</strong>' function, which will use our test database module.</p><h3><strong>Write the Test</strong></h3><div><p>To more easily test the '<strong>lookupFriends</strong>' function, we will define a helper function. Given test data and input to the function, the helper will return the final test state and the output of the '<strong>lookupFriends</strong>' function:</p><pre><code>def runLookupFriends(data: Map[UserID, UserProfile], uid: UserID): Task[(TestDatabaseState, List[Send])] = 
  for {
    ref   &lt;- Ref.make(TestDatabaseState(Nil, data))
    resp  &lt;- lookupFriends(uid)
               .provide(TestDatabase(ref))
    state &lt;- ref.get 
  } yield (state, resp)</code></pre><p>The helper function creates a '<strong>Ref</strong>' with the initial test data, uses the '<strong>Ref</strong>' to create the '<strong>TestDatabase</strong>' module, and then supplies the database module to the effect returned by '<strong>lookupFriends</strong>'.</p><p>With this helper function, writing a test becomes quite simple:</p><pre><code>class TestSuite extends DefaultRuntime {
  def testLookupFriends = {
    val (state, resp) = 
      unsafeRun {
        runLookupFriends(
          Map(TestUserID -&gt; TestUserProfile),
          TestUserID
        )
      }
    
    (state.lookups must_=== List(TestUserID)) and
      (resp must_=== TestResponse)
}</code></pre><p>This test for '<strong>inviteFriends</strong>' is not perfect. It still interacts with a real Facebook API and a real email service. But compared to whatever tests already exist, at least this test does not interact with a real database.</p><p>Moreover, we were able to make this change in a&nbsp;minimally disruptive manner.</p><h3><strong>A Glimpse Beyond</strong></h3><div><p>After a little more refactoring, of course, we would succeed in making '<strong>inviteFriends</strong>' fully testable. Even after the full refactoring, the code for '<strong>lookupFriends</strong>' would not change.</p><p>Instead, our type alias for '<strong>Webapp</strong>' would expand to include new environmental effects:</p><pre><code>type WebappFX = 
  Database with Social with Email

type Webapp[A] = ZIO[WebappFX, Throwable, A]</code></pre><p>Now all the methods in the '<strong>DB</strong>', '<strong>Social</strong>', and '<strong>Email</strong>' objects would simply delegate to their respective modules using '<strong>ZIO.accessM</strong>'.</p><p>Running our application would now look a little different:</p><pre><code>val myRuntime = 
  Runtime(
    new  DatabaseLive 
    with SocialLive 
    with EmailLive, PlatformLive)
...
myRuntime.unsafeRun(effect)</code></pre><p>Finally, testing '<strong>lookupFriends</strong>' would be entirely fast, deterministic, and type-safe, without any dependencies on external systems, or use of any reflection.</p><h3><strong>Summary</strong></h3><div><p>Environmental effects make it easy to test purely functional applications—significantly easier and with less ceremony than tagless-final, with full type inference, and without false promises.</p><p>Morever, with environmental effects, we can make even just a&nbsp;single function testable, by pushing that function into an environmental effect. This requires just a few small changes that can be done incrementally without major disruption to the application.</p><p>This ability lets us make incremental progress towards better application architecture. We don’t have to solve all the problems in our code base at once. We can focus on making our application a little better each day.</p><p>While this post focused on ZIO Environment, if you’re using '<strong>Future</strong>', Monix, or Cats IO, you can still use this approach with a '<strong>ReaderT</strong>' monad transformer. With a monad transformer, you will lose type inference and some performance, but you will gain the other benefits in a more familiar package.</p><p>If you’d like to give ZIO Environment a try, hop over to the&nbsp;<a href="https://github.com/scalaz/scalaz-zio">Github project page</a>, and be sure to stop by the&nbsp;<a href="https://gitter.im/scalaz/scalaz-zio">Gitter channel</a>&nbsp;and say hello.</p><p>In future posts, I will cover how to provide partial dependencies, how to model services that require other services (the&nbsp;graph problem), how to hide implementation details, and how this approach differs from the classic cake pattern. Stay tuned for more!'</p><p><small>This article was written by <a href="https://twitter.com/jdegoes?lang=en">John De Goes</a> and originally posted on&nbsp;<a href="http://degoes.net/articles/testable-zio">degoes.net</a></small></p></div></div></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>