<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Introduction to Blazor Component Testing -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Introduction to Blazor Component Testing</h1>
    <div class="post-content"> <blockquote>This post is part of the <a href="https://crosscuttingconcerns.com/The-Third-Annual-csharp-Advent">third annual C# advent</a>. Two new posts are published every day between 1st December and 25th December.</blockquote><p>One significant area which has been lacking in Blazor is testing. There is a <a href="https://github.com/aspnet/AspNetCore/issues/5458">placeholder issue</a> for it, but for a very long time, there wasn&apos;t any progress. This is because testing was out of scope for the first official release of Blazor - which shipped with .NET Core 3 back in September.</p><p>However, just before the release in August, Steve Sanderson <a href="https://blog.stevensanderson.com/2019/08/29/blazor-unit-testing-prototype/">published a blog post</a> introducing a prototype unit testing library for Blazor components. Steve&apos;s prototype has the goal of getting the conversation going around testing in Blazor. I&apos;ve wanted to test the library for a while, but I haven&apos;t had the chance until now.</p><p>Let&apos;s start by covering some of the high level questions about this prototype.</p><blockquote>I want to stress this is a prototype library and there is <strong>ZERO </strong>support for it, there isn&apos;t even a NuGet package right now. Therefore, anything you read here can, and most likely will, change.</blockquote><h2 id="what-types-of-testing-does-it-cover">What types of testing does it cover?</h2><p>There are various ways to test web applications but the two most common are unit tests and end-to-end tests (E2E tests). </p><h3 id="unit-testing">Unit testing</h3><p>Unit tests are lightweight and fast to run if written correctly, of course. They test small <em>&quot;units&quot;</em> of code in isolation. For example, given a method which takes two numbers and returns the sum of them. You could write a unit test which checks that if you provide the inputs <code>2</code> and <code>2</code> that the method returns <code>4</code>. However, checks in isolation can also be their downfall. It&apos;s possible that various units of code could run fine in isolation, but when put together they don&apos;t quite match up, and errors can occur.</p><h3 id="end-to-end-testing">End to end testing</h3><p>E2E tests can help to combat the issues with unit tests. You can test the whole application stack using E2E testing. E2E tests often use a headless browser to run tests which assert against the DOM. This is achieved using tools such as <a href="https://selenium.dev/">Selenium</a> which drive a headless browser and provide an interface to access the HTML. The drawback of these type of tests is they&apos;re much more heavyweight. They&apos;re also known to be brittle and slow; it takes substantial effort to both make them reliable and keep them that way.</p><h3 id="the-best-of-both">The best of both</h3><p>What Steve&apos;s prototype library attempts to do is to bring the best of both of these testing approaches but without the drawbacks - sounds pretty good to me!</p><h2 id="how-does-it-work">How does it work?</h2><p>Steve&apos;s library supplies a <code>TestHost</code> which allows components to be mounted using a <code>TestRenderer</code> under the hood. It&apos;s compatible with traditional unit testing frameworks such as XUnit and NUnit and gives us a straightforward and clean way of writing tests. This is an example of what a test looks like using XUnit.</p><pre><code class="language-html">&lt;!-- MyComponent.razor --&gt;

&lt;h1&gt;Testing is awesome!&lt;/h1&gt;
</code></pre>
<pre><code class="language-csharp">public class MyComponentTests
{
    private TestHost _host = new TestHost();

    [Fact]
    public void MyBlazingUnitTest()
    {
        var component = _host.AddComponent&lt;MyComponent&gt;();
        
        Assert.Equal(&quot;Testing is awesome!&quot;, component.Find(&quot;h1&quot;).InnerText);
    }
}
</code></pre>
<p>We use CSS selectors to locate points of interest in the rendered output. In the test above, I&apos;m locating the <code>h1</code> tag and asserting that it contains the text &quot;<em>Testing is awesome!</em>&quot;. </p><p>We can run this test like we would a traditional unit test using the Visual Studio Test Explorer.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/12/example-test.png" class="kg-image"></figure><p>The tests also run exactly how you would expect when using a CI pipeline. Here&apos;s an example from Azure DevOps.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/12/blazored-modal-ci-tests.png" class="kg-image"></figure><h2 id="using-the-library">Using the library</h2><p>As I mentioned earlier, there isn&apos;t a NuGet package available for the library just yet. To use it you have to either download/clone/fork the repo from <a href="https://github.com/SteveSandersonMS/BlazorUnitTestingPrototype">Steve&apos;s GitHub account</a>. I&apos;ve created a <a href="https://github.com/chrissainty/BlazorUnitTestingPrototype">fork of it to my GitHub</a>, I&apos;ve also updated all the packages to the latest versions.</p><p>Once you have a copy of the code, you can open up the solution included with the repo. You&apos;ll find a sample application and some sample tests which give a few good examples of how to use the library.</p><p>You can play around with it from here if you just want to get to know it better. But I&apos;ve wanted to get some tests added into my Blazored libraries for quite a while now. So I thought this would be the perfect opportunity to do that and see how the library works with a real-world project.</p><p>We&apos;re going to start by adding some tests to <a href="https://github.com/Blazored/Modal">Blazored Modal</a>. This is a reasonably straightforward component which is controlled via a service. By calling a method on the service and passing different options or parameters, the modal is displayed in different configurations.</p><p>I&apos;ve decided on two test groupings, display tests and modal options tests. I like to try and group my tests to make them easier to find and maintain.</p><p>To start, we&apos;ll add a copy of Steve&apos;s testing library to the solution and also a new XUnit test project called <code>Blazored.Modal.Tests</code>.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/12/blazored-modal-test-setup.png" class="kg-image"></figure><p>Next, we need to add a reference to the testing library from the XUnit project and a reference to the <code>Blazored.Modal</code> project.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/12/blazored-modal-test-project-references.png" class="kg-image"></figure><p>We&apos;re going to create each of the test groupings I mentioned earlier as classes in the <code>Blazored.Modal.Tests</code> project. But so we don&apos;t have to duplicate boilerplate code we&apos;re going to create a test base class to encapsulate it.</p><pre><code class="language-csharp">public class TestBase
{
    protected TestHost _host;
    protected IModalService _modalService;

    public TestBase()
    {
        _host = new TestHost();
        _modalService = new ModalService();
        _host.AddService&lt;IModalService&gt;(_modalService);
    }
}
</code></pre>
<p>We start by creating a new <code>TestHost</code> instance, which is provided by Steve&apos;s testing library. As the modal component relies on an <code>IModalService</code> to function, we also need to add an instance of one to the <code>TestHost</code>&apos;s DI container. This is the place to replace any services with mocks if your components are using services which make external calls.</p><p>Now we have our <code>TestBase</code> sorted, let&apos;s get cracking with our display tests. Let&apos;s start by making sure that the modals initial state is not visible.</p><pre><code class="language-csharp">public class DisplayTests : TestBase
{
    [Fact]
    public void ModalIsNotVisibleByDefault()
    {
        var component = _host.AddComponent&lt;BlazoredModal&gt;();
        var modalContainer = component.Find(&quot;.blazored-modal-container.blazored-modal-active&quot;);

        Assert.Null(modalContainer);
    }
}
</code></pre>
<p>In the test we&apos;re creating an instance of the <code>BlazoredModal</code> component via the <code>TestHost</code>. Once we have that instance, we can use it to look for particular state. In our case, we&apos;re checking that no element has the <code>.blazored-modal-active</code> CSS class, as it&apos;s this class which makes the modal visible.</p><p>We now need a test to make sure the modal becomes visible when we call the <code>Show</code> method on the <code>IModalService</code>.</p><pre><code class="language-csharp">[Fact]
public void ModalIsVisibleWhenShowCalled()
{
    var component = _host.AddComponent&lt;BlazoredModal&gt;();
    _modalService.Show&lt;TestComponent&gt;(&quot;&quot;);

    var modalContainer = component.Find(&quot;.blazored-modal-container.blazored-modal-active&quot;);

    Assert.NotNull(modalContainer);
}
</code></pre>
<p>This time we&apos;re using the <code>_modalService</code> instance we setup in the <code>TestBase</code>. Once we&apos;ve created the instance of our <code>BlazoredModal</code> component, we call the <code>Show</code> method on the service. We then look for an element which has the <code>.blazored-modal-active</code> CSS class and check it&apos;s not null. </p><p>If you&apos;re wondering about the <code>TestComponent</code> type in the <code>Show</code> call, it&apos;s a simple component I created to use for these tests and looks like this.</p><pre><code class="language-csharp">internal class TestComponent : ComponentBase
{
    public const string TitleText = &quot;My Test Component&quot;;

    [CascadingParameter] public ModalParameters ModalParameters { get; set; }

    public string Title
    {
        get
        {
            var cascadedTitle = ModalParameters.TryGet&lt;string&gt;(&quot;Title&quot;);
            return string.IsNullOrWhiteSpace(cascadedTitle) ? TitleText : cascadedTitle;
        }
    }

    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        base.BuildRenderTree(builder);

        builder.OpenElement(1, &quot;h1&quot;);
        builder.AddContent(2, Title);
        builder.CloseElement();
    }
}
</code></pre>
<p>We&apos;ll see this used more later on.</p><p>So far so good, now we are going to test cancelling and closing the modal. Here are the tests.</p><pre><code class="language-csharp">[Fact]
public void ModalHidesWhenCloseCalled()
{
    var component = _host.AddComponent&lt;BlazoredModal&gt;();
    _modalService.Show&lt;TestComponent&gt;(&quot;&quot;);
    var modalContainer = component.Find(&quot;.blazored-modal-container.blazored-modal-active&quot;);

    Assert.NotNull(modalContainer);

    _modalService.Close(ModalResult.Ok(&quot;Ok&quot;));
    modalContainer = component.Find(&quot;.blazored-modal-container.blazored-modal-active&quot;);

    Assert.Null(modalContainer);
}

[Fact]
public void ModalHidesWhenCancelCalled()
{
    var component = _host.AddComponent&lt;BlazoredModal&gt;();
    _modalService.Show&lt;TestComponent&gt;(&quot;&quot;);
    var modalContainer = component.Find(&quot;.blazored-modal-container.blazored-modal-active&quot;);

    Assert.NotNull(modalContainer);

    _modalService.Cancel();
    modalContainer = component.Find(&quot;.blazored-modal-container.blazored-modal-active&quot;);

    Assert.Null(modalContainer);
}
</code></pre>
<p>These two tests are very similar, the only difference is the method we call on the modal service, either <code>Close</code> or <code>Cancel</code>. As you can see, I&apos;ve got two <code>Assert</code>s in each test. The first one is asserting that the modal is visible, then, after the <code>Cancel</code> or <code>Close</code> methods are called, the second assert checks that it&apos;s not anymore.</p><p>That&apos;s it for the display tests. Let&apos;s move on and look at the modal options tests next. I&apos;m not going to go through them all as I think things will get very repetitive, but I do want to look at two of them.</p><pre><code class="language-csharp">public class ModalOptionsTests : TestBase
{
    // Other tests omitted for brevity

    [Fact]
    public void ModalDisplaysCorrectContent()
    {
        var component = _host.AddComponent&lt;BlazoredModal&gt;();

        _modalService.Show&lt;TestComponent&gt;(&quot;&quot;);

        var content = component.Find(&quot;h1&quot;);

        Assert.Equal(content.InnerText, TestComponent.TitleText);
    }
    
    [Fact]
    public void ModalDisplaysCorrectContentWhenUsingModalParameters()
    {
        var testTitle = &quot;Testing Components&quot;;
        var parameters = new ModalParameters();
        parameters.Add(&quot;Title&quot;, testTitle);

        var component = _host.AddComponent&lt;BlazoredModal&gt;();

        _modalService.Show&lt;TestComponent&gt;(&quot;&quot;, parameters);

        var content = component.Find(&quot;h1&quot;);

        Assert.Equal(content.InnerText, testTitle);
    }
}
</code></pre>
<p>The first test is checking that the correct content gets rendered by the modal component. In the test, we&apos;re checking that the content of the <code>TestComponent</code> (see code from earlier) is rendered correctly inside the modal. The <code>TestComponent</code> just contains a simple <code>h1</code> tag which will display the string <em>&quot;My Test Component&quot;</em> by default.</p><p>The next test is checking that the component being displayed renders correctly based on a value passed using <code>ModalParameters</code>, which are passed into child components via a <code>CascadingParameter</code>. In this test, we&apos;re setting a <code>Title</code> parameter with the value <em>&quot;Testing Components&quot;</em>. We then check to make sure the correct title is displayed by the <code>TestComponent</code>.</p><p>The reason I wanted to highlight these two tests is because they show the more E2E style of testing achievable with this library. In order to test the <code>BlazoredModal</code> component fully we need to make sure it interacts with other components in the right way. And this is a very common scenario when building component based UIs, testing in isolation here wouldn&apos;t give us the same amount of confidence as testing these components together. </p><blockquote>You can view all the tests mentioned in this post at the <a href="https://github.com/Blazored/Modal">Blazored Modal</a> repo.</blockquote><p>That&apos;s where we&apos;re going to leave things. We&apos;ve managed to get setup with Steve&apos;s library and write some decent tests to check the functionality of Blazored Modal.</p><p>In this post, we&apos;ve taken a look at how to test Blazor components using Steve Sanderson&apos;s prototype testing library. We looked at how to get up and running with the library before using it to write some tests for the Blazored Modal component library.</p><p>I hope you&apos;ve found this post useful and if you have any feedback for Steve about his prototype, then please <a href="https://github.com/SteveSandersonMS/BlazorUnitTestingPrototype">head over to the repo</a> and open an issue.</p> <div class="coffee-button"> <a class="bmc-button" href="https://www.buymeacoffee.com/chrissainty"> <img src="https://bmc-cdn.nyc3.digitaloceanspaces.com/BMC-button-images/BMC-btn-logo.svg" alt="Buy me a coffee"> <span>Buy me a coffee</span> </a> </div> <div class="post-tags"> Tagged in: <a href="/blazor/">Blazor</a> | <a href="/unit-testing/">Unit Testing</a> | <a href="/blazor-server-side/">Blazor (Server)</a> | <a href="/blazor-client-side/">Blazor (WebAssembly)</a> </div> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>