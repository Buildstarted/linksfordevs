<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Introduction to Blazor Component Testing -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Introduction to Blazor Component Testing</h1><div><div class="post-content"><blockquote>This post is part of the <a href="https://crosscuttingconcerns.com/The-Third-Annual-csharp-Advent">third annual C# advent</a>. Two new posts are published every day between 1st December and 25th December.</blockquote><p>One significant area which has been lacking in Blazor is testing. There is a <a href="https://github.com/aspnet/AspNetCore/issues/5458">placeholder issue</a> for it, but for a very long time, there wasn't any progress. This is because testing was out of scope for the first official release of Blazor - which shipped with .NET Core 3 back in September.</p><p>However, just before the release in August, Steve Sanderson <a href="https://blog.stevensanderson.com/2019/08/29/blazor-unit-testing-prototype/">published a blog post</a> introducing a prototype unit testing library for Blazor components. Steve's prototype has the goal of getting the conversation going around testing in Blazor. I've wanted to test the library for a while, but I haven't had the chance until now.</p><p>Let's start by covering some of the high level questions about this prototype.</p><blockquote>I want to stress this is a prototype library and there is <strong>ZERO </strong>support for it, there isn't even a NuGet package right now. Therefore, anything you read here can, and most likely will, change.</blockquote><h2 id="what-types-of-testing-does-it-cover">What types of testing does it cover?</h2><p>There are various ways to test web applications but the two most common are unit tests and end-to-end tests (E2E tests). </p><h3 id="unit-testing">Unit testing</h3><p>Unit tests are lightweight and fast to run if written correctly, of course. They test small <em>"units"</em> of code in isolation. For example, given a method which takes two numbers and returns the sum of them. You could write a unit test which checks that if you provide the inputs <code>2</code> and <code>2</code> that the method returns <code>4</code>. However, checks in isolation can also be their downfall. It's possible that various units of code could run fine in isolation, but when put together they don't quite match up, and errors can occur.</p><h3 id="end-to-end-testing">End to end testing</h3><p>E2E tests can help to combat the issues with unit tests. You can test the whole application stack using E2E testing. E2E tests often use a headless browser to run tests which assert against the DOM. This is achieved using tools such as <a href="https://selenium.dev/">Selenium</a> which drive a headless browser and provide an interface to access the HTML. The drawback of these type of tests is they're much more heavyweight. They're also known to be brittle and slow; it takes substantial effort to both make them reliable and keep them that way.</p><h3 id="the-best-of-both">The best of both</h3><p>What Steve's prototype library attempts to do is to bring the best of both of these testing approaches but without the drawbacks - sounds pretty good to me!</p><h2 id="how-does-it-work">How does it work?</h2><p>Steve's library supplies a <code>TestHost</code> which allows components to be mounted using a <code>TestRenderer</code> under the hood. It's compatible with traditional unit testing frameworks such as XUnit and NUnit and gives us a straightforward and clean way of writing tests. This is an example of what a test looks like using XUnit.</p><pre><code class="language-html">&lt;!-- MyComponent.razor --&gt;

&lt;h1&gt;Testing is awesome!&lt;/h1&gt;
</code></pre><pre><code class="language-csharp">public class MyComponentTests
{
    private TestHost _host = new TestHost();

    [Fact]
    public void MyBlazingUnitTest()
    {
        var component = _host.AddComponent&lt;MyComponent&gt;();
        
        Assert.Equal("Testing is awesome!", component.Find("h1").InnerText);
    }
}
</code></pre><p>We use CSS selectors to locate points of interest in the rendered output. In the test above, I'm locating the <code>h1</code> tag and asserting that it contains the text "<em>Testing is awesome!</em>". </p><p>We can run this test like we would a traditional unit test using the Visual Studio Test Explorer.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/12/example-test.png" class="kg-image"></figure><p>The tests also run exactly how you would expect when using a CI pipeline. Here's an example from Azure DevOps.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/12/blazored-modal-ci-tests.png" class="kg-image"></figure><h2 id="using-the-library">Using the library</h2><p>As I mentioned earlier, there isn't a NuGet package available for the library just yet. To use it you have to either download/clone/fork the repo from <a href="https://github.com/SteveSandersonMS/BlazorUnitTestingPrototype">Steve's GitHub account</a>. I've created a <a href="https://github.com/chrissainty/BlazorUnitTestingPrototype">fork of it to my GitHub</a>, I've also updated all the packages to the latest versions.</p><p>Once you have a copy of the code, you can open up the solution included with the repo. You'll find a sample application and some sample tests which give a few good examples of how to use the library.</p><p>You can play around with it from here if you just want to get to know it better. But I've wanted to get some tests added into my Blazored libraries for quite a while now. So I thought this would be the perfect opportunity to do that and see how the library works with a real-world project.</p><h2 id="testing-blazored-modal">Testing Blazored Modal</h2><p>We're going to start by adding some tests to <a href="https://github.com/Blazored/Modal">Blazored Modal</a>. This is a reasonably straightforward component which is controlled via a service. By calling a method on the service and passing different options or parameters, the modal is displayed in different configurations.</p><p>I've decided on two test groupings, display tests and modal options tests. I like to try and group my tests to make them easier to find and maintain.</p><p>To start, we'll add a copy of Steve's testing library to the solution and also a new XUnit test project called <code>Blazored.Modal.Tests</code>.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/12/blazored-modal-test-setup.png" class="kg-image"></figure><p>Next, we need to add a reference to the testing library from the XUnit project and a reference to the <code>Blazored.Modal</code> project.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/12/blazored-modal-test-project-references.png" class="kg-image"></figure><p>We're going to create each of the test groupings I mentioned earlier as classes in the <code>Blazored.Modal.Tests</code> project. But so we don't have to duplicate boilerplate code we're going to create a test base class to encapsulate it.</p><pre><code class="language-csharp">public class TestBase
{
    protected TestHost _host;
    protected IModalService _modalService;

    public TestBase()
    {
        _host = new TestHost();
        _modalService = new ModalService();
        _host.AddService&lt;IModalService&gt;(_modalService);
    }
}
</code></pre><p>We start by creating a new <code>TestHost</code> instance, which is provided by Steve's testing library. As the modal component relies on an <code>IModalService</code> to function, we also need to add an instance of one to the <code>TestHost</code>'s DI container. This is the place to replace any services with mocks if your components are using services which make external calls.</p><p>Now we have our <code>TestBase</code> sorted, let's get cracking with our display tests. Let's start by making sure that the modals initial state is not visible.</p><pre><code class="language-csharp">public class DisplayTests : TestBase
{
    [Fact]
    public void ModalIsNotVisibleByDefault()
    {
        var component = _host.AddComponent&lt;BlazoredModal&gt;();
        var modalContainer = component.Find(".blazored-modal-container.blazored-modal-active");

        Assert.Null(modalContainer);
    }
}
</code></pre><p>In the test we're creating an instance of the <code>BlazoredModal</code> component via the <code>TestHost</code>. Once we have that instance, we can use it to look for particular state. In our case, we're checking that no element has the <code>.blazored-modal-active</code> CSS class, as it's this class which makes the modal visible.</p><p>We now need a test to make sure the modal becomes visible when we call the <code>Show</code> method on the <code>IModalService</code>.</p><pre><code class="language-csharp">[Fact]
public void ModalIsVisibleWhenShowCalled()
{
    var component = _host.AddComponent&lt;BlazoredModal&gt;();
    _modalService.Show&lt;TestComponent&gt;("");

    var modalContainer = component.Find(".blazored-modal-container.blazored-modal-active");

    Assert.NotNull(modalContainer);
}
</code></pre><p>This time we're using the <code>_modalService</code> instance we setup in the <code>TestBase</code>. Once we've created the instance of our <code>BlazoredModal</code> component, we call the <code>Show</code> method on the service. We then look for an element which has the <code>.blazored-modal-active</code> CSS class and check it's not null. </p><p>If you're wondering about the <code>TestComponent</code> type in the <code>Show</code> call, it's a simple component I created to use for these tests and looks like this.</p><pre><code class="language-csharp">internal class TestComponent : ComponentBase
{
    public const string TitleText = "My Test Component";

    [CascadingParameter] public ModalParameters ModalParameters { get; set; }

    public string Title
    {
        get
        {
            var cascadedTitle = ModalParameters.TryGet&lt;string&gt;("Title");
            return string.IsNullOrWhiteSpace(cascadedTitle) ? TitleText : cascadedTitle;
        }
    }

    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        base.BuildRenderTree(builder);

        builder.OpenElement(1, "h1");
        builder.AddContent(2, Title);
        builder.CloseElement();
    }
}
</code></pre><p>We'll see this used more later on.</p><p>So far so good, now we are going to test cancelling and closing the modal. Here are the tests.</p><pre><code class="language-csharp">[Fact]
public void ModalHidesWhenCloseCalled()
{
    var component = _host.AddComponent&lt;BlazoredModal&gt;();
    _modalService.Show&lt;TestComponent&gt;("");
    var modalContainer = component.Find(".blazored-modal-container.blazored-modal-active");

    Assert.NotNull(modalContainer);

    _modalService.Close(ModalResult.Ok("Ok"));
    modalContainer = component.Find(".blazored-modal-container.blazored-modal-active");

    Assert.Null(modalContainer);
}

[Fact]
public void ModalHidesWhenCancelCalled()
{
    var component = _host.AddComponent&lt;BlazoredModal&gt;();
    _modalService.Show&lt;TestComponent&gt;("");
    var modalContainer = component.Find(".blazored-modal-container.blazored-modal-active");

    Assert.NotNull(modalContainer);

    _modalService.Cancel();
    modalContainer = component.Find(".blazored-modal-container.blazored-modal-active");

    Assert.Null(modalContainer);
}
</code></pre><p>These two tests are very similar, the only difference is the method we call on the modal service, either <code>Close</code> or <code>Cancel</code>. As you can see, I've got two <code>Assert</code>s in each test. The first one is asserting that the modal is visible, then, after the <code>Cancel</code> or <code>Close</code> methods are called, the second assert checks that it's not anymore.</p><p>That's it for the display tests. Let's move on and look at the modal options tests next. I'm not going to go through them all as I think things will get very repetitive, but I do want to look at two of them.</p><pre><code class="language-csharp">public class ModalOptionsTests : TestBase
{
    // Other tests omitted for brevity

    [Fact]
    public void ModalDisplaysCorrectContent()
    {
        var component = _host.AddComponent&lt;BlazoredModal&gt;();

        _modalService.Show&lt;TestComponent&gt;("");

        var content = component.Find("h1");

        Assert.Equal(content.InnerText, TestComponent.TitleText);
    }
    
    [Fact]
    public void ModalDisplaysCorrectContentWhenUsingModalParameters()
    {
        var testTitle = "Testing Components";
        var parameters = new ModalParameters();
        parameters.Add("Title", testTitle);

        var component = _host.AddComponent&lt;BlazoredModal&gt;();

        _modalService.Show&lt;TestComponent&gt;("", parameters);

        var content = component.Find("h1");

        Assert.Equal(content.InnerText, testTitle);
    }
}
</code></pre><p>The first test is checking that the correct content gets rendered by the modal component. In the test, we're checking that the content of the <code>TestComponent</code> (see code from earlier) is rendered correctly inside the modal. The <code>TestComponent</code> just contains a simple <code>h1</code> tag which will display the string <em>"My Test Component"</em> by default.</p><p>The next test is checking that the component being displayed renders correctly based on a value passed using <code>ModalParameters</code>, which are passed into child components via a <code>CascadingParameter</code>. In this test, we're setting a <code>Title</code> parameter with the value <em>"Testing Components"</em>. We then check to make sure the correct title is displayed by the <code>TestComponent</code>.</p><p>The reason I wanted to highlight these two tests is because they show the more E2E style of testing achievable with this library. In order to test the <code>BlazoredModal</code> component fully we need to make sure it interacts with other components in the right way. And this is a very common scenario when building component based UIs, testing in isolation here wouldn't give us the same amount of confidence as testing these components together. </p><blockquote>You can view all the tests mentioned in this post at the <a href="https://github.com/Blazored/Modal">Blazored Modal</a> repo.</blockquote><h2 id="summary">Summary</h2><p>That's where we're going to leave things. We've managed to get setup with Steve's library and write some decent tests to check the functionality of Blazored Modal.</p><p>In this post, we've taken a look at how to test Blazor components using Steve Sanderson's prototype testing library. We looked at how to get up and running with the library before using it to write some tests for the Blazored Modal component library.</p><p>I hope you've found this post useful and if you have any feedback for Steve about his prototype, then please <a href="https://github.com/SteveSandersonMS/BlazorUnitTestingPrototype">head over to the repo</a> and open an issue.</p><hr><hr></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>