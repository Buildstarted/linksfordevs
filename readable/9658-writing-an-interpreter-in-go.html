<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Writing An Interpreter In Go -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Writing An Interpreter In Go</h1><div><div class="col-md-8 col-md-offset-2"><div class="buy-container"><h4 id="span-classnewnewspan-buy-the-ebook-bundle-and-get-two-books"><span class="new">NEW:</span> Buy the <strong>eBook bundle</strong> and get two books!</h4><p><a href="https://compilerbook.com"><img class="img-responsive" id="bundle-cover-img" src="/img/wacig_cover-4581a171.png"></a></p><p>This book now has a sequel in which we take the next step in Monkey's evolution. You can buy both books together to get:</p><ul><li><strong>Writing An Interpreter In Go</strong> and <a href="https://compilerbook.com">Writing A Compiler In Go</a> in one package for a <strong>reduced bundle price</strong>!</li><li>Both books in <strong>ePub (iBook), Mobi (Kindle), PDF and HTML</strong>.</li><li>The complete code presented in both books, including the Monkey
interpreter from <em>Writing An Interpreter In Go</em> and the <strong>Monkey bytecode
compiler and virtual machine</strong> from <a href="https://compilerbook.com">Writing A Compiler In Go</a>.</li></ul></div><h4 id="buy-this-book-to-learn">Buy this book to learn:</h4><ul><li>How to build an interpreter for a C-like programming language <strong>from scratch</strong></li><li>What a <strong>lexer</strong>, a <strong>parser</strong> and an <strong>Abstract Syntax Tree (AST)</strong> are and
<strong>how to build your own</strong></li><li>What <strong>closures</strong> are and how and why they work</li><li>What the <strong>Pratt parsing technique</strong> and a <strong>recursive descent parser</strong> is</li><li>What others talk about when they talk about <strong>built-in data structures</strong></li><li>What <strong>REPL</strong> stands for and how to build one</li></ul><h4 id="why-this-book">Why this book?</h4><p>This is the book I wanted to have a year ago. This is the book I couldn't find.
<strong>I wrote this book for you and me</strong>.</p><p>So why should you buy it? What's different about it, compared to other
interpreter or compiler literature?</p><ul><li><strong>Working code is the focus</strong>. Code is not just found in the appendix. Code is
the main focus of this book.</li><li><strong>It's small!</strong> It has around <strong>200 pages</strong> of which a great deal is
readable, syntax-highlighted, working code.</li><li>The code presented in the book is <strong>easy to understand, easy to extend, easy
to maintain.</strong></li><li><strong>No 3rd party libraries!</strong> You're not left wondering: "But how does tool X do
that?" We won't use a tool X. We only use the Go standard library and write
everything ourselves.</li><li><strong>Tests!</strong> The interpreter we build in the book is <strong>fully tested!</strong> Sometimes
in TDD style, sometimes with the tests written after. You can easily run the
tests to experiment with the interpreter and make changes.</li></ul><div class="wrapper quotes"><blockquote><p>
      "If you don’t know how compilers work, then you don’t know how computers work.
      If you’re not 100% sure whether you know how compilers work, then you don’t
      know how they work."
    </p><footer><a href="http://steve-yegge.blogspot.de/2007/06/rich-programmer-food.html">
        Steve Yegge, super famous programmer and blogger
      </a></footer></blockquote><blockquote><p>
      "Start by writing an interpreter with me!"
    </p><footer>
      Thorsten Ball, author of the book you're looking at
    </footer></blockquote></div><h4 id="this-book-is-for-you-if-you">This book is for you if you…</h4><ul><li><strong>learn by building</strong> and <strong>love to look under the hood</strong></li><li>love programming and to <strong>program for the sake of learning and joy</strong>!</li><li>are interested in <strong>how your favorite, interpreted programming language works</strong></li><li><strong>never took a compiler course in college</strong></li><li>want to <strong>get started</strong> with interpreters or compilers…</li><li>… but don't want to work through a <strong>theory-heavy, 800 pages, 4 pounds
compiler book</strong> as a beginner</li><li>kept screaming <strong>"show me the code!"</strong> when reading about interpreters and
compilers</li><li>always wanted to say: <strong>"Holy shit, I built a programming language!"</strong></li></ul><h4 id="the-monkey-programming-language">The Monkey Programming Language</h4><p>In this book we'll create an interpreter for the Monkey programming language.
Monkey is a language especially designed for this book. <strong>We will bring it to
life by implementing its interpreter</strong>.</p><p>Monkey looks like this:</p><pre class="highlight javascript"><code><span class="c1">// Bind values to names with let-statements</span><span class="kd">let</span><span class="nx">version</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="kd">let</span><span class="nx">name</span><span class="o">=</span><span class="s2">"Monkey programming language"</span><span class="p">;</span><span class="kd">let</span><span class="nx">myArray</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span><span class="kd">let</span><span class="nx">coolBooleanLiteral</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span><span class="c1">// Use expressions to produce values</span><span class="kd">let</span><span class="nx">awesomeValue</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="o">+</span><span class="mi">30</span><span class="p">;</span><span class="kd">let</span><span class="nx">arrayWithValues</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span></code></pre><p>Monkey also supports function literals and we can use them to bind a function to
a name:</p><pre class="highlight javascript"><code><span class="c1">// Define a `fibonacci` function</span><span class="kd">let</span><span class="nx">fibonacci</span><span class="o">=</span><span class="nx">fn</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="p">{</span><span class="mi">0</span><span class="c1">// Monkey supports implicit returning of values</span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="p">{</span><span class="k">return</span><span class="mi">1</span><span class="p">;</span><span class="c1">// ... and explicit return statements</span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span><span class="c1">// Recursion! Yay!</span><span class="p">}</span><span class="p">}</span><span class="p">};</span></code></pre><p>The data types we're going to support in this book are booleans, strings, hashes,
integers and arrays. We can combine them!</p><pre class="highlight javascript"><code><span class="c1">// Here is an array containing two hashes, that use strings as keys and integers</span><span class="c1">// and strings as values</span><span class="kd">let</span><span class="nx">people</span><span class="o">=</span><span class="p">[{</span><span class="s2">"name"</span><span class="p">:</span><span class="s2">"Anna"</span><span class="p">,</span><span class="s2">"age"</span><span class="p">:</span><span class="mi">24</span><span class="p">},</span><span class="p">{</span><span class="s2">"name"</span><span class="p">:</span><span class="s2">"Bob"</span><span class="p">,</span><span class="s2">"age"</span><span class="p">:</span><span class="mi">99</span><span class="p">}];</span><span class="c1">// Getting elements out of the data types is also supported.</span><span class="c1">// Here is how we can access array elements by using index expressions:</span><span class="nx">fibonacci</span><span class="p">(</span><span class="nx">myArray</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span><span class="c1">// =&gt; 5</span><span class="c1">// We can also access hash elements with index expressions:</span><span class="kd">let</span><span class="nx">getName</span><span class="o">=</span><span class="nx">fn</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span><span class="p">{</span><span class="nx">person</span><span class="p">[</span><span class="s2">"name"</span><span class="p">];</span><span class="p">};</span><span class="c1">// And here we access array elements and call a function with the element as</span><span class="c1">// argument:</span><span class="nx">getName</span><span class="p">(</span><span class="nx">people</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="c1">// =&gt; "Anna"</span><span class="nx">getName</span><span class="p">(</span><span class="nx">people</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="c1">// =&gt; "Bob"</span></code></pre><p>That's not all though. Monkey has a few tricks up its sleeve. In Monkey
functions are first-class citizens, they are treated like any other value. Thus
we can use higher-order functions and pass functions around as values:</p><pre class="highlight javascript"><code><span class="c1">// Define the higher-order function `map`, that calls the given function `f`</span><span class="c1">// on each element in `arr` and returns an array of the produced values.</span><span class="kd">let</span><span class="nx">map</span><span class="o">=</span><span class="nx">fn</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">f</span><span class="p">)</span><span class="p">{</span><span class="kd">let</span><span class="nx">iter</span><span class="o">=</span><span class="nx">fn</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="nx">accumulated</span><span class="p">)</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="nx">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="p">{</span><span class="nx">accumulated</span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="nx">iter</span><span class="p">(</span><span class="nx">rest</span><span class="p">(</span><span class="nx">arr</span><span class="p">),</span><span class="nx">push</span><span class="p">(</span><span class="nx">accumulated</span><span class="p">,</span><span class="nx">f</span><span class="p">(</span><span class="nx">first</span><span class="p">(</span><span class="nx">arr</span><span class="p">))));</span><span class="p">}</span><span class="p">};</span><span class="nx">iter</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="p">[]);</span><span class="p">};</span><span class="c1">// Now let's take the `people` array and the `getName` function from above and</span><span class="c1">// use them with `map`.</span><span class="nx">map</span><span class="p">(</span><span class="nx">people</span><span class="p">,</span><span class="nx">getName</span><span class="p">);</span><span class="c1">// =&gt; ["Anna", "Bob"]</span></code></pre><p>And, of course, Monkey also supports closures:</p><pre class="highlight javascript"><code><span class="c1">// newGreeter returns a new function, that greets a `name` with the given</span><span class="c1">// `greeting`.</span><span class="kd">let</span><span class="nx">newGreeter</span><span class="o">=</span><span class="nx">fn</span><span class="p">(</span><span class="nx">greeting</span><span class="p">)</span><span class="p">{</span><span class="c1">// `puts` is a built-in function we add to the interpreter</span><span class="k">return</span><span class="nx">fn</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span><span class="p">{</span><span class="nx">puts</span><span class="p">(</span><span class="nx">greeting</span><span class="o">+</span><span class="s2">" "</span><span class="o">+</span><span class="nx">name</span><span class="p">);</span><span class="p">}</span><span class="p">};</span><span class="c1">// `hello` is a greeter function that says "Hello"</span><span class="kd">let</span><span class="nx">hello</span><span class="o">=</span><span class="nx">newGreeter</span><span class="p">(</span><span class="s2">"Hello"</span><span class="p">);</span><span class="c1">// Calling it outputs the greeting:</span><span class="nx">hello</span><span class="p">(</span><span class="s2">"dear, future Reader!"</span><span class="p">);</span><span class="c1">// =&gt; Hello dear, future Reader!</span></code></pre><p><strong>Yes! All of this works with the interpreter we build in the book!</strong></p><p>So, to summarize: Monkey has a C-like syntax, supports <strong>variable bindings</strong>,
<strong>prefix</strong> and <strong>infix</strong> operators, has <strong>first-class and higher-order
functions</strong>, can handle <strong>closures</strong> with ease and has <strong>integers</strong>,
<strong>booleans</strong>, <strong>arrays</strong> and <strong>hashes</strong> built-in.</p><h4>Readers are saying...</h4><blockquote class="testimonial"><p>
  "Compilers was the most surprisingly useful university course I ever took.
  Learning to write a parser and runtime for a toy language helps take away a
  lot of "magic" in various parts of computer science. I recommend any engineer
  who isn't familiar with lexers, parsers, and evaluators to read Thorsten's
  book."
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/mitchellh/small">
    Mitchell Hashimoto (<a href="https://twitter.com/mitchellh">@mitchellh</a>)<br>Founder of <a href="https://www.hashicorp.com/">HashiCorp</a></cite></blockquote><blockquote class="testimonial"><p>
  "Amazing book! Besides satisfying my curiosity with clear writing and code
  examples, the book inspired me to apply those skills to a new http testing
  tool I’m working on."
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/felixge/small">
    Felix Geisendörfer (<a href="https://twitter.com/felixge">@felixge</a>)<br>Prolific Open Source Contributor, Creator of <a href="http://godrone.readthedocs.io/en/latest/">GoDrone</a>, Node.js Core Alumni
  </cite></blockquote><blockquote class="testimonial"><p>
  "Great book. I loved it because everything is built by hand, so you get to think
  about all the details, and it does so in a gradual way, which is didactic. The
  implementation itself is also nice and simple 🙌"
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/fxn/small">
    Xavier Noria (<a href="https://twitter.com/fxn">@fxn</a>)<br>Everlasting student, Rails Core Team, Ruby Hero, Freelance, Live lover
  </cite></blockquote><blockquote class="testimonial"><p>
  "I really enjoyed the modern, practical approach of this book. Diving into
  the world of interpreters, by getting your hands dirty right from the
  beginning."
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/fabrik42/small">
    Christian Bäuerlein (<a href="https://twitter.com/fabrik42">@fabrik42</a>)<br>Developer, Organizer &amp; Curator of <a href="https://www.meetup.com/Mechanical-Keyboard-Meetup-Rhein-Main/">MECHANICON</a></cite></blockquote><blockquote class="testimonial"><p>
  "This book demystifies and makes the topic of interpreters approachable and
  fun. Don't be surprised if you become a better Go programmer after working
  your way through it."
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/jboursiquot/small">
    Johnny Boursiquot (<a href="https://twitter.com/jboursiquot">@jboursiquot</a>)<br>Go Programmer, <a href="https://twitter.com/BaltimoreGolang">@BaltimoreGolang</a> Organizer,
    <a href="https://twitter.com/GolangBridge">@GolangBridge</a> Core Member
  </cite></blockquote><blockquote class="testimonial"><p>
  "Great writing and explanations. The practical focus of the book kept me
  coding for a week straight. Definitely the best book to get into the magical
  world of compilers and interpreters."
  </p><cite>
    Arthur&nbsp;Tabatchnic (<a href="https://www.linkedin.com/in/arthur-tabatchnic-ab694290">LinkedIn</a>)<br>Senior Cloud Solutions Developer
  </cite></blockquote><blockquote class="testimonial"><p>
  "We use parsers and interpreters on a daily basis, just think of JavaScript
  and JSON. This book not only helped me to better understand how they work but
  will come in handy the next time I have to implement a parser for an obscure
  data format."
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/rmehner/small">
    Robin Mehner (<a href="https://twitter.com/rmehner">@rmehner</a>)<br>Developer, Organizer of <a href="http://berlinjs.org/">BerlinJS</a>, <a href="http://rejectjs.org/">Reject.JS</a> &amp; <a href="http://www.nodecopter.com/">NodeCopter</a>.
  </cite></blockquote><blockquote class="testimonial"><p>
  "This book clearly, and elegantly explains the different pieces needed to
  make a language. From lexing and parsing to actually executing the code, this
  book does a great job explaining to the reader the purpose of each element
  and how they interact."
  </p><cite>
    Lee Keitel (<a href="https://github.com/lfkeitel">lfkeitel</a>)<br>Systems Programmer &amp; Network Technician
  </cite></blockquote><blockquote class="testimonial"><p>
  "I loved this book and it remains one of my favorite #golang books to this day."
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/bdowns328/small">
    Brian Downs (<a href="https://twitter.com/bdowns328">@bdowns328</a>)<br>Software Engineer &amp; Organizer of <a href="https://twitter.com/golangphoenix">Golang Phoenix</a></cite></blockquote><blockquote class="testimonial"><p>
  "I only wish this book was available ten years ago! At the time I was using
  Appel's Java book and trying wade through the dragon book too. It's so
  refreshing to have a TDD-based tutorial to learn the concepts in a language
  you might reasonably use to build an interpreter."
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/robertgravina/small">
    Robert Gravina (<a href="https://twitter.com/robertgravina">@robertgravina</a>)<br>Programmer
  </cite></blockquote><blockquote class="testimonial"><p>
  "This book is not only educational, but the code quality is incredible, which
  allows the reader to move seamlessly from chapter to chapter without the need
  to scratch their head over what the code means or how it works. It is cleanly
  separated, well optimized, highly readable, and very precise in its
  functionality. Because of this, it provides an excellent example for both
  novices and veterans of the Go programming language, and will serve readers
  beyond a purely intellectual understanding of programming language design and
  functionality; the code used in the book will also provide a solid foundation
  in Go programming that can be practically applied right away. This balance is
  tough to achieve, and made the book a joy to read."
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/insp3ctre/small">
    Aaron Hnatiw (<a href="https://twitter.com/insp3ctre">@insp3ctre</a>)<br>Hacker, educator, software developer
  </cite></blockquote><blockquote class="testimonial"><p>
  "I was completely hooked by your book on writing an interpreter and read it
  in 3 days. It might be the best book on programming I've ever read, and I
  read a lot of them. I love how all of the concepts are explained simply
  through very readable code and I love how the product turned out so real and
  useful. I wish more books were written in this style and I look forward to
  diving into the sequel!"
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/ludviggislason/small">
    Ludvig Gislason (<a href="https://twitter.com/ludviggislason">@ludviggislason</a>)<br>Software Engineer
  </cite></blockquote><blockquote class="testimonial"><p>
  "Thorsten took a topic that is usually very dry and CS heavy and made it
  accessible and easy to understand. After reading this book I felt confident
  enough to write <a href="https://github.com/gobuffalo/plush">Plush</a>, the
  templating language I’ve always wanted in Go! If you have yet to read
  Thorsten's book, I can't recommend it enough. Please go and buy it!"
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/markbates/small">
    Mark Bates (<a href="https://twitter.com/markbates">@markbates</a>)<br>Creator of <a href="http://gobuffalo.io/">gobuffalo.io</a></cite></blockquote><blockquote class="testimonial"><p>
  "Thorsten's writing style is fun and easy to understand with detailed
  explanations and even better code. Even if you've written an interpreter
  before, this book is a great refresher. I picked it up as <a href="https://www.influxdata.com/blog/rust-can-be-difficult-to-learn-and-frustrating-but-its-also-the-most-exciting-thing-in-software-development-in-a-long-time/">a project to learn
    Rust</a>, translating the example Go code into Rust as I read through. Lexers,
  parsers, and interpreters are such a fundamental part of CS, these skills are
  valuable to more than just programmers implementing programming languages. As
  a project for picking up a new language, this book is perfect because it only
  requires the standard library and has extensive test driven development,
  which means you get quick feedback as you go along. I highly recommend it for
  programmers wanting to learn more about lexers, parsers, and interpreters or
  Go programmers picking up a new language looking for a project to learn
  through."
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/pauldix/small">
    Paul Dix (<a href="https://twitter.com/pauldix">@pauldix</a>)<br>CTO of <a href="https://www.influxdata.com/">InfluxDB</a></cite></blockquote><blockquote class="testimonial"><p>
    "This is a very polished pair of books that together give a steady path to
    follow for learning some of the real techniques that are used to implement
    programming languages. They're both well above average for their depth,
    technical clarity, and accessibility. I've been recommending them to
    everyone I work with who wants to get involved in compilers."
  </p><cite><img class="testimonial-avatar" src="https://avatars.io/twitter/chrisgseaton/small">
    Chris Seaton (<a href="https://twitter.com/ChrisGSeaton">@ChrisGSeaton</a>)<br>Researcher at <a href="https://www.shopify.com/">Shopify</a>, PhD in Ruby, Founder of <a href="https://chrisseaton.com/truffleruby/">Truffle Ruby</a></cite></blockquote><div class="buy-container"><h4 id="buy-the-ebook-and-you-will-get">Buy the <strong>eBook</strong> and you will get:</h4><ul><li>The complete book in <strong>ePub (iBook), Mobi (Kindle), PDF and HTML</strong>.</li><li><strong>The complete, working interpreter for the Monkey programming language!</strong></li><li><strong>All the code presented in the book</strong>, easily usable, organized by
chapters, MIT licensed and including the complete test suite.</li><li><strong>Free updates</strong>: Once you buy the book you will get free updates for the
lifetime of that edition of the book.</li><li><strong>Money-Back-Guarantee</strong>: I want you to enjoy this book. If you, for any
reason, are not happy with it just send me an email. You'll keep
what you bought and your money back.</li></ul></div><div class="buy-container"><h4 id="buy-the-paperback-and-you-will-get">Buy the <strong>paperback</strong> and you will get:</h4><ul><li>The <strong>physical</strong> 260 pages paperback book</li><li><strong>The complete, working interpreter for the Monkey programming language!</strong></li><li><strong>All the code presented in the book</strong>, easily usable, organized by
chapters, MIT licensed and including the complete test suite.</li><li><strong>Amazon Support</strong>: the book is distributed through Amazon and you get to
benefit by all the money-back-guarantees and shipping Amazon offers.</li></ul></div><div class="buy-container"><h4 id="span-classnewnewspan-buy-the-ebook-bundle-and-get-two-books"><span class="new">NEW:</span> Buy the <strong>eBook bundle</strong> and get two books!</h4><p><a href="https://compilerbook.com"><img class="img-responsive" id="bundle-cover-img" src="/img/wacig_cover-4581a171.png"></a></p><p>This book now has a sequel in which we take the next step in Monkey's evolution. You can buy both books together to get:</p><ul><li><strong>Writing An Interpreter In Go</strong> and <a href="https://compilerbook.com">Writing A Compiler In Go</a> in one package for a <strong>reduced bundle price</strong>!</li><li>Both books in <strong>ePub (iBook), Mobi (Kindle), PDF and HTML</strong>.</li><li>The complete code presented in both books, including the Monkey
interpreter from <em>Writing An Interpreter In Go</em> and the <strong>Monkey bytecode
compiler and virtual machine</strong> from <a href="https://compilerbook.com">Writing A Compiler In Go</a>.</li></ul></div><div class="faq-container"><h4 id="faq">FAQ</h4><ul><li><p><strong>Do I need previous experience with interpreters or compilers?</strong></p><p>Absolutely not! On the contrary, this book was written for you!</p></li><li><p><strong>Can I read the book even though I'm not a Go programmer?</strong></p><p>Yes! I wrote the book with the aim to keep the code as easy to understand as
possible. If you are experienced in other programming languages you should be
able to understand it. Take a look at the <a href="/sample.pdf">free
excerpt</a> - that's as advanced as the Go code gets.</p></li><li><p><strong>Can I buy a bundle of the eBook and the paperback?</strong></p><p>I'm sorry to say it, but no, I cannot bundle eBooks with paperbacks. It's not
that I don't want to (I do!) but I can't. The eBooks are sold and distributed
through Gumroad, where I have a lot of influence on the process, but the
paperback editions are being printed, sold and shipped by Amazon and I don't
have many options there. I can't tell Amazon to bundle digital files with the
paperback. Sorry!</p></li><li><p><strong>I found a typo/mistake/error in the book. What now?</strong></p><p>Take a look at the <a href="/changelog">changelog</a> to see whether I've already fixed
it. If I haven't or you're not sure I have, please send me an email to
<strong>me&nbsp;@&nbsp;thorstenball.com</strong> —&nbsp;I really appreciate it!</p></li><li><p><strong>Why isn't the book called "Writing An Interpreter In Golang"? Wouldn't that
be better for SEO?</strong></p><p>Well, I always thought I could use the "Golang" somewhere on the landingpage,
maybe in the FAQ or something.</p></li><li><p><strong>The books are too expensive for me. Can you help me out?</strong></p><p>Sure, just send me a picture! I'm always fascinated by new places and love
seeing where people live, so here's my proposal.</p><p>You go outside, take a picture of where you live and send it to me to
<strong>me&nbsp;@&nbsp;thorstenball.com</strong>. Tell me what you feel comfortable paying
for the book(s) and we'll make that happen.</p></li></ul></div><h4 id="the-lost-chapter">
  The Lost Chapter: A Macro System For Monkey
</h4><p><a href="https://interpreterbook.com/lost"><img class="img-responsive" id="lost-chapter-cover-img" src="/img/lost_chapter_cover-86db7d5c.png"></a></p><p>More than half a year after publishing <em>Writing An Interpreter In Go</em> I decided
to write another chapter. An additional chapter that's available to everyone:
<strong>free to read online or to download as an eBook.</strong></p><p>It's called <em>The Lost Chapter: A Macro System For Monkey</em> and can be thought of
as the fifth chapter for <em>Writing An Interpreter In Go</em>. It builds directly
upon the previous four and extends the Monkey interpreter as it stands at the
end of the book.</p><p>In the chapter we add a fully-working Lisp-style macro system to Monkey, that's
close to the way Elixir's macro system works. It looks like this:</p><pre class="highlight javascript"><code><span class="kd">let</span><span class="nx">unless</span><span class="o">=</span><span class="nx">macro</span><span class="p">(</span><span class="nx">condition</span><span class="p">,</span><span class="nx">consequence</span><span class="p">,</span><span class="nx">alternative</span><span class="p">)</span><span class="p">{</span><span class="nx">quote</span><span class="p">(</span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">unquote</span><span class="p">(</span><span class="nx">condition</span><span class="p">)))</span><span class="p">{</span><span class="nx">unquote</span><span class="p">(</span><span class="nx">consequence</span><span class="p">);</span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="nx">unquote</span><span class="p">(</span><span class="nx">alternative</span><span class="p">);</span><span class="p">});</span><span class="p">};</span><span class="nx">unless</span><span class="p">(</span><span class="mi">10</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">,</span><span class="nx">puts</span><span class="p">(</span><span class="s2">"not greater"</span><span class="p">),</span><span class="nx">puts</span><span class="p">(</span><span class="s2">"greater"</span><span class="p">));</span><span class="c1">// outputs only: "greater"</span></code></pre><p>Building your own programming language is likely not something you do in your
day job. But adding a fully working macro system? Well, that's not just
unlikely, but <strong>outright bizarre and, oh, so much fun!</strong> Macros are code that
writes code. Can you imagine how much fun it is to write code that allows us to
write code that writes code? Exactly!</p><h4 id="about-the-author">About the author</h4><p><img src="/img/author-25e23738.jpg" class="img-rounded author-picture"></p><p>Hi, my name is Thorsten Ball. I'm a programmer living in Germany. My whole
professional life as a software developer I've been working with web
technologies and have deployed Ruby, JavaScript, Go and even C code to
production systems.</p><p>Maybe you've read one of my blog posts. Some of them are pretty popular. There's
the one about <a href="http://thorstenball.com/blog/2014/03/12/watching-understanding-ruby-2.1-garbage-collector/">the Ruby Garbage
Collector</a>.
And the one about <a href="http://thorstenball.com/blog/2014/06/13/where-did-fork-go/">the fork system
call</a>. If you
haven't read one of them, then maybe the one about <a href="http://thorstenball.com/blog/2014/10/13/why-threads-cant-fork/">forking processes in a
multi-threaded
environment</a>.</p><p>I also give <a href="https://www.youtube.com/watch?v=DGhlQomeqKc">talks about Unix
software</a> and other topics. And I
turned one talk into a <a href="http://thorstenball.com/blog/2014/11/20/unicorn-unix-magic-tricks/">blog
post</a> which
got super popular and remains my favorite.</p><p>Writing an interpreter from scratch in Go has been one of the most enjoyable
and fun things I ever did as a programmer. So I hope you enjoy this book as
much as I enjoyed writing it.</p><p>If you want to know more about me, you can also visit <a href="http://thorstenball.com">my blog and
website</a>, check out my <a href="https://github.com/mrnugget">GitHub
profile</a> or even better: <a href="https://twitter.com/thorstenball">follow @thorstenball on
Twitter</a>.</p><h4 id="any-questions">Any questions?</h4><p>If you have any questions, send me an email. I promise, you'll make my day. I
love getting email from you: <strong>me @ thorstenball.com</strong></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>