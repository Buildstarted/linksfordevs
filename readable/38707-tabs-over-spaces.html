<!DOCTYPE html>
<html lang="en">
<head>
    <title>
tabs &#x21B9; over &#x2423; &#x2423; &#x2423; spaces -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>tabs &#x21B9; over &#x2423; &#x2423; &#x2423; spaces</h1>
    <div><article> <p>Have you ever looked how anonymous classes are implemented? If you did, you know it&#x2019;s a generated generic class. And if you didn&#x2019;t, you know now. Either way, you can find more details below. But also building on top of [previous post about generic parameters limit in generic classes], where&#x2019;s the limit here? It surely cannot be higher.</p> <h4>Background</h4>
<p>If you create an anonymous class, the compiler creates class for you and it&#x2019;s a generic class where each field is typed using the generic parameter. Take for example this code.</p>
<pre><code class="language-csharp">static object Test()
{
	return new
	{
		Field1 = 10,
		Field2 = 20,
		Field3 = 30,
	};
}
</code></pre>
<p>The compiler generates something like this for you (<code>Equals</code>, <code>GetHashCode</code> and <code>ToString</code> omitted).</p>
<pre><code class="language-csharp">[CompilerGenerated]
internal sealed class &lt;&gt;f__AnonymousType0&lt;&lt;Field1&gt;j__TPar, &lt;Field2&gt;j__TPar, &lt;Field3&gt;j__TPar&gt;
{
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly &lt;Field1&gt;j__TPar &lt;Field1&gt;i__Field;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly &lt;Field2&gt;j__TPar &lt;Field2&gt;i__Field;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly &lt;Field3&gt;j__TPar &lt;Field3&gt;i__Field;

	public &lt;Field1&gt;j__TPar Field1 =&gt; &lt;Field1&gt;i__Field;

	public &lt;Field2&gt;j__TPar Field2 =&gt; &lt;Field2&gt;i__Field;

	public &lt;Field3&gt;j__TPar Field3 =&gt; &lt;Field3&gt;i__Field;

	[DebuggerHidden]
	public &lt;&gt;f__AnonymousType0(&lt;Field1&gt;j__TPar Field1, &lt;Field2&gt;j__TPar Field2, &lt;Field3&gt;j__TPar Field3)
	{
		&lt;Field1&gt;i__Field = Field1;
		&lt;Field2&gt;i__Field = Field2;
		&lt;Field3&gt;i__Field = Field3;
	}
}
</code></pre>
<p>The <code>&lt;Field1&gt;j__TPar</code>, <code>&lt;Field2&gt;j__TPar</code> and <code>&lt;Field3&gt;j__TPar</code> are the generic parameters. Thus, the limits mentioned in <a href="/233802-whats-the-maximum-number-of-generic-parameters-for-a-class-in-net-csharp">previous post</a> apply here, granted it&#x2019;s under the cover.</p>
<p>A small interesting fact. If you create anonymous class with the same field names, the generated class will be reused and the types don&#x2019;t matter thanks to the power of generics. I.e. the code below reuses the above generated class.</p>
<pre><code class="language-csharp">static object Test2()
{
	return new
	{
		Field1 = &quot;&quot;,
		Field2 = 20,
		Field3 = 30,
	};
}
</code></pre>
<p>But not this one.</p>
<pre><code class="language-csharp">static object Test3()
{
	return new
	{
		Field1 = &quot;&quot;,
		Field2 = 20,
		Field33 = 30,
	};
}
</code></pre>
<h4>Limit</h4>
<p>Compared to <a href="/233802-whats-the-maximum-number-of-generic-parameters-for-a-class-in-net-csharp">previous post</a>, it&#x2019;s purely about compiler. If you could somehow generate the code or assembly, well, you would generate exactly what would be needed. Right? With that, let&#x2019;s dive directly into it. <a href="https://i.tabsoverspaces.com/233804/AnonymousClass.cs">Here</a> is a piece of code that returns an anonymous class with 65535 fields. That should be right on the edge. But trying to compile that file with <code>csc.exe</code> version <code>3.300.119.46102</code> aka .NET Core 3.0 fails with error <code>CS8078: An expression is too long or complex to compile</code> (after significant amount of time). That&#x2019;s not much information to work with. Luckily <a href="https://github.com/dotnet/roslyn/blob/41548da4df58e5cab883111567160a70827a01cf/src/Compilers/CSharp/Portable/Errors/ErrorCode.cs#L1311">looking into <code>ErrorCode.cs</code></a> shows that the &#x201C;name&#x201D; for this error code is <code>ERR_InsufficientStack</code>. Probably something in Roslyn is using recursion and this goes too deep. Bummer. Let&#x2019;s try &#x201C;only&#x201D; 4000 fields (4000 for no particular reason). OK, that works. And in fact, it&#x2019;s quite fast. What now?</p>
<p>Let&#x2019;s take a reasonable approach. Although you can create a code with anonymous class that fails to compile, it&#x2019;s beyond what one would write. Fair, isn&#x2019;t it? Also, it&#x2019;s important to understand that the limit is very fragile, because even a small change in Roslyn&#x2019;s code can change how stack space is consumed (both negatively and positively) and hence at what point it will stop working. You don&#x2019;t want to hover around it.</p>
<p>Now let&#x2019;s take unreasonable approach. Can I push it somehow? And the answer is, I can. Unless Roslyn sets the stack size explicitly, I can change the default stack size in PE header and hope for the best. In the spirit of <em>balls to the wall</em> I used <code>editbin /stack</code> and set the stack to 400MB (in case you&#x2019;d like to run it yourself, <a href="https://i.tabsoverspaces.com/233804/csc.exe">here is the binary</a>). For the record, 1MB is default stack size on Windows. Cue the dramatic music&#x2026; Nope. Although indeed Roslyn uses default stack sizes, thus the bigger stack was active, it failed at different point later and even harder via <code>FailFast</code>.</p>
<pre><code class="language-text">Message: System.InvalidOperationException: Sequence contains no elements
   at System.Linq.Enumerable.First[TSource](IEnumerable`1 source)
   at System.Linq.ImmutableArrayExtensions.First[T](ImmutableArray`1 immutableArray)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(PEModuleBuilder moduleBuilder, MethodSymbol method, Int32 methodOrdinal, BoundStatement block, ImmutableArray`1 lambdaDebugInfo, ImmutableArray`1 closureDebugInfo, StateMachineTypeSymbol stateMachineTypeOpt, VariableSlotAllocator variableSlotAllocatorOpt, DiagnosticBag diagnostics, DebugDocumentProvider debugDocumentProvider, ImportChain importChainOpt, Boolean emittingPdb, Boolean emitTestCoverageData, ImmutableArray`1 dynamicAnalysisSpans, AsyncForwardEntryPoint entryPointOpt)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedMethods(TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass22_0.&lt;CompileNamedTypeAsTask&gt;b__0()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass22_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at System.Linq.Enumerable.First[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.IEnumerable`1&lt;System.__Canon&gt;)
   at System.Linq.ImmutableArrayExtensions.First[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Immutable.ImmutableArray`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, Microsoft.CodeAnalysis.CSharp.BoundStatement, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt;, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt;, Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol, Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider, Microsoft.CodeAnalysis.CSharp.ImportChain, Boolean, Boolean, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.CodeGen.SourceSpan&gt;, AsyncForwardEntryPoint)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedMethods(Microsoft.CodeAnalysis.CSharp.TypeCompilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass22_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities+&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
</code></pre>
<p>At this time, instead of wasting time (I could instead do some PRs on Roslyn optimizing the stack consumption, right? &#x1F609;), I decided to try where it fails in this setup. Surprisingly it failed right after nice &#x201C;computer-ish&#x201D; number of 32767 fields. Result! If you&#x2019;d like to explore the resulting assembly, <a href="https://i.tabsoverspaces.com/233804/32767.7z">here it is</a>.</p>
<h4>Closing</h4>
<p>What we can take from this exercise? First, don&#x2019;t write crazy shit. Compilers, although written by smart people, play on the same field as all of us. Then, unbounded recursion might kill your application (sometimes <a href="https://en.wikipedia.org/wiki/Tail_call">tail-call optimization</a> can save you), because stack is limited. Think about edge cases and when or if these will be hit.</p> </article><article> <p class="bio"> <a href="/about"><img src="/assets/bio_image.png" alt="Profile Picture"></a> Ji&#x159;&#xED; &#x10C;in&#x10D;ura is an independent developer focusing on data and business layers, language constructs, parallelism and databases. Specifically Entity Framework, asynchronous and parallel programming, cloud and Azure. He&apos;s Microsoft Most Valuable Professional and you can read his articles, guides, tips and tricks at www.tabsoverspaces.com. </p> </article></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>