<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Hiding messages in x86 binaries using semantic duals - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Hiding messages in x86 binaries using semantic duals - linksfor.dev(s)"/>
    <meta property="og:description" content="Tags:&#xA;  &#xA;    &#xA;    rust,&#xA;    &#xA;  &#xA;    &#xA;    devblog,&#xA;    &#xA;  &#xA;    &#xA;    programming"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.yossarian.net/2020/08/16/Hiding-messages-in-x86-binaries-using-semantic-duals"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Hiding messages in x86 binaries using semantic duals</title>
<div class="readable">
        <h1>Hiding messages in x86 binaries using semantic duals</h1>
            <div>Reading time: 9-11 minutes</div>
        <div>Posted here: 17 Aug 2020</div>
        <p><a href="https://blog.yossarian.net/2020/08/16/Hiding-messages-in-x86-binaries-using-semantic-duals">https://blog.yossarian.net/2020/08/16/Hiding-messages-in-x86-binaries-using-semantic-duals</a></p>
        <hr/>
<div id="readability-page-1" class="page">


<h2><em>Programming, philosophy, pedaling.</em></h2>

<ul>
    <li><a href="https://blog.yossarian.net/">Home</a></li>
    <li><a href="https://blog.yossarian.net/tags">Tags</a></li>
    <li><a href="https://blog.yossarian.net/favorites">Favorites</a></li>
    <li><a href="https://blog.yossarian.net/archive">Archive</a></li>
    
      <li><a href="https://yossarian.net/">Main Site</a></li>
    
</ul>

<hr>



<h2>
  <em>Aug 16, 2020</em>
</h2>

  <p>Tags:
  
    
    <a href="https://blog.yossarian.net/tags#rust">rust</a>,
    
  
    
    <a href="https://blog.yossarian.net/tags#devblog">devblog</a>,
    
  
    
    <a href="https://blog.yossarian.net/tags#programming">programming</a>
    
  
  </p>


<p>This is a quick writeup of a <a href="https://en.wikipedia.org/wiki/Steganography">steganographic</a> tool
that I threw together: <a href="https://github.com/woodruffw/steg86"><em>steg86</em></a>. It uses a quirk of the
x86 instruction encoding format to hide messages in pre-existing binaries with no size or
performance overhead.</p>

<p>You can play with it yourself by fetching it with <code>cargo</code>:</p>

<div><div><pre><code><span>$ </span>cargo <span>install </span>steg86
<span>$ </span>steg86 <span>--help</span>
</code></pre></div></div>

<h2 id="a-quick-steganography-refresher">A quick steganography refresher</h2>

<p>Steganography is the practice of concealing data within other data. A variety of different
common formats open themselves up to steganographic channels:</p>

<ul>
  <li>Image formats: using the least significant bits of the color space</li>
  <li>Audio formats: hiding information in background noise, or hiding an image
in the <a href="https://en.wikipedia.org/wiki/Spectrogram">spectrogram</a></li>
  <li>Plain text: using <a href="https://en.wikipedia.org/wiki/IDN_homograph_attack">homographs</a> and
<a href="https://en.wikipedia.org/wiki/Zero-width_joiner">special spacing characters</a> to encode information</li>
</ul>

<p>On its own, steganography is <em>not</em> a replacement for cryptography: it’s strictly
obfuscatory, and does not provide any deniablity of the embedded message if revealed.</p>

<p>That being said, there exist a variety of use cases for steganographic schemes:</p>

<ul>
  <li>Coupled with strong cryptography, they <em>do</em> allow for deniability: depending on the format,
an extracted message can be made indistinguishable from random noise prior to decryption.</li>
  <li>Steganography can be used for fingerprinting and asset management.
<a href="https://en.wikipedia.org/wiki/Machine_Identification_Code">Commercial printers</a> are well-known for doing this;
video games have also used it to <a href="https://www.schneier.com/blog/archives/2012/09/steganography_i_1.html">track users and their machines</a>.</li>
</ul>

<h2 id="doing-steganography-on-computer-programs">Doing steganography on computer programs</h2>

<p>There are two obvious avenues for doing steganography on compiled programs. <em>steg86</em> does
<strong>neither</strong> of these, but for the sake of completeness:</p>

<h3 id="instrumenting-the-program-via-the-compiler">Instrumenting the program via the compiler</h3>

<p>Compilers perform instruction selection to lower their internal representations into machine code.
Instruction selection can be informed by any number of weights, including
<a href="https://en.wikipedia.org/wiki/Register_allocation">register pressure</a>, individual instruction
performance (clock cycles, use of shared units), and feature availability
(e.g., selecting an older version of <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a>
to be compatible with more CPUs).</p>

<p>In this approach, the steganographer would control the compiler and its instruction selection
weights, encoding information in particular selections of instructions (or other parts of
code generation, like stack object order).</p>

<p>This affords a great deal of flexibility and control, but also makes it more difficult for the
compiler to perform optimal selections. It also requires the steganographer to maintain
their (forked) compiler. Not a bad idea, but requires a decent amount of effort.</p>

<h3 id="instrumenting-the-container-format">Instrumenting the container format</h3>

<p>Another approach is to ignore the compiled instructions themselves, and focus on the binary
container: <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a>,
<a href="https://en.wikipedia.org/wiki/Mach-O">Mach-O</a>, or
<a href="https://en.wikipedia.org/wiki/Portable_Executable">PE</a>, among others.</p>

<p>These formats afford many opportunities for embedding information: the order
(both file and virtual address) of segments and sections, the order and layout
of <a href="https://en.wikipedia.org/wiki/Relocation_(computing)">relocation tables</a> and the composition of
their internal rules, and so on.</p>

<p>Instrumenting the binary format rather than the executable code means not having
to muck with instruction selection, but is also less bountiful in terms of
information density. It’s also not portable, e.g. tricks for hiding information
in ELF relocation entries would have to be tweaked for PEs.</p>

<h2 id="how-steg86-works">How <em>steg86</em> works</h2>

<p>Instead of controlling instruction selection or tweaking the details of the containing binary
format, <em>steg86</em> takes a third route: it uses the presence of <em>semantic duals</em> in the x86 and AMD64
instruction formats to selectively rewrite a program <em>after</em> compilation.</p>

<h3 id="semantic-duals">Semantic duals</h3>

<p>Like every ISA, x86 (and AMD64) have multiple ways to encode the semantics of a particular
(higher level, conceptual) operation. For example, clearing a register:</p>

<div><div><pre><code><span>; xor'ing a register with itself clears all bits</span>
<span>xor</span> <span>eax</span><span>,</span> <span>eax</span>

<span>; and'ing a register with 0 also clears all bits</span>
<span>and</span> <span>eax</span><span>,</span> <span>0</span>

<span>; we could also set 0</span>
<span>mov</span> <span>eax</span><span>,</span> <span>0</span>

<span>; ...or subtract</span>
<span>sub</span> <span>eax</span><span>,</span> <span>eax</span>

<span>; ...or load a "computed" address that's always 0</span>
<span>lea</span> <span>eax</span><span>,</span> <span>[</span><span>0</span><span>]</span>
</code></pre></div></div>

<p>…among many others. Unfortunately, this doesn’t work exactly as we’d like:</p>

<ul>
  <li>Each of these alternatives may have a different length when encoded, e.g. 2 bytes for
<code>xor eax, eax</code> versus 6 for <code>lea eax, [0]</code>. Consequently, rewriting one in terms of another
might entail a length change and subsequent relocation and displacement fixups.</li>
  <li>Each of these alternatives has subtle microarchitectural differences: they set and clear
different arithmetic flags, have different implicit segmentation behavior, and so on.
We don’t know perfectly whether the original operations took advantage of those details,
so many of our potential alternatives run the risk of subtle breakage.</li>
</ul>

<p>Fortunately, this is <strong>not</strong> what <em>steg86</em> does.</p>

<p>Instead, <em>steg86</em> takes advantage of one of the quirks of the x86 instruction encoding: the ModR/M
byte:</p>

<p><img src="https://blog.yossarian.net/assets/modrm.png" alt="The ModR/M byte."></p>

<p>The ModR/M byte is normally used to encode one or more explicit register and/or memory operands
to an opcode<sup id="fnref:1" role="doc-noteref"><a href="#fn:1">1</a></sup>: it’s how x86 can supply the rich range of source-to-sink modes that it has
(register-to-memory, memory-to-register, register-to-register, immediate-to-register, &amp;c).</p>

<p>Because register-to-memory and memory-to-register are both valid source-sink combinations for
many opcodes, many have encoding forms like the following:</p>

<div><div><pre><code><span>; xor register with register/memory32 and store register/memory32</span>
<span>xor</span> <span>r</span><span>/</span><span>m32</span><span>,</span> <span>r32</span>

<span>; xor register/memory32 with register and store register</span>
<span>xor</span> <span>r32</span><span>,</span> <span>r</span><span>/</span><span>m32</span>
</code></pre></div></div>

<p>Consequently, there are actually <strong>two</strong> ways to encode <code>xor eax, eax</code>:</p>

<div><div><pre><code>; r/m32, r
31 C0

; r, r/m32
33 C0
</code></pre></div></div>

<p>These encodings are <em>semantic duals</em>: they have different opcodes, but belong to the same
instruction family, have the same length, and have the <em>exact same behavior and performance</em>.
We could replace every occurrence of <code>31 C0</code> with <code>33 C0</code> and our programs would happily chug along,
none the wiser.</p>

<p>As it turns out, there are actually quite a few of these duals on some of the most common
x86 instructions<sup id="fnref:2" role="doc-noteref"><a href="#fn:2">2</a></sup>:</p>

<div><div><pre><code>ADD r/m8, r8   &lt;=&gt; ADD r8, r/m8
ADD r/m16, r16 &lt;=&gt; ADD r16, r/m16
ADD r/m32, r32 &lt;=&gt; ADD r32, r/m32
ADD r/m64, r64 &lt;=&gt; ADD r64, r/m64

ADC r/m8, r8   &lt;=&gt; ADC r8, r/m8
ADC r/m16, r16 &lt;=&gt; ADC r16, r/m16
ADC r/m32, r32 &lt;=&gt; ADC r32, r/m32
ADC r/m64, r64 &lt;=&gt; ADC r64, r/m64

AND r/m8, r8   &lt;=&gt; AND r8, r/m8
AND r/m16, r16 &lt;=&gt; AND r16, r/m16
AND r/m32, r32 &lt;=&gt; AND r32, r/m32
AND r/m64, r64 &lt;=&gt; AND r64, r/m64

OR r/m8, r8    &lt;=&gt; OR r8, r/m8
OR r/m16, r16  &lt;=&gt; OR r16, r/m16
OR r/m32, r32  &lt;=&gt; OR r32, r/m32
OR r/m64, r64  &lt;=&gt; OR r64, r/m64

XOR r/m8, r8   &lt;=&gt; XOR r8, r/m8
XOR r/m16, r16 &lt;=&gt; XOR r16, r/m16
XOR r/m32, r32 &lt;=&gt; XOR r32, r/m32
XOR r/m64, r64 &lt;=&gt; XOR r64, r/m64

SUB r/m8, r8   &lt;=&gt; SUB r8, r/m8
SUB r/m16, r16 &lt;=&gt; SUB r16, r/m16
SUB r/m32, r32 &lt;=&gt; SUB r32, r/m32
SUB r/m64, r64 &lt;=&gt; SUB r64, r/m64

SBB r/m8, r8   &lt;=&gt; SBB r8, r/m8
SBB r/m16, r16 &lt;=&gt; SBB r16, r/m16
SBB r/m32, r32 &lt;=&gt; SBB r32, r/m32
SBB r/m64, r64 &lt;=&gt; SBB r64, r/m64

MOV r/m8, r8   &lt;=&gt; MOV r8, r/m8
MOV r/m16, r16 &lt;=&gt; MOV r16, r/m16
MOV r/m32, r32 &lt;=&gt; MOV r32, r/m32
MOV r/m64, r64 &lt;=&gt; MOV r64, r/m64

CMP r/m8, r8   &lt;=&gt; CMP r8, r/m8
CMP r/m16, r16 &lt;=&gt; CMP r16, r/m16
CMP r/m32, r32 &lt;=&gt; CMP r32, r/m32
CMP r/m64, r64 &lt;=&gt; CMP r64, r/m64
</code></pre></div></div>

<p>Each dual represents one bit of information: we can arbitrarily assign one form
to be <code>true</code> and its counterpart to be <code>false</code>. Given enough of them in a target
program, we can hide a message by translating between the forms. The result:
a binary that’s exactly the same size as the original and with the same performance
characteristics, but with a hidden message.</p>

<p>That’s all <em>steg86</em> does: it locates every semantic dual in its target program, maps
its input message to a bitstring, and translates each dual depending on its corresponding
message bit. Because it only uses duals, it’s completely agnostic to its containing format:
the <code>steg86</code> CLI currently supports ELF, Mach-O, and PE/PE32+ binaries.</p>

<p>Here’s what that actually looks like, with (some of the) differing bytes highlighted in red:</p>

<p><img src="https://blog.yossarian.net/assets/steg86_vbindiff.png" alt="vbindiff between bash and steg'd bash"></p>

<p>And, of course, try it for yourself:</p>

<div><div><pre><code><span>$ </span>steg86 profile /bin/bash
Summary <span>for</span> /bin/bash:
  175828 total instructions
  27957 potential semantic pairs
  27925 bits of information capacity <span>(</span>3490 bytes, approx. 3KB<span>)</span>

<span>$ </span>steg86 embed /bin/bash test.steg <span>&lt;&lt;&lt;</span> <span>"hello world!"</span>
<span>$ </span>file test.steg
test.steg: ELF 64-bit LSB shared object, x86-64, version 1 <span>(</span>SYSV<span>)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]<span>=</span>a6cb40078351e05121d46daa768e271846d5cc54, <span>for </span>GNU/Linux 3.2.0, stripped

<span>$ </span>steg86 extract test.steg
hello world!
</code></pre></div></div>

<p>See the <a href="https://github.com/woodruffw/steg86/blob/master/README.md">README</a> for prior work and
future refinements to <em>steg86</em>’s informational capacity.</p>

<p><strong>Edit</strong>: An important note: because compilers and assemblers tend to select just one of the forms
above, <em>steg86</em> <strong>cannot</strong> provide deniability, even with strong encryption. Its transformations
will always look abnormal compared to a compiler-produced binary.</p>

<hr>




<hr>




  






</div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>