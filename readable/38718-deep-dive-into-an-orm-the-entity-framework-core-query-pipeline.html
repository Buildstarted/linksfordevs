<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Deep Dive into an ORM: The Entity Framework Core Query Pipeline -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Deep Dive into an ORM: The Entity Framework Core Query Pipeline</h1>
    <div class="reveal"> <p class="slides"> <section> <p><img src="ef-unicorn.png" alt="EF Title Logo"></p>
<p>Deep Dive into an ORM:</p>
<p>The Entity Framework Core Query Pipeline</p> </section> <section> <ul>
<li>Shay Rojansky</li>
<li>Engineer at Microsoft, part of the Entity Framework/Data team</li>
<li>Lead dev of Npgsql
<ul>
<li>.NET driver for PostgreSQL</li>
<li>PG provider for Entity Framework Core</li>
</ul>
</li>
<li>Linux guy</li>
<li>Based in Berlin</li>
</ul> </section> <section> <section> <ul>
<li class="fragment">Not a talk about low-level intrinsics/GC/JIT/assembly</li>
<li class="fragment">Not a talk about EF Core 3.0 new features</li>
<li class="fragment">Deep dive into how an ORM works</li>
<li class="fragment">Lots of architecture (and performance!)</li>
</ul>
<aside class="notes">
A lot of this talk is not immediately useful. Will call out when it is.
</aside> </section> <section> <ul>
<li>Without ORMs, devs have to:
<ul>
<li>Write SQL (without compile-time verification)</li>
<li>Serialize/deserialize results (materialization)</li>
</ul>
</li>
</ul> </section> <section> <ul>
<li>C# is unique because it has LINQ</li>
<li class="fragment">ORMs in other languages define their own operator functions</li>
<li class="fragment">However: LINQ can express far more than what is translatable to SQL</li>
</ul>
<aside class="notes">
LINQ can express not just untranslatable things, but things that translate poorly (perf)
</aside> </section> <section> <ul>
<li>We had LINQ to SQL, EF6&#x2026;</li>
<li class="fragment">EF Core 3.0 just released
<ul>
<li>Query pipeline got rewritten</li>
</ul>
</li>
<li class="fragment">Unique: not just for relational databases (SQL)</li>
</ul>
<aside class="notes">
Retro talk, we stand on the shoulders of giants.
Joke about Matt Warren.
</aside> </section> <section> </section> <section> <pre><code class="language-csharp">Func&lt;int, bool&gt; comparer = num =&gt; num &lt; 5;
</code></pre>
<div class="fragment">
<pre><code>Expression&lt;Func&lt;int, bool&gt;&gt; comparerExpression = num =&gt; num &lt; 5;
Func<int,> compiled = comparerExpression.Compile();
</int,></code></pre>
</div>
<pre class="fragment"><code>var numParam = Expression.Parameter(typeof(int), &quot;num&quot;);

Expression&lt;Func&lt;int, bool&gt;&gt; comparerExpression2 =
    Expression.Lambda&lt;Func&lt;int, bool&gt;&gt;(
        Expression.LessThan(
            numParam,
            Expression.Constant(5)),
        numParam);

var compiled2 = comparerExpression2.Compile();
</code></pre>
<img class="fragment" src="diagrams/basic-expression-tree.svg"> </section> <section> <ul>
<li>Great solution for code generation</li>
<li>Generate specific, tailored lambdas based on config/user input</li>
<li>Compiled delegates run (almost) as fast as if they were written by hand</li>
</ul>
<aside class="notes">
This is one of the few things usable at home.
</aside> </section> <section> <p class="fragment"><strong>Roslyn</strong> - high-level source representation</p>
<p class="fragment"><strong>T4</strong> - source representation with templates</p>
<p class="fragment"><strong>Expression trees</strong></p>
<p class="fragment"><strong>Reflection.Emit</strong> - low-level IL</p> </section> <section> <ul>
<li>Up to now we compiled expression trees to IL for execution</li>
<li>IQueryable allows building providers which execute trees in other ways</li>
<li class="fragment">ORMs: take the expression tree, convert it to SQL, send it to DB and materialize the results</li>
</ul> </section> </section> <section> <section> <aside class="notes">SQL shown is not real EF-generated SQL</aside> </section> <section> <p>Let&#x2019;s translate this:</p>
<pre><code class="language-csharp">employees.Where(c =&gt; c.FirstName == c.LastName)
</code></pre>
<div class="fragment">
To this, right?
<pre><code>SELECT ... FROM Employees WHERE FirstName = LastName</code></pre>
</div>
<p class="fragment"><strong>Could be wrong, SQL has three-valued logic</strong></p>
<p><span class="fragment">In SQL, FirstName = NULL is never true&#x2026; </span>
<span class="fragment">(and it ain&#x2019;t false either :))</span></p>
<aside class="notes">
Major major!
</aside> </section> <section> <p>Try to mimic C# behavior (best-effort only!)</p>
<div class="fragment">
<pre><code>WHERE FirstName = LastName OR
  (FirstName IS NULL AND LastName IS NULL)
</code></pre>
<p class="fragment">If one of the columns is non-nullable in the database schema, we can optimize</p>
<p class="fragment">Counter-example: case-sensitivity</p>
<aside class="notes">
Perf/hacks, align to natural database behavior.
</aside> </div></section> <section> <p>Let&#x2019;s get complicated:</p>
<pre><code class="language-csharp">employees.Where(e =&gt; e.Tasks.Count == 2)
</code></pre>
<div class="fragment">
<pre><code class="sql">SELECT ...
FROM Employees AS e
WHERE (
    SELECT COUNT(*)
    FROM Tasks AS t
    WHERE t.EmployeeId = e.Id
) = 2;
</code></pre>
</div> </section> <section> <p>What about this?</p>
<pre><code class="language-c#">employees.Where(e =&gt; e == e.Boss)
</code></pre>
<div class="fragment">
We need to compare keys:
<pre><code class="sql">WHERE e.Id = Boss.Id</code></pre>
</div>
<div class="fragment">
The same happens if instead of a Boss we have a subquery:
<pre><code class="csharp">employees.Where(e =&gt; e.Tasks.First() == x)

WHERE (SELECT ... FROM Tasks ...).Id1 = x.Id1
</code></pre>
</div>
<aside class="notes">
Contains (check that a subordinate is my boss)
OrderBy.
</aside>
<aside class="notes">
C#: reference identity (although can be overridden, mismatch).
<p>Explain the word entity</p>
</aside> </section> <section> <p>Now, what happens if something has a composite key?</p>
<div class="fragment">
<pre><code class="sql">WHERE Id1 = Boss.Id1 AND Id2 = Boss.Id2</code></pre>
</div>
<div class="fragment">
And with a subquery?
<pre><code class="csharp">employees.Where(e =&gt; e.Tasks.First() == x)</code></pre>
</div>
<div class="fragment">
<pre><code class="sql">WHERE (SELECT ...).Id1 = x.Id1 AND (SELECT ...).Id2 = x.Id2</code></pre>
</div>
<p><span class="fragment"><strong>Double evaluation&#x2026; Better not do this!</strong></span></p> </section> <section> <p>In C#, &#x201C;related instances&#x201D; are just there in memory.</p>
<div class="fragment">
With DB, we need to fetch only what&apos;s needed:
<pre><code>employees.Include(b =&gt; b.Tasks)</code></pre>
</div>
<div class="fragment">
<pre><code>SELECT ...
FROM Employees AS e
LEFT JOIN Tasks AS t ON e.Id = t.EmployeeId
ORDER BY e.Id, t.Id
</code></pre>
</div>
<ul>
<li class="fragment">Previous versions of EF Core translated this with multiple queries
<ul>
<li>Multiple roundtrips vs. &#x201C;cartesian explosion&#x201D;</li>
<li>Transactionality</li>
</ul>
</li>
</ul>
<aside class="notes">
Manual ways to split apart the query to multiple ones.
</aside> </section> <section> <p>What to do about this?</p>
<pre><code class="language-c#">employees.Where(e =&gt; SomeFunc(e))
</code></pre>
<p class="fragment">Previous versions: translate to server if we can, otherwise evaluate on client</p>
<ul>
<li class="fragment">Can bring <em>lots</em> of data to client</li>
<li class="fragment">Adding a new translation can break behavior</li>
</ul>
<p class="fragment">EF Core 3 throws, except for top-most projection</p>
<aside class="notes">
Not just about functions, other expression types
</aside> </section> <section> <ul>
<li>There are many, many mismatches between C# LINQ and SQL</li>
<li class="fragment">ORMs need to make decisions about how to translate</li>
<li class="fragment">We need to do many things to expression trees before they can be converted</li>
</ul> </section> </section> <section> <section> </section> <section> <ul>
<li>Input: LINQ expression tree (from IQueryable)</li>
<li>Outputs (for relational)?
<ul>
<li class="fragment">SQL</li>
<li class="fragment">Shaper / materializer, to read results (DbDataReader)</li>
</ul>
</li>
<li class="fragment">We are building a compiler!</li>
</ul> </section> <section> <ul>
<li class="fragment">The query engine is architected as a pipeline of <strong>visitors</strong></li>
<li class="fragment">Each visitor traverses the expression tree, responsible for doing one thing </li>
</ul>
<aside class="notes">
Break down a complex task into separate components, a bit like functions.
</aside> </section> <section> <ul>
<li>For example, the instance equality visitor:
<ul>
<li class="fragment">Traverses the entire tree</li>
<li class="fragment">Identifies equality expression over instances</li>
<li class="fragment">Replaces with equality over their keys</li>
</ul>
</li>
</ul> </section> <section> <p><strong>Exercise</strong>: optimize an expression tree, eliminating needless null checks on non-nullable database columns:</p>
<pre><code class="language-csharp">// INPUT:
customers.Where(c =&gt; c.Age &gt; 18 &amp;&amp; c.Name != null)

// OUTPUT:
customers.Where(c =&gt; c.Age &gt; 18)
</code></pre> </section> <section> <pre>
<code>class MyVisitor1 : ExpressionVisitor
{
    protected override Expression VisitBinary(BinaryExpression b)
    {
        var visited = (BinaryExpression)base.VisitBinary(b);

        if (b.NodeType == ExpressionType.NotEqual)
        {
            if (b.Right is ConstantExpression rightConstant &amp;&amp;
                rightConstant.Value == null &amp;&amp;
                !IsNullable(b.Left))
            {
                return Expression.Constant(true);
            }
            // TODO: Sides may be flipped!
        }

        return visited;
    }
}
</code></pre>
<pre class="fragment">
<code>customers.Where(c =&gt; c.Age &gt; 18 &amp;&amp; true)
</code></pre> </section> <section> <pre>
<code>class MyVisitor2 : ExpressionVisitor
{
    protected override Expression VisitBinary(BinaryExpression b)
    {
        var visited = (BinaryExpression)base.VisitBinary(b);

        if (b.NodeType == ExpressionType.AndAlso)
        {
            if (b.Right is ConstantExpression rightConstant &amp;&amp;
                rightConstant.Value is bool boolValue &amp;&amp;
                boolValue)
            {
                return b.Left;
            }
            // TODO: Same for other side!
        }
        // TODO: Also take care of OrElse!

        return visited;
    }
}
</code></pre>
<pre class="fragment">
<code>customers.Where(c =&gt; c.Age &gt; 18)
</code></pre> </section> <section> <p>From this:</p>
<pre><code>customers.Where(c =&gt; c.Age &gt; 18 &amp;&amp; c.Name != null)</code></pre>
<div class="fragment">
To this:
<pre><code>customers.Where(c =&gt; c.Age &gt; 18 &amp;&amp; true)</code></pre>
</div>
<div class="fragment">
To this:
<pre><code>customers.Where(c =&gt; c.Age &gt; 18)</code></pre>
</div> </section> <section> <pre>
<code>public virtual Expression Process(Expression query)
{
    query = new EnumerableToQueryableMethodConvertingExpressionVisitor().Visit(query);
    query = new QueryMetadataExtractingExpressionVisitor(_queryCompilationContext).Visit(query);
    query = new AllAnyToContainsRewritingExpressionVisitor().Visit(query);
    query = new GroupJoinFlatteningExpressionVisitor().Visit(query);
    query = new NullCheckRemovingExpressionVisitor().Visit(query);
    query = new EntityEqualityRewritingExpressionVisitor(_queryCompilationContext).Rewrite(query);
    query = new SubqueryMemberPushdownExpressionVisitor().Visit(query);
    query = new NavigationExpandingExpressionVisitor(...).Expand(query);
    query = new FunctionPreprocessingExpressionVisitor().Visit(query);
    new EnumerableVerifyingExpressionVisitor().Visit(query);

    return query;
}
</code></pre>
<img src="diagrams/visitor-chain.svg" class="fragment">
<aside class="notes">
The last one is a verifying visitor, no meaningful return value.
</aside> </section> <section> <ul>
<li>We&#x2019;ve been talking about LINQ methods, but&#x2026; at some point we want a model of an SQL query.</li>
<li>Instead of CLR types, methods and members, we want tables and columns.</li>
</ul> </section> <section> <pre>
<code>customers
   .Where(c =&gt; c.Name == &quot;Joe&quot;)
   .OrderBy(c =&gt; c.Age)
   .Take(5)
   .Select(c =&gt; new { c.Name, c.Age });
</code></pre>
<img src="diagrams/csharp-expression-tree.svg" class="fragment">
<div class="fragment">
<img src="diagrams/sql-expression-tree.svg">
<pre>
<code>SELECT Name, Age FROM Customers
WHERE Age &gt; 18
ORDER BY Age
LIMIT 10
</code></pre>
</div>
<aside class="notes">
SelectExpression has tables which have columns. All these are references.
</aside> </section> <section> <p>Still expressions, but now custom SQL ones!</p>
<pre><code class="language-c#">customers.Where(c =&gt; new[] { 1, 2, 3 }.Contains(c.Id));

// Becomes:
WHERE c.ID IN (1, 2, 3) // This is an SqlInExpression
</code></pre>
<p class="fragment">Expression trees can have custom expression types</p>
<p class="fragment">Non-relational providers will do something completely different</p> </section> <section> <pre><code class="language-csharp">customers.Where(c =&gt; c.Name.Length &gt; 5)

// Becomes:
WHERE LEN(c.Name) &gt; 5    // On SqlServer
WHERE LENGTH(c.Name) &gt; 5 // On PostgreSQL
</code></pre>
<p class="fragment">Users can define functions which render into arbitrary SQL expressions</p> </section> <section> <ul>
<li>Some more postprocessing after SQL translation</li>
<li class="fragment">QuerySqlGenerator is just another visitor, outputs an SQL string</li>
<li class="fragment">Another visitor code-generates the shaper</li>
</ul>
<p class="fragment">(&#x2026;with&#x2026; expression trees&#x2026;)</p> </section> <section> <p><img src="diagrams/pipeline.svg" alt="Query Pipeline"></p> </section> </section> <section> <section> </section> <section> <pre><code class="language-csharp">var posts1 = ctx.Posts.Where(p =&gt; p.Title.Contains(&quot;dotnetos&quot;));

var title = &quot;dotnetos&quot;;  // Read from somewhere
var posts2 = ctx.Posts.Where(p =&gt; p.Title.Contains(title));
</code></pre>
<div class="fragment">
<pre><code>SELECT ... FROM Posts WHERE STRPOS(&apos;dotnetos&apos;) &gt; 0;</code></pre>
<pre><code>SELECT ... FROM Posts WHERE STRPOS(@p) &gt; 0;</code></pre>
</div>
<ul>
<li class="fragment">Can leverage cached plans and prepared queries</li>
<li class="fragment">Closure variables are your way of asking for parameterization</li>
</ul>
<aside class="notes">
Guy generating trees with constant every time
</aside> </section> <section> <ul>
<li>No way we run all these visitors each time</li>
<li class="fragment">The answer is always, always&#x2026; caching.</li>
<li class="fragment"><strong>Input</strong>: expression tree. <strong>Outputs</strong>: SQL+shaper.</li>
</ul> </section> <section> <p>We can just do recursive structural comparison:</p>
<pre><code class="language-csharp">var posts = ctx.Posts.Where(p =&gt; p.Title.Contains(&quot;dotnetos&quot;));
</code></pre>
<div>
<img src="diagrams/csharp-expression-tree2.svg">
</div>
<div class="fragment">
<img src="diagrams/csharp-expression-tree2.svg">
</div>
<aside class="notes">
* Literal/constant: &quot;dotnetos&quot; will get embedded in the SQL.
* Mention hash code computation, then equality. SLOW (but later compiled queries)
</aside> </section> <section> <pre><code class="language-csharp">var title = &quot;dotnetos&quot;;  // Read from somewhere
var posts2 = ctx.Posts.Where(p =&gt; p.Title.Contains(title));
</code></pre>
<ul>
<li>Before checking the cache, identify parameter references (to closure variables)</li>
<li class="fragment">Extract them out and replace them with placeholders, &#x201C;punching holes in the tree&#x201D;</li>
</ul> </section> <section> <p><img src="diagrams/pipeline-full.svg" alt="Full pipeline"></p>
<div class="fragment">
Cool! However, for each query, we still do:
<ul>
<li>Parameter extraction</li>
<li>Cache key hashcode calculation</li>
<li>Structural comparison with trees in the query cache</li>
</ul>
</div>
<aside class="notes">
Pretty cool, compilation isn&apos;t perf sensitive and we can concentrate on a good clean design.
</aside> </section> <section> <pre><code class="language-csharp">using (var ctx = new MyContext())
{
    var id = 8;
    var posts = ctx.Posts.Single(p =&gt; p.Id == id);
}
</code></pre>
<pre class="fragment"><code>
// Create an explicitly compiled query
private static Func&lt;MyContext, int, Post&gt; _postById
    = EF.CompileQuery((MyContext ctx, int id) =&gt;
        ctx.Posts.Single(p =&gt; p.Id == id));

// Use the compiled query by invoking it
using (var ctx = new MyContext())
{
   var post = _postById(ctx, 8);
}
</code></pre> </section> <section> <p>Remember our InExpression from before?</p>
<pre><code class="language-csharp">customers.Where(c =&gt; new[] { 1, 2, 3 }.Contains(c.Id));

WHERE c.Id IN (1, 2, 3)
</code></pre>
<div class="fragment">
How do we parameterize this?
<pre><code>var customerIds = new[] { 1, 2, 3 };
customers.Where(c =&gt; customerIds.Contains(c.Id));
</code></pre>
</div> </section> <section> <p>Expand to constant <strong>at execution time</strong>:</p>
<pre><code class="language-csharp">var values = new[] { 1, 2, 3 };
ctx.Posts.Where(p =&gt; values.Contains(p.Foo));

WHERE p.Foo IN (1, 2, 3)
</code></pre>
<ul>
<li>Pollutes database query cache</li>
<li class="fragment">PostgreSQL has <code>WHERE p.Foo = ANY (@p)</code></li>
</ul>
<aside class="notes">
Main point: provider extensibility, dependency injection
</aside> </section> </section> <section> <ul>
<li>Writing an ORM is&#x2026; complex :)</li>
<li class="fragment">Being aware of what happens under the hood is always important.</li>
<li class="fragment">Check the SQL being generated!</li>
</ul> </section> <section> <p><strong>Smit Patel</strong></p>
<p>(new query pipeline architect)</p>
<p><strong>Maurycy Markowski</strong></p>
<p>(big query guy and also a Polish guy!)</p>
<p><strong>And of course &#x2026; the rest of the EF team</strong></p> </section> <section> <p><strong>Shay Rojansky</strong></p>
<p>Blog &amp; Presentation: <a href="http://roji.org">http://roji.org</a></p>
<p>Twitter: @shayrojansky</p> </section> </p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>