<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How to port desktop applications to .NET Core 3.0 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>How to port desktop applications to .NET Core 3.0</h1><div><div class="entry-content col-12 sharepostcontent"><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2018/10/Olia-Gavrysh-e1538680748374-150x150.jpg" width="58" height="58" alt="Olia Gavrysh" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 alignnone photo"><p>Olia</p></div></div></div><p>February 26th, 2019</p><p>In this post, I will describe how to port a desktop application from .NET Framework to .NET Core. I picked a WinForms application as an example. Steps for WPF application are similar and I’ll describe what needs to be done different for WPF as we go. I will also show how you can keep using the WinForms designer in Visual Studio even though it is under development and is not yet available for .NET Core projects.</p><h2><a id="user-content-about-the-sample" class="anchor" href="https://github.com/Microsoft/dotnet#about-the-sample"></a>About the sample</h2><p>For this post, I’ll be using a&nbsp;<a href="https://en.wikipedia.org/wiki/Concentration_(game)" rel="nofollow">Memory-style</a>&nbsp;board game application. It contains a WinForms UI (<code>MatchingGame.exe</code>) and a class library with the game logic (<code>MatchingGame.Logic.dll</code>), both targeting .NET Framework 4.5. You can download the sample&nbsp;<a href="https://github.com/OliaG/matching-game">here</a>. I’ll be porting the application project to .NET Core 3.0 and the class library to .NET Standard 2.0. Using .NET Standard instead of .NET Core allows me to reuse the game logic to provide the application for other platforms, such as iOS, Android or web.</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/02/matching-game-ui-296x300.jpg"><img class="size-medium wp-image-22096 aligncenter" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/02/matching-game-ui-296x300.jpg" alt="" width="296" height="300" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/02/matching-game-ui-296x300.jpg 296w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/02/matching-game-ui.jpg 500w" sizes="(max-width: 296px) 100vw, 296px"></a></p><p>You can either watch Scott Hunter and me doing the conversion in the following video, or you can follow the step-by-step instructions below. Of course, I won’t be holding it against you, if you were to do both.</p><h2><a id="user-content-step-by-step-process" class="anchor" href="https://github.com/Microsoft/dotnet#step-by-step-process"></a>Step-by-step process</h2><blockquote><p>I suggest doing the migration in a separate branch or, if you’re not using version control, creating a copy of your project so you have a clean state to go back to if necessary.</p></blockquote><p>Before porting the application to .NET Core 3.0, I need to do some preparation first.</p><h2><a id="user-content-preparing-to-port" class="anchor" href="https://github.com/Microsoft/dotnet#preparing-to-port"></a>Preparing to port</h2><ol><li><strong>Install&nbsp;<a href="https://dotnet.microsoft.com/download" rel="nofollow">.NET Core 3</a></strong>&nbsp;and Visual Studio 2019 Preview version (Visual Studio 2017 only supports up to .NET Core 2.2).</li><li><strong>Start from a working solution</strong>. Ensure the solution opens, builds, and runs without any issues.</li><li><strong>Update NuGet packages</strong>. It’s always a good practice to use the latest versions of NuGet packages before any migration. If your application is referencing any NuGet packages, update them to the latest version. Ensure your application builds successfully. In case of any NuGet errors, downgrade the version and find the latest one that doesn’t break your code.</li><li><strong>Run the&nbsp;<a href="https://blogs.msdn.microsoft.com/dotnet/2018/08/08/are-your-windows-forms-and-wpf-applications-ready-for-net-core-3-0/" rel="nofollow">.NET Portability Analyzer</a></strong>&nbsp;to determine if there are any APIs your application depends on that are missing from .NET Core. If there are, you need to refactor your code to avoid dependencies on APIs, not supported in .NET Core. Sometimes it’s possible to find an alternative API that provides the needed functionality.</li><li><strong>Replace&nbsp;<code>packages.config</code>&nbsp;with&nbsp;<code>PackageReference</code></strong>. If your project uses NuGet packages, you need to add the same NuGet packages to the new .NET Core project. .NET Core projects support only&nbsp;<code>PackageReference</code>&nbsp;for adding NuGet packages. To move your NuGet references from&nbsp;<code>packages.config</code>&nbsp;to your project file, in the solution explorer right-click on&nbsp;<code>packages.config</code>&nbsp;-&gt;&nbsp;<strong>Migrate packages.config to PackageReference…</strong>.You can learn more about this migration in the&nbsp;<a href="https://docs.microsoft.com/en-us/nuget/reference/migrate-packages-config-to-package-reference" rel="nofollow">Migrate from packages.config to PackageReference</a>&nbsp;article.</li></ol><h2><a id="user-content-porting-main-project" class="anchor" href="https://github.com/Microsoft/dotnet#porting-main-project"></a>Porting main project</h2><p><strong>Create new project</strong></p><ol><li>Create new application of the same type (Console, WinForms, WPF, Class Library) as the application you are wanting to port, targeting .NET Core 3. At the moment we did the demo Visual Studio templates for desktop projects were under development, so I used the console.<pre class="lang:sh decode:true">dotnet new winforms -o &lt;path-to-your-solution&gt;\MatchingGame.Core\</pre></li><li>In the project file copy all external references from the old project, for example:<div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true">&lt;PackageReference Include="Newtonsoft.Json" Version="9.0.1" /&gt;</pre></div></li><li>Build. At this point if the packages you’re referencing support only .NET Framework, you will get a&nbsp;<a href="https://docs.microsoft.com/en-us/nuget/reference/errors-and-warnings/nu1701" rel="nofollow">NuGet warning</a>. If you have not upgraded to the latest versions of NuGet packages on the step 3, try to find if the latest version supporting .NET Core (.NET Standard) is available and upgrade. If there are no newer version, .NET Framework packages can still be used but you might get run-time errors if those packages have dependencies on APIs not supported in .NET Core. We recommend to let the author of the NuGet package know that you’d be interested in seeing the package being updated to .NET Standard. You can do it via&nbsp;<code>Contact</code>&nbsp;form on the&nbsp;<a href="https://www.nuget.org/" rel="nofollow">NuGet gallery</a>.</li></ol><h3><a id="user-content-fast-way-replace-existing-project-file" class="anchor" href="https://github.com/Microsoft/dotnet#fast-way-replace-existing-project-file"></a>Fast way (replace existing project file)</h3><p><strong>First, let’s try the fast way to port.</strong>&nbsp;Make sure you have a copy of your current&nbsp;<code>.csproj</code>&nbsp;file, you might need to use it in future. Replace your current&nbsp;<code>.csproj</code>&nbsp;file with the&nbsp;<code>.csproj</code>&nbsp;file from the project you created on the step above and add in the top&nbsp;<code>&lt;PropertyGroup&gt;</code>:</p><div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true ">&lt;GenerateAssemblyInfo&gt;false&lt;/GenerateAssemblyInfo&gt;</pre></div><p>Build your app. If you got no errors – congrats, you’ve successfully migrated your project to .NET Core 3. For porting a dependent (UI) project see&nbsp;<strong>Porting UI</strong>&nbsp;section, for using the Designer, check out&nbsp;<strong>Using WinForms Designer for .NET Core projects</strong>&nbsp;section.</p><h3><a id="user-content-slow-way-guided-porting" class="anchor" href="https://github.com/Microsoft/dotnet#slow-way-guided-porting"></a>Slow way (guided porting)</h3><p>If you got errors (like I did with my app), it means there are more adjustments you need to make. Instead of the fast way described above, here I’ll do one change at a time and give possible fixes for each issue. Steps below would also help to better understand the process of the migration so if the fast way worked for you but you’re curious to learn all “whys”, keep on reading.</p><ol><li><strong>Migrate to the SDK-style .csproj file</strong>. To move my application to .NET Core, first I need to change my project file to SDK-style format because the old format does not support .NET Core. Besides, the SDK-style format is much leaner and easier to work with.Make sure you have a copy of your current&nbsp;<code>.csproj</code>&nbsp;file. Replace the content of your&nbsp;<code>.csproj</code>&nbsp;file with the following. For WinForms application:<div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net472&lt;/TargetFramework&gt;
    &lt;UseWindowsForms&gt;true&lt;/UseWindowsForms&gt;
    &lt;GenerateAssemblyInfo&gt;false&lt;/GenerateAssemblyInfo&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre></div><p>For WPF application:</p><div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true ">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net472&lt;/TargetFramework&gt;
    &lt;UseWPF&gt;true&lt;/UseWPF&gt;
    &lt;GenerateAssemblyInfo&gt;false&lt;/GenerateAssemblyInfo&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre></div><blockquote><p>Note that I set&nbsp;<code>&lt;GenerateAssemblyInfo&gt;</code>&nbsp;to&nbsp;<code>false</code>. In the new-style projects&nbsp;<code>AssemblyInfo.cs</code>&nbsp;is generated automatically by default. So if you already have&nbsp;<code>AssemblyInfo.cs</code>&nbsp;file in your project (spoiler alert: you do), you need to disable auto-generation or remove the file.</p></blockquote><p>Now copy &amp; paste all references from the old version of&nbsp;<code>.csproj</code>&nbsp;file into the new one. For example:</p><p><em>NuGet package reference</em></p><pre class="lang:xhtml decode:true ">&lt;PackageReference Include="Microsoft.Windows.Compatibility" Version="2.0.1" /&gt;</pre><p><em>Project reference</em></p><pre class="lang:xhtml decode:true">&lt;ProjectReference Include="..\MatchingGame.Core\MatchingGame.Core.csproj" /&gt;</pre><p>The project should build successfully since it is just a new way of writing the same thing. If you got any errors, double check your steps.</p><p>There is also a third-party tool&nbsp;<a href="https://github.com/hvanbakel/CsprojToVs2017">CsprojToVs2017</a>&nbsp;that can perform the conversion for you. But after using it, you still might need to delete some reference by hand, such as:</p><div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true">&lt;Reference Include="System.Data.DataSetExtensions" /&gt;
&lt;Reference Include="Microsoft.CSharp" /&gt;
&lt;Reference Include="System.Net.Http" /&gt;</pre></div></li><li><strong>Move from .NET Framework to .NET Standard or .NET Core</strong>. After successfully converting my library to SDK-style format I’m able to retarget it. In my case I want my class library to target&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/standard/net-standard" rel="nofollow">.NET Standard</a>&nbsp;instead of .NET Core. That way, it will be accessible from any .NET implementation if I decide to ship the game to other platforms (such as iOS, Android, or Web Assembly). To do so, replace this<div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true">&lt;TargetFramework&gt;net472&lt;/TargetFramework&gt;</pre></div><p>with</p><div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true ">&lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;</pre></div><p>Build your application. You might get some errors if you are using APIs that are not included in .NET Standard. If you did not get any errors with your application, you can skip the next two steps.</p></li><li><strong>Add Windows Compatibility Pack if needed</strong>. Some APIs that are not included in .NET Standard are available in&nbsp;<a href="https://docs.microsoft.com/dotnet/core/porting/windows-compat-pack" rel="nofollow">Windows Compatibility Pack</a>. If you got errors on the previous step, you can check if&nbsp;<a href="https://docs.microsoft.com/dotnet/core/porting/windows-compat-pack" rel="nofollow">Windows Compatibility Pack</a>&nbsp;can help.I got an error “The name ‘Registry’ does not exist in the current context”, so I added the&nbsp;<strong>Microsoft.Windows.Compatibility</strong>&nbsp;NuGet package to my project. After installation, the error disappeared.</li><li><strong>Install API Analyzer</strong>.&nbsp;<a href="https://blogs.msdn.microsoft.com/dotnet/2017/10/31/introducing-api-analyzer/" rel="nofollow">API Analyzer</a>, available as the NuGet package&nbsp;<strong>Microsoft.DotNet.Analyzers.Compatibility</strong>, will prompt you with warnings when you are using deprecated APIs or APIs that are not supported across all platforms (Windows, Linux, macOS). If you added the Compatibility Pack, I recommend adding the API Analyzer to keep track of all of API usages that won’t work across all platforms.At this point, I am done with the class library migration to .NET Standard. If you have multiple projects referencing each other, migrate them “bottom-up” starting with the project that has no dependencies on other projects.In my example I also have a WinForms project&nbsp;<code>MatchingGame.exe</code>, so now I will perform similar steps to migrate that to .NET Core.</li></ol><h2><a id="user-content-porting-the-ui" class="anchor" href="https://github.com/Microsoft/dotnet#porting-the-ui"></a>Porting the UI</h2><ol><li><strong>Add .NET Core UI project</strong>. Add a new .NET Core 3.0 UI project to the solution. At this moment, the Visual Studio templates for desktop projects are under development, so I just used the&nbsp;<code>dotnet</code>&nbsp;CLI.<pre class="lang:sh decode:true">dotnet new winforms -o &lt;path-to-your-solution&gt;\MatchingGame.Core\</pre><p>For WPF projects you’d use this:</p><pre class="lang:sh decode:true">dotnet new wpf -o &lt;path-to-your-solution&gt;\MatchingGame.Core\</pre><p>After my new WinForms .NET Core project was created, I added it to my solution.</p></li><li><strong>Link projects</strong>. First, delete all files from the new project (right now it contains the generic Hello World code). Then, link all files from your existing .NET Framework UI project to the .NET Core 3.0 UI project by adding following to the&nbsp;<code>.csproj</code>file.<div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true">&lt;ItemGroup&gt;
    &lt;Compile Include="..\&lt;Your .NET Framework Project Name&gt;\**\*.cs" /&gt;
    &lt;EmbeddedResource Include="..\&lt;Your .NET Framework Project Name&gt;\**\*.resx" /&gt;
&lt;/ItemGroup&gt;</pre></div><p>If you have a WPF application you also need to include&nbsp;<code>.xaml</code>&nbsp;files:</p><div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true">&lt;ItemGroup&gt;
  &lt;ApplicationDefinition Include="..\WpfApp1\App.xaml" Link="App.xaml"&gt;
    &lt;Generator&gt;MSBuild:Compile&lt;/Generator&gt;
  &lt;/ApplicationDefinition&gt;
  &lt;Compile Include="..\WpfApp1\App.xaml.cs" Link="App.xaml.cs" /&gt;
&lt;/ItemGroup&gt;

&lt;ItemGroup&gt;
  &lt;Page Include="..\WpfApp1\MainWindow.xaml" Link="MainWindow.xaml"&gt;
    &lt;Generator&gt;MSBuild:Compile&lt;/Generator&gt;
  &lt;/Page&gt;
  &lt;Compile Include="..\WpfApp1\MainWindow.xaml.cs" Link="MainWindow.xaml.cs" /&gt;
&lt;/ItemGroup&gt;</pre></div></li><li><strong>Align default namespace and assembly name</strong>. Since you’re linking to designer generated files (for example,&nbsp;<code>Resources.Designer.cs</code>), you generally want to make sure that the .NET Core version of your application uses the same namespace and the same assembly name. Copy the following settings from your .NET Framework project:<div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true ">&lt;PropertyGroup&gt;
    &lt;RootNamespace&gt;&lt;!-- (Your default namespace) --&gt;&lt;/RootNamespace&gt;
    &lt;AssemblyName&gt;&lt;!-- (Your assembly name) --&gt;&lt;/AssemblyName&gt;
&lt;/PropertyGroup&gt;</pre></div></li><li><strong>Disable&nbsp;<code>AssemblyInfo.cs</code>&nbsp;generation</strong>. As I mentioned earlier, in the new-style projects,&nbsp;<code>AssemblyInfo.cs</code>&nbsp;is generated automatically by default. At the same time the&nbsp;<code>AssemblyInfo.cs</code>&nbsp;file from the old WinForms project will be copied to the new project too, because I linked all files&nbsp;<code>**\*.cs</code>&nbsp;in the previous step. That will result in duplication of&nbsp;<code>AssemblyInfo.cs</code>. To avoid it in&nbsp;<code>MatchingGame.Core</code>&nbsp;project file I set&nbsp;<code>GenerateAssemblyInfo</code>&nbsp;to&nbsp;<code>false</code>.<div class="highlight highlight-text-xml"><pre class="lang:xhtml decode:true">&lt;GenerateAssemblyInfo&gt;false&lt;/GenerateAssemblyInfo&gt;</pre></div></li><li><strong>Run new project</strong>. Set your new .NET Core project as the StartUp project and run it. Make sure everything works.</li><li><strong>Copy or leave linked</strong>. Now instead of linking the files, you can actually copy them from the old .NET Framework UI project to the new .NET Core 3.0 UI project. After that, you can get rid of the old project.</li></ol><h2><a id="user-content-using-the-winforms-designer-for-net-core-projects" class="anchor" href="https://github.com/Microsoft/dotnet#using-the-winforms-designer-for-net-core-projects"></a>Using the WinForms designer for .NET Core projects</h2><p>As I mentioned above, the WinForms designer for .NET Core projects is not yet available in Visual Studio. However there are two ways to work around it:</p><ol><li>You can keep your files linked (by just not performing the previous step) and copy them when the designer support is available. This way, you can modify the files in your old .NET Framework WinForms project using the designer. And the changes will be automatically reflected in the new .NET Core WinForms project — since they’re linked.</li><li>You can have two project files in the same directory as your WinForms project: the old&nbsp;<code>.csproj</code>&nbsp;file from the existing .NET Framework project and the new SDK-style&nbsp;<code>.csproj</code>&nbsp;file of the new .NET Core WinForms project. You’ll just have to unload and reload the project with corresponding project file depending on whether you want to use the designer or not.</li></ol><h2><a id="user-content-summary" class="anchor" href="https://github.com/Microsoft/dotnet#summary"></a>Summary</h2><p>In this blog post, I showed you how to port a desktop application containing multiple projects from .NET Framework to .NET Core. In typical cases, just retargeting your projects to .NET Core isn’t enough. I described potential issues you might encounter and ways of addressing them. Also, I demonstrated how you can still use the WinForms designer for your ported apps while it’s not yet available for .NET Core projects.</p><div class="authorinfoarea"><div><p>Program Manager,&nbsp;.NET</p><p><strong>Follow Olia</strong>&nbsp;&nbsp;&nbsp;<a class="no-underline stayinformed" aria-label="Olia Gavrysh Twitter profile" target="_blank" href="https://twitter.com/oliagavrysh"></a><a class="no-underline stayinformed" aria-label="Olia Gavrysh GitHub profile" target="_blank" href="https://github.com/OliaG"><i class="fa fa-github"></i></a><a class="no-underline stayinformed hvr-pop" aria-label="Olia Gavrysh RSS Feed" target="_blank" href="https://devblogs.microsoft.com/dotnet/author/olga-gavrysh/feed/"></a></p></div></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>