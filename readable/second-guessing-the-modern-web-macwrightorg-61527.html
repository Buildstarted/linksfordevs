<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Second-guessing the modern web - macwright.org - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Second-guessing the modern web - macwright.org - linksfor.dev(s)"/>
    <meta property="article:author" content="Tom MacWright"/>
    <meta property="og:description" content="What if everyone&#x27;s wrong?"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://macwright.org/2020/05/10/spa-fatigue.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Second-guessing the modern web - macwright.org</title>
<div class="readable">
        <h1>Second-guessing the modern web - macwright.org</h1>
            <div>by Tom MacWright</div>
            <div>Reading time: 11-14 minutes</div>
        <div>Posted here: 11 May 2020</div>
        <p><a href="https://macwright.org/2020/05/10/spa-fatigue.html">https://macwright.org/2020/05/10/spa-fatigue.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>The emerging norm for web development is to build a React single-page application, with server rendering. The two key elements of this architecture are something like:</p><ol><li>The main UI is built &amp; updated in JavaScript using React or something similar.</li><li>The backend is an API that that application makes requests against.</li></ol><p>This idea has really swept the internet. It started with a few major popular websites and has crept into corners like marketing sites and blogs.</p><p>I’m increasingly skeptical of it.</p><p>There is a sweet spot of React: in moderately interactive interfaces. Complex forms that require immediate feedback, UIs that need to move around and react instantly. That’s where it excels. I helped build the editors in <a href="https://www.mapbox.com/mapbox-studio/">Mapbox Studio</a> and <a href="https://observablehq.com/">Observable</a> and for the most part, React was a great choice.</p><p>But there’s a lot on either side of that sweet spot.</p><p>The high performance parts aren’t React. <a href="https://docs.mapbox.com/mapbox-gl-js/api/">Mapbox GL</a>, for example, is vanilla JavaScript and probably should be, forever. The level of abstraction that React works on is too high, and the cost of using React - in payload, parse time, and so on - is too high for any company to include it as part of an SDK. Same with the <a href="https://github.com/observablehq/runtime">Observable runtime</a>, the juicy center of that product: it’s very performance-intensive and would barely benefit from a port.</p><p>The low performance parts don’t need to be React. Listing pages, static pages, blogs - these things are increasingly built in React, but the benefits they accrue are extremely narrow. A lot of the optimizations that are cropping up in these corners, things like bundle splitting, server-side rendering, and prerendering, are triangulating, essentially, what we had before the rise of React.</p><p>And they’re kind of messy optimizations. Here are some examples.</p><h3 id="bundle-splitting">Bundle splitting.</h3><p>The idea is that, as your React application grows, the application bundle grows. Unlike with a traditional multi-page app, that growth affects <em>every visitor</em>: you download the whole app the first time that you visit it. At some point, this becomes a real problem. Someone who lands on the About page is also downloading 20 other pages in the same application bundle. Bundle splitting ‘solves’ this problem by creating many bundles that can lazily load each other. So you load the About page and what your browser downloads is an ‘index’ bundle, and then that ‘index’ bundle loads the ‘about page’ bundle.</p><p>This <em>sort of</em> solves the problem, but it’s not great. Most bundle splitting techniques require you to load that ‘index bundle’, and then only once that JavaScript is loaded and executed does your browser know which ‘page bundle’ it needs. So you need two round-trips to start your page rendering.</p><p>Plus, there’s the question of updating code-split bundles. User sessions are surprisingly long: someone might have your website open in a tab for weeks at a time. I’ve seen it happen. So if they open the ‘about page’, keep the tab open for a week, and then request the ‘home page’, then the home page that they request is dictated by <em>the index bundle that they downloaded last week</em>. This is a deeply weird and under-discussed situation. There are essentially two solutions to it:</p><ol><li>You keep all generated JavaScript around, forever, and people will see the version of the site that was live at the time of their first page request.</li><li>You create a system that alerts users when you’ve deployed a new version of the site, and prompt them to reload.</li></ol><p>The first solution has a drawback that might not be immediately obvious. In those intervening weeks between loading the site and clicking a link, you might’ve deployed a new API version. So the user will be using an old version of your JavaScript frontend with a new version of your API backend, and they’ll trigger errors that none of your testing knows about, because you’ll usually be testing current versions of each.</p><p>And the second solution, while it works (and is what we implemented for Mapbox Studio), is a bizarre way for a web application to behave. Prompting users to ‘update’ is something from the bad old days of desktop software, not from the shiny new days of the web.</p><p>Sure: traditional non-SPA websites are not immune to this pitfall. Someone might load your website, have a <em>form</em> open for many weeks, and then submit it after their session expired or the API changed. But that’s a much more limited exposure to failure than in the SPA case.</p><h3 id="server-side-rendering">Server-Side Rendering</h3><p>Okay, so the theory here is that SPAs are initially a blank page, which has to be filled out by React &amp; JavaScript. That’s bad for performance, obviously, when HTML pages don’t <em>need</em> to be blank initially. So, Server-Sider Rendering runs your JavaScript frontend code on the backend, creating a filled-out HTML page. The user loads the page, which is filled-out, and then the JavaScript loads and makes the page interactive.</p><p>A great optimization, but again, caveats.</p><p>The first is that the page you initially render is dead: you’ve created the <a href="https://web.dev/interactive/">Time To Interactive</a> metric. It’s your startup’s homepage, and it has a “Sign up” button, but until the JavaScript loads, that button doesn’t do anything. So you need to compensate. Either you omit some interactive elements on load, or you try really hard to make sure that the JavaScript loads faster than users will click, or you make some elements not require JavaScript to work - like making them normal links or forms. Or some combination of those.</p><p>And then there’s the authentication story. If you do SSR on any pages that are custom to the user, then you need to forward any cookies or authentication-relevant information to your API backend and make sure that you never cache the server-rendered result.</p><h3 id="apis">APIs</h3><p>The dream of APIs is that you have beautiful REST endpoints that align to each different table in your database or model in your business logic. That idea breaks down pretty fast.</p><p>Most interactive web applications start to triangulate on “one query per page.” API calls being generic or reusable never seems to persist as a value in infrastructure. This is because a large portion of web applications are, at their core, query &amp; transformation interfaces on top of databases. The hardest performance problems they tend to have are query problems and transfer problems.</p><p>For example: a puritanical REST application that tries to never mix ‘concerns’ (tables), will produce a frontend application that has to make lots and lots of requests to display a page. And then a new-age GraphQL application will suffer under the <a href="https://engineering.shopify.com/blogs/engineering/solving-the-n-1-problem-for-graphql-through-batching">N+1 query problem</a> at the database level until an optimization arrives. And a traditional “make a query and put it on a page” application will just, well, try to write some good queries.</p><p>None of these solutions are silver bullets: I’ve worked with overly-strict REST APIs, optimization-hungry GraphQL APIs, and hand-crafted SQL APIs. But no option really lets a web app be careless about its data-fetching layer.</p><h3 id="data-fetching">Data fetching</h3><p>Speaking of data fetching. It’s really important and really bizarre in React land. Years ago, I expected that some good patterns would emerge. Frankly, they didn’t.</p><p>There are decent patterns in the form of GraphQL, but for a React component that loads data with fetch from an API, the solutions have only gotten weirder. There’s great documentation for everything else, but old-fashioned data loading is relegated to one example of how to mock out ‘fetch’ for testing, and lots of Medium posts of varying quality.</p><hr><p>Don’t read this as anti-React. I still think React is pretty great, and for a particular scope of use cases it’s the best tool you can find. And I explicitly want to say that –&nbsp;from what I’ve seen –&nbsp;most other Single-Page-Application tools share most of these problems. They’re issues with the pattern, not the specific technologies used to implement it. React alternatives have some great ideas, and they might be better, but they are ultimately really similar.</p><p>But I’m at the point where you look at where the field is and what the alternatives are –&nbsp;taking a second look at unloved, unpopular, uncool things like Django, Rails, Laravel –&nbsp;and think <em>what the heck is happening</em>. We’re layering optimizations upon optimizations in order to get the SPA-like pattern to fit every use case, and I’m not sure that it is, well, worth it.</p><p><strong>And it should be easy to do a good job.</strong></p><p>Frameworks should lure people into the <a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/">pit of success</a>, where following the normal rules and using normal techniques is the winning approach.</p><p>I don’t think that React, in this context, really is that pit of success. A naïvely implemented React SPA isn’t stable, or efficient, and it doesn’t naturally scale to significant complexity</p><p>You can add optimizations on top of it that fix those problems,&nbsp;or you can use a framework like Next.js that will include those optimizations by default. That’ll help you get pretty far. But then you’ll be lured by all of the easy one-click ways to add bloat and complexity. You’ll be responsible for keeping some of these complex, finicky optimizations working properly.</p><p>And for what? Again - there is a swath of use cases which would be hard without React and which aren’t complicated enough to push beyond React’s limits. But there are also a <em>lot</em> of problems for which I can’t see any concrete benefit to using React. Those are things like blogs, shopping-cart-websites, mostly-<a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>-and-forms-websites. For these things, all of the fancy optimizations are optimizations to get you closer to <em>the performance you would’ve gotten if you just hadn’t used so much technology</em>.</p><p>I can, for example, guarantee that this blog is faster than <em>any Gatsby blog</em> (and much love to the Gatsby team) because there is nothing that a React static site can do that will make it faster than a non-React static site.</p><hr><p>But the cultural tides are <em>strong</em>. Building a company on Django in 2020 seems like the equivalent of driving a PT Cruiser and blasting Faith Hill’s “Breathe” on a CD while your friends are listening to The Weeknd in their Teslas. Swimming against this current isn’t easy, and not in a trendy contrarian way.</p><p>I don’t think that everyone’s using the SPA pattern for no reason. For large corporations, it allows teams to work independently: the “frontend engineers” can “consume” “APIs” from teams that probably work in a different language and can only communicate through the hierarchy. For heavily interactive applications, it has real benefits in modularity, performance, and structure. And it’s beneficial for companies to shift computing requirements from their servers to their customers browsers: it’s a real win for reducing their spend on infrastructure.</p><p>But I think there are a lot of problems that are better solved some other way. There’s no category winner like React as an alternative. Ironically, backends are churning through technology even faster than frontends, which have been loyal to one programming language for decades. There are some age-old technologies like Rails, Django, and Laravel, and there are a few halfhearted attempts to do templating and “serving web pages” from Go, Node, and other new languages. You’re beset by the cognitive dissonance of following in the footsteps of enormous projects - Wikipedia rendering web pages in PHP, Craigslist rendering webpages in Perl - but being far outside the norms of <em>modern web development</em>. If Wikipedia were started today, it’d be React. Maybe?</p><p>What if everyone’s wrong? We’ve been wrong before.</p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>