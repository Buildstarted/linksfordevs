<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Discards - C# Guide | Microsoft Docs -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Discards - C# Guide | Microsoft Docs</h1><div><div id="main" class="content "><p>Starting with C# 7.0, C# supports discards, which are temporary, dummy variables that are intentionally unused in application code. Discards are equivalent to unassigned variables; they do not have a value. Because there is only a single discard variable, and that variable may not even be allocated storage, discards can reduce memory allocations. Because they make the intent of your code clear, they enhance its readability and maintainability.</p><p>You indicate that a variable is a discard by assigning it the underscore (<code>_</code>) as its name. For example, the following method call returns a 3-tuple in which the first and second values are discards and <em>area</em> is a previously declared variable to be set to the corresponding third component returned by <em>GetCityInformation</em>:</p><pre><code class="lang-csharp">(_, _, area) = city.GetCityInformation(cityName);
</code></pre><p>In C# 7.0, discards are supported in assignments in the following contexts:</p><ul><li>Tuple and object <a href="deconstruct" data-linktype="relative-path">deconstruction</a>.</li><li>Pattern matching with <a href="language-reference/keywords/is" data-linktype="relative-path">is</a> and <a href="language-reference/keywords/switch" data-linktype="relative-path">switch</a>.</li><li>Calls to methods with <code>out</code> parameters.</li><li>A standalone <code>_</code> when no <code>_</code> is in scope.</li></ul><p>When <code>_</code> is a valid discard, attempting to retrieve its value or use it in an assignment operation generates compiler error CS0301, "The name '_' does not exist in the current context". This is because <code>_</code> is not assigned a value, and may not even be assigned a storage location. If it were an actual variable, you could not discard more than one value, as the previous example did.</p><h2 id="tuple-and-object-deconstruction">Tuple and object deconstruction</h2><p>Discards are particularly useful in working with tuples when your application code uses some tuple elements but ignores others. For example, the following <code>QueryCityDataForYears</code> method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year. The example shows the change in population between those two years. Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time. As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</p><pre><code class="lang-csharp" name="Tuple-discard">using System;
using System.Collections.Generic;

public class Example
{
    public static void Main()
    {
        var (_, _, _, pop1, _, pop2) = QueryCityDataForYears("New York City", 1960, 2010);

        Console.WriteLine($"Population change, 1960 to 2010: {pop2 - pop1:N0}");
    }
   
    private static (string, double, int, int, int, int) QueryCityDataForYears(string name, int year1, int year2)
    {
        int population1 = 0, population2 = 0;
        double area = 0;
      
        if (name == "New York City")
        {
            area = 468.48; 
            if (year1 == 1960)
            {
                population1 = 7781984;
            }
            if (year2 == 2010)
            {
                population2 = 8175133;
            }
            return (name, area, year1, population1, year2, population2);
        }

        return ("", 0, 0, 0, 0, 0);
    }
}
// The example displays the following output:
//      Population change, 1960 to 2010: 393,149
</code></pre><p>For more information on deconstructing tuples with discards, see <a href="deconstruct#deconstructing-tuple-elements-with-discards" data-linktype="relative-path">Deconstructing tuples and other types</a>.</p><p>The <code>Deconstruct</code> method of a class, structure, or interface also allows you to retrieve and deconstruct a specific set of data from an object. You can use discards when you are interested in working with only a subset of the deconstructed values. The following example deconstructs a <code>Person</code> object into four strings (the first and last names, the city, and the state), but discards the last name and the state.</p><pre><code class="lang-csharp" name="Class-discard">using System;

public class Person
{
    public string FirstName { get; set; }
    public string MiddleName { get; set; }
    public string LastName { get; set; }
    public string City { get; set; }
    public string State { get; set; }

    public Person(string fname, string mname, string lname, 
                  string cityName, string stateName)
    {
        FirstName = fname;
        MiddleName = mname;
        LastName = lname;
        City = cityName;
        State = stateName;
    }

    // Return the first and last name.
    public void Deconstruct(out string fname, out string lname)
    {
        fname = FirstName;
        lname = LastName;
    }

    public void Deconstruct(out string fname, out string mname, out string lname)
    {
        fname = FirstName;
        mname = MiddleName;
        lname = LastName;
    }

    public void Deconstruct(out string fname, out string lname, 
                            out string city, out string state)
    {
        fname = FirstName;
        lname = LastName;
        city = City;
        state = State;
    }
}

public class Example
{
    public static void Main()
    {
        var p = new Person("John", "Quincy", "Adams", "Boston", "MA");

        // &lt;Snippet1&gt;
        // Deconstruct the person object.
        var (fName, _, city, _) = p;
        Console.WriteLine($"Hello {fName} of {city}!");
        // The example displays the following output:
        //      Hello John of Boston!
        // &lt;/Snippet1&gt;
    }
}
// The example displays the following output:
//    Hello John Adams of Boston, MA!
</code></pre><p>For more information on deconstructing user-defined types with discards, see <a href="deconstruct#deconstructing-a-user-defined-type-with-discards" data-linktype="relative-path">Deconstructing tuples and other types</a>.</p><h2 id="pattern-matching-with-switch-and-is">Pattern matching with <code>switch</code> and <code>is</code></h2><p>The <em>discard pattern</em> can be used in pattern matching with the <a href="language-reference/keywords/is" data-linktype="relative-path">is</a> and <a href="language-reference/keywords/switch" data-linktype="relative-path">switch</a> keywords. Every expression always matches the discard pattern.</p><p>The following example defines a <code>ProvidesFormatInfo</code> method that uses <a href="language-reference/keywords/is" data-linktype="relative-path">is</a> statements to determine whether an object provides an <a href="/en-us/dotnet/api/system.iformatprovider" data-linktype="absolute-path">IFormatProvider</a> implementation and tests whether the object is <code>null</code>. It also uses the discard pattern to handle non-null objects of any other type.</p><pre><code class="lang-csharp" name="discard-pattern">using System;
using System.Globalization;

public class Example
{
   public static void Main()
   {
      object[] objects = { CultureInfo.CurrentCulture, 
                           CultureInfo.CurrentCulture.DateTimeFormat, 
                           CultureInfo.CurrentCulture.NumberFormat,
                           new ArgumentException(), null };
      foreach (var obj in objects)
         ProvidesFormatInfo(obj);
   }

   private static void ProvidesFormatInfo(object obj)         
   {
      switch (obj)
      {
         case IFormatProvider fmt:
            Console.WriteLine($"{fmt} object");
            break;
         case null:
            Console.Write("A null object reference: ");
            Console.WriteLine("Its use could result in a NullReferenceException");
            break;
         case object _:
            Console.WriteLine("Some object type without format information");
            break;
      }
   }
}
// The example displays the following output:
//    en-US object
//    System.Globalization.DateTimeFormatInfo object
//    System.Globalization.NumberFormatInfo object
//    Some object type without format information
//    A null object reference: Its use could result in a NullReferenceException
</code></pre><h2 id="calls-to-methods-with-out-parameters">Calls to methods with out parameters</h2><p>When calling the <code>Deconstruct</code> method to deconstruct a user-defined type (an instance of a class, structure, or interface), you can discard the values of individual <code>out</code> arguments. But you can also discard the value of <code>out</code> arguments when calling any method with an out parameter.</p><p>The following example calls the <a href="/en-us/dotnet/api/system.datetime.tryparse#System_DateTime_TryParse_System_String_System_DateTime__" data-linktype="absolute-path">DateTime.TryParse(String, out DateTime)</a> method to determine whether the string representation of a date is valid in the current culture. Because the example is concerned only with validating the date string and not with parsing it to extract the date, the <code>out</code> argument to the method is a discard.</p><pre><code class="lang-csharp" name="discard-with-out">using System;

public class Example
{
   public static void Main()
   {
      string[] dateStrings = {"05/01/2018 14:57:32.8", "2018-05-01 14:57:32.8",
                              "2018-05-01T14:57:32.8375298-04:00", "5/01/2018",
                              "5/01/2018 14:57:32.80 -07:00", 
                              "1 May 2018 2:57:32.8 PM", "16-05-2018 1:00:32 PM", 
                              "Fri, 15 May 2018 20:10:57 GMT" };
      foreach (string dateString in dateStrings)
      {
         if (DateTime.TryParse(dateString, out _)) 
            Console.WriteLine($"'{dateString}': valid");
         else
            Console.WriteLine($"'{dateString}': invalid");
      }
   }
}
// The example displays output like the following:
//       '05/01/2018 14:57:32.8': valid
//       '2018-05-01 14:57:32.8': valid
//       '2018-05-01T14:57:32.8375298-04:00': valid
//       '5/01/2018': valid
//       '5/01/2018 14:57:32.80 -07:00': valid
//       '1 May 2018 2:57:32.8 PM': valid
//       '16-05-2018 1:00:32 PM': invalid
//       'Fri, 15 May 2018 20:10:57 GMT': invalid
</code></pre><h2 id="a-standalone-discard">A standalone discard</h2><p>You can use a standalone discard to indicate any variable that you choose to ignore. The following example uses a standalone discard to ignore the <a href="/en-us/dotnet/api/system.threading.tasks.task" data-linktype="absolute-path">Task</a> object returned by an asynchronous operation. This has the effect of suppressing the exception that the operation throws as it is about to complete.</p><pre><code class="lang-csharp" name="standalone-discard">using System;
using System.Threading.Tasks;

public class Example
{
   public static void Main()
   {
      ExecuteAsyncMethods().Wait();
   }

   private static async Task ExecuteAsyncMethods()
   {    
      Console.WriteLine("About to launch a task...");
      _ = Task.Run(() =&gt; { var iterations = 0;  
                           for (int ctr = 0; ctr &lt; int.MaxValue; ctr++)
                              iterations++;
                           Console.WriteLine("Completed looping operation...");
                           throw new InvalidOperationException();
                         });
      await Task.Delay(5000);                        
      Console.WriteLine("Exiting after 5 second delay");
   }
}
// The example displays output like the following:
//       About to launch a task...
//       Completed looping operation...
//       Exiting after 5 second delay
</code></pre><p>Note that <code>_</code> is also a valid identifier. When used outside of a supported context, <code>_</code> is treated not as a discard but as a valid variable. If an identifier named <code>_</code> is already in scope, the use of <code>_</code> as a standalone discard can result in:</p><ul><li><p>Accidental modification of the value of the in-scope <code>_</code> variable by assigning it the value of the intended discard. For example:</p><pre><code class="lang-csharp" name="standalone-discard">private static void ShowValue(int _)
{
   byte[] arr = { 0, 0, 1, 2 };
   _ = BitConverter.ToInt32(arr, 0);
   Console.WriteLine(_);
}
// The example displays the following output:
//       33619968
</code></pre></li><li><p>A compiler error for violating type safety. For example:</p><pre><code class="lang-csharp" name="standalone-discard">private static bool RoundTrips(int _)
{
   string value = _.ToString();
   int newValue = 0;
   _ = Int32.TryParse(value, out newValue);
   return _ == newValue;
}
// The example displays the following compiler error:
//      error CS0029: Cannot implicitly convert type 'bool' to 'int'   
</code></pre></li><li><p>Compiler error CS0136, "A local or parameter named '_' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter." For example:</p><pre><code class="lang-csharp" name="standalone-discard">public void DoSomething(int _) 
{
 var _ = GetValue(); // Error: cannot declare local _ when one is already in scope
}   
// The example displays the following compiler error:
// error CS0136: 
//       A local or parameter named '_' cannot be declared in this scope 
//       because that name is used in an enclosing local scope 
//       to define a local or parameter   
</code></pre></li></ul><h2 id="see-also">See also</h2></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>