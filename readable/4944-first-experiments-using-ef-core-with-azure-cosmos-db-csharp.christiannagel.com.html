<!DOCTYPE html>
<html lang="en">
<head>
    <title>
First experiments using EF Core with Azure Cosmos DB &#x2013; csharp.christiannagel.com -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>First experiments using EF Core with Azure Cosmos DB – csharp.christiannagel.com</h1><div><div class="entry-content"><p>Entity Framework Core (EF Core) was designed to not being a framework for only relational databases. It just takes some time to get the first non-relational providers. Now is the time.</p><p>Microsoft now has the first preview for an EF Core provider for Cosmos DB. With this I have to do my first experiments using <strong>Cosmos DB</strong> from <strong>EF Core</strong>.</p><blockquote><p>
  Updated to Entity Framework Core 2.2 Preview 3
</p></blockquote><p><img src="https://csharpdotchristiannageldotcom.files.wordpress.com/2018/08/unicorn.jpg?w=672" alt="Unicorn in galaxy nebula cloud"></p><h2>Azure Cosmos DB</h2><p>Azure Cosmos DB is a NoSQL database from Microsoft. It is globally distributed and offers multiple models. You can store data with key/values pairs, records with multiple columns (table storage), documents, and data linked within graphs. If you need massive amounts of data, reads, and writes with fast responses and high throughput, Azure Cosmos DB gives you great options.</p><h2>EF Core Providers</h2><p>Available EF Core providers are listed in the document <a href="https://docs.microsoft.com/en-us/ef/core/providers/">Database Providers</a>. The provider I’m using most of the time is of course the provider for <strong>SQL Server</strong>. There are some other providers as well, e.g. from Microsoft for <strong>SQLite</strong>, and <strong>in-memory</strong>. From the <a href="https://github.com/npgsql">Npgsql Development Team</a> you can get a provider for <strong>PostreSQL</strong>. <strong>MySQL</strong> and <strong>MariaDB</strong> providers are from the <a href="https://github.com/PomeloFoundation">Pomelo Foundation Project</a>. <a href="https://github.com/ErikEJ/">Erik Ejlskov Jensen</a> created a provider for <strong>SQL Server Compact</strong>. Oracle offers a provider for <strong>MySQL</strong>. <a href="https://github.com/cincuranet">Jiří Činčura</a> and <a href="https://github.com/ralmsdeveloper">Rafael Almeida</a> have providers for <strong>Firebird</strong>. <a href="https://ibm.com/">IBM</a> is in the game with providers for <strong>Db2</strong> and <strong>Informix</strong>. Paid high quality providers for <strong>Oracle</strong>, <strong>PostgreSQL</strong>, <strong>SQLite</strong>, and <strong>MySQL</strong> are from <a href="https://www.devart.com/">DevArt</a>. There’s even one for <strong>Microsoft Access</strong> from <a href="https://github.com/bubibubi">Bubi</a>.</p><p>Missing are Non-SQL providers, and an Oracle provider from Oracle. Oracle already has a <a href="http://www.oracle.com/technetwork/topics/dotnet/tech-info/odpnet-dotnet-ef-core-sod-4395108.pdf">Statement of Direction for .NET Core and Entity Framework Core</a>, so a provider from Oracle is coming soon. Oracle is not left out as there’s a provider from DevArt as previously mentioned. Microsoft now has a <a href="https://github.com/aspnet/EntityFrameworkCore/tree/master/samples/OracleProvider">sample provider for Oracle</a> as well, but this one has some limitations.</p><p>With NoSQL Providers, Microsoft started to work on a <a href="https://github.com/aspnet/EntityFrameworkCore/issues/1142">Azure Table Storage provider</a>. Because of time constraints, this was delayed. Now the <a href="https://github.com/aspnet/EntityFrameworkCore/issues/8443">Cosmos DB provider</a> has a bigger focus. Preview 3 for <a href="https://github.com/aspnet/EntityFrameworkCore/tree/release/2.2/src/EFCore.Cosmos">Microsoft.EntityFrameworkCore.Cosmos</a> is now available on the NuGet server.</p><h2>Project Preparation</h2><p>To start, I’m creating a .NET Core 2.2 console application and adding these packages:</p><ul><li>Microsoft.EntityFrameworkCore.Cosmos</li><li>Microsoft.Extensions.Configuration.Json</li><li>Microsoft.Extensions.Configuration.UserSecrets</li><li>Microsoft.Extensions.DependencyInjection</li><li>Microsoft.Extensions.Logging.Debug</li></ul><blockquote><p>
  From the first preview, the name of the provider package changed from <em>Microsoft.EntityFrameworkCore.Cosmos.Sql</em> to <em>Microsoft.EntityFrameworkCore.Cosmos</em>.
</p></blockquote><p>The configuration for the Cosmos DB is read from a JSON configuration file. I’m not storing the secret key in the source code repository. Instead, app secrets are used during development time with the package <em>Microsoft.Extensions.Configuration.UserSecrets</em>.</p><p>The EF Core context is instantiated by using dependency injection, that’s why the package <em>Microsoft.Extensions.DependencyInjection</em> is added. EF Core could be used without creating a DI container. However as in all production apps I’m creating nowadays I’m using a DI container, I’m using it with this small sample as well.</p><p>For logging I’m using the <code>ILogger</code> interface, to see what information is traced by the EF Core provider – that’s the reason for the <em>Microsoft.Extensions.Logging.Debug</em> package.</p><blockquote><p>
  .NET Core 2.2 is in preview at the time of this writing, and can be downloaded from the <a href="https://www.microsoft.com/net/download/dotnet-core/2.2">.NET Core 2.2 downloads</a>.
</p></blockquote><p>The project file for the sample app lists the packages:</p><h2>Creating Azure Cosmos DB</h2><p>Before building the application, I’m creating a new Azure Cosmos DB account:</p><p><img src="https://csharpdotchristiannageldotcom.files.wordpress.com/2018/08/cosmos_01_create.png?w=672" alt="Create Azure Cosmos DB Account"></p><p>Creating an Azure Cosmos DB account, you need to decide and select one of the APIs:</p><ul><li>SQL</li><li>MongoDB</li><li>Cassandra</li><li>Azure Table</li><li>Gremlin (graph)</li></ul><p>Azure Cosmos DB offers different storage technologies, such as <em>JSON documents</em>, <em>table storage</em>, and storing relations using a <em>graph API</em>. <em>SQL</em> is the successor of <em>DocumentDB</em>, and this is where this new provider can be used.</p><p>To access this account from the provider, from the portal the URI and the key is needed. All this information can be accessed by selecting the <em>Keys</em> settings from the portal.</p><p><img src="https://csharpdotchristiannageldotcom.files.wordpress.com/2018/08/cosmos_02_keys.png?w=672" alt="Use Keys and URI"></p><p>I’m adding the service endpoint from the Azure Cosmos DB account and a database name to the JSON configuration file <code>appsettings.json</code>:</p><p>I’m not directly adding the key to the JSON configuration file, but instead use <em>app secrets</em>. Because an identifier for app secrets (<code>UserSecretsId</code>) was added to <code>CosmosDBWithEFCore.csproj</code>, and the NuGet package <code>Microsoft.Extensions.Configuration.UserSecrets</code> was added, the dotnet CLI can be used to configure the authentication key:</p><p><code>dotnet user-secrets set CosmosSettings:AuthKey "add your auth-key from Azure Cosmos DB"</code></p><h2>EF Core Context and Model and Services</h2><p>Next, I’m creating the EF Core context and the model. The model is defined with the <code>Book</code> class and simple properties:</p><p>The EF Core <code>BooksContext</code> does not differ to other EF Core contexts that are used with SQL Server:</p><p>The class <code>BooksService</code> is used to read and write <code>Book</code> objects. It’s not different to other services using an EF Core context. With the constructor, the <code>BooksContext</code> is injected. This context is used when creating the database, adding new <code>Book</code> objects, and creating a query to read the <code>Book</code> objects:</p><blockquote><p>
  First I tried to create the database and the collection in the portal. However, I didn’t see how to map the names at first, and documentation was not existing yet. It turned out that creating the database directly from EF Core is already working which helped finding the default database name.
</p></blockquote><p>The dependency injection container is configured in the <code>Program</code> class. Having the NuGet package for the EF Core provider for Azure Cosmos DB referenced, allows using the <code>UseCosmos</code> extension method. This method needs the configuration for the service endpoint, the key, and the database name. These settings are coming from <code>appsettings.json</code>, and the app secrets.</p><p>The <code>Main</code> method just connects everything together. First, the DI container is configured. The <code>BooksService</code> is returned from the container to a) create the database, b) write book records, and to c) query books.</p><h2>Running the App</h2><p>Running the app results in creation of the database with the name passed to the <code>UseCosmos</code> method, and the collection with the name of the context. You can see this in the Azure Portal.</p><p><img src="https://csharpdotchristiannageldotcom.files.wordpress.com/2018/08/cosmos_03_databaseandcollection.png?w=672" alt="Azure Cosmos DB database created"></p><p>Using the Azure Cosmos DB Data Explorer, you can see all the book objects created.</p><p><img src="https://csharpdotchristiannageldotcom.files.wordpress.com/2018/08/cosmos_04_dataexplorer.png?w=672" alt="Azure Cosmos DB Data Explorer"></p><blockquote><p>
  With the collection name, you can change a different default, or assign a collection name for an entity using the <code>ModelBuilder</code>.
</p></blockquote><h2>Accessing Azure Cosmos DB generated values</h2><p>A book is represented within Cosmos DB with the properties defined in the model, and some additional properties used by Azure Cosmos DB:</p><p>Here’s some information about these values:</p><ul><li>etag – This is the resource etag,  required for optimistic concurrency. This value is changed with every update.</li><li>id – A unique name with a max length of 255 characters. This value, must be set on insert, and be unique within the database. Using EF Core, it has the same value as specified by the key in the model.</li><li>rid – This is a system generated hierarchical unique identifier, and used for navigation.</li><li>ts – The timestamp shows the last update time.</li><li>self – An addressable url to the document.</li><li>attachment – Documents can have attachments. This value gives references to attachment resources.</li></ul><blockquote><p>
  The type of the class is stored with the <strong>Discriminator</strong> value. Don’t be tempted to use different collections for every type. You can save different types in the same collection. Retrieving objects on the type is fast, this information is indexed. Calculate costs for Azure Cosmos DB per collection.
</p></blockquote><p>Using EF Core, you can either add properties to your model to retrieve these values, or create <strong>shadow properties</strong> in the context definition.</p><p>These shadow properties can be retrieved using the <code>Entry</code> method of the <code>DbContext</code>:</p><h2>Summary</h2><p>This just have been the first experiments using Azure Cosmos DB using the new EF Core provider. Azure Cosmos DB integrates nicely into EF Core. You’re creating the models and the context as you are used to, and can create the database, write documents, and create queries.<br>Additional properties such as the etag and self implemented by Azure Cosmos DB do not need to be part of your model, but can be easily retrieved using the <em>shadow properties</em> from EF Core.</p><p>Expect more information on EF Core and Azure Cosmos DB to come in the following months.</p><p>If you’ve read this far, consider buying me a coffee which helps me staying up longer and writing more articles.</p><p><a href="https://www.buymeacoffee.com/christiannagel" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png" alt="Buy Me A Coffee"></a></p><p>More information on EF Core and writing data-driven applications is in my book <a href="https://csharp.christiannagel.com/2018/04/16/professionalcsharp7/">Professional C# 7 and .NET Core 2.0</a>, and in my <a href="https://cninnovation.com/Training/Data">Data Programming workshops</a>.</p><p>Enjoy learning and programming!</p><p>Christian</p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>