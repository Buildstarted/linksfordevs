<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Mistaeks I Hav Made: Mistakes we made adopting event sourcing (and how we recovered) -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Mistaeks I Hav Made: Mistakes we made adopting event sourcing (and how we recovered)</h1>
    <div><div id="article"> <p>Over the last year or so we have been building a new system that has an <a href="https://martinfowler.com/eaaDev/EventSourcing.html">event-sourced</a> architecture. Event-sourcing is a good fit for our needs because the organisation wants to preserve an accurate history of information managed by the system and analyse it for (among other things) fraud detection. When we started, however, none of us had built a system with an event-sourced architecture before. Despite reading plenty of advice on what to do and what to avoid, and experience reports from other projects, we made some significant mistakes in our design. This article describes where we went wrong, in the hope that others can learn from our failures.</p> <p>But it&#x2019;s not all bad news. We were able to recover from our mistakes with an ease that surprised us. I&#x2019;ll also describe the factors that allowed us to easily change our architecture, in the hope that others can learn from our successes too.</p> <section id="mistakes" class="level2"> <section id="not-separating-persisting-the-event-history-and-persisting-a-view-of-the-current-state" class="level3"> <p>The app maintained a relational model of the current state of its entities alongside the event history. That in itself wouldn&#x2019;t be a bad thing, if it had been implemented as a &#x201C;projection&#x201D; of the events. However, we implemented the current state by making the command handlers both record events and update the relational model. This meant that (a) there was nothing to ensure that entity state could be rebuilt from the recorded events, and (b) managing the migrations of the relational model was a significant overhead while the app was in rapid flux.</p>
<p>Surely this was missing the entire point of adopting event-sourcing?</p>
<p>Well&#x2026; yes. People came to the project with different backgrounds and technical preferences. There was a creative tension that led to an initial design the team was comfortable with, rather than one that was &#x201C;by the book&#x201D; for any specific book. Some of us did notice the architecture diverging from what the event-sourcing literature described, but didn&#x2019;t react immediately. We wanted the team (ourselves included) to build an intuition for the advantages, disadvantages and trade-offs inherent in an event-sourced architecture, rather than apply patterns cookie-cutter style. And we didn&#x2019;t know how this hybrid architecture would work out &#x2013; it could have been very successful for all we knew &#x2013; so we didn&#x2019;t want to dismiss the idea based only on a theoretical understanding gleaned from technical articles &amp; conference sessions. Therefore we continued down this road until the difficulties outlined above were clearly outweighing the benefits. Then we had a technical retrospective in which we examined the differences between canonical event-sourcing and our architecture. The outcome was that we all understood why canonical event-sourcing would work better than our application&#x2019;s current design, and agreed to change its architecture to match.</p>
</section>
<section id="confusion-between-event-driven-and-event-sourced-architecture" class="level3"> <p>In an event-driven architecture, components perform activity in response to receiving events and emit events to trigger activities in other components. In an event-sourced architecture, components record a history of events that occurred to the entities they manage, and calculate the state of an entity from the sequence of events that relate to it.</p>
<p>We got confused between the two, and had events recorded in the history by one component triggering activity in others.</p>
<p>We realised we&#x2019;d made a mistake when we had to make entities distinguish between reading an event in order to react to it, and reading an event in order to know what happened in the past.</p>
<p>This also led to us&#x2026;</p>
</section>
<section id="using-the-event-store-as-a-message-bus" class="level3"> <p>We added notifications to our event store so services could subscribe to updates and keep their projection up to date. Bad idea! Our event store started being used as an event bus for transient communication between components, and our history included technical events that had no clear relationship to the business process. We noticed that we had to filter technical events out of the history displayed to users. For example, we had events in the history about technical things like &#x201C;attempt to send email failed with an IOException&#x201D;, which users didn&#x2019;t care about. They wanted to see the history of the business process, not technical jibber-jabber.</p>
<p>The literature describes event-sourced and event-driven architectures as orthogonal, and that tripped us up. We came to realise that clearly distinguishing between commands that trigger activity and events that represent what happened in the past is even more important than Command/Query Responsibility Segregation, especially at the modest scale and strict consistency requirements of our system. The word &#x201C;event&#x201D; is such an overused term we had many discussions about how to name different kinds of event to distinguish between those that are part of the event-sourcing history, those that are emitted by our active application monitoring, those that are notifications that should trigger activity, and so on. In our new applications we use the term <em>Business Process Event</em> for events recorded in our event-sourcing history.</p>
</section>
<section id="seduced-by-eventual-consistency" class="level3"> <p>Initially we gave the event store an HTTP interface and application components used it to read and store events. However, that meant that clients couldn&#x2019;t process events in ACID transactions and we found ourselves building mechanisms in the application to maintain consistency.</p>
</section>
</section> <section id="noticing-our-mistakes" class="level2"> <p>Luckily we caught these mistakes early during a regular architecture &#x201C;<a href="https://www.hp-lexicon.org/thing/wizengamot/">wizengamot</a>&#x201D; before our design decisions had affected the event history of our live system.</p>
<p>We decided to replace our use of HTTP between command processors and the event store with direct database connections and serialisable transactions. We kept the HTTP service for traversing the event history, but only for peripheral services that maintain read-optimised views that can be eventually consistent (daily reports, business metrics, that kind of thing).</p>
<p>We decided to stop using notifications from the event store to trigger activity and went back to REST (particularly <a href="https://en.m.wikipedia.org/wiki/HATEOAS">HATEOAS</a>) for passing data and control between components.</p>
<p>We decided to not update the record of the current state of the entities in command handlers. Instead the application computes the current state from the event history when the entity is loaded from the database. The application still maintains a &#x201C;projection&#x201D; of the current entity states, but treats the projection as a read-through cache, used to optimise loading entities, so that it doesn&#x2019;t have to load all of an entity&#x2019;s events on every transaction, and to select subsets of the currently active entities, so that it doesn&#x2019;t have to load all events of all entities. Entries are expired from the cache by events: each projection is a set of tables and function is passed each event and creates, updates and deletes rows in its tables in response.</p>
<p>Logic to execute commands now looks like:</p>
<ol type="1">
<li>Load the recent state of the entity into an in-memory model</li>
<li>In a write transaction
<ol type="1">
<li>load events that occurred to the entity since the recent projection into the in-memory model</li>
<li>perform business logic</li>
<li>record events resulting from executing the command</li>
</ol></li>
<li>Save the in memory state as the most recent projection if it was created from more recent events than that the projection that is currently persisted (the persisted state may have been updated by a concurrent command)</li>
</ol>
<p>Read transactions don&#x2019;t record events and can therefore run in parallel with each other and write transactions.</p>
<p>We decided to replace the relational model, which required so much effort to migrate as the app evolved, with JSON blobs serialised from the domain model that can be automatically discarded and rebuilt when the persisted state becomes incompatible with the latest version of the application. Thanks to Postgres&#x2019; <a href="https://www.postgresql.org/docs/9.5/datatype-json.html">JSONB</a> columns, we can still index properties of entity state and select entities in bulk without adding columns of denormalised data for filtering.</p>
<p>The application also maintains projections for other uses, which have less stringent consistency requirements. For example, we update projections for reporting in the background on a regular schedule.</p>
</section> <section id="re-engineering-the-system-architecture" class="level2"> <p>We were concerned that such significant changes to the systems architecture would deliver a blow to our delivery schedule. But it turned out to be very straightforward. The reasons why are orthogonal to event-sourcing.</p>
<p>As well as using event-sourcing, the application has a Ports-and-Adapters (aka &#x201C;hexagonal&#x201D;) architecture. Loading the current state of an entity was hidden from the application logic behind a Port interface that was implemented by an Adapter class. My colleague, <a href="https://www.linkedin.com/in/s4nchez/">Ivan Sanchez</a>, was able to switch the app over to calculating an entity&#x2019;s current state from its event history and treating persistent entity state as a read through cache (as described above) in about <em>one hour</em>. The team then replaced the relational model, which required so much effort to migrate as the app evolved, with JSON blobs serialised from the domain model that could be automatically discarded and rebuilt when the persisted state became incompatible with the latest version of the application. The change was live by the end of the day.</p>
<p>We also have extensive functional tests that run in our continuous deployment pipelines. These were <a href="https://www.youtube.com/watch?v=Fk4rCn4YLLU">written to take advantage of the Ports-and-Adapters architecture</a>, a style we call &#x201C;Domain-Driven Tests&#x201D;. They capture the functional behaviour of the application in terms of users needs and concepts from the problem domain, without referring to details of the technical infrastructure of the application. They can be run against the domain model, in memory, against the HTTP interfaces of the application services, or through the browser, against an instance running on a developer workstation or one deployed into our cloud environment.</p>
<p>The functional tests serve two purposes that paid off handsomely when we had to make significant changes to the application&#x2019;s architecture.</p>
<p>Firstly, they force us to follow the Ports-and-Adapters architecture. Our tests cannot refer to details of the application&#x2019;s technical underpinnings (HTTP, database, user interface controls, HTML, JSON, etc). We get early warning if we violate the architectural constraints by, say, writing business logic in the HTTP adapter layer, because it becomes impossible to write a test that can run against the domain model alone.</p>
<p>As a result, changes to the technical architecture of the application were strictly segregated from the definition and implementation of its functional behaviour, neither of which needed to be changed when we changed the architecture. This allowed them to fulfil their second purpose: to rapidly verify that the application still performs the same user visible behaviour as we made large changes to its architecture.</p>
</section> <section id="conclusions" class="level2"> <p>It&#x2019;s inevitable that you&#x2019;re going to make mistakes when implementing a system, especially when adopting a new architectural style with which the team are not familiar. A system&#x2019;s architecture has to address how you recover from those mistakes.</p>
<p>In our case, using the Ports and Adapters style, with which the team had a lot of experience, and considering test and deployment infrastructure as an essential part of the system architecture allowed us to adopt Event Sourcing, with which we were entirely unfamiliar, and recover from our misunderstandings as the system evolved.</p>
</section> <section id="acknowledgements" class="level2"> <p>Thanks to <a href="http://oneeyedmen.com/">Duncan McGregor</a>, <a href="https://dannorth.net/">Dan North</a>, <a href="https://medium.com/exortech">Owen Rogers</a> &amp; <a href="https://blog.danielwellman.com/">Daniel Wellman</a> for their detailed and valuable feedback.</p>
</section> </div><div id="about"> <p> Copyright &#xA9; 2019 Nat Pryce. Posted 2019-06-30. <a href="http://www.reddit.com/submit?url=http://natpryce.com/articles/000819.html&amp;title=Mistakes we made adopting event sourcing (and how we recovered)">Share it.</a></p> </div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>