<!DOCTYPE html>
<html lang="en">
<head>
    <title>
(De)serialization support for quoted numbers &#xB7; Issue #30255 &#xB7; dotnet/runtime &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>(De)serialization support for quoted numbers  · Issue #30255 · dotnet/runtime · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>For 5.0 we can consider an option to support "looser" deserialization modes depending on how common these scenarios are, and whether we can agree on common semantics.</p><p>However I believe all such modes can be supported today by using custom converters and by extending <code>JsonConverterAttribute</code> so that specific properties can be targeted (instead of all properties). For some cases it may be that there is no common consensus for the semantics so leaving it as-is and requiring the use of custom converters and custom attributes is the best solution. Perhaps doc and examples for common scenarios works too, or the community creates extensions for common scenarios.</p><p>A 5.0 feature could be to add a <code>options.DeserializeQuotedNumbers == true</code>. Then we need to determine if serializing as numbers is always desired, otherwise we'd need another option like <code>SerializeNumbersAsQuoted</code> (perhaps a flags enum would be easier to extend instead of separate option properties). There are subtleties here like do we account for culture settings? We'd also need a new attribute so that specific properties can be targeted instead of all through the global option.</p><p>Similarly, there has been feedback on what primitive types to deserialize when the property is a <code>System.Object</code>. Today that is <code>JsonElement</code>.  The requests have been to deserialize <a href="https://github.com/dotnet/corefx/issues/38713">true\false</a> as <code>System.Bool</code>, <a href="https://github.com/dotnet/corefx/issues/38713">numbers</a> as <code>System.Double</code> and strings as <code>System.String</code> instead of <code>JsonElement</code>.</p><p>Adding additional option(s) for this is also possible, however there are subtleties: precision can be lost (e.g. <code>System.Double</code> has less precision than <code>System.Decimal</code> -- what is the intent?) and when the JSON values belong to an object being deserialized into <code>System.Object</code>, the deserializer would still need to deserialize the object and all of its properties as <code>JsonElement</code> since it doesn't know what type to create and deserialize into (without getting into polymorphic deserialization, which is a separate feature).</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>