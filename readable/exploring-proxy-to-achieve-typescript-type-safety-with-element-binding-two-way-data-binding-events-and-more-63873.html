<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Exploring Proxy to Achieve TypeScript Type Safety with Element Binding, two way Data Binding, Events, and More - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Exploring Proxy to Achieve TypeScript Type Safety with Element Binding, two way Data Binding, Events, and More - linksfor.dev(s)"/>
    <meta property="article:author" content="Marc Clifton"/>
    <meta property="og:description" content="An Alice in Wonderland journey into the nuances of using Proxy with HTML and TypeScript classes."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.codeproject.com/Articles/5272881/Exploring-Proxy-to-Achieve-TypeScript-Type-Safety"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Exploring Proxy to Achieve TypeScript Type Safety with Element Binding, two way Data Binding, Events, and More</title>
<div class="readable">
        <h1>Exploring Proxy to Achieve TypeScript Type Safety with Element Binding, two way Data Binding, Events, and More</h1>
            <div>by Marc Clifton</div>
            <div>Reading time: 52-65 minutes</div>
        <div>Posted here: 06 Jul 2020</div>
        <p><a href="https://www.codeproject.com/Articles/5272881/Exploring-Proxy-to-Achieve-TypeScript-Type-Safety">https://www.codeproject.com/Articles/5272881/Exploring-Proxy-to-Achieve-TypeScript-Type-Safety</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>I have found it a useful exploration of how to leverage the Proxy type to bind class properties to models, achieve two way binding, subscribe to UI events, and so forth, all using actual "edit-time" types for type safety and Intellisense support - as in, no strings referencing DOM elements by their ID's.</p><div id="contentdiv">
						



<ul>
	<li><a href="https://www.codeproject.com/KB/applications/5272881/Demo.zip">Download demo - 63.4 KB</a></li></ul>

<p><img height="478" src="https://www.codeproject.com/KB/applications/5272881/titlescreen.png" width="504" alt="Image 1" data-sizes="auto" data-srcset="/KB/applications/5272881/titlescreen-r-400.png 400w, /KB/applications/5272881/titlescreen.png 504w" sizes="504px" srcset="/KB/applications/5272881/titlescreen-r-400.png 400w, /KB/applications/5272881/titlescreen.png 504w"></p>

<h2>Contents</h2>

<ul>
	<li><a href="#Introduction0">Introduction</a>

	<ul>
		<li><a href="#Pros1">Pros</a></li>		<li><a href="#Cons2">Cons</a></li>		<li><a href="#SoWhyBother3">So Why Bother?</a></li>	</ul>
	</li>	<li><a href="#WhatisaProxy4">What is a Proxy?</a>
	<ul>
		<li><a href="#ASimpleExample5">A Simple Example</a></li>		<li><a href="#ADOMExample6">A DOM Example</a></li>		<li><a href="#ThePointBeing...7">The Point Being...</a></li>	</ul>
	</li>	<li><a href="#AboutTheCode8">About The Code</a></li>	<li><a href="#SimpleDataBindingofInnerHTML9">Simple Data Binding of Inner HTML</a>
	<ul>
		<li><a href="#TheVueWay10">The Vue Way</a></li>		<li><a href="#TheIXWay11">The IX Way</a></li>	</ul>
	</li>	<li><a href="#ReactiveBehavior12">Reactive Behavior</a>
	<ul>
		<li><a href="#TheVueWay13">The Vue Way</a></li>		<li><a href="#TheIXWay14">The IX Way</a></li>	</ul>
	</li>	<li><a href="#Conditionals15">Conditionals</a>
	<ul>
		<li><a href="#TheVueWay16">The Vue Way</a></li>		<li><a href="#TheIXWay17">The IX Way</a></li>	</ul>
	</li>	<li><a href="#Loops18">Loops</a>
	<ul>
		<li><a href="#TheVueWay19">The Vue Way</a></li>		<li><a href="#TheIXWay20">The IX Way</a></li>	</ul>
	</li>	<li><a href="#ButtonClicks21">Button Clicks</a>
	<ul>
		<li><a href="#TheVueWay22">The Vue Way</a></li>		<li><a href="#TheIXWay23">The IX Way</a></li>	</ul>
	</li>	<li><a href="#DataConversion24">Data Conversion</a></li>	<li><a href="#TwoWayBinding25">Two Way Binding</a>
	<ul>
		<li><a href="#TheVueWay26">The Vue Way</a></li>		<li><a href="#TheIXWay27">The IX Way</a></li>	</ul>
	</li>	<li><a href="#Checkboxes28">Checkboxes</a>
	<ul>
		<li><a href="#BindingCheckboxState29">Binding Checkbox State</a>
		<ul>
			<li><a href="#TheVueWay30">The Vue Way</a></li>			<li><a href="#TheIXWay31">The IX Way</a></li>		</ul>
		</li>		<li><a href="#BindingCheckboxValues32">Binding Checkbox Values</a>
		<ul>
			<li><a href="#TheViewWay33">The View Way</a></li>			<li><a href="#TheIXWay34">The IX Way</a></li>		</ul>
		</li>	</ul>
	</li>	<li><a href="#RadioButtons35">Radio Buttons</a>
	<ul>
		<li><a href="#TheViewWay36">The View Way</a></li>		<li><a href="#TheIXWay37">The IX Way</a></li>	</ul>
	</li>	<li><a href="#ComboBoxes38">ComboBoxes</a>
	<ul>
		<li><a href="#TheVueWay39">The Vue Way</a></li>		<li><a href="#TheIXWay40">The IX Way</a></li>	</ul>
	</li>	<li><a href="#ImplementationPatterns41">Implementation Patterns</a>
	<ul>
		<li><a href="#IDandClassPropertyName42">ID and Class Property Name</a></li>		<li><a href="#KeyUp,Changed,andConvertEvents43">KeyUp, Changed, and Convert Events</a></li>		<li><a href="#SupportedEvents44">Supported Events</a>
		<ul>
			<li><a href="#KeyUp45">KeyUp</a></li>			<li><a href="#Changed46">Changed</a></li>			<li><a href="#Convert47">Convert</a></li>			<li><a href="#Hover48">Hover</a></li>		</ul>
		</li>	</ul>
	</li>	<li><a href="#IntegrationTests49">Integration Tests</a>
	<ul>
		<li><a href="#TheTestRunner50">The Test Runner</a></li>		<li><a href="#DefiningtheTests51">Defining the Tests</a></li>		<li><a href="#TheIXAssertHelper52">The IXAssert Helper</a></li>		<li><a href="#YouDon'tNeedTypeScriptClasses53">You Don't Need TypeScript Classes</a></li>	</ul>
	</li>	<li><a href="#BehindtheScenes54">Behind the Scenes</a>
	<ul>
		<li><a href="#TypeScriptDoesNotMeanRuntimeTypeReflection55">TypeScript Does Not Mean Runtime Type Reflection</a></li>		<li><a href="#ProxyInitialization56">Proxy Initialization</a>
		<ul>
			<li><a href="#CreatePropertyHandlers57">CreatePropertyHandlers</a></li>			<li><a href="#WireUpEventHandler58">WireUpEventHandler</a></li>			<li><a href="#CustomConverter59">CustomConverter</a></li>		</ul>
		</li>		<li><a href="#CreateButtonHandlers60">CreateButtonHandlers</a></li>		<li><a href="#CreateBinders61">CreateBinders</a></li>		<li><a href="#Initialize62">Initialize</a></li>		<li><a href="#Arrays63">Arrays</a></li>		<li><a href="#IXEvent64">IXEvent</a></li>		<li><a href="#IXTemplate65">IXTemplate</a></li>	</ul>
	</li>	<li><a href="#Conclusion66">Conclusion</a>
	<ul>
		<li><a href="#DoIneedaProxy67">Do I need a Proxy?</a></li>		<li><a href="#BothProxyandDOMWrapper68">Both Proxy and DOM Wrapper</a></li>		<li><a href="#TheFutureIsEmerging69">The Future Is Emerging</a></li>	</ul>
	</li></ul>

<h2><a name="Introduction0">Introduction</a></h2>

<p>I despise two things about front-end development:</p>

<ol>
	<li>Element ID's are string literals.</li>	<li>Javascript code in my HTML.</li>	<li>Javascript.</li>	<li>Actually anything having to do with front-end development, but that's life.</li></ol>

<p>Oh wait.&nbsp; That's four things.</p>

<p>When I started writing the code for this article, I ended up experience what something that <a href="https://www.presencing.org/aboutus/theory-u">Theory U</a> describes as "Leading From the Future As It Emerges."&nbsp; Riiiight.&nbsp; Nonetheless, this was my experience:</p>

<p><img height="299" src="https://www.codeproject.com/KB/applications/5272881/theu.png" width="533" alt="Image 2" data-src="/KB/applications/5272881/theu.png" data-sizes="auto" data-srcset="/KB/applications/5272881/theu-r-400.png 400w, /KB/applications/5272881/theu.png 533w" srcset="/KB/applications/5272881/theu-r-400.png 400w, /KB/applications/5272881/theu.png 533w"></p>

<p>So my "future" was discovering that the code I'm about to present here is, well, not what I would actually want to use, now that the future as arrived in the present and by the time I finished writing this article, I realized there's a lot of things I would do differently!&nbsp; Regardless, I have found it a useful exploration of how to leverage the Proxy type to bind class properties to models, achieve two way binding, subscribe to UI events, and so forth, all using actual "edit-time" types for type safety and Intellisense support - as in, no strings referencing DOM elements by their ID's.&nbsp; Thus "IX" is born, which is short for "Interacx", which was a WinForm suite of tools that I created a long time ago to automate data manipulation without using an ORM.&nbsp; I decided to repurpose the name since WinForm applications are, well, passe, and the reality is that the thing I despise, writing web apps, it where it's app, I mean, at.&nbsp; And for your endless amusement, I decided to use some Vue examples as comparison to the implementation I've developed here using proxies.</p>

<h3><a name="Pros1">Pros</a></h3>

<p>Working with the code I've developed here, I find several advantages:</p>

<ol>
	<li>I'm not hardcoding DOM ID string literals.</li>	<li>I'm able to leverage the type safety of TypeScript.</li>	<li>Being able to refer to DOM elements as object properties leverages Visual Studio's Intellisense.</li>	<li>It's really easy to wire up events and bindings.</li>	<li>It was quite easy to write unit tests - in fact, the unit tests are one of the more interesting aspects of this code, in my opinion.</li>	<li>I'm not putting "declarative code" in the HTML
	<ol>
		<li>The HTML remains completely clean.</li>		<li>The business logic is implemented in code.</li>		<li>You don't have to inspect both code and HTML to figure out what in the world is actually going on.</li>	</ol>
	</li>	<li>Point #6</li>	<li>Point #6</li>	<li>Point #6</li></ol>

<p>I cannot reiterate enough how important, at least to me, point #6 is.&nbsp; With a large web application, I have pulled my hair out bouncing between code and markup to figure out what the conditions, loops, and rendering is, and it is a frustrating experience.&nbsp; To me, the idea of including declarative syntax at the UI level that is driven by effectively business data/rules is bad, no horrible, design.&nbsp; It's why I don't use Razor or similar rendering engines.&nbsp; I personally think that arcane custom tags in the HTML, "if" and "loop" tags, etc., to control UI rendering is one of the worst ideas to come out of so-called modern web development.</p>

<h3><a name="Cons2">Cons</a></h3>

<p>So let's be realistic:</p>

<ol>
	<li>The syntax requires a specific mapping between the DOM element ID and the object's property name.</li>	<li>Proxies are slower.</li>	<li>The code to work with proxies is highly specialized.</li>	<li>The code to work with arrays is bizarre.</li>	<li>The code here is really incomplete with regards to all the DOM attributes, properties, and events that could be handled.</li>	<li>I have no idea whether the code here is actually robust enough to handle #4.</li>	<li>I have yet to explore whether this concept works well with third party widget libraries, my favorite being jqWidgets.</li>	<li>The "future" arrived rather late, basically by the time I was done writing this article.</li></ol>

<p>And I really doubt anyone is going to say, "ooh, let's use IX to build a major website", except perhaps for me!</p>

<h3><a name="SoWhyBother3">So Why Bother?</a></h3>

<ol>
	<li>I like to explore different ways to solve the warts of web development.</li>	<li>I haven't come across anyone else attempting this.</li>	<li>It's quite interesting to learn about proxies.</li>	<li>This was fun!</li></ol>

<h2><a name="WhatisaProxy4">What is a Proxy?</a></h2>

<p>A <code>Proxy</code>, at least in Javascript, is an object that replaces your object and lets you intercept the "get" and "set" methods.&nbsp; Read more about the <code>Proxy</code> object <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"> here</a>.&nbsp;</p>

<h3><a name="ASimpleExample5">A Simple Example</a></h3>

<p>I simple demonstration will suffice.&nbsp; First, a simple proxy stub that just does the get/set operations with console logging:</p>

<p><span id="prehide227371" onclick="processCodeBlocks.togglePre(227371);">Hide</span>  &nbsp; <span id="copycode227371" onclick="return processCodeBlocks.copyCode(227371);">Copy Code</span></p><pre id="pre227371">private myProxyHandler = {
  get: (obj, prop) =&gt; {
    console.log(`get ${prop}`);

    return obj[prop];
  },

  set: (obj, prop, val) =&gt; {
    console.log(`set ${prop} to ${val}`);
    obj[prop] = val;

    // Return true to accept change.
    return true;
  }
}</pre>

<p>And a simple test case:</p>

<p><span id="prehide294560" onclick="processCodeBlocks.togglePre(294560);">Hide</span>  &nbsp; <span id="copycode294560" onclick="return processCodeBlocks.copyCode(294560);">Copy Code</span></p><pre id="pre294560">let proxy = new Proxy({}, this.myProxyHandler);
proxy.foo = 1;
let foo = proxy.foo;
console.log(`foo = ${foo}`);</pre>

<p>and the output:</p>

<p><span id="prehide944555" onclick="processCodeBlocks.togglePre(944555);">Hide</span>  &nbsp; <span id="copycode944555" onclick="return processCodeBlocks.copyCode(944555);">Copy Code</span></p><pre id="pre944555">set foo to 1
get foo
foo = 1</pre>

<p>Ahh, feel the power!&nbsp; The world is now mine!</p>

<h3><a name="ADOMExample6">A DOM Example</a></h3>

<p>Now let's do something a little more interesting.&nbsp; We'll create a class with a property whose name matches a DOM element.&nbsp; The DOM element, with a label because input elements should have labels:</p>

<p><span id="prehide51384" onclick="processCodeBlocks.togglePre(51384);">Hide</span>  &nbsp; <span id="copycode51384" onclick="return processCodeBlocks.copyCode(51384);">Copy Code</span></p><pre id="pre51384">&lt;div class="inline marginTop5"&gt;
  &lt;div class="inline label"&gt;Name:&lt;/div&gt;
  &lt;div class="inline"&gt;&lt;input id="name"/&gt;&lt;/div&gt;
&lt;/div&gt;</pre>

<p><img height="28" src="https://www.codeproject.com/KB/applications/5272881/ex1.png" width="210" alt="Image 3" data-src="/KB/applications/5272881/ex1.png"></p>

<p>Exciting!</p>

<p>Now the class:</p>

<p><span id="prehide163694" onclick="processCodeBlocks.togglePre(163694);">Hide</span>  &nbsp; <span id="copycode163694" onclick="return processCodeBlocks.copyCode(163694);">Copy Code</span></p><pre id="pre163694">class NameContainer {
  name: string;
}</pre>

<p>And the new proxy:</p>

<p><span id="prehide360209" onclick="processCodeBlocks.togglePre(360209);">Hide</span>  &nbsp; <span id="copycode360209" onclick="return processCodeBlocks.copyCode(360209);">Copy Code</span></p><pre id="pre360209">private valueProxy = {
  get: (obj, prop) =&gt; {
    console.log(`get ${prop}`);

    return obj[prop];
  },

  set: (obj, prop, val) =&gt; {
    console.log(`set ${prop} to ${val}`);

    let el = document.getElementById(prop) as HTMLInputElement;
    el.value = val;
    obj[prop] = val;

    // Return true to accept change.
    return true;
  }
}</pre>

<p>Notice the only thing I've added is this:</p>

<p><span id="prehide463580" onclick="processCodeBlocks.togglePre(463580);">Hide</span>  &nbsp; <span id="copycode463580" onclick="return processCodeBlocks.copyCode(463580);">Copy Code</span></p><pre id="pre463580">let el = document.getElementById(prop) as HTMLInputElement;
el.value = val;</pre>

<p>Here the assumption is that the property name is the element ID!</p>

<p>Now we can set the value and it proxies to setting both the object's <code>name</code> property and the DOM <code>value</code> property:</p>

<p><span id="prehide292402" onclick="processCodeBlocks.togglePre(292402);">Hide</span>  &nbsp; <span id="copycode292402" onclick="return processCodeBlocks.copyCode(292402);">Copy Code</span></p><pre id="pre292402">let nc = new Proxy(new NameContainer(), this.valueProxy);
nc.name = "Hello World!";</pre>

<p>The result is:</p>

<p><img height="30" src="https://www.codeproject.com/KB/applications/5272881/ex2.png" width="208" alt="Image 4" data-src="/KB/applications/5272881/ex2.png"></p>

<p>What if I type something in and I want to see that value when I "get" the <code>name</code> property?&nbsp; Easy enough, the getter changes to this:</p>

<p><span id="prehide760177" onclick="processCodeBlocks.togglePre(760177);">Hide</span>  &nbsp; <span id="copycode760177" onclick="return processCodeBlocks.copyCode(760177);">Copy Code</span></p><pre id="pre760177">get: (obj, prop) =&gt; {
  console.log(`get ${prop}`);

  let el = document.getElementById(prop) as HTMLInputElement;
  let val = el.value;
  obj[prop] = val;

  return obj[prop];
},</pre>

<p>We can test the code by simulating a change the user made:</p>

<p><span id="prehide388727" onclick="processCodeBlocks.togglePre(388727);">Hide</span>  &nbsp; <span id="copycode388727" onclick="return processCodeBlocks.copyCode(388727);">Copy Code</span></p><pre id="pre388727">let nc = new Proxy(new NameContainer(), this.valueProxy);
nc.name = "Hello World!";

// Simulate the user having changed the input box:
let el = document.getElementById("name") as HTMLInputElement;
el.value = "fizbin";

let newName = nc.name;
console.log(`The new name is: ${newName}`);</pre>

<p>and in the console log, we see:</p>

<p><span id="prehide946459" onclick="processCodeBlocks.togglePre(946459);">Hide</span>  &nbsp; <span id="copycode946459" onclick="return processCodeBlocks.copyCode(946459);">Copy Code</span></p><pre id="pre946459">set name to Hello World!
get name
The new name is: fizbin</pre>

<p>It's important to note that <code>obj[prop] = val</code> makes the assignment on the non-proxy'd object, therefore the proxy <i>setter</i> does not get called.</p>

<h3><a name="ThePointBeing...7">The Point Being...</a></h3>

<ol>
	<li>I'm using types (and therefore Intellisense) to get/set the DOM element value.</li>	<li>I've eliminated the string literal for the name by assuming that the name of the class property is the same as the element ID.</li></ol>

<p>Snazzy!&nbsp; One small step for Marc, one giant leap for better front-end development!&nbsp; Unfortunately, getting to the moon requires a whole lot more effort, infrastructure, time, and a lot of disasters along the way (a pause here to recognize the lives that have been lost in space exploration, as I don't want to appear&nbsp; flippant about "disasters.")</p>

<p>So, let's start the journey down the slope of the U!</p>

<h2><a name="AboutTheCode8">About The Code</a></h2>

<p>The code is TypeScript with simple HTML and CSS, implemented in VS2017 solution.</p>

<p>The source code can also be found at: <a href="https://github.com/cliftonm/IX">https://github.com/cliftonm/IX</a></p>

<p>There are two HTML pages to play with:</p>

<ol>
	<li>index.html is the demo page</li>	<li>Tests/IntegrationTests.html runs the integration tests.</li></ol>

<h2><a name="SimpleDataBindingofInnerHTML9">Simple Data Binding of Inner HTML</a></h2>

<p>Let's start with simple data binding of the inner HTML associated with a <code>DIV</code>.</p>

<h3><a name="TheVueWay10">The Vue Way</a></h3>

<p><span id="prehide142981" onclick="processCodeBlocks.togglePre(142981);">Hide</span>  &nbsp; <span id="copycode142981" onclick="return processCodeBlocks.copyCode(142981);">Copy Code</span></p><pre id="pre142981">&lt;div id="app"&gt;
  {{ message }}
&lt;/div&gt;

var app = new Vue({
  el: '#app',
  data: {
   message: 'Hello Vue!'
  }
})</pre>

<p>What I don't like:</p>

<ol>
	<li>The "Mustache" <code>{{ }}</code> usage.</li>	<li>The <code>#app</code>.</li>	<li>The whole <code>data</code> object thing.</li></ol>

<h3><a name="TheIXWay11">The IX Way</a></h3>

<p><span id="prehide176952" onclick="processCodeBlocks.togglePre(176952);">Hide</span>  &nbsp; <span id="copycode176952" onclick="return processCodeBlocks.copyCode(176952);">Copy Code</span></p><pre id="pre176952">&lt;div id="app"&gt;&lt;/div&gt;

let form = IX.CreateNullProxy(); // No associated view model.
form.app = "Hello Interacx!";</pre>

<p><img height="26" src="https://www.codeproject.com/KB/applications/5272881/helloIX.png" width="114" alt="Image 5" data-src="/KB/applications/5272881/helloIX.png"></p>

<p>That's it.</p>

<h2><a name="ReactiveBehavior12">Reactive Behavior</a></h2>

<p>The next example is displaying some realtime computed value as part of a SPAN title.</p>

<h3><a name="TheVueWay13">The Vue Way</a></h3>

<p><span id="prehide698794" onclick="processCodeBlocks.togglePre(698794);">Hide</span>  &nbsp; <span id="copycode698794" onclick="return processCodeBlocks.copyCode(698794);">Copy Code</span></p><pre id="pre698794">&lt;div id="app-2"&gt;
  &lt;span v-bind:title="message"&gt;
    Hover your mouse over me for a few seconds
    to see my dynamically bound title!
  &lt;/span&gt;
&lt;/div&gt;

var app2 = new Vue({
  el: '#app-2',
  data: {
    message: 'You loaded this page on ' + new Date().toLocaleString()
  }
})</pre>

<h3><a name="TheIXWay14">The IX Way</a></h3>

<p><span id="prehide674840" onclick="processCodeBlocks.togglePre(674840);">Hide</span>  &nbsp; <span id="copycode674840" onclick="return processCodeBlocks.copyCode(674840);">Copy Code</span></p><pre id="pre674840">&lt;span id="mySpan"&gt;However your mouse over me for a few seconds to see the dynamically bound title!&lt;/span&gt;

class HoverExample {
  mySpan = {
    attr: { title: "" }
  };

  onMySpanHover = new IXEvent();
}

let form = IX.CreateProxy(new HoverExample());
form
  .onMySpanHover
  .Add(() =&gt; 
    hform.mySpan.attr.title = `You loaded this page on ${new Date().toLocaleString()}`);</pre>

<p>More verbose but the benefit is that you're using a repeatable pattern of using a multicast event handler.&nbsp; I did have an implementation where I could just set the title as a function, but I didn't like the one-off implementation behind the scenes that this required.</p>

<h2><a name="Conditionals15">Conditionals</a></h2>

<p>I also really don't like to make a mess of the markup with declarative code elements.</p>

<h3><a name="TheVueWay16">The Vue Way</a></h3>

<p><span id="prehide438805" onclick="processCodeBlocks.togglePre(438805);">Hide</span>  &nbsp; <span id="copycode438805" onclick="return processCodeBlocks.copyCode(438805);">Copy Code</span></p><pre id="pre438805">&lt;div id="app-3"&gt;
  &lt;span v-if="seen"&gt;Now you see me&lt;/span&gt;
&lt;/div&gt;

var app3 = new Vue({
  el: '#app-3',
  data: {
    seen: true
  }
})</pre>

<h3><a name="TheIXWay17">The IX Way</a></h3>

<p>In IX, conditional behaviors are implemented through the event mechanism, usually to manipulate element attributes.&nbsp; Diverging slightly from the Vue example above, note the addition of two buttons to toggle the visibility of the <code>SPAN</code>:</p>

<p><span id="prehide390119" onclick="processCodeBlocks.togglePre(390119);">Hide</span>  &nbsp; <span id="copycode390119" onclick="return processCodeBlocks.copyCode(390119);">Copy Code</span></p><pre id="pre390119">&lt;span id="seen"&gt;Now you see me...&lt;/span&gt;
 &lt;!-- Two ways to declare a button --&gt;
&lt;button id="show"&gt;Show&lt;/button&gt;
&lt;input id="hide" type="button" value="Hide" /&gt;


class VisibilityExample {
  seen = {
    attr: { visible: true }
  };


  onShowClicked = new IXEvent().Add((_, p) =&gt; p.seen.attr.visible = true);
  onHideClicked = new IXEvent().Add((_, p) =&gt; p.seen.attr.visible = false);
}

IX.CreateProxy(new VisibilityExample());</pre>

<p>These are wired up to two buttons, hence the event handlers.</p>

<p>Here:</p>

<ol>
	<li>We have a consistent way of manipulating element attributes.</li>	<li>Intellisense works perfectly in Visual Studio.</li>	<li>No "string" element name.</li></ol>

<h2><a name="Loops18">Loops</a></h2>

<h3><a name="TheVueWay19">The Vue Way</a></h3>

<p><span id="prehide258202" onclick="processCodeBlocks.togglePre(258202);">Hide</span>  &nbsp; <span id="copycode258202" onclick="return processCodeBlocks.copyCode(258202);">Copy Code</span></p><pre id="pre258202">&lt;div id="app-4"&gt;
  &lt;ol&gt;
    &lt;li v-for="todo in todos"&gt;
      {{ todo.text }}
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

var app4 = new Vue({
  el: '#app-4',
  data: {
    todos: [
      { text: 'Learn JavaScript' },
      { text: 'Learn Vue' },
      { text: 'Build something awesome' }
    ]
  }
})</pre>

<h3><a name="TheIXWay20">The IX Way</a></h3>

<p><span id="prehide26757" onclick="processCodeBlocks.togglePre(26757);">Hide</span>  &nbsp; <span id="copycode26757" onclick="return processCodeBlocks.copyCode(26757);">Copy Code</span></p><pre id="pre26757">&lt;ol id="someList"&gt;&lt;/ol&gt;

class ListExample {
  someList: string[] = ["Learn Javascript", "Learn IX", "Wear a mask!"];
}

IX.CreateProxy(new ListExample());</pre>

<p>Result:</p>

<p><img height="91" src="https://www.codeproject.com/KB/applications/5272881/loop1.png" width="152" alt="Image 6" data-src="/KB/applications/5272881/loop1.png"></p>

<p>Given that most lists come from a data source rather being hard coded:</p>

<p><span id="prehide126670" onclick="processCodeBlocks.togglePre(126670);">Hide</span>  &nbsp; <span id="copycode126670" onclick="return processCodeBlocks.copyCode(126670);">Copy Code</span></p><pre id="pre126670">&lt;ol id="someList"&gt;&lt;/ol&gt;

class ListExample {
  someList: string[] = [];
}

let listForm = IX.CreateProxy(new ListExample());

listForm.someList.push("Learn Javascript");
listForm.someList.push("Learn IX");
listForm.someList.push("Wear a mask!");</pre>

<p>Or:</p>

<p><span id="prehide195583" onclick="processCodeBlocks.togglePre(195583);">Hide</span>  &nbsp; <span id="copycode195583" onclick="return processCodeBlocks.copyCode(195583);">Copy Code</span></p><pre id="pre195583">let listForm = IX.CreateProxy(new ListExample());
let items = ["Learn Javascript", "Learn IX", "Wear a mask!"];
listForm.someList = items;</pre>

<h2><a name="ButtonClicks21">Button Clicks</a></h2>

<h3><a name="TheVueWay22">The Vue Way</a></h3>

<p><span id="prehide731715" onclick="processCodeBlocks.togglePre(731715);">Hide</span>  &nbsp; <span id="copycode731715" onclick="return processCodeBlocks.copyCode(731715);">Copy Code</span></p><pre id="pre731715">&lt;div id="app-5"&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;button v-on:click="reverseMessage"&gt;Reverse Message&lt;/button&gt;
&lt;/div&gt;

var app5 = new Vue({
  el: '#app-5',
  data: {
  message: 'Hello Vue.js!'
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
    }
  }
})</pre>

<h3><a name="TheIXWay23">The IX Way</a></h3>

<p><span id="prehide892460" onclick="processCodeBlocks.togglePre(892460);">Hide</span>  &nbsp; <span id="copycode892460" onclick="return processCodeBlocks.copyCode(892460);">Copy Code</span></p><pre id="pre892460">&lt;div&gt;
  &lt;p id="message"&gt;&lt;/p&gt;
  &lt;button id="reverseMessage"&gt;Reverse Message&lt;/button&gt;
&lt;/div&gt;

class ReverseExample {
  message = "Hello From Interacx!";
  onReverseMessageClicked = new IXEvent()
    .Add((_, p: ReverseExample) =&gt; p.message = p.message.split('').reverse().join(''));
}

IX.CreateProxy(new ReverseExample());</pre>

<p>Again, notice:</p>

<ol>
	<li>No "Mustache" {{ }} syntax required.</li>	<li>No "#id" string to identify the element ID.</li>	<li>The event mechanism, being multicast, allows us to wire up more than one event (not illustrated, but that's point of using events.)</li></ol>

<p><img height="54" src="https://www.codeproject.com/KB/applications/5272881/r1.png" width="170" alt="Image 7" data-src="/KB/applications/5272881/r1.png"></p>

<p>After clicking on the button:</p>

<p><img height="52" src="https://www.codeproject.com/KB/applications/5272881/r2.png" width="161" alt="Image 8" data-src="/KB/applications/5272881/r2.png"></p>

<h2><a name="DataConversion24">Data Conversion</a></h2>

<p>The following example is similar to Vue's <code>.number</code> attribute but the actual implementation is much more general purpose.</p>

<p>Consider this UI:</p>

<p><img height="52" src="https://www.codeproject.com/KB/applications/5272881/convert.png" width="548" alt="Image 9" data-src="/KB/applications/5272881/convert.png" data-sizes="auto" data-srcset="/KB/applications/5272881/convert-r-400.png 400w, /KB/applications/5272881/convert.png 548w" srcset="/KB/applications/5272881/convert-r-400.png 400w, /KB/applications/5272881/convert.png 548w"></p>

<p>And the markup (CSS and extraneous DIV's removed for readability):</p>

<p><span id="prehide917010" onclick="processCodeBlocks.togglePre(917010);">Hide</span>  &nbsp; <span id="copycode917010" onclick="return processCodeBlocks.copyCode(917010);">Copy Code</span></p><pre id="pre917010">X:
&lt;input id="x" class="fieldInputSmall" /&gt;
Y:
&lt;input id="y" class="fieldInputSmall" /&gt;</pre>

<p>Here, we do not want the strings "1" and "2" to sum to "12", so we implement converters:</p>

<p><span id="prehide187530" onclick="processCodeBlocks.togglePre(187530);">Hide</span>  &nbsp; <span id="copycode187530" onclick="return processCodeBlocks.copyCode(187530);">Copy Code</span></p><pre id="pre187530">class InputForm {
  x: number;
  y: number;

  onXChanged = new IXEvent();
  onYChanged = new IXEvent();

  // Converters, so 1 + 2 != '12'
  onConvertX = x =&gt; Number(x);
  onConvertY = y =&gt; Number(y);

  Add = () =&gt; this.x + this.y;
}

class OutputForm {
  sum: number;
}</pre>

<p>And the events are wired up like this:</p>

<p><span id="prehide549178" onclick="processCodeBlocks.togglePre(549178);">Hide</span>  &nbsp; <span id="copycode549178" onclick="return processCodeBlocks.copyCode(549178);">Copy Code</span></p><pre id="pre549178">let inputForm = IX.CreateProxy(new InputForm());
let outputForm = IX.CreateProxy(new OutputForm());

inputForm.onXChanged.Add(() =&gt; outputForm.sum = inputForm.Add());
inputForm.onYChanged.Add(() =&gt; outputForm.sum = inputForm.Add());</pre>

<p>Behind the scenes, the input box text is converted to a <code>Number</code> with the <code>onConvertX</code> and <code>onConvertY</code> converters, and the rest is handled by the standard data binding of the properties for setting <code>sum</code> to the values of x and y.</p>

<p>Also, notice how you can create classes as containers to sections of the HTML.&nbsp; We could easily have put <code>sum</code> in the <code>InputForm</code>, but instead I wanted to illustrate how to use a separate container object, <code>OutputForm</code>, as a way of compartmentalizing the properties into separate containers.</p>

<h2><a name="TwoWayBinding25">Two Way Binding</a></h2>

<p>We've already seen in the examples above binding between the view and the model.&nbsp; One of Vue's examples is direct update of one element based on the realtime update of an input element.&nbsp; While I can't think of a real-life example where one would need this, real-time updating, say of a filter criteria, is definitely useful, so we'll start with the Vue example:</p>

<h3><a name="TheVueWay26">The Vue Way</a></h3>

<p><span id="prehide621046" onclick="processCodeBlocks.togglePre(621046);">Hide</span>  &nbsp; <span id="copycode621046" onclick="return processCodeBlocks.copyCode(621046);">Copy Code</span></p><pre id="pre621046">&lt;div id="app-6"&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
    &lt;input v-model="message"&gt;
  &lt;/div&gt;

var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})</pre>

<h3><a name="TheIXWay27">The IX Way</a></h3>

<p>This is already easily accomplished with events:</p>

<p><span id="prehide772211" onclick="processCodeBlocks.togglePre(772211);">Hide</span>  &nbsp; <span id="copycode772211" onclick="return processCodeBlocks.copyCode(772211);">Copy Code</span></p><pre id="pre772211">First Name:
&lt;p id="message2"&gt;/p&gt;
&lt;input id="input2"/&gt;

class BidirectionalExample {
  message2: string = "";
  input2: string = "";

  onInput2KeyUp = new IXEvent().Add((v, p: BidirectionalExample) =&gt; p.message2 = v);
}

IX.CreateProxy(new BidirectionalExample());</pre>

<p><img height="48" src="https://www.codeproject.com/KB/applications/5272881/keyUp.png" width="171" alt="Image 10" data-src="/KB/applications/5272881/keyUp.png"></p>

<p>However, to make this more "Vue-ish", we can do:</p>

<p><span id="prehide360610" onclick="processCodeBlocks.togglePre(360610);">Hide</span>  &nbsp; <span id="copycode360610" onclick="return processCodeBlocks.copyCode(360610);">Copy Code</span></p><pre id="pre360610">class BidirectionalExample {
  message2 = new IXBinder({ input2: null });
  input2: string = "";</pre>

<p>Here we are specifying the "from" element as the key and any "value" of the key.&nbsp; What displeases me about this is that the key cannot be implemented a way that leverages Intellisense and type checking.&nbsp; The best we can do is runtime checking that the "from" binder element exists.&nbsp; So at this point, specifying the "bind from" property as a string almost makes sense.&nbsp; Instead, I opted for this implementation:</p>

<p><span id="prehide913271" onclick="processCodeBlocks.togglePre(913271);">Hide</span>  &nbsp; <span id="copycode913271" onclick="return processCodeBlocks.copyCode(913271);">Copy Code</span></p><pre id="pre913271">class BidirectionalExample {
  input2: string = "";
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  onInput2KeyUp = new IXEvent().Add((v, p: BidirectionalExample) =&gt; p.message2 = v);
}</pre>

<p>Which is somewhat lame as well but has the advantage of supporting Intellisense, albeit the property your binding to must already be declared previously.&nbsp; Behind the scenes, we have a very simple implementation to extract the name, by converting the function into a string:</p>

<p><span id="prehide81101" onclick="processCodeBlocks.togglePre(81101);">Hide</span>  &nbsp; <span id="copycode81101" onclick="return processCodeBlocks.copyCode(81101);">Copy Code</span></p><pre id="pre81101">public static nameof&lt;TResult&gt;(name: () =&gt; TResult): string {
  let ret = IX.RightOf(name.toString(), ".");

  return ret;
}</pre>

<p>Sadly that's seems to be the best we can do with Javascript unless you want to use something like <a href="https://github.com/dsherret/ts-nameof">ts-nameof</a>, which I do not because ts-nameof is a compile-time transformation, and I do not want the developer that uses this library to have to go through hoops to get this to work.</p>

<p>We can also bind the same source to different targets:</p>

<p><span id="prehide415715" onclick="processCodeBlocks.togglePre(415715);">Hide</span>  &nbsp; <span id="copycode415715" onclick="return processCodeBlocks.copyCode(415715);">Copy Code</span></p><pre id="pre415715">&lt;p&gt;
  &lt;label id="message2"&gt;&lt;/label&gt;
  &lt;label id="message3"&gt;&lt;/label&gt;
&lt;/p&gt;
&lt;input id="input2" /&gt;

class BidirectionalExample {
  input2: string = "";
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  message3 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
}</pre>

<p>As well as different sources to the same target:</p>

<p><span id="prehide484569" onclick="processCodeBlocks.togglePre(484569);">Hide</span>  &nbsp; <span id="copycode484569" onclick="return processCodeBlocks.copyCode(484569);">Copy Code</span></p><pre id="pre484569">&lt;p&gt;
  &lt;label id="message2"&gt;&lt;/label&gt;
  &lt;label id="message3"&gt;&lt;/label&gt;
&lt;/p&gt;
&lt;input id="input2" /&gt;
&lt;input id="input3" /&gt;

class BidirectionalExample {
  input2: string = "";
  input3: string = "";
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  message3 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) })
               .Add({ bindFrom: IX.nameof(() =&gt; this.input3) });
}</pre>

<p>Here, typing in the left edit box sets messages 2 &amp; 3:</p>

<p><img height="51" src="https://www.codeproject.com/KB/applications/5272881/src1.png" width="326" alt="Image 11" data-src="/KB/applications/5272881/src1.png"></p>

<p>Typing in the right edit box sets message 3:</p>

<p><img height="51" src="https://www.codeproject.com/KB/applications/5272881/src2.png" width="324" alt="Image 12" data-src="/KB/applications/5272881/src2.png"></p>

<p>But as I said earlier, doing this kind of binding really doesn't make much sense.&nbsp; Typically, a transformation does something "useful", so we have this contrived example:</p>

<p><span id="prehide245481" onclick="processCodeBlocks.togglePre(245481);">Hide</span>  &nbsp; <span id="copycode245481" onclick="return processCodeBlocks.copyCode(245481);">Copy Code</span></p><pre id="pre245481">class BidirectionalExample {
  input2: string = "";
  input3: string = "";
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  message3 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) }).Add({
    bindFrom: IX.nameof(() =&gt; this.input3), 
    op: v =&gt; v.split('').reverse().join('') 
  });

// onInput2KeyUp = new IXEvent().Add((v, p: BidirectionalExample) =&gt; p.message2 = v);
}</pre>

<p>and thus we get:</p>

<p><img height="49" src="https://www.codeproject.com/KB/applications/5272881/op1.png" width="313" alt="Image 13" data-src="/KB/applications/5272881/op1.png"></p>

<h2><a name="Checkboxes28">Checkboxes</a></h2>

<h3><a name="BindingCheckboxState29">Binding Checkbox State</a></h3>

<h4><a name="TheVueWay30">The Vue Way</a></h4>

<p>Vue has an elegant demonstration of binding the checkbox state to the label:</p>

<p><span id="prehide384313" onclick="processCodeBlocks.togglePre(384313);">Hide</span>  &nbsp; <span id="copycode384313" onclick="return processCodeBlocks.copyCode(384313);">Copy Code</span></p><pre id="pre384313">&lt;input type="checkbox" id="checkbox" v-model="checked"&gt;
&lt;label for="checkbox"&gt;{{ checked }}&lt;/label&gt;</pre>

<h4><a name="TheIXWay31">The IX Way</a></h4>

<p>Given:</p>

<p><span id="prehide918421" onclick="processCodeBlocks.togglePre(918421);">Hide</span>  &nbsp; <span id="copycode918421" onclick="return processCodeBlocks.copyCode(918421);">Copy Code</span></p><pre id="pre918421">&lt;input id="checkbox" type="checkbox" /&gt;
&lt;label id="ckLabel" for="checkbox"&gt;&lt;/label&gt;</pre>

<p>We continue to follow the pattern of using TypeScript classes and properties:</p>

<p><span id="prehide421425" onclick="processCodeBlocks.togglePre(421425);">Hide</span>  &nbsp; <span id="copycode421425" onclick="return processCodeBlocks.copyCode(421425);">Copy Code</span></p><pre id="pre421425">class CheckboxExample {
  checkbox: boolean = false;
  ckLabel = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.checkbox) });
}

IX.CreateProxy(new CheckboxExample());</pre>

<p>or, because the nameof syntax above is clumsy and we don't have a real "nameof" operator in Javascript by the time the code is transpiled, so we have to revert to string literals in this case:</p>

<p><span id="prehide979734" onclick="processCodeBlocks.togglePre(979734);">Hide</span>  &nbsp; <span id="copycode979734" onclick="return processCodeBlocks.copyCode(979734);">Copy Code</span></p><pre id="pre979734">class CheckboxExample {
  checkbox: boolean = false;
  ckLabel = new IXBinder({ bindFrom: "checkbox" });
}

IX.CreateProxy(new CheckboxExample());</pre>

<p><img height="28" src="https://www.codeproject.com/KB/applications/5272881/ckfalse.png" width="56" alt="Image 14" data-src="/KB/applications/5272881/ckfalse.png"></p>

<p><img height="27" src="https://www.codeproject.com/KB/applications/5272881/cktrue.png" width="58" alt="Image 15" data-src="/KB/applications/5272881/cktrue.png"></p>

<p>Or we can wire up the click event:</p>

<p><span id="prehide603470" onclick="processCodeBlocks.togglePre(603470);">Hide</span>  &nbsp; <span id="copycode603470" onclick="return processCodeBlocks.copyCode(603470);">Copy Code</span></p><pre id="pre603470">class CheckboxExample {
  checkbox: boolean = false;
  ckLabel: string = "Unchecked";

  onCheckboxClicked = 
    new IXEvent().Add(
      (_, p: CheckboxExample) =&gt; 
          p.ckLabel = p.checkbox ? "Checked" : "Unchecked");
}

IX.CreateProxy(new CheckboxExample());</pre>

<p><img height="27" src="https://www.codeproject.com/KB/applications/5272881/ckunchecked.png" width="94" alt="Image 16" data-src="/KB/applications/5272881/ckunchecked.png"></p>

<p><img height="29" src="https://www.codeproject.com/KB/applications/5272881/ckchecked.png" width="87" alt="Image 17" data-src="/KB/applications/5272881/ckchecked.png"></p>

<h3><a name="BindingCheckboxValues32">Binding Checkbox Values</a></h3>

<h4><a name="TheViewWay33">The View Way</a></h4>

<p><span id="prehide430315" onclick="processCodeBlocks.togglePre(430315);">Hide</span>  &nbsp; <span id="copycode430315" onclick="return processCodeBlocks.copyCode(430315);">Copy Code</span></p><pre id="pre430315">&lt;input type="checkbox" id="jack" value="Jack" v-model="checkedNames"&gt;
&lt;label for="jack"&gt;Jack&lt;/label&gt;
&lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt;
&lt;label for="john"&gt;John&lt;/label&gt;
&lt;input type="checkbox" id="mike" value="Mike" v-model="checkedNames"&gt;
&lt;label for="mike"&gt;Mike&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Checked names: {{ checkedNames }}&lt;/span&gt;</pre>

<p>Note that the span text includes the array brackets:</p>

<p><img height="69" src="https://www.codeproject.com/KB/applications/5272881/viewckarray.png" width="251" alt="Image 18" data-src="/KB/applications/5272881/viewckarray.png"></p>

<h4><a name="TheIXWay34">The IX Way</a></h4>

<p>Given:</p>

<p><span id="prehide585643" onclick="processCodeBlocks.togglePre(585643);">Hide</span>  &nbsp; <span id="copycode585643" onclick="return processCodeBlocks.copyCode(585643);">Copy Code</span></p><pre id="pre585643">&lt;input id="jane" value="Jane" type="checkbox" /&gt;
&lt;label for="jane"&gt;Jane&lt;/label&gt;
&lt;input id="mary" value="Mary" type="checkbox" /&gt;
&lt;label for="mary"&gt;Mary&lt;/label&gt;
&lt;input id="grace" value="Grace" type="checkbox" /&gt;
&lt;label for="grace"&gt;Grace&lt;/label&gt;
&lt;br /&gt;
&lt;label id="ckNames"&gt;&lt;/label&gt;</pre>

<p>We implement the container object with a special array binding (because the properties don't exist in the class, I can't use the "nameof" kludge, so the ID"s are, sadly, string literals.)&nbsp; Of course, in the next example, I do have properties for the checkboxes, but I still used the string literals!</p>

<p><span id="prehide987857" onclick="processCodeBlocks.togglePre(987857);">Hide</span>  &nbsp; <span id="copycode987857" onclick="return processCodeBlocks.copyCode(987857);">Copy Code</span></p><pre id="pre987857">class CheckboxListExample {
  ckNames = IXBinder.AsArray(items =&gt; items.join(", "))
    .Add({ bindFrom: "jane", attribute: "value" })
    .Add({ bindFrom: "mary", attribute: "value" })
    .Add({ bindFrom: "grace", attribute: "value" });
}

IX.CreateProxy(new CheckboxListExample());</pre>

<p>And we get:</p>

<p><img height="55" src="https://www.codeproject.com/KB/applications/5272881/ixckarray.png" width="191" alt="Image 19" data-src="/KB/applications/5272881/ixckarray.png"></p>

<p>Notice that we did not initialize properties with the checkbox state!&nbsp; If we do this:</p>

<p><span id="prehide305351" onclick="processCodeBlocks.togglePre(305351);">Hide</span>  &nbsp; <span id="copycode305351" onclick="return processCodeBlocks.copyCode(305351);">Copy Code</span></p><pre id="pre305351">class CheckboxListExample {
  jane: boolean = false;
  mary: boolean = false;
  grace: boolean = false;
  ckNames = IXBinder.AsArray(items =&gt; items.join(", "))
    .Add({ bindFrom: "jane", attribute: "value" })
    .Add({ bindFrom: "mary", attribute: "value" })
    .Add({ bindFrom: "grace", attribute: "value" });
}

let ckListExample = IX.CreateProxy(new CheckboxListExample());</pre>

<p>We can programmatically set the check state:</p>

<p><span id="prehide108069" onclick="processCodeBlocks.togglePre(108069);">Hide</span>  &nbsp; <span id="copycode108069" onclick="return processCodeBlocks.copyCode(108069);">Copy Code</span></p><pre id="pre108069">ckListExample.jane = true;
ckListExample.mary = true;</pre>

<p>and we see:</p>

<p><img height="50" src="https://www.codeproject.com/KB/applications/5272881/cklistprog.png" width="180" alt="Image 20" data-src="/KB/applications/5272881/cklistprog.png"></p>

<p>So one thing we note here is that the property referring to the HTML element is associated <i>with the checked attribute of the element</i>.&nbsp; That is an artifact of how IX is coded, and actually points out an interesting problem -- the object property maps to only one attribute of the DOM element, and IX is very opinionated as to what that DOM element should be, depending on what the element is!</p>

<h2><a name="RadioButtons35">Radio Buttons</a></h2>

<h3><a name="TheViewWay36">The View Way</a></h3>

<p>This example binds the value of the radio button to the span:</p>

<p><span id="prehide494113" onclick="processCodeBlocks.togglePre(494113);">Hide</span>  &nbsp; <span id="copycode494113" onclick="return processCodeBlocks.copyCode(494113);">Copy Code</span></p><pre id="pre494113">&lt;input type="radio" id="one" value="One" v-model="picked"&gt;
&lt;label for="one"&gt;One&lt;/label&gt;
&lt;br&gt;
&lt;input type="radio" id="two" value="Two" v-model="picked"&gt;
&lt;label for="two"&gt;Two&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Picked: {{ picked }}&lt;/span&gt;</pre>

<h3><a name="TheIXWay37">The IX Way</a></h3>

<p>Given:</p>

<p><span id="prehide488073" onclick="processCodeBlocks.togglePre(488073);">Hide</span>  &nbsp; <span id="copycode488073" onclick="return processCodeBlocks.copyCode(488073);">Copy Code</span></p><pre id="pre488073">&lt;input id="marc" value="Marc" type="radio" name="group1" /&gt;
&lt;label for="marc"&gt;Marc&lt;/label&gt;
&lt;input id="chris" value="Chris" type="radio" name="group1" /&gt;
&lt;label for="chris"&gt;Chris&lt;/label&gt;
&lt;br /&gt;
&lt;label id="rbPicked"&gt;&lt;/label&gt;</pre>

<p>We add two binders, whichever one is clicked becomes the one whose binder event is fired.&nbsp; Again, note in this example I'm not using the "nameof" syntax because in this case the property doesn't exist!</p>

<p><span id="prehide182886" onclick="processCodeBlocks.togglePre(182886);">Hide</span>  &nbsp; <span id="copycode182886" onclick="return processCodeBlocks.copyCode(182886);">Copy Code</span></p><pre id="pre182886">class RadioExample {
  rbPicked = new IXBinder({ bindFrom: "marc", attribute: "value" })
    .Add({ bindFrom: "chris", attribute: "value" });
}

IX.CreateProxy(new RadioExample());</pre>

<p>thus updating to the current radio button:</p>

<p><img height="48" src="https://www.codeproject.com/KB/applications/5272881/rb1.png" width="132" alt="Image 21" data-src="/KB/applications/5272881/rb1.png"></p>

<p><img height="43" src="https://www.codeproject.com/KB/applications/5272881/rb2.png" width="120" alt="Image 22" data-src="/KB/applications/5272881/rb2.png"></p>

<p>And if we want to programmatically set the radio button state, define the properties:</p>

<p><span id="prehide295193" onclick="processCodeBlocks.togglePre(295193);">Hide</span>  &nbsp; <span id="copycode295193" onclick="return processCodeBlocks.copyCode(295193);">Copy Code</span></p><pre id="pre295193">class RadioExample {
  marc: boolean = false;
  chris: boolean = false;
  rbPicked = new IXBinder({ bindFrom: "marc", attribute: "value" })
    .Add({ bindFrom: "chris", attribute: "value" });
}</pre>

<p>and after proxy initialization, set the state:</p>

<p><span id="prehide993870" onclick="processCodeBlocks.togglePre(993870);">Hide</span>  &nbsp; <span id="copycode993870" onclick="return processCodeBlocks.copyCode(993870);">Copy Code</span></p><pre id="pre993870">let rbExample = IX.CreateProxy(new RadioExample());
rbExample.chris = true;</pre>

<p><img height="43" src="https://www.codeproject.com/KB/applications/5272881/rb2.png" width="120" alt="Image 23" data-src="/KB/applications/5272881/rb2.png"></p>

<h2><a name="ComboBoxes38">ComboBoxes</a></h2>

<h3><a name="TheVueWay39">The Vue Way</a></h3>

<p><span id="prehide981215" onclick="processCodeBlocks.togglePre(981215);">Hide</span>  &nbsp; <span id="copycode981215" onclick="return processCodeBlocks.copyCode(981215);">Copy Code</span></p><pre id="pre981215">&lt;select v-model="selected"&gt;
  &lt;option disabled value=""&gt;Please select one&lt;/option&gt;
  &lt;option&gt;A&lt;/option&gt;
  &lt;option&gt;B&lt;/option&gt;
  &lt;option&gt;C&lt;/option&gt;
&lt;/select&gt;
&lt;span&gt;Selected: {{ selected }}&lt;/span&gt;</pre>

<h3><a name="TheIXWay40">The IX Way</a></h3>

<p>Given:</p>

<p><span id="prehide146375" onclick="processCodeBlocks.togglePre(146375);">Hide</span>  &nbsp; <span id="copycode146375" onclick="return processCodeBlocks.copyCode(146375);">Copy Code</span></p><pre id="pre146375">&lt;select id="selector"&gt;
  &lt;option selected disabled&gt;Please select one&lt;/option&gt;
  &lt;option value="1"&gt;A&lt;/option&gt;
  &lt;option value="2"&gt;B&lt;/option&gt;
  &lt;option value="3"&gt;C&lt;/option&gt;
&lt;/select&gt;
&lt;br /&gt;
&lt;span id="selection"&gt;&lt;/span&gt;</pre>

<p>and the container class:</p>

<p><span id="prehide398315" onclick="processCodeBlocks.togglePre(398315);">Hide</span>  &nbsp; <span id="copycode398315" onclick="return processCodeBlocks.copyCode(398315);">Copy Code</span></p><pre id="pre398315">class ComboboxExample {
  selector = new IXSelector();
  selection: string = "";

  onSelectorChanged = 
    new IXEvent().Add((_, p) =&gt; 
      p.selection = `Selected: ${p.selector.text} with value ${p.selector.value}`);
}

IX.CreateProxy(new ComboboxExample());</pre>

<p>We then see:</p>

<p><img height="28" src="https://www.codeproject.com/KB/applications/5272881/select1.png" width="129" alt="Image 24" data-src="/KB/applications/5272881/select1.png"></p>

<p>and after selection:</p>

<p><img height="45" src="https://www.codeproject.com/KB/applications/5272881/select2.png" width="156" alt="Image 25" data-src="/KB/applications/5272881/select2.png"></p>

<p>Note that the selector property, implemented as an <code>IXSelector</code>, contains two properties, <code>text</code> and <code>value</code>, for the selected item.</p>

<p>We can also initialize the options programmatically.&nbsp; Given:</p>

<p><span id="prehide395113" onclick="processCodeBlocks.togglePre(395113);">Hide</span>  &nbsp; <span id="copycode395113" onclick="return processCodeBlocks.copyCode(395113);">Copy Code</span></p><pre id="pre395113">&lt;select id="selector2"&gt;&lt;/select&gt;
&lt;br /&gt;
&lt;span id="selection2"&gt;&lt;/span&gt;</pre>

<p>and:</p>

<p><span id="prehide258873" onclick="processCodeBlocks.togglePre(258873);">Hide</span>  &nbsp; <span id="copycode258873" onclick="return processCodeBlocks.copyCode(258873);">Copy Code</span></p><pre id="pre258873">class ComboboxInitializationExample {
  selector2 = new IXSelector().Add({ selected:true, disabled: true, text: "Please select one" })
    .Add({ value: 12, text: "AAA" })
    .Add({ value: 23, text: "BBB" })
    .Add({ value: 34, text: "CCC" });

  selection2: string = "";

  onSelector2Changed = new IXEvent().Add((_, p) =&gt; p.selection2 = `Selected: ${p.selector2.text} with value ${p.selector2.value}`);
}

 let cb = IX.CreateProxy(new ComboboxInitializationExample());</pre>

<p>We see:</p>

<p><img height="42" src="https://www.codeproject.com/KB/applications/5272881/select3.png" width="184" alt="Image 26" data-src="/KB/applications/5272881/select3.png"></p>

<p>And programmatically set the selection with the option value:</p>

<p><span id="prehide29143" onclick="processCodeBlocks.togglePre(29143);">Hide</span>  &nbsp; <span id="copycode29143" onclick="return processCodeBlocks.copyCode(29143);">Copy Code</span></p><pre id="pre29143">cb.selector2.value = 34;</pre>

<p><img height="45" src="https://www.codeproject.com/KB/applications/5272881/select4.png" width="189" alt="Image 27" data-src="/KB/applications/5272881/select4.png"></p>

<p>or with the option text:</p>

<p><span id="prehide184450" onclick="processCodeBlocks.togglePre(184450);">Hide</span>  &nbsp; <span id="copycode184450" onclick="return processCodeBlocks.copyCode(184450);">Copy Code</span></p><pre id="pre184450">cb.selector2.text = "AAA";</pre>

<p><span id="prehide36561" onclick="processCodeBlocks.togglePre(36561);">Hide</span>  &nbsp; <span id="copycode36561" onclick="return processCodeBlocks.copyCode(36561);">Copy Code</span></p><pre id="pre36561">&lt;img border="0" height="45" src="/KB/applications/5272881/select5.png" width="182" /&gt;</pre>

<p>Or add to the list of options:</p>

<p><span id="prehide640731" onclick="processCodeBlocks.togglePre(640731);">Hide</span>  &nbsp; <span id="copycode640731" onclick="return processCodeBlocks.copyCode(640731);">Copy Code</span></p><pre id="pre640731">cb.selector2.options.push({ text: "DDD", value: 45 });</pre>

<p><img height="187" src="https://www.codeproject.com/KB/applications/5272881/select6.png" width="127" alt="Image 28" data-src="/KB/applications/5272881/select6.png"></p>

<p>Or remove the option item:</p>

<p><span id="prehide405815" onclick="processCodeBlocks.togglePre(405815);">Hide</span>  &nbsp; <span id="copycode405815" onclick="return processCodeBlocks.copyCode(405815);">Copy Code</span></p><pre id="pre405815">cb.selector2.options.pop();</pre>

<p><span id="prehide539478" onclick="processCodeBlocks.togglePre(539478);">Hide</span>  &nbsp; <span id="copycode539478" onclick="return processCodeBlocks.copyCode(539478);">Copy Code</span></p><pre id="pre539478">&lt;img border="0" height="119" src="/KB/applications/5272881/selector7.png" width="133" /&gt;</pre>

<p>Or change an option's text and value:</p>

<p><span id="prehide13522" onclick="processCodeBlocks.togglePre(13522);">Hide</span>  &nbsp; <span id="copycode13522" onclick="return processCodeBlocks.copyCode(13522);">Copy Code</span></p><pre id="pre13522">cb.selector2.options[2] = { text: "bbb", value: 999 };</pre>

<p><img height="154" src="https://www.codeproject.com/KB/applications/5272881/selector8.png" width="124" alt="Image 29" data-src="/KB/applications/5272881/selector8.png"></p>

<h2><a name="ImplementationPatterns41">Implementation Patterns</a></h2>

<p>IX requires that class properties match the DOM element ID and that event handlers have specific signatures.</p>

<h3><a name="IDandClassPropertyName42">ID and Class Property Name</a></h3>

<p><img height="115" src="https://www.codeproject.com/KB/applications/5272881/idprop1.png" width="405" alt="Image 30" data-src="/KB/applications/5272881/idprop1.png" data-sizes="auto" data-srcset="/KB/applications/5272881/idprop1-r-400.png 400w, /KB/applications/5272881/idprop1.png 405w" srcset="/KB/applications/5272881/idprop1-r-400.png 400w, /KB/applications/5272881/idprop1.png 405w"></p>

<h3><a name="KeyUp,Changed,andConvertEvents43">KeyUp, Changed, and Convert Events</a></h3>

<p><img height="152" src="https://www.codeproject.com/KB/applications/5272881/idprop2.png" width="368" alt="Image 31" data-src="/KB/applications/5272881/idprop2.png"></p>

<p>Notice:</p>

<p>The event name uses the property name with the first letter capitalized, so <code>firstName</code> becomes <code>FirstName</code>.</p>

<h3><a name="SupportedEvents44">Supported Events</a></h3>

<h4><a name="KeyUp45">KeyUp</a></h4>

<p>on[Prop]KeyUp - realtime key up events.</p>

<h4><a name="Changed46">Changed</a></h4>

<p>on[Prop]Changed - element loses focus.</p>

<p>This event applies to text, radio and checkbox inputs and "select" (combobox) elements.</p>

<h4><a name="Convert47">Convert</a></h4>

<p>onConvert[Prop] - if defined, executes the function before the KeyUp and Changed events fire.</p>

<h4><a name="Hover48">Hover</a></h4>

<p>on[Prop]Hover - if defined and the property has the signature:</p>

<p><span id="prehide664510" onclick="processCodeBlocks.togglePre(664510);">Hide</span>  &nbsp; <span id="copycode664510" onclick="return processCodeBlocks.copyCode(664510);">Copy Code</span></p><pre id="pre664510">{
  attr: { title: "" }
};</pre>

<p>This will set the element's title on mouse hover.</p>

<h2><a name="IntegrationTests49">Integration Tests</a></h2>

<p><img height="302" src="https://www.codeproject.com/KB/applications/5272881/tests.png" width="257" alt="Image 32" data-src="/KB/applications/5272881/tests.png"></p>

<p>We can easily test the behavior of IX by directly inspecting DOM elements after model changes, and vice versa.&nbsp; And I prefer to use the phrase "integration test" rather than "unit test" because we're not testing low level functions in the IX library -- we are testing the integration of the DOM elements with object properties.&nbsp;</p>

<p>The HTML for the test cases is simple:</p>

<p><span id="prehide231867" onclick="processCodeBlocks.togglePre(231867);">Hide</span>  &nbsp; <span id="copycode231867" onclick="return processCodeBlocks.copyCode(231867);">Copy Code</span></p><pre id="pre231867">&lt;div id="testResults" class="inline" style="min-width:600px"&gt;
  &lt;ol id="tests"&gt;&lt;/ol&gt;
&lt;/div&gt;

&lt;div id="testDom"&gt;&lt;/div&gt;</pre>

<p>We have an ordered list for the test results, and a <code>div</code> in which we place the HTML required for each test.</p>

<h3><a name="TheTestRunner50">The Test Runner</a></h3>

<p>The tests actually use IX to manipulate the test results, and direct DOM manipulation to simulate UI changes.&nbsp; The runner looks like this:</p>

<p><span id="prehide930387" onclick="processCodeBlocks.togglePre(930387);">Hide</span>  &nbsp; <span id="preShrink930387" onclick="processCodeBlocks.shrinkExpand(930387);">Shrink</span> <img id="preimg930387" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(930387);">  &nbsp; <span id="copycode930387" onclick="return processCodeBlocks.copyCode(930387);">Copy Code</span></p><pre id="pre930387" processed="true">let testForm = IX.CreateProxy(new TestResults());
let idx = 0;

tests.forEach(test =&gt; {
  // Get just the name of the test function.
  let testName = IX.LeftOf(test.testFnc.toString(), "(");

  // The ID will start with a lowercase letter
  let id = IX.LowerCaseFirstChar(testName);

  // Push a template to OL, where the template value is simply the test name, to the test results ordered list.
  testForm.tests.push(IXTemplate.Create({ value: testName, id: id }));

  // Create an object with the id and proxy it. This will match the id of the template we just created, so we can set its style.
  // This is a great example of not actually needing to create a class, which is really
  // just a dictionary.
  let obj = {};

  // The classList here allows us to set the test LI element style class to indicate success/failure of the test.
  obj[id] = { classList: new IXClassList() }; 
  let testProxy = IX.CreateProxy(obj);

  // Create the DOM needed for the test.
  this.CreateTestDom(testForm, test.dom);

  // Run the test and indicate the result.
  this.RunTest(testForm, idx, testProxy, test, id);

  // Remove the DOM needed for the test.
  this.RemoveTestDom(testForm);

  ++idx;
});</pre>

<p>And we have these three helper functions:</p>

<p><span id="prehide561511" onclick="processCodeBlocks.togglePre(561511);">Hide</span>  &nbsp; <span id="copycode561511" onclick="return processCodeBlocks.copyCode(561511);">Copy Code</span></p><pre id="pre561511">CreateTestDom(testForm: TestResults, testDom: string): void {
  testForm.testDom = testDom || "";
}

RemoveTestDom(testForm: TestResults, ): void {
  testForm.testDom = "";
}

RunTest(testForm: TestResults, idx:number, testProxy: object, test, id: string): void {
  let passFail = "pass";

  try {
    test.testFnc(test.obj, id);
  } catch (err) {
    passFail = "fail";
    let template = testForm.tests[idx];
    template.SetValue(`${template.value} =&gt; ${err}`);
  }

  testProxy[id].classList.Add(passFail);
}</pre>

<p>A passing test is indicated in green, a failing test in red, along with the error message.</p>

<p><span id="prehide504598" onclick="processCodeBlocks.togglePre(504598);">Hide</span>  &nbsp; <span id="copycode504598" onclick="return processCodeBlocks.copyCode(504598);">Copy Code</span></p><pre id="pre504598">.pass {
  color: green;
}

.fail {
  color: red;
}</pre>

<p>So for example, we can test that failure are handled:</p>

<p><span id="prehide410668" onclick="processCodeBlocks.togglePre(410668);">Hide</span>  &nbsp; <span id="copycode410668" onclick="return processCodeBlocks.copyCode(410668);">Copy Code</span></p><pre id="pre410668">static ShouldFail(obj): void {
  throw "Failed!!!";
}</pre>

<p>And we see:</p>

<p><img height="25" src="https://www.codeproject.com/KB/applications/5272881/failed.png" width="173" alt="Image 33" data-src="/KB/applications/5272881/failed.png"></p>

<h3><a name="DefiningtheTests51">Defining the Tests</a></h3>

<p>The tests are defined as an array of objects the specify:</p>

<ol>
	<li>The test to be run.</li>	<li>The "object" being manipulated in the test.</li>	<li>The HTML to support the test.</li></ol>

<p>Like this:</p>

<p><span id="prehide832893" onclick="processCodeBlocks.togglePre(832893);">Hide</span>  &nbsp; <span id="preShrink832893" onclick="processCodeBlocks.shrinkExpand(832893);">Shrink</span> <img id="preimg832893" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(832893);">  &nbsp; <span id="copycode832893" onclick="return processCodeBlocks.copyCode(832893);">Copy Code</span></p><pre id="pre832893" processed="true">let tests = [
  // { testFnc: IntegrationTests.ShouldFail },
  { testFnc: IntegrationTests.InputElementSetOnInitializationTest, obj: { inputTest: "Test" }, dom: "&lt;input id='inputTest'/&gt;" },
  { testFnc: IntegrationTests.InputElementSetOnAssignmentTest, obj: { inputTest: "" }, dom: "&lt;input id='inputTest'/&gt;" },
  { testFnc: IntegrationTests.InputSetsPropertyTest, obj: { inputTest: "" }, dom: "&lt;input id='inputTest'/&gt;" },
  { testFnc: IntegrationTests.ListInitializedTest, obj: { list: ["A", "B", "C"] }, dom: "&lt;ol id='list'&gt;&lt;/ol&gt;" },
  { testFnc: IntegrationTests.ReplaceInitializedTest, obj: { list: ["A", "B", "C"] }, dom: "&lt;ol id='list'&gt;&lt;/ol&gt;" },
  { testFnc: IntegrationTests.ChangeListItemTest, obj: { list: ["A", "B", "C"] }, dom: "&lt;ol id='list'&gt;&lt;/ol&gt;" },
  { testFnc: IntegrationTests.PushListItemTest, obj: { list: ["A", "B", "C"] }, dom: "&lt;ol id='list'&gt;&lt;/ol&gt;" },
  { testFnc: IntegrationTests.PopListItemTest, obj: { list: ["A", "B", "C"] }, dom: "&lt;ol id='list'&gt;&lt;/ol&gt;" },
  {
    testFnc: IntegrationTests.ButtonClickTest,
    obj: { clicked: false, onButtonClicked : new IXEvent().Add((_, p) =&gt; p.clicked = true)},
    dom: "&lt;button id='button'&gt;&lt;/button&gt;"
  },
  {
    testFnc: IntegrationTests.OnlyOneClickEventTest,
    obj: { clicked: 0, onButtonClicked: new IXEvent().Add((_, p) =&gt; p.clicked += 1) },
    dom: "&lt;button id='button'&gt;&lt;/button&gt;"
  },
  {
    testFnc: IntegrationTests.CheckboxClickTest,
    obj: { clicked: false, checkbox: false, onCheckboxClicked: new IXEvent().Add((_, p) =&gt; p.clicked = p.checkbox)},
    dom: "&lt;input id='checkbox' type='checkbox'/&gt;"
  },
  {
    testFnc: IntegrationTests.RadioButtonClickTest,
    obj: { clicked: false, checkbox: false, onRadioClicked: new IXEvent().Add((_, p) =&gt; p.clicked = p.radio) },
    dom: "&lt;input id='radio' type='radio'/&gt;"
  },
  {
    testFnc: IntegrationTests.ConvertTest,
    obj: { inputTest: "", onConvertInputTest: s =&gt; `${s} Converted!` },
    dom: "&lt;input id='inputTest'/&gt;"
  },
  { testFnc: IntegrationTests.VisibleAttributeTest, obj: { inputTest: { attr: { visible: true } } }, dom: "&lt;input id='inputTest'/&gt;" },
  { testFnc: IntegrationTests.ControlBindingTest, obj: { input: "123", output: new IXBinder({ bindFrom: "input" }) }, dom: "&lt;input id='input'&gt;&lt;p id='output'&gt;" },
  { testFnc: IntegrationTests.ControlBindingWithOperationTest, obj: { input: "123", output: new IXBinder({ bindFrom: "input", op: v =&gt; `${v} Operated!` }) }, dom: "&lt;input id='input'&gt;&lt;p id='output'&gt;" },
  { testFnc: IntegrationTests.ControlBindingAssignmentTest, obj: { input: "", output: new IXBinder({ bindFrom: "input" }) }, dom: "&lt;input id='input'&gt;&lt;p id='output'&gt;" },
];</pre>

<p>I'm not going to bore you with the actual tests, but I'll point out that in some cases we have to simulate clicking and therefore the test must dispatch the appropriate event, for example:</p>

<p><span id="prehide452140" onclick="processCodeBlocks.togglePre(452140);">Hide</span>  &nbsp; <span id="copycode452140" onclick="return processCodeBlocks.copyCode(452140);">Copy Code</span></p><pre id="pre452140">static ButtonClickTest(obj): void {
  let test = IX.CreateProxy(obj);
  let el = document.getElementById("button") as HTMLButtonElement;
  el.dispatchEvent(new Event('click')); 
  IXAssert.Equal(test.clicked, true);
}</pre>

<h3><a name="TheIXAssertHelper52">The IXAssert Helper</a></h3>

<p>This class simply wraps the <code>if</code> statement into a one-liner, as I rather dislike <code>if</code> statements for assertions.</p>

<p><span id="prehide327273" onclick="processCodeBlocks.togglePre(327273);">Hide</span>  &nbsp; <span id="copycode327273" onclick="return processCodeBlocks.copyCode(327273);">Copy Code</span></p><pre id="pre327273">export class IXAssert {
  public static Equal(got: any, expected: any): void {
    let b = got == expected;

    if (!b) {
      throw `Expected ${expected}, got ${got}`;
    }
  }

  public static IsTrue(b: boolean): void {
    if (!b) {
      throw "Not true";
    }
  }
}</pre>

<h3><a name="YouDon'tNeedTypeScriptClasses53">You Don't Need TypeScript Classes</a></h3>

<p>You should realize from looking at how the tests are implemented that you don't need actual TypeScript classes, you just need an object, like <code>obj: { inputTest: "Test" }</code> - after all, a TypeScript class is a purely development-side construct used for type checking and Intellisense by the IDE.&nbsp; Even a JavaScript class is really just "syntactical sugar of JavaScript's existing prototype-based inheritance." (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">JavaScript classes</a>)</p>

<h2><a name="BehindtheScenes54">Behind the Scenes</a></h2>

<h3><a name="TypeScriptDoesNotMeanRuntimeTypeReflection55">TypeScript Does Not Mean Runtime Type Reflection</a></h3>

<p>TypeScript is fantastic for ensuring type safety when <i>writing</i> code.&nbsp; However, by the time the code has been transpiled to JavasScript, all that type information that the IDE is using is of course lost.&nbsp; This is unfortunate because there are times in the code that I really wish I had type information.&nbsp; There are some workarounds, such as for native types and classes:</p>

<p><span id="prehide500049" onclick="processCodeBlocks.togglePre(500049);">Hide</span>  &nbsp; <span id="copycode500049" onclick="return processCodeBlocks.copyCode(500049);">Copy Code</span></p><pre id="pre500049">let a = 1;
let b = "foo";
let c = true;
let d = [];
let e = new SomeClass();
[a, b, c, d, e].forEach(q =&gt; console.log(q.constructor.name));

let listForm = IX.CreateProxy(new ListExample());</pre>

<p>You get:</p>

<p><img height="78" src="https://www.codeproject.com/KB/applications/5272881/objects2.png" width="80" alt="Image 34" data-src="/KB/applications/5272881/objects2.png"></p>

<p>This is useful.&nbsp; However, given this class:</p>

<p><span id="prehide807212" onclick="processCodeBlocks.togglePre(807212);">Hide</span>  &nbsp; <span id="copycode807212" onclick="return processCodeBlocks.copyCode(807212);">Copy Code</span></p><pre id="pre807212">class SomeClass {
  a: number;
  b: string;
}</pre>

<p>What that gets transpiled to is simply an empty object <code>{}</code>.&nbsp; So, <code>Object.keys(new SomeClass())</code> return an empty array <code>[]</code>.&nbsp; To determine properties of the class, the properties must be initialized, and they can even be initialized to null or undefined:</p>

<p><span id="prehide321164" onclick="processCodeBlocks.togglePre(321164);">Hide</span>  &nbsp; <span id="copycode321164" onclick="return processCodeBlocks.copyCode(321164);">Copy Code</span></p><pre id="pre321164">class SomeClass {
  a: number = null;
  b: string = undefined;
}</pre>

<p><img height="69" src="https://www.codeproject.com/KB/applications/5272881/objects1.png" width="455" alt="Image 35" data-src="/KB/applications/5272881/objects1.png" data-sizes="auto" data-srcset="/KB/applications/5272881/objects1-r-400.png 400w, /KB/applications/5272881/objects1.png 455w" srcset="/KB/applications/5272881/objects1-r-400.png 400w, /KB/applications/5272881/objects1.png 455w"></p>

<p>Hence the constraint in IX that you must initialize properties, otherwise the wire-up cannot be made between the class property and the element with the ID of the property name.</p>

<h3><a name="ProxyInitialization56">Proxy Initialization</a></h3>

<p><span id="prehide173712" onclick="processCodeBlocks.togglePre(173712);">Hide</span>  &nbsp; <span id="copycode173712" onclick="return processCodeBlocks.copyCode(173712);">Copy Code</span></p><pre id="pre173712">public static CreateProxy&lt;T&gt;(container: T): T {
  let proxy = new Proxy(container, IX.uiHandler);
  IX.CreatePropertyHandlers(container, proxy);
  IX.CreateButtonHandlers(container, proxy);
  IX.CreateBinders(container, proxy);
  IX.Initialize(container, proxy);

  return proxy;
}</pre>

<p>Besides instantiating the proxy, we can see that several other steps are required:</p>

<ol>
	<li>Special property handlers.</li>	<li>Button handlers.</li>	<li>Binders.</li>	<li>Final initialization.</li></ol>

<h4><a name="CreatePropertyHandlers57">CreatePropertyHandlers</a></h4>

<p>This code is intended to handle attributes, class lists, and event wireups.&nbsp; Events are only wired up once, in case the proxy is re-initialized after class property assignments.&nbsp; To make matters a bit more complicated, specific cases are handled here, such as proxy'ing the <code>attr</code> key to accommodate the custom syntax for assigning attributes to the associated DOM element.&nbsp; The <code>class</code> attribute is handled similarly, creating a proxy for the <code>classList</code> key.&nbsp; A better implementation is discussed in the conclusion.&nbsp; Otherwise, the initial purpose of the function was solely to handle the <code>mouseover</code>, <code>change</code>, and <code>keyup</code> events.</p>

<p><span id="prehide862795" onclick="processCodeBlocks.togglePre(862795);">Hide</span>  &nbsp; <span id="preShrink862795" onclick="processCodeBlocks.shrinkExpand(862795);">Shrink</span> <img id="preimg862795" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(862795);">  &nbsp; <span id="copycode862795" onclick="return processCodeBlocks.copyCode(862795);">Copy Code</span></p><pre id="pre862795" processed="true">private static CreatePropertyHandlers&lt;T&gt;(container: T, proxy: T) {
  Object.keys(container).forEach(k =&gt; {
  let el = document.getElementById(k);
  let anonEl = el as any;

  // If element exists and we haven't assigned a proxy to the container's field, then wire up the events.
  if (el &amp;&amp; !anonEl._proxy) {
    anonEl._proxy = this;

    if (container[k].attr) {
      // Proxy the attributes of the container so we can intercept the setter for attributes
      console.log(`Creating proxy for attr ${k}`);
      container[k].attr = IXAttributeProxy.Create(k, container[k].attr);
    }

    if (container[k].classList) {
      console.log(`Creating proxy for classList ${k}`);
      container[k].classList = IXClassListProxy.Create(k, container[k].classList);
    }

    let idName = IX.UpperCaseFirstChar(el.id);

    // TODO: create a dictionary to handle this.
    let changedEvent = `on${idName}Changed`;
    let hoverEvent = `on${idName}Hover`;
    let keyUpEvent = `on${idName}KeyUp`;

    if (container[hoverEvent]) {
      IX.WireUpEventHandler(el, container, proxy, null, "mouseover", hoverEvent);
    }

    // Change event is always wired up so we set the container's value when the UI element value changes.
    switch (el.nodeName) {
      case "SELECT":
      case "INPUT":
        // TODO: If this is a button type, then what?
        IX.WireUpEventHandler(el, container, proxy, "value", "change", changedEvent);
      break;
    }

    if (container[keyUpEvent]) {
      switch (el.nodeName) {
        case "INPUT":
          // TODO: If this is a button type, then what?
          IX.WireUpEventHandler(el, container, proxy, "value", "keyup", keyUpEvent);
          break;
        }
      }
    }
  });
}</pre>

<p>It should be obvious that this a very incomplete implementation sufficient for the proof-of-concept.</p>

<h4><a name="WireUpEventHandler58">WireUpEventHandler</a></h4>

<p>The event handler that is attached the event listener implements a custom check for the <code>SELECT</code> HTML element and makes the assumption that the class property has been initialized with an <code>IXSelector</code> instance.&nbsp; This was done so that the selected item's text and value could be assigned on selection to the <code>IXSelector</code> instance.&nbsp; Otherwise, the event handler updates the class' property (as in, the class that has been proxied.)&nbsp; Because "buttons" don't have a property but are just an event, we check if there is actually a property on the DOM that needs to be read and set on the corresponding class property.&nbsp; Lastly, if the class implements an event handler, any multicast events are fired.&nbsp; A custom converter, if defined in the class, is invoked first for non-button events.</p>

<p><span id="prehide724730" onclick="processCodeBlocks.togglePre(724730);">Hide</span>  &nbsp; <span id="preShrink724730" onclick="processCodeBlocks.shrinkExpand(724730);">Shrink</span> <img id="preimg724730" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(724730);">  &nbsp; <span id="copycode724730" onclick="return processCodeBlocks.copyCode(724730);">Copy Code</span></p><pre id="pre724730" processed="true">private static WireUpEventHandler&lt;T&gt;(el: HTMLElement, container: T, proxy: T, propertyName: string, eventName: string, handlerName: string) {
  el.addEventListener(eventName, ev =&gt; {
    let el = ev.srcElement as HTMLElement;
    let oldVal = undefined;
    let newVal = undefined;
    let propName = undefined;
    let handler = container[handlerName];

    switch (el.nodeName) {
      case "SELECT":
        let elSelector = el as HTMLSelectElement;
        let selector = container[el.id] as IXSelector;
        selector.value = elSelector.value;
        selector.text = elSelector.options[elSelector.selectedIndex].text;
        break;

      default:
        // buttons are click events, not change properties.
        if (propertyName) {
          oldVal = container[el.id];
          newVal = el[propertyName];
          propName = el.id;
        }

        let ucPropName = IX.UpperCaseFirstChar(propName ?? "");

        if (propertyName) {
          newVal = IX.CustomConverter(proxy, ucPropName, newVal);
          container[propName] = newVal;
        }

        break;
    }

    if (handler) {
      (handler as IXEvent).Invoke(newVal, proxy, oldVal);
    }
  });
}</pre>

<p>Again, enough to implement the proof-of-concept.&nbsp;</p>

<h4><a name="CustomConverter59">CustomConverter</a></h4>

<p><span id="prehide296860" onclick="processCodeBlocks.togglePre(296860);">Hide</span>  &nbsp; <span id="copycode296860" onclick="return processCodeBlocks.copyCode(296860);">Copy Code</span></p><pre id="pre296860">private static CustomConverter&lt;T&gt;(container: T, ucPropName: string, newVal: string): any {
  let converter = `onConvert${ucPropName}`;

  if (container[converter]) {
    newVal = container[converter](newVal);
  }

  return newVal;
}</pre>

<h3><a name="CreateButtonHandlers60">CreateButtonHandlers</a></h3>

<p>Buttons (and button-like things, like checkboxes and radio buttons) have their own unique requirements.&nbsp; Checkboxes and radio buttons (which are <code>INPUT</code> HTML elements) have a <code>checked</code> property, whereas buttons do not.&nbsp; The proxy'd class must implement the expected "on...." which must be assigned to an <code>IXEvent</code> to support multicast events.</p>

<p><span id="prehide8239" onclick="processCodeBlocks.togglePre(8239);">Hide</span>  &nbsp; <span id="preShrink8239" onclick="processCodeBlocks.shrinkExpand(8239);">Shrink</span> <img id="preimg8239" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(8239);">  &nbsp; <span id="copycode8239" onclick="return processCodeBlocks.copyCode(8239);">Copy Code</span></p><pre id="pre8239" processed="true">private static CreateButtonHandlers&lt;T&gt;(container: T, proxy: T) {
  Object.keys(container).forEach(k =&gt; {
    if (k.startsWith("on") &amp;&amp; k.endsWith("Clicked")) {
      let elName = IX.LeftOf(IX.LowerCaseFirstChar(k.substring(2)), "Clicked");
      let el = document.getElementById(elName);
      let anonEl = el as any;

      if (el) {
        if (!anonEl._proxy) {
        anonEl._proxy = this;
      }

      if (!anonEl._clickEventWiredUp) {
        anonEl._clickEventWiredUp = true;

        switch (el.nodeName) {
          case "BUTTON":
            IX.WireUpEventHandler(el, container, proxy, null, "click", k);
            break;

          case "INPUT":
            // sort of not necessary to test type but a good idea, especially for checkboxes and radio buttons.
            let typeAttr = el.getAttribute("type");

            if (typeAttr == "checkbox" || typeAttr == "radio") {
              IX.WireUpEventHandler(el, container, proxy, "checked", "click", k);
            } else {
              IX.WireUpEventHandler(el, container, proxy, null, "click", k);
            }

            break;
          }
        }
      }
    }
  });
}</pre>

<h3><a name="CreateBinders61">CreateBinders</a></h3>

<p>Binders handle real-time events such as keyup as well as when an input element loses focus.&nbsp; Adding to the complexity is the concept that a binder might be associated with multiple checkboxes or radio buttons and bind the list of currently selected items.&nbsp; This is a confusing piece of code, as both array and non-array properties can be bound.&nbsp; It is assumed that if an array is being bound, the array is populated with the selected checkboxes or radio buttons (though technically, a radio button should be exclusive.)&nbsp; Otherwise, the property itself is set with either the checked state or the element's value.&nbsp; Lastly, an optional "op" (operation) can be defined before the value is set <i>on the proxy</i>.&nbsp; Setting the value on the proxy rather than the <i>proxy'd</i> object invokes the proxy setter which can define further behaviors but ultimately also assigns the value to the original container object.</p>

<p><span id="prehide400168" onclick="processCodeBlocks.togglePre(400168);">Hide</span>  &nbsp; <span id="preShrink400168" onclick="processCodeBlocks.shrinkExpand(400168);">Shrink</span> <img id="preimg400168" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(400168);">  &nbsp; <span id="copycode400168" onclick="return processCodeBlocks.copyCode(400168);">Copy Code</span></p><pre id="pre400168" processed="true">// We assume binders are created on input elements. Probably not a great assumption.
private static CreateBinders&lt;T&gt;(container: T, proxy: T): void {
  Object.keys(container).forEach(k =&gt; {

    if (container[k].binders?.length ?? 0 &gt; 0) {
      let binderContainer = container[k] as IXBinder;
      let binders = binderContainer.binders as IXBind[];

      if (binderContainer.asArray) {
        binders.forEach(b =&gt; {
          let elName = b.bindFrom;
          let el = document.getElementById(elName);

          let typeAttr = el.getAttribute("type");

          // Limited support at the moment.
          if (typeAttr == "checkbox" || typeAttr == "radio") {
            el.addEventListener("click", ev =&gt; {
              let values: string[] = [];

              // Get all the items currently checked
                binders.forEach(binderItem =&gt; {
                  let boundElement = (document.getElementById(binderItem.bindFrom) as HTMLInputElement);
                  let checked = boundElement.checked;

                  if (checked) {
                    values.push(boundElement[binderItem.attribute]);
                  }
                });

                let ret = binderContainer.arrayOp(values);
                proxy[k] = ret;
              });
            }
          });
        } else {
          binders.forEach(b =&gt; {
            let elName = b.bindFrom;
            let el = document.getElementById(elName);
            console.log(`Binding receiver ${k} to sender ${elName}`);

            let typeAttr = el.getAttribute("type");
  
            if (typeAttr == "checkbox" || typeAttr == "radio") {
              el.addEventListener("click", ev =&gt; {
                let boundAttr = b.attribute ?? "checked";
                let v = String((ev.currentTarget as HTMLInputElement)[boundAttr]);
                v = b.op === undefined ? v : b.op(v);
                proxy[k] = v;
              });
            } else {
              // Realtime typing
              el.addEventListener("keyup", ev =&gt; {
                let v = (ev.currentTarget as HTMLInputElement).value;
                // proxy[elName] = v; --- why?
                v = b.op === undefined ? v : b.op(v);
                proxy[k] = v;
              });

              // Lost focus, or called when value is set programmatically in the proxy setter.
              el.addEventListener("changed", ev =&gt; {
                let v = (ev.currentTarget as HTMLInputElement).value;
                v = b.op === undefined ? v : b.op(v);
                proxy[k] = v;
              });
          }
        });
      }
    }
  });
}</pre>

<h3><a name="Initialize62">Initialize</a></h3>

<p>This last function started off simple and ended up being more complicated as it needs to handle not just native non-array types, but also arrays and DOM elements like "select":</p>

<p><span id="prehide19675" onclick="processCodeBlocks.togglePre(19675);">Hide</span>  &nbsp; <span id="preShrink19675" onclick="processCodeBlocks.shrinkExpand(19675);">Shrink</span> <img id="preimg19675" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(19675);">  &nbsp; <span id="copycode19675" onclick="return processCodeBlocks.copyCode(19675);">Copy Code</span></p><pre id="pre19675" processed="true">private static Initialize&lt;T&gt;(container: T, proxy: T): void {
  Object.keys(container).forEach(k =&gt; {
    let name = container[k].constructor?.name;

    switch (name) {
      case "String":
      case "Number":
      case "Boolean":
      case "BigInt":
        proxy[k] = container[k]; // Force the proxy to handle the initial value.

        break;

      case "Array":
        // Special handling of arrays that have an initial set of elements so we don't duplicate the elements.
        // At this point, container[k] IS the proxy (IXArrayProxy) so we have the issue that the proxy is set to 
        // the array but the UI elements haven't been created. If we just do: 
        // proxy[k] = container[k]; 
        // This will initialize the UI list but push duplicates of the into the array.

        // So, for arrays, we want to create the array proxy as an empty array during initialization instead,
        // then set the empty proxy to the container, then the container to the proxy.
        if (container[k]._id != k) {
          let newProxy = IXArrayProxy.Create(k, container);
          newProxy[k] = container[k];
          container[k] = newProxy;
        }

        break;

      case "IXSelector":
        // Similar to "Array" above, except we are proxying the IXSelector.options array, not the container itself.
        if (container[k]._id != k) {
          // Set the element that this IXSelector manages so we know what to do when value and text are assigned.
          container[k]._element = document.getElementById(k);
          let selector = container[k] as IXSelector;

          // Proxy the options array so we can initialize it as well as push/pop.
          if (selector.options.length &gt; 0) {
          let newProxy = IXArrayProxy.Create(k, container);
            newProxy[k] = selector.options;
            selector.options = newProxy;
          }
        }

        break;
    }
  });
}</pre>

<h3><a name="Arrays63">Arrays</a></h3>

<p>Arrays are something of nightmare.&nbsp; Array functions, such as <code>push</code>, <code>pop</code>, and <code>length</code>, are actually vectored through the proxy's getter (as would any other function on a proxy'd object):</p>

<p><span id="prehide413092" onclick="processCodeBlocks.togglePre(413092);">Hide</span>  &nbsp; <span id="copycode413092" onclick="return processCodeBlocks.copyCode(413092);">Copy Code</span></p><pre id="pre413092">static ArrayChangeHandler = {
  get: function (obj, prop, receiver) {
  // return true for this special property, so we know that we're dealing with a ProxyArray object.
  if (prop == "_isProxy") {
    return true;
  }

  // Setup for push and pop, preserve state when the setter is called.
  // Very kludgy but I don't know of any other way to do this.
    if (prop == "push") {
    receiver._push = true;
  }

  if (prop == "pop") {
    receiver._pop = true;
  }

  if (prop == "length") {
    return obj[receiver._id].length;
  }

  return obj[prop];
},</pre>

<p>Notice that a flag is being set as to whether the operation about to be performed, in the setter, is a <code>push</code> or <code>pop</code>!&nbsp; This information is used to determine how the array should be adjusted in the setter when the length is changed.&nbsp; Popping an array element, it turns out, merely changes the length of the array:</p>

<p><span id="prehide514368" onclick="processCodeBlocks.togglePre(514368);">Hide</span>  &nbsp; <span id="copycode514368" onclick="return processCodeBlocks.copyCode(514368);">Copy Code</span></p><pre id="pre514368">set: function (obj, prop, val, receiver) {
  // we're looking for this pattern:
  // "setting 0 for someList with value Learn Javascript"
  let id = receiver._id;
  console.log('setting ' + prop + ' for ' + id + ' with value ' + val);

  if (prop == "length" &amp;&amp; receiver._pop) {
    let el = document.getElementById(id);
    let len = obj[id].length;

    for (let i = val; i &lt; len; i++) {
      el.childNodes[val].remove();
      obj[id].pop();
    }

    receiver._pop = false;
  } else {</pre>

<p>If the setter is not a pop, then it is either updating an existing item in the array:</p>

<p><span id="prehide38537" onclick="processCodeBlocks.togglePre(38537);">Hide</span>  &nbsp; <span id="copycode38537" onclick="return processCodeBlocks.copyCode(38537);">Copy Code</span></p><pre id="pre38537">// We might be setting an array item, or we might be doing a push, in either case "prop" is the index value.
if (!isNaN(prop)) {
  let el = document.getElementById(id);
  switch (el.nodeName) {
    // TODO: "UL"!
    case "OL": {
    let n = Number(prop);
    let ol = el as HTMLOListElement;

    if (n &lt; ol.childNodes.length &amp;&amp; !receiver._push) {
      // We are replacing a node
      // innerText or innerHTML?
      (ol.childNodes[n] as HTMLLIElement).innerText = val;</pre>

<p>or we are adding an item to the array:</p>

<p><span id="prehide809937" onclick="processCodeBlocks.togglePre(809937);">Hide</span>  &nbsp; <span id="copycode809937" onclick="return processCodeBlocks.copyCode(809937);">Copy Code</span></p><pre id="pre809937">} else {
  let li = document.createElement("li") as HTMLLIElement;
  let v = val;

  if (val._isTemplate) {
    let t = val as IXTemplate;
    // innerText or innerHTML?
    li.innerText = t.value;
    li.id = t.id;
    v = t.value;
  } else {
    li.innerText = val;
  }

  (el as HTMLOListElement).append(li);
  obj[id].push(v);
  receiver._push = false;
}
</pre>

<p>Lastly, the array property might be being set to a whole new array:</p>

<p><span id="prehide295755" onclick="processCodeBlocks.togglePre(295755);">Hide</span>  &nbsp; <span id="preShrink295755" onclick="processCodeBlocks.shrinkExpand(295755);">Shrink</span> <img id="preimg295755" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(295755);">  &nbsp; <span id="copycode295755" onclick="return processCodeBlocks.copyCode(295755);">Copy Code</span></p><pre id="pre295755" processed="true">} else if (val.constructor.name == "Array") {
  let el = document.getElementById(id);

  // TODO: remove all child elements?

  switch (el.nodeName) {
    case "SELECT":
      (val as IXOption[]).forEach(v =&gt; {
        let opt = document.createElement("option") as HTMLOptionElement;
        opt.innerText = v.text;
        opt.value = String(v.value);
        opt.disabled = v.disabled;
        opt.selected = v.selected;
        (el as HTMLSelectElement).append(opt);
      });
    break;

    case "OL":
    case "UL":
      (val as []).forEach(v =&gt; {
        let li = document.createElement("li") as HTMLLIElement;
        li.innerText = v;
        (el as HTMLOListElement).append(li);
      });
    break;
  }
}</pre>

<h3><a name="IXEvent64">IXEvent</a></h3>

<p><code>IXEvent</code> (and it's helper, <code>IXSubscriber</code>) are wrappers to implement multicast events:</p>

<p><span id="prehide498438" onclick="processCodeBlocks.togglePre(498438);">Hide</span>  &nbsp; <span id="preShrink498438" onclick="processCodeBlocks.shrinkExpand(498438);">Shrink</span> <img id="preimg498438" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(498438);">  &nbsp; <span id="copycode498438" onclick="return processCodeBlocks.copyCode(498438);">Copy Code</span></p><pre id="pre498438" processed="true">export class IXSubscriber {
  subscriber: (obj: any, oldVal: string, newVal: string) =&gt; void;

  constructor(subscriber: (obj: any, oldVal: string, newVal: string) =&gt; void) {
  this.subscriber = subscriber;
}

  Invoke(obj: any, oldVal: string, newVal: string): void {
    this.subscriber(obj, oldVal, newVal);
  }
}

import { IXSubscriber } from "./IXSubscriber"

export class IXEvent {
  subscribers: IXSubscriber[] = [];

  // We probably only usually want the new value, followed by the container, folloed by the old value.
  Add(subscriber: (newVal: string, obj: any, oldVal: string) =&gt; void) : IXEvent {
    this.subscribers.push(new IXSubscriber(subscriber));

    return this;
  }

  Invoke(newVal: string, obj: any, oldVal: string): void {
    this.subscribers.forEach(s =&gt; s.Invoke(newVal, obj, oldVal));
  }
}</pre>

<h3><a name="IXTemplate65">IXTemplate</a></h3>

<p>This class is my lame attempt to provide for templates.</p>

<p><span id="prehide589485" onclick="processCodeBlocks.togglePre(589485);">Hide</span>  &nbsp; <span id="copycode589485" onclick="return processCodeBlocks.copyCode(589485);">Copy Code</span></p><pre id="pre589485">export class IXTemplate {
  public _isTemplate: boolean = true;

  public value?: string;
  public id?: string;

  public static Create(t: any): IXTemplate {
    let template = new IXTemplate();
    template.value = t.value;
    template.id = t.id;

    return template;
  }

  public SetValue(val: string): void {
    document.getElementById(this.id).innerText = val;
  }
}</pre>

<p>This is dubious at best because it sets <code>innerText</code> rather than <code>innerHtml</code>, and I'm really not sure of the usefulness of it except that it's used in the integration tests.</p>

<h2><a name="Conclusion66">Conclusion</a></h2>

<p>Having come to the top of the other end of the U, I'm now reconsidering the entire implementation.</p>

<h3><a name="DoIneedaProxy67">Do I need a Proxy?</a></h3>

<p>By the time I was implementing an example of the comobox, and using this construct:</p>

<p><span id="prehide599899" onclick="processCodeBlocks.togglePre(599899);">Hide</span>  &nbsp; <span id="copycode599899" onclick="return processCodeBlocks.copyCode(599899);">Copy Code</span></p><pre id="pre599899">selector = new IXSelector();</pre>

<p>It occurred to me, hmm, maybe all the class properties that map to DOM elements should be wrapped by an actual "helper."&nbsp; This would allow the wrapper to directly implement the DOM attributes and properties of an element which effectively eliminates the need for a Proxy!&nbsp; It would also eliminate the "make up my own syntax", like:</p>

<p><span id="prehide266038" onclick="processCodeBlocks.togglePre(266038);">Hide</span>  &nbsp; <span id="copycode266038" onclick="return processCodeBlocks.copyCode(266038);">Copy Code</span></p><pre id="pre266038">.Add({ bindFrom: "jane", attribute: "value" })</pre>

<p>or:</p>

<p><span id="prehide934391" onclick="processCodeBlocks.togglePre(934391);">Hide</span>  &nbsp; <span id="copycode934391" onclick="return processCodeBlocks.copyCode(934391);">Copy Code</span></p><pre id="pre934391">mySpan = {
  attr: { title: "" }
};</pre>

<p>The "initialization" process would merely iterate over the class properties (they still have to exist) and initialize the property with the DOM ID, thus the specific implementation can manipulate the DOM directly rather than through a proxy.&nbsp; And I'd still have Intellisense because the wrapper implemention would have the DOM attributes and properties I'd be touching.</p>

<p>Of course, this involves a ton of work - ideally the DOM for each element would have to be re-implemented, and that's just for native HTML elements.&nbsp; What about third party UI libraries?&nbsp; One approach would be to do this a piece at a time, as needed in the web apps that I'd be writing with this framework.&nbsp; Furthermore, I could derive such wrapper classes from the HTML.... interfaces that already exist, for example, <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement"> HTMLButtonElement</a>.&nbsp; That would work, but I also really like the beauty of:</p>

<p><span id="prehide304335" onclick="processCodeBlocks.togglePre(304335);">Hide</span>  &nbsp; <span id="copycode304335" onclick="return processCodeBlocks.copyCode(304335);">Copy Code</span></p><pre id="pre304335">nc.name = "Hello World!";</pre>

<h3><a name="BothProxyandDOMWrapper68">Both Proxy and DOM Wrapper</a></h3>

<p>There's no reason the implementation cannot support both by inspecting the constructor name, as I'm already doing in the initialization process.&nbsp; This would therefore leave it up to the developer:</p>

<ol>
	<li>For native types, a proxy would wrap basic behaviors.</li>	<li>For wrapper types, a proxy would not be used, giving the developer more fine-grained control of the element.</li></ol>

<p>This would also eliminate any arcane syntax that the developer would have to learn, as the wrapper would implement the HTML... interfaces that already exist and with which one would already be familiar.</p>

<p>Also, all that krufty code to handle array push, pop, and assignment would be a lot cleaner!</p>

<h3><a name="TheFutureIsEmerging69">The Future Is Emerging</a></h3>

<p>Therefore I can only conclude that after having gone through the U process, I now know what the future will look like, at least for the framework that <i>I</i> want to use!</p>


						</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>