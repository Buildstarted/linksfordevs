<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Implementing Model View Update Pattern in Typescript - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Implementing Model View Update Pattern in Typescript - linksfor.dev(s)"/>
    <meta property="article:author" content="Volodymyr Kopytin"/>
    <meta property="og:description" content="In this article, we will see how to build a small application in a functional way."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.codeproject.com/Articles/5274726/Implementing-Model-View-Update-Pattern-in-Typescri"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Implementing Model View Update Pattern in Typescript</title>
<div class="readable">
        <h1>Implementing Model View Update Pattern in Typescript</h1>
            <div>by Volodymyr Kopytin</div>
            <div>Reading time: 61-77 minutes</div>
        <div>Posted here: 11 Aug 2020</div>
        <p><a href="https://www.codeproject.com/Articles/5274726/Implementing-Model-View-Update-Pattern-in-Typescri">https://www.codeproject.com/Articles/5274726/Implementing-Model-View-Update-Pattern-in-Typescri</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>In this post, predictable state, selectors, actions, high order components, effects will be the main actors on the playground. Material from this article can be used to learn MVU. It outlines the impact of the functional approach on the shape of the implemented application.</p><div id="contentdiv">
						



<p>The world of applications development is vast and rich. There are small blocks. There are bigger composite abstractions, different programming languages, libraries for the programming languages, new trends, fashions, forgotten treasures, and silent components that have kept unnoticed.</p>

<p>With this article, we will build a small application in a functional way. Predictable state, selectors, actions, high order components, effects will be the main actors on the playground. Material from this article can be used to learn MVU. It can be used as an experimental playground, and will challenge those who seek knowledge about functional development. It outlines the impact of the functional approach on the shape of the implemented application.</p>

<p>Still we keep inventing, re-inventing. Discover and rediscover. For me, everything has begun from the glory of WndProc. The message dispatching system in Windows API. Now the fashion gradually is moving towards functional development. Message dispatching queue, predictable state container, monad functions is the answer to the fashion.</p>

<p><em>When I know - I don't know What I don't know.</em></p>

<ul>
	<li>Working example on <a href="https://jsfiddle.net/vkopytin/ngcbmLho/23/">jsfiddle</a></li>	<li>Full example on <a href="https://github.com/vkopytin/databinding/tree/a9de09173bea7b7526902c9ce94bd5bed02593e1/src/examples/reflux-ts">github</a></li></ul>

<h2>Model View Update (MVU) - Existing, Re-invented, Re-discovered</h2>

<p>MVU is the design pattern that has gradually emerged from functional programming languages. In the earlier stages, Object Oriented Programming (OOP) was taking the first small steps. Existing developers used the functional paradigm, monads operator abstractions, functional <code>map</code> and <code>reduce</code> operators while resolving requirements. Let's try to follow the functional software path and resolve the task like it could be done with the modern technologies. What limits are there? Are those limits real? Maybe it was a trade deal in favour of OOP fashion.</p>

<h2>Sub Layers in the Draft MVU</h2>

<p>Since MVU is another design pattern. Similar to MVC, MVVM would have a similar high layer ecosystem such as data transfer, model, view layers. More about those layers can be found in the article <a href="https://www.codeproject.com/Articles/5265632/Introducing-MVVM-Architecture-in-JavaScript-TypeSc">Introducing MVVM Architecture</a>. In this article, let's focus on the difference. The view layer has a different shape. Since at our responsibility just functions. The state of the application is going to be updated frequently. Only some state updates are related to UI changes. There should be a tool that would pick and update only a part of the UI that is actually changed. The rest of the UI will be the same. There is a modern concept to it. It is a Virtual DOM. Since the full vDom is a big task. Here will be just a small version. Enough, to show the general idea.</p>

<h3>Virtual DOM</h3>

<p>It is separated into three parts:</p>

<ol>
	<li>Template - will keep markup that describes the shape of the View</li>	<li>DOM - to work with browser elements</li>	<li>Virtual DOM - to produce initial views and perform small updates</li></ol>

<p>It would provide the method to locate elements on UI. Elements that are bound to an updated part of the state. From the start, the task sounds a bit strange. However, it has a clever solution. Let's check the implementation and try to understand the most important parts.</p>

<p>This is what could be done with the UI in terms of DOM entities:</p>

<p><span id="prehide861416" onclick="processCodeBlocks.togglePre(861416);">Hide</span>  &nbsp; <span id="preShrink861416" onclick="processCodeBlocks.shrinkExpand(861416);">Shrink</span> <img id="preimg861416" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(861416);">  &nbsp; <span id="copycode861416" onclick="return processCodeBlocks.copyCode(861416);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre861416" processed="true"><span>const</span> dom = {
    eventHandlers: [],
    closest(el, selector) {
        <span>return</span> el.closest(selector);
    },
    attach(inst, selector, eventName, fn) {
        <span>const</span> pair = dom.eventHandlers.find(([key]) =&gt; fn === key);
        <span>const</span> index = dom.eventHandlers.indexOf(pair);
        <span>if</span> (index &gt;= <span>0</span>) {
            <span>throw</span> <span>new</span> Error(<span>`</span>Event handler ${fn} for event ${eventName} already attached`);
        }
        let detach;
        const handler = function (evnt) {
            if (selector &amp;&amp; dom.closest(evnt.target, selector)) {
                fn(evnt);
            } else if (!selector) {
                fn(evnt);
            }
        };
        inst.addEventListener(eventName, handler);
        dom.eventHandlers.push([fn, handler]);
        return detach = function () {
            const pair = dom.eventHandlers.find(([, h]) =&gt; handler === h);
            const index = dom.eventHandlers.indexOf(pair);
            if (index &gt;= <span>0</span>) {
                inst.removeEventListener(eventName, handler);
            } <span>else</span> {
                <span>throw</span> <span>new</span> Error(<span>`</span>Error in detach result. 
                      Can't detach unexisting ${eventName} handler`);
            }
        };
    },
    detach(inst, eventName, fn) {
        const pair = dom.eventHandlers.find(([key]) =&gt; fn === key) || [];
        const [, handler] = pair;
        const index = dom.eventHandlers.indexOf(pair);
        if (index &gt;= <span>0</span>) {
            dom.eventHandlers.splice(index, <span>1</span>);
            inst.removeEventListener(eventName, handler);
        } <span>else</span> {
            setTimeout(() =&gt; {
                <span>throw</span> <span>new</span> Error(<span>`</span>Error in detach method. 
                      Can't detach unexisting ${eventName} handler`);
            });
        }
    },
    el(type, attrs, ...children) {
        attrs = attrs || {};
        children = [].concat(...children);
        const el = document.createElement(type);
        const attrNames = Object.keys(attrs);
        attrNames.forEach(attrName =&gt; {
            if (attrName in EVENT_NAMES) {
                const eventName = EVENT_NAMES[attrName];
                dom.attach(el, '', eventName, attrs[attrName]);
            } else if (attrName in el) {
                el[attrName] = attrs[attrName];
            } else {
                el.setAttribute(attrName, attrs[attrName]);
            }
        });
        for (const child of [...children]) {
            el.append(child);
        }

        return el;
    }
};</pre>

<p>Strange feeling from the first look. All that is really needed is just attach/detach events and create elements. Despite that small list of tools. All that is here is really important. Events will be attached and detached very frequently. In the worst case with every state update. Sounds pretty creepy. It can be optimized. The optimization part would depend on the implementation.</p>

<p>The second sub layer is more interesting. It would contain more operations on the DOM. Those operations are related to comparing changes on the Virtual DOM. Perform update UI when needed. The UI is going to be updated when the state update has something to show.</p>

<p>The virtual DOM - second part of the DOM manipulations.</p>

<p><span id="prehide198382" onclick="processCodeBlocks.togglePre(198382);">Hide</span>  &nbsp; <span id="preShrink198382" onclick="processCodeBlocks.shrinkExpand(198382);">Shrink</span> <img id="preimg198382" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(198382);">  &nbsp; <span id="copycode198382" onclick="return processCodeBlocks.copyCode(198382);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre198382" processed="true"><span>import</span> { dom } from <span>'</span><span>./dom'</span>;
<span>import</span> { arrayMerge } from <span>'</span><span>./utils'</span>; 


<span>export</span> <span>const</span> EVENT_NAMES = {
    onClick: <span>'</span><span>click'</span>,
    onInput: <span>'</span><span>input'</span>,
    onKeyPress: <span>'</span><span>keypress'</span>,
    onChange: <span>'</span><span>change'</span>,
    onSubmit: <span>'</span><span>submit'</span>,
    onKeyDown: <span>'</span><span>keydown'</span>,
    onKeyUp: <span>'</span><span>keyup'</span>,
    onBlur: <span>'</span><span>blur'</span>,
    onMouseDown: <span>'</span><span>mousedown'</span>
};

<span>export</span> <span>const</span> propConverters = {
    contentEditable: <span>function</span> (value) {
        <span>return</span> !!value;
    },
    convert(propName, value) {
        <span>if</span> (propName <span>in</span> propConverters) {
            <span>return</span> propConverters[propName](value);
        }
        <span>return</span> value;
    }
};

<span>export</span> <span>function</span> el(type, attrs = {}, ...children) {
    children = [].concat(...children)
        .filter(a =&gt; [<span>undefined</span>, <span>true</span>, <span>false</span>].indexOf(a) === -1)
        .map(item =&gt; ([<span>'</span><span>object'</span>, <span>'</span><span>function'</span>].indexOf(<span>typeof</span> item) === -1 ? <span>'</span><span>'</span> + item : item));
    <span>if</span> (<span>typeof</span> type === <span>'</span><span>function'</span>) {
        <span>return</span> type({ ...attrs, store: currentStore, 
        children: children.length &gt; <span>1</span> ? children : children[<span>0</span>] }, children);
    }

    <span>return</span> {
        type,
        attrs,
        children
    };
}

<span>export</span> <span>let</span> currentStore = <span>null</span>;

<span>export</span> <span>function</span> makeVdom(oldDom, store) {
    currentStore = store;
    <span>function</span> createElement(node) {
        <span>if</span> (node === <span>undefined</span>) {
            <span>return</span> <span>document</span>.createTextNode(<span>'</span><span>'</span>);
        }
        <span>if</span> ([<span>'</span><span>object'</span>, <span>'</span><span>function'</span>].indexOf(<span>typeof</span> node) === -1) {
            <span>return</span> <span>document</span>.createTextNode(node);
        }
        <span>if</span> (<span>typeof</span> node.type === <span>'</span><span>function'</span>) {
            <span>const</span> { children = [] } = node;
            <span>const</span> [first] = children;
            <span>const</span> $el = createElement(first);
            patch($el, node.type, { ...node.attrs, store });
            <span>return</span> $el;
        }
        <span>const</span> { type, attrs = {}, children } = node;
        <span>const</span> { ref, ...attributes } = (attrs || {});
        <span>const</span> el = dom.el(type, attributes, 
                   ...[].concat(children).map(child =&gt; createElement(child)));
        <span>return</span> el;
    }

    <span>function</span> compare($el, newNode, oldNode) {
        <span>if</span> (<span>typeof</span> newNode !== <span>typeof</span> oldNode) {
            <span>return</span> <span>true</span>;
        }
        <span>if</span> ([<span>'</span><span>object'</span>, <span>'</span><span>function'</span>].indexOf(<span>typeof</span> newNode) === -1) {
            <span>if</span> (newNode !== oldNode) {
                <span>const</span> oldValue = $el.textContent;
                <span>if</span> (oldValue !== newNode) {
                    <span>return</span> <span>true</span>;
                }
            }
            <span>return</span> <span>false</span>;
        }
        <span>return</span> newNode.type !== oldNode.type
    }

    <span>function</span> updateAttribute($el, newValue, oldValue, key) {
        <span>if</span> (oldValue === <span>undefined</span>) {
            $el.setAttribute(key, newValue);
        } <span>else</span> <span>if</span> (newValue === <span>undefined</span>) {
            $el.removeAttribute(key);
        } <span>else</span> <span>if</span> (newValue !== oldValue) {
            $el.setAttribute(key, newValue);
        }
    }

    <span>function</span> updateProperty($el, newValue, oldValue, key) {
        <span>const</span> oldElValue = $el[key];
        <span>if</span> (oldValue === <span>undefined</span>) {
            <span>if</span> (oldElValue !== newValue) {
                $el[key] = propConverters.convert(key, newValue);
            }
        } <span>else</span> <span>if</span> (newValue === <span>undefined</span>) {
            <span>if</span> (oldElValue !== newValue) {
                $el[key] = propConverters.convert(key, newValue);
            }
        } <span>else</span> <span>if</span> (newValue !== oldValue) {
            <span>if</span> (oldElValue !== newValue) {
                $el[key] = propConverters.convert(key, newValue);
            }
        }
    }

    <span>function</span> updateEvent($el, newHandler, oldHandler, key) {
        <span>const</span> eventName = EVENT_NAMES[key];
        <span>if</span> (!oldHandler) {
            dom.attach($el, <span>'</span><span>'</span>, eventName, newHandler);
        } <span>else</span> <span>if</span> (!newHandler) {
            dom.detach($el, eventName, oldHandler);
        } <span>else</span> {
            dom.detach($el, eventName, oldHandler);
            dom.attach($el, <span>'</span><span>'</span>, eventName, newHandler);
        }
    }

    <span>function</span> updateAttributes($el, newAttrs, oldAttrs) {
        newAttrs = newAttrs || {};
        oldAttrs = oldAttrs || {}
        <span>const</span> newKeys = Object.keys(newAttrs);
        <span>const</span> oldKeys = Object.keys(oldAttrs);
        <span>const</span> allKeys = arrayMerge(newKeys, oldKeys);
        <span>for</span> (<span>const</span> key of allKeys) {
            <span>if</span> (key <span>in</span> EVENT_NAMES) {
                updateEvent($el, newAttrs[key], oldAttrs[key], key);
            } <span>else</span> <span>if</span> (key <span>in</span> $el) {
                updateProperty($el, newAttrs[key], oldAttrs[key], key);
            } <span>else</span> {
                updateAttribute($el, newAttrs[key], oldAttrs[key], key);
            }
        }
    }

    <span>function</span> detachEvents($el, oldAttrs) {
        oldAttrs = oldAttrs || {}
        <span>const</span> oldKeys = Object.keys(oldAttrs);
        <span>for</span> (<span>const</span> key of oldKeys) {
            <span>if</span> (key <span>in</span> EVENT_NAMES) {
                updateEvent($el, <span>undefined</span>, oldAttrs[key], key);
            }
        }
    }

    <span>function</span> updateElement($parent, newNode, oldNode, index = <span>0</span>) {
        <span>let</span> nodesToRemove = [];
        <span>if</span> (!oldNode) {
            $parent.appendChild(
                createElement(newNode)
            );
        } <span>else</span> <span>if</span> (!newNode) {
            detachEvents($parent.childNodes[index], oldNode.attrs);
            nodesToRemove.push($parent.childNodes[index]);
        } <span>else</span> <span>if</span> (compare($parent.childNodes[index], newNode, oldNode)) {
            detachEvents($parent.childNodes[index], oldNode.attrs);
            $parent.replaceChild(
                createElement(newNode),
                $parent.childNodes[index]
            );
        } <span>else</span> <span>if</span> (newNode.type) {
            updateAttributes($parent.childNodes[index], newNode.attrs, oldNode.attrs);
            <span>const</span> length = <span>Math</span>.max(newNode.children.length, oldNode.children.length);
            <span>for</span> (<span>let</span> i = <span>0</span>; i &lt; length; i++) {
                nodesToRemove = [
                    ...nodesToRemove,
                    ...updateElement(
                        $parent.childNodes[index],
                        newNode.children[i],
                        oldNode.children[i],
                        i
                    )];
            }
        }
        <span>if</span> (newNode &amp;&amp; newNode.attrs &amp;&amp; newNode.attrs.ref) {
            newNode.attrs.ref($parent.childNodes[index]);
        }
        <span>return</span> nodesToRemove;
    }

    <span>function</span> patch($el, view, props = {}) {
        <span>const</span> newDom = view({
            ...props,
            store,
            render(props) { patch($el, view, props); }
        });
        <span>const</span> removedNodes = updateElement($el, newDom, oldDom);
        removedNodes.map(node =&gt; node.parentElement.removeChild(node));
        oldDom = newDom;
    }

    <span>return</span> patch;
}</pre>

<p>Here, I would omit the part that describes the main approach on how to find differences and apply changes. It is described in this article: <a href="https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060">How to write your own Virtual DOM</a>. Here, I will focus on new parts that are related to the integration.</p>

<p>The main function here is <code>makeVdom</code>. This is the initialization method. It creates an initial Virtual DOM state. It takes two parameters: <code>oldDom</code> and <code>state</code>. <code>OldDom</code> is <code>null</code> by default. It will keep the previous version of the Virtual DOM. Used to compare changes and produce updates on UI. <code>state</code> is to provide the global state of the application into every component. The global state will be injected into every render component method. <code>makeVdom</code> function returns <code>patch</code> function. The <code>patch</code> function is going to be called very frequently. On render initial UI, refresh UI when state is updated, render/re-render child components. The <code>el</code> function will be used in JSX/TSX templates.</p>

<h2>Global Predictable State</h2>

<p>If in OOP state of the application is highly parted. As a member of the classes. In the functional paradigm, the state is less partitioned. Ideally, it is just one big hierarchical data structure. Keeps all state in a single place. Good part, <span>the global state</span><span> is easy to manage. Reads can be performed in parallel. The trickiest part is when it comes to updating the global state. Sequential updates are ideal to modify global state. When several functions are to update the state. Only one function performs an update. The next coming functions are queued, waiting for the future execution.</span></p>

<h3>The Store</h3>

<p><span id="prehide213036" onclick="processCodeBlocks.togglePre(213036);">Hide</span>  &nbsp; <span id="preShrink213036" onclick="processCodeBlocks.shrinkExpand(213036);">Shrink</span> <img id="preimg213036" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(213036);">  &nbsp; <span id="copycode213036" onclick="return processCodeBlocks.copyCode(213036);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre213036" processed="true"><span>export</span> <span>function</span> createStore(reducer, initialState, enhancer = <span>null</span>) {
    <span>const</span> currentReducer = reducer;
    <span>let</span> currentState = initialState;
    <span>const</span> listeners = [];

    <span>if</span> (enhancer) {
        <span>return</span> enhancer(createStore)(
            reducer,
            initialState
        );
    }

    <span>return</span> {
        getState() {
            <span>return</span> currentState;
        },
        dispatch(action) {
            currentState = currentReducer(currentState, action);
            listeners.map(listener =&gt; listener(currentState));
            <span>return</span> action;
        },
        subscribe(newListener) {
            listeners.push(newListener);
            <span>return</span> <span>function</span> () {
                <span>const</span> index = listeners.indexOf(newListener);
                <span>if</span> (index &gt;= <span>0</span>) {
                    listeners.splice(index, <span>1</span>);
                }
            };
        }
    };
}</pre>

<p>A <code>getState</code> method - provides a way to request global state. A <code>dispatch method</code> - provides a queue for sequential state updates. <code>subscribe</code> - method to listen for updates on store and refresh view. More information about creating a store is described in this article: <a href="https://blog.jakoblind.no/learn-redux-by-coding-a-mini-redux/">Learn Redux by coding a Mini-Redux</a>.</p>

<p>Please, note. It comes from a similar story about what was done with Virtual DOM. Now it is for the state. The second part of the store is the composition of creating state functions. Here are the rules how the final state of the store can be organised. More on that is well described in the article: <a href="https://blog.jakoblind.no/learn-react-redux-by-coding-the-connect-function-yourself/">Code your own Redux part 2: the connect function</a>.</p>

<p><span id="prehide787977" onclick="processCodeBlocks.togglePre(787977);">Hide</span>  &nbsp; <span id="preShrink787977" onclick="processCodeBlocks.shrinkExpand(787977);">Shrink</span> <img id="preimg787977" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(787977);">  &nbsp; <span id="copycode787977" onclick="return processCodeBlocks.copyCode(787977);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre787977" processed="true"><span>import</span> { createStore } from <span>'</span><span>./createStore'</span>;
<span>import</span> { reducer } from <span>'</span><span>./reducers'</span>;
<span>import</span> { rootEffect } from <span>'</span><span>./components'</span>;


<span>export</span> <span>default</span> <span>function</span> compose(...funcs: Function[]) {
    <span>if</span> (funcs.length === <span>0</span>) {
      
      <span>return</span> &lt;t&gt;(arg: T) =&gt; arg
    }
  
    <span>if</span> (funcs.length === <span>1</span>) {
      <span>return</span> funcs[<span>0</span>]
    }
  
    <span>return</span> funcs.reduce((a, b) =&gt; (...args: any) =&gt; a(b(...args)))
}




<span>export</span> <span>function</span> applyMiddleware(...middlewares) {
    <span>return</span> <span>function</span> (createStoreFn: <span>typeof</span> createStore) {
        <span>return</span> <span>function</span> (reducer, initialState) {
            <span>const</span> store = createStoreFn(reducer, initialState);
            <span>let</span> dispatch = (action, ...args) =&gt; { <span>throw</span> Error
                (<span>`</span>Dispatching {${JSON.stringify(action)}} while creating middleware`) };
            const middlewareAPI = {
                getState: store.getState,
                dispatch: (action, ...args) =&gt; dispatch(action, ...args)
            }
            const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));
            dispatch = compose(...chain)(store.dispatch);

            return {
                ...store,
                dispatch
            };
        };
    }
}

function effectsMiddleware(store) {

    setTimeout(() =&gt; {
        store.dispatch({ type: '@INIT' });
    });

    let handler = rootEffect();

    return function (dispatch) {

        return function (action) {
            const ret = dispatch(action);

            for (const a of [].concat(...handler(action, store.getState(), 
                 (a) =&gt; store.dispatch(a)))) {
                store.dispatch(a);
            }

            return ret;
        };
    };
}

const createThunkMiddleware = (extraArgument?) =&gt; 
                       ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
    if (typeof action === 'function') {
        return action(dispatch, getState, extraArgument);
    }

    return next(action);
};

var thunk = createThunkMiddleware();

export const store = createStore(reducer, { items: [], itemName: '' }, applyMiddleware(
    thunk,
    effectsMiddleware
));
<span>&lt;</span><span>/t</span><span>&gt;</span></pre>

<p>This complex layer is responsible for the shape of the state. Custom processing of the state after <code>update</code>. When a store message is dispatched to the store. In OOP, it could be ingested per class. With the help of the Observer pattern. Eventually if to take a close look at the <code>effectsMiddleware</code> function. There is emerging another design pattern from the OOP - Publish Subscribe.</p>

<p>The other legacy of the functional paradigm is that there is nothing to make new. Every solution looks similar to each other. The whole application looks like a one composite function. It is like an emitting waves star. And the only way to measure it is to send input data and observe output.</p>

<p>The storage is the updating state system and it is a message dispatching hub. Every time a new message is dispatched to the store, it would update state according to the rules. Defined in reducers. Refresh views, defined in templates. Then the message, along with the updated state, will be passed for the extra processing to the <code>rootEffect</code> routine.</p>

<p>To get a better vision on the store and global state, let's try to find similarities between DOM elements, DOM events and DOM element properties. The DOM is declarative by nature. And Store is functional by nature. The main entry into the functional world. A store with Views listens to DOM updates. Transforms DOM events with properties into messages. Observe and synchronise relevant property values from the DOM elements with the global state.</p>

<p>The last block to complete the picture is the <code>connect</code> method.</p>

<p><span id="prehide945140" onclick="processCodeBlocks.togglePre(945140);">Hide</span>  &nbsp; <span id="copycode945140" onclick="return processCodeBlocks.copyCode(945140);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre945140"><span>export</span> <span>function</span> connect(mapStateToProps, mapDispatchToProps) {
    <span>let</span> unsubscribe = () =&gt; { };
    <span>return</span> <span>function</span> (wrappedTemplate) {
        <span>return</span> <span>function</span> (p) {
            <span>const</span> { render, store = vdom.currentStore, ...props } = p;
            unsubscribe();
            unsubscribe = store.subscribe((state) =&gt; {
                render &amp;&amp; render(props);
            });

            <span>return</span> wrappedTemplate({
                ...props,
                ...mapStateToProps(store.getState(), props),
                ...mapDispatchToProps(store.dispatch, props)
            });
        }
    }
}</pre>

<p>This function "connects" both paradigms, declarative approach and functional. The <code>store.subscribe</code> method is for the declarative part. On subscribe the <code>render</code> method is called. The whole view will be re-rendered, updated according to the store state. The <code>rootEffect</code> is for the functional part. Do you see how it is important to be connected in our time? ;)</p>

<p>On this step, just for easy comprehension. The store can be treated as the functional DOM adapter. Every <code>onclick</code>, <code>onchange</code>, etc. events are messages. Every DOM element property is a part of the state. Similarly, we attach listeners to the DOM elements and read, for instance, <code>value</code> property. Same we can do now with the help of the <code>rootEffect</code> method. It is described at the end of the article. This time about the messages and state. Every element can have many events. And DOM eventually can have many elements. Now you can imagine the amount of kinds of messages that could be produced by this setup. We can think in the same way for the DOM element properties. This is the perfect input system. It allows to control any part of the UI at any moment in any way. The central commands dispatching queue with sequential updates. Similar to the command line. The functional universe was just born. Instead of display, it can listen and talk.</p>

<h2>Action Messages and State Snippet Reducers</h2>

<p>Till now, the application is mute. Let's break the silence. The form in which applications can update the state and dispatch events is well described in this article: <a href="https://blog.jakoblind.no/reduce-redux-boilerplate/">Three ways to reduce the Redux boilerplate (and become more productive)</a>. The simple idea is to treat state updating tasks as simple <code>update</code> operations. Then all reducers can be separated per low level tasks. Sort of like how we program work with DataBase tables. <code>Insert</code>, <code>update</code>, <code>delete</code> operations.</p>

<p>In regards to this idea, it was introduced in the <code>declareActions</code> function.</p>

<p><span id="prehide982337" onclick="processCodeBlocks.togglePre(982337);">Hide</span>  &nbsp; <span id="preShrink982337" onclick="processCodeBlocks.shrinkExpand(982337);">Shrink</span> <img id="preimg982337" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(982337);">  &nbsp; <span id="copycode982337" onclick="return processCodeBlocks.copyCode(982337);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre982337" processed="true"><span>export</span> <span>function</span> createReducer (initialState) {
   <span>return</span> (reducerMap) =&gt; (state = initialState, action) =&gt; {
        <span>const</span> reducer = reducerMap[action.type];
        <span>return</span> reducer ? reducer(state, action) : state;
    }
};

type UnionToIntersection&lt;U&gt; = (U <span>extends</span> any
    ? (k: U) =&gt; <span>void</span>
    : any) <span>extends</span> ((k: infer I) =&gt; <span>void</span>)
    ? I
    : any;

type ActionArg&lt;Y, T&gt; = T <span>extends</span> (a: keyof Y, b: infer I, c?) =&gt; any ? I : any;

<span>export</span> <span>function</span> declareActions&lt;T <span>extends</span> {
    [type <span>in</span> keyof T]: {
        [name <span>in</span> keyof T[K]]: (type: type, props: P, meta?) =&gt; any;
    };
}, K <span>extends</span> keyof T, KK <span>extends</span> keyof UnionToIntersection&lt;T[K]&gt;, 
   P, O <span>extends</span> UnionToIntersection&lt;T[K]&gt;&gt;(
    actions: T
): [{ [key <span>in</span> KK]: (args?: ActionArg&lt;T, O[KK]&gt;, meta?) =&gt; any }, { [key <span>in</span> K]: K }, any] {
    <span>const</span> reducers = {};
    <span>const</span> keys = Object.keys(actions);
    <span>const</span> resActions = keys.reduce((res, type) =&gt; {
        <span>const</span> actionDecl = actions[type];
        <span>let</span> left = res[<span>0</span>],
            right = res[<span>1</span>];
        <span>const</span> actionNames = Object.keys(actionDecl);
        <span>const</span> reducer = actionDecl.reducer;
        <span>if</span> (reducer) {
            reducers[type] = reducer;
        }
        <span>const</span> actionFn = actionDecl[actionNames[<span>0</span>]];
        left = { ...left, [actionNames[<span>0</span>]]: (props, meta) =&gt; actionFn(type, props, meta) };
        right = { ...right, [type]: type };

        <span>return</span> [left, right];
    }, [{}, {}]);
    <span>return</span> [...resActions, createReducer({})(reducers)] as any;
}

<span>export</span> <span>const</span> selectPayload = ({ payload }) =&gt; payload;</pre>

<p>It is a building method. F<span>or simple update state commands. </span><span>It allows to build message processing blocks (reducers). Along with messages (actions) and message types. The tradeoff is that it dictates the following format for the message.</span></p>

<p>The shape of the action message.</p>

<p><span id="prehide789828" onclick="processCodeBlocks.togglePre(789828);">Hide</span>  &nbsp; <span id="copycode789828" onclick="return processCodeBlocks.copyCode(789828);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre789828">{
    type: <span>"</span><span>UI_CREATE_TODO"</span>,
    payload: {
        title: <span>"</span><span>New todo item title"</span>
    }
}</pre>

<p>Here below are listed all constructions that are responsible for the shape of the global state.</p>

<p>This is how it is going to be updated for the todo list.</p>

<p><span id="prehide795290" onclick="processCodeBlocks.togglePre(795290);">Hide</span>  &nbsp; <span id="preShrink795290" onclick="processCodeBlocks.shrinkExpand(795290);">Shrink</span> <img id="preimg795290" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(795290);">  &nbsp; <span id="copycode795290" onclick="return processCodeBlocks.copyCode(795290);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre795290" processed="true"><span>export</span> <span>const</span> [MainActions, MainActionTypes, mainReducer] = declareActions({
    UI_CREATE_TODO: {
        uiCreateTodo: (type, payload) =&gt; ({ type, payload })
    },
    UI_UPDATE_NEW_TITLE: {
        uiUpdateNewTodoTitle: (type, payload) =&gt; ({ type, payload })
    },
    UI_TOGGLE_ALL_COMPLETE: {
        uiToggleAllComplete: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                toggleAllComplete: payload
            };
        }
    },
    UI_SET_ACTIVE_FILTER: {
        uiSetActiveFilter: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                activeFilter: payload
            };
        }
    },
    UI_CLEAR_COMPLETED: {
        uiClearCompleted: (type, payload) =&gt; ({ type, payload })
    },
    UPDATE_MAIN_NEW_TODO_TITLE: {
        updateNewTodoTitle: (type, payload: string) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                newTodoTitle: payload
            };
        }
    },
    UPDATE_MAIN_ITEMS: {
        updateItems: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                items: payload,
                activeItems: selectActiveItems(payload),
                completeItems: selectCompleteItems(payload)
            }
        }
    }
});</pre>

<p>In regards to naming of the messages, there are messages that come from a UI. Those messages are named with the prefix <code>UI_</code>. Others, that could cause UI updates. For updating a global state. Triggering async operations don't have any prefix. This small convention would help to focus on UI related stuff and the rest.</p>

<p>This is how the one list item is going to be updated.</p>

<p><span id="prehide62911" onclick="processCodeBlocks.togglePre(62911);">Hide</span>  &nbsp; <span id="preShrink62911" onclick="processCodeBlocks.shrinkExpand(62911);">Shrink</span> <img id="preimg62911" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(62911);">  &nbsp; <span id="copycode62911" onclick="return processCodeBlocks.copyCode(62911);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre62911" processed="true"><span>export</span> <span>const</span> [ItemActions, ItemActionTypes, itemReducer] = declareActions({
    UI_UPDATE_CURRENT_TITLE: {
        uiUpdateCurrentTitle: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                title: payload
            };
        }
    },
    UI_SET_CURRENT_ITEM: {
        uiSetCurrentItem: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                id: payload
            };
        }
    },
    UI_UPDATE_TODO_TITLE: {
        uiUpdateTodoTitle: (type, payload) =&gt; ({ type, payload })
    },
    UI_SET_COMPLETE: {
        uiSetComplete: (type, id, complete) =&gt; ({ type, payload: { id, complete } })
    },
    UI_REMOVE_ITEM: {
        uiRemoveItem: (type, payload) =&gt; ({ type, payload })
    },
    SET_CURRENT: {
        setCurrent: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { payload }) =&gt; {
            <span>return</span> {
                ...state,
                ...payload
            };
        }
    }
});</pre>

<p>The other advantage is that such declarations help to start writing actions, action types and reducers. Keep them at one place. For the fast checking what would happen with the global state when the message is dispatched.</p>

<p>The next set of messages and reducers. This time, it is to update state. The data comes from backend requests.</p>

<p><span id="prehide796049" onclick="processCodeBlocks.togglePre(796049);">Hide</span>  &nbsp; <span id="preShrink796049" onclick="processCodeBlocks.shrinkExpand(796049);">Shrink</span> <img id="preimg796049" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(796049);">  &nbsp; <span id="copycode796049" onclick="return processCodeBlocks.copyCode(796049);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre796049" processed="true"><span>export</span> <span>const</span> [ToDoActions, ToDoActionTypes, toDoReducer] = declareActions({
    FETCH_TODOS_ERROR: {
        fetchTodosError: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                error: payload
            };
        }
    },
    FETCH_TODOS_RESULT: {
        fetchTodosResult: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                loading: <span>false</span>,
                items: selectItemsById(payload),
                order: selectItemsOrder(payload)
            };
        }
    },
    FETCH_TODOS: {
        fetchItems: (type, payload) =&gt; dispatch =&gt; {
            <span>const</span> adapter = <span>new</span> TodosAdapter();
            (async () =&gt; {
                <span>try</span> {
                    <span>const</span> items = await adapter.fetchTodos();
                    dispatch(ToDoActions.fetchTodosResult(items));
                } <span>catch</span> (ex) {
                    dispatch(ToDoActions.fetchTodosError(ex));
                }
            })();
            <span>return</span> {
                type,
                payload: <span>true</span>
            }
        },
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                loading: payload
            };
        }
    },
    CREATE_TODO_ERROR: {
        createTodoError: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                error: payload
            };
        }
    },
    CREATE_TODO_RESULT: {
        createTodoResult: (type, payload) =&gt; ({ type, payload }),
        reducer: ({ loading, ...state}: any = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                items: {
                    ...selectItems(state),
                    [payload.id]: payload
                },
                order: [payload.id, ...selectOrder(state)]
            };
        }
    },
    CREATE_TODO: {
        createTodo: (type, title) =&gt; dispatch =&gt; {
            <span>const</span> adapter = <span>new</span> TodosAdapter();
            (async () =&gt; {
                <span>try</span> {
                    <span>const</span> item = await adapter.createTodo(title);
                    dispatch(ToDoActions.createTodoResult(item));
                } <span>catch</span> (ex) {
                    dispatch(ToDoActions.createTodoError(ex));
                }
            })();
            <span>return</span> {
                type,
                payload: <span>true</span>
            }
        },
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                loading: payload
            };
        }
    },
    UPDATE_TODO_ERROR: {
        updateTodoError: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                error: payload
            };
        }
    },
    UPDATE_TODO_RESULT: {
        updateTodoResult: (type, payload) =&gt; ({ type, payload }),
        reducer: ({ loading, ...state}: any = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                items: {
                    ...selectItems(state),
                    [payload.id]: payload
                }
            };
        }
    },
    UPDATE_TODO: {
        updateTodo: (type, id, attrs) =&gt; dispatch =&gt; {
            <span>const</span> adapter = <span>new</span> TodosAdapter();
            (async () =&gt; {
                <span>try</span> {
                    <span>const</span> item = await adapter.updateTodo(id, attrs);
                    dispatch(ToDoActions.updateTodoResult(item));
                } <span>catch</span> (ex) {
                    dispatch(ToDoActions.updateTodoError(ex));
                }
            })();
            <span>return</span> {
                type,
                payload: <span>true</span>
            }
        },
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                loading: payload
            };
        }
    },
    DELETE_TODO_ERROR: {
        deleteTodoError: (type, payload) =&gt; ({ type, payload }),
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                error: payload
            };
        }
    },
    DELETE_TODO_RESULT: {
        deleteTodoResult: (type, payload) =&gt; ({ type, payload }),
        reducer: ({ loading, ...state }: any = {}, { type, payload: id }) =&gt; {
            <span>const</span> { [id]: removed, ...items } = selectItemsInternal(state) as any;
            <span>return</span> {
                ...state,
                items,
                order: selectOrder(state).filter(pos =&gt; pos !== id)
            };
        }
    },
    DELETE_TODO: {
        deleteTodo: (type, id) =&gt; dispatch =&gt; {
            <span>const</span> adapter = <span>new</span> TodosAdapter();
            (async () =&gt; {
                <span>try</span> {
                    <span>const</span> item = await adapter.deleteTodo(id);
                    dispatch(ToDoActions.deleteTodoResult(id));
                } <span>catch</span> (ex) {
                    dispatch(ToDoActions.deleteTodoError(ex));
                }
            })();
            <span>return</span> {
                type,
                payload: <span>true</span>
            }
        },
        reducer: (state: {} = {}, { type, payload }) =&gt; {
            <span>return</span> {
                ...state,
                loading: payload
            };
        }
    }
});</pre>

<p>Those messages are for backend communication. They can be divided into commands: <code>create</code>, <code>update</code>, <code>delete</code>. And divided by request. Messages that start a remote request. Messages that come with results from a backend. Messages that are for error reporting.</p>

<p>Everything is combined into this final reducer.</p>

<p><span id="prehide629262" onclick="processCodeBlocks.togglePre(629262);">Hide</span>  &nbsp; <span id="copycode629262" onclick="return processCodeBlocks.copyCode(629262);">Copy Code</span></p><pre id="pre629262">import { mainReducer, selectMain } from './components/main';
import { toDoReducer, selectTodos } from './models/todos';
import { itemReducer, selectCurrent } from './components/todoItem';


export const reducer = (prevState, action) =&gt; {
    const state = {
        ...prevState,
        main: mainReducer(selectMain(prevState), action),
        todos: toDoReducer(selectTodos(prevState), action),
        current: itemReducer(selectCurrent(prevState), action)
    };
    const { type, payload } = action;
    switch (type) {
        default:
            return state;
    }
};</pre>

<p>In OOP, such kind of information usually was organised in the class methods and class members. This is similar. All can be grouped by separate files with the help of the <code>declareActions method</code>. It is always reminding me that I am just one step to OOP. Maybe this is because I can't switch enough from OOP to functional paradigm. <code>CREATE_TODO</code>, <code>UPDATE_TODO</code> and <code>DELETE_TODO</code> - actually should be smaller. For the sake of brevity. <code>(async () =&gt; { ... })</code> was inlined within the message.</p>

<h2>Views</h2>

<p>The shape of the global state is adjusted. There are rules on how to update the state. Now this is the part to read the state. Views are the first participants that would actively read the state. Select a part of the state to display.</p>

<h3>Templates</h3>

<p>Templates are rendered with the help of Virtual DOM. And since it is VDOM, we can fully leverage JSX/TSX templating technology. It would be handy to produce The Virtual DOM state. Render UI. More information about JSX can be found over the internet. Here, I just list the templates that will be used for the solution. In this article, the word "<code>component</code>" is used for the view that is connected to the global state. Over the <code>connect</code> function. And the word "<code>control</code>" is used for the simple views that are sufficient by themselves. Not connected to the global state.</p>

<p>This is the template for the main component.</p>

<p><span id="prehide7996" onclick="processCodeBlocks.togglePre(7996);">Hide</span>  &nbsp; <span id="preShrink7996" onclick="processCodeBlocks.shrinkExpand(7996);">Shrink</span> <img id="preimg7996" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(7996);">  &nbsp; <span id="copycode7996" onclick="return processCodeBlocks.copyCode(7996);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre7996" processed="true">
<span>import</span> { el } from <span>'</span><span>../../virtualDom'</span>;
<span>import</span> { connect } from <span>'</span><span>../../connect'</span>;
<span>import</span> { className as cn } from <span>'</span><span>../../utils'</span>;
<span>import</span> { TodoListView } from <span>'</span><span>../../controls/todoListView'</span>;
<span>import</span> { TodoListViewItem } from <span>'</span><span>../todoItem'</span>;
<span>import</span> { selectMain } from <span>'</span><span>.'</span>;
<span>import</span> { Actions } from <span>'</span><span>../'</span>;
<span>import</span> { bindActions } from <span>'</span><span>../../bindActions'</span>;

<span>const</span> ENTER_KEY = <span>13</span>;

<span>function</span> mapStateToProps(state, props: {
    error;
    showClearCompleted;
    activeFilter;
    hasTodos;
    items;
    completeItems;
    activeItems;
    totalText;
    todoCount;
    manyTasks;
}) {
    <span>const</span> newState = {
        ...props,
        ...selectMain(state)
    };
    <span>return</span> {
        ...newState,
        errors: {
            main: newState.error,
            todos: state.todos &amp;&amp; state.todos.error
        }
    };
}

<span>function</span> mapDispatchToProps(dispatch, props) {
    <span>const</span> actions = bindActions(Actions, dispatch);
    <span>return</span> {
        dispatch: dispatch,
        onKeypress(evnt) {
            <span>if</span> (evnt.which === ENTER_KEY) {
                actions.uiCreateTodo();
            }
        },
        ...actions
    };
}

<span>export</span> <span>const</span> MainView = connect(mapStateToProps, mapDispatchToProps)
                        (({ dispatch, ...props } = {

} as ReturnType&lt;typeof mapDispatchToProps&gt; &amp; ReturnType&lt;typeof mapStateToProps&gt;) =&gt; &lt;main&gt;
    &lt;section className=<span>"</span><span>todoapp device-content"</span>&gt;
        &lt;header className=<span>"</span><span>bar bar-nav"</span>&gt;
            &lt;button className={cn(<span>'</span><span>btn pull-left ?active'</span>, props.toggleAllComplete)}&gt;
                &lt;input className=<span>"</span><span>toggle-all hidden"</span> id=<span>"</span><span>toggle-all"</span> type=<span>"</span><span>checkbox"</span>
                    defaultChecked={!!props.toggleAllComplete}
                    onClick={e =&gt; props.uiToggleAllComplete(e.target[<span>'</span><span>checked'</span>])}
                /&gt;
                &lt;label htmlFor=<span>"</span><span>toggle-all"</span>&gt;Complete All<span>&lt;/</span><span>label</span><span>&gt;</span>
            <span>&lt;/</span><span>button</span><span>&gt;</span>
            &lt;button className={cn(<span>'</span><span>clear-completed btn pull-right ?hidden'</span>, 
                               props.showClearCompleted)}
                onClick={e =&gt; props.uiClearCompleted()}
                &gt;Clear completed<span>&lt;/</span><span>button</span><span>&gt;</span>
            &lt;hr/&gt;
            &lt;div className=<span>"</span><span>filters segmented-control"</span>&gt;
                &lt;a className={cn(<span>"</span><span>control-item ?active"</span>, !props.activeFilter)} href=<span>"</span><span>#/"</span>
                    onClick={evnt =&gt; props.uiSetActiveFilter(<span>'</span><span>all'</span>)}
                    &gt;All<span>&lt;/</span><span>a</span><span>&gt;</span>
                     • 
                &lt;a className={cn(<span>"</span><span>control-item ?active"</span>, 
                 props.activeFilter === <span>'</span><span>active'</span>)} href=<span>"</span><span>#/active"</span>
                    onClick={evnt =&gt; props.uiSetActiveFilter(<span>'</span><span>active'</span>)}
                    &gt;Active<span>&lt;/</span><span>a</span><span>&gt;</span>
                     • 
                &lt;a className={cn(<span>"</span><span>control-item ?active"</span>, 
                 props.activeFilter === <span>'</span><span>completed'</span>)} href=<span>"</span><span>#/completed"</span>
                    onClick={evnt =&gt; props.uiSetActiveFilter(<span>'</span><span>complete'</span>)}    
                    &gt;Completed<span>&lt;/</span><span>a</span><span>&gt;</span>
            <span>&lt;/</span><span>div</span><span>&gt;</span>
        <span>&lt;/</span><span>header</span><span>&gt;</span>
        &lt;hr/&gt;
        &lt;section className=<span>"</span><span>bar bar-standard bar-header-secondary"</span>&gt;
            &lt;form onSubmit={e =&gt; e.preventDefault()}&gt;
                &lt;input className=<span>"</span><span>new-todo"</span> 
                 type=<span>"</span><span>search"</span> placeholder=<span>"</span><span>What needs to be done?"</span>
                    value={props.newTodoTitle}
                    onInput={e =&gt; props.uiUpdateNewTodoTitle(e.target[<span>'</span><span>value'</span>])}
                    onKeyPress={e =&gt; props.onKeypress(e)}
                /&gt;
            <span>&lt;/</span><span>form</span><span>&gt;</span>
        <span>&lt;/</span><span>section</span><span>&gt;</span>
        &lt;hr/&gt;
        &lt;footer className={cn(<span>'</span><span>footer bar bar-standard bar-footer ?hidden'</span>, props.hasTodos)}&gt;
            &lt;span className=<span>"</span><span>todo-count title"</span>&gt;
                &lt;strong&gt;{props.activeItems ? props.activeItems.length : <span>0</span>}<span>&lt;/</span><span>strong</span><span>&gt;</span> 
            {!(props.activeItems &amp;&amp; props.activeItems.length === <span>1</span>)
                    ? &lt;span className=<span>"</span><span>items-word"</span>&gt;items<span>&lt;/</span><span>span</span><span>&gt;</span>
                    : &lt;span className=<span>"</span><span>item-word"</span>&gt;item<span>&lt;/</span><span>span</span><span>&gt;</span>
                }
             left from 
            &lt;span className=<span>"</span><span>total"</span>&gt;{props.items ? props.items.length : <span>0</span>}<span>&lt;/</span><span>span</span><span>&gt;</span>
            <span>&lt;/</span><span>span</span><span>&gt;</span>
        <span>&lt;/</span><span>footer</span><span>&gt;</span>
        &lt;section className={cn(<span>'</span><span>content ?hidden'</span>, props.hasTodos)}&gt;
                &lt;TodoListView items={
                    props.activeFilter === <span>'</span><span>complete'</span>
                        ? props.completeItems
                        : props.activeFilter === <span>'</span><span>active'</span>
                            ? props.activeItems
                            : props.items
                }&gt;
                {item =&gt; TodoListViewItem(item)}
            <span>&lt;/</span><span>TodoListView</span><span>&gt;</span>
            &lt;footer className=<span>"</span><span>info content-padded"</span>&gt;
                &lt;p&gt;Click to edit a todo<span>&lt;/</span><span>p</span><span>&gt;</span>
            <span>&lt;/</span><span>footer</span><span>&gt;</span>
        <span>&lt;/</span><span>section</span><span>&gt;</span>
    <span>&lt;/</span><span>section</span><span>&gt;</span>
<span>&lt;/</span><span>main</span><span>&gt;</span>);</pre>

<p>The template for the list item component.</p>

<p><span id="prehide461815" onclick="processCodeBlocks.togglePre(461815);">Hide</span>  &nbsp; <span id="preShrink461815" onclick="processCodeBlocks.shrinkExpand(461815);">Shrink</span> <img id="preimg461815" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(461815);">  &nbsp; <span id="copycode461815" onclick="return processCodeBlocks.copyCode(461815);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre461815" processed="true">
<span>import</span> { el } from <span>'</span><span>../../virtualDom'</span>;
<span>import</span> { connect } from <span>'</span><span>../../connect'</span>;
<span>import</span> { className as cn } from <span>'</span><span>../../utils'</span>;
<span>import</span> { selectCurrent, selectTitle } from <span>'</span><span>./'</span>;
<span>import</span> { Actions } from <span>'</span><span>../'</span>;
<span>import</span> { bindActions } from <span>'</span><span>../../bindActions'</span>;


<span>const</span> ENTER_KEY = <span>13</span>;
<span>export</span> <span>const</span> ESC_KEY = <span>27</span>;

<span>function</span> mapStateToProps(state, props) {
    <span>const</span> newState = {
        ...props,
        current: selectCurrent(state)
    };
    <span>return</span> {
        ...newState,
        errors: {
            main: newState.error,
            todos: state.todos &amp;&amp; state.todos.error
        }
    };
}

<span>function</span> mapDispatchToProps(dispatch, props) {
    <span>const</span> actions = bindActions(Actions, dispatch);
    <span>return</span> {
        dispatch: dispatch,
        ...actions,
        updateOnEnter(evnt, itemId) {
            <span>if</span> (evnt.which === ENTER_KEY) {
                actions.uiUpdateTodoTitle(itemId);
                actions.uiSetCurrentItem(<span>null</span>);
            }
        },
        revertOnEscape(e) {
            <span>if</span> (e.which === ESC_KEY) {
                actions.uiSetCurrentItem(<span>null</span>);
                
            }
        }
    };
}



<span>function</span> setCaretAtStartEnd(node, atEnd) {
    <span>const</span> sel = <span>document</span>.getSelection();
    node = node.firstChild;
  
    <span>if</span> (sel.rangeCount) {
        [<span>'</span><span>Start'</span>, <span>'</span><span>End'</span>].forEach(pos =&gt;
            sel.getRangeAt(<span>0</span>)[<span>"</span><span>set"</span> + pos](node, atEnd ? node.length : <span>0</span>)
        )
    }
}


<span>function</span> focusEditbox(el) {
    el.focus();
    <span>if</span> (el.textContent) {
        setCaretAtStartEnd(el, <span>true</span>);
    }
}

<span>export</span> <span>const</span> TodoListViewItem = connect(mapStateToProps, mapDispatchToProps)
                                (({ dispatch, ...props } = {

} as ReturnType&lt;typeof mapDispatchToProps&gt; &amp; 
     ReturnType&lt;typeof mapStateToProps&gt;) =&gt; &lt;div className={cn(
    <span>'</span><span>table-view-cell'</span>, <span>'</span><span>media'</span>, <span>'</span><span>completed?'</span>, <span>'</span><span>editing?'</span>, <span>'</span><span>hidden?'</span>,
    props.completed, props.current.id, props.hidden
)}&gt;
        &lt;span className=<span>"</span><span>media-object pull-left"</span> style={<span>"</span><span>display: inline-block;"</span> as any}&gt;
            &lt;input id={<span>`</span>view-${props.id}`} className="hidden" type="checkbox"
                checked={props.complete}
                onChange={e =&gt; props.uiSetComplete(props.id, e.target['checked'])}
            /&gt;
        <span>&lt;/</span><span>span</span><span>&gt;</span>
        &lt;span className=<span>"</span><span>input-group"</span> style={<span>"</span><span>display: inline-block; width: 70%;"</span> as any}&gt;
            {(props.current &amp;&amp; props.current.id === props.id) || 
             &lt;label className=<span>"</span><span>view input"</span> style={<span>"</span><span>padding: 1px 1px 1px 1px;"</span> as any}
                onClick={e =&gt; props.uiSetCurrentItem(props.id)}
            &gt;{props.title}<span>&lt;/</span><span>label</span><span>&gt;</span>}
            {(props.current &amp;&amp; props.current.id === props.id) &amp;&amp; 
            &lt;div className=<span>"</span><span>edit"</span> style={<span>"</span><span>border: 1px solid grey;outline: none;"</span> as any}
                contentEditable={<span>true</span>}
                ref={el =&gt; focusEditbox(el)}
                onInput={e =&gt; props.uiUpdateCurrentTitle(e.target[<span>'</span><span>innerText'</span>])}
                onKeyPress={e =&gt; props.updateOnEnter(e, props.current.id)}
                onKeyUp={e =&gt; props.revertOnEscape(e)}
                onBlur={e =&gt;props.uiSetCurrentItem(<span>null</span>)}
            &gt;{props.current.title}<span>&lt;/</span><span>div</span><span>&gt;</span>}
        <span>&lt;/</span><span>span</span><span>&gt;</span>
        &lt;button className=<span>"</span><span>destroy btn icon icon-trash"</span>
            onClick={e =&gt; props.uiRemoveItem(props.id)}
            style={<span>"</span><span>display: inline-block;"</span> as any}
        &gt;Delete<span>&lt;/</span><span>button</span><span>&gt;</span>
    <span>&lt;/</span><span>div</span><span>&gt;</span>
);</pre>

<p>And the template for the list control.</p>

<p><span id="prehide713353" onclick="processCodeBlocks.togglePre(713353);">Hide</span>  &nbsp; <span id="copycode713353" onclick="return processCodeBlocks.copyCode(713353);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre713353">
<span>import</span> { el } from <span>'</span><span>../virtualDom'</span>;

<span>const</span> map = (items, fn) =&gt; {
    <span>const</span> res = [];
    <span>for</span> (<span>let</span> key <span>in</span> items) {
        <span>if</span> (items.hasOwnProperty(key)) {
            res.push(fn(items[key], key));
        }
    }
    <span>return</span> res;
}

<span>export</span> <span>const</span> TodoListView = ({ items = [], children = item =&gt; <span>'</span><span>'</span> + item }: 
          { items: [] | {}, children?}) =&gt; &lt;ul style={<span>"</span><span>padding: 0px;"</span> as any}&gt;
    {map(items, (item, index) =&gt; &lt;li style={<span>"</span><span>list-style: none;"</span> as any}&gt;
                                 {children(item, index)}<span>&lt;/</span><span>li</span><span>&gt;</span>)}
<span>&lt;/</span><span>ul</span><span>&gt;</span>;</pre>

<p>The last is the small one. It is a template for the list view. Similar to MVVM. The same approach is used to build controls without state. They are used as simple controls to do simple tasks. For this case, it is to list todo items.</p>

<p>Besides the JSX markup, the important parts in a template are those methods: <code>mapStateToProps</code> and <code>mapDispatchToProps</code>. Since it is Virtual DOM. It will be frequently re-rendered. Everything that is in <code>mapStateToProps</code> and <code>mapDispatchToProps</code> should be written with caution. This is the first place that could cause performance degradation of the whole application. Even if nothing is going to be updated in a UI, it would be re-rendered with every dispatch operation. Selectors that are used here should be quick.</p>

<p>Selectors should provide the part of the state just enough for the view. This is important. When an application grows. It would be useful to quickly find what part of the data is used and in which view. Just by observing the top of the template. The next important part here is function <code>bindActions</code>. The function is used to bind every action to the dispatch function from the state. Then it can be used to trigger relevant action.</p>

<p>This is how the <code>bindActions</code> function is defined.</p>

<p><span id="prehide932769" onclick="processCodeBlocks.togglePre(932769);">Hide</span>  &nbsp; <span id="copycode932769" onclick="return processCodeBlocks.copyCode(932769);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre932769"><span>export</span> <span>function</span> bindActions&lt;A, K <span>extends</span> keyof A&gt;(actions: A, dispatch) {
    <span>const</span> res = Object.keys(actions).reduce((res, key) =&gt; ({
        ...res,
        [key]: (...args) =&gt; dispatch(actions[key](...args))
    }), {} as { [key <span>in</span> K]: A[K] });

    <span>return</span> res;
}</pre>

<p>And this is how all actions in the application are merged into the <code>Actions</code> object.</p>

<p><span id="prehide862649" onclick="processCodeBlocks.togglePre(862649);">Hide</span>  &nbsp; <span id="copycode862649" onclick="return processCodeBlocks.copyCode(862649);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre862649"><span>import</span> { MainActions } from <span>'</span><span>./main'</span>;
<span>import</span> { ItemActions } from <span>'</span><span>./todoItem'</span>;


<span>export</span> <span>const</span> Actions = {
    ...MainActions,
    ...ItemActions
};</pre>

<p>Next - are selectors.</p>

<h3>Selectors</h3>

<p>The idea of selectors is already explained in many articles. I would just mention that selectors are to slice the global state into a small part. Selectors can be combined in regards to how they are slicing data. There are selectors that tend to dive deep through the global state and produce sub state snippets. And selectors that would work in the composition. Pick a part of the necessary data as an input for other selectors. A part of the data snippet will be provided as an argument for other selectors that build the final <code>sub</code> snippet.</p>

<p>Selectors are not only a part of the views. They will be used in many places.</p>

<p>Here is the list of the selectors from the backend module.</p>

<p><span id="prehide472177" onclick="processCodeBlocks.togglePre(472177);">Hide</span>  &nbsp; <span id="copycode472177" onclick="return processCodeBlocks.copyCode(472177);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre472177"><span>const</span> selectItemsById = (items = []) =&gt; items.reduce((res, item) =&gt; ({
    ...res,
    [item.id]: item
}), {});
<span>const</span> selectItemsOrder = (items = []) =&gt; items.map(({ id }) =&gt; id);
<span>const</span> selectOrder = ({ order }) =&gt; order;
<span>export</span> <span>const</span> selectTodos = ({ todos }) =&gt; todos;
<span>export</span> <span>const</span> selectItemsInternal = ({ items = {} }) =&gt; items;
<span>export</span> <span>const</span> selectItems = ({ items = {}, order = [] }) =&gt; order.map(id =&gt; items[id]);</pre>

<p>The list of the selectors for the main module.</p>

<p><span id="prehide626753" onclick="processCodeBlocks.togglePre(626753);">Hide</span>  &nbsp; <span id="copycode626753" onclick="return processCodeBlocks.copyCode(626753);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre626753"><span>export</span> <span>const</span> selectMain = ({ main = { newTodoTitle: <span>'</span><span>'</span>, toggleAllComplete: <span>false</span> } }) =&gt; main;
<span>export</span> <span>const</span> selectItems = ({ items = [] }) =&gt; items;
<span>export</span> <span>const</span> selectItemIsComplete = ({ complete }) =&gt; complete;
<span>export</span> <span>const</span> selectActiveItems = 
    (items = []) =&gt; pick(items, item =&gt; !selectItemIsComplete(item));
<span>export</span> <span>const</span> selectCompleteItems = 
    (items = []) =&gt; pick(items, item =&gt; selectItemIsComplete(item));
<span>export</span> <span>const</span> selectNewTodoTitle = ({ newTodoTitle = <span>'</span><span>'</span> }) =&gt; newTodoTitle;
<span>export</span> <span>const</span> selectToggleAllComplete = ({ toggleAllComplete }) =&gt; toggleAllComplete;</pre>

<p>The list of the selectors for the list item module</p>

<p><span id="prehide485374" onclick="processCodeBlocks.togglePre(485374);">Hide</span>  &nbsp; <span id="copycode485374" onclick="return processCodeBlocks.copyCode(485374);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre485374"><span>export</span> <span>const</span> selectCurrent = ({ current = {} }) =&gt; current;
<span>export</span> <span>const</span> selectTitle = ({ title }) =&gt; title;
<span>export</span> <span>const</span> selectId = ({ id }) =&gt; id;
<span>export</span> <span>const</span> selectComplete = ({ complete }) =&gt; complete;</pre>

<p>To summarise, the selectors are similar to class getters. Selectors are evaluated frequently. Should be quick. Ideally, to pick up a small part of the state. And reducers are similar to class setters. Setters should be small. Ideally are for the one task: <code>create</code>, <code>update</code>, <code>delete</code>.</p>

<h2>Effects</h2>

<p>The answer to the databinding in declarative development. This time from the functional paradigm.</p>

<p>Like we can attach an event to the DOM document element. And be overwhelmed with the amount of events that are triggered when the cursor is moved. Mouse clicked. Key on the keyboard is pressed. UI button is clicked. The same picture is with the <code>rootEffect</code> function. Every element on the View can trigger a message. When the application is small. It would produce a small amount of messages. With a time, when views will become advanced. More actions will be attached to element events. The amount of messages will grow. Every message will be delivered to the store. State will be updated. Then, the same message with the new state will be passed as the parameter to the <code>rootEffect</code> method. Now the message will live another life.</p>

<p>Let's take a closer look to the effect for the list item component.</p>

<p><span id="prehide387009" onclick="processCodeBlocks.togglePre(387009);">Hide</span>  &nbsp; <span id="preShrink387009" onclick="processCodeBlocks.shrinkExpand(387009);">Shrink</span> <img id="preimg387009" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(387009);">  &nbsp; <span id="copycode387009" onclick="return processCodeBlocks.copyCode(387009);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre387009" processed="true"><span>export</span> <span>const</span> currentItem = () =&gt; {

    <span>const</span> fromView = merge(
        pipe(
            whenSetCurrentItem,
            withArg(pipe(onState, queryTodos, queryItems)),
            map(([{ payload: id }, items]: [any, any[]]) =&gt; {
                <span>const</span> currentItem = items.find(item =&gt; item.id === id);
                <span>return</span> ItemActions.setCurrent(currentItem);
            })
        ),
        pipe(
            whenUpdateTodoTitle,
            withArg(pipe(onState, queryCurrent, queryId), 
                    pipe(onState, queryCurrent, queryTitle)),
            map(([a, itemId, editTitle]) =&gt; 
                  ToDoActions.updateTodo(itemId, { title: editTitle }))
        ),
        pipe(
            whenSetComplete,
            map(({ payload: { id, complete } }) =&gt; ToDoActions.updateTodo(id, { complete }))
        ),
        pipe(
            whenRemoveItem,
            map(({ payload: id }) =&gt; ToDoActions.deleteTodo(id))
        )
    );
    <span>const</span> fromService = merge(
        pipe(
            whenUpdateTodoResult,
            map(() =&gt; ToDoActions.fetchItems())
        )
    );

    <span>return</span> merge(
        fromView,
        fromService
    );
}</pre>

<p>It is a composite function that would produce another function in the end. There is the catch. The whole <code>currentItem</code> method is declared as the function for a purpose. The function would build another function. The returning function would be a part of the <code>rootEffect</code> function.</p>

<p>Let's take a close look at how the <code>rootEffect</code> function is built.</p>

<p><span id="prehide314260" onclick="processCodeBlocks.togglePre(314260);">Hide</span>  &nbsp; <span id="copycode314260" onclick="return processCodeBlocks.copyCode(314260);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre314260"><span>import</span> { main } from <span>'</span><span>./main'</span>;
<span>import</span> { currentItem } from <span>'</span><span>./todoItem'</span>;
<span>import</span> { merge } from <span>'</span><span>../itrx'</span>;


<span>export</span> <span>const</span> rootEffect = () =&gt; merge(
    main(),
    currentItem()
);</pre>

<p>Once more. It is a function that builds another function. This is a common approach in functional programming. When the big task is split on small operations. There are functions for the smaller operations. And there is a composite function. It is a combination of the smaller functions. To perform a bigger task.</p>

<p>Here is the final <code>handler</code> function that would perform a big task. Part of the <code>effectsMiddleware</code> function.</p>

<p><span id="prehide190379" onclick="processCodeBlocks.togglePre(190379);">Hide</span>  &nbsp; <span id="copycode190379" onclick="return processCodeBlocks.copyCode(190379);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre190379">...


<span>let</span> handler = rootEffect();
...</pre>

<p>And this is how it would be called:</p>

<p><span id="prehide698158" onclick="processCodeBlocks.togglePre(698158);">Hide</span>  &nbsp; <span id="copycode698158" onclick="return processCodeBlocks.copyCode(698158);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre698158">...


<span>for</span> (<span>const</span> a of [].concat(...handler(action, store.getState(), (a) =&gt; store.dispatch(a)))) {
    store.dispatch(a);
}
...</pre>

<p>The result of the function is another set of actions. To be dispatched to the store. The view is programmed to dispatch actions. And the effects handler is programmed to dispatch actions. It is programmed in a special way.</p>

<p>Let's try to investigate the life cyrcle of the <code>rootEffect</code> function. It is created like that <code>rootEffect()</code>. And it is used like that <code>rootEffect()(&lt;action&gt;, &lt;state&gt;)</code>. It is separated into two parts to improve performance. The first initialization faze executed only once. When the whole function is built. Then it will be executed very frequently. In this case, it would be called along with initialization. It would take a bigger road than it could.</p>

<p>The internal composition of the <code>rootEffect</code> function can be split on many small tasks. Here is another effect. This time for the <code>main</code> component.</p>

<p><span id="prehide884058" onclick="processCodeBlocks.togglePre(884058);">Hide</span>  &nbsp; <span id="preShrink884058" onclick="processCodeBlocks.shrinkExpand(884058);">Shrink</span> <img id="preimg884058" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(884058);">  &nbsp; <span id="copycode884058" onclick="return processCodeBlocks.copyCode(884058);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre884058" processed="true"><span>export</span> <span>const</span> main = () =&gt; {
    <span>const</span> init = merge(
        pipe(
            ofType(<span>'</span><span>@INIT'</span>),
            map(() =&gt; ToDoActions.fetchItems())
        )
    );
    <span>const</span> fromView = merge(
        pipe(
            whenCreateTodo,
            withArg(pipe(onState, queryMain, queryNewTodoTitle)),
            map(([a, newTodoTitle]) =&gt; ToDoActions.createTodo(newTodoTitle))
        ),
        pipe(
            whenUpdateNewTitle,
            map(({ payload }) =&gt; MainActions.updateNewTodoTitle(payload))
        ),
        pipe(
            whenToggleAllComplete,
            withArg(pipe(onState, queryTodos, queryItems), 
                    pipe(onState, queryMain, queryToggleAllComplete)),
            map(([, items, isCompleted]) =&gt; API.markAllItemsCompleted(items, isCompleted)),
            map(completedItems =&gt; completedItems.map
                                  (item =&gt; ToDoActions.updateTodo(item.id, item)))
        ),
        pipe(
            whenSetActiveFilter,
            withArg(pipe(onState, queryTodos, queryItems)),
            map(([a, todos]) =&gt; MainActions.updateItems(todos))
        ),
        pipe(
            whenClearCompleted,
            withArg(pipe(onState, queryTodos, queryItems, queryCompleteItems)),
            map(([a, completeItems = []]) =&gt; completeItems.map
                                             (item =&gt; ToDoActions.deleteTodo(item.id)))
        )
    );
    <span>const</span> fromService = merge(
        pipe(
            whenCreateTodoResult,
            map(() =&gt; MainActions.updateNewTodoTitle(<span>'</span><span>'</span>))
        ),
        pipe(
            merge(whenCreateItem, whenDeleteItem),
            map(() =&gt; ToDoActions.fetchItems())
        ),
        pipe(
            merge(whenChangeItems, whenCreateItem, whenDeleteItem),
            withArg(pipe(onState, queryTodos, queryItems)),
            map(([action, todos]) =&gt; {
                <span>return</span> MainActions.updateItems(todos);
            })
        )
    );

    <span>return</span> merge(
        init,
        fromView,
        fromService
    );
}</pre>

<p>It works in this way. First, it would run the initial request. To fetch items from the backend. The action is <code>ToDoActions.fetchItems()</code>. Then it would listen for more messages from the UI. In the end, it would process internal commands. Such as reset todo title on a create new todo form. Run more backend requests. Refreshing todo items. Update UI with the fetched todo items from backend.</p>

<p>There are two types of custom operator functions. Sort of operator methods. Such as <code>map</code>, <code>pipe</code>, <code>merge</code>, <code>ofType</code>. As basic blocks to build a more advanced logic. And customized operator functions. Let's call them "<code>query</code>" and "<code>when</code>" functions. They will be used along with operator functions. They are to keep small logic composed into the custom operator function.</p>

<p>"<code>query</code>" functions are based on selectors and a <code>map</code> operator function. "<code>when</code>" functions are based on message type and <code>ofType</code> operator function.</p>

<p>This is the list of the all "<code>query</code>" and "<code>when</code>" custom operator functions. They are small building blocks to build effects.</p>

<p><span id="prehide886883" onclick="processCodeBlocks.togglePre(886883);">Hide</span>  &nbsp; <span id="preShrink886883" onclick="processCodeBlocks.shrinkExpand(886883);">Shrink</span> <img id="preimg886883" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(886883);">  &nbsp; <span id="copycode886883" onclick="return processCodeBlocks.copyCode(886883);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre886883" processed="true">
<span>const</span> queryMain = map(selectMain);
<span>const</span> queryNewTodoTitle = map(selectNewTodoTitle);
<span>const</span> queryToggleAllComplete = map(selectToggleAllComplete);
<span>const</span> queryCompleteItems = map(selectCompleteItems);

<span>const</span> whenUpdateNewTitle = ofType(MainActionTypes.UI_UPDATE_NEW_TITLE);
<span>const</span> whenCreateTodo = ofType(MainActionTypes.UI_CREATE_TODO);
<span>const</span> whenToggleAllComplete = ofType(MainActionTypes.UI_TOGGLE_ALL_COMPLETE);
<span>const</span> whenSetActiveFilter = ofType(MainActionTypes.UI_SET_ACTIVE_FILTER);
<span>const</span> whenClearCompleted = ofType(MainActionTypes.UI_CLEAR_COMPLETED);


<span>export</span> <span>const</span> queryCurrent = map(selectCurrent);
<span>export</span> <span>const</span> queryTitle = map(selectTitle);
<span>export</span> <span>const</span> queryComplete = map(selectComplete);
<span>export</span> <span>const</span> queryId = map(selectId);

<span>const</span> whenSetCurrentItem = ofType(ItemActionTypes.UI_SET_CURRENT_ITEM);
<span>const</span> whenUpdateTodoTitle = ofType(ItemActionTypes.UI_UPDATE_TODO_TITLE);
<span>const</span> whenSetComplete = ofType(ItemActionTypes.UI_SET_COMPLETE);
<span>const</span> whenRemoveItem = ofType(ItemActionTypes.UI_REMOVE_ITEM);


<span>export</span> <span>const</span> queryTodos = map(selectTodos);
<span>export</span> <span>const</span> queryItems = map(selectItems);

<span>export</span> <span>const</span> whenChangeItems = ofType(ToDoActionTypes.FETCH_TODOS_RESULT);
<span>export</span> <span>const</span> whenCreateItem = ofType(ToDoActionTypes.CREATE_TODO_RESULT);
<span>export</span> <span>const</span> whenDeleteItem = ofType(ToDoActionTypes.DELETE_TODO_RESULT);

<span>export</span> <span>const</span> whenCreateTodoResult = ofType(ToDoActionTypes.CREATE_TODO_RESULT);
<span>export</span> <span>const</span> whenUpdateTodoResult = ofType(ToDoActionTypes.UPDATE_TODO_RESULT);</pre>

<p>Let's check the operator functions in detail.</p>

<p><span id="prehide808903" onclick="processCodeBlocks.togglePre(808903);">Hide</span>  &nbsp; <span id="copycode808903" onclick="return processCodeBlocks.copyCode(808903);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre808903"><span>export</span> <span>const</span> onAction = (...abc) =&gt; [abc[<span>0</span>]];
<span>export</span> <span>const</span> onState = (...abc) =&gt; [abc[<span>1</span>]];
<span>export</span> <span>const</span> onDispatch = (...abc) =&gt; [abc[<span>2</span>]];

<span>export</span> <span>const</span> pipe = (...fn) =&gt; (...abc) =&gt; 
           fn.reduce((res, curr) =&gt; res.length ? curr(...res) : [], abc);
<span>export</span> <span>const</span> merge = (...fn) =&gt; (...abc) =&gt; 
           fn.reduce((res, curr) =&gt; [...res, ...curr(...abc)], []);

<span>export</span> <span>const</span> map = (fn) =&gt; (...abc) =&gt; [fn(...abc)];
<span>export</span> <span>const</span> withArg = (...fn) =&gt; (a, ...abc) =&gt; [[a, ...merge(...fn)(a, ...abc)], ...abc];
<span>export</span> <span>const</span> filter = (fn) =&gt; (...abc) =&gt; fn(...abc) ? [...abc] : [];

<span>export</span> <span>const</span> ofType = (type) =&gt; filter(a =&gt; a.type === type);</pre>

<p>It is a small library, named "<code>itrx</code>". It provides blocks that perform small operations. Similar to streams. But this solution is for arrays.</p>

<p>Three functions <code>onAction</code>, <code>onState</code> and <code>onDispatch</code>. Those operator functions provide <code>actions</code>, <code>state</code> and <code>dispatch</code> arguments. They select just one argument passed to the <code>handler</code> (result of the <code>rootEffects()</code>) function.</p>

<p>The first method that is often used is <code>pipe</code>. This is a sort of pipeline method in functional programming. A bit customized. Since it is expected to dispatch messages. The result could be nothing, one message or many messages. For that case, all operator functions are adjusted to work with data as function or array. This is how it is defined.</p>

<p>Please, pay attention to the inline <code>if</code>. It would work till an array. And the array is not empty. Result could provide an empty array. Then the piping will stop processing the rest of the methods in arguments and return the result.</p>

<p><span id="prehide860382" onclick="processCodeBlocks.togglePre(860382);">Hide</span>  &nbsp; <span id="copycode860382" onclick="return processCodeBlocks.copyCode(860382);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre860382"><span>export</span> <span>const</span> pipe = (...args) =&gt; 
    (...abc) =&gt; args.reduce((res, fn) =&gt; res.length ? fn(...res) : [], abc);</pre>

<p>It would take the first method. Evaluate it and pass the result to the next method. Like this:</p>

<p><span id="prehide268040" onclick="processCodeBlocks.togglePre(268040);">Hide</span>  &nbsp; <span id="copycode268040" onclick="return processCodeBlocks.copyCode(268040);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre268040">...
pipe(
    whenCreateTodo,
    withArg(pipe(onState, queryMain, queryNewTodoTitle)),
    map(([a, newTodoTitle]) =&gt; ToDoActions.createTodo(newTodoTitle))
),
...</pre>

<p>First will be called method <code>whenCreateTodo</code>. Then the result will be passed to the method <code>withArg</code>. And finally, the next result will be passed to the <code>map</code>.</p>

<p>The <code>merge</code> function is designed to apply every function from <code>...fn</code> passing same arguments <code>...abc</code>. It is adjusted in the way to map every function provided in argument. Then merge the result into a single array.</p>

<p>This is how the <code>merge</code> function is used.</p>

<p><span id="prehide300" onclick="processCodeBlocks.togglePre(300);">Hide</span>  &nbsp; <span id="copycode300" onclick="return processCodeBlocks.copyCode(300);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre300"><span>return</span> merge(
    init,
    fromView,
    fromService
);</pre>

<p>With introducing the <code>merge</code> function, it has become an ability to group messages from one component into a single unit.</p>

<p>The <code>map</code> method helps to pick an action that would be used in the end. Analog is the <code>map</code> method from array. Any custom logic can be used there. Try to keep it small. In the other case, it could produce big effects. And with a bigger effect, it is harder to understand what it does. Similar to templates.</p>

<p><span id="prehide130877" onclick="processCodeBlocks.togglePre(130877);">Hide</span>  &nbsp; <span id="copycode130877" onclick="return processCodeBlocks.copyCode(130877);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre130877">map(({ payload }) =&gt; MainActions.updateNewTodoTitle(payload))</pre>

<p>The most trickiest function is <code>withArg</code>. This is an arguments altering function for the next piped function. Let's take a closer look into it again.</p>

<p><span id="prehide173813" onclick="processCodeBlocks.togglePre(173813);">Hide</span>  &nbsp; <span id="copycode173813" onclick="return processCodeBlocks.copyCode(173813);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre173813"><span>export</span> <span>const</span> withArg = (...fn) =&gt; (a, ...abc) =&gt; [[a, ...merge(...fn)(a, ...abc)], ...abc];</pre>

<p>This is how it is used.</p>

<p><span id="prehide620163" onclick="processCodeBlocks.togglePre(620163);">Hide</span>  &nbsp; <span id="copycode620163" onclick="return processCodeBlocks.copyCode(620163);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre620163">withArg(pipe(onState, queryTodos, queryItems)),
map(([action, todos]) =&gt; {
    <span>return</span> MainActions.updateItems(todos);
})</pre>

<p>To get a better idea, let's check another <code>map</code> method. This time without altered arguments.</p>

<p><span id="prehide545802" onclick="processCodeBlocks.togglePre(545802);">Hide</span>  &nbsp; <span id="copycode545802" onclick="return processCodeBlocks.copyCode(545802);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre545802">map(action =&gt; ToDoActions.updateTodo(action.payload.id, action.payload.complete))</pre>

<p>Though, by default <code>action</code>, <code>state</code> and <code>dispatch</code> arguments will be passed into the <code>map</code> method. This is a sort of universal approach. Very often, it would require to build logic that is based on the part of the state. Though, we can use something like that: <code>state.todo.items</code>. Which would work for the small applications. In the future, referring deep into nested properties in the state could become a problem.</p>

<p>First, it is unsafe to request nested state over dots. Some parts could have a <code>null</code> value. That would lead to an error, e.g.,</p>

<p><span id="prehide45782" onclick="processCodeBlocks.togglePre(45782);">Hide</span>  &nbsp; <span id="copycode45782" onclick="return processCodeBlocks.copyCode(45782);">Copy Code</span></p><pre lang="text" data-lang-orig="text" id="pre45782">VM135419:1 Uncaught TypeError: Cannot read property 'items' of null
    at &lt;anonymous&gt;:1:6
&lt;/anonymous&gt;</pre>

<p>Second. It produces a strong coupling to the state. Every evolution of the state structure would lead to update effects as well.</p>

<p>There is a solution to it. Selectors are to pick up a small portion of the state. Usually, when state structure is altered, selectors will be changed as well. We can reuse selectors one more. This time for building effects. What makes it slow is the convenient way to adjust selectors. Make selectors assist to build effects. And the <code>withArg</code> is the answer.</p>

<p>Let's check one more time.</p>

<p><span id="prehide77617" onclick="processCodeBlocks.togglePre(77617);">Hide</span>  &nbsp; <span id="copycode77617" onclick="return processCodeBlocks.copyCode(77617);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre77617">withArg(pipe(onState, queryTodos, queryItems), 
        pipe(onState, queryMain, queryToggleAllComplete)),</pre>

<p>Where the <code>queryTodos</code> and the <code>queryItems</code> query methods are piped. Once evaluated, they would extract a small portion of the state. Same is with the <code>queryMain</code> and the <code>queryToggleAllComplete</code>. Another part of the state. In the end, it would produce such a set of arguments as <code>[items, isCompleted]</code>. For the <code>map</code> operator function <code>map(([, items, isCompleted]) =&gt; API.markAllItemsCompleted(items, isCompleted))</code>. With<span> this approach. </span><span>It is unusual to admit that it would work. Once used, it becomes so handy that it is hard to ignore it when building effects.</span></p>

<p>The <code>filter</code> function will be used to pick the message by action type. And skip the rest. Similar to the <code>filter</code> method for array. With the help of the <code>filter</code> function, it becomes possible to build "<code>when</code>" operator functions, e.g.:</p>

<p><span id="prehide773403" onclick="processCodeBlocks.togglePre(773403);">Hide</span>  &nbsp; <span id="copycode773403" onclick="return processCodeBlocks.copyCode(773403);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre773403">
<span>export</span> <span>const</span> ofType = (type) =&gt; filter(a =&gt; a.type === type);


<span>const</span> whenCreateTodoResult = ofType(ToDoActionTypes.CREATE_TODO_RESULT);</pre>

<p>From the first glance, it looks strange why so many small functions are just to call another function. When given a second though, it can be treated as the new language. Build on top of the programming language. In this article, it is typescript. For functional development. Another common approach. When function becomes the smallest simple building block. Gradually, it would emerge as another higher order language. Build on the syntax of the programming language. With a unique linguistic ecosystem. Similar to frameworks, that have emerged in a declarative world.</p>

<p>As for the effects, it can be treated as another way to declare data bindings. When binding commands are well defined and built as universal blocks. Everyone gets used to them. Knows how to use them. Similar case for the effects. This time with the option to build your own building commands. That would have a unique linguistic ecosystem. Just remember one rule. Effects module should be small. Consist of the small, easy understanding constructions. Similar like it is done with event listeners and event handlers.</p>

<ul>
	<li>Working example on <a href="https://jsfiddle.net/vkopytin/ngcbmLho/23/">jsfiddle</a></li>	<li>Full example on <a href="https://github.com/vkopytin/databinding/tree/a9de09173bea7b7526902c9ce94bd5bed02593e1/src/examples/reflux-ts">github</a></li></ul>

<p>Patient readers could notice that many parts are similar to React/Redux. However, it is omitted. The reason is that I try to focus on the Model View Update design pattern. React/Redux is one of the possible ways to implement it.</p>

<h3>Conclusions About MVU Design Pattern</h3>

<p>MVU design pattern is a functional approach.</p>

<h4>Positives</h4>

<p>Simple to understand. The smallest building block is a function.</p>

<p>The application state can be stored as the one global state.</p>

<p>Data flow is adjusted in one direction. From a view, over the actions and far to the state.</p>

<p>Updating state messages are organised in a sequential way. Less code to synchronise data when state is updating.</p>

<p>To every OOP approach, there is an answer from the functional world. Such as getters/setters and selectors/reducers. Databinding and effects.</p>

<p>Ability to produce unique high order language. Build on the top of the programming language.</p>

<h4>Consequences</h4>

<p>The tool is the only function. Leads to overuse of the high order functions.</p>

<p>The global state could grow. That could lead to logical fragmentation of the state.</p>

<p>The one direction of the data flow could lead to frequent extra updates with no changes on UI.</p>

<p>The state could become fragile. If wrong, updating a small part of the state, could break the whole UI.</p>

<p>There are already many tools for the OOP. Programming language syntax should support functional programming.</p>

<p>Leads to create high order language. Would require extra time to learn it.</p>

<p>Thank you for the reading. The code material in this article is based on the sources that can be found over the internet. My work was in putting it all together. Make it run as playground. Hope, it will be useful.</p>

<h2>The List of Some of Them</h2>

<ul>
	<li><a href="https://thomasbandt.com/model-view-update">Model-View-Update (MVU) – How Does It Work?</a></li>	<li><a href="https://proandroiddev.com/mvc-mvp-mvvm-clean-viper-redux-mvi-prnsaaspfruicc-building-abstractions-for-the-sake-of-building-18459ab89386">MVC/MVP/MVVM/CLEAN/VIPER/REDUX/MVI/PRNSAASPFRUICC — building abstractions for the sake of building abstractions (and because they’re pretty and popular)</a></li>	<li><a href="https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060">How to write your own Virtual DOM</a></li>	<li><a href="https://www.pluralsight.com/guides/how-to-organize-your-react-+-redux-codebase">How to Organize Your React + Redux Codebase</a></li>	<li><a href="https://www.freecodecamp.org/news/scaling-your-redux-app-with-ducks-6115955638be/">Scaling your Redux App with ducks</a></li>	<li><a href="https://blog.jakoblind.no/learn-react-redux-by-coding-the-connect-function-yourself/">Code your own Redux part 2: the connect function</a></li>	<li><a href="https://itnext.io/fast-pipelines-with-generators-in-typescript-85d285ae6f51">Lazy Pipelines with Generators in TypeScript</a></li></ul>


						</div><p>This article, along with any associated source code and files, is licensed under <a href="http://www.opensource.org/licenses/mit-license.php" rel="license">The MIT License</a></p></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>