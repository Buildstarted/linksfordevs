<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">ðŸŽ‰</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - damienbod/AspNetCoreCertificates</title>
<div class="readable">
        <h1>damienbod/AspNetCoreCertificates</h1>
        <p>
by damienbod <br/>Reading time: 20-26 minutes        </p>
        <p><a href="https://github.com/damienbod/AspNetCoreCertificates/blob/master/Documentation.md">https://github.com/damienbod/AspNetCoreCertificates/blob/master/Documentation.md</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    <article itemprop="text">
<p>Certificate Manager is a package which makes it easy to create certificates (chained and self signed) which can be used to in client server authentication and IoT Devices like Azure IoT Hub</p>
<ul>
<li><a href="#basic-usage-aspnet-core-net-core">Basic usage ASP.NET Core, NET Core</a></li>
<li><a href="#certificate-configuration">Certificate Configuration</a></li>
<li><a href="#creating-self-signed-certificates-for-client-server-authentication">Creating Self Signed Certificates for Client Server Authentication</a></li>
<li><a href="#creating-chained-certificates-for-client-server-authentication">Creating Chained Certificates for Client Server Authentication</a></li>
<li><a href="#creating-chained-certificates-for-azure-iot-hub">Creating Chained Certificates for Azure IoT Hub</a></li>
<li><a href="#creating-verify-certificate-for-azure-iot-hub">Creating Verify Certificate for Azure IoT Hub</a></li>
<li><a href="#creating-device-leaf-certificates-for-azure-iot-hub">Creating Device (Leaf) Certificates for Azure IoT Hub</a></li>
<li><a href="#creating-certificates-for-application-development-angular-vuejs">Creating certificates for application development Angular, VUE.js</a></li>
<li><a href="#exporting-certificates">Exporting Certificates</a></li>
<li><a href="#general-certificates-full-apis">General Certificates, full APIs</a></li>
<li><a href="#certificate-configuration-full-apis">Certificate Configuration full APIs</a></li>
</ul>

<p>Add the NuGet package to the your project file</p>
<pre><code>&lt;PackageReference Include="CertificateManager" Version="1.0.3" /&gt;
</code></pre>
<p>The NuGet packages uses dependency injection to setup. In a console application initialize the package as follows:</p>
<div><pre><span>var</span> <span>serviceProvider</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
    .<span>AddCertificateManager</span>()
    .<span>BuildServiceProvider</span>();
</pre></div>
<p>Or in an ASP.NET Core application use the Startup ConfigureServices method to initialize the package.</p>
<div><pre><span>public</span> <span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection</span> <span>services</span>)
{
    <span><span>//</span> ...</span>

    <span>services</span>.<span>AddCertificateManager</span>();
}</pre></div>
<h2>Certificate Configuration</h2>
<h3>Distinguished Name</h3>
<p>The distinguished name will be saved to the Issuer and the Subject properties of the certificate.</p>
<div><pre><span>var</span> <span>distinguishedName</span> <span>=</span> <span>new</span> <span>DistinguishedName</span>
{
    <span>CommonName</span> <span>=</span> <span><span>"</span>localhost<span>"</span></span>,
    <span>Country</span> <span>=</span> <span><span>"</span>CH<span>"</span></span>,
    <span>Locality</span> <span>=</span> <span><span>"</span>CH<span>"</span></span>,
    <span>Organisation</span> <span>=</span> <span><span>"</span>damienbod<span>"</span></span>,
    <span>OrganisationUnit</span> <span>=</span> <span><span>"</span>development<span>"</span></span>
};</pre></div>
<p>The CommonName property is required.</p>
<p>example in certificate:</p>
<pre><code>C=CH, C=CH, O=damienbod, OU=development, CN=localhost
</code></pre>
<p>definitions:</p>
<ul>
<li>C= Country</li>
<li>ST= State or province</li>
<li>L= Locality</li>
<li>O= organisation</li>
<li>OU=Organisation Unit</li>
<li>CN= Common name</li>
</ul>
<p>// CN is REQUIRED</p>
<h3>Validity Period</h3>
<p>The Validity Period defines when the certificate is valid from and how long.</p>
<div><pre><span>var</span> <span>validityPeriod</span> <span>=</span> <span>new</span> <span>ValidityPeriod</span>
{
    <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>,
    <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>)
};</pre></div>
<p>If creating a child certificate from a root or an intermediate certification, the values cannot be outside the range of the parent. If the certificate values are outside the range, the parent values will be used.</p>
<p>The ValidFrom and the ValidTo values can then be used to validate the certificate. It is recommended the keep this period short. This depends on how you use and deploy the certificates.</p>
<h2>Creating Self Signed Certificates for Client Server Authentication</h2>
<p>The <strong>CreateCertificatesClientServerAuth</strong> service is used to create these certificates.</p>
<div><pre><span>var</span> <span>dnsName</span> <span>=</span> <span><span>"</span>localhost<span>"</span></span>;
<span>var</span> <span>serviceProvider</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
    .<span>AddCertificateManager</span>()
    .<span>BuildServiceProvider</span>();

<span>var</span> <span>createClientServerAuthCerts</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>CreateCertificatesClientServerAuth</span>&gt;();</pre></div>
<p>The <strong>NewServerSelfSignedCertificate</strong> method can be used to create a self signed certificate for a certificate which is to be used on the server. The dnsName must match your server deployment. Only the correct enhanced Key usages is set.</p>
<p>Oid("1.3.6.1.5.5.7.3.1"), // TLS Server auth</p>
<p>This can then be validated.</p>
<div><pre><span><span>//</span> Server self signed certificate</span>
<span>var</span> <span>server</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewServerSelfSignedCertificate</span>(
    <span>new</span> <span>DistinguishedName</span> { <span>CommonName</span> <span>=</span> <span><span>"</span>server<span>"</span></span>, <span>Country</span> <span>=</span> <span><span>"</span>CH<span>"</span></span> },
    <span>new</span> <span>ValidityPeriod</span> { <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>, <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>) },
    <span>dnsName</span>);
<span>server</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>azure server certificate<span>"</span></span>;</pre></div>
<p>The <strong>NewClientSelfSignedCertificate</strong> method can be used to create a self signed certificate for a certificate which is to be used on the server. The dnsName must match your server deployment. Only the correct enhanced Key usages is set.</p>
<p>Oid("1.3.6.1.5.5.7.3.2"), // TLS Client auth</p>
<p>This can then be validated.</p>
<div><pre><span><span>//</span> Client self signed certificate</span>
<span>var</span> <span>client</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewClientSelfSignedCertificate</span>(
    <span>new</span> <span>DistinguishedName</span> { <span>CommonName</span> <span>=</span> <span><span>"</span>client<span>"</span></span>, <span>Country</span> <span>=</span> <span><span>"</span>CH<span>"</span></span> },
    <span>new</span> <span>ValidityPeriod</span> { <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>, <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>) },
    <span>dnsName</span>);

<span>client</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>azure client certificate<span>"</span></span>;</pre></div>
<h2>Creating Chained Certificates for Client Server Authentication</h2>
<p>The <strong>CreateCertificatesClientServerAuth</strong> service is used to create these certificates.</p>
<div><pre><span>var</span> <span>serviceProvider</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
    .<span>AddCertificateManager</span>()
    .<span>BuildServiceProvider</span>();

<span>var</span> <span>createClientServerAuthCerts</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>CreateCertificatesClientServerAuth</span>&gt;();</pre></div>
<p>The <strong>NewRootCertificate</strong> method creates a new root certificate which can be used for chained structures. If you use your own root certificate, it needs to be added to the trusted certificate store on deployment host.</p>
<p>This is not needed if creting certificates from a public CA certificate. The root certificatge is a self signed certificate.</p>
<div><pre><span>var</span> <span>rootCaL1</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewRootCertificate</span>(
    <span>new</span> <span>DistinguishedName</span> { <span>CommonName</span> <span>=</span> <span><span>"</span>root dev<span>"</span></span>, <span>Country</span> <span>=</span> <span><span>"</span>IT<span>"</span></span> },
    <span>new</span> <span>ValidityPeriod</span> { <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>, <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>) },
    <span>3</span>, <span><span>"</span>localhost<span>"</span></span>);
<span>rootCaL1</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>developement root L1 certificate<span>"</span></span>;</pre></div>
<p>The <strong>NewIntermediateChainedCertificate</strong> creates an intermediate certificate from a parent root or another intermediate certificate.</p>
<div><pre><span><span>//</span> Intermediate L2 chained from root L1</span>
<span>var</span> <span>intermediateCaL2</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewIntermediateChainedCertificate</span>(
    <span>new</span> <span>DistinguishedName</span> { <span>CommonName</span> <span>=</span> <span><span>"</span>intermediate dev<span>"</span></span>, <span>Country</span> <span>=</span> <span><span>"</span>FR<span>"</span></span> },
    <span>new</span> <span>ValidityPeriod</span> { <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>, <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>) },
    <span>2</span>,  <span><span>"</span>localhost<span>"</span></span>, <span>rootCaL1</span>);
<span>intermediateCaL2</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>developement Intermediate L2 certificate<span>"</span></span>;</pre></div>
<p>The <strong>NewServerChainedCertificate</strong> method can be used to create a self signed certificate for a certificate which is to be used on the server. The dnsName must match your server deployment. Only the correct enhanced Key usages is set.</p>
<p>Oid("1.3.6.1.5.5.7.3.1"), // TLS Server auth</p>
<p>This can then be validated.</p>
<div><pre><span><span>//</span> Server, Client L3 chained from Intermediate L2</span>
<span>var</span> <span>serverL3</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewServerChainedCertificate</span>(
    <span>new</span> <span>DistinguishedName</span> { <span>CommonName</span> <span>=</span> <span><span>"</span>server<span>"</span></span>, <span>Country</span> <span>=</span> <span><span>"</span>DE<span>"</span></span> },
    <span>new</span> <span>ValidityPeriod</span> { <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>, <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>) },
    <span><span>"</span>localhost<span>"</span></span>, <span>intermediateCaL2</span>);
<span>serverL3</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>developement server L3 certificate<span>"</span></span>;</pre></div>
<p>The <strong>NewClientChainedCertificate</strong> method can be used to create a chained certificate for a certificate which is to be used on the server. The dnsName must match your server deployment. Only the correct enhanced Key usages is set.</p>
<p>Oid("1.3.6.1.5.5.7.3.2"), // TLS Client auth</p>
<p>This can then be validated.</p>
<div><pre><span>var</span> <span>clientL3</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewClientChainedCertificate</span>(
    <span>new</span> <span>DistinguishedName</span> { <span>CommonName</span> <span>=</span> <span><span>"</span>client<span>"</span></span>, <span>Country</span> <span>=</span> <span><span>"</span>IE<span>"</span></span> },
    <span>new</span> <span>ValidityPeriod</span> { <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>, <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>) },
    <span><span>"</span>localhost<span>"</span></span>, <span>intermediateCaL2</span>);
<span>clientL3</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>developement client L3 certificate<span>"</span></span>;
            </pre></div>
<h2>Creating Chained Certificates for Azure IoT Hub</h2>
<div><pre><span>var</span> <span>serviceProvider</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
	.<span>AddCertificateManager</span>()
	.<span>BuildServiceProvider</span>();

<span>var</span> <span>createClientServerAuthCerts</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>CreateCertificatesClientServerAuth</span>&gt;();

<span>var</span> <span>root</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewRootCertificate</span>(
	<span>new</span> <span>DistinguishedName</span> { <span>CommonName</span> <span>=</span> <span><span>"</span>root dev<span>"</span></span>, <span>Country</span> <span>=</span> <span><span>"</span>IT<span>"</span></span> },
	<span>new</span> <span>ValidityPeriod</span> { <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>, <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>) },
	<span>3</span>, <span><span>"</span>localhost<span>"</span></span>);
<span>root</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>developement root certificate<span>"</span></span>;

<span><span>//</span> Intermediate L2 chained from root L1</span>
<span>var</span> <span>intermediate</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewIntermediateChainedCertificate</span>(
	<span>new</span> <span>DistinguishedName</span> { <span>CommonName</span> <span>=</span> <span><span>"</span>intermediate dev<span>"</span></span>, <span>Country</span> <span>=</span> <span><span>"</span>FR<span>"</span></span> },
	<span>new</span> <span>ValidityPeriod</span> { <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>, <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>) },
	<span>2</span>, <span><span>"</span>localhost<span>"</span></span>, <span>root</span>);
<span>intermediate</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>developement Intermediate certificate<span>"</span></span>;

<span>string</span> <span>password</span> <span>=</span> <span><span>"</span>1234<span>"</span></span>;
<span>var</span> <span>importExportCertificate</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>ImportExportCertificate</span>&gt;();

<span>var</span> <span>rootCertInPfxBtyes</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportRootPfx</span>(<span>password</span>, <span>root</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>"</span>root.pfx<span>"</span></span>, <span>rootCertInPfxBtyes</span>);

<span><span>//</span> https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-security-x509-get-started</span>

<span>var</span> <span>rootPublicKey</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportCertificatePublicKey</span>(<span>root</span>);
<span>var</span> <span>rootPublicKeyBytes</span> <span>=</span> <span>rootPublicKey</span>.<span>Export</span>(<span>X509ContentType</span>.<span>Cert</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>$"</span>root.cer<span>"</span></span>, <span>rootPublicKeyBytes</span>);

<span>var</span> <span>intermediateCertInPfxBtyes</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportChainedCertificatePfx</span>(<span>password</span>, <span>intermediate</span>, <span>root</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>"</span>intermediate.pfx<span>"</span></span>, <span>intermediateCertInPfxBtyes</span>);</pre></div>
<h2>Creating Verify Certificate for Azure IoT Hub</h2>
<div><pre><span>var</span> <span>serviceProvider</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
	.<span>AddCertificateManager</span>()
	.<span>BuildServiceProvider</span>();

<span>var</span> <span>createClientServerAuthCerts</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>CreateCertificatesClientServerAuth</span>&gt;();

<span>var</span> <span>importExportCertificate</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>ImportExportCertificate</span>&gt;();

<span>var</span> <span>root</span> <span>=</span> <span>new</span> <span>X509Certificate2</span>(<span><span>"</span>root.pfx<span>"</span></span>, <span><span>"</span>1234<span>"</span></span>);

<span>var</span> <span>deviceVerify</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewDeviceVerificationCertificate</span>(
<span><span>"</span>&lt;veification code from Azure IoT Hub&gt;<span>"</span></span>, <span>root</span>);
<span>deviceVerify</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>device verify<span>"</span></span>;

<span>var</span> <span>deviceVerifyPEM</span> <span>=</span> <span>importExportCertificate</span>.<span>PemExportPublicKeyCertificate</span>(<span>deviceVerify</span>);
<span>File</span>.<span>WriteAllText</span>(<span><span>"</span>deviceVerify.pem<span>"</span></span>, <span>deviceVerifyPEM</span>);

<span>var</span> <span>deviceVerifyPublicKey</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportCertificatePublicKey</span>(<span>deviceVerify</span>);
<span>var</span> <span>deviceVerifyPublicKeyBytes</span> <span>=</span> <span>deviceVerifyPublicKey</span>.<span>Export</span>(<span>X509ContentType</span>.<span>Cert</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>$"</span>deviceVerify.cer<span>"</span></span>, <span>deviceVerifyPublicKeyBytes</span>);
</pre></div>
<h2>Creating Device (Leaf) Certificates for Azure IoT Hub</h2>
<div><pre><span>var</span> <span>serviceProvider</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
	.<span>AddCertificateManager</span>()
	.<span>BuildServiceProvider</span>();

<span>var</span> <span>createClientServerAuthCerts</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>CreateCertificatesClientServerAuth</span>&gt;();

<span>var</span> <span>intermediate</span> <span>=</span> <span>new</span> <span>X509Certificate2</span>(<span><span>"</span>intermediate.pfx<span>"</span></span>, <span><span>"</span>1234<span>"</span></span>);

<span>var</span> <span>testDevice01</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewDeviceChainedCertificate</span>(
	<span>new</span> <span>DistinguishedName</span> { <span>CommonName</span> <span>=</span> <span><span>"</span>&lt;Device ID&gt;<span>"</span></span> },
	<span>new</span> <span>ValidityPeriod</span> { <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>, <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>) },
	<span><span>"</span>localhost<span>"</span></span>, <span>intermediate</span>);
<span>testDevice01</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>IoT device testDevice01<span>"</span></span>;

<span>string</span> <span>password</span> <span>=</span> <span><span>"</span>1234<span>"</span></span>;
<span>var</span> <span>importExportCertificate</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>ImportExportCertificate</span>&gt;();

<span>var</span> <span>deviceInPfxBytes</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportChainedCertificatePfx</span>(<span>password</span>, <span>testDevice01</span>, <span>intermediate</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>"</span>testDevice01.pfx<span>"</span></span>, <span>deviceInPfxBytes</span>);</pre></div>
<h2>Creating certificates for application development Angular, VUE.js</h2>
<div><pre><span>var</span> <span>serviceProvider</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
    .<span>AddCertificateManager</span>()
    .<span>BuildServiceProvider</span>();

<span>var</span> <span>_createCertificatesRsa</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>CreateCertificatesRsa</span>&gt;();

<span><span>//</span> Create development certificate for localhost</span>
<span>var</span> <span>devCertificate</span> <span>=</span> <span>_createCertificatesRsa</span>
    .<span>CreateDevelopmentCertificate</span>(<span><span>"</span>localhost<span>"</span></span>, <span>10</span>);

<span>devCertificate</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>localhost development<span>"</span></span>;

<span>string</span> <span>password</span> <span>=</span> <span><span>"</span>1234<span>"</span></span>;
<span>var</span> <span>importExportCertificate</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>ImportExportCertificate</span>&gt;();

<span><span>//</span> full pfx with password</span>
<span>var</span> <span>rootCertInPfxBtyes</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportRootPfx</span>(<span>password</span>, <span>devCertificate</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>"</span>dev_localhost.pfx<span>"</span></span>, <span>rootCertInPfxBtyes</span>);

<span><span>//</span> private key</span>
<span>var</span> <span>exportRsaPrivateKeyPem</span> <span>=</span> <span>importExportCertificate</span>.<span>PemExportRsaPrivateKey</span>(<span>devCertificate</span>);
<span>File</span>.<span>WriteAllText</span>(<span><span>$"</span>dev_localhost.key<span>"</span></span>, <span>exportRsaPrivateKeyPem</span>);

<span><span>//</span> public key certificate as pem</span>
<span>var</span> <span>exportPublicKeyCertificatePem</span> <span>=</span> <span>importExportCertificate</span>.<span>PemExportPublicKeyCertificate</span>(<span>devCertificate</span>);
<span>File</span>.<span>WriteAllText</span>(<span><span>$"</span>dev_localhost.pem<span>"</span></span>, <span>exportPublicKeyCertificatePem</span>);</pre></div>
<h2>Creating Chained Certificates from a trusted CA Certificate</h2>
<h2>Exporting Certificates</h2>
<h3>Exporting self signed certificates</h3>
<div><pre><span>var</span> <span>serverCertInPfxBtyes</span> <span>=</span> 
    <span>importExportCertificate</span>.<span>ExportSelfSignedCertificatePfx</span>(<span>password</span>, <span>server</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>"</span>server.pfx<span>"</span></span>, <span>serverCertInPfxBtyes</span>);

<span>var</span> <span>clientCertInPfxBtyes</span> <span>=</span> 
    <span>importExportCertificate</span>.<span>ExportSelfSignedCertificatePfx</span>(<span>password</span>, <span>client</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>"</span>client.pfx<span>"</span></span>, <span>clientCertInPfxBtyes</span>);</pre></div>
<h3>Exporting chained certificates</h3>
<div><pre><span>string</span> <span>password</span> <span>=</span> <span><span>"</span>1234<span>"</span></span>;
<span>var</span> <span>importExportCertificate</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>ImportExportCertificate</span>&gt;();

<span>var</span> <span>rootCertInPfxBtyes</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportRootPfx</span>(<span>password</span>, <span>rootCaL1</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>"</span>localhost_root_l1.pfx<span>"</span></span>, <span>rootCertInPfxBtyes</span>);

<span>var</span> <span>rootPublicKey</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportCertificatePublicKey</span>(<span>rootCaL1</span>);
<span>var</span> <span>rootPublicKeyBytes</span> <span>=</span> <span>rootPublicKey</span>.<span>Export</span>(<span>X509ContentType</span>.<span>Cert</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>$"</span>localhost_root_l1.cer<span>"</span></span>, <span>rootPublicKeyBytes</span>);

<span>var</span> <span>intermediateCertInPfxBtyes</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportChainedCertificatePfx</span>(<span>password</span>, <span>intermediateCaL2</span>, <span>rootCaL1</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>"</span>localhost_intermediate_l2.pfx<span>"</span></span>, <span>intermediateCertInPfxBtyes</span>);

<span>var</span> <span>serverCertL3InPfxBtyes</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportChainedCertificatePfx</span>(<span>password</span>, <span>serverL3</span>, <span>intermediateCaL2</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>"</span>serverl3.pfx<span>"</span></span>, <span>serverCertL3InPfxBtyes</span>);

<span>var</span> <span>clientCertL3InPfxBtyes</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportChainedCertificatePfx</span>(<span>password</span>, <span>clientL3</span>, <span>intermediateCaL2</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>"</span>clientl3.pfx<span>"</span></span>, <span>clientCertL3InPfxBtyes</span>);</pre></div>
<h3>Exporting verify certificates</h3>
<div><pre><span>var</span> <span>serviceProvider</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
    .<span>AddCertificateManager</span>()
    .<span>BuildServiceProvider</span>();

<span>var</span> <span>createClientServerAuthCerts</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>CreateCertificatesClientServerAuth</span>&gt;();

<span>var</span> <span>importExportCertificate</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>ImportExportCertificate</span>&gt;();

<span>var</span> <span>root</span> <span>=</span> <span>new</span> <span>X509Certificate2</span>(<span><span>"</span>root.pfx<span>"</span></span>, <span><span>"</span>1234<span>"</span></span>);

<span>var</span> <span>deviceVerify</span> <span>=</span> <span>createClientServerAuthCerts</span>.<span>NewDeviceVerificationCertificate</span>(
<span><span>"</span>4C8C754C6DA4280DBAB7FC7BB320E7FFFB7F411CBB7EAA7D<span>"</span></span>, <span>root</span>);
<span>deviceVerify</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>device verify<span>"</span></span>;

<span>var</span> <span>deviceVerifyPEM</span> <span>=</span> <span>importExportCertificate</span>.<span>PemExportPublicKeyCertificate</span>(<span>deviceVerify</span>);
<span>File</span>.<span>WriteAllText</span>(<span><span>"</span>deviceVerify.pem<span>"</span></span>, <span>deviceVerifyPEM</span>);

<span>var</span> <span>deviceVerifyPublicKey</span> <span>=</span> <span>importExportCertificate</span>.<span>ExportCertificatePublicKey</span>(<span>deviceVerify</span>);
<span>var</span> <span>deviceVerifyPublicKeyBytes</span> <span>=</span> <span>deviceVerifyPublicKey</span>.<span>Export</span>(<span>X509ContentType</span>.<span>Cert</span>);
<span>File</span>.<span>WriteAllBytes</span>(<span><span>$"</span>deviceVerify.cer<span>"</span></span>, <span>deviceVerifyPublicKeyBytes</span>);</pre></div>
<h2>Exporting Importing PEM</h2>
<p>RSA</p>
<div><pre><span>var</span> <span>sp</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
    .<span>AddCertificateManager</span>()
    .<span>BuildServiceProvider</span>();

<span>var</span> <span>ccRsa</span> <span>=</span> <span>sp</span>.<span>GetService</span>&lt;<span>CreateCertificatesRsa</span>&gt;();
<span>var</span> <span>iec</span> <span>=</span> <span>sp</span>.<span>GetService</span>&lt;<span>ImportExportCertificate</span>&gt;();

<span>var</span> <span>rsaCert</span> <span>=</span> <span>ccRsa</span>.<span>CreateDevelopmentCertificate</span>(<span><span>"</span>localhost<span>"</span></span>, <span>2</span>, <span>2048</span>);

<span><span>//</span> export</span>
<span>var</span> <span>publicKeyPem</span> <span>=</span> <span>iec</span>.<span>PemExportPublicKeyCertificate</span>(<span>rsaCert</span>);
<span>var</span> <span>rsaPrivateKeyPem</span> <span>=</span> <span>iec</span>.<span>PemExportRsaPrivateKey</span>(<span>rsaCert</span>);

<span><span>//</span> import</span>
<span>var</span> <span>roundTripPublicKeyPem</span> <span>=</span> <span>iec</span>.<span>PemImportCertificate</span>(<span>publicKeyPem</span>);
<span>var</span> <span>roundTripRsaPrivateKeyPem</span> <span>=</span> <span>iec</span>.<span>PemImportPrivateKey</span>(<span>rsaPrivateKeyPem</span>);

<span>var</span> <span>roundTripFullCert</span> <span>=</span> 
    <span>iec</span>.<span>CreateCertificateWithPrivateKey</span>(
        <span>roundTripPublicKeyPem</span>, 
        <span>roundTripRsaPrivateKeyPem</span>, 
        <span><span>"</span>1234<span>"</span></span>);
</pre></div>
<p>ECDsa</p>
<div><pre><span>var</span> <span>sp</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
    .<span>AddCertificateManager</span>()
    .<span>BuildServiceProvider</span>();

<span>var</span> <span>cc</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>CreateCertificatesClientServerAuth</span>&gt;();

<span>var</span> <span>root</span> <span>=</span> <span>cc</span>.<span>NewRootCertificate</span>(
    <span>new</span> <span>DistinguishedName</span> { <span>CommonName</span> <span>=</span> <span><span>"</span>root dev<span>"</span></span>, <span>Country</span> <span>=</span> <span><span>"</span>IT<span>"</span></span> },
    <span>new</span> <span>ValidityPeriod</span> { <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>, <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>) },
    <span>3</span>, <span><span>"</span>localhost<span>"</span></span>);
<span>root</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>developement root L1 certificate<span>"</span></span>;

<span>var</span> <span>iec</span> <span>=</span> <span>sp</span>.<span>GetService</span>&lt;<span>ImportExportCertificate</span>&gt;();

<span><span>//</span> export</span>
<span>var</span> <span>publicKeyPem</span> <span>=</span> <span>iec</span>.<span>PemExportPublicKeyCertificate</span>(<span>root</span>);
<span>var</span> <span>eCDsaPrivateKeyPem</span> <span>=</span> <span>iec</span>.<span>PemExportECPrivateKey</span>(<span>root</span>);

<span><span>//</span> import</span>
<span>var</span> <span>roundTripPublicKeyPem</span> <span>=</span> <span>iec</span>.<span>PemImportCertificate</span>(<span>publicKeyPem</span>);
<span>var</span> <span>roundTripECPrivateKeyPem</span> <span>=</span> <span>iec</span>.<span>PemImportPrivateKey</span>(<span>eCDsaPrivateKeyPem</span>);

<span>var</span> <span>roundTripFullCert</span> <span>=</span> 
    <span>iec</span>.<span>CreateCertificateWithPrivateKey</span>(
        <span>roundTripPublicKeyPem</span>, 
        <span>roundTripECPrivateKeyPem</span>, 
        <span><span>"</span>1234<span>"</span></span>);
</pre></div>
<h2>General Certificates, full APIs</h2>
<h3>Self signed certificate</h3>
<p>Creating a self signed certificate using <strong>NewECDsaSelfSignedCertificate</strong> with ECDsa</p>
<div><pre><span>var</span> <span>serviceProvider</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
    .<span>AddCertificateManager</span>()
    .<span>BuildServiceProvider</span>();

<span>var</span> <span>enhancedKeyUsages</span> <span>=</span> <span>new</span> <span>OidCollection</span> {
    <span>new</span> <span>Oid</span>(<span><span>"</span>1.3.6.1.5.5.7.3.2<span>"</span></span>), <span><span>//</span> TLS Client auth</span>
    <span>new</span> <span>Oid</span>(<span><span>"</span>1.3.6.1.5.5.7.3.1<span>"</span></span>)  <span><span>//</span> TLS Server auth</span>
};

<span>var</span> <span>createCertificates</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>CreateCertificates</span>&gt;();

<span><span>//</span> Create the root self signed cert</span>
<span>var</span> <span>rootCert</span> <span>=</span> <span>createCertificates</span>.<span>NewECDsaSelfSignedCertificate</span>(
    <span>RootCertConfig</span>.<span>DistinguishedName</span>,
    <span>RootCertConfig</span>.<span>BasicConstraints</span>,
    <span>RootCertConfig</span>.<span>ValidityPeriod</span>,
    <span>RootCertConfig</span>.<span>SubjectAlternativeName</span>,
    <span>enhancedKeyUsages</span>,
    <span>RootCertConfig</span>.<span>X509KeyUsageFlags</span>,
    <span>new</span> <span>ECDsaConfiguration</span>());

<span>rootCert</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>localhost root l1<span>"</span></span>;</pre></div>
<p>Certificate configuration for a self signed root</p>
<div><pre><span>public</span> <span>static</span> <span>class</span> <span>RootCertConfig</span>
{
    <span>public</span> <span>static</span> <span>DistinguishedName</span> <span>DistinguishedName</span> <span>=</span> <span>new</span> <span>DistinguishedName</span>
    {
        <span>CommonName</span> <span>=</span> <span><span>"</span>localhost<span>"</span></span>,
        <span>Country</span> <span>=</span> <span><span>"</span>CH<span>"</span></span>,
        <span>Locality</span> <span>=</span> <span><span>"</span>CH<span>"</span></span>,
        <span>Organisation</span> <span>=</span> <span><span>"</span>damienbod<span>"</span></span>,
        <span>OrganisationUnit</span> <span>=</span> <span><span>"</span>developement<span>"</span></span>
    };

    <span>public</span> <span>static</span> <span>BasicConstraints</span> <span>BasicConstraints</span> <span>=</span> <span>new</span> <span>BasicConstraints</span>
    {
        <span>CertificateAuthority</span> <span>=</span> <span>true</span>,
        <span>HasPathLengthConstraint</span> <span>=</span> <span>true</span>,
        <span>PathLengthConstraint</span> <span>=</span> <span>3</span>,
        <span>Critical</span> <span>=</span> <span>true</span>
    };

    <span>public</span> <span>static</span> <span>ValidityPeriod</span> <span>ValidityPeriod</span> <span>=</span> <span>new</span> <span>ValidityPeriod</span>
    {
        <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>,
        <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>)
    };

    <span>public</span> <span>static</span> <span>SubjectAlternativeName</span> <span>SubjectAlternativeName</span> <span>=</span> <span>new</span> <span>SubjectAlternativeName</span>
    {
        <span>Email</span> <span>=</span> <span><span>"</span>damienbod@damienbod.ch<span>"</span></span>,
        <span>DnsName</span> <span>=</span> <span>new</span> <span>List</span>&lt;<span>string</span>&gt;
        {
            <span><span>"</span>localhost<span>"</span></span>,
            <span><span>"</span>test.damienbod.ch<span>"</span></span>
        }
    };

    <span><span>//</span> Only X509KeyUsageFlags.KeyCertSign required for client server auth</span>
    <span>public</span> <span>static</span> <span>X509KeyUsageFlags</span> <span>X509KeyUsageFlags</span> <span>=</span> <span>X509KeyUsageFlags</span>.<span>DigitalSignature</span>
            <span>|</span> <span>X509KeyUsageFlags</span>.<span>KeyEncipherment</span>
            <span>|</span> <span>X509KeyUsageFlags</span>.<span>KeyCertSign</span>;
    }</pre></div>
<h3>Chained certificate</h3>
<p>Creating a certificate using <strong>NewECDsaChainedCertificate</strong> using ECDsa</p>
<div><pre><span>var</span> <span>serviceProvider</span> <span>=</span> <span>new</span> <span>ServiceCollection</span>()
    .<span>AddCertificateManager</span>()
    .<span>BuildServiceProvider</span>();

<span>var</span> <span>enhancedKeyUsages</span> <span>=</span> <span>new</span> <span>OidCollection</span> {
    <span>new</span> <span>Oid</span>(<span><span>"</span>1.3.6.1.5.5.7.3.2<span>"</span></span>), <span><span>//</span> TLS Client auth</span>
    <span>new</span> <span>Oid</span>(<span><span>"</span>1.3.6.1.5.5.7.3.1<span>"</span></span>)  <span><span>//</span> TLS Server auth</span>
};

<span>var</span> <span>createCertificates</span> <span>=</span> <span>serviceProvider</span>.<span>GetService</span>&lt;<span>CreateCertificates</span>&gt;();

<span>var</span> <span>deviceCertificate</span> <span>=</span> <span>createCertificates</span>.<span>NewECDsaChainedCertificate</span>(
    <span>DeviceCertConfig</span>.<span>DistinguishedName</span>,
    <span>DeviceCertConfig</span>.<span>BasicConstraints</span>,
    <span>DeviceCertConfig</span>.<span>ValidityPeriod</span>,
    <span>DeviceCertConfig</span>.<span>SubjectAlternativeName</span>,
    <span>intermediateCertificateLevel3</span>,
    <span>enhancedKeyUsages</span>,
    <span>DeviceCertConfig</span>.<span>X509KeyUsageFlags</span>,
    <span>new</span> <span>ECDsaConfiguration</span>());

<span>deviceCertificate</span>.<span>FriendlyName</span> <span>=</span> <span><span>"</span>device cert l4<span>"</span></span>;</pre></div>
<p>Device certificate chained</p>
<div><pre><span>public</span> <span>static</span> <span>class</span> <span>DeviceCertConfig</span>
    {
        <span>public</span> <span>static</span> <span>DistinguishedName</span> <span>DistinguishedName</span> <span>=</span> <span>new</span> <span>DistinguishedName</span>
        {
            <span>CommonName</span> <span>=</span> <span><span>"</span>localhost<span>"</span></span>,
            <span>Country</span> <span>=</span> <span><span>"</span>CH<span>"</span></span>,
            <span>Locality</span> <span>=</span> <span><span>"</span>CH<span>"</span></span>,
            <span>Organisation</span> <span>=</span> <span><span>"</span>firma x<span>"</span></span>,
            <span>OrganisationUnit</span> <span>=</span> <span><span>"</span>skills<span>"</span></span>
        };

        <span>public</span> <span>static</span> <span>BasicConstraints</span> <span>BasicConstraints</span> <span>=</span> <span>new</span> <span>BasicConstraints</span>
        {
            <span>CertificateAuthority</span> <span>=</span> <span>false</span>,
            <span>HasPathLengthConstraint</span> <span>=</span> <span>false</span>,
            <span>PathLengthConstraint</span> <span>=</span> <span>0</span>,
            <span>Critical</span> <span>=</span> <span>true</span>
        };

        <span>public</span> <span>static</span> <span>ValidityPeriod</span> <span>ValidityPeriod</span> <span>=</span> <span>new</span> <span>ValidityPeriod</span>
        {
            <span>ValidFrom</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>,
            <span>ValidTo</span> <span>=</span> <span>DateTime</span>.<span>UtcNow</span>.<span>AddYears</span>(<span>10</span>)
        };

        <span>public</span> <span>static</span> <span>SubjectAlternativeName</span> <span>SubjectAlternativeName</span> <span>=</span> <span>new</span> <span>SubjectAlternativeName</span>
        {
            <span>DnsName</span> <span>=</span> <span>new</span> <span>List</span>&lt;<span>string</span>&gt;
            {
                <span><span>"</span>localhost<span>"</span></span>
            }
        };

        <span>public</span> <span>static</span> <span>X509KeyUsageFlags</span> <span>X509KeyUsageFlags</span> <span>=</span> 
             <span>X509KeyUsageFlags</span>.<span>DigitalSignature</span> <span>|</span> <span>X509KeyUsageFlags</span>.<span>KeyEncipherment</span>;
    }</pre></div>
<h2>Certificate Configuration full APIs</h2>
<h3>Basic Constraints</h3>
<p>basic constraints for intermediate and root certificates. Set the path length to match the chain length.</p>
<div><pre><span>var</span> <span>basicConstraints</span> <span>=</span> <span>new</span> <span>BasicConstraints</span>
{
    <span>CertificateAuthority</span> <span>=</span> <span>true</span>,
    <span>HasPathLengthConstraint</span> <span>=</span> <span>true</span>,
    <span>PathLengthConstraint</span> <span>=</span> <span>pathLengthConstraint</span>,
    <span>Critical</span> <span>=</span> <span>true</span>
};</pre></div>
<p>Or the basic constaints for a device, client or server certificate.</p>
<div><pre><span>var</span> <span>basicConstraints</span> <span>=</span> <span>new</span> <span>BasicConstraints</span>
{
    <span>CertificateAuthority</span> <span>=</span> <span>false</span>,
    <span>HasPathLengthConstraint</span> <span>=</span> <span>false</span>,
    <span>PathLengthConstraint</span> <span>=</span> <span>0</span>,
    <span>Critical</span> <span>=</span> <span>true</span>
};</pre></div>
<h3>Subject Alternative Name</h3>
<p>Add the required or supported DnsName or the Email here.</p>
<div><pre><span>var</span> <span>subjectAlternativeName</span> <span>=</span> <span>new</span> <span>SubjectAlternativeName</span>
{
    <span>DnsName</span> <span>=</span> <span>new</span> <span>List</span>&lt;<span>string</span>&gt;
    {
        <span><span>"</span>localhost<span>"</span></span>
    }
};</pre></div>
<h3>Enhanced Key Usages</h3>
<p>Defines how the certificate key can be used.</p>
<div><pre><span>var</span> <span>enhancedKeyUsages</span> <span>=</span> <span>new</span> <span>OidCollection</span> {
    <span>new</span> <span>Oid</span>(<span><span>"</span>1.3.6.1.5.5.7.3.2<span>"</span></span>), <span><span>//</span> TLS Client auth</span>
    <span>new</span> <span>Oid</span>(<span><span>"</span>1.3.6.1.5.5.7.3.1<span>"</span></span>)  <span><span>//</span> TLS Server auth</span>
};</pre></div>
<ul>
<li>new Oid("1.3.6.1.5.5.7.3.1")  // TLS Server auth</li>
<li>new Oid("1.3.6.1.5.5.7.3.2")  // TLS Client auth</li>
<li>new Oid("1.3.6.1.5.5.7.3.3")  // Code signing</li>
<li>new Oid("1.3.6.1.5.5.7.3.4")  // Email</li>
<li>new Oid("1.3.6.1.5.5.7.3.8")  // Timestamping</li>
</ul>
<h3>X509 Key Usage Flags</h3>
<p>Defines how the certificate key can be used.</p>
<div><pre><span>var</span> <span>x509KeyUsageFlags</span> <span>=</span> 
             <span>X509KeyUsageFlags</span>.<span>DigitalSignature</span> <span>|</span> <span>X509KeyUsageFlags</span>.<span>KeyEncipherment</span>;</pre></div>
<ul>
<li>None             No key usage parameters.</li>
<li>EncipherOnly     The key can be used for encryption only.</li>
<li>CrlSign          The key can be used to sign a certificate revocation list (CRL).</li>
<li>KeyCertSign      The key can be used to sign certificates.</li>
<li>KeyAgreement     The key can be used to determine key agreement, such as a key created using the Diffie-Hellman key agreement algorithm.</li>
<li>DataEncipherment The key can be used for data encryption.</li>
<li>KeyEncipherment  The key can be used for key encryption.</li>
<li>NonRepudiation   The key can be used for authentication.</li>
<li>DecipherOnly     The key can be used for decryption only.</li>
</ul>
</article>
  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>