<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Understanding the Whys, Whats, and Whens of ValueTask | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Understanding the Whys, Whats, and Whens of ValueTask | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Stephen ToubSoftware Engineer,&#xA0;.NETFollow Stephen"/>
    <meta property="og:description" content="The .NET Framework 4 saw the introduction of the&#xA0;System.Threading.Tasks&#xA0;namespace, and with it the&#xA0;Task&#xA0;class. This type and the derived&#xA0;Task&lt;TResult&gt;&#xA0;have long since become a staple of .NET programming, key aspects of the asynchronous programming model introduced with C# 5 and its&#xA0;async&#xA0;/&#xA0;await&#xA0;keywords."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Understanding the Whys, Whats, and Whens of ValueTask | .NET Blog</title>
<div class="readable">
        <h1>Understanding the Whys, Whats, and Whens of ValueTask | .NET Blog</h1>
            <div>by Stephen ToubSoftware Engineer,&#xA0;.NETFollow Stephen</div>
            <div>Reading time: 22-28 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/">https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/2f85938ff9d752d14977fa35c0af37e5?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p><p>Stephen</p></div></div></div><p>November 7th, 2018</p><p>The .NET Framework 4 saw the introduction of the&nbsp;<code>System.Threading.Tasks</code>&nbsp;namespace, and with it the&nbsp;<code>Task</code>&nbsp;class. This type and the derived&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;have long since become a staple of .NET programming, key aspects of the asynchronous programming model introduced with C# 5 and its&nbsp;<code>async</code>&nbsp;/&nbsp;<code>await</code>&nbsp;keywords. In this post, I’ll cover the newer&nbsp;<code>ValueTask</code>/<code>ValueTask&lt;TResult&gt;</code>&nbsp;types, which were introduced to help improve asynchronous performance in common use cases where decreased allocation overhead is important.</p><h2>Task</h2><p><code>Task</code>&nbsp;serves multiple purposes, but at its core it’s a “promise”, an object that represents the eventual completion of some operation. You initiate an operation and get back a&nbsp;<code>Task</code>&nbsp;for it, and that&nbsp;<code>Task</code>&nbsp;will complete when the operation completes, which may happen synchronously as part of initiating the operation (e.g. accessing some data that was already buffered), asynchronously but complete by the time you get back the&nbsp;<code>Task</code>&nbsp;(e.g. accessing some data that wasn’t yet buffered but that was very fast to access), or asynchronously and complete after you’re already holding the&nbsp;<code>Task</code>&nbsp;(e.g. accessing some data from across a network). Since operations might complete asynchronously, you either need to block waiting for the results (which often defeats the purpose of the operation having been asynchronous to begin with) or you need to supply a callback that’ll be invoked when the operation completes. In .NET 4, providing such a callback was achieved via&nbsp;<code>ContinueWith</code>&nbsp;methods on the&nbsp;<code>Task</code>, which explicitly exposed the callback model by accepting a delegate to invoke when the&nbsp;<code>Task</code>&nbsp;completed:</p><div><pre><span>SomeOperationAsync</span><span>().</span><span>ContinueWith</span><span>(</span><span>task </span><span>=&gt;</span><span>
</span><span>{</span><span>
    </span><span>try</span><span>
    </span><span>{</span><span>
        </span><span>TResult</span><span> result </span><span>=</span><span> task</span><span>.</span><span>Result</span><span>;</span><span>
        </span><span>UseResult</span><span>(</span><span>result</span><span>);</span><span>
    </span><span>}</span><span>
    </span><span>catch</span><span> </span><span>(</span><span>Exception</span><span> e</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>HandleException</span><span>(</span><span>e</span><span>);</span><span>
    </span><span>}</span><span>
</span><span>});</span></pre></div><p>But with the .NET Framework 4.5 and C# 5,&nbsp;<code>Task</code>s could simply be&nbsp;<code>await</code>ed, making it easy to consume the results of an asynchronous operation, and with the generated code being able to optimize all of the aforementioned cases, correctly handling things regardless of whether the operation completes synchronously, completes asynchronously quickly, or completes asynchronously after already (implicitly) providing a callback:</p><div><pre><span>TResult</span><span> result </span><span>=</span><span> await </span><span>SomeOperationAsync</span><span>();</span><span>
</span><span>UseResult</span><span>(</span><span>result</span><span>);</span></pre></div><p><code>Task</code>&nbsp;as a class is very flexible and has resulting benefits. For example, you can await it multiple times, by any number of consumers concurrently. You can store one into a dictionary for any number of subsequent consumers to await in the future, which allows it to be used as a cache for asynchronous results. You can block waiting for one to complete should the scenario require that. And you can write and consume a large variety of operations over tasks (sometimes referred to as “combinators”), such as a “when any” operation that asynchronously waits for the first to complete.</p><p>However, that flexibility is not needed for the most common case: simply invoking an asynchronous operation and awaiting its resulting task:</p><div><pre><span>TResult</span><span> result </span><span>=</span><span> await </span><span>SomeOperationAsync</span><span>();</span><span>
</span><span>UseResult</span><span>(</span><span>result</span><span>);</span></pre></div><p>In such usage, we don’t need to be able to await the task multiple times. We don’t need to be able to handle concurrent awaits. We don’t need to be able to handle synchronous blocking. We don’t need to write combinators. We simply need to be able to await the resulting promise of the asynchronous operation. This is, after all, how we write synchronous code (e.g.&nbsp;<code>TResult result = SomeOperation();</code>), and it naturally translates to the world of&nbsp;<code>async</code>&nbsp;/&nbsp;<code>await</code>.</p><p>Further,&nbsp;<code>Task</code>&nbsp;does have a potential downside, in particular for scenarios where instances are created&nbsp;<em>a lot</em>&nbsp;and where high-throughput and performance is a key concern:&nbsp;<code>Task</code>&nbsp;is a class. As a class, that means that any operation which needs to create one needs to allocate an object, and the more objects that are allocated, the more work the garbage collector (GC) needs to do, and the more resources we spend on it that could be spent doing other things.</p><p>The runtime and core libraries mitigate this in many situations. For example, if you write a method like the following:</p><div><pre><span>public</span><span> async </span><span>Task</span><span> </span><span>WriteAsync</span><span>(</span><span>byte</span><span> value</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>if</span><span> </span><span>(</span><span>_bufferedCount </span><span>==</span><span> _buffer</span><span>.</span><span>Length</span><span>)</span><span>
    </span><span>{</span><span>
        await </span><span>FlushAsync</span><span>();</span><span>
    </span><span>}</span><span>
    _buffer</span><span>[</span><span>_bufferedCount</span><span>++]</span><span> </span><span>=</span><span> value</span><span>;</span><span>
</span><span>}</span></pre></div><p>in the common case there will be space available in the buffer and the operation will complete synchronously. When it does, there’s nothing special about the&nbsp;<code>Task</code>&nbsp;that needs to be returned, since there’s no return value: this is the&nbsp;<code>Task</code>-based equivalent of a&nbsp;<code>void</code>-returning synchronous method. Thus, the runtime can simply cache a single non-generic&nbsp;<code>Task</code>&nbsp;and use that over and over again as the result task for any&nbsp;<code>async Task</code>&nbsp;method that completes synchronously (that cached singleton is exposed via `Task.CompletedTask`). Or for example, if you write:</p><div><pre><span>public</span><span> async </span><span>Task</span><span>&lt;bool&gt;</span><span> </span><span>MoveNextAsync</span><span>()</span><span>
</span><span>{</span><span>
    </span><span>if</span><span> </span><span>(</span><span>_bufferedCount </span><span>==</span><span> </span><span>0</span><span>)</span><span>
    </span><span>{</span><span>
        await </span><span>FillBuffer</span><span>();</span><span>
    </span><span>}</span><span>
    </span><span>return</span><span> _bufferedCount </span><span>&gt;</span><span> </span><span>0</span><span>;</span><span>
</span><span>}</span></pre></div><p>in the common case, we expect there to be some data buffered, in which case this method simply checks&nbsp;<code>_bufferedCount</code>, sees that it’s larger than&nbsp;<code>0</code>, and returns&nbsp;<code>true</code>; only if there’s currently no buffered data does it need to perform an operation that might complete asynchronously. And since there are only two possible&nbsp;<code>Boolean</code>&nbsp;results (<code>true</code>&nbsp;and&nbsp;<code>false</code>), there are only two possible&nbsp;<code>Task&lt;bool&gt;</code>&nbsp;objects needed to represent all possible result values, and so the runtime is able to cache two such objects and simply return a cached&nbsp;<code>Task&lt;bool&gt;</code>&nbsp;with a&nbsp;<code>Result</code>&nbsp;of&nbsp;<code>true</code>, avoiding the need to allocate. Only if the operation completes asynchronously does the method then need to allocate a new&nbsp;<code>Task&lt;bool&gt;</code>, because it needs to hand back the object to the caller before it knows what the result of the operation will be, and needs to have a unique object into which it can store the result when the operation does complete.</p><p>The runtime maintains a small such cache for other types as well, but it’s not feasible to cache everything. For example, a method like:</p><div><pre><span>public</span><span> async </span><span>Task</span><span>&lt;int&gt;</span><span> </span><span>ReadNextByteAsync</span><span>()</span><span>
</span><span>{</span><span>
    </span><span>if</span><span> </span><span>(</span><span>_bufferedCount </span><span>==</span><span> </span><span>0</span><span>)</span><span>
    </span><span>{</span><span>
        await </span><span>FillBuffer</span><span>();</span><span>
    </span><span>}</span><span>

    </span><span>if</span><span> </span><span>(</span><span>_bufferedCount </span><span>==</span><span> </span><span>0</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>return</span><span> </span><span>-</span><span>1</span><span>;</span><span>
    </span><span>}</span><span>

    _bufferedCount</span><span>--;</span><span>
    </span><span>return</span><span> _buffer</span><span>[</span><span>_position</span><span>++];</span><span>
</span><span>}</span></pre></div><p>will also frequently complete synchronously. But unlike the&nbsp;<code>Boolean</code>&nbsp;case, this method returns an&nbsp;<code>Int32</code>&nbsp;value, which has ~4 billion possible results, and caching a&nbsp;<code>Task&lt;int&gt;</code>&nbsp;for all such cases would consume potentially hundreds of gigabytes of memory. The runtime does maintain a small cache for&nbsp;<code>Task&lt;int&gt;</code>, but only for a few small result values, so for example if this completes synchronously (there’s data in the buffer) with a value like 4, it’ll end up using a cached task, but if it completes synchronously with a value like 42, it’ll end up allocating a new&nbsp;<code>Task&lt;int&gt;</code>, akin to calling&nbsp;<code>Task.FromResult(42)</code>.</p><p>Many library implementations attempt to mitigate this further by maintaining their own cache as well. For example, the&nbsp;<code>MemoryStream.ReadAsync</code>&nbsp;overload introduced in the .NET Framework 4.5 always completes synchronously, since it’s just reading data from memory.&nbsp;<code>ReadAsync</code>&nbsp;returns a&nbsp;<code>Task&lt;int&gt;</code>, where the&nbsp;<code>Int32</code>&nbsp;result represents the number of bytes read.&nbsp;<code>ReadAsync</code>&nbsp;is often used in a loop, often with the number of bytes requested the same on each call, and often with&nbsp;<code>ReadAsync</code>&nbsp;able to fully fulfill that request. Thus, it’s common for repeated calls to&nbsp;<code>ReadAsync</code>&nbsp;to return a&nbsp;<code>Task&lt;int&gt;</code>&nbsp;synchronously with the same result as it did on the previous call. As such,&nbsp;<code>MemoryStream</code>&nbsp;maintains a cache of a single task, the last one it returned successfully. Then on a subsequent call, if the new result matches that of its cached&nbsp;<code>Task&lt;int&gt;</code>, it just returns the cached one again; otherwise, it uses&nbsp;<code>Task.FromResult</code>&nbsp;to create a new one, stores that as its new cached task, and returns it.</p><p>Even so, there are many cases where operations complete synchronously and are forced to allocate a&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;to hand back.<a id="user-content-valuetasktresult-and-synchronous-completion" href="https://github.com/stephentoub/dotnet-blog/blob/ff8b236a4867d0e1dfa34daae6f203c18c594a7d/2018/11-Nov/valuetasks/valuetasks.md#valuetasktresult-and-synchronous-completion" target="_blank"></a></p><h2>ValueTask&lt;TResult&gt;&nbsp;and synchronous completion</h2><p>All of this motivated the introduction of a new type in .NET Core 2.0 and made available for previous .NET releases via a&nbsp;<code>System.Threading.Tasks.Extensions</code>&nbsp;NuGet package:&nbsp;<code>ValueTask&lt;TResult&gt;</code>.</p><p><code>ValueTask&lt;TResult&gt;</code>&nbsp;was introduced in .NET Core 2.0 as a struct capable of wrapping either a&nbsp;<code>TResult</code>&nbsp;or a&nbsp;<code>Task&lt;TResult&gt;</code>. This means it can be returned from an async method, and if that method completes synchronously and successfully, nothing need be allocated: we can simply initialize this&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;struct with the&nbsp;<code>TResult</code>&nbsp;and return that. Only if the method completes asynchronously does a&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;need to be allocated, with the&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;created to wrap that instance (to minimize the size of&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;and to optimize for the success path, an async method that faults with an unhandled exception will also allocate a&nbsp;<code>Task&lt;TResult&gt;</code>, so that the&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;can simply wrap that&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;rather than always having to carry around an additional field to store an&nbsp;<code>Exception</code>).</p><p>With that, a method like&nbsp;<code>MemoryStream.ReadAsync</code>&nbsp;that instead returns a&nbsp;<code>ValueTask&lt;int&gt;</code>&nbsp;need not be concerned with caching, and can instead be written with code like:</p><div><pre><span>public</span><span> </span><span>override</span><span> </span><span>ValueTask</span><span>&lt;int&gt;</span><span> </span><span>ReadAsync</span><span>(</span><span>byte</span><span>[]</span><span> buffer</span><span>,</span><span> </span><span>int</span><span> offset</span><span>,</span><span> </span><span>int</span><span> count</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>try</span><span>
    </span><span>{</span><span>
        </span><span>int</span><span> bytesRead </span><span>=</span><span> </span><span>Read</span><span>(</span><span>buffer</span><span>,</span><span> offset</span><span>,</span><span> count</span><span>);</span><span>
        </span><span>return</span><span> </span><span>new</span><span> </span><span>ValueTask</span><span>&lt;int&gt;</span><span>(</span><span>bytesRead</span><span>);</span><span>
    </span><span>}</span><span>
    </span><span>catch</span><span> </span><span>(</span><span>Exception</span><span> e</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>return</span><span> </span><span>new</span><span> </span><span>ValueTask</span><span>&lt;int&gt;</span><span>(</span><span>Task</span><span>.</span><span>FromException</span><span>&lt;int&gt;</span><span>(</span><span>e</span><span>));</span><span>
    </span><span>}</span><span>
</span><span>}</span></pre></div><h2>ValueTask&lt;TResult&gt;&nbsp;and asynchronous completion</h2><p>Being able to write an async method that can complete synchronously without incurring an additional allocation for the result type is a big win. This is why&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;was added to .NET Core 2.0, and why new methods that are expected to be used on hot paths are now defined to return&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;instead of&nbsp;<code>Task&lt;TResult&gt;</code>. For example, when we added a new&nbsp;<code>ReadAsync</code>&nbsp;overload to&nbsp;<code>Stream</code>&nbsp;in .NET Core 2.1 in order to be able to pass in a&nbsp;<code>Memory&lt;byte&gt;</code>&nbsp;instead of a&nbsp;<code>byte[]</code>, we made the return type of that method be&nbsp;<code>ValueTask&lt;int&gt;</code>. That way, Streams (which very often have a&nbsp;<code>ReadAsync</code>&nbsp;method that completes synchronously, as in the earlier&nbsp;<code>MemoryStream</code>&nbsp;example) can now be used with significantly less allocation.</p><p>However, when working on very high-throughput services, we still care about avoiding as much allocation as possible, and that means thinking about reducing and removing allocations associated with asynchronous completion paths as well.</p><p>With the&nbsp;<code>await</code>&nbsp;model, for any operation that completes asynchronously we need to be able to hand back an object that represents the eventual completion of the operation: the caller needs to be able to hand off a callback that’ll be invoked when the operation completes, and that requires having a unique object on the heap that can serve as the conduit for this specific operation. It doesn’t, however, imply anything about whether that object can be reused once an operation completes. If the object can be reused, then an API can maintain a cache of one or more such objects, and reuse them for serialized operations, meaning it can’t use the same object for multiple in-flight async operations, but it can reuse an object for non-concurrent accesses.</p><p>In .NET Core 2.1,&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;was augmented to support such pooling and reuse. Rather than just being able to wrap a&nbsp;<code>TResult</code>&nbsp;or a&nbsp;<code>Task&lt;TResult&gt;</code>, a new interface was introduced,&nbsp;<code>IValueTaskSource&lt;TResult&gt;</code>, and&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;was augmented to be able to wrap that as well.&nbsp;<code>IValueTaskSource&lt;TResult&gt;</code>&nbsp;provides the core support necessary to represent an asynchronous operation to&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;in a similar manner to how&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;does:</p><div><pre><span>public</span><span> </span><span>interface</span><span> </span><span>IValueTaskSource</span><span>&lt;</span><span>out</span><span> </span><span>TResult</span><span>&gt;</span><span>
</span><span>{</span><span>
    </span><span>ValueTaskSourceStatus</span><span> </span><span>GetStatus</span><span>(</span><span>short</span><span> token</span><span>);</span><span>
    </span><span>void</span><span> </span><span>OnCompleted</span><span>(</span><span>Action</span><span>&lt;object&gt;</span><span> continuation</span><span>,</span><span> </span><span>object</span><span> state</span><span>,</span><span> </span><span>short</span><span> token</span><span>,</span><span> </span><span>ValueTaskSourceOnCompletedFlags</span><span> flags</span><span>);</span><span>
    </span><span>TResult</span><span> </span><span>GetResult</span><span>(</span><span>short</span><span> token</span><span>);</span><span>
</span><span>}</span></pre></div><p><code>GetStatus</code>&nbsp;is used to satisfy properties like&nbsp;<code>ValueTask&lt;TResult&gt;.IsCompleted</code>, returning an indication of whether the async operation is still pending or whether it’s completed and how (success or not).&nbsp;<code>OnCompleted</code>&nbsp;is used by the&nbsp;<code>ValueTask&lt;TResult&gt;</code>‘s awaiter to hook up the callback necessary to continue execution from an&nbsp;<code>await</code>&nbsp;when the operation completes. And&nbsp;<code>GetResult</code>&nbsp;is used to retrieve the result of the operation, such that after the operation completes, the awaiter can either get the&nbsp;<code>TResult</code>&nbsp;or propagate any exception that may have occurred.</p><p>Most developers should never have a need to see this interface: methods simply hand back a&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;that may have been constructed to wrap an instance of this interface, and the consumer is none-the-wiser. The interface is primarily there so that developers of performance-focused APIs are able to avoid allocation.</p><p>There are several such APIs in .NET Core 2.1. The most notable are&nbsp;<code>Socket.ReceiveAsync</code>&nbsp;and&nbsp;<code>Socket.SendAsync</code>, with new overloads added in 2.1, e.g.</p><div><pre><span>public</span><span> </span><span>ValueTask</span><span>&lt;int&gt;</span><span> </span><span>ReceiveAsync</span><span>(</span><span>Memory</span><span>&lt;byte&gt;</span><span> buffer</span><span>,</span><span> </span><span>SocketFlags</span><span> socketFlags</span><span>,</span><span> </span><span>CancellationToken</span><span> cancellationToken </span><span>=</span><span> </span><span>default</span><span>);</span></pre></div><p>This overload returns a&nbsp;<code>ValueTask&lt;int&gt;</code>. If the operation completes synchronously, it can simply construct a&nbsp;<code>ValueTask&lt;int&gt;</code>&nbsp;with the appropriate result, e.g.</p><div><pre><span>int</span><span> result </span><span>=</span><span> </span><span>…;</span><span>
</span><span>return</span><span> </span><span>new</span><span> </span><span>ValueTask</span><span>&lt;int&gt;</span><span>(</span><span>result</span><span>);</span></pre></div><p>If it completes asynchronously, it can use a pooled object that implements this interface:</p><div><pre><span>IValueTaskSource</span><span>&lt;int&gt;</span><span> vts </span><span>=</span><span> </span><span>…;</span><span>
</span><span>return</span><span> </span><span>new</span><span> </span><span>ValueTask</span><span>&lt;int&gt;</span><span>(</span><span>vts</span><span>);</span></pre></div><p>The&nbsp;<code>Socket</code>&nbsp;implementation maintains one such pooled object for receives and one for sends, such that as long as no more than one of each is outstanding at a time, these overloads will end up being allocation-free, even if they complete operations asynchronously. That’s then further surfaced through&nbsp;<code>NetworkStream</code>. For example, in .NET Core 2.1,&nbsp;<code>Stream</code>&nbsp;exposes:</p><div><pre><span>public</span><span> </span><span>virtual</span><span> </span><span>ValueTask</span><span>&lt;int&gt;</span><span> </span><span>ReadAsync</span><span>(</span><span>Memory</span><span>&lt;byte&gt;</span><span> buffer</span><span>,</span><span> </span><span>CancellationToken</span><span> cancellationToken</span><span>);</span></pre></div><p>which&nbsp;<code>NetworkStream</code>&nbsp;overrides.&nbsp;<code>NetworkStream.ReadAsync</code>&nbsp;just delegates to&nbsp;<code>Socket.ReceiveAsync</code>, so the wins from&nbsp;<code>Socket</code>&nbsp;translate to&nbsp;<code>NetworkStream</code>, and&nbsp;<code>NetworkStream.ReadAsync</code>&nbsp;effectively becomes allocation-free as well.</p><h2>Non-generic&nbsp;ValueTask</h2><p>When&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;was introduced in .NET Core 2.0, it was purely about optimizing for the synchronous completion case, in order to avoid having to allocate a&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;to store the&nbsp;<code>TResult</code>&nbsp;already available. That also meant that a non-generic&nbsp;<code>ValueTask</code>&nbsp;wasn’t necessary: for the synchronous completion case, the&nbsp;<code>Task.CompletedTask</code>&nbsp;singleton could just be returned from a&nbsp;<code>Task</code>-returning method, and was implicitly by the runtime for&nbsp;<code>async Task</code>&nbsp;methods.</p><p>With the advent of enabling even asynchronous completions to be allocation-free, however, a non-generic&nbsp;<code>ValueTask</code>&nbsp;becomes relevant again. Thus, in .NET Core 2.1 we also introduced the non-generic&nbsp;<code>ValueTask</code>&nbsp;and&nbsp;<code>IValueTaskSource</code>. These provide direct counterparts to the generic versions, usable in similar ways, just with a void result.</p><h2><a id="user-content-implementing-ivaluetasksource--ivaluetasksourcet" href="https://github.com/stephentoub/dotnet-blog/blob/ff8b236a4867d0e1dfa34daae6f203c18c594a7d/2018/11-Nov/valuetasks/valuetasks.md#implementing-ivaluetasksource--ivaluetasksourcet" target="_blank"></a>Implementing&nbsp;IValueTaskSource&nbsp;/&nbsp;IValueTaskSource&lt;T&gt;</h2><p>Most developers should never need to implement these interfaces. They’re also not particularly easy to implement. If you decide you need to, there are several implementations internal to .NET Core 2.1 that can serve as a reference, e.g.</p><ul><li><a href="https://github.com/dotnet/corefx/blob/61f51e6b2b26271de205eb8a14236afef482971b/src/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs#L808" target="_blank"><code>AwaitableSocketAsyncEventArgs</code></a></li><li><a href="https://github.com/dotnet/corefx/blob/89ab1e83a7e00d869e1580151e24f01226acaf3f/src/System.Threading.Channels/src/System/Threading/Channels/AsyncOperation.cs#L37" target="_blank"><code>AsyncOperation&lt;TResult&gt;</code></a></li><li><a href="https://github.com/dotnet/corefx/blob/a10890f4ffe0fadf090c922578ba0e606ebdd16c/src/System.IO.Pipelines/src/System/IO/Pipelines/Pipe.DefaultPipeReader.cs#L16" target="_blank"><code>DefaultPipeReader</code></a></li></ul><p>To make this easier for developers that do want to do it, in .NET Core 3.0 we plan to introduce all of this logic encapsulated into a&nbsp;<code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code>&nbsp;type, a struct that can be encapsulated into another object that implements&nbsp;<code>IValueTaskSource&lt;TResult&gt;</code>&nbsp;and/or&nbsp;<code>IValueTaskSource</code>, with that wrapper type simply delegating to the struct for the bulk of its implementation. You can learn more about this in the associated issue in the dotnet/corefx repo at&nbsp;<a href="https://github.com/dotnet/corefx/issues/32664" target="_blank">https://github.com/dotnet/corefx/issues/32664</a>.</p><h2><a id="user-content-valid-consumption-patterns-for-valuetasks" href="https://github.com/stephentoub/dotnet-blog/blob/ff8b236a4867d0e1dfa34daae6f203c18c594a7d/2018/11-Nov/valuetasks/valuetasks.md#valid-consumption-patterns-for-valuetasks" target="_blank"></a>Valid consumption patterns for ValueTasks</h2><p>From a surface area perspective,&nbsp;<code>ValueTask</code>&nbsp;and&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;are much more limited than&nbsp;<code>Task</code>&nbsp;and&nbsp;<code>Task&lt;TResult&gt;</code>. That’s ok, even desirable, as the primary method for consumption is meant to simply be&nbsp;<code>await</code>ing them.</p><p>However, because&nbsp;<code>ValueTask</code>&nbsp;and&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;may wrap reusable objects, there are actually significant constraints on their consumption when compared with&nbsp;<code>Task</code>&nbsp;and&nbsp;<code>Task&lt;TResult&gt;</code>, should someone veer off the desired path of just&nbsp;<code>await</code>ing them. In general, the following operations should&nbsp;<em>never</em>&nbsp;be performed on a&nbsp;<code>ValueTask</code>&nbsp;/&nbsp;<code>ValueTask&lt;TResult&gt;</code>:</p><ul><li><strong>Awaiting a&nbsp;<code>ValueTask</code>&nbsp;/&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;multiple times.</strong>&nbsp;The underlying object may have been recycled already and be in use by another operation. In contrast, a&nbsp;<code>Task</code>&nbsp;/&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;will never transition from a complete to incomplete state, so you can await it as many times as you need to, and will always get the same answer every time.</li><li><strong>Awaiting a&nbsp;<code>ValueTask</code>&nbsp;/&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;concurrently.</strong>&nbsp;The underlying object expects to work with only a single callback from a single consumer at a time, and attempting to await it concurrently could easily introduce race conditions and subtle program errors. It’s also just a more specific case of the above bad operation: “awaiting a&nbsp;<code>ValueTask</code>&nbsp;/&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;multiple times.” In contrast,&nbsp;<code>Task</code>&nbsp;/&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;do support any number of concurrent awaits.</li><li><strong>Using&nbsp;<code>.GetAwaiter().GetResult()</code>&nbsp;when the operation hasn’t yet completed.</strong>&nbsp;The&nbsp;<code>IValueTaskSource</code>&nbsp;/&nbsp;<code>IValueTaskSource&lt;TResult&gt;</code>&nbsp;implementation need not support blocking until the operation completes, and likely doesn’t, so such an operation is inherently a race condition and is unlikely to behave the way the caller intends. In contrast,&nbsp;<code>Task</code>&nbsp;/&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;do enable this, blocking the caller until the task completes.</li></ul><p>If you have a&nbsp;<code>ValueTask</code>&nbsp;or a&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;and you need to do one of these things, you should use&nbsp;<code>.AsTask()</code>&nbsp;to get a&nbsp;<code>Task</code>&nbsp;/&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;and then operate on that resulting task object. After that point, you should never interact with that&nbsp;<code>ValueTask</code>&nbsp;/&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;again.</p><p><strong>The short rule is this:</strong>&nbsp;with a&nbsp;<code>ValueTask</code>&nbsp;or a&nbsp;<code>ValueTask&lt;TResult&gt;</code>, you should either&nbsp;<code>await</code>&nbsp;it directly (optionally with&nbsp;<code>.ConfigureAwait(false)</code>) or call&nbsp;<code>AsTask()</code>&nbsp;on it directly, and then never use it again, e.g.</p><div><pre><span>// Given this ValueTask&lt;int&gt;-returning method…</span><span>
</span><span>public</span><span> </span><span>ValueTask</span><span>&lt;int&gt;</span><span> </span><span>SomeValueTaskReturningMethodAsync</span><span>();</span><span>
</span><span>…</span><span>
</span><span>// GOOD</span><span>
</span><span>int</span><span> result </span><span>=</span><span> await </span><span>SomeValueTaskReturningMethodAsync</span><span>();</span><span>

</span><span>// GOOD</span><span>
</span><span>int</span><span> result </span><span>=</span><span> await </span><span>SomeValueTaskReturningMethodAsync</span><span>().</span><span>ConfigureAwait</span><span>(</span><span>false</span><span>);</span><span>

</span><span>// GOOD</span><span>
</span><span>Task</span><span>&lt;int&gt;</span><span> t </span><span>=</span><span> </span><span>SomeValueTaskReturningMethodAsync</span><span>().</span><span>AsTask</span><span>();</span><span>

</span><span>// WARNING</span><span>
</span><span>ValueTask</span><span>&lt;int&gt;</span><span> vt </span><span>=</span><span> </span><span>SomeValueTaskReturningMethodAsync</span><span>();</span><span>
</span><span>...</span><span> </span><span>// storing the instance into a local makes it much more likely it'll be misused,</span><span>
    </span><span>// but it could still be ok</span><span>

</span><span>// BAD: awaits multiple times</span><span>
</span><span>ValueTask</span><span>&lt;int&gt;</span><span> vt </span><span>=</span><span> </span><span>SomeValueTaskReturningMethodAsync</span><span>();</span><span>
</span><span>int</span><span> result </span><span>=</span><span> await vt</span><span>;</span><span>
</span><span>int</span><span> result2 </span><span>=</span><span> await vt</span><span>;</span><span>

</span><span>// BAD: awaits concurrently (and, by definition then, multiple times)</span><span>
</span><span>ValueTask</span><span>&lt;int&gt;</span><span> vt </span><span>=</span><span> </span><span>SomeValueTaskReturningMethodAsync</span><span>();</span><span>
</span><span>Task</span><span>.</span><span>Run</span><span>(</span><span>async </span><span>()</span><span> </span><span>=&gt;</span><span> await vt</span><span>);</span><span>
</span><span>Task</span><span>.</span><span>Run</span><span>(</span><span>async </span><span>()</span><span> </span><span>=&gt;</span><span> await vt</span><span>);</span><span>

</span><span>// BAD: uses GetAwaiter().GetResult() when it's not known to be done</span><span>
</span><span>ValueTask</span><span>&lt;int&gt;</span><span> vt </span><span>=</span><span> </span><span>SomeValueTaskReturningMethodAsync</span><span>();</span><span>
</span><span>int</span><span> result </span><span>=</span><span> vt</span><span>.</span><span>GetAwaiter</span><span>().</span><span>GetResult</span><span>();</span></pre></div><p>There is one additional advanced pattern that some developers may choose to use, hopefully only after measuring carefully and finding it provides meaningful benefit. Specifically,&nbsp;<code>ValueTask</code>&nbsp;/&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;do expose some properties that speak to the current state of the operation, for example the&nbsp;<code>IsCompleted</code>&nbsp;property returning&nbsp;<code>false</code>&nbsp;if the operation hasn’t yet completed, and returning&nbsp;<code>true</code>&nbsp;if it has (meaning it’s no longer running and may have completed successfully or otherwise), and the&nbsp;<code>IsCompletedSuccessfully</code>&nbsp;property returning&nbsp;<code>true</code>&nbsp;if and only if it’s completed and completed successfully (meaning attempting to await it or access its result will not result in an exception being thrown). For very hot paths where a developer wants to, for example, avoid some additional costs only necessary on the asynchronous path, these properties can be checked prior to performing one of the operations that essentially invalidates the&nbsp;<code>ValueTask</code>&nbsp;/&nbsp;<code>ValueTask&lt;TResult&gt;</code>, e.g.&nbsp;<code>await</code>,&nbsp;<code>.AsTask()</code>. For example, in the&nbsp;<code>SocketsHttpHandler</code>&nbsp;implementation in .NET Core 2.1, the code issues a read on a connection, which returns a&nbsp;<code>ValueTask&lt;int&gt;</code>. If that operation completed synchronously, then we don’t need to worry about being able to cancel the operation. But if it completes asynchronously, then while it’s running we want to hook up cancellation such that a cancellation request will tear down the connection. As this is a very hot code path, and as profiling showed it to make a small difference, the code is structured essentially as follows:</p><div><pre><span>int</span><span> bytesRead</span><span>;</span><span>
</span><span>{</span><span>
    </span><span>ValueTask</span><span>&lt;int&gt;</span><span> readTask </span><span>=</span><span> _connection</span><span>.</span><span>ReadAsync</span><span>(</span><span>buffer</span><span>);</span><span>
    </span><span>if</span><span> </span><span>(</span><span>readTask</span><span>.</span><span>IsCompletedSuccessfully</span><span>)</span><span>
    </span><span>{</span><span>
        bytesRead </span><span>=</span><span> readTask</span><span>.</span><span>Result</span><span>;</span><span>
    </span><span>}</span><span>
    </span><span>else</span><span>
    </span><span>{</span><span>
        </span><span>using</span><span> </span><span>(</span><span>_connection</span><span>.</span><span>RegisterCancellation</span><span>())</span><span>
        </span><span>{</span><span>
            bytesRead </span><span>=</span><span> await readTask</span><span>;</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
</span><span>}</span></pre></div><p>This pattern is acceptable, because the&nbsp;<code>ValueTask&lt;int&gt;</code>&nbsp;isn’t used again after either&nbsp;<code>.Result</code>&nbsp;is accessed or it’s awaited.</p><h2><a id="user-content-should-every-new-asynchronous-api-return-valuetask--valuetasktresult" href="https://github.com/stephentoub/dotnet-blog/blob/ff8b236a4867d0e1dfa34daae6f203c18c594a7d/2018/11-Nov/valuetasks/valuetasks.md#should-every-new-asynchronous-api-return-valuetask--valuetasktresult" target="_blank"></a>Should every new asynchronous API return&nbsp;ValueTask&nbsp;/&nbsp;ValueTask&lt;TResult&gt;?</h2><p>In short, no: the default choice is still&nbsp;<code>Task</code>&nbsp;/&nbsp;<code>Task&lt;TResult&gt;</code>.</p><p>As highlighted above,&nbsp;<code>Task</code>&nbsp;and&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;are easier to use correctly than are&nbsp;<code>ValueTask</code>&nbsp;and&nbsp;<code>ValueTask&lt;TResult&gt;</code>, and so unless the performance implications outweigh the usability implications,&nbsp;<code>Task</code>&nbsp;/&nbsp;<code>Task&lt;TResult&gt;</code>are still preferred. There are also some minor costs associated with returning a&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;instead of a&nbsp;<code>Task&lt;TResult&gt;</code>, e.g. in microbenchmarks it’s a bit faster to&nbsp;<code>await</code>&nbsp;a&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;than it is to&nbsp;<code>await</code>&nbsp;a&nbsp;<code>ValueTask&lt;TResult&gt;</code>, so if you can use cached tasks (e.g. you’re API returns&nbsp;<code>Task</code>&nbsp;or&nbsp;<code>Task&lt;bool&gt;</code>), you might be better off performance-wise sticking with&nbsp;<code>Task</code>&nbsp;and&nbsp;<code>Task&lt;bool&gt;</code>.&nbsp;<code>ValueTask</code>&nbsp;/&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;are also multiple words in size, and so when these are&nbsp;<code>await</code>d and a field for them is stored in a calling async method’s state machine, they’ll take up a little more space in that state machine object.</p><p>However,&nbsp;<code>ValueTask</code>&nbsp;/&nbsp;<code>ValueTask&lt;TResult&gt;</code>&nbsp;are great choices when a) you expect consumers of your API to only&nbsp;<code>await</code>&nbsp;them directly, b) allocation-related overhead is important to avoid for your API, and c) either you expect synchronous completion to be a very common case, or you’re able to effectively pool objects for use with asynchronous completion. When adding abstract, virtual, or interface methods, you also need to consider whether these situations will exist for overrides/implementations of that method.</p><h2><a id="user-content-whats-next-for-valuetask-and-valuetasktresult" href="https://github.com/stephentoub/dotnet-blog/blob/ff8b236a4867d0e1dfa34daae6f203c18c594a7d/2018/11-Nov/valuetasks/valuetasks.md#whats-next-for-valuetask-and-valuetasktresult" target="_blank"></a>What’s Next for&nbsp;ValueTask&nbsp;and&nbsp;ValueTask&lt;TResult&gt;?</h2><p>For the core .NET libraries, we’ll continue to see new&nbsp;<code>Task</code>&nbsp;/&nbsp;<code>Task&lt;TResult&gt;</code>-returning APIs added, but we’ll also see new&nbsp;<code>ValueTask</code>&nbsp;/&nbsp;<code>ValueTask&lt;TResult&gt;</code>-returning APIs added where appropriate. One key example of the latter is for the new&nbsp;<code>IAsyncEnumerator&lt;T&gt;</code>&nbsp;support planned for .NET Core 3.0.&nbsp;<code>IEnumerator&lt;T&gt;</code>&nbsp;exposes a&nbsp;<code>bool</code>-returning&nbsp;<code>MoveNext</code>&nbsp;method, and the asynchronous&nbsp;<code>IAsyncEnumerator&lt;T&gt;</code>&nbsp;counterpart exposes a&nbsp;<code>MoveNextAsync</code>method. When we initially started designing this feature, we thought of&nbsp;<code>MoveNextAsync</code>&nbsp;as returning a&nbsp;<code>Task&lt;bool&gt;</code>, which could be made very efficient via cached tasks for the common case of&nbsp;<code>MoveNextAsync</code>&nbsp;completing synchronously. However, given how wide-reaching we expect async enumerables to be, and given that they’re based on interfaces that could end up with many different implementations (some of which may care deeply about performance and allocations), and given that the vast, vast majority of consumption will be through&nbsp;<code>await foreach</code>&nbsp;language support, we switched to having&nbsp;<code>MoveNextAsync</code>&nbsp;return a&nbsp;<code>ValueTask&lt;bool&gt;</code>. This allows for the synchronous completion case to be fast but also for optimized implementations to use reusable objects to make the asynchronous completion case low-allocation as well. In fact, the C# compiler takes advantage of this when implementing async iterators to make async iterators as allocation-free as possible.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>