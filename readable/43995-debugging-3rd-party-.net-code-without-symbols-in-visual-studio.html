<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Debugging 3rd Party .NET Code without symbols in Visual Studio -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Debugging 3rd Party .NET Code without symbols in Visual Studio</h1>
    <div class="post-content entry-content"> <p>It&#x2019;s not so rare to see weird things happen in 3rd party library code. Call some method and you&#x2019;ve got a strange exception. Or an incorrect behavior or even a process crash. Is it a bug? Are you doing something wrong? Is it a configuration problem? It sure would be nice to debug some of these issues.</p>
<p>In this article we&#x2019;re going to do just that &#x2013; We&#x2019;re going to see how to debug 3rd party library code in Visual Studio. It doesn&#x2019;t have to be 3rd party code though. It might be internal company code without symbols, your own production code, or code from the .NET framework itself. We&#x2019;ll see how to debug any .NET assembly that has no symbols or source code.</p>
<h2>Breaking on Exceptions from 3rd-party code</h2>
<p>There are many cases when there&#x2019;s an exception in the 3rd-party code that you want to debug. Here are some examples:</p>
<ul>
<li>When something strange is going on and you can&#x2019;t understand why. For example, a request to your server returns a 500 error code for no apparent reason. There&#x2019;s a good chance there was an exception in some middleware for which you don&#x2019;t have symbols and source code. The exception was swallowed in a <code>catch</code> clause and you are left to guesswork.</li>
<li>It happens once and again that you&#x2019;re calling 3rd party library code and it returns unexpected results. There&#x2019;s a good chance an exception was thrown and then handled. If you knew the exception details, it might have helped to solve the issue.</li>
<li>Suppose you&#x2019;re calling 3rd party library code and it throws an exception. You will see the exception object, but only partial call stack frames. And no local variables from the frame where the exception was thrown. Sure, the exception object contains some of the details, but that&#x2019;s not the whole picture.</li> </ul>
<p>There are a couple of things you need to do to be able to debug these exceptions.</p>
<h3>1. User Code and non-user code</h3>
<p>Visual Studio tags code as &#x201C;user-code&#x201D; and &#x201C;non-user code&#x201D;. If an assembly has symbols and it&#x2019;s not optimized, then it&#x2019;s considered &#x201C;user-code&#x201D;. Otherwise, it&#x2019;s considered &#x201C;non-user code&#x201D;. Any 3rd-party code is going to be &#x201C;non-user code&#x201D; because it&#x2019;s usually without symbols and almost certainly optimized.</p>
<p>To break on exceptions from non-user code, you&#x2019;ll need to turn off the &#x201C;Enable Just My Code&#x201D; setting in VS options:</p>
<p><img src="/wp-content/uploads/2019/12/thirdParty-vs-debuggingOptions.png"></p>
<h3>2. Optimized code</h3>
<p>When you build a project in &#x201C;Release&#x201D; mode, it&#x2019;s set to &#x201C;optimize code&#x201D; by default. This is done for performance reasons because optimized code is much faster. Code optimization changes many things like rearranges code and inlines methods. For performance reasons and to prevent reverse-engineering, 3rd party code is almost always optimized.</p>
<p>When you build in &#x201C;Debug&#x201D; mode, the default setting is not to optimize code. That&#x2019;s because when code is optimized, many of the debugger&#x2019;s features stop working. This includes seeing Local Variables, seeing the currently executed line and stopping on breakpoints.</p>
<p>The thing is that the IL code produced from Debug and Release builds is the same because code optimization is done in runtime. The only difference is a flag that instructs the JIT compiler to optimize or not to optimize. By default, when you do break on the exception, you won&#x2019;t see Locals because the code will be optimized. But if you check &#x201C;Suppress JIT optimization on module load&#x201D; (like in the image above), then VS will tell the JIT Compiler, not to optimized code.</p>
<h6>Note that code is optimized when a module loads. So if you attach Visual Studio when the module was already loaded, it will stay optimized, even if the &#x201C;Suppress&#x2026; &#x201D; setting is on. That&#x2019;s why it&#x2019;s always best to start the process with Visual Studio debugger instead of attaching. You can see which modules are optimized in the Modules window.</h6> <p>Here&#x2019;s an example of an exception in 3rd-party code:</p> <div id="crayon-5defffd2ca9e3189595783" class="crayon-syntax crayon-theme-github crayon-font-consolas crayon-os-pc print-yes notranslate"> <div class="crayon-main"> <table class="crayon-table"> <tr class="crayon-row"> <td class="crayon-nums "> </td> <td class="crayon-code"><div class="crayon-pre"><p class="crayon-line" id="crayon-5defffd2ca9e3189595783-1"><span class="crayon-m">public</span><span class="crayon-h"> </span><span class="crayon-e">override </span><span class="crayon-t">void</span><span class="crayon-h"> </span><span class="crayon-e">Start</span><span class="crayon-sy">(</span><span class="crayon-sy">)</span></p><p class="crayon-line" id="crayon-5defffd2ca9e3189595783-2"><span class="crayon-sy">{</span></p><p class="crayon-line" id="crayon-5defffd2ca9e3189595783-3"><span class="crayon-h">&#xA0;&#xA0;&#xA0;&#xA0;</span><span class="crayon-t">var</span><span class="crayon-h"> </span><span class="crayon-v">serialized</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-s">&quot;{\&quot;Nadsafsdfds&quot;</span><span class="crayon-sy">;</span><span class="crayon-h"> </span></p><p class="crayon-line" id="crayon-5defffd2ca9e3189595783-4"><span class="crayon-h">&#xA0;&#xA0;&#xA0;&#xA0;</span><span class="crayon-e">Person </span><span class="crayon-v">deserialized</span><span class="crayon-h"> </span><span class="crayon-o">=</span><span class="crayon-h"> </span><span class="crayon-v">JsonConvert</span><span class="crayon-sy">.</span><span class="crayon-v">DeserializeObject</span><span class="crayon-o">&lt;</span><span class="crayon-v">Person</span><span class="crayon-o">&gt;</span><span class="crayon-sy">(</span><span class="crayon-v">serialized</span><span class="crayon-sy">)</span><span class="crayon-sy">;</span></p><p class="crayon-line" id="crayon-5defffd2ca9e3189595783-5"><span class="crayon-sy">}</span></p></div></td> </tr> </table> </div> </div> <p>When checking &#x201C;Suppress JIT optimization&#x201D; you&#x2019;ll see Locals and you&#x2019;ll see a full call stack:</p>
<p><img src="/wp-content/uploads/2019/12/thirdParty-vs-supressedOptimize.png"></p>
<p>However, if &#x201C;Suppress JIT optimization&#x201D; was not checked and the code was optimized, the results are much less informative:</p>
<p> <img src="/wp-content/uploads/2019/12/thirdParty-vs-optimized.png"></p>
<p>The Locals cannot be evaluated and the call stack doesn&#x2019;t really say anything from within the non-user code.</p>
<h6>Newtonsoft.Json has <a href="http://blog.ctaggart.com/2018/06/newtonsoftjson-enabling-source-link.html">SourceLink enabled</a>. This means the symbols contain a link to the correct git commit with the source code. If adding with NuGet, Visual Studio will be able to automatically load the source code and everything will work by itself. Instead of adding a NuGet package, I deleted the symbols and manually referenced Newtonsoft.Json.dll. So we&#x2019;re now dealing with an assembly without symbols or source code.</h6>
<h2>Place Breakpoints anywhere</h2>
<p>It&#x2019;s possible to place breakpoints in Visual Studio into methods for which you don&#x2019;t have the source code.</p>
<p>Before starting, make sure to uncheck &#x201C;Enable Just My Code&#x201D;, otherwise the breakpoint won&#x2019;t be hit. And to check &#x201C;Suppress JIT optimization on module load&#x201D; so that you can see Locals when the breakpoint does hit.</p>
<p>Before placing the breakpoint in 3rd party code, you&#x2019;ll need to find the method where you want to place the breakpoint. To do that, use your favorite decompiler to open the assembly and explore the methods (like <a href="https://github.com/icsharpcode/ILSpy">ILSpy</a>, <a href="https://www.jetbrains.com/decompiler/">dotPeek</a>, or <a href="https://www.telerik.com/products/decompiler.aspx">JustDecompile</a>). In the case of Newtonosoft.Json, let&#x2019;s say I want to place a breakpoint in the private method <code>SerializeObjectInternal</code>. You&#x2019;ll need the fully qualified name here: <code>Newtonsoft.Json.JsonConvert.SerializeObjectInternal</code> where <code>Newtonsoft.Json</code> is the namespace, <code>JsonConvert</code> is the class name, and <code>SerializeObjectInternal</code> is the method. </p>
<p>Now go to <strong>Debug | Windows | Breakpoints</strong> and click on <strong>New | Function Breakpoint&#x2026;</strong></p>
<p><img src="/wp-content/uploads/2019/12/thirdParty-vs-newBreakpoint.png"></p>
<p>In the dialog that opens, enter the fully-qualified name: <code>Newtonsoft.Json.JsonConvert.SerializeObjectInternal</code>.</p>
<p>That&#x2019;s it, run the code and the breakpoint will be hit.</p>
<p><img src="/wp-content/uploads/2019/12/thirdParty-vs-newBreakpointHit.png"></p>
<p>You&#x2019;ll be able to see the full call stack and the Locals. Pretty nice for no symbols and no source code. You can travel in the call stack and other threads. You&#x2019;ll see Locals for all frames, including those without symbols.</p>
<p>Note that VS has a little quirk when placing these breakpoints. It doesn&#x2019;t seem to work if you place the breakpoint before the current debugging session. So if you restart the process and start debugging again, your previously set breakpoints won&#x2019;t work. You always have to start debugging and set new breakpoints in the current debugging session.</p>
<h6><strong>TIP:</strong> Sometimes, you want to debug 3rd-party code, but have no idea which methods are hit and where to place the breakpoint. A great way to find out which methods were invoked in a scenario is to use a performance profiler like <a href="https://www.jetbrains.com/profiler/">dotTrace</a>. Record the snapshot you want to debug and look at all the methods that were called. It&#x2019;s best to use <strong>Tracing</strong> mode, which shows all methods that were hit, even if they took very little time.</h6>
<h2>Full debugging experience with dotPeek&#x2019;s symbol server</h2>
<p>Placing breakpoints is nice and can get you somewhere, but there&#x2019;s nothing like a full debugging experience where you can step over code with F10, step into methods with F11, and watch variables. It&#x2019;s quite possible to do in Visual Studio with any managed assembly, even without symbols and source code.</p>
<p>Even though this experience is a bit nicer with <a href="https://github.com/0xd4d/dnSpy">dnSpy</a>, you can achieve the same with Visual Studio and <a href="https://www.jetbrains.com/help/decompiler/Using_product_as_a_Symbol_Server.html">dotPeek&#x2019;s Symbol Server</a> capability. The concept is pretty simple: dotPeek decompiles the assembly and extracts symbols that point to the decompiled code. It then acts as a symbol server. Visual Studio just needs to add the symbol server&#x2019;s location and debugging just works.</p>
<p>To do this, start dotPeek with the correct bitness &#x2013; <strong>dotPeek32.exe</strong> if you&#x2019;re debugging a 32-bit process and <strong>dotPeek64.exe</strong> if you&#x2019;re debugging a 64-bit process. Open the assembly that you want to debug in dotPeek with <strong>File | Open</strong>. You&#x2019;ll see it appear in the Assembly Explorer. Now click the &#x201C;Start symbol server&#x201D; button:</p>
<p><img src="/wp-content/uploads/2019/12/thirdParty-dotPeek-symbolServer.png"></p>
<p>dotPeek will tell you the server&#x2019;s location. Something like <code>http://localhost:33417</code>.</p>
<p>In Visual Studio, go to <strong>Tools | Options | Debugging | Symbols</strong>. Hit the <strong>New Location</strong> button on top and add the URL from dotPeek. Now you&#x2019;re all set to start debugging. You&#x2019;ll be able to step into (F11) the 3rd party library and debug freely with source code and all other VS features available:</p>
<p><img src="/wp-content/uploads/2019/12/thirdParty-vs-withDotPeekDebugging.png"></p>
<p>Like with all other methods in this article, when using this, you need to disable the &#x201C;Enable Just My Code&#x201D; option and enable the &#x201C;Suppress JIT optimization on module load&#x201D; option.</p>
<p>If you don&#x2019;t want to step into the 3rd-party library code with F11, and want to place a breakpoint instead, there are a couple of ways to do that:</p>
<ul>
<li><p>Use the <strong>New Breakpoint</strong> functionality in Visual Studio&#x2019;s Breakpoints window that we talked about before.</p>
</li>
<li><p>Use ReSharper&#x2019;s <strong>Navigation to Sources</strong> feature. In this mode, R# overrides the default Visual Studio behavior when clicking F12 (Go to Definition). Instead of going to assembly Metadata, R# can take you to decompiled sources. And it integrates perfectly with dotPeek&#x2019;s symbol server by preferring symbol server sources first. Go to <strong>Extensions | ReSharper | Options | Tools | External Sources</strong> and select the last option <strong>Navigation to Sources</strong>:</p>
<p><img src="/wp-content/uploads/2019/12/thirdParty-vs-resharper-navigateToSources.png"></p>
<p>Now you can navigate to the library code with F12 and place breakpoints freely.</p>
</li> </ul>
<h2>Summary</h2>
<p>There are several techniques that we saw to debug .NET assemblies without symbols or source code. These methods can be a lifesaver when running into strange behavior. If there&#x2019;s one thing to remember from this article, it&#x2019;s this: Whenever something strange is going on, uncheck &#x201C;Enable Just My Code&#x201D; and run the scenario again. It&#x2019;s very possible that some exception occurred and you didn&#x2019;t even notice.</p>
<p>As for the wonderful experience with dotPeek&#x2019;s symbol server &#x2013; as great as it is, <a href="https://github.com/0xd4d/dnSpy">dnSpy</a> is even better. And it&#x2019;s much more suited to debug production machines than Visual Studio. Just copy the installation folder and run the executable. But that&#x2019;s stuff for another blog post. Happy debugging.</p> <div class="optin-endofpost optin-endofpost_desktop"> <div> <div> <img src="https://i2.wp.com/michaelscodingspot.com/wp-content/uploads/2017/06/black-small-optimized-flipped.gif?w=1080&amp;ssl=1"> </div> <div> <div> <span>Get Exclusive Articles and Level-up Your C# Game</span> <img src="https://i0.wp.com/michaelscodingspot.com/wp-content/uploads/2019/04/pdf-icon.png?w=1080&amp;ssl=1"> <span> Performance Optimizations in C#: 10 Best Practices</span> </div> </div> </div> </div> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>