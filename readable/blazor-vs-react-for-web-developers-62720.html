<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Blazor vs React for Web Developers - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Blazor vs React for Web Developers - linksfor.dev(s)"/>
    <meta property="og:description" content="A comparison of Blazor and React when it comes to modern web development&#x2014;a review of the pros and cons. Does Blazor stack up?"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.telerik.com/blogs/blazor-vs-react-web-developers"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Blazor vs React for Web Developers</title>
<div class="readable">
        <h1>Blazor vs React for Web Developers</h1>
            <div>Reading time: 16-20 minutes</div>
        <div>Posted here: 11 Jun 2020</div>
        <p><a href="https://www.telerik.com/blogs/blazor-vs-react-web-developers">https://www.telerik.com/blogs/blazor-vs-react-web-developers</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
  
  
			<p><span>A comparison of Blazor and React when it comes to modern web development—a review of the pros and cons. Does Blazor stack up?</span></p>
<p>Blazor WebAssembly&nbsp;(or Blazor Wasm, as all the cool kids are calling it!) has arrived, but how does it stack up compared to the other, more established options for building "modern" web applications?</p>
<p>Let's start with a comparison to React JS.</p>
<p>Specifically we'll explore how the following aspects work (for both frameworks):</p>
<ul>
    <li>Getting started</li>
    <li>Building the UI</li>
    <li>Passing data between components</li>
    <li>Handling Forms</li>
    <li>Routing</li>
    <li>Fetching data from an API</li>
    <li>Pros and cons of each</li>
</ul>
<p>Before we dig in, it's worth noting this article focuses on Blazor Wasm, which runs in the browser using WebAssembly. That said, many of the points are equally valid if you're looking at using Blazor Server instead.</p>
<h2 id="reactthetwominuteoverview">React—The Two-Minute Overview</h2>
<p>React is a <strong>UI library</strong> which helps you build responsive, interactive user interfaces for your web-based applications.</p>
<p>Unlike frameworks such as Angular, React focuses purely on the component-building aspects of your app and doesn't tackle other concerns (like routing), preferring instead to leave it up to you to choose the best tool for your specific use case.</p>
<p>When you create a new React app, it will automatically bring in various packages it needs to work (using npm or its alternative, Yarn) and you can then bring in additional packages to handle things like routing, handling forms, making network requests.</p>
<p>You write your application using HTML (well, actually JSX but we'll get to that), CSS, and JavaScript.</p>
<p>To publish your app, you can run a command to bundle it up (using a bundler such as webpack), take the static bundled files (HTML, JavaScript, etc.) and deploy them to a web server.  </p>
<p>When someone visits the deployed site, the browser JavaScript engine kicks in and runs your application code, rendering elements via the browser's DOM and handling various browser events (users clicking buttons, entering text in an input, etc.).</p>
<p>If you need to fetch data from a database or similar, you can make HTTP requests from your application to a server, which will return the data for your app to display.</p>
<h2 id="howdoesblazorcompare">How Does Blazor Compare?</h2>
<p>Blazor is a <strong>framework</strong> which also enables you to build client web applications that run in the browser, but using C# instead of JavaScript.</p>
<p>When you create a new Blazor app, it arrives with a few carefully selected packages (the essentials needed to make everything work) and you can install additional packages using NuGet.</p>
<p>From here, you build your app as a series of components, using the Razor markup language, with your UI logic written using C#.</p>
<p>To publish your app, you can use .NET's built-in <code>publish</code> command, which bundles up your application into a number of files (HTML, CSS, JavaScript and DLLs) which can then be published to any web server that can serves static files.</p>
<p>When a user accesses your Blazor Wasm application, a Blazor JavaScript file takes over which downloads the .NET runtime, your application and its dependencies, before running your app using WebAssembly.</p>
<p>Blazor then takes care of updating the DOM, rendering elements and forwarding events (such as button clicks) to your application code.</p>
<h2 id="creatinganewreactapp">Creating a New React App</h2>
<p>By far the simplest way to spin up a new React application is to use "Create React App."</p>
<p>You need these commands:</p>

<p>CRA also gives you easily accessed commands for bundling up your app ready for deployment.</p>
<h2 id="creatinganewblazorapp">Creating a New Blazor App</h2>
<p>For Blazor, you can use Visual Studio or spin up a new project via the command prompt.</p>

<p>You have a few other options, like the ability to include infrastructure for authenticating users, and whether to host your Blazor app in an ASP.NET web application, but the command above is the simplest option to get started.</p>
<h2 id="buildingyouruiwithreact">Building Your UI with React</h2>
<p>With React you build your applications as a series of components, using a declarative approach.</p>
<p>Here's an example:</p>

<p>If you're not familiar with React, there's a little to unpack here.</p>
<p>React components are written using JavaScript. </p>
<p>Here we export a JavaScript function called <code>Greeting</code>.</p>
<p>This <code>Greeting</code> function represents a React component, and exporting it means we can easily reference this elsewhere in our app (so we can render it wherever we want).</p>
<p>Our <code>Greeting</code> function returns something which looks suspiciously like HTML but is actually JSX.</p>
<p>JSX is really JavaScript. </p>
<p>For example, when we declare <code>span</code> as JSX in a component, React will turn this into JavaScript which will be invoked to render the relevant HTML markup in the browser.</p>
<p>In practice, you can usually just write your JSX as if it were HTML and everything "just works!"</p>
<p>If you look at the <code>input</code> element, you'll notice we've declared an event handler for the <code>onChange</code> event. When you type something into this input, it will invoke our <code>nameChanged</code> function.</p>
<p>This will update the state of our component using something called hooks. Specifically we're using the <code>UseState</code> hook to update the value of <code>name</code> to whatever the user typed in.</p>
<p>Finally, in our <code>span</code> element we render the value of <code>name</code> resulting in a friendly personalized greeting for our user.</p>
<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-06/react-hello-world.png" alt="A form field asks &quot;What's your name,&quot; and Jon has been entered. After that, it says, &quot;Hello Jon&quot;" title="react hello world"></p>
<p>As we change the value in the input, the greeting instantly updates to reflect the new value.</p>
<p>Generally speaking, everything you build in React revolves around components, which you can then render wherever you want, like this:</p>

<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-06/ReactHelloWorld.gif" alt="React example showing how typing name changes the greeting" title="react hello world in action"></p>
<p>In summary, a React UI:</p>
<ul>
    <li>Comprises one or more components</li>
    <li>Is written using JSX (which takes your markup and data, and combines them together)</li>
    <li>Runs as JavaScript in the browser</li>
</ul>
<h2 id="buildingyouruiwithblazor">Building Your UI with Blazor</h2>
<p>Blazor adopts a very similar approach to React in that you build your UI using components.</p>
<p>Where it differs is that you use Razor and C# (instead of JSX and JavaScript) to write your markup and UI logic.</p>

<p>This operates exactly the same way as the React example when you run it in the browser.</p>
<p>We've got roughly the same markup, but this time we have used Blazor's <code>@bind</code> syntax to bind our input to a property called <code>Name</code>.</p>
<p>When the user enters their name, the <code>Name</code>  property will be updated with the value they enter.</p>
<p>By default, Blazor would update the value of <code>Name</code> on blur (when we clicked out of the text input) so we've added <code>@bind-value:event="oninput"</code> to make it update the property as soon as we start typing.</p>
<p>As with React you're now free to render this component wherever (and as often as) you like.</p>

<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-06/blazor-hello-world.gif" alt="Blazor example showing how typing in a name changes the greeting" title="Blazor Hello World in action"></p>
<p>In summary, a Blazor UI:</p>
<ul>
    <li>Comprises one or more components</li>
    <li>Is written using Razor and C# (which takes your markup and data, and combines them together)</li>
    <li>Runs on WebAssembly in the browser</li>
</ul>
<h2 id="passingdataaroundreact">Passing Data Around—React</h2>
<p>There are two main "out of the box" approaches to handling state in your React components.</p>
<p>They can either interact with their own state (as we saw when we stored <code>Name</code> in our example), or they can accept data via props:</p>

<p>Here we've added a <code>props</code> argument to our <code>Greeting</code> function, and then rendered its value in our component via <code>{props.headline}</code>.</p>
<p>Now when we render this component, we can pass in a value for the headline.</p>

<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-06/react-custom-headline.png" alt="React example showing greeting with customized greeting" title="React greeting with custom headline"></p>
<p>As you use React for real applications, these options for storing state can become a little unwieldy, with more and more state to pass around and/or store. This is where alternatives like Redux come into play, giving you a centralized data store for your entire application. </p>
<p>But it's worth noting Redux is not directly tied to React, and is not something you would necessarily use from day one when you start building React applications.</p>
<h2 id="passingdataaroundblazor">Passing Data Around—Blazor</h2>
<p>Broadly speaking, Blazor has the same two primary options for managing state.</p>
<p>You can store data in the component itself using properties (as with <code>Name</code> in our example) or take data in via parameters.</p>

<p>As with the React example, when you render <code>Greeting</code> you can pass in a headline and it will be rendered accordingly.</p>

<h2 id="handlingformsinreact">Handling Forms in React</h2>
<p>React doesn't ship with anything to specifically help you with forms.</p>
<p>This means you need to either "roll your own" or use a third-party npm package for the job.</p>
<p>Here's the markup for a simple contact form.</p>

<p>Note how we're setting the value of our inputs from state in our component (<code>name</code> and <code>comments</code>) and forwarding the onChange events to our own functions (<code>handleNameChange</code> and <code>handleCommentsChange</code>).</p>
<p>Here's what the JavaScript for this function looks like:</p>

<p>So we are effectively intercepting the normal behavior for the form to both read and update our own component state.</p>
<p>For validation you can either roll your own, writing logic to check the values set in the form and alerting the user if they are invalid, or lean on third-party libraries (typically brought in via npm).</p>
<h2 id="handlingformswithblazor">Handling Forms with Blazor</h2>
<p>By contrast, Blazor has built-in functionality to handle your form data and validation using something called <code>EditForm</code>.</p>
<p>Here's the markup for an equivalent form to our React example.</p>

<p>In many ways this is similar to React, except we're using Blazor's <code>InputText</code> component for our input fields.</p>
<p>Technically it's entirely possible to use standard HTML elements and forms with Blazor, but using the built-in controls make certain things a lot easier (validation being one, as we'll see in a moment).</p>
<p><code>@bind-Value</code> takes care of both reading the value from a field and updating it when a user types in a new value.</p>
<p>The form itself is based on a model of our choosing (where the form values will live) and we've told it which method to invoke when the form is submitted (and is valid). </p>
<p>Note how we've included a <code>DataAnnotationsValidator</code> and <code>ValidationSummary</code>; these components wire up the form to automatically respect any validation rules we set up on our model.</p>
<p>Here's the rest of the code:</p>

<p>The <code>ContactUsModel</code> class could live anywhere in our project.</p>
<p>We have a <code>FormModel</code> property and <code>HandleValidSubmit</code> method.</p>
<p>When someone fills in the form, if they've met the validation rules (a <code>Name</code> has been entered) then <code>HandleValidSubmit</code> will be invoked.</p>
<p>Otherwise, the <code>ValidationSummary</code> will be used to show which fields have validation errors.</p>
<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-06/blazor-validation.png" alt="Blazor example of form with validation errors" title="Blazor validation example"></p>
<h2 id="routinginreact">Routing in React</h2>
<p>As with forms, React (deliberately) doesn't ship with any built-in routing engine, leaving you free to choose which of various third-party routing options you want to use.</p>
<p>Notable options include "Reach Router" and "React Router."</p>
<h2 id="routinginblazor">Routing in Blazor</h2>
<p>Blazor does include routing and leans on ASP.NET's existing routing engine. If you want to make a component "routable" you can add a directive:</p>

<p>Now any request to <code>http://&lt;your-web-site-here&gt;/GreetMe</code> will render this component.</p>
<p>You can also pass data in via the route, like this:</p>

<p>Now any request to <code>http://&lt;your-web-site-here&gt;/GreetMe/Jon</code> will render a more personalized greeting (well, if your name's Jon according to this example!)</p>
<h2 id="fetchingdatafromanapiusingreact">Fetching Data from an API Using React</h2>
<p>React leaves data fetching to your discretion.</p>
<p>You can use the native <code>fetch</code> API:</p>

<p>Or you can employ one of many third-party libraries, such as "Axios" which offers more features and flexibility.</p>
<p>Typically you'd fetch data using something like React's <code>useEffect</code> hook, then update your component state with the results.</p>

<p>UseEffect hooks are intended to allow your component to handle "side effects", in this case, fetching data.</p>
<p>From here you'd typically use JavaScript's map function to loop over your data and render something for each item.</p>

<h2 id="fetchingdatafromanapiusingblazor">Fetching Data from an API Using Blazor</h2>
<p>With Blazor, you can use <code>HttpClient</code> for all your data-fetching needs!</p>
<p>Under the hood, this defers to the native <code>fetch</code> API, but you can generally just ignore that and use the abstraction.</p>
<p>Here's an example:</p>


<p>Blazor has a useful trick up its sleeve (compared to React, or any other existing frontend framework) when it comes to the interaction between your UI and API.</p>
<p>Because you're writing your web app in C#, you can use the same data models in your frontend and backend (API) code.</p>
<p>Let's say for example you need to retrieve a list of people...</p>
<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-06/shared-models.png" alt="Diagram showing how it works using one shared model between client and API with Blazor" title="Blazor Shared Model Overview"></p>
<p>The <code>Person</code> model lives in a shared class library.</p>
<p>Both your Web API and Blazor Client projects reference this shared library.</p>
<p>Now your API can be strongly typed, returning (and accepting) data using the <code>Person</code> model.</p>
<p>The data is still serialized and sent "over the wire" as JSON data, but your Blazor application can deserialize the JSON data using the exact same <code>Person</code> model that was used to serialize it in the first place.</p>
<p>Now if you make breaking changes to your <code>Person</code> model, you'll immediately see compilation errors if you've introduced any breaking changes which affect either the client or server use of the model.</p>
<h2 id="prosandcons">Pros and Cons</h2>
<p>So all this brings us to the obvious question: which one should you choose?</p>
<p>Well, naturally, this will depend on your own background, skills and preferences. </p>
<p>We've seen how there are a number of similarities between the two, but also a few key differences.</p>
<h3 id="react">React</h3>
<p><strong>React</strong> is generally unopinionated when it comes to the things that aren't its primary focus, like routing, form handling, etc.</p>
<p>This could count as either a pro or a con depending on your perspective.</p>
<p>Also, if you're writing React components, you have little choice but to use JavaScript, and adopt everything that comes along for the ride (the ecosystem, npm, bundling, etc.).</p>
<p>Create React App offers a handy abstraction for some of the thornier details (like webpack), so you can focus on building your application.</p>
<p><strong>React Pros</strong></p>
<ul>
    <li>Well-established and battle-tested component model</li>
    <li>"Create React App" simplifies the JS build process</li>
    <li>"Light Touch" library—no "extras" like routers included (freedom to choose your own path!)</li>
    <li>JSX—keeps the parts of the UI that change together in one place</li>
    <li>Freedom to plug in other JS libraries</li>
    <li>A large existing JS library ecosystem to lean on</li>
    <li>Can be deployed as static files to hosting like Netlify, GitHub Pages, etc.</li>
</ul>
<p><strong>React Cons</strong></p>
<ul>
    <li>JSX (if you don't like it!)</li>
    <li>No built-in router, form handling, etc. (can slow things down as you have to plug the gaps with packages or your own solutions)</li>
    <li>JavaScript (again, if you don't like it)
    <ul>
        <li>You have to use it</li>
        <li>You have to learn it (difficult and time-consuming if you spend most of your time using another language like C#)</li>
    </ul>
    </li>
    <li>The JS "ecosystem" can get complicated (build tools, package managers, compilation for different browsers, etc.)</li>
</ul>
<h3 id="blazor">Blazor</h3>
<p><strong>Blazor</strong> offers a few advantages, especially if you're coming from a C# background.</p>
<p>You can bring your existing C# skills, experience and knowledge to the modern web application party!</p>
<p>You can stick to the ecosystem you already know (NuGet, the <code>dotnet</code> tooling, Visual Studio or VS Code).</p>
<p>Shared models between client and backend API. This is a big deal and makes it much harder to inadvertently break your application.</p>
<p>Routing, form handling and validation are baked in.</p>
<p>You can still call out to JavaScript if you need to.</p>
<p><strong>Blazor Pros</strong></p>
<ul>
    <li>Write modern web apps using C#</li>
    <li>Built-in form handling, validation, routing and data-fetching client</li>
    <li>Ability to bring in third-party code via NuGet packages</li>
    <li>You can use the tools you already know (Visual Studio, VS Code, Rider, etc.)</li>
    <li>Can be deployed as static files</li>
    <li>Shared models significantly reduce the chances of accidentally breaking the client</li>
    <li>You can use the same component model in the browser (using WebAssembly) or on the server (using Blazor Server)</li>
    <li>Support to use the same Blazor component model on windows and for mobile development is coming</li>
</ul>
<p><strong>Blazor Cons</strong></p>
<ul>
    <li>New framework, will take time to bed in and gain adoption</li>
    <li>Sizeable initial download of .NET framework to browser on first load</li>
    <li>Tooling also young and will evolve over time</li>
    <li>Fewer resources available on the internet (tutorials, etc.) compared to React</li>
    <li>Does depend on WebAssembly&nbsp;support in the browser (although this is now widely supported)</li>
    <li>The initial download for the .NET runtime is relatively big</li>
</ul>
<p>One thing to call out here is the initial download time.</p>
<p>When someone accesses your Blazor Wasm app for the first time, their browser will download a version of the .NET framework as well as your application's files.</p>
<p>Once they have these files they don't need to download them again, but it does mean you're likely to see a "loading..." indicator first time round.</p>
<p>The team at Microsoft has done a lot of work to get this initial download size down, but naturally this means Blazor is better suited to some web applications than others. </p>
<p>You probably wouldn't want to use it for things like product landing pages where there's little to no business logic and it's imperative that the page loads as quickly as possible.</p>
<p>But, for any Line of Business apps this initial download is unlikely to pose a major issue.</p>
<h2 id="overtoyou">Over to You!</h2>
<p>So, are you thinking of using Blazor? Is it a contender or your next project, or will you be sticking with React for now?</p>
<p>The choice is yours!</p>
	<hr>
          
                   
   </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>