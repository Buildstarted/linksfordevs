<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Consuming Ethernet frames with the nom crate -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Consuming Ethernet frames with the nom crate</h1>
    <div class="markdown"> <p>Now that we&#x2019;ve found the best way to find the &#x201C;default network interface&#x201D;&#x2026;
what can we do with that interface?</p> <p>Well, listen for network traffic of course!</p> <pre><code class="language-rust">use rawsock::open_best_library;
use std::time::Instant;

fn main() -&gt; Result&lt;(), Error&gt; {
    let lib = open_best_library()?;

    let iface_name = format!(r#&quot;\Device\NPF_{}&quot;#, netinfo::default_nic_guid()?);
    let iface = lib.open_interface(&amp;iface_name)?;

    println!(&quot;Listening for packets...&quot;);

    // doing some low-cost logging over here
    let start = Instant::now();
    iface.loop_infinite_dyn(&amp;mut |packet| {
        println!(
            &quot;{:?} | received {} bytes&quot;,
            start.elapsed(),
            packet.len()
        );
    })?;
    Ok(())
}
</code></pre> <p>Here&#x2019;s a video:</p> <p>And here&#x2019;s some text, for accessibility:</p> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
1.0005401s | received 60 bytes
1.0005401s | received 100 bytes
1.0005401s | received 85 bytes
1.0005401s | received 54 bytes
1.0005401s | received 54 bytes
1.0005401s | received 54 bytes
1.0005401s | received 54 bytes
1.0005401s | received 54 bytes
1.8324313s | received 900 bytes
1.8324313s | received 183 bytes
1.8324313s | received 1392 bytes
1.8324313s | received 1392 bytes
1.8324313s | received 1392 bytes
1.8333986s | received 1392 bytes
(cut)
</code></pre> <p>It.. seems to work? Although it&#x2019;s hard to tell, because I haven&#x2019;t printed the
contents of each packet. And I haven&#x2019;t printed the contents of each packet,
because I don&#x2019;t want to post raw traffic from and to my own computer on the
internet, even if I can&#x2019;t make sense of it right now - somebody might!</p> <h2 id="sniffing-the-dumb-way">Sniffing the dumb way</h2> <p>I can think of a way to make sure it works.</p> <p>Remember in <a href="/blog/2019/making-our-own-ping-2/">Part 2</a> when we discovered that
Windows&#x2019;s <code>ping.exe</code> sent lowercase letters of the alphabet?</p> <p>If the payload for ICMP echo packets isn&#x2019;t compressed (and this seems unlikely),
then we should be able to find it in the packets we&#x2019;re sniffing. Let&#x2019;s give it a go.</p> <p>So we just use <code>.find()</code> and..</p> <pre><code class="language-rust">iface.loop_infinite_dyn(&amp;mut |packet| {
    let now = start.elapsed();

    match packet.find(&quot;abcdefghijkl&quot;) {
        Some(_) =&gt; println!(&quot;{:?} | probably an ICMP packet&quot;, now),
        None =&gt; println!(&quot;{:?} | probably *not* an ICMP packet&quot;, now),
    }
})?;
</code></pre> <pre><code class="language-shell">$ cargo check
    Checking ersatz v0.1.0 (C:\msys64\home\amos\ftl\ersatz)
error[E0599]: no method named `find` found for type `&amp;rawsock::common::packet::BorrowedPacket&lt;&apos;_&gt;` in the current scope
  --&gt; src\main.rs:23:22
   |
23 |         match packet.find(&quot;abcdefghijkl&quot;) {
   |                      ^^^^
</code></pre> <p>Wait, frick, no, <code>&amp;[u8]</code> doesn&#x2019;t have <code>.find</code>. It has <code>contains</code> but that&#x2019;s
just for a single element (a single u8) - which is not helpful here.</p> <p>How do we find if a slice contains another slice?</p> <p>Well, there are certainly smart ways to do it, but for the time being we
can simply use <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.windows">windows iterators</a>.</p> <p><code>haystack.windows(N)</code> gives us an iterator over iterators over all subslices
of length N of <code>haystack</code>. If we call it with <code>N = needle.len()</code>, we can test
all those subslices for equality with needle, and stop whenever we find one
that matches!</p> <p><img src="/img/making-our-own-ping-9/windows-iterators.png" alt></p> <p>Let&#x2019;s make a quick function for that:</p> <pre><code class="language-rust">fn contains(haystack: &amp;[u8], needle: &amp;[u8]) -&gt; bool {
    haystack
        .windows(needle.len())
        .any(|window| window == needle)
}
</code></pre> <p>No, you know what, let&#x2019;s make it generic over <em>any</em> type that can be
thought of as a sequence of bytes:</p> <pre><code class="language-rust">fn contains&lt;H, N&gt;(haystack: H, needle: N) -&gt; bool
where
    H: AsRef&lt;[u8]&gt;,
    N: AsRef&lt;[u8]&gt;,
{
    let (haystack, needle) = (haystack.as_ref(), needle.as_ref());
    haystack
        .windows(needle.len())
        .any(|window| window == needle)
}
</code></pre> <p>And then use it:</p> <pre><code class="language-rust">// in main()

iface.loop_infinite_dyn(&amp;mut |packet| {
    let now = start.elapsed();

    if contains(&amp;packet[..], &quot;abcdefghijkl&quot;) {
        println!(&quot;{:?} | probably an ICMP packet&quot;, now);
    } else {
        println!(&quot;{:?} | probably *not* an ICMP packet&quot;, now);
    }
})?;
</code></pre> <pre><code class="language-raw">$ cargo run --quiet
Listening for packets...
1.0005319s | probably *not* an ICMP packet
1.0005319s | probably *not* an ICMP packet
1.0005319s | probably an ICMP packet
1.0005319s | probably an ICMP packet
1.6498447s | probably an ICMP packet
1.6498447s | probably an ICMP packet
1.6498447s | probably *not* an ICMP packet
2.6507489s | probably *not* an ICMP packet
2.6507489s | probably *not* an ICMP packet
2.6507489s | probably *not* an ICMP packet
2.6507489s | probably *not* an ICMP packet
2.6507489s | probably *not* an ICMP packet
2.6507489s | probably an ICMP packet
2.6507489s | probably an ICMP packet
</code></pre> <p>Wonderful!</p> <blockquote>
<p>Note: I was running <code>ping 8.8.8.8 -t</code> in the background to test this.
Otherwise, it&#x2019;s relatively rare to see ICMP packets pass.
Not extremely rare, just uncommon enough that it got annoying to wait.</p>
</blockquote> <p>For convenience&#x2019;s sake, let&#x2019;s move our &#x201C;process packet&#x201D; function out of
main:</p> <pre><code class="language-rust">use rawsock::BorrowedPacket;
use std::time::{Duration, Instant};

fn main() -&gt; Result&lt;(), Error&gt; {
    let lib = open_best_library()?;

    let iface_name = format!(r#&quot;\Device\NPF_{}&quot;#, netinfo::default_nic_guid()?);
    let iface = lib.open_interface(&amp;iface_name)?;

    println!(&quot;Listening for packets...&quot;);

    let start = Instant::now();
    iface.loop_infinite_dyn(&amp;mut |packet| {
        if !contains(&amp;packet[..], &quot;abcdefghijkl&quot;) {
            // only handle ICMP packets
            return;
        }
        process_packet(start.elapsed(), packet);
    })?;
    Ok(())
}

fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    println!(&quot;{:?} | probably an ICMP packet&quot;, now);
}
</code></pre> <p>Good. Moving on.</p> <p>So we know that <em>somewhere in there</em>, there&#x2019;s <em>probably</em> some ICMP packets.
But what it is exactly we&#x2019;re getting? Ethernet frames? IP packets? It could
be either, depending on the library
<a href="https://crates.io/crates/rawsock">rawsock</a> is using under the hood.</p> <p>If it is an Ethernet frame, then it should have the following structure:</p> <p><img src="/img/making-our-own-ping-9/ethernet-frame-structure.png" alt></p> <p>And the EtherType for IPv4 is <code>0x0800</code>. So if we read a 16-bit
integer at position 12, we should be good?</p> <p>But how do we get a u16 from a <code>&amp;[u8]</code>? Well, by now, we know an unsafe
way to do it:</p> <pre><code class="language-rust">fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    let ether_type: u16 = unsafe {
        let u16_ptr: *const u16 = transmute(&amp;packet[12]);
        *u16_ptr
    };
    println!(&quot;{:?} | ether_type = 0x{:04x}&quot;, now, ether_type);
}
</code></pre> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
6.1546872s | ether_type = 0x0008
6.1547236s | ether_type = 0x0008
6.6612632s | ether_type = 0x0008
6.6613005s | ether_type = 0x0008
7.3471202s | ether_type = 0x0008
7.3471402s | ether_type = 0x0008

</code></pre> <p>Huh. That&#x2019;s <code>0x0008</code>, not <code>0x0800</code>. Still, pretty close though. Looks like two bytes
were just swapped?</p> <p>Remember in <a href="/blog/2019/reading-files-the-hard-way-3/">Reading files the hard way - Part 3</a>,
when we used the <a href="https://crates.io/crates/byteorder">byteorder</a> crate?</p> <p>Well, same. It just so happens that my processor (an Intel i7) is little-endian, but
Ethernet is big-endian, so we can&#x2019;t <em>just</em> transmute things at will and expect it to
work.</p> <p><img src="/img/making-our-own-ping-9/be-le.png" alt></p> <p>We <em>can</em> do it by hand:</p> <pre><code class="language-rust">fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    let (a, b) = (packet[12], packet[13]);
    let (a, b) = (a as u16, b as u16);

    let ether_type = (a &lt;&lt; 8) + b;
    println!(&quot;{:?} | ether_type = 0x{:04x}&quot;, now, ether_type);
}
</code></pre> <p>And it&#x2019;d work:</p> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
1.0068664s | ether_type = 0x0800
1.0069143s | ether_type = 0x0800
2.0119471s | ether_type = 0x0800
3.0154707s | ether_type = 0x0800
3.0154912s | ether_type = 0x0800
</code></pre> <p>But this would only work <em>on little-endian processors</em>. On big-endian
processors, we&#x2019;d be shifting bytes around unnecessarily (and incorrectly).</p> <p>Plus, writing this by hand is kinda error-prone. I&#x2019;m not ashamed to admit
that I - your humble servant - <em>frequently</em> get bit-twiddling wrong.</p> <p>I&#x2019;m also not ashamed to admit that I prefer portable, declarative(-ish) code.</p> <p>Luckily, here we don&#x2019;t even have to bring the <code>byteorder</code> crate in (we&#x2019;re
watching our <code>Cargo.toml</code> size and compile times, remember?). The Rust
standard library contains everything we need.</p> <p>Unluckily, it wants a fixed-size array, ie. <code>[u8; 2]</code>, not a slice, ie.
<code>&amp;[u8]</code> - which we have.</p> <p>But look on the bright side! Unsafe no more:</p> <pre><code class="language-rust">fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    let ether_type = {
        let mut ether_type = [0u8; 2];
        ether_type.copy_from_slice(&amp;packet[12..14]);
        // &quot;be&quot; stands for &quot;big endian&quot;
        u16::from_be_bytes(ether_type)
    };
    println!(&quot;{:?} | ether_type = 0x{:04x}&quot;, now, ether_type);
}
</code></pre> <div class="tip"> <p>You may be wondering - does <code>copy_from_slice</code> really need to be passed
<code>&amp;packet[12..14]</code>?</p> <p>Would just <code>&amp;packet[12..]</code> suffice?</p> <p>It would not. It would panic.</p> <p>This also explains why <code>copy_from_slice</code> does not return a Result. It just
panics. Just like trying to subslice with invalid indices will also panic.</p> </div> <p>Does this work?</p> <pre><code class="language-raw">$ cargo run --quiet
Listening for packets...
1.0005347s | ether_type = 0x0800
1.0005645s | ether_type = 0x0800
2.0012903s | ether_type = 0x0800
2.0013114s | ether_type = 0x0800
3.0014023s | ether_type = 0x0800
3.0014241s | ether_type = 0x0800
</code></pre> <p>Yeah! Seems okay. We don&#x2019;t know <em>yet</em> if they&#x2019;re actually ICMP packets, but at least,
it looks like we&#x2019;re getting Ethernet frames that contain IPv4 packets. Either that, or
many coincidences are happening in a row (which is always a possibility, because computers).</p> <h2 id="two-macs-in-a-rowboat">Two MACs in a rowboat</h2> <p>How about we check that the MAC addresses look reasonable? We know MAC
addresses look something like <code>12:34:56:78:9A:BC</code>, so, let&#x2019;s make a quick struct.</p> <p>This is not the last we&#x2019;ve seen of Ethernet, so, let&#x2019;s make an <code>ethernet</code> module.</p> <pre><code class="language-rust">// in `src/main.rs`

mod ethernet;
</code></pre> <pre><code class="language-rust">// in `src/ethernet.rs`

use std::fmt;

#[derive(PartialEq, Eq, Clone, Copy)]
pub struct Addr([u8; 6]);

impl fmt::Display for Addr {
    fn fmt(&amp;self, w: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let [a, b, c, d, e, f] = self.0;
        write!(
            w,
            &quot;{:02X}-{:02X}-{:02X}-{:02X}-{:02X}-{:02X}&quot;,
            a, b, c, d, e, f
        )
    }
}

impl fmt::Debug for Addr {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        fmt::Display::fmt(self, f)
    }
}
</code></pre> <div class="tip"> <p>MAC addresses are sometimes formatted as &#x201C;12:34:45:67:89:AB&#x201D;, but <a href="https://standards.ieee.org/content/dam/ieee-standards/standards/web/documents/tutorials/macgrp.pdf">according
to some IEEE
document</a>,
the &#x201C;12-34-45-67-89-AB&#x201D; form is preferred, so that&#x2019;s what we&#x2019;ll use.</p> <p>It&#x2019;s also the format used in <code>ipconfig /all</code>&#x2019;s output on Windows 10 at least.</p> <p>As a bonus, the hyphen-separated format doesn&#x2019;t look anything like IPv6
addresses. No confusion!</p> </div> <p>Let&#x2019;s also make a convenience method to &#x201C;build&#x201D; a MacAddress from a slice:</p> <pre><code class="language-rust">// in `src/ethernet.rs`

impl Addr {
    pub fn new(slice: &amp;[u8]) -&gt; Self {
        let mut res = Self([0u8; 6]);
        // note: this will panic if the slice is too small!
        res.0.copy_from_slice(&amp;slice[..6]);
        res
    }
}
</code></pre> <p>Then, for readability, let&#x2019;s define a <code>read_u16</code> function, which will read
a big-endian 16-bit integer from a slice.</p> <p>All together, we get:</p> <pre><code class="language-rust">fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    let read_u16 = |slice: &amp;[u8]| {
        let mut res = [0u8; 2];
        res.copy_from_slice(&amp;slice[..2]);
        u16::from_be_bytes(res)
    };

    let dst = ethernet::Addr::new(&amp;packet[0..]);
    let src = ethernet::Addr::new(&amp;packet[6..]);
    let ether_type = read_u16(&amp;packet[12..]);
    println!(
        &quot;{:?} | dst {} | src {} | typ 0x{:04x}&quot;,
        now, dst, src, ether_type
    );
}
</code></pre> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
404.8053ms | dst 14-0C-76-6A-71-BD | src F4-D1-08-0B-7E-BC | typ 0x0800
404.8525ms | dst F4-D1-08-0B-7E-BC | src 14-0C-76-6A-71-BD | typ 0x0800
1.4515468s | dst 14-0C-76-6A-71-BD | src F4-D1-08-0B-7E-BC | typ 0x0800
1.4515697s | dst F4-D1-08-0B-7E-BC | src 14-0C-76-6A-71-BD | typ 0x0800
2.8507864s | dst 14-0C-76-6A-71-BD | src F4-D1-08-0B-7E-BC | typ 0x0800
2.8508097s | dst F4-D1-08-0B-7E-BC | src 14-0C-76-6A-71-BD | typ 0x0800
3.6322431s | dst 14-0C-76-6A-71-BD | src F4-D1-08-0B-7E-BC | typ 0x0800
3.6322665s | dst F4-D1-08-0B-7E-BC | src 14-0C-76-6A-71-BD | typ 0x0800
</code></pre> <p>This looks good!</p> <p>We can immediately see that there&#x2019;s pairs of packets, from <code>F4-D1...</code>
to <code>14-0C...</code>, and back. Probably echo requests and responses!</p> <p>Do those look legit? Remember that blocks of MAC addresses are assigned
to network hardware vendors, so we can simply look those up in <a href="https://dnschecker.org/mac-lookup.php">an online
database</a>, and we find that:</p> <ul>
<li><code>F4-D1-08-0B-7E-BC</code> is manufactured by &#x201C;Intel Corporate&#x201D;</li>
<li><code>14-0C-76-6A-71-BD</code> is manufactured by &#x201C;FREEBOX SAS&#x201D;</li>
</ul> <p>Which would definitely match my Wi-Fi adapter and my ISP&#x2019;s box.</p> <h2 id="code-review-debugging-interlude">Code review + debugging interlude</h2> <p>So we&#x2019;ve parsed a little bit of Ethernet.</p> <p>Should we be happy? Yes!</p> <p>Should we be content! No!</p> <p>Our parsing code right now is very imperative, and it&#x2019;s not immediately
obvious what&#x2019;s going on.</p> <p>Here it is again with annotations:</p> <pre><code class="language-rust">// FIXME: why is this a closure? seems generally useful,
// it should be somewhere else.
let read_u16 = |slice: &amp;[u8]| {
    // TODO: are we sure this optimizes nicely?
    // or does it to unnecessarily allocations left and right?
    let mut res = [0u8; 2];
    res.copy_from_slice(&amp;slice[..2]);
    u16::from_be_bytes(res)
};

let dst = ethernet::Addr::new(&amp;packet[0..]);
// TODO: are we sure that `dst` is 6 bytes?
// or is it 4 bytes and we&apos;re skipping 2 bytes here?

let src = ethernet::Addr::new(&amp;packet[6..]);
// TODO: same questions

let ether_type = read_u16(&amp;packet[12..]);
// TODO: check if `read_u16` takes a slice of any length &gt;= 2,
// or only slices of length 2 exactly.
</code></pre> <p>And for that, we&#x2019;re going to want a few crates.</p> <p>But first, a diversion: <em>does</em> <code>from_be_bytes</code> optimize nicely?</p> <p>Let&#x2019;s build a sample program:</p> <pre><code class="language-shell">$ mkdir wat
$ cargo init
</code></pre> <pre><code>// in `wat/src/main.rs`

#[inline(never)]
pub extern &quot;C&quot; fn read_u16(slice: &amp;[u8]) -&gt; u16 {
    let mut res = [0u8; 2];
    res.copy_from_slice(&amp;slice[..2]);
    u16::from_be_bytes(res)
}

fn main() {
    println!(&quot;{}&quot;, read_u16(&amp;[0x12, 0x34]));
    println!(&quot;{}&quot;, read_u16(&amp;[0x56, 0x78]));
}
</code></pre> <p>Let&#x2019;s include debug symbols, because we want a release build here:</p> <pre><code class="language-toml"># at the end of `wat/Cargo.toml`

[profile.release]
debug = true
</code></pre> <pre><code class="language-shell">$ cargo build --release
   Compiling wat v0.1.0 (C:\msys64\home\amos\ftl\wat)
    Finished release [optimized + debuginfo] target(s) in 0.30s
</code></pre> <p>We&#x2019;ll use <a href="https://x64dbg.com/">x64dbg</a> to find out. We can just open up the
<code>wat\target\release</code> directory in explorer and drag our <code>.exe</code> into the
x64dbg window.</p> <p><img src="/img/making-our-own-ping-9/dbg-initial.png" alt></p> <p>To find our function, we can use the &#x201C;Symbols&#x201D; tab:</p> <p><img src="/img/making-our-own-ping-9/dbg-find-symbol.png" alt></p> <p>Double-clicking on the symbol brings us to its disassembly:</p> <p><img src="/img/making-our-own-ping-9/dbg-disasm.png" alt></p> <p>Yeah that&#x2019;s uhh pretty short.</p> <pre><code class="language-x86asm">movzx       eax, word ptr ds:[rcx]
rol         ax, 8
ret
</code></pre> <p>Let&#x2019;s set a breakpoint and start debugging:</p> <p><img src="/img/making-our-own-ping-9/dbg-break-and-run.png" alt></p> <p>Here we are at the very start of <code>read_u16</code>:</p> <p><img src="/img/making-our-own-ping-9/dbg-before-movzx.png" alt></p> <p>There&#x2019;s only one argument passed to <code>read_u16</code>, and it&#x2019;s a slice.
It appears the address of the slice&#x2019;s contents are passed through
the <code>RCX</code> register, which <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions">seems correct on Microsoft x64</a>.</p> <pre><code class="language-x86asm">movzx       eax, word ptr ds:[rcx]
</code></pre> <p>We&#x2019;re reading a word (two bytes, 16 bits) from memory, starting from
the address contained in the <code>RCX</code> register. We&#x2019;re also zero-extending
(that&#x2019;s the <code>zx</code> in <code>movzx</code>), so that the rest of <code>EAX</code> contains zeroes.</p> <p>Which, after <code>movzx</code>, it does!</p> <p><img src="/img/making-our-own-ping-9/dbg-before-rol.png" alt></p> <p>All that&#x2019;s left is to rotate the <code>AX</code> register (16-bit wide) left 8 bits and&#x2026;</p> <pre><code class="language-x86asm">rol         ax, 8
</code></pre> <p>wait.. just rotate left? Does it wrap around?</p> <p><img src="/img/making-our-own-ping-9/dbg-before-ret.png" alt></p> <p>Yeah! Apparently it does.</p> <p>We now have the u16 we want in <code>RAX</code>, and, what a coincidence, that&#x2019;s also
the register used to return integers in the Microsoft x64 calling convention.</p> <p>So, to answer our question, <strong>yes</strong>, <code>u16::from_be_bytes</code> (and even <code>copy_from_slice</code>)
optimize <em>really well</em>.</p> <h2 id="back-to-our-regularly-scheduled-parsing">Back to our regularly-scheduled parsing</h2> <p>Before we took a detour through x64dbg-land, I said I wanted our parsing to be more
declarative.</p> <p>First off, I want an <code>ethernet::Frame</code> structure.</p> <pre><code class="language-rust">// in `src/ethernet.rs`

use custom_debug_derive::*;

#[derive(CustomDebug)]
pub struct Frame {
    pub dst: Addr,
    pub src: Addr,

    #[debug(format = &quot;0x{:04x}&quot;)]
    pub ether_type: u16,
}
</code></pre> <p>Second, I want it to have a <code>parse</code> method:</p> <pre><code class="language-rust">// still in `src/ethernet.rs`

impl Frame {
    pub fn parse(i: &amp;[u8]) -&gt; Self {
        let read_u16 = |slice: &amp;[u8]| {
            let mut res = [0u8; 2];
            res.copy_from_slice(&amp;slice[..2]);
            u16::from_be_bytes(res)
        };

        Self {
            dst: Addr::new(&amp;i[0..]),
            src: Addr::new(&amp;i[6..]),
            ether_type: read_u16(&amp;i[12..]),
        }
    }
}
</code></pre> <p>Our <code>process_packet</code> function now becomes:</p> <pre><code class="language-rust">// in `src/main.rs`

fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    let frame = ethernet::Frame::parse(packet);
    println!(&quot;{:?} | {:?}&quot;, now, frame);
}
</code></pre> <p>Does it still work? Why wouldn&#x2019;t it!</p> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
1.0004896s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
1.0005298s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
2.0009547s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
2.0009996s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
</code></pre> <p>But still our code is very imperative.</p> <p>We&#x2019;re going to use one of my all-time favorite crates: <a href="https://crates.io/crates/nom">nom</a>.</p> <div class="tip"> <p>The <code>nom</code> crate has changed a lot over the course of its life.</p> <p>We&#x2019;ll be using version 5, which I hear is significantly better than the
previous releases.</p> <p>In particular, nom 5 is based on <code>impl Fn</code> rather than macros, making the
code easier to read and write, and even giving a performance boost!</p> </div> <pre><code class="language-rust">$ cargo add nom
      Adding nom v5.0.1 to dependencies
</code></pre> <p><code>nom</code> is a <em>parser combinators</em> library, which means we&#x2019;ll get to.. combine..
parsers.</p> <p>A parser is just a function that takes an input, and returns a result.</p> <p>If we look for <code>be_u16</code> in nom&#x2019;s documentation we&#x2019;ll find two variants:
one in <code>nom::number::complete</code> and one in <code>nom::number::streaming</code>. We&#x2019;re
only interested in the former, as we have complete Ethernet frames available.</p> <p>Its signature is as follows:</p> <pre><code class="language-rust">pub fn be_u16&lt;&apos;a, E: ParseError&lt;&amp;&apos;a[u8]&gt;&gt;(i: &amp;&apos;a[u8]) -&gt; IResult&lt;&amp;&apos;a[u8], u16, E&gt; {
    // (cut)
}
</code></pre> <p>We immediately notice <code>IResult</code>, which is a <code>nom</code> type. Why not just use <code>Result</code> ?</p> <p>Because parsers consume part of the input. So in case of success, they&#x2019;d
typically return a tuple: <code>(remaining_input, parsed)</code>.</p> <p>Can we use it to replace our <code>read_u16</code> ? Let&#x2019;s see.</p> <pre><code class="language-rust">use nom::number::complete::be_u16;

impl Frame {
    pub fn parse(i: &amp;[u8]) -&gt; Self {
        let (_, ether_type) = be_u16::&lt;()&gt;(&amp;i[12..]).unwrap();

        Self {
            dst: Addr::new(&amp;i[0..]),
            src: Addr::new(&amp;i[6..]),
            ether_type,
        }
    }
}
</code></pre> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
999.8623ms | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
999.8913ms | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
2.000622s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
2.0006446s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
3.0006469s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
3.0006706s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
</code></pre> <p>Yeah! Seems to work!</p> <p>Although we&#x2019;ve been very naughty:</p> <ul>
<li>We&#x2019;ve completely ignored errors (by specifying <code>E=()</code>, and using <code>.unwrap()</code>)</li>
<li>We&#x2019;re.. not actually combining parsers</li>
</ul> <p>If we want to combine parsers, we&#x2019;ll need to make a parser for <code>Addr</code>.</p> <p>We can do that as an associated method:</p> <pre><code class="language-rust">// in `src/ethernet.rs`

use nom::{bytes::complete::take, combinator::map, error::ParseError, IResult};

impl Addr {
    pub fn parse&lt;&apos;a, E&gt;(i: &amp;&apos;a [u8]) -&gt; IResult&lt;&amp;&apos;a [u8], Self, E&gt;
    where
        E: ParseError&lt;&amp;&apos;a [u8]&gt;,
    {
        map(take(6_usize), Self::new)(i)
    }
}
</code></pre> <p>Whoa, that&#x2019;s a lot of use directives. Get used to those!</p> <p>Let&#x2019;s walk through these:</p> <ul>
<li><code>Addr::parse</code> is a parser - it takes an input and returns an <code>IResult&lt;I, O, E&gt;</code></li>
<li><code>take(N)</code> returns a parser - that takes 6 bytes and returns them as a slice</li>
<li><code>map(P, F)</code> runs the parser <code>P</code> and, if successful, runs its output through <code>F</code> before returning <ul>
<li>In our case, we transform a <code>&amp;[u8]</code> into an <code>ethernet::Addr</code></li>
</ul></li>
</ul> <p>Here&#x2019;s another way to write the same thing:</p> <pre><code class="language-rust">// in `src/ethernet.rs`

use nom::{combinator::map, error::ParseError, number::complete::be_u8, sequence::tuple, IResult};
// note: `be_u8` and `le_u8` are the same thing, they&apos;re just here for
// completeness. There&apos;s no such thing as a &quot;big-endian byte&quot;, but it
// looks nicer that way.

impl Addr {
    pub fn parse&lt;&apos;a, E&gt;(i: &amp;&apos;a [u8]) -&gt; IResult&lt;&amp;&apos;a [u8], Self, E&gt;
    where
        E: ParseError&lt;&amp;&apos;a [u8]&gt;,
    {
        // note: tuple((a, b, c)) returns an IResult&lt;I, (A, B, C), E&gt;

        map(
            tuple((be_u8, be_u8, be_u8, be_u8, be_u8, be_u8)),
            |(a, b, c, d, e, f)| Self([a, b, c, d, e, f]),
        )(i)
    }
}
</code></pre> <p>&#x2026;but I like the first version better.</p> <p>How do we use our new parser?</p> <p>Well, we can keep being naughty:</p> <pre><code class="language-rust">impl Frame {
    pub fn parse(i: &amp;[u8]) -&gt; Self {
        let (_, dst) = Addr::parse::&lt;()&gt;(&amp;i[0..]).unwrap();
        let (_, src) = Addr::parse::&lt;()&gt;(&amp;i[6..]).unwrap();
        let (_, ether_type) = be_u16::&lt;()&gt;(&amp;i[12..]).unwrap();

        Self {
            dst,
            src,
            ether_type,
        }
    }
}
</code></pre> <p>This sure still works:</p> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
999.5699ms | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
999.5999ms | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
1.9995319s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
1.9995561s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
2.3363625s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
2.3364035s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
</code></pre> <p>&#x2026;but, again, this completely defeats the purpose of <code>nom</code>. What we want is
to <em>combine</em> those, like that:</p> <pre><code class="language-rust">use nom::{number::complete::be_u16, sequence::tuple};

impl Frame {
    pub fn parse&lt;&apos;a, E&gt;(i: &amp;&apos;a [u8]) -&gt; IResult&lt;&amp;&apos;a [u8], Self, E&gt;
    where
        E: ParseError&lt;&amp;&apos;a [u8]&gt;,
    {
        map(
            tuple((Addr::parse, Addr::parse, be_u16)),
            |(dst, src, ether_type)| Self {
                dst,
                src,
                ether_type,
            },
        )(i)
    }
}
</code></pre> <p>Nowwww we&#x2019;re getting somewhere.</p> <p>But I&#x2019;m getting tired of typing those <code>&apos;a</code> and <code>where E: ParseError</code> by hand.</p> <p>How about we make a <code>parse</code> module that has some types for us.</p> <pre><code class="language-rust">// in `src/main.rs`

mod parse;
</code></pre> <pre><code class="language-rust">// in `src/parse.rs`

pub type Input&lt;&apos;a&gt; = &amp;&apos;a [u8];
pub type Result&lt;&apos;a, T&gt; = nom::IResult&lt;Input&lt;&apos;a&gt;, T, ()&gt;;
</code></pre> <pre><code class="language-rust">// in `src/ethernet.rs`

impl Addr {
    pub fn parse(i: parse::Input) -&gt; parse::Result&lt;Self&gt; {
        map(take(6_usize), Self::new)(i)
    }
}

impl Frame {
    pub fn parse(i: parse::Input) -&gt; parse::Result&lt;Self&gt; {
        map(
            tuple((Addr::parse, Addr::parse, be_u16)),
            |(dst, src, ether_type)| Self {
                dst,
                src,
                ether_type,
            },
        )(i)
    }
}
</code></pre> <p>Ahhh. Much better.</p> <p>Of course, we need to change our <code>process_packet</code> function a bit, to account
for error handling:</p> <pre><code class="language-rust">fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    match ethernet::Frame::parse(packet) {
        Ok((_remaining, frame)) =&gt; {
            println!(&quot;{:?} | {:?}&quot;, now, frame);
        }
        Err(e) =&gt; {
            println!(&quot;{:?} | could not parse ethernet frame: {:?}&quot;, now, e);
        }
    }
}
</code></pre> <p>And our sample program - still doing the same thing - works again.</p> <p>But speaking of errors, what happens if we call <code>ethernet::Frame::parse</code> with
invalid input? Say, an incomplete frame?</p> <pre><code class="language-rust">fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    let incomplete_packet = &amp;packet[..2];

    match ethernet::Frame::parse(incomplete_packet) {
        // (cut)
    }
}
</code></pre> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
999.9702ms | could not parse ethernet frame: Error(())
999.9991ms | could not parse ethernet frame: Error(())
2.0000975s | could not parse ethernet frame: Error(())
2.0001199s | could not parse ethernet frame: Error(())
</code></pre> <p>Oh right. We chose the empty tuple, <code>()</code>, as our error type.</p> <p>Let&#x2019;s fix that.</p> <pre><code class="language-rust">// in `src/parse.rs`

use nom::error::ErrorKind as NomErrorKind;

pub type Input&lt;&apos;a&gt; = &amp;&apos;a [u8];
pub type Result&lt;&apos;a, T&gt; = nom::IResult&lt;Input&lt;&apos;a&gt;, T, (Input&lt;&apos;a&gt;, NomErrorKind)&gt;;
</code></pre> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
644.1433ms | could not parse ethernet frame: Error(([20, 12], Eof))
644.1723ms | could not parse ethernet frame: Error(([244, 209], Eof))
1.6446712s | could not parse ethernet frame: Error(([20, 12], Eof))
1.6446948s | could not parse ethernet frame: Error(([244, 209], Eof))
</code></pre> <p>It&#x2019;s something! <code>nom::error::ParseError</code> is implemented for <code>(I, nom::error::ErrorKind)</code>.</p> <p>What if we want something a little more.. custom?</p> <pre><code class="language-rust">// in `src/parse.rs`

use nom::error::ErrorKind as NomErrorKind;

pub type Input&lt;&apos;a&gt; = &amp;&apos;a [u8];
pub type Result&lt;&apos;a, T&gt; = nom::IResult&lt;Input&lt;&apos;a&gt;, T, Error&lt;Input&lt;&apos;a&gt;&gt;&gt;;

#[derive(Debug)]
pub struct Error&lt;I&gt; {
    pub errors: Vec&lt;(I, NomErrorKind)&gt;,
}
</code></pre> <pre><code class="language-shell">$ cargo check --quiet
error[E0277]: the trait bound `parse::Error&lt;&amp;[u8]&gt;: nom::error::ParseError&lt;&amp;[u8]&gt;` is not satisfied
  --&gt; src\ethernet.rs:37:9
   |
37 |         map(take(6_usize), Self::new)(i)
   |         ^^^ the trait `nom::error::ParseError&lt;&amp;[u8]&gt;` is not implemented for `parse::Error&lt;&amp;[u8]&gt;`
   |
   = note: required by `nom::combinator::map`

(many more errors omitted)
</code></pre> <p>Oh right, we need to actually implement that trait.</p> <p>I wouldn&#x2019;t put you - the reader - through all of that if it wasn&#x2019;t going
to come in handy later. In the meantime, just consider it a leisurely walk
through some of nom&#x2019;s internals.</p> <pre><code class="language-rust">// in `src/parse.rs`

use nom::error::{ErrorKind as NomErrorKind, ParseError as NomParseError};

pub type Input&lt;&apos;a&gt; = &amp;&apos;a [u8];
pub type Result&lt;&apos;a, T&gt; = nom::IResult&lt;Input&lt;&apos;a&gt;, T, Error&lt;Input&lt;&apos;a&gt;&gt;&gt;;

#[derive(Debug)]
pub struct Error&lt;I&gt; {
    pub errors: Vec&lt;(I, NomErrorKind)&gt;,
}

impl&lt;I&gt; NomParseError&lt;I&gt; for Error&lt;I&gt; {
    fn from_error_kind(input: I, kind: NomErrorKind) -&gt; Self {
        let errors = vec![(input, kind)];
        Self { errors }
    }

    fn append(input: I, kind: NomErrorKind, mut other: Self) -&gt; Self {
        other.errors.push((input, kind));
        other
    }
}
</code></pre> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
999.5487ms | could not parse ethernet frame: Error(Error { errors: [([20, 12], Eof)] })
999.5803ms | could not parse ethernet frame: Error(Error { errors: [([244, 209], Eof)] })
2.0000408s | could not parse ethernet frame: Error(Error { errors: [([20, 12], Eof)] })
2.0001096s | could not parse ethernet frame: Error(Error { errors: [([244, 209], Eof)] })
</code></pre> <p>Cool!</p> <p>You may have noticed our <code>parse::Error</code> type actually holds a <code>Vec</code> of errors.</p> <p>Why is this important? So we can have multiple errors of course.</p> <p>The <code>context</code> combinator allows us to add some, well, context, to our errors.
In other words it allows us to attach to our errors information about what it is
we were trying to parse.</p> <p>Let&#x2019;s use it now:</p> <pre><code>// in `src/ethernet.rs`

use nom::{
    bytes::complete::take, combinator::map, error::context, number::complete::be_u16,
    sequence::tuple,
};

impl Addr {
    pub fn parse(i: parse::Input) -&gt; parse::Result&lt;Self&gt; {
        context(&quot;MAC address&quot;, map(take(6_usize), Self::new))(i)
    }
}

impl Frame {
    pub fn parse(i: parse::Input) -&gt; parse::Result&lt;Self&gt; {
        context(
            &quot;Ethernet frame&quot;,
            map(
                tuple((Addr::parse, Addr::parse, context(&quot;EtherType&quot;, be_u16))),
                |(dst, src, ether_type)| Self {
                    dst,
                    src,
                    ether_type,
                },
            ),
        )(i)
    }
}
</code></pre> <p>Huh, this doesn&#x2019;t change the output at all. Let&#x2019;s look at the implementation
of the <code>context</code> combinator:</p> <pre><code class="language-rust">/// create a new error from an input position, a static string and an existing error.
/// This is used mainly in the [context] combinator, to add user friendly information
/// to errors when backtracking through a parse tree
#[cfg(feature = &quot;alloc&quot;)]
pub fn context&lt;I: Clone, E: ParseError&lt;I&gt;, F, O&gt;(context: &amp;&apos;static str, f: F) -&gt; impl Fn(I) -&gt; IResult&lt;I, O, E&gt;
where
    F: Fn(I) -&gt; IResult&lt;I, O, E&gt; {

    move |i: I| {
        match f(i.clone()) {
            Ok(o) =&gt; Ok(o),
            Err(Err::Incomplete(i)) =&gt; Err(Err::Incomplete(i)),
            Err(Err::Error(e)) =&gt; Err(Err::Error(E::add_context(i, context, e))),
            Err(Err::Failure(e)) =&gt; Err(Err::Failure(E::add_context(i, context, e))),
        }
    }
}
</code></pre> <p>Okay.. looks like it calls <code>add_context</code> on our <code>Error</code> type. I don&#x2019;t remember
implementing that, do you? Maybe there&#x2019;s a default implementation in the <code>ParseError</code>
trait..</p> <pre><code class="language-rust">pub trait ParseError&lt;I&gt;: Sized {
    // (cut: other fns)

    /// create a new error from an input position, a static string and an existing error.
    /// This is used mainly in the [context] combinator, to add user friendly information
    /// to errors when backtracking through a parse tree
    fn add_context(_input: I, _ctx: &amp;&apos;static str, other: Self) -&gt; Self {
        other
    }
}
</code></pre> <p>Oh. It&#x2019;s just throwing the context away.</p> <p>We&#x2019;re going to need an enum. <code>NomErrorKind</code> is already an enum, but none of the variants
take a string, they&#x2019;re just simple cases like so:</p> <pre><code class="language-rust">pub enum ErrorKind {
  Tag,
  MapRes,
  MapOpt,
  Alt,
  IsNot,
  // etc.
}
</code></pre> <p>So let&#x2019;s make our <em>own</em> ErrorKind:</p> <pre><code class="language-rust">#[derive(Debug)]
pub enum ErrorKind {
    // ooh that&apos;s why `nom::error::ErrorKind` was aliased to `NomErrorKind`:)
    Nom(NomErrorKind),
    Context(&amp;&apos;static str),
}

#[derive(Debug)]
pub struct Error&lt;I&gt; {
    // was NomErrorKind, now ErrorKind
    pub errors: Vec&lt;(I, ErrorKind)&gt;,
}

impl&lt;I&gt; NomParseError&lt;I&gt; for Error&lt;I&gt; {
    fn from_error_kind(input: I, kind: NomErrorKind) -&gt; Self {
        // was (input, kind)
        let errors = vec![(input, ErrorKind::Nom(kind))];
        Self { errors }
    }

    fn append(input: I, kind: NomErrorKind, mut other: Self) -&gt; Self {
        // was (input, kind)
        other.errors.push((input, ErrorKind::Nom(kind)));
        other
    }

    // new!
    fn add_context(input: I, ctx: &amp;&apos;static str, mut other: Self) -&gt; Self {
        other.errors.push((input, ErrorKind::Context(ctx)));
        other
    }
}
</code></pre> <p>Now we can see <em>exactly</em> where parsing failed:</p> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
1.0001186s | Error(Error { errors: [([20, 12], Nom(Eof)), ([20, 12], Context(&quot;MAC address&quot;)), ([20, 12], Context(&quot;Ethernet frame&quot;))] })
1.0001786s | Error(Error { errors: [([244, 209], Nom(Eof)), ([244, 209], Context(&quot;MAC address&quot;)), ([244, 209], Context(&quot;Ethernet frame&quot;))] })
2.0002709s | Error(Error { errors: [([20, 12], Nom(Eof)), ([20, 12], Context(&quot;MAC address&quot;)), ([20, 12], Context(&quot;Ethernet frame&quot;))] })
2.0003059s | Error(Error { errors: [([244, 209], Nom(Eof)), ([244, 209], Context(&quot;MAC address&quot;)), ([244, 209], Context(&quot;Ethernet frame&quot;))] })
</code></pre> <p>Although.. I&#x2019;m not in love with that error format.</p> <p>How about we prettify it a little bit?</p> <pre><code class="language-shell">$ cargo add hex_slice
WARN: Added `hex-slice` instead of `hex_slice`
      Adding hex-slice v0.1.4 to dependencies

$ echo &quot;thanks cargo-edit, I promise not to typo it again&quot;
</code></pre> <pre><code class="language-rust">// in `src/parse.rs`

use std::fmt;

impl&lt;&apos;a&gt; fmt::Debug for Error&lt;&amp;&apos;a [u8]&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;/!\\ ersatz parsing error\n&quot;)?;
        for (input, kind) in self.errors.iter().rev() {
            let prefix = match kind {
                ErrorKind::Context(ctx) =&gt; format!(&quot;...in {}&quot;, ctx),
                ErrorKind::Nom(err) =&gt; format!(&quot;nom error {:?}&quot;, err),
            };

            let maxlen = 40;
            let input = if input.len() &gt; maxlen {
                &amp;input[input.len() - maxlen..]
            } else {
                input
            };

            use hex_slice::AsHex;
            write!(f, &quot;{:&lt;30} {:x}\n&quot;, prefix, input.as_hex())?;
        }
        Ok(())
    }
}
</code></pre> <p>We&#x2019;re also going to adjust our <code>process_packet()</code> function a bit - by
matching the error more precisely.</p> <p>As long as we never use the <code>cut</code> combinator, and never use any streaming
parsers, we should only ever get <code>nom::Err::Error</code>, never <code>nom::Err::Failure</code>
(from <code>cut</code>) or <code>nom::Err::Incomplete</code> (from streaming parsers).</p> <p>This will make the output even cleaner:</p> <pre><code class="language-rust">fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    let incomplete_packet = &amp;packet[..2];

    match ethernet::Frame::parse(incomplete_packet) {
        Ok((_remaining, frame)) =&gt; {
            println!(&quot;{:?} | {:?}&quot;, now, frame);
        }
        Err(nom::Err::Error(e)) =&gt; {
            println!(&quot;{:?} | {:?}&quot;, now, e);
        }
        // this will crash *loudly* if our assumptions were wrong
        _ =&gt; unreachable!(),
    }
}
</code></pre> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
303.8231ms | /!\ ersatz parsing error
...in Ethernet frame           [14 c]
...in MAC address              [14 c]
nom error Eof                  [14 c]

303.8853ms | /!\ ersatz parsing error
...in Ethernet frame           [f4 d1]
...in MAC address              [f4 d1]
nom error Eof                  [f4 d1]

1.3050234s | /!\ ersatz parsing error
...in Ethernet frame           [14 c]
...in MAC address              [14 c]
nom error Eof                  [14 c]

1.3050716s | /!\ ersatz parsing error
...in Ethernet frame           [f4 d1]
...in MAC address              [f4 d1]
nom error Eof                  [f4 d1]
</code></pre> <p>That already looks a lot better. I wonder if it&#x2019;s useful to
print the input for every line though. What if we give a slightly
longer truncated Ethernet frame, so that it fails in, say, the middle
of reading the EtherType?</p> <pre><code class="language-rust">// in `src/main.rs`

fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    // was `..2`
    let incomplete_packet = &amp;packet[..13];

    // cut: call ethernet::Frame::parse()
}
</code></pre> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
1.0010714s | /!\ ersatz parsing error
...in Ethernet frame           [f4 d1 8 b 7e bc 14 c 76 6a 71 bd 8]
...in EtherType                [8]
nom error Eof                  [8]

1.0011471s | /!\ ersatz parsing error
...in Ethernet frame           [14 c 76 6a 71 bd f4 d1 8 b 7e bc 8]
...in EtherType                [8]
nom error Eof                  [8]
</code></pre> <p>Yeah! It is useful!</p> <p>Although.. I&#x2019;m not fond of the way <code>hex-slice</code> shows hex values. I&#x2019;d like them
to be two-character wide no matter what.</p> <p>Also, <code>[8]</code> is not extremely useful as far as context goes. Is it the first 8?
Or the second one?</p> <pre><code class="language-raw">...in Ethernet frame           [f4 d1 8 b 7e bc 14 c 76 6a 71 bd 8]
                                      ^                          ^
                                   this one ?              or this one ?
</code></pre> <pre><code class="language-shell">$ cargo rm hex-slice
    Removing hex-slice from dependencies
</code></pre> <p>We can do better than this.</p> <pre><code class="language-rust">use std::fmt;

impl&lt;&apos;a&gt; fmt::Debug for Error&lt;&amp;&apos;a [u8]&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;/!\\ ersatz parsing error\n&quot;)?;

        let mut shown_input = None;
        let margin_left = 4;
        let margin_str = &quot; &quot;.repeat(margin_left);

        // maximum amount of binary data we&apos;ll dump per line
        let maxlen = 60;

        // given a big slice, an offset, and a length, attempt to show
        // some data before, some data after, and highlight which part
        // we&apos;re talking about with tildes.
        let print_slice =
            |f: &amp;mut fmt::Formatter, s: &amp;[u8], offset: usize, len: usize| -&gt; fmt::Result {
                // decide which part of `s` we&apos;re going to show.
                let (s, offset, len) = {
                    // see diagram further in article.
                    // TODO: review for off-by-one errors

                    let avail_after = s.len() - offset;
                    let after = std::cmp::min(avail_after, maxlen / 2);

                    let avail_before = offset;
                    let before = std::cmp::min(avail_before, maxlen / 2);

                    let new_start = offset - before;
                    let new_end = offset + after;
                    let new_offset = before;
                    let new_len = std::cmp::min(new_end - new_start, len);

                    (&amp;s[new_start..new_end], new_offset, new_len)
                };

                write!(f, &quot;{}&quot;, margin_str)?;
                for b in s {
                    write!(f, &quot;{:02X} &quot;, b)?;
                }
                write!(f, &quot;\n&quot;)?;

                write!(f, &quot;{}&quot;, margin_str)?;
                for i in 0..s.len() {
                    // each byte takes three characters, ie &quot;FF &quot;
                    if i == offset + len - 1 {
                        // ..except the last one
                        write!(f, &quot;~~&quot;)?;
                    } else if (offset..offset + len).contains(&amp;i) {
                        write!(f, &quot;~~~&quot;)?;
                    } else {
                        write!(f, &quot;   &quot;)?;
                    };
                }
                write!(f, &quot;\n&quot;)?;

                Ok(())
            };

        for (input, kind) in self.errors.iter().rev() {
            let prefix = match kind {
                ErrorKind::Context(ctx) =&gt; format!(&quot;...in {}&quot;, ctx),
                ErrorKind::Nom(err) =&gt; format!(&quot;nom error {:?}&quot;, err),
            };

            write!(f, &quot;{}\n&quot;, prefix)?;
            match shown_input {
                None =&gt; {
                    shown_input.replace(input);
                    print_slice(f, input, 0, input.len())?;
                }
                Some(parent_input) =&gt; {
                    // `nom::Offset` is a trait that lets us get the position
                    // of a subslice into its parent slice. This works great for
                    // our error reporting!
                    use nom::Offset;
                    let offset = parent_input.offset(input);
                    print_slice(f, parent_input, offset, input.len())?;
                }
            };
        }
        Ok(())
    }
}
</code></pre> <p>Here&#x2019;s the diagram I drew to help me write this code:</p> <p><img src="/img/making-our-own-ping-9/highlight-math.png" alt></p> <p>I&#x2019;m fairly happy with the result:</p> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
1.0008906s | /!\ ersatz parsing error
...in Ethernet frame
    14 0C 76 6A 71 BD F4 D1 08 0B 7E BC 08
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
...in EtherType
    14 0C 76 6A 71 BD F4 D1 08 0B 7E BC 08
                                        ~~
nom error Eof
    14 0C 76 6A 71 BD F4 D1 08 0B 7E BC 08
                                        ~~
</code></pre> <h2 id="real-world-errors">Real-world errors</h2> <p>We&#x2019;ve only seen synthetic errors for now, so how about a real one?</p> <p>There&#x2019;s only a handful of <code>EtherType</code> values we care about, so let&#x2019;s make
it an enum:</p> <pre><code class="language-shell">$ cargo add derive-try-from-primitive
      Adding derive-try-from-primitive v0.1.0 to dependencies
</code></pre> <pre><code class="language-rust">// in `src/ethernet.rs`

use derive_try_from_primitive::*;

#[derive(Debug, TryFromPrimitive)]
#[repr(u16)]
pub enum EtherType {
    IPv4 = 0x0800,
}
</code></pre> <p>Make a parser for it:</p> <pre><code class="language-rust">impl EtherType {
    pub fn parse(i: parse::Input) -&gt; parse::Result&lt;Self&gt; {
        context(
            &quot;EtherType&quot;,
            map(be_u16, |x| EtherType::try_from(x).unwrap()),
        )(i)
    }
}
</code></pre> <p>Use it in <code>Frame</code>:</p> <pre><code class="language-rust">#[derive(Debug)]
pub struct Frame {
    pub dst: Addr,
    pub src: Addr,
    pub ether_type: EtherType,
}
</code></pre> <p>Use it in <code>Frame</code>&#x2019;s parser:</p> <pre><code class="language-rust">impl Frame {
    pub fn parse(i: parse::Input) -&gt; parse::Result&lt;Self&gt; {
        context(
            &quot;Ethernet frame&quot;,
            map(
                tuple((Addr::parse, Addr::parse, EtherType::parse)),
                |(dst, src, ether_type)| Self {
                    dst,
                    src,
                    ether_type,
                },
            ),
        )(i)
    }
}
</code></pre> <p>And take it for a spin:</p> <pre><code class="language-rust">// in `src/main.rs`
fn process_packet(now: Duration, packet: &amp;BorrowedPacket) {
    // was `incomplete_packet`
    match ethernet::Frame::parse(packet) {

    // etc.
</code></pre> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
999.8431ms | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: IPv4 }
999.889ms | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: IPv4 }
1.7093166s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: IPv4 }
1.7093598s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: IPv4 }
2.7247371s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: IPv4 }
2.7247634s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: IPv4 }
</code></pre> <p>So far so good.</p> <p>Remember that we&#x2019;re still pinging <code>8.8.8.8</code> in the background.</p> <p>What happens if we start pinging <code>google.com</code> instead? A the moment, it
resolves to <code>[2a00:1450:4007:817::200e]</code> for me and that.. doesn&#x2019;t look like
IPv4.</p> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
thread &apos;main&apos; panicked at &apos;called `Option::unwrap()` on a `None` value&apos;, src\libcore\option.rs:378:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre> <p>Well. Something certainly happened. But it brought down our entire packet sniffer with it.</p> <p>Which isn&#x2019;t great.</p> <p>What happened?</p> <p>Well, we&#x2019;ve used the
<a href="https://crates.io/crates/derive-try-from-primitive">derive-try-from-primitive</a>
crate to get <code>EtherType::try_from</code>.</p> <p>It performs mappings from <code>u16</code> values to <code>EtherType</code> variants:</p> <p><img src="/img/making-our-own-ping-9/value-mapping.png" alt></p> <p>..and then we call <code>.unwrap()</code> on it:</p> <pre><code class="language-rust">impl EtherType {
    pub fn parse(i: parse::Input) -&gt; parse::Result&lt;Self&gt; {
        context(
            &quot;EtherType&quot;,
            map(be_u16, |x| EtherType::try_from(x).unwrap()),
        )(i)
    }
}
</code></pre> <p>&#x2026;which panics on <code>None</code>. So everything is expected. I just kind of glossed it
over so we had an opportunity to fix it later.</p> <p>How <em>do</em> we fix it though?</p> <p>We can add.. a custom error type!</p> <pre><code class="language-rust">// in `src/parse.rs`

#[derive(Debug)]
pub enum ErrorKind {
    Nom(NomErrorKind),
    Context(&amp;&apos;static str),
    // new!
    Custom(String),
}

// new!
impl&lt;I&gt; Error&lt;I&gt; {
    pub fn custom(input: I, msg: String) -&gt; Self {
        Self {
            errors: vec![(input, ErrorKind::Custom(msg))],
        }
    }
}

// omitted: new match arm in the `fmt::Debug` implementation
</code></pre> <p>Then, instead of having <code>EtherType::parse</code> be a pure parser combinator, we
can &#x201C;stop&#x201D; after calling <code>be_u16</code> (if it succeeded), and check that it&#x2019;s a
unknown EtherType value.</p> <pre><code class="language-rust">impl EtherType {
    pub fn parse(i: parse::Input) -&gt; parse::Result&lt;Self&gt; {
        let original_i = i;
        let (i, x) = context(&quot;EtherType&quot;, be_u16)(i)?;
        // `i` is now the remaining input after reading the be_u16

        match EtherType::try_from(x) {
            Some(typ) =&gt; Ok((i, typ)),
            None =&gt; {
                let msg = format!(&quot;unknown EtherType 0x{:04X}&quot;, x);
                // we could hardcode `&amp;original_i[..4]` but why bother?
                use nom::Offset;
                let err_slice = &amp;original_i[..original_i.offset(i)];

                Err(nom::Err::Error(parse::Error::custom(err_slice, msg)))
            }
        }
    }
}
</code></pre> <p>The result is <em>very</em> readable:</p> <pre><code class="language-shell">$ cargo run --quiet
Listening for packets...
1.0000231s | /!\ ersatz parsing error
...in Ethernet frame
    14 0C 76 6A 71 BD F4 D1 08 0B 7E BC 86 DD 60 00 00 00 00 28
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
unknown EtherType 0x86dd
    14 0C 76 6A 71 BD F4 D1 08 0B 7E BC 86 DD 60 00 00 00 00 28 3A 80 2A 01 0E 35 2F D6 8F 60 E4 5F
                                        ~~~~~

1.0001009s | /!\ ersatz parsing error
...in Ethernet frame
    F4 D1 08 0B 7E BC 14 0C 76 6A 71 BD 86 DD 60 00 00 00 00 28
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
unknown EtherType 0x86dd
    F4 D1 08 0B 7E BC 14 0C 76 6A 71 BD 86 DD 60 00 00 00 00 28 3A 39 2A 00 14 50 40 07 08 17 00 00
                                        ~~~~~
</code></pre> <div class="recap"> <p><a href="https://crates.io/crates/nom">nom</a> is a powerful parsing library, that can be used both for
text formats and binary formats.</p> <p>With a few <code>impl</code> blocks here and there, it can easily support custom error handling.</p> <p>Its &#x201C;parser combinator&#x201D; approach makes for code that&#x2019;s both readable <em>and</em> fast.</p> </div> <p>Wait, wait, cool bear, hold on, wait.</p> <p>We haven&#x2019;t checked what kind of instructions our code actually generates.</p> <p>Time to make a release build and start up x64dbg.</p> <pre><code>$ cargo build --release
   Compiling proc-macro2 v0.4.30
   Compiling semver-parser v0.7.0
   (cut: many more lines)
   Compiling ersatz v0.1.0 (C:\msys64\home\amos\ftl\ersatz)
    Finished release [optimized] target(s) in 29.91s

$ butler sizeof ./target/release/ersatz.exe
Total size of ./target/release/ersatz.exe: 352.00 KiB
</code></pre> <p>Honestly? 352 KiB isn&#x2019;t that bad.</p> <p>Let&#x2019;s hope we can find our way through the executable&#x2026;</p> <p>I was able to find the symbol
<code>_ZN6ersatz8ethernet5Frame5parse17h813008bcdcb13adbE</code>, which looks promising.
I was not able to find any trace of <code>EtherType::parse</code> - I&#x2019;m assuming it has
been inlined.</p> <p>I analyzed the function and visualized it as a graph. The graph unfortunately
doesn&#x2019;t fit in a single screenshot. Although, the overview view does:</p> <p><img src="/img/making-our-own-ping-9/dbg-frame-parse.png" alt></p> <p>We can see that it calls <code>ersatz.sub_...</code> twice (although it checks the return
value first):</p> <p><img src="/img/making-our-own-ping-9/dbg-call-sub.png" alt></p> <p>If everything goes well, it keeps on trucking:</p> <p><img src="/img/making-our-own-ping-9/dbg-interlude.png" alt></p> <p>And then&#x2026; ooooh would you look at that - looks a lot like our <code>read_u16</code> from before!</p> <p><img src="/img/making-our-own-ping-9/dbg-rol.png" alt></p> <p>Here&#x2019;s another interesting bit - our fancy Rust <code>enum</code>? Disappeared:</p> <p><img src="/img/making-our-own-ping-9/dbg-ipv4-ethertype.png" alt></p> <p>Alright, it seems that cool bear was right after all, this looks good.</p> <p>Something is bothering me, though. If we look at <code>ersatz.sub_...</code>&#x2019;s code:</p> <p><img src="/img/making-our-own-ping-9/dbg-to-usize.png" alt></p> <p>It&#x2019;s calling one of nom&#x2019;s trait methods? I wonder what it does&#x2026;</p> <p><img src="/img/making-our-own-ping-9/dbg-to-usize-impl.png" alt></p> <p>Oh. Uh. Seems wasteful? Let&#x2019;s try turning on Link-Time Optimization:</p> <pre><code class="language-toml">// in `Cargo.toml`

[profile.release]
lto = true
</code></pre> <pre><code class="language-shell">$ cargo build --release
   Compiling proc-macro2 v0.4.30
   (many lines cut)
   Compiling ersatz v0.1.0 (C:\msys64\home\amos\ftl\ersatz)
    Finished release [optimized] target(s) in 34.16s
</code></pre> <p>Didn&#x2019;t even take that much longer.</p> <p>Did it make a difference in the codegen?</p> <p><img src="/img/making-our-own-ping-9/lto-symbols.png" alt></p> <p>Looks like it! I can&#x2019;t find <code>ethernet::Frame::parse</code> anymore.</p> <p>I know there&#x2019;s an <code>unknown EtherType</code> error message <em>somewhere</em> though.</p> <p><img src="/img/making-our-own-ping-9/lto-stringref.png" alt></p> <p>ahAH! There it is.</p> <p><img src="/img/making-our-own-ping-9/lto-unknown-ethertype.png" alt></p> <p>Let&#x2019;s follow it in the graph:</p> <p><img src="/img/making-our-own-ping-9/lto-ethertype-error.png" alt></p> <p>Alright, it&#x2019;s definitely formatting an error message. Where can we come from though?</p> <p><img src="/img/making-our-own-ping-9/lto-rol.png" alt></p> <p>Aha! Here&#x2019;s our <code>movzx</code> and our <code>rol</code>.</p> <p>This is in turn accessible from this part of the graph:</p> <p><img src="/img/making-our-own-ping-9/lto-mac-calls.png" alt></p> <p>And I bet you those two <code>call</code> (highlighted in cyan) are to <code>ethernet::Addr::parse</code>.</p> <p><img src="/img/making-our-own-ping-9/lto-mac-impl1.png" alt></p> <p>Mhhh is it? Let&#x2019;s look a little further down the graph&#x2026;</p> <p><img src="/img/making-our-own-ping-9/lto-mac-impl2.png" alt></p> <p>It is!</p> <p>I also cannot see <em>any</em> trace of <code>ToUsize::to_usize</code> anymore, which means
rustc / LLVM / MSVC worked together to successfully perform cross-crate inlining.</p> <h2 id="epilogue">Epilogue</h2> <p>This has been a long article, <strong>but</strong> we&#x2019;ve got everything we need to finish
this series. Well, except the ability to <em>send</em> traffic, but I promise you
the <code>rawsock</code> crate will also let us do that.</p> <p>In the meantime, we&#x2019;ll just slowly chip away at IPv4, and ICMP.. and then rebuild
them from the ground up to come up with the ultimate, userland-networking-powered,
version of <code>sup</code>.</p> <p class="patreon_credits">This article was made possible thanks to my patrons: Aurora, Ignacio Vergara, Jane Lusby, Jes&#xFA;s Higueras, J&#xE9;r&#xE9;my Gtld, Nicolas
Goy, Pascal, Raphael Gaschignard, Romain Ruetschi, Ryszard Sommefeldt, and
Xananax.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>