<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Certificate Authentication in ASP.NET Core&#xA0;3.0 -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Certificate Authentication in ASP.NET Core&#xA0;3.0</h1>
    <div id="post-12475" class="post-12475 post type-post status-publish format-standard hentry category-uncategorized"> <div class="entry-content"> <p>This article shows how <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth">Certificate Authentication</a> can be implemented in ASP.NET Core 3.0. In this example, a shared self signed certificate is used to authenticate one application calling an API on a second ASP.NET Core application.</p>
<p><strong>Code</strong> <a href="https://github.com/damienbod/AspNetCoreCertificateAuth">https://github.com/damienbod/AspNetCoreCertificateAuth</a></p>
<p><strong>Setting up the Server</strong></p>
<p>Add the Certificate Authentication using the Microsoft.AspNetCore.Authentication.Certificate NuGet package to the server ASP.NET Core application.</p>
<p><img src="https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=640" alt width="640" class="alignnone size-full wp-image-12480" srcset="https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=640&amp;h=677 640w, https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=142&amp;h=150 142w, https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=567&amp;h=600 567w, https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=768&amp;h=812 768w, https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=968&amp;h=1024 968w, https://damienbod.files.wordpress.com/2019/06/certauth_01.png 1130w" sizes="(max-width: 640px) 100vw, 640px"></p>
<p>This can also be added directly in the csproj file.</p>
<pre class="brush: xml; title: ; notranslate">
&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt;
    &lt;AspNetCoreHostingModel&gt;OutOfProcess&lt;/AspNetCoreHostingModel&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authentication.Certificate&quot; 
      Version=&quot;3.0.0-preview6.19307.2&quot; /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;None Update=&quot;sts_dev_cert.pfx&quot;&gt;
      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;

</pre>
<p>The authentication can be added in the ConfigureServices method in the Startup class. This example was built using the ASP.NET Core documentation. The AddAuthentication extension method is used to define the default scheme as &#x201C;Certificate&#x201D; using the CertificateAuthenticationDefaults.AuthenticationScheme string. The AddCertificate method then adds the configuration for the certificate authentication. At present, all certificates are excepted which is not good and the MyCertificateValidationService class is used to do extra validation of the client certificate. If the validation fails, the request is failed and the request for the resource will be rejected.</p>
<pre class="brush: csharp; title: ; notranslate">
public void ConfigureServices(IServiceCollection services)
{
	services.AddSingleton&lt;MyCertificateValidationService&gt;();

	services.AddAuthentication(CertificateAuthenticationDefaults.AuthenticationScheme)
		.AddCertificate(options =&gt; // code from ASP.NET Core sample
		{
			options.AllowedCertificateTypes = CertificateTypes.All;
			options.Events = new CertificateAuthenticationEvents
			{
				OnCertificateValidated = context =&gt;
				{
					var validationService =
						context.HttpContext.RequestServices.GetService&lt;MyCertificateValidationService&gt;();

					if (validationService.ValidateCertificate(context.ClientCertificate))
					{
						var claims = new[]
						{
							new Claim(ClaimTypes.NameIdentifier, context.ClientCertificate.Subject, ClaimValueTypes.String, context.Options.ClaimsIssuer),
							new Claim(ClaimTypes.Name, context.ClientCertificate.Subject, ClaimValueTypes.String, context.Options.ClaimsIssuer)
						};

						context.Principal = new ClaimsPrincipal(new ClaimsIdentity(claims, context.Scheme.Name));
						context.Success();
					}
					else
					{
						context.Fail(&quot;invalid cert&quot;);
					}

					return Task.CompletedTask;
				}
			};
		});

	services.AddAuthorization();

	services.AddControllers();
}
</pre>
<p>The AddCertificateForwarding method is used so that the client header can be specified and how the certificate is to be loaded using the HeaderConverter option. When sending the certificate with the HttpClient using the default settings, the ClientCertificate was always be null. The X-ARR-ClientCert header is used to pass the client certificate, and the cert is passed as a string to work around this.</p>
<pre class="brush: csharp; title: ; notranslate">
services.AddCertificateForwarding(options =&gt;
{
	options.CertificateHeader = &quot;X-ARR-ClientCert&quot;;
	options.HeaderConverter = (headerValue) =&gt;
	{
		X509Certificate2 clientCertificate = null;
		if(!string.IsNullOrWhiteSpace(headerValue))
		{
			byte[] bytes = StringToByteArray(headerValue);
			clientCertificate = new X509Certificate2(bytes);
		}

		return clientCertificate;
	};
});

</pre>
<p>The Configure method then adds the middleware. UseCertificateForwarding is added before the UseAuthentication and the UseAuthorization.</p>
<pre class="brush: csharp; title: ; notranslate">
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
	...
	
	app.UseRouting();

	app.UseCertificateForwarding();
	app.UseAuthentication();
	app.UseAuthorization();

	app.UseEndpoints(endpoints =&gt;
	{
		endpoints.MapControllers();
	});
}
</pre>
<p>The MyCertificateValidationService is used to implement validation logic. Because we are using self signed certificates, we need to ensure that only our certificate can be used. We validate that the thumbprints of the client certificate and also the server one match, otherwise any certificate can be used and will be be enough to authenticate.</p>
<pre class="brush: csharp; title: ; notranslate">
using System.IO;
using System.Security.Cryptography.X509Certificates;

namespace AspNetCoreCertificateAuthApi
{
    public class MyCertificateValidationService
    {
        public bool ValidateCertificate(X509Certificate2 clientCertificate)
        {
            var cert = new X509Certificate2(Path.Combine(&quot;sts_dev_cert.pfx&quot;), &quot;1234&quot;);
            if (clientCertificate.Thumbprint == cert.Thumbprint)
            {
                return true;
            }

            return false;
        }
    }
}

</pre>
<p>The API ValuesController is then secured using the Authorize attribute. </p>
<pre class="brush: csharp; title: ; notranslate">
[Route(&quot;api/[controller]&quot;)]
[ApiController]
[Authorize]
public class ValuesController : ControllerBase
{

...
</pre>
<p>The ASP.NET Core server project is deployed in this example as an out of process application using kestrel. To use the service, a certificate is required. This is defined using the ClientCertificateMode.RequireCertificate option. </p>
<pre class="brush: csharp; title: ; notranslate">
public static IWebHost BuildWebHost(string[] args)
  =&gt; WebHost.CreateDefaultBuilder(args)
  .UseStartup&lt;Startup&gt;()
  .ConfigureKestrel(options =&gt;
  {
	var cert = new X509Certificate2(Path.Combine(&quot;sts_dev_cert.pfx&quot;), &quot;1234&quot;);
	options.ConfigureHttpsDefaults(o =&gt;
	{
		o.ServerCertificate = cert;
		o.ClientCertificateMode = ClientCertificateMode.RequireCertificate;
	});
  })
  .Build();
</pre>
<p><strong>Implementing the HttpClient</strong></p>
<p>The client of the API uses a HttpClient which was create using an instance of the IHttpClientFactory. This does not provide a way to define a handler for the HttpClient and so we use a HttpRequestMessage to add the Certificate to the &#x201C;X-ARR-ClientCert&#x201D; request header. The cert is added as a string using the GetRawCertDataString method. </p>
<pre class="brush: csharp; title: ; notranslate">
private async Task&lt;JArray&gt; GetApiDataAsync()
{
	try
	{
		var cert = new X509Certificate2(Path.Combine(_environment.ContentRootPath, &quot;sts_dev_cert.pfx&quot;), &quot;1234&quot;);

		var client = _clientFactory.CreateClient();

		var request = new HttpRequestMessage()
		{
			RequestUri = new Uri(&quot;https://localhost:44379/api/values&quot;),
			Method = HttpMethod.Get,
		};

		request.Headers.Add(&quot;X-ARR-ClientCert&quot;, cert.GetRawCertDataString());
		var response = await client.SendAsync(request);

		if (response.IsSuccessStatusCode)
		{
			var responseContent = await response.Content.ReadAsStringAsync();
			var data = JArray.Parse(responseContent);

			return data;
		}

		throw new ApplicationException($&quot;Status code: {response.StatusCode}, Error: {response.ReasonPhrase}&quot;);
	}
	catch (Exception e)
	{
		throw new ApplicationException($&quot;Exception {e}&quot;);
	}
}
</pre>
<p>If the correct certificate is sent to the server, the data will be returned. If no certificate is sent, or the wrong certificate, then a 403 will be returned. It would be nice if the IHttpClientFactory would have a way of defining a handler for the HttpClient. I also believe a non valid certificates should fail per default and not require extra validation for this. The AddCertificateForwarding should also not be required to use for a default HTTPClient client calling the service. </p>
<p>Certificate Authentication is great, and helps add another security layer which can be used together with other solutions. See the code and ASP.NET Core src code for further documentation and examples. Links underneath.</p>
<p><strong>Links</strong></p>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0">https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0</a></p>
<p><a href="https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/Certificate/src">https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/Certificate/src</a></p>
<p><a href="https://tools.ietf.org/html/rfc5246#section-7.4.4">https://tools.ietf.org/html/rfc5246#section-7.4.4</a></p> </div> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>