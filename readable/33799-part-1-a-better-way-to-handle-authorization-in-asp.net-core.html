<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Part 1: A better way to handle authorization in ASP.NET Core -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Part 1: A better way to handle authorization in ASP.NET Core</h1>
    <body><p>I was asked by one of my clients to help build a fairly large web application, and their <em>authentication</em> (i.e. checking who is logging in) and <em>authorization</em> (i.e. what pages/feature the logged in user can access) is very complex. From my experience a knew that using ASP.NET&#x2019;s Role-based approach wouldn&#x2019;t cut it, and I found the new ASP.NET Core policy-based approach really clever but it needed me to write lots of (boring) policies.</p>
<p>In the end I created a solution for my client and this article describes the authorization part &#x2013; I call it Roles-to-Permissions (the name will make more sense as you read the article). I have also build <a href="https://github.com/JonPSmith/PermissionAccessControl">an example ASP.NET Core application</a>, with all new code to support this article. This example application is quite different from my client&#x2019;s system as I tap into ASP.NET Core built-in Identity system (the client&#x2019;s system needed OAuth2). The example application contains about 60 lines that I copied (with my client&#x2019;s permission) from the original implementation to create an open-source version (MIT licence) you can use.</p>
<p>This article is part of a series on authorization in ASP.NET Core</p>
<p><span><strong>UPDATE: New articles added to this series</strong><br></span></p>
<p><strong><span>There was a lot of interest in this article so I have written some follow-on articles that answer some of the comments/questions from the first two articles, plus a new, improved example application.<br></span></strong></p>
<blockquote><p>NOTE: you can Clone the <a href="https://github.com/JonPSmith/PermissionAccessControl">GitHub repo</a> and run locally &#x2013; it uses in-memory databases so it will run anywhere. The application was written using ASP.NET Core 2.1: parts of the ASP.NET Identity is changing, but the overall concept will work with any version of ASP.NET Core.</p></blockquote>
<p>This is a long article, so here are links to the major parts:</p> <ul><li>NET Role-based authorization system works for systems with simple authorization rules, but it has limitations, like the fact that you have to republish your code if you change the authorization rules.</li>
<li><em>Roles</em>, with names like &#x201C;Manager&#x201D; or &#x201C;ExternalBuyer&#x201D; makes sense for users (human or external services) as they define a &#x201C;Use Case&#x201D; of what the user should be able to do.</li>
<li>But Roles don&#x2019;t work well when applied to ASP.NET Core actions or Razor Pages. Here you need a much more fine-grained solution, with names like &#x201C;CanRequestHoliday&#x201D;, &#x201C;CanApproveHoliday&#x201D; &#x2013; I call these <em>Permissions</em>.</li>
<li>The solution is to map the user&#x2019;s Roles to a group of Permissions and store these in the User&#x2019;s Claims.</li>
<li>Then I use ASP.NET Core&#x2019;s new policy-based authorization system to check that the User&#x2019;s Permissions Claims contains the Permission placed on the action/page they want to access.</li>
<li>There is <a href="https://github.com/JonPSmith/PermissionAccessControl">an open-source example ASP.NET Core application</a> to go with this article.</li>
</ul><h2 id="setting-the-scene-a-look-at-different-application-security-needs">Setting the Scene &#x2013; a look at different application security needs<a class="anchorlink dashicons-before" href="#setting-the-scene-a-look-at-different-application-security-needs"></a></h2>
<p><em>If you understand ASP.NET&#x2019;s authorization and authentication features then you can skip this section.</em></p>
<p>There are billions of web applications and the control of what you can do ranges for &#x201C;anyone can do anything&#x201D;, e.g. Google search, up to some military systems where access needs keys, biometrics etc. When you need to prove you are a valid user of the system, say by logging in, that is referred to as <em>authentication</em>. Once you are logged in then what you can do is controlled by what is called <em>authorization</em>.</p>
<p>Authorization breaks down into two parts:</p>
<ol><li>What data can I access? For instance, you can see your personal information, but not other people&#x2019;s personal information.</li>
<li>What features you can use? For instance, are you allowed to change the title of a book that you can see?</li>
</ol><blockquote><p>NOTE: This article only describes a way to manage the second part, what features can you use.</p></blockquote>
<p>ASP.NET MVC and now ASP.NET Core have various systems to help with authorization and authentication. Some systems only need a simple authorization &#x2013; I could imagine a very simple e-commerce system could get away with: a) No logged in &#x2013; browsing, b) Logged in &#x2013; buying, and c) Admin &#x2013; Add/Remove items for sale. This could be done using ASP.NET Role-based authentication.</p>
<p>But many business-to-business (B-to-B) systems have more complex authorization needs. For instance, think of a human resources (HR) system where people can request holiday leave and their manager has to approve those requests &#x2013; there is lot going on inside to ensure only the correct users can use these features.</p>
<p>Systems like my example HR B-to-B system often end up with lots of complex authorization rules. My experience is that the ASP.NET Role-based authentication starts to have problems implementing this type of system, which is why I created the Roles-to-Permissions code.</p>
<p>Another type of application that could benefit from the Roles-to-Permissions approach are subscription systems, where the features a user can access depend on what subscription they paid for. The Roles-to-Permissions approach can control the features that as user can access based on the subscription they bought.</p> <p>Roles authorization has been around for years in the ASP.NET MVC application, and I have used it in a number of applications. Here is an example of a ASP.NET Core controller that can only be accessed by logged in users with either the &#x201C;Staff&#x201D; Role or the &#x201C;Manger&#x201D; role.</p>
<pre class="brush: csharp; title: ; notranslate">
[Authorize(Roles = &quot;Staff,Manager&quot;)]
public ActionResult Index()
{
    return View(MyData);
}
</pre>
<p>This works for applications that have fairly simple and well-defined Roles, like User/Admin or Staff/Manager/Admin, then Roles is a good choice. But here are some of the problems I have found:</p>
<ol><li>If you have lots of roles you can end up with long Authorize attributes, e.g. [Authorize(Roles = &#x201C;Staff,HrManager,BizManager,DevManage,Admin,SuperAdmin&#x201D;)].</li>
<li>Because Authorize is an attribute then the string has to be a constant, e.g. you can&#x2019;t have $&#x201D;{RoleConstants.StaffRole}&#x201D;. This means if things change you are editing strings, and you could misspell something really easily.</li>
<li>The big one for me is your authorization rules are hard-coded into your code. So, if you want to change who can access a certain action you have to edit the appropriate Authorize attributes and redeploy your application.</li>
</ol><p>My experience from previous applications using Roles-based authorization is me constantly having to go back and edit the authorize Roles part as I develop or refine the application. I have been looking for a better way for some time, and my client&#x2019;s requirements spurred me on to find something better than Roles authorization.</p>
<h2 id="the-architecture-of-the-roles-to-permissions-system">The architecture of the Roles-to-Permissions system<a class="anchorlink dashicons-before" href="#the-architecture-of-the-roles-to-permissions-system"></a></h2>
<h3 id="1-introducing-roles-permissions-and-modules">1. Introducing Roles, Permissions and Modules<a class="anchorlink dashicons-before" href="#1-introducing-roles-permissions-and-modules"></a></h3>
<p>It turns out that there is nothing wrong with the idea of a user having Roles. A user (human or an external service) can typically can be described by their function or department, like &#x201C;Developer&#x201D; or &#x201C;HR&#x201D;, maybe with side Roles like &#x201C;HolidayAdmin&#x201D;. Think of Roles as &#x201C;<a href="http://www.gatherspace.com/static/use_case_example.html">Use Cases</a> for users.</p>
<blockquote><p>NOTE: In the example application I have Roles of &#x201C;Staff&#x201D;, &#x201C;Manager&#x201D;, and &#x201C;Admin.</p></blockquote>
<p>But the problem is that Roles aren&#x2019;t a good fit for the actions in the Controllers. Each Controller action has a little part to play in a Role, or to turn it around, a Role is made up of a series of Controller actions that the Role allows you to access.&#xA0; I decided I would call the authorization feature on each action a &#x201C;Permission&#x201D;, and I used an Enum to define them. A permission Enum member might be called &#x201C;CanReadHoliday&#x201D;, &#x201C;CanRequestHoliday&#x201D;, &#x201C;CanApproveHoliday&#x201D;, etc.</p>
<blockquote><p>NOTE: In the example application I have Permissions on my ColorController of &#x201C;ColorRead&#x201D;, &#x201C;ColorCreate&#x201D;, &#x201C;ColorUpdate&#x201D;, and &#x201C;ColorDelete&#x201D;.</p></blockquote>
<p>Now that we have permissions we can provide another feature that of controls access to optional features, e.g. features that a user only has based on their subscription to the service. There are many ways of handling features but by combining optional features into the permissions makes it simpler to setup and control.</p>
<blockquote><p>NOTE:&#xA0; In the example application I have Permissions called &#x201C;Feature1&#x201D; and &#x201C;Feature2&#x201D; which are mapped to Modules with the same name.</p></blockquote>
<h3 id="2-how-this-is-implemented">2. How this is implemented<a class="anchorlink dashicons-before" href="#2-how-this-is-implemented"></a></h3>
<p>Having defined my terms, I&#x2019;m going to give you an overview of the process. It consists of two parts: the login stage and the normal accesses to the web site. The login stage is the most complex with lots of magic goes on in the background. Its basic job is to convert the user&#x2019;s Roles into Permissions and add it to the User&#x2019;s information.</p>
<p>I have set up my example application to store the user&#x2019;s claims in a cookie which is read in with every HTTP request and turned into a ClaimsPrincipal, which can be accessed in ASP.NET Core by the HttpContext property called &#x201C;User&#x201D;.</p>
<p>Here is a diagram of that login stage. It might not make a lot of sense yet, but I describe each part in the rest of the article. This diagram is to give you an overview.</p>
<p><a href="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart1.png"><img class="aligncenter size-full wp-image-1548" src="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart1.png" alt width="935" srcset="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart1.png 935w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart1-300x169.png 300w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart1-768x433.png 768w" sizes="(max-width: 935px) 100vw, 935px"></a></p>
<blockquote><p>NOTE: In this example application I use the Roles in the ASP.NET Core&#x2019;s Identity, mainly to show the step from Roles to Permissions. But in my client implementation I just used ASP.NET Core&#x2019;s Identity for Authentication and I had my own UserToRoles table. <span>You can read about this in the Part 3 article, <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/">A better way to handle authorization &#x2013; six months on</a></span>.</p></blockquote>
<p>The second part is simpler and covers what happens every time the logged-in user accesses a protected Controller action. Basically, I have a policy-based authorization with dynamic rules that checks the current User has the permission needed to execute the ASP.NET action/razor page.</p>
<p><a href="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart2.png"><img class="aligncenter size-full wp-image-1549" src="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart2.png" alt width="935" srcset="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart2.png 935w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart2-300x126.png 300w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart2-768x322.png 768w" sizes="(max-width: 935px) 100vw, 935px"></a></p>
<blockquote><p>NOTE: Don&#x2019;t forget there is <a href="https://github.com/JonPSmith/PermissionAccessControl">example application</a> if you want to look at the actual code.</p></blockquote>
<p>Now I&#x2019;m going to build up the Roles-to-Permissions in stages and explain what each part does.</p>
<h2 id="why-i-used-enums-for-the-permissions">Why I used Enums for the Permissions<a class="anchorlink dashicons-before" href="#why-i-used-enums-for-the-permissions"></a></h2>
<p>One of the down-sides of using Roles is it used strings, and I&#x2019;m a little bit dyslexic. That means I can type/spell things incorrectly and not notice. Therefore, I wanted something where intellisence would prompt me and if I still typed it incorrectly it would be a compile error. But it turns out there are a couple of other reasons that make using an Enum for the permissions a good idea. Let me explain.</p>
<p>In a big application there could be hundreds of Permissions. This lead to two problems:</p>
<ol><li>If I use Cookie Authorization there is a maximum size of 4096 bytes for the Cookie. If I had hundreds of long strings I might start to fill up the Cookie, and I want some room for other things like my data authorization. If I can store the Enums permissions as a series of integers it&#x2019;s going to be much smaller than a series of strings.</li>
<li>Secondly, I want to help the Admin person who needs to build the mapping from Roles to permissions. If they need to scroll through hundreds of permission names it could be hard to work out which ones are needed. It turns out Enum members can have attributes, so I can add extra information to help the Admin person.</li>
</ol><p>So, here is part of my Permissions Enum code</p>
<pre class="brush: csharp; title: ; notranslate">
public enum Permissions
{
    //Here is an example of very detailed control over something
    [Display(GroupName = &quot;Color&quot;, Name = &quot;Read&quot;, Description = &quot;Can read colors&quot;)]
    ColorRead = 0x10,
    [Display(GroupName = &quot;Color&quot;, Name = &quot;Create&quot;, Description = &quot;Can create a color entry&quot;)]
    ColorCreate = 0x11,
    [Display(GroupName = &quot;Color&quot;, Name = &quot;Update&quot;, Description = &quot;Can update a color entry&quot;)]
    ColorUpdate = 0x12,
    [Display(GroupName = &quot;Color&quot;, Name = &quot;Delete&quot;, Description = &quot;Can delete a color entry&quot;)]
    ColorDelete = 0x13,

    [Display(GroupName = &quot;UserAdmin&quot;, Name = &quot;Read users&quot;, Description = &quot;Can list User&quot;)]
    UserRead = 0x20,
    //This is an example of grouping multiple actions under one permission
    [Display(GroupName = &quot;UserAdmin&quot;, Name = &quot;Alter user&quot;, Description = &quot;Can do anything to the User&quot;)]
    UserChange = 0x21,

    [Obsolete]
    [Display(GroupName = &quot;Old&quot;, Name = &quot;Not used&quot;, Description = &quot;example of old permission&quot;
    OldPermissionNotUsed = 0x40,
</pre>
<p>The things to note are:</p>
<ul><li>I show two types of permissions.
<ul><li>First four (lines 4 to 1) are fine-grained permissions, almost one per action.</li>
<li>Next two (lines 13 to 17) are more generic, e.g. I have a specific &#x201C;UserRead&#x201D;, but then one permission called &#x201C;UserChange&#x201D; which allows create, update, delete, lock, change password etc.</li>
</ul></li>
<li>Line 5, 7, etc. Notice that I give each enum a specific number. If you are operating a 24/7 application with a new version seamlessly replacing the old version, then the Permission numbed mustn&#x2019;t change otherwise user&#x2019;s Claims be wrong. That is why I give each enum a specific number.</li>
<li>Line 19. I also support the Obsolete attribute, which stops the Permission appearing in the listing. There are plenty of scary stories about reusing a number with unintended consequences. (Also, it you try to use something marked as Obsolete you get a warning).</li>
<li>Line 4 etc. I add a Display Attribute to each Permission Enum. This has useful information that I can show lots of useful information to help the person who is building a Role.</li>
<li>Line 4, 6, 8, 10. I &#x201C;Group&#x201D; permissions that are used in the same place. This makes it easier for the Admin person to find the things they want. I also number in Hex, which gives me 16 possible permissions in a Group (I tried 10 and you could go over that, so 16 is better).</li>
</ul><p>Here is a list of some of the Permissions in my example application listed via the Users-&gt;List Permissions nav dropdown.</p>
<p><a href="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/ListOfEnumPermissions.png"><img class="aligncenter size-full wp-image-1551" src="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/ListOfEnumPermissions.png" alt width="1002" srcset="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/ListOfEnumPermissions.png 1002w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/ListOfEnumPermissions-300x187.png 300w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/ListOfEnumPermissions-768x478.png 768w" sizes="(max-width: 1002px) 100vw, 1002px"></a></p>
<p>And the code that produced that output (link to <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/PermissionParts/PermissionDisplay.cs">PermissionDisplay class</a> for the whole thing)</p>
<pre class="brush: csharp; title: ; notranslate">
public static List&lt;PermissionDisplay&gt; GetPermissionsToDisplay(Type enumType) 
{
    var result = new List&lt;PermissionDisplay&gt;();
    foreach (var permissionName in Enum.GetNames(enumType))
    {
        var member = enumType.GetMember(permissionName);
        //This allows you to obsolete a permission and it won&apos;t be shown as a
        //possible option, but is still there so you won&apos;t reuse the number
        var obsoleteAttribute = member[0].GetCustomAttribute&lt;ObsoleteAttribute&gt;();
        if (obsoleteAttribute != null)
            continue;
        //If there is no DisplayAttribute then the Enum is not used
        var displayAttribute = member[0].GetCustomAttribute&lt;DisplayAttribute&gt;();
        if (displayAttribute == null)
            continue;

        //Gets the optional PaidForModule that a permission can be linked to
        var moduleAttribute = member[0].GetCustomAttribute&lt;PermissionLinkedToModuleAttribute&gt;();

        var permission = (Permissions)Enum.Parse(enumType, permissionName, false);

        result.Add(new PermissionDisplay(displayAttribute.GroupName, displayAttribute.Name, 
                displayAttribute.Description, permission, moduleAttribute?.PaidForModule.ToString()));
    }

    return result;
}
</pre>
<h2 id="how-to-handle-optional-paid-for-features">How to handle optional/paid-for features?<a class="anchorlink dashicons-before" href="#how-to-handle-optional-paid-for-features"></a></h2>
<p>My client provides a Business-to-Business application and plans to add new features that customers can subscribe to. One way to handle this would be create different Roles, like &#x201C;Manager&#x201D;, &#x201C;ManagerWithFeature1&#x201D;, &#x201C;ManagerWithFeature2&#x201D; or add separate Feature Roles that you have to manually apply to a user. That works but is pretty horrible to manage, and human error could cause problems. My preferred system is mark Permissions linked to a paid-for feature filter them based on the User&#x2019;s subscriptions.</p>
<p>Marking Permissions as linked to a module is easy to do with the Enums &#x2013; I just add another attribute. Here an example of Permissions linked to a Module (see line 5).</p>
<pre class="brush: csharp; title: ; notranslate">
public enum Permissions
{
    //&#x2026; other Permissions removed for clarity

    [LinkedToModule(PaidForModules.Feature1)]
    [Display(GroupName = &quot;Features&quot;, Name = &quot;Feature1&quot;, Description = &quot;Can access feature1&quot;)]
    Feature1Access = 0x30,
    [LinkedToModule(PaidForModules.Feature2)]
    [Display(GroupName = &quot;Features&quot;, Name = &quot;Feature2&quot;, Description = &quot;Can access feature2&quot;)]
    Feature2Access = 0x31
}
</pre>
<p>The paid-for modules are again represented by an Enum, but one marked the [Flags] attribute because a user can have multiple modules that they have subscribed to. Here is my PaidForModules Enum code</p>
<pre class="brush: csharp; title: ; notranslate">
[Flags]
public enum PaidForModules : long
{
    None = 0,
    Feature1 = 1,
    Feature2 = 2,
    Feature3 = 4
} 
</pre>
<blockquote><p>NOTE I add &#x201C;: long&#x201D; to the Enum which gives me up to 64 different modules in my system.</p></blockquote>
<p>What happens is that Permissions linked to a Module that the user hasn&#x2019;t subscribe to are filtered out during the login stage (I show how later). This makes the setting up the Roles much simpler, as you build each Role with all the Permissions that make sense for that role, including features mapped to a paid-for module. Then, at login time, the system will remove any Permissions the current user doesn&#x2019;t have access to. That is simpler for the Admin person and more secure for the application.</p>
<h2 id="how-do-i-turn-the-roles-into-a-permissions-claim">How do I turn the Roles into a Permissions Claim?<a class="anchorlink dashicons-before" href="#how-do-i-turn-the-roles-into-a-permissions-claim"></a></h2>
<p>I my client&#x2019;s system we uses <a href="https://www.jerriepelser.com/blog/authenticate-oauth-aspnet-core-2/">0Auth2 authentication</a>, but for this example I used ASP.NET Core IdentityRole to hold the Roles that a user has. That means I can use all of the ASP.NET Core built-in Identity code to set up the Users and Roles. But how do I convert the User&#x2019;s Roles to a Permissions Claim?</p>
<p>Again there are few ways to do it, but in the end I tapped into an event in the Authorization Cookie called &#x2018;OnValidatePrincipal&#x2019; (here is a <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/TestWebApp/Startup.cs#L60-L69">link to the lines in the example application startup class</a>). This calls the code below, but be warned it&#x2019;s pretty complex so here is a summary of the steps it goes through:</p>
<ol><li>If the Claims already have the Permissions claim type then nothing to do so return quickly.</li>
<li>Then we get the Roles the user has from the Role Claim</li>
<li>I need to access my part of the database. I can&#x2019;t use dependency injection, so I use the extraAuthDbContextOptions, which is a singleton that I can provide at startup.</li>
<li>Then I get all the permissions for all of the roles, with a Distinct to remove unnecessary duplicates.</li>
<li>Then I filter out any permissions that are linked to a Module that the user doesn&#x2019;t have access to.</li>
<li>Then I add a permissions Claim containing all the Permissions the user is allowed, but packed as hex numbers in a single string so that it doesn&#x2019;t take up so much room (I used Hex format as it made debugging easier).</li>
<li>Finally I have to create a new ClaimsPrincipal and tell ASP.NET Core to replace the current ClaimsPrincipal, plus set the all-important ShouldRenew to true, which updates the Cookie, otherwise this complex (slow) method on every HTTP request!</li>
</ol><pre class="brush: csharp; title: ; notranslate">
public async Task ValidateAsync(CookieValidatePrincipalContext context)
{
    if (context.Principal.Claims.Any(x =&gt; 
        x.Type == PermissionConstants.PackedPermissionClaimType))
        return;

    //No permissions in the claims so we need to add it
    //This is only happens once after the user has logged in
    var claims = new List&lt;Claim&gt;();
    foreach (var claim in context.Principal.Claims)
    {
        claims.Add(claim);
    }

    var usersRoles = context.Principal.Claims
        .Where(x =&gt; x.Type == ClaimTypes.Role)
        .Select(x =&gt; x.Value)
        .ToList();
    //I can&apos;t inject the DbContext here because that is dynamic, 
    //but I can pass in the database options because that is a 
    //From that I can create a valid dbContext to access the database
    using (var dbContext = new ExtraAuthorizeDbContext(_extraAuthDbContextOptions))
    {
        //This gets all the permissions, with a distinct to remove duplicates
        var permissionsForUser = await dbContext.RolesToPermissions
            .Where(x =&gt; usersRoles.Contains(x.RoleName))
            .SelectMany(x =&gt; x.PermissionsInRole)
            .Distinct()
            .ToListAsync();

        //we get the modules this user is allows to see
        var userModules =
            dbContext.ModulesForUsers
                .Find(context.Principal.Claims
                     .SingleOrDefault(x =&gt; x.Type == ClaimTypes.Name).Value)
                ?.AllowedPaidForModules ?? PaidForModules.None;
        //Now we remove permissions that are linked to modules that the user has no access to
        var filteredPermissions =
            from permission in permissionsForUser
            let moduleAttr = typeof(Permissions).GetMember(permission.ToString())[0]
                .GetCustomAttribute&lt;LinkedToModuleAttribute&gt;()
            where moduleAttr == null || userModules.HasFlag(moduleAttr.PaidForModule)
            select permission;

          //Now add it to the claim
          claims.Add(new Claim(PermissionConstants.PackedPermissionClaimType,
              filteredPermissions.PackPermissionsIntoString()));    }

    var identity = new ClaimsIdentity(claims, &quot;Cookie&quot;);
    var newPrincipal = new ClaimsPrincipal(identity);

    context.ReplacePrincipal(newPrincipal);
    context.ShouldRenew = true;
}
</pre>
<h4 id="update-in-part-3-article-i-show-you-a-much-easier-way-to-add-the-claims-to-the-users-claim-set-and-it-works-with-cookie-or-token-based-authorisation-see-this-section-for-more-on-t"><span><strong>UPDATE: In <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/">Part 3 article</a> I show you a much easier way to add the claims to the user&#x2019;s Claim set, and it works with Cookie or Token based authorisation &#x2013; see <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/#a-simpler-way-to-add-to-the-users-claims">this section</a> for more on this.</strong></span><a class="anchorlink dashicons-before" href="#update-in-part-3-article-i-show-you-a-much-easier-way-to-add-the-claims-to-the-users-claim-set-and-it-works-with-cookie-or-token-based-authorisation-see-this-section-for-more-on-t"></a></h4> <p>OK, I now have access to the Permissions via the User&#x2019; Claims, but how do I get this turned into something that ASP.NET Core can use for authorization. This is where a .NET developer and friend, <a href="https://www.jerriepelser.com/">Jerrie Pelser</a> helped me.</p>
<p>When I started this project, I emailed Jerrie Pelser, who runs the <a href="https://www.getrevue.co/profile/aspnetweekly">ASP.NET Weekly newsletter</a> (great newsletter! Do sign up) as I know Jerrie is an expert in authentication &amp; authorization.&#xA0; He pointed me at a few architectural things and I also found his own article &#x201C;<a href="https://www.jerriepelser.com/blog/creating-dynamic-authorization-policies-aspnet-core/">Creating Authorization Policies dynamically with ASP.NET Core</a>&#x201D; really helpful.&#xA0; Jerris&#x2019;s article showed me how to build policies dynamically, which is exactly what I need.</p>
<p>I&#x2019;m not going to repeat Jerrie article here (use the link above), but I will show you my PermissionHandler that is used inside the policy to check that the current User&#x2019;s Permissions claim exists and contains the Permission on the action/Razor Page. It uses an extension method called <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/PermissionParts/PermissionChecker.cs">ThisPermissionIsAllowed</a> which does the check.</p>
<pre class="brush: csharp; title: ; notranslate">
public class PermissionHandler : 
    AuthorizationHandler&lt;PermissionRequirement&gt;
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context, 
        PermissionRequirement requirement)
    {
        var permissionsClaim = context.User.Claims
            .SingleOrDefault(c =&gt; 
                 c.Type == PermissionConstants
                     .PackedPermissionClaimType);
        // If user does not have the scope claim, get out of here
        if (permissionsClaim == null)
            return Task.CompletedTask;

        if (permissionsClaim.Value
            .ThisPermissionIsAllowed(
                 requirement.PermissionName))
        {
            context.Succeed(requirement);
        }

        return Task.CompletedTask;
    }
}
</pre>
<p>There are two other classes that are involved in making dynamic policy-based authorisation work. Here are the links to them:</p>
<p>Policies are defined by strings, but as I said I hate strings as I can make a mistake. I therefore created this very simple HasPermission attribute which allows me to apply an Authorize attribute, but using a Permissions Enum</p>
<pre class="brush: csharp; title: ; notranslate">
[AttributeUsage(AttributeTargets.Method 
    | AttributeTargets.Class, Inherited = false)]
public class HasPermissionAttribute : AuthorizeAttribute
{
    public HasPermissionAttribute(Permissions permission) 
       : base(permission.ToString()) { }
}
</pre>
<p>That&#x2019;s pretty simple, but it means I get intellisence when I am adding the Permission.</p>
<h2 id="putting-it-all-together">Putting it all together<a class="anchorlink dashicons-before" href="#putting-it-all-together"></a></h2>
<p>So, we have the Permissions in the code and we can apply them using our HasPermissionAttribute to each action we want to protect via authorization. Here is one action taken from the ColorController in my example application.</p>
<pre class="brush: csharp; title: ; notranslate">
[HasPermission(Permissions.ColorRead)]
public ActionResult Index()
{
    return View(MyData);
}
</pre>
<p>We also need to add two tables to whatever database your application uses. The two EF Core entity classes are:</p>
<p>Once the application is up and running an Admin-type user has to:</p>
<ol><li>Create some roles, e.g. &#x201C;Staff&#x201D;, &#x201C;Manager&#x201D;, etc. using ASP.NET Core Identity code.</li>
<li>Create matching RoleToPermissions for each of the roles, specifying what Permissions map to each Role.</li>
</ol><p>Then, for every new user an Admin person (or some automatic subscription code) has to:</p>
<ol><li>Create the user (if an invite-only type application)</li>
<li>Add the correct Roles and ModulesForUser for that new user.</li>
</ol><p>Once that is done all the code I have shown you takes over. The user logs in, gets the Permissions and what they can access is managed by ASP.NET Core&#x2019;s policy-based authentication.</p>
<h2 id="things-i-didnt-cover-elsewhere">Things I didn&#x2019;t cover elsewhere<a class="anchorlink dashicons-before" href="#things-i-didnt-cover-elsewhere"></a></h2>
<p>There are a few things I didn&#x2019;t cover in detail, but here are links to the items:</p>
<ul><li>The important parts about registering things are shown in <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/TestWebApp/Startup.cs#L60-L73">highlighted lines in this link to the Startup class</a>. (NOTE: I built the application with ASP.NET Core 2.1, but I know the Identity parts are changing in 2.2, so you might have to update the code I put in the Startup class for newer versions of ASP.NET Core).
<ul><li><strong><span>UPDATE: I built a new example application (referred to as version 2) that is much better on it startup code &#x2013; see <a href="https://github.com/JonPSmith/PermissionAccessControl2">PermissionAccessControl2</a>.</span></strong></li>
</ul></li>
<li>You don&#x2019;t need to use ASP.NET Core Identity system at all &#x2013; I said the client&#x2019;s version uses an external authentication system. You just have to create a Roles-to-User table so you can assign Roles to each user.</li>
<li>I didn&#x2019;t cover how I Packed/Unpacked the Permissions. You can find the Extension methods for doing that in <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/PermissionParts/PermissionPackers.cs">PermissionPackers</a>.
</li>
<li>You might want to check for a permission in your razor pages to show/hide links. I created a simple method in the <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/RolesToPermission/PermissionExtensions.cs">PermissionsExtension</a> class, and used it in the <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/TestWebApp/Views/Shared/_Layout.cshtml#L49-L52">_layout.cshtml</a> Razor page.
<ul><li><strong><span>UPDATE: There is a <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/#using-permissions-in-the-front-end">whole new section on this</a> in the Part 3 article.</span></strong></li>
</ul></li>
</ul><h2 id="conclusion">Conclusion<a class="anchorlink dashicons-before" href="#conclusion"></a></h2>
<p>Well that is a long article so well done by getting to the end. I have described an authentication I have built that handles complex authentication rules while being (relatively) easy to understand and manage via the Admin staff. Sure, if you have hundreds of Permissions it&#x2019;s not to be hard setting up the initial RolesToPermissions, but the Admin has a lot of information to help them.</p>
<p>For me the Roles-to-Permissions approach solves a lot of problems I had in older systems I built using ASP.NET MVC Roles. I have to write some more code, but it makes it a) easier to change the authorization rules and b) helps the Admin person manage applications with lots of Roles/Permissions. I hope it helps you think of better ways of building better authentication systems for your projects.</p>
<h4 id="update-dont-miss-the-new-articles-that-go-deeper-into-feature-and-data-authorization"><span><strong>UPDATE: Don&#x2019;t miss the new articles that go deeper into feature and data authorization.</strong></span><a class="anchorlink dashicons-before" href="#update-dont-miss-the-new-articles-that-go-deeper-into-feature-and-data-authorization"></a></h4>
<h2 id="further-reading">Further reading<a class="anchorlink dashicons-before" href="#further-reading"></a></h2>
<p>Happy coding.</p>
<p><strong><span>Don&#x2019;t forget to sign up to Jerrie Pelser&#x2019;s, <a href="https://www.getrevue.co/profile/aspnetweekly">ASP.NET Weekly newsletter</a> if you are interested in ASP.NET or Entity Framework. It is the most important newsletter I get.</span></strong></p></body>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>