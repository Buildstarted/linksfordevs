<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Builder Pattern Test Kata Questions -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Builder Pattern Test Kata Questions</h1><div><div id="" class="mcnTextContent">
from last week, which you'll find <a href="https://github.com/ardalis/BuilderTestSample" target="_blank">here</a>. If you find it useful, give it a star!<p>Kevin (full name withheld because I forgot to ask permission to share) is using <a href="https://github.com/JeremySkinner/FluentValidation" target="_blank">FluentValidation </a>and asks:</p><p><em>Would you put validation in the Model, the Service, or the ? I’m starting to favor the Model, but I’d love your input.</em></p><p>I replied, in typical consultant style (i.e. saying it depends):</p><p><em>In this example I'm putting the validation in the service, but that's mostly just to make it so the exercise is simple and there is only one test class (because everything hits OrderService.PlaceOrder).</em></p><p>In a real application, I would probably pull validation out of the service (to follow Single Responsibility). I'd probably err on putting it in the model, but if it became too big and complex I might pull it out and have a have a way a collaborator do the validation work.</p><p>I just shy away from .IsValid() methods on model types because there's always the question "valid for what?", at which point you may end up with a bunch more methods like IsValidForSave, IsValidForPlaceOrder, IsValidForPayment, etc. Since in the model an Aggregate is responsible for enforcing invariants and *basic* validation of the structure of the aggregate, I typically keep this validation in the model. However, if there are business rule validations that are less structural and perhaps more context/operation specific, these might not go into the model (or at least they would go somewhere else).</p><p>Does that help? The short version is "it depends" but hopefully this showed some of the considerations I'd have.</p><p>Where do you put validation logic for model types? Do you have one place it always goes, or is it a mix? Does it depend? On what?</p><p>Regarding the kata, there was one issue reported and fixed last week. I also have a branch showing an in-progress attempt at completing it <a href="https://github.com/ardalis/BuilderTestSample/tree/trying1" target="_blank">here</a>. If you complete the kata and want to share your version, send a PR with a link in the README.md and I'll pull it in so others can see how you did things.</p><p><em>Do you have a dev tip or programming horror story to share? I'd love to hear it and, with permission, share it with others. Just hit reply and email me.</em></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>