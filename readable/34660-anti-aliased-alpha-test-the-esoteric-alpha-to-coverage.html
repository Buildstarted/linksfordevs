<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Anti-aliased Alpha Test: The Esoteric Alpha To Coverage -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Anti-aliased Alpha Test: The Esoteric Alpha To Coverage</h1>
    <div><section class="ij ik il im in"><div class="y io x cs cq cr"><div><div class="ja"><div class="as ar"><div><a href="https://link.medium.com/@bgolus?source=post_page-----8b177335ae4f----------------------"><img alt="Ben Golus" class="l es jb jc" src="https://miro.medium.com/fit/c/96/96/1*aZ0riE9vn3VFI7v4H1V-GQ.png" width="48"></a></div><div class="jd x l"><span class="br b bs bt bu bv l bw bx"><span class="br dt du bt jg jh ji jj jk jl bw"><div><a class="bb bc bd be bf bg bh bi bj bk if bn bo bp bq" href="https://link.medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f?source=post_page-----8b177335ae4f----------------------">Aug 12, 2017</a> &#xB7; 15 min read</div></span></span></div></div></div></div><p id="af7e" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">Aliasing is the bane of VR. We have several tools we use to try to remove, or at least reduce aliasing in real time graphics today. Tools like <a href="https://en.wikipedia.org/wiki/Supersampling" class="bb cn kd ke kf kg">super sampling</a>, <a href="https://en.wikipedia.org/wiki/Temporal_anti-aliasing" class="bb cn kd ke kf kg">temporal anti-aliasing (TAA)</a>, and <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing" class="bb cn kd ke kf kg">multi sample anti-aliasing (MSAA)</a>. They all have their pros and cons, but there&#x2019;s one tool I don&#x2019;t feel like gets the use and respect it deserves. That tool is a feature of MSAA, Alpha to Coverage.</p><p id="707c" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">This article will be assuming you&#x2019;re using forward rendering with at least 4x MSAA. If you&#x2019;ve chosen to use deferred rendering this article will be less useful for you. Some techniques are still applicable though. If you&#x2019;ve chosen to use TAA and forward rendering this may solve one of the reasons you chose that option!</p></div></section><section class="ij ik il im in"><div class="y io x cs cq cr"><p id="31d3" class="jp jq fo bs jr b js lo ju lp jw lq jy lr ka ls kc">A very common case of aliasing is the use of alpha test, used for things like trees or bushes. Lets look at why it&#x2019;s used so much even though it causes so much aliasing.</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="v w lt"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*8EKqWSOOPXaTrDHVFTACJg.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><p id="faca" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">This is a basic plant mesh in Unity with a very basic lit alpha test shader. In Unity these are often called Cutout shaders. I&#x2019;m using the bush03 mesh and texture from <a href="https://www.assetstore.unity3d.com/en/#!/content/52977" class="bb cn kd ke kf kg">Nature Starter Kit 2</a> on the asset store if you want to try this yourself. It doesn&#x2019;t look to bad, but there&#x2019;s a lot of aliasing there from the alpha testing. Note that the above image <em class="mi">is </em>using 4x MSAA. That doesn&#x2019;t help here since this is shader aliasing which generally MSAA can&#x2019;t help with. This is something people usually fix with some extra super sampling or they give up on MSAA and use TAA instead. Or they just live with it.</p><p id="4cb5" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">What about traditional alpha blending? Seems like that should be an obvious answer, so why don&#x2019;t people use that?</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="v w lt"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*ixT6wJi1c3CaX6s9OLSNBg.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><p id="9cf7" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">That looks way better, at least in this static shot, maybe a little blurry, but the aliasing is gone! Success, right? Of course it isn&#x2019;t that easy. In motion using alpha blending for this case looks <em class="mi">really </em>wrong.</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="mk ml dg mm x"><div class="v w mj"><div class="mc l dg md"><div class="mn l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/freeze/max/60/1*c8oBU4tFHgmh1qPbB8qj-Q.gif?q=20" width="800"></div><img alt class="cu lz fm n o fl x fj" width="800"></div></div></div></div></figure><p id="7644" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">It almost looks like the bush is inside out! It&#x2019;s even more obviously wrong in VR, so this isn&#x2019;t a usable option. So what&#x2019;s happening here? Alpha blended shaders don&#x2019;t get to use per pixel depth sorting like opaque and alpha test shaders do. The bush is made from a bunch of intersecting polygons. You could sort the polygons, but they&#x2019;re still intersecting so that only helps so much. So, that&#x2019;s why we&#x2019;re stuck with using alpha test.</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="v w lt"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*krEWVM14_s1eTAN7LRomog.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><p id="5de2" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">But there <em class="mi">are </em>ways to have the benefit of both alpha test and alpha blend; a way to get per pixel depth sorting and the smooth edge. There are some two pass techniques<a href="https://link.medium.com/n2KuBMcSfZ#620e" class="bb cn kd ke kf kg">&#xB9;</a> that can work well. There are also some order independent transparency approximations, though they are potentially expensive. There&#x2019;s an even better option if you&#x2019;re using MSAA. Enter Alpha to Coverage.</p></div></section><section class="ij ik il im in"><div class="y io x cs cq cr"><p id="88e6" class="jp jq fo bs jr b js lo ju lp jw lq jy lr ka ls kc">Alpha to Coverage (sometimes referred to as A2C or ATOC) is a less commonly mentioned graphics technique. While used by several big games, it is seemingly unknown to the vast majority of smaller devs. It&#x2019;s a powerful tool that is often overlooked due to the requirement of MSAA. Games often treat MSAA as an expensive option for high end PCs. Or they&#x2019;ve used rendering techniques that don&#x2019;t allow for easy use of MSAA to begin with, like deferred rendering. The result is games have overwhelmingly preferred post process anti-aliasing like <a href="https://en.wikipedia.org/wiki/Fast_approximate_anti-aliasing" class="bb cn kd ke kf kg">FXAA</a>. This made Alpha to Coverage even more uncommon for a while. But the rise of VR has lead to the resurgence of forward rendering and of MSAA. This means A2C has become a useful tool again, especially for VR.</p><p id="5109" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">Anti-aliased alpha test is one of the most basic use cases for Alpha to Coverage. The basic idea for this has been around for as long as A2C has existed. It may even have been the original intended use for it. The first time I saw this idea was on Emil Persson&#x2019;s (better known to many as Humus) site <a href="http://www.humus.name/index.php?page=3D&amp;ID=61" class="bb cn kd ke kf kg">here</a>. I believe the method in this article is superior to the one used in his original demo.</p><h2 id="d276" class="lc kq fo bs br gg ld le lf lg lh li lj lk ll lm ln">Multi Sample Anti-Aliasing</h2><p id="15f0" class="jp jq fo bs jr b js lo ju lp jw lq jy lr ka ls kc">Before we get into that though, I&#x2019;m going to quickly run down what Alpha to Coverage <em class="mi">is</em> and why MSAA is a requirement.</p><p id="168b" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">Alpha to Coverage maps the alpha output from a pixel shader to the coverage mask of MSAA. Obvious, right?!</p><p id="466c" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">Okay, that&#x2019;s going to take a little more explanation. Be warned, I&#x2019;m going to get into some of the gritty details here.</p><p id="9336" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">The big trick with MSAA and how it differs from super sampling is what Multi Sample Anti-Aliasing is doing multiple samples <em class="mi">of</em>. Super sampling at its most basic is rendering <em class="mi">everything </em>at a higher resolution. The final on screen image is a scaled down average of this higher resolution render. MSAA renders the color at the same resolution as the target resolution, but multiple <em class="mi">coverage </em>samples per pixel. In simpler terms it&#x2019;s rendering the depth of the scene at a higher resolution than the target resolution. Each rendered triangle&#x2019;s depth samples are its coverage. If you&#x2019;re using 4x MSAA it&#x2019;s rendering 4 depth / coverage samples within the bounds of each pixel. Each coverage sample can store a unique color. But it&#x2019;s only getting a color by running the pixel shader once <em class="mi">per triangle</em>, per pixel. Most of time all 4 depth samples will be the same triangle. In this case all 4 coverage samples use the same single pixel shader output color. This behaves no different than when having no MSAA enabled at all.</p><p id="ab3f" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">Where MSAA&#x2019;s strength comes into play is when a triangle doesn&#x2019;t cover all the depth samples. For example, if a triangle only covers two depth samples the two matching coverage samples are set to the pixel shader ouput. The other coverage samples can store the color of other triangles&#x2019;s pixel shaders that can be seen.</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="mk ml dg mm x"><div class="v w mo"><div class="mc l dg md"><div class="mp l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*8ywXDlRYcSrG5A1eOHzfog.png?q=20" width="1030"></div><img alt class="cu lz fm n o fl x fj" width="1030"></div></div></div></div><figcaption class="bw du mq mr hc cs v w ms mt br dt">from <a href="https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/" class="bb cn kd ke kf kg">https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/</a></figcaption></figure><p id="c5ed" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">More in depth write ups can be found elsewhere, like on Matt Pettineo&#x2019;s (MJP) site.</p><p id="ee59" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc"><a href="https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/" class="bb cn kd ke kf kg">https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/</a></p><p id="9edd" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">I&#x2019;m glossing over a bunch of details, but the main point is MSAA can store a list of multiple colors per pixel, one color per coverage sample. These get averaged together to make the final on screen pixel color. But it&#x2019;s not always having to render a pixel shader more than once per pixel resulting in significant savings over super sampling of similar quality.</p><h2 id="1606" class="lc kq fo bs br gg ld le lf lg lh li lj lk ll lm ln">Alpha to Coverage</h2><p id="dec4" class="jp jq fo bs jr b js lo ju lp jw lq jy lr ka ls kc">This is where Alpha to Coverage comes in. Alpha to Coverage let&#x2019;s the pixel shader&#x2019;s output alpha change the fraction of coverage samples rendered to. Hence the name. In the simple case of a triangle covering all 4 depth samples, all 4 coverage samples store the color output. With Alpha to Coverage enabled and an output color alpha of 0.5, only half of the possible coverage samples will store the color. The result will be as if it&#x2019;s half<a href="https://link.medium.com/n2KuBMcSfZ#5995" class="bb cn kd ke kf kg">&#xB2;</a> as opaque as it&#x2019;s only contributing color to half the samples!</p><p id="6c45" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">Okay, so with 4x MSAA and Alpha to Coverage you get 5 levels of opacity you can play with, 4/4 through 0/4 samples. What good is that? With traditional alpha blending you get at least 256 levels, so why would you ever want to use this? Because with Alpha to Coverage those coverage samples are opaque. That means they can be depth sorted! You can have a mesh of polygon soup and have intersecting triangles accurately sort at better than per pixel accuracy. This is no different than opaque objects or even alpha test with MSAA, but you also get soft edges.</p><p id="0362" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">Lets just turn Alpha to Coverage on and see how that looks. In Unity&#x2019;s ShaderLab it&#x2019;s enabled by just adding <code class="md mu mv mw b">AlphaToMask On</code> to an otherwise opaque shader that outputs alpha. So here we go &#x2026;</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="v w lt"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*ERfxfVWyO9yP9xHBSI47wA.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><p id="8240" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">And we&#x2019;re done, doesn&#x2019;t that look so much better than before?! Lets compare it to the original alpha test version!</p></div><div class="dw"><div class="ar dx"><div class="mx my mz na nb nc eb nd ec ne x"><p class="lu"><figure class="ng dw nh ni nj nk nl paragraph-image"><div class="mk ml dg mm x"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*8EKqWSOOPXaTrDHVFTACJg.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><figure class="ng dw nh ni nj nk nl paragraph-image"><div class="mk ml dg mm x"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*ERfxfVWyO9yP9xHBSI47wA.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure></p></div></div></div><div class="y io x cs cq cr"><p id="d4eb" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">Wait, no, Alpha to Coverage looks terrible! It&#x2019;s somehow simultaneously fuzzy and aliased, not to mention sort of noisy, and seems like the bush got more transparent through the middle? The story only gets worse when we get close up to those leaves.</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="v w lt"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*4D4vRF4-8Qvxy7l0Sr1_uA.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><p id="7b0f" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">Oy vey, that&#x2019;s no good at all. The limited number of opacity steps makes for some ugly banding. Clearly there&#x2019;s a reason why this isn&#x2019;t used more often, so why would I even suggest doing this if it looks so bad?!</p><h2 id="c66b" class="lc kq fo bs br gg ld le lf lg lh li lj lk ll lm ln">Fixing the Solution</h2><p id="8750" class="jp jq fo bs jr b js lo ju lp jw lq jy lr ka ls kc">Well, because that&#x2019;s what happens if you use Alpha to Coverage with the alpha of the texture straight. This is what replacing basic alpha blending using alpha to coverage looks like. Many implementations of Alpha to Coverage I&#x2019;ve seen in games really do leave it here.</p><p id="20a3" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">But what&#x2019;s happening in that first alpha to coverage image to make it so bad? It&#x2019;s not just the banding, it&#x2019;s also the interaction between the coverage samples. In short it&#x2019;s a limitation of using Alpha to Coverage. Essentially when using Alpha to Coverage only &#x201C;one layer&#x201D; of a specific coverage can be seen at one time. Two or more overlapping triangles with 50% Alpha to Coverage results in no change in opacity. Only the closest coverage points get rendered. This is unlike alpha blending where they will blend over each other increasing the perceived opacity. If you remember earlier I said the coverage samples are individually opaque. If the output alpha is 50% with 4x MSAA only two coverage samples are written to. But it&#x2019;s going to be the <em class="mi">same</em> two coverage samples for everything that renders to that pixel with 50% A2C! The answer might seem like &#x201C;well, render to different samples!&#x201D;. But that&#x2019;s harder than it sounds to do and be effective. It is an option though. Or you might be thinking &#x201C;nope, still don&#x2019;t get it at all&#x201D;, and that&#x2019;s okay. Don&#x2019;t worry about it. It&#x2019;s unnecessary to understand for this particular case as it&#x2019;s relatively easy to solve.</p><p id="39c9" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">So what is the solution here? Alpha to Coverage is great for anti-aliasing alpha <em class="mi">test</em>, not so much for replacing an alpha blend! We need to sharpen the alpha so there are fewer overlapping areas of partial opacity. This will simultaneously solve the banding, and interior transparency. Anyone who&#x2019;s done signed distance field text, or shader based line rendering probably knows whats coming next. For everyone else I&#x2019;m going to introduce you to one of my favorite functions in shaders:</p><p id="b534" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc"><code class="md mu mv mw b">fwidth()</code></p><p id="ed21" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">With out further explanation we get this (I&#x2019;ll talk about it later):</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="v w lt"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*nRI3S7Kq7G9-JLNnwsYEkQ.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="v w lt"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*zu3SAj1FZ1C8cUyBDvCTUQ.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><p id="a6f4" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">Now that&#x2019;s better. Looks very similar to the original alpha tested version, but is nicely anti-aliased. And it&#x2019;s not strangely transparent, noisy, or blurry anymore! Here&#x2019;s the original alpha tested version one more time for reference.</p></div><div class="dw"><div class="ar dx"><div class="mx my mz na nb nc eb nd ec ne x"><p class="lu"><figure class="ng dw nh ni nj nk nl paragraph-image"><div class="mk ml dg mm x"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*8EKqWSOOPXaTrDHVFTACJg.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><figure class="ng dw nh ni nj nk nl paragraph-image"><div class="mk ml dg mm x"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*zu3SAj1FZ1C8cUyBDvCTUQ.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure></p></div></div></div><div class="y io x cs cq cr"><p id="911c" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">So, what did I do? What was that <code class="md mu mv mw b">fwidth()</code> I mentioned earlier? All the magic is in this one line of shader code.</p><pre class="lu lv lw lx ly ha el nm"><span id="cd30" class="lc kq fo bs mw b du nn no l np">col.a = (col.a - _Cutoff) / max(fwidth(col.a), 0.0001) + 0.5;</span></pre><p id="41e8" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">What that line does is sharpens the alpha of the texture to the width of a single pixel. The <code class="md mu mv mw b">fwidth()</code> function returns the sum of the pixel&#x2019;s partial derivatives for a value, usually described as the equivalent of <code class="md mu mv mw b">abs(ddx(value)) + abs(ddy(value))</code>. Those two functions, <code class="md mu mv mw b">ddx()</code> and <code class="md mu mv mw b">ddy()</code>, are partial derivative functions. They measure the change of a value between the two pixels either to the side or above<a href="https://link.medium.com/n2KuBMcSfZ#68b9" class="bb cn kd ke kf kg">&#xB3;</a> the pixel that&#x2019;s currently being processed. Derivatives are wonderful, magical things in shaders. For the moment it&#x2019;s enough to know <code class="md mu mv mw b">fwidth()</code> gives a good approximation of how much a value changes per pixel. If you divide a value by how much it&#x2019;s changing it&#x2019;ll rescale it to give you a nice crisp edge. The <code class="md mu mv mw b">max()</code> is there because if the texture&#x2019;s alpha is a flat color at some point, like black or white, <code class="md mu mv mw b">fwidth()</code> will be zero. Dividing by zero is bad! The 0.0001 is just an arbitrarily small number, small enough that you have to really get close to a texture before the banding will show up again. The <code class="md mu mv mw b">_Cutoff </code>is the same value you would be using for an alpha test shader and helps center the alpha around the edge you want.</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="v w nq"><div class="mc l dg md"><div class="nr l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*Ugf2jtGvo5dyfOx-ma-Lvw.png?q=20" width="600"></div><img alt class="cu lz fm n o fl x fj" width="600"></div></div></div></figure><p id="64d6" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">We could end here, but another problem that will show up that most people will probably miss initially. It is an issue that plagues alpha test already, so people might just be living with it. As you get far away from an object using alpha test it&#x2019;ll appear to shrink and eventually vanish. Alpha blending does not suffer from this.</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="mk ml dg mm x"><div class="v w ns"><div class="mc l dg md"><div class="nt l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/freeze/max/60/1*IDnS5V6FMWbsIGf_Ek2z_g.gif?q=20" width="780"></div><img alt class="cu lz fm n o fl x fj" width="780"></div></div></div></div></figure><p id="7f5c" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">The cause is the texture&#x2019;s mip mapping making the alpha fade out from averaging. Since the alpha is fading out that hard &#x201C;cutoff&#x201D; edge is vanishing too.</p><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="mk ml dg mm x"><div class="v w nu"><div class="mc l dg md"><div class="nr l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*YWa1Vh49IxfUMDBseVwMjg.png?q=20" width="768"></div><img alt class="cu lz fm n o fl x fj" width="768"></div></div></div></div><figcaption class="bw du mq mr hc cs v w ms mt br dt">Texture mip mapping, Alpha Blend (top) vs Alpha Test (bottom)</figcaption></figure><p id="d0c5" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">There are several workarounds to this problem. Lowering the cutoff value (a common solution for alpha testing in general). Super sampling in the shader (I do this for font rendering). Or using some kind of noise like stochastic sampling or <a href="https://casual-effects.com/research/Wyman2017Hashed/index.html" class="bb cn kd ke kf kg">hashed alpha testing</a>. Probably the best solution is the one proposed by Ignacio Casta&#xF1;o on The Witness blog back in 2010. It requires recalculating each mip maps&#x2019; alpha values in a way that&#x2019;s aware of it&#x2019;s intended use for alpha testing or Alpha to Coverage. The Witness uses A2C for foliage as well as several other effects too.</p><p id="17db" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">It has the great advantage of being &#x201C;free&#x201D; since all of the work is done before hand and there&#x2019;s nothing the shader has to do. For Unity it could be implemented with an asset post processor or an editor script.</p><p id="3ab3" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc"><em class="mi">Edit: S&#xE9;bastien Lagarde brought to my attention the fact that Ignacio&#x2019;s technique is now available as an official texture import option in Unity 2017.1! There&#x2019;s now a Mip Maps Preserve Coverage check box.</em></p><p id="b265" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">But there is another way that works almost as well, scaling the alpha by mip level. Effectively that&#x2019;s what the above solution is doing, so we can just do an approximation the shader. It&#x2019;s not &#x201C;free&#x201D;, but it&#x2019;s not that expensive either.</p><pre class="lu lv lw lx ly ha el nm"><span id="cc34" class="lc kq fo bs mw b du nn no l np">col.a *= 1 + CalcMipLevel(i.uv * _MainTex_TexelSize.zw) * _MipScale;</span></pre><figure class="lu lv lw lx ly dw v w paragraph-image"><div class="mk ml dg mm x"><div class="v w ns"><div class="mc l dg md"><div class="nt l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/freeze/max/60/1*zNbZFiJXjcqqyTkM9eEt7w.gif?q=20" width="780"></div><img alt class="cu lz fm n o fl x fj" width="780"></div></div></div></div></figure><p id="f107" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">We can approximate the loss of density from mip mapping almost perfectly with a <code class="md mu mv mw b">_MipScale</code> of <code class="md mu mv mw b">0.25</code>. The <code class="md mu mv mw b">CalcMipLevel()</code> function is the magic here. You can see the implementation of the function in the shader code below. Note if you use any kind of LOD bias on your textures you&#x2019;ll have to account for this manually. If you want more information about the function you can read this Stack Overflow post:</p><p id="47a1" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc"><a href="https://stackoverflow.com/questions/24388346/how-to-access-automatic-mipmap-level-in-glsl-fragment-shader-texture" class="bb cn kd ke kf kg">https://stackoverflow.com/questions/24388346/how-to-access-automatic-mipmap-level-in-glsl-fragment-shader-texture</a></p><p id="8fee" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">The same scaling trick works for alpha test as well. In fact if MSAA is disabled Alpha to Coverage falls back to alpha test. This means it isn&#x2019;t only useful for VR or other games where you&#x2019;re guaranteed to have MSAA enabled. Basically there&#x2019;s rarely a reason to use straight alpha testing ever!</p></div></section><section class="ij ik il im in"><div class="y io x cs cq cr"><p id="a13d" class="jp jq fo bs jr b js lo ju lp jw lq jy lr ka ls kc">You don&#x2019;t need to live with the aliasing of alpha test, the sorting issues of alpha blend, or the cost of a two pass shader. There is a happy middle ground using Alpha to Coverage. If you&#x2019;re using MSAA you should never need to use alpha test again!</p></div></section><section class="ij ik il im in"><div class="y io x cs cq cr"><p id="fc25" class="jp jq fo bs jr b js lo ju lp jw lq jy lr ka ls kc">The Unity ShaderLab file for the final shader used in this article can be found below.</p><pre class="lu lv lw lx ly ha el nm"><div id="2164" class="lc">Shader &quot;Custom/Alpha To Coverage&quot;{ Properties { _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {} _Cutoff (&quot;Alpha cutoff&quot;, Range(0.15,0.85)) = 0.4 _MipScale (&quot;Mip Level Alpha Scale&quot;, Range(0,1)) = 0.25 } SubShader { Tags { &quot;RenderQueue&quot;=&quot;AlphaTest&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot; } Cull Off Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } AlphaToMask On CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; #include &quot;Lighting.cginc&quot; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; half3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; half3 worldNormal : NORMAL; }; sampler2D _MainTex; float4 _MainTex_ST; float4 _MainTex_TexelSize; fixed _Cutoff; half _MipScale; float CalcMipLevel(float2 texture_coord) { float2 dx = ddx(texture_coord); float2 dy = ddy(texture_coord); float delta_max_sqr = max(dot(dx, dx), dot(dy, dy)); return max(0.0, 0.5 * log2(delta_max_sqr)); } v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); o.worldNormal = UnityObjectToWorldNormal(v.normal); return o; } fixed4 frag (v2f i, fixed facing : VFACE) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv); // rescale alpha by mip level (if not using preserved coverage mip maps) col.a *= 1 + max(0, CalcMipLevel(i.uv * _MainTex_TexelSize.zw)) * _MipScale; // rescale alpha by partial derivative col.a = (col.a - _Cutoff) / max(fwidth(col.a), 0.0001) + 0.5; half3 worldNormal = normalize(i.worldNormal * facing); fixed ndotl = saturate(dot(worldNormal, normalize(_WorldSpaceLightPos0.xyz))); fixed3 lighting = ndotl * _LightColor0; lighting += ShadeSH9(half4(worldNormal, 1.0)); col.rgb *= lighting; return col; } ENDCG } }<p>}</p></div></pre><h2 id="560d" class="lc kq fo bs br gg ld le lf lg lh li lj lk ll lm ln">Unity&#x2019;s Surface Shaders &amp; Directional Shadows</h2><p id="434f" class="jp jq fo bs jr b js lo ju lp jw lq jy lr ka ls kc">Many peoples&#x2019; first inclination is probably going to be to try this technique in Unity with a surface shader by adding <code class="md mu mv mw b">AlphaToMask On</code>. This does work, but it breaks shadow casting and receiving if you use the <code class="md mu mv mw b">addshadow</code> surface option due to Unity&#x2019;s default shadow caster passes outputing 0% alpha and <code class="md mu mv mw b">AlphaToMask On</code> still being enabled for the generated pass. You can use <code class="md mu mv mw b">Fallback &#x201C;Legacy Shaders/Transparent/Cutout/VertexLit&#x201D;</code> instead as fallback passes don&#x2019;t inherent the parent shader file&#x2019;s render settings, but it won&#x2019;t do the mip level alpha rescaling so it might look odd in the distance unless you use a custom shadow caster pass. Even then Unity&#x2019;s directional shadows will sometimes cause bright and dark noise around the edges or seemingly disable anti-aliasing since their directional shadows are rendered with out MSAA. This is one of the reasons why MSAA never seems to work as well as you might expect it to in Unity. You can disable shadow cascades in the Graphics settings, but then the shadows don&#x2019;t look as nice. It does mean if you&#x2019;re not using real time directional shadows on the PC or consoles, or you&#x2019;re working on a mobile project, this technique works great. Upcoming changes to Unity&#x2019;s forward renderer will also likely solve this.</p><p id="1860" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">There is a work around for getting shadow cascades and MSAA working together better, which I used for <a href="http://www.uberent.com/waywardsky/" class="bb cn kd ke kf kg">Wayward Sky</a> and <a href="http://www.uberent.com/dinofrontier/" class="bb cn kd ke kf kg">Dino Frontier</a> (both out now for the PSVR). But that is for another article. I posted the basic idea on the Unity forums <a href="https://forum.unity3d.com/threads/fixing-screen-space-directional-shadows-and-anti-aliasing.379902/" class="bb cn kd ke kf kg">here</a> for those curious.</p></div><div class="dw"><div class="ar dx"><div class="mx my mz na nb nc eb nd ec ne x"><p class="lu"><figure class="ng dw or ni nj nk nl paragraph-image"><div class="mk ml dg mm x"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*BOaybXT4L0rKNb0fTG72BQ.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><figure class="ng dw or ni nj nk nl paragraph-image"><div class="mk ml dg mm x"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*N00jL_UBLENog-gm5rBAFQ.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div></figure><figure class="ng dw or ni nj nk nl paragraph-image"><div class="mk ml dg mm x"><div class="mc l dg md"><div class="me l"><div class="cu lz fm n o fl x jg ma mb"><img alt class="fm n o fl x mf mg mh" src="https://miro.medium.com/max/60/1*hx1DgLXUW51nZI-4WDg5hw.png?q=20" width="640"></div><img alt class="cu lz fm n o fl x fj" width="640"></div></div></div><figcaption class="bw du mq mr hc cs v w ms mt br dt os dg ot ou">artifacts and apparent loss of anti-aliasing from Unity&#x2019;s cascaded shadow maps (left); cascades disabled in Graphics settings (center); cascades and MSAA with fix (right)</figcaption></figure></p></div></div></div></section><section class="ij ik il im in"><div class="y io x cs cq cr"><p id="620e" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">&#xB9;<a href="https://link.medium.com/n2KuBMcSfZ#5de2" class="bb cn kd ke kf kg">^</a>Rendering an object once using an alpha test pass, and again with an alpha blend pass is a good solution, especially if you don&#x2019;t have MSAA. There are plenty of places that have discussed this technique, like Wolfire Games&#x2019; blog <a href="http://blog.wolfire.com/2009/02/rendering-plants-with-smooth-edges/" class="bb cn kd ke kf kg">here</a> (which also mentions an Alpha to Coverage like technique) and even Unity&#x2019;s documentation on <a href="https://docs.unity3d.com/Manual/SL-AlphaTest.html" class="bb cn kd ke kf kg">Legacy Alpha Testing</a>. Interestingly, Alpha to Coverage can be used leverage the two pass technique for softer blending than is normally possible with Alpha to Coverage alone, so effectively getting the benefits of Alpha to Coverage and alpha blending. It&#x2019;s mentioned briefly on Luis Antonio&#x2019;s site in a post about the clouds in The Witness. It&#x2019;s actually a section written by Ignacio Casta&#xF1;o again.</p><p id="2c09" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc"><a href="http://www.artofluis.com/3d-work/the-art-of-the-witness/clouds/" class="bb cn kd ke kf kg">http://www.artofluis.com/3d-work/the-art-of-the-witness/clouds/</a></p><p id="5995" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">&#xB2;<a href="https://link.medium.com/n2KuBMcSfZ#dec4" class="bb cn kd ke kf kg">^</a>Two coverage samples result in something similar to 50% opaque, but only if using gamma (aka sRGB) color space rendering. Otherwise if you&#x2019;re using linear color space rendering and not using a custom resolver it&#x2019;s more like ~74% alpha, or ~188/255, which if you&#x2019;re familiar with linear to gamma conversions might look familiar.</p><p id="68b9" class="jp jq fo bs jr b js jt ju jv jw jx jy jz ka kb kc">&#xB3;<a href="https://link.medium.com/n2KuBMcSfZ#41e8" class="bb cn kd ke kf kg">^</a>Pixel derivatives work in blocks of 2x2 pixels, so <code class="md mu mv mw b">fwidth()</code> might be comparing the pixel above or below, and the pixel to the left or right, depending on which pixel in the 2x2 block the pixel/fragment shader is currently running. The <code class="md mu mv mw b">ddx()</code> and <code class="md mu mv mw b">ddy()</code> functions individually give the horizontal and vertical partial derivatives. These are always compared in the same order, so the <code class="md mu mv mw b">ddx()</code> and <code class="md mu mv mw b">ddy()</code> values for each pair of pixels is the same. Depending on the implementation it may even be the same values for all four pixels in the 2x2 grid. Basically 4 instances of a pixel/fragment shader is running in parallel always, even if a triangle is only covering one of those pixels.</p></div></section></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>