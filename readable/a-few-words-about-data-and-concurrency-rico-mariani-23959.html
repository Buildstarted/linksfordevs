<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A few words about data and concurrency</title>
<div class="readable">
        <h1>A few words about data and concurrency</h1>
        <p>
by Rico Mariani <br/>Reading time: 7-9 minutes        </p>
        <p><a href="https://medium.com/@ricomariani/a-few-words-about-data-and-concurrency-cc16c6294440?source=friends_link&amp;sk=dd6b701bc8dc15a05bf786b4f7ac0a5a">https://medium.com/@ricomariani/a-few-words-about-data-and-concurrency-cc16c6294440?source=friends_link&amp;sk=dd6b701bc8dc15a05bf786b4f7ac0a5a</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><div><a rel="noopener" href="https://medium.com/@ricomariani?source=post_page-----cc16c6294440----------------------"><div><p><img alt="Rico Mariani" src="https://miro.medium.com/fit/c/48/48/1*Tu7FyWs_jnYLC-quD-e5IQ.jpeg" width="48" height="48"></p></div></a></div></div></div></div></div><p id="46e9" data-selectable-paragraph="">‚ÄúI need an atomic integer‚Äù</p><p id="9f9b" data-selectable-paragraph="">Oh Lord, here we go.</p><p id="226a" data-selectable-paragraph="">I find it completely astonishing observing what people think they need with regard to concurrent constructs and especially data sharing. It‚Äôs super hard to even understand all the considerations, even for experts, which is why not sharing data between threads at all has to be the first line of defense.</p><p id="b364" data-selectable-paragraph="">But ok, you want to go there, I strongly recommend you don‚Äôt, but at least let me tell you what some of the concerns are and maybe I will scare you out of it. That would be good.</p><p id="1917" data-selectable-paragraph="">This is a good place to remind everyone that what I‚Äôm going to write is only approximately correct, mainly in the interest of brevity.</p><p id="cf92" data-selectable-paragraph=""><strong>Primitives are already atomic for simple read/write</strong></p><p id="4c4e" data-selectable-paragraph="">In virtually all the cases you will encounter on any modern processor every primitive type (e.g. int) is an atomic read or write. It writes or it doesn‚Äôt. Most times when people are talking about atomic primitives they actually aren‚Äôt referring to atomicity at all, but maybe ordering or observability.</p><p id="b682" data-selectable-paragraph="">Why call it this at all? Well, maybe because of some of the elementary operations you can expect on an ‚Äúatomic‚Äù type. Even if integer storage is atomic, incrementing it might not be, it‚Äôs a read-modify-write operation. So maybe you‚Äôd like to have something that you can ++ that has an atomic++ operator on it. You might call that an atomic int right? So I guess the question is, what are the atomic operations you want? How are they offered? Do you want/need a datatype for that?</p><p id="e1ce" data-selectable-paragraph="">There are some notable exceptions to atomicity. Generally it requires natural alignment of the data type in question (else it might take two writes to update it) and it must be a processor supported type (e.g. some 32 bit systems have C compilers that offer 64 bit integers, but they aren‚Äôt a primitive type as far as the processor is concerned).</p><p id="cddc" data-selectable-paragraph=""><strong>Can‚Äôt I just fix everything by sprinkling volatile everywhere?</strong></p><p id="e1df" data-selectable-paragraph="">Well, no, actually most of the time people don‚Äôt even know what it does and it most likely won‚Äôt help you by itself. Briefly, the volatile keyword tells the compiler that the value in question might change without the code seeming to do anything. Classically this was because you were storing something like the address of a memory mapped timer device in a variable.</p><pre><span id="633b" data-selectable-paragraph="">int *timer = (int *)0xF0001122;</span><span id="353a" data-selectable-paragraph="">int time1 = *timer;</span><span id="cf24" data-selectable-paragraph="">...</span><span id="246f" data-selectable-paragraph="">int time2 = *timer;</span></pre><p id="c4f1" data-selectable-paragraph="">A clever compiler might remove the second timer read noting that you read the same address and nothing modified it in between. The following was designed to prevent just such a thing.</p><pre><span id="417c" data-selectable-paragraph="">volatile int *timer = (int *)0xF0001122;</span><span id="4600" data-selectable-paragraph="">int time1 = *timer;</span><span id="9357" data-selectable-paragraph="">...</span><span id="8e2f" data-selectable-paragraph="">int time2 = *timer;</span></pre><p id="2cbb" data-selectable-paragraph="">When volatile is used it tells the compiler that it may not elide any reads/writes from/to the pointer. It must emit exactly one read/write for each appearance in the code and it may not reorder them relative to other volatile operations. Note the consequences of getting this wrong can be very painful. This loop for instance could be quite bad if the timer wasn‚Äôt read on every iteration:</p><pre><span id="3a11" data-selectable-paragraph="">int *timer = (int *)0xF0001122;</span><span id="8405" data-selectable-paragraph="">*timer = 0;</span><span id="1589" data-selectable-paragraph="">while (*timer &lt; 1000) ;  // ultra dumb example (might spin forever)</span></pre><p id="da7b" data-selectable-paragraph="">Concurrent programming can provide similar kinds of ‚Äúchanged when I wasn‚Äôt looking‚Äù behavior because some other thread might be modifying the timer variable. Some compilers (e.g. MSC) were changed to include certain processor memory fences on volatile reads and writes to help with that. Those things are generally gone now. You‚Äôre left with <em>volatile means read and write exactly the number of times I specify and never skip or reorder a read or write</em>.</p><p id="240d" data-selectable-paragraph=""><strong>Some microprocessor basics</strong></p><p id="2543" data-selectable-paragraph="">To understand what‚Äôs left, you have to know a few things about modern processors with multiple cores and therefore multiple concurrent threads of execution.</p><ul><li id="635a" data-selectable-paragraph="">when you write data, the data might not be written immediately, processors routinely queue up writes and flush them when it‚Äôs convenient</li><li id="714c" data-selectable-paragraph="">the processor might not flush the writes in the order that you did the writing</li><li id="5f8e" data-selectable-paragraph=""><em>on any given thread of execution</em> if you write data and read it back you will see what you wrote, even if it hasn‚Äôt been flushed yet, the processor lies :)</li><li id="d319" data-selectable-paragraph="">any other thread looking at the same data might see a previous value because a pending write has not yet retired</li><li id="14b9" data-selectable-paragraph="">you might see writes ‚Äúout of order‚Äù because of the processor shenanigans above</li></ul><p id="bb49" data-selectable-paragraph="">Sometimes when people want to avoid these problems they say ‚ÄúI need an atomic int‚Äù ‚Äî atomicity probably isn‚Äôt what they need at all, it‚Äôs some kind of write ordering guarantee.</p><p id="b0ae" data-selectable-paragraph="">Let me give you a concrete semi-realistic scenario. Suppose I have a simple linked list and one thread adding items to it periodically. For simplicity items are never removed.</p><p id="d856" data-selectable-paragraph="">The writing thread does this:</p><pre><span id="73d8" data-selectable-paragraph="">Foo *head;</span><span id="69de" data-selectable-paragraph="">Foo *foo = malloc(sizeof(Foo));</span><span id="bfa2" data-selectable-paragraph="">foo-&gt;data = 1;<br>foo-&gt;next = head;<br>head = foo;<br></span></pre><p id="e5e1" data-selectable-paragraph="">You might be forgiven for thinking that this is a safe thing to do. After all, you safely make a nice fresh foo, then you set it up, and finally point the head at it atomically. The other thread will either see the new head or it won‚Äôt, and if you don‚Äôt care about a little delay all is well. It will see the new head soon enough. Right?</p><p id="f34e" data-selectable-paragraph="">Well, no. There are several problems here.</p><p id="9f73" data-selectable-paragraph="">There are three writes here, foo-&gt;data, foo-&gt;next, and head. They can be retired in any order. So there is some chance that the reading thread will see the new head before it sees the new foo-&gt;next. That‚Äôs bad because there‚Äôs junk in your foo object at that point‚Ä¶ Similarly foo-&gt;data might still have junk in it.</p><p id="69fc" data-selectable-paragraph="">So another service sometimes provided by ‚Äúatomic‚Äù primitives is some kind of write-barrier. Applying this to head would effectively turn the code into something like this:</p><pre><span id="4a28" data-selectable-paragraph="">foo-&gt;data = 1;<br>foo-&gt;next = head;</span><span id="5f0f" data-selectable-paragraph="">_flush_primitive();<br>head = foo;</span></pre><p id="cb8b" data-selectable-paragraph="">Which means that if you see the new head you will for sure also see the other writes that preceded it. The symmetric thing can be done on the reader side. This are sometimes called ‚Äúload acquire‚Äù and ‚Äústore release‚Äù semantics (store release shown above.)</p><p id="68d2" data-selectable-paragraph="">Importantly, if there is no data ordering necessary, then none of this is needed. For instance if you want to tell a background thread that your user did something and you have no other actions to take no synchronization is needed at all! But this is tricky business. Allow me to illustrate:</p><pre><span id="f6d8" data-selectable-paragraph="">int user_did_it = 0;</span><span id="4c99" data-selectable-paragraph="">// user does something<br>user_did_it = 1;</span><span id="101f" data-selectable-paragraph="">// sometime later, on a different thread<br>if (user_did_it) { coolness_ensues(); }</span></pre><p id="3f37" data-selectable-paragraph="">That‚Äôs fair enough, but this code which is nearly the same won‚Äôt work:</p><pre><span id="a0e6" data-selectable-paragraph="">int user_did_it = 0;</span><span id="e6dc" data-selectable-paragraph="">// user does something<br>prepare_for_coolness();<br>user_did_it = 1;</span><span id="8e53" data-selectable-paragraph="">// sometime later, on a different thread<br>if (user_did_it) { coolness_ensues(); }</span></pre><p id="2ab0" data-selectable-paragraph="">The problem being that the background thread might not see the prepared coolness before it sees user_did_it. Now you need a fence at least.</p><p id="80c1" data-selectable-paragraph="">And I left off all the volatiles that are needed so that the compiler won‚Äôt mess it all up.</p><p id="ffb7" data-selectable-paragraph=""><strong>Summary</strong></p><ul><li id="d76d" data-selectable-paragraph="">volatile gives you a fighting chance at getting concurrency correct because it prevents the compiler from removing and/or reordering and rewriting your operations.</li><li id="d55f" data-selectable-paragraph="">volatile isn‚Äôt sufficient because the processor is also reordering writes, so you need some operations that give you more sane memory order guarantees</li><li id="cb67" data-selectable-paragraph="">sometimes these are called ‚Äúatomic‚Äù services but they often have very little to do with atomicity (except maybe atomic ++ operators and such)</li></ul><p id="7eec" data-selectable-paragraph="">In general this stuff is fantastically hard to get right and so you basically never want to do it. It‚Äôs hard enough to get simple critical sections correct‚Ä¶</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>