<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A few words about data and concurrency - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="A few words about data and concurrency - linksfor.dev(s)"/>
    <meta property="article:author" content="Rico Mariani"/>
    <meta property="og:description" content="&#x201C;I need an atomic integer&#x201D;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@ricomariani/a-few-words-about-data-and-concurrency-cc16c6294440?sk=dd6b701bc8dc15a05bf786b4f7ac0a5a"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A few words about data and concurrency</title>
<div class="readable">
        <h1>A few words about data and concurrency</h1>
            <div>by Rico Mariani</div>
            <div>Reading time: 7-9 minutes</div>
        <div>Posted here: 16 May 2019</div>
        <p><a href="https://medium.com/@ricomariani/a-few-words-about-data-and-concurrency-cc16c6294440?sk=dd6b701bc8dc15a05bf786b4f7ac0a5a">https://medium.com/@ricomariani/a-few-words-about-data-and-concurrency-cc16c6294440?sk=dd6b701bc8dc15a05bf786b4f7ac0a5a</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><div><a rel="noopener" href="https://medium.com/@ricomariani?source=post_page-----cc16c6294440----------------------"><div><p><img alt="Rico Mariani" src="https://miro.medium.com/fit/c/48/48/1*Tu7FyWs_jnYLC-quD-e5IQ.jpeg" width="48" height="48"></p></div></a></div></div></div></div></div><p id="46e9" data-selectable-paragraph="">“I need an atomic integer”</p><p id="9f9b" data-selectable-paragraph="">Oh Lord, here we go.</p><p id="226a" data-selectable-paragraph="">I find it completely astonishing observing what people think they need with regard to concurrent constructs and especially data sharing. It’s super hard to even understand all the considerations, even for experts, which is why not sharing data between threads at all has to be the first line of defense.</p><p id="b364" data-selectable-paragraph="">But ok, you want to go there, I strongly recommend you don’t, but at least let me tell you what some of the concerns are and maybe I will scare you out of it. That would be good.</p><p id="1917" data-selectable-paragraph="">This is a good place to remind everyone that what I’m going to write is only approximately correct, mainly in the interest of brevity.</p><p id="cf92" data-selectable-paragraph=""><strong>Primitives are already atomic for simple read/write</strong></p><p id="4c4e" data-selectable-paragraph="">In virtually all the cases you will encounter on any modern processor every primitive type (e.g. int) is an atomic read or write. It writes or it doesn’t. Most times when people are talking about atomic primitives they actually aren’t referring to atomicity at all, but maybe ordering or observability.</p><p id="b682" data-selectable-paragraph="">Why call it this at all? Well, maybe because of some of the elementary operations you can expect on an “atomic” type. Even if integer storage is atomic, incrementing it might not be, it’s a read-modify-write operation. So maybe you’d like to have something that you can ++ that has an atomic++ operator on it. You might call that an atomic int right? So I guess the question is, what are the atomic operations you want? How are they offered? Do you want/need a datatype for that?</p><p id="e1ce" data-selectable-paragraph="">There are some notable exceptions to atomicity. Generally it requires natural alignment of the data type in question (else it might take two writes to update it) and it must be a processor supported type (e.g. some 32 bit systems have C compilers that offer 64 bit integers, but they aren’t a primitive type as far as the processor is concerned).</p><p id="cddc" data-selectable-paragraph=""><strong>Can’t I just fix everything by sprinkling volatile everywhere?</strong></p><p id="e1df" data-selectable-paragraph="">Well, no, actually most of the time people don’t even know what it does and it most likely won’t help you by itself. Briefly, the volatile keyword tells the compiler that the value in question might change without the code seeming to do anything. Classically this was because you were storing something like the address of a memory mapped timer device in a variable.</p><pre><span id="633b" data-selectable-paragraph="">int *timer = (int *)0xF0001122;</span><span id="353a" data-selectable-paragraph="">int time1 = *timer;</span><span id="cf24" data-selectable-paragraph="">...</span><span id="246f" data-selectable-paragraph="">int time2 = *timer;</span></pre><p id="c4f1" data-selectable-paragraph="">A clever compiler might remove the second timer read noting that you read the same address and nothing modified it in between. The following was designed to prevent just such a thing.</p><pre><span id="417c" data-selectable-paragraph="">volatile int *timer = (int *)0xF0001122;</span><span id="4600" data-selectable-paragraph="">int time1 = *timer;</span><span id="9357" data-selectable-paragraph="">...</span><span id="8e2f" data-selectable-paragraph="">int time2 = *timer;</span></pre><p id="2cbb" data-selectable-paragraph="">When volatile is used it tells the compiler that it may not elide any reads/writes from/to the pointer. It must emit exactly one read/write for each appearance in the code and it may not reorder them relative to other volatile operations. Note the consequences of getting this wrong can be very painful. This loop for instance could be quite bad if the timer wasn’t read on every iteration:</p><pre><span id="3a11" data-selectable-paragraph="">int *timer = (int *)0xF0001122;</span><span id="8405" data-selectable-paragraph="">*timer = 0;</span><span id="1589" data-selectable-paragraph="">while (*timer &lt; 1000) ;  // ultra dumb example (might spin forever)</span></pre><p id="da7b" data-selectable-paragraph="">Concurrent programming can provide similar kinds of “changed when I wasn’t looking” behavior because some other thread might be modifying the timer variable. Some compilers (e.g. MSC) were changed to include certain processor memory fences on volatile reads and writes to help with that. Those things are generally gone now. You’re left with <em>volatile means read and write exactly the number of times I specify and never skip or reorder a read or write</em>.</p><p id="240d" data-selectable-paragraph=""><strong>Some microprocessor basics</strong></p><p id="2543" data-selectable-paragraph="">To understand what’s left, you have to know a few things about modern processors with multiple cores and therefore multiple concurrent threads of execution.</p><ul><li id="635a" data-selectable-paragraph="">when you write data, the data might not be written immediately, processors routinely queue up writes and flush them when it’s convenient</li><li id="714c" data-selectable-paragraph="">the processor might not flush the writes in the order that you did the writing</li><li id="5f8e" data-selectable-paragraph=""><em>on any given thread of execution</em> if you write data and read it back you will see what you wrote, even if it hasn’t been flushed yet, the processor lies :)</li><li id="d319" data-selectable-paragraph="">any other thread looking at the same data might see a previous value because a pending write has not yet retired</li><li id="14b9" data-selectable-paragraph="">you might see writes “out of order” because of the processor shenanigans above</li></ul><p id="bb49" data-selectable-paragraph="">Sometimes when people want to avoid these problems they say “I need an atomic int” — atomicity probably isn’t what they need at all, it’s some kind of write ordering guarantee.</p><p id="b0ae" data-selectable-paragraph="">Let me give you a concrete semi-realistic scenario. Suppose I have a simple linked list and one thread adding items to it periodically. For simplicity items are never removed.</p><p id="d856" data-selectable-paragraph="">The writing thread does this:</p><pre><span id="73d8" data-selectable-paragraph="">Foo *head;</span><span id="69de" data-selectable-paragraph="">Foo *foo = malloc(sizeof(Foo));</span><span id="bfa2" data-selectable-paragraph="">foo-&gt;data = 1;<br>foo-&gt;next = head;<br>head = foo;<br></span></pre><p id="e5e1" data-selectable-paragraph="">You might be forgiven for thinking that this is a safe thing to do. After all, you safely make a nice fresh foo, then you set it up, and finally point the head at it atomically. The other thread will either see the new head or it won’t, and if you don’t care about a little delay all is well. It will see the new head soon enough. Right?</p><p id="f34e" data-selectable-paragraph="">Well, no. There are several problems here.</p><p id="9f73" data-selectable-paragraph="">There are three writes here, foo-&gt;data, foo-&gt;next, and head. They can be retired in any order. So there is some chance that the reading thread will see the new head before it sees the new foo-&gt;next. That’s bad because there’s junk in your foo object at that point… Similarly foo-&gt;data might still have junk in it.</p><p id="69fc" data-selectable-paragraph="">So another service sometimes provided by “atomic” primitives is some kind of write-barrier. Applying this to head would effectively turn the code into something like this:</p><pre><span id="4a28" data-selectable-paragraph="">foo-&gt;data = 1;<br>foo-&gt;next = head;</span><span id="5f0f" data-selectable-paragraph="">_flush_primitive();<br>head = foo;</span></pre><p id="cb8b" data-selectable-paragraph="">Which means that if you see the new head you will for sure also see the other writes that preceded it. The symmetric thing can be done on the reader side. This are sometimes called “load acquire” and “store release” semantics (store release shown above.)</p><p id="68d2" data-selectable-paragraph="">Importantly, if there is no data ordering necessary, then none of this is needed. For instance if you want to tell a background thread that your user did something and you have no other actions to take no synchronization is needed at all! But this is tricky business. Allow me to illustrate:</p><pre><span id="f6d8" data-selectable-paragraph="">int user_did_it = 0;</span><span id="4c99" data-selectable-paragraph="">// user does something<br>user_did_it = 1;</span><span id="101f" data-selectable-paragraph="">// sometime later, on a different thread<br>if (user_did_it) { coolness_ensues(); }</span></pre><p id="3f37" data-selectable-paragraph="">That’s fair enough, but this code which is nearly the same won’t work:</p><pre><span id="a0e6" data-selectable-paragraph="">int user_did_it = 0;</span><span id="e6dc" data-selectable-paragraph="">// user does something<br>prepare_for_coolness();<br>user_did_it = 1;</span><span id="8e53" data-selectable-paragraph="">// sometime later, on a different thread<br>if (user_did_it) { coolness_ensues(); }</span></pre><p id="2ab0" data-selectable-paragraph="">The problem being that the background thread might not see the prepared coolness before it sees user_did_it. Now you need a fence at least.</p><p id="80c1" data-selectable-paragraph="">And I left off all the volatiles that are needed so that the compiler won’t mess it all up.</p><p id="ffb7" data-selectable-paragraph=""><strong>Summary</strong></p><ul><li id="d76d" data-selectable-paragraph="">volatile gives you a fighting chance at getting concurrency correct because it prevents the compiler from removing and/or reordering and rewriting your operations.</li><li id="d55f" data-selectable-paragraph="">volatile isn’t sufficient because the processor is also reordering writes, so you need some operations that give you more sane memory order guarantees</li><li id="cb67" data-selectable-paragraph="">sometimes these are called “atomic” services but they often have very little to do with atomicity (except maybe atomic ++ operators and such)</li></ul><p id="7eec" data-selectable-paragraph="">In general this stuff is fantastically hard to get right and so you basically never want to do it. It’s hard enough to get simple critical sections correct…</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>