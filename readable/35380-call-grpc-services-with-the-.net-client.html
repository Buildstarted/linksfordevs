<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Call gRPC services with the .NET client -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Call gRPC services with the .NET client</h1>
    <main id="main" class="content "> <ul class="metadata page-metadata"> <li class="displayDate loading"> <time>08/21/2019</time> </li> <li class="readingTime">4 minutes to read</li> <li class="contributors-holder"> <a class="has-inner-focus" href="https://github.com/aspnet/AspNetCore.Docs/blob/master/aspnetcore/grpc/client.md"> <ul class="contributors"> <li><img src="https://github.com/JamesNK.png?size=32"></li> </ul> </a> </li> </ul> <p>A .NET gRPC client library is available in the <a href="https://www.nuget.org/packages/Grpc.Net.Client">Grpc.Net.Client</a> NuGet package. This document explains how to:</p>
<ul>
<li>Configure a gRPC client to call gRPC services.</li>
<li>Make gRPC calls to unary, server streaming, client streaming, and bi-directional streaming methods.</li>
</ul>
<h2 id="configure-grpc-client">Configure gRPC client</h2>
<p>gRPC clients are concrete client types that are <a class="xref" href="basics?view=aspnetcore-3.0#generated-c-assets">generated from <em>*.proto</em> files</a>. The concrete gRPC client has methods that translate to the gRPC service in the <em>*.proto</em> file.</p>
<p>A gRPC client is created from a channel. Start by using <code>GrpcChannel.ForAddress</code> to create a channel, and then use the channel to create a gRPC client:</p>
<pre><code class="lang-csharp">var channel = GrpcChannel.ForAddress(&quot;https://localhost:5001&quot;);
var client = new Greet.GreeterClient(channel);
</code></pre>
<p>A channel represents a long-lived connection to a gRPC service. When a channel is created it is configured with options related to calling a service. For example, the <code>HttpClient</code> used to make calls, the maximum send and receive message size, and logging can be specified on <code>GrpcChannelOptions</code> and used with <code>GrpcChannel.ForAddress</code>. For a complete list of options, see <a class="xref" href="configuration?view=aspnetcore-3.0#configure-client-options">client configuration options</a>.</p>
<p>Creating a channel can be an expensive operation and reusing a channel for gRPC calls offers performance benefits. Multiple concrete gRPC clients can be created from a channel, including different types of clients. Concrete gRPC client types are lightweight objects and can be created when needed.</p>
<pre><code class="lang-csharp">var channel = GrpcChannel.ForAddress(&quot;https://localhost:5001&quot;);

var greeterClient = new Greet.GreeterClient(channel);
var counterClient = new Count.CounterClient(channel);

// Use clients to call gRPC services
</code></pre>
<p><code>GrpcChannel.ForAddress</code> isn&apos;t the only option for creating a gRPC client. If you are calling gRPC services from an ASP.NET Core app, consider <a class="xref" href="clientfactory?view=aspnetcore-3.0">gRPC client factory integration</a>. gRPC integration with <code>HttpClientFactory</code> offers a centralized alternative to creating gRPC clients.</p>
<h2 id="make-grpc-calls">Make gRPC calls</h2>
<p>A gRPC call is initiated by calling a method on the client. The gRPC client will handle message serialization and addressing the gRPC call to the correct service.</p>
<p>gRPC has different types of methods. How you use the client to make a gRPC call depends on the type of method you are calling. The gRPC method types are:</p>
<ul>
<li>Unary</li>
<li>Server streaming</li>
<li>Client streaming</li>
<li>Bi-directional streaming</li>
</ul>
<h3 id="unary-call">Unary call</h3>
<p>A unary call starts with the client sending a request message. A response message is returned when the service finishes.</p>
<pre><code class="lang-csharp">var client = new Greet.GreeterClient(channel);
var response = await client.SayHelloAsync(new HelloRequest { Name = &quot;World&quot; });

Console.WriteLine(&quot;Greeting: &quot; + response.Message);
// Greeting: Hello World
</code></pre>
<p>Each unary service method in the <em>*.proto</em> file will result in two .NET methods on the concrete gRPC client type for calling the method: an asynchronous method and a blocking method. For example, on <code>GreeterClient</code> there are two ways of calling <code>SayHello</code>:</p>
<ul>
<li><code>GreeterClient.SayHelloAsync</code> - calls <code>Greeter.SayHello</code> service asynchronously. Can be awaited.</li>
<li><code>GreeterClient.SayHello</code> - calls <code>Greeter.SayHello</code> service and blocks until complete. Don&apos;t use in asynchronous code.</li>
</ul>
<h3 id="server-streaming-call">Server streaming call</h3>
<p>A server streaming call starts with the client sending a request message. <code>ResponseStream.MoveNext()</code> reads messages streamed from the service. The server streaming call is complete when <code>ResponseStream.MoveNext()</code> returns <code>false</code>.</p>
<pre><code class="lang-csharp">var client = new Greet.GreeterClient(channel);
using (var call = client.SayHellos(new HelloRequest { Name = &quot;World&quot; }))
{
    while (await call.ResponseStream.MoveNext())
    {
        Console.WriteLine(&quot;Greeting: &quot; + call.ResponseStream.Current.Message);
        // Greeting: Hello World&quot; is streamed multiple times
    }
}
</code></pre>
<p>If you are using C# 8 or later then the <code>await foreach</code> syntax can be used to read messages. The <code>IAsyncStreamReader&lt;T&gt;.ReadAllAsync()</code> extension method reads all messages from the response stream:</p>
<pre><code class="lang-csharp">var client = new Greet.GreeterClient(channel);
using (var call = client.SayHellos(new HelloRequest { Name = &quot;World&quot; }))
{
    await foreach (var response in call.ResponseStream.ReadAllAsync())
    {
        Console.WriteLine(&quot;Greeting: &quot; + response.Message);
        // &quot;Greeting: Hello World&quot; is streamed multiple times
    }
}
</code></pre>
<h3 id="client-streaming-call">Client streaming call</h3>
<p>A client streaming call starts <em>without</em> the client sending a message. The client can choose to send sends messages with <code>RequestStream.WriteAsync</code>. When the client has finished sending messages <code>RequestStream.CompleteAsync</code> should be called to notify the service. The call is finished when the service returns a response message.</p>
<pre><code class="lang-csharp">var client = new Counter.CounterClient(channel);
using (var call = client.AccumulateCount())
{
    for (var i = 0; i &lt; 3; i++)
    {
        await call.RequestStream.WriteAsync(new CounterRequest { Count = 1 });
    }
    await call.RequestStream.CompleteAsync();

    var response = await call;
    Console.WriteLine($&quot;Count: {response.Count}&quot;);
    // Count: 3
}
</code></pre>
<h3 id="bi-directional-streaming-call">Bi-directional streaming call</h3>
<p>A bi-directional streaming call starts <em>without</em> the client sending a message. The client can choose to send messages with <code>RequestStream.WriteAsync</code>. Messages streamed from the service are accessible with <code>ResponseStream.MoveNext()</code> or <code>ResponseStream.ReadAllAsync()</code>. The bi-directional streaming call is complete when the <code>ResponseStream</code> has no more messages.</p>
<pre><code class="lang-csharp">using (var call = client.Echo())
{
    Console.WriteLine(&quot;Starting background task to receive messages&quot;);
    var readTask = Task.Run(async () =&gt;
    {
        await foreach (var response in call.ResponseStream.ReadAllAsync())
        {
            Console.WriteLine(response.Message);
            // Echo messages sent to the service
        }
    });

    Console.WriteLine(&quot;Starting to send messages&quot;);
    Console.WriteLine(&quot;Type a message to echo then press enter.&quot;);
    while (true)
    {
        var result = Console.ReadLine();
        if (string.IsNullOrEmpty(result))
        {
            break;
        }

        await call.RequestStream.WriteAsync(new EchoMessage { Message = result });
    }

    Console.WriteLine(&quot;Disconnecting&quot;);
    await call.RequestStream.CompleteAsync();
    await readTask;
}
</code></pre>
<p>During a bi-directional streaming call, the client and service can send messages to each other at any time. The best client logic for interacting with a bi-directional call varies depending upon the service logic.</p>
<h2 id="additional-resources">Additional resources</h2>
<ul>
<li><a class="xref" href="clientfactory?view=aspnetcore-3.0">gRPC client factory integration in .NET Core</a></li>
<li><a class="xref" href="basics?view=aspnetcore-3.0">gRPC services with C#</a></li>
</ul> </main>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>