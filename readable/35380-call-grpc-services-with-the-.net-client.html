<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Call gRPC services with the .NET client -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Call gRPC services with the .NET client</h1><div><div id="main" class="content "><p>A .NET gRPC client library is available in the <a href="https://www.nuget.org/packages/Grpc.Net.Client" data-linktype="external">Grpc.Net.Client</a> NuGet package. This document explains how to:</p><ul><li>Configure a gRPC client to call gRPC services.</li><li>Make gRPC calls to unary, server streaming, client streaming, and bi-directional streaming methods.</li></ul><h2 id="configure-grpc-client">Configure gRPC client</h2><p>gRPC clients are concrete client types that are <a href="basics?view=aspnetcore-3.1#generated-c-assets" data-linktype="relative-path">generated from <em>*.proto</em> files</a>. The concrete gRPC client has methods that translate to the gRPC service in the <em>*.proto</em> file.</p><p>A gRPC client is created from a channel. Start by using <code>GrpcChannel.ForAddress</code> to create a channel, and then use the channel to create a gRPC client:</p><pre><code class="lang-csharp">var channel = GrpcChannel.ForAddress("https://localhost:5001");
var client = new Greet.GreeterClient(channel);
</code></pre><p>A channel represents a long-lived connection to a gRPC service. When a channel is created, it is configured with options related to calling a service. For example, the <code>HttpClient</code> used to make calls, the maximum send and receive message size, and logging can be specified on <code>GrpcChannelOptions</code> and used with <code>GrpcChannel.ForAddress</code>. For a complete list of options, see <a href="configuration?view=aspnetcore-3.1#configure-client-options" data-linktype="relative-path">client configuration options</a>.</p><pre><code class="lang-csharp">var channel = GrpcChannel.ForAddress("https://localhost:5001");

var greeterClient = new Greet.GreeterClient(channel);
var counterClient = new Count.CounterClient(channel);

// Use clients to call gRPC services
</code></pre><p>Channel and client performance and usage:</p><ul><li>Creating a channel can be an expensive operation. Reusing a channel for gRPC calls provides performance benefits.</li><li>gRPC clients are created with channels. gRPC clients are lightweight objects and don't need to be cached or reused.</li><li>Multiple gRPC clients can be created from a channel, including different types of clients.</li><li>A channel and clients created from the channel can safely be used by multiple threads.</li><li>Clients created from the channel can make multiple simultaneous calls.</li></ul><p><code>GrpcChannel.ForAddress</code> isn't the only option for creating a gRPC client. If you're calling gRPC services from an ASP.NET Core app, consider <a href="clientfactory?view=aspnetcore-3.1" data-linktype="relative-path">gRPC client factory integration</a>. gRPC integration with <code>HttpClientFactory</code> offers a centralized alternative to creating gRPC clients.</p><h2 id="make-grpc-calls">Make gRPC calls</h2><p>A gRPC call is initiated by calling a method on the client. The gRPC client will handle message serialization and addressing the gRPC call to the correct service.</p><p>gRPC has different types of methods. How you use the client to make a gRPC call depends on the type of method you are calling. The gRPC method types are:</p><ul><li>Unary</li><li>Server streaming</li><li>Client streaming</li><li>Bi-directional streaming</li></ul><h3 id="unary-call">Unary call</h3><p>A unary call starts with the client sending a request message. A response message is returned when the service finishes.</p><pre><code class="lang-csharp">var client = new Greet.GreeterClient(channel);
var response = await client.SayHelloAsync(new HelloRequest { Name = "World" });

Console.WriteLine("Greeting: " + response.Message);
// Greeting: Hello World
</code></pre><p>Each unary service method in the <em>*.proto</em> file will result in two .NET methods on the concrete gRPC client type for calling the method: an asynchronous method and a blocking method. For example, on <code>GreeterClient</code> there are two ways of calling <code>SayHello</code>:</p><ul><li><code>GreeterClient.SayHelloAsync</code> - calls <code>Greeter.SayHello</code> service asynchronously. Can be awaited.</li><li><code>GreeterClient.SayHello</code> - calls <code>Greeter.SayHello</code> service and blocks until complete. Don't use in asynchronous code.</li></ul><h3 id="server-streaming-call">Server streaming call</h3><p>A server streaming call starts with the client sending a request message. <code>ResponseStream.MoveNext()</code> reads messages streamed from the service. The server streaming call is complete when <code>ResponseStream.MoveNext()</code> returns <code>false</code>.</p><pre><code class="lang-csharp">var client = new Greet.GreeterClient(channel);
using (var call = client.SayHellos(new HelloRequest { Name = "World" }))
{
    while (await call.ResponseStream.MoveNext())
    {
        Console.WriteLine("Greeting: " + call.ResponseStream.Current.Message);
        // "Greeting: Hello World" is written multiple times
    }
}
</code></pre><p>If you are using C# 8 or later, the <code>await foreach</code> syntax can be used to read messages. The <code>IAsyncStreamReader&lt;T&gt;.ReadAllAsync()</code> extension method reads all messages from the response stream:</p><pre><code class="lang-csharp">var client = new Greet.GreeterClient(channel);
using (var call = client.SayHellos(new HelloRequest { Name = "World" }))
{
    await foreach (var response in call.ResponseStream.ReadAllAsync())
    {
        Console.WriteLine("Greeting: " + response.Message);
        // "Greeting: Hello World" is written multiple times
    }
}
</code></pre><h3 id="client-streaming-call">Client streaming call</h3><p>A client streaming call starts <em>without</em> the client sending a message. The client can choose to send messages with <code>RequestStream.WriteAsync</code>. When the client has finished sending messages <code>RequestStream.CompleteAsync</code> should be called to notify the service. The call is finished when the service returns a response message.</p><pre><code class="lang-csharp">var client = new Counter.CounterClient(channel);
using (var call = client.AccumulateCount())
{
    for (var i = 0; i &lt; 3; i++)
    {
        await call.RequestStream.WriteAsync(new CounterRequest { Count = 1 });
    }
    await call.RequestStream.CompleteAsync();

    var response = await call;
    Console.WriteLine($"Count: {response.Count}");
    // Count: 3
}
</code></pre><h3 id="bi-directional-streaming-call">Bi-directional streaming call</h3><p>A bi-directional streaming call starts <em>without</em> the client sending a message. The client can choose to send messages with <code>RequestStream.WriteAsync</code>. Messages streamed from the service are accessible with <code>ResponseStream.MoveNext()</code> or <code>ResponseStream.ReadAllAsync()</code>. The bi-directional streaming call is complete when the <code>ResponseStream</code> has no more messages.</p><pre><code class="lang-csharp">using (var call = client.Echo())
{
    Console.WriteLine("Starting background task to receive messages");
    var readTask = Task.Run(async () =&gt;
    {
        await foreach (var response in call.ResponseStream.ReadAllAsync())
        {
            Console.WriteLine(response.Message);
            // Echo messages sent to the service
        }
    });

    Console.WriteLine("Starting to send messages");
    Console.WriteLine("Type a message to echo then press enter.");
    while (true)
    {
        var result = Console.ReadLine();
        if (string.IsNullOrEmpty(result))
        {
            break;
        }

        await call.RequestStream.WriteAsync(new EchoMessage { Message = result });
    }

    Console.WriteLine("Disconnecting");
    await call.RequestStream.CompleteAsync();
    await readTask;
}
</code></pre><p>During a bi-directional streaming call, the client and service can send messages to each other at any time. The best client logic for interacting with a bi-directional call varies depending upon the service logic.</p><h2 id="additional-resources">Additional resources</h2></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>