<!DOCTYPE html>
<html lang="en">
<head>
    <title>
To Null, or not to Null?!? - Dave Cook -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>To Null, or not to Null?!? - Dave Cook</h1><div><div class="ac ae af ag ah dw aj ak"><p id="8616" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">It’s been over a decade since <a href="https://en.wikipedia.org/wiki/Tony_Hoare" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">Sir Tony Hoare</a> described his invention of the null reference in 1965 as his <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">billion-dollar mistake</a>:</p><blockquote class="hm hn ho"><p id="f1cc" class="gg gh dz hp gi b gj gk gl gm gn go gp gq gr gs gt cu">“This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.”</p></blockquote><p id="a973" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Given that the inventor of null thinks it was a bad idea, you would expect that the rest of us might have figured out an alternative to code like this:</p><figure class="hq hr hs ht hu cz"><p id="46a1" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">This is not real code, but is based on real code that I’ve seen many times, and I expect you have too!</p><p id="f4f5" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">So, what’s the issue? Well, let’s ignore the fact that it has more than one <a href="https://deviq.com/single-responsibility-principle/" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">responsibility</a> and there are <a class="at cg gz ha hb hc" target="_blank" rel="noopener" href="/@dcook_net/how-to-check-for-null-in-c-926a115dfc1b">better ways to check for null</a> … my main bugbear is that there are paths through this code that result in a null being returned to the caller.</p><p id="74cd" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">This is something that has been grating on me for some time now, as every null is another exception waiting to happen. Over recent months I have come to the conclusion that this is lies somewhere between a poor design decision and just a little bit lazy!</p><p id="4ae3" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Why?</p><p id="c955" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Because it casually pushes work and responsibility on to each and every one of our consumers, opening the door to the dreaded <a href="https://docs.microsoft.com/en-us/dotnet/api/system.nullreferenceexception?view=netcore-3.0" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">NullReferenceException</a>, and in order to avoid said exception each of our callers needs to test the result for null.</p><p id="e3ee" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">No hardship right; it’s just a one-liner to check for null, or a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">?</a> here and there!</p><p id="0b92" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Sure, but it assumes that everyone calling our code actually knows to check for null; what about the juniors on the team? And we need to remember to write that code to check for null; what about the seniors on the team ;-)</p><p id="48a2" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">In some scenarios we might get a warning indicating a possible null reference, and maybe even a helpful suggestion on how to fix it, but nothing is physically stopping us from building our app. Nothing is stopping us from deploying it to Production and then finding the issue at run time.</p><p id="84d3" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">You might be reading this and thinking ‘it’s ok, our test suite would pick that up!” — great! But tests don’t solve all of our problems!</p><h1 id="db66" class="hw hx dz bk bj hy eb hz ed ia ib ic id ie if ig ih">The problems that Null creates</h1><ul class=""><li id="d65f" class="gg gh dz bk gi b gj ii gl ij gn ik gp il gr im gt in io ip"><strong class="gi gu">Problem 1: Returning null forces work on to our consumer(s)</strong></li></ul><p id="2af7" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Not only that, but it does so covertly!</p><p id="4c98" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Let’s look at some code through the eyes of a potential consumer of a theoretical Accounts class:</p><pre class="hq hr hs ht hu iq ir is"><span id="fbce" class="it hx dz bk gy b dp iu iv r iw">//method signature:<br>public User LookupUserByEmail(string email)  </span><span id="154c" class="it hx dz bk gy b dp ix iy iz ja jb iv r iw">//calling code:<br>User result = accounts.LookupUserByEmail(“test.user@data.com”);</span></pre><p id="53a0" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">What can we infer from this?</p><p id="13d6" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Its reasonable to assume that given we supply an email address then we will get a User object back, but we can’t actually learn anything else without further investigation. In order to figure out what happens when a user isn’t found, or when something fails, we need to actually look at the implementation and read the code.</p><ul class=""><li id="cef2" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt in io ip"><strong class="gi gu">Problem 2: Reading code takes time and delays us from our goal!</strong></li></ul><p id="c78d" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Then upon reading the code, we uncover a lie. A dirty, dirty lie!</p><p id="79b3" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">When a user with a matching email address can’t be found, it doesn’t return the promised User object at all. It returns a null. A dirty, dirty null!</p><ul class=""><li id="04b5" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt in io ip"><strong class="gi gu">Problem 3: The method signature is dishonest</strong></li></ul><p id="32dc" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Our method signature gives no indication that there is a possibility of us not getting a User object back, nothing explicit to flag the potential error scenario that we need to deal with, and no warnings about nulls.</p><p id="c0cb" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">This is less than ideal, and unfortunately because it requires little thought or effort, it’s easy to fall into this trap and adopt this default behaviour, reusing this pattern time and time again: littering our code bases with land mines, waiting to blow up in our faces.</p><figure class="hq hr hs ht hu cz cl cm paragraph-image"><figcaption class="bo dp dq dr ds cn cl cm dt du bj dv">Spotted on Twitter!</figcaption></figure><p id="9ea2" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">But what alternatives do we have? What can we do to solve these issues?</p><p id="68dd" class="gg gh dz bk gi b gj ii gl ij gn ik gp il gr im gt cu">There are actually a number of techniques we can use as safe alternatives to null, which remove the possibility of null reference exceptions while still modelling the absence of data, and also keeping our <a href="http://functionalprogrammingcsharp.com/honest-functions" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">functions honest</a>.</p><p id="26d7" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">For starters, we could return a safe default value such as an empty collection. For example:</p><figure class="hq hr hs ht hu cz"><p id="7737" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Here we handle 3 different scenarios, or routes, through our code:</p><ul class=""><li id="90c1" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt in io ip">The happy path: Everything works. We find 1 or more matching accounts and return them to the caller.</li><li id="a811" class="gg gh dz bk gi b gj js gl jt gn ju gp jv gr jw gt in io ip">The Less happy, but not exceptional or unanticipated path: No accounts match our criteria, so we return an empty list.</li><li id="2e1b" class="gg gh dz bk gi b gj js gl jt gn ju gp jv gr jw gt in io ip">Error Path: Something hits the fan. We log the detail to aid diagnostics, then return an empty list.</li></ul><p id="4239" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">In each of these scenarios, we return an object that meets the promises stated in the method signature. We keep our function honest, as it always returns a list of account objects, even in the event of failure.</p><p id="9bb4" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">We remove the need to check that the response is not null, so we are not forcing work on to our consumer, and our code is less prone to error: if our caller fails to check for null, we don’t give rise to unwanted NullReferecnceExceptions.</p><p id="f63a" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Here’s the calling code that executes the example above:</p><figure class="hq hr hs ht hu cz"><figcaption class="bo dp dq dr ds cn cl cm dt du bj dv">Nothing blows up when we access the accounts object!</figcaption></figure><p id="a98b" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">An alternative to returning an empty list, which is quite specific, is to use the <a href="https://deviq.com/null-object-pattern/" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">Null Object Pattern</a>, returning an object derived from the return type expressed in the signature that carries zero side effects when it’s members are accessed.</p><p id="5e40" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Consider the following example where we upgrade an existing insurance policy to a newer version:</p><figure class="hq hr hs ht hu cz"><figcaption class="bo dp dq dr ds cn cl cm dt du bj dv">No checks for null here!</figcaption></figure><p id="6b3d" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Here we lookup the implementation required to upgrade the Policy from version x to y, and then we use the result of that lookup to actually upgrade the Policy object, returning the updated Policy to the caller.</p><p id="e463" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Notice that there is no guard clause around the <code class="dj gv gw gx gy b">policyUpgrader</code> object to ensure that we found a matching implementation to perform the upgrade. So how do we sleep at night?</p><p id="ea3d" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Here is the implementation of FindPolicyUpgrader:</p><figure class="hq hr hs ht hu cz"><figcaption class="bo dp dq dr ds cn cl cm dt du bj dv">If no matches found, return a NullObject rather than a null.</figcaption></figure><p id="b8d7" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">In the event that we find a match for our query, then we obviously return that matching implementation. However, when no match is found, instead of returning a null we return an instance of an object that conforms to the contract in our method signature; in this case it implements the interface we are expecting to return: IPolicyUpgrader.</p><p id="ac91" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">The key thing about this special case implementation of our interface is that it doesn’t actually do anything when we execute it’s UpgradePolicy method…there are no consequences or side effects to executing this code, it simply returns the policy object that it is supplied, without doing anything to it.</p><p id="7f68" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Again, we have kept our method honest and returned what we said we would in our method signature, and we’ve not forced any extra work on to our clients with the potential of creating errors if they forget to perform that work.</p><p id="75e2" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">While these two approaches do work for some scenarios, we obviously can’t get away with this behaviour all the time. We need to think about how our response is going to be used and what possible implications Null Objects might have once released into our program. For example, if downstream code makes a decision based on the count of items in a collection, and some of the instances in that collection are Null Objects, then we are potentially introducing defects into the codebase that could be really difficult to diagnose.</p><p id="27b8" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">In a similar way, if we returned an empty string instead of a null, then we avoid a potential null reference exception, but we might cause strange behaviour further downstream.</p><p id="1023" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Indeed — in the example above, we’ve performed the Upgrade task, but the Policy has not actually been upgraded…will that cause other errors elsewhere?</p><p id="6ab4" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">These techniques also fail to address the fact that we still need to look at the implementation of the function in order to figure out what happens when we deviate from the happy path, as their method signatures are not expressive enough to communicate that level of detail.</p><h1 id="01b6" class="hw hx dz bk bj hy eb hz ed ia ib ic id ie if ig ih">What tools do we have?</h1><p id="0203" class="gg gh dz bk gi b gj ii gl ij gn ik gp il gr im gt cu">If you are lucky enough to be using C# 8, then you can benefit from a new language feature called <a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">non-nullable reference types</a>, which allows us to tell the compiler and anyone reading our code: this object is not supposed to be null!</p><p id="f00a" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Its something we need to <a href="https://devblogs.microsoft.com/dotnet/try-out-nullable-reference-types/" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">opt into at a project level</a>, and once enabled it magically makes all the existing reference types in that project non-nullable by default (unless suffixed with a ?, in the same way you define a nullable value type). This means that instances of these objects must be initialised to a non-null value, and the variable can never be assigned the value <code class="dj gv gw gx gy b">null</code>.</p><p id="2880" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Here’s an excerpt from the docs:</p><blockquote class="hm hn ho"><p id="c298" class="gg gh dz hp gi b gj gk gl gm gn go gp gq gr gs gt cu">The compiler uses static analysis to determine if a nullable reference is known to be non-null. The compiler warns you if you dereference a nullable reference when it may be null</p></blockquote><p id="69f9" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Sounds good, right? That should prevent some null reference exceptions! For example, while this code was perfectly fine before, now we get a compiler warning against each of these assignments:</p><pre class="hq hr hs ht hu iq ir is"><span id="fab0" class="it hx dz bk gy b dp iu iv r iw">Policy policy = null;<br>List&lt;IPolicyUpgrader&gt; policyUpgraders = null;<br>string name = null;  </span><span id="c751" class="it hx dz bk gy b dp ix iy iz ja jb iv r iw">// [CS8600] Converting null literal or possible null value to non-nullable type.</span></pre><p id="5335" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Pretty cool… but we can ignore these warnings and ship to production anyway! What if we <a href="https://dailydotnettips.com/avoid-code-warnings-being-missed-or-ignored-treating-warnings-as-errors-in-visual-studio/" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">crank up the compiler settings</a> all the way to 11 and <a href="https://blog.submain.com/treat-warnings-errors/" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow"><em class="hp">treat all warnings as errors</em></a>?</p><p id="f5d8" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Now the game has changed again, as these assignments now fail the build. This is obviously much better than a warning, as it is physically stopping us from initialising our objects with a null.</p><p id="df1c" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">It’s not a quick fix though; opting for these settings on even a small project may suddenly create quite a bit of work in order to get it compiling again. So what do we get for our efforts? How do non-nullable reference types address the 3 problems discussed above?</p><ul class=""><li id="d9ca" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt in io ip"><strong class="gi gu">Returning null forces work on to our consumer: </strong>The compiler is now preventing us from returning null at design time, so that solves that issue.</li><li id="c201" class="gg gh dz bk gi b gj js gl jt gn ju gp jv gr jw gt in io ip"><strong class="gi gu">The method signature is dishonest: </strong>We are now forced to return something that matches the signature of our method, so that’s not a problem anymore.</li><li id="8023" class="gg gh dz bk gi b gj js gl jt gn ju gp jv gr jw gt in io ip"><strong class="gi gu">Reading code takes time and delays us from our goal: </strong>Let’s look at our original example again…</li></ul><pre class="hq hr hs ht hu iq ir is"><span id="51e9" class="it hx dz bk gy b dp iu iv r iw">public User LookupUserByEmail(string email)</span></pre><p id="3774" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">This looks like exactly the same code that we saw before, but now that our reference types are all non-nullable we know a little bit more information: Given an email address that should not be null, it returns a User object, which also should not be null. That’s a little more expressive than it was.</p><p id="7847" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">But we still can’t infer what happens when a match for our requested user can’t be found, so we still need to look at the implementation and read the code to figure this out.</p><p id="4d28" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">There is also the slightly disappointing use of the word <strong class="gi gu"><em class="hp">should</em></strong>. While non-nullable reference types prevent us from initialising our objects and returning null from our functions at design time, it does not actually prevent them from containing null at run time.</p><p id="3f21" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">For example, the following test will fail even though <code class="dj gv gw gx gy b">Policy</code> is non-nullable, because the value of <code class="dj gv gw gx gy b">p</code> is <code class="dj gv gw gx gy b">null</code>:</p><figure class="hq hr hs ht hu cz"><p id="7650" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">So while this means we can’t delete all of our null checking code just yet, it’s still well worth turning on this feature in order to reduce the chances of a null reference exception, and express our intent a teeny wee bit more.</p><h1 id="ee7e" class="hw hx dz bk bj hy eb hz ed ia ib ic id ie if ig ih">Anything else we could Try?</h1><p id="6649" class="gg gh dz bk gi b gj ii gl ij gn ik gp il gr im gt cu">We could use the TryGet pattern: whereby our function returns a tuple of <code class="dj gv gw gx gy b">(bool, T)</code> with the boolean flag indicating if the function was successful or not, and <code class="dj gv gw gx gy b">T</code> will either contain a result or a null. Let’s have a look at how this might look if we refactor our earlier example:</p><figure class="hq hr hs ht hu cz"><figcaption class="bo dp dq dr ds cn cl cm dt du bj dv">This pattern is often implemented using out params…</figcaption></figure><p id="477b" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">What does this give us? Our method name has changed very subtly to indicate that this may or may not succeed with the inclusion of the word Try. This is slightly more expressive to us humans, as it provides a small hint of the possibility of failure, but it means nothing to the compiler, and therefore does nothing to force a change in the consumer’s behaviour.</p><p id="4665" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">The return type does go a little bit further though: as we are now returning a tuple (a value type: aka a struct) we now know that we can never receive a null response, and we have made our code less prone to error in that regard.</p><p id="bd7d" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Our consumers can now check the boolean success flag to determine if it is safe or not to access the result. This is, however, a check that the consumer needs to opt into: they can choose to skip the safety check and access the result anyway, which may or may not be null:</p><pre class="hq hr hs ht hu iq ir is"><span id="74eb" class="it hx dz bk gy b dp iu iv r iw">var (_, policyUpgrader) = TryFindUpdater(1, 2);</span><span id="9e2b" class="it hx dz bk gy b dp ix iy iz ja jb iv r iw">policyUpgrader.UpgradePolicy(policy);</span></pre><p id="3021" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">The TryGet pattern is a step in the right direction, but we can go a little further.</p><h1 id="ee2c" class="hw hx dz bk bj hy eb hz ed ia ib ic id ie if ig ih">We could throw!</h1><p id="62a1" class="gg gh dz bk gi b gj ii gl ij gn ik gp il gr im gt cu">I’ve been avoiding the elephant in the room. We could obviously avoid returning null by throwing an Exception instead. But this is a post about reducing null reference exceptions, so it seems a little odd to replace one type of exception with another. That feels a little like massaging the numbers to me!</p><p id="6b56" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Throwing Exceptions also has the side affect of making our methods dishonest and forces work onto our consumers in a similar way to returning null, so this isn’t solving all the issues we set out to fix.</p><p id="0560" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">For the purposes of this discussion I will continue to avoid throwing exceptions.</p><h1 id="cd8f" class="hw hx dz bk bj hy eb hz ed ia ib ic id ie if ig ih">What more can we do?</h1><p id="f307" class="gg gh dz bk gi b gj ii gl ij gn ik gp il gr im gt cu">If we look to functional programming languages for a little inspiration we can actually lean on the compiler a lot more. In languages such as F# and Haskell it’s impossible to return null from a function, because there is no null. It simply doesn’t exist!</p><p id="5a9b" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Instead, F# uses a <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/options" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">built-in type</a> of <code class="dj gv gw gx gy b">Option&lt;T&gt;</code> (called ‘Maybe’ In Haskell), to represent the fact that an instance may, or may not, contain an underlaying value of <code class="dj gv gw gx gy b">T</code>:</p><ul class=""><li id="8348" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt in io ip">When we have a value to return, then we return that value wrapped inside a <code class="dj gv gw gx gy b">Some</code>.</li><li id="8017" class="gg gh dz bk gi b gj js gl jt gn ju gp jv gr jw gt in io ip">When we have no value to return, then we return <code class="dj gv gw gx gy b">None</code>.</li><li id="2f31" class="gg gh dz bk gi b gj js gl jt gn ju gp jv gr jw gt in io ip">Both <code class="dj gv gw gx gy b">Some&lt;T&gt;</code> and <code class="dj gv gw gx gy b">None</code> satisfy the compiler’s need for type safety.</li><li id="7e57" class="gg gh dz bk gi b gj js gl jt gn ju gp jv gr jw gt in io ip">And crucially, <code class="dj gv gw gx gy b">Option&lt;T&gt;</code> can never be set it to null, just as a struct can never be null.</li></ul><p id="2f6d" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">With the ground rules established, let’s have a look at those method signatures from earlier and see how they might look if we could use something like <code class="dj gv gw gx gy b">Option&lt;T&gt;</code> in C#, while also reflecting on those initial problems with null;</p><pre class="hq hr hs ht hu iq ir is"><span id="7aa4" class="it hx dz bk gy b dp iu iv r iw">public Option&lt;IPolicyUpgrader&gt; FindPolicyUpgrader(int from, int to)</span><span id="c8da" class="it hx dz bk gy b dp ix iy iz ja jb iv r iw">public Option&lt;User&gt; LookupUserByEmail(string email)</span></pre><p id="cac4" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu"><strong class="gi gu">Is our signature honest?</strong></p><p id="e2a5" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Yes. Our signatures have changed to explicitly show that our response may or may not return an instance of T, and whether it succeeds or fails we always get something back that we were expecting, never a null.</p><p id="71c7" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu"><strong class="gi gu">Do we need to inspect the method’s implementation?</strong></p><p id="d436" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">As the method signatures are a lot more expressive, we actually have a much better idea of what to expect the method to return, both on and off the happy path. We don’t really need to read the implementation to see what the method does in failure scenarios, as we can infer from the response type what we will get back if no match is found.</p><p id="0923" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu"><strong class="gi gu">Are we forcing work on to our consumers?</strong></p><p id="4e76" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu"><code class="dj gv gw gx gy b">Option&lt;T&gt;</code> can’t be null, so we’ve removed the need for a null check and the possibility of a null reference exception.</p><p id="b553" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">What the caller needs to do now is decide what to do with <code class="dj gv gw gx gy b">Option&lt;T&gt;</code>. Does it contain a value or not, and what to do if its empty? These are decisions that they should have been making anyway, only now they are being forced by the compiler (and aided by the intellisense in the IDE) to consider both possibilities, Some and None, rather than assuming that all was well and forgetting about that pesky null!</p><p id="2e8e" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Cool. We’ve solved all the problems created by null, but the solution is to use a type from another programming language…so where does that leave us?</p><p id="0c34" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Have no fear, these types DO exist in C# and are just a nuget package away: both <a href="https://www.nuget.org/packages/LaYumba.Functional/" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">LaYumba</a> and <a href="https://www.nuget.org/packages/LanguageExt.Core/" class="at cg gz ha hb hc" target="_blank" rel="noopener nofollow">LanguageExt</a> packages contain good implementations of <code class="dj gv gw gx gy b">Option&lt;T&gt;</code> that we can use to achieve the behaviour we’ve just discussed, have excellent documentation explaining how to use them, and are based on structs so they can never be null.</p><h1 id="337c" class="hw hx dz bk bj hy eb hz ed ia ib ic id ie if ig ih"><strong class="az">What about crossing system boundaries?</strong></h1><p id="accc" class="gg gh dz bk gi b gj ii gl ij gn ik gp il gr im gt cu">This is actually a question I’m trying to answer for myself right now. Most of the code I write exists within web services: they process incoming json payloads, interact with a database or another web service, and respond with more json. How do we model the absence of data when talking to our collaborators at the edges of our system?</p><p id="83d6" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu"><code class="dj gv gw gx gy b">Option&lt;T&gt;</code> does not serialise to json straight out of the box, so does not work smoothly with model binding when a controller receives a request, or when a controller responds to a request with an object of <code class="dj gv gw gx gy b">Option&lt;T&gt;</code>, or an object with properties of <code class="dj gv gw gx gy b">Option&lt;T&gt;</code>.</p><p id="7f8b" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">Likewise, the out of the box behaviour does not serialise when saving a document (an Object) to a Mongo Database. If I wanted to save something to SQL Server, then I assume I would need to model the field as as nullable, using the appropriate datatype, and then write either the underlying value or a null to the record. I assume I need to do a similar thing with Mongo.</p><p id="c712" class="gg gh dz bk gi b gj gk gl gm gn go gp gq gr gs gt cu">So for now I am using <code class="dj gv gw gx gy b">Option&lt;T&gt;</code> inside my services, mapping back and forth into nullable types at the boundaries when talking to other systems.</p></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>