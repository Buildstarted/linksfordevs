<!DOCTYPE html>
<html lang="en">
<head>
    <title>
dotnet/coreclr - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="dotnet/coreclr - linksfor.dev(s)"/>
    <meta property="og:description" content="CoreCLR is the runtime for .NET Core. It includes the garbage collector, JIT compiler, primitive data types and low-level classes. - dotnet/coreclr"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/dotnet/coreclr/blob/ab2f9caaf35c96d029b96aa171ee65d04253cf7c/src/debug/di/process.cpp"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - dotnet/coreclr</title>
<div class="readable">
        <h1>dotnet/coreclr</h1>
            <div>Reading time: 942-1197 minutes</div>
        <div>Posted here: 05 Sep 2019</div>
        <p><a href="https://github.com/dotnet/coreclr/blob/ab2f9caaf35c96d029b96aa171ee65d04253cf7c/src/debug/di/process.cpp">https://github.com/dotnet/coreclr/blob/ab2f9caaf35c96d029b96aa171ee65d04253cf7c/src/debug/di/process.cpp</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div itemprop="text">
      
<table data-tab-size="4">
      <tbody><tr>
        <td id="L1" data-line-number="1"></td>
        <td id="LC1"><span><span>//</span> Licensed to the .NET Foundation under one or more agreements.</span></td>
      </tr>
      <tr>
        <td id="L2" data-line-number="2"></td>
        <td id="LC2"><span><span>//</span> The .NET Foundation licenses this file to you under the MIT license.</span></td>
      </tr>
      <tr>
        <td id="L3" data-line-number="3"></td>
        <td id="LC3"><span><span>//</span> See the LICENSE file in the project root for more information.</span></td>
      </tr>
      <tr>
        <td id="L4" data-line-number="4"></td>
        <td id="LC4"><span><span>//</span>*****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L5" data-line-number="5"></td>
        <td id="LC5"><span><span>//</span> File: process.cpp</span></td>
      </tr>
      <tr>
        <td id="L6" data-line-number="6"></td>
        <td id="LC6"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7" data-line-number="7"></td>
        <td id="LC7">
</td>
      </tr>
      <tr>
        <td id="L8" data-line-number="8"></td>
        <td id="LC8"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9" data-line-number="9"></td>
        <td id="LC9"><span><span>//</span>*****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L10" data-line-number="10"></td>
        <td id="LC10">#<span>include</span> <span><span>"</span>stdafx.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L11" data-line-number="11"></td>
        <td id="LC11">#<span>include</span> <span><span>"</span>primitives.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L12" data-line-number="12"></td>
        <td id="LC12">#<span>include</span> <span><span>"</span>safewrap.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L13" data-line-number="13"></td>
        <td id="LC13">
</td>
      </tr>
      <tr>
        <td id="L14" data-line-number="14"></td>
        <td id="LC14">#<span>include</span> <span><span>"</span>check.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L15" data-line-number="15"></td>
        <td id="LC15">
</td>
      </tr>
      <tr>
        <td id="L16" data-line-number="16"></td>
        <td id="LC16">#<span>ifndef</span> SM_REMOTESESSION</td>
      </tr>
      <tr>
        <td id="L17" data-line-number="17"></td>
        <td id="LC17">#<span>define</span> <span>SM_REMOTESESSION</span> <span>0x1000</span></td>
      </tr>
      <tr>
        <td id="L18" data-line-number="18"></td>
        <td id="LC18">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L19" data-line-number="19"></td>
        <td id="LC19">
</td>
      </tr>
      <tr>
        <td id="L20" data-line-number="20"></td>
        <td id="LC20">#<span>include</span> <span><span>"</span>corpriv.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L21" data-line-number="21"></td>
        <td id="LC21">#<span>include</span> <span><span>"</span>corexcep.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L22" data-line-number="22"></td>
        <td id="LC22">#<span>include</span> <span><span>"</span>../../dlls/mscorrc/resource.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L23" data-line-number="23"></td>
        <td id="LC23">#<span>include</span> <span><span>&lt;</span>limits.h<span>&gt;</span></span></td>
      </tr>
      <tr>
        <td id="L24" data-line-number="24"></td>
        <td id="LC24">
</td>
      </tr>
      <tr>
        <td id="L25" data-line-number="25"></td>
        <td id="LC25">#<span>include</span> <span><span>&lt;</span>sstring.h<span>&gt;</span></span></td>
      </tr>
      <tr>
        <td id="L26" data-line-number="26"></td>
        <td id="LC26">
</td>
      </tr>
      <tr>
        <td id="L27" data-line-number="27"></td>
        <td id="LC27"><span><span>//</span> @dbgtodo shim: process has some private hooks into the shim.</span></td>
      </tr>
      <tr>
        <td id="L28" data-line-number="28"></td>
        <td id="LC28">#<span>include</span> <span><span>"</span>shimpriv.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L29" data-line-number="29"></td>
        <td id="LC29">
</td>
      </tr>
      <tr>
        <td id="L30" data-line-number="30"></td>
        <td id="LC30">#<span>include</span> <span><span>"</span>metadataexports.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L31" data-line-number="31"></td>
        <td id="LC31">#<span>include</span> <span><span>"</span>readonlydatatargetfacade.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L32" data-line-number="32"></td>
        <td id="LC32">#<span>include</span> <span><span>"</span>metahost.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L33" data-line-number="33"></td>
        <td id="LC33">
</td>
      </tr>
      <tr>
        <td id="L34" data-line-number="34"></td>
        <td id="LC34"><span><span>//</span> Keep this around for retail debugging. It's very very useful because</span></td>
      </tr>
      <tr>
        <td id="L35" data-line-number="35"></td>
        <td id="LC35"><span><span>//</span> it's global state that we can always find, regardless of how many locals the compiler</span></td>
      </tr>
      <tr>
        <td id="L36" data-line-number="36"></td>
        <td id="LC36"><span><span>//</span> optimizes away ;)</span></td>
      </tr>
      <tr>
        <td id="L37" data-line-number="37"></td>
        <td id="LC37"><span>struct</span> <span>RSDebuggingInfo</span>;</td>
      </tr>
      <tr>
        <td id="L38" data-line-number="38"></td>
        <td id="LC38"><span>extern</span> RSDebuggingInfo * g_pRSDebuggingInfo;</td>
      </tr>
      <tr>
        <td id="L39" data-line-number="39"></td>
        <td id="LC39">
</td>
      </tr>
      <tr>
        <td id="L40" data-line-number="40"></td>
        <td id="LC40"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L41" data-line-number="41"></td>
        <td id="LC41"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L42" data-line-number="42"></td>
        <td id="LC42"><span><span>//</span> OpenVirtualProcessImpl method called by the shim to get an ICorDebugProcess4 instance</span></td>
      </tr>
      <tr>
        <td id="L43" data-line-number="43"></td>
        <td id="LC43"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L44" data-line-number="44"></td>
        <td id="LC44"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L45" data-line-number="45"></td>
        <td id="LC45"><span><span>//</span>    clrInstanceId - target pointer identifying which CLR in the Target to debug.</span></td>
      </tr>
      <tr>
        <td id="L46" data-line-number="46"></td>
        <td id="LC46"><span><span>//</span>    pDataTarget - data target abstraction.</span></td>
      </tr>
      <tr>
        <td id="L47" data-line-number="47"></td>
        <td id="LC47"><span><span>//</span>    hDacModule - the handle of the appropriate DAC dll for this runtime</span></td>
      </tr>
      <tr>
        <td id="L48" data-line-number="48"></td>
        <td id="LC48"><span><span>//</span>    riid - interface ID to query for.</span></td>
      </tr>
      <tr>
        <td id="L49" data-line-number="49"></td>
        <td id="LC49"><span><span>//</span>    ppProcessOut - new object for target, interface ID matches riid.</span></td>
      </tr>
      <tr>
        <td id="L50" data-line-number="50"></td>
        <td id="LC50"><span><span>//</span>    ppFlagsOut - currently only has 1 bit to indicate whether or not this runtime</span></td>
      </tr>
      <tr>
        <td id="L51" data-line-number="51"></td>
        <td id="LC51"><span><span>//</span>                 instance will send a managed event after attach</span></td>
      </tr>
      <tr>
        <td id="L52" data-line-number="52"></td>
        <td id="LC52"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L53" data-line-number="53"></td>
        <td id="LC53"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L54" data-line-number="54"></td>
        <td id="LC54"><span><span>//</span>    S_OK on success. Else failure</span></td>
      </tr>
      <tr>
        <td id="L55" data-line-number="55"></td>
        <td id="LC55"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L56" data-line-number="56"></td>
        <td id="LC56"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L57" data-line-number="57"></td>
        <td id="LC57"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L58" data-line-number="58"></td>
        <td id="LC58"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L59" data-line-number="59"></td>
        <td id="LC59"><span><span>//</span>    The outgoing process object can be cleaned up by calling Detach (which</span></td>
      </tr>
      <tr>
        <td id="L60" data-line-number="60"></td>
        <td id="LC60"><span><span>//</span>    will reset the Attach bit.)</span></td>
      </tr>
      <tr>
        <td id="L61" data-line-number="61"></td>
        <td id="LC61"><span><span>//</span>    @dbgtodo attach-bit: need to determine fate of attach bit.</span></td>
      </tr>
      <tr>
        <td id="L62" data-line-number="62"></td>
        <td id="LC62"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L63" data-line-number="63"></td>
        <td id="LC63"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L64" data-line-number="64"></td>
        <td id="LC64">STDAPI DLLEXPORT <span>OpenVirtualProcessImpl</span>(</td>
      </tr>
      <tr>
        <td id="L65" data-line-number="65"></td>
        <td id="LC65">    ULONG64 clrInstanceId,</td>
      </tr>
      <tr>
        <td id="L66" data-line-number="66"></td>
        <td id="LC66">    IUnknown * pDataTarget,</td>
      </tr>
      <tr>
        <td id="L67" data-line-number="67"></td>
        <td id="LC67">    HMODULE hDacModule,</td>
      </tr>
      <tr>
        <td id="L68" data-line-number="68"></td>
        <td id="LC68">    CLR_DEBUGGING_VERSION * pMaxDebuggerSupportedVersion,</td>
      </tr>
      <tr>
        <td id="L69" data-line-number="69"></td>
        <td id="LC69">    REFIID riid,</td>
      </tr>
      <tr>
        <td id="L70" data-line-number="70"></td>
        <td id="LC70">    IUnknown ** ppInstance,</td>
      </tr>
      <tr>
        <td id="L71" data-line-number="71"></td>
        <td id="LC71">    CLR_DEBUGGING_PROCESS_FLAGS* pFlagsOut)</td>
      </tr>
      <tr>
        <td id="L72" data-line-number="72"></td>
        <td id="LC72">{</td>
      </tr>
      <tr>
        <td id="L73" data-line-number="73"></td>
        <td id="LC73">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L74" data-line-number="74"></td>
        <td id="LC74">    RSExtSmartPtr&lt;CordbProcess&gt; pProcess;</td>
      </tr>
      <tr>
        <td id="L75" data-line-number="75"></td>
        <td id="LC75">    <span>PUBLIC_API_ENTRY</span>(<span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L76" data-line-number="76"></td>
        <td id="LC76">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L77" data-line-number="77"></td>
        <td id="LC77">    {</td>
      </tr>
      <tr>
        <td id="L78" data-line-number="78"></td>
        <td id="LC78">
</td>
      </tr>
      <tr>
        <td id="L79" data-line-number="79"></td>
        <td id="LC79">        <span>if</span> ( (pDataTarget == <span>NULL</span>) || (clrInstanceId == <span>0</span>) || (pMaxDebuggerSupportedVersion == <span>NULL</span>) ||</td>
      </tr>
      <tr>
        <td id="L80" data-line-number="80"></td>
        <td id="LC80">            ((pFlagsOut == <span>NULL</span>) &amp;&amp; (ppInstance == <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L81" data-line-number="81"></td>
        <td id="LC81">            )</td>
      </tr>
      <tr>
        <td id="L82" data-line-number="82"></td>
        <td id="LC82">        {</td>
      </tr>
      <tr>
        <td id="L83" data-line-number="83"></td>
        <td id="LC83">            <span>ThrowHR</span>(E_INVALIDARG);</td>
      </tr>
      <tr>
        <td id="L84" data-line-number="84"></td>
        <td id="LC84">        }</td>
      </tr>
      <tr>
        <td id="L85" data-line-number="85"></td>
        <td id="LC85">
</td>
      </tr>
      <tr>
        <td id="L86" data-line-number="86"></td>
        <td id="LC86">        <span><span>//</span> We consider the top 8 bits of the struct version to be the only part that represents</span></td>
      </tr>
      <tr>
        <td id="L87" data-line-number="87"></td>
        <td id="LC87">        <span><span>//</span> a breaking change.  This gives us some freedom in the future to have the debugger</span></td>
      </tr>
      <tr>
        <td id="L88" data-line-number="88"></td>
        <td id="LC88">        <span><span>//</span> opt into getting more data.</span></td>
      </tr>
      <tr>
        <td id="L89" data-line-number="89"></td>
        <td id="LC89">        <span>const</span> WORD <span>kMajorMask</span> = <span>0xff00</span>;</td>
      </tr>
      <tr>
        <td id="L90" data-line-number="90"></td>
        <td id="LC90">        <span>const</span> WORD <span>kMaxStructMajor</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L91" data-line-number="91"></td>
        <td id="LC91">        <span>if</span> ((pMaxDebuggerSupportedVersion-&gt;<span>wStructVersion</span> &amp; <span>kMajorMask</span>) &gt; <span>kMaxStructMajor</span>)</td>
      </tr>
      <tr>
        <td id="L92" data-line-number="92"></td>
        <td id="LC92">        {</td>
      </tr>
      <tr>
        <td id="L93" data-line-number="93"></td>
        <td id="LC93">            <span><span>//</span> Don't know how to interpret the version structure</span></td>
      </tr>
      <tr>
        <td id="L94" data-line-number="94"></td>
        <td id="LC94">            <span>ThrowHR</span>(CORDBG_E_UNSUPPORTED_VERSION_STRUCT);</td>
      </tr>
      <tr>
        <td id="L95" data-line-number="95"></td>
        <td id="LC95">        }</td>
      </tr>
      <tr>
        <td id="L96" data-line-number="96"></td>
        <td id="LC96">
</td>
      </tr>
      <tr>
        <td id="L97" data-line-number="97"></td>
        <td id="LC97">        <span><span>//</span> This process object is intended to be used for the V3 pipeline, and so</span></td>
      </tr>
      <tr>
        <td id="L98" data-line-number="98"></td>
        <td id="LC98">        <span><span>//</span> much of the process from V2 is not being used. For example,</span></td>
      </tr>
      <tr>
        <td id="L99" data-line-number="99"></td>
        <td id="LC99">        <span><span>//</span> - there is no ShimProcess object</span></td>
      </tr>
      <tr>
        <td id="L100" data-line-number="100"></td>
        <td id="LC100">        <span><span>//</span> - there is no w32et thread (all threads are effectively an event thread)</span></td>
      </tr>
      <tr>
        <td id="L101" data-line-number="101"></td>
        <td id="LC101">        <span><span>//</span> - the stop state is 'live', which corresponds to CordbProcess not knowing what</span></td>
      </tr>
      <tr>
        <td id="L102" data-line-number="102"></td>
        <td id="LC102">        <span><span>//</span> its stop state really is (because that is now controlled by the shim).</span></td>
      </tr>
      <tr>
        <td id="L103" data-line-number="103"></td>
        <td id="LC103">        ProcessDescriptor pd = <span>ProcessDescriptor::CreateUninitialized</span>();</td>
      </tr>
      <tr>
        <td id="L104" data-line-number="104"></td>
        <td id="LC104">        <span>IfFailThrow</span>(<span>CordbProcess::OpenVirtualProcess</span>(</td>
      </tr>
      <tr>
        <td id="L105" data-line-number="105"></td>
        <td id="LC105">            clrInstanceId,</td>
      </tr>
      <tr>
        <td id="L106" data-line-number="106"></td>
        <td id="LC106">            pDataTarget,  <span><span>//</span> takes a reference</span></td>
      </tr>
      <tr>
        <td id="L107" data-line-number="107"></td>
        <td id="LC107">            hDacModule,</td>
      </tr>
      <tr>
        <td id="L108" data-line-number="108"></td>
        <td id="LC108">            <span>NULL</span>, <span><span>//</span> Cordb</span></td>
      </tr>
      <tr>
        <td id="L109" data-line-number="109"></td>
        <td id="LC109">            &amp;pd, <span><span>//</span> 0 for V3 cases (pShim == NULL).</span></td>
      </tr>
      <tr>
        <td id="L110" data-line-number="110"></td>
        <td id="LC110">            <span>NULL</span>, <span><span>//</span> no Shim in V3 cases</span></td>
      </tr>
      <tr>
        <td id="L111" data-line-number="111"></td>
        <td id="LC111">            &amp;pProcess));</td>
      </tr>
      <tr>
        <td id="L112" data-line-number="112"></td>
        <td id="LC112">
</td>
      </tr>
      <tr>
        <td id="L113" data-line-number="113"></td>
        <td id="LC113">        <span><span>//</span> CordbProcess::OpenVirtualProcess already did the external addref to pProcess.</span></td>
      </tr>
      <tr>
        <td id="L114" data-line-number="114"></td>
        <td id="LC114">        <span><span>//</span> Since pProcess is a smart ptr, it will external release in this function.</span></td>
      </tr>
      <tr>
        <td id="L115" data-line-number="115"></td>
        <td id="LC115">        <span><span>//</span> Living reference will be the one from the QI.</span></td>
      </tr>
      <tr>
        <td id="L116" data-line-number="116"></td>
        <td id="LC116">
</td>
      </tr>
      <tr>
        <td id="L117" data-line-number="117"></td>
        <td id="LC117">        <span><span>//</span> get the managed debug event pending flag</span></td>
      </tr>
      <tr>
        <td id="L118" data-line-number="118"></td>
        <td id="LC118">        <span>if</span>(pFlagsOut != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L119" data-line-number="119"></td>
        <td id="LC119">        {</td>
      </tr>
      <tr>
        <td id="L120" data-line-number="120"></td>
        <td id="LC120">            hr = pProcess-&gt;<span>GetAttachStateFlags</span>(pFlagsOut);</td>
      </tr>
      <tr>
        <td id="L121" data-line-number="121"></td>
        <td id="LC121">            <span>if</span>(<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L122" data-line-number="122"></td>
        <td id="LC122">            {</td>
      </tr>
      <tr>
        <td id="L123" data-line-number="123"></td>
        <td id="LC123">                <span>ThrowHR</span>(hr);</td>
      </tr>
      <tr>
        <td id="L124" data-line-number="124"></td>
        <td id="LC124">            }</td>
      </tr>
      <tr>
        <td id="L125" data-line-number="125"></td>
        <td id="LC125">        }</td>
      </tr>
      <tr>
        <td id="L126" data-line-number="126"></td>
        <td id="LC126">
</td>
      </tr>
      <tr>
        <td id="L127" data-line-number="127"></td>
        <td id="LC127">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L128" data-line-number="128"></td>
        <td id="LC128">        <span><span>//</span> Check to make sure the debugger supports debugging this version</span></td>
      </tr>
      <tr>
        <td id="L129" data-line-number="129"></td>
        <td id="LC129">        <span><span>//</span> Note that it's important that we still store the flags (above) in this case</span></td>
      </tr>
      <tr>
        <td id="L130" data-line-number="130"></td>
        <td id="LC130">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L131" data-line-number="131"></td>
        <td id="LC131">        <span>if</span> (!<span>CordbProcess::IsCompatibleWith</span>(pMaxDebuggerSupportedVersion-&gt;<span>wMajor</span>))</td>
      </tr>
      <tr>
        <td id="L132" data-line-number="132"></td>
        <td id="LC132">        {</td>
      </tr>
      <tr>
        <td id="L133" data-line-number="133"></td>
        <td id="LC133">            <span><span>//</span> Not compatible - don't keep the process instance, and return this specific error-code</span></td>
      </tr>
      <tr>
        <td id="L134" data-line-number="134"></td>
        <td id="LC134">            <span>ThrowHR</span>(CORDBG_E_UNSUPPORTED_FORWARD_COMPAT);</td>
      </tr>
      <tr>
        <td id="L135" data-line-number="135"></td>
        <td id="LC135">        }</td>
      </tr>
      <tr>
        <td id="L136" data-line-number="136"></td>
        <td id="LC136">
</td>
      </tr>
      <tr>
        <td id="L137" data-line-number="137"></td>
        <td id="LC137">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L138" data-line-number="138"></td>
        <td id="LC138">        <span><span>//</span> Now Query for the requested interface</span></td>
      </tr>
      <tr>
        <td id="L139" data-line-number="139"></td>
        <td id="LC139">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L140" data-line-number="140"></td>
        <td id="LC140">        <span>if</span>(ppInstance != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L141" data-line-number="141"></td>
        <td id="LC141">        {</td>
      </tr>
      <tr>
        <td id="L142" data-line-number="142"></td>
        <td id="LC142">            <span>IfFailThrow</span>(pProcess-&gt;<span>QueryInterface</span>(riid, <span>reinterpret_cast</span>&lt;<span>void</span>**&gt; (ppInstance)));</td>
      </tr>
      <tr>
        <td id="L143" data-line-number="143"></td>
        <td id="LC143">        }</td>
      </tr>
      <tr>
        <td id="L144" data-line-number="144"></td>
        <td id="LC144">
</td>
      </tr>
      <tr>
        <td id="L145" data-line-number="145"></td>
        <td id="LC145">        <span><span>//</span> if you have to add code here that could fail make sure ppInstance gets released and NULL'ed at exit</span></td>
      </tr>
      <tr>
        <td id="L146" data-line-number="146"></td>
        <td id="LC146">    }</td>
      </tr>
      <tr>
        <td id="L147" data-line-number="147"></td>
        <td id="LC147">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L148" data-line-number="148"></td>
        <td id="LC148">
</td>
      </tr>
      <tr>
        <td id="L149" data-line-number="149"></td>
        <td id="LC149">    <span>if</span>((<span>FAILED</span>(hr) || ppInstance == <span>NULL</span>) &amp;&amp; pProcess != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L150" data-line-number="150"></td>
        <td id="LC150">    {</td>
      </tr>
      <tr>
        <td id="L151" data-line-number="151"></td>
        <td id="LC151">        <span><span>//</span> The process has a strong reference to itself which is only released by neutering it.</span></td>
      </tr>
      <tr>
        <td id="L152" data-line-number="152"></td>
        <td id="LC152">        <span><span>//</span> Since we aren't handing out the ref then we need to clean it up</span></td>
      </tr>
      <tr>
        <td id="L153" data-line-number="153"></td>
        <td id="LC153">        <span>_ASSERTE</span>(ppInstance == <span>NULL</span> || *ppInstance == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L154" data-line-number="154"></td>
        <td id="LC154">        pProcess-&gt;<span>Neuter</span>();</td>
      </tr>
      <tr>
        <td id="L155" data-line-number="155"></td>
        <td id="LC155">    }</td>
      </tr>
      <tr>
        <td id="L156" data-line-number="156"></td>
        <td id="LC156">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L157" data-line-number="157"></td>
        <td id="LC157">};</td>
      </tr>
      <tr>
        <td id="L158" data-line-number="158"></td>
        <td id="LC158">
</td>
      </tr>
      <tr>
        <td id="L159" data-line-number="159"></td>
        <td id="LC159"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L160" data-line-number="160"></td>
        <td id="LC160"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L161" data-line-number="161"></td>
        <td id="LC161"><span><span>//</span> OpenVirtualProcessImpl2 method called by the dbgshim to get an ICorDebugProcess4 instance</span></td>
      </tr>
      <tr>
        <td id="L162" data-line-number="162"></td>
        <td id="LC162"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L163" data-line-number="163"></td>
        <td id="LC163"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L164" data-line-number="164"></td>
        <td id="LC164"><span><span>//</span>    clrInstanceId - target pointer identifying which CLR in the Target to debug.</span></td>
      </tr>
      <tr>
        <td id="L165" data-line-number="165"></td>
        <td id="LC165"><span><span>//</span>    pDataTarget - data target abstraction.</span></td>
      </tr>
      <tr>
        <td id="L166" data-line-number="166"></td>
        <td id="LC166"><span><span>//</span>    pDacModulePath - the module path of the appropriate DAC dll for this runtime</span></td>
      </tr>
      <tr>
        <td id="L167" data-line-number="167"></td>
        <td id="LC167"><span><span>//</span>    riid - interface ID to query for.</span></td>
      </tr>
      <tr>
        <td id="L168" data-line-number="168"></td>
        <td id="LC168"><span><span>//</span>    ppProcessOut - new object for target, interface ID matches riid.</span></td>
      </tr>
      <tr>
        <td id="L169" data-line-number="169"></td>
        <td id="LC169"><span><span>//</span>    ppFlagsOut - currently only has 1 bit to indicate whether or not this runtime</span></td>
      </tr>
      <tr>
        <td id="L170" data-line-number="170"></td>
        <td id="LC170"><span><span>//</span>                 instance will send a managed event after attach</span></td>
      </tr>
      <tr>
        <td id="L171" data-line-number="171"></td>
        <td id="LC171"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L172" data-line-number="172"></td>
        <td id="LC172"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L173" data-line-number="173"></td>
        <td id="LC173"><span><span>//</span>    S_OK on success. Else failure</span></td>
      </tr>
      <tr>
        <td id="L174" data-line-number="174"></td>
        <td id="LC174"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L175" data-line-number="175"></td>
        <td id="LC175">STDAPI DLLEXPORT <span>OpenVirtualProcessImpl2</span>(</td>
      </tr>
      <tr>
        <td id="L176" data-line-number="176"></td>
        <td id="LC176">    ULONG64 clrInstanceId,</td>
      </tr>
      <tr>
        <td id="L177" data-line-number="177"></td>
        <td id="LC177">    IUnknown * pDataTarget,</td>
      </tr>
      <tr>
        <td id="L178" data-line-number="178"></td>
        <td id="LC178">    LPCWSTR pDacModulePath,</td>
      </tr>
      <tr>
        <td id="L179" data-line-number="179"></td>
        <td id="LC179">    CLR_DEBUGGING_VERSION * pMaxDebuggerSupportedVersion,</td>
      </tr>
      <tr>
        <td id="L180" data-line-number="180"></td>
        <td id="LC180">    REFIID riid,</td>
      </tr>
      <tr>
        <td id="L181" data-line-number="181"></td>
        <td id="LC181">    IUnknown ** ppInstance,</td>
      </tr>
      <tr>
        <td id="L182" data-line-number="182"></td>
        <td id="LC182">    CLR_DEBUGGING_PROCESS_FLAGS* pFlagsOut)</td>
      </tr>
      <tr>
        <td id="L183" data-line-number="183"></td>
        <td id="LC183">{</td>
      </tr>
      <tr>
        <td id="L184" data-line-number="184"></td>
        <td id="LC184">    HMODULE hDac = <span>LoadLibraryW</span>(pDacModulePath);</td>
      </tr>
      <tr>
        <td id="L185" data-line-number="185"></td>
        <td id="LC185">    <span>if</span> (hDac == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L186" data-line-number="186"></td>
        <td id="LC186">    {</td>
      </tr>
      <tr>
        <td id="L187" data-line-number="187"></td>
        <td id="LC187">        <span>return</span> <span>HRESULT_FROM_WIN32</span>(<span>GetLastError</span>());</td>
      </tr>
      <tr>
        <td id="L188" data-line-number="188"></td>
        <td id="LC188">    }</td>
      </tr>
      <tr>
        <td id="L189" data-line-number="189"></td>
        <td id="LC189">    <span>return</span> <span>OpenVirtualProcessImpl</span>(clrInstanceId, pDataTarget, hDac, pMaxDebuggerSupportedVersion, riid, ppInstance, pFlagsOut);</td>
      </tr>
      <tr>
        <td id="L190" data-line-number="190"></td>
        <td id="LC190">}</td>
      </tr>
      <tr>
        <td id="L191" data-line-number="191"></td>
        <td id="LC191">
</td>
      </tr>
      <tr>
        <td id="L192" data-line-number="192"></td>
        <td id="LC192"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L193" data-line-number="193"></td>
        <td id="LC193"><span><span>//</span> DEPRECATED - use OpenVirtualProcessImpl</span></td>
      </tr>
      <tr>
        <td id="L194" data-line-number="194"></td>
        <td id="LC194"><span><span>//</span> OpenVirtualProcess method used by the shim in CLR v4 Beta1</span></td>
      </tr>
      <tr>
        <td id="L195" data-line-number="195"></td>
        <td id="LC195"><span><span>//</span> We'd like a beta1 shim/VS to still be able to open dumps using a CLR v4 Beta2+ mscordbi.dll,</span></td>
      </tr>
      <tr>
        <td id="L196" data-line-number="196"></td>
        <td id="LC196"><span><span>//</span> so we'll leave this in place (at least until after Beta2 is in wide use).</span></td>
      </tr>
      <tr>
        <td id="L197" data-line-number="197"></td>
        <td id="LC197"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L198" data-line-number="198"></td>
        <td id="LC198">STDAPI DLLEXPORT <span>OpenVirtualProcess2</span>(</td>
      </tr>
      <tr>
        <td id="L199" data-line-number="199"></td>
        <td id="LC199">    ULONG64 clrInstanceId,</td>
      </tr>
      <tr>
        <td id="L200" data-line-number="200"></td>
        <td id="LC200">    IUnknown * pDataTarget,</td>
      </tr>
      <tr>
        <td id="L201" data-line-number="201"></td>
        <td id="LC201">    HMODULE hDacModule,</td>
      </tr>
      <tr>
        <td id="L202" data-line-number="202"></td>
        <td id="LC202">    REFIID riid,</td>
      </tr>
      <tr>
        <td id="L203" data-line-number="203"></td>
        <td id="LC203">    IUnknown ** ppInstance,</td>
      </tr>
      <tr>
        <td id="L204" data-line-number="204"></td>
        <td id="LC204">    CLR_DEBUGGING_PROCESS_FLAGS* pFlagsOut)</td>
      </tr>
      <tr>
        <td id="L205" data-line-number="205"></td>
        <td id="LC205">{</td>
      </tr>
      <tr>
        <td id="L206" data-line-number="206"></td>
        <td id="LC206">    CLR_DEBUGGING_VERSION maxVersion = {<span>0</span>};</td>
      </tr>
      <tr>
        <td id="L207" data-line-number="207"></td>
        <td id="LC207">    maxVersion.<span>wMajor</span> = <span>4</span>;</td>
      </tr>
      <tr>
        <td id="L208" data-line-number="208"></td>
        <td id="LC208">    <span>return</span> <span>OpenVirtualProcessImpl</span>(clrInstanceId, pDataTarget, hDacModule, &amp;maxVersion, riid, ppInstance, pFlagsOut);</td>
      </tr>
      <tr>
        <td id="L209" data-line-number="209"></td>
        <td id="LC209">}</td>
      </tr>
      <tr>
        <td id="L210" data-line-number="210"></td>
        <td id="LC210">
</td>
      </tr>
      <tr>
        <td id="L211" data-line-number="211"></td>
        <td id="LC211"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L212" data-line-number="212"></td>
        <td id="LC212"><span><span>//</span> DEPRECATED - use OpenVirtualProcessImpl</span></td>
      </tr>
      <tr>
        <td id="L213" data-line-number="213"></td>
        <td id="LC213"><span><span>//</span> Public OpenVirtualProcess method to get an ICorDebugProcess4 instance</span></td>
      </tr>
      <tr>
        <td id="L214" data-line-number="214"></td>
        <td id="LC214"><span><span>//</span> Used directly in CLR v4 pre Beta1 - can probably be safely removed now</span></td>
      </tr>
      <tr>
        <td id="L215" data-line-number="215"></td>
        <td id="LC215"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L216" data-line-number="216"></td>
        <td id="LC216">STDAPI DLLEXPORT <span>OpenVirtualProcess</span>(</td>
      </tr>
      <tr>
        <td id="L217" data-line-number="217"></td>
        <td id="LC217">    ULONG64 clrInstanceId,</td>
      </tr>
      <tr>
        <td id="L218" data-line-number="218"></td>
        <td id="LC218">    IUnknown * pDataTarget,</td>
      </tr>
      <tr>
        <td id="L219" data-line-number="219"></td>
        <td id="LC219">    REFIID riid,</td>
      </tr>
      <tr>
        <td id="L220" data-line-number="220"></td>
        <td id="LC220">    IUnknown ** ppInstance)</td>
      </tr>
      <tr>
        <td id="L221" data-line-number="221"></td>
        <td id="LC221">{</td>
      </tr>
      <tr>
        <td id="L222" data-line-number="222"></td>
        <td id="LC222">    <span>return</span> <span>OpenVirtualProcess2</span>(clrInstanceId, pDataTarget, <span>NULL</span>, riid, ppInstance, <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L223" data-line-number="223"></td>
        <td id="LC223">};</td>
      </tr>
      <tr>
        <td id="L224" data-line-number="224"></td>
        <td id="LC224">
</td>
      </tr>
      <tr>
        <td id="L225" data-line-number="225"></td>
        <td id="LC225"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L226" data-line-number="226"></td>
        <td id="LC226"><span><span>//</span> Most Hresults to Unrecoverable error indicate an internal error</span></td>
      </tr>
      <tr>
        <td id="L227" data-line-number="227"></td>
        <td id="LC227"><span><span>//</span> in the Right-Side.</span></td>
      </tr>
      <tr>
        <td id="L228" data-line-number="228"></td>
        <td id="LC228"><span><span>//</span> However, a few are legal (eg, "could actually happen in a retail scenario and</span></td>
      </tr>
      <tr>
        <td id="L229" data-line-number="229"></td>
        <td id="LC229"><span><span>//</span> not indicate an issue in mscorbi"). Track that here.</span></td>
      </tr>
      <tr>
        <td id="L230" data-line-number="230"></td>
        <td id="LC230"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L231" data-line-number="231"></td>
        <td id="LC231">
</td>
      </tr>
      <tr>
        <td id="L232" data-line-number="232"></td>
        <td id="LC232"><span>bool</span> <span>IsLegalFatalError</span>(HRESULT hr)</td>
      </tr>
      <tr>
        <td id="L233" data-line-number="233"></td>
        <td id="LC233">{</td>
      </tr>
      <tr>
        <td id="L234" data-line-number="234"></td>
        <td id="LC234">    <span>return</span></td>
      </tr>
      <tr>
        <td id="L235" data-line-number="235"></td>
        <td id="LC235">        (hr == CORDBG_E_INCOMPATIBLE_PROTOCOL) ||</td>
      </tr>
      <tr>
        <td id="L236" data-line-number="236"></td>
        <td id="LC236">        (hr == CORDBG_E_CANNOT_DEBUG_FIBER_PROCESS) ||</td>
      </tr>
      <tr>
        <td id="L237" data-line-number="237"></td>
        <td id="LC237">        (hr == CORDBG_E_UNCOMPATIBLE_PLATFORMS) ||</td>
      </tr>
      <tr>
        <td id="L238" data-line-number="238"></td>
        <td id="LC238">        (hr == CORDBG_E_MISMATCHED_CORWKS_AND_DACWKS_DLLS) ||</td>
      </tr>
      <tr>
        <td id="L239" data-line-number="239"></td>
        <td id="LC239">        <span><span>//</span> This should only happen in the case of a security attack on us.</span></td>
      </tr>
      <tr>
        <td id="L240" data-line-number="240"></td>
        <td id="LC240">        (hr == E_ACCESSDENIED) ||</td>
      </tr>
      <tr>
        <td id="L241" data-line-number="241"></td>
        <td id="LC241">        (hr == E_FAIL);</td>
      </tr>
      <tr>
        <td id="L242" data-line-number="242"></td>
        <td id="LC242">}</td>
      </tr>
      <tr>
        <td id="L243" data-line-number="243"></td>
        <td id="LC243">
</td>
      </tr>
      <tr>
        <td id="L244" data-line-number="244"></td>
        <td id="LC244"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L245" data-line-number="245"></td>
        <td id="LC245"><span><span>//</span> Safe wait. Use this anytime we're waiting on:</span></td>
      </tr>
      <tr>
        <td id="L246" data-line-number="246"></td>
        <td id="LC246"><span><span>//</span> - an event signaled by the helper thread.</span></td>
      </tr>
      <tr>
        <td id="L247" data-line-number="247"></td>
        <td id="LC247"><span><span>//</span> - something signaled by a thread that holds the process lock.</span></td>
      </tr>
      <tr>
        <td id="L248" data-line-number="248"></td>
        <td id="LC248"><span><span>//</span> Note that we must preserve GetLastError() semantics.</span></td>
      </tr>
      <tr>
        <td id="L249" data-line-number="249"></td>
        <td id="LC249"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L250" data-line-number="250"></td>
        <td id="LC250"><span>inline</span> DWORD <span>SafeWaitForSingleObject</span>(CordbProcess * p, HANDLE h, DWORD dwTimeout)</td>
      </tr>
      <tr>
        <td id="L251" data-line-number="251"></td>
        <td id="LC251">{</td>
      </tr>
      <tr>
        <td id="L252" data-line-number="252"></td>
        <td id="LC252">    <span><span>//</span> Can't hold process lock while blocking</span></td>
      </tr>
      <tr>
        <td id="L253" data-line-number="253"></td>
        <td id="LC253">    <span>_ASSERTE</span>(!p-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L254" data-line-number="254"></td>
        <td id="LC254">
</td>
      </tr>
      <tr>
        <td id="L255" data-line-number="255"></td>
        <td id="LC255">    <span>return</span> ::<span>WaitForSingleObject</span>(h, dwTimeout);</td>
      </tr>
      <tr>
        <td id="L256" data-line-number="256"></td>
        <td id="LC256">}</td>
      </tr>
      <tr>
        <td id="L257" data-line-number="257"></td>
        <td id="LC257">
</td>
      </tr>
      <tr>
        <td id="L258" data-line-number="258"></td>
        <td id="LC258">#<span>define</span> <span>CORDB_WAIT_TIMEOUT</span> <span>360000</span> <span><span>//</span> milliseconds</span></td>
      </tr>
      <tr>
        <td id="L259" data-line-number="259"></td>
        <td id="LC259">
</td>
      </tr>
      <tr>
        <td id="L260" data-line-number="260"></td>
        <td id="LC260"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L261" data-line-number="261"></td>
        <td id="LC261"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L262" data-line-number="262"></td>
        <td id="LC262"><span><span>//</span> Get the timeout value used in waits.</span></td>
      </tr>
      <tr>
        <td id="L263" data-line-number="263"></td>
        <td id="LC263"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L264" data-line-number="264"></td>
        <td id="LC264"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L265" data-line-number="265"></td>
        <td id="LC265"><span><span>//</span>    Number of milliseconds to waite or possible INFINITE (-1).</span></td>
      </tr>
      <tr>
        <td id="L266" data-line-number="266"></td>
        <td id="LC266"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L267" data-line-number="267"></td>
        <td id="LC267"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L268" data-line-number="268"></td>
        <td id="LC268"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L269" data-line-number="269"></td>
        <td id="LC269"><span><span>//</span>    Uses registry values for fine tuning.</span></td>
      </tr>
      <tr>
        <td id="L270" data-line-number="270"></td>
        <td id="LC270"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L271" data-line-number="271"></td>
        <td id="LC271">
</td>
      </tr>
      <tr>
        <td id="L272" data-line-number="272"></td>
        <td id="LC272"><span><span>//</span> static</span></td>
      </tr>
      <tr>
        <td id="L273" data-line-number="273"></td>
        <td id="LC273"><span>static</span> <span>inline</span> DWORD <span>CordbGetWaitTimeout</span>()</td>
      </tr>
      <tr>
        <td id="L274" data-line-number="274"></td>
        <td id="LC274">{</td>
      </tr>
      <tr>
        <td id="L275" data-line-number="275"></td>
        <td id="LC275">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L276" data-line-number="276"></td>
        <td id="LC276">    <span><span>//</span> 0 = Wait forever</span></td>
      </tr>
      <tr>
        <td id="L277" data-line-number="277"></td>
        <td id="LC277">    <span><span>//</span> 1 = Wait for CORDB_WAIT_TIMEOUT</span></td>
      </tr>
      <tr>
        <td id="L278" data-line-number="278"></td>
        <td id="LC278">    <span><span>//</span> n = Wait for n milliseconds</span></td>
      </tr>
      <tr>
        <td id="L279" data-line-number="279"></td>
        <td id="LC279">    <span>static</span> ConfigDWORD cordbWaitTimeout;</td>
      </tr>
      <tr>
        <td id="L280" data-line-number="280"></td>
        <td id="LC280">    DWORD dwTimeoutVal = cordbWaitTimeout.<span>val</span>(CLRConfig::INTERNAL_DbgWaitTimeout);</td>
      </tr>
      <tr>
        <td id="L281" data-line-number="281"></td>
        <td id="LC281">    <span>if</span> (dwTimeoutVal == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L282" data-line-number="282"></td>
        <td id="LC282">        <span>return</span> <span>DWORD</span>(-<span>1</span>);</td>
      </tr>
      <tr>
        <td id="L283" data-line-number="283"></td>
        <td id="LC283">    <span>else</span> <span>if</span> (dwTimeoutVal != <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L284" data-line-number="284"></td>
        <td id="LC284">        <span>return</span> dwTimeoutVal;</td>
      </tr>
      <tr>
        <td id="L285" data-line-number="285"></td>
        <td id="LC285">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L286" data-line-number="286"></td>
        <td id="LC286">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L287" data-line-number="287"></td>
        <td id="LC287">    {</td>
      </tr>
      <tr>
        <td id="L288" data-line-number="288"></td>
        <td id="LC288">        <span>return</span> CORDB_WAIT_TIMEOUT;</td>
      </tr>
      <tr>
        <td id="L289" data-line-number="289"></td>
        <td id="LC289">    }</td>
      </tr>
      <tr>
        <td id="L290" data-line-number="290"></td>
        <td id="LC290">}</td>
      </tr>
      <tr>
        <td id="L291" data-line-number="291"></td>
        <td id="LC291">
</td>
      </tr>
      <tr>
        <td id="L292" data-line-number="292"></td>
        <td id="LC292"><span><span>//</span>----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L293" data-line-number="293"></td>
        <td id="LC293"><span><span>//</span> Implementation of IDacDbiInterface::IMetaDataLookup.</span></td>
      </tr>
      <tr>
        <td id="L294" data-line-number="294"></td>
        <td id="LC294"><span><span>//</span> lookup Internal Metadata Importer keyed by PEFile</span></td>
      </tr>
      <tr>
        <td id="L295" data-line-number="295"></td>
        <td id="LC295"><span><span>//</span> isILMetaDataForNGENImage is true iff the IMDInternalImport returned represents a pointer to</span></td>
      </tr>
      <tr>
        <td id="L296" data-line-number="296"></td>
        <td id="LC296"><span><span>//</span> metadata from an IL image when the module was an ngen'ed image.</span></td>
      </tr>
      <tr>
        <td id="L297" data-line-number="297"></td>
        <td id="LC297">IMDInternalImport * <span>CordbProcess::LookupMetaData</span>(VMPTR_PEFile vmPEFile, <span>bool</span> &amp;isILMetaDataForNGENImage)</td>
      </tr>
      <tr>
        <td id="L298" data-line-number="298"></td>
        <td id="LC298">{</td>
      </tr>
      <tr>
        <td id="L299" data-line-number="299"></td>
        <td id="LC299">    <span>INTERNAL_DAC_CALLBACK</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L300" data-line-number="300"></td>
        <td id="LC300">
</td>
      </tr>
      <tr>
        <td id="L301" data-line-number="301"></td>
        <td id="LC301">    HASHFIND hashFindAppDomain;</td>
      </tr>
      <tr>
        <td id="L302" data-line-number="302"></td>
        <td id="LC302">    HASHFIND hashFindModule;</td>
      </tr>
      <tr>
        <td id="L303" data-line-number="303"></td>
        <td id="LC303">    IMDInternalImport * pMDII = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L304" data-line-number="304"></td>
        <td id="LC304">    isILMetaDataForNGENImage = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L305" data-line-number="305"></td>
        <td id="LC305">
</td>
      </tr>
      <tr>
        <td id="L306" data-line-number="306"></td>
        <td id="LC306">    <span><span>//</span> Check to see if one of the cached modules has the metadata we need</span></td>
      </tr>
      <tr>
        <td id="L307" data-line-number="307"></td>
        <td id="LC307">    <span><span>//</span> If not we will do a more exhaustive search below</span></td>
      </tr>
      <tr>
        <td id="L308" data-line-number="308"></td>
        <td id="LC308">    <span>for</span> (CordbAppDomain * pAppDomain = m_appDomains.<span>FindFirst</span>(&amp;hashFindAppDomain);</td>
      </tr>
      <tr>
        <td id="L309" data-line-number="309"></td>
        <td id="LC309">         pAppDomain != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L310" data-line-number="310"></td>
        <td id="LC310">         pAppDomain = m_appDomains.<span>FindNext</span>(&amp;hashFindAppDomain))</td>
      </tr>
      <tr>
        <td id="L311" data-line-number="311"></td>
        <td id="LC311">    {</td>
      </tr>
      <tr>
        <td id="L312" data-line-number="312"></td>
        <td id="LC312">        <span>for</span> (CordbModule * pModule = pAppDomain-&gt;<span>m_modules</span>.<span>FindFirst</span>(&amp;hashFindModule);</td>
      </tr>
      <tr>
        <td id="L313" data-line-number="313"></td>
        <td id="LC313">             pModule != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L314" data-line-number="314"></td>
        <td id="LC314">             pModule = pAppDomain-&gt;<span>m_modules</span>.<span>FindNext</span>(&amp;hashFindModule))</td>
      </tr>
      <tr>
        <td id="L315" data-line-number="315"></td>
        <td id="LC315">        {</td>
      </tr>
      <tr>
        <td id="L316" data-line-number="316"></td>
        <td id="LC316">            <span>if</span> (pModule-&gt;<span>GetPEFile</span>() == vmPEFile)</td>
      </tr>
      <tr>
        <td id="L317" data-line-number="317"></td>
        <td id="LC317">            {</td>
      </tr>
      <tr>
        <td id="L318" data-line-number="318"></td>
        <td id="LC318">                pMDII = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L319" data-line-number="319"></td>
        <td id="LC319">                <span>ALLOW_DATATARGET_MISSING_MEMORY</span>(</td>
      </tr>
      <tr>
        <td id="L320" data-line-number="320"></td>
        <td id="LC320">                    pMDII = pModule-&gt;<span>GetInternalMD</span>();</td>
      </tr>
      <tr>
        <td id="L321" data-line-number="321"></td>
        <td id="LC321">                );</td>
      </tr>
      <tr>
        <td id="L322" data-line-number="322"></td>
        <td id="LC322">                <span>if</span>(pMDII != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L323" data-line-number="323"></td>
        <td id="LC323">                    <span>return</span> pMDII;</td>
      </tr>
      <tr>
        <td id="L324" data-line-number="324"></td>
        <td id="LC324">            }</td>
      </tr>
      <tr>
        <td id="L325" data-line-number="325"></td>
        <td id="LC325">        }</td>
      </tr>
      <tr>
        <td id="L326" data-line-number="326"></td>
        <td id="LC326">    }</td>
      </tr>
      <tr>
        <td id="L327" data-line-number="327"></td>
        <td id="LC327">
</td>
      </tr>
      <tr>
        <td id="L328" data-line-number="328"></td>
        <td id="LC328">    <span><span>//</span> Cache didn't have it... time to search harder</span></td>
      </tr>
      <tr>
        <td id="L329" data-line-number="329"></td>
        <td id="LC329">    <span>PrepopulateAppDomainsOrThrow</span>();</td>
      </tr>
      <tr>
        <td id="L330" data-line-number="330"></td>
        <td id="LC330">
</td>
      </tr>
      <tr>
        <td id="L331" data-line-number="331"></td>
        <td id="LC331">    <span><span>//</span> There may be perf issues here. The DAC may make a lot of metadata requests, and so</span></td>
      </tr>
      <tr>
        <td id="L332" data-line-number="332"></td>
        <td id="LC332">    <span><span>//</span> this may be an area for potential perf optimizations if we find things running slow.</span></td>
      </tr>
      <tr>
        <td id="L333" data-line-number="333"></td>
        <td id="LC333">
</td>
      </tr>
      <tr>
        <td id="L334" data-line-number="334"></td>
        <td id="LC334">    <span><span>//</span> enumerate through all Modules</span></td>
      </tr>
      <tr>
        <td id="L335" data-line-number="335"></td>
        <td id="LC335">    <span>for</span> (CordbAppDomain * pAppDomain = m_appDomains.<span>FindFirst</span>(&amp;hashFindAppDomain);</td>
      </tr>
      <tr>
        <td id="L336" data-line-number="336"></td>
        <td id="LC336">         pAppDomain != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L337" data-line-number="337"></td>
        <td id="LC337">         pAppDomain = m_appDomains.<span>FindNext</span>(&amp;hashFindAppDomain))</td>
      </tr>
      <tr>
        <td id="L338" data-line-number="338"></td>
        <td id="LC338">    {</td>
      </tr>
      <tr>
        <td id="L339" data-line-number="339"></td>
        <td id="LC339">        pAppDomain-&gt;<span>PrepopulateModules</span>();</td>
      </tr>
      <tr>
        <td id="L340" data-line-number="340"></td>
        <td id="LC340">
</td>
      </tr>
      <tr>
        <td id="L341" data-line-number="341"></td>
        <td id="LC341">        <span>for</span> (CordbModule * pModule = pAppDomain-&gt;<span>m_modules</span>.<span>FindFirst</span>(&amp;hashFindModule);</td>
      </tr>
      <tr>
        <td id="L342" data-line-number="342"></td>
        <td id="LC342">             pModule != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L343" data-line-number="343"></td>
        <td id="LC343">             pModule = pAppDomain-&gt;<span>m_modules</span>.<span>FindNext</span>(&amp;hashFindModule))</td>
      </tr>
      <tr>
        <td id="L344" data-line-number="344"></td>
        <td id="LC344">        {</td>
      </tr>
      <tr>
        <td id="L345" data-line-number="345"></td>
        <td id="LC345">            <span>if</span> (pModule-&gt;<span>GetPEFile</span>() == vmPEFile)</td>
      </tr>
      <tr>
        <td id="L346" data-line-number="346"></td>
        <td id="LC346">            {</td>
      </tr>
      <tr>
        <td id="L347" data-line-number="347"></td>
        <td id="LC347">                pMDII = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L348" data-line-number="348"></td>
        <td id="LC348">                <span>ALLOW_DATATARGET_MISSING_MEMORY</span>(</td>
      </tr>
      <tr>
        <td id="L349" data-line-number="349"></td>
        <td id="LC349">                    pMDII = pModule-&gt;<span>GetInternalMD</span>();</td>
      </tr>
      <tr>
        <td id="L350" data-line-number="350"></td>
        <td id="LC350">                );</td>
      </tr>
      <tr>
        <td id="L351" data-line-number="351"></td>
        <td id="LC351">
</td>
      </tr>
      <tr>
        <td id="L352" data-line-number="352"></td>
        <td id="LC352">                <span>if</span> ( pMDII == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L353" data-line-number="353"></td>
        <td id="LC353">                {</td>
      </tr>
      <tr>
        <td id="L354" data-line-number="354"></td>
        <td id="LC354">                    <span><span>//</span> If we couldn't get metadata from the CordbModule, then we need to ask the</span></td>
      </tr>
      <tr>
        <td id="L355" data-line-number="355"></td>
        <td id="LC355">                    <span><span>//</span> debugger if it can find the metadata elsewhere.</span></td>
      </tr>
      <tr>
        <td id="L356" data-line-number="356"></td>
        <td id="LC356">                    <span><span>//</span> If this was live debugging, we should have just gotten the memory contents.</span></td>
      </tr>
      <tr>
        <td id="L357" data-line-number="357"></td>
        <td id="LC357">                    <span><span>//</span> Thus this code is for dump debugging, when you don't have the metadata in the dump.</span></td>
      </tr>
      <tr>
        <td id="L358" data-line-number="358"></td>
        <td id="LC358">                    pMDII = <span>LookupMetaDataFromDebugger</span>(vmPEFile, isILMetaDataForNGENImage, pModule);</td>
      </tr>
      <tr>
        <td id="L359" data-line-number="359"></td>
        <td id="LC359">                }</td>
      </tr>
      <tr>
        <td id="L360" data-line-number="360"></td>
        <td id="LC360">                <span>return</span> pMDII;</td>
      </tr>
      <tr>
        <td id="L361" data-line-number="361"></td>
        <td id="LC361">            }</td>
      </tr>
      <tr>
        <td id="L362" data-line-number="362"></td>
        <td id="LC362">        }</td>
      </tr>
      <tr>
        <td id="L363" data-line-number="363"></td>
        <td id="LC363">    }</td>
      </tr>
      <tr>
        <td id="L364" data-line-number="364"></td>
        <td id="LC364">
</td>
      </tr>
      <tr>
        <td id="L365" data-line-number="365"></td>
        <td id="LC365">    <span>return</span> <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L366" data-line-number="366"></td>
        <td id="LC366">}</td>
      </tr>
      <tr>
        <td id="L367" data-line-number="367"></td>
        <td id="LC367">
</td>
      </tr>
      <tr>
        <td id="L368" data-line-number="368"></td>
        <td id="LC368">
</td>
      </tr>
      <tr>
        <td id="L369" data-line-number="369"></td>
        <td id="LC369">IMDInternalImport * <span>CordbProcess::LookupMetaDataFromDebugger</span>(</td>
      </tr>
      <tr>
        <td id="L370" data-line-number="370"></td>
        <td id="LC370">    VMPTR_PEFile vmPEFile,</td>
      </tr>
      <tr>
        <td id="L371" data-line-number="371"></td>
        <td id="LC371">    <span>bool</span> &amp;isILMetaDataForNGENImage,</td>
      </tr>
      <tr>
        <td id="L372" data-line-number="372"></td>
        <td id="LC372">    CordbModule * pModule)</td>
      </tr>
      <tr>
        <td id="L373" data-line-number="373"></td>
        <td id="LC373">{</td>
      </tr>
      <tr>
        <td id="L374" data-line-number="374"></td>
        <td id="LC374">    DWORD dwImageTimeStamp = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L375" data-line-number="375"></td>
        <td id="LC375">    DWORD dwImageSize = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L376" data-line-number="376"></td>
        <td id="LC376">    <span>bool</span> isNGEN = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L377" data-line-number="377"></td>
        <td id="LC377">    StringCopyHolder filePath;</td>
      </tr>
      <tr>
        <td id="L378" data-line-number="378"></td>
        <td id="LC378">    IMDInternalImport * pMDII = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L379" data-line-number="379"></td>
        <td id="LC379">
</td>
      </tr>
      <tr>
        <td id="L380" data-line-number="380"></td>
        <td id="LC380">    <span><span>//</span> First, see if the debugger can locate the exact metadata we want.</span></td>
      </tr>
      <tr>
        <td id="L381" data-line-number="381"></td>
        <td id="LC381">    <span>if</span> (<span>this</span>-&gt;<span>GetDAC</span>()-&gt;<span>GetMetaDataFileInfoFromPEFile</span>(vmPEFile, dwImageTimeStamp, dwImageSize, isNGEN, &amp;filePath))</td>
      </tr>
      <tr>
        <td id="L382" data-line-number="382"></td>
        <td id="LC382">    {</td>
      </tr>
      <tr>
        <td id="L383" data-line-number="383"></td>
        <td id="LC383">        <span>_ASSERTE</span>(filePath.<span>IsSet</span>());</td>
      </tr>
      <tr>
        <td id="L384" data-line-number="384"></td>
        <td id="LC384">
</td>
      </tr>
      <tr>
        <td id="L385" data-line-number="385"></td>
        <td id="LC385">        <span><span>//</span> Since we track modules by their IL images, that presents a little bit of oddness here.  The correct</span></td>
      </tr>
      <tr>
        <td id="L386" data-line-number="386"></td>
        <td id="LC386">        <span><span>//</span> thing to do is preferentially load the NI content.</span></td>
      </tr>
      <tr>
        <td id="L387" data-line-number="387"></td>
        <td id="LC387">        <span><span>//</span> We don't discriminate between timestamps &amp; sizes becuase CLRv4 deterministic NGEN guarantees that the</span></td>
      </tr>
      <tr>
        <td id="L388" data-line-number="388"></td>
        <td id="LC388">        <span><span>//</span> IL image and NGEN image have the same timestamp and size.  Should that guarantee change, this code</span></td>
      </tr>
      <tr>
        <td id="L389" data-line-number="389"></td>
        <td id="LC389">        <span><span>//</span> will be horribly broken.</span></td>
      </tr>
      <tr>
        <td id="L390" data-line-number="390"></td>
        <td id="LC390">
</td>
      </tr>
      <tr>
        <td id="L391" data-line-number="391"></td>
        <td id="LC391">        <span><span>//</span> If we happen to have an NI file path, use it instead.</span></td>
      </tr>
      <tr>
        <td id="L392" data-line-number="392"></td>
        <td id="LC392">        <span>const</span> WCHAR * pwszFilePath = pModule-&gt;<span>GetNGenImagePath</span>();</td>
      </tr>
      <tr>
        <td id="L393" data-line-number="393"></td>
        <td id="LC393">        <span>if</span> (pwszFilePath)</td>
      </tr>
      <tr>
        <td id="L394" data-line-number="394"></td>
        <td id="LC394">        {</td>
      </tr>
      <tr>
        <td id="L395" data-line-number="395"></td>
        <td id="LC395">            <span><span>//</span> Force the issue, regardless of the older codepath's opinion.</span></td>
      </tr>
      <tr>
        <td id="L396" data-line-number="396"></td>
        <td id="LC396">            isNGEN = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L397" data-line-number="397"></td>
        <td id="LC397">        }</td>
      </tr>
      <tr>
        <td id="L398" data-line-number="398"></td>
        <td id="LC398">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L399" data-line-number="399"></td>
        <td id="LC399">        {</td>
      </tr>
      <tr>
        <td id="L400" data-line-number="400"></td>
        <td id="LC400">            pwszFilePath = (WCHAR *)filePath;</td>
      </tr>
      <tr>
        <td id="L401" data-line-number="401"></td>
        <td id="LC401">        }</td>
      </tr>
      <tr>
        <td id="L402" data-line-number="402"></td>
        <td id="LC402">
</td>
      </tr>
      <tr>
        <td id="L403" data-line-number="403"></td>
        <td id="LC403">        <span>ALLOW_DATATARGET_MISSING_MEMORY</span>(</td>
      </tr>
      <tr>
        <td id="L404" data-line-number="404"></td>
        <td id="LC404">            pMDII = <span>LookupMetaDataFromDebuggerForSingleFile</span>(pModule, pwszFilePath, dwImageTimeStamp, dwImageSize);</td>
      </tr>
      <tr>
        <td id="L405" data-line-number="405"></td>
        <td id="LC405">        );</td>
      </tr>
      <tr>
        <td id="L406" data-line-number="406"></td>
        <td id="LC406">
</td>
      </tr>
      <tr>
        <td id="L407" data-line-number="407"></td>
        <td id="LC407">        <span><span>//</span> If it's an ngen'ed image and the debugger couldn't find it, we can use the metadata from</span></td>
      </tr>
      <tr>
        <td id="L408" data-line-number="408"></td>
        <td id="LC408">        <span><span>//</span> the corresponding IL image if the debugger can locate it.</span></td>
      </tr>
      <tr>
        <td id="L409" data-line-number="409"></td>
        <td id="LC409">        filePath.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L410" data-line-number="410"></td>
        <td id="LC410">        <span>if</span> ((pMDII == <span>NULL</span>) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L411" data-line-number="411"></td>
        <td id="LC411">            (isNGEN) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L412" data-line-number="412"></td>
        <td id="LC412">            (<span>this</span>-&gt;<span>GetDAC</span>()-&gt;<span>GetILImageInfoFromNgenPEFile</span>(vmPEFile, dwImageTimeStamp, dwImageSize, &amp;filePath)))</td>
      </tr>
      <tr>
        <td id="L413" data-line-number="413"></td>
        <td id="LC413">        {</td>
      </tr>
      <tr>
        <td id="L414" data-line-number="414"></td>
        <td id="LC414">            <span>_ASSERTE</span>(filePath.<span>IsSet</span>());</td>
      </tr>
      <tr>
        <td id="L415" data-line-number="415"></td>
        <td id="LC415">
</td>
      </tr>
      <tr>
        <td id="L416" data-line-number="416"></td>
        <td id="LC416">            WCHAR *mutableFilePath = (WCHAR *)filePath;</td>
      </tr>
      <tr>
        <td id="L417" data-line-number="417"></td>
        <td id="LC417">
</td>
      </tr>
      <tr>
        <td id="L418" data-line-number="418"></td>
        <td id="LC418">#<span>if</span> defined(FEATURE_CORESYSTEM)</td>
      </tr>
      <tr>
        <td id="L419" data-line-number="419"></td>
        <td id="LC419">            <span>size_t</span> pathLen = <span>wcslen</span>(mutableFilePath);</td>
      </tr>
      <tr>
        <td id="L420" data-line-number="420"></td>
        <td id="LC420">
</td>
      </tr>
      <tr>
        <td id="L421" data-line-number="421"></td>
        <td id="LC421">            <span>const</span> <span>wchar_t</span> *nidll = <span>W</span>(<span><span>"</span>.ni.dll<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L422" data-line-number="422"></td>
        <td id="LC422">            <span>const</span> <span>wchar_t</span> *niexe = <span>W</span>(<span><span>"</span>.ni.exe<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L423" data-line-number="423"></td>
        <td id="LC423">            <span>const</span> <span>size_t</span> dllLen = <span>wcslen</span>(nidll);  <span><span>//</span> used for ni.exe as well</span></td>
      </tr>
      <tr>
        <td id="L424" data-line-number="424"></td>
        <td id="LC424">
</td>
      </tr>
      <tr>
        <td id="L425" data-line-number="425"></td>
        <td id="LC425">            <span>const</span> <span>wchar_t</span> *niwinmd = <span>W</span>(<span><span>"</span>.ni.winmd<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L426" data-line-number="426"></td>
        <td id="LC426">            <span>const</span> <span>size_t</span> winmdLen = <span>wcslen</span>(niwinmd);</td>
      </tr>
      <tr>
        <td id="L427" data-line-number="427"></td>
        <td id="LC427">
</td>
      </tr>
      <tr>
        <td id="L428" data-line-number="428"></td>
        <td id="LC428">            <span>if</span> (pathLen &gt; dllLen &amp;&amp; <span>_wcsicmp</span>(mutableFilePath+pathLen-dllLen, nidll) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L429" data-line-number="429"></td>
        <td id="LC429">            {</td>
      </tr>
      <tr>
        <td id="L430" data-line-number="430"></td>
        <td id="LC430">                <span>wcscpy_s</span>(mutableFilePath+pathLen-dllLen, dllLen, <span>W</span>(<span><span>"</span>.dll<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L431" data-line-number="431"></td>
        <td id="LC431">            }</td>
      </tr>
      <tr>
        <td id="L432" data-line-number="432"></td>
        <td id="LC432">            <span>else</span> <span>if</span> (pathLen &gt; dllLen &amp;&amp; <span>_wcsicmp</span>(mutableFilePath+pathLen-dllLen, niexe) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L433" data-line-number="433"></td>
        <td id="LC433">            {</td>
      </tr>
      <tr>
        <td id="L434" data-line-number="434"></td>
        <td id="LC434">                <span>wcscpy_s</span>(mutableFilePath+pathLen-dllLen, dllLen, <span>W</span>(<span><span>"</span>.exe<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L435" data-line-number="435"></td>
        <td id="LC435">            }</td>
      </tr>
      <tr>
        <td id="L436" data-line-number="436"></td>
        <td id="LC436">            <span>else</span> <span>if</span> (pathLen &gt; winmdLen &amp;&amp; <span>_wcsicmp</span>(mutableFilePath+pathLen-winmdLen, niwinmd) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L437" data-line-number="437"></td>
        <td id="LC437">            {</td>
      </tr>
      <tr>
        <td id="L438" data-line-number="438"></td>
        <td id="LC438">                <span>wcscpy_s</span>(mutableFilePath+pathLen-winmdLen, winmdLen, <span>W</span>(<span><span>"</span>.winmd<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L439" data-line-number="439"></td>
        <td id="LC439">            }</td>
      </tr>
      <tr>
        <td id="L440" data-line-number="440"></td>
        <td id="LC440">#<span>endif</span><span><span>//</span>FEATURE_CORESYSTEM</span></td>
      </tr>
      <tr>
        <td id="L441" data-line-number="441"></td>
        <td id="LC441">
</td>
      </tr>
      <tr>
        <td id="L442" data-line-number="442"></td>
        <td id="LC442">            <span>ALLOW_DATATARGET_MISSING_MEMORY</span>(</td>
      </tr>
      <tr>
        <td id="L443" data-line-number="443"></td>
        <td id="LC443">                pMDII = <span>LookupMetaDataFromDebuggerForSingleFile</span>(pModule, mutableFilePath, dwImageTimeStamp, dwImageSize);</td>
      </tr>
      <tr>
        <td id="L444" data-line-number="444"></td>
        <td id="LC444">            );</td>
      </tr>
      <tr>
        <td id="L445" data-line-number="445"></td>
        <td id="LC445">
</td>
      </tr>
      <tr>
        <td id="L446" data-line-number="446"></td>
        <td id="LC446">            <span>if</span> (pMDII != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L447" data-line-number="447"></td>
        <td id="LC447">            {</td>
      </tr>
      <tr>
        <td id="L448" data-line-number="448"></td>
        <td id="LC448">                isILMetaDataForNGENImage = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L449" data-line-number="449"></td>
        <td id="LC449">            }</td>
      </tr>
      <tr>
        <td id="L450" data-line-number="450"></td>
        <td id="LC450">        }</td>
      </tr>
      <tr>
        <td id="L451" data-line-number="451"></td>
        <td id="LC451">    }</td>
      </tr>
      <tr>
        <td id="L452" data-line-number="452"></td>
        <td id="LC452">    <span>return</span> pMDII;</td>
      </tr>
      <tr>
        <td id="L453" data-line-number="453"></td>
        <td id="LC453">}</td>
      </tr>
      <tr>
        <td id="L454" data-line-number="454"></td>
        <td id="LC454">
</td>
      </tr>
      <tr>
        <td id="L455" data-line-number="455"></td>
        <td id="LC455"><span><span>//</span> We do not know if the image being sent to us is an IL image or ngen image.</span></td>
      </tr>
      <tr>
        <td id="L456" data-line-number="456"></td>
        <td id="LC456"><span><span>//</span> CordbProcess::LookupMetaDataFromDebugger() has this knowledge when it looks up the file to hand off</span></td>
      </tr>
      <tr>
        <td id="L457" data-line-number="457"></td>
        <td id="LC457"><span><span>//</span> to this function.</span></td>
      </tr>
      <tr>
        <td id="L458" data-line-number="458"></td>
        <td id="LC458"><span><span>//</span> DacDbiInterfaceImpl::GetMDImport() has this knowledge in the isNGEN flag.</span></td>
      </tr>
      <tr>
        <td id="L459" data-line-number="459"></td>
        <td id="LC459"><span><span>//</span> The CLR v2 code that windbg used made a distinction whether the metadata came from</span></td>
      </tr>
      <tr>
        <td id="L460" data-line-number="460"></td>
        <td id="LC460"><span><span>//</span> the exact binary or not (i.e. were we getting metadata from the IL image and using</span></td>
      </tr>
      <tr>
        <td id="L461" data-line-number="461"></td>
        <td id="LC461"><span><span>//</span> it against the ngen image?) but that information was never used and so not brought forward.</span></td>
      </tr>
      <tr>
        <td id="L462" data-line-number="462"></td>
        <td id="LC462"><span><span>//</span> It would probably be more interesting generally to track whether the debugger gives us back</span></td>
      </tr>
      <tr>
        <td id="L463" data-line-number="463"></td>
        <td id="LC463"><span><span>//</span> a file that bears some relationship to the file we asked for, which would catch the NI/IL case</span></td>
      </tr>
      <tr>
        <td id="L464" data-line-number="464"></td>
        <td id="LC464"><span><span>//</span> as well.</span></td>
      </tr>
      <tr>
        <td id="L465" data-line-number="465"></td>
        <td id="LC465">IMDInternalImport * <span>CordbProcess::LookupMetaDataFromDebuggerForSingleFile</span>(</td>
      </tr>
      <tr>
        <td id="L466" data-line-number="466"></td>
        <td id="LC466">    CordbModule * pModule,</td>
      </tr>
      <tr>
        <td id="L467" data-line-number="467"></td>
        <td id="LC467">    LPCWSTR pwszFilePath,</td>
      </tr>
      <tr>
        <td id="L468" data-line-number="468"></td>
        <td id="LC468">    DWORD dwTimeStamp,</td>
      </tr>
      <tr>
        <td id="L469" data-line-number="469"></td>
        <td id="LC469">    DWORD dwSize)</td>
      </tr>
      <tr>
        <td id="L470" data-line-number="470"></td>
        <td id="LC470">{</td>
      </tr>
      <tr>
        <td id="L471" data-line-number="471"></td>
        <td id="LC471">    <span>INTERNAL_DAC_CALLBACK</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L472" data-line-number="472"></td>
        <td id="LC472">
</td>
      </tr>
      <tr>
        <td id="L473" data-line-number="473"></td>
        <td id="LC473">    ULONG32 cchLocalImagePath = MAX_LONGPATH;</td>
      </tr>
      <tr>
        <td id="L474" data-line-number="474"></td>
        <td id="LC474">    ULONG32 cchLocalImagePathRequired;</td>
      </tr>
      <tr>
        <td id="L475" data-line-number="475"></td>
        <td id="LC475">    NewArrayHolder&lt;WCHAR&gt; pwszLocalFilePath = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L476" data-line-number="476"></td>
        <td id="LC476">    IMDInternalImport * pMDII = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L477" data-line-number="477"></td>
        <td id="LC477">
</td>
      </tr>
      <tr>
        <td id="L478" data-line-number="478"></td>
        <td id="LC478">    <span>const</span> HRESULT E_NSF_BUFFER = <span>HRESULT_FROM_WIN32</span>(ERROR_INSUFFICIENT_BUFFER);</td>
      </tr>
      <tr>
        <td id="L479" data-line-number="479"></td>
        <td id="LC479">    HRESULT hr = E_NSF_BUFFER;</td>
      </tr>
      <tr>
        <td id="L480" data-line-number="480"></td>
        <td id="LC480">    <span>for</span>(<span>unsigned</span> i=<span>0</span>; i&lt;<span>2</span> &amp;&amp; hr == E_NSF_BUFFER; i++)</td>
      </tr>
      <tr>
        <td id="L481" data-line-number="481"></td>
        <td id="LC481">    {</td>
      </tr>
      <tr>
        <td id="L482" data-line-number="482"></td>
        <td id="LC482">        <span>if</span> (pwszLocalFilePath != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L483" data-line-number="483"></td>
        <td id="LC483">            pwszLocalFilePath.<span>Release</span>();</td>
      </tr>
      <tr>
        <td id="L484" data-line-number="484"></td>
        <td id="LC484">
</td>
      </tr>
      <tr>
        <td id="L485" data-line-number="485"></td>
        <td id="LC485">        <span>if</span> (<span>NULL</span> == (pwszLocalFilePath = <span>new</span> (nothrow) WCHAR[cchLocalImagePath+<span>1</span>]))</td>
      </tr>
      <tr>
        <td id="L486" data-line-number="486"></td>
        <td id="LC486">            <span>ThrowHR</span>(E_OUTOFMEMORY);</td>
      </tr>
      <tr>
        <td id="L487" data-line-number="487"></td>
        <td id="LC487">
</td>
      </tr>
      <tr>
        <td id="L488" data-line-number="488"></td>
        <td id="LC488">        cchLocalImagePathRequired = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L489" data-line-number="489"></td>
        <td id="LC489">
</td>
      </tr>
      <tr>
        <td id="L490" data-line-number="490"></td>
        <td id="LC490">        hr = m_pMetaDataLocator-&gt;<span>GetMetaData</span>(pwszFilePath,</td>
      </tr>
      <tr>
        <td id="L491" data-line-number="491"></td>
        <td id="LC491">                                             dwTimeStamp,</td>
      </tr>
      <tr>
        <td id="L492" data-line-number="492"></td>
        <td id="LC492">                                             dwSize,</td>
      </tr>
      <tr>
        <td id="L493" data-line-number="493"></td>
        <td id="LC493">                                             cchLocalImagePath,</td>
      </tr>
      <tr>
        <td id="L494" data-line-number="494"></td>
        <td id="LC494">                                             &amp;cchLocalImagePathRequired,</td>
      </tr>
      <tr>
        <td id="L495" data-line-number="495"></td>
        <td id="LC495">                                             pwszLocalFilePath);</td>
      </tr>
      <tr>
        <td id="L496" data-line-number="496"></td>
        <td id="LC496">
</td>
      </tr>
      <tr>
        <td id="L497" data-line-number="497"></td>
        <td id="LC497">        pwszLocalFilePath[cchLocalImagePath] = <span>W</span>(<span><span>'</span><span>\0</span><span>'</span></span>);</td>
      </tr>
      <tr>
        <td id="L498" data-line-number="498"></td>
        <td id="LC498">        cchLocalImagePath = cchLocalImagePathRequired;</td>
      </tr>
      <tr>
        <td id="L499" data-line-number="499"></td>
        <td id="LC499">    }</td>
      </tr>
      <tr>
        <td id="L500" data-line-number="500"></td>
        <td id="LC500">
</td>
      </tr>
      <tr>
        <td id="L501" data-line-number="501"></td>
        <td id="LC501">    <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L502" data-line-number="502"></td>
        <td id="LC502">    {</td>
      </tr>
      <tr>
        <td id="L503" data-line-number="503"></td>
        <td id="LC503">        hr = pModule-&gt;<span>InitPublicMetaDataFromFile</span>(pwszLocalFilePath, ofReadOnly, <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L504" data-line-number="504"></td>
        <td id="LC504">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L505" data-line-number="505"></td>
        <td id="LC505">        {</td>
      </tr>
      <tr>
        <td id="L506" data-line-number="506"></td>
        <td id="LC506">            <span><span>//</span> While we're successfully returning a metadata reader, remember that there's</span></td>
      </tr>
      <tr>
        <td id="L507" data-line-number="507"></td>
        <td id="LC507">            <span><span>//</span> absolutely no guarantee this metadata is an exact match for the vmPEFile.</span></td>
      </tr>
      <tr>
        <td id="L508" data-line-number="508"></td>
        <td id="LC508">            <span><span>//</span> The debugger could literally send us back a path to any managed file with</span></td>
      </tr>
      <tr>
        <td id="L509" data-line-number="509"></td>
        <td id="LC509">            <span><span>//</span> metadata content that is readable and we'll 'succeed'.</span></td>
      </tr>
      <tr>
        <td id="L510" data-line-number="510"></td>
        <td id="LC510">            <span><span>//</span> For now, this is by-design.  A debugger should be allowed to decide if it wants</span></td>
      </tr>
      <tr>
        <td id="L511" data-line-number="511"></td>
        <td id="LC511">            <span><span>//</span> to take a risk by returning 'mostly matching' metadata to see if debugging is</span></td>
      </tr>
      <tr>
        <td id="L512" data-line-number="512"></td>
        <td id="LC512">            <span><span>//</span> possible in the absence of a true match.</span></td>
      </tr>
      <tr>
        <td id="L513" data-line-number="513"></td>
        <td id="LC513">            pMDII = pModule-&gt;<span>GetInternalMD</span>();</td>
      </tr>
      <tr>
        <td id="L514" data-line-number="514"></td>
        <td id="LC514">        }</td>
      </tr>
      <tr>
        <td id="L515" data-line-number="515"></td>
        <td id="LC515">    }</td>
      </tr>
      <tr>
        <td id="L516" data-line-number="516"></td>
        <td id="LC516">
</td>
      </tr>
      <tr>
        <td id="L517" data-line-number="517"></td>
        <td id="LC517">    <span>return</span> pMDII;</td>
      </tr>
      <tr>
        <td id="L518" data-line-number="518"></td>
        <td id="LC518">}</td>
      </tr>
      <tr>
        <td id="L519" data-line-number="519"></td>
        <td id="LC519">
</td>
      </tr>
      <tr>
        <td id="L520" data-line-number="520"></td>
        <td id="LC520">
</td>
      </tr>
      <tr>
        <td id="L521" data-line-number="521"></td>
        <td id="LC521"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L522" data-line-number="522"></td>
        <td id="LC522"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L523" data-line-number="523"></td>
        <td id="LC523"><span><span>//</span> Implement IDacDbiInterface::IAllocator::Alloc</span></td>
      </tr>
      <tr>
        <td id="L524" data-line-number="524"></td>
        <td id="LC524"><span><span>//</span> Expected to throws on error.</span></td>
      </tr>
      <tr>
        <td id="L525" data-line-number="525"></td>
        <td id="LC525"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L526" data-line-number="526"></td>
        <td id="LC526"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L527" data-line-number="527"></td>
        <td id="LC527"><span><span>//</span>    lenBytes - size of the byte array to allocate</span></td>
      </tr>
      <tr>
        <td id="L528" data-line-number="528"></td>
        <td id="LC528"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L529" data-line-number="529"></td>
        <td id="LC529"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L530" data-line-number="530"></td>
        <td id="LC530"><span><span>//</span>    Return the newly allocated byte array, or throw on OOM</span></td>
      </tr>
      <tr>
        <td id="L531" data-line-number="531"></td>
        <td id="LC531"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L532" data-line-number="532"></td>
        <td id="LC532"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L533" data-line-number="533"></td>
        <td id="LC533"><span><span>//</span>    Since this function is a callback from DAC, it must not take the process lock.</span></td>
      </tr>
      <tr>
        <td id="L534" data-line-number="534"></td>
        <td id="LC534"><span><span>//</span>    If it does, we may deadlock between the DD lock and the process lock.</span></td>
      </tr>
      <tr>
        <td id="L535" data-line-number="535"></td>
        <td id="LC535"><span><span>//</span>    If we really need to take the process lock for whatever reason, we must take it in the DBI functions</span></td>
      </tr>
      <tr>
        <td id="L536" data-line-number="536"></td>
        <td id="LC536"><span><span>//</span>    which call the DAC API that ends up calling this function.</span></td>
      </tr>
      <tr>
        <td id="L537" data-line-number="537"></td>
        <td id="LC537"><span><span>//</span>    See code:InternalDacCallbackHolder for more information.</span></td>
      </tr>
      <tr>
        <td id="L538" data-line-number="538"></td>
        <td id="LC538"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L539" data-line-number="539"></td>
        <td id="LC539">
</td>
      </tr>
      <tr>
        <td id="L540" data-line-number="540"></td>
        <td id="LC540"><span>void</span> * <span>CordbProcess::Alloc</span>(SIZE_T lenBytes)</td>
      </tr>
      <tr>
        <td id="L541" data-line-number="541"></td>
        <td id="LC541">{</td>
      </tr>
      <tr>
        <td id="L542" data-line-number="542"></td>
        <td id="LC542">    <span>return</span> <span>new</span> BYTE[lenBytes]; <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L543" data-line-number="543"></td>
        <td id="LC543">}</td>
      </tr>
      <tr>
        <td id="L544" data-line-number="544"></td>
        <td id="LC544">
</td>
      </tr>
      <tr>
        <td id="L545" data-line-number="545"></td>
        <td id="LC545"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L546" data-line-number="546"></td>
        <td id="LC546"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L547" data-line-number="547"></td>
        <td id="LC547"><span><span>//</span> Implements IDacDbiInterface::IAllocator::Free</span></td>
      </tr>
      <tr>
        <td id="L548" data-line-number="548"></td>
        <td id="LC548"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L549" data-line-number="549"></td>
        <td id="LC549"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L550" data-line-number="550"></td>
        <td id="LC550"><span><span>//</span>    p - pointer to the memory to be released</span></td>
      </tr>
      <tr>
        <td id="L551" data-line-number="551"></td>
        <td id="LC551"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L552" data-line-number="552"></td>
        <td id="LC552"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L553" data-line-number="553"></td>
        <td id="LC553"><span><span>//</span>    Since this function is a callback from DAC, it must not take the process lock.</span></td>
      </tr>
      <tr>
        <td id="L554" data-line-number="554"></td>
        <td id="LC554"><span><span>//</span>    If it does, we may deadlock between the DD lock and the process lock.</span></td>
      </tr>
      <tr>
        <td id="L555" data-line-number="555"></td>
        <td id="LC555"><span><span>//</span>    If we really need to take the process lock for whatever reason, we must take it in the DBI functions</span></td>
      </tr>
      <tr>
        <td id="L556" data-line-number="556"></td>
        <td id="LC556"><span><span>//</span>    which call the DAC API that ends up calling this function.</span></td>
      </tr>
      <tr>
        <td id="L557" data-line-number="557"></td>
        <td id="LC557"><span><span>//</span>    See code:InternalDacCallbackHolder for more information.</span></td>
      </tr>
      <tr>
        <td id="L558" data-line-number="558"></td>
        <td id="LC558"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L559" data-line-number="559"></td>
        <td id="LC559">
</td>
      </tr>
      <tr>
        <td id="L560" data-line-number="560"></td>
        <td id="LC560"><span>void</span> <span>CordbProcess::Free</span>(<span>void</span> * p)</td>
      </tr>
      <tr>
        <td id="L561" data-line-number="561"></td>
        <td id="LC561">{</td>
      </tr>
      <tr>
        <td id="L562" data-line-number="562"></td>
        <td id="LC562">    <span><span>//</span> This shouldn't throw.</span></td>
      </tr>
      <tr>
        <td id="L563" data-line-number="563"></td>
        <td id="LC563">    <span>delete []</span> ((BYTE *) p);</td>
      </tr>
      <tr>
        <td id="L564" data-line-number="564"></td>
        <td id="LC564">}</td>
      </tr>
      <tr>
        <td id="L565" data-line-number="565"></td>
        <td id="LC565">
</td>
      </tr>
      <tr>
        <td id="L566" data-line-number="566"></td>
        <td id="LC566">
</td>
      </tr>
      <tr>
        <td id="L567" data-line-number="567"></td>
        <td id="LC567"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L568" data-line-number="568"></td>
        <td id="LC568"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L569" data-line-number="569"></td>
        <td id="LC569"><span><span>//</span> #DBIVersionChecking</span></td>
      </tr>
      <tr>
        <td id="L570" data-line-number="570"></td>
        <td id="LC570"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L571" data-line-number="571"></td>
        <td id="LC571"><span><span>//</span> There are a few checks we need to do to make sure we are using the matching DBI and DAC for a particular</span></td>
      </tr>
      <tr>
        <td id="L572" data-line-number="572"></td>
        <td id="LC572"><span><span>//</span> version of the runtime.</span></td>
      </tr>
      <tr>
        <td id="L573" data-line-number="573"></td>
        <td id="LC573"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L574" data-line-number="574"></td>
        <td id="LC574"><span><span>//</span> 1. Runtime vs. DBI</span></td>
      </tr>
      <tr>
        <td id="L575" data-line-number="575"></td>
        <td id="LC575"><span><span>//</span>     - Desktop</span></td>
      </tr>
      <tr>
        <td id="L576" data-line-number="576"></td>
        <td id="LC576"><span><span>//</span>         This is done by making sure that the CorDebugInterfaceVersion passed to code:CreateCordbObject is</span></td>
      </tr>
      <tr>
        <td id="L577" data-line-number="577"></td>
        <td id="LC577"><span><span>//</span>         compatible with the version of the DBI.</span></td>
      </tr>
      <tr>
        <td id="L578" data-line-number="578"></td>
        <td id="LC578"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L579" data-line-number="579"></td>
        <td id="LC579"><span><span>//</span>     - Windows CoreCLR</span></td>
      </tr>
      <tr>
        <td id="L580" data-line-number="580"></td>
        <td id="LC580"><span><span>//</span>         This is done by dbgshim.dll.  It checks whether the runtime DLL and the DBI DLL have the same</span></td>
      </tr>
      <tr>
        <td id="L581" data-line-number="581"></td>
        <td id="LC581"><span><span>//</span>         product version.  See CreateDebuggingInterfaceForVersion() in dbgshim.cpp.</span></td>
      </tr>
      <tr>
        <td id="L582" data-line-number="582"></td>
        <td id="LC582"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L583" data-line-number="583"></td>
        <td id="LC583"><span><span>//</span>     - Remote transport (Mac CoreCLR + CoreSystem CoreCLR)</span></td>
      </tr>
      <tr>
        <td id="L584" data-line-number="584"></td>
        <td id="LC584"><span><span>//</span>         Since there is no dbgshim.dll for a remote CoreCLR, we have to do this check in some other place.</span></td>
      </tr>
      <tr>
        <td id="L585" data-line-number="585"></td>
        <td id="LC585"><span><span>//</span>         We do this in code:CordbProcess::CreateDacDbiInterface, by calling</span></td>
      </tr>
      <tr>
        <td id="L586" data-line-number="586"></td>
        <td id="LC586"><span><span>//</span>         code:DacDbiInterfaceImpl::CheckDbiVersion right after we have created the DDMarshal.</span></td>
      </tr>
      <tr>
        <td id="L587" data-line-number="587"></td>
        <td id="LC587"><span><span>//</span>         The IDacDbiInterface implementation on remote device checks the product version of the device</span></td>
      </tr>
      <tr>
        <td id="L588" data-line-number="588"></td>
        <td id="LC588"><span><span>//</span>         coreclr by:</span></td>
      </tr>
      <tr>
        <td id="L589" data-line-number="589"></td>
        <td id="LC589"><span><span>//</span>             mac - looking at the Info.plist file in the CoreCLR bundle.</span></td>
      </tr>
      <tr>
        <td id="L590" data-line-number="590"></td>
        <td id="LC590"><span><span>//</span>             CoreSystem - this check is skipped at the moment, but should be implemented if we release it</span></td>
      </tr>
      <tr>
        <td id="L591" data-line-number="591"></td>
        <td id="LC591"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L592" data-line-number="592"></td>
        <td id="LC592"><span><span>//</span>         The one twist here is that the DBI needs to communicate with the IDacDbiInterface</span></td>
      </tr>
      <tr>
        <td id="L593" data-line-number="593"></td>
        <td id="LC593"><span><span>//</span>         implementation on the device BEFORE it can verify the product versions.  This means that we need to</span></td>
      </tr>
      <tr>
        <td id="L594" data-line-number="594"></td>
        <td id="LC594"><span><span>//</span>         have one IDacDbiInterface API which is consistent across all versions of the IDacDbiInterface.</span></td>
      </tr>
      <tr>
        <td id="L595" data-line-number="595"></td>
        <td id="LC595"><span><span>//</span>         This puts two constraints on CheckDbiVersion():</span></td>
      </tr>
      <tr>
        <td id="L596" data-line-number="596"></td>
        <td id="LC596"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L597" data-line-number="597"></td>
        <td id="LC597"><span><span>//</span>             1.  It has to be the first API on the IDacDbiInterface.</span></td>
      </tr>
      <tr>
        <td id="L598" data-line-number="598"></td>
        <td id="LC598"><span><span>//</span>             - Otherwise, a wrong version of the DBI may end up calling a different API on the</span></td>
      </tr>
      <tr>
        <td id="L599" data-line-number="599"></td>
        <td id="LC599"><span><span>//</span>               IDacDbiInterface and getting random results. (Really what matters is that it is</span></td>
      </tr>
      <tr>
        <td id="L600" data-line-number="600"></td>
        <td id="LC600"><span><span>//</span>               protocol message id 0, at present the source code position implies the message id)</span></td>
      </tr>
      <tr>
        <td id="L601" data-line-number="601"></td>
        <td id="LC601"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L602" data-line-number="602"></td>
        <td id="LC602"><span><span>//</span>             2.  Its parameters cannot change.</span></td>
      </tr>
      <tr>
        <td id="L603" data-line-number="603"></td>
        <td id="LC603"><span><span>//</span>             - Otherwise, we may run into random errors when we marshal/unmarshal the arguments for the</span></td>
      </tr>
      <tr>
        <td id="L604" data-line-number="604"></td>
        <td id="LC604"><span><span>//</span>               call to CheckDbiVersion().  Debugging will still fail, but we won't get the</span></td>
      </tr>
      <tr>
        <td id="L605" data-line-number="605"></td>
        <td id="LC605"><span><span>//</span>               version mismatch error. (Again, the protocol is what ultimately matters)</span></td>
      </tr>
      <tr>
        <td id="L606" data-line-number="606"></td>
        <td id="LC606"><span><span>//</span>             - To mitigate the impact of this constraint, we use the code:DbiVersion structure.</span></td>
      </tr>
      <tr>
        <td id="L607" data-line-number="607"></td>
        <td id="LC607"><span><span>//</span>               In addition to the DBI version, it also contains a format number (in case we decide to</span></td>
      </tr>
      <tr>
        <td id="L608" data-line-number="608"></td>
        <td id="LC608"><span><span>//</span>               check something else in the future), a breaking change number so that we can force</span></td>
      </tr>
      <tr>
        <td id="L609" data-line-number="609"></td>
        <td id="LC609"><span><span>//</span>               breaking changes between a DBI and a DAC, and space reserved for future use.</span></td>
      </tr>
      <tr>
        <td id="L610" data-line-number="610"></td>
        <td id="LC610"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L611" data-line-number="611"></td>
        <td id="LC611"><span><span>//</span> 2. DBI vs. DAC</span></td>
      </tr>
      <tr>
        <td id="L612" data-line-number="612"></td>
        <td id="LC612"><span><span>//</span>     - Desktop and Windows CoreCLR (old architecture)</span></td>
      </tr>
      <tr>
        <td id="L613" data-line-number="613"></td>
        <td id="LC613"><span><span>//</span>          No verification is done. There is a transitive implication that if DBI matches runtime and DAC matches</span></td>
      </tr>
      <tr>
        <td id="L614" data-line-number="614"></td>
        <td id="LC614"><span><span>//</span>          runtime then DBI matches DAC. Technically because the DBI only matches runtime on major version number</span></td>
      </tr>
      <tr>
        <td id="L615" data-line-number="615"></td>
        <td id="LC615"><span><span>//</span>          runtime and DAC could be from different builds. However because we service all three binaries together</span></td>
      </tr>
      <tr>
        <td id="L616" data-line-number="616"></td>
        <td id="LC616"><span><span>//</span>          and DBI always loads the DAC that is sitting in the same directory DAC and DBI generally get tight</span></td>
      </tr>
      <tr>
        <td id="L617" data-line-number="617"></td>
        <td id="LC617"><span><span>//</span>          version coupling. A user with admin privleges could put different builds together and no version check</span></td>
      </tr>
      <tr>
        <td id="L618" data-line-number="618"></td>
        <td id="LC618"><span><span>//</span>          would ever fail though.</span></td>
      </tr>
      <tr>
        <td id="L619" data-line-number="619"></td>
        <td id="LC619"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L620" data-line-number="620"></td>
        <td id="LC620"><span><span>//</span>      - Desktop and Windows CoreCLR (new architecture)</span></td>
      </tr>
      <tr>
        <td id="L621" data-line-number="621"></td>
        <td id="LC621"><span><span>//</span>          No verification is done. Similar to above its implied that if DBI matches runtime and runtime matches</span></td>
      </tr>
      <tr>
        <td id="L622" data-line-number="622"></td>
        <td id="LC622"><span><span>//</span>          DAC then DBI matches DAC. The only difference is that here both the DBI and DAC are provided by the</span></td>
      </tr>
      <tr>
        <td id="L623" data-line-number="623"></td>
        <td id="LC623"><span><span>//</span>          debugger. We provide timestamp and filesize for both binaries which are relatively strongly bound hints,</span></td>
      </tr>
      <tr>
        <td id="L624" data-line-number="624"></td>
        <td id="LC624"><span><span>//</span>          but there is no enforcement on the returned binaries beyond the runtime compat checking.</span></td>
      </tr>
      <tr>
        <td id="L625" data-line-number="625"></td>
        <td id="LC625"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L626" data-line-number="626"></td>
        <td id="LC626"><span><span>//</span>      - Remote transport (Mac CoreCLR and CoreSystem CoreCLR)</span></td>
      </tr>
      <tr>
        <td id="L627" data-line-number="627"></td>
        <td id="LC627"><span><span>//</span>          Because the transport exists between DBI and DAC it becomes much more important to do a versioning check</span></td>
      </tr>
      <tr>
        <td id="L628" data-line-number="628"></td>
        <td id="LC628"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L629" data-line-number="629"></td>
        <td id="LC629"><span><span>//</span>          Mac - currently does a tightly bound version check between DBI and the runtime (CheckDbiVersion() above),</span></td>
      </tr>
      <tr>
        <td id="L630" data-line-number="630"></td>
        <td id="LC630"><span><span>//</span>             which transitively gives a tightly bound check to DAC. In same function there is also a check that is</span></td>
      </tr>
      <tr>
        <td id="L631" data-line-number="631"></td>
        <td id="LC631"><span><span>//</span>             logically a DAC DBI protocol check, verifying that the m_dwProtocolBreakingChangeCounter of DbiVersion</span></td>
      </tr>
      <tr>
        <td id="L632" data-line-number="632"></td>
        <td id="LC632"><span><span>//</span>             matches. However this check should be weaker than the build version check and doesn't add anything here.</span></td>
      </tr>
      <tr>
        <td id="L633" data-line-number="633"></td>
        <td id="LC633"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L634" data-line-number="634"></td>
        <td id="LC634"><span><span>//</span>          CoreSystem - currently skips the tightly bound version check to make internal deployment and usage easier.</span></td>
      </tr>
      <tr>
        <td id="L635" data-line-number="635"></td>
        <td id="LC635"><span><span>//</span>             We want to use old desktop side debugger components to target newer CoreCLR builds, only forcing a desktop</span></td>
      </tr>
      <tr>
        <td id="L636" data-line-number="636"></td>
        <td id="LC636"><span><span>//</span>             upgrade when the protocol actually does change. To do this we use two checks:</span></td>
      </tr>
      <tr>
        <td id="L637" data-line-number="637"></td>
        <td id="LC637"><span><span>//</span>             1. The breaking change counter in CheckDbiVersion() whenever a dev knows they are breaking back</span></td>
      </tr>
      <tr>
        <td id="L638" data-line-number="638"></td>
        <td id="LC638"><span><span>//</span>                compat and wants to be explicit about it. This is the same as mac above.</span></td>
      </tr>
      <tr>
        <td id="L639" data-line-number="639"></td>
        <td id="LC639"><span><span>//</span>             2. During the auto-generation of the DDMarshal classes we take an MD5 hash of IDacDbiInterface source</span></td>
      </tr>
      <tr>
        <td id="L640" data-line-number="640"></td>
        <td id="LC640"><span><span>//</span>                code and embed it in two DDMarshal functions, one which runs locally and one that runs remotely.</span></td>
      </tr>
      <tr>
        <td id="L641" data-line-number="641"></td>
        <td id="LC641"><span><span>//</span>                If both DBI and DAC were built from the same source then the local and remote hashes will match. If the</span></td>
      </tr>
      <tr>
        <td id="L642" data-line-number="642"></td>
        <td id="LC642"><span><span>//</span>                hashes don't match then we assume there has been a been a breaking change in the protocol. Note</span></td>
      </tr>
      <tr>
        <td id="L643" data-line-number="643"></td>
        <td id="LC643"><span><span>//</span>                this hash could have both false-positives and false-negatives. False positives could occur when</span></td>
      </tr>
      <tr>
        <td id="L644" data-line-number="644"></td>
        <td id="LC644"><span><span>//</span>                IDacDbiInterface is changed in a trivial way, such as changing a comment. False negatives could</span></td>
      </tr>
      <tr>
        <td id="L645" data-line-number="645"></td>
        <td id="LC645"><span><span>//</span>                occur when the semantics of the protocol are changed even though the interface is not. Another</span></td>
      </tr>
      <tr>
        <td id="L646" data-line-number="646"></td>
        <td id="LC646"><span><span>//</span>                case would be changing the DDMarshal proxy generation code. In addition to the hashes we also</span></td>
      </tr>
      <tr>
        <td id="L647" data-line-number="647"></td>
        <td id="LC647"><span><span>//</span>                embed timestamps when the auto-generated code was produced. However this isn't used for version</span></td>
      </tr>
      <tr>
        <td id="L648" data-line-number="648"></td>
        <td id="LC648"><span><span>//</span>                matching, only as a hint to indicate which of two mismatched versions is newer.</span></td>
      </tr>
      <tr>
        <td id="L649" data-line-number="649"></td>
        <td id="LC649"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L650" data-line-number="650"></td>
        <td id="LC650"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L651" data-line-number="651"></td>
        <td id="LC651"><span><span>//</span> 3. Runtime vs. DAC</span></td>
      </tr>
      <tr>
        <td id="L652" data-line-number="652"></td>
        <td id="LC652"><span><span>//</span>     - Desktop, Windows CoreCLR, CoreSystem CoreCLR</span></td>
      </tr>
      <tr>
        <td id="L653" data-line-number="653"></td>
        <td id="LC653"><span><span>//</span>         In both cases we check this by matching the timestamp in the debug directory of the runtime image</span></td>
      </tr>
      <tr>
        <td id="L654" data-line-number="654"></td>
        <td id="LC654"><span><span>//</span>         and the timestamp we store in the DAC table when we generate the DAC dll.  This is done in</span></td>
      </tr>
      <tr>
        <td id="L655" data-line-number="655"></td>
        <td id="LC655"><span><span>//</span>         code:ClrDataAccess::VerifyDlls.</span></td>
      </tr>
      <tr>
        <td id="L656" data-line-number="656"></td>
        <td id="LC656"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L657" data-line-number="657"></td>
        <td id="LC657"><span><span>//</span>     - Mac CoreCLR</span></td>
      </tr>
      <tr>
        <td id="L658" data-line-number="658"></td>
        <td id="LC658"><span><span>//</span>         On Mac, we don't have a timestamp in the runtime image.  Instead, we rely on checking the 16-byte</span></td>
      </tr>
      <tr>
        <td id="L659" data-line-number="659"></td>
        <td id="LC659"><span><span>//</span>         UUID in the image.  This UUID is used to check whether a symbol file matches the image, so</span></td>
      </tr>
      <tr>
        <td id="L660" data-line-number="660"></td>
        <td id="LC660"><span><span>//</span>         conceptually it's the same as the timestamp we use on Windows.  This is also done in</span></td>
      </tr>
      <tr>
        <td id="L661" data-line-number="661"></td>
        <td id="LC661"><span><span>//</span>         code:ClrDataAccess::VerifyDlls.</span></td>
      </tr>
      <tr>
        <td id="L662" data-line-number="662"></td>
        <td id="LC662"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L663" data-line-number="663"></td>
        <td id="LC663"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L664" data-line-number="664"></td>
        <td id="LC664"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L665" data-line-number="665"></td>
        <td id="LC665"><span><span>//</span> Instantiates a DacDbi Interface object in a live-debugging scenario that matches</span></td>
      </tr>
      <tr>
        <td id="L666" data-line-number="666"></td>
        <td id="LC666"><span><span>//</span> the current instance of mscorwks in this process.</span></td>
      </tr>
      <tr>
        <td id="L667" data-line-number="667"></td>
        <td id="LC667"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L668" data-line-number="668"></td>
        <td id="LC668"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L669" data-line-number="669"></td>
        <td id="LC669"><span><span>//</span>    Returns on success. Else throws.</span></td>
      </tr>
      <tr>
        <td id="L670" data-line-number="670"></td>
        <td id="LC670"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L671" data-line-number="671"></td>
        <td id="LC671"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L672" data-line-number="672"></td>
        <td id="LC672"><span><span>//</span>    Client will code:CordbProcess::FreeDac when its done with the DacDbi interface.</span></td>
      </tr>
      <tr>
        <td id="L673" data-line-number="673"></td>
        <td id="LC673"><span><span>//</span>    Caller has initialized clrInstanceId.</span></td>
      </tr>
      <tr>
        <td id="L674" data-line-number="674"></td>
        <td id="LC674"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L675" data-line-number="675"></td>
        <td id="LC675"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L676" data-line-number="676"></td>
        <td id="LC676"><span><span>//</span>    This looks for the DAC next to this current DBI. This assumes that Dac and Dbi are both on</span></td>
      </tr>
      <tr>
        <td id="L677" data-line-number="677"></td>
        <td id="LC677"><span><span>//</span>    the local file system. That assumption will break in zero-copy deployment scenarios.</span></td>
      </tr>
      <tr>
        <td id="L678" data-line-number="678"></td>
        <td id="LC678"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L679" data-line-number="679"></td>
        <td id="LC679"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L680" data-line-number="680"></td>
        <td id="LC680"><span>void</span></td>
      </tr>
      <tr>
        <td id="L681" data-line-number="681"></td>
        <td id="LC681"><span>CordbProcess::CreateDacDbiInterface</span>()</td>
      </tr>
      <tr>
        <td id="L682" data-line-number="682"></td>
        <td id="LC682">{</td>
      </tr>
      <tr>
        <td id="L683" data-line-number="683"></td>
        <td id="LC683">    <span>_ASSERTE</span>(m_pDACDataTarget != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L684" data-line-number="684"></td>
        <td id="LC684">    <span>_ASSERTE</span>(m_pDacPrimitives == <span>NULL</span>); <span><span>//</span> don't double-init</span></td>
      </tr>
      <tr>
        <td id="L685" data-line-number="685"></td>
        <td id="LC685">
</td>
      </tr>
      <tr>
        <td id="L686" data-line-number="686"></td>
        <td id="LC686">    <span><span>//</span> Caller has already determined which CLR in the target is being debugged.</span></td>
      </tr>
      <tr>
        <td id="L687" data-line-number="687"></td>
        <td id="LC687">    <span>_ASSERTE</span>(m_clrInstanceId != <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L688" data-line-number="688"></td>
        <td id="LC688">
</td>
      </tr>
      <tr>
        <td id="L689" data-line-number="689"></td>
        <td id="LC689">    m_pDacPrimitives = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L690" data-line-number="690"></td>
        <td id="LC690">
</td>
      </tr>
      <tr>
        <td id="L691" data-line-number="691"></td>
        <td id="LC691">    HRESULT hrStatus = S_OK;</td>
      </tr>
      <tr>
        <td id="L692" data-line-number="692"></td>
        <td id="LC692">
</td>
      </tr>
      <tr>
        <td id="L693" data-line-number="693"></td>
        <td id="LC693">    <span><span>//</span> Non-marshalling path for live local dac.</span></td>
      </tr>
      <tr>
        <td id="L694" data-line-number="694"></td>
        <td id="LC694">    <span><span>//</span> in the new arch we can get the module from OpenVirtualProcess2 but in the shim case</span></td>
      </tr>
      <tr>
        <td id="L695" data-line-number="695"></td>
        <td id="LC695">    <span><span>//</span> and the deprecated OpenVirtualProcess case we must assume it comes from DAC in the</span></td>
      </tr>
      <tr>
        <td id="L696" data-line-number="696"></td>
        <td id="LC696">    <span><span>//</span> same directory as DBI</span></td>
      </tr>
      <tr>
        <td id="L697" data-line-number="697"></td>
        <td id="LC697">    <span>if</span>(m_hDacModule == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L698" data-line-number="698"></td>
        <td id="LC698">    {</td>
      </tr>
      <tr>
        <td id="L699" data-line-number="699"></td>
        <td id="LC699">        m_hDacModule.<span>Assign</span>(<span>ShimProcess::GetDacModule</span>());</td>
      </tr>
      <tr>
        <td id="L700" data-line-number="700"></td>
        <td id="LC700">    }</td>
      </tr>
      <tr>
        <td id="L701" data-line-number="701"></td>
        <td id="LC701">
</td>
      </tr>
      <tr>
        <td id="L702" data-line-number="702"></td>
        <td id="LC702">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L703" data-line-number="703"></td>
        <td id="LC703">    <span><span>//</span> Get the access interface, passing our callback interfaces (data target, allocator and metadata lookup)</span></td>
      </tr>
      <tr>
        <td id="L704" data-line-number="704"></td>
        <td id="LC704">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L705" data-line-number="705"></td>
        <td id="LC705">
</td>
      </tr>
      <tr>
        <td id="L706" data-line-number="706"></td>
        <td id="LC706">    IDacDbiInterface::IAllocator * pAllocator = <span>this</span>;</td>
      </tr>
      <tr>
        <td id="L707" data-line-number="707"></td>
        <td id="LC707">    IDacDbiInterface::IMetaDataLookup * pMetaDataLookup = <span>this</span>;</td>
      </tr>
      <tr>
        <td id="L708" data-line-number="708"></td>
        <td id="LC708">
</td>
      </tr>
      <tr>
        <td id="L709" data-line-number="709"></td>
        <td id="LC709">
</td>
      </tr>
      <tr>
        <td id="L710" data-line-number="710"></td>
        <td id="LC710">    <span>typedef</span> <span>HRESULT</span> (STDAPICALLTYPE * PFN_DacDbiInterfaceInstance)(</td>
      </tr>
      <tr>
        <td id="L711" data-line-number="711"></td>
        <td id="LC711">        ICorDebugDataTarget *,</td>
      </tr>
      <tr>
        <td id="L712" data-line-number="712"></td>
        <td id="LC712">        CORDB_ADDRESS,</td>
      </tr>
      <tr>
        <td id="L713" data-line-number="713"></td>
        <td id="LC713">        IDacDbiInterface::IAllocator *,</td>
      </tr>
      <tr>
        <td id="L714" data-line-number="714"></td>
        <td id="LC714">        IDacDbiInterface::IMetaDataLookup *,</td>
      </tr>
      <tr>
        <td id="L715" data-line-number="715"></td>
        <td id="LC715">        IDacDbiInterface **);</td>
      </tr>
      <tr>
        <td id="L716" data-line-number="716"></td>
        <td id="LC716">
</td>
      </tr>
      <tr>
        <td id="L717" data-line-number="717"></td>
        <td id="LC717">    IDacDbiInterface* pInterfacePtr = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L718" data-line-number="718"></td>
        <td id="LC718">    PFN_DacDbiInterfaceInstance pfnEntry = (PFN_DacDbiInterfaceInstance)<span>GetProcAddress</span>(m_hDacModule, <span><span>"</span>DacDbiInterfaceInstance<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L719" data-line-number="719"></td>
        <td id="LC719">    <span>if</span> (!pfnEntry)</td>
      </tr>
      <tr>
        <td id="L720" data-line-number="720"></td>
        <td id="LC720">    {</td>
      </tr>
      <tr>
        <td id="L721" data-line-number="721"></td>
        <td id="LC721">        <span>ThrowLastError</span>();</td>
      </tr>
      <tr>
        <td id="L722" data-line-number="722"></td>
        <td id="LC722">    }</td>
      </tr>
      <tr>
        <td id="L723" data-line-number="723"></td>
        <td id="LC723">
</td>
      </tr>
      <tr>
        <td id="L724" data-line-number="724"></td>
        <td id="LC724">    hrStatus = <span>pfnEntry</span>(m_pDACDataTarget, m_clrInstanceId, pAllocator, pMetaDataLookup, &amp;pInterfacePtr);</td>
      </tr>
      <tr>
        <td id="L725" data-line-number="725"></td>
        <td id="LC725">    <span>IfFailThrow</span>(hrStatus);</td>
      </tr>
      <tr>
        <td id="L726" data-line-number="726"></td>
        <td id="LC726">
</td>
      </tr>
      <tr>
        <td id="L727" data-line-number="727"></td>
        <td id="LC727">    <span><span>//</span> We now have a resource, pInterfacePtr, that needs to be freed.</span></td>
      </tr>
      <tr>
        <td id="L728" data-line-number="728"></td>
        <td id="LC728">    m_pDacPrimitives = pInterfacePtr;</td>
      </tr>
      <tr>
        <td id="L729" data-line-number="729"></td>
        <td id="LC729">
</td>
      </tr>
      <tr>
        <td id="L730" data-line-number="730"></td>
        <td id="LC730">    <span><span>//</span> Setup DAC target consistency checking based on what we're using for DBI</span></td>
      </tr>
      <tr>
        <td id="L731" data-line-number="731"></td>
        <td id="LC731">    m_pDacPrimitives-&gt;<span>DacSetTargetConsistencyChecks</span>( m_fAssertOnTargetInconsistency );</td>
      </tr>
      <tr>
        <td id="L732" data-line-number="732"></td>
        <td id="LC732">}</td>
      </tr>
      <tr>
        <td id="L733" data-line-number="733"></td>
        <td id="LC733">
</td>
      </tr>
      <tr>
        <td id="L734" data-line-number="734"></td>
        <td id="LC734"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L735" data-line-number="735"></td>
        <td id="LC735"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L736" data-line-number="736"></td>
        <td id="LC736"><span><span>//</span> Is the DAC/DBI interface initialized?</span></td>
      </tr>
      <tr>
        <td id="L737" data-line-number="737"></td>
        <td id="LC737"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L738" data-line-number="738"></td>
        <td id="LC738"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L739" data-line-number="739"></td>
        <td id="LC739"><span><span>//</span>    TRUE iff init.</span></td>
      </tr>
      <tr>
        <td id="L740" data-line-number="740"></td>
        <td id="LC740"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L741" data-line-number="741"></td>
        <td id="LC741"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L742" data-line-number="742"></td>
        <td id="LC742"><span><span>//</span>    The RS will try to initialize DD as soon as it detects the runtime as loaded.</span></td>
      </tr>
      <tr>
        <td id="L743" data-line-number="743"></td>
        <td id="LC743"><span><span>//</span>    If the DD interface has not initialized, then it very likely the runtime has not</span></td>
      </tr>
      <tr>
        <td id="L744" data-line-number="744"></td>
        <td id="LC744"><span><span>//</span>    been loaded into the target.</span></td>
      </tr>
      <tr>
        <td id="L745" data-line-number="745"></td>
        <td id="LC745"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L746" data-line-number="746"></td>
        <td id="LC746">BOOL <span>CordbProcess::IsDacInitialized</span>()</td>
      </tr>
      <tr>
        <td id="L747" data-line-number="747"></td>
        <td id="LC747">{</td>
      </tr>
      <tr>
        <td id="L748" data-line-number="748"></td>
        <td id="LC748">    <span>return</span> m_pDacPrimitives != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L749" data-line-number="749"></td>
        <td id="LC749">}</td>
      </tr>
      <tr>
        <td id="L750" data-line-number="750"></td>
        <td id="LC750">
</td>
      </tr>
      <tr>
        <td id="L751" data-line-number="751"></td>
        <td id="LC751"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L752" data-line-number="752"></td>
        <td id="LC752"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L753" data-line-number="753"></td>
        <td id="LC753"><span><span>//</span> Get the DAC interface.</span></td>
      </tr>
      <tr>
        <td id="L754" data-line-number="754"></td>
        <td id="LC754"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L755" data-line-number="755"></td>
        <td id="LC755"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L756" data-line-number="756"></td>
        <td id="LC756"><span><span>//</span>    the Dac/Dbi interface pointer to the process.</span></td>
      </tr>
      <tr>
        <td id="L757" data-line-number="757"></td>
        <td id="LC757"><span><span>//</span>    Never returns NULL.</span></td>
      </tr>
      <tr>
        <td id="L758" data-line-number="758"></td>
        <td id="LC758"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L759" data-line-number="759"></td>
        <td id="LC759"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L760" data-line-number="760"></td>
        <td id="LC760"><span><span>//</span>    Caller is responsible for ensuring Data-Target is safe to access (eg, not</span></td>
      </tr>
      <tr>
        <td id="L761" data-line-number="761"></td>
        <td id="LC761"><span><span>//</span>    currently running).</span></td>
      </tr>
      <tr>
        <td id="L762" data-line-number="762"></td>
        <td id="LC762"><span><span>//</span>    Caller is responsible for ensuring DAC-cache is flushed. Call code:CordbProcess::ForceDacFlush</span></td>
      </tr>
      <tr>
        <td id="L763" data-line-number="763"></td>
        <td id="LC763"><span><span>//</span>    as needed.</span></td>
      </tr>
      <tr>
        <td id="L764" data-line-number="764"></td>
        <td id="LC764"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L765" data-line-number="765"></td>
        <td id="LC765"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L766" data-line-number="766"></td>
        <td id="LC766">IDacDbiInterface * <span>CordbProcess::GetDAC</span>()</td>
      </tr>
      <tr>
        <td id="L767" data-line-number="767"></td>
        <td id="LC767">{</td>
      </tr>
      <tr>
        <td id="L768" data-line-number="768"></td>
        <td id="LC768">    <span><span>//</span> Since the DD primitives may throw, easiest way to model that is to make this throw.</span></td>
      </tr>
      <tr>
        <td id="L769" data-line-number="769"></td>
        <td id="LC769">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L770" data-line-number="770"></td>
        <td id="LC770">    {</td>
      </tr>
      <tr>
        <td id="L771" data-line-number="771"></td>
        <td id="LC771">        THROWS;</td>
      </tr>
      <tr>
        <td id="L772" data-line-number="772"></td>
        <td id="LC772">    }</td>
      </tr>
      <tr>
        <td id="L773" data-line-number="773"></td>
        <td id="LC773">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L774" data-line-number="774"></td>
        <td id="LC774">
</td>
      </tr>
      <tr>
        <td id="L775" data-line-number="775"></td>
        <td id="LC775">    <span><span>//</span> We should always have the DAC/DBI interface.</span></td>
      </tr>
      <tr>
        <td id="L776" data-line-number="776"></td>
        <td id="LC776">    <span>_ASSERTE</span>(m_pDacPrimitives != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L777" data-line-number="777"></td>
        <td id="LC777">    <span>return</span> m_pDacPrimitives;</td>
      </tr>
      <tr>
        <td id="L778" data-line-number="778"></td>
        <td id="LC778">}</td>
      </tr>
      <tr>
        <td id="L779" data-line-number="779"></td>
        <td id="LC779">
</td>
      </tr>
      <tr>
        <td id="L780" data-line-number="780"></td>
        <td id="LC780"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L781" data-line-number="781"></td>
        <td id="LC781"><span><span>//</span> Get the Data-Target</span></td>
      </tr>
      <tr>
        <td id="L782" data-line-number="782"></td>
        <td id="LC782"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L783" data-line-number="783"></td>
        <td id="LC783"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L784" data-line-number="784"></td>
        <td id="LC784"><span><span>//</span>     pointer to the data-target. Should be non-null.</span></td>
      </tr>
      <tr>
        <td id="L785" data-line-number="785"></td>
        <td id="LC785"><span><span>//</span>     Lifetime of the pointer is until this process object is neutered.</span></td>
      </tr>
      <tr>
        <td id="L786" data-line-number="786"></td>
        <td id="LC786"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L787" data-line-number="787"></td>
        <td id="LC787">ICorDebugDataTarget * <span>CordbProcess::GetDataTarget</span>()</td>
      </tr>
      <tr>
        <td id="L788" data-line-number="788"></td>
        <td id="LC788">{</td>
      </tr>
      <tr>
        <td id="L789" data-line-number="789"></td>
        <td id="LC789">    <span>return</span> m_pDACDataTarget;</td>
      </tr>
      <tr>
        <td id="L790" data-line-number="790"></td>
        <td id="LC790">}</td>
      </tr>
      <tr>
        <td id="L791" data-line-number="791"></td>
        <td id="LC791">
</td>
      </tr>
      <tr>
        <td id="L792" data-line-number="792"></td>
        <td id="LC792"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L793" data-line-number="793"></td>
        <td id="LC793"><span><span>//</span> Create a CordbProcess object around an existing OS process.</span></td>
      </tr>
      <tr>
        <td id="L794" data-line-number="794"></td>
        <td id="LC794"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L795" data-line-number="795"></td>
        <td id="LC795"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L796" data-line-number="796"></td>
        <td id="LC796"><span><span>//</span>     pDataTarget - abstracts access to the debuggee.</span></td>
      </tr>
      <tr>
        <td id="L797" data-line-number="797"></td>
        <td id="LC797"><span><span>//</span>     clrInstanceId - identifies the CLR instance within the debuggee. (This is the</span></td>
      </tr>
      <tr>
        <td id="L798" data-line-number="798"></td>
        <td id="LC798"><span><span>//</span>         base address of mscorwks)</span></td>
      </tr>
      <tr>
        <td id="L799" data-line-number="799"></td>
        <td id="LC799"><span><span>//</span>     pCordb - Pointer to the implementation of the owning Cordb object implementing the</span></td>
      </tr>
      <tr>
        <td id="L800" data-line-number="800"></td>
        <td id="LC800"><span><span>//</span>         owning ICD interface.</span></td>
      </tr>
      <tr>
        <td id="L801" data-line-number="801"></td>
        <td id="LC801"><span><span>//</span>         This should go away - we can get the functionality from the pShim.</span></td>
      </tr>
      <tr>
        <td id="L802" data-line-number="802"></td>
        <td id="LC802"><span><span>//</span>         If this is null, then pShim must be null too.</span></td>
      </tr>
      <tr>
        <td id="L803" data-line-number="803"></td>
        <td id="LC803"><span><span>//</span>     processID - OS process ID of target process. 0 if pShim == NULL.</span></td>
      </tr>
      <tr>
        <td id="L804" data-line-number="804"></td>
        <td id="LC804"><span><span>//</span>     pShim - shim counter part object. This allows hooks back for v2 compat. This will</span></td>
      </tr>
      <tr>
        <td id="L805" data-line-number="805"></td>
        <td id="LC805"><span><span>//</span>         go away once we no longer support V2 backwards compat.</span></td>
      </tr>
      <tr>
        <td id="L806" data-line-number="806"></td>
        <td id="LC806"><span><span>//</span>         This must be non-null for any V2 paths (including non-DAC-ized code).</span></td>
      </tr>
      <tr>
        <td id="L807" data-line-number="807"></td>
        <td id="LC807"><span><span>//</span>         If this is null, then we're in a V3 path.</span></td>
      </tr>
      <tr>
        <td id="L808" data-line-number="808"></td>
        <td id="LC808"><span><span>//</span>     ppProcess - out parameter for new process object. This gets addreffed.</span></td>
      </tr>
      <tr>
        <td id="L809" data-line-number="809"></td>
        <td id="LC809"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L810" data-line-number="810"></td>
        <td id="LC810"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L811" data-line-number="811"></td>
        <td id="LC811"><span><span>//</span>     S_OK on success, and *ppProcess set to newly created debuggee object. Else error.</span></td>
      </tr>
      <tr>
        <td id="L812" data-line-number="812"></td>
        <td id="LC812"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L813" data-line-number="813"></td>
        <td id="LC813"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L814" data-line-number="814"></td>
        <td id="LC814"><span><span>//</span>    @dbgtodo - , shim: Cordb, and pShim will all eventually go away.</span></td>
      </tr>
      <tr>
        <td id="L815" data-line-number="815"></td>
        <td id="LC815"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L816" data-line-number="816"></td>
        <td id="LC816"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L817" data-line-number="817"></td>
        <td id="LC817">
</td>
      </tr>
      <tr>
        <td id="L818" data-line-number="818"></td>
        <td id="LC818"><span><span>//</span> static</span></td>
      </tr>
      <tr>
        <td id="L819" data-line-number="819"></td>
        <td id="LC819">HRESULT <span>CordbProcess::OpenVirtualProcess</span>(</td>
      </tr>
      <tr>
        <td id="L820" data-line-number="820"></td>
        <td id="LC820">    ULONG64 clrInstanceId,</td>
      </tr>
      <tr>
        <td id="L821" data-line-number="821"></td>
        <td id="LC821">    IUnknown * pDataTarget,</td>
      </tr>
      <tr>
        <td id="L822" data-line-number="822"></td>
        <td id="LC822">    HMODULE hDacModule,</td>
      </tr>
      <tr>
        <td id="L823" data-line-number="823"></td>
        <td id="LC823">    Cordb* pCordb,</td>
      </tr>
      <tr>
        <td id="L824" data-line-number="824"></td>
        <td id="LC824">    <span>const</span> ProcessDescriptor * pProcessDescriptor,</td>
      </tr>
      <tr>
        <td id="L825" data-line-number="825"></td>
        <td id="LC825">    ShimProcess * pShim,</td>
      </tr>
      <tr>
        <td id="L826" data-line-number="826"></td>
        <td id="LC826">    CordbProcess ** ppProcess)</td>
      </tr>
      <tr>
        <td id="L827" data-line-number="827"></td>
        <td id="LC827">{</td>
      </tr>
      <tr>
        <td id="L828" data-line-number="828"></td>
        <td id="LC828">    <span>_ASSERTE</span>(pDataTarget != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L829" data-line-number="829"></td>
        <td id="LC829">
</td>
      </tr>
      <tr>
        <td id="L830" data-line-number="830"></td>
        <td id="LC830">    <span><span>//</span> In DEBUG builds, verify that we do actually have an ICorDebugDataTarget (i.e. that</span></td>
      </tr>
      <tr>
        <td id="L831" data-line-number="831"></td>
        <td id="LC831">    <span><span>//</span> someone hasn't messed up the COM interop marshalling, etc.).</span></td>
      </tr>
      <tr>
        <td id="L832" data-line-number="832"></td>
        <td id="LC832">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L833" data-line-number="833"></td>
        <td id="LC833">    {</td>
      </tr>
      <tr>
        <td id="L834" data-line-number="834"></td>
        <td id="LC834">        IUnknown * pTempDt;</td>
      </tr>
      <tr>
        <td id="L835" data-line-number="835"></td>
        <td id="LC835">        HRESULT hrQi = pDataTarget-&gt;<span>QueryInterface</span>(IID_ICorDebugDataTarget, (<span>void</span>**)&amp;pTempDt);</td>
      </tr>
      <tr>
        <td id="L836" data-line-number="836"></td>
        <td id="LC836">        <span>_ASSERTE_MSG</span>(<span>SUCCEEDED</span>(hrQi), <span><span>"</span>OpenVirtualProcess was passed something that isn't actually an ICorDebugDataTarget<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L837" data-line-number="837"></td>
        <td id="LC837">        pTempDt-&gt;<span>Release</span>();</td>
      </tr>
      <tr>
        <td id="L838" data-line-number="838"></td>
        <td id="LC838">    }</td>
      </tr>
      <tr>
        <td id="L839" data-line-number="839"></td>
        <td id="LC839">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L840" data-line-number="840"></td>
        <td id="LC840">
</td>
      </tr>
      <tr>
        <td id="L841" data-line-number="841"></td>
        <td id="LC841">    <span><span>//</span> If we're emulating V2, then both pCordb and pShim are non-NULL.</span></td>
      </tr>
      <tr>
        <td id="L842" data-line-number="842"></td>
        <td id="LC842">    <span><span>//</span> If we're doing a real V3 path, then they're both NULL.</span></td>
      </tr>
      <tr>
        <td id="L843" data-line-number="843"></td>
        <td id="LC843">    <span><span>//</span> Either way, they should have the same null-status.</span></td>
      </tr>
      <tr>
        <td id="L844" data-line-number="844"></td>
        <td id="LC844">    <span>_ASSERTE</span>((pCordb == <span>NULL</span>) == (pShim == <span>NULL</span>));</td>
      </tr>
      <tr>
        <td id="L845" data-line-number="845"></td>
        <td id="LC845">
</td>
      </tr>
      <tr>
        <td id="L846" data-line-number="846"></td>
        <td id="LC846">    <span><span>//</span> If we're doing real V3, then we must have a real instance ID</span></td>
      </tr>
      <tr>
        <td id="L847" data-line-number="847"></td>
        <td id="LC847">    <span>_ASSERTE</span>(!((pShim == <span>NULL</span>) &amp;&amp; (clrInstanceId == <span>0</span>)));</td>
      </tr>
      <tr>
        <td id="L848" data-line-number="848"></td>
        <td id="LC848">
</td>
      </tr>
      <tr>
        <td id="L849" data-line-number="849"></td>
        <td id="LC849">    *ppProcess = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L850" data-line-number="850"></td>
        <td id="LC850">
</td>
      </tr>
      <tr>
        <td id="L851" data-line-number="851"></td>
        <td id="LC851">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L852" data-line-number="852"></td>
        <td id="LC852">    RSUnsafeExternalSmartPtr&lt;CordbProcess&gt; pProcess;</td>
      </tr>
      <tr>
        <td id="L853" data-line-number="853"></td>
        <td id="LC853">    pProcess.<span>Assign</span>(<span>new</span> (nothrow) <span>CordbProcess</span>(clrInstanceId, pDataTarget, hDacModule, pCordb, pProcessDescriptor, pShim));</td>
      </tr>
      <tr>
        <td id="L854" data-line-number="854"></td>
        <td id="LC854">
</td>
      </tr>
      <tr>
        <td id="L855" data-line-number="855"></td>
        <td id="LC855">    <span>if</span> (pProcess == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L856" data-line-number="856"></td>
        <td id="LC856">    {</td>
      </tr>
      <tr>
        <td id="L857" data-line-number="857"></td>
        <td id="LC857">        <span>return</span> E_OUTOFMEMORY;</td>
      </tr>
      <tr>
        <td id="L858" data-line-number="858"></td>
        <td id="LC858">    }</td>
      </tr>
      <tr>
        <td id="L859" data-line-number="859"></td>
        <td id="LC859">
</td>
      </tr>
      <tr>
        <td id="L860" data-line-number="860"></td>
        <td id="LC860">    ICorDebugProcess * pThis = pProcess;</td>
      </tr>
      <tr>
        <td id="L861" data-line-number="861"></td>
        <td id="LC861">    (<span>void</span>)pThis; <span><span>//</span>prevent "unused variable" error from GCC</span></td>
      </tr>
      <tr>
        <td id="L862" data-line-number="862"></td>
        <td id="LC862">
</td>
      </tr>
      <tr>
        <td id="L863" data-line-number="863"></td>
        <td id="LC863">    <span><span>//</span> CordbProcess::Init may need shim hooks, so connect Shim now.</span></td>
      </tr>
      <tr>
        <td id="L864" data-line-number="864"></td>
        <td id="LC864">    <span><span>//</span> This will bump reference count.</span></td>
      </tr>
      <tr>
        <td id="L865" data-line-number="865"></td>
        <td id="LC865">    <span>if</span> (pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L866" data-line-number="866"></td>
        <td id="LC866">    {</td>
      </tr>
      <tr>
        <td id="L867" data-line-number="867"></td>
        <td id="LC867">        pShim-&gt;<span>SetProcess</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L868" data-line-number="868"></td>
        <td id="LC868">
</td>
      </tr>
      <tr>
        <td id="L869" data-line-number="869"></td>
        <td id="LC869">        <span>_ASSERTE</span>(pShim-&gt;<span>GetProcess</span>() == pThis);</td>
      </tr>
      <tr>
        <td id="L870" data-line-number="870"></td>
        <td id="LC870">        <span>_ASSERTE</span>(pShim-&gt;<span>GetWin32EventThread</span>() != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L871" data-line-number="871"></td>
        <td id="LC871">    }</td>
      </tr>
      <tr>
        <td id="L872" data-line-number="872"></td>
        <td id="LC872">
</td>
      </tr>
      <tr>
        <td id="L873" data-line-number="873"></td>
        <td id="LC873">    hr = pProcess-&gt;<span>Init</span>();</td>
      </tr>
      <tr>
        <td id="L874" data-line-number="874"></td>
        <td id="LC874">
</td>
      </tr>
      <tr>
        <td id="L875" data-line-number="875"></td>
        <td id="LC875">    <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L876" data-line-number="876"></td>
        <td id="LC876">    {</td>
      </tr>
      <tr>
        <td id="L877" data-line-number="877"></td>
        <td id="LC877">        *ppProcess = pProcess;</td>
      </tr>
      <tr>
        <td id="L878" data-line-number="878"></td>
        <td id="LC878">        pProcess-&gt;<span>ExternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L879" data-line-number="879"></td>
        <td id="LC879">    }</td>
      </tr>
      <tr>
        <td id="L880" data-line-number="880"></td>
        <td id="LC880">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L881" data-line-number="881"></td>
        <td id="LC881">    {</td>
      </tr>
      <tr>
        <td id="L882" data-line-number="882"></td>
        <td id="LC882">        <span><span>//</span> handle failure path</span></td>
      </tr>
      <tr>
        <td id="L883" data-line-number="883"></td>
        <td id="LC883">        pProcess-&gt;<span>CleanupHalfBakedLeftSide</span>();</td>
      </tr>
      <tr>
        <td id="L884" data-line-number="884"></td>
        <td id="LC884">
</td>
      </tr>
      <tr>
        <td id="L885" data-line-number="885"></td>
        <td id="LC885">        <span>if</span> (pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L886" data-line-number="886"></td>
        <td id="LC886">        {</td>
      </tr>
      <tr>
        <td id="L887" data-line-number="887"></td>
        <td id="LC887">            <span><span>//</span> Shim still needs to be disposed to clean up other resources.</span></td>
      </tr>
      <tr>
        <td id="L888" data-line-number="888"></td>
        <td id="LC888">            pShim-&gt;<span>SetProcess</span>(<span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L889" data-line-number="889"></td>
        <td id="LC889">        }</td>
      </tr>
      <tr>
        <td id="L890" data-line-number="890"></td>
        <td id="LC890">
</td>
      </tr>
      <tr>
        <td id="L891" data-line-number="891"></td>
        <td id="LC891">        <span><span>//</span> In failure case, pProcess's dtor will do the final release.</span></td>
      </tr>
      <tr>
        <td id="L892" data-line-number="892"></td>
        <td id="LC892">    }</td>
      </tr>
      <tr>
        <td id="L893" data-line-number="893"></td>
        <td id="LC893">
</td>
      </tr>
      <tr>
        <td id="L894" data-line-number="894"></td>
        <td id="LC894">
</td>
      </tr>
      <tr>
        <td id="L895" data-line-number="895"></td>
        <td id="LC895">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L896" data-line-number="896"></td>
        <td id="LC896">}</td>
      </tr>
      <tr>
        <td id="L897" data-line-number="897"></td>
        <td id="LC897">
</td>
      </tr>
      <tr>
        <td id="L898" data-line-number="898"></td>
        <td id="LC898"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L899" data-line-number="899"></td>
        <td id="LC899"><span><span>//</span> CordbProcess constructor</span></td>
      </tr>
      <tr>
        <td id="L900" data-line-number="900"></td>
        <td id="LC900"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L901" data-line-number="901"></td>
        <td id="LC901"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L902" data-line-number="902"></td>
        <td id="LC902"><span><span>//</span>     pDataTarget - Pointer to an implementation of ICorDebugDataTarget</span></td>
      </tr>
      <tr>
        <td id="L903" data-line-number="903"></td>
        <td id="LC903"><span><span>//</span>         (or ICorDebugMutableDataTarget), which virtualizes access to the process.</span></td>
      </tr>
      <tr>
        <td id="L904" data-line-number="904"></td>
        <td id="LC904"><span><span>//</span>     clrInstanceId - representation of the CLR to debug in the process.  Must be specified</span></td>
      </tr>
      <tr>
        <td id="L905" data-line-number="905"></td>
        <td id="LC905"><span><span>//</span>         (non-zero) if pShim is NULL.  If 0, use the first CLR that we see.</span></td>
      </tr>
      <tr>
        <td id="L906" data-line-number="906"></td>
        <td id="LC906"><span><span>//</span>     pCordb - Pointer to the implementation of the owning Cordb object implementing the</span></td>
      </tr>
      <tr>
        <td id="L907" data-line-number="907"></td>
        <td id="LC907"><span><span>//</span>         owning ICD interface.</span></td>
      </tr>
      <tr>
        <td id="L908" data-line-number="908"></td>
        <td id="LC908"><span><span>//</span>     pW32 - Pointer to the Win32 event thread to use when processing events for this</span></td>
      </tr>
      <tr>
        <td id="L909" data-line-number="909"></td>
        <td id="LC909"><span><span>//</span>         process.</span></td>
      </tr>
      <tr>
        <td id="L910" data-line-number="910"></td>
        <td id="LC910"><span><span>//</span>     dwProcessID - For V3, 0.</span></td>
      </tr>
      <tr>
        <td id="L911" data-line-number="911"></td>
        <td id="LC911"><span><span>//</span>         Else for shim codepaths, the processID of the process this object will represent.</span></td>
      </tr>
      <tr>
        <td id="L912" data-line-number="912"></td>
        <td id="LC912"><span><span>//</span>     pShim - Pointer to the shim for handling V2 debuggers on the V3 architecture.</span></td>
      </tr>
      <tr>
        <td id="L913" data-line-number="913"></td>
        <td id="LC913"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L914" data-line-number="914"></td>
        <td id="LC914"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L915" data-line-number="915"></td>
        <td id="LC915">
</td>
      </tr>
      <tr>
        <td id="L916" data-line-number="916"></td>
        <td id="LC916"><span>CordbProcess::CordbProcess</span>(ULONG64 clrInstanceId,</td>
      </tr>
      <tr>
        <td id="L917" data-line-number="917"></td>
        <td id="LC917">                           IUnknown * pDataTarget,</td>
      </tr>
      <tr>
        <td id="L918" data-line-number="918"></td>
        <td id="LC918">                           HMODULE hDacModule,</td>
      </tr>
      <tr>
        <td id="L919" data-line-number="919"></td>
        <td id="LC919">                           Cordb * pCordb,</td>
      </tr>
      <tr>
        <td id="L920" data-line-number="920"></td>
        <td id="LC920">                           <span>const</span> ProcessDescriptor * pProcessDescriptor,</td>
      </tr>
      <tr>
        <td id="L921" data-line-number="921"></td>
        <td id="LC921">                           ShimProcess * pShim)</td>
      </tr>
      <tr>
        <td id="L922" data-line-number="922"></td>
        <td id="LC922">  : CordbBase(<span>NULL</span>, pProcessDescriptor-&gt;m_Pid, enumCordbProcess),</td>
      </tr>
      <tr>
        <td id="L923" data-line-number="923"></td>
        <td id="LC923">    m_fDoDelayedManagedAttached(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L924" data-line-number="924"></td>
        <td id="LC924">    m_cordb(pCordb),</td>
      </tr>
      <tr>
        <td id="L925" data-line-number="925"></td>
        <td id="LC925">    m_handle(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L926" data-line-number="926"></td>
        <td id="LC926">    m_processDescriptor(*pProcessDescriptor),</td>
      </tr>
      <tr>
        <td id="L927" data-line-number="927"></td>
        <td id="LC927">    m_detached(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L928" data-line-number="928"></td>
        <td id="LC928">    m_uninitializedStop(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L929" data-line-number="929"></td>
        <td id="LC929">    m_exiting(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L930" data-line-number="930"></td>
        <td id="LC930">    m_terminated(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L931" data-line-number="931"></td>
        <td id="LC931">    m_unrecoverableError(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L932" data-line-number="932"></td>
        <td id="LC932">    m_specialDeferment(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L933" data-line-number="933"></td>
        <td id="LC933">    m_helperThreadDead(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L934" data-line-number="934"></td>
        <td id="LC934">    m_loaderBPReceived(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L935" data-line-number="935"></td>
        <td id="LC935">    m_cOutstandingEvals(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L936" data-line-number="936"></td>
        <td id="LC936">    m_cOutstandingHandles(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L937" data-line-number="937"></td>
        <td id="LC937">    m_clrInstanceId(clrInstanceId),</td>
      </tr>
      <tr>
        <td id="L938" data-line-number="938"></td>
        <td id="LC938">    m_stopCount(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L939" data-line-number="939"></td>
        <td id="LC939">    m_synchronized(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L940" data-line-number="940"></td>
        <td id="LC940">    m_syncCompleteReceived(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L941" data-line-number="941"></td>
        <td id="LC941">    m_pShim(pShim),</td>
      </tr>
      <tr>
        <td id="L942" data-line-number="942"></td>
        <td id="LC942">    m_userThreads(<span>11</span>),</td>
      </tr>
      <tr>
        <td id="L943" data-line-number="943"></td>
        <td id="LC943">    m_oddSync(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L944" data-line-number="944"></td>
        <td id="LC944">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L945" data-line-number="945"></td>
        <td id="LC945">    <span>m_unmanagedThreads</span>(<span>11</span>),</td>
      </tr>
      <tr>
        <td id="L946" data-line-number="946"></td>
        <td id="LC946">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L947" data-line-number="947"></td>
        <td id="LC947">    <span>m_appDomains</span>(<span>11</span>),</td>
      </tr>
      <tr>
        <td id="L948" data-line-number="948"></td>
        <td id="LC948">    m_sharedAppDomain(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L949" data-line-number="949"></td>
        <td id="LC949">    m_steppers(<span>11</span>),</td>
      </tr>
      <tr>
        <td id="L950" data-line-number="950"></td>
        <td id="LC950">    m_continueCounter(<span>1</span>),</td>
      </tr>
      <tr>
        <td id="L951" data-line-number="951"></td>
        <td id="LC951">    m_flushCounter(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L952" data-line-number="952"></td>
        <td id="LC952">    m_leftSideEventAvailable(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L953" data-line-number="953"></td>
        <td id="LC953">    m_leftSideEventRead(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L954" data-line-number="954"></td>
        <td id="LC954">#<span>if</span> defined(FEATURE_INTEROP_DEBUGGING)</td>
      </tr>
      <tr>
        <td id="L955" data-line-number="955"></td>
        <td id="LC955">    <span>m_leftSideUnmanagedWaitEvent</span>(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L956" data-line-number="956"></td>
        <td id="LC956">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L957" data-line-number="957"></td>
        <td id="LC957">    <span>m_initialized</span>(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L958" data-line-number="958"></td>
        <td id="LC958">    m_stopRequested(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L959" data-line-number="959"></td>
        <td id="LC959">    m_stopWaitEvent(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L960" data-line-number="960"></td>
        <td id="LC960">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L961" data-line-number="961"></td>
        <td id="LC961">    <span>m_cFirstChanceHijackedThreads</span>(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L962" data-line-number="962"></td>
        <td id="LC962">    m_unmanagedEventQueue(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L963" data-line-number="963"></td>
        <td id="LC963">    m_lastQueuedUnmanagedEvent(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L964" data-line-number="964"></td>
        <td id="LC964">    m_lastQueuedOOBEvent(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L965" data-line-number="965"></td>
        <td id="LC965">    m_outOfBandEventQueue(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L966" data-line-number="966"></td>
        <td id="LC966">    m_lastDispatchedIBEvent(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L967" data-line-number="967"></td>
        <td id="LC967">    m_dispatchingUnmanagedEvent(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L968" data-line-number="968"></td>
        <td id="LC968">    m_dispatchingOOBEvent(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L969" data-line-number="969"></td>
        <td id="LC969">    m_doRealContinueAfterOOBBlock(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L970" data-line-number="970"></td>
        <td id="LC970">    m_state(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L971" data-line-number="971"></td>
        <td id="LC971">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L972" data-line-number="972"></td>
        <td id="LC972">    <span>m_helperThreadId</span>(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L973" data-line-number="973"></td>
        <td id="LC973">    m_pPatchTable(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L974" data-line-number="974"></td>
        <td id="LC974">    m_cPatch(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L975" data-line-number="975"></td>
        <td id="LC975">    m_rgData(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L976" data-line-number="976"></td>
        <td id="LC976">    m_rgNextPatch(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L977" data-line-number="977"></td>
        <td id="LC977">    m_rgUncommitedOpcode(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L978" data-line-number="978"></td>
        <td id="LC978">    m_minPatchAddr(MAX_ADDRESS),</td>
      </tr>
      <tr>
        <td id="L979" data-line-number="979"></td>
        <td id="LC979">    m_maxPatchAddr(MIN_ADDRESS),</td>
      </tr>
      <tr>
        <td id="L980" data-line-number="980"></td>
        <td id="LC980">    m_iFirstPatch(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L981" data-line-number="981"></td>
        <td id="LC981">    m_hHelperThread(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L982" data-line-number="982"></td>
        <td id="LC982">    m_dispatchedEvent(DB_IPCE_DEBUGGER_INVALID),</td>
      </tr>
      <tr>
        <td id="L983" data-line-number="983"></td>
        <td id="LC983">    m_pDefaultAppDomain(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L984" data-line-number="984"></td>
        <td id="LC984">    m_hDacModule(hDacModule),</td>
      </tr>
      <tr>
        <td id="L985" data-line-number="985"></td>
        <td id="LC985">    m_pDacPrimitives(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L986" data-line-number="986"></td>
        <td id="LC986">    m_pEventChannel(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L987" data-line-number="987"></td>
        <td id="LC987">    m_fAssertOnTargetInconsistency(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L988" data-line-number="988"></td>
        <td id="LC988">    m_runtimeOffsetsInitialized(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L989" data-line-number="989"></td>
        <td id="LC989">    m_writableMetadataUpdateMode(LegacyCompatPolicy)</td>
      </tr>
      <tr>
        <td id="L990" data-line-number="990"></td>
        <td id="LC990">{</td>
      </tr>
      <tr>
        <td id="L991" data-line-number="991"></td>
        <td id="LC991">    <span>_ASSERTE</span>((m_id == <span>0</span>) == (pShim == <span>NULL</span>));</td>
      </tr>
      <tr>
        <td id="L992" data-line-number="992"></td>
        <td id="LC992">
</td>
      </tr>
      <tr>
        <td id="L993" data-line-number="993"></td>
        <td id="LC993">    HRESULT hr = pDataTarget-&gt;<span>QueryInterface</span>(IID_ICorDebugDataTarget, <span>reinterpret_cast</span>&lt;<span>void</span> **&gt;(&amp;m_pDACDataTarget));</td>
      </tr>
      <tr>
        <td id="L994" data-line-number="994"></td>
        <td id="LC994">    <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L995" data-line-number="995"></td>
        <td id="LC995">
</td>
      </tr>
      <tr>
        <td id="L996" data-line-number="996"></td>
        <td id="LC996">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L997" data-line-number="997"></td>
        <td id="LC997">    m_DbgSupport.<span>m_DebugEventQueueIdx</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L998" data-line-number="998"></td>
        <td id="LC998">    m_DbgSupport.<span>m_TotalNativeEvents</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L999" data-line-number="999"></td>
        <td id="LC999">    m_DbgSupport.<span>m_TotalIB</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1000" data-line-number="1000"></td>
        <td id="LC1000">    m_DbgSupport.<span>m_TotalOOB</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1001" data-line-number="1001"></td>
        <td id="LC1001">    m_DbgSupport.<span>m_TotalCLR</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1002" data-line-number="1002"></td>
        <td id="LC1002">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L1003" data-line-number="1003"></td>
        <td id="LC1003">
</td>
      </tr>
      <tr>
        <td id="L1004" data-line-number="1004"></td>
        <td id="LC1004">    g_pRSDebuggingInfo-&gt;<span>m_MRUprocess</span> = <span>this</span>;</td>
      </tr>
      <tr>
        <td id="L1005" data-line-number="1005"></td>
        <td id="LC1005">
</td>
      </tr>
      <tr>
        <td id="L1006" data-line-number="1006"></td>
        <td id="LC1006">    <span><span>//</span> This is a strong reference to ourselves.</span></td>
      </tr>
      <tr>
        <td id="L1007" data-line-number="1007"></td>
        <td id="LC1007">    <span><span>//</span> This is cleared in code:CordbProcess::Neuter</span></td>
      </tr>
      <tr>
        <td id="L1008" data-line-number="1008"></td>
        <td id="LC1008">    m_pProcess.<span>Assign</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1009" data-line-number="1009"></td>
        <td id="LC1009">
</td>
      </tr>
      <tr>
        <td id="L1010" data-line-number="1010"></td>
        <td id="LC1010">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L1011" data-line-number="1011"></td>
        <td id="LC1011">    <span><span>//</span> On Debug builds, we'll ASSERT by default whenever the target appears to be corrupt or</span></td>
      </tr>
      <tr>
        <td id="L1012" data-line-number="1012"></td>
        <td id="LC1012">    <span><span>//</span> otherwise inconsistent (both in DAC and DBI).  But we also need the ability to</span></td>
      </tr>
      <tr>
        <td id="L1013" data-line-number="1013"></td>
        <td id="LC1013">    <span><span>//</span> explicitly test corrupt targets.</span></td>
      </tr>
      <tr>
        <td id="L1014" data-line-number="1014"></td>
        <td id="LC1014">    <span><span>//</span> Tests should set COMPlus_DbgIgnoreInconsistentTarget=1 to suppress these asserts</span></td>
      </tr>
      <tr>
        <td id="L1015" data-line-number="1015"></td>
        <td id="LC1015">    <span><span>//</span> Note that this controls two things:</span></td>
      </tr>
      <tr>
        <td id="L1016" data-line-number="1016"></td>
        <td id="LC1016">    <span><span>//</span>     1) DAC behavior - see code:IDacDbiInterface::DacSetTargetConsistencyChecks</span></td>
      </tr>
      <tr>
        <td id="L1017" data-line-number="1017"></td>
        <td id="LC1017">    <span><span>//</span>     2) RS-only consistency asserts - see code:CordbProcess::TargetConsistencyCheck</span></td>
      </tr>
      <tr>
        <td id="L1018" data-line-number="1018"></td>
        <td id="LC1018">    <span>if</span>( !<span>CLRConfig::GetConfigValue</span>(CLRConfig::INTERNAL_DbgDisableTargetConsistencyAsserts) )</td>
      </tr>
      <tr>
        <td id="L1019" data-line-number="1019"></td>
        <td id="LC1019">    {</td>
      </tr>
      <tr>
        <td id="L1020" data-line-number="1020"></td>
        <td id="LC1020">        m_fAssertOnTargetInconsistency = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1021" data-line-number="1021"></td>
        <td id="LC1021">    }</td>
      </tr>
      <tr>
        <td id="L1022" data-line-number="1022"></td>
        <td id="LC1022">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1023" data-line-number="1023"></td>
        <td id="LC1023">}</td>
      </tr>
      <tr>
        <td id="L1024" data-line-number="1024"></td>
        <td id="LC1024">
</td>
      </tr>
      <tr>
        <td id="L1025" data-line-number="1025"></td>
        <td id="LC1025"><span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L1026" data-line-number="1026"></td>
        <td id="LC1026"><span>    A list of which resources owned by this object are accounted for.</span></td>
      </tr>
      <tr>
        <td id="L1027" data-line-number="1027"></td>
        <td id="LC1027"><span></span></td>
      </tr>
      <tr>
        <td id="L1028" data-line-number="1028"></td>
        <td id="LC1028"><span>    UNKNOWN</span></td>
      </tr>
      <tr>
        <td id="L1029" data-line-number="1029"></td>
        <td id="LC1029"><span>        Cordb*                      m_cordb;</span></td>
      </tr>
      <tr>
        <td id="L1030" data-line-number="1030"></td>
        <td id="LC1030"><span>        CordbHashTable              m_unmanagedThreads; // Released in CordbProcess but not removed from hash</span></td>
      </tr>
      <tr>
        <td id="L1031" data-line-number="1031"></td>
        <td id="LC1031"><span>        DebuggerIPCEvent*           m_lastQueuedEvent;</span></td>
      </tr>
      <tr>
        <td id="L1032" data-line-number="1032"></td>
        <td id="LC1032"><span></span></td>
      </tr>
      <tr>
        <td id="L1033" data-line-number="1033"></td>
        <td id="LC1033"><span>        // CordbUnmannagedEvent is a struct which is not derrived from CordbBase.</span></td>
      </tr>
      <tr>
        <td id="L1034" data-line-number="1034"></td>
        <td id="LC1034"><span>        // It contains a CordbUnmannagedThread which may need to be released.</span></td>
      </tr>
      <tr>
        <td id="L1035" data-line-number="1035"></td>
        <td id="LC1035"><span>        CordbUnmanagedEvent         *m_unmanagedEventQueue;</span></td>
      </tr>
      <tr>
        <td id="L1036" data-line-number="1036"></td>
        <td id="LC1036"><span>        CordbUnmanagedEvent         *m_lastQueuedUnmanagedEvent;</span></td>
      </tr>
      <tr>
        <td id="L1037" data-line-number="1037"></td>
        <td id="LC1037"><span>        CordbUnmanagedEvent         *m_outOfBandEventQueue;</span></td>
      </tr>
      <tr>
        <td id="L1038" data-line-number="1038"></td>
        <td id="LC1038"><span>        CordbUnmanagedEvent         *m_lastQueuedOOBEvent;</span></td>
      </tr>
      <tr>
        <td id="L1039" data-line-number="1039"></td>
        <td id="LC1039"><span></span></td>
      </tr>
      <tr>
        <td id="L1040" data-line-number="1040"></td>
        <td id="LC1040"><span>        BYTE*                       m_pPatchTable;</span></td>
      </tr>
      <tr>
        <td id="L1041" data-line-number="1041"></td>
        <td id="LC1041"><span>        BYTE                        *m_rgData;</span></td>
      </tr>
      <tr>
        <td id="L1042" data-line-number="1042"></td>
        <td id="LC1042"><span>        void                        *m_pbRemoteBuf;</span></td>
      </tr>
      <tr>
        <td id="L1043" data-line-number="1043"></td>
        <td id="LC1043"><span></span></td>
      </tr>
      <tr>
        <td id="L1044" data-line-number="1044"></td>
        <td id="LC1044"><span>   RESOLVED</span></td>
      </tr>
      <tr>
        <td id="L1045" data-line-number="1045"></td>
        <td id="LC1045"><span>        // Nutered</span></td>
      </tr>
      <tr>
        <td id="L1046" data-line-number="1046"></td>
        <td id="LC1046"><span>        CordbHashTable        m_userThreads;</span></td>
      </tr>
      <tr>
        <td id="L1047" data-line-number="1047"></td>
        <td id="LC1047"><span>        CordbHashTable        m_appDomains;</span></td>
      </tr>
      <tr>
        <td id="L1048" data-line-number="1048"></td>
        <td id="LC1048"><span></span></td>
      </tr>
      <tr>
        <td id="L1049" data-line-number="1049"></td>
        <td id="LC1049"><span>        // Cleaned up in ExitProcess</span></td>
      </tr>
      <tr>
        <td id="L1050" data-line-number="1050"></td>
        <td id="LC1050"><span>        DebuggerIPCEvent*     m_queuedEventList;</span></td>
      </tr>
      <tr>
        <td id="L1051" data-line-number="1051"></td>
        <td id="LC1051"><span></span></td>
      </tr>
      <tr>
        <td id="L1052" data-line-number="1052"></td>
        <td id="LC1052"><span>        CordbHashTable        m_steppers; // Closed in ~CordbProcess</span></td>
      </tr>
      <tr>
        <td id="L1053" data-line-number="1053"></td>
        <td id="LC1053"><span></span></td>
      </tr>
      <tr>
        <td id="L1054" data-line-number="1054"></td>
        <td id="LC1054"><span>        // Closed in CloseIPCEventHandles called from ~CordbProcess</span></td>
      </tr>
      <tr>
        <td id="L1055" data-line-number="1055"></td>
        <td id="LC1055"><span>        HANDLE                m_leftSideEventAvailable;</span></td>
      </tr>
      <tr>
        <td id="L1056" data-line-number="1056"></td>
        <td id="LC1056"><span>        HANDLE                m_leftSideEventRead;</span></td>
      </tr>
      <tr>
        <td id="L1057" data-line-number="1057"></td>
        <td id="LC1057"><span></span></td>
      </tr>
      <tr>
        <td id="L1058" data-line-number="1058"></td>
        <td id="LC1058"><span>        // Closed in ~CordbProcess</span></td>
      </tr>
      <tr>
        <td id="L1059" data-line-number="1059"></td>
        <td id="LC1059"><span>        HANDLE                m_handle;</span></td>
      </tr>
      <tr>
        <td id="L1060" data-line-number="1060"></td>
        <td id="LC1060"><span>        HANDLE                m_leftSideUnmanagedWaitEvent;</span></td>
      </tr>
      <tr>
        <td id="L1061" data-line-number="1061"></td>
        <td id="LC1061"><span>        HANDLE                m_stopWaitEvent;</span></td>
      </tr>
      <tr>
        <td id="L1062" data-line-number="1062"></td>
        <td id="LC1062"><span></span></td>
      </tr>
      <tr>
        <td id="L1063" data-line-number="1063"></td>
        <td id="LC1063"><span>        // Deleted in ~CordbProcess</span></td>
      </tr>
      <tr>
        <td id="L1064" data-line-number="1064"></td>
        <td id="LC1064"><span>        CRITICAL_SECTION      m_processMutex;</span></td>
      </tr>
      <tr>
        <td id="L1065" data-line-number="1065"></td>
        <td id="LC1065"><span></span></td>
      </tr>
      <tr>
        <td id="L1066" data-line-number="1066"></td>
        <td id="LC1066"><span><span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1067" data-line-number="1067"></td>
        <td id="LC1067">
</td>
      </tr>
      <tr>
        <td id="L1068" data-line-number="1068"></td>
        <td id="LC1068">
</td>
      </tr>
      <tr>
        <td id="L1069" data-line-number="1069"></td>
        <td id="LC1069"><span>CordbProcess::~CordbProcess</span>()</td>
      </tr>
      <tr>
        <td id="L1070" data-line-number="1070"></td>
        <td id="LC1070">{</td>
      </tr>
      <tr>
        <td id="L1071" data-line-number="1071"></td>
        <td id="LC1071">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::~CP: deleting process 0x%08x<span>\n</span><span>"</span></span>, <span>this</span>));</td>
      </tr>
      <tr>
        <td id="L1072" data-line-number="1072"></td>
        <td id="LC1072">
</td>
      </tr>
      <tr>
        <td id="L1073" data-line-number="1073"></td>
        <td id="LC1073">    <span>DTOR_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1074" data-line-number="1074"></td>
        <td id="LC1074">
</td>
      </tr>
      <tr>
        <td id="L1075" data-line-number="1075"></td>
        <td id="LC1075">    <span>_ASSERTE</span>(<span>IsNeutered</span>());</td>
      </tr>
      <tr>
        <td id="L1076" data-line-number="1076"></td>
        <td id="LC1076">
</td>
      </tr>
      <tr>
        <td id="L1077" data-line-number="1077"></td>
        <td id="LC1077">    <span>_ASSERTE</span>(m_cordb == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1078" data-line-number="1078"></td>
        <td id="LC1078">
</td>
      </tr>
      <tr>
        <td id="L1079" data-line-number="1079"></td>
        <td id="LC1079">    <span><span>//</span> We shouldn't still be in Cordb's list of processes. Unfortunately, our root Cordb object</span></td>
      </tr>
      <tr>
        <td id="L1080" data-line-number="1080"></td>
        <td id="LC1080">    <span><span>//</span> may have already been deleted b/c we're at the mercy of ref-counting, so we can't check.</span></td>
      </tr>
      <tr>
        <td id="L1081" data-line-number="1081"></td>
        <td id="LC1081">
</td>
      </tr>
      <tr>
        <td id="L1082" data-line-number="1082"></td>
        <td id="LC1082">	<span>_ASSERTE</span>(m_sharedAppDomain == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1083" data-line-number="1083"></td>
        <td id="LC1083">
</td>
      </tr>
      <tr>
        <td id="L1084" data-line-number="1084"></td>
        <td id="LC1084">    m_processMutex.<span>Destroy</span>();</td>
      </tr>
      <tr>
        <td id="L1085" data-line-number="1085"></td>
        <td id="LC1085">    m_StopGoLock.<span>Destroy</span>();</td>
      </tr>
      <tr>
        <td id="L1086" data-line-number="1086"></td>
        <td id="LC1086">
</td>
      </tr>
      <tr>
        <td id="L1087" data-line-number="1087"></td>
        <td id="LC1087">    <span><span>//</span> These handles were cleared in neuter</span></td>
      </tr>
      <tr>
        <td id="L1088" data-line-number="1088"></td>
        <td id="LC1088">    <span>_ASSERTE</span>(m_handle == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1089" data-line-number="1089"></td>
        <td id="LC1089">#<span>if</span> defined(FEATURE_INTEROP_DEBUGGING)</td>
      </tr>
      <tr>
        <td id="L1090" data-line-number="1090"></td>
        <td id="LC1090">    <span>_ASSERTE</span>(m_leftSideUnmanagedWaitEvent == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1091" data-line-number="1091"></td>
        <td id="LC1091">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L1092" data-line-number="1092"></td>
        <td id="LC1092">    <span>_ASSERTE</span>(m_stopWaitEvent == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1093" data-line-number="1093"></td>
        <td id="LC1093">
</td>
      </tr>
      <tr>
        <td id="L1094" data-line-number="1094"></td>
        <td id="LC1094">    <span><span>//</span> Set this to mark that we really did cleanup.</span></td>
      </tr>
      <tr>
        <td id="L1095" data-line-number="1095"></td>
        <td id="LC1095">}</td>
      </tr>
      <tr>
        <td id="L1096" data-line-number="1096"></td>
        <td id="LC1096">
</td>
      </tr>
      <tr>
        <td id="L1097" data-line-number="1097"></td>
        <td id="LC1097"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1098" data-line-number="1098"></td>
        <td id="LC1098"><span><span>//</span> Static build helper.</span></td>
      </tr>
      <tr>
        <td id="L1099" data-line-number="1099"></td>
        <td id="LC1099"><span><span>//</span> This will create a process under the pCordb root, and add it to the list.</span></td>
      </tr>
      <tr>
        <td id="L1100" data-line-number="1100"></td>
        <td id="LC1100"><span><span>//</span> We don't return the process - caller gets the pid and looks it up under</span></td>
      </tr>
      <tr>
        <td id="L1101" data-line-number="1101"></td>
        <td id="LC1101"><span><span>//</span> the Cordb object.</span></td>
      </tr>
      <tr>
        <td id="L1102" data-line-number="1102"></td>
        <td id="LC1102"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1103" data-line-number="1103"></td>
        <td id="LC1103"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1104" data-line-number="1104"></td>
        <td id="LC1104"><span><span>//</span>     pCordb - Pointer to the implementation of the owning Cordb object implementing the</span></td>
      </tr>
      <tr>
        <td id="L1105" data-line-number="1105"></td>
        <td id="LC1105"><span><span>//</span>         owning ICD interface.</span></td>
      </tr>
      <tr>
        <td id="L1106" data-line-number="1106"></td>
        <td id="LC1106"><span><span>//</span>     szProgramName - Name of the program to execute.</span></td>
      </tr>
      <tr>
        <td id="L1107" data-line-number="1107"></td>
        <td id="LC1107"><span><span>//</span>     szProgramArgs - Command line arguments for the process.</span></td>
      </tr>
      <tr>
        <td id="L1108" data-line-number="1108"></td>
        <td id="LC1108"><span><span>//</span>     lpProcessAttributes - OS-specific attributes for process creation.</span></td>
      </tr>
      <tr>
        <td id="L1109" data-line-number="1109"></td>
        <td id="LC1109"><span><span>//</span>     lpThreadAttributes - OS-specific attributes for thread creation.</span></td>
      </tr>
      <tr>
        <td id="L1110" data-line-number="1110"></td>
        <td id="LC1110"><span><span>//</span>     fInheritFlags - OS-specific flag for child process inheritance.</span></td>
      </tr>
      <tr>
        <td id="L1111" data-line-number="1111"></td>
        <td id="LC1111"><span><span>//</span>     dwCreationFlags - OS-specific creation flags.</span></td>
      </tr>
      <tr>
        <td id="L1112" data-line-number="1112"></td>
        <td id="LC1112"><span><span>//</span>     lpEnvironment - OS-specific environmental strings.</span></td>
      </tr>
      <tr>
        <td id="L1113" data-line-number="1113"></td>
        <td id="LC1113"><span><span>//</span>     szCurrentDirectory - OS-specific string for directory to run in.</span></td>
      </tr>
      <tr>
        <td id="L1114" data-line-number="1114"></td>
        <td id="LC1114"><span><span>//</span>     lpStartupInfo - OS-specific info on startup.</span></td>
      </tr>
      <tr>
        <td id="L1115" data-line-number="1115"></td>
        <td id="LC1115"><span><span>//</span>     lpProcessInformation - OS-specific process information buffer.</span></td>
      </tr>
      <tr>
        <td id="L1116" data-line-number="1116"></td>
        <td id="LC1116"><span><span>//</span>     corDebugFlags - What type of process to create, currently always managed.</span></td>
      </tr>
      <tr>
        <td id="L1117" data-line-number="1117"></td>
        <td id="LC1117"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1118" data-line-number="1118"></td>
        <td id="LC1118">HRESULT <span>ShimProcess::CreateProcess</span>(</td>
      </tr>
      <tr>
        <td id="L1119" data-line-number="1119"></td>
        <td id="LC1119">      Cordb * pCordb,</td>
      </tr>
      <tr>
        <td id="L1120" data-line-number="1120"></td>
        <td id="LC1120">      ICorDebugRemoteTarget * pRemoteTarget,</td>
      </tr>
      <tr>
        <td id="L1121" data-line-number="1121"></td>
        <td id="LC1121">      LPCWSTR szProgramName,</td>
      </tr>
      <tr>
        <td id="L1122" data-line-number="1122"></td>
        <td id="LC1122">      __in_z LPWSTR  szProgramArgs,</td>
      </tr>
      <tr>
        <td id="L1123" data-line-number="1123"></td>
        <td id="LC1123">      LPSECURITY_ATTRIBUTES lpProcessAttributes,</td>
      </tr>
      <tr>
        <td id="L1124" data-line-number="1124"></td>
        <td id="LC1124">      LPSECURITY_ATTRIBUTES lpThreadAttributes,</td>
      </tr>
      <tr>
        <td id="L1125" data-line-number="1125"></td>
        <td id="LC1125">      BOOL <span>fInheritHandles</span>,</td>
      </tr>
      <tr>
        <td id="L1126" data-line-number="1126"></td>
        <td id="LC1126">      DWORD dwCreationFlags,</td>
      </tr>
      <tr>
        <td id="L1127" data-line-number="1127"></td>
        <td id="LC1127">      PVOID lpEnvironment,</td>
      </tr>
      <tr>
        <td id="L1128" data-line-number="1128"></td>
        <td id="LC1128">      LPCWSTR szCurrentDirectory,</td>
      </tr>
      <tr>
        <td id="L1129" data-line-number="1129"></td>
        <td id="LC1129">      LPSTARTUPINFOW lpStartupInfo,</td>
      </tr>
      <tr>
        <td id="L1130" data-line-number="1130"></td>
        <td id="LC1130">      LPPROCESS_INFORMATION lpProcessInformation,</td>
      </tr>
      <tr>
        <td id="L1131" data-line-number="1131"></td>
        <td id="LC1131">      CorDebugCreateProcessFlags corDebugFlags</td>
      </tr>
      <tr>
        <td id="L1132" data-line-number="1132"></td>
        <td id="LC1132">)</td>
      </tr>
      <tr>
        <td id="L1133" data-line-number="1133"></td>
        <td id="LC1133">{</td>
      </tr>
      <tr>
        <td id="L1134" data-line-number="1134"></td>
        <td id="LC1134">    <span>_ASSERTE</span>(pCordb != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1135" data-line-number="1135"></td>
        <td id="LC1135">
</td>
      </tr>
      <tr>
        <td id="L1136" data-line-number="1136"></td>
        <td id="LC1136">#<span>if</span> defined(FEATURE_DBGIPC_TRANSPORT_DI)</td>
      </tr>
      <tr>
        <td id="L1137" data-line-number="1137"></td>
        <td id="LC1137">    <span><span>//</span> The transport cannot deal with creating a suspended process (it needs the debugger to start up and</span></td>
      </tr>
      <tr>
        <td id="L1138" data-line-number="1138"></td>
        <td id="LC1138">    <span><span>//</span> listen for connections).</span></td>
      </tr>
      <tr>
        <td id="L1139" data-line-number="1139"></td>
        <td id="LC1139">    <span>_ASSERTE</span>((dwCreationFlags &amp; CREATE_SUSPENDED) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L1140" data-line-number="1140"></td>
        <td id="LC1140">#<span>endif</span> <span><span>//</span> FEATURE_DBGIPC_TRANSPORT_DI</span></td>
      </tr>
      <tr>
        <td id="L1141" data-line-number="1141"></td>
        <td id="LC1141">
</td>
      </tr>
      <tr>
        <td id="L1142" data-line-number="1142"></td>
        <td id="LC1142">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L1143" data-line-number="1143"></td>
        <td id="LC1143">
</td>
      </tr>
      <tr>
        <td id="L1144" data-line-number="1144"></td>
        <td id="LC1144">    RSExtSmartPtr&lt;ShimProcess&gt; pShim;</td>
      </tr>
      <tr>
        <td id="L1145" data-line-number="1145"></td>
        <td id="LC1145">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L1146" data-line-number="1146"></td>
        <td id="LC1146">    {</td>
      </tr>
      <tr>
        <td id="L1147" data-line-number="1147"></td>
        <td id="LC1147">        pShim.<span>Assign</span>(<span>new</span> <span>ShimProcess</span>());</td>
      </tr>
      <tr>
        <td id="L1148" data-line-number="1148"></td>
        <td id="LC1148">
</td>
      </tr>
      <tr>
        <td id="L1149" data-line-number="1149"></td>
        <td id="LC1149">        <span><span>//</span> Indicate that this process was started under the debugger as opposed to attaching later.</span></td>
      </tr>
      <tr>
        <td id="L1150" data-line-number="1150"></td>
        <td id="LC1150">        pShim-&gt;<span>m_attached</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1151" data-line-number="1151"></td>
        <td id="LC1151">
</td>
      </tr>
      <tr>
        <td id="L1152" data-line-number="1152"></td>
        <td id="LC1152">        hr = pShim-&gt;<span>CreateAndStartWin32ET</span>(pCordb);</td>
      </tr>
      <tr>
        <td id="L1153" data-line-number="1153"></td>
        <td id="LC1153">        <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L1154" data-line-number="1154"></td>
        <td id="LC1154">
</td>
      </tr>
      <tr>
        <td id="L1155" data-line-number="1155"></td>
        <td id="LC1155">        <span><span>//</span> Call out to newly created Win32-event Thread to create the process.</span></td>
      </tr>
      <tr>
        <td id="L1156" data-line-number="1156"></td>
        <td id="LC1156">        <span><span>//</span> If this succeeds, new CordbProcess will add a ref to the ShimProcess</span></td>
      </tr>
      <tr>
        <td id="L1157" data-line-number="1157"></td>
        <td id="LC1157">        hr = pShim-&gt;<span>GetWin32EventThread</span>()-&gt;<span>SendCreateProcessEvent</span>(pShim-&gt;<span>GetMachineInfo</span>(),</td>
      </tr>
      <tr>
        <td id="L1158" data-line-number="1158"></td>
        <td id="LC1158">                                                                  szProgramName,</td>
      </tr>
      <tr>
        <td id="L1159" data-line-number="1159"></td>
        <td id="LC1159">                                                                  szProgramArgs,</td>
      </tr>
      <tr>
        <td id="L1160" data-line-number="1160"></td>
        <td id="LC1160">                                                                  lpProcessAttributes,</td>
      </tr>
      <tr>
        <td id="L1161" data-line-number="1161"></td>
        <td id="LC1161">                                                                  lpThreadAttributes,</td>
      </tr>
      <tr>
        <td id="L1162" data-line-number="1162"></td>
        <td id="LC1162">                                                                  <span>fInheritHandles</span>,</td>
      </tr>
      <tr>
        <td id="L1163" data-line-number="1163"></td>
        <td id="LC1163">                                                                  dwCreationFlags,</td>
      </tr>
      <tr>
        <td id="L1164" data-line-number="1164"></td>
        <td id="LC1164">                                                                  lpEnvironment,</td>
      </tr>
      <tr>
        <td id="L1165" data-line-number="1165"></td>
        <td id="LC1165">                                                                  szCurrentDirectory,</td>
      </tr>
      <tr>
        <td id="L1166" data-line-number="1166"></td>
        <td id="LC1166">                                                                  lpStartupInfo,</td>
      </tr>
      <tr>
        <td id="L1167" data-line-number="1167"></td>
        <td id="LC1167">                                                                  lpProcessInformation,</td>
      </tr>
      <tr>
        <td id="L1168" data-line-number="1168"></td>
        <td id="LC1168">                                                                  corDebugFlags);</td>
      </tr>
      <tr>
        <td id="L1169" data-line-number="1169"></td>
        <td id="LC1169">        <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L1170" data-line-number="1170"></td>
        <td id="LC1170">    }</td>
      </tr>
      <tr>
        <td id="L1171" data-line-number="1171"></td>
        <td id="LC1171">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L1172" data-line-number="1172"></td>
        <td id="LC1172">
</td>
      </tr>
      <tr>
        <td id="L1173" data-line-number="1173"></td>
        <td id="LC1173">    <span><span>//</span> If this succeeds, then process takes ownership of thread. Else we need to kill it.</span></td>
      </tr>
      <tr>
        <td id="L1174" data-line-number="1174"></td>
        <td id="LC1174">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L1175" data-line-number="1175"></td>
        <td id="LC1175">    {</td>
      </tr>
      <tr>
        <td id="L1176" data-line-number="1176"></td>
        <td id="LC1176">        <span>if</span> (pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1177" data-line-number="1177"></td>
        <td id="LC1177">        {</td>
      </tr>
      <tr>
        <td id="L1178" data-line-number="1178"></td>
        <td id="LC1178">            pShim-&gt;<span>Dispose</span>();</td>
      </tr>
      <tr>
        <td id="L1179" data-line-number="1179"></td>
        <td id="LC1179">        }</td>
      </tr>
      <tr>
        <td id="L1180" data-line-number="1180"></td>
        <td id="LC1180">    }</td>
      </tr>
      <tr>
        <td id="L1181" data-line-number="1181"></td>
        <td id="LC1181">    <span><span>//</span> Always release our ref to ShimProcess. If the Process was created, then it takes a reference.</span></td>
      </tr>
      <tr>
        <td id="L1182" data-line-number="1182"></td>
        <td id="LC1182">
</td>
      </tr>
      <tr>
        <td id="L1183" data-line-number="1183"></td>
        <td id="LC1183">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L1184" data-line-number="1184"></td>
        <td id="LC1184">}</td>
      </tr>
      <tr>
        <td id="L1185" data-line-number="1185"></td>
        <td id="LC1185">
</td>
      </tr>
      <tr>
        <td id="L1186" data-line-number="1186"></td>
        <td id="LC1186"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1187" data-line-number="1187"></td>
        <td id="LC1187"><span><span>//</span> Static build helper for the attach case.</span></td>
      </tr>
      <tr>
        <td id="L1188" data-line-number="1188"></td>
        <td id="LC1188"><span><span>//</span> On success, this will add the process to the pCordb list, and then</span></td>
      </tr>
      <tr>
        <td id="L1189" data-line-number="1189"></td>
        <td id="LC1189"><span><span>//</span> callers can look it up there by pid.</span></td>
      </tr>
      <tr>
        <td id="L1190" data-line-number="1190"></td>
        <td id="LC1190"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1191" data-line-number="1191"></td>
        <td id="LC1191"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1192" data-line-number="1192"></td>
        <td id="LC1192"><span><span>//</span>     pCordb - root under which this all lives</span></td>
      </tr>
      <tr>
        <td id="L1193" data-line-number="1193"></td>
        <td id="LC1193"><span><span>//</span>     dwProcessID - OS process ID to attach to</span></td>
      </tr>
      <tr>
        <td id="L1194" data-line-number="1194"></td>
        <td id="LC1194"><span><span>//</span>     fWin32Attach - are we interop debugging?</span></td>
      </tr>
      <tr>
        <td id="L1195" data-line-number="1195"></td>
        <td id="LC1195"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1196" data-line-number="1196"></td>
        <td id="LC1196">HRESULT <span>ShimProcess::DebugActiveProcess</span>(</td>
      </tr>
      <tr>
        <td id="L1197" data-line-number="1197"></td>
        <td id="LC1197">    Cordb * pCordb,</td>
      </tr>
      <tr>
        <td id="L1198" data-line-number="1198"></td>
        <td id="LC1198">    ICorDebugRemoteTarget * pRemoteTarget,</td>
      </tr>
      <tr>
        <td id="L1199" data-line-number="1199"></td>
        <td id="LC1199">    <span>const</span> ProcessDescriptor * pProcessDescriptor,</td>
      </tr>
      <tr>
        <td id="L1200" data-line-number="1200"></td>
        <td id="LC1200">    BOOL <span>fWin32Attach</span></td>
      </tr>
      <tr>
        <td id="L1201" data-line-number="1201"></td>
        <td id="LC1201">)</td>
      </tr>
      <tr>
        <td id="L1202" data-line-number="1202"></td>
        <td id="LC1202">{</td>
      </tr>
      <tr>
        <td id="L1203" data-line-number="1203"></td>
        <td id="LC1203">    <span>_ASSERTE</span>(pCordb != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1204" data-line-number="1204"></td>
        <td id="LC1204">
</td>
      </tr>
      <tr>
        <td id="L1205" data-line-number="1205"></td>
        <td id="LC1205">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L1206" data-line-number="1206"></td>
        <td id="LC1206">
</td>
      </tr>
      <tr>
        <td id="L1207" data-line-number="1207"></td>
        <td id="LC1207">    RSExtSmartPtr&lt;ShimProcess&gt; pShim;</td>
      </tr>
      <tr>
        <td id="L1208" data-line-number="1208"></td>
        <td id="LC1208">
</td>
      </tr>
      <tr>
        <td id="L1209" data-line-number="1209"></td>
        <td id="LC1209">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L1210" data-line-number="1210"></td>
        <td id="LC1210">    {</td>
      </tr>
      <tr>
        <td id="L1211" data-line-number="1211"></td>
        <td id="LC1211">        pShim.<span>Assign</span>(<span>new</span> <span>ShimProcess</span>());</td>
      </tr>
      <tr>
        <td id="L1212" data-line-number="1212"></td>
        <td id="LC1212">
</td>
      </tr>
      <tr>
        <td id="L1213" data-line-number="1213"></td>
        <td id="LC1213">        <span><span>//</span> Indicate that this process was attached to, asopposed to being started under the debugger.</span></td>
      </tr>
      <tr>
        <td id="L1214" data-line-number="1214"></td>
        <td id="LC1214">        pShim-&gt;<span>m_attached</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1215" data-line-number="1215"></td>
        <td id="LC1215">
</td>
      </tr>
      <tr>
        <td id="L1216" data-line-number="1216"></td>
        <td id="LC1216">        hr = pShim-&gt;<span>CreateAndStartWin32ET</span>(pCordb);</td>
      </tr>
      <tr>
        <td id="L1217" data-line-number="1217"></td>
        <td id="LC1217">        <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L1218" data-line-number="1218"></td>
        <td id="LC1218">
</td>
      </tr>
      <tr>
        <td id="L1219" data-line-number="1219"></td>
        <td id="LC1219">        <span><span>//</span> If this succeeds, new CordbProcess will add a ref to the ShimProcess</span></td>
      </tr>
      <tr>
        <td id="L1220" data-line-number="1220"></td>
        <td id="LC1220">        hr = pShim-&gt;<span>GetWin32EventThread</span>()-&gt;<span>SendDebugActiveProcessEvent</span>(pShim-&gt;<span>GetMachineInfo</span>(),</td>
      </tr>
      <tr>
        <td id="L1221" data-line-number="1221"></td>
        <td id="LC1221">                                                                       pProcessDescriptor,</td>
      </tr>
      <tr>
        <td id="L1222" data-line-number="1222"></td>
        <td id="LC1222">                                                                       <span>fWin32Attach</span> == <span>TRUE</span>,</td>
      </tr>
      <tr>
        <td id="L1223" data-line-number="1223"></td>
        <td id="LC1223">                                                                       <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1224" data-line-number="1224"></td>
        <td id="LC1224">        <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L1225" data-line-number="1225"></td>
        <td id="LC1225">
</td>
      </tr>
      <tr>
        <td id="L1226" data-line-number="1226"></td>
        <td id="LC1226">        <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L1227" data-line-number="1227"></td>
        <td id="LC1227">
</td>
      </tr>
      <tr>
        <td id="L1228" data-line-number="1228"></td>
        <td id="LC1228">#<span>if</span> !defined(FEATURE_DBGIPC_TRANSPORT_DI)</td>
      </tr>
      <tr>
        <td id="L1229" data-line-number="1229"></td>
        <td id="LC1229">        <span><span>//</span> Don't do this when we are remote debugging since we won't be getting the loader breakpoint.</span></td>
      </tr>
      <tr>
        <td id="L1230" data-line-number="1230"></td>
        <td id="LC1230">        <span><span>//</span> We don't support JIT attach in remote debugging scenarios anyway.</span></td>
      </tr>
      <tr>
        <td id="L1231" data-line-number="1231"></td>
        <td id="LC1231">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1232" data-line-number="1232"></td>
        <td id="LC1232">        <span><span>//</span> When doing jit attach for pure managed debugging we allow the native attach event to be signaled</span></td>
      </tr>
      <tr>
        <td id="L1233" data-line-number="1233"></td>
        <td id="LC1233">        <span><span>//</span> after DebugActiveProcess completes which means we must wait here long enough to have set the debuggee</span></td>
      </tr>
      <tr>
        <td id="L1234" data-line-number="1234"></td>
        <td id="LC1234">        <span><span>//</span> bit indicating managed attach is coming.</span></td>
      </tr>
      <tr>
        <td id="L1235" data-line-number="1235"></td>
        <td id="LC1235">        <span><span>//</span> However in interop debugging we can't do that because there are debug events which come before the</span></td>
      </tr>
      <tr>
        <td id="L1236" data-line-number="1236"></td>
        <td id="LC1236">        <span><span>//</span> loader breakpoint (which is how far we need to get to set the debuggee bit). If we blocked</span></td>
      </tr>
      <tr>
        <td id="L1237" data-line-number="1237"></td>
        <td id="LC1237">        <span><span>//</span> DebugActiveProcess there then the debug events would be refering to an ICorDebugProcess that hasn't</span></td>
      </tr>
      <tr>
        <td id="L1238" data-line-number="1238"></td>
        <td id="LC1238">        <span><span>//</span> yet been returned to the caller of DebugActiveProcess. Instead, for interop debugging we force the</span></td>
      </tr>
      <tr>
        <td id="L1239" data-line-number="1239"></td>
        <td id="LC1239">        <span><span>//</span> native debugger to wait until it gets the loader breakpoint to set the event. Note we can't converge</span></td>
      </tr>
      <tr>
        <td id="L1240" data-line-number="1240"></td>
        <td id="LC1240">        <span><span>//</span> on that solution for the pure managed case because there is no loader breakpoint event. Hence pure</span></td>
      </tr>
      <tr>
        <td id="L1241" data-line-number="1241"></td>
        <td id="LC1241">        <span><span>//</span> managed and interop debugging each require their own solution</span></td>
      </tr>
      <tr>
        <td id="L1242" data-line-number="1242"></td>
        <td id="LC1242">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1243" data-line-number="1243"></td>
        <td id="LC1243">        <span><span>//</span> See bugs Dev10 600873 and 595322 for examples of what happens if we wait in interop or don't wait</span></td>
      </tr>
      <tr>
        <td id="L1244" data-line-number="1244"></td>
        <td id="LC1244">        <span><span>//</span> in pure managed respectively</span></td>
      </tr>
      <tr>
        <td id="L1245" data-line-number="1245"></td>
        <td id="LC1245">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1246" data-line-number="1246"></td>
        <td id="LC1246">        <span><span>//</span> Long term this should all go away because we won't need to set a managed attach pending bit because</span></td>
      </tr>
      <tr>
        <td id="L1247" data-line-number="1247"></td>
        <td id="LC1247">        <span><span>//</span> there shouldn't be any IPC events involved in managed attach. There might not even be a notion of</span></td>
      </tr>
      <tr>
        <td id="L1248" data-line-number="1248"></td>
        <td id="LC1248">        <span><span>//</span> being 'managed attached'</span></td>
      </tr>
      <tr>
        <td id="L1249" data-line-number="1249"></td>
        <td id="LC1249">        <span>if</span>(!pShim-&gt;<span>m_fIsInteropDebugging</span>)</td>
      </tr>
      <tr>
        <td id="L1250" data-line-number="1250"></td>
        <td id="LC1250">        {</td>
      </tr>
      <tr>
        <td id="L1251" data-line-number="1251"></td>
        <td id="LC1251">            DWORD  dwHandles = <span>2</span>;</td>
      </tr>
      <tr>
        <td id="L1252" data-line-number="1252"></td>
        <td id="LC1252">            HANDLE arrHandles[<span>2</span>];</td>
      </tr>
      <tr>
        <td id="L1253" data-line-number="1253"></td>
        <td id="LC1253">
</td>
      </tr>
      <tr>
        <td id="L1254" data-line-number="1254"></td>
        <td id="LC1254">            arrHandles[<span>0</span>] = pShim-&gt;<span>m_terminatingEvent</span>;</td>
      </tr>
      <tr>
        <td id="L1255" data-line-number="1255"></td>
        <td id="LC1255">            arrHandles[<span>1</span>] = pShim-&gt;<span>m_markAttachPendingEvent</span>;</td>
      </tr>
      <tr>
        <td id="L1256" data-line-number="1256"></td>
        <td id="LC1256">
</td>
      </tr>
      <tr>
        <td id="L1257" data-line-number="1257"></td>
        <td id="LC1257">            <span><span>//</span> Wait for the completion of marking pending attach bit or debugger detaching</span></td>
      </tr>
      <tr>
        <td id="L1258" data-line-number="1258"></td>
        <td id="LC1258">            <span>WaitForMultipleObjectsEx</span>(dwHandles, arrHandles, <span>FALSE</span>, INFINITE, <span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L1259" data-line-number="1259"></td>
        <td id="LC1259">        }</td>
      </tr>
      <tr>
        <td id="L1260" data-line-number="1260"></td>
        <td id="LC1260">#<span>endif</span> <span><span>//</span>!FEATURE_DBGIPC_TRANSPORT_DI</span></td>
      </tr>
      <tr>
        <td id="L1261" data-line-number="1261"></td>
        <td id="LC1261">    }</td>
      </tr>
      <tr>
        <td id="L1262" data-line-number="1262"></td>
        <td id="LC1262">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L1263" data-line-number="1263"></td>
        <td id="LC1263">
</td>
      </tr>
      <tr>
        <td id="L1264" data-line-number="1264"></td>
        <td id="LC1264">    <span><span>//</span> If this succeeds, then process takes ownership of thread. Else we need to kill it.</span></td>
      </tr>
      <tr>
        <td id="L1265" data-line-number="1265"></td>
        <td id="LC1265">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L1266" data-line-number="1266"></td>
        <td id="LC1266">    {</td>
      </tr>
      <tr>
        <td id="L1267" data-line-number="1267"></td>
        <td id="LC1267">        <span>if</span> (pShim!= <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1268" data-line-number="1268"></td>
        <td id="LC1268">        {</td>
      </tr>
      <tr>
        <td id="L1269" data-line-number="1269"></td>
        <td id="LC1269">            pShim-&gt;<span>Dispose</span>();</td>
      </tr>
      <tr>
        <td id="L1270" data-line-number="1270"></td>
        <td id="LC1270">        }</td>
      </tr>
      <tr>
        <td id="L1271" data-line-number="1271"></td>
        <td id="LC1271">    }</td>
      </tr>
      <tr>
        <td id="L1272" data-line-number="1272"></td>
        <td id="LC1272">
</td>
      </tr>
      <tr>
        <td id="L1273" data-line-number="1273"></td>
        <td id="LC1273">    <span><span>//</span> Always release our ref to ShimProcess. If the Process was created, then it takes a reference.</span></td>
      </tr>
      <tr>
        <td id="L1274" data-line-number="1274"></td>
        <td id="LC1274">
</td>
      </tr>
      <tr>
        <td id="L1275" data-line-number="1275"></td>
        <td id="LC1275">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L1276" data-line-number="1276"></td>
        <td id="LC1276">}</td>
      </tr>
      <tr>
        <td id="L1277" data-line-number="1277"></td>
        <td id="LC1277">
</td>
      </tr>
      <tr>
        <td id="L1278" data-line-number="1278"></td>
        <td id="LC1278"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1279" data-line-number="1279"></td>
        <td id="LC1279"><span><span>//</span> Neuter all of all children, but not the actual process object.</span></td>
      </tr>
      <tr>
        <td id="L1280" data-line-number="1280"></td>
        <td id="LC1280"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1281" data-line-number="1281"></td>
        <td id="LC1281"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L1282" data-line-number="1282"></td>
        <td id="LC1282"><span><span>//</span>   This clears Right-side state. Assumptions about left-side state are either:</span></td>
      </tr>
      <tr>
        <td id="L1283" data-line-number="1283"></td>
        <td id="LC1283"><span><span>//</span>   1. We're in a shutdown scenario, where all left-side state is already</span></td>
      </tr>
      <tr>
        <td id="L1284" data-line-number="1284"></td>
        <td id="LC1284"><span><span>//</span>   freed.</span></td>
      </tr>
      <tr>
        <td id="L1285" data-line-number="1285"></td>
        <td id="LC1285"><span><span>//</span>   2. Caller already verified there are no left-side resources (eg, by calling</span></td>
      </tr>
      <tr>
        <td id="L1286" data-line-number="1286"></td>
        <td id="LC1286"><span><span>//</span>   code:CordbProcess::IsReadyForDetach)</span></td>
      </tr>
      <tr>
        <td id="L1287" data-line-number="1287"></td>
        <td id="LC1287"><span><span>//</span>   3. Caller did code:CordbProcess::NeuterLeftSideResources first</span></td>
      </tr>
      <tr>
        <td id="L1288" data-line-number="1288"></td>
        <td id="LC1288"><span><span>//</span>   to clean up left-side resources.</span></td>
      </tr>
      <tr>
        <td id="L1289" data-line-number="1289"></td>
        <td id="LC1289"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1290" data-line-number="1290"></td>
        <td id="LC1290"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1291" data-line-number="1291"></td>
        <td id="LC1291"><span><span>//</span>   This could be called multiple times (code:CordbProcess::FlushAll), so</span></td>
      </tr>
      <tr>
        <td id="L1292" data-line-number="1292"></td>
        <td id="LC1292"><span><span>//</span>   be sure to null out any potential dangling pointers. State may be rebuilt</span></td>
      </tr>
      <tr>
        <td id="L1293" data-line-number="1293"></td>
        <td id="LC1293"><span><span>//</span>   up after each time.</span></td>
      </tr>
      <tr>
        <td id="L1294" data-line-number="1294"></td>
        <td id="LC1294"><span>void</span> <span>CordbProcess::NeuterChildren</span>()</td>
      </tr>
      <tr>
        <td id="L1295" data-line-number="1295"></td>
        <td id="LC1295">{</td>
      </tr>
      <tr>
        <td id="L1296" data-line-number="1296"></td>
        <td id="LC1296">    <span>_ASSERTE</span>(<span>GetProcessLock</span>()-&gt;<span>HasLock</span>());</td>
      </tr>
      <tr>
        <td id="L1297" data-line-number="1297"></td>
        <td id="LC1297">
</td>
      </tr>
      <tr>
        <td id="L1298" data-line-number="1298"></td>
        <td id="LC1298">    <span><span>//</span> Frees left-side resources. See assumptions above.</span></td>
      </tr>
      <tr>
        <td id="L1299" data-line-number="1299"></td>
        <td id="LC1299">    m_LeftSideResourceCleanupList.<span>NeuterAndClear</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1300" data-line-number="1300"></td>
        <td id="LC1300">
</td>
      </tr>
      <tr>
        <td id="L1301" data-line-number="1301"></td>
        <td id="LC1301">
</td>
      </tr>
      <tr>
        <td id="L1302" data-line-number="1302"></td>
        <td id="LC1302">    m_EvalTable.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L1303" data-line-number="1303"></td>
        <td id="LC1303">
</td>
      </tr>
      <tr>
        <td id="L1304" data-line-number="1304"></td>
        <td id="LC1304">
</td>
      </tr>
      <tr>
        <td id="L1305" data-line-number="1305"></td>
        <td id="LC1305">    <span><span>//</span> Sweep neuter lists.</span></td>
      </tr>
      <tr>
        <td id="L1306" data-line-number="1306"></td>
        <td id="LC1306">    m_ExitNeuterList.<span>NeuterAndClear</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1307" data-line-number="1307"></td>
        <td id="LC1307">    m_ContinueNeuterList.<span>NeuterAndClear</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1308" data-line-number="1308"></td>
        <td id="LC1308">
</td>
      </tr>
      <tr>
        <td id="L1309" data-line-number="1309"></td>
        <td id="LC1309">    m_userThreads.<span>NeuterAndClear</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1310" data-line-number="1310"></td>
        <td id="LC1310">
</td>
      </tr>
      <tr>
        <td id="L1311" data-line-number="1311"></td>
        <td id="LC1311">    m_pDefaultAppDomain = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1312" data-line-number="1312"></td>
        <td id="LC1312">
</td>
      </tr>
      <tr>
        <td id="L1313" data-line-number="1313"></td>
        <td id="LC1313">    <span><span>//</span> Frees per-appdomain left-side resources. See assumptions above.</span></td>
      </tr>
      <tr>
        <td id="L1314" data-line-number="1314"></td>
        <td id="LC1314">    m_appDomains.<span>NeuterAndClear</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1315" data-line-number="1315"></td>
        <td id="LC1315">    <span>if</span> (m_sharedAppDomain != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1316" data-line-number="1316"></td>
        <td id="LC1316">    {</td>
      </tr>
      <tr>
        <td id="L1317" data-line-number="1317"></td>
        <td id="LC1317">        m_sharedAppDomain-&gt;<span>Neuter</span>();</td>
      </tr>
      <tr>
        <td id="L1318" data-line-number="1318"></td>
        <td id="LC1318">        m_sharedAppDomain-&gt;<span>InternalRelease</span>();</td>
      </tr>
      <tr>
        <td id="L1319" data-line-number="1319"></td>
        <td id="LC1319">        m_sharedAppDomain = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1320" data-line-number="1320"></td>
        <td id="LC1320">    }</td>
      </tr>
      <tr>
        <td id="L1321" data-line-number="1321"></td>
        <td id="LC1321">
</td>
      </tr>
      <tr>
        <td id="L1322" data-line-number="1322"></td>
        <td id="LC1322">    m_steppers.<span>NeuterAndClear</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1323" data-line-number="1323"></td>
        <td id="LC1323">
</td>
      </tr>
      <tr>
        <td id="L1324" data-line-number="1324"></td>
        <td id="LC1324">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L1325" data-line-number="1325"></td>
        <td id="LC1325">    m_unmanagedThreads.<span>NeuterAndClear</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1326" data-line-number="1326"></td>
        <td id="LC1326">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L1327" data-line-number="1327"></td>
        <td id="LC1327">
</td>
      </tr>
      <tr>
        <td id="L1328" data-line-number="1328"></td>
        <td id="LC1328">    <span><span>//</span> Explicitly keep the Win32EventThread alive so that we can use it in the window</span></td>
      </tr>
      <tr>
        <td id="L1329" data-line-number="1329"></td>
        <td id="LC1329">    <span><span>//</span> between NeuterChildren + Neuter.</span></td>
      </tr>
      <tr>
        <td id="L1330" data-line-number="1330"></td>
        <td id="LC1330">}</td>
      </tr>
      <tr>
        <td id="L1331" data-line-number="1331"></td>
        <td id="LC1331">
</td>
      </tr>
      <tr>
        <td id="L1332" data-line-number="1332"></td>
        <td id="LC1332"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1333" data-line-number="1333"></td>
        <td id="LC1333"><span><span>//</span> Neuter</span></td>
      </tr>
      <tr>
        <td id="L1334" data-line-number="1334"></td>
        <td id="LC1334"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1335" data-line-number="1335"></td>
        <td id="LC1335"><span><span>//</span> When the process dies, remove all the resources associated with this object.</span></td>
      </tr>
      <tr>
        <td id="L1336" data-line-number="1336"></td>
        <td id="LC1336"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1337" data-line-number="1337"></td>
        <td id="LC1337"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1338" data-line-number="1338"></td>
        <td id="LC1338"><span><span>//</span>   Once we neuter ourself, we can no longer send IPC events. So this is useful</span></td>
      </tr>
      <tr>
        <td id="L1339" data-line-number="1339"></td>
        <td id="LC1339"><span><span>//</span>   on detach. This will be called on FlushAll (which has Whidbey detach</span></td>
      </tr>
      <tr>
        <td id="L1340" data-line-number="1340"></td>
        <td id="LC1340"><span><span>//</span>   semantics)</span></td>
      </tr>
      <tr>
        <td id="L1341" data-line-number="1341"></td>
        <td id="LC1341"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1342" data-line-number="1342"></td>
        <td id="LC1342"><span>void</span> <span>CordbProcess::Neuter</span>()</td>
      </tr>
      <tr>
        <td id="L1343" data-line-number="1343"></td>
        <td id="LC1343">{</td>
      </tr>
      <tr>
        <td id="L1344" data-line-number="1344"></td>
        <td id="LC1344">    <span><span>//</span> Process's Neuter is at the top of the neuter tree. So we take the process-lock</span></td>
      </tr>
      <tr>
        <td id="L1345" data-line-number="1345"></td>
        <td id="LC1345">    <span><span>//</span> here and then all child items (appdomains, modules, etc) will assert</span></td>
      </tr>
      <tr>
        <td id="L1346" data-line-number="1346"></td>
        <td id="LC1346">    <span><span>//</span> that they hold the lock.</span></td>
      </tr>
      <tr>
        <td id="L1347" data-line-number="1347"></td>
        <td id="LC1347">    <span>_ASSERTE</span>(!<span>this</span>-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1348" data-line-number="1348"></td>
        <td id="LC1348">
</td>
      </tr>
      <tr>
        <td id="L1349" data-line-number="1349"></td>
        <td id="LC1349">    <span><span>//</span> Take the process lock.</span></td>
      </tr>
      <tr>
        <td id="L1350" data-line-number="1350"></td>
        <td id="LC1350">    RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1351" data-line-number="1351"></td>
        <td id="LC1351">
</td>
      </tr>
      <tr>
        <td id="L1352" data-line-number="1352"></td>
        <td id="LC1352">
</td>
      </tr>
      <tr>
        <td id="L1353" data-line-number="1353"></td>
        <td id="LC1353">    <span>NeuterChildren</span>();</td>
      </tr>
      <tr>
        <td id="L1354" data-line-number="1354"></td>
        <td id="LC1354">
</td>
      </tr>
      <tr>
        <td id="L1355" data-line-number="1355"></td>
        <td id="LC1355">    <span><span>//</span> Release the metadata interfaces</span></td>
      </tr>
      <tr>
        <td id="L1356" data-line-number="1356"></td>
        <td id="LC1356">    m_pMetaDispenser.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L1357" data-line-number="1357"></td>
        <td id="LC1357">
</td>
      </tr>
      <tr>
        <td id="L1358" data-line-number="1358"></td>
        <td id="LC1358">
</td>
      </tr>
      <tr>
        <td id="L1359" data-line-number="1359"></td>
        <td id="LC1359">    <span>if</span> (m_hHelperThread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1360" data-line-number="1360"></td>
        <td id="LC1360">    {</td>
      </tr>
      <tr>
        <td id="L1361" data-line-number="1361"></td>
        <td id="LC1361">        <span>CloseHandle</span>(m_hHelperThread);</td>
      </tr>
      <tr>
        <td id="L1362" data-line-number="1362"></td>
        <td id="LC1362">        m_hHelperThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1363" data-line-number="1363"></td>
        <td id="LC1363">    }</td>
      </tr>
      <tr>
        <td id="L1364" data-line-number="1364"></td>
        <td id="LC1364">
</td>
      </tr>
      <tr>
        <td id="L1365" data-line-number="1365"></td>
        <td id="LC1365">    {</td>
      </tr>
      <tr>
        <td id="L1366" data-line-number="1366"></td>
        <td id="LC1366">        lockHolder.<span>Release</span>();</td>
      </tr>
      <tr>
        <td id="L1367" data-line-number="1367"></td>
        <td id="LC1367">        {</td>
      </tr>
      <tr>
        <td id="L1368" data-line-number="1368"></td>
        <td id="LC1368">            <span><span>//</span> We may still hold the Stop-Go lock.</span></td>
      </tr>
      <tr>
        <td id="L1369" data-line-number="1369"></td>
        <td id="LC1369">            <span><span>//</span> @dbgtodo - left-side resources / shutdown, shim: Currently</span></td>
      </tr>
      <tr>
        <td id="L1370" data-line-number="1370"></td>
        <td id="LC1370">            <span><span>//</span> the shim shutdown is too interwoven with CordbProcess to split</span></td>
      </tr>
      <tr>
        <td id="L1371" data-line-number="1371"></td>
        <td id="LC1371">            <span><span>//</span> it out from the locks. Must fully hoist the W32ET and make</span></td>
      </tr>
      <tr>
        <td id="L1372" data-line-number="1372"></td>
        <td id="LC1372">            <span><span>//</span> it safely outside the RS, and outside the protection of RS</span></td>
      </tr>
      <tr>
        <td id="L1373" data-line-number="1373"></td>
        <td id="LC1373">            <span><span>//</span> locks.</span></td>
      </tr>
      <tr>
        <td id="L1374" data-line-number="1374"></td>
        <td id="LC1374">            <span>PUBLIC_API_UNSAFE_ENTRY_FOR_SHIM</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1375" data-line-number="1375"></td>
        <td id="LC1375">
</td>
      </tr>
      <tr>
        <td id="L1376" data-line-number="1376"></td>
        <td id="LC1376">            <span><span>//</span> Now that all of our children are neutered, it should be safe to kill the W32ET.</span></td>
      </tr>
      <tr>
        <td id="L1377" data-line-number="1377"></td>
        <td id="LC1377">            <span><span>//</span> Shutdown the shim, and this will also shutdown the W32ET.</span></td>
      </tr>
      <tr>
        <td id="L1378" data-line-number="1378"></td>
        <td id="LC1378">            <span><span>//</span> Do this outside of the process-lock so that we can shutdown the</span></td>
      </tr>
      <tr>
        <td id="L1379" data-line-number="1379"></td>
        <td id="LC1379">            <span><span>//</span> W23ET.</span></td>
      </tr>
      <tr>
        <td id="L1380" data-line-number="1380"></td>
        <td id="LC1380">            <span>if</span> (m_pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1381" data-line-number="1381"></td>
        <td id="LC1381">            {</td>
      </tr>
      <tr>
        <td id="L1382" data-line-number="1382"></td>
        <td id="LC1382">                m_pShim-&gt;<span>Dispose</span>();</td>
      </tr>
      <tr>
        <td id="L1383" data-line-number="1383"></td>
        <td id="LC1383">                m_pShim.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L1384" data-line-number="1384"></td>
        <td id="LC1384">            }</td>
      </tr>
      <tr>
        <td id="L1385" data-line-number="1385"></td>
        <td id="LC1385">        }</td>
      </tr>
      <tr>
        <td id="L1386" data-line-number="1386"></td>
        <td id="LC1386">
</td>
      </tr>
      <tr>
        <td id="L1387" data-line-number="1387"></td>
        <td id="LC1387">        lockHolder.<span>Acquire</span>();</td>
      </tr>
      <tr>
        <td id="L1388" data-line-number="1388"></td>
        <td id="LC1388">    }</td>
      </tr>
      <tr>
        <td id="L1389" data-line-number="1389"></td>
        <td id="LC1389">
</td>
      </tr>
      <tr>
        <td id="L1390" data-line-number="1390"></td>
        <td id="LC1390">    <span><span>//</span> Unload DAC, and then release our final data target references</span></td>
      </tr>
      <tr>
        <td id="L1391" data-line-number="1391"></td>
        <td id="LC1391">    <span>FreeDac</span>();</td>
      </tr>
      <tr>
        <td id="L1392" data-line-number="1392"></td>
        <td id="LC1392">    m_pDACDataTarget.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L1393" data-line-number="1393"></td>
        <td id="LC1393">    m_pMutableDataTarget.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L1394" data-line-number="1394"></td>
        <td id="LC1394">    m_pMetaDataLocator.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L1395" data-line-number="1395"></td>
        <td id="LC1395">
</td>
      </tr>
      <tr>
        <td id="L1396" data-line-number="1396"></td>
        <td id="LC1396">    <span>if</span> (m_pEventChannel != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1397" data-line-number="1397"></td>
        <td id="LC1397">    {</td>
      </tr>
      <tr>
        <td id="L1398" data-line-number="1398"></td>
        <td id="LC1398">        m_pEventChannel-&gt;<span>Delete</span>();</td>
      </tr>
      <tr>
        <td id="L1399" data-line-number="1399"></td>
        <td id="LC1399">        m_pEventChannel = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1400" data-line-number="1400"></td>
        <td id="LC1400">    }</td>
      </tr>
      <tr>
        <td id="L1401" data-line-number="1401"></td>
        <td id="LC1401">
</td>
      </tr>
      <tr>
        <td id="L1402" data-line-number="1402"></td>
        <td id="LC1402">    <span><span>//</span> Need process lock to clear the patch table</span></td>
      </tr>
      <tr>
        <td id="L1403" data-line-number="1403"></td>
        <td id="LC1403">    <span>ClearPatchTable</span>();</td>
      </tr>
      <tr>
        <td id="L1404" data-line-number="1404"></td>
        <td id="LC1404">
</td>
      </tr>
      <tr>
        <td id="L1405" data-line-number="1405"></td>
        <td id="LC1405">    <span>CordbProcess::CloseIPCHandles</span>();</td>
      </tr>
      <tr>
        <td id="L1406" data-line-number="1406"></td>
        <td id="LC1406">
</td>
      </tr>
      <tr>
        <td id="L1407" data-line-number="1407"></td>
        <td id="LC1407">    <span>CordbBase::Neuter</span>();</td>
      </tr>
      <tr>
        <td id="L1408" data-line-number="1408"></td>
        <td id="LC1408">
</td>
      </tr>
      <tr>
        <td id="L1409" data-line-number="1409"></td>
        <td id="LC1409">    m_cordb.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L1410" data-line-number="1410"></td>
        <td id="LC1410">
</td>
      </tr>
      <tr>
        <td id="L1411" data-line-number="1411"></td>
        <td id="LC1411">    <span><span>//</span> Need to release this reference to ourselves. Other leaf objects may still hold</span></td>
      </tr>
      <tr>
        <td id="L1412" data-line-number="1412"></td>
        <td id="LC1412">    <span><span>//</span> strong references back to this CordbProcess object.</span></td>
      </tr>
      <tr>
        <td id="L1413" data-line-number="1413"></td>
        <td id="LC1413">    <span>_ASSERTE</span>(m_pProcess == <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1414" data-line-number="1414"></td>
        <td id="LC1414">    m_pProcess.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L1415" data-line-number="1415"></td>
        <td id="LC1415">}</td>
      </tr>
      <tr>
        <td id="L1416" data-line-number="1416"></td>
        <td id="LC1416">
</td>
      </tr>
      <tr>
        <td id="L1417" data-line-number="1417"></td>
        <td id="LC1417"><span><span>//</span> Wrapper to return metadata dispenser.</span></td>
      </tr>
      <tr>
        <td id="L1418" data-line-number="1418"></td>
        <td id="LC1418"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1419" data-line-number="1419"></td>
        <td id="LC1419"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1420" data-line-number="1420"></td>
        <td id="LC1420"><span><span>//</span>    Does not adjust reference count of dispenser.</span></td>
      </tr>
      <tr>
        <td id="L1421" data-line-number="1421"></td>
        <td id="LC1421"><span><span>//</span>    Dispenser is destroyed in code:CordbProcess::Neuter</span></td>
      </tr>
      <tr>
        <td id="L1422" data-line-number="1422"></td>
        <td id="LC1422"><span><span>//</span>    Dispenser is non-null.</span></td>
      </tr>
      <tr>
        <td id="L1423" data-line-number="1423"></td>
        <td id="LC1423">IMetaDataDispenserEx * <span>CordbProcess::GetDispenser</span>()</td>
      </tr>
      <tr>
        <td id="L1424" data-line-number="1424"></td>
        <td id="LC1424">{</td>
      </tr>
      <tr>
        <td id="L1425" data-line-number="1425"></td>
        <td id="LC1425">    <span>_ASSERTE</span>(m_pMetaDispenser != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1426" data-line-number="1426"></td>
        <td id="LC1426">    <span>return</span> m_pMetaDispenser;</td>
      </tr>
      <tr>
        <td id="L1427" data-line-number="1427"></td>
        <td id="LC1427">}</td>
      </tr>
      <tr>
        <td id="L1428" data-line-number="1428"></td>
        <td id="LC1428">
</td>
      </tr>
      <tr>
        <td id="L1429" data-line-number="1429"></td>
        <td id="LC1429">
</td>
      </tr>
      <tr>
        <td id="L1430" data-line-number="1430"></td>
        <td id="LC1430"><span>void</span> <span>CordbProcess::CloseIPCHandles</span>()</td>
      </tr>
      <tr>
        <td id="L1431" data-line-number="1431"></td>
        <td id="LC1431">{</td>
      </tr>
      <tr>
        <td id="L1432" data-line-number="1432"></td>
        <td id="LC1432">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1433" data-line-number="1433"></td>
        <td id="LC1433">
</td>
      </tr>
      <tr>
        <td id="L1434" data-line-number="1434"></td>
        <td id="LC1434">    <span><span>//</span> Close off Right Side's handles.</span></td>
      </tr>
      <tr>
        <td id="L1435" data-line-number="1435"></td>
        <td id="LC1435">    <span>if</span> (m_leftSideEventAvailable != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1436" data-line-number="1436"></td>
        <td id="LC1436">    {</td>
      </tr>
      <tr>
        <td id="L1437" data-line-number="1437"></td>
        <td id="LC1437">        <span>CloseHandle</span>(m_leftSideEventAvailable);</td>
      </tr>
      <tr>
        <td id="L1438" data-line-number="1438"></td>
        <td id="LC1438">        m_leftSideEventAvailable = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1439" data-line-number="1439"></td>
        <td id="LC1439">    }</td>
      </tr>
      <tr>
        <td id="L1440" data-line-number="1440"></td>
        <td id="LC1440">
</td>
      </tr>
      <tr>
        <td id="L1441" data-line-number="1441"></td>
        <td id="LC1441">    <span>if</span> (m_leftSideEventRead != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1442" data-line-number="1442"></td>
        <td id="LC1442">    {</td>
      </tr>
      <tr>
        <td id="L1443" data-line-number="1443"></td>
        <td id="LC1443">        <span>CloseHandle</span>(m_leftSideEventRead);</td>
      </tr>
      <tr>
        <td id="L1444" data-line-number="1444"></td>
        <td id="LC1444">        m_leftSideEventRead = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1445" data-line-number="1445"></td>
        <td id="LC1445">    }</td>
      </tr>
      <tr>
        <td id="L1446" data-line-number="1446"></td>
        <td id="LC1446">
</td>
      </tr>
      <tr>
        <td id="L1447" data-line-number="1447"></td>
        <td id="LC1447">    <span>if</span> (m_handle != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1448" data-line-number="1448"></td>
        <td id="LC1448">    {</td>
      </tr>
      <tr>
        <td id="L1449" data-line-number="1449"></td>
        <td id="LC1449">        <span><span>//</span> @dbgtodo  - We should probably add asserts to all calls to CloseHandles(), but this has been</span></td>
      </tr>
      <tr>
        <td id="L1450" data-line-number="1450"></td>
        <td id="LC1450">        <span><span>//</span> a particularly problematic spot in the past for Mac debugging.</span></td>
      </tr>
      <tr>
        <td id="L1451" data-line-number="1451"></td>
        <td id="LC1451">        BOOL <span>fSuccess</span> = <span>CloseHandle</span>(m_handle);</td>
      </tr>
      <tr>
        <td id="L1452" data-line-number="1452"></td>
        <td id="LC1452">        (<span>void</span>)<span>fSuccess</span>; <span><span>//</span>prevent "unused variable" error from GCC</span></td>
      </tr>
      <tr>
        <td id="L1453" data-line-number="1453"></td>
        <td id="LC1453">        <span>_ASSERTE</span>(<span>fSuccess</span>);</td>
      </tr>
      <tr>
        <td id="L1454" data-line-number="1454"></td>
        <td id="LC1454">
</td>
      </tr>
      <tr>
        <td id="L1455" data-line-number="1455"></td>
        <td id="LC1455">        m_handle = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1456" data-line-number="1456"></td>
        <td id="LC1456">    }</td>
      </tr>
      <tr>
        <td id="L1457" data-line-number="1457"></td>
        <td id="LC1457">
</td>
      </tr>
      <tr>
        <td id="L1458" data-line-number="1458"></td>
        <td id="LC1458">#<span>if</span> defined(FEATURE_INTEROP_DEBUGGING)</td>
      </tr>
      <tr>
        <td id="L1459" data-line-number="1459"></td>
        <td id="LC1459">    <span>if</span> (m_leftSideUnmanagedWaitEvent != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1460" data-line-number="1460"></td>
        <td id="LC1460">    {</td>
      </tr>
      <tr>
        <td id="L1461" data-line-number="1461"></td>
        <td id="LC1461">        <span>CloseHandle</span>(m_leftSideUnmanagedWaitEvent);</td>
      </tr>
      <tr>
        <td id="L1462" data-line-number="1462"></td>
        <td id="LC1462">        m_leftSideUnmanagedWaitEvent = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1463" data-line-number="1463"></td>
        <td id="LC1463">    }</td>
      </tr>
      <tr>
        <td id="L1464" data-line-number="1464"></td>
        <td id="LC1464">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L1465" data-line-number="1465"></td>
        <td id="LC1465">
</td>
      </tr>
      <tr>
        <td id="L1466" data-line-number="1466"></td>
        <td id="LC1466">    <span>if</span> (m_stopWaitEvent != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1467" data-line-number="1467"></td>
        <td id="LC1467">    {</td>
      </tr>
      <tr>
        <td id="L1468" data-line-number="1468"></td>
        <td id="LC1468">        <span>CloseHandle</span>(m_stopWaitEvent);</td>
      </tr>
      <tr>
        <td id="L1469" data-line-number="1469"></td>
        <td id="LC1469">        m_stopWaitEvent = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1470" data-line-number="1470"></td>
        <td id="LC1470">    }</td>
      </tr>
      <tr>
        <td id="L1471" data-line-number="1471"></td>
        <td id="LC1471">}</td>
      </tr>
      <tr>
        <td id="L1472" data-line-number="1472"></td>
        <td id="LC1472">
</td>
      </tr>
      <tr>
        <td id="L1473" data-line-number="1473"></td>
        <td id="LC1473">
</td>
      </tr>
      <tr>
        <td id="L1474" data-line-number="1474"></td>
        <td id="LC1474"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1475" data-line-number="1475"></td>
        <td id="LC1475"><span><span>//</span> Create new OS Thread for the Win32 Event Thread (the thread used in interop-debugging to sniff</span></td>
      </tr>
      <tr>
        <td id="L1476" data-line-number="1476"></td>
        <td id="LC1476"><span><span>//</span> native debug events). This is 1:1 w/ a CordbProcess object.</span></td>
      </tr>
      <tr>
        <td id="L1477" data-line-number="1477"></td>
        <td id="LC1477"><span><span>//</span> This will then be used to actuall create the CordbProcess object.</span></td>
      </tr>
      <tr>
        <td id="L1478" data-line-number="1478"></td>
        <td id="LC1478"><span><span>//</span> The process object will then take ownership of the thread.</span></td>
      </tr>
      <tr>
        <td id="L1479" data-line-number="1479"></td>
        <td id="LC1479"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1480" data-line-number="1480"></td>
        <td id="LC1480"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1481" data-line-number="1481"></td>
        <td id="LC1481"><span><span>//</span>     pCordb - the root object that the process lives under</span></td>
      </tr>
      <tr>
        <td id="L1482" data-line-number="1482"></td>
        <td id="LC1482"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1483" data-line-number="1483"></td>
        <td id="LC1483"><span><span>//</span> Return values:</span></td>
      </tr>
      <tr>
        <td id="L1484" data-line-number="1484"></td>
        <td id="LC1484"><span><span>//</span>     S_OK on success.</span></td>
      </tr>
      <tr>
        <td id="L1485" data-line-number="1485"></td>
        <td id="LC1485"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1486" data-line-number="1486"></td>
        <td id="LC1486">HRESULT <span>ShimProcess::CreateAndStartWin32ET</span>(Cordb * pCordb)</td>
      </tr>
      <tr>
        <td id="L1487" data-line-number="1487"></td>
        <td id="LC1487">{</td>
      </tr>
      <tr>
        <td id="L1488" data-line-number="1488"></td>
        <td id="LC1488">
</td>
      </tr>
      <tr>
        <td id="L1489" data-line-number="1489"></td>
        <td id="LC1489">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1490" data-line-number="1490"></td>
        <td id="LC1490">    <span><span>//</span> Create the win32 event listening thread</span></td>
      </tr>
      <tr>
        <td id="L1491" data-line-number="1491"></td>
        <td id="LC1491">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1492" data-line-number="1492"></td>
        <td id="LC1492">    CordbWin32EventThread * pWin32EventThread = <span>new</span> (nothrow) <span>CordbWin32EventThread</span>(pCordb, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1493" data-line-number="1493"></td>
        <td id="LC1493">
</td>
      </tr>
      <tr>
        <td id="L1494" data-line-number="1494"></td>
        <td id="LC1494">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L1495" data-line-number="1495"></td>
        <td id="LC1495">
</td>
      </tr>
      <tr>
        <td id="L1496" data-line-number="1496"></td>
        <td id="LC1496">    <span>if</span> (pWin32EventThread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1497" data-line-number="1497"></td>
        <td id="LC1497">    {</td>
      </tr>
      <tr>
        <td id="L1498" data-line-number="1498"></td>
        <td id="LC1498">        hr = pWin32EventThread-&gt;<span>Init</span>();</td>
      </tr>
      <tr>
        <td id="L1499" data-line-number="1499"></td>
        <td id="LC1499">
</td>
      </tr>
      <tr>
        <td id="L1500" data-line-number="1500"></td>
        <td id="LC1500">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L1501" data-line-number="1501"></td>
        <td id="LC1501">        {</td>
      </tr>
      <tr>
        <td id="L1502" data-line-number="1502"></td>
        <td id="LC1502">            hr = pWin32EventThread-&gt;<span>Start</span>();</td>
      </tr>
      <tr>
        <td id="L1503" data-line-number="1503"></td>
        <td id="LC1503">        }</td>
      </tr>
      <tr>
        <td id="L1504" data-line-number="1504"></td>
        <td id="LC1504">
</td>
      </tr>
      <tr>
        <td id="L1505" data-line-number="1505"></td>
        <td id="LC1505">        <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L1506" data-line-number="1506"></td>
        <td id="LC1506">        {</td>
      </tr>
      <tr>
        <td id="L1507" data-line-number="1507"></td>
        <td id="LC1507">            <span>delete</span> pWin32EventThread;</td>
      </tr>
      <tr>
        <td id="L1508" data-line-number="1508"></td>
        <td id="LC1508">            pWin32EventThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1509" data-line-number="1509"></td>
        <td id="LC1509">        }</td>
      </tr>
      <tr>
        <td id="L1510" data-line-number="1510"></td>
        <td id="LC1510">    }</td>
      </tr>
      <tr>
        <td id="L1511" data-line-number="1511"></td>
        <td id="LC1511">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L1512" data-line-number="1512"></td>
        <td id="LC1512">    {</td>
      </tr>
      <tr>
        <td id="L1513" data-line-number="1513"></td>
        <td id="LC1513">        hr = E_OUTOFMEMORY;</td>
      </tr>
      <tr>
        <td id="L1514" data-line-number="1514"></td>
        <td id="LC1514">    }</td>
      </tr>
      <tr>
        <td id="L1515" data-line-number="1515"></td>
        <td id="LC1515">
</td>
      </tr>
      <tr>
        <td id="L1516" data-line-number="1516"></td>
        <td id="LC1516">    m_pWin32EventThread = pWin32EventThread;</td>
      </tr>
      <tr>
        <td id="L1517" data-line-number="1517"></td>
        <td id="LC1517">    <span>return</span> <span>ErrWrapper</span>(hr);</td>
      </tr>
      <tr>
        <td id="L1518" data-line-number="1518"></td>
        <td id="LC1518">}</td>
      </tr>
      <tr>
        <td id="L1519" data-line-number="1519"></td>
        <td id="LC1519">
</td>
      </tr>
      <tr>
        <td id="L1520" data-line-number="1520"></td>
        <td id="LC1520">
</td>
      </tr>
      <tr>
        <td id="L1521" data-line-number="1521"></td>
        <td id="LC1521"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1522" data-line-number="1522"></td>
        <td id="LC1522"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1523" data-line-number="1523"></td>
        <td id="LC1523"><span><span>//</span> Try to initialize the DAC. Called in scenarios where it may fail.</span></td>
      </tr>
      <tr>
        <td id="L1524" data-line-number="1524"></td>
        <td id="LC1524"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1525" data-line-number="1525"></td>
        <td id="LC1525"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L1526" data-line-number="1526"></td>
        <td id="LC1526"><span><span>//</span>    TRUE  - DAC is initialized.</span></td>
      </tr>
      <tr>
        <td id="L1527" data-line-number="1527"></td>
        <td id="LC1527"><span><span>//</span>    FALSE  - Not initialized, but can try again later. Common case if</span></td>
      </tr>
      <tr>
        <td id="L1528" data-line-number="1528"></td>
        <td id="LC1528"><span><span>//</span>          target has not yet loaded the runtime.</span></td>
      </tr>
      <tr>
        <td id="L1529" data-line-number="1529"></td>
        <td id="LC1529"><span><span>//</span>    Throws exception - fatal.</span></td>
      </tr>
      <tr>
        <td id="L1530" data-line-number="1530"></td>
        <td id="LC1530"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1531" data-line-number="1531"></td>
        <td id="LC1531"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L1532" data-line-number="1532"></td>
        <td id="LC1532"><span><span>//</span>    Target is stopped by OS, so we can safely inspect it without it moving on us.</span></td>
      </tr>
      <tr>
        <td id="L1533" data-line-number="1533"></td>
        <td id="LC1533"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1534" data-line-number="1534"></td>
        <td id="LC1534"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1535" data-line-number="1535"></td>
        <td id="LC1535"><span><span>//</span>    This can be called eagerly to sniff if the LS is initialized.</span></td>
      </tr>
      <tr>
        <td id="L1536" data-line-number="1536"></td>
        <td id="LC1536"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1537" data-line-number="1537"></td>
        <td id="LC1537"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1538" data-line-number="1538"></td>
        <td id="LC1538">BOOL <span>CordbProcess::TryInitializeDac</span>()</td>
      </tr>
      <tr>
        <td id="L1539" data-line-number="1539"></td>
        <td id="LC1539">{</td>
      </tr>
      <tr>
        <td id="L1540" data-line-number="1540"></td>
        <td id="LC1540">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L1541" data-line-number="1541"></td>
        <td id="LC1541">    {</td>
      </tr>
      <tr>
        <td id="L1542" data-line-number="1542"></td>
        <td id="LC1542">        THROWS;</td>
      </tr>
      <tr>
        <td id="L1543" data-line-number="1543"></td>
        <td id="LC1543">    }</td>
      </tr>
      <tr>
        <td id="L1544" data-line-number="1544"></td>
        <td id="LC1544">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L1545" data-line-number="1545"></td>
        <td id="LC1545">
</td>
      </tr>
      <tr>
        <td id="L1546" data-line-number="1546"></td>
        <td id="LC1546">    <span><span>//</span> Target is stopped by OS, so we can safely inspect it without it moving on us.</span></td>
      </tr>
      <tr>
        <td id="L1547" data-line-number="1547"></td>
        <td id="LC1547">
</td>
      </tr>
      <tr>
        <td id="L1548" data-line-number="1548"></td>
        <td id="LC1548">    <span><span>//</span> We want to avoid exceptions in the normal case, so we do some pre-checks</span></td>
      </tr>
      <tr>
        <td id="L1549" data-line-number="1549"></td>
        <td id="LC1549">    <span><span>//</span> to detect failure without relying on exceptions.</span></td>
      </tr>
      <tr>
        <td id="L1550" data-line-number="1550"></td>
        <td id="LC1550">    <span><span>//</span> Can't initialize DAC until mscorwks is loaded. So that's a sanity test.</span></td>
      </tr>
      <tr>
        <td id="L1551" data-line-number="1551"></td>
        <td id="LC1551">    HRESULT hr = <span>EnsureClrInstanceIdSet</span>();</td>
      </tr>
      <tr>
        <td id="L1552" data-line-number="1552"></td>
        <td id="LC1552">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L1553" data-line-number="1553"></td>
        <td id="LC1553">    {</td>
      </tr>
      <tr>
        <td id="L1554" data-line-number="1554"></td>
        <td id="LC1554">        <span>return</span> <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L1555" data-line-number="1555"></td>
        <td id="LC1555">    }</td>
      </tr>
      <tr>
        <td id="L1556" data-line-number="1556"></td>
        <td id="LC1556">
</td>
      </tr>
      <tr>
        <td id="L1557" data-line-number="1557"></td>
        <td id="LC1557">    <span><span>//</span> By this point, we know which CLR in the target to debug. That means there is a CLR</span></td>
      </tr>
      <tr>
        <td id="L1558" data-line-number="1558"></td>
        <td id="LC1558">    <span><span>//</span> in the target, and it's safe to initialize DAC.</span></td>
      </tr>
      <tr>
        <td id="L1559" data-line-number="1559"></td>
        <td id="LC1559">    <span>_ASSERTE</span>(m_clrInstanceId != <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L1560" data-line-number="1560"></td>
        <td id="LC1560">
</td>
      </tr>
      <tr>
        <td id="L1561" data-line-number="1561"></td>
        <td id="LC1561">    <span><span>//</span> Now expect it to succeed</span></td>
      </tr>
      <tr>
        <td id="L1562" data-line-number="1562"></td>
        <td id="LC1562">    <span>InitializeDac</span>();</td>
      </tr>
      <tr>
        <td id="L1563" data-line-number="1563"></td>
        <td id="LC1563">    <span>return</span> <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L1564" data-line-number="1564"></td>
        <td id="LC1564">}</td>
      </tr>
      <tr>
        <td id="L1565" data-line-number="1565"></td>
        <td id="LC1565">
</td>
      </tr>
      <tr>
        <td id="L1566" data-line-number="1566"></td>
        <td id="LC1566"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1567" data-line-number="1567"></td>
        <td id="LC1567"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1568" data-line-number="1568"></td>
        <td id="LC1568"><span><span>//</span> Load &amp; Init DAC, expecting to succeed.</span></td>
      </tr>
      <tr>
        <td id="L1569" data-line-number="1569"></td>
        <td id="LC1569"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1570" data-line-number="1570"></td>
        <td id="LC1570"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L1571" data-line-number="1571"></td>
        <td id="LC1571"><span><span>//</span>    Throws on failure.</span></td>
      </tr>
      <tr>
        <td id="L1572" data-line-number="1572"></td>
        <td id="LC1572"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1573" data-line-number="1573"></td>
        <td id="LC1573"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L1574" data-line-number="1574"></td>
        <td id="LC1574"><span><span>//</span>    Caller invokes this at a point where they can expect it to succeed.</span></td>
      </tr>
      <tr>
        <td id="L1575" data-line-number="1575"></td>
        <td id="LC1575"><span><span>//</span>    This is called early in the startup path because DAC is needed for accessing</span></td>
      </tr>
      <tr>
        <td id="L1576" data-line-number="1576"></td>
        <td id="LC1576"><span><span>//</span>    data in the target.</span></td>
      </tr>
      <tr>
        <td id="L1577" data-line-number="1577"></td>
        <td id="LC1577"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1578" data-line-number="1578"></td>
        <td id="LC1578"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1579" data-line-number="1579"></td>
        <td id="LC1579"><span><span>//</span>    This needs to succeed, and should always succeed (baring a bad installation)</span></td>
      </tr>
      <tr>
        <td id="L1580" data-line-number="1580"></td>
        <td id="LC1580"><span><span>//</span>    so we assert on failure paths.</span></td>
      </tr>
      <tr>
        <td id="L1581" data-line-number="1581"></td>
        <td id="LC1581"><span><span>//</span>    This may be called mutliple times.</span></td>
      </tr>
      <tr>
        <td id="L1582" data-line-number="1582"></td>
        <td id="LC1582"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1583" data-line-number="1583"></td>
        <td id="LC1583"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1584" data-line-number="1584"></td>
        <td id="LC1584"><span>void</span> <span>CordbProcess::InitializeDac</span>()</td>
      </tr>
      <tr>
        <td id="L1585" data-line-number="1585"></td>
        <td id="LC1585">{</td>
      </tr>
      <tr>
        <td id="L1586" data-line-number="1586"></td>
        <td id="LC1586">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L1587" data-line-number="1587"></td>
        <td id="LC1587">    {</td>
      </tr>
      <tr>
        <td id="L1588" data-line-number="1588"></td>
        <td id="LC1588">        THROWS;</td>
      </tr>
      <tr>
        <td id="L1589" data-line-number="1589"></td>
        <td id="LC1589">    }</td>
      </tr>
      <tr>
        <td id="L1590" data-line-number="1590"></td>
        <td id="LC1590">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L1591" data-line-number="1591"></td>
        <td id="LC1591">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1592" data-line-number="1592"></td>
        <td id="LC1592">
</td>
      </tr>
      <tr>
        <td id="L1593" data-line-number="1593"></td>
        <td id="LC1593">    <span><span>//</span> For Mac debugginger, m_hDacModule is not used, and it will always be NULL.  To check whether DAC has</span></td>
      </tr>
      <tr>
        <td id="L1594" data-line-number="1594"></td>
        <td id="LC1594">    <span><span>//</span> been initialized, we need to check something else, namely m_pDacPrimitives.</span></td>
      </tr>
      <tr>
        <td id="L1595" data-line-number="1595"></td>
        <td id="LC1595">    <span>if</span> (m_pDacPrimitives == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1596" data-line-number="1596"></td>
        <td id="LC1596">    {</td>
      </tr>
      <tr>
        <td id="L1597" data-line-number="1597"></td>
        <td id="LC1597">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>About to load DAC<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L1598" data-line-number="1598"></td>
        <td id="LC1598">        <span>CreateDacDbiInterface</span>(); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L1599" data-line-number="1599"></td>
        <td id="LC1599">    }</td>
      </tr>
      <tr>
        <td id="L1600" data-line-number="1600"></td>
        <td id="LC1600">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L1601" data-line-number="1601"></td>
        <td id="LC1601">    {</td>
      </tr>
      <tr>
        <td id="L1602" data-line-number="1602"></td>
        <td id="LC1602">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>Dac already loaded, 0x%p<span>\n</span><span>"</span></span>, (HMODULE)m_hDacModule));</td>
      </tr>
      <tr>
        <td id="L1603" data-line-number="1603"></td>
        <td id="LC1603">    }</td>
      </tr>
      <tr>
        <td id="L1604" data-line-number="1604"></td>
        <td id="LC1604">
</td>
      </tr>
      <tr>
        <td id="L1605" data-line-number="1605"></td>
        <td id="LC1605">    <span><span>//</span> Always flush dac.</span></td>
      </tr>
      <tr>
        <td id="L1606" data-line-number="1606"></td>
        <td id="LC1606">    <span>ForceDacFlush</span>();</td>
      </tr>
      <tr>
        <td id="L1607" data-line-number="1607"></td>
        <td id="LC1607">}</td>
      </tr>
      <tr>
        <td id="L1608" data-line-number="1608"></td>
        <td id="LC1608">
</td>
      </tr>
      <tr>
        <td id="L1609" data-line-number="1609"></td>
        <td id="LC1609"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1610" data-line-number="1610"></td>
        <td id="LC1610"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1611" data-line-number="1611"></td>
        <td id="LC1611"><span><span>//</span> Free DAC resources</span></td>
      </tr>
      <tr>
        <td id="L1612" data-line-number="1612"></td>
        <td id="LC1612"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1613" data-line-number="1613"></td>
        <td id="LC1613"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1614" data-line-number="1614"></td>
        <td id="LC1614"><span><span>//</span>    This should clean up state such that code:CordbProcess::InitializeDac could be called again.</span></td>
      </tr>
      <tr>
        <td id="L1615" data-line-number="1615"></td>
        <td id="LC1615"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1616" data-line-number="1616"></td>
        <td id="LC1616"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1617" data-line-number="1617"></td>
        <td id="LC1617"><span>void</span> <span>CordbProcess::FreeDac</span>()</td>
      </tr>
      <tr>
        <td id="L1618" data-line-number="1618"></td>
        <td id="LC1618">{</td>
      </tr>
      <tr>
        <td id="L1619" data-line-number="1619"></td>
        <td id="LC1619">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L1620" data-line-number="1620"></td>
        <td id="LC1620">    {</td>
      </tr>
      <tr>
        <td id="L1621" data-line-number="1621"></td>
        <td id="LC1621">        NOTHROW; <span><span>//</span> backout code.</span></td>
      </tr>
      <tr>
        <td id="L1622" data-line-number="1622"></td>
        <td id="LC1622">    }</td>
      </tr>
      <tr>
        <td id="L1623" data-line-number="1623"></td>
        <td id="LC1623">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L1624" data-line-number="1624"></td>
        <td id="LC1624">
</td>
      </tr>
      <tr>
        <td id="L1625" data-line-number="1625"></td>
        <td id="LC1625">    <span>if</span> (m_pDacPrimitives != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1626" data-line-number="1626"></td>
        <td id="LC1626">    {</td>
      </tr>
      <tr>
        <td id="L1627" data-line-number="1627"></td>
        <td id="LC1627">        m_pDacPrimitives-&gt;<span>Destroy</span>();</td>
      </tr>
      <tr>
        <td id="L1628" data-line-number="1628"></td>
        <td id="LC1628">        m_pDacPrimitives = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L1629" data-line-number="1629"></td>
        <td id="LC1629">    }</td>
      </tr>
      <tr>
        <td id="L1630" data-line-number="1630"></td>
        <td id="LC1630">
</td>
      </tr>
      <tr>
        <td id="L1631" data-line-number="1631"></td>
        <td id="LC1631">    <span>if</span> (m_hDacModule != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1632" data-line-number="1632"></td>
        <td id="LC1632">    {</td>
      </tr>
      <tr>
        <td id="L1633" data-line-number="1633"></td>
        <td id="LC1633">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>Unloading DAC<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L1634" data-line-number="1634"></td>
        <td id="LC1634">        m_hDacModule.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L1635" data-line-number="1635"></td>
        <td id="LC1635">    }</td>
      </tr>
      <tr>
        <td id="L1636" data-line-number="1636"></td>
        <td id="LC1636">}</td>
      </tr>
      <tr>
        <td id="L1637" data-line-number="1637"></td>
        <td id="LC1637">
</td>
      </tr>
      <tr>
        <td id="L1638" data-line-number="1638"></td>
        <td id="LC1638">IEventChannel * <span>CordbProcess::GetEventChannel</span>()</td>
      </tr>
      <tr>
        <td id="L1639" data-line-number="1639"></td>
        <td id="LC1639">{</td>
      </tr>
      <tr>
        <td id="L1640" data-line-number="1640"></td>
        <td id="LC1640">    <span>_ASSERTE</span>(m_pEventChannel != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1641" data-line-number="1641"></td>
        <td id="LC1641">    <span>return</span> m_pEventChannel;</td>
      </tr>
      <tr>
        <td id="L1642" data-line-number="1642"></td>
        <td id="LC1642">}</td>
      </tr>
      <tr>
        <td id="L1643" data-line-number="1643"></td>
        <td id="LC1643">
</td>
      </tr>
      <tr>
        <td id="L1644" data-line-number="1644"></td>
        <td id="LC1644"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1645" data-line-number="1645"></td>
        <td id="LC1645"><span><span>//</span> Mark that the process is being interop-debugged.</span></td>
      </tr>
      <tr>
        <td id="L1646" data-line-number="1646"></td>
        <td id="LC1646"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1647" data-line-number="1647"></td>
        <td id="LC1647"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1648" data-line-number="1648"></td>
        <td id="LC1648"><span><span>//</span>   @dbgtodo shim: this should eventually move into the shim or go away.</span></td>
      </tr>
      <tr>
        <td id="L1649" data-line-number="1649"></td>
        <td id="LC1649"><span><span>//</span>   It's only to support V2 legacy interop-debugging.</span></td>
      </tr>
      <tr>
        <td id="L1650" data-line-number="1650"></td>
        <td id="LC1650"><span><span>//</span>   Called after code:CordbProcess::Init if we want to enable interop debugging.</span></td>
      </tr>
      <tr>
        <td id="L1651" data-line-number="1651"></td>
        <td id="LC1651"><span><span>//</span>   This allows us to separate out Interop-debugging flags from the core initialization,</span></td>
      </tr>
      <tr>
        <td id="L1652" data-line-number="1652"></td>
        <td id="LC1652"><span><span>//</span>   and paves the way for us to eventually remove it.</span></td>
      </tr>
      <tr>
        <td id="L1653" data-line-number="1653"></td>
        <td id="LC1653"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1654" data-line-number="1654"></td>
        <td id="LC1654"><span><span>//</span>   Since we're always on the naitve-pipeline, the Enabling interop debugging just changes</span></td>
      </tr>
      <tr>
        <td id="L1655" data-line-number="1655"></td>
        <td id="LC1655"><span><span>//</span>   how the native debug events are being handled. So this must be called after Init, but</span></td>
      </tr>
      <tr>
        <td id="L1656" data-line-number="1656"></td>
        <td id="LC1656"><span><span>//</span>   before any events are actually handled.</span></td>
      </tr>
      <tr>
        <td id="L1657" data-line-number="1657"></td>
        <td id="LC1657"><span><span>//</span>   This mus be calle on the win32 event thread to gaurantee that it's called before WFDE.</span></td>
      </tr>
      <tr>
        <td id="L1658" data-line-number="1658"></td>
        <td id="LC1658"><span>void</span> <span>CordbProcess::EnableInteropDebugging</span>()</td>
      </tr>
      <tr>
        <td id="L1659" data-line-number="1659"></td>
        <td id="LC1659">{</td>
      </tr>
      <tr>
        <td id="L1660" data-line-number="1660"></td>
        <td id="LC1660">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L1661" data-line-number="1661"></td>
        <td id="LC1661">    {</td>
      </tr>
      <tr>
        <td id="L1662" data-line-number="1662"></td>
        <td id="LC1662">        THROWS;</td>
      </tr>
      <tr>
        <td id="L1663" data-line-number="1663"></td>
        <td id="LC1663">        <span>PRECONDITION</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1664" data-line-number="1664"></td>
        <td id="LC1664">    }</td>
      </tr>
      <tr>
        <td id="L1665" data-line-number="1665"></td>
        <td id="LC1665">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L1666" data-line-number="1666"></td>
        <td id="LC1666">
</td>
      </tr>
      <tr>
        <td id="L1667" data-line-number="1667"></td>
        <td id="LC1667">    <span><span>//</span> Must be on W32ET to gaurantee that we're called after Init yet before WFDE (which</span></td>
      </tr>
      <tr>
        <td id="L1668" data-line-number="1668"></td>
        <td id="LC1668">    <span><span>//</span> are both called on the W32et).</span></td>
      </tr>
      <tr>
        <td id="L1669" data-line-number="1669"></td>
        <td id="LC1669">    <span>_ASSERTE</span>(<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L1670" data-line-number="1670"></td>
        <td id="LC1670">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L1671" data-line-number="1671"></td>
        <td id="LC1671">
</td>
      </tr>
      <tr>
        <td id="L1672" data-line-number="1672"></td>
        <td id="LC1672">    m_state |= PS_WIN32_ATTACHED;</td>
      </tr>
      <tr>
        <td id="L1673" data-line-number="1673"></td>
        <td id="LC1673">    <span>if</span> (<span>GetDCB</span>() != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1674" data-line-number="1674"></td>
        <td id="LC1674">    {</td>
      </tr>
      <tr>
        <td id="L1675" data-line-number="1675"></td>
        <td id="LC1675">        <span>GetDCB</span>()-&gt;<span>m_rightSideIsWin32Debugger</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1676" data-line-number="1676"></td>
        <td id="LC1676">        <span>UpdateLeftSideDCBField</span>(&amp;(<span>GetDCB</span>()-&gt;<span>m_rightSideIsWin32Debugger</span>), <span>sizeof</span>(<span>GetDCB</span>()-&gt;<span>m_rightSideIsWin32Debugger</span>));</td>
      </tr>
      <tr>
        <td id="L1677" data-line-number="1677"></td>
        <td id="LC1677">    }</td>
      </tr>
      <tr>
        <td id="L1678" data-line-number="1678"></td>
        <td id="LC1678">
</td>
      </tr>
      <tr>
        <td id="L1679" data-line-number="1679"></td>
        <td id="LC1679">    <span><span>//</span> Tell the Shim we're interop-debugging.</span></td>
      </tr>
      <tr>
        <td id="L1680" data-line-number="1680"></td>
        <td id="LC1680">    m_pShim-&gt;<span>SetIsInteropDebugging</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L1681" data-line-number="1681"></td>
        <td id="LC1681">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L1682" data-line-number="1682"></td>
        <td id="LC1682">    <span>ThrowHR</span>(CORDBG_E_INTEROP_NOT_SUPPORTED);</td>
      </tr>
      <tr>
        <td id="L1683" data-line-number="1683"></td>
        <td id="LC1683">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1684" data-line-number="1684"></td>
        <td id="LC1684">}</td>
      </tr>
      <tr>
        <td id="L1685" data-line-number="1685"></td>
        <td id="LC1685">
</td>
      </tr>
      <tr>
        <td id="L1686" data-line-number="1686"></td>
        <td id="LC1686"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1687" data-line-number="1687"></td>
        <td id="LC1687"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1688" data-line-number="1688"></td>
        <td id="LC1688"><span><span>//</span> Init -- create any objects that the process object needs to operate.</span></td>
      </tr>
      <tr>
        <td id="L1689" data-line-number="1689"></td>
        <td id="LC1689"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1690" data-line-number="1690"></td>
        <td id="LC1690"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1691" data-line-number="1691"></td>
        <td id="LC1691"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1692" data-line-number="1692"></td>
        <td id="LC1692"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L1693" data-line-number="1693"></td>
        <td id="LC1693"><span><span>//</span>    S_OK on success</span></td>
      </tr>
      <tr>
        <td id="L1694" data-line-number="1694"></td>
        <td id="LC1694"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1695" data-line-number="1695"></td>
        <td id="LC1695"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L1696" data-line-number="1696"></td>
        <td id="LC1696"><span><span>//</span>    Called on Win32 Event Thread, after OS debugging pipeline is established but</span></td>
      </tr>
      <tr>
        <td id="L1697" data-line-number="1697"></td>
        <td id="LC1697"><span><span>//</span>    before WaitForDebugEvent / ContinueDebugEvent. This means the target is stopped.</span></td>
      </tr>
      <tr>
        <td id="L1698" data-line-number="1698"></td>
        <td id="LC1698"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1699" data-line-number="1699"></td>
        <td id="LC1699"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1700" data-line-number="1700"></td>
        <td id="LC1700"><span><span>//</span>    To enable interop-debugging, call code:CordbProcess::EnableInteropDebugging</span></td>
      </tr>
      <tr>
        <td id="L1701" data-line-number="1701"></td>
        <td id="LC1701"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1702" data-line-number="1702"></td>
        <td id="LC1702">HRESULT <span>CordbProcess::Init</span>()</td>
      </tr>
      <tr>
        <td id="L1703" data-line-number="1703"></td>
        <td id="LC1703">{</td>
      </tr>
      <tr>
        <td id="L1704" data-line-number="1704"></td>
        <td id="LC1704">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1705" data-line-number="1705"></td>
        <td id="LC1705">
</td>
      </tr>
      <tr>
        <td id="L1706" data-line-number="1706"></td>
        <td id="LC1706">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L1707" data-line-number="1707"></td>
        <td id="LC1707">    BOOL <span>fIsLSStarted</span> = <span>FALSE</span>; <span><span>//</span> see meaning below.</span></td>
      </tr>
      <tr>
        <td id="L1708" data-line-number="1708"></td>
        <td id="LC1708">
</td>
      </tr>
      <tr>
        <td id="L1709" data-line-number="1709"></td>
        <td id="LC1709">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1710" data-line-number="1710"></td>
        <td id="LC1710">
</td>
      </tr>
      <tr>
        <td id="L1711" data-line-number="1711"></td>
        <td id="LC1711">
</td>
      </tr>
      <tr>
        <td id="L1712" data-line-number="1712"></td>
        <td id="LC1712">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L1713" data-line-number="1713"></td>
        <td id="LC1713">    {</td>
      </tr>
      <tr>
        <td id="L1714" data-line-number="1714"></td>
        <td id="LC1714">        m_processMutex.<span>Init</span>(<span><span>"</span>Process Lock<span>"</span></span>, RSLock::cLockReentrant, RSLock::LL_PROCESS_LOCK);</td>
      </tr>
      <tr>
        <td id="L1715" data-line-number="1715"></td>
        <td id="LC1715">        m_StopGoLock.<span>Init</span>(<span><span>"</span>Stop-Go Lock<span>"</span></span>, RSLock::cLockReentrant, RSLock::LL_STOP_GO_LOCK);</td>
      </tr>
      <tr>
        <td id="L1716" data-line-number="1716"></td>
        <td id="LC1716">
</td>
      </tr>
      <tr>
        <td id="L1717" data-line-number="1717"></td>
        <td id="LC1717">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L1718" data-line-number="1718"></td>
        <td id="LC1718">        m_appDomains.<span>DebugSetRSLock</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1719" data-line-number="1719"></td>
        <td id="LC1719">        m_userThreads.<span>DebugSetRSLock</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1720" data-line-number="1720"></td>
        <td id="LC1720">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L1721" data-line-number="1721"></td>
        <td id="LC1721">        m_unmanagedThreads.<span>DebugSetRSLock</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1722" data-line-number="1722"></td>
        <td id="LC1722">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1723" data-line-number="1723"></td>
        <td id="LC1723">        m_steppers.<span>DebugSetRSLock</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1724" data-line-number="1724"></td>
        <td id="LC1724">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1725" data-line-number="1725"></td>
        <td id="LC1725">
</td>
      </tr>
      <tr>
        <td id="L1726" data-line-number="1726"></td>
        <td id="LC1726">        <span><span>//</span> See if the data target is mutable, and cache the mutable interface if it is</span></td>
      </tr>
      <tr>
        <td id="L1727" data-line-number="1727"></td>
        <td id="LC1727">        <span><span>//</span> We must initialize this before we try to use the data target to access the memory in the target process.</span></td>
      </tr>
      <tr>
        <td id="L1728" data-line-number="1728"></td>
        <td id="LC1728">        m_pMutableDataTarget.<span>Clear</span>();            <span><span>//</span> if we were called already, release</span></td>
      </tr>
      <tr>
        <td id="L1729" data-line-number="1729"></td>
        <td id="LC1729">        hr = m_pDACDataTarget-&gt;<span>QueryInterface</span>(IID_ICorDebugMutableDataTarget, (<span>void</span>**)&amp;m_pMutableDataTarget);</td>
      </tr>
      <tr>
        <td id="L1730" data-line-number="1730"></td>
        <td id="LC1730">        <span>if</span> (!<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L1731" data-line-number="1731"></td>
        <td id="LC1731">        {</td>
      </tr>
      <tr>
        <td id="L1732" data-line-number="1732"></td>
        <td id="LC1732">            <span><span>//</span> The data target doesn't support mutation.  We'll fail any requests that require mutation.</span></td>
      </tr>
      <tr>
        <td id="L1733" data-line-number="1733"></td>
        <td id="LC1733">            m_pMutableDataTarget.<span>Assign</span>(<span>new</span> <span>ReadOnlyDataTargetFacade</span>());</td>
      </tr>
      <tr>
        <td id="L1734" data-line-number="1734"></td>
        <td id="LC1734">        }</td>
      </tr>
      <tr>
        <td id="L1735" data-line-number="1735"></td>
        <td id="LC1735">
</td>
      </tr>
      <tr>
        <td id="L1736" data-line-number="1736"></td>
        <td id="LC1736">        m_pMetaDataLocator.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L1737" data-line-number="1737"></td>
        <td id="LC1737">        hr = m_pDACDataTarget-&gt;<span>QueryInterface</span>(IID_ICorDebugMetaDataLocator, <span>reinterpret_cast</span>&lt;<span>void</span> **&gt;(&amp;m_pMetaDataLocator));</td>
      </tr>
      <tr>
        <td id="L1738" data-line-number="1738"></td>
        <td id="LC1738">
</td>
      </tr>
      <tr>
        <td id="L1739" data-line-number="1739"></td>
        <td id="LC1739">        <span><span>//</span> Get the metadata dispenser.</span></td>
      </tr>
      <tr>
        <td id="L1740" data-line-number="1740"></td>
        <td id="LC1740">        hr = <span>InternalCreateMetaDataDispenser</span>(IID_IMetaDataDispenserEx, (<span>void</span> **)&amp;m_pMetaDispenser);</td>
      </tr>
      <tr>
        <td id="L1741" data-line-number="1741"></td>
        <td id="LC1741">
</td>
      </tr>
      <tr>
        <td id="L1742" data-line-number="1742"></td>
        <td id="LC1742">        <span><span>//</span> We statically link in the dispenser. We expect it to succeed, except for OOM, which</span></td>
      </tr>
      <tr>
        <td id="L1743" data-line-number="1743"></td>
        <td id="LC1743">        <span><span>//</span> debugger doesn't yet handle.</span></td>
      </tr>
      <tr>
        <td id="L1744" data-line-number="1744"></td>
        <td id="LC1744">        <span>SIMPLIFYING_ASSUMPTION_SUCCEEDED</span>(hr);</td>
      </tr>
      <tr>
        <td id="L1745" data-line-number="1745"></td>
        <td id="LC1745">        <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L1746" data-line-number="1746"></td>
        <td id="LC1746">
</td>
      </tr>
      <tr>
        <td id="L1747" data-line-number="1747"></td>
        <td id="LC1747">        <span>_ASSERTE</span>(m_pMetaDispenser != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1748" data-line-number="1748"></td>
        <td id="LC1748">
</td>
      </tr>
      <tr>
        <td id="L1749" data-line-number="1749"></td>
        <td id="LC1749">        <span><span>//</span> In order to allow users to call the metadata reader from multiple threads we need to set</span></td>
      </tr>
      <tr>
        <td id="L1750" data-line-number="1750"></td>
        <td id="LC1750">        <span><span>//</span> a flag on the dispenser to create threadsafe readers. This is done best-effort but</span></td>
      </tr>
      <tr>
        <td id="L1751" data-line-number="1751"></td>
        <td id="LC1751">        <span><span>//</span> really shouldn't ever fail. See issue 696511.</span></td>
      </tr>
      <tr>
        <td id="L1752" data-line-number="1752"></td>
        <td id="LC1752">        VARIANT optionValue;</td>
      </tr>
      <tr>
        <td id="L1753" data-line-number="1753"></td>
        <td id="LC1753">        <span>VariantInit</span>(&amp;optionValue);</td>
      </tr>
      <tr>
        <td id="L1754" data-line-number="1754"></td>
        <td id="LC1754">        <span>V_VT</span>(&amp;optionValue) = VT_UI4;</td>
      </tr>
      <tr>
        <td id="L1755" data-line-number="1755"></td>
        <td id="LC1755">        <span>V_UI4</span>(&amp;optionValue) = MDThreadSafetyOn;</td>
      </tr>
      <tr>
        <td id="L1756" data-line-number="1756"></td>
        <td id="LC1756">        m_pMetaDispenser-&gt;<span>SetOption</span>(MetaDataThreadSafetyOptions, &amp;optionValue);</td>
      </tr>
      <tr>
        <td id="L1757" data-line-number="1757"></td>
        <td id="LC1757">
</td>
      </tr>
      <tr>
        <td id="L1758" data-line-number="1758"></td>
        <td id="LC1758">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1759" data-line-number="1759"></td>
        <td id="LC1759">        <span><span>//</span> Setup internal events.</span></td>
      </tr>
      <tr>
        <td id="L1760" data-line-number="1760"></td>
        <td id="LC1760">        <span><span>//</span> @dbgtodo shim: these events should eventually be in the shim.</span></td>
      </tr>
      <tr>
        <td id="L1761" data-line-number="1761"></td>
        <td id="LC1761">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1762" data-line-number="1762"></td>
        <td id="LC1762">
</td>
      </tr>
      <tr>
        <td id="L1763" data-line-number="1763"></td>
        <td id="LC1763">
</td>
      </tr>
      <tr>
        <td id="L1764" data-line-number="1764"></td>
        <td id="LC1764">        <span><span>//</span> Managed debugging is built on the native-pipeline, and that will detect against double-attaches.</span></td>
      </tr>
      <tr>
        <td id="L1765" data-line-number="1765"></td>
        <td id="LC1765">
</td>
      </tr>
      <tr>
        <td id="L1766" data-line-number="1766"></td>
        <td id="LC1766">        <span><span>//</span> @dbgtodo shim: In V2, LSEA + LSER were used by the LS's helper thread. Now with the V3 pipeline,</span></td>
      </tr>
      <tr>
        <td id="L1767" data-line-number="1767"></td>
        <td id="LC1767">        <span><span>//</span> that helper-thread uses native-debug events. The W32ET gets those events and then uses LSEA, LSER to</span></td>
      </tr>
      <tr>
        <td id="L1768" data-line-number="1768"></td>
        <td id="LC1768">        <span><span>//</span> signal existing RS infrastructure. Eventually get rid of LSEA, LSER completely.</span></td>
      </tr>
      <tr>
        <td id="L1769" data-line-number="1769"></td>
        <td id="LC1769">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1770" data-line-number="1770"></td>
        <td id="LC1770">
</td>
      </tr>
      <tr>
        <td id="L1771" data-line-number="1771"></td>
        <td id="LC1771">        m_leftSideEventAvailable = <span>WszCreateEvent</span>(<span>NULL</span>, <span>FALSE</span>, <span>FALSE</span>, <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1772" data-line-number="1772"></td>
        <td id="LC1772">        <span>if</span> (m_leftSideEventAvailable == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1773" data-line-number="1773"></td>
        <td id="LC1773">        {</td>
      </tr>
      <tr>
        <td id="L1774" data-line-number="1774"></td>
        <td id="LC1774">            <span>ThrowLastError</span>();</td>
      </tr>
      <tr>
        <td id="L1775" data-line-number="1775"></td>
        <td id="LC1775">        }</td>
      </tr>
      <tr>
        <td id="L1776" data-line-number="1776"></td>
        <td id="LC1776">
</td>
      </tr>
      <tr>
        <td id="L1777" data-line-number="1777"></td>
        <td id="LC1777">        m_leftSideEventRead = <span>WszCreateEvent</span>(<span>NULL</span>, <span>FALSE</span>, <span>FALSE</span>, <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1778" data-line-number="1778"></td>
        <td id="LC1778">        <span>if</span> (m_leftSideEventRead == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1779" data-line-number="1779"></td>
        <td id="LC1779">        {</td>
      </tr>
      <tr>
        <td id="L1780" data-line-number="1780"></td>
        <td id="LC1780">            <span>ThrowLastError</span>();</td>
      </tr>
      <tr>
        <td id="L1781" data-line-number="1781"></td>
        <td id="LC1781">        }</td>
      </tr>
      <tr>
        <td id="L1782" data-line-number="1782"></td>
        <td id="LC1782">
</td>
      </tr>
      <tr>
        <td id="L1783" data-line-number="1783"></td>
        <td id="LC1783">        m_stopWaitEvent = <span>WszCreateEvent</span>(<span>NULL</span>, <span>TRUE</span>, <span>FALSE</span>, <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1784" data-line-number="1784"></td>
        <td id="LC1784">        <span>if</span> (m_stopWaitEvent == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1785" data-line-number="1785"></td>
        <td id="LC1785">        {</td>
      </tr>
      <tr>
        <td id="L1786" data-line-number="1786"></td>
        <td id="LC1786">            <span>ThrowLastError</span>();</td>
      </tr>
      <tr>
        <td id="L1787" data-line-number="1787"></td>
        <td id="LC1787">        }</td>
      </tr>
      <tr>
        <td id="L1788" data-line-number="1788"></td>
        <td id="LC1788">
</td>
      </tr>
      <tr>
        <td id="L1789" data-line-number="1789"></td>
        <td id="LC1789">        <span>if</span> (m_pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1790" data-line-number="1790"></td>
        <td id="LC1790">        {</td>
      </tr>
      <tr>
        <td id="L1791" data-line-number="1791"></td>
        <td id="LC1791">            <span><span>//</span> Get a handle to the debuggee.</span></td>
      </tr>
      <tr>
        <td id="L1792" data-line-number="1792"></td>
        <td id="LC1792">            <span><span>//</span> This is not needed in the V3 pipeline because we don't assume we have a live, local, process.</span></td>
      </tr>
      <tr>
        <td id="L1793" data-line-number="1793"></td>
        <td id="LC1793">            m_handle = <span>GetShim</span>()-&gt;<span>GetNativePipeline</span>()-&gt;<span>GetProcessHandle</span>();</td>
      </tr>
      <tr>
        <td id="L1794" data-line-number="1794"></td>
        <td id="LC1794">
</td>
      </tr>
      <tr>
        <td id="L1795" data-line-number="1795"></td>
        <td id="LC1795">            <span>if</span> (m_handle == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1796" data-line-number="1796"></td>
        <td id="LC1796">            {</td>
      </tr>
      <tr>
        <td id="L1797" data-line-number="1797"></td>
        <td id="LC1797">                <span>ThrowLastError</span>();</td>
      </tr>
      <tr>
        <td id="L1798" data-line-number="1798"></td>
        <td id="LC1798">            }</td>
      </tr>
      <tr>
        <td id="L1799" data-line-number="1799"></td>
        <td id="LC1799">        }</td>
      </tr>
      <tr>
        <td id="L1800" data-line-number="1800"></td>
        <td id="LC1800">
</td>
      </tr>
      <tr>
        <td id="L1801" data-line-number="1801"></td>
        <td id="LC1801">        <span><span>//</span> The LS startup goes through the following phases:</span></td>
      </tr>
      <tr>
        <td id="L1802" data-line-number="1802"></td>
        <td id="LC1802">        <span><span>//</span> 1) mscorwks not yet loaded (eg, any unmanaged app)</span></td>
      </tr>
      <tr>
        <td id="L1803" data-line-number="1803"></td>
        <td id="LC1803">        <span><span>//</span> 2) mscorwks loaded (DAC can now be used)</span></td>
      </tr>
      <tr>
        <td id="L1804" data-line-number="1804"></td>
        <td id="LC1804">        <span><span>//</span> 3) IPC Block created at OS level</span></td>
      </tr>
      <tr>
        <td id="L1805" data-line-number="1805"></td>
        <td id="LC1805">        <span><span>//</span> 4) IPC block data initialized (so we can read meainingful data from it)</span></td>
      </tr>
      <tr>
        <td id="L1806" data-line-number="1806"></td>
        <td id="LC1806">        <span><span>//</span> 5) LS marks that it's initialized (queryable by a DAC primitive) (may not be atomic)</span></td>
      </tr>
      <tr>
        <td id="L1807" data-line-number="1807"></td>
        <td id="LC1807">        <span><span>//</span> 6) LS fires a "Startup" exception (sniffed by WFDE).</span></td>
      </tr>
      <tr>
        <td id="L1808" data-line-number="1808"></td>
        <td id="LC1808">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1809" data-line-number="1809"></td>
        <td id="LC1809">        <span><span>//</span> LS is currently stopped by OS debugging, so it's doesn't shift phases.</span></td>
      </tr>
      <tr>
        <td id="L1810" data-line-number="1810"></td>
        <td id="LC1810">        <span><span>//</span> From the RS's perspective:</span></td>
      </tr>
      <tr>
        <td id="L1811" data-line-number="1811"></td>
        <td id="LC1811">        <span><span>//</span> - after phase 5 is an attach</span></td>
      </tr>
      <tr>
        <td id="L1812" data-line-number="1812"></td>
        <td id="LC1812">        <span><span>//</span> - before phase 6 is a launch.</span></td>
      </tr>
      <tr>
        <td id="L1813" data-line-number="1813"></td>
        <td id="LC1813">        <span><span>//</span> This means there's an overlap: if we catch it at phase 5, we'll just get</span></td>
      </tr>
      <tr>
        <td id="L1814" data-line-number="1814"></td>
        <td id="LC1814">        <span><span>//</span> an extra Startup exception from phase 6, which is safe. This overlap is good</span></td>
      </tr>
      <tr>
        <td id="L1815" data-line-number="1815"></td>
        <td id="LC1815">        <span><span>//</span> because it means there's no bad window to do an attach in.</span></td>
      </tr>
      <tr>
        <td id="L1816" data-line-number="1816"></td>
        <td id="LC1816">
</td>
      </tr>
      <tr>
        <td id="L1817" data-line-number="1817"></td>
        <td id="LC1817">        <span><span>//</span> fIsLSStarted means before phase 6 (eg, RS should expect a startup exception)</span></td>
      </tr>
      <tr>
        <td id="L1818" data-line-number="1818"></td>
        <td id="LC1818">
</td>
      </tr>
      <tr>
        <td id="L1819" data-line-number="1819"></td>
        <td id="LC1819">        <span><span>//</span> Determines if the LS is started.</span></td>
      </tr>
      <tr>
        <td id="L1820" data-line-number="1820"></td>
        <td id="LC1820">
</td>
      </tr>
      <tr>
        <td id="L1821" data-line-number="1821"></td>
        <td id="LC1821">        {</td>
      </tr>
      <tr>
        <td id="L1822" data-line-number="1822"></td>
        <td id="LC1822">            BOOL <span>fReady</span> = <span>TryInitializeDac</span>();</td>
      </tr>
      <tr>
        <td id="L1823" data-line-number="1823"></td>
        <td id="LC1823">
</td>
      </tr>
      <tr>
        <td id="L1824" data-line-number="1824"></td>
        <td id="LC1824">            <span>if</span> (<span>fReady</span>)</td>
      </tr>
      <tr>
        <td id="L1825" data-line-number="1825"></td>
        <td id="LC1825">            {</td>
      </tr>
      <tr>
        <td id="L1826" data-line-number="1826"></td>
        <td id="LC1826">                <span><span>//</span> Invoke DAC primitive.</span></td>
      </tr>
      <tr>
        <td id="L1827" data-line-number="1827"></td>
        <td id="LC1827">                <span>_ASSERTE</span>(m_pDacPrimitives != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1828" data-line-number="1828"></td>
        <td id="LC1828">                <span>fIsLSStarted</span> = m_pDacPrimitives-&gt;<span>IsLeftSideInitialized</span>();</td>
      </tr>
      <tr>
        <td id="L1829" data-line-number="1829"></td>
        <td id="LC1829">            }</td>
      </tr>
      <tr>
        <td id="L1830" data-line-number="1830"></td>
        <td id="LC1830">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L1831" data-line-number="1831"></td>
        <td id="LC1831">            {</td>
      </tr>
      <tr>
        <td id="L1832" data-line-number="1832"></td>
        <td id="LC1832">                <span>_ASSERTE</span>(m_pDacPrimitives == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1833" data-line-number="1833"></td>
        <td id="LC1833">
</td>
      </tr>
      <tr>
        <td id="L1834" data-line-number="1834"></td>
        <td id="LC1834">                <span><span>//</span> DAC is not yet loaded, so we're at least before phase 2, which is before phase 6.</span></td>
      </tr>
      <tr>
        <td id="L1835" data-line-number="1835"></td>
        <td id="LC1835">                <span><span>//</span> So leave fIsLSStarted = false. We'll get a startup exception later.</span></td>
      </tr>
      <tr>
        <td id="L1836" data-line-number="1836"></td>
        <td id="LC1836">                <span>_ASSERTE</span>(!<span>fIsLSStarted</span>);</td>
      </tr>
      <tr>
        <td id="L1837" data-line-number="1837"></td>
        <td id="LC1837">            }</td>
      </tr>
      <tr>
        <td id="L1838" data-line-number="1838"></td>
        <td id="LC1838">        }</td>
      </tr>
      <tr>
        <td id="L1839" data-line-number="1839"></td>
        <td id="LC1839">
</td>
      </tr>
      <tr>
        <td id="L1840" data-line-number="1840"></td>
        <td id="LC1840">
</td>
      </tr>
      <tr>
        <td id="L1841" data-line-number="1841"></td>
        <td id="LC1841">        <span>if</span> (<span>fIsLSStarted</span>)</td>
      </tr>
      <tr>
        <td id="L1842" data-line-number="1842"></td>
        <td id="LC1842">        {</td>
      </tr>
      <tr>
        <td id="L1843" data-line-number="1843"></td>
        <td id="LC1843">            <span><span>//</span> Left-side has started up. This is common for Attach cases when managed-code is already running.</span></td>
      </tr>
      <tr>
        <td id="L1844" data-line-number="1844"></td>
        <td id="LC1844">
</td>
      </tr>
      <tr>
        <td id="L1845" data-line-number="1845"></td>
        <td id="LC1845">            <span>if</span> (m_pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1846" data-line-number="1846"></td>
        <td id="LC1846">            {</td>
      </tr>
      <tr>
        <td id="L1847" data-line-number="1847"></td>
        <td id="LC1847">                <span>FinishInitializeIPCChannelWorker</span>(); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L1848" data-line-number="1848"></td>
        <td id="LC1848">
</td>
      </tr>
      <tr>
        <td id="L1849" data-line-number="1849"></td>
        <td id="LC1849">                <span><span>//</span> At this point, the control block is complete and all four</span></td>
      </tr>
      <tr>
        <td id="L1850" data-line-number="1850"></td>
        <td id="LC1850">                <span><span>//</span> events are available and valid for the remote process.</span></td>
      </tr>
      <tr>
        <td id="L1851" data-line-number="1851"></td>
        <td id="LC1851">
</td>
      </tr>
      <tr>
        <td id="L1852" data-line-number="1852"></td>
        <td id="LC1852">                <span><span>//</span> Request that the process object send an Attach IPC event.</span></td>
      </tr>
      <tr>
        <td id="L1853" data-line-number="1853"></td>
        <td id="LC1853">                <span><span>//</span> This is only used in an attach case.</span></td>
      </tr>
      <tr>
        <td id="L1854" data-line-number="1854"></td>
        <td id="LC1854">                <span><span>//</span> @dbgtodo sync: this flag can go away once the</span></td>
      </tr>
      <tr>
        <td id="L1855" data-line-number="1855"></td>
        <td id="LC1855">                <span><span>//</span> shim can use real sync APIs.</span></td>
      </tr>
      <tr>
        <td id="L1856" data-line-number="1856"></td>
        <td id="LC1856">                m_fDoDelayedManagedAttached = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1857" data-line-number="1857"></td>
        <td id="LC1857">            }</td>
      </tr>
      <tr>
        <td id="L1858" data-line-number="1858"></td>
        <td id="LC1858">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L1859" data-line-number="1859"></td>
        <td id="LC1859">            {</td>
      </tr>
      <tr>
        <td id="L1860" data-line-number="1860"></td>
        <td id="LC1860">                <span><span>//</span> In the V3 pipeline case, if we have the DD-interface, then the runtime is loaded</span></td>
      </tr>
      <tr>
        <td id="L1861" data-line-number="1861"></td>
        <td id="LC1861">                <span><span>//</span> and we consider it initialized.</span></td>
      </tr>
      <tr>
        <td id="L1862" data-line-number="1862"></td>
        <td id="LC1862">                <span>if</span> (<span>IsDacInitialized</span>())</td>
      </tr>
      <tr>
        <td id="L1863" data-line-number="1863"></td>
        <td id="LC1863">                {</td>
      </tr>
      <tr>
        <td id="L1864" data-line-number="1864"></td>
        <td id="LC1864">                    m_initialized = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1865" data-line-number="1865"></td>
        <td id="LC1865">                }</td>
      </tr>
      <tr>
        <td id="L1866" data-line-number="1866"></td>
        <td id="LC1866">            }</td>
      </tr>
      <tr>
        <td id="L1867" data-line-number="1867"></td>
        <td id="LC1867">        }</td>
      </tr>
      <tr>
        <td id="L1868" data-line-number="1868"></td>
        <td id="LC1868">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L1869" data-line-number="1869"></td>
        <td id="LC1869">        {</td>
      </tr>
      <tr>
        <td id="L1870" data-line-number="1870"></td>
        <td id="LC1870">            <span><span>//</span> LS is not started yet. This would be common for "Launch" cases.</span></td>
      </tr>
      <tr>
        <td id="L1871" data-line-number="1871"></td>
        <td id="LC1871">            <span><span>//</span> We will get a Startup Exception notification when it does start.</span></td>
      </tr>
      <tr>
        <td id="L1872" data-line-number="1872"></td>
        <td id="LC1872">        }</td>
      </tr>
      <tr>
        <td id="L1873" data-line-number="1873"></td>
        <td id="LC1873">    }</td>
      </tr>
      <tr>
        <td id="L1874" data-line-number="1874"></td>
        <td id="LC1874">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L1875" data-line-number="1875"></td>
        <td id="LC1875">
</td>
      </tr>
      <tr>
        <td id="L1876" data-line-number="1876"></td>
        <td id="LC1876">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L1877" data-line-number="1877"></td>
        <td id="LC1877">    {</td>
      </tr>
      <tr>
        <td id="L1878" data-line-number="1878"></td>
        <td id="LC1878">        <span>CleanupHalfBakedLeftSide</span>();</td>
      </tr>
      <tr>
        <td id="L1879" data-line-number="1879"></td>
        <td id="LC1879">    }</td>
      </tr>
      <tr>
        <td id="L1880" data-line-number="1880"></td>
        <td id="LC1880">
</td>
      </tr>
      <tr>
        <td id="L1881" data-line-number="1881"></td>
        <td id="LC1881">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L1882" data-line-number="1882"></td>
        <td id="LC1882">}</td>
      </tr>
      <tr>
        <td id="L1883" data-line-number="1883"></td>
        <td id="LC1883">
</td>
      </tr>
      <tr>
        <td id="L1884" data-line-number="1884"></td>
        <td id="LC1884">
</td>
      </tr>
      <tr>
        <td id="L1885" data-line-number="1885"></td>
        <td id="LC1885">COM_METHOD <span>CordbProcess::CanCommitChanges</span>(ULONG cSnapshots,</td>
      </tr>
      <tr>
        <td id="L1886" data-line-number="1886"></td>
        <td id="LC1886">                ICorDebugEditAndContinueSnapshot *pSnapshots[],</td>
      </tr>
      <tr>
        <td id="L1887" data-line-number="1887"></td>
        <td id="LC1887">                ICorDebugErrorInfoEnum **pError)</td>
      </tr>
      <tr>
        <td id="L1888" data-line-number="1888"></td>
        <td id="LC1888">{</td>
      </tr>
      <tr>
        <td id="L1889" data-line-number="1889"></td>
        <td id="LC1889">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L1890" data-line-number="1890"></td>
        <td id="LC1890">}</td>
      </tr>
      <tr>
        <td id="L1891" data-line-number="1891"></td>
        <td id="LC1891">
</td>
      </tr>
      <tr>
        <td id="L1892" data-line-number="1892"></td>
        <td id="LC1892">COM_METHOD <span>CordbProcess::CommitChanges</span>(ULONG cSnapshots,</td>
      </tr>
      <tr>
        <td id="L1893" data-line-number="1893"></td>
        <td id="LC1893">    ICorDebugEditAndContinueSnapshot *pSnapshots[],</td>
      </tr>
      <tr>
        <td id="L1894" data-line-number="1894"></td>
        <td id="LC1894">    ICorDebugErrorInfoEnum **pError)</td>
      </tr>
      <tr>
        <td id="L1895" data-line-number="1895"></td>
        <td id="LC1895">{</td>
      </tr>
      <tr>
        <td id="L1896" data-line-number="1896"></td>
        <td id="LC1896">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L1897" data-line-number="1897"></td>
        <td id="LC1897">}</td>
      </tr>
      <tr>
        <td id="L1898" data-line-number="1898"></td>
        <td id="LC1898">
</td>
      </tr>
      <tr>
        <td id="L1899" data-line-number="1899"></td>
        <td id="LC1899">
</td>
      </tr>
      <tr>
        <td id="L1900" data-line-number="1900"></td>
        <td id="LC1900"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1901" data-line-number="1901"></td>
        <td id="LC1901"><span><span>//</span> Terminating -- places the process into the terminated state. This should</span></td>
      </tr>
      <tr>
        <td id="L1902" data-line-number="1902"></td>
        <td id="LC1902"><span><span>//</span> also get any blocking process functions unblocked so they'll return</span></td>
      </tr>
      <tr>
        <td id="L1903" data-line-number="1903"></td>
        <td id="LC1903"><span><span>//</span> a failure code.</span></td>
      </tr>
      <tr>
        <td id="L1904" data-line-number="1904"></td>
        <td id="LC1904"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1905" data-line-number="1905"></td>
        <td id="LC1905"><span>void</span> <span>CordbProcess::Terminating</span>(BOOL <span>fDetach</span>)</td>
      </tr>
      <tr>
        <td id="L1906" data-line-number="1906"></td>
        <td id="LC1906">{</td>
      </tr>
      <tr>
        <td id="L1907" data-line-number="1907"></td>
        <td id="LC1907">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1908" data-line-number="1908"></td>
        <td id="LC1908">
</td>
      </tr>
      <tr>
        <td id="L1909" data-line-number="1909"></td>
        <td id="LC1909">    <span>LOG</span>((LF_CORDB, LL_INFO1000,<span><span>"</span>CP::T: Terminating process 0x%x detach=%d<span>\n</span><span>"</span></span>, m_id, <span>fDetach</span>));</td>
      </tr>
      <tr>
        <td id="L1910" data-line-number="1910"></td>
        <td id="LC1910">    m_terminated = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1911" data-line-number="1911"></td>
        <td id="LC1911">
</td>
      </tr>
      <tr>
        <td id="L1912" data-line-number="1912"></td>
        <td id="LC1912">    m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L1913" data-line-number="1913"></td>
        <td id="LC1913">
</td>
      </tr>
      <tr>
        <td id="L1914" data-line-number="1914"></td>
        <td id="LC1914">    <span><span>//</span> Set events that may be blocking stuff.</span></td>
      </tr>
      <tr>
        <td id="L1915" data-line-number="1915"></td>
        <td id="LC1915">    <span><span>//</span> But don't set RSER unless we actually read the event. We don't block on RSER</span></td>
      </tr>
      <tr>
        <td id="L1916" data-line-number="1916"></td>
        <td id="LC1916">    <span><span>//</span> since that wait also checks the leftside's process handle.</span></td>
      </tr>
      <tr>
        <td id="L1917" data-line-number="1917"></td>
        <td id="LC1917">    <span>SetEvent</span>(m_leftSideEventRead);</td>
      </tr>
      <tr>
        <td id="L1918" data-line-number="1918"></td>
        <td id="LC1918">    <span>SetEvent</span>(m_leftSideEventAvailable);</td>
      </tr>
      <tr>
        <td id="L1919" data-line-number="1919"></td>
        <td id="LC1919">    <span>SetEvent</span>(m_stopWaitEvent);</td>
      </tr>
      <tr>
        <td id="L1920" data-line-number="1920"></td>
        <td id="LC1920">
</td>
      </tr>
      <tr>
        <td id="L1921" data-line-number="1921"></td>
        <td id="LC1921">    <span>if</span> (m_pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1922" data-line-number="1922"></td>
        <td id="LC1922">        m_pShim-&gt;<span>SetTerminatingEvent</span>();</td>
      </tr>
      <tr>
        <td id="L1923" data-line-number="1923"></td>
        <td id="LC1923">
</td>
      </tr>
      <tr>
        <td id="L1924" data-line-number="1924"></td>
        <td id="LC1924">    <span>if</span> (<span>fDetach</span> &amp;&amp; (m_pEventChannel != <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L1925" data-line-number="1925"></td>
        <td id="LC1925">    {</td>
      </tr>
      <tr>
        <td id="L1926" data-line-number="1926"></td>
        <td id="LC1926">        m_pEventChannel-&gt;<span>Detach</span>();</td>
      </tr>
      <tr>
        <td id="L1927" data-line-number="1927"></td>
        <td id="LC1927">    }</td>
      </tr>
      <tr>
        <td id="L1928" data-line-number="1928"></td>
        <td id="LC1928">}</td>
      </tr>
      <tr>
        <td id="L1929" data-line-number="1929"></td>
        <td id="LC1929">
</td>
      </tr>
      <tr>
        <td id="L1930" data-line-number="1930"></td>
        <td id="LC1930">
</td>
      </tr>
      <tr>
        <td id="L1931" data-line-number="1931"></td>
        <td id="LC1931"><span><span>//</span> Wrapper to give shim access to code:CordbProcess::QueueManagedAttachIfNeededWorker</span></td>
      </tr>
      <tr>
        <td id="L1932" data-line-number="1932"></td>
        <td id="LC1932"><span>void</span> <span>CordbProcess::QueueManagedAttachIfNeeded</span>()</td>
      </tr>
      <tr>
        <td id="L1933" data-line-number="1933"></td>
        <td id="LC1933">{</td>
      </tr>
      <tr>
        <td id="L1934" data-line-number="1934"></td>
        <td id="LC1934">    <span>PUBLIC_API_ENTRY_FOR_SHIM</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1935" data-line-number="1935"></td>
        <td id="LC1935">    <span>QueueManagedAttachIfNeededWorker</span>();</td>
      </tr>
      <tr>
        <td id="L1936" data-line-number="1936"></td>
        <td id="LC1936">}</td>
      </tr>
      <tr>
        <td id="L1937" data-line-number="1937"></td>
        <td id="LC1937">
</td>
      </tr>
      <tr>
        <td id="L1938" data-line-number="1938"></td>
        <td id="LC1938"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1939" data-line-number="1939"></td>
        <td id="LC1939"><span><span>//</span> Hook from Shim to request a managed attach IPC event</span></td>
      </tr>
      <tr>
        <td id="L1940" data-line-number="1940"></td>
        <td id="LC1940"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1941" data-line-number="1941"></td>
        <td id="LC1941"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1942" data-line-number="1942"></td>
        <td id="LC1942"><span><span>//</span>   Called by shim after the loader-breakpoint is handled.</span></td>
      </tr>
      <tr>
        <td id="L1943" data-line-number="1943"></td>
        <td id="LC1943"><span><span>//</span>   @dbgtodo sync: ths should go away once the shim can initiate</span></td>
      </tr>
      <tr>
        <td id="L1944" data-line-number="1944"></td>
        <td id="LC1944"><span><span>//</span>   a sync</span></td>
      </tr>
      <tr>
        <td id="L1945" data-line-number="1945"></td>
        <td id="LC1945"><span>void</span> <span>CordbProcess::QueueManagedAttachIfNeededWorker</span>()</td>
      </tr>
      <tr>
        <td id="L1946" data-line-number="1946"></td>
        <td id="LC1946">{</td>
      </tr>
      <tr>
        <td id="L1947" data-line-number="1947"></td>
        <td id="LC1947">    HRESULT hrQueue = S_OK;</td>
      </tr>
      <tr>
        <td id="L1948" data-line-number="1948"></td>
        <td id="LC1948">
</td>
      </tr>
      <tr>
        <td id="L1949" data-line-number="1949"></td>
        <td id="LC1949">    <span><span>//</span> m_fDoDelayedManagedAttached ensures that we only send an Attach event if the LS is actually present.</span></td>
      </tr>
      <tr>
        <td id="L1950" data-line-number="1950"></td>
        <td id="LC1950">    <span>if</span> (m_fDoDelayedManagedAttached &amp;&amp; <span>GetShim</span>()-&gt;<span>GetAttached</span>())</td>
      </tr>
      <tr>
        <td id="L1951" data-line-number="1951"></td>
        <td id="LC1951">    {</td>
      </tr>
      <tr>
        <td id="L1952" data-line-number="1952"></td>
        <td id="LC1952">        RSLockHolder <span>lockHolder</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L1953" data-line-number="1953"></td>
        <td id="LC1953">        <span>GetDAC</span>()-&gt;<span>MarkDebuggerAttachPending</span>();</td>
      </tr>
      <tr>
        <td id="L1954" data-line-number="1954"></td>
        <td id="LC1954">
</td>
      </tr>
      <tr>
        <td id="L1955" data-line-number="1955"></td>
        <td id="LC1955">        hrQueue = <span>this</span>-&gt;<span>QueueManagedAttach</span>();</td>
      </tr>
      <tr>
        <td id="L1956" data-line-number="1956"></td>
        <td id="LC1956">    }</td>
      </tr>
      <tr>
        <td id="L1957" data-line-number="1957"></td>
        <td id="LC1957">
</td>
      </tr>
      <tr>
        <td id="L1958" data-line-number="1958"></td>
        <td id="LC1958">    <span>if</span> (m_pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1959" data-line-number="1959"></td>
        <td id="LC1959">        m_pShim-&gt;<span>SetMarkAttachPendingEvent</span>();</td>
      </tr>
      <tr>
        <td id="L1960" data-line-number="1960"></td>
        <td id="LC1960">
</td>
      </tr>
      <tr>
        <td id="L1961" data-line-number="1961"></td>
        <td id="LC1961">    <span>IfFailThrow</span>(hrQueue);</td>
      </tr>
      <tr>
        <td id="L1962" data-line-number="1962"></td>
        <td id="LC1962">}</td>
      </tr>
      <tr>
        <td id="L1963" data-line-number="1963"></td>
        <td id="LC1963">
</td>
      </tr>
      <tr>
        <td id="L1964" data-line-number="1964"></td>
        <td id="LC1964"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1965" data-line-number="1965"></td>
        <td id="LC1965"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1966" data-line-number="1966"></td>
        <td id="LC1966"><span><span>//</span> QueueManagedAttach</span></td>
      </tr>
      <tr>
        <td id="L1967" data-line-number="1967"></td>
        <td id="LC1967"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1968" data-line-number="1968"></td>
        <td id="LC1968"><span><span>//</span> Send a managed attach. This is asynchronous and will return immediately.</span></td>
      </tr>
      <tr>
        <td id="L1969" data-line-number="1969"></td>
        <td id="LC1969"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1970" data-line-number="1970"></td>
        <td id="LC1970"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L1971" data-line-number="1971"></td>
        <td id="LC1971"><span><span>//</span>    S_OK on success</span></td>
      </tr>
      <tr>
        <td id="L1972" data-line-number="1972"></td>
        <td id="LC1972"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1973" data-line-number="1973"></td>
        <td id="LC1973"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1974" data-line-number="1974"></td>
        <td id="LC1974">HRESULT <span>CordbProcess::QueueManagedAttach</span>()</td>
      </tr>
      <tr>
        <td id="L1975" data-line-number="1975"></td>
        <td id="LC1975">{</td>
      </tr>
      <tr>
        <td id="L1976" data-line-number="1976"></td>
        <td id="LC1976">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1977" data-line-number="1977"></td>
        <td id="LC1977">
</td>
      </tr>
      <tr>
        <td id="L1978" data-line-number="1978"></td>
        <td id="LC1978">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L1979" data-line-number="1979"></td>
        <td id="LC1979">
</td>
      </tr>
      <tr>
        <td id="L1980" data-line-number="1980"></td>
        <td id="LC1980">    <span>_ASSERTE</span>(m_fDoDelayedManagedAttached);</td>
      </tr>
      <tr>
        <td id="L1981" data-line-number="1981"></td>
        <td id="LC1981">    m_fDoDelayedManagedAttached = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1982" data-line-number="1982"></td>
        <td id="LC1982">
</td>
      </tr>
      <tr>
        <td id="L1983" data-line-number="1983"></td>
        <td id="LC1983">    <span>_ASSERTE</span>(<span>IsDacInitialized</span>());</td>
      </tr>
      <tr>
        <td id="L1984" data-line-number="1984"></td>
        <td id="LC1984">
</td>
      </tr>
      <tr>
        <td id="L1985" data-line-number="1985"></td>
        <td id="LC1985">    <span><span>//</span> We don't know what Queue it.</span></td>
      </tr>
      <tr>
        <td id="L1986" data-line-number="1986"></td>
        <td id="LC1986">    SendAttachProcessWorkItem * pItem = <span>new</span> (nothrow) <span>SendAttachProcessWorkItem</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L1987" data-line-number="1987"></td>
        <td id="LC1987">
</td>
      </tr>
      <tr>
        <td id="L1988" data-line-number="1988"></td>
        <td id="LC1988">    <span>if</span> (pItem == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L1989" data-line-number="1989"></td>
        <td id="LC1989">    {</td>
      </tr>
      <tr>
        <td id="L1990" data-line-number="1990"></td>
        <td id="LC1990">        <span>return</span> E_OUTOFMEMORY;</td>
      </tr>
      <tr>
        <td id="L1991" data-line-number="1991"></td>
        <td id="LC1991">    }</td>
      </tr>
      <tr>
        <td id="L1992" data-line-number="1992"></td>
        <td id="LC1992">
</td>
      </tr>
      <tr>
        <td id="L1993" data-line-number="1993"></td>
        <td id="LC1993">    <span>this</span>-&gt;<span>m_cordb</span>-&gt;<span>m_rcEventThread</span>-&gt;<span>QueueAsyncWorkItem</span>(pItem);</td>
      </tr>
      <tr>
        <td id="L1994" data-line-number="1994"></td>
        <td id="LC1994">
</td>
      </tr>
      <tr>
        <td id="L1995" data-line-number="1995"></td>
        <td id="LC1995">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L1996" data-line-number="1996"></td>
        <td id="LC1996">}</td>
      </tr>
      <tr>
        <td id="L1997" data-line-number="1997"></td>
        <td id="LC1997">
</td>
      </tr>
      <tr>
        <td id="L1998" data-line-number="1998"></td>
        <td id="LC1998"><span><span>//</span> However, we still want to synchronize.</span></td>
      </tr>
      <tr>
        <td id="L1999" data-line-number="1999"></td>
        <td id="LC1999"><span><span>//</span> @dbgtodo sync: when we hoist attaching, we can send an DB_IPCE_ASYNC_BREAK event instead or Attach</span></td>
      </tr>
      <tr>
        <td id="L2000" data-line-number="2000"></td>
        <td id="LC2000"><span><span>//</span> (for V2 semantics, we still need to synchronize the process)?</span></td>
      </tr>
      <tr>
        <td id="L2001" data-line-number="2001"></td>
        <td id="LC2001"><span>void</span> <span>SendAttachProcessWorkItem::Do</span>()</td>
      </tr>
      <tr>
        <td id="L2002" data-line-number="2002"></td>
        <td id="LC2002">{</td>
      </tr>
      <tr>
        <td id="L2003" data-line-number="2003"></td>
        <td id="LC2003">    HRESULT hr;</td>
      </tr>
      <tr>
        <td id="L2004" data-line-number="2004"></td>
        <td id="LC2004">
</td>
      </tr>
      <tr>
        <td id="L2005" data-line-number="2005"></td>
        <td id="LC2005">    <span><span>//</span> This is being processed on the RCET, where it's safe to take the Stop-Go lock.</span></td>
      </tr>
      <tr>
        <td id="L2006" data-line-number="2006"></td>
        <td id="LC2006">    RSLockHolder <span>ch</span>(<span>this</span>-&gt;<span>GetProcess</span>()-&gt;<span>GetStopGoLock</span>());</td>
      </tr>
      <tr>
        <td id="L2007" data-line-number="2007"></td>
        <td id="LC2007">
</td>
      </tr>
      <tr>
        <td id="L2008" data-line-number="2008"></td>
        <td id="LC2008">    DebuggerIPCEvent *event = (DebuggerIPCEvent*) <span>_alloca</span>(CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L2009" data-line-number="2009"></td>
        <td id="LC2009">
</td>
      </tr>
      <tr>
        <td id="L2010" data-line-number="2010"></td>
        <td id="LC2010">    <span><span>//</span> This just acts like an async-break, which will kick off things.</span></td>
      </tr>
      <tr>
        <td id="L2011" data-line-number="2011"></td>
        <td id="LC2011">    <span><span>//</span> This will not induce any faked attach events from the VM (like it did in V2).</span></td>
      </tr>
      <tr>
        <td id="L2012" data-line-number="2012"></td>
        <td id="LC2012">    <span><span>//</span> The Left-side will still slip foward allowing the async-break to happen, so</span></td>
      </tr>
      <tr>
        <td id="L2013" data-line-number="2013"></td>
        <td id="LC2013">    <span><span>//</span> we may get normal debug events in addition to the sync-complete.</span></td>
      </tr>
      <tr>
        <td id="L2014" data-line-number="2014"></td>
        <td id="LC2014">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2015" data-line-number="2015"></td>
        <td id="LC2015">    <span><span>//</span> 1. In the common attach case, we should just get a sync-complete.</span></td>
      </tr>
      <tr>
        <td id="L2016" data-line-number="2016"></td>
        <td id="LC2016">    <span><span>//</span> 2. In Jit-attach cases, the LS is sending an event, and so we'll get that event and then the sync-complete.</span></td>
      </tr>
      <tr>
        <td id="L2017" data-line-number="2017"></td>
        <td id="LC2017">    <span>GetProcess</span>()-&gt;<span>InitAsyncIPCEvent</span>(event, DB_IPCE_ATTACHING, <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L2018" data-line-number="2018"></td>
        <td id="LC2018">
</td>
      </tr>
      <tr>
        <td id="L2019" data-line-number="2019"></td>
        <td id="LC2019">    <span><span>//</span> This should result in a sync-complete from the Left-side, which will be raised as an exception</span></td>
      </tr>
      <tr>
        <td id="L2020" data-line-number="2020"></td>
        <td id="LC2020">    <span><span>//</span> that the debugger passes into Filter and then internally goes through code:CordbProcess::TriageSyncComplete</span></td>
      </tr>
      <tr>
        <td id="L2021" data-line-number="2021"></td>
        <td id="LC2021">    <span><span>//</span> and that triggers code:CordbRCEventThread::FlushQueuedEvents to be called on the RCET.</span></td>
      </tr>
      <tr>
        <td id="L2022" data-line-number="2022"></td>
        <td id="LC2022">    <span><span>//</span> We already pre-queued a fake CreateProcess event.</span></td>
      </tr>
      <tr>
        <td id="L2023" data-line-number="2023"></td>
        <td id="LC2023">
</td>
      </tr>
      <tr>
        <td id="L2024" data-line-number="2024"></td>
        <td id="LC2024">    <span><span>//</span> The left-side will also mark itself as attached in response to this event.</span></td>
      </tr>
      <tr>
        <td id="L2025" data-line-number="2025"></td>
        <td id="LC2025">    <span><span>//</span> We explicitly don't mark it as attached from the right-side because we want to let the left-side</span></td>
      </tr>
      <tr>
        <td id="L2026" data-line-number="2026"></td>
        <td id="LC2026">    <span><span>//</span> synchronize first (to stop all running threads) before marking the debugger as attached.</span></td>
      </tr>
      <tr>
        <td id="L2027" data-line-number="2027"></td>
        <td id="LC2027">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] CP::S: sending attach.<span>\n</span><span>"</span></span>, <span>GetCurrentThreadId</span>()));</td>
      </tr>
      <tr>
        <td id="L2028" data-line-number="2028"></td>
        <td id="LC2028">
</td>
      </tr>
      <tr>
        <td id="L2029" data-line-number="2029"></td>
        <td id="LC2029">    hr = <span>GetProcess</span>()-&gt;<span>SendIPCEvent</span>(event, CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L2030" data-line-number="2030"></td>
        <td id="LC2030">
</td>
      </tr>
      <tr>
        <td id="L2031" data-line-number="2031"></td>
        <td id="LC2031">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] CP::S: sent attach.<span>\n</span><span>"</span></span>, <span>GetCurrentThreadId</span>()));</td>
      </tr>
      <tr>
        <td id="L2032" data-line-number="2032"></td>
        <td id="LC2032">}</td>
      </tr>
      <tr>
        <td id="L2033" data-line-number="2033"></td>
        <td id="LC2033">
</td>
      </tr>
      <tr>
        <td id="L2034" data-line-number="2034"></td>
        <td id="LC2034"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2035" data-line-number="2035"></td>
        <td id="LC2035"><span><span>//</span> Try to lookup a cached thread object</span></td>
      </tr>
      <tr>
        <td id="L2036" data-line-number="2036"></td>
        <td id="LC2036"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2037" data-line-number="2037"></td>
        <td id="LC2037"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2038" data-line-number="2038"></td>
        <td id="LC2038"><span><span>//</span>     vmThread - vm identifier for thread.</span></td>
      </tr>
      <tr>
        <td id="L2039" data-line-number="2039"></td>
        <td id="LC2039"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2040" data-line-number="2040"></td>
        <td id="LC2040"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L2041" data-line-number="2041"></td>
        <td id="LC2041"><span><span>//</span>     Thread object if cached; null if not yet cached.</span></td>
      </tr>
      <tr>
        <td id="L2042" data-line-number="2042"></td>
        <td id="LC2042"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2043" data-line-number="2043"></td>
        <td id="LC2043"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2044" data-line-number="2044"></td>
        <td id="LC2044"><span><span>//</span>     This does not create the thread object if it's not cached. Caching is unpredictable,</span></td>
      </tr>
      <tr>
        <td id="L2045" data-line-number="2045"></td>
        <td id="LC2045"><span><span>//</span>     and so this may appear to randomly return NULL.</span></td>
      </tr>
      <tr>
        <td id="L2046" data-line-number="2046"></td>
        <td id="LC2046"><span><span>//</span>     Callers should prefer code:CordbProcess::LookupOrCreateThread unless they expicitly</span></td>
      </tr>
      <tr>
        <td id="L2047" data-line-number="2047"></td>
        <td id="LC2047"><span><span>//</span>     want to check RS state.</span></td>
      </tr>
      <tr>
        <td id="L2048" data-line-number="2048"></td>
        <td id="LC2048">CordbThread * <span>CordbProcess::TryLookupThread</span>(VMPTR_Thread vmThread)</td>
      </tr>
      <tr>
        <td id="L2049" data-line-number="2049"></td>
        <td id="LC2049">{</td>
      </tr>
      <tr>
        <td id="L2050" data-line-number="2050"></td>
        <td id="LC2050">    <span>return</span> m_userThreads.<span>GetBase</span>(<span>VmPtrToCookie</span>(vmThread));</td>
      </tr>
      <tr>
        <td id="L2051" data-line-number="2051"></td>
        <td id="LC2051">}</td>
      </tr>
      <tr>
        <td id="L2052" data-line-number="2052"></td>
        <td id="LC2052">
</td>
      </tr>
      <tr>
        <td id="L2053" data-line-number="2053"></td>
        <td id="LC2053"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2054" data-line-number="2054"></td>
        <td id="LC2054"><span><span>//</span> Lookup (or create) a CordbThread object by the given volatile OS id. Returns null if not a manged thread</span></td>
      </tr>
      <tr>
        <td id="L2055" data-line-number="2055"></td>
        <td id="LC2055"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2056" data-line-number="2056"></td>
        <td id="LC2056"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2057" data-line-number="2057"></td>
        <td id="LC2057"><span><span>//</span>      dwThreadId - os thread id that a managed thread may be using.</span></td>
      </tr>
      <tr>
        <td id="L2058" data-line-number="2058"></td>
        <td id="LC2058"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2059" data-line-number="2059"></td>
        <td id="LC2059"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L2060" data-line-number="2060"></td>
        <td id="LC2060"><span><span>//</span>      Thread instance if there is currently a managed thread scheduled to run on dwThreadId.</span></td>
      </tr>
      <tr>
        <td id="L2061" data-line-number="2061"></td>
        <td id="LC2061"><span><span>//</span>      NULL if this tid is not a valid Managed thread. (This is considered a common case)</span></td>
      </tr>
      <tr>
        <td id="L2062" data-line-number="2062"></td>
        <td id="LC2062"><span><span>//</span>      Throws on error.</span></td>
      </tr>
      <tr>
        <td id="L2063" data-line-number="2063"></td>
        <td id="LC2063"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2064" data-line-number="2064"></td>
        <td id="LC2064"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2065" data-line-number="2065"></td>
        <td id="LC2065"><span><span>//</span>      OS Thread ID is not fiber-safe, so this is a dangerous function to call.</span></td>
      </tr>
      <tr>
        <td id="L2066" data-line-number="2066"></td>
        <td id="LC2066"><span><span>//</span>      Avoid this as much as possible. Prefer using VMPTR_Thread and</span></td>
      </tr>
      <tr>
        <td id="L2067" data-line-number="2067"></td>
        <td id="LC2067"><span><span>//</span>      code:CordbProcess::LookupOrCreateThread instead of OS thread IDs.</span></td>
      </tr>
      <tr>
        <td id="L2068" data-line-number="2068"></td>
        <td id="LC2068"><span><span>//</span>      See code:CordbThread::GetID for details.</span></td>
      </tr>
      <tr>
        <td id="L2069" data-line-number="2069"></td>
        <td id="LC2069">CordbThread * <span>CordbProcess::TryLookupOrCreateThreadByVolatileOSId</span>(DWORD dwThreadId)</td>
      </tr>
      <tr>
        <td id="L2070" data-line-number="2070"></td>
        <td id="LC2070">{</td>
      </tr>
      <tr>
        <td id="L2071" data-line-number="2071"></td>
        <td id="LC2071">    <span>PrepopulateThreadsOrThrow</span>();</td>
      </tr>
      <tr>
        <td id="L2072" data-line-number="2072"></td>
        <td id="LC2072">    <span>return</span> <span>TryLookupThreadByVolatileOSId</span>(dwThreadId);</td>
      </tr>
      <tr>
        <td id="L2073" data-line-number="2073"></td>
        <td id="LC2073">}</td>
      </tr>
      <tr>
        <td id="L2074" data-line-number="2074"></td>
        <td id="LC2074">
</td>
      </tr>
      <tr>
        <td id="L2075" data-line-number="2075"></td>
        <td id="LC2075"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2076" data-line-number="2076"></td>
        <td id="LC2076"><span><span>//</span> Lookup a cached CordbThread object by the tid. Returns null if not in the cache (which</span></td>
      </tr>
      <tr>
        <td id="L2077" data-line-number="2077"></td>
        <td id="LC2077"><span><span>//</span> includes unmanged thread)</span></td>
      </tr>
      <tr>
        <td id="L2078" data-line-number="2078"></td>
        <td id="LC2078"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2079" data-line-number="2079"></td>
        <td id="LC2079"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2080" data-line-number="2080"></td>
        <td id="LC2080"><span><span>//</span>      dwThreadId - os thread id that a managed thread may be using.</span></td>
      </tr>
      <tr>
        <td id="L2081" data-line-number="2081"></td>
        <td id="LC2081"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2082" data-line-number="2082"></td>
        <td id="LC2082"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L2083" data-line-number="2083"></td>
        <td id="LC2083"><span><span>//</span>      Thread instance if there is currently a managed thread scheduled to run on dwThreadId.</span></td>
      </tr>
      <tr>
        <td id="L2084" data-line-number="2084"></td>
        <td id="LC2084"><span><span>//</span>      NULL if this tid is not a valid Managed thread. (This is considered a common case)</span></td>
      </tr>
      <tr>
        <td id="L2085" data-line-number="2085"></td>
        <td id="LC2085"><span><span>//</span>      Throws on error.</span></td>
      </tr>
      <tr>
        <td id="L2086" data-line-number="2086"></td>
        <td id="LC2086"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2087" data-line-number="2087"></td>
        <td id="LC2087"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2088" data-line-number="2088"></td>
        <td id="LC2088"><span><span>//</span>   Avoids this method:</span></td>
      </tr>
      <tr>
        <td id="L2089" data-line-number="2089"></td>
        <td id="LC2089"><span><span>//</span>   * OS Thread ID is not fiber-safe, so this is a dangerous function to call.</span></td>
      </tr>
      <tr>
        <td id="L2090" data-line-number="2090"></td>
        <td id="LC2090"><span><span>//</span>   * This is juts a Lookup, not LookupOrCreate, so it should only be used by methods</span></td>
      </tr>
      <tr>
        <td id="L2091" data-line-number="2091"></td>
        <td id="LC2091"><span><span>//</span>    that care about the RS state (instead of just LS state).</span></td>
      </tr>
      <tr>
        <td id="L2092" data-line-number="2092"></td>
        <td id="LC2092"><span><span>//</span>   Prefer using VMPTR_Thread and code:CordbProcess::LookupOrCreateThread</span></td>
      </tr>
      <tr>
        <td id="L2093" data-line-number="2093"></td>
        <td id="LC2093"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2094" data-line-number="2094"></td>
        <td id="LC2094">CordbThread * <span>CordbProcess::TryLookupThreadByVolatileOSId</span>(DWORD dwThreadId)</td>
      </tr>
      <tr>
        <td id="L2095" data-line-number="2095"></td>
        <td id="LC2095">{</td>
      </tr>
      <tr>
        <td id="L2096" data-line-number="2096"></td>
        <td id="LC2096">    HASHFIND find;</td>
      </tr>
      <tr>
        <td id="L2097" data-line-number="2097"></td>
        <td id="LC2097">    <span>for</span> (CordbThread * pThread = m_userThreads.<span>FindFirst</span>(&amp;find);</td>
      </tr>
      <tr>
        <td id="L2098" data-line-number="2098"></td>
        <td id="LC2098">         pThread != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2099" data-line-number="2099"></td>
        <td id="LC2099">         pThread =  m_userThreads.<span>FindNext</span>(&amp;find))</td>
      </tr>
      <tr>
        <td id="L2100" data-line-number="2100"></td>
        <td id="LC2100">    {</td>
      </tr>
      <tr>
        <td id="L2101" data-line-number="2101"></td>
        <td id="LC2101">        <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L2102" data-line-number="2102"></td>
        <td id="LC2102">
</td>
      </tr>
      <tr>
        <td id="L2103" data-line-number="2103"></td>
        <td id="LC2103">        <span><span>//</span> Get the OS tid. This returns 0 if the thread is switched out.</span></td>
      </tr>
      <tr>
        <td id="L2104" data-line-number="2104"></td>
        <td id="LC2104">        DWORD dwThreadId2 = <span>GetDAC</span>()-&gt;<span>TryGetVolatileOSThreadID</span>(pThread-&gt;<span>m_vmThreadToken</span>);</td>
      </tr>
      <tr>
        <td id="L2105" data-line-number="2105"></td>
        <td id="LC2105">        <span>if</span> (dwThreadId2 == dwThreadId)</td>
      </tr>
      <tr>
        <td id="L2106" data-line-number="2106"></td>
        <td id="LC2106">        {</td>
      </tr>
      <tr>
        <td id="L2107" data-line-number="2107"></td>
        <td id="LC2107">            <span>return</span> pThread;</td>
      </tr>
      <tr>
        <td id="L2108" data-line-number="2108"></td>
        <td id="LC2108">        }</td>
      </tr>
      <tr>
        <td id="L2109" data-line-number="2109"></td>
        <td id="LC2109">    }</td>
      </tr>
      <tr>
        <td id="L2110" data-line-number="2110"></td>
        <td id="LC2110">
</td>
      </tr>
      <tr>
        <td id="L2111" data-line-number="2111"></td>
        <td id="LC2111">    <span><span>//</span> This OS thread ID does not match any managed thread id.</span></td>
      </tr>
      <tr>
        <td id="L2112" data-line-number="2112"></td>
        <td id="LC2112">    <span>return</span> <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2113" data-line-number="2113"></td>
        <td id="LC2113">}</td>
      </tr>
      <tr>
        <td id="L2114" data-line-number="2114"></td>
        <td id="LC2114">
</td>
      </tr>
      <tr>
        <td id="L2115" data-line-number="2115"></td>
        <td id="LC2115"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2116" data-line-number="2116"></td>
        <td id="LC2116"><span><span>//</span> Preferred CordbThread lookup routine.</span></td>
      </tr>
      <tr>
        <td id="L2117" data-line-number="2117"></td>
        <td id="LC2117"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2118" data-line-number="2118"></td>
        <td id="LC2118"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2119" data-line-number="2119"></td>
        <td id="LC2119"><span><span>//</span>     vmThread - LS thread to lookup. Must be non-null.</span></td>
      </tr>
      <tr>
        <td id="L2120" data-line-number="2120"></td>
        <td id="LC2120"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2121" data-line-number="2121"></td>
        <td id="LC2121"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L2122" data-line-number="2122"></td>
        <td id="LC2122"><span><span>//</span>     CordbThread instance for given vmThread. May return a previously cached</span></td>
      </tr>
      <tr>
        <td id="L2123" data-line-number="2123"></td>
        <td id="LC2123"><span><span>//</span>     instance or create a new instance. Never returns NULL.</span></td>
      </tr>
      <tr>
        <td id="L2124" data-line-number="2124"></td>
        <td id="LC2124"><span><span>//</span>     Throw on error.</span></td>
      </tr>
      <tr>
        <td id="L2125" data-line-number="2125"></td>
        <td id="LC2125">CordbThread * <span>CordbProcess::LookupOrCreateThread</span>(VMPTR_Thread vmThread)</td>
      </tr>
      <tr>
        <td id="L2126" data-line-number="2126"></td>
        <td id="LC2126">{</td>
      </tr>
      <tr>
        <td id="L2127" data-line-number="2127"></td>
        <td id="LC2127">    <span>_ASSERTE</span>(!vmThread.<span>IsNull</span>());</td>
      </tr>
      <tr>
        <td id="L2128" data-line-number="2128"></td>
        <td id="LC2128">
</td>
      </tr>
      <tr>
        <td id="L2129" data-line-number="2129"></td>
        <td id="LC2129">    <span><span>//</span> Return if we have an existing instance.</span></td>
      </tr>
      <tr>
        <td id="L2130" data-line-number="2130"></td>
        <td id="LC2130">    CordbThread * pReturn = <span>TryLookupThread</span>(vmThread);</td>
      </tr>
      <tr>
        <td id="L2131" data-line-number="2131"></td>
        <td id="LC2131">    <span>if</span> (pReturn != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L2132" data-line-number="2132"></td>
        <td id="LC2132">    {</td>
      </tr>
      <tr>
        <td id="L2133" data-line-number="2133"></td>
        <td id="LC2133">        <span>return</span> pReturn;</td>
      </tr>
      <tr>
        <td id="L2134" data-line-number="2134"></td>
        <td id="LC2134">    }</td>
      </tr>
      <tr>
        <td id="L2135" data-line-number="2135"></td>
        <td id="LC2135">
</td>
      </tr>
      <tr>
        <td id="L2136" data-line-number="2136"></td>
        <td id="LC2136">    RSInitHolder&lt;CordbThread&gt; <span>pThread</span>(<span>new</span> <span>CordbThread</span>(<span>this</span>, vmThread)); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L2137" data-line-number="2137"></td>
        <td id="LC2137">    pReturn = pThread.<span>TransferOwnershipToHash</span>(&amp;m_userThreads);</td>
      </tr>
      <tr>
        <td id="L2138" data-line-number="2138"></td>
        <td id="LC2138">
</td>
      </tr>
      <tr>
        <td id="L2139" data-line-number="2139"></td>
        <td id="LC2139">    <span>return</span> pReturn;</td>
      </tr>
      <tr>
        <td id="L2140" data-line-number="2140"></td>
        <td id="LC2140">}</td>
      </tr>
      <tr>
        <td id="L2141" data-line-number="2141"></td>
        <td id="LC2141">
</td>
      </tr>
      <tr>
        <td id="L2142" data-line-number="2142"></td>
        <td id="LC2142">
</td>
      </tr>
      <tr>
        <td id="L2143" data-line-number="2143"></td>
        <td id="LC2143">
</td>
      </tr>
      <tr>
        <td id="L2144" data-line-number="2144"></td>
        <td id="LC2144">
</td>
      </tr>
      <tr>
        <td id="L2145" data-line-number="2145"></td>
        <td id="LC2145">HRESULT <span>CordbProcess::QueryInterface</span>(REFIID id, <span>void</span> **pInterface)</td>
      </tr>
      <tr>
        <td id="L2146" data-line-number="2146"></td>
        <td id="LC2146">{</td>
      </tr>
      <tr>
        <td id="L2147" data-line-number="2147"></td>
        <td id="LC2147">    <span>if</span> (id == IID_ICorDebugProcess)</td>
      </tr>
      <tr>
        <td id="L2148" data-line-number="2148"></td>
        <td id="LC2148">    {</td>
      </tr>
      <tr>
        <td id="L2149" data-line-number="2149"></td>
        <td id="LC2149">        *pInterface = <span>static_cast</span>&lt;ICorDebugProcess*&gt;(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2150" data-line-number="2150"></td>
        <td id="LC2150">    }</td>
      </tr>
      <tr>
        <td id="L2151" data-line-number="2151"></td>
        <td id="LC2151">    <span>else</span> <span>if</span> (id == IID_ICorDebugController)</td>
      </tr>
      <tr>
        <td id="L2152" data-line-number="2152"></td>
        <td id="LC2152">    {</td>
      </tr>
      <tr>
        <td id="L2153" data-line-number="2153"></td>
        <td id="LC2153">        *pInterface = <span>static_cast</span>&lt;ICorDebugController*&gt;(<span>static_cast</span>&lt;ICorDebugProcess*&gt;(<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L2154" data-line-number="2154"></td>
        <td id="LC2154">    }</td>
      </tr>
      <tr>
        <td id="L2155" data-line-number="2155"></td>
        <td id="LC2155">    <span>else</span> <span>if</span> (id == IID_ICorDebugProcess2)</td>
      </tr>
      <tr>
        <td id="L2156" data-line-number="2156"></td>
        <td id="LC2156">
</td>
      </tr>
      <tr>
        <td id="L2157" data-line-number="2157"></td>
        <td id="LC2157">    {</td>
      </tr>
      <tr>
        <td id="L2158" data-line-number="2158"></td>
        <td id="LC2158">        *pInterface = <span>static_cast</span>&lt;ICorDebugProcess2*&gt;(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2159" data-line-number="2159"></td>
        <td id="LC2159">    }</td>
      </tr>
      <tr>
        <td id="L2160" data-line-number="2160"></td>
        <td id="LC2160">    <span>else</span> <span>if</span> (id == IID_ICorDebugProcess3)</td>
      </tr>
      <tr>
        <td id="L2161" data-line-number="2161"></td>
        <td id="LC2161">    {</td>
      </tr>
      <tr>
        <td id="L2162" data-line-number="2162"></td>
        <td id="LC2162">        *pInterface = <span>static_cast</span>&lt;ICorDebugProcess3*&gt;(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2163" data-line-number="2163"></td>
        <td id="LC2163">    }</td>
      </tr>
      <tr>
        <td id="L2164" data-line-number="2164"></td>
        <td id="LC2164">    <span>else</span> <span>if</span> (id == IID_ICorDebugProcess4)</td>
      </tr>
      <tr>
        <td id="L2165" data-line-number="2165"></td>
        <td id="LC2165">    {</td>
      </tr>
      <tr>
        <td id="L2166" data-line-number="2166"></td>
        <td id="LC2166">        *pInterface = <span>static_cast</span>&lt;ICorDebugProcess4*&gt;(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2167" data-line-number="2167"></td>
        <td id="LC2167">    }</td>
      </tr>
      <tr>
        <td id="L2168" data-line-number="2168"></td>
        <td id="LC2168">    <span>else</span> <span>if</span> (id == IID_ICorDebugProcess5)</td>
      </tr>
      <tr>
        <td id="L2169" data-line-number="2169"></td>
        <td id="LC2169">    {</td>
      </tr>
      <tr>
        <td id="L2170" data-line-number="2170"></td>
        <td id="LC2170">        *pInterface = <span>static_cast</span>&lt;ICorDebugProcess5*&gt;(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2171" data-line-number="2171"></td>
        <td id="LC2171">    }</td>
      </tr>
      <tr>
        <td id="L2172" data-line-number="2172"></td>
        <td id="LC2172">    <span>else</span> <span>if</span> (id == IID_ICorDebugProcess7)</td>
      </tr>
      <tr>
        <td id="L2173" data-line-number="2173"></td>
        <td id="LC2173">    {</td>
      </tr>
      <tr>
        <td id="L2174" data-line-number="2174"></td>
        <td id="LC2174">        *pInterface = <span>static_cast</span>&lt;ICorDebugProcess7*&gt;(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2175" data-line-number="2175"></td>
        <td id="LC2175">    }</td>
      </tr>
      <tr>
        <td id="L2176" data-line-number="2176"></td>
        <td id="LC2176">    <span>else</span> <span>if</span> (id == IID_ICorDebugProcess8)</td>
      </tr>
      <tr>
        <td id="L2177" data-line-number="2177"></td>
        <td id="LC2177">    {</td>
      </tr>
      <tr>
        <td id="L2178" data-line-number="2178"></td>
        <td id="LC2178">        *pInterface = <span>static_cast</span>&lt;ICorDebugProcess8*&gt;(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2179" data-line-number="2179"></td>
        <td id="LC2179">    }</td>
      </tr>
      <tr>
        <td id="L2180" data-line-number="2180"></td>
        <td id="LC2180">    <span>else</span> <span>if</span> (id == IID_ICorDebugProcess10)</td>
      </tr>
      <tr>
        <td id="L2181" data-line-number="2181"></td>
        <td id="LC2181">    {</td>
      </tr>
      <tr>
        <td id="L2182" data-line-number="2182"></td>
        <td id="LC2182">        *pInterface = <span>static_cast</span>&lt;ICorDebugProcess10*&gt;(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2183" data-line-number="2183"></td>
        <td id="LC2183">    }</td>
      </tr>
      <tr>
        <td id="L2184" data-line-number="2184"></td>
        <td id="LC2184">    <span>else</span> <span>if</span> (id == IID_IUnknown)</td>
      </tr>
      <tr>
        <td id="L2185" data-line-number="2185"></td>
        <td id="LC2185">    {</td>
      </tr>
      <tr>
        <td id="L2186" data-line-number="2186"></td>
        <td id="LC2186">        *pInterface = <span>static_cast</span>&lt;IUnknown*&gt;(<span>static_cast</span>&lt;ICorDebugProcess*&gt;(<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L2187" data-line-number="2187"></td>
        <td id="LC2187">    }</td>
      </tr>
      <tr>
        <td id="L2188" data-line-number="2188"></td>
        <td id="LC2188">
</td>
      </tr>
      <tr>
        <td id="L2189" data-line-number="2189"></td>
        <td id="LC2189">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L2190" data-line-number="2190"></td>
        <td id="LC2190">    {</td>
      </tr>
      <tr>
        <td id="L2191" data-line-number="2191"></td>
        <td id="LC2191">        *pInterface = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2192" data-line-number="2192"></td>
        <td id="LC2192">        <span>return</span> E_NOINTERFACE;</td>
      </tr>
      <tr>
        <td id="L2193" data-line-number="2193"></td>
        <td id="LC2193">    }</td>
      </tr>
      <tr>
        <td id="L2194" data-line-number="2194"></td>
        <td id="LC2194">
</td>
      </tr>
      <tr>
        <td id="L2195" data-line-number="2195"></td>
        <td id="LC2195">    <span>ExternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L2196" data-line-number="2196"></td>
        <td id="LC2196">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L2197" data-line-number="2197"></td>
        <td id="LC2197">}</td>
      </tr>
      <tr>
        <td id="L2198" data-line-number="2198"></td>
        <td id="LC2198">
</td>
      </tr>
      <tr>
        <td id="L2199" data-line-number="2199"></td>
        <td id="LC2199">
</td>
      </tr>
      <tr>
        <td id="L2200" data-line-number="2200"></td>
        <td id="LC2200">
</td>
      </tr>
      <tr>
        <td id="L2201" data-line-number="2201"></td>
        <td id="LC2201">
</td>
      </tr>
      <tr>
        <td id="L2202" data-line-number="2202"></td>
        <td id="LC2202"><span><span>//</span> Public implementation of ICorDebugProcess4::ProcessStateChanged</span></td>
      </tr>
      <tr>
        <td id="L2203" data-line-number="2203"></td>
        <td id="LC2203">HRESULT <span>CordbProcess::ProcessStateChanged</span>(CorDebugStateChange eChange)</td>
      </tr>
      <tr>
        <td id="L2204" data-line-number="2204"></td>
        <td id="LC2204">{</td>
      </tr>
      <tr>
        <td id="L2205" data-line-number="2205"></td>
        <td id="LC2205">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2206" data-line-number="2206"></td>
        <td id="LC2206">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>)</td>
      </tr>
      <tr>
        <td id="L2207" data-line-number="2207"></td>
        <td id="LC2207">    {</td>
      </tr>
      <tr>
        <td id="L2208" data-line-number="2208"></td>
        <td id="LC2208">        <span>switch</span>(eChange)</td>
      </tr>
      <tr>
        <td id="L2209" data-line-number="2209"></td>
        <td id="LC2209">        {</td>
      </tr>
      <tr>
        <td id="L2210" data-line-number="2210"></td>
        <td id="LC2210">        <span>case</span> PROCESS_RUNNING:</td>
      </tr>
      <tr>
        <td id="L2211" data-line-number="2211"></td>
        <td id="LC2211">            <span>FlushProcessRunning</span>();</td>
      </tr>
      <tr>
        <td id="L2212" data-line-number="2212"></td>
        <td id="LC2212">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2213" data-line-number="2213"></td>
        <td id="LC2213">
</td>
      </tr>
      <tr>
        <td id="L2214" data-line-number="2214"></td>
        <td id="LC2214">        <span>case</span> FLUSH_ALL:</td>
      </tr>
      <tr>
        <td id="L2215" data-line-number="2215"></td>
        <td id="LC2215">            <span>FlushAll</span>();</td>
      </tr>
      <tr>
        <td id="L2216" data-line-number="2216"></td>
        <td id="LC2216">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2217" data-line-number="2217"></td>
        <td id="LC2217">
</td>
      </tr>
      <tr>
        <td id="L2218" data-line-number="2218"></td>
        <td id="LC2218">        <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L2219" data-line-number="2219"></td>
        <td id="LC2219">            <span>ThrowHR</span>(E_INVALIDARG);</td>
      </tr>
      <tr>
        <td id="L2220" data-line-number="2220"></td>
        <td id="LC2220">
</td>
      </tr>
      <tr>
        <td id="L2221" data-line-number="2221"></td>
        <td id="LC2221">        }</td>
      </tr>
      <tr>
        <td id="L2222" data-line-number="2222"></td>
        <td id="LC2222">    }</td>
      </tr>
      <tr>
        <td id="L2223" data-line-number="2223"></td>
        <td id="LC2223">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2224" data-line-number="2224"></td>
        <td id="LC2224">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2225" data-line-number="2225"></td>
        <td id="LC2225">}</td>
      </tr>
      <tr>
        <td id="L2226" data-line-number="2226"></td>
        <td id="LC2226">
</td>
      </tr>
      <tr>
        <td id="L2227" data-line-number="2227"></td>
        <td id="LC2227">
</td>
      </tr>
      <tr>
        <td id="L2228" data-line-number="2228"></td>
        <td id="LC2228">HRESULT <span>CordbProcess::EnumerateHeap</span>(ICorDebugHeapEnum **ppObjects)</td>
      </tr>
      <tr>
        <td id="L2229" data-line-number="2229"></td>
        <td id="LC2229">{</td>
      </tr>
      <tr>
        <td id="L2230" data-line-number="2230"></td>
        <td id="LC2230">    <span>if</span> (!ppObjects)</td>
      </tr>
      <tr>
        <td id="L2231" data-line-number="2231"></td>
        <td id="LC2231">        <span>return</span> E_POINTER;</td>
      </tr>
      <tr>
        <td id="L2232" data-line-number="2232"></td>
        <td id="LC2232">
</td>
      </tr>
      <tr>
        <td id="L2233" data-line-number="2233"></td>
        <td id="LC2233">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2234" data-line-number="2234"></td>
        <td id="LC2234">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2235" data-line-number="2235"></td>
        <td id="LC2235">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2236" data-line-number="2236"></td>
        <td id="LC2236">
</td>
      </tr>
      <tr>
        <td id="L2237" data-line-number="2237"></td>
        <td id="LC2237">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2238" data-line-number="2238"></td>
        <td id="LC2238">    {</td>
      </tr>
      <tr>
        <td id="L2239" data-line-number="2239"></td>
        <td id="LC2239">        <span>if</span> (m_pDacPrimitives-&gt;<span>AreGCStructuresValid</span>())</td>
      </tr>
      <tr>
        <td id="L2240" data-line-number="2240"></td>
        <td id="LC2240">        {</td>
      </tr>
      <tr>
        <td id="L2241" data-line-number="2241"></td>
        <td id="LC2241">            CordbHeapEnum *pHeapEnum = <span>new</span> <span>CordbHeapEnum</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2242" data-line-number="2242"></td>
        <td id="LC2242">            <span>GetContinueNeuterList</span>()-&gt;<span>Add</span>(<span>this</span>, pHeapEnum);</td>
      </tr>
      <tr>
        <td id="L2243" data-line-number="2243"></td>
        <td id="LC2243">            hr = pHeapEnum-&gt;<span>QueryInterface</span>(<span>__uuidof</span>(ICorDebugHeapEnum), (<span>void</span>**)ppObjects);</td>
      </tr>
      <tr>
        <td id="L2244" data-line-number="2244"></td>
        <td id="LC2244">        }</td>
      </tr>
      <tr>
        <td id="L2245" data-line-number="2245"></td>
        <td id="LC2245">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L2246" data-line-number="2246"></td>
        <td id="LC2246">        {</td>
      </tr>
      <tr>
        <td id="L2247" data-line-number="2247"></td>
        <td id="LC2247">            hr = CORDBG_E_GC_STRUCTURES_INVALID;</td>
      </tr>
      <tr>
        <td id="L2248" data-line-number="2248"></td>
        <td id="LC2248">        }</td>
      </tr>
      <tr>
        <td id="L2249" data-line-number="2249"></td>
        <td id="LC2249">    }</td>
      </tr>
      <tr>
        <td id="L2250" data-line-number="2250"></td>
        <td id="LC2250">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2251" data-line-number="2251"></td>
        <td id="LC2251">
</td>
      </tr>
      <tr>
        <td id="L2252" data-line-number="2252"></td>
        <td id="LC2252">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2253" data-line-number="2253"></td>
        <td id="LC2253">}</td>
      </tr>
      <tr>
        <td id="L2254" data-line-number="2254"></td>
        <td id="LC2254">
</td>
      </tr>
      <tr>
        <td id="L2255" data-line-number="2255"></td>
        <td id="LC2255">HRESULT <span>CordbProcess::GetGCHeapInformation</span>(COR_HEAPINFO *pHeapInfo)</td>
      </tr>
      <tr>
        <td id="L2256" data-line-number="2256"></td>
        <td id="LC2256">{</td>
      </tr>
      <tr>
        <td id="L2257" data-line-number="2257"></td>
        <td id="LC2257">    <span>if</span> (!pHeapInfo)</td>
      </tr>
      <tr>
        <td id="L2258" data-line-number="2258"></td>
        <td id="LC2258">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L2259" data-line-number="2259"></td>
        <td id="LC2259">
</td>
      </tr>
      <tr>
        <td id="L2260" data-line-number="2260"></td>
        <td id="LC2260">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2261" data-line-number="2261"></td>
        <td id="LC2261">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2262" data-line-number="2262"></td>
        <td id="LC2262">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2263" data-line-number="2263"></td>
        <td id="LC2263">
</td>
      </tr>
      <tr>
        <td id="L2264" data-line-number="2264"></td>
        <td id="LC2264">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2265" data-line-number="2265"></td>
        <td id="LC2265">    {</td>
      </tr>
      <tr>
        <td id="L2266" data-line-number="2266"></td>
        <td id="LC2266">        <span>GetDAC</span>()-&gt;<span>GetGCHeapInformation</span>(pHeapInfo);</td>
      </tr>
      <tr>
        <td id="L2267" data-line-number="2267"></td>
        <td id="LC2267">    }</td>
      </tr>
      <tr>
        <td id="L2268" data-line-number="2268"></td>
        <td id="LC2268">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2269" data-line-number="2269"></td>
        <td id="LC2269">
</td>
      </tr>
      <tr>
        <td id="L2270" data-line-number="2270"></td>
        <td id="LC2270">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2271" data-line-number="2271"></td>
        <td id="LC2271">}</td>
      </tr>
      <tr>
        <td id="L2272" data-line-number="2272"></td>
        <td id="LC2272">
</td>
      </tr>
      <tr>
        <td id="L2273" data-line-number="2273"></td>
        <td id="LC2273">HRESULT <span>CordbProcess::EnumerateHeapRegions</span>(ICorDebugHeapSegmentEnum **ppRegions)</td>
      </tr>
      <tr>
        <td id="L2274" data-line-number="2274"></td>
        <td id="LC2274">{</td>
      </tr>
      <tr>
        <td id="L2275" data-line-number="2275"></td>
        <td id="LC2275">    <span>if</span> (!ppRegions)</td>
      </tr>
      <tr>
        <td id="L2276" data-line-number="2276"></td>
        <td id="LC2276">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L2277" data-line-number="2277"></td>
        <td id="LC2277">
</td>
      </tr>
      <tr>
        <td id="L2278" data-line-number="2278"></td>
        <td id="LC2278">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2279" data-line-number="2279"></td>
        <td id="LC2279">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2280" data-line-number="2280"></td>
        <td id="LC2280">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2281" data-line-number="2281"></td>
        <td id="LC2281">
</td>
      </tr>
      <tr>
        <td id="L2282" data-line-number="2282"></td>
        <td id="LC2282">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2283" data-line-number="2283"></td>
        <td id="LC2283">    {</td>
      </tr>
      <tr>
        <td id="L2284" data-line-number="2284"></td>
        <td id="LC2284">        DacDbiArrayList&lt;COR_SEGMENT&gt; segments;</td>
      </tr>
      <tr>
        <td id="L2285" data-line-number="2285"></td>
        <td id="LC2285">        hr = <span>GetDAC</span>()-&gt;<span>GetHeapSegments</span>(&amp;segments);</td>
      </tr>
      <tr>
        <td id="L2286" data-line-number="2286"></td>
        <td id="LC2286">
</td>
      </tr>
      <tr>
        <td id="L2287" data-line-number="2287"></td>
        <td id="LC2287">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2288" data-line-number="2288"></td>
        <td id="LC2288">        {</td>
      </tr>
      <tr>
        <td id="L2289" data-line-number="2289"></td>
        <td id="LC2289">            <span>if</span> (!segments.<span>IsEmpty</span>())</td>
      </tr>
      <tr>
        <td id="L2290" data-line-number="2290"></td>
        <td id="LC2290">            {</td>
      </tr>
      <tr>
        <td id="L2291" data-line-number="2291"></td>
        <td id="LC2291">                CordbHeapSegmentEnumerator *segEnum = <span>new</span> <span>CordbHeapSegmentEnumerator</span>(<span>this</span>, &amp;segments[<span>0</span>], (DWORD)segments.<span>Count</span>());</td>
      </tr>
      <tr>
        <td id="L2292" data-line-number="2292"></td>
        <td id="LC2292">                <span>GetContinueNeuterList</span>()-&gt;<span>Add</span>(<span>this</span>, segEnum);</td>
      </tr>
      <tr>
        <td id="L2293" data-line-number="2293"></td>
        <td id="LC2293">                hr = segEnum-&gt;<span>QueryInterface</span>(<span>__uuidof</span>(ICorDebugHeapSegmentEnum), (<span>void</span>**)ppRegions);</td>
      </tr>
      <tr>
        <td id="L2294" data-line-number="2294"></td>
        <td id="LC2294">            }</td>
      </tr>
      <tr>
        <td id="L2295" data-line-number="2295"></td>
        <td id="LC2295">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L2296" data-line-number="2296"></td>
        <td id="LC2296">            {</td>
      </tr>
      <tr>
        <td id="L2297" data-line-number="2297"></td>
        <td id="LC2297">                hr = E_OUTOFMEMORY;</td>
      </tr>
      <tr>
        <td id="L2298" data-line-number="2298"></td>
        <td id="LC2298">            }</td>
      </tr>
      <tr>
        <td id="L2299" data-line-number="2299"></td>
        <td id="LC2299">        }</td>
      </tr>
      <tr>
        <td id="L2300" data-line-number="2300"></td>
        <td id="LC2300">    }</td>
      </tr>
      <tr>
        <td id="L2301" data-line-number="2301"></td>
        <td id="LC2301">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2302" data-line-number="2302"></td>
        <td id="LC2302">
</td>
      </tr>
      <tr>
        <td id="L2303" data-line-number="2303"></td>
        <td id="LC2303">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2304" data-line-number="2304"></td>
        <td id="LC2304">}</td>
      </tr>
      <tr>
        <td id="L2305" data-line-number="2305"></td>
        <td id="LC2305">
</td>
      </tr>
      <tr>
        <td id="L2306" data-line-number="2306"></td>
        <td id="LC2306">HRESULT <span>CordbProcess::GetObject</span>(CORDB_ADDRESS addr, ICorDebugObjectValue **ppObject)</td>
      </tr>
      <tr>
        <td id="L2307" data-line-number="2307"></td>
        <td id="LC2307">{</td>
      </tr>
      <tr>
        <td id="L2308" data-line-number="2308"></td>
        <td id="LC2308">    <span>return</span> <span>this</span>-&gt;<span>GetObjectInternal</span>(addr, <span>nullptr</span>, ppObject);</td>
      </tr>
      <tr>
        <td id="L2309" data-line-number="2309"></td>
        <td id="LC2309">}</td>
      </tr>
      <tr>
        <td id="L2310" data-line-number="2310"></td>
        <td id="LC2310">
</td>
      </tr>
      <tr>
        <td id="L2311" data-line-number="2311"></td>
        <td id="LC2311">HRESULT <span>CordbProcess::GetObjectInternal</span>(CORDB_ADDRESS addr, CordbAppDomain* pAppDomainOverride, ICorDebugObjectValue **pObject)</td>
      </tr>
      <tr>
        <td id="L2312" data-line-number="2312"></td>
        <td id="LC2312">{</td>
      </tr>
      <tr>
        <td id="L2313" data-line-number="2313"></td>
        <td id="LC2313">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2314" data-line-number="2314"></td>
        <td id="LC2314">
</td>
      </tr>
      <tr>
        <td id="L2315" data-line-number="2315"></td>
        <td id="LC2315">    <span>PUBLIC_REENTRANT_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2316" data-line-number="2316"></td>
        <td id="LC2316">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2317" data-line-number="2317"></td>
        <td id="LC2317">
</td>
      </tr>
      <tr>
        <td id="L2318" data-line-number="2318"></td>
        <td id="LC2318">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2319" data-line-number="2319"></td>
        <td id="LC2319">    {</td>
      </tr>
      <tr>
        <td id="L2320" data-line-number="2320"></td>
        <td id="LC2320">        <span>if</span> (!m_pDacPrimitives-&gt;<span>IsValidObject</span>(addr))</td>
      </tr>
      <tr>
        <td id="L2321" data-line-number="2321"></td>
        <td id="LC2321">        {</td>
      </tr>
      <tr>
        <td id="L2322" data-line-number="2322"></td>
        <td id="LC2322">            hr = CORDBG_E_CORRUPT_OBJECT;</td>
      </tr>
      <tr>
        <td id="L2323" data-line-number="2323"></td>
        <td id="LC2323">        }</td>
      </tr>
      <tr>
        <td id="L2324" data-line-number="2324"></td>
        <td id="LC2324">        <span>else</span> <span>if</span> (pObject == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L2325" data-line-number="2325"></td>
        <td id="LC2325">        {</td>
      </tr>
      <tr>
        <td id="L2326" data-line-number="2326"></td>
        <td id="LC2326">            hr = E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L2327" data-line-number="2327"></td>
        <td id="LC2327">        }</td>
      </tr>
      <tr>
        <td id="L2328" data-line-number="2328"></td>
        <td id="LC2328">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L2329" data-line-number="2329"></td>
        <td id="LC2329">        {</td>
      </tr>
      <tr>
        <td id="L2330" data-line-number="2330"></td>
        <td id="LC2330">            RSLockHolder <span>ch</span>(<span>GetProcess</span>()-&gt;<span>GetStopGoLock</span>());</td>
      </tr>
      <tr>
        <td id="L2331" data-line-number="2331"></td>
        <td id="LC2331">            RSLockHolder <span>procLock</span>(<span>this</span>-&gt;<span>GetProcess</span>()-&gt;<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L2332" data-line-number="2332"></td>
        <td id="LC2332">
</td>
      </tr>
      <tr>
        <td id="L2333" data-line-number="2333"></td>
        <td id="LC2333">            CordbAppDomain *cdbAppDomain = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2334" data-line-number="2334"></td>
        <td id="LC2334">            CordbType *pType = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2335" data-line-number="2335"></td>
        <td id="LC2335">            hr = <span>GetTypeForObject</span>(addr, pAppDomainOverride, &amp;pType, &amp;cdbAppDomain);</td>
      </tr>
      <tr>
        <td id="L2336" data-line-number="2336"></td>
        <td id="LC2336">
</td>
      </tr>
      <tr>
        <td id="L2337" data-line-number="2337"></td>
        <td id="LC2337">            <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2338" data-line-number="2338"></td>
        <td id="LC2338">            {</td>
      </tr>
      <tr>
        <td id="L2339" data-line-number="2339"></td>
        <td id="LC2339">                <span>_ASSERTE</span>(pType != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L2340" data-line-number="2340"></td>
        <td id="LC2340">                <span>_ASSERTE</span>(cdbAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L2341" data-line-number="2341"></td>
        <td id="LC2341">
</td>
      </tr>
      <tr>
        <td id="L2342" data-line-number="2342"></td>
        <td id="LC2342">                DebuggerIPCE_ObjectData objData;</td>
      </tr>
      <tr>
        <td id="L2343" data-line-number="2343"></td>
        <td id="LC2343">                m_pDacPrimitives-&gt;<span>GetBasicObjectInfo</span>(addr, ELEMENT_TYPE_CLASS, cdbAppDomain-&gt;<span>GetADToken</span>(), &amp;objData);</td>
      </tr>
      <tr>
        <td id="L2344" data-line-number="2344"></td>
        <td id="LC2344">
</td>
      </tr>
      <tr>
        <td id="L2345" data-line-number="2345"></td>
        <td id="LC2345">                NewHolder&lt;CordbObjectValue&gt; <span>pNewObjectValue</span>(<span>new</span> <span>CordbObjectValue</span>(cdbAppDomain, pType, <span>TargetBuffer</span>(addr, (ULONG)objData.<span>objSize</span>), &amp;objData));</td>
      </tr>
      <tr>
        <td id="L2346" data-line-number="2346"></td>
        <td id="LC2346">                hr = pNewObjectValue-&gt;<span>Init</span>();</td>
      </tr>
      <tr>
        <td id="L2347" data-line-number="2347"></td>
        <td id="LC2347">
</td>
      </tr>
      <tr>
        <td id="L2348" data-line-number="2348"></td>
        <td id="LC2348">                <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2349" data-line-number="2349"></td>
        <td id="LC2349">                {</td>
      </tr>
      <tr>
        <td id="L2350" data-line-number="2350"></td>
        <td id="LC2350">                    hr = pNewObjectValue-&gt;<span>QueryInterface</span>(<span>__uuidof</span>(ICorDebugObjectValue), (<span>void</span>**)pObject);</td>
      </tr>
      <tr>
        <td id="L2351" data-line-number="2351"></td>
        <td id="LC2351">                    <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2352" data-line-number="2352"></td>
        <td id="LC2352">                        pNewObjectValue.<span>SuppressRelease</span>();</td>
      </tr>
      <tr>
        <td id="L2353" data-line-number="2353"></td>
        <td id="LC2353">                }</td>
      </tr>
      <tr>
        <td id="L2354" data-line-number="2354"></td>
        <td id="LC2354">            }</td>
      </tr>
      <tr>
        <td id="L2355" data-line-number="2355"></td>
        <td id="LC2355">        }</td>
      </tr>
      <tr>
        <td id="L2356" data-line-number="2356"></td>
        <td id="LC2356">    }</td>
      </tr>
      <tr>
        <td id="L2357" data-line-number="2357"></td>
        <td id="LC2357">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2358" data-line-number="2358"></td>
        <td id="LC2358">
</td>
      </tr>
      <tr>
        <td id="L2359" data-line-number="2359"></td>
        <td id="LC2359">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2360" data-line-number="2360"></td>
        <td id="LC2360">}</td>
      </tr>
      <tr>
        <td id="L2361" data-line-number="2361"></td>
        <td id="LC2361">
</td>
      </tr>
      <tr>
        <td id="L2362" data-line-number="2362"></td>
        <td id="LC2362">
</td>
      </tr>
      <tr>
        <td id="L2363" data-line-number="2363"></td>
        <td id="LC2363">HRESULT <span>CordbProcess::EnumerateGCReferences</span>(BOOL enumerateWeakReferences, ICorDebugGCReferenceEnum **ppEnum)</td>
      </tr>
      <tr>
        <td id="L2364" data-line-number="2364"></td>
        <td id="LC2364">{</td>
      </tr>
      <tr>
        <td id="L2365" data-line-number="2365"></td>
        <td id="LC2365">    <span>if</span> (!ppEnum)</td>
      </tr>
      <tr>
        <td id="L2366" data-line-number="2366"></td>
        <td id="LC2366">        <span>return</span> E_POINTER;</td>
      </tr>
      <tr>
        <td id="L2367" data-line-number="2367"></td>
        <td id="LC2367">
</td>
      </tr>
      <tr>
        <td id="L2368" data-line-number="2368"></td>
        <td id="LC2368">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2369" data-line-number="2369"></td>
        <td id="LC2369">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2370" data-line-number="2370"></td>
        <td id="LC2370">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2371" data-line-number="2371"></td>
        <td id="LC2371">
</td>
      </tr>
      <tr>
        <td id="L2372" data-line-number="2372"></td>
        <td id="LC2372">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2373" data-line-number="2373"></td>
        <td id="LC2373">    {</td>
      </tr>
      <tr>
        <td id="L2374" data-line-number="2374"></td>
        <td id="LC2374">        CordbRefEnum *pRefEnum = <span>new</span> <span>CordbRefEnum</span>(<span>this</span>, enumerateWeakReferences);</td>
      </tr>
      <tr>
        <td id="L2375" data-line-number="2375"></td>
        <td id="LC2375">        <span>GetContinueNeuterList</span>()-&gt;<span>Add</span>(<span>this</span>, pRefEnum);</td>
      </tr>
      <tr>
        <td id="L2376" data-line-number="2376"></td>
        <td id="LC2376">        hr = pRefEnum-&gt;<span>QueryInterface</span>(IID_ICorDebugGCReferenceEnum, (<span>void</span>**)ppEnum);</td>
      </tr>
      <tr>
        <td id="L2377" data-line-number="2377"></td>
        <td id="LC2377">    }</td>
      </tr>
      <tr>
        <td id="L2378" data-line-number="2378"></td>
        <td id="LC2378">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2379" data-line-number="2379"></td>
        <td id="LC2379">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2380" data-line-number="2380"></td>
        <td id="LC2380">}</td>
      </tr>
      <tr>
        <td id="L2381" data-line-number="2381"></td>
        <td id="LC2381">
</td>
      </tr>
      <tr>
        <td id="L2382" data-line-number="2382"></td>
        <td id="LC2382">HRESULT <span>CordbProcess::EnumerateHandles</span>(CorGCReferenceType types, ICorDebugGCReferenceEnum **ppEnum)</td>
      </tr>
      <tr>
        <td id="L2383" data-line-number="2383"></td>
        <td id="LC2383">{</td>
      </tr>
      <tr>
        <td id="L2384" data-line-number="2384"></td>
        <td id="LC2384">    <span>if</span> (!ppEnum)</td>
      </tr>
      <tr>
        <td id="L2385" data-line-number="2385"></td>
        <td id="LC2385">        <span>return</span> E_POINTER;</td>
      </tr>
      <tr>
        <td id="L2386" data-line-number="2386"></td>
        <td id="LC2386">
</td>
      </tr>
      <tr>
        <td id="L2387" data-line-number="2387"></td>
        <td id="LC2387">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2388" data-line-number="2388"></td>
        <td id="LC2388">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2389" data-line-number="2389"></td>
        <td id="LC2389">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2390" data-line-number="2390"></td>
        <td id="LC2390">
</td>
      </tr>
      <tr>
        <td id="L2391" data-line-number="2391"></td>
        <td id="LC2391">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2392" data-line-number="2392"></td>
        <td id="LC2392">    {</td>
      </tr>
      <tr>
        <td id="L2393" data-line-number="2393"></td>
        <td id="LC2393">        CordbRefEnum *pRefEnum = <span>new</span> <span>CordbRefEnum</span>(<span>this</span>, types);</td>
      </tr>
      <tr>
        <td id="L2394" data-line-number="2394"></td>
        <td id="LC2394">        <span>GetContinueNeuterList</span>()-&gt;<span>Add</span>(<span>this</span>, pRefEnum);</td>
      </tr>
      <tr>
        <td id="L2395" data-line-number="2395"></td>
        <td id="LC2395">        hr = pRefEnum-&gt;<span>QueryInterface</span>(IID_ICorDebugGCReferenceEnum, (<span>void</span>**)ppEnum);</td>
      </tr>
      <tr>
        <td id="L2396" data-line-number="2396"></td>
        <td id="LC2396">    }</td>
      </tr>
      <tr>
        <td id="L2397" data-line-number="2397"></td>
        <td id="LC2397">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2398" data-line-number="2398"></td>
        <td id="LC2398">
</td>
      </tr>
      <tr>
        <td id="L2399" data-line-number="2399"></td>
        <td id="LC2399">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2400" data-line-number="2400"></td>
        <td id="LC2400">}</td>
      </tr>
      <tr>
        <td id="L2401" data-line-number="2401"></td>
        <td id="LC2401">
</td>
      </tr>
      <tr>
        <td id="L2402" data-line-number="2402"></td>
        <td id="LC2402">HRESULT <span>CordbProcess::EnableNGENPolicy</span>(CorDebugNGENPolicy ePolicy)</td>
      </tr>
      <tr>
        <td id="L2403" data-line-number="2403"></td>
        <td id="LC2403">{</td>
      </tr>
      <tr>
        <td id="L2404" data-line-number="2404"></td>
        <td id="LC2404">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L2405" data-line-number="2405"></td>
        <td id="LC2405">}</td>
      </tr>
      <tr>
        <td id="L2406" data-line-number="2406"></td>
        <td id="LC2406">
</td>
      </tr>
      <tr>
        <td id="L2407" data-line-number="2407"></td>
        <td id="LC2407">
</td>
      </tr>
      <tr>
        <td id="L2408" data-line-number="2408"></td>
        <td id="LC2408">HRESULT <span>CordbProcess::GetTypeID</span>(CORDB_ADDRESS obj, COR_TYPEID *pId)</td>
      </tr>
      <tr>
        <td id="L2409" data-line-number="2409"></td>
        <td id="LC2409">{</td>
      </tr>
      <tr>
        <td id="L2410" data-line-number="2410"></td>
        <td id="LC2410">    <span>if</span> (pId == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L2411" data-line-number="2411"></td>
        <td id="LC2411">        <span>return</span> E_POINTER;</td>
      </tr>
      <tr>
        <td id="L2412" data-line-number="2412"></td>
        <td id="LC2412">
</td>
      </tr>
      <tr>
        <td id="L2413" data-line-number="2413"></td>
        <td id="LC2413">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2414" data-line-number="2414"></td>
        <td id="LC2414">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2415" data-line-number="2415"></td>
        <td id="LC2415">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2416" data-line-number="2416"></td>
        <td id="LC2416">
</td>
      </tr>
      <tr>
        <td id="L2417" data-line-number="2417"></td>
        <td id="LC2417">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2418" data-line-number="2418"></td>
        <td id="LC2418">    {</td>
      </tr>
      <tr>
        <td id="L2419" data-line-number="2419"></td>
        <td id="LC2419">        hr = <span>GetProcess</span>()-&gt;<span>GetDAC</span>()-&gt;<span>GetTypeID</span>(obj, pId);</td>
      </tr>
      <tr>
        <td id="L2420" data-line-number="2420"></td>
        <td id="LC2420">    }</td>
      </tr>
      <tr>
        <td id="L2421" data-line-number="2421"></td>
        <td id="LC2421">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2422" data-line-number="2422"></td>
        <td id="LC2422">
</td>
      </tr>
      <tr>
        <td id="L2423" data-line-number="2423"></td>
        <td id="LC2423">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2424" data-line-number="2424"></td>
        <td id="LC2424">}</td>
      </tr>
      <tr>
        <td id="L2425" data-line-number="2425"></td>
        <td id="LC2425">
</td>
      </tr>
      <tr>
        <td id="L2426" data-line-number="2426"></td>
        <td id="LC2426">HRESULT <span>CordbProcess::GetTypeForTypeID</span>(COR_TYPEID id, ICorDebugType **ppType)</td>
      </tr>
      <tr>
        <td id="L2427" data-line-number="2427"></td>
        <td id="LC2427">{</td>
      </tr>
      <tr>
        <td id="L2428" data-line-number="2428"></td>
        <td id="LC2428">    <span>if</span> (ppType == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L2429" data-line-number="2429"></td>
        <td id="LC2429">        <span>return</span> E_POINTER;</td>
      </tr>
      <tr>
        <td id="L2430" data-line-number="2430"></td>
        <td id="LC2430">
</td>
      </tr>
      <tr>
        <td id="L2431" data-line-number="2431"></td>
        <td id="LC2431">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2432" data-line-number="2432"></td>
        <td id="LC2432">
</td>
      </tr>
      <tr>
        <td id="L2433" data-line-number="2433"></td>
        <td id="LC2433">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2434" data-line-number="2434"></td>
        <td id="LC2434">    RSLockHolder <span>stopGoLock</span>(<span>this</span>-&gt;<span>GetProcess</span>()-&gt;<span>GetStopGoLock</span>());</td>
      </tr>
      <tr>
        <td id="L2435" data-line-number="2435"></td>
        <td id="LC2435">    RSLockHolder <span>procLock</span>(<span>this</span>-&gt;<span>GetProcess</span>()-&gt;<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L2436" data-line-number="2436"></td>
        <td id="LC2436">
</td>
      </tr>
      <tr>
        <td id="L2437" data-line-number="2437"></td>
        <td id="LC2437">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2438" data-line-number="2438"></td>
        <td id="LC2438">    {</td>
      </tr>
      <tr>
        <td id="L2439" data-line-number="2439"></td>
        <td id="LC2439">        DebuggerIPCE_ExpandedTypeData data;</td>
      </tr>
      <tr>
        <td id="L2440" data-line-number="2440"></td>
        <td id="LC2440">        <span>GetDAC</span>()-&gt;<span>GetObjectExpandedTypeInfoFromID</span>(AllBoxed, <span>VMPTR_AppDomain::NullPtr</span>(), id, &amp;data);</td>
      </tr>
      <tr>
        <td id="L2441" data-line-number="2441"></td>
        <td id="LC2441">
</td>
      </tr>
      <tr>
        <td id="L2442" data-line-number="2442"></td>
        <td id="LC2442">        CordbType *type = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2443" data-line-number="2443"></td>
        <td id="LC2443">        hr = <span>CordbType::TypeDataToType</span>(<span>GetSharedAppDomain</span>(), &amp;data, &amp;type);</td>
      </tr>
      <tr>
        <td id="L2444" data-line-number="2444"></td>
        <td id="LC2444">
</td>
      </tr>
      <tr>
        <td id="L2445" data-line-number="2445"></td>
        <td id="LC2445">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2446" data-line-number="2446"></td>
        <td id="LC2446">            hr = type-&gt;<span>QueryInterface</span>(IID_ICorDebugType, (<span>void</span>**)ppType);</td>
      </tr>
      <tr>
        <td id="L2447" data-line-number="2447"></td>
        <td id="LC2447">    }</td>
      </tr>
      <tr>
        <td id="L2448" data-line-number="2448"></td>
        <td id="LC2448">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2449" data-line-number="2449"></td>
        <td id="LC2449">
</td>
      </tr>
      <tr>
        <td id="L2450" data-line-number="2450"></td>
        <td id="LC2450">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2451" data-line-number="2451"></td>
        <td id="LC2451">}</td>
      </tr>
      <tr>
        <td id="L2452" data-line-number="2452"></td>
        <td id="LC2452">
</td>
      </tr>
      <tr>
        <td id="L2453" data-line-number="2453"></td>
        <td id="LC2453">
</td>
      </tr>
      <tr>
        <td id="L2454" data-line-number="2454"></td>
        <td id="LC2454">COM_METHOD <span>CordbProcess::GetArrayLayout</span>(COR_TYPEID id, COR_ARRAY_LAYOUT *pLayout)</td>
      </tr>
      <tr>
        <td id="L2455" data-line-number="2455"></td>
        <td id="LC2455">{</td>
      </tr>
      <tr>
        <td id="L2456" data-line-number="2456"></td>
        <td id="LC2456">    <span>if</span> (pLayout == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L2457" data-line-number="2457"></td>
        <td id="LC2457">        <span>return</span> E_POINTER;</td>
      </tr>
      <tr>
        <td id="L2458" data-line-number="2458"></td>
        <td id="LC2458">
</td>
      </tr>
      <tr>
        <td id="L2459" data-line-number="2459"></td>
        <td id="LC2459">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2460" data-line-number="2460"></td>
        <td id="LC2460">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2461" data-line-number="2461"></td>
        <td id="LC2461">
</td>
      </tr>
      <tr>
        <td id="L2462" data-line-number="2462"></td>
        <td id="LC2462">    hr = <span>GetProcess</span>()-&gt;<span>GetDAC</span>()-&gt;<span>GetArrayLayout</span>(id, pLayout);</td>
      </tr>
      <tr>
        <td id="L2463" data-line-number="2463"></td>
        <td id="LC2463">
</td>
      </tr>
      <tr>
        <td id="L2464" data-line-number="2464"></td>
        <td id="LC2464">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2465" data-line-number="2465"></td>
        <td id="LC2465">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2466" data-line-number="2466"></td>
        <td id="LC2466">}</td>
      </tr>
      <tr>
        <td id="L2467" data-line-number="2467"></td>
        <td id="LC2467">
</td>
      </tr>
      <tr>
        <td id="L2468" data-line-number="2468"></td>
        <td id="LC2468">COM_METHOD <span>CordbProcess::GetTypeLayout</span>(COR_TYPEID id, COR_TYPE_LAYOUT *pLayout)</td>
      </tr>
      <tr>
        <td id="L2469" data-line-number="2469"></td>
        <td id="LC2469">{</td>
      </tr>
      <tr>
        <td id="L2470" data-line-number="2470"></td>
        <td id="LC2470">    <span>if</span> (pLayout == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L2471" data-line-number="2471"></td>
        <td id="LC2471">        <span>return</span> E_POINTER;</td>
      </tr>
      <tr>
        <td id="L2472" data-line-number="2472"></td>
        <td id="LC2472">
</td>
      </tr>
      <tr>
        <td id="L2473" data-line-number="2473"></td>
        <td id="LC2473">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2474" data-line-number="2474"></td>
        <td id="LC2474">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2475" data-line-number="2475"></td>
        <td id="LC2475">
</td>
      </tr>
      <tr>
        <td id="L2476" data-line-number="2476"></td>
        <td id="LC2476">    hr = <span>GetProcess</span>()-&gt;<span>GetDAC</span>()-&gt;<span>GetTypeLayout</span>(id, pLayout);</td>
      </tr>
      <tr>
        <td id="L2477" data-line-number="2477"></td>
        <td id="LC2477">
</td>
      </tr>
      <tr>
        <td id="L2478" data-line-number="2478"></td>
        <td id="LC2478">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2479" data-line-number="2479"></td>
        <td id="LC2479">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2480" data-line-number="2480"></td>
        <td id="LC2480">}</td>
      </tr>
      <tr>
        <td id="L2481" data-line-number="2481"></td>
        <td id="LC2481">
</td>
      </tr>
      <tr>
        <td id="L2482" data-line-number="2482"></td>
        <td id="LC2482">COM_METHOD <span>CordbProcess::GetTypeFields</span>(COR_TYPEID id, ULONG32 celt, COR_FIELD fields[], ULONG32 *pceltNeeded)</td>
      </tr>
      <tr>
        <td id="L2483" data-line-number="2483"></td>
        <td id="LC2483">{</td>
      </tr>
      <tr>
        <td id="L2484" data-line-number="2484"></td>
        <td id="LC2484">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2485" data-line-number="2485"></td>
        <td id="LC2485">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2486" data-line-number="2486"></td>
        <td id="LC2486">
</td>
      </tr>
      <tr>
        <td id="L2487" data-line-number="2487"></td>
        <td id="LC2487">    hr = <span>GetProcess</span>()-&gt;<span>GetDAC</span>()-&gt;<span>GetObjectFields</span>(id, celt, fields, pceltNeeded);</td>
      </tr>
      <tr>
        <td id="L2488" data-line-number="2488"></td>
        <td id="LC2488">
</td>
      </tr>
      <tr>
        <td id="L2489" data-line-number="2489"></td>
        <td id="LC2489">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2490" data-line-number="2490"></td>
        <td id="LC2490">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2491" data-line-number="2491"></td>
        <td id="LC2491">}</td>
      </tr>
      <tr>
        <td id="L2492" data-line-number="2492"></td>
        <td id="LC2492">
</td>
      </tr>
      <tr>
        <td id="L2493" data-line-number="2493"></td>
        <td id="LC2493">COM_METHOD <span>CordbProcess::SetWriteableMetadataUpdateMode</span>(WriteableMetadataUpdateMode flags)</td>
      </tr>
      <tr>
        <td id="L2494" data-line-number="2494"></td>
        <td id="LC2494">{</td>
      </tr>
      <tr>
        <td id="L2495" data-line-number="2495"></td>
        <td id="LC2495">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2496" data-line-number="2496"></td>
        <td id="LC2496">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2497" data-line-number="2497"></td>
        <td id="LC2497">
</td>
      </tr>
      <tr>
        <td id="L2498" data-line-number="2498"></td>
        <td id="LC2498">    <span>if</span>(flags != LegacyCompatPolicy &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L2499" data-line-number="2499"></td>
        <td id="LC2499">       flags != AlwaysShowUpdates)</td>
      </tr>
      <tr>
        <td id="L2500" data-line-number="2500"></td>
        <td id="LC2500">    {</td>
      </tr>
      <tr>
        <td id="L2501" data-line-number="2501"></td>
        <td id="LC2501">        hr = E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L2502" data-line-number="2502"></td>
        <td id="LC2502">    }</td>
      </tr>
      <tr>
        <td id="L2503" data-line-number="2503"></td>
        <td id="LC2503">    <span>else</span> <span>if</span>(m_pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L2504" data-line-number="2504"></td>
        <td id="LC2504">    {</td>
      </tr>
      <tr>
        <td id="L2505" data-line-number="2505"></td>
        <td id="LC2505">        <span>if</span>(flags != LegacyCompatPolicy)</td>
      </tr>
      <tr>
        <td id="L2506" data-line-number="2506"></td>
        <td id="LC2506">        {</td>
      </tr>
      <tr>
        <td id="L2507" data-line-number="2507"></td>
        <td id="LC2507">            hr = CORDBG_E_UNSUPPORTED;</td>
      </tr>
      <tr>
        <td id="L2508" data-line-number="2508"></td>
        <td id="LC2508">        }</td>
      </tr>
      <tr>
        <td id="L2509" data-line-number="2509"></td>
        <td id="LC2509">    }</td>
      </tr>
      <tr>
        <td id="L2510" data-line-number="2510"></td>
        <td id="LC2510">
</td>
      </tr>
      <tr>
        <td id="L2511" data-line-number="2511"></td>
        <td id="LC2511">    <span>if</span>(<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2512" data-line-number="2512"></td>
        <td id="LC2512">    {</td>
      </tr>
      <tr>
        <td id="L2513" data-line-number="2513"></td>
        <td id="LC2513">        m_writableMetadataUpdateMode = flags;</td>
      </tr>
      <tr>
        <td id="L2514" data-line-number="2514"></td>
        <td id="LC2514">    }</td>
      </tr>
      <tr>
        <td id="L2515" data-line-number="2515"></td>
        <td id="LC2515">
</td>
      </tr>
      <tr>
        <td id="L2516" data-line-number="2516"></td>
        <td id="LC2516">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2517" data-line-number="2517"></td>
        <td id="LC2517">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2518" data-line-number="2518"></td>
        <td id="LC2518">}</td>
      </tr>
      <tr>
        <td id="L2519" data-line-number="2519"></td>
        <td id="LC2519">
</td>
      </tr>
      <tr>
        <td id="L2520" data-line-number="2520"></td>
        <td id="LC2520">COM_METHOD <span>CordbProcess::EnableExceptionCallbacksOutsideOfMyCode</span>(BOOL enableExceptionsOutsideOfJMC)</td>
      </tr>
      <tr>
        <td id="L2521" data-line-number="2521"></td>
        <td id="LC2521">{</td>
      </tr>
      <tr>
        <td id="L2522" data-line-number="2522"></td>
        <td id="LC2522">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2523" data-line-number="2523"></td>
        <td id="LC2523">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2524" data-line-number="2524"></td>
        <td id="LC2524">
</td>
      </tr>
      <tr>
        <td id="L2525" data-line-number="2525"></td>
        <td id="LC2525">    hr = <span>GetProcess</span>()-&gt;<span>GetDAC</span>()-&gt;<span>SetSendExceptionsOutsideOfJMC</span>(enableExceptionsOutsideOfJMC);</td>
      </tr>
      <tr>
        <td id="L2526" data-line-number="2526"></td>
        <td id="LC2526">
</td>
      </tr>
      <tr>
        <td id="L2527" data-line-number="2527"></td>
        <td id="LC2527">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2528" data-line-number="2528"></td>
        <td id="LC2528">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2529" data-line-number="2529"></td>
        <td id="LC2529">}</td>
      </tr>
      <tr>
        <td id="L2530" data-line-number="2530"></td>
        <td id="LC2530">
</td>
      </tr>
      <tr>
        <td id="L2531" data-line-number="2531"></td>
        <td id="LC2531">COM_METHOD <span>CordbProcess::EnableGCNotificationEvents</span>(BOOL <span>fEnable</span>)</td>
      </tr>
      <tr>
        <td id="L2532" data-line-number="2532"></td>
        <td id="LC2532">{</td>
      </tr>
      <tr>
        <td id="L2533" data-line-number="2533"></td>
        <td id="LC2533">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2534" data-line-number="2534"></td>
        <td id="LC2534">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>)</td>
      </tr>
      <tr>
        <td id="L2535" data-line-number="2535"></td>
        <td id="LC2535">    {</td>
      </tr>
      <tr>
        <td id="L2536" data-line-number="2536"></td>
        <td id="LC2536">        hr = <span>this</span>-&gt;<span>m_pDacPrimitives</span>-&gt;<span>EnableGCNotificationEvents</span>(<span>fEnable</span>);</td>
      </tr>
      <tr>
        <td id="L2537" data-line-number="2537"></td>
        <td id="LC2537">    }</td>
      </tr>
      <tr>
        <td id="L2538" data-line-number="2538"></td>
        <td id="LC2538">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2539" data-line-number="2539"></td>
        <td id="LC2539">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2540" data-line-number="2540"></td>
        <td id="LC2540">}</td>
      </tr>
      <tr>
        <td id="L2541" data-line-number="2541"></td>
        <td id="LC2541">
</td>
      </tr>
      <tr>
        <td id="L2542" data-line-number="2542"></td>
        <td id="LC2542">HRESULT <span>CordbProcess::GetTypeForObject</span>(CORDB_ADDRESS addr, CordbAppDomain* pAppDomainOverride, CordbType **ppType, CordbAppDomain **pAppDomain)</td>
      </tr>
      <tr>
        <td id="L2543" data-line-number="2543"></td>
        <td id="LC2543">{</td>
      </tr>
      <tr>
        <td id="L2544" data-line-number="2544"></td>
        <td id="LC2544">    VMPTR_AppDomain appDomain;</td>
      </tr>
      <tr>
        <td id="L2545" data-line-number="2545"></td>
        <td id="LC2545">    VMPTR_Module mod;</td>
      </tr>
      <tr>
        <td id="L2546" data-line-number="2546"></td>
        <td id="LC2546">    VMPTR_DomainFile domainFile;</td>
      </tr>
      <tr>
        <td id="L2547" data-line-number="2547"></td>
        <td id="LC2547">
</td>
      </tr>
      <tr>
        <td id="L2548" data-line-number="2548"></td>
        <td id="LC2548">    HRESULT hr = E_FAIL;</td>
      </tr>
      <tr>
        <td id="L2549" data-line-number="2549"></td>
        <td id="LC2549">    <span>if</span> (<span>GetDAC</span>()-&gt;<span>GetAppDomainForObject</span>(addr, &amp;appDomain, &amp;mod, &amp;domainFile))</td>
      </tr>
      <tr>
        <td id="L2550" data-line-number="2550"></td>
        <td id="LC2550">    {</td>
      </tr>
      <tr>
        <td id="L2551" data-line-number="2551"></td>
        <td id="LC2551">        <span>if</span> (pAppDomainOverride)</td>
      </tr>
      <tr>
        <td id="L2552" data-line-number="2552"></td>
        <td id="LC2552">        {</td>
      </tr>
      <tr>
        <td id="L2553" data-line-number="2553"></td>
        <td id="LC2553">            appDomain = pAppDomainOverride-&gt;<span>GetADToken</span>();</td>
      </tr>
      <tr>
        <td id="L2554" data-line-number="2554"></td>
        <td id="LC2554">        }</td>
      </tr>
      <tr>
        <td id="L2555" data-line-number="2555"></td>
        <td id="LC2555">        CordbAppDomain *cdbAppDomain = appDomain.<span>IsNull</span>() ? <span>GetSharedAppDomain</span>() : <span>LookupOrCreateAppDomain</span>(appDomain);</td>
      </tr>
      <tr>
        <td id="L2556" data-line-number="2556"></td>
        <td id="LC2556">
</td>
      </tr>
      <tr>
        <td id="L2557" data-line-number="2557"></td>
        <td id="LC2557">        <span>_ASSERTE</span>(cdbAppDomain);</td>
      </tr>
      <tr>
        <td id="L2558" data-line-number="2558"></td>
        <td id="LC2558">
</td>
      </tr>
      <tr>
        <td id="L2559" data-line-number="2559"></td>
        <td id="LC2559">        DebuggerIPCE_ExpandedTypeData data;</td>
      </tr>
      <tr>
        <td id="L2560" data-line-number="2560"></td>
        <td id="LC2560">        <span>GetDAC</span>()-&gt;<span>GetObjectExpandedTypeInfo</span>(AllBoxed, appDomain, addr, &amp;data);</td>
      </tr>
      <tr>
        <td id="L2561" data-line-number="2561"></td>
        <td id="LC2561">
</td>
      </tr>
      <tr>
        <td id="L2562" data-line-number="2562"></td>
        <td id="LC2562">        CordbType *type = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2563" data-line-number="2563"></td>
        <td id="LC2563">        hr = <span>CordbType::TypeDataToType</span>(cdbAppDomain, &amp;data, &amp;type);</td>
      </tr>
      <tr>
        <td id="L2564" data-line-number="2564"></td>
        <td id="LC2564">
</td>
      </tr>
      <tr>
        <td id="L2565" data-line-number="2565"></td>
        <td id="LC2565">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2566" data-line-number="2566"></td>
        <td id="LC2566">        {</td>
      </tr>
      <tr>
        <td id="L2567" data-line-number="2567"></td>
        <td id="LC2567">            *ppType = type;</td>
      </tr>
      <tr>
        <td id="L2568" data-line-number="2568"></td>
        <td id="LC2568">            <span>if</span> (pAppDomain)</td>
      </tr>
      <tr>
        <td id="L2569" data-line-number="2569"></td>
        <td id="LC2569">                *pAppDomain = cdbAppDomain;</td>
      </tr>
      <tr>
        <td id="L2570" data-line-number="2570"></td>
        <td id="LC2570">        }</td>
      </tr>
      <tr>
        <td id="L2571" data-line-number="2571"></td>
        <td id="LC2571">    }</td>
      </tr>
      <tr>
        <td id="L2572" data-line-number="2572"></td>
        <td id="LC2572">
</td>
      </tr>
      <tr>
        <td id="L2573" data-line-number="2573"></td>
        <td id="LC2573">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2574" data-line-number="2574"></td>
        <td id="LC2574">}</td>
      </tr>
      <tr>
        <td id="L2575" data-line-number="2575"></td>
        <td id="LC2575">
</td>
      </tr>
      <tr>
        <td id="L2576" data-line-number="2576"></td>
        <td id="LC2576">
</td>
      </tr>
      <tr>
        <td id="L2577" data-line-number="2577"></td>
        <td id="LC2577"><span><span>//</span> ******************************************</span></td>
      </tr>
      <tr>
        <td id="L2578" data-line-number="2578"></td>
        <td id="LC2578"><span><span>//</span> CordbRefEnum</span></td>
      </tr>
      <tr>
        <td id="L2579" data-line-number="2579"></td>
        <td id="LC2579"><span><span>//</span> ******************************************</span></td>
      </tr>
      <tr>
        <td id="L2580" data-line-number="2580"></td>
        <td id="LC2580"><span>CordbRefEnum::CordbRefEnum</span>(CordbProcess *proc, BOOL walkWeakRefs)</td>
      </tr>
      <tr>
        <td id="L2581" data-line-number="2581"></td>
        <td id="LC2581">    : CordbBase(proc, <span>0</span>, enumCordbHeap), mRefHandle(<span>0</span>), mEnumStacksFQ(<span>TRUE</span>),</td>
      </tr>
      <tr>
        <td id="L2582" data-line-number="2582"></td>
        <td id="LC2582">      mHandleMask((UINT32)(walkWeakRefs ? CorHandleAll : CorHandleStrongOnly))</td>
      </tr>
      <tr>
        <td id="L2583" data-line-number="2583"></td>
        <td id="LC2583">{</td>
      </tr>
      <tr>
        <td id="L2584" data-line-number="2584"></td>
        <td id="LC2584">}</td>
      </tr>
      <tr>
        <td id="L2585" data-line-number="2585"></td>
        <td id="LC2585">
</td>
      </tr>
      <tr>
        <td id="L2586" data-line-number="2586"></td>
        <td id="LC2586"><span>CordbRefEnum::CordbRefEnum</span>(CordbProcess *proc, CorGCReferenceType types)</td>
      </tr>
      <tr>
        <td id="L2587" data-line-number="2587"></td>
        <td id="LC2587">    : CordbBase(proc, <span>0</span>, enumCordbHeap), mRefHandle(<span>0</span>), mEnumStacksFQ(<span>FALSE</span>),</td>
      </tr>
      <tr>
        <td id="L2588" data-line-number="2588"></td>
        <td id="LC2588">      mHandleMask((UINT32)types)</td>
      </tr>
      <tr>
        <td id="L2589" data-line-number="2589"></td>
        <td id="LC2589">{</td>
      </tr>
      <tr>
        <td id="L2590" data-line-number="2590"></td>
        <td id="LC2590">}</td>
      </tr>
      <tr>
        <td id="L2591" data-line-number="2591"></td>
        <td id="LC2591">
</td>
      </tr>
      <tr>
        <td id="L2592" data-line-number="2592"></td>
        <td id="LC2592"><span>void</span> <span>CordbRefEnum::Neuter</span>()</td>
      </tr>
      <tr>
        <td id="L2593" data-line-number="2593"></td>
        <td id="LC2593">{</td>
      </tr>
      <tr>
        <td id="L2594" data-line-number="2594"></td>
        <td id="LC2594">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2595" data-line-number="2595"></td>
        <td id="LC2595">    {</td>
      </tr>
      <tr>
        <td id="L2596" data-line-number="2596"></td>
        <td id="LC2596">        <span>if</span> (<span>mRefHandle</span>)</td>
      </tr>
      <tr>
        <td id="L2597" data-line-number="2597"></td>
        <td id="LC2597">        {</td>
      </tr>
      <tr>
        <td id="L2598" data-line-number="2598"></td>
        <td id="LC2598">            <span>GetProcess</span>()-&gt;<span>GetDAC</span>()-&gt;<span>DeleteRefWalk</span>(<span>mRefHandle</span>);</td>
      </tr>
      <tr>
        <td id="L2599" data-line-number="2599"></td>
        <td id="LC2599">            <span>mRefHandle</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2600" data-line-number="2600"></td>
        <td id="LC2600">        }</td>
      </tr>
      <tr>
        <td id="L2601" data-line-number="2601"></td>
        <td id="LC2601">    }</td>
      </tr>
      <tr>
        <td id="L2602" data-line-number="2602"></td>
        <td id="LC2602">    EX_CATCH</td>
      </tr>
      <tr>
        <td id="L2603" data-line-number="2603"></td>
        <td id="LC2603">    {</td>
      </tr>
      <tr>
        <td id="L2604" data-line-number="2604"></td>
        <td id="LC2604">        <span>_ASSERTE</span>(!<span><span>"</span>Hit an error freeing a ref walk.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2605" data-line-number="2605"></td>
        <td id="LC2605">    }</td>
      </tr>
      <tr>
        <td id="L2606" data-line-number="2606"></td>
        <td id="LC2606">    <span>EX_END_CATCH</span>(SwallowAllExceptions)</td>
      </tr>
      <tr>
        <td id="L2607" data-line-number="2607"></td>
        <td id="LC2607">
</td>
      </tr>
      <tr>
        <td id="L2608" data-line-number="2608"></td>
        <td id="LC2608">    <span>CordbBase::Neuter</span>();</td>
      </tr>
      <tr>
        <td id="L2609" data-line-number="2609"></td>
        <td id="LC2609">}</td>
      </tr>
      <tr>
        <td id="L2610" data-line-number="2610"></td>
        <td id="LC2610">
</td>
      </tr>
      <tr>
        <td id="L2611" data-line-number="2611"></td>
        <td id="LC2611">HRESULT <span>CordbRefEnum::QueryInterface</span>(REFIID riid, <span>void</span> **ppInterface)</td>
      </tr>
      <tr>
        <td id="L2612" data-line-number="2612"></td>
        <td id="LC2612">{</td>
      </tr>
      <tr>
        <td id="L2613" data-line-number="2613"></td>
        <td id="LC2613">    <span>if</span> (ppInterface == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L2614" data-line-number="2614"></td>
        <td id="LC2614">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L2615" data-line-number="2615"></td>
        <td id="LC2615">
</td>
      </tr>
      <tr>
        <td id="L2616" data-line-number="2616"></td>
        <td id="LC2616">    <span>if</span> (riid == IID_ICorDebugGCReferenceEnum)</td>
      </tr>
      <tr>
        <td id="L2617" data-line-number="2617"></td>
        <td id="LC2617">    {</td>
      </tr>
      <tr>
        <td id="L2618" data-line-number="2618"></td>
        <td id="LC2618">        *ppInterface = <span>static_cast</span>&lt;ICorDebugGCReferenceEnum*&gt;(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2619" data-line-number="2619"></td>
        <td id="LC2619">    }</td>
      </tr>
      <tr>
        <td id="L2620" data-line-number="2620"></td>
        <td id="LC2620">    <span>else</span> <span>if</span> (riid == IID_IUnknown)</td>
      </tr>
      <tr>
        <td id="L2621" data-line-number="2621"></td>
        <td id="LC2621">    {</td>
      </tr>
      <tr>
        <td id="L2622" data-line-number="2622"></td>
        <td id="LC2622">        *ppInterface = <span>static_cast</span>&lt;IUnknown*&gt;(<span>static_cast</span>&lt;ICorDebugGCReferenceEnum*&gt;(<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L2623" data-line-number="2623"></td>
        <td id="LC2623">    }</td>
      </tr>
      <tr>
        <td id="L2624" data-line-number="2624"></td>
        <td id="LC2624">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L2625" data-line-number="2625"></td>
        <td id="LC2625">    {</td>
      </tr>
      <tr>
        <td id="L2626" data-line-number="2626"></td>
        <td id="LC2626">        *ppInterface = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2627" data-line-number="2627"></td>
        <td id="LC2627">        <span>return</span> E_NOINTERFACE;</td>
      </tr>
      <tr>
        <td id="L2628" data-line-number="2628"></td>
        <td id="LC2628">    }</td>
      </tr>
      <tr>
        <td id="L2629" data-line-number="2629"></td>
        <td id="LC2629">
</td>
      </tr>
      <tr>
        <td id="L2630" data-line-number="2630"></td>
        <td id="LC2630">    <span>ExternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L2631" data-line-number="2631"></td>
        <td id="LC2631">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L2632" data-line-number="2632"></td>
        <td id="LC2632">}</td>
      </tr>
      <tr>
        <td id="L2633" data-line-number="2633"></td>
        <td id="LC2633">
</td>
      </tr>
      <tr>
        <td id="L2634" data-line-number="2634"></td>
        <td id="LC2634">HRESULT <span>CordbRefEnum::Skip</span>(ULONG celt)</td>
      </tr>
      <tr>
        <td id="L2635" data-line-number="2635"></td>
        <td id="LC2635">{</td>
      </tr>
      <tr>
        <td id="L2636" data-line-number="2636"></td>
        <td id="LC2636">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L2637" data-line-number="2637"></td>
        <td id="LC2637">}</td>
      </tr>
      <tr>
        <td id="L2638" data-line-number="2638"></td>
        <td id="LC2638">
</td>
      </tr>
      <tr>
        <td id="L2639" data-line-number="2639"></td>
        <td id="LC2639">HRESULT <span>CordbRefEnum::Reset</span>()</td>
      </tr>
      <tr>
        <td id="L2640" data-line-number="2640"></td>
        <td id="LC2640">{</td>
      </tr>
      <tr>
        <td id="L2641" data-line-number="2641"></td>
        <td id="LC2641">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2642" data-line-number="2642"></td>
        <td id="LC2642">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2643" data-line-number="2643"></td>
        <td id="LC2643">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2644" data-line-number="2644"></td>
        <td id="LC2644">    {</td>
      </tr>
      <tr>
        <td id="L2645" data-line-number="2645"></td>
        <td id="LC2645">        <span>if</span> (<span>mRefHandle</span>)</td>
      </tr>
      <tr>
        <td id="L2646" data-line-number="2646"></td>
        <td id="LC2646">        {</td>
      </tr>
      <tr>
        <td id="L2647" data-line-number="2647"></td>
        <td id="LC2647">            <span>GetProcess</span>()-&gt;<span>GetDAC</span>()-&gt;<span>DeleteRefWalk</span>(<span>mRefHandle</span>);</td>
      </tr>
      <tr>
        <td id="L2648" data-line-number="2648"></td>
        <td id="LC2648">            <span>mRefHandle</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2649" data-line-number="2649"></td>
        <td id="LC2649">        }</td>
      </tr>
      <tr>
        <td id="L2650" data-line-number="2650"></td>
        <td id="LC2650">    }</td>
      </tr>
      <tr>
        <td id="L2651" data-line-number="2651"></td>
        <td id="LC2651">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2652" data-line-number="2652"></td>
        <td id="LC2652">
</td>
      </tr>
      <tr>
        <td id="L2653" data-line-number="2653"></td>
        <td id="LC2653">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2654" data-line-number="2654"></td>
        <td id="LC2654">}</td>
      </tr>
      <tr>
        <td id="L2655" data-line-number="2655"></td>
        <td id="LC2655">
</td>
      </tr>
      <tr>
        <td id="L2656" data-line-number="2656"></td>
        <td id="LC2656">HRESULT <span>CordbRefEnum::Clone</span>(ICorDebugEnum **ppEnum)</td>
      </tr>
      <tr>
        <td id="L2657" data-line-number="2657"></td>
        <td id="LC2657">{</td>
      </tr>
      <tr>
        <td id="L2658" data-line-number="2658"></td>
        <td id="LC2658">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L2659" data-line-number="2659"></td>
        <td id="LC2659">}</td>
      </tr>
      <tr>
        <td id="L2660" data-line-number="2660"></td>
        <td id="LC2660">
</td>
      </tr>
      <tr>
        <td id="L2661" data-line-number="2661"></td>
        <td id="LC2661">HRESULT <span>CordbRefEnum::GetCount</span>(ULONG *pcelt)</td>
      </tr>
      <tr>
        <td id="L2662" data-line-number="2662"></td>
        <td id="LC2662">{</td>
      </tr>
      <tr>
        <td id="L2663" data-line-number="2663"></td>
        <td id="LC2663">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L2664" data-line-number="2664"></td>
        <td id="LC2664">}</td>
      </tr>
      <tr>
        <td id="L2665" data-line-number="2665"></td>
        <td id="LC2665">
</td>
      </tr>
      <tr>
        <td id="L2666" data-line-number="2666"></td>
        <td id="LC2666">
</td>
      </tr>
      <tr>
        <td id="L2667" data-line-number="2667"></td>
        <td id="LC2667"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2668" data-line-number="2668"></td>
        <td id="LC2668">
</td>
      </tr>
      <tr>
        <td id="L2669" data-line-number="2669"></td>
        <td id="LC2669">HRESULT <span>CordbRefEnum::Next</span>(ULONG celt, COR_GC_REFERENCE refs[], ULONG *pceltFetched)</td>
      </tr>
      <tr>
        <td id="L2670" data-line-number="2670"></td>
        <td id="LC2670">{</td>
      </tr>
      <tr>
        <td id="L2671" data-line-number="2671"></td>
        <td id="LC2671">    <span>if</span> (refs == <span>NULL</span> || pceltFetched == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L2672" data-line-number="2672"></td>
        <td id="LC2672">        <span>return</span> E_POINTER;</td>
      </tr>
      <tr>
        <td id="L2673" data-line-number="2673"></td>
        <td id="LC2673">
</td>
      </tr>
      <tr>
        <td id="L2674" data-line-number="2674"></td>
        <td id="LC2674">    CordbProcess *process = <span>GetProcess</span>();</td>
      </tr>
      <tr>
        <td id="L2675" data-line-number="2675"></td>
        <td id="LC2675">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2676" data-line-number="2676"></td>
        <td id="LC2676">
</td>
      </tr>
      <tr>
        <td id="L2677" data-line-number="2677"></td>
        <td id="LC2677">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2678" data-line-number="2678"></td>
        <td id="LC2678">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2679" data-line-number="2679"></td>
        <td id="LC2679">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(process);</td>
      </tr>
      <tr>
        <td id="L2680" data-line-number="2680"></td>
        <td id="LC2680">
</td>
      </tr>
      <tr>
        <td id="L2681" data-line-number="2681"></td>
        <td id="LC2681">    RSLockHolder <span>procLockHolder</span>(process-&gt;<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L2682" data-line-number="2682"></td>
        <td id="LC2682">
</td>
      </tr>
      <tr>
        <td id="L2683" data-line-number="2683"></td>
        <td id="LC2683">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2684" data-line-number="2684"></td>
        <td id="LC2684">    {</td>
      </tr>
      <tr>
        <td id="L2685" data-line-number="2685"></td>
        <td id="LC2685">        <span>if</span> (!<span>mRefHandle</span>)</td>
      </tr>
      <tr>
        <td id="L2686" data-line-number="2686"></td>
        <td id="LC2686">            hr = process-&gt;<span>GetDAC</span>()-&gt;<span>CreateRefWalk</span>(&amp;<span>mRefHandle</span>, <span>mEnumStacksFQ</span>, <span>mEnumStacksFQ</span>, <span>mHandleMask</span>);</td>
      </tr>
      <tr>
        <td id="L2687" data-line-number="2687"></td>
        <td id="LC2687">
</td>
      </tr>
      <tr>
        <td id="L2688" data-line-number="2688"></td>
        <td id="LC2688">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2689" data-line-number="2689"></td>
        <td id="LC2689">        {</td>
      </tr>
      <tr>
        <td id="L2690" data-line-number="2690"></td>
        <td id="LC2690">            DacGcReference dacRefs[<span>32</span>];</td>
      </tr>
      <tr>
        <td id="L2691" data-line-number="2691"></td>
        <td id="LC2691">            ULONG toFetch = <span>_countof</span>(dacRefs);</td>
      </tr>
      <tr>
        <td id="L2692" data-line-number="2692"></td>
        <td id="LC2692">            ULONG total = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2693" data-line-number="2693"></td>
        <td id="LC2693">
</td>
      </tr>
      <tr>
        <td id="L2694" data-line-number="2694"></td>
        <td id="LC2694">            <span>for</span> (ULONG c = <span>0</span>; <span>SUCCEEDED</span>(hr) &amp;&amp; c &lt; (celt/<span>_countof</span>(dacRefs) + <span>1</span>); ++c)</td>
      </tr>
      <tr>
        <td id="L2695" data-line-number="2695"></td>
        <td id="LC2695">            {</td>
      </tr>
      <tr>
        <td id="L2696" data-line-number="2696"></td>
        <td id="LC2696">                <span><span>//</span> Fetch 32 references at a time, the last time, only fetch the remainder (that is, if</span></td>
      </tr>
      <tr>
        <td id="L2697" data-line-number="2697"></td>
        <td id="LC2697">                <span><span>//</span> the user didn't fetch a multiple of 32).</span></td>
      </tr>
      <tr>
        <td id="L2698" data-line-number="2698"></td>
        <td id="LC2698">                <span>if</span> (c == celt/<span>_countof</span>(dacRefs))</td>
      </tr>
      <tr>
        <td id="L2699" data-line-number="2699"></td>
        <td id="LC2699">                    toFetch = celt % <span>_countof</span>(dacRefs);</td>
      </tr>
      <tr>
        <td id="L2700" data-line-number="2700"></td>
        <td id="LC2700">
</td>
      </tr>
      <tr>
        <td id="L2701" data-line-number="2701"></td>
        <td id="LC2701">                ULONG fetched = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2702" data-line-number="2702"></td>
        <td id="LC2702">                hr = process-&gt;<span>GetDAC</span>()-&gt;<span>WalkRefs</span>(<span>mRefHandle</span>, toFetch, dacRefs, &amp;fetched);</td>
      </tr>
      <tr>
        <td id="L2703" data-line-number="2703"></td>
        <td id="LC2703">
</td>
      </tr>
      <tr>
        <td id="L2704" data-line-number="2704"></td>
        <td id="LC2704">                <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2705" data-line-number="2705"></td>
        <td id="LC2705">                {</td>
      </tr>
      <tr>
        <td id="L2706" data-line-number="2706"></td>
        <td id="LC2706">                    <span>for</span> (ULONG i = <span>0</span>; i &lt; fetched; ++i)</td>
      </tr>
      <tr>
        <td id="L2707" data-line-number="2707"></td>
        <td id="LC2707">                    {</td>
      </tr>
      <tr>
        <td id="L2708" data-line-number="2708"></td>
        <td id="LC2708">                        CordbAppDomain *pDomain = process-&gt;<span>LookupOrCreateAppDomain</span>(dacRefs[i].<span>vmDomain</span>);</td>
      </tr>
      <tr>
        <td id="L2709" data-line-number="2709"></td>
        <td id="LC2709">
</td>
      </tr>
      <tr>
        <td id="L2710" data-line-number="2710"></td>
        <td id="LC2710">                        ICorDebugAppDomain *pAppDomain;</td>
      </tr>
      <tr>
        <td id="L2711" data-line-number="2711"></td>
        <td id="LC2711">                        ICorDebugValue *pOutObject = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2712" data-line-number="2712"></td>
        <td id="LC2712">                        <span>if</span> (dacRefs[i].<span>pObject</span> &amp; <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L2713" data-line-number="2713"></td>
        <td id="LC2713">                        {</td>
      </tr>
      <tr>
        <td id="L2714" data-line-number="2714"></td>
        <td id="LC2714">                            dacRefs[i].<span>pObject</span> &amp;= ~<span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2715" data-line-number="2715"></td>
        <td id="LC2715">                            ICorDebugObjectValue *pObjValue = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2716" data-line-number="2716"></td>
        <td id="LC2716">
</td>
      </tr>
      <tr>
        <td id="L2717" data-line-number="2717"></td>
        <td id="LC2717">                            hr = process-&gt;<span>GetObject</span>(dacRefs[i].<span>pObject</span>, &amp;pObjValue);</td>
      </tr>
      <tr>
        <td id="L2718" data-line-number="2718"></td>
        <td id="LC2718">
</td>
      </tr>
      <tr>
        <td id="L2719" data-line-number="2719"></td>
        <td id="LC2719">                            <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2720" data-line-number="2720"></td>
        <td id="LC2720">                            {</td>
      </tr>
      <tr>
        <td id="L2721" data-line-number="2721"></td>
        <td id="LC2721">                                hr = pObjValue-&gt;<span>QueryInterface</span>(IID_ICorDebugValue, (<span>void</span>**)&amp;pOutObject);</td>
      </tr>
      <tr>
        <td id="L2722" data-line-number="2722"></td>
        <td id="LC2722">                                pObjValue-&gt;<span>Release</span>();</td>
      </tr>
      <tr>
        <td id="L2723" data-line-number="2723"></td>
        <td id="LC2723">                            }</td>
      </tr>
      <tr>
        <td id="L2724" data-line-number="2724"></td>
        <td id="LC2724">                        }</td>
      </tr>
      <tr>
        <td id="L2725" data-line-number="2725"></td>
        <td id="LC2725">                        <span>else</span></td>
      </tr>
      <tr>
        <td id="L2726" data-line-number="2726"></td>
        <td id="LC2726">                        {</td>
      </tr>
      <tr>
        <td id="L2727" data-line-number="2727"></td>
        <td id="LC2727">                            ICorDebugReferenceValue *tmpValue = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2728" data-line-number="2728"></td>
        <td id="LC2728">                            <span>IfFailThrow</span>(<span>CordbReferenceValue::BuildFromGCHandle</span>(pDomain,</td>
      </tr>
      <tr>
        <td id="L2729" data-line-number="2729"></td>
        <td id="LC2729">                                                                   dacRefs[i].<span>objHnd</span>,</td>
      </tr>
      <tr>
        <td id="L2730" data-line-number="2730"></td>
        <td id="LC2730">                                                                   &amp;tmpValue));</td>
      </tr>
      <tr>
        <td id="L2731" data-line-number="2731"></td>
        <td id="LC2731">
</td>
      </tr>
      <tr>
        <td id="L2732" data-line-number="2732"></td>
        <td id="LC2732">                            <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2733" data-line-number="2733"></td>
        <td id="LC2733">                            {</td>
      </tr>
      <tr>
        <td id="L2734" data-line-number="2734"></td>
        <td id="LC2734">                                hr = tmpValue-&gt;<span>QueryInterface</span>(IID_ICorDebugValue, (<span>void</span>**)&amp;pOutObject);</td>
      </tr>
      <tr>
        <td id="L2735" data-line-number="2735"></td>
        <td id="LC2735">                                tmpValue-&gt;<span>Release</span>();</td>
      </tr>
      <tr>
        <td id="L2736" data-line-number="2736"></td>
        <td id="LC2736">                            }</td>
      </tr>
      <tr>
        <td id="L2737" data-line-number="2737"></td>
        <td id="LC2737">                        }</td>
      </tr>
      <tr>
        <td id="L2738" data-line-number="2738"></td>
        <td id="LC2738">
</td>
      </tr>
      <tr>
        <td id="L2739" data-line-number="2739"></td>
        <td id="LC2739">                        <span>if</span> (<span>SUCCEEDED</span>(hr) &amp;&amp; pDomain)</td>
      </tr>
      <tr>
        <td id="L2740" data-line-number="2740"></td>
        <td id="LC2740">                        {</td>
      </tr>
      <tr>
        <td id="L2741" data-line-number="2741"></td>
        <td id="LC2741">                            hr = pDomain-&gt;<span>QueryInterface</span>(IID_ICorDebugAppDomain, (<span>void</span>**)&amp;pAppDomain);</td>
      </tr>
      <tr>
        <td id="L2742" data-line-number="2742"></td>
        <td id="LC2742">                        }</td>
      </tr>
      <tr>
        <td id="L2743" data-line-number="2743"></td>
        <td id="LC2743">
</td>
      </tr>
      <tr>
        <td id="L2744" data-line-number="2744"></td>
        <td id="LC2744">                        <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2745" data-line-number="2745"></td>
        <td id="LC2745">                            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2746" data-line-number="2746"></td>
        <td id="LC2746">
</td>
      </tr>
      <tr>
        <td id="L2747" data-line-number="2747"></td>
        <td id="LC2747">                        refs[total].<span>Domain</span> = pAppDomain;</td>
      </tr>
      <tr>
        <td id="L2748" data-line-number="2748"></td>
        <td id="LC2748">                        refs[total].<span>Location</span> = pOutObject;</td>
      </tr>
      <tr>
        <td id="L2749" data-line-number="2749"></td>
        <td id="LC2749">                        refs[total].<span>Type</span> = (CorGCReferenceType)dacRefs[i].<span>dwType</span>;</td>
      </tr>
      <tr>
        <td id="L2750" data-line-number="2750"></td>
        <td id="LC2750">                        refs[total].<span>ExtraData</span> = dacRefs[i].<span>i64ExtraData</span>;</td>
      </tr>
      <tr>
        <td id="L2751" data-line-number="2751"></td>
        <td id="LC2751">
</td>
      </tr>
      <tr>
        <td id="L2752" data-line-number="2752"></td>
        <td id="LC2752">                        total++;</td>
      </tr>
      <tr>
        <td id="L2753" data-line-number="2753"></td>
        <td id="LC2753">                    }</td>
      </tr>
      <tr>
        <td id="L2754" data-line-number="2754"></td>
        <td id="LC2754">                }</td>
      </tr>
      <tr>
        <td id="L2755" data-line-number="2755"></td>
        <td id="LC2755">            }</td>
      </tr>
      <tr>
        <td id="L2756" data-line-number="2756"></td>
        <td id="LC2756">
</td>
      </tr>
      <tr>
        <td id="L2757" data-line-number="2757"></td>
        <td id="LC2757">            *pceltFetched = total;</td>
      </tr>
      <tr>
        <td id="L2758" data-line-number="2758"></td>
        <td id="LC2758">        }</td>
      </tr>
      <tr>
        <td id="L2759" data-line-number="2759"></td>
        <td id="LC2759">    }</td>
      </tr>
      <tr>
        <td id="L2760" data-line-number="2760"></td>
        <td id="LC2760">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2761" data-line-number="2761"></td>
        <td id="LC2761">
</td>
      </tr>
      <tr>
        <td id="L2762" data-line-number="2762"></td>
        <td id="LC2762">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2763" data-line-number="2763"></td>
        <td id="LC2763">}</td>
      </tr>
      <tr>
        <td id="L2764" data-line-number="2764"></td>
        <td id="LC2764">
</td>
      </tr>
      <tr>
        <td id="L2765" data-line-number="2765"></td>
        <td id="LC2765">
</td>
      </tr>
      <tr>
        <td id="L2766" data-line-number="2766"></td>
        <td id="LC2766"><span><span>//</span> ******************************************</span></td>
      </tr>
      <tr>
        <td id="L2767" data-line-number="2767"></td>
        <td id="LC2767"><span><span>//</span> CordbHeapEnum</span></td>
      </tr>
      <tr>
        <td id="L2768" data-line-number="2768"></td>
        <td id="LC2768"><span><span>//</span> ******************************************</span></td>
      </tr>
      <tr>
        <td id="L2769" data-line-number="2769"></td>
        <td id="LC2769"><span>CordbHeapEnum::CordbHeapEnum</span>(CordbProcess *proc)</td>
      </tr>
      <tr>
        <td id="L2770" data-line-number="2770"></td>
        <td id="LC2770">    : CordbBase(proc, <span>0</span>, enumCordbHeap), mHeapHandle(<span>0</span>)</td>
      </tr>
      <tr>
        <td id="L2771" data-line-number="2771"></td>
        <td id="LC2771">{</td>
      </tr>
      <tr>
        <td id="L2772" data-line-number="2772"></td>
        <td id="LC2772">}</td>
      </tr>
      <tr>
        <td id="L2773" data-line-number="2773"></td>
        <td id="LC2773">
</td>
      </tr>
      <tr>
        <td id="L2774" data-line-number="2774"></td>
        <td id="LC2774">HRESULT <span>CordbHeapEnum::QueryInterface</span>(REFIID riid, <span>void</span> **ppInterface)</td>
      </tr>
      <tr>
        <td id="L2775" data-line-number="2775"></td>
        <td id="LC2775">{</td>
      </tr>
      <tr>
        <td id="L2776" data-line-number="2776"></td>
        <td id="LC2776">    <span>if</span> (ppInterface == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L2777" data-line-number="2777"></td>
        <td id="LC2777">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L2778" data-line-number="2778"></td>
        <td id="LC2778">
</td>
      </tr>
      <tr>
        <td id="L2779" data-line-number="2779"></td>
        <td id="LC2779">    <span>if</span> (riid == IID_ICorDebugHeapEnum)</td>
      </tr>
      <tr>
        <td id="L2780" data-line-number="2780"></td>
        <td id="LC2780">    {</td>
      </tr>
      <tr>
        <td id="L2781" data-line-number="2781"></td>
        <td id="LC2781">        *ppInterface = <span>static_cast</span>&lt;ICorDebugHeapEnum*&gt;(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2782" data-line-number="2782"></td>
        <td id="LC2782">    }</td>
      </tr>
      <tr>
        <td id="L2783" data-line-number="2783"></td>
        <td id="LC2783">    <span>else</span> <span>if</span> (riid == IID_IUnknown)</td>
      </tr>
      <tr>
        <td id="L2784" data-line-number="2784"></td>
        <td id="LC2784">    {</td>
      </tr>
      <tr>
        <td id="L2785" data-line-number="2785"></td>
        <td id="LC2785">        *ppInterface = <span>static_cast</span>&lt;IUnknown*&gt;(<span>static_cast</span>&lt;ICorDebugHeapEnum*&gt;(<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L2786" data-line-number="2786"></td>
        <td id="LC2786">    }</td>
      </tr>
      <tr>
        <td id="L2787" data-line-number="2787"></td>
        <td id="LC2787">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L2788" data-line-number="2788"></td>
        <td id="LC2788">    {</td>
      </tr>
      <tr>
        <td id="L2789" data-line-number="2789"></td>
        <td id="LC2789">        *ppInterface = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2790" data-line-number="2790"></td>
        <td id="LC2790">        <span>return</span> E_NOINTERFACE;</td>
      </tr>
      <tr>
        <td id="L2791" data-line-number="2791"></td>
        <td id="LC2791">    }</td>
      </tr>
      <tr>
        <td id="L2792" data-line-number="2792"></td>
        <td id="LC2792">
</td>
      </tr>
      <tr>
        <td id="L2793" data-line-number="2793"></td>
        <td id="LC2793">    <span>ExternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L2794" data-line-number="2794"></td>
        <td id="LC2794">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L2795" data-line-number="2795"></td>
        <td id="LC2795">}</td>
      </tr>
      <tr>
        <td id="L2796" data-line-number="2796"></td>
        <td id="LC2796">
</td>
      </tr>
      <tr>
        <td id="L2797" data-line-number="2797"></td>
        <td id="LC2797">HRESULT <span>CordbHeapEnum::Skip</span>(ULONG celt)</td>
      </tr>
      <tr>
        <td id="L2798" data-line-number="2798"></td>
        <td id="LC2798">{</td>
      </tr>
      <tr>
        <td id="L2799" data-line-number="2799"></td>
        <td id="LC2799">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L2800" data-line-number="2800"></td>
        <td id="LC2800">}</td>
      </tr>
      <tr>
        <td id="L2801" data-line-number="2801"></td>
        <td id="LC2801">
</td>
      </tr>
      <tr>
        <td id="L2802" data-line-number="2802"></td>
        <td id="LC2802">HRESULT <span>CordbHeapEnum::Reset</span>()</td>
      </tr>
      <tr>
        <td id="L2803" data-line-number="2803"></td>
        <td id="LC2803">{</td>
      </tr>
      <tr>
        <td id="L2804" data-line-number="2804"></td>
        <td id="LC2804">    <span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L2805" data-line-number="2805"></td>
        <td id="LC2805">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L2806" data-line-number="2806"></td>
        <td id="LC2806">}</td>
      </tr>
      <tr>
        <td id="L2807" data-line-number="2807"></td>
        <td id="LC2807">
</td>
      </tr>
      <tr>
        <td id="L2808" data-line-number="2808"></td>
        <td id="LC2808"><span>void</span> <span>CordbHeapEnum::Clear</span>()</td>
      </tr>
      <tr>
        <td id="L2809" data-line-number="2809"></td>
        <td id="LC2809">{</td>
      </tr>
      <tr>
        <td id="L2810" data-line-number="2810"></td>
        <td id="LC2810">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2811" data-line-number="2811"></td>
        <td id="LC2811">    {</td>
      </tr>
      <tr>
        <td id="L2812" data-line-number="2812"></td>
        <td id="LC2812">        <span>if</span> (<span>mHeapHandle</span>)</td>
      </tr>
      <tr>
        <td id="L2813" data-line-number="2813"></td>
        <td id="LC2813">        {</td>
      </tr>
      <tr>
        <td id="L2814" data-line-number="2814"></td>
        <td id="LC2814">            <span>GetProcess</span>()-&gt;<span>GetDAC</span>()-&gt;<span>DeleteHeapWalk</span>(<span>mHeapHandle</span>);</td>
      </tr>
      <tr>
        <td id="L2815" data-line-number="2815"></td>
        <td id="LC2815">            <span>mHeapHandle</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2816" data-line-number="2816"></td>
        <td id="LC2816">        }</td>
      </tr>
      <tr>
        <td id="L2817" data-line-number="2817"></td>
        <td id="LC2817">    }</td>
      </tr>
      <tr>
        <td id="L2818" data-line-number="2818"></td>
        <td id="LC2818">    EX_CATCH</td>
      </tr>
      <tr>
        <td id="L2819" data-line-number="2819"></td>
        <td id="LC2819">    {</td>
      </tr>
      <tr>
        <td id="L2820" data-line-number="2820"></td>
        <td id="LC2820">        <span>_ASSERTE</span>(!<span><span>"</span>Hit an error freeing the heap walk.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2821" data-line-number="2821"></td>
        <td id="LC2821">    }</td>
      </tr>
      <tr>
        <td id="L2822" data-line-number="2822"></td>
        <td id="LC2822">    <span>EX_END_CATCH</span>(SwallowAllExceptions)</td>
      </tr>
      <tr>
        <td id="L2823" data-line-number="2823"></td>
        <td id="LC2823">}</td>
      </tr>
      <tr>
        <td id="L2824" data-line-number="2824"></td>
        <td id="LC2824">
</td>
      </tr>
      <tr>
        <td id="L2825" data-line-number="2825"></td>
        <td id="LC2825">HRESULT <span>CordbHeapEnum::Clone</span>(ICorDebugEnum **ppEnum)</td>
      </tr>
      <tr>
        <td id="L2826" data-line-number="2826"></td>
        <td id="LC2826">{</td>
      </tr>
      <tr>
        <td id="L2827" data-line-number="2827"></td>
        <td id="LC2827">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L2828" data-line-number="2828"></td>
        <td id="LC2828">}</td>
      </tr>
      <tr>
        <td id="L2829" data-line-number="2829"></td>
        <td id="LC2829">
</td>
      </tr>
      <tr>
        <td id="L2830" data-line-number="2830"></td>
        <td id="LC2830">HRESULT <span>CordbHeapEnum::GetCount</span>(ULONG *pcelt)</td>
      </tr>
      <tr>
        <td id="L2831" data-line-number="2831"></td>
        <td id="LC2831">{</td>
      </tr>
      <tr>
        <td id="L2832" data-line-number="2832"></td>
        <td id="LC2832">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L2833" data-line-number="2833"></td>
        <td id="LC2833">}</td>
      </tr>
      <tr>
        <td id="L2834" data-line-number="2834"></td>
        <td id="LC2834">
</td>
      </tr>
      <tr>
        <td id="L2835" data-line-number="2835"></td>
        <td id="LC2835">HRESULT <span>CordbHeapEnum::Next</span>(ULONG celt, COR_HEAPOBJECT objects[], ULONG *pceltFetched)</td>
      </tr>
      <tr>
        <td id="L2836" data-line-number="2836"></td>
        <td id="LC2836">{</td>
      </tr>
      <tr>
        <td id="L2837" data-line-number="2837"></td>
        <td id="LC2837">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2838" data-line-number="2838"></td>
        <td id="LC2838">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2839" data-line-number="2839"></td>
        <td id="LC2839">    RSLockHolder <span>stopGoLock</span>(<span>this</span>-&gt;<span>GetProcess</span>()-&gt;<span>GetStopGoLock</span>());</td>
      </tr>
      <tr>
        <td id="L2840" data-line-number="2840"></td>
        <td id="LC2840">    RSLockHolder <span>procLock</span>(<span>this</span>-&gt;<span>GetProcess</span>()-&gt;<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L2841" data-line-number="2841"></td>
        <td id="LC2841">    ULONG fetched = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2842" data-line-number="2842"></td>
        <td id="LC2842">
</td>
      </tr>
      <tr>
        <td id="L2843" data-line-number="2843"></td>
        <td id="LC2843">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L2844" data-line-number="2844"></td>
        <td id="LC2844">    {</td>
      </tr>
      <tr>
        <td id="L2845" data-line-number="2845"></td>
        <td id="LC2845">        <span>if</span> (<span>mHeapHandle</span> == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L2846" data-line-number="2846"></td>
        <td id="LC2846">        {</td>
      </tr>
      <tr>
        <td id="L2847" data-line-number="2847"></td>
        <td id="LC2847">            hr = <span>GetProcess</span>()-&gt;<span>GetDAC</span>()-&gt;<span>CreateHeapWalk</span>(&amp;<span>mHeapHandle</span>);</td>
      </tr>
      <tr>
        <td id="L2848" data-line-number="2848"></td>
        <td id="LC2848">        }</td>
      </tr>
      <tr>
        <td id="L2849" data-line-number="2849"></td>
        <td id="LC2849">
</td>
      </tr>
      <tr>
        <td id="L2850" data-line-number="2850"></td>
        <td id="LC2850">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2851" data-line-number="2851"></td>
        <td id="LC2851">        {</td>
      </tr>
      <tr>
        <td id="L2852" data-line-number="2852"></td>
        <td id="LC2852">            hr = <span>GetProcess</span>()-&gt;<span>GetDAC</span>()-&gt;<span>WalkHeap</span>(<span>mHeapHandle</span>, celt, objects, &amp;fetched);</td>
      </tr>
      <tr>
        <td id="L2853" data-line-number="2853"></td>
        <td id="LC2853">            <span>_ASSERTE</span>(fetched &lt;= celt);</td>
      </tr>
      <tr>
        <td id="L2854" data-line-number="2854"></td>
        <td id="LC2854">        }</td>
      </tr>
      <tr>
        <td id="L2855" data-line-number="2855"></td>
        <td id="LC2855">
</td>
      </tr>
      <tr>
        <td id="L2856" data-line-number="2856"></td>
        <td id="LC2856">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2857" data-line-number="2857"></td>
        <td id="LC2857">        {</td>
      </tr>
      <tr>
        <td id="L2858" data-line-number="2858"></td>
        <td id="LC2858">            <span><span>//</span> Return S_FALSE if we've reached the end of the enum.</span></td>
      </tr>
      <tr>
        <td id="L2859" data-line-number="2859"></td>
        <td id="LC2859">            <span>if</span> (fetched &lt; celt)</td>
      </tr>
      <tr>
        <td id="L2860" data-line-number="2860"></td>
        <td id="LC2860">                hr = S_FALSE;</td>
      </tr>
      <tr>
        <td id="L2861" data-line-number="2861"></td>
        <td id="LC2861">        }</td>
      </tr>
      <tr>
        <td id="L2862" data-line-number="2862"></td>
        <td id="LC2862">    }</td>
      </tr>
      <tr>
        <td id="L2863" data-line-number="2863"></td>
        <td id="LC2863">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2864" data-line-number="2864"></td>
        <td id="LC2864">
</td>
      </tr>
      <tr>
        <td id="L2865" data-line-number="2865"></td>
        <td id="LC2865">    <span><span>//</span> Set the fetched parameter to reflect the number of elements (if any)</span></td>
      </tr>
      <tr>
        <td id="L2866" data-line-number="2866"></td>
        <td id="LC2866">    <span><span>//</span> that were successfully saved to "objects"</span></td>
      </tr>
      <tr>
        <td id="L2867" data-line-number="2867"></td>
        <td id="LC2867">    <span>if</span> (pceltFetched)</td>
      </tr>
      <tr>
        <td id="L2868" data-line-number="2868"></td>
        <td id="LC2868">        *pceltFetched = fetched;</td>
      </tr>
      <tr>
        <td id="L2869" data-line-number="2869"></td>
        <td id="LC2869">
</td>
      </tr>
      <tr>
        <td id="L2870" data-line-number="2870"></td>
        <td id="LC2870">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2871" data-line-number="2871"></td>
        <td id="LC2871">}</td>
      </tr>
      <tr>
        <td id="L2872" data-line-number="2872"></td>
        <td id="LC2872">
</td>
      </tr>
      <tr>
        <td id="L2873" data-line-number="2873"></td>
        <td id="LC2873"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2874" data-line-number="2874"></td>
        <td id="LC2874"><span><span>//</span> Flush state for when the process starts running.</span></td>
      </tr>
      <tr>
        <td id="L2875" data-line-number="2875"></td>
        <td id="LC2875"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2876" data-line-number="2876"></td>
        <td id="LC2876"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2877" data-line-number="2877"></td>
        <td id="LC2877"><span><span>//</span>   Helper for code:CordbProcess::ProcessStateChanged.</span></td>
      </tr>
      <tr>
        <td id="L2878" data-line-number="2878"></td>
        <td id="LC2878"><span><span>//</span>   Since ICD Arrowhead does not own the eventing pipeline, it needs the debugger to</span></td>
      </tr>
      <tr>
        <td id="L2879" data-line-number="2879"></td>
        <td id="LC2879"><span><span>//</span>   notifying it of when the process is running again.  This is like the counterpart</span></td>
      </tr>
      <tr>
        <td id="L2880" data-line-number="2880"></td>
        <td id="LC2880"><span><span>//</span>   to code:CordbProcess::Filter</span></td>
      </tr>
      <tr>
        <td id="L2881" data-line-number="2881"></td>
        <td id="LC2881"><span>void</span> <span>CordbProcess::FlushProcessRunning</span>()</td>
      </tr>
      <tr>
        <td id="L2882" data-line-number="2882"></td>
        <td id="LC2882">{</td>
      </tr>
      <tr>
        <td id="L2883" data-line-number="2883"></td>
        <td id="LC2883">    <span>_ASSERTE</span>(<span>GetProcessLock</span>()-&gt;<span>HasLock</span>());</td>
      </tr>
      <tr>
        <td id="L2884" data-line-number="2884"></td>
        <td id="LC2884">
</td>
      </tr>
      <tr>
        <td id="L2885" data-line-number="2885"></td>
        <td id="LC2885">    <span><span>//</span> Update the continue counter.</span></td>
      </tr>
      <tr>
        <td id="L2886" data-line-number="2886"></td>
        <td id="LC2886">    m_continueCounter++;</td>
      </tr>
      <tr>
        <td id="L2887" data-line-number="2887"></td>
        <td id="LC2887">
</td>
      </tr>
      <tr>
        <td id="L2888" data-line-number="2888"></td>
        <td id="LC2888">    <span><span>//</span> Safely dispose anything that should be neutered on continue.</span></td>
      </tr>
      <tr>
        <td id="L2889" data-line-number="2889"></td>
        <td id="LC2889">    <span>MarkAllThreadsDirty</span>();</td>
      </tr>
      <tr>
        <td id="L2890" data-line-number="2890"></td>
        <td id="LC2890">    <span>ForceDacFlush</span>();</td>
      </tr>
      <tr>
        <td id="L2891" data-line-number="2891"></td>
        <td id="LC2891">}</td>
      </tr>
      <tr>
        <td id="L2892" data-line-number="2892"></td>
        <td id="LC2892">
</td>
      </tr>
      <tr>
        <td id="L2893" data-line-number="2893"></td>
        <td id="LC2893"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2894" data-line-number="2894"></td>
        <td id="LC2894"><span><span>//</span> Flush all cached state and bring us back to "cold startup"</span></td>
      </tr>
      <tr>
        <td id="L2895" data-line-number="2895"></td>
        <td id="LC2895"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2896" data-line-number="2896"></td>
        <td id="LC2896"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2897" data-line-number="2897"></td>
        <td id="LC2897"><span><span>//</span>   Helper for code:CordbProcess::ProcessStateChanged.</span></td>
      </tr>
      <tr>
        <td id="L2898" data-line-number="2898"></td>
        <td id="LC2898"><span><span>//</span>   This is used if the data-target changes underneath us in a way that is</span></td>
      </tr>
      <tr>
        <td id="L2899" data-line-number="2899"></td>
        <td id="LC2899"><span><span>//</span>   not consistent with the process running forward. For example, if for</span></td>
      </tr>
      <tr>
        <td id="L2900" data-line-number="2900"></td>
        <td id="LC2900"><span><span>//</span>   a time-travel debugger, the data-target may flow "backwards" in time.</span></td>
      </tr>
      <tr>
        <td id="L2901" data-line-number="2901"></td>
        <td id="LC2901"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2902" data-line-number="2902"></td>
        <td id="LC2902"><span>void</span> <span>CordbProcess::FlushAll</span>()</td>
      </tr>
      <tr>
        <td id="L2903" data-line-number="2903"></td>
        <td id="LC2903">{</td>
      </tr>
      <tr>
        <td id="L2904" data-line-number="2904"></td>
        <td id="LC2904">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L2905" data-line-number="2905"></td>
        <td id="LC2905">    {</td>
      </tr>
      <tr>
        <td id="L2906" data-line-number="2906"></td>
        <td id="LC2906">        THROWS;</td>
      </tr>
      <tr>
        <td id="L2907" data-line-number="2907"></td>
        <td id="LC2907">    }</td>
      </tr>
      <tr>
        <td id="L2908" data-line-number="2908"></td>
        <td id="LC2908">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L2909" data-line-number="2909"></td>
        <td id="LC2909">
</td>
      </tr>
      <tr>
        <td id="L2910" data-line-number="2910"></td>
        <td id="LC2910">    HRESULT hr;</td>
      </tr>
      <tr>
        <td id="L2911" data-line-number="2911"></td>
        <td id="LC2911">    <span>_ASSERTE</span>(<span>GetProcessLock</span>()-&gt;<span>HasLock</span>());</td>
      </tr>
      <tr>
        <td id="L2912" data-line-number="2912"></td>
        <td id="LC2912">
</td>
      </tr>
      <tr>
        <td id="L2913" data-line-number="2913"></td>
        <td id="LC2913">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2914" data-line-number="2914"></td>
        <td id="LC2914">    <span><span>//</span> First, determine if it's safe to Flush</span></td>
      </tr>
      <tr>
        <td id="L2915" data-line-number="2915"></td>
        <td id="LC2915">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2916" data-line-number="2916"></td>
        <td id="LC2916">
</td>
      </tr>
      <tr>
        <td id="L2917" data-line-number="2917"></td>
        <td id="LC2917">    hr = <span>IsReadyForDetach</span>();</td>
      </tr>
      <tr>
        <td id="L2918" data-line-number="2918"></td>
        <td id="LC2918">    <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L2919" data-line-number="2919"></td>
        <td id="LC2919">
</td>
      </tr>
      <tr>
        <td id="L2920" data-line-number="2920"></td>
        <td id="LC2920">    <span><span>//</span> Check for outstanding CordbHandle values.</span></td>
      </tr>
      <tr>
        <td id="L2921" data-line-number="2921"></td>
        <td id="LC2921">    <span>if</span> (<span>OutstandingHandles</span>())</td>
      </tr>
      <tr>
        <td id="L2922" data-line-number="2922"></td>
        <td id="LC2922">    {</td>
      </tr>
      <tr>
        <td id="L2923" data-line-number="2923"></td>
        <td id="LC2923">        <span>ThrowHR</span>(CORDBG_E_DETACH_FAILED_OUTSTANDING_TARGET_RESOURCES);</td>
      </tr>
      <tr>
        <td id="L2924" data-line-number="2924"></td>
        <td id="LC2924">    }</td>
      </tr>
      <tr>
        <td id="L2925" data-line-number="2925"></td>
        <td id="LC2925">
</td>
      </tr>
      <tr>
        <td id="L2926" data-line-number="2926"></td>
        <td id="LC2926">    <span><span>//</span> FlushAll is a superset of FlushProcessRunning.</span></td>
      </tr>
      <tr>
        <td id="L2927" data-line-number="2927"></td>
        <td id="LC2927">    <span><span>//</span> This will also ensure we clear the DAC cache.</span></td>
      </tr>
      <tr>
        <td id="L2928" data-line-number="2928"></td>
        <td id="LC2928">    <span>FlushProcessRunning</span>();</td>
      </tr>
      <tr>
        <td id="L2929" data-line-number="2929"></td>
        <td id="LC2929">
</td>
      </tr>
      <tr>
        <td id="L2930" data-line-number="2930"></td>
        <td id="LC2930">    <span><span>//</span> If we detach before the CLR is loaded into the debuggee, then we can no-op a lot of work.</span></td>
      </tr>
      <tr>
        <td id="L2931" data-line-number="2931"></td>
        <td id="LC2931">    <span><span>//</span> We sure can't be sending IPC events to the LS before it exists.</span></td>
      </tr>
      <tr>
        <td id="L2932" data-line-number="2932"></td>
        <td id="LC2932">    <span>NeuterChildren</span>();</td>
      </tr>
      <tr>
        <td id="L2933" data-line-number="2933"></td>
        <td id="LC2933">}</td>
      </tr>
      <tr>
        <td id="L2934" data-line-number="2934"></td>
        <td id="LC2934">
</td>
      </tr>
      <tr>
        <td id="L2935" data-line-number="2935"></td>
        <td id="LC2935"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2936" data-line-number="2936"></td>
        <td id="LC2936"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2937" data-line-number="2937"></td>
        <td id="LC2937"><span><span>//</span> Detach the Debugger from the LS process.</span></td>
      </tr>
      <tr>
        <td id="L2938" data-line-number="2938"></td>
        <td id="LC2938"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2939" data-line-number="2939"></td>
        <td id="LC2939"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2940" data-line-number="2940"></td>
        <td id="LC2940"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L2941" data-line-number="2941"></td>
        <td id="LC2941"><span><span>//</span>    S_OK on successful detach. Else errror.</span></td>
      </tr>
      <tr>
        <td id="L2942" data-line-number="2942"></td>
        <td id="LC2942"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2943" data-line-number="2943"></td>
        <td id="LC2943"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L2944" data-line-number="2944"></td>
        <td id="LC2944"><span><span>//</span>    Target is stopped.</span></td>
      </tr>
      <tr>
        <td id="L2945" data-line-number="2945"></td>
        <td id="LC2945"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2946" data-line-number="2946"></td>
        <td id="LC2946"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2947" data-line-number="2947"></td>
        <td id="LC2947"><span><span>//</span>    Once we're detached, the LS can resume running and exit.</span></td>
      </tr>
      <tr>
        <td id="L2948" data-line-number="2948"></td>
        <td id="LC2948"><span><span>//</span>    So it's possible to get an ExitProcess callback in the middle of the Detach phase. If that happens,</span></td>
      </tr>
      <tr>
        <td id="L2949" data-line-number="2949"></td>
        <td id="LC2949"><span><span>//</span>    we must return CORDBG_E_PROCESS_TERMINATED and pretend that the exit happened before we tried to detach.</span></td>
      </tr>
      <tr>
        <td id="L2950" data-line-number="2950"></td>
        <td id="LC2950"><span><span>//</span>    Else if we detach successfully, return S_OK.</span></td>
      </tr>
      <tr>
        <td id="L2951" data-line-number="2951"></td>
        <td id="LC2951"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2952" data-line-number="2952"></td>
        <td id="LC2952"><span><span>//</span>    @dbgtodo attach-bit: need to figure out semantics of Detach</span></td>
      </tr>
      <tr>
        <td id="L2953" data-line-number="2953"></td>
        <td id="LC2953"><span><span>//</span>    in V3, especially w.r.t to an attach bit.</span></td>
      </tr>
      <tr>
        <td id="L2954" data-line-number="2954"></td>
        <td id="LC2954"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2955" data-line-number="2955"></td>
        <td id="LC2955">HRESULT <span>CordbProcess::Detach</span>()</td>
      </tr>
      <tr>
        <td id="L2956" data-line-number="2956"></td>
        <td id="LC2956">{</td>
      </tr>
      <tr>
        <td id="L2957" data-line-number="2957"></td>
        <td id="LC2957">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2958" data-line-number="2958"></td>
        <td id="LC2958">
</td>
      </tr>
      <tr>
        <td id="L2959" data-line-number="2959"></td>
        <td id="LC2959">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2960" data-line-number="2960"></td>
        <td id="LC2960">
</td>
      </tr>
      <tr>
        <td id="L2961" data-line-number="2961"></td>
        <td id="LC2961">    <span>if</span> (<span>IsInteropDebugging</span>())</td>
      </tr>
      <tr>
        <td id="L2962" data-line-number="2962"></td>
        <td id="LC2962">    {</td>
      </tr>
      <tr>
        <td id="L2963" data-line-number="2963"></td>
        <td id="LC2963">        <span>return</span> CORDBG_E_INTEROP_NOT_SUPPORTED;</td>
      </tr>
      <tr>
        <td id="L2964" data-line-number="2964"></td>
        <td id="LC2964">    }</td>
      </tr>
      <tr>
        <td id="L2965" data-line-number="2965"></td>
        <td id="LC2965">
</td>
      </tr>
      <tr>
        <td id="L2966" data-line-number="2966"></td>
        <td id="LC2966">
</td>
      </tr>
      <tr>
        <td id="L2967" data-line-number="2967"></td>
        <td id="LC2967">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L2968" data-line-number="2968"></td>
        <td id="LC2968">    <span><span>//</span> A very important note: we require that the process is synchronized before doing a detach. This ensures</span></td>
      </tr>
      <tr>
        <td id="L2969" data-line-number="2969"></td>
        <td id="LC2969">    <span><span>//</span> that no events are on their way from the Left Side. We also require that the user has drained the</span></td>
      </tr>
      <tr>
        <td id="L2970" data-line-number="2970"></td>
        <td id="LC2970">    <span><span>//</span> managed event queue, but there is currently no way to really enforce that here.</span></td>
      </tr>
      <tr>
        <td id="L2971" data-line-number="2971"></td>
        <td id="LC2971">    <span><span>//</span> @todo-  why can't we enforce that the managed event Q is drained?</span></td>
      </tr>
      <tr>
        <td id="L2972" data-line-number="2972"></td>
        <td id="LC2972">    <span>ATT_REQUIRE_SYNCED_OR_NONINIT_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2973" data-line-number="2973"></td>
        <td id="LC2973">
</td>
      </tr>
      <tr>
        <td id="L2974" data-line-number="2974"></td>
        <td id="LC2974">
</td>
      </tr>
      <tr>
        <td id="L2975" data-line-number="2975"></td>
        <td id="LC2975">    hr = <span>IsReadyForDetach</span>();</td>
      </tr>
      <tr>
        <td id="L2976" data-line-number="2976"></td>
        <td id="LC2976">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L2977" data-line-number="2977"></td>
        <td id="LC2977">    {</td>
      </tr>
      <tr>
        <td id="L2978" data-line-number="2978"></td>
        <td id="LC2978">        <span><span>//</span> Avoid neutering. Gives client a chance to fix detach issue and retry.</span></td>
      </tr>
      <tr>
        <td id="L2979" data-line-number="2979"></td>
        <td id="LC2979">        <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L2980" data-line-number="2980"></td>
        <td id="LC2980">    }</td>
      </tr>
      <tr>
        <td id="L2981" data-line-number="2981"></td>
        <td id="LC2981">
</td>
      </tr>
      <tr>
        <td id="L2982" data-line-number="2982"></td>
        <td id="LC2982">    <span><span>//</span> Since the detach may resume the LS and allow it to exit, which may invoke the EP callback</span></td>
      </tr>
      <tr>
        <td id="L2983" data-line-number="2983"></td>
        <td id="LC2983">    <span><span>//</span> which may destroy this process object, be sure to protect us w/ an extra AddRef/Release</span></td>
      </tr>
      <tr>
        <td id="L2984" data-line-number="2984"></td>
        <td id="LC2984">    RSSmartPtr&lt;CordbProcess&gt; <span>pRef</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L2985" data-line-number="2985"></td>
        <td id="LC2985">
</td>
      </tr>
      <tr>
        <td id="L2986" data-line-number="2986"></td>
        <td id="LC2986">
</td>
      </tr>
      <tr>
        <td id="L2987" data-line-number="2987"></td>
        <td id="LC2987">
</td>
      </tr>
      <tr>
        <td id="L2988" data-line-number="2988"></td>
        <td id="LC2988">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::Detach - beginning<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L2989" data-line-number="2989"></td>
        <td id="LC2989">    <span>if</span> (m_pShim == <span>NULL</span>) <span><span>//</span> This API is moved off to the shim</span></td>
      </tr>
      <tr>
        <td id="L2990" data-line-number="2990"></td>
        <td id="LC2990">    {</td>
      </tr>
      <tr>
        <td id="L2991" data-line-number="2991"></td>
        <td id="LC2991">
</td>
      </tr>
      <tr>
        <td id="L2992" data-line-number="2992"></td>
        <td id="LC2992">        <span><span>//</span> This is still invasive.</span></td>
      </tr>
      <tr>
        <td id="L2993" data-line-number="2993"></td>
        <td id="LC2993">        <span><span>//</span> Ignore failures. This will fail for a non-invasive target.</span></td>
      </tr>
      <tr>
        <td id="L2994" data-line-number="2994"></td>
        <td id="LC2994">        <span>if</span> (<span>IsDacInitialized</span>())</td>
      </tr>
      <tr>
        <td id="L2995" data-line-number="2995"></td>
        <td id="LC2995">        {</td>
      </tr>
      <tr>
        <td id="L2996" data-line-number="2996"></td>
        <td id="LC2996">            HRESULT hrIgnore = S_OK;</td>
      </tr>
      <tr>
        <td id="L2997" data-line-number="2997"></td>
        <td id="LC2997">            EX_TRY</td>
      </tr>
      <tr>
        <td id="L2998" data-line-number="2998"></td>
        <td id="LC2998">            {</td>
      </tr>
      <tr>
        <td id="L2999" data-line-number="2999"></td>
        <td id="LC2999">                <span>GetDAC</span>()-&gt;<span>MarkDebuggerAttached</span>(<span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L3000" data-line-number="3000"></td>
        <td id="LC3000">            }</td>
      </tr>
      <tr>
        <td id="L3001" data-line-number="3001"></td>
        <td id="LC3001">            <span>EX_CATCH_HRESULT</span>(hrIgnore);</td>
      </tr>
      <tr>
        <td id="L3002" data-line-number="3002"></td>
        <td id="LC3002">        }</td>
      </tr>
      <tr>
        <td id="L3003" data-line-number="3003"></td>
        <td id="LC3003">    }</td>
      </tr>
      <tr>
        <td id="L3004" data-line-number="3004"></td>
        <td id="LC3004">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L3005" data-line-number="3005"></td>
        <td id="LC3005">    {</td>
      </tr>
      <tr>
        <td id="L3006" data-line-number="3006"></td>
        <td id="LC3006">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L3007" data-line-number="3007"></td>
        <td id="LC3007">        {</td>
      </tr>
      <tr>
        <td id="L3008" data-line-number="3008"></td>
        <td id="LC3008">            <span>DetachShim</span>();</td>
      </tr>
      <tr>
        <td id="L3009" data-line-number="3009"></td>
        <td id="LC3009">        }</td>
      </tr>
      <tr>
        <td id="L3010" data-line-number="3010"></td>
        <td id="LC3010">        <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L3011" data-line-number="3011"></td>
        <td id="LC3011">    }</td>
      </tr>
      <tr>
        <td id="L3012" data-line-number="3012"></td>
        <td id="LC3012">
</td>
      </tr>
      <tr>
        <td id="L3013" data-line-number="3013"></td>
        <td id="LC3013">    <span><span>//</span> Either way, neuter everything.</span></td>
      </tr>
      <tr>
        <td id="L3014" data-line-number="3014"></td>
        <td id="LC3014">    <span>this</span>-&gt;<span>Neuter</span>();</td>
      </tr>
      <tr>
        <td id="L3015" data-line-number="3015"></td>
        <td id="LC3015">
</td>
      </tr>
      <tr>
        <td id="L3016" data-line-number="3016"></td>
        <td id="LC3016">    <span><span>//</span> Implicit release on pRef</span></td>
      </tr>
      <tr>
        <td id="L3017" data-line-number="3017"></td>
        <td id="LC3017">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::Detach - returning w/ hr=0x%x<span>\n</span><span>"</span></span>, hr));</td>
      </tr>
      <tr>
        <td id="L3018" data-line-number="3018"></td>
        <td id="LC3018">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L3019" data-line-number="3019"></td>
        <td id="LC3019">}</td>
      </tr>
      <tr>
        <td id="L3020" data-line-number="3020"></td>
        <td id="LC3020">
</td>
      </tr>
      <tr>
        <td id="L3021" data-line-number="3021"></td>
        <td id="LC3021"><span><span>//</span> Free up key left-side resources</span></td>
      </tr>
      <tr>
        <td id="L3022" data-line-number="3022"></td>
        <td id="LC3022"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3023" data-line-number="3023"></td>
        <td id="LC3023"><span><span>//</span> Called on detach</span></td>
      </tr>
      <tr>
        <td id="L3024" data-line-number="3024"></td>
        <td id="LC3024"><span><span>//</span> This does key neutering of objects that hold left-side resources and require</span></td>
      </tr>
      <tr>
        <td id="L3025" data-line-number="3025"></td>
        <td id="LC3025"><span><span>//</span> preemptively freeing the resources.</span></td>
      </tr>
      <tr>
        <td id="L3026" data-line-number="3026"></td>
        <td id="LC3026"><span><span>//</span> After this, code:CordbProcess::Neuter should only affect right-side state.</span></td>
      </tr>
      <tr>
        <td id="L3027" data-line-number="3027"></td>
        <td id="LC3027"><span>void</span> <span>CordbProcess::NeuterChildrenLeftSideResources</span>()</td>
      </tr>
      <tr>
        <td id="L3028" data-line-number="3028"></td>
        <td id="LC3028">{</td>
      </tr>
      <tr>
        <td id="L3029" data-line-number="3029"></td>
        <td id="LC3029">    <span>_ASSERTE</span>(<span>GetStopGoLock</span>()-&gt;<span>HasLock</span>());</td>
      </tr>
      <tr>
        <td id="L3030" data-line-number="3030"></td>
        <td id="LC3030">
</td>
      </tr>
      <tr>
        <td id="L3031" data-line-number="3031"></td>
        <td id="LC3031">    <span>_ASSERTE</span>(!<span>GetProcessLock</span>()-&gt;<span>HasLock</span>());</td>
      </tr>
      <tr>
        <td id="L3032" data-line-number="3032"></td>
        <td id="LC3032">    RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L3033" data-line-number="3033"></td>
        <td id="LC3033">
</td>
      </tr>
      <tr>
        <td id="L3034" data-line-number="3034"></td>
        <td id="LC3034">
</td>
      </tr>
      <tr>
        <td id="L3035" data-line-number="3035"></td>
        <td id="LC3035">    <span><span>//</span> Need process-lock to operate on hashtable, but can't yet Neuter under process-lock,</span></td>
      </tr>
      <tr>
        <td id="L3036" data-line-number="3036"></td>
        <td id="LC3036">    <span><span>//</span> so we have to copy the contents to an auxilary list which we can then traverse outside the lock.</span></td>
      </tr>
      <tr>
        <td id="L3037" data-line-number="3037"></td>
        <td id="LC3037">    RSPtrArray&lt;CordbAppDomain&gt; listAppDomains;</td>
      </tr>
      <tr>
        <td id="L3038" data-line-number="3038"></td>
        <td id="LC3038">    m_appDomains.<span>CopyToArray</span>(&amp;listAppDomains);</td>
      </tr>
      <tr>
        <td id="L3039" data-line-number="3039"></td>
        <td id="LC3039">
</td>
      </tr>
      <tr>
        <td id="L3040" data-line-number="3040"></td>
        <td id="LC3040">
</td>
      </tr>
      <tr>
        <td id="L3041" data-line-number="3041"></td>
        <td id="LC3041">
</td>
      </tr>
      <tr>
        <td id="L3042" data-line-number="3042"></td>
        <td id="LC3042">    <span><span>//</span> Must not hold process lock so that we can be safe to send IPC events</span></td>
      </tr>
      <tr>
        <td id="L3043" data-line-number="3043"></td>
        <td id="LC3043">    <span><span>//</span> to cleanup left-side resources.</span></td>
      </tr>
      <tr>
        <td id="L3044" data-line-number="3044"></td>
        <td id="LC3044">    lockHolder.<span>Release</span>();</td>
      </tr>
      <tr>
        <td id="L3045" data-line-number="3045"></td>
        <td id="LC3045">    <span>_ASSERTE</span>(!<span>GetProcessLock</span>()-&gt;<span>HasLock</span>());</td>
      </tr>
      <tr>
        <td id="L3046" data-line-number="3046"></td>
        <td id="LC3046">
</td>
      </tr>
      <tr>
        <td id="L3047" data-line-number="3047"></td>
        <td id="LC3047">    <span><span>//</span> Frees left-side resources. This may send IPC events.</span></td>
      </tr>
      <tr>
        <td id="L3048" data-line-number="3048"></td>
        <td id="LC3048">    <span><span>//</span> This will make normal neutering a nop.</span></td>
      </tr>
      <tr>
        <td id="L3049" data-line-number="3049"></td>
        <td id="LC3049">    m_LeftSideResourceCleanupList.<span>NeuterLeftSideResourcesAndClear</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3050" data-line-number="3050"></td>
        <td id="LC3050">
</td>
      </tr>
      <tr>
        <td id="L3051" data-line-number="3051"></td>
        <td id="LC3051">    <span>for</span>(<span>unsigned</span> <span>int</span> idx = <span>0</span>; idx &lt; listAppDomains.<span>Length</span>(); idx++)</td>
      </tr>
      <tr>
        <td id="L3052" data-line-number="3052"></td>
        <td id="LC3052">    {</td>
      </tr>
      <tr>
        <td id="L3053" data-line-number="3053"></td>
        <td id="LC3053">        CordbAppDomain * pAppDomain = listAppDomains[idx];</td>
      </tr>
      <tr>
        <td id="L3054" data-line-number="3054"></td>
        <td id="LC3054">
</td>
      </tr>
      <tr>
        <td id="L3055" data-line-number="3055"></td>
        <td id="LC3055">        <span><span>//</span> CordbHandleValue is in the appdomain exit list, and that needs</span></td>
      </tr>
      <tr>
        <td id="L3056" data-line-number="3056"></td>
        <td id="LC3056">        <span><span>//</span> to send an IPC event to cleanup and release the handle from</span></td>
      </tr>
      <tr>
        <td id="L3057" data-line-number="3057"></td>
        <td id="LC3057">        <span><span>//</span> the GCs handle table.</span></td>
      </tr>
      <tr>
        <td id="L3058" data-line-number="3058"></td>
        <td id="LC3058">        pAppDomain-&gt;<span>GetSweepableExitNeuterList</span>()-&gt;<span>NeuterLeftSideResourcesAndClear</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3059" data-line-number="3059"></td>
        <td id="LC3059">    }</td>
      </tr>
      <tr>
        <td id="L3060" data-line-number="3060"></td>
        <td id="LC3060">    listAppDomains.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L3061" data-line-number="3061"></td>
        <td id="LC3061">
</td>
      </tr>
      <tr>
        <td id="L3062" data-line-number="3062"></td>
        <td id="LC3062">}</td>
      </tr>
      <tr>
        <td id="L3063" data-line-number="3063"></td>
        <td id="LC3063">
</td>
      </tr>
      <tr>
        <td id="L3064" data-line-number="3064"></td>
        <td id="LC3064"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3065" data-line-number="3065"></td>
        <td id="LC3065"><span><span>//</span> Detach the Debugger from the LS process for the V2 case</span></td>
      </tr>
      <tr>
        <td id="L3066" data-line-number="3066"></td>
        <td id="LC3066"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3067" data-line-number="3067"></td>
        <td id="LC3067"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L3068" data-line-number="3068"></td>
        <td id="LC3068"><span><span>//</span>      This will NeuterChildren(), caller will do the real Neuter()</span></td>
      </tr>
      <tr>
        <td id="L3069" data-line-number="3069"></td>
        <td id="LC3069"><span><span>//</span>      Caller has already ensured that detach is safe.</span></td>
      </tr>
      <tr>
        <td id="L3070" data-line-number="3070"></td>
        <td id="LC3070"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3071" data-line-number="3071"></td>
        <td id="LC3071"><span><span>//</span>   @dbgtodo attach-bit: this should be moved into the shim; need</span></td>
      </tr>
      <tr>
        <td id="L3072" data-line-number="3072"></td>
        <td id="LC3072"><span><span>//</span>   to figure out semantics for freeing left-side resources (especially GC</span></td>
      </tr>
      <tr>
        <td id="L3073" data-line-number="3073"></td>
        <td id="LC3073"><span><span>//</span>   handles) on detach.</span></td>
      </tr>
      <tr>
        <td id="L3074" data-line-number="3074"></td>
        <td id="LC3074"><span>void</span> <span>CordbProcess::DetachShim</span>()</td>
      </tr>
      <tr>
        <td id="L3075" data-line-number="3075"></td>
        <td id="LC3075">{</td>
      </tr>
      <tr>
        <td id="L3076" data-line-number="3076"></td>
        <td id="LC3076">
</td>
      </tr>
      <tr>
        <td id="L3077" data-line-number="3077"></td>
        <td id="LC3077">    HASHFIND hashFind;</td>
      </tr>
      <tr>
        <td id="L3078" data-line-number="3078"></td>
        <td id="LC3078">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L3079" data-line-number="3079"></td>
        <td id="LC3079">
</td>
      </tr>
      <tr>
        <td id="L3080" data-line-number="3080"></td>
        <td id="LC3080">    <span><span>//</span> If we detach before the CLR is loaded into the debuggee, then we can no-op a lot of work.</span></td>
      </tr>
      <tr>
        <td id="L3081" data-line-number="3081"></td>
        <td id="LC3081">    <span><span>//</span> We sure can't be sending IPC events to the LS before it exists.</span></td>
      </tr>
      <tr>
        <td id="L3082" data-line-number="3082"></td>
        <td id="LC3082">    <span>if</span> (m_initialized)</td>
      </tr>
      <tr>
        <td id="L3083" data-line-number="3083"></td>
        <td id="LC3083">    {</td>
      </tr>
      <tr>
        <td id="L3084" data-line-number="3084"></td>
        <td id="LC3084">        <span><span>//</span> The managed event queue is not necessarily drained. Cordbg could call detach between any callback.</span></td>
      </tr>
      <tr>
        <td id="L3085" data-line-number="3085"></td>
        <td id="LC3085">        <span><span>//</span> While the process is still stopped, neuter all of our children.</span></td>
      </tr>
      <tr>
        <td id="L3086" data-line-number="3086"></td>
        <td id="LC3086">        <span><span>//</span> This will make our Neuter() a nop and saves the W32ET from having to do dangerous work.</span></td>
      </tr>
      <tr>
        <td id="L3087" data-line-number="3087"></td>
        <td id="LC3087">        <span>this</span>-&gt;<span>NeuterChildrenLeftSideResources</span>();</td>
      </tr>
      <tr>
        <td id="L3088" data-line-number="3088"></td>
        <td id="LC3088">        {</td>
      </tr>
      <tr>
        <td id="L3089" data-line-number="3089"></td>
        <td id="LC3089">            RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L3090" data-line-number="3090"></td>
        <td id="LC3090">            <span>this</span>-&gt;<span>NeuterChildren</span>();</td>
      </tr>
      <tr>
        <td id="L3091" data-line-number="3091"></td>
        <td id="LC3091">        }</td>
      </tr>
      <tr>
        <td id="L3092" data-line-number="3092"></td>
        <td id="LC3092">
</td>
      </tr>
      <tr>
        <td id="L3093" data-line-number="3093"></td>
        <td id="LC3093">        <span><span>//</span> Go ahead and detach from the entire process now. This is like sending a "Continue".</span></td>
      </tr>
      <tr>
        <td id="L3094" data-line-number="3094"></td>
        <td id="LC3094">        DebuggerIPCEvent * pIPCEvent = (DebuggerIPCEvent *) <span>_alloca</span>(CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L3095" data-line-number="3095"></td>
        <td id="LC3095">        <span>InitIPCEvent</span>(pIPCEvent, DB_IPCE_DETACH_FROM_PROCESS, <span>true</span>, <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L3096" data-line-number="3096"></td>
        <td id="LC3096">
</td>
      </tr>
      <tr>
        <td id="L3097" data-line-number="3097"></td>
        <td id="LC3097">        hr = m_cordb-&gt;<span>SendIPCEvent</span>(<span>this</span>, pIPCEvent, CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L3098" data-line-number="3098"></td>
        <td id="LC3098">        hr = <span>WORST_HR</span>(hr, pIPCEvent-&gt;<span>hr</span>);</td>
      </tr>
      <tr>
        <td id="L3099" data-line-number="3099"></td>
        <td id="LC3099">        <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L3100" data-line-number="3100"></td>
        <td id="LC3100">    }</td>
      </tr>
      <tr>
        <td id="L3101" data-line-number="3101"></td>
        <td id="LC3101">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L3102" data-line-number="3102"></td>
        <td id="LC3102">    {</td>
      </tr>
      <tr>
        <td id="L3103" data-line-number="3103"></td>
        <td id="LC3103">        <span><span>//</span> @dbgtodo attach-bit: push this up, once detach IPC event is hoisted.</span></td>
      </tr>
      <tr>
        <td id="L3104" data-line-number="3104"></td>
        <td id="LC3104">        RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L3105" data-line-number="3105"></td>
        <td id="LC3105">
</td>
      </tr>
      <tr>
        <td id="L3106" data-line-number="3106"></td>
        <td id="LC3106">        <span><span>//</span> Shouldn't have any appdomains.</span></td>
      </tr>
      <tr>
        <td id="L3107" data-line-number="3107"></td>
        <td id="LC3107">        (<span>void</span>)hashFind; <span><span>//</span>prevent "unused variable" error from GCC</span></td>
      </tr>
      <tr>
        <td id="L3108" data-line-number="3108"></td>
        <td id="LC3108">        <span>_ASSERTE</span>(m_appDomains.<span>FindFirst</span>(&amp;hashFind) == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L3109" data-line-number="3109"></td>
        <td id="LC3109">    }</td>
      </tr>
      <tr>
        <td id="L3110" data-line-number="3110"></td>
        <td id="LC3110">
</td>
      </tr>
      <tr>
        <td id="L3111" data-line-number="3111"></td>
        <td id="LC3111">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::Detach - got reply from LS<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L3112" data-line-number="3112"></td>
        <td id="LC3112">
</td>
      </tr>
      <tr>
        <td id="L3113" data-line-number="3113"></td>
        <td id="LC3113">    <span><span>//</span> It's possible that the LS may exit after they reply to our detach_from_process, but</span></td>
      </tr>
      <tr>
        <td id="L3114" data-line-number="3114"></td>
        <td id="LC3114">    <span><span>//</span> before we update our internal state that they're detached. So still have to check</span></td>
      </tr>
      <tr>
        <td id="L3115" data-line-number="3115"></td>
        <td id="LC3115">    <span><span>//</span> failure codes here.</span></td>
      </tr>
      <tr>
        <td id="L3116" data-line-number="3116"></td>
        <td id="LC3116">    hr = <span>this</span>-&gt;<span>m_pShim</span>-&gt;<span>GetWin32EventThread</span>()-&gt;<span>SendDetachProcessEvent</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3117" data-line-number="3117"></td>
        <td id="LC3117">
</td>
      </tr>
      <tr>
        <td id="L3118" data-line-number="3118"></td>
        <td id="LC3118">
</td>
      </tr>
      <tr>
        <td id="L3119" data-line-number="3119"></td>
        <td id="LC3119">    <span><span>//</span> Since we're auto-continuing when we detach, we should set the stop count back to zero.</span></td>
      </tr>
      <tr>
        <td id="L3120" data-line-number="3120"></td>
        <td id="LC3120">    <span><span>//</span> This (along w/ m_detached) prevents anyone from calling Continue on this process</span></td>
      </tr>
      <tr>
        <td id="L3121" data-line-number="3121"></td>
        <td id="LC3121">    <span><span>//</span> after this call returns.</span></td>
      </tr>
      <tr>
        <td id="L3122" data-line-number="3122"></td>
        <td id="LC3122">    m_stopCount = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3123" data-line-number="3123"></td>
        <td id="LC3123">
</td>
      </tr>
      <tr>
        <td id="L3124" data-line-number="3124"></td>
        <td id="LC3124">    <span>if</span> (hr != CORDBG_E_PROCESS_TERMINATED)</td>
      </tr>
      <tr>
        <td id="L3125" data-line-number="3125"></td>
        <td id="LC3125">    {</td>
      </tr>
      <tr>
        <td id="L3126" data-line-number="3126"></td>
        <td id="LC3126">        <span><span>//</span> Remember that we've detached from this process object. This will prevent any further operations on</span></td>
      </tr>
      <tr>
        <td id="L3127" data-line-number="3127"></td>
        <td id="LC3127">        <span><span>//</span> this process, just in case... :)</span></td>
      </tr>
      <tr>
        <td id="L3128" data-line-number="3128"></td>
        <td id="LC3128">        <span><span>//</span> If LS exited, then don't set this flag because it overrides m_terminated when reporting errors;</span></td>
      </tr>
      <tr>
        <td id="L3129" data-line-number="3129"></td>
        <td id="LC3129">        <span><span>//</span> and we want to provide a consistent story about whether we detached or whether the LS exited.</span></td>
      </tr>
      <tr>
        <td id="L3130" data-line-number="3130"></td>
        <td id="LC3130">        m_detached = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3131" data-line-number="3131"></td>
        <td id="LC3131">    }</td>
      </tr>
      <tr>
        <td id="L3132" data-line-number="3132"></td>
        <td id="LC3132">    <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L3133" data-line-number="3133"></td>
        <td id="LC3133">
</td>
      </tr>
      <tr>
        <td id="L3134" data-line-number="3134"></td>
        <td id="LC3134">
</td>
      </tr>
      <tr>
        <td id="L3135" data-line-number="3135"></td>
        <td id="LC3135">    <span><span>//</span> Now that all complicated cleanup is done, caller can do a final neuter.</span></td>
      </tr>
      <tr>
        <td id="L3136" data-line-number="3136"></td>
        <td id="LC3136">    <span><span>//</span> This will implicitly stop our Win32 event thread as well.</span></td>
      </tr>
      <tr>
        <td id="L3137" data-line-number="3137"></td>
        <td id="LC3137">}</td>
      </tr>
      <tr>
        <td id="L3138" data-line-number="3138"></td>
        <td id="LC3138">
</td>
      </tr>
      <tr>
        <td id="L3139" data-line-number="3139"></td>
        <td id="LC3139"><span><span>//</span> Delete all events from the queue without dispatching. This is useful in shutdown.</span></td>
      </tr>
      <tr>
        <td id="L3140" data-line-number="3140"></td>
        <td id="LC3140"><span><span>//</span> An event that is currently dispatching is not on the queue.</span></td>
      </tr>
      <tr>
        <td id="L3141" data-line-number="3141"></td>
        <td id="LC3141"><span>void</span> <span>CordbProcess::DeleteQueuedEvents</span>()</td>
      </tr>
      <tr>
        <td id="L3142" data-line-number="3142"></td>
        <td id="LC3142">{</td>
      </tr>
      <tr>
        <td id="L3143" data-line-number="3143"></td>
        <td id="LC3143">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3144" data-line-number="3144"></td>
        <td id="LC3144">    <span><span>//</span> We must have the process lock to ensure that no one is trying to add an event</span></td>
      </tr>
      <tr>
        <td id="L3145" data-line-number="3145"></td>
        <td id="LC3145">    <span>_ASSERTE</span>(!<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L3146" data-line-number="3146"></td>
        <td id="LC3146">
</td>
      </tr>
      <tr>
        <td id="L3147" data-line-number="3147"></td>
        <td id="LC3147">    <span>if</span> (m_pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L3148" data-line-number="3148"></td>
        <td id="LC3148">    {</td>
      </tr>
      <tr>
        <td id="L3149" data-line-number="3149"></td>
        <td id="LC3149">        <span>PUBLIC_CALLBACK_IN_THIS_SCOPE0_NO_LOCK</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3150" data-line-number="3150"></td>
        <td id="LC3150">
</td>
      </tr>
      <tr>
        <td id="L3151" data-line-number="3151"></td>
        <td id="LC3151">        <span><span>//</span> DeleteAll() is part of the shim, and it will change external ref counts, so must really</span></td>
      </tr>
      <tr>
        <td id="L3152" data-line-number="3152"></td>
        <td id="LC3152">        <span><span>//</span> be marked as outside the RS.</span></td>
      </tr>
      <tr>
        <td id="L3153" data-line-number="3153"></td>
        <td id="LC3153">        m_pShim-&gt;<span>GetManagedEventQueue</span>()-&gt;<span>DeleteAll</span>();</td>
      </tr>
      <tr>
        <td id="L3154" data-line-number="3154"></td>
        <td id="LC3154">    }</td>
      </tr>
      <tr>
        <td id="L3155" data-line-number="3155"></td>
        <td id="LC3155">}</td>
      </tr>
      <tr>
        <td id="L3156" data-line-number="3156"></td>
        <td id="LC3156">
</td>
      </tr>
      <tr>
        <td id="L3157" data-line-number="3157"></td>
        <td id="LC3157"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3158" data-line-number="3158"></td>
        <td id="LC3158"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3159" data-line-number="3159"></td>
        <td id="LC3159"><span><span>//</span> Track that we're about to dispatch a managed event.</span></td>
      </tr>
      <tr>
        <td id="L3160" data-line-number="3160"></td>
        <td id="LC3160"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3161" data-line-number="3161"></td>
        <td id="LC3161"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L3162" data-line-number="3162"></td>
        <td id="LC3162"><span><span>//</span>      event - event being dispatched</span></td>
      </tr>
      <tr>
        <td id="L3163" data-line-number="3163"></td>
        <td id="LC3163"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3164" data-line-number="3164"></td>
        <td id="LC3164"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L3165" data-line-number="3165"></td>
        <td id="LC3165"><span><span>//</span>    This is used to support code:CordbProcess::AreDispatchingEvent</span></td>
      </tr>
      <tr>
        <td id="L3166" data-line-number="3166"></td>
        <td id="LC3166"><span><span>//</span>    This is always called on the same thread as code:CordbProcess::FinishEventDispatch</span></td>
      </tr>
      <tr>
        <td id="L3167" data-line-number="3167"></td>
        <td id="LC3167"><span>void</span> <span>CordbProcess::StartEventDispatch</span>(DebuggerIPCEventType event)</td>
      </tr>
      <tr>
        <td id="L3168" data-line-number="3168"></td>
        <td id="LC3168">{</td>
      </tr>
      <tr>
        <td id="L3169" data-line-number="3169"></td>
        <td id="LC3169">    LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3170" data-line-number="3170"></td>
        <td id="LC3170">
</td>
      </tr>
      <tr>
        <td id="L3171" data-line-number="3171"></td>
        <td id="LC3171">    <span>_ASSERTE</span>(m_dispatchedEvent == DB_IPCE_DEBUGGER_INVALID);</td>
      </tr>
      <tr>
        <td id="L3172" data-line-number="3172"></td>
        <td id="LC3172">    <span>_ASSERTE</span>(event != DB_IPCE_DEBUGGER_INVALID);</td>
      </tr>
      <tr>
        <td id="L3173" data-line-number="3173"></td>
        <td id="LC3173">    m_dispatchedEvent = event;</td>
      </tr>
      <tr>
        <td id="L3174" data-line-number="3174"></td>
        <td id="LC3174">}</td>
      </tr>
      <tr>
        <td id="L3175" data-line-number="3175"></td>
        <td id="LC3175">
</td>
      </tr>
      <tr>
        <td id="L3176" data-line-number="3176"></td>
        <td id="LC3176"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3177" data-line-number="3177"></td>
        <td id="LC3177"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3178" data-line-number="3178"></td>
        <td id="LC3178"><span><span>//</span> Track that we're done dispatching a managed event.</span></td>
      </tr>
      <tr>
        <td id="L3179" data-line-number="3179"></td>
        <td id="LC3179"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3180" data-line-number="3180"></td>
        <td id="LC3180"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3181" data-line-number="3181"></td>
        <td id="LC3181"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L3182" data-line-number="3182"></td>
        <td id="LC3182"><span><span>//</span>    This is always called on the same thread as code:CordbProcess::StartEventDispatch</span></td>
      </tr>
      <tr>
        <td id="L3183" data-line-number="3183"></td>
        <td id="LC3183"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3184" data-line-number="3184"></td>
        <td id="LC3184"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L3185" data-line-number="3185"></td>
        <td id="LC3185"><span><span>//</span>   @dbgtodo shim: eventually this goes into the shim when we hoist Continue</span></td>
      </tr>
      <tr>
        <td id="L3186" data-line-number="3186"></td>
        <td id="LC3186"><span>void</span> <span>CordbProcess::FinishEventDispatch</span>()</td>
      </tr>
      <tr>
        <td id="L3187" data-line-number="3187"></td>
        <td id="LC3187">{</td>
      </tr>
      <tr>
        <td id="L3188" data-line-number="3188"></td>
        <td id="LC3188">    LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3189" data-line-number="3189"></td>
        <td id="LC3189">
</td>
      </tr>
      <tr>
        <td id="L3190" data-line-number="3190"></td>
        <td id="LC3190">    <span>_ASSERTE</span>(m_dispatchedEvent != DB_IPCE_DEBUGGER_INVALID);</td>
      </tr>
      <tr>
        <td id="L3191" data-line-number="3191"></td>
        <td id="LC3191">    m_dispatchedEvent = DB_IPCE_DEBUGGER_INVALID;</td>
      </tr>
      <tr>
        <td id="L3192" data-line-number="3192"></td>
        <td id="LC3192">}</td>
      </tr>
      <tr>
        <td id="L3193" data-line-number="3193"></td>
        <td id="LC3193">
</td>
      </tr>
      <tr>
        <td id="L3194" data-line-number="3194"></td>
        <td id="LC3194"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3195" data-line-number="3195"></td>
        <td id="LC3195"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3196" data-line-number="3196"></td>
        <td id="LC3196"><span><span>//</span> Are we in the middle of dispatching an event?</span></td>
      </tr>
      <tr>
        <td id="L3197" data-line-number="3197"></td>
        <td id="LC3197"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3198" data-line-number="3198"></td>
        <td id="LC3198"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L3199" data-line-number="3199"></td>
        <td id="LC3199"><span><span>//</span>   This is used by code::CordbProcess::ContinueInternal. Continue logic takes</span></td>
      </tr>
      <tr>
        <td id="L3200" data-line-number="3200"></td>
        <td id="LC3200"><span><span>//</span>   a shortcut if the continue is called on the dispatch thread.</span></td>
      </tr>
      <tr>
        <td id="L3201" data-line-number="3201"></td>
        <td id="LC3201"><span><span>//</span>   It doesn't matter which event is being dispatch; only that we're on the dispatch thread.</span></td>
      </tr>
      <tr>
        <td id="L3202" data-line-number="3202"></td>
        <td id="LC3202"><span><span>//</span>   @dbgtodo shim: eventually this goes into the shim when we hoist Continue</span></td>
      </tr>
      <tr>
        <td id="L3203" data-line-number="3203"></td>
        <td id="LC3203"><span>bool</span> <span>CordbProcess::AreDispatchingEvent</span>()</td>
      </tr>
      <tr>
        <td id="L3204" data-line-number="3204"></td>
        <td id="LC3204">{</td>
      </tr>
      <tr>
        <td id="L3205" data-line-number="3205"></td>
        <td id="LC3205">    LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3206" data-line-number="3206"></td>
        <td id="LC3206">
</td>
      </tr>
      <tr>
        <td id="L3207" data-line-number="3207"></td>
        <td id="LC3207">    <span>return</span> m_dispatchedEvent != DB_IPCE_DEBUGGER_INVALID;</td>
      </tr>
      <tr>
        <td id="L3208" data-line-number="3208"></td>
        <td id="LC3208">}</td>
      </tr>
      <tr>
        <td id="L3209" data-line-number="3209"></td>
        <td id="LC3209">
</td>
      </tr>
      <tr>
        <td id="L3210" data-line-number="3210"></td>
        <td id="LC3210">
</td>
      </tr>
      <tr>
        <td id="L3211" data-line-number="3211"></td>
        <td id="LC3211">
</td>
      </tr>
      <tr>
        <td id="L3212" data-line-number="3212"></td>
        <td id="LC3212">
</td>
      </tr>
      <tr>
        <td id="L3213" data-line-number="3213"></td>
        <td id="LC3213">
</td>
      </tr>
      <tr>
        <td id="L3214" data-line-number="3214"></td>
        <td id="LC3214"><span><span>//</span> Terminate the app. We'll still dispatch an ExitProcess callback, so the app</span></td>
      </tr>
      <tr>
        <td id="L3215" data-line-number="3215"></td>
        <td id="LC3215"><span><span>//</span> must wait for that before calling Cordb::Terminate.</span></td>
      </tr>
      <tr>
        <td id="L3216" data-line-number="3216"></td>
        <td id="LC3216"><span><span>//</span> If this fails, the client can always call the OS's TerminateProcess command</span></td>
      </tr>
      <tr>
        <td id="L3217" data-line-number="3217"></td>
        <td id="LC3217"><span><span>//</span> to rudely kill the debuggee.</span></td>
      </tr>
      <tr>
        <td id="L3218" data-line-number="3218"></td>
        <td id="LC3218">HRESULT <span>CordbProcess::Terminate</span>(<span>unsigned</span> <span>int</span> exitCode)</td>
      </tr>
      <tr>
        <td id="L3219" data-line-number="3219"></td>
        <td id="LC3219">{</td>
      </tr>
      <tr>
        <td id="L3220" data-line-number="3220"></td>
        <td id="LC3220">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3221" data-line-number="3221"></td>
        <td id="LC3221">
</td>
      </tr>
      <tr>
        <td id="L3222" data-line-number="3222"></td>
        <td id="LC3222">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::Terminate: with exitcode %u<span>\n</span><span>"</span></span>, exitCode));</td>
      </tr>
      <tr>
        <td id="L3223" data-line-number="3223"></td>
        <td id="LC3223">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3224" data-line-number="3224"></td>
        <td id="LC3224">
</td>
      </tr>
      <tr>
        <td id="L3225" data-line-number="3225"></td>
        <td id="LC3225">
</td>
      </tr>
      <tr>
        <td id="L3226" data-line-number="3226"></td>
        <td id="LC3226">    <span><span>//</span> @dbgtodo shutdown: eventually, all of Terminate() will be in the Shim.</span></td>
      </tr>
      <tr>
        <td id="L3227" data-line-number="3227"></td>
        <td id="LC3227">    <span><span>//</span> Free all the remaining events. Since this will call into the shim, do this outside of any locks.</span></td>
      </tr>
      <tr>
        <td id="L3228" data-line-number="3228"></td>
        <td id="LC3228">    <span><span>//</span> (ATT_ takes locks).</span></td>
      </tr>
      <tr>
        <td id="L3229" data-line-number="3229"></td>
        <td id="LC3229">    <span>DeleteQueuedEvents</span>();</td>
      </tr>
      <tr>
        <td id="L3230" data-line-number="3230"></td>
        <td id="LC3230">
</td>
      </tr>
      <tr>
        <td id="L3231" data-line-number="3231"></td>
        <td id="LC3231">    <span>ATT_REQUIRE_SYNCED_OR_NONINIT_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3232" data-line-number="3232"></td>
        <td id="LC3232">
</td>
      </tr>
      <tr>
        <td id="L3233" data-line-number="3233"></td>
        <td id="LC3233">    <span><span>//</span> When we terminate the process, it's handle will become signaled and</span></td>
      </tr>
      <tr>
        <td id="L3234" data-line-number="3234"></td>
        <td id="LC3234">    <span><span>//</span> Win32 Event Thread will leap into action and call CordbWin32EventThread::ExitProcess</span></td>
      </tr>
      <tr>
        <td id="L3235" data-line-number="3235"></td>
        <td id="LC3235">    <span><span>//</span> Unfortunately, that may destroy this object if the ExitProcess callback</span></td>
      </tr>
      <tr>
        <td id="L3236" data-line-number="3236"></td>
        <td id="LC3236">    <span><span>//</span> decides to call Release() on the process.</span></td>
      </tr>
      <tr>
        <td id="L3237" data-line-number="3237"></td>
        <td id="LC3237">
</td>
      </tr>
      <tr>
        <td id="L3238" data-line-number="3238"></td>
        <td id="LC3238">
</td>
      </tr>
      <tr>
        <td id="L3239" data-line-number="3239"></td>
        <td id="LC3239">    <span><span>//</span> Indicate that the process is exiting so that (among other things) we don't try and</span></td>
      </tr>
      <tr>
        <td id="L3240" data-line-number="3240"></td>
        <td id="LC3240">    <span><span>//</span> send messages to the left side while it's being deleted.</span></td>
      </tr>
      <tr>
        <td id="L3241" data-line-number="3241"></td>
        <td id="LC3241">    <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L3242" data-line-number="3242"></td>
        <td id="LC3242">
</td>
      </tr>
      <tr>
        <td id="L3243" data-line-number="3243"></td>
        <td id="LC3243">    <span><span>//</span> In case we're continuing from the loader bp, we don't want to try and kick off an attach. :)</span></td>
      </tr>
      <tr>
        <td id="L3244" data-line-number="3244"></td>
        <td id="LC3244">    m_fDoDelayedManagedAttached = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3245" data-line-number="3245"></td>
        <td id="LC3245">    m_exiting = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3246" data-line-number="3246"></td>
        <td id="LC3246">
</td>
      </tr>
      <tr>
        <td id="L3247" data-line-number="3247"></td>
        <td id="LC3247">
</td>
      </tr>
      <tr>
        <td id="L3248" data-line-number="3248"></td>
        <td id="LC3248">
</td>
      </tr>
      <tr>
        <td id="L3249" data-line-number="3249"></td>
        <td id="LC3249">    <span><span>//</span> We'd like to just take a lock around everything here, but that may deadlock us</span></td>
      </tr>
      <tr>
        <td id="L3250" data-line-number="3250"></td>
        <td id="LC3250">    <span><span>//</span> since W32ET will wait on the lock, and Continue may wait on W32ET.</span></td>
      </tr>
      <tr>
        <td id="L3251" data-line-number="3251"></td>
        <td id="LC3251">    <span><span>//</span> So we just do an extra AddRef/Release to make sure we're still around.</span></td>
      </tr>
      <tr>
        <td id="L3252" data-line-number="3252"></td>
        <td id="LC3252">    <span><span>//</span> @todo - could we move this smartptr up so that it's well-nested w/ the lock?</span></td>
      </tr>
      <tr>
        <td id="L3253" data-line-number="3253"></td>
        <td id="LC3253">    RSSmartPtr&lt;CordbProcess&gt; <span>pRef</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3254" data-line-number="3254"></td>
        <td id="LC3254">
</td>
      </tr>
      <tr>
        <td id="L3255" data-line-number="3255"></td>
        <td id="LC3255">    <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3256" data-line-number="3256"></td>
        <td id="LC3256">
</td>
      </tr>
      <tr>
        <td id="L3257" data-line-number="3257"></td>
        <td id="LC3257">
</td>
      </tr>
      <tr>
        <td id="L3258" data-line-number="3258"></td>
        <td id="LC3258">    <span><span>//</span> At any point after this call, the w32 ET may run the ExitProcess code which will race w/ the continue call.</span></td>
      </tr>
      <tr>
        <td id="L3259" data-line-number="3259"></td>
        <td id="LC3259">    <span><span>//</span> This call only posts a request that the process terminate and does not guarantee the process actually</span></td>
      </tr>
      <tr>
        <td id="L3260" data-line-number="3260"></td>
        <td id="LC3260">    <span><span>//</span> terminates. In particular, the process can not exit until any outstanding IO requests are done (on cancelled).</span></td>
      </tr>
      <tr>
        <td id="L3261" data-line-number="3261"></td>
        <td id="LC3261">    <span><span>//</span> It also can not exit if we have an outstanding not-continued native-debug event.</span></td>
      </tr>
      <tr>
        <td id="L3262" data-line-number="3262"></td>
        <td id="LC3262">    <span><span>//</span> Fortunately, the interesting work in terminate is done in ExitProcessWorkItem::Do, which can take the Stop-Go lock.</span></td>
      </tr>
      <tr>
        <td id="L3263" data-line-number="3263"></td>
        <td id="LC3263">    <span><span>//</span> Since we're currently holding the stop-go lock, that means we at least get some serialization.</span></td>
      </tr>
      <tr>
        <td id="L3264" data-line-number="3264"></td>
        <td id="LC3264">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3265" data-line-number="3265"></td>
        <td id="LC3265">    <span><span>//</span> Note that on Windows, the process isn't really terminated until we receive the EXIT_PROCESS_DEBUG_EVENT.</span></td>
      </tr>
      <tr>
        <td id="L3266" data-line-number="3266"></td>
        <td id="LC3266">    <span><span>//</span> Before then, we can still still access the debuggee's address space.  On the other, for Mac debugging,</span></td>
      </tr>
      <tr>
        <td id="L3267" data-line-number="3267"></td>
        <td id="LC3267">    <span><span>//</span> the process can die any time after this call, and so we can no longer call into the DAC.</span></td>
      </tr>
      <tr>
        <td id="L3268" data-line-number="3268"></td>
        <td id="LC3268">    <span>GetShim</span>()-&gt;<span>GetNativePipeline</span>()-&gt;<span>TerminateProcess</span>(exitCode);</td>
      </tr>
      <tr>
        <td id="L3269" data-line-number="3269"></td>
        <td id="LC3269">
</td>
      </tr>
      <tr>
        <td id="L3270" data-line-number="3270"></td>
        <td id="LC3270">    <span><span>//</span> We just call Continue() so that the debugger doesn't have to. (It's arguably odd</span></td>
      </tr>
      <tr>
        <td id="L3271" data-line-number="3271"></td>
        <td id="LC3271">    <span><span>//</span> to call Continue() after Terminate).</span></td>
      </tr>
      <tr>
        <td id="L3272" data-line-number="3272"></td>
        <td id="LC3272">    <span><span>//</span> We're stopped &amp; Synced.</span></td>
      </tr>
      <tr>
        <td id="L3273" data-line-number="3273"></td>
        <td id="LC3273">    <span><span>//</span> For interop-debugging this is very important because the Terminate may not really kill the process</span></td>
      </tr>
      <tr>
        <td id="L3274" data-line-number="3274"></td>
        <td id="LC3274">    <span><span>//</span> until after we continue from the current native debug event.</span></td>
      </tr>
      <tr>
        <td id="L3275" data-line-number="3275"></td>
        <td id="LC3275">    <span>ContinueInternal</span>(<span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L3276" data-line-number="3276"></td>
        <td id="LC3276">
</td>
      </tr>
      <tr>
        <td id="L3277" data-line-number="3277"></td>
        <td id="LC3277">    <span><span>//</span> Implicit release on pRef here (since it's going out of scope)...</span></td>
      </tr>
      <tr>
        <td id="L3278" data-line-number="3278"></td>
        <td id="LC3278">    <span><span>//</span> After this release, this object may be destroyed. So don't use any member functions</span></td>
      </tr>
      <tr>
        <td id="L3279" data-line-number="3279"></td>
        <td id="LC3279">    <span><span>//</span> (including Locks) after here.</span></td>
      </tr>
      <tr>
        <td id="L3280" data-line-number="3280"></td>
        <td id="LC3280">
</td>
      </tr>
      <tr>
        <td id="L3281" data-line-number="3281"></td>
        <td id="LC3281">
</td>
      </tr>
      <tr>
        <td id="L3282" data-line-number="3282"></td>
        <td id="LC3282">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L3283" data-line-number="3283"></td>
        <td id="LC3283">}</td>
      </tr>
      <tr>
        <td id="L3284" data-line-number="3284"></td>
        <td id="LC3284">
</td>
      </tr>
      <tr>
        <td id="L3285" data-line-number="3285"></td>
        <td id="LC3285"><span><span>//</span> This can be called at any time, even if we're in an unrecoverable error state.</span></td>
      </tr>
      <tr>
        <td id="L3286" data-line-number="3286"></td>
        <td id="LC3286">HRESULT <span>CordbProcess::GetID</span>(DWORD *pdwProcessId)</td>
      </tr>
      <tr>
        <td id="L3287" data-line-number="3287"></td>
        <td id="LC3287">{</td>
      </tr>
      <tr>
        <td id="L3288" data-line-number="3288"></td>
        <td id="LC3288">    <span>PUBLIC_REENTRANT_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3289" data-line-number="3289"></td>
        <td id="LC3289">    <span>OK_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3290" data-line-number="3290"></td>
        <td id="LC3290">    <span>VALIDATE_POINTER_TO_OBJECT</span>(pdwProcessId, DWORD *);</td>
      </tr>
      <tr>
        <td id="L3291" data-line-number="3291"></td>
        <td id="LC3291">
</td>
      </tr>
      <tr>
        <td id="L3292" data-line-number="3292"></td>
        <td id="LC3292">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L3293" data-line-number="3293"></td>
        <td id="LC3293">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L3294" data-line-number="3294"></td>
        <td id="LC3294">    {</td>
      </tr>
      <tr>
        <td id="L3295" data-line-number="3295"></td>
        <td id="LC3295">        <span><span>//</span> This shouldn't be used in V3 paths. Normally, we can enforce that by checking against</span></td>
      </tr>
      <tr>
        <td id="L3296" data-line-number="3296"></td>
        <td id="LC3296">        <span><span>//</span> m_pShim. However, this API can be called after being neutered, in which case m_pShim is cleared.</span></td>
      </tr>
      <tr>
        <td id="L3297" data-line-number="3297"></td>
        <td id="LC3297">        <span><span>//</span> So check against 0 instead.</span></td>
      </tr>
      <tr>
        <td id="L3298" data-line-number="3298"></td>
        <td id="LC3298">        <span>if</span> (m_id == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3299" data-line-number="3299"></td>
        <td id="LC3299">        {</td>
      </tr>
      <tr>
        <td id="L3300" data-line-number="3300"></td>
        <td id="LC3300">            *pdwProcessId = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3301" data-line-number="3301"></td>
        <td id="LC3301">            <span>ThrowHR</span>(E_NOTIMPL);</td>
      </tr>
      <tr>
        <td id="L3302" data-line-number="3302"></td>
        <td id="LC3302">        }</td>
      </tr>
      <tr>
        <td id="L3303" data-line-number="3303"></td>
        <td id="LC3303">        *pdwProcessId = <span>GetProcessDescriptor</span>()-&gt;<span>m_Pid</span>;</td>
      </tr>
      <tr>
        <td id="L3304" data-line-number="3304"></td>
        <td id="LC3304">    }</td>
      </tr>
      <tr>
        <td id="L3305" data-line-number="3305"></td>
        <td id="LC3305">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L3306" data-line-number="3306"></td>
        <td id="LC3306">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L3307" data-line-number="3307"></td>
        <td id="LC3307">}</td>
      </tr>
      <tr>
        <td id="L3308" data-line-number="3308"></td>
        <td id="LC3308">
</td>
      </tr>
      <tr>
        <td id="L3309" data-line-number="3309"></td>
        <td id="LC3309"><span><span>//</span> Helper to get process descriptor internally. We know we'll always succeed.</span></td>
      </tr>
      <tr>
        <td id="L3310" data-line-number="3310"></td>
        <td id="LC3310"><span><span>//</span> This is more convient for internal callers since they can just use it as an expression</span></td>
      </tr>
      <tr>
        <td id="L3311" data-line-number="3311"></td>
        <td id="LC3311"><span><span>//</span> without having to check HRESULTS.</span></td>
      </tr>
      <tr>
        <td id="L3312" data-line-number="3312"></td>
        <td id="LC3312"><span>const</span> ProcessDescriptor* <span>CordbProcess::GetProcessDescriptor</span>()</td>
      </tr>
      <tr>
        <td id="L3313" data-line-number="3313"></td>
        <td id="LC3313">{</td>
      </tr>
      <tr>
        <td id="L3314" data-line-number="3314"></td>
        <td id="LC3314">    <span><span>//</span> This shouldn't be used in V3 paths, in which case it's set to 0. Only the shim should be</span></td>
      </tr>
      <tr>
        <td id="L3315" data-line-number="3315"></td>
        <td id="LC3315">    <span><span>//</span> calling this. Assert to catch anybody else.</span></td>
      </tr>
      <tr>
        <td id="L3316" data-line-number="3316"></td>
        <td id="LC3316">    <span>_ASSERTE</span>(m_processDescriptor.<span>IsInitialized</span>());</td>
      </tr>
      <tr>
        <td id="L3317" data-line-number="3317"></td>
        <td id="LC3317">
</td>
      </tr>
      <tr>
        <td id="L3318" data-line-number="3318"></td>
        <td id="LC3318">    <span>return</span> &amp;m_processDescriptor;</td>
      </tr>
      <tr>
        <td id="L3319" data-line-number="3319"></td>
        <td id="LC3319">}</td>
      </tr>
      <tr>
        <td id="L3320" data-line-number="3320"></td>
        <td id="LC3320">
</td>
      </tr>
      <tr>
        <td id="L3321" data-line-number="3321"></td>
        <td id="LC3321">
</td>
      </tr>
      <tr>
        <td id="L3322" data-line-number="3322"></td>
        <td id="LC3322">HRESULT <span>CordbProcess::GetHandle</span>(HANDLE *phProcessHandle)</td>
      </tr>
      <tr>
        <td id="L3323" data-line-number="3323"></td>
        <td id="LC3323">{</td>
      </tr>
      <tr>
        <td id="L3324" data-line-number="3324"></td>
        <td id="LC3324">    <span>PUBLIC_REENTRANT_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3325" data-line-number="3325"></td>
        <td id="LC3325">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>); <span><span>//</span> Once we neuter the process, we close our OS handle to it.</span></td>
      </tr>
      <tr>
        <td id="L3326" data-line-number="3326"></td>
        <td id="LC3326">    <span>VALIDATE_POINTER_TO_OBJECT</span>(phProcessHandle, HANDLE *);</td>
      </tr>
      <tr>
        <td id="L3327" data-line-number="3327"></td>
        <td id="LC3327">
</td>
      </tr>
      <tr>
        <td id="L3328" data-line-number="3328"></td>
        <td id="LC3328">    <span>if</span> (m_pShim == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L3329" data-line-number="3329"></td>
        <td id="LC3329">    {</td>
      </tr>
      <tr>
        <td id="L3330" data-line-number="3330"></td>
        <td id="LC3330">        <span>_ASSERTE</span>(!<span><span>"</span>CordbProcess::GetHandle() should be not be called on the new architecture<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3331" data-line-number="3331"></td>
        <td id="LC3331">        *phProcessHandle = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L3332" data-line-number="3332"></td>
        <td id="LC3332">        <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L3333" data-line-number="3333"></td>
        <td id="LC3333">    }</td>
      </tr>
      <tr>
        <td id="L3334" data-line-number="3334"></td>
        <td id="LC3334">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L3335" data-line-number="3335"></td>
        <td id="LC3335">    {</td>
      </tr>
      <tr>
        <td id="L3336" data-line-number="3336"></td>
        <td id="LC3336">        *phProcessHandle = m_handle;</td>
      </tr>
      <tr>
        <td id="L3337" data-line-number="3337"></td>
        <td id="LC3337">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L3338" data-line-number="3338"></td>
        <td id="LC3338">    }</td>
      </tr>
      <tr>
        <td id="L3339" data-line-number="3339"></td>
        <td id="LC3339">}</td>
      </tr>
      <tr>
        <td id="L3340" data-line-number="3340"></td>
        <td id="LC3340">
</td>
      </tr>
      <tr>
        <td id="L3341" data-line-number="3341"></td>
        <td id="LC3341">HRESULT <span>CordbProcess::IsRunning</span>(BOOL *pbRunning)</td>
      </tr>
      <tr>
        <td id="L3342" data-line-number="3342"></td>
        <td id="LC3342">{</td>
      </tr>
      <tr>
        <td id="L3343" data-line-number="3343"></td>
        <td id="LC3343">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3344" data-line-number="3344"></td>
        <td id="LC3344">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3345" data-line-number="3345"></td>
        <td id="LC3345">    <span>VALIDATE_POINTER_TO_OBJECT</span>(pbRunning, BOOL*);</td>
      </tr>
      <tr>
        <td id="L3346" data-line-number="3346"></td>
        <td id="LC3346">
</td>
      </tr>
      <tr>
        <td id="L3347" data-line-number="3347"></td>
        <td id="LC3347">    *pbRunning = !<span>GetSynchronized</span>();</td>
      </tr>
      <tr>
        <td id="L3348" data-line-number="3348"></td>
        <td id="LC3348">
</td>
      </tr>
      <tr>
        <td id="L3349" data-line-number="3349"></td>
        <td id="LC3349">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L3350" data-line-number="3350"></td>
        <td id="LC3350">}</td>
      </tr>
      <tr>
        <td id="L3351" data-line-number="3351"></td>
        <td id="LC3351">
</td>
      </tr>
      <tr>
        <td id="L3352" data-line-number="3352"></td>
        <td id="LC3352">HRESULT <span>CordbProcess::EnableSynchronization</span>(BOOL bEnableSynchronization)</td>
      </tr>
      <tr>
        <td id="L3353" data-line-number="3353"></td>
        <td id="LC3353">{</td>
      </tr>
      <tr>
        <td id="L3354" data-line-number="3354"></td>
        <td id="LC3354">    <span><span>/*</span> !!! <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3355" data-line-number="3355"></td>
        <td id="LC3355">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3356" data-line-number="3356"></td>
        <td id="LC3356">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L3357" data-line-number="3357"></td>
        <td id="LC3357">}</td>
      </tr>
      <tr>
        <td id="L3358" data-line-number="3358"></td>
        <td id="LC3358">
</td>
      </tr>
      <tr>
        <td id="L3359" data-line-number="3359"></td>
        <td id="LC3359">HRESULT <span>CordbProcess::Stop</span>(DWORD dwTimeout)</td>
      </tr>
      <tr>
        <td id="L3360" data-line-number="3360"></td>
        <td id="LC3360">{</td>
      </tr>
      <tr>
        <td id="L3361" data-line-number="3361"></td>
        <td id="LC3361">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3362" data-line-number="3362"></td>
        <td id="LC3362">    <span>CORDBRequireProcessStateOK</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3363" data-line-number="3363"></td>
        <td id="LC3363">
</td>
      </tr>
      <tr>
        <td id="L3364" data-line-number="3364"></td>
        <td id="LC3364">    HRESULT hr = <span>StopInternal</span>(dwTimeout, <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L3365" data-line-number="3365"></td>
        <td id="LC3365">
</td>
      </tr>
      <tr>
        <td id="L3366" data-line-number="3366"></td>
        <td id="LC3366">    <span>return</span> <span>ErrWrapper</span>(hr);</td>
      </tr>
      <tr>
        <td id="L3367" data-line-number="3367"></td>
        <td id="LC3367">}</td>
      </tr>
      <tr>
        <td id="L3368" data-line-number="3368"></td>
        <td id="LC3368">
</td>
      </tr>
      <tr>
        <td id="L3369" data-line-number="3369"></td>
        <td id="LC3369">HRESULT <span>CordbProcess::StopInternal</span>(DWORD dwTimeout, VMPTR_AppDomain pAppDomainToken)</td>
      </tr>
      <tr>
        <td id="L3370" data-line-number="3370"></td>
        <td id="LC3370">{</td>
      </tr>
      <tr>
        <td id="L3371" data-line-number="3371"></td>
        <td id="LC3371">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: stopping process 0x%x(%d) with timeout %d<span>\n</span><span>"</span></span>, m_id, m_id,  dwTimeout));</td>
      </tr>
      <tr>
        <td id="L3372" data-line-number="3372"></td>
        <td id="LC3372">
</td>
      </tr>
      <tr>
        <td id="L3373" data-line-number="3373"></td>
        <td id="LC3373">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3374" data-line-number="3374"></td>
        <td id="LC3374">
</td>
      </tr>
      <tr>
        <td id="L3375" data-line-number="3375"></td>
        <td id="LC3375">    <span><span>//</span> Stop + Continue are executed under the Stop-Go lock. This makes them atomic.</span></td>
      </tr>
      <tr>
        <td id="L3376" data-line-number="3376"></td>
        <td id="LC3376">    <span><span>//</span> We'll toggle the process-lock (b/c we communicate w/ the W32et, so just the process-lock is</span></td>
      </tr>
      <tr>
        <td id="L3377" data-line-number="3377"></td>
        <td id="LC3377">    <span><span>//</span> not sufficient to make this atomic).</span></td>
      </tr>
      <tr>
        <td id="L3378" data-line-number="3378"></td>
        <td id="LC3378">    <span><span>//</span> It's ok to take this lock before checking if the CordbProcess has been neutered because</span></td>
      </tr>
      <tr>
        <td id="L3379" data-line-number="3379"></td>
        <td id="LC3379">    <span><span>//</span> the lock is destroyed in the dtor after neutering.</span></td>
      </tr>
      <tr>
        <td id="L3380" data-line-number="3380"></td>
        <td id="LC3380">    RSLockHolder <span>ch</span>(&amp;m_StopGoLock);</td>
      </tr>
      <tr>
        <td id="L3381" data-line-number="3381"></td>
        <td id="LC3381">
</td>
      </tr>
      <tr>
        <td id="L3382" data-line-number="3382"></td>
        <td id="LC3382">    <span><span>//</span> Check if this CordbProcess has been neutered under the SG lock.</span></td>
      </tr>
      <tr>
        <td id="L3383" data-line-number="3383"></td>
        <td id="LC3383">    <span><span>//</span> Otherwise it's possible to race with Detach() and Terminate().</span></td>
      </tr>
      <tr>
        <td id="L3384" data-line-number="3384"></td>
        <td id="LC3384">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3385" data-line-number="3385"></td>
        <td id="LC3385">    <span>CORDBFailIfOnWin32EventThread</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3386" data-line-number="3386"></td>
        <td id="LC3386">
</td>
      </tr>
      <tr>
        <td id="L3387" data-line-number="3387"></td>
        <td id="LC3387">    <span>if</span> (m_pShim == <span>NULL</span>) <span><span>//</span> Stop/Go is moved off to the shim</span></td>
      </tr>
      <tr>
        <td id="L3388" data-line-number="3388"></td>
        <td id="LC3388">    {</td>
      </tr>
      <tr>
        <td id="L3389" data-line-number="3389"></td>
        <td id="LC3389">        <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L3390" data-line-number="3390"></td>
        <td id="LC3390">    }</td>
      </tr>
      <tr>
        <td id="L3391" data-line-number="3391"></td>
        <td id="LC3391">
</td>
      </tr>
      <tr>
        <td id="L3392" data-line-number="3392"></td>
        <td id="LC3392">
</td>
      </tr>
      <tr>
        <td id="L3393" data-line-number="3393"></td>
        <td id="LC3393">    DebuggerIPCEvent* event;</td>
      </tr>
      <tr>
        <td id="L3394" data-line-number="3394"></td>
        <td id="LC3394">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L3395" data-line-number="3395"></td>
        <td id="LC3395">
</td>
      </tr>
      <tr>
        <td id="L3396" data-line-number="3396"></td>
        <td id="LC3396">    <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::SI, timeout=%d, this=%p<span>\n</span><span>"</span></span>, dwTimeout, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3397" data-line-number="3397"></td>
        <td id="LC3397">
</td>
      </tr>
      <tr>
        <td id="L3398" data-line-number="3398"></td>
        <td id="LC3398">    <span><span>//</span> Stop() is a syncronous (blocking) operation. Furthermore, we have no way to cancel the async-break request.</span></td>
      </tr>
      <tr>
        <td id="L3399" data-line-number="3399"></td>
        <td id="LC3399">    <span><span>//</span> Thus if we returned early on a timeout, then we'll be in a random state b/c the LS may get stopped at any</span></td>
      </tr>
      <tr>
        <td id="L3400" data-line-number="3400"></td>
        <td id="LC3400">    <span><span>//</span> later spot.</span></td>
      </tr>
      <tr>
        <td id="L3401" data-line-number="3401"></td>
        <td id="LC3401">    <span><span>//</span> One solution just require the param is INFINITE until we fix this and E_INVALIDARG if it's not.</span></td>
      </tr>
      <tr>
        <td id="L3402" data-line-number="3402"></td>
        <td id="LC3402">    <span><span>//</span> But that could be a breaking change (what if a debugger passes in a really large value that's effectively</span></td>
      </tr>
      <tr>
        <td id="L3403" data-line-number="3403"></td>
        <td id="LC3403">    <span><span>//</span> INFINITE).</span></td>
      </tr>
      <tr>
        <td id="L3404" data-line-number="3404"></td>
        <td id="LC3404">    <span><span>//</span> So we'll just ignore it and always treat it as infinite.</span></td>
      </tr>
      <tr>
        <td id="L3405" data-line-number="3405"></td>
        <td id="LC3405">    dwTimeout = INFINITE;</td>
      </tr>
      <tr>
        <td id="L3406" data-line-number="3406"></td>
        <td id="LC3406">
</td>
      </tr>
      <tr>
        <td id="L3407" data-line-number="3407"></td>
        <td id="LC3407">    <span><span>//</span> Do the checks on the process state under the SG lock.  This ensures that another thread cannot come in</span></td>
      </tr>
      <tr>
        <td id="L3408" data-line-number="3408"></td>
        <td id="LC3408">    <span><span>//</span> after we do the checks and take the lock before we do.  For example, Detach() can race with Stop() such</span></td>
      </tr>
      <tr>
        <td id="L3409" data-line-number="3409"></td>
        <td id="LC3409">    <span><span>//</span> that:</span></td>
      </tr>
      <tr>
        <td id="L3410" data-line-number="3410"></td>
        <td id="LC3410">    <span><span>//</span>      1. Thread A calls CordbProcess::Detach() and takes the stop-go lock</span></td>
      </tr>
      <tr>
        <td id="L3411" data-line-number="3411"></td>
        <td id="LC3411">    <span><span>//</span>      2. Thread B calls CordbProcess::Stop(), passes all the checks, and then blocks on the stop-go lock</span></td>
      </tr>
      <tr>
        <td id="L3412" data-line-number="3412"></td>
        <td id="LC3412">    <span><span>//</span>      3. Thread A finishes the detach, invalides the process state, cleans all the resources, and then</span></td>
      </tr>
      <tr>
        <td id="L3413" data-line-number="3413"></td>
        <td id="LC3413">    <span><span>//</span>         releases the stop-go lock</span></td>
      </tr>
      <tr>
        <td id="L3414" data-line-number="3414"></td>
        <td id="LC3414">    <span><span>//</span>      4. Thread B gets the lock, but everything has changed</span></td>
      </tr>
      <tr>
        <td id="L3415" data-line-number="3415"></td>
        <td id="LC3415">    <span>CORDBRequireProcessStateOK</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3416" data-line-number="3416"></td>
        <td id="LC3416">
</td>
      </tr>
      <tr>
        <td id="L3417" data-line-number="3417"></td>
        <td id="LC3417">    <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L3418" data-line-number="3418"></td>
        <td id="LC3418">
</td>
      </tr>
      <tr>
        <td id="L3419" data-line-number="3419"></td>
        <td id="LC3419">    <span>ASSERT_SINGLE_THREAD_ONLY</span>(<span>HoldsLock</span>(&amp;m_StopGoLock));</td>
      </tr>
      <tr>
        <td id="L3420" data-line-number="3420"></td>
        <td id="LC3420">
</td>
      </tr>
      <tr>
        <td id="L3421" data-line-number="3421"></td>
        <td id="LC3421">    <span><span>//</span> Don't need to stop if the process hasn't even executed any managed code yet.</span></td>
      </tr>
      <tr>
        <td id="L3422" data-line-number="3422"></td>
        <td id="LC3422">    <span>if</span> (!m_initialized)</td>
      </tr>
      <tr>
        <td id="L3423" data-line-number="3423"></td>
        <td id="LC3423">    {</td>
      </tr>
      <tr>
        <td id="L3424" data-line-number="3424"></td>
        <td id="LC3424">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: process isn't initialized yet.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L3425" data-line-number="3425"></td>
        <td id="LC3425">
</td>
      </tr>
      <tr>
        <td id="L3426" data-line-number="3426"></td>
        <td id="LC3426">        <span><span>//</span> Mark the process as synchronized so no events will be dispatched until the thing is continued.</span></td>
      </tr>
      <tr>
        <td id="L3427" data-line-number="3427"></td>
        <td id="LC3427">        <span>SetSynchronized</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L3428" data-line-number="3428"></td>
        <td id="LC3428">
</td>
      </tr>
      <tr>
        <td id="L3429" data-line-number="3429"></td>
        <td id="LC3429">        <span><span>//</span> Remember uninitialized stop...</span></td>
      </tr>
      <tr>
        <td id="L3430" data-line-number="3430"></td>
        <td id="LC3430">        m_uninitializedStop = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3431" data-line-number="3431"></td>
        <td id="LC3431">
</td>
      </tr>
      <tr>
        <td id="L3432" data-line-number="3432"></td>
        <td id="LC3432">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L3433" data-line-number="3433"></td>
        <td id="LC3433">        <span><span>//</span> If we're Win32 attached, then suspend all the unmanaged threads in the process.</span></td>
      </tr>
      <tr>
        <td id="L3434" data-line-number="3434"></td>
        <td id="LC3434">        <span><span>//</span> We may or may not be stopped at a native debug event.</span></td>
      </tr>
      <tr>
        <td id="L3435" data-line-number="3435"></td>
        <td id="LC3435">        <span>if</span> (<span>IsInteropDebugging</span>())</td>
      </tr>
      <tr>
        <td id="L3436" data-line-number="3436"></td>
        <td id="LC3436">        {</td>
      </tr>
      <tr>
        <td id="L3437" data-line-number="3437"></td>
        <td id="LC3437">            <span>SuspendUnmanagedThreads</span>();</td>
      </tr>
      <tr>
        <td id="L3438" data-line-number="3438"></td>
        <td id="LC3438">        }</td>
      </tr>
      <tr>
        <td id="L3439" data-line-number="3439"></td>
        <td id="LC3439">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L3440" data-line-number="3440"></td>
        <td id="LC3440">
</td>
      </tr>
      <tr>
        <td id="L3441" data-line-number="3441"></td>
        <td id="LC3441">        <span><span>//</span> Get the RC Event Thread to stop listening to the process.</span></td>
      </tr>
      <tr>
        <td id="L3442" data-line-number="3442"></td>
        <td id="LC3442">        m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L3443" data-line-number="3443"></td>
        <td id="LC3443">
</td>
      </tr>
      <tr>
        <td id="L3444" data-line-number="3444"></td>
        <td id="LC3444">        hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L3445" data-line-number="3445"></td>
        <td id="LC3445">        <span>goto</span> Exit;</td>
      </tr>
      <tr>
        <td id="L3446" data-line-number="3446"></td>
        <td id="LC3446">    }</td>
      </tr>
      <tr>
        <td id="L3447" data-line-number="3447"></td>
        <td id="LC3447">
</td>
      </tr>
      <tr>
        <td id="L3448" data-line-number="3448"></td>
        <td id="LC3448">    <span><span>//</span> Don't need to stop if the process is already synchronized.</span></td>
      </tr>
      <tr>
        <td id="L3449" data-line-number="3449"></td>
        <td id="LC3449">    <span><span>//</span> @todo - Issue 129917. It's possible that we'll get a call to Stop when the LS is already stopped.</span></td>
      </tr>
      <tr>
        <td id="L3450" data-line-number="3450"></td>
        <td id="LC3450">    <span><span>//</span> Sending an AsyncBreak would deadlock here (b/c the LS will ignore the frivilous request,</span></td>
      </tr>
      <tr>
        <td id="L3451" data-line-number="3451"></td>
        <td id="LC3451">    <span><span>//</span> and thus never send a SyncComplete, and thus our Waiting on the SyncComplete will deadlock).</span></td>
      </tr>
      <tr>
        <td id="L3452" data-line-number="3452"></td>
        <td id="LC3452">    <span><span>//</span> We avoid this case by checking m_syncCompleteReceived (which should roughly correspond to</span></td>
      </tr>
      <tr>
        <td id="L3453" data-line-number="3453"></td>
        <td id="LC3453">    <span><span>//</span> the LS's m_stopped variable).</span></td>
      </tr>
      <tr>
        <td id="L3454" data-line-number="3454"></td>
        <td id="LC3454">    <span><span>//</span> One window this can happen is after a Continue() pings the RCET but before the RCET actually sweeps + flushes.</span></td>
      </tr>
      <tr>
        <td id="L3455" data-line-number="3455"></td>
        <td id="LC3455">
</td>
      </tr>
      <tr>
        <td id="L3456" data-line-number="3456"></td>
        <td id="LC3456">    <span>if</span> (<span>GetSynchronized</span>() || <span>GetSyncCompleteRecv</span>())</td>
      </tr>
      <tr>
        <td id="L3457" data-line-number="3457"></td>
        <td id="LC3457">    {</td>
      </tr>
      <tr>
        <td id="L3458" data-line-number="3458"></td>
        <td id="LC3458">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: process was already synchronized. m_syncCompleteReceived=%d<span>\n</span><span>"</span></span>, <span>GetSyncCompleteRecv</span>()));</td>
      </tr>
      <tr>
        <td id="L3459" data-line-number="3459"></td>
        <td id="LC3459">
</td>
      </tr>
      <tr>
        <td id="L3460" data-line-number="3460"></td>
        <td id="LC3460">        <span>if</span> (<span>GetSyncCompleteRecv</span>())</td>
      </tr>
      <tr>
        <td id="L3461" data-line-number="3461"></td>
        <td id="LC3461">        {</td>
      </tr>
      <tr>
        <td id="L3462" data-line-number="3462"></td>
        <td id="LC3462">            <span><span>//</span> We must be in that window alluded to above (while the RCET is sweeping). Re-ping the RCET.</span></td>
      </tr>
      <tr>
        <td id="L3463" data-line-number="3463"></td>
        <td id="LC3463">            <span>SetSynchronized</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L3464" data-line-number="3464"></td>
        <td id="LC3464">            m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L3465" data-line-number="3465"></td>
        <td id="LC3465">        }</td>
      </tr>
      <tr>
        <td id="L3466" data-line-number="3466"></td>
        <td id="LC3466">        hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L3467" data-line-number="3467"></td>
        <td id="LC3467">        <span>goto</span> Exit;</td>
      </tr>
      <tr>
        <td id="L3468" data-line-number="3468"></td>
        <td id="LC3468">    }</td>
      </tr>
      <tr>
        <td id="L3469" data-line-number="3469"></td>
        <td id="LC3469">
</td>
      </tr>
      <tr>
        <td id="L3470" data-line-number="3470"></td>
        <td id="LC3470">    <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: process not sync'd, requesting stop.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3471" data-line-number="3471"></td>
        <td id="LC3471">
</td>
      </tr>
      <tr>
        <td id="L3472" data-line-number="3472"></td>
        <td id="LC3472">    m_stopRequested = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3473" data-line-number="3473"></td>
        <td id="LC3473">
</td>
      </tr>
      <tr>
        <td id="L3474" data-line-number="3474"></td>
        <td id="LC3474">    <span><span>//</span> We don't want to dispatch any Win32 debug events while we're trying to stop.</span></td>
      </tr>
      <tr>
        <td id="L3475" data-line-number="3475"></td>
        <td id="LC3475">    <span><span>//</span> Setting m_specialDeferment=true means that any debug event we get will be queued and not dispatched.</span></td>
      </tr>
      <tr>
        <td id="L3476" data-line-number="3476"></td>
        <td id="LC3476">    <span><span>//</span> We do this to avoid a nested call to Continue.</span></td>
      </tr>
      <tr>
        <td id="L3477" data-line-number="3477"></td>
        <td id="LC3477">    <span><span>//</span> These defered events will get dispatched when somebody calls continue (and since they're calling</span></td>
      </tr>
      <tr>
        <td id="L3478" data-line-number="3478"></td>
        <td id="LC3478">    <span><span>//</span> stop now, they must call continue eventually).</span></td>
      </tr>
      <tr>
        <td id="L3479" data-line-number="3479"></td>
        <td id="LC3479">    <span><span>//</span> Note that if we got a Win32 debug event between when we took the Stop-Go lock above and now,</span></td>
      </tr>
      <tr>
        <td id="L3480" data-line-number="3480"></td>
        <td id="LC3480">    <span><span>//</span> that even may have been dispatched. We're ok because SSFW32Stop will hijack that event and continue it,</span></td>
      </tr>
      <tr>
        <td id="L3481" data-line-number="3481"></td>
        <td id="LC3481">    <span><span>//</span> and then all future events will be queued.</span></td>
      </tr>
      <tr>
        <td id="L3482" data-line-number="3482"></td>
        <td id="LC3482">    m_specialDeferment = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3483" data-line-number="3483"></td>
        <td id="LC3483">    <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3484" data-line-number="3484"></td>
        <td id="LC3484">
</td>
      </tr>
      <tr>
        <td id="L3485" data-line-number="3485"></td>
        <td id="LC3485">    BOOL asyncBreakSent;</td>
      </tr>
      <tr>
        <td id="L3486" data-line-number="3486"></td>
        <td id="LC3486">
</td>
      </tr>
      <tr>
        <td id="L3487" data-line-number="3487"></td>
        <td id="LC3487">    <span><span>//</span> We need to ensure that the helper thread is alive.</span></td>
      </tr>
      <tr>
        <td id="L3488" data-line-number="3488"></td>
        <td id="LC3488">    hr = <span>this</span>-&gt;<span>StartSyncFromWin32Stop</span>(&amp;asyncBreakSent);</td>
      </tr>
      <tr>
        <td id="L3489" data-line-number="3489"></td>
        <td id="LC3489">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L3490" data-line-number="3490"></td>
        <td id="LC3490">    {</td>
      </tr>
      <tr>
        <td id="L3491" data-line-number="3491"></td>
        <td id="LC3491">        <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L3492" data-line-number="3492"></td>
        <td id="LC3492">    }</td>
      </tr>
      <tr>
        <td id="L3493" data-line-number="3493"></td>
        <td id="LC3493">
</td>
      </tr>
      <tr>
        <td id="L3494" data-line-number="3494"></td>
        <td id="LC3494">
</td>
      </tr>
      <tr>
        <td id="L3495" data-line-number="3495"></td>
        <td id="LC3495">    <span>if</span> (asyncBreakSent)</td>
      </tr>
      <tr>
        <td id="L3496" data-line-number="3496"></td>
        <td id="LC3496">    {</td>
      </tr>
      <tr>
        <td id="L3497" data-line-number="3497"></td>
        <td id="LC3497">        hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L3498" data-line-number="3498"></td>
        <td id="LC3498">        <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L3499" data-line-number="3499"></td>
        <td id="LC3499">
</td>
      </tr>
      <tr>
        <td id="L3500" data-line-number="3500"></td>
        <td id="LC3500">        m_stopRequested = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3501" data-line-number="3501"></td>
        <td id="LC3501">
</td>
      </tr>
      <tr>
        <td id="L3502" data-line-number="3502"></td>
        <td id="LC3502">        <span>goto</span> Exit;</td>
      </tr>
      <tr>
        <td id="L3503" data-line-number="3503"></td>
        <td id="LC3503">    }</td>
      </tr>
      <tr>
        <td id="L3504" data-line-number="3504"></td>
        <td id="LC3504">
</td>
      </tr>
      <tr>
        <td id="L3505" data-line-number="3505"></td>
        <td id="LC3505">    <span><span>//</span> Send the async break event to the RC.</span></td>
      </tr>
      <tr>
        <td id="L3506" data-line-number="3506"></td>
        <td id="LC3506">    event = (DebuggerIPCEvent*) <span>_alloca</span>(CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L3507" data-line-number="3507"></td>
        <td id="LC3507">    <span>InitIPCEvent</span>(event, DB_IPCE_ASYNC_BREAK, <span>false</span>, pAppDomainToken);</td>
      </tr>
      <tr>
        <td id="L3508" data-line-number="3508"></td>
        <td id="LC3508">
</td>
      </tr>
      <tr>
        <td id="L3509" data-line-number="3509"></td>
        <td id="LC3509">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: sending async stop to appd 0x%x.<span>\n</span><span>"</span></span>, <span>VmPtrToCookie</span>(pAppDomainToken));</td>
      </tr>
      <tr>
        <td id="L3510" data-line-number="3510"></td>
        <td id="LC3510">
</td>
      </tr>
      <tr>
        <td id="L3511" data-line-number="3511"></td>
        <td id="LC3511">    hr = m_cordb-&gt;<span>SendIPCEvent</span>(<span>this</span>, event, CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L3512" data-line-number="3512"></td>
        <td id="LC3512">    hr = <span>WORST_HR</span>(hr, event-&gt;<span>hr</span>);</td>
      </tr>
      <tr>
        <td id="L3513" data-line-number="3513"></td>
        <td id="LC3513">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L3514" data-line-number="3514"></td>
        <td id="LC3514">    {</td>
      </tr>
      <tr>
        <td id="L3515" data-line-number="3515"></td>
        <td id="LC3515">        <span><span>//</span> We don't hold the lock so just return immediately. Don't adjust stop-count.</span></td>
      </tr>
      <tr>
        <td id="L3516" data-line-number="3516"></td>
        <td id="LC3516">        <span>_ASSERTE</span>(!<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L3517" data-line-number="3517"></td>
        <td id="LC3517">        <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L3518" data-line-number="3518"></td>
        <td id="LC3518">    }</td>
      </tr>
      <tr>
        <td id="L3519" data-line-number="3519"></td>
        <td id="LC3519">
</td>
      </tr>
      <tr>
        <td id="L3520" data-line-number="3520"></td>
        <td id="LC3520">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: sent async stop to appd 0x%x.<span>\n</span><span>"</span></span>, <span>VmPtrToCookie</span>(pAppDomainToken)));</td>
      </tr>
      <tr>
        <td id="L3521" data-line-number="3521"></td>
        <td id="LC3521">
</td>
      </tr>
      <tr>
        <td id="L3522" data-line-number="3522"></td>
        <td id="LC3522">    <span><span>//</span> Wait for the sync complete message to come in. Note: when the sync complete message arrives to the RCEventThread,</span></td>
      </tr>
      <tr>
        <td id="L3523" data-line-number="3523"></td>
        <td id="LC3523">    <span><span>//</span> it will mark the process as synchronized and _not_ dispatch any events. Instead, it will set m_stopWaitEvent</span></td>
      </tr>
      <tr>
        <td id="L3524" data-line-number="3524"></td>
        <td id="LC3524">    <span><span>//</span> which will let this function return. If the user wants to process any queued events, they will need to call</span></td>
      </tr>
      <tr>
        <td id="L3525" data-line-number="3525"></td>
        <td id="LC3525">    <span><span>//</span> Continue.</span></td>
      </tr>
      <tr>
        <td id="L3526" data-line-number="3526"></td>
        <td id="LC3526">    <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: waiting for event.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3527" data-line-number="3527"></td>
        <td id="LC3527">
</td>
      </tr>
      <tr>
        <td id="L3528" data-line-number="3528"></td>
        <td id="LC3528">    DWORD ret;</td>
      </tr>
      <tr>
        <td id="L3529" data-line-number="3529"></td>
        <td id="LC3529">    ret = <span>SafeWaitForSingleObject</span>(<span>this</span>, m_stopWaitEvent, dwTimeout);</td>
      </tr>
      <tr>
        <td id="L3530" data-line-number="3530"></td>
        <td id="LC3530">
</td>
      </tr>
      <tr>
        <td id="L3531" data-line-number="3531"></td>
        <td id="LC3531">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: got event, %d.<span>\n</span><span>"</span></span>, ret);</td>
      </tr>
      <tr>
        <td id="L3532" data-line-number="3532"></td>
        <td id="LC3532">
</td>
      </tr>
      <tr>
        <td id="L3533" data-line-number="3533"></td>
        <td id="LC3533">    <span>if</span> (m_terminated)</td>
      </tr>
      <tr>
        <td id="L3534" data-line-number="3534"></td>
        <td id="LC3534">    {</td>
      </tr>
      <tr>
        <td id="L3535" data-line-number="3535"></td>
        <td id="LC3535">        <span>return</span> CORDBG_E_PROCESS_TERMINATED;</td>
      </tr>
      <tr>
        <td id="L3536" data-line-number="3536"></td>
        <td id="LC3536">    }</td>
      </tr>
      <tr>
        <td id="L3537" data-line-number="3537"></td>
        <td id="LC3537">
</td>
      </tr>
      <tr>
        <td id="L3538" data-line-number="3538"></td>
        <td id="LC3538">    <span>if</span> (ret == WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L3539" data-line-number="3539"></td>
        <td id="LC3539">    {</td>
      </tr>
      <tr>
        <td id="L3540" data-line-number="3540"></td>
        <td id="LC3540">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: process stopped.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L3541" data-line-number="3541"></td>
        <td id="LC3541">
</td>
      </tr>
      <tr>
        <td id="L3542" data-line-number="3542"></td>
        <td id="LC3542">        m_stopRequested = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3543" data-line-number="3543"></td>
        <td id="LC3543">        m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L3544" data-line-number="3544"></td>
        <td id="LC3544">
</td>
      </tr>
      <tr>
        <td id="L3545" data-line-number="3545"></td>
        <td id="LC3545">        hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L3546" data-line-number="3546"></td>
        <td id="LC3546">        <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L3547" data-line-number="3547"></td>
        <td id="LC3547">        <span>goto</span> Exit;</td>
      </tr>
      <tr>
        <td id="L3548" data-line-number="3548"></td>
        <td id="LC3548">    }</td>
      </tr>
      <tr>
        <td id="L3549" data-line-number="3549"></td>
        <td id="LC3549">    <span>else</span> <span>if</span> (ret == WAIT_TIMEOUT)</td>
      </tr>
      <tr>
        <td id="L3550" data-line-number="3550"></td>
        <td id="LC3550">    {</td>
      </tr>
      <tr>
        <td id="L3551" data-line-number="3551"></td>
        <td id="LC3551">        hr = <span>ErrWrapper</span>(CORDBG_E_TIMEOUT);</td>
      </tr>
      <tr>
        <td id="L3552" data-line-number="3552"></td>
        <td id="LC3552">    }</td>
      </tr>
      <tr>
        <td id="L3553" data-line-number="3553"></td>
        <td id="LC3553">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L3554" data-line-number="3554"></td>
        <td id="LC3554">        hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L3555" data-line-number="3555"></td>
        <td id="LC3555">
</td>
      </tr>
      <tr>
        <td id="L3556" data-line-number="3556"></td>
        <td id="LC3556">    <span><span>//</span> We came out of the wait, but we weren't signaled because a sync complete event came in. Re-check the process and</span></td>
      </tr>
      <tr>
        <td id="L3557" data-line-number="3557"></td>
        <td id="LC3557">    <span><span>//</span> remove the stop requested flag.</span></td>
      </tr>
      <tr>
        <td id="L3558" data-line-number="3558"></td>
        <td id="LC3558">    <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L3559" data-line-number="3559"></td>
        <td id="LC3559">    m_stopRequested = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3560" data-line-number="3560"></td>
        <td id="LC3560">
</td>
      </tr>
      <tr>
        <td id="L3561" data-line-number="3561"></td>
        <td id="LC3561">    <span>if</span> (<span>GetSynchronized</span>())</td>
      </tr>
      <tr>
        <td id="L3562" data-line-number="3562"></td>
        <td id="LC3562">    {</td>
      </tr>
      <tr>
        <td id="L3563" data-line-number="3563"></td>
        <td id="LC3563">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: process stopped.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L3564" data-line-number="3564"></td>
        <td id="LC3564">
</td>
      </tr>
      <tr>
        <td id="L3565" data-line-number="3565"></td>
        <td id="LC3565">        m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L3566" data-line-number="3566"></td>
        <td id="LC3566">
</td>
      </tr>
      <tr>
        <td id="L3567" data-line-number="3567"></td>
        <td id="LC3567">        hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L3568" data-line-number="3568"></td>
        <td id="LC3568">    }</td>
      </tr>
      <tr>
        <td id="L3569" data-line-number="3569"></td>
        <td id="LC3569">
</td>
      </tr>
      <tr>
        <td id="L3570" data-line-number="3570"></td>
        <td id="LC3570">Exit:</td>
      </tr>
      <tr>
        <td id="L3571" data-line-number="3571"></td>
        <td id="LC3571">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L3572" data-line-number="3572"></td>
        <td id="LC3572">
</td>
      </tr>
      <tr>
        <td id="L3573" data-line-number="3573"></td>
        <td id="LC3573">    <span><span>//</span> Stop queuing any Win32 Debug events. We should be synchronized now.</span></td>
      </tr>
      <tr>
        <td id="L3574" data-line-number="3574"></td>
        <td id="LC3574">    m_specialDeferment = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3575" data-line-number="3575"></td>
        <td id="LC3575">
</td>
      </tr>
      <tr>
        <td id="L3576" data-line-number="3576"></td>
        <td id="LC3576">    <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L3577" data-line-number="3577"></td>
        <td id="LC3577">    {</td>
      </tr>
      <tr>
        <td id="L3578" data-line-number="3578"></td>
        <td id="LC3578">        <span>IncStopCount</span>();</td>
      </tr>
      <tr>
        <td id="L3579" data-line-number="3579"></td>
        <td id="LC3579">    }</td>
      </tr>
      <tr>
        <td id="L3580" data-line-number="3580"></td>
        <td id="LC3580">
</td>
      </tr>
      <tr>
        <td id="L3581" data-line-number="3581"></td>
        <td id="LC3581">    <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::S: returning from Stop, hr=0x%08x, m_stopCount=%d.<span>\n</span><span>"</span></span>, hr, <span>GetStopCount</span>());</td>
      </tr>
      <tr>
        <td id="L3582" data-line-number="3582"></td>
        <td id="LC3582">
</td>
      </tr>
      <tr>
        <td id="L3583" data-line-number="3583"></td>
        <td id="LC3583">    <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3584" data-line-number="3584"></td>
        <td id="LC3584">
</td>
      </tr>
      <tr>
        <td id="L3585" data-line-number="3585"></td>
        <td id="LC3585">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L3586" data-line-number="3586"></td>
        <td id="LC3586">}</td>
      </tr>
      <tr>
        <td id="L3587" data-line-number="3587"></td>
        <td id="LC3587">
</td>
      </tr>
      <tr>
        <td id="L3588" data-line-number="3588"></td>
        <td id="LC3588"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3589" data-line-number="3589"></td>
        <td id="LC3589"><span><span>//</span> Clear all RS state on all CordbThread objects.</span></td>
      </tr>
      <tr>
        <td id="L3590" data-line-number="3590"></td>
        <td id="LC3590"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3591" data-line-number="3591"></td>
        <td id="LC3591"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L3592" data-line-number="3592"></td>
        <td id="LC3592"><span><span>//</span>   This clears all the thread-related state that the RS may have cached,</span></td>
      </tr>
      <tr>
        <td id="L3593" data-line-number="3593"></td>
        <td id="LC3593"><span><span>//</span>   such as locals, frames, etc.</span></td>
      </tr>
      <tr>
        <td id="L3594" data-line-number="3594"></td>
        <td id="LC3594"><span><span>//</span>   This would be called if the debugger is resuming execution.</span></td>
      </tr>
      <tr>
        <td id="L3595" data-line-number="3595"></td>
        <td id="LC3595"><span>void</span> <span>CordbProcess::MarkAllThreadsDirty</span>()</td>
      </tr>
      <tr>
        <td id="L3596" data-line-number="3596"></td>
        <td id="LC3596">{</td>
      </tr>
      <tr>
        <td id="L3597" data-line-number="3597"></td>
        <td id="LC3597">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3598" data-line-number="3598"></td>
        <td id="LC3598">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L3599" data-line-number="3599"></td>
        <td id="LC3599">
</td>
      </tr>
      <tr>
        <td id="L3600" data-line-number="3600"></td>
        <td id="LC3600">    CordbThread * pThread;</td>
      </tr>
      <tr>
        <td id="L3601" data-line-number="3601"></td>
        <td id="LC3601">    HASHFIND find;</td>
      </tr>
      <tr>
        <td id="L3602" data-line-number="3602"></td>
        <td id="LC3602">
</td>
      </tr>
      <tr>
        <td id="L3603" data-line-number="3603"></td>
        <td id="LC3603">    <span><span>//</span> We don't need to prepopulate here (to collect LS state) because we're just updating RS state.</span></td>
      </tr>
      <tr>
        <td id="L3604" data-line-number="3604"></td>
        <td id="LC3604">    <span>for</span> (pThread =  m_userThreads.<span>FindFirst</span>(&amp;find);</td>
      </tr>
      <tr>
        <td id="L3605" data-line-number="3605"></td>
        <td id="LC3605">         pThread != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L3606" data-line-number="3606"></td>
        <td id="LC3606">         pThread =  m_userThreads.<span>FindNext</span>(&amp;find))</td>
      </tr>
      <tr>
        <td id="L3607" data-line-number="3607"></td>
        <td id="LC3607">    {</td>
      </tr>
      <tr>
        <td id="L3608" data-line-number="3608"></td>
        <td id="LC3608">        <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L3609" data-line-number="3609"></td>
        <td id="LC3609">        pThread-&gt;<span>MarkStackFramesDirty</span>();</td>
      </tr>
      <tr>
        <td id="L3610" data-line-number="3610"></td>
        <td id="LC3610">    }</td>
      </tr>
      <tr>
        <td id="L3611" data-line-number="3611"></td>
        <td id="LC3611">
</td>
      </tr>
      <tr>
        <td id="L3612" data-line-number="3612"></td>
        <td id="LC3612">    <span>ClearPatchTable</span>();</td>
      </tr>
      <tr>
        <td id="L3613" data-line-number="3613"></td>
        <td id="LC3613">}</td>
      </tr>
      <tr>
        <td id="L3614" data-line-number="3614"></td>
        <td id="LC3614">
</td>
      </tr>
      <tr>
        <td id="L3615" data-line-number="3615"></td>
        <td id="LC3615">HRESULT <span>CordbProcess::Continue</span>(BOOL <span>fIsOutOfBand</span>)</td>
      </tr>
      <tr>
        <td id="L3616" data-line-number="3616"></td>
        <td id="LC3616">{</td>
      </tr>
      <tr>
        <td id="L3617" data-line-number="3617"></td>
        <td id="LC3617">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3618" data-line-number="3618"></td>
        <td id="LC3618">
</td>
      </tr>
      <tr>
        <td id="L3619" data-line-number="3619"></td>
        <td id="LC3619">    <span>if</span> (m_pShim == <span>NULL</span>) <span><span>//</span> This API is moved off to the shim</span></td>
      </tr>
      <tr>
        <td id="L3620" data-line-number="3620"></td>
        <td id="LC3620">    {</td>
      </tr>
      <tr>
        <td id="L3621" data-line-number="3621"></td>
        <td id="LC3621">        <span><span>//</span> bias towards failing with CORDBG_E_NUETERED.</span></td>
      </tr>
      <tr>
        <td id="L3622" data-line-number="3622"></td>
        <td id="LC3622">        <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3623" data-line-number="3623"></td>
        <td id="LC3623">        <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L3624" data-line-number="3624"></td>
        <td id="LC3624">    }</td>
      </tr>
      <tr>
        <td id="L3625" data-line-number="3625"></td>
        <td id="LC3625">
</td>
      </tr>
      <tr>
        <td id="L3626" data-line-number="3626"></td>
        <td id="LC3626">    HRESULT hr;</td>
      </tr>
      <tr>
        <td id="L3627" data-line-number="3627"></td>
        <td id="LC3627">
</td>
      </tr>
      <tr>
        <td id="L3628" data-line-number="3628"></td>
        <td id="LC3628">    <span>if</span> (<span>fIsOutOfBand</span>)</td>
      </tr>
      <tr>
        <td id="L3629" data-line-number="3629"></td>
        <td id="LC3629">    {</td>
      </tr>
      <tr>
        <td id="L3630" data-line-number="3630"></td>
        <td id="LC3630">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L3631" data-line-number="3631"></td>
        <td id="LC3631">        hr = <span>ContinueOOB</span>();</td>
      </tr>
      <tr>
        <td id="L3632" data-line-number="3632"></td>
        <td id="LC3632">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L3633" data-line-number="3633"></td>
        <td id="LC3633">        hr = E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L3634" data-line-number="3634"></td>
        <td id="LC3634">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L3635" data-line-number="3635"></td>
        <td id="LC3635">    }</td>
      </tr>
      <tr>
        <td id="L3636" data-line-number="3636"></td>
        <td id="LC3636">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L3637" data-line-number="3637"></td>
        <td id="LC3637">    {</td>
      </tr>
      <tr>
        <td id="L3638" data-line-number="3638"></td>
        <td id="LC3638">        hr = <span>ContinueInternal</span>(<span>fIsOutOfBand</span>);</td>
      </tr>
      <tr>
        <td id="L3639" data-line-number="3639"></td>
        <td id="LC3639">    }</td>
      </tr>
      <tr>
        <td id="L3640" data-line-number="3640"></td>
        <td id="LC3640">
</td>
      </tr>
      <tr>
        <td id="L3641" data-line-number="3641"></td>
        <td id="LC3641">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L3642" data-line-number="3642"></td>
        <td id="LC3642">}</td>
      </tr>
      <tr>
        <td id="L3643" data-line-number="3643"></td>
        <td id="LC3643">
</td>
      </tr>
      <tr>
        <td id="L3644" data-line-number="3644"></td>
        <td id="LC3644">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L3645" data-line-number="3645"></td>
        <td id="LC3645"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3646" data-line-number="3646"></td>
        <td id="LC3646"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3647" data-line-number="3647"></td>
        <td id="LC3647"><span><span>//</span> ContinueOOB</span></td>
      </tr>
      <tr>
        <td id="L3648" data-line-number="3648"></td>
        <td id="LC3648"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3649" data-line-number="3649"></td>
        <td id="LC3649"><span><span>//</span> Continue the Win32 event as an out-of-band event.</span></td>
      </tr>
      <tr>
        <td id="L3650" data-line-number="3650"></td>
        <td id="LC3650"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3651" data-line-number="3651"></td>
        <td id="LC3651"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L3652" data-line-number="3652"></td>
        <td id="LC3652"><span><span>//</span>    S_OK on successful continue. Else error.</span></td>
      </tr>
      <tr>
        <td id="L3653" data-line-number="3653"></td>
        <td id="LC3653"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3654" data-line-number="3654"></td>
        <td id="LC3654"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3655" data-line-number="3655"></td>
        <td id="LC3655">HRESULT <span>CordbProcess::ContinueOOB</span>()</td>
      </tr>
      <tr>
        <td id="L3656" data-line-number="3656"></td>
        <td id="LC3656">{</td>
      </tr>
      <tr>
        <td id="L3657" data-line-number="3657"></td>
        <td id="LC3657">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3658" data-line-number="3658"></td>
        <td id="LC3658">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3659" data-line-number="3659"></td>
        <td id="LC3659">
</td>
      </tr>
      <tr>
        <td id="L3660" data-line-number="3660"></td>
        <td id="LC3660">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L3661" data-line-number="3661"></td>
        <td id="LC3661">
</td>
      </tr>
      <tr>
        <td id="L3662" data-line-number="3662"></td>
        <td id="LC3662">    <span><span>//</span> If we're continuing from an out-of-band unmanaged event, then just go</span></td>
      </tr>
      <tr>
        <td id="L3663" data-line-number="3663"></td>
        <td id="LC3663">    <span><span>//</span> ahead and get the Win32 event thread to continue the process. No other</span></td>
      </tr>
      <tr>
        <td id="L3664" data-line-number="3664"></td>
        <td id="LC3664">    <span><span>//</span> work needs to be done (i.e., don't need to send a managed continue message</span></td>
      </tr>
      <tr>
        <td id="L3665" data-line-number="3665"></td>
        <td id="LC3665">    <span><span>//</span> or dispatch any events) because any processing done due to the out-of-band</span></td>
      </tr>
      <tr>
        <td id="L3666" data-line-number="3666"></td>
        <td id="LC3666">    <span><span>//</span> message can't alter the synchronized state of the process.</span></td>
      </tr>
      <tr>
        <td id="L3667" data-line-number="3667"></td>
        <td id="LC3667">
</td>
      </tr>
      <tr>
        <td id="L3668" data-line-number="3668"></td>
        <td id="LC3668">    <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L3669" data-line-number="3669"></td>
        <td id="LC3669">    <span>_ASSERTE</span>(m_outOfBandEventQueue != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L3670" data-line-number="3670"></td>
        <td id="LC3670">
</td>
      </tr>
      <tr>
        <td id="L3671" data-line-number="3671"></td>
        <td id="LC3671">    <span><span>//</span> Are we calling this from the unmanaged callback?</span></td>
      </tr>
      <tr>
        <td id="L3672" data-line-number="3672"></td>
        <td id="LC3672">    <span>if</span> (m_dispatchingOOBEvent)</td>
      </tr>
      <tr>
        <td id="L3673" data-line-number="3673"></td>
        <td id="LC3673">    {</td>
      </tr>
      <tr>
        <td id="L3674" data-line-number="3674"></td>
        <td id="LC3674">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: continue while dispatching unmanaged out-of-band event.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3675" data-line-number="3675"></td>
        <td id="LC3675">        <span><span>//</span> We don't know what thread we're on here.</span></td>
      </tr>
      <tr>
        <td id="L3676" data-line-number="3676"></td>
        <td id="LC3676">
</td>
      </tr>
      <tr>
        <td id="L3677" data-line-number="3677"></td>
        <td id="LC3677">        <span><span>//</span> Tell the Win32 event thread to continue when it returns from handling its unmanaged callback.</span></td>
      </tr>
      <tr>
        <td id="L3678" data-line-number="3678"></td>
        <td id="LC3678">        m_dispatchingOOBEvent = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3679" data-line-number="3679"></td>
        <td id="LC3679">
</td>
      </tr>
      <tr>
        <td id="L3680" data-line-number="3680"></td>
        <td id="LC3680">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3681" data-line-number="3681"></td>
        <td id="LC3681">    }</td>
      </tr>
      <tr>
        <td id="L3682" data-line-number="3682"></td>
        <td id="LC3682">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L3683" data-line-number="3683"></td>
        <td id="LC3683">    {</td>
      </tr>
      <tr>
        <td id="L3684" data-line-number="3684"></td>
        <td id="LC3684">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: continue outside of dispatching.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3685" data-line-number="3685"></td>
        <td id="LC3685">
</td>
      </tr>
      <tr>
        <td id="L3686" data-line-number="3686"></td>
        <td id="LC3686">        <span><span>//</span> If we're not dispatching this, then they shouldn't be on the win32 event thread.</span></td>
      </tr>
      <tr>
        <td id="L3687" data-line-number="3687"></td>
        <td id="LC3687">        <span>_ASSERTE</span>(!<span>this</span>-&gt;<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L3688" data-line-number="3688"></td>
        <td id="LC3688">
</td>
      </tr>
      <tr>
        <td id="L3689" data-line-number="3689"></td>
        <td id="LC3689">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3690" data-line-number="3690"></td>
        <td id="LC3690">
</td>
      </tr>
      <tr>
        <td id="L3691" data-line-number="3691"></td>
        <td id="LC3691">        <span><span>//</span> Send an event to the Win32 event thread to do the continue. This is an out-of-band continue.</span></td>
      </tr>
      <tr>
        <td id="L3692" data-line-number="3692"></td>
        <td id="LC3692">        hr = <span>this</span>-&gt;<span>m_pShim</span>-&gt;<span>GetWin32EventThread</span>()-&gt;<span>SendUnmanagedContinue</span>(<span>this</span>, cOobUMContinue);</td>
      </tr>
      <tr>
        <td id="L3693" data-line-number="3693"></td>
        <td id="LC3693">    }</td>
      </tr>
      <tr>
        <td id="L3694" data-line-number="3694"></td>
        <td id="LC3694">
</td>
      </tr>
      <tr>
        <td id="L3695" data-line-number="3695"></td>
        <td id="LC3695">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L3696" data-line-number="3696"></td>
        <td id="LC3696">
</td>
      </tr>
      <tr>
        <td id="L3697" data-line-number="3697"></td>
        <td id="LC3697">
</td>
      </tr>
      <tr>
        <td id="L3698" data-line-number="3698"></td>
        <td id="LC3698">}</td>
      </tr>
      <tr>
        <td id="L3699" data-line-number="3699"></td>
        <td id="LC3699">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L3700" data-line-number="3700"></td>
        <td id="LC3700">
</td>
      </tr>
      <tr>
        <td id="L3701" data-line-number="3701"></td>
        <td id="LC3701"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3702" data-line-number="3702"></td>
        <td id="LC3702"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3703" data-line-number="3703"></td>
        <td id="LC3703"><span><span>//</span> ContinueInternal</span></td>
      </tr>
      <tr>
        <td id="L3704" data-line-number="3704"></td>
        <td id="LC3704"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3705" data-line-number="3705"></td>
        <td id="LC3705"><span><span>//</span> Continue the Win32 event.</span></td>
      </tr>
      <tr>
        <td id="L3706" data-line-number="3706"></td>
        <td id="LC3706"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3707" data-line-number="3707"></td>
        <td id="LC3707"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L3708" data-line-number="3708"></td>
        <td id="LC3708"><span><span>//</span>    S_OK on success. Else error.</span></td>
      </tr>
      <tr>
        <td id="L3709" data-line-number="3709"></td>
        <td id="LC3709"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3710" data-line-number="3710"></td>
        <td id="LC3710"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3711" data-line-number="3711"></td>
        <td id="LC3711">HRESULT <span>CordbProcess::ContinueInternal</span>(BOOL <span>fIsOutOfBand</span>)</td>
      </tr>
      <tr>
        <td id="L3712" data-line-number="3712"></td>
        <td id="LC3712">{</td>
      </tr>
      <tr>
        <td id="L3713" data-line-number="3713"></td>
        <td id="LC3713">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3714" data-line-number="3714"></td>
        <td id="LC3714">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3715" data-line-number="3715"></td>
        <td id="LC3715">
</td>
      </tr>
      <tr>
        <td id="L3716" data-line-number="3716"></td>
        <td id="LC3716">    <span><span>//</span> Continue has an ATT similar to ATT_REQUIRE_STOPPED_MAY_FAIL, but w/ some subtle differences.</span></td>
      </tr>
      <tr>
        <td id="L3717" data-line-number="3717"></td>
        <td id="LC3717">    <span><span>//</span> - if we're stopped at a native DE, but not synchronized, we don't want to sync.</span></td>
      </tr>
      <tr>
        <td id="L3718" data-line-number="3718"></td>
        <td id="LC3718">    <span><span>//</span> - We may get Debug events (especially native ones) at weird times, and thus we have to continue</span></td>
      </tr>
      <tr>
        <td id="L3719" data-line-number="3719"></td>
        <td id="LC3719">    <span><span>//</span> at weird times.</span></td>
      </tr>
      <tr>
        <td id="L3720" data-line-number="3720"></td>
        <td id="LC3720">
</td>
      </tr>
      <tr>
        <td id="L3721" data-line-number="3721"></td>
        <td id="LC3721">    <span><span>//</span> External APIs should not have the process lock.</span></td>
      </tr>
      <tr>
        <td id="L3722" data-line-number="3722"></td>
        <td id="LC3722">    <span>_ASSERTE</span>(!<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L3723" data-line-number="3723"></td>
        <td id="LC3723">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L3724" data-line-number="3724"></td>
        <td id="LC3724">
</td>
      </tr>
      <tr>
        <td id="L3725" data-line-number="3725"></td>
        <td id="LC3725">    <span><span>//</span> OutOfBand should use ContinueOOB</span></td>
      </tr>
      <tr>
        <td id="L3726" data-line-number="3726"></td>
        <td id="LC3726">    <span>_ASSERTE</span>(!<span>fIsOutOfBand</span>);</td>
      </tr>
      <tr>
        <td id="L3727" data-line-number="3727"></td>
        <td id="LC3727">
</td>
      </tr>
      <tr>
        <td id="L3728" data-line-number="3728"></td>
        <td id="LC3728">    <span><span>//</span> Since Continue is process-wide, just use a null appdomain pointer.</span></td>
      </tr>
      <tr>
        <td id="L3729" data-line-number="3729"></td>
        <td id="LC3729">    VMPTR_AppDomain pAppDomainToken = <span>VMPTR_AppDomain::NullPtr</span>();</td>
      </tr>
      <tr>
        <td id="L3730" data-line-number="3730"></td>
        <td id="LC3730">
</td>
      </tr>
      <tr>
        <td id="L3731" data-line-number="3731"></td>
        <td id="LC3731">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L3732" data-line-number="3732"></td>
        <td id="LC3732">
</td>
      </tr>
      <tr>
        <td id="L3733" data-line-number="3733"></td>
        <td id="LC3733">    <span>if</span> (m_unrecoverableError)</td>
      </tr>
      <tr>
        <td id="L3734" data-line-number="3734"></td>
        <td id="LC3734">    {</td>
      </tr>
      <tr>
        <td id="L3735" data-line-number="3735"></td>
        <td id="LC3735">        <span>return</span> <span>CORDBHRFromProcessState</span>(<span>this</span>, <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L3736" data-line-number="3736"></td>
        <td id="LC3736">    }</td>
      </tr>
      <tr>
        <td id="L3737" data-line-number="3737"></td>
        <td id="LC3737">
</td>
      </tr>
      <tr>
        <td id="L3738" data-line-number="3738"></td>
        <td id="LC3738">
</td>
      </tr>
      <tr>
        <td id="L3739" data-line-number="3739"></td>
        <td id="LC3739">    <span><span>//</span> We can't call ContinueInternal for an inband event on the win32 event thread.</span></td>
      </tr>
      <tr>
        <td id="L3740" data-line-number="3740"></td>
        <td id="LC3740">    <span><span>//</span> This is an issue in the CLR (or an API design decision, depending on your perspective).</span></td>
      </tr>
      <tr>
        <td id="L3741" data-line-number="3741"></td>
        <td id="LC3741">    <span><span>//</span> Continue() may send an IPC event and we can't do that on the win32 event thread.</span></td>
      </tr>
      <tr>
        <td id="L3742" data-line-number="3742"></td>
        <td id="LC3742">
</td>
      </tr>
      <tr>
        <td id="L3743" data-line-number="3743"></td>
        <td id="LC3743">    <span>CORDBFailIfOnWin32EventThread</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3744" data-line-number="3744"></td>
        <td id="LC3744">
</td>
      </tr>
      <tr>
        <td id="L3745" data-line-number="3745"></td>
        <td id="LC3745">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: continuing IB,  this=0x%X<span>\n</span><span>"</span></span>, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3746" data-line-number="3746"></td>
        <td id="LC3746">
</td>
      </tr>
      <tr>
        <td id="L3747" data-line-number="3747"></td>
        <td id="LC3747">    <span><span>//</span> Stop + Continue are executed under the Stop-Go lock. This makes them atomic.</span></td>
      </tr>
      <tr>
        <td id="L3748" data-line-number="3748"></td>
        <td id="LC3748">    <span><span>//</span> We'll toggle the process-lock (b/c we communicate w/ the W32et, so that's not sufficient).</span></td>
      </tr>
      <tr>
        <td id="L3749" data-line-number="3749"></td>
        <td id="LC3749">    RSLockHolder <span>rsLockHolder</span>(&amp;m_StopGoLock);</td>
      </tr>
      <tr>
        <td id="L3750" data-line-number="3750"></td>
        <td id="LC3750">
</td>
      </tr>
      <tr>
        <td id="L3751" data-line-number="3751"></td>
        <td id="LC3751">    <span><span>//</span> Check for other failures (do these after we have the SG lock).</span></td>
      </tr>
      <tr>
        <td id="L3752" data-line-number="3752"></td>
        <td id="LC3752">    <span>if</span> (m_terminated)</td>
      </tr>
      <tr>
        <td id="L3753" data-line-number="3753"></td>
        <td id="LC3753">    {</td>
      </tr>
      <tr>
        <td id="L3754" data-line-number="3754"></td>
        <td id="LC3754">        <span>return</span> CORDBG_E_PROCESS_TERMINATED;</td>
      </tr>
      <tr>
        <td id="L3755" data-line-number="3755"></td>
        <td id="LC3755">    }</td>
      </tr>
      <tr>
        <td id="L3756" data-line-number="3756"></td>
        <td id="LC3756">    <span>if</span> (m_detached)</td>
      </tr>
      <tr>
        <td id="L3757" data-line-number="3757"></td>
        <td id="LC3757">    {</td>
      </tr>
      <tr>
        <td id="L3758" data-line-number="3758"></td>
        <td id="LC3758">        <span>return</span> CORDBG_E_PROCESS_DETACHED;</td>
      </tr>
      <tr>
        <td id="L3759" data-line-number="3759"></td>
        <td id="LC3759">    }</td>
      </tr>
      <tr>
        <td id="L3760" data-line-number="3760"></td>
        <td id="LC3760">
</td>
      </tr>
      <tr>
        <td id="L3761" data-line-number="3761"></td>
        <td id="LC3761">    <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L3762" data-line-number="3762"></td>
        <td id="LC3762">
</td>
      </tr>
      <tr>
        <td id="L3763" data-line-number="3763"></td>
        <td id="LC3763">    <span>ASSERT_SINGLE_THREAD_ONLY</span>(<span>HoldsLock</span>(&amp;m_StopGoLock));</td>
      </tr>
      <tr>
        <td id="L3764" data-line-number="3764"></td>
        <td id="LC3764">    <span>_ASSERTE</span>(<span>fIsOutOfBand</span> == <span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L3765" data-line-number="3765"></td>
        <td id="LC3765">
</td>
      </tr>
      <tr>
        <td id="L3766" data-line-number="3766"></td>
        <td id="LC3766">    <span><span>//</span> If we've got multiple Stop calls, we need a Continue for each one. So, if the stop count &gt; 1, just go ahead and</span></td>
      </tr>
      <tr>
        <td id="L3767" data-line-number="3767"></td>
        <td id="LC3767">    <span><span>//</span> return without doing anything. Note: this is only for in-band or managed events. OOB events are still handled as</span></td>
      </tr>
      <tr>
        <td id="L3768" data-line-number="3768"></td>
        <td id="LC3768">    <span><span>//</span> normal above.</span></td>
      </tr>
      <tr>
        <td id="L3769" data-line-number="3769"></td>
        <td id="LC3769">    <span>_ASSERTE</span>(<span>GetStopCount</span>() &gt; <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L3770" data-line-number="3770"></td>
        <td id="LC3770">
</td>
      </tr>
      <tr>
        <td id="L3771" data-line-number="3771"></td>
        <td id="LC3771">    <span>if</span> (<span>GetStopCount</span>() == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3772" data-line-number="3772"></td>
        <td id="LC3772">    {</td>
      </tr>
      <tr>
        <td id="L3773" data-line-number="3773"></td>
        <td id="LC3773">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3774" data-line-number="3774"></td>
        <td id="LC3774">        <span>_ASSERTE</span>(!<span><span>"</span>Superflous Continue. ICorDebugProcess.Continue() called too many times<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3775" data-line-number="3775"></td>
        <td id="LC3775">        <span>return</span> CORDBG_E_SUPERFLOUS_CONTINUE;</td>
      </tr>
      <tr>
        <td id="L3776" data-line-number="3776"></td>
        <td id="LC3776">    }</td>
      </tr>
      <tr>
        <td id="L3777" data-line-number="3777"></td>
        <td id="LC3777">
</td>
      </tr>
      <tr>
        <td id="L3778" data-line-number="3778"></td>
        <td id="LC3778">    <span>DecStopCount</span>();</td>
      </tr>
      <tr>
        <td id="L3779" data-line-number="3779"></td>
        <td id="LC3779">
</td>
      </tr>
      <tr>
        <td id="L3780" data-line-number="3780"></td>
        <td id="LC3780">    <span><span>//</span> We give managed events priority over unmanaged events. That way, the entire queued managed state can drain before</span></td>
      </tr>
      <tr>
        <td id="L3781" data-line-number="3781"></td>
        <td id="LC3781">    <span><span>//</span> we let any other unmanaged events through.</span></td>
      </tr>
      <tr>
        <td id="L3782" data-line-number="3782"></td>
        <td id="LC3782">
</td>
      </tr>
      <tr>
        <td id="L3783" data-line-number="3783"></td>
        <td id="LC3783">    <span><span>//</span> Every stop or event must be matched by a corresponding Continue. m_stopCount counts outstanding stopping events</span></td>
      </tr>
      <tr>
        <td id="L3784" data-line-number="3784"></td>
        <td id="LC3784">    <span><span>//</span> along with calls to Stop. If the count is high at this point, we simply return. This ensures that even if someone</span></td>
      </tr>
      <tr>
        <td id="L3785" data-line-number="3785"></td>
        <td id="LC3785">    <span><span>//</span> calls Stop just as they're receiving an event that they can call Continue for that Stop and for that event</span></td>
      </tr>
      <tr>
        <td id="L3786" data-line-number="3786"></td>
        <td id="LC3786">    <span><span>//</span> without problems.</span></td>
      </tr>
      <tr>
        <td id="L3787" data-line-number="3787"></td>
        <td id="LC3787">    <span>if</span> (<span>GetStopCount</span>() &gt; <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3788" data-line-number="3788"></td>
        <td id="LC3788">    {</td>
      </tr>
      <tr>
        <td id="L3789" data-line-number="3789"></td>
        <td id="LC3789">        <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: m_stopCount=%d, Continue just returning S_OK...<span>\n</span><span>"</span></span>, <span>GetStopCount</span>());</td>
      </tr>
      <tr>
        <td id="L3790" data-line-number="3790"></td>
        <td id="LC3790">
</td>
      </tr>
      <tr>
        <td id="L3791" data-line-number="3791"></td>
        <td id="LC3791">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3792" data-line-number="3792"></td>
        <td id="LC3792">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L3793" data-line-number="3793"></td>
        <td id="LC3793">    }</td>
      </tr>
      <tr>
        <td id="L3794" data-line-number="3794"></td>
        <td id="LC3794">
</td>
      </tr>
      <tr>
        <td id="L3795" data-line-number="3795"></td>
        <td id="LC3795">    <span><span>//</span> We're no longer stopped, so reset the m_stopWaitEvent.</span></td>
      </tr>
      <tr>
        <td id="L3796" data-line-number="3796"></td>
        <td id="LC3796">    <span>ResetEvent</span>(m_stopWaitEvent);</td>
      </tr>
      <tr>
        <td id="L3797" data-line-number="3797"></td>
        <td id="LC3797">
</td>
      </tr>
      <tr>
        <td id="L3798" data-line-number="3798"></td>
        <td id="LC3798">    <span><span>//</span> If we're continuing from an uninitialized stop, then we don't need to do much at all. No event need be sent to</span></td>
      </tr>
      <tr>
        <td id="L3799" data-line-number="3799"></td>
        <td id="LC3799">    <span><span>//</span> the Left Side (duh, it isn't even there yet.) We just need to get the RC Event Thread to start listening to the</span></td>
      </tr>
      <tr>
        <td id="L3800" data-line-number="3800"></td>
        <td id="LC3800">    <span><span>//</span> process again, and resume any unmanaged threads if necessary.</span></td>
      </tr>
      <tr>
        <td id="L3801" data-line-number="3801"></td>
        <td id="LC3801">    <span>if</span> (m_uninitializedStop)</td>
      </tr>
      <tr>
        <td id="L3802" data-line-number="3802"></td>
        <td id="LC3802">    {</td>
      </tr>
      <tr>
        <td id="L3803" data-line-number="3803"></td>
        <td id="LC3803">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: continuing from uninitialized stop.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3804" data-line-number="3804"></td>
        <td id="LC3804">
</td>
      </tr>
      <tr>
        <td id="L3805" data-line-number="3805"></td>
        <td id="LC3805">        <span><span>//</span> No longer synchronized (it was a partial sync in the first place.)</span></td>
      </tr>
      <tr>
        <td id="L3806" data-line-number="3806"></td>
        <td id="LC3806">        <span>SetSynchronized</span>(<span>false</span>);</td>
      </tr>
      <tr>
        <td id="L3807" data-line-number="3807"></td>
        <td id="LC3807">        <span>MarkAllThreadsDirty</span>();</td>
      </tr>
      <tr>
        <td id="L3808" data-line-number="3808"></td>
        <td id="LC3808">
</td>
      </tr>
      <tr>
        <td id="L3809" data-line-number="3809"></td>
        <td id="LC3809">        <span><span>//</span> No longer in an uninitialized stop.</span></td>
      </tr>
      <tr>
        <td id="L3810" data-line-number="3810"></td>
        <td id="LC3810">        m_uninitializedStop = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3811" data-line-number="3811"></td>
        <td id="LC3811">
</td>
      </tr>
      <tr>
        <td id="L3812" data-line-number="3812"></td>
        <td id="LC3812">        <span><span>//</span> Notify the RC Event Thread.</span></td>
      </tr>
      <tr>
        <td id="L3813" data-line-number="3813"></td>
        <td id="LC3813">        m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L3814" data-line-number="3814"></td>
        <td id="LC3814">
</td>
      </tr>
      <tr>
        <td id="L3815" data-line-number="3815"></td>
        <td id="LC3815">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3816" data-line-number="3816"></td>
        <td id="LC3816">
</td>
      </tr>
      <tr>
        <td id="L3817" data-line-number="3817"></td>
        <td id="LC3817">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L3818" data-line-number="3818"></td>
        <td id="LC3818">        <span><span>//</span> We may or may not have a native debug event queued here.</span></td>
      </tr>
      <tr>
        <td id="L3819" data-line-number="3819"></td>
        <td id="LC3819">        <span><span>//</span> If Cordbg called Stop() from a native debug event (to get the process Synchronized), then</span></td>
      </tr>
      <tr>
        <td id="L3820" data-line-number="3820"></td>
        <td id="LC3820">        <span><span>//</span> we'll have a native debug event, and we need to continue it.</span></td>
      </tr>
      <tr>
        <td id="L3821" data-line-number="3821"></td>
        <td id="LC3821">        <span><span>//</span> If Cordbg called Stop() to do an AsyncBreak, then there's no native-debug event.</span></td>
      </tr>
      <tr>
        <td id="L3822" data-line-number="3822"></td>
        <td id="LC3822">
</td>
      </tr>
      <tr>
        <td id="L3823" data-line-number="3823"></td>
        <td id="LC3823">        <span><span>//</span> If we're Win32 attached, resume all the unmanaged threads.</span></td>
      </tr>
      <tr>
        <td id="L3824" data-line-number="3824"></td>
        <td id="LC3824">        <span>if</span> (<span>IsInteropDebugging</span>())</td>
      </tr>
      <tr>
        <td id="L3825" data-line-number="3825"></td>
        <td id="LC3825">        {</td>
      </tr>
      <tr>
        <td id="L3826" data-line-number="3826"></td>
        <td id="LC3826">            <span>if</span>(m_lastDispatchedIBEvent != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L3827" data-line-number="3827"></td>
        <td id="LC3827">            {</td>
      </tr>
      <tr>
        <td id="L3828" data-line-number="3828"></td>
        <td id="LC3828">                m_lastDispatchedIBEvent-&gt;<span>SetState</span>(CUES_UserContinued);</td>
      </tr>
      <tr>
        <td id="L3829" data-line-number="3829"></td>
        <td id="LC3829">            }</td>
      </tr>
      <tr>
        <td id="L3830" data-line-number="3830"></td>
        <td id="LC3830">
</td>
      </tr>
      <tr>
        <td id="L3831" data-line-number="3831"></td>
        <td id="LC3831">            <span><span>//</span> Send to the Win32 event thread to do the unmanaged continue for us.</span></td>
      </tr>
      <tr>
        <td id="L3832" data-line-number="3832"></td>
        <td id="LC3832">            <span><span>//</span> If we're at a debug event, this will continue it.</span></td>
      </tr>
      <tr>
        <td id="L3833" data-line-number="3833"></td>
        <td id="LC3833">            <span><span>//</span> Else it will degenerate into ResumeUnmanagedThreads();</span></td>
      </tr>
      <tr>
        <td id="L3834" data-line-number="3834"></td>
        <td id="LC3834">            <span>this</span>-&gt;<span>m_pShim</span>-&gt;<span>GetWin32EventThread</span>()-&gt;<span>SendUnmanagedContinue</span>(<span>this</span>, cRealUMContinue);</td>
      </tr>
      <tr>
        <td id="L3835" data-line-number="3835"></td>
        <td id="LC3835">        }</td>
      </tr>
      <tr>
        <td id="L3836" data-line-number="3836"></td>
        <td id="LC3836">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L3837" data-line-number="3837"></td>
        <td id="LC3837">
</td>
      </tr>
      <tr>
        <td id="L3838" data-line-number="3838"></td>
        <td id="LC3838">
</td>
      </tr>
      <tr>
        <td id="L3839" data-line-number="3839"></td>
        <td id="LC3839">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L3840" data-line-number="3840"></td>
        <td id="LC3840">    }</td>
      </tr>
      <tr>
        <td id="L3841" data-line-number="3841"></td>
        <td id="LC3841">
</td>
      </tr>
      <tr>
        <td id="L3842" data-line-number="3842"></td>
        <td id="LC3842">    <span><span>//</span> If there are more managed events, get them dispatched now.</span></td>
      </tr>
      <tr>
        <td id="L3843" data-line-number="3843"></td>
        <td id="LC3843">    <span>if</span> (!m_pShim-&gt;<span>GetManagedEventQueue</span>()-&gt;<span>IsEmpty</span>() &amp;&amp; <span>GetSynchronized</span>())</td>
      </tr>
      <tr>
        <td id="L3844" data-line-number="3844"></td>
        <td id="LC3844">    {</td>
      </tr>
      <tr>
        <td id="L3845" data-line-number="3845"></td>
        <td id="LC3845">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: managed event queued.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3846" data-line-number="3846"></td>
        <td id="LC3846">
</td>
      </tr>
      <tr>
        <td id="L3847" data-line-number="3847"></td>
        <td id="LC3847">        <span><span>//</span> Mark that we're not synchronized anymore.</span></td>
      </tr>
      <tr>
        <td id="L3848" data-line-number="3848"></td>
        <td id="LC3848">        <span>SetSynchronized</span>(<span>false</span>);</td>
      </tr>
      <tr>
        <td id="L3849" data-line-number="3849"></td>
        <td id="LC3849">
</td>
      </tr>
      <tr>
        <td id="L3850" data-line-number="3850"></td>
        <td id="LC3850">        <span><span>//</span> If the callback queue is not empty, then the LS is not actually continuing, and so our cached</span></td>
      </tr>
      <tr>
        <td id="L3851" data-line-number="3851"></td>
        <td id="LC3851">        <span><span>//</span> state is still valid.</span></td>
      </tr>
      <tr>
        <td id="L3852" data-line-number="3852"></td>
        <td id="LC3852">
</td>
      </tr>
      <tr>
        <td id="L3853" data-line-number="3853"></td>
        <td id="LC3853">        <span><span>//</span> If we're in the middle of dispatching a managed event, then simply return. This indicates to HandleRCEvent</span></td>
      </tr>
      <tr>
        <td id="L3854" data-line-number="3854"></td>
        <td id="LC3854">        <span><span>//</span> that the user called Continue and HandleRCEvent will dispatch the next queued event. But if Continue was</span></td>
      </tr>
      <tr>
        <td id="L3855" data-line-number="3855"></td>
        <td id="LC3855">        <span><span>//</span> called outside the managed callback, all we have to do is tell the RC event thread that something about the</span></td>
      </tr>
      <tr>
        <td id="L3856" data-line-number="3856"></td>
        <td id="LC3856">        <span><span>//</span> process has changed and it will dispatch the next managed event.</span></td>
      </tr>
      <tr>
        <td id="L3857" data-line-number="3857"></td>
        <td id="LC3857">        <span>if</span> (!<span>AreDispatchingEvent</span>())</td>
      </tr>
      <tr>
        <td id="L3858" data-line-number="3858"></td>
        <td id="LC3858">        {</td>
      </tr>
      <tr>
        <td id="L3859" data-line-number="3859"></td>
        <td id="LC3859">            <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: continuing while not dispatching managed event.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3860" data-line-number="3860"></td>
        <td id="LC3860">
</td>
      </tr>
      <tr>
        <td id="L3861" data-line-number="3861"></td>
        <td id="LC3861">            m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L3862" data-line-number="3862"></td>
        <td id="LC3862">        }</td>
      </tr>
      <tr>
        <td id="L3863" data-line-number="3863"></td>
        <td id="LC3863">
</td>
      </tr>
      <tr>
        <td id="L3864" data-line-number="3864"></td>
        <td id="LC3864">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3865" data-line-number="3865"></td>
        <td id="LC3865">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L3866" data-line-number="3866"></td>
        <td id="LC3866">    }</td>
      </tr>
      <tr>
        <td id="L3867" data-line-number="3867"></td>
        <td id="LC3867">
</td>
      </tr>
      <tr>
        <td id="L3868" data-line-number="3868"></td>
        <td id="LC3868">    <span><span>//</span> Neuter if we have an outstanding object.</span></td>
      </tr>
      <tr>
        <td id="L3869" data-line-number="3869"></td>
        <td id="LC3869">    <span><span>//</span> Only do this if we're really continuining the debuggee. So don't do this if our stop-count is high b/c we</span></td>
      </tr>
      <tr>
        <td id="L3870" data-line-number="3870"></td>
        <td id="LC3870">    <span><span>//</span> shouldn't neuter until we're done w/ the current event. And don't do this until we drain the current callback queue.</span></td>
      </tr>
      <tr>
        <td id="L3871" data-line-number="3871"></td>
        <td id="LC3871">    <span><span>//</span> Note that we can't hold the process lock while we do this b/c Neutering may send IPC events.</span></td>
      </tr>
      <tr>
        <td id="L3872" data-line-number="3872"></td>
        <td id="LC3872">    <span><span>//</span> However, we're still under the StopGo lock b/c that may help us serialize things.</span></td>
      </tr>
      <tr>
        <td id="L3873" data-line-number="3873"></td>
        <td id="LC3873">
</td>
      </tr>
      <tr>
        <td id="L3874" data-line-number="3874"></td>
        <td id="LC3874">    <span><span>//</span> Sweep neuter list. This will catch anything that's marked as 'safe to neuter'. This includes</span></td>
      </tr>
      <tr>
        <td id="L3875" data-line-number="3875"></td>
        <td id="LC3875">    <span><span>//</span> all objects added to the 'neuter-on-Continue'.</span></td>
      </tr>
      <tr>
        <td id="L3876" data-line-number="3876"></td>
        <td id="LC3876">    <span><span>//</span> Only do this if we're synced- we don't want to do this if we're continuing from a Native Debug event.</span></td>
      </tr>
      <tr>
        <td id="L3877" data-line-number="3877"></td>
        <td id="LC3877">    <span>if</span> (<span>GetSynchronized</span>())</td>
      </tr>
      <tr>
        <td id="L3878" data-line-number="3878"></td>
        <td id="LC3878">    {</td>
      </tr>
      <tr>
        <td id="L3879" data-line-number="3879"></td>
        <td id="LC3879">        <span><span>//</span> Need process-lock to operate on hashtable, but can't yet Neuter under process-lock,</span></td>
      </tr>
      <tr>
        <td id="L3880" data-line-number="3880"></td>
        <td id="LC3880">        <span><span>//</span> so we have to copy the contents to an auxilary list which we can then traverse outside the lock.</span></td>
      </tr>
      <tr>
        <td id="L3881" data-line-number="3881"></td>
        <td id="LC3881">        RSPtrArray&lt;CordbAppDomain&gt; listAppDomains;</td>
      </tr>
      <tr>
        <td id="L3882" data-line-number="3882"></td>
        <td id="LC3882">        HRESULT hrCopy = S_OK;</td>
      </tr>
      <tr>
        <td id="L3883" data-line-number="3883"></td>
        <td id="LC3883">        EX_TRY <span><span>//</span> @dbgtodo cleanup: push this up</span></td>
      </tr>
      <tr>
        <td id="L3884" data-line-number="3884"></td>
        <td id="LC3884">        {</td>
      </tr>
      <tr>
        <td id="L3885" data-line-number="3885"></td>
        <td id="LC3885">            m_appDomains.<span>CopyToArray</span>(&amp;listAppDomains);</td>
      </tr>
      <tr>
        <td id="L3886" data-line-number="3886"></td>
        <td id="LC3886">        }</td>
      </tr>
      <tr>
        <td id="L3887" data-line-number="3887"></td>
        <td id="LC3887">        <span>EX_CATCH_HRESULT</span>(hrCopy);</td>
      </tr>
      <tr>
        <td id="L3888" data-line-number="3888"></td>
        <td id="LC3888">        <span>SetUnrecoverableIfFailed</span>(<span>GetProcess</span>(), hrCopy);</td>
      </tr>
      <tr>
        <td id="L3889" data-line-number="3889"></td>
        <td id="LC3889">
</td>
      </tr>
      <tr>
        <td id="L3890" data-line-number="3890"></td>
        <td id="LC3890">        m_ContinueNeuterList.<span>NeuterAndClear</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3891" data-line-number="3891"></td>
        <td id="LC3891">
</td>
      </tr>
      <tr>
        <td id="L3892" data-line-number="3892"></td>
        <td id="LC3892">        <span><span>//</span> @dbgtodo left-side resources: eventually (once</span></td>
      </tr>
      <tr>
        <td id="L3893" data-line-number="3893"></td>
        <td id="LC3893">        <span><span>//</span> NeuterLeftSideResources is process-lock safe), do this all under the</span></td>
      </tr>
      <tr>
        <td id="L3894" data-line-number="3894"></td>
        <td id="LC3894">        <span><span>//</span> lock. Can't hold process lock b/c neutering left-side resources</span></td>
      </tr>
      <tr>
        <td id="L3895" data-line-number="3895"></td>
        <td id="LC3895">        <span><span>//</span> may send events.</span></td>
      </tr>
      <tr>
        <td id="L3896" data-line-number="3896"></td>
        <td id="LC3896">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3897" data-line-number="3897"></td>
        <td id="LC3897">
</td>
      </tr>
      <tr>
        <td id="L3898" data-line-number="3898"></td>
        <td id="LC3898">        <span><span>//</span> This may send IPC events.</span></td>
      </tr>
      <tr>
        <td id="L3899" data-line-number="3899"></td>
        <td id="LC3899">        <span><span>//</span> This will make normal neutering a nop.</span></td>
      </tr>
      <tr>
        <td id="L3900" data-line-number="3900"></td>
        <td id="LC3900">        <span><span>//</span> This will toggle the process lock.</span></td>
      </tr>
      <tr>
        <td id="L3901" data-line-number="3901"></td>
        <td id="LC3901">        m_LeftSideResourceCleanupList.<span>SweepNeuterLeftSideResources</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3902" data-line-number="3902"></td>
        <td id="LC3902">
</td>
      </tr>
      <tr>
        <td id="L3903" data-line-number="3903"></td>
        <td id="LC3903">
</td>
      </tr>
      <tr>
        <td id="L3904" data-line-number="3904"></td>
        <td id="LC3904">        <span><span>//</span> Many objects (especially CordbValue, FuncEval) don't have clear lifetime semantics and</span></td>
      </tr>
      <tr>
        <td id="L3905" data-line-number="3905"></td>
        <td id="LC3905">        <span><span>//</span> so they must be put into an exit-neuter list (Process/AppDomain) for worst-case scenarios.</span></td>
      </tr>
      <tr>
        <td id="L3906" data-line-number="3906"></td>
        <td id="LC3906">        <span><span>//</span> These objects are likely released early, and so we sweep them aggressively on each Continue (kind of like a mini-GC).</span></td>
      </tr>
      <tr>
        <td id="L3907" data-line-number="3907"></td>
        <td id="LC3907">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3908" data-line-number="3908"></td>
        <td id="LC3908">        <span><span>//</span> One drawback is that there may be a lot of useless sweeping if the debugger creates a lot of</span></td>
      </tr>
      <tr>
        <td id="L3909" data-line-number="3909"></td>
        <td id="LC3909">        <span><span>//</span> objects that it holds onto. Consider instead of sweeping, have the object explicitly post itself</span></td>
      </tr>
      <tr>
        <td id="L3910" data-line-number="3910"></td>
        <td id="LC3910">        <span><span>//</span> to a list that's guaranteed to be cleared. This would let us avoid sweeping not-yet-ready objects.</span></td>
      </tr>
      <tr>
        <td id="L3911" data-line-number="3911"></td>
        <td id="LC3911">        <span><span>//</span> This will toggle the process lock</span></td>
      </tr>
      <tr>
        <td id="L3912" data-line-number="3912"></td>
        <td id="LC3912">        m_ExitNeuterList.<span>SweepAllNeuterAtWillObjects</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3913" data-line-number="3913"></td>
        <td id="LC3913">
</td>
      </tr>
      <tr>
        <td id="L3914" data-line-number="3914"></td>
        <td id="LC3914">
</td>
      </tr>
      <tr>
        <td id="L3915" data-line-number="3915"></td>
        <td id="LC3915">        <span>for</span>(<span>unsigned</span> <span>int</span> idx = <span>0</span>; idx &lt; listAppDomains.<span>Length</span>(); idx++)</td>
      </tr>
      <tr>
        <td id="L3916" data-line-number="3916"></td>
        <td id="LC3916">        {</td>
      </tr>
      <tr>
        <td id="L3917" data-line-number="3917"></td>
        <td id="LC3917">            CordbAppDomain * pAppDomain = listAppDomains[idx];</td>
      </tr>
      <tr>
        <td id="L3918" data-line-number="3918"></td>
        <td id="LC3918">
</td>
      </tr>
      <tr>
        <td id="L3919" data-line-number="3919"></td>
        <td id="LC3919">            <span><span>//</span> CordbHandleValue is in the appdomain exit list, and that needs</span></td>
      </tr>
      <tr>
        <td id="L3920" data-line-number="3920"></td>
        <td id="LC3920">            <span><span>//</span> to send an IPC event to cleanup and release the handle from</span></td>
      </tr>
      <tr>
        <td id="L3921" data-line-number="3921"></td>
        <td id="LC3921">            <span><span>//</span> the GCs handle table.</span></td>
      </tr>
      <tr>
        <td id="L3922" data-line-number="3922"></td>
        <td id="LC3922">            <span><span>//</span> This will toggle the process lock.</span></td>
      </tr>
      <tr>
        <td id="L3923" data-line-number="3923"></td>
        <td id="LC3923">            pAppDomain-&gt;<span>GetSweepableExitNeuterList</span>()-&gt;<span>SweepNeuterLeftSideResources</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3924" data-line-number="3924"></td>
        <td id="LC3924">        }</td>
      </tr>
      <tr>
        <td id="L3925" data-line-number="3925"></td>
        <td id="LC3925">        listAppDomains.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L3926" data-line-number="3926"></td>
        <td id="LC3926">
</td>
      </tr>
      <tr>
        <td id="L3927" data-line-number="3927"></td>
        <td id="LC3927">        <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L3928" data-line-number="3928"></td>
        <td id="LC3928">    }</td>
      </tr>
      <tr>
        <td id="L3929" data-line-number="3929"></td>
        <td id="LC3929">
</td>
      </tr>
      <tr>
        <td id="L3930" data-line-number="3930"></td>
        <td id="LC3930">
</td>
      </tr>
      <tr>
        <td id="L3931" data-line-number="3931"></td>
        <td id="LC3931">    <span><span>//</span> At this point, if the managed event queue is empty, m_synchronized may still be true if we had previously</span></td>
      </tr>
      <tr>
        <td id="L3932" data-line-number="3932"></td>
        <td id="LC3932">    <span><span>//</span> synchronized.</span></td>
      </tr>
      <tr>
        <td id="L3933" data-line-number="3933"></td>
        <td id="LC3933">
</td>
      </tr>
      <tr>
        <td id="L3934" data-line-number="3934"></td>
        <td id="LC3934">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L3935" data-line-number="3935"></td>
        <td id="LC3935">    <span><span>//</span> Next, check for unmanaged events that may be queued. If there are some queued, then we need to get the Win32</span></td>
      </tr>
      <tr>
        <td id="L3936" data-line-number="3936"></td>
        <td id="LC3936">    <span><span>//</span> event thread to go ahead and dispatch the next one. If there aren't any queued, then we can just fall through and</span></td>
      </tr>
      <tr>
        <td id="L3937" data-line-number="3937"></td>
        <td id="LC3937">    <span><span>//</span> send the continue message to the left side. This works even if we have an outstanding ownership request, because</span></td>
      </tr>
      <tr>
        <td id="L3938" data-line-number="3938"></td>
        <td id="LC3938">    <span><span>//</span> until that answer is received, its just like the event hasn't happened yet.</span></td>
      </tr>
      <tr>
        <td id="L3939" data-line-number="3939"></td>
        <td id="LC3939">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3940" data-line-number="3940"></td>
        <td id="LC3940">    <span><span>//</span> If we're terminated, then we've already continued from the last win32 event and so don't continue.</span></td>
      </tr>
      <tr>
        <td id="L3941" data-line-number="3941"></td>
        <td id="LC3941">    <span><span>//</span> @todo - or we could ensure the PS_SOME_THREADS_SUSPENDED | PS_HIJACKS_IN_PLACE are removed.</span></td>
      </tr>
      <tr>
        <td id="L3942" data-line-number="3942"></td>
        <td id="LC3942">    <span><span>//</span> Either way, we're just protecting against exit-process at strange times.</span></td>
      </tr>
      <tr>
        <td id="L3943" data-line-number="3943"></td>
        <td id="LC3943">    <span>bool</span> <span>fDoWin32Continue</span> = !m_terminated &amp;&amp; ((m_state &amp; (PS_WIN32_STOPPED | PS_SOME_THREADS_SUSPENDED | PS_HIJACKS_IN_PLACE)) != <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L3944" data-line-number="3944"></td>
        <td id="LC3944">
</td>
      </tr>
      <tr>
        <td id="L3945" data-line-number="3945"></td>
        <td id="LC3945">    <span><span>//</span> We need to store this before marking the event user continued below</span></td>
      </tr>
      <tr>
        <td id="L3946" data-line-number="3946"></td>
        <td id="LC3946">    BOOL <span>fHasUserUncontinuedEvents</span> = <span>HasUserUncontinuedNativeEvents</span>();</td>
      </tr>
      <tr>
        <td id="L3947" data-line-number="3947"></td>
        <td id="LC3947">
</td>
      </tr>
      <tr>
        <td id="L3948" data-line-number="3948"></td>
        <td id="LC3948">    <span>if</span>(m_lastDispatchedIBEvent != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L3949" data-line-number="3949"></td>
        <td id="LC3949">    {</td>
      </tr>
      <tr>
        <td id="L3950" data-line-number="3950"></td>
        <td id="LC3950">        m_lastDispatchedIBEvent-&gt;<span>SetState</span>(CUES_UserContinued);</td>
      </tr>
      <tr>
        <td id="L3951" data-line-number="3951"></td>
        <td id="LC3951">    }</td>
      </tr>
      <tr>
        <td id="L3952" data-line-number="3952"></td>
        <td id="LC3952">
</td>
      </tr>
      <tr>
        <td id="L3953" data-line-number="3953"></td>
        <td id="LC3953">    <span>if</span> (<span>fHasUserUncontinuedEvents</span>)</td>
      </tr>
      <tr>
        <td id="L3954" data-line-number="3954"></td>
        <td id="LC3954">    {</td>
      </tr>
      <tr>
        <td id="L3955" data-line-number="3955"></td>
        <td id="LC3955">        <span><span>//</span> ExitProcess is the last debug event we'll get. The Process Handle is not signaled until</span></td>
      </tr>
      <tr>
        <td id="L3956" data-line-number="3956"></td>
        <td id="LC3956">        <span><span>//</span> after we continue from ExitProcess. m_terminated is only set once we know the process is signaled.</span></td>
      </tr>
      <tr>
        <td id="L3957" data-line-number="3957"></td>
        <td id="LC3957">        <span><span>//</span> (This isn't 100% true for the detach case, but since you can't do interop detach, we don't care)</span></td>
      </tr>
      <tr>
        <td id="L3958" data-line-number="3958"></td>
        <td id="LC3958">        <span><span>//</span>_ASSERTE(!m_terminated);</span></td>
      </tr>
      <tr>
        <td id="L3959" data-line-number="3959"></td>
        <td id="LC3959">
</td>
      </tr>
      <tr>
        <td id="L3960" data-line-number="3960"></td>
        <td id="LC3960">        <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: there are queued uncontinued events. m_dispatchingUnmanagedEvent = %d<span>\n</span><span>"</span></span>, m_dispatchingUnmanagedEvent);</td>
      </tr>
      <tr>
        <td id="L3961" data-line-number="3961"></td>
        <td id="LC3961">
</td>
      </tr>
      <tr>
        <td id="L3962" data-line-number="3962"></td>
        <td id="LC3962">        <span><span>//</span> Are we being called while in the unmanaged event callback?</span></td>
      </tr>
      <tr>
        <td id="L3963" data-line-number="3963"></td>
        <td id="LC3963">        <span>if</span> (m_dispatchingUnmanagedEvent)</td>
      </tr>
      <tr>
        <td id="L3964" data-line-number="3964"></td>
        <td id="LC3964">        {</td>
      </tr>
      <tr>
        <td id="L3965" data-line-number="3965"></td>
        <td id="LC3965">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: continue while dispatching.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L3966" data-line-number="3966"></td>
        <td id="LC3966">            <span><span>//</span> The Win32ET could have made a cross-thread call to Continue while dispatching,</span></td>
      </tr>
      <tr>
        <td id="L3967" data-line-number="3967"></td>
        <td id="LC3967">            <span><span>//</span> so we don't know if this is the win32 ET.</span></td>
      </tr>
      <tr>
        <td id="L3968" data-line-number="3968"></td>
        <td id="LC3968">
</td>
      </tr>
      <tr>
        <td id="L3969" data-line-number="3969"></td>
        <td id="LC3969">            <span><span>//</span> Tell the Win32 thread to continue when it returns from handling its unmanaged callback.</span></td>
      </tr>
      <tr>
        <td id="L3970" data-line-number="3970"></td>
        <td id="LC3970">            m_dispatchingUnmanagedEvent = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3971" data-line-number="3971"></td>
        <td id="LC3971">
</td>
      </tr>
      <tr>
        <td id="L3972" data-line-number="3972"></td>
        <td id="LC3972">            <span><span>//</span> If there are no more unmanaged events, then we fall through and continue the process for real. Otherwise,</span></td>
      </tr>
      <tr>
        <td id="L3973" data-line-number="3973"></td>
        <td id="LC3973">            <span><span>//</span> we can simply return.</span></td>
      </tr>
      <tr>
        <td id="L3974" data-line-number="3974"></td>
        <td id="LC3974">            <span>if</span> (<span>HasUndispatchedNativeEvents</span>())</td>
      </tr>
      <tr>
        <td id="L3975" data-line-number="3975"></td>
        <td id="LC3975">            {</td>
      </tr>
      <tr>
        <td id="L3976" data-line-number="3976"></td>
        <td id="LC3976">                <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: more unmanaged events need dispatching.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3977" data-line-number="3977"></td>
        <td id="LC3977">
</td>
      </tr>
      <tr>
        <td id="L3978" data-line-number="3978"></td>
        <td id="LC3978">                <span><span>//</span> Note: if we tried to access the Left Side while stopped but couldn't, then m_oddSync will be true. We</span></td>
      </tr>
      <tr>
        <td id="L3979" data-line-number="3979"></td>
        <td id="LC3979">                <span><span>//</span> need to reset it to false since we're continuing now.</span></td>
      </tr>
      <tr>
        <td id="L3980" data-line-number="3980"></td>
        <td id="LC3980">                m_oddSync = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3981" data-line-number="3981"></td>
        <td id="LC3981">
</td>
      </tr>
      <tr>
        <td id="L3982" data-line-number="3982"></td>
        <td id="LC3982">                <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L3983" data-line-number="3983"></td>
        <td id="LC3983">                <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L3984" data-line-number="3984"></td>
        <td id="LC3984">            }</td>
      </tr>
      <tr>
        <td id="L3985" data-line-number="3985"></td>
        <td id="LC3985">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L3986" data-line-number="3986"></td>
        <td id="LC3986">            {</td>
      </tr>
      <tr>
        <td id="L3987" data-line-number="3987"></td>
        <td id="LC3987">                <span><span>//</span> Also, if there are no more unmanaged events, then when DispatchUnmanagedInBandEvent sees that</span></td>
      </tr>
      <tr>
        <td id="L3988" data-line-number="3988"></td>
        <td id="LC3988">                <span><span>//</span> m_dispatchingUnmanagedEvent is false, it will continue the process. So we set doWin32Continue to</span></td>
      </tr>
      <tr>
        <td id="L3989" data-line-number="3989"></td>
        <td id="LC3989">                <span><span>//</span> false here so that we don't try to double continue the process below.</span></td>
      </tr>
      <tr>
        <td id="L3990" data-line-number="3990"></td>
        <td id="LC3990">                <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: no more unmanaged events to dispatch.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3991" data-line-number="3991"></td>
        <td id="LC3991">
</td>
      </tr>
      <tr>
        <td id="L3992" data-line-number="3992"></td>
        <td id="LC3992">                <span>fDoWin32Continue</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3993" data-line-number="3993"></td>
        <td id="LC3993">            }</td>
      </tr>
      <tr>
        <td id="L3994" data-line-number="3994"></td>
        <td id="LC3994">        }</td>
      </tr>
      <tr>
        <td id="L3995" data-line-number="3995"></td>
        <td id="LC3995">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L3996" data-line-number="3996"></td>
        <td id="LC3996">        {</td>
      </tr>
      <tr>
        <td id="L3997" data-line-number="3997"></td>
        <td id="LC3997">            <span><span>//</span> after the DebugEvent callback returned the continue still had no been issued. Then later</span></td>
      </tr>
      <tr>
        <td id="L3998" data-line-number="3998"></td>
        <td id="LC3998">            <span><span>//</span> on another thread the user called back to continue the event, which gets us to right here</span></td>
      </tr>
      <tr>
        <td id="L3999" data-line-number="3999"></td>
        <td id="LC3999">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: continue outside of dispatching.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L4000" data-line-number="4000"></td>
        <td id="LC4000">
</td>
      </tr>
      <tr>
        <td id="L4001" data-line-number="4001"></td>
        <td id="LC4001">            <span><span>//</span> This should be the common place to Dispatch an IB event that was hijacked for sync.</span></td>
      </tr>
      <tr>
        <td id="L4002" data-line-number="4002"></td>
        <td id="LC4002">
</td>
      </tr>
      <tr>
        <td id="L4003" data-line-number="4003"></td>
        <td id="LC4003">            <span><span>//</span> If we're not dispatching, this better not be the win32 event thread.</span></td>
      </tr>
      <tr>
        <td id="L4004" data-line-number="4004"></td>
        <td id="LC4004">            <span>_ASSERTE</span>(!<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L4005" data-line-number="4005"></td>
        <td id="LC4005">
</td>
      </tr>
      <tr>
        <td id="L4006" data-line-number="4006"></td>
        <td id="LC4006">            <span><span>//</span> If the event at the head of the queue is really the last event, or if the event at the head of the queue</span></td>
      </tr>
      <tr>
        <td id="L4007" data-line-number="4007"></td>
        <td id="LC4007">            <span><span>//</span> hasn't been dispatched yet, then we simply fall through and continue the process for real. However, if</span></td>
      </tr>
      <tr>
        <td id="L4008" data-line-number="4008"></td>
        <td id="LC4008">            <span><span>//</span> its not the last event, we send to the Win32 event thread and get it to continue, then we return.</span></td>
      </tr>
      <tr>
        <td id="L4009" data-line-number="4009"></td>
        <td id="LC4009">            <span>if</span> (<span>HasUndispatchedNativeEvents</span>())</td>
      </tr>
      <tr>
        <td id="L4010" data-line-number="4010"></td>
        <td id="LC4010">            {</td>
      </tr>
      <tr>
        <td id="L4011" data-line-number="4011"></td>
        <td id="LC4011">                <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: more unmanaged events need dispatching.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4012" data-line-number="4012"></td>
        <td id="LC4012">
</td>
      </tr>
      <tr>
        <td id="L4013" data-line-number="4013"></td>
        <td id="LC4013">                <span><span>//</span> Note: if we tried to access the Left Side while stopped but couldn't, then m_oddSync will be true. We</span></td>
      </tr>
      <tr>
        <td id="L4014" data-line-number="4014"></td>
        <td id="LC4014">                <span><span>//</span> need to reset it to false since we're continuing now.</span></td>
      </tr>
      <tr>
        <td id="L4015" data-line-number="4015"></td>
        <td id="LC4015">                m_oddSync = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L4016" data-line-number="4016"></td>
        <td id="LC4016">
</td>
      </tr>
      <tr>
        <td id="L4017" data-line-number="4017"></td>
        <td id="LC4017">                <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L4018" data-line-number="4018"></td>
        <td id="LC4018">
</td>
      </tr>
      <tr>
        <td id="L4019" data-line-number="4019"></td>
        <td id="LC4019">                hr = <span>this</span>-&gt;<span>m_pShim</span>-&gt;<span>GetWin32EventThread</span>()-&gt;<span>SendUnmanagedContinue</span>(<span>this</span>, cRealUMContinue);</td>
      </tr>
      <tr>
        <td id="L4020" data-line-number="4020"></td>
        <td id="LC4020">
</td>
      </tr>
      <tr>
        <td id="L4021" data-line-number="4021"></td>
        <td id="LC4021">                <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L4022" data-line-number="4022"></td>
        <td id="LC4022">            }</td>
      </tr>
      <tr>
        <td id="L4023" data-line-number="4023"></td>
        <td id="LC4023">        }</td>
      </tr>
      <tr>
        <td id="L4024" data-line-number="4024"></td>
        <td id="LC4024">    }</td>
      </tr>
      <tr>
        <td id="L4025" data-line-number="4025"></td>
        <td id="LC4025">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L4026" data-line-number="4026"></td>
        <td id="LC4026">
</td>
      </tr>
      <tr>
        <td id="L4027" data-line-number="4027"></td>
        <td id="LC4027">    <span><span>//</span> Both the managed and unmanaged event queues are now empty. Go</span></td>
      </tr>
      <tr>
        <td id="L4028" data-line-number="4028"></td>
        <td id="LC4028">    <span><span>//</span> ahead and continue the process for real.</span></td>
      </tr>
      <tr>
        <td id="L4029" data-line-number="4029"></td>
        <td id="LC4029">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: headed for true continue.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L4030" data-line-number="4030"></td>
        <td id="LC4030">
</td>
      </tr>
      <tr>
        <td id="L4031" data-line-number="4031"></td>
        <td id="LC4031">    <span><span>//</span> We need to check these while under the lock, but action must be</span></td>
      </tr>
      <tr>
        <td id="L4032" data-line-number="4032"></td>
        <td id="LC4032">    <span><span>//</span> taked outside of the lock.</span></td>
      </tr>
      <tr>
        <td id="L4033" data-line-number="4033"></td>
        <td id="LC4033">    <span>bool</span> <span>fIsExiting</span> = m_exiting;</td>
      </tr>
      <tr>
        <td id="L4034" data-line-number="4034"></td>
        <td id="LC4034">    <span>bool</span> <span>fWasSynchronized</span> = <span>GetSynchronized</span>();</td>
      </tr>
      <tr>
        <td id="L4035" data-line-number="4035"></td>
        <td id="LC4035">
</td>
      </tr>
      <tr>
        <td id="L4036" data-line-number="4036"></td>
        <td id="LC4036">    <span><span>//</span> Mark that we're no longer synchronized.</span></td>
      </tr>
      <tr>
        <td id="L4037" data-line-number="4037"></td>
        <td id="LC4037">    <span>if</span> (<span>fWasSynchronized</span>)</td>
      </tr>
      <tr>
        <td id="L4038" data-line-number="4038"></td>
        <td id="LC4038">    {</td>
      </tr>
      <tr>
        <td id="L4039" data-line-number="4039"></td>
        <td id="LC4039">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: process was synchronized.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L4040" data-line-number="4040"></td>
        <td id="LC4040">
</td>
      </tr>
      <tr>
        <td id="L4041" data-line-number="4041"></td>
        <td id="LC4041">        <span>SetSynchronized</span>(<span>false</span>);</td>
      </tr>
      <tr>
        <td id="L4042" data-line-number="4042"></td>
        <td id="LC4042">        <span>SetSyncCompleteRecv</span>(<span>false</span>);</td>
      </tr>
      <tr>
        <td id="L4043" data-line-number="4043"></td>
        <td id="LC4043">
</td>
      </tr>
      <tr>
        <td id="L4044" data-line-number="4044"></td>
        <td id="LC4044">        <span><span>//</span> we're no longer in a callback, so set flags to indicate that we've finished.</span></td>
      </tr>
      <tr>
        <td id="L4045" data-line-number="4045"></td>
        <td id="LC4045">        <span>GetShim</span>()-&gt;<span>NotifyOnContinue</span>();</td>
      </tr>
      <tr>
        <td id="L4046" data-line-number="4046"></td>
        <td id="LC4046">
</td>
      </tr>
      <tr>
        <td id="L4047" data-line-number="4047"></td>
        <td id="LC4047">        <span><span>//</span> Flush will update state, including continue counter and marking</span></td>
      </tr>
      <tr>
        <td id="L4048" data-line-number="4048"></td>
        <td id="LC4048">        <span><span>//</span> frames dirty.</span></td>
      </tr>
      <tr>
        <td id="L4049" data-line-number="4049"></td>
        <td id="LC4049">        <span>this</span>-&gt;<span>FlushProcessRunning</span>();</td>
      </tr>
      <tr>
        <td id="L4050" data-line-number="4050"></td>
        <td id="LC4050">
</td>
      </tr>
      <tr>
        <td id="L4051" data-line-number="4051"></td>
        <td id="LC4051">
</td>
      </tr>
      <tr>
        <td id="L4052" data-line-number="4052"></td>
        <td id="LC4052">        <span><span>//</span> Tell the RC event thread that something about this process has changed.</span></td>
      </tr>
      <tr>
        <td id="L4053" data-line-number="4053"></td>
        <td id="LC4053">        m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L4054" data-line-number="4054"></td>
        <td id="LC4054">    }</td>
      </tr>
      <tr>
        <td id="L4055" data-line-number="4055"></td>
        <td id="LC4055">
</td>
      </tr>
      <tr>
        <td id="L4056" data-line-number="4056"></td>
        <td id="LC4056">    m_continueCounter++;</td>
      </tr>
      <tr>
        <td id="L4057" data-line-number="4057"></td>
        <td id="LC4057">
</td>
      </tr>
      <tr>
        <td id="L4058" data-line-number="4058"></td>
        <td id="LC4058">    <span><span>//</span> If m_oddSync is set, then out last synchronization was due to us syncing the process because we were Win32</span></td>
      </tr>
      <tr>
        <td id="L4059" data-line-number="4059"></td>
        <td id="LC4059">    <span><span>//</span> stopped. Therefore, while we do need to do most of the work to continue the process below, we don't actually have</span></td>
      </tr>
      <tr>
        <td id="L4060" data-line-number="4060"></td>
        <td id="LC4060">    <span><span>//</span> to send the managed continue event. Setting wasSynchronized to false here helps us do that.</span></td>
      </tr>
      <tr>
        <td id="L4061" data-line-number="4061"></td>
        <td id="LC4061">    <span>if</span> (m_oddSync)</td>
      </tr>
      <tr>
        <td id="L4062" data-line-number="4062"></td>
        <td id="LC4062">    {</td>
      </tr>
      <tr>
        <td id="L4063" data-line-number="4063"></td>
        <td id="LC4063">        <span>fWasSynchronized</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L4064" data-line-number="4064"></td>
        <td id="LC4064">        m_oddSync = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L4065" data-line-number="4065"></td>
        <td id="LC4065">    }</td>
      </tr>
      <tr>
        <td id="L4066" data-line-number="4066"></td>
        <td id="LC4066">
</td>
      </tr>
      <tr>
        <td id="L4067" data-line-number="4067"></td>
        <td id="LC4067">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L4068" data-line-number="4068"></td>
        <td id="LC4068">    <span><span>//</span> We must ensure that all managed threads are suspended here. We're about to let all managed threads run free via</span></td>
      </tr>
      <tr>
        <td id="L4069" data-line-number="4069"></td>
        <td id="LC4069">    <span><span>//</span> the managed continue message to the Left Side. If we don't suspend the managed threads, then they may start</span></td>
      </tr>
      <tr>
        <td id="L4070" data-line-number="4070"></td>
        <td id="LC4070">    <span><span>//</span> slipping forward even if we receive an in-band unmanaged event. We have to hijack in-band unmanaged events while</span></td>
      </tr>
      <tr>
        <td id="L4071" data-line-number="4071"></td>
        <td id="LC4071">    <span><span>//</span> getting the managed continue message over to the Left Side to keep the process running free. Otherwise, the</span></td>
      </tr>
      <tr>
        <td id="L4072" data-line-number="4072"></td>
        <td id="LC4072">    <span><span>//</span> SendIPCEvent will hang below. But in doing so, we could let managed threads slip to far. So we ensure they're all</span></td>
      </tr>
      <tr>
        <td id="L4073" data-line-number="4073"></td>
        <td id="LC4073">    <span><span>//</span> suspended here.</span></td>
      </tr>
      <tr>
        <td id="L4074" data-line-number="4074"></td>
        <td id="LC4074">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4075" data-line-number="4075"></td>
        <td id="LC4075">    <span><span>//</span> Note: we only do this suspension if the helper thread hasn't died yet. If the helper thread has died, then we</span></td>
      </tr>
      <tr>
        <td id="L4076" data-line-number="4076"></td>
        <td id="LC4076">    <span><span>//</span> know that we're loosing the Runtime. No more managed code is going to run, so we don't bother trying to prevent</span></td>
      </tr>
      <tr>
        <td id="L4077" data-line-number="4077"></td>
        <td id="LC4077">    <span><span>//</span> managed threads from slipping via the call below.</span></td>
      </tr>
      <tr>
        <td id="L4078" data-line-number="4078"></td>
        <td id="LC4078">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4079" data-line-number="4079"></td>
        <td id="LC4079">    <span><span>//</span> Note: we just remember here, under the lock, so we can unlock then wait for the syncing thread to free the</span></td>
      </tr>
      <tr>
        <td id="L4080" data-line-number="4080"></td>
        <td id="LC4080">    <span><span>//</span> debugger lock. Otherwise, we may block here and prevent someone from continuing from an OOB event, which also</span></td>
      </tr>
      <tr>
        <td id="L4081" data-line-number="4081"></td>
        <td id="LC4081">    <span><span>//</span> prevents the syncing thread from releasing the debugger lock like we want it to.</span></td>
      </tr>
      <tr>
        <td id="L4082" data-line-number="4082"></td>
        <td id="LC4082">    <span>bool</span> <span>fNeedSuspend</span> = <span>fWasSynchronized</span> &amp;&amp; <span>fDoWin32Continue</span> &amp;&amp; !m_helperThreadDead;</td>
      </tr>
      <tr>
        <td id="L4083" data-line-number="4083"></td>
        <td id="LC4083">
</td>
      </tr>
      <tr>
        <td id="L4084" data-line-number="4084"></td>
        <td id="LC4084">    <span><span>//</span> If we receive a new in-band event once we unlock, we need to know to hijack it and keep going while we're still</span></td>
      </tr>
      <tr>
        <td id="L4085" data-line-number="4085"></td>
        <td id="LC4085">    <span><span>//</span> trying to send the managed continue event to the process.</span></td>
      </tr>
      <tr>
        <td id="L4086" data-line-number="4086"></td>
        <td id="LC4086">    <span>if</span> (<span>fWasSynchronized</span> &amp;&amp; <span>fDoWin32Continue</span> &amp;&amp; !<span>fIsExiting</span>)</td>
      </tr>
      <tr>
        <td id="L4087" data-line-number="4087"></td>
        <td id="LC4087">    {</td>
      </tr>
      <tr>
        <td id="L4088" data-line-number="4088"></td>
        <td id="LC4088">        m_specialDeferment = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L4089" data-line-number="4089"></td>
        <td id="LC4089">    }</td>
      </tr>
      <tr>
        <td id="L4090" data-line-number="4090"></td>
        <td id="LC4090">
</td>
      </tr>
      <tr>
        <td id="L4091" data-line-number="4091"></td>
        <td id="LC4091">    <span>if</span> (<span>fNeedSuspend</span>)</td>
      </tr>
      <tr>
        <td id="L4092" data-line-number="4092"></td>
        <td id="LC4092">    {</td>
      </tr>
      <tr>
        <td id="L4093" data-line-number="4093"></td>
        <td id="LC4093">        <span><span>//</span> @todo - what does this actually accomplish? We already suspended everything when we first synced.</span></td>
      </tr>
      <tr>
        <td id="L4094" data-line-number="4094"></td>
        <td id="LC4094">
</td>
      </tr>
      <tr>
        <td id="L4095" data-line-number="4095"></td>
        <td id="LC4095">        <span><span>//</span> Any thread that may hold a lock blocking the helper is</span></td>
      </tr>
      <tr>
        <td id="L4096" data-line-number="4096"></td>
        <td id="LC4096">        <span><span>//</span> inside of a can't stop region, and thus we won't suspend it.</span></td>
      </tr>
      <tr>
        <td id="L4097" data-line-number="4097"></td>
        <td id="LC4097">        <span>SuspendUnmanagedThreads</span>();</td>
      </tr>
      <tr>
        <td id="L4098" data-line-number="4098"></td>
        <td id="LC4098">    }</td>
      </tr>
      <tr>
        <td id="L4099" data-line-number="4099"></td>
        <td id="LC4099">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L4100" data-line-number="4100"></td>
        <td id="LC4100">
</td>
      </tr>
      <tr>
        <td id="L4101" data-line-number="4101"></td>
        <td id="LC4101">    <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L4102" data-line-number="4102"></td>
        <td id="LC4102">
</td>
      </tr>
      <tr>
        <td id="L4103" data-line-number="4103"></td>
        <td id="LC4103">    <span><span>//</span> Although we've released the Process-lock, we still have the Stop-Go lock.</span></td>
      </tr>
      <tr>
        <td id="L4104" data-line-number="4104"></td>
        <td id="LC4104">    <span>_ASSERTE</span>(m_StopGoLock.<span>HasLock</span>());</td>
      </tr>
      <tr>
        <td id="L4105" data-line-number="4105"></td>
        <td id="LC4105">
</td>
      </tr>
      <tr>
        <td id="L4106" data-line-number="4106"></td>
        <td id="LC4106">    <span><span>//</span> If we're processing an ExitProcess managed event, then we don't want to really continue the process, so just fall</span></td>
      </tr>
      <tr>
        <td id="L4107" data-line-number="4107"></td>
        <td id="LC4107">    <span><span>//</span> thru.  Note: we did let the unmanaged continue go through above for this case.</span></td>
      </tr>
      <tr>
        <td id="L4108" data-line-number="4108"></td>
        <td id="LC4108">    <span>if</span> (<span>fIsExiting</span>)</td>
      </tr>
      <tr>
        <td id="L4109" data-line-number="4109"></td>
        <td id="LC4109">    {</td>
      </tr>
      <tr>
        <td id="L4110" data-line-number="4110"></td>
        <td id="LC4110">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: continuing from exit case.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L4111" data-line-number="4111"></td>
        <td id="LC4111">    }</td>
      </tr>
      <tr>
        <td id="L4112" data-line-number="4112"></td>
        <td id="LC4112">    <span>else</span> <span>if</span> (<span>fWasSynchronized</span>)</td>
      </tr>
      <tr>
        <td id="L4113" data-line-number="4113"></td>
        <td id="LC4113">    {</td>
      </tr>
      <tr>
        <td id="L4114" data-line-number="4114"></td>
        <td id="LC4114">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: Sending continue to AppD:0x%x.<span>\n</span><span>"</span></span>, <span>VmPtrToCookie</span>(pAppDomainToken)));</td>
      </tr>
      <tr>
        <td id="L4115" data-line-number="4115"></td>
        <td id="LC4115">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L4116" data-line-number="4116"></td>
        <td id="LC4116">        <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>Continue flags:special=%d, dowin32=%d<span>\n</span><span>"</span></span>, m_specialDeferment, <span>fDoWin32Continue</span>);</td>
      </tr>
      <tr>
        <td id="L4117" data-line-number="4117"></td>
        <td id="LC4117">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4118" data-line-number="4118"></td>
        <td id="LC4118">        <span><span>//</span> Send to the RC to continue the process.</span></td>
      </tr>
      <tr>
        <td id="L4119" data-line-number="4119"></td>
        <td id="LC4119">        DebuggerIPCEvent * pEvent = (DebuggerIPCEvent *) <span>_alloca</span>(CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L4120" data-line-number="4120"></td>
        <td id="LC4120">
</td>
      </tr>
      <tr>
        <td id="L4121" data-line-number="4121"></td>
        <td id="LC4121">        <span>InitIPCEvent</span>(pEvent, DB_IPCE_CONTINUE, <span>false</span>, pAppDomainToken);</td>
      </tr>
      <tr>
        <td id="L4122" data-line-number="4122"></td>
        <td id="LC4122">
</td>
      </tr>
      <tr>
        <td id="L4123" data-line-number="4123"></td>
        <td id="LC4123">        hr = m_cordb-&gt;<span>SendIPCEvent</span>(<span>this</span>, pEvent, CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L4124" data-line-number="4124"></td>
        <td id="LC4124">
</td>
      </tr>
      <tr>
        <td id="L4125" data-line-number="4125"></td>
        <td id="LC4125">        <span><span>//</span> It is possible that we continue and then the process immediately exits before the helper</span></td>
      </tr>
      <tr>
        <td id="L4126" data-line-number="4126"></td>
        <td id="LC4126">        <span><span>//</span> thread is finished continuing and can report success back to us. That's arguably a success</span></td>
      </tr>
      <tr>
        <td id="L4127" data-line-number="4127"></td>
        <td id="LC4127">        <span><span>//</span> case sinceu the process did indeed continue, but since we didn't get the acknowledgement,</span></td>
      </tr>
      <tr>
        <td id="L4128" data-line-number="4128"></td>
        <td id="LC4128">        <span><span>//</span> we can't be sure it's success. So we call it S_FALSE instead of S_OK.</span></td>
      </tr>
      <tr>
        <td id="L4129" data-line-number="4129"></td>
        <td id="LC4129">        <span><span>//</span> @todo - how do we handle other failure here?</span></td>
      </tr>
      <tr>
        <td id="L4130" data-line-number="4130"></td>
        <td id="LC4130">        <span>if</span> (hr == CORDBG_E_PROCESS_TERMINATED)</td>
      </tr>
      <tr>
        <td id="L4131" data-line-number="4131"></td>
        <td id="LC4131">        {</td>
      </tr>
      <tr>
        <td id="L4132" data-line-number="4132"></td>
        <td id="LC4132">            hr = S_FALSE;</td>
      </tr>
      <tr>
        <td id="L4133" data-line-number="4133"></td>
        <td id="LC4133">        }</td>
      </tr>
      <tr>
        <td id="L4134" data-line-number="4134"></td>
        <td id="LC4134">        <span>_ASSERTE</span>(<span>SUCCEEDED</span>(pEvent-&gt;<span>hr</span>));</td>
      </tr>
      <tr>
        <td id="L4135" data-line-number="4135"></td>
        <td id="LC4135">
</td>
      </tr>
      <tr>
        <td id="L4136" data-line-number="4136"></td>
        <td id="LC4136">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: Continue sent to AppD:0x%x.<span>\n</span><span>"</span></span>, <span>VmPtrToCookie</span>(pAppDomainToken)));</td>
      </tr>
      <tr>
        <td id="L4137" data-line-number="4137"></td>
        <td id="LC4137">    }</td>
      </tr>
      <tr>
        <td id="L4138" data-line-number="4138"></td>
        <td id="LC4138">
</td>
      </tr>
      <tr>
        <td id="L4139" data-line-number="4139"></td>
        <td id="LC4139">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L4140" data-line-number="4140"></td>
        <td id="LC4140">    <span><span>//</span> If we're win32 attached to the Left side, then we need to win32 continue the process too (unless, of course, it's</span></td>
      </tr>
      <tr>
        <td id="L4141" data-line-number="4141"></td>
        <td id="LC4141">    <span><span>//</span> already been done above.)</span></td>
      </tr>
      <tr>
        <td id="L4142" data-line-number="4142"></td>
        <td id="LC4142">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4143" data-line-number="4143"></td>
        <td id="LC4143">    <span><span>//</span> Note: we do this here because we want to get the Left Side to receive and ack our continue message above if we</span></td>
      </tr>
      <tr>
        <td id="L4144" data-line-number="4144"></td>
        <td id="LC4144">    <span><span>//</span> were sync'd. If we were sync'd, then by definition the process (and the helper thread) is running anyway, so all</span></td>
      </tr>
      <tr>
        <td id="L4145" data-line-number="4145"></td>
        <td id="LC4145">    <span><span>//</span> this continue is going to do is to let the threads that have been suspended go.</span></td>
      </tr>
      <tr>
        <td id="L4146" data-line-number="4146"></td>
        <td id="LC4146">    <span>if</span> (<span>fDoWin32Continue</span>)</td>
      </tr>
      <tr>
        <td id="L4147" data-line-number="4147"></td>
        <td id="LC4147">    {</td>
      </tr>
      <tr>
        <td id="L4148" data-line-number="4148"></td>
        <td id="LC4148">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L4149" data-line-number="4149"></td>
        <td id="LC4149">        {</td>
      </tr>
      <tr>
        <td id="L4150" data-line-number="4150"></td>
        <td id="LC4150">            <span><span>//</span> A little pause here extends the special deferment region and thus causes native-debug</span></td>
      </tr>
      <tr>
        <td id="L4151" data-line-number="4151"></td>
        <td id="LC4151">            <span><span>//</span> events to get hijacked. This test some wildly different corner case paths.</span></td>
      </tr>
      <tr>
        <td id="L4152" data-line-number="4152"></td>
        <td id="LC4152">            <span><span>//</span> See VSWhidbey bugs 131905, 168971</span></td>
      </tr>
      <tr>
        <td id="L4153" data-line-number="4153"></td>
        <td id="LC4153">            <span>static</span> DWORD dwRace = -<span>1</span>;</td>
      </tr>
      <tr>
        <td id="L4154" data-line-number="4154"></td>
        <td id="LC4154">            <span>if</span> (dwRace == -<span>1</span>)</td>
      </tr>
      <tr>
        <td id="L4155" data-line-number="4155"></td>
        <td id="LC4155">                dwRace = <span>CLRConfig::GetConfigValue</span>(CLRConfig::INTERNAL_DbgRace);</td>
      </tr>
      <tr>
        <td id="L4156" data-line-number="4156"></td>
        <td id="LC4156">
</td>
      </tr>
      <tr>
        <td id="L4157" data-line-number="4157"></td>
        <td id="LC4157">            <span>if</span> ((dwRace &amp; <span>1</span>) == <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L4158" data-line-number="4158"></td>
        <td id="LC4158">            {</td>
      </tr>
      <tr>
        <td id="L4159" data-line-number="4159"></td>
        <td id="LC4159">                <span>Sleep</span>(<span>30</span>);</td>
      </tr>
      <tr>
        <td id="L4160" data-line-number="4160"></td>
        <td id="LC4160">            }</td>
      </tr>
      <tr>
        <td id="L4161" data-line-number="4161"></td>
        <td id="LC4161">        }</td>
      </tr>
      <tr>
        <td id="L4162" data-line-number="4162"></td>
        <td id="LC4162">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4163" data-line-number="4163"></td>
        <td id="LC4163">
</td>
      </tr>
      <tr>
        <td id="L4164" data-line-number="4164"></td>
        <td id="LC4164">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: sending unmanaged continue.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4165" data-line-number="4165"></td>
        <td id="LC4165">
</td>
      </tr>
      <tr>
        <td id="L4166" data-line-number="4166"></td>
        <td id="LC4166">        <span><span>//</span> Send to the Win32 event thread to do the unmanaged continue for us.</span></td>
      </tr>
      <tr>
        <td id="L4167" data-line-number="4167"></td>
        <td id="LC4167">        hr = <span>this</span>-&gt;<span>m_pShim</span>-&gt;<span>GetWin32EventThread</span>()-&gt;<span>SendUnmanagedContinue</span>(<span>this</span>, cRealUMContinue);</td>
      </tr>
      <tr>
        <td id="L4168" data-line-number="4168"></td>
        <td id="LC4168">    }</td>
      </tr>
      <tr>
        <td id="L4169" data-line-number="4169"></td>
        <td id="LC4169">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L4170" data-line-number="4170"></td>
        <td id="LC4170">
</td>
      </tr>
      <tr>
        <td id="L4171" data-line-number="4171"></td>
        <td id="LC4171">    <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CI: continue done, returning.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4172" data-line-number="4172"></td>
        <td id="LC4172">
</td>
      </tr>
      <tr>
        <td id="L4173" data-line-number="4173"></td>
        <td id="LC4173">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L4174" data-line-number="4174"></td>
        <td id="LC4174">}</td>
      </tr>
      <tr>
        <td id="L4175" data-line-number="4175"></td>
        <td id="LC4175">
</td>
      </tr>
      <tr>
        <td id="L4176" data-line-number="4176"></td>
        <td id="LC4176">HRESULT <span>CordbProcess::HasQueuedCallbacks</span>(ICorDebugThread *pThread,</td>
      </tr>
      <tr>
        <td id="L4177" data-line-number="4177"></td>
        <td id="LC4177">                                         BOOL *pbQueued)</td>
      </tr>
      <tr>
        <td id="L4178" data-line-number="4178"></td>
        <td id="LC4178">{</td>
      </tr>
      <tr>
        <td id="L4179" data-line-number="4179"></td>
        <td id="LC4179">    <span>PUBLIC_REENTRANT_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4180" data-line-number="4180"></td>
        <td id="LC4180">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4181" data-line-number="4181"></td>
        <td id="LC4181">    <span>VALIDATE_POINTER_TO_OBJECT_OR_NULL</span>(pThread,ICorDebugThread *);</td>
      </tr>
      <tr>
        <td id="L4182" data-line-number="4182"></td>
        <td id="LC4182">    <span>VALIDATE_POINTER_TO_OBJECT</span>(pbQueued,BOOL *);</td>
      </tr>
      <tr>
        <td id="L4183" data-line-number="4183"></td>
        <td id="LC4183">
</td>
      </tr>
      <tr>
        <td id="L4184" data-line-number="4184"></td>
        <td id="LC4184">    <span><span>//</span> Shim owns the event queue</span></td>
      </tr>
      <tr>
        <td id="L4185" data-line-number="4185"></td>
        <td id="LC4185">    <span>if</span> (m_pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L4186" data-line-number="4186"></td>
        <td id="LC4186">    {</td>
      </tr>
      <tr>
        <td id="L4187" data-line-number="4187"></td>
        <td id="LC4187">        <span>PUBLIC_CALLBACK_IN_THIS_SCOPE0_NO_LOCK</span>(<span>this</span>); <span><span>//</span> Calling to shim, leaving RS.</span></td>
      </tr>
      <tr>
        <td id="L4188" data-line-number="4188"></td>
        <td id="LC4188">        *pbQueued = m_pShim-&gt;<span>GetManagedEventQueue</span>()-&gt;<span>HasQueuedCallbacks</span>(pThread);</td>
      </tr>
      <tr>
        <td id="L4189" data-line-number="4189"></td>
        <td id="LC4189">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L4190" data-line-number="4190"></td>
        <td id="LC4190">    }</td>
      </tr>
      <tr>
        <td id="L4191" data-line-number="4191"></td>
        <td id="LC4191">    <span>return</span> E_NOTIMPL; <span><span>//</span> Not implemented in V3.</span></td>
      </tr>
      <tr>
        <td id="L4192" data-line-number="4192"></td>
        <td id="LC4192">}</td>
      </tr>
      <tr>
        <td id="L4193" data-line-number="4193"></td>
        <td id="LC4193">
</td>
      </tr>
      <tr>
        <td id="L4194" data-line-number="4194"></td>
        <td id="LC4194"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4195" data-line-number="4195"></td>
        <td id="LC4195"><span><span>//</span> A small helper function to convert a CordbBreakpoint to an ICorDebugBreakpoint based on its type.</span></td>
      </tr>
      <tr>
        <td id="L4196" data-line-number="4196"></td>
        <td id="LC4196"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4197" data-line-number="4197"></td>
        <td id="LC4197"><span>static</span> ICorDebugBreakpoint *<span>CordbBreakpointToInterface</span>(CordbBreakpoint * pBreakpoint)</td>
      </tr>
      <tr>
        <td id="L4198" data-line-number="4198"></td>
        <td id="LC4198">{</td>
      </tr>
      <tr>
        <td id="L4199" data-line-number="4199"></td>
        <td id="LC4199">    <span>_ASSERTE</span>(pBreakpoint != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4200" data-line-number="4200"></td>
        <td id="LC4200">
</td>
      </tr>
      <tr>
        <td id="L4201" data-line-number="4201"></td>
        <td id="LC4201">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4202" data-line-number="4202"></td>
        <td id="LC4202">    <span><span>//</span> I really dislike this. We've got three subclasses of CordbBreakpoint, but we store them all into the same hash</span></td>
      </tr>
      <tr>
        <td id="L4203" data-line-number="4203"></td>
        <td id="LC4203">    <span><span>//</span> (m_breakpoints), so when we get one out of the hash, we don't really know what type it is. But we need to know</span></td>
      </tr>
      <tr>
        <td id="L4204" data-line-number="4204"></td>
        <td id="LC4204">    <span><span>//</span> what type it is because we need to cast it to the proper interface before passing it out. I.e., when we create a</span></td>
      </tr>
      <tr>
        <td id="L4205" data-line-number="4205"></td>
        <td id="LC4205">    <span><span>//</span> function breakpoint, we return the breakpoint casted to an ICorDebugFunctionBreakpoint. But if we grab that same</span></td>
      </tr>
      <tr>
        <td id="L4206" data-line-number="4206"></td>
        <td id="LC4206">    <span><span>//</span> breakpoint out of the hash as a CordbBreakpoint and pass it out as an ICorDebugBreakpoint, then that's a</span></td>
      </tr>
      <tr>
        <td id="L4207" data-line-number="4207"></td>
        <td id="LC4207">    <span><span>//</span> different pointer, and its wrong. So I've added the type to the breakpoint so we can cast properly here. I'd love</span></td>
      </tr>
      <tr>
        <td id="L4208" data-line-number="4208"></td>
        <td id="LC4208">    <span><span>//</span> to do this a different way, though...</span></td>
      </tr>
      <tr>
        <td id="L4209" data-line-number="4209"></td>
        <td id="LC4209">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4210" data-line-number="4210"></td>
        <td id="LC4210">    <span><span>//</span> -- Mon Dec 14 21:06:46 1998</span></td>
      </tr>
      <tr>
        <td id="L4211" data-line-number="4211"></td>
        <td id="LC4211">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4212" data-line-number="4212"></td>
        <td id="LC4212">    <span>switch</span>(pBreakpoint-&gt;<span>GetBPType</span>())</td>
      </tr>
      <tr>
        <td id="L4213" data-line-number="4213"></td>
        <td id="LC4213">    {</td>
      </tr>
      <tr>
        <td id="L4214" data-line-number="4214"></td>
        <td id="LC4214">    <span>case</span> CBT_FUNCTION:</td>
      </tr>
      <tr>
        <td id="L4215" data-line-number="4215"></td>
        <td id="LC4215">        <span>return</span> <span>static_cast</span>&lt;ICorDebugFunctionBreakpoint *&gt;(<span>static_cast</span>&lt;CordbFunctionBreakpoint *&gt; (pBreakpoint));</td>
      </tr>
      <tr>
        <td id="L4216" data-line-number="4216"></td>
        <td id="LC4216">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4217" data-line-number="4217"></td>
        <td id="LC4217">
</td>
      </tr>
      <tr>
        <td id="L4218" data-line-number="4218"></td>
        <td id="LC4218">    <span>case</span> CBT_MODULE:</td>
      </tr>
      <tr>
        <td id="L4219" data-line-number="4219"></td>
        <td id="LC4219">        <span>return</span> <span>static_cast</span>&lt;ICorDebugModuleBreakpoint*&gt;(<span>static_cast</span>&lt;CordbModuleBreakpoint *&gt; (pBreakpoint));</td>
      </tr>
      <tr>
        <td id="L4220" data-line-number="4220"></td>
        <td id="LC4220">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4221" data-line-number="4221"></td>
        <td id="LC4221">
</td>
      </tr>
      <tr>
        <td id="L4222" data-line-number="4222"></td>
        <td id="LC4222">    <span>case</span> CBT_VALUE:</td>
      </tr>
      <tr>
        <td id="L4223" data-line-number="4223"></td>
        <td id="LC4223">        <span>return</span> <span>static_cast</span>&lt;ICorDebugValueBreakpoint *&gt;(<span>static_cast</span>&lt;CordbValueBreakpoint *&gt; (pBreakpoint));</td>
      </tr>
      <tr>
        <td id="L4224" data-line-number="4224"></td>
        <td id="LC4224">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4225" data-line-number="4225"></td>
        <td id="LC4225">
</td>
      </tr>
      <tr>
        <td id="L4226" data-line-number="4226"></td>
        <td id="LC4226">    <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L4227" data-line-number="4227"></td>
        <td id="LC4227">        <span>_ASSERTE</span>(!<span><span>"</span>Invalid breakpoint type!<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4228" data-line-number="4228"></td>
        <td id="LC4228">    }</td>
      </tr>
      <tr>
        <td id="L4229" data-line-number="4229"></td>
        <td id="LC4229">
</td>
      </tr>
      <tr>
        <td id="L4230" data-line-number="4230"></td>
        <td id="LC4230">    <span>return</span> <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L4231" data-line-number="4231"></td>
        <td id="LC4231">}</td>
      </tr>
      <tr>
        <td id="L4232" data-line-number="4232"></td>
        <td id="LC4232">
</td>
      </tr>
      <tr>
        <td id="L4233" data-line-number="4233"></td>
        <td id="LC4233">
</td>
      </tr>
      <tr>
        <td id="L4234" data-line-number="4234"></td>
        <td id="LC4234"><span><span>//</span> Callback data for code:CordbProcess::GetAssembliesInLoadOrder</span></td>
      </tr>
      <tr>
        <td id="L4235" data-line-number="4235"></td>
        <td id="LC4235"><span>class</span> <span>ShimAssemblyCallbackData</span></td>
      </tr>
      <tr>
        <td id="L4236" data-line-number="4236"></td>
        <td id="LC4236">{</td>
      </tr>
      <tr>
        <td id="L4237" data-line-number="4237"></td>
        <td id="LC4237"><span>public:</span></td>
      </tr>
      <tr>
        <td id="L4238" data-line-number="4238"></td>
        <td id="LC4238">    <span><span>//</span> Ctor to intialize callback data</span></td>
      </tr>
      <tr>
        <td id="L4239" data-line-number="4239"></td>
        <td id="LC4239">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4240" data-line-number="4240"></td>
        <td id="LC4240">    <span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4241" data-line-number="4241"></td>
        <td id="LC4241">    <span><span>//</span>   pAppDomain - appdomain that the assemblies are in.</span></td>
      </tr>
      <tr>
        <td id="L4242" data-line-number="4242"></td>
        <td id="LC4242">    <span><span>//</span>   pAssemblies - preallocated array of smart pointers to hold assemblies</span></td>
      </tr>
      <tr>
        <td id="L4243" data-line-number="4243"></td>
        <td id="LC4243">    <span><span>//</span>   countAssemblies - size of pAssemblies in elements.</span></td>
      </tr>
      <tr>
        <td id="L4244" data-line-number="4244"></td>
        <td id="LC4244">    <span>ShimAssemblyCallbackData</span>(</td>
      </tr>
      <tr>
        <td id="L4245" data-line-number="4245"></td>
        <td id="LC4245">        CordbAppDomain * pAppDomain,</td>
      </tr>
      <tr>
        <td id="L4246" data-line-number="4246"></td>
        <td id="LC4246">        RSExtSmartPtr&lt;ICorDebugAssembly&gt;* pAssemblies,</td>
      </tr>
      <tr>
        <td id="L4247" data-line-number="4247"></td>
        <td id="LC4247">        ULONG countAssemblies)</td>
      </tr>
      <tr>
        <td id="L4248" data-line-number="4248"></td>
        <td id="LC4248">    {</td>
      </tr>
      <tr>
        <td id="L4249" data-line-number="4249"></td>
        <td id="LC4249">        <span>_ASSERTE</span>(pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4250" data-line-number="4250"></td>
        <td id="LC4250">        <span>_ASSERTE</span>(pAssemblies != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4251" data-line-number="4251"></td>
        <td id="LC4251">
</td>
      </tr>
      <tr>
        <td id="L4252" data-line-number="4252"></td>
        <td id="LC4252">        m_pProcess = pAppDomain-&gt;<span>GetProcess</span>();</td>
      </tr>
      <tr>
        <td id="L4253" data-line-number="4253"></td>
        <td id="LC4253">        m_pAppDomain = pAppDomain;</td>
      </tr>
      <tr>
        <td id="L4254" data-line-number="4254"></td>
        <td id="LC4254">        m_pAssemblies = pAssemblies;</td>
      </tr>
      <tr>
        <td id="L4255" data-line-number="4255"></td>
        <td id="LC4255">        m_countElements = countAssemblies;</td>
      </tr>
      <tr>
        <td id="L4256" data-line-number="4256"></td>
        <td id="LC4256">        m_index = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4257" data-line-number="4257"></td>
        <td id="LC4257">
</td>
      </tr>
      <tr>
        <td id="L4258" data-line-number="4258"></td>
        <td id="LC4258">        <span><span>//</span> Just to be safe, clear them all out</span></td>
      </tr>
      <tr>
        <td id="L4259" data-line-number="4259"></td>
        <td id="LC4259">        <span>for</span>(ULONG i = <span>0</span>; i &lt; countAssemblies; i++)</td>
      </tr>
      <tr>
        <td id="L4260" data-line-number="4260"></td>
        <td id="LC4260">        {</td>
      </tr>
      <tr>
        <td id="L4261" data-line-number="4261"></td>
        <td id="LC4261">            pAssemblies[i].<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L4262" data-line-number="4262"></td>
        <td id="LC4262">        }</td>
      </tr>
      <tr>
        <td id="L4263" data-line-number="4263"></td>
        <td id="LC4263">    }</td>
      </tr>
      <tr>
        <td id="L4264" data-line-number="4264"></td>
        <td id="LC4264">
</td>
      </tr>
      <tr>
        <td id="L4265" data-line-number="4265"></td>
        <td id="LC4265">    <span><span>//</span> Dtor</span></td>
      </tr>
      <tr>
        <td id="L4266" data-line-number="4266"></td>
        <td id="LC4266">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4267" data-line-number="4267"></td>
        <td id="LC4267">    <span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L4268" data-line-number="4268"></td>
        <td id="LC4268">    <span><span>//</span>   This can assert end-of-enumeration invariants.</span></td>
      </tr>
      <tr>
        <td id="L4269" data-line-number="4269"></td>
        <td id="LC4269">    <span>~ShimAssemblyCallbackData</span>()</td>
      </tr>
      <tr>
        <td id="L4270" data-line-number="4270"></td>
        <td id="LC4270">    {</td>
      </tr>
      <tr>
        <td id="L4271" data-line-number="4271"></td>
        <td id="LC4271">        <span><span>//</span> Ensure that we went through all assemblies.</span></td>
      </tr>
      <tr>
        <td id="L4272" data-line-number="4272"></td>
        <td id="LC4272">        <span>_ASSERTE</span>(m_index == m_countElements);</td>
      </tr>
      <tr>
        <td id="L4273" data-line-number="4273"></td>
        <td id="LC4273">    }</td>
      </tr>
      <tr>
        <td id="L4274" data-line-number="4274"></td>
        <td id="LC4274">
</td>
      </tr>
      <tr>
        <td id="L4275" data-line-number="4275"></td>
        <td id="LC4275">    <span><span>//</span> Callback invoked from DAC enumeration.</span></td>
      </tr>
      <tr>
        <td id="L4276" data-line-number="4276"></td>
        <td id="LC4276">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4277" data-line-number="4277"></td>
        <td id="LC4277">    <span><span>//</span> arguments:</span></td>
      </tr>
      <tr>
        <td id="L4278" data-line-number="4278"></td>
        <td id="LC4278">    <span><span>//</span>    vmDomainAssembly - VMPTR for assembly</span></td>
      </tr>
      <tr>
        <td id="L4279" data-line-number="4279"></td>
        <td id="LC4279">    <span><span>//</span>    pData - a 'this' pointer</span></td>
      </tr>
      <tr>
        <td id="L4280" data-line-number="4280"></td>
        <td id="LC4280">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4281" data-line-number="4281"></td>
        <td id="LC4281">    <span>static</span> <span>void</span> <span>Callback</span>(VMPTR_DomainAssembly vmDomainAssembly, <span>void</span> * pData)</td>
      </tr>
      <tr>
        <td id="L4282" data-line-number="4282"></td>
        <td id="LC4282">    {</td>
      </tr>
      <tr>
        <td id="L4283" data-line-number="4283"></td>
        <td id="LC4283">        ShimAssemblyCallbackData * pThis = <span>static_cast</span>&lt;ShimAssemblyCallbackData *&gt; (pData);</td>
      </tr>
      <tr>
        <td id="L4284" data-line-number="4284"></td>
        <td id="LC4284">        <span>INTERNAL_DAC_CALLBACK</span>(pThis-&gt;<span>m_pProcess</span>);</td>
      </tr>
      <tr>
        <td id="L4285" data-line-number="4285"></td>
        <td id="LC4285">
</td>
      </tr>
      <tr>
        <td id="L4286" data-line-number="4286"></td>
        <td id="LC4286">        CordbAssembly * pAssembly = pThis-&gt;<span>m_pAppDomain</span>-&gt;<span>LookupOrCreateAssembly</span>(vmDomainAssembly);</td>
      </tr>
      <tr>
        <td id="L4287" data-line-number="4287"></td>
        <td id="LC4287">
</td>
      </tr>
      <tr>
        <td id="L4288" data-line-number="4288"></td>
        <td id="LC4288">        pThis-&gt;<span>SetAndMoveNext</span>(pAssembly);</td>
      </tr>
      <tr>
        <td id="L4289" data-line-number="4289"></td>
        <td id="LC4289">    }</td>
      </tr>
      <tr>
        <td id="L4290" data-line-number="4290"></td>
        <td id="LC4290">
</td>
      </tr>
      <tr>
        <td id="L4291" data-line-number="4291"></td>
        <td id="LC4291">    <span><span>//</span> Set the current index in the table and increment the cursor.</span></td>
      </tr>
      <tr>
        <td id="L4292" data-line-number="4292"></td>
        <td id="LC4292">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4293" data-line-number="4293"></td>
        <td id="LC4293">    <span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4294" data-line-number="4294"></td>
        <td id="LC4294">    <span><span>//</span>    pAssembly - assembly from DAC enumerator</span></td>
      </tr>
      <tr>
        <td id="L4295" data-line-number="4295"></td>
        <td id="LC4295">    <span>void</span> <span>SetAndMoveNext</span>(CordbAssembly * pAssembly)</td>
      </tr>
      <tr>
        <td id="L4296" data-line-number="4296"></td>
        <td id="LC4296">    {</td>
      </tr>
      <tr>
        <td id="L4297" data-line-number="4297"></td>
        <td id="LC4297">        <span>_ASSERTE</span>(pAssembly != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4298" data-line-number="4298"></td>
        <td id="LC4298">
</td>
      </tr>
      <tr>
        <td id="L4299" data-line-number="4299"></td>
        <td id="LC4299">        <span>if</span> (m_index &gt;= m_countElements)</td>
      </tr>
      <tr>
        <td id="L4300" data-line-number="4300"></td>
        <td id="LC4300">        {</td>
      </tr>
      <tr>
        <td id="L4301" data-line-number="4301"></td>
        <td id="LC4301">            <span><span>//</span> Enumerating the assemblies in the target should be fixed since</span></td>
      </tr>
      <tr>
        <td id="L4302" data-line-number="4302"></td>
        <td id="LC4302">            <span><span>//</span> the target is not running.</span></td>
      </tr>
      <tr>
        <td id="L4303" data-line-number="4303"></td>
        <td id="LC4303">            <span><span>//</span> We should never get here unless the target is unstable.</span></td>
      </tr>
      <tr>
        <td id="L4304" data-line-number="4304"></td>
        <td id="LC4304">            <span><span>//</span> The caller (the shim) pre-allocated the table of assemblies.</span></td>
      </tr>
      <tr>
        <td id="L4305" data-line-number="4305"></td>
        <td id="LC4305">            m_pProcess-&gt;<span>TargetConsistencyCheck</span>(!<span><span>"</span>Target changed assembly count<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4306" data-line-number="4306"></td>
        <td id="LC4306">            <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L4307" data-line-number="4307"></td>
        <td id="LC4307">        }</td>
      </tr>
      <tr>
        <td id="L4308" data-line-number="4308"></td>
        <td id="LC4308">
</td>
      </tr>
      <tr>
        <td id="L4309" data-line-number="4309"></td>
        <td id="LC4309">        m_pAssemblies[m_index].<span>Assign</span>(pAssembly);</td>
      </tr>
      <tr>
        <td id="L4310" data-line-number="4310"></td>
        <td id="LC4310">        m_index++;</td>
      </tr>
      <tr>
        <td id="L4311" data-line-number="4311"></td>
        <td id="LC4311">    }</td>
      </tr>
      <tr>
        <td id="L4312" data-line-number="4312"></td>
        <td id="LC4312">
</td>
      </tr>
      <tr>
        <td id="L4313" data-line-number="4313"></td>
        <td id="LC4313"><span>protected:</span></td>
      </tr>
      <tr>
        <td id="L4314" data-line-number="4314"></td>
        <td id="LC4314">    CordbProcess * m_pProcess;</td>
      </tr>
      <tr>
        <td id="L4315" data-line-number="4315"></td>
        <td id="LC4315">    CordbAppDomain * m_pAppDomain;</td>
      </tr>
      <tr>
        <td id="L4316" data-line-number="4316"></td>
        <td id="LC4316">    RSExtSmartPtr&lt;ICorDebugAssembly&gt;* m_pAssemblies;</td>
      </tr>
      <tr>
        <td id="L4317" data-line-number="4317"></td>
        <td id="LC4317">    ULONG m_countElements;</td>
      </tr>
      <tr>
        <td id="L4318" data-line-number="4318"></td>
        <td id="LC4318">    ULONG m_index;</td>
      </tr>
      <tr>
        <td id="L4319" data-line-number="4319"></td>
        <td id="LC4319">};</td>
      </tr>
      <tr>
        <td id="L4320" data-line-number="4320"></td>
        <td id="LC4320">
</td>
      </tr>
      <tr>
        <td id="L4321" data-line-number="4321"></td>
        <td id="LC4321"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4322" data-line-number="4322"></td>
        <td id="LC4322"><span><span>//</span> Shim Helper to enumerate the assemblies in the load-order</span></td>
      </tr>
      <tr>
        <td id="L4323" data-line-number="4323"></td>
        <td id="LC4323"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4324" data-line-number="4324"></td>
        <td id="LC4324"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4325" data-line-number="4325"></td>
        <td id="LC4325"><span><span>//</span>    pAppdomain - non-null appdomain to enumerate assemblies.</span></td>
      </tr>
      <tr>
        <td id="L4326" data-line-number="4326"></td>
        <td id="LC4326"><span><span>//</span>    pAssemblies - caller pre-allocated array to hold assemblies</span></td>
      </tr>
      <tr>
        <td id="L4327" data-line-number="4327"></td>
        <td id="LC4327"><span><span>//</span>    countAssemblies - size of the array.</span></td>
      </tr>
      <tr>
        <td id="L4328" data-line-number="4328"></td>
        <td id="LC4328"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4329" data-line-number="4329"></td>
        <td id="LC4329"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L4330" data-line-number="4330"></td>
        <td id="LC4330"><span><span>//</span>    Caller preallocated array (likely from ICorDebugAssemblyEnum::GetCount),</span></td>
      </tr>
      <tr>
        <td id="L4331" data-line-number="4331"></td>
        <td id="LC4331"><span><span>//</span>    and now this function fills in the assemblies in the order they were</span></td>
      </tr>
      <tr>
        <td id="L4332" data-line-number="4332"></td>
        <td id="LC4332"><span><span>//</span>    loaded.</span></td>
      </tr>
      <tr>
        <td id="L4333" data-line-number="4333"></td>
        <td id="LC4333"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4334" data-line-number="4334"></td>
        <td id="LC4334"><span><span>//</span>    The target should be stable, such that the number of assemblies in the</span></td>
      </tr>
      <tr>
        <td id="L4335" data-line-number="4335"></td>
        <td id="LC4335"><span><span>//</span>    target is stable, and therefore countAssemblies as determined by the</span></td>
      </tr>
      <tr>
        <td id="L4336" data-line-number="4336"></td>
        <td id="LC4336"><span><span>//</span>    shim via ICorDebugAssemblyEnum::GetCount should match the number of</span></td>
      </tr>
      <tr>
        <td id="L4337" data-line-number="4337"></td>
        <td id="LC4337"><span><span>//</span>    assemblies enumerated here.</span></td>
      </tr>
      <tr>
        <td id="L4338" data-line-number="4338"></td>
        <td id="LC4338"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4339" data-line-number="4339"></td>
        <td id="LC4339"><span><span>//</span>    Called by code:ShimProcess::QueueFakeAttachEvents.</span></td>
      </tr>
      <tr>
        <td id="L4340" data-line-number="4340"></td>
        <td id="LC4340"><span><span>//</span>    This provides the assemblies in load-order. In contrast,</span></td>
      </tr>
      <tr>
        <td id="L4341" data-line-number="4341"></td>
        <td id="LC4341"><span><span>//</span>    ICorDebugAppDomain::EnumerateAssemblies is a random order. The shim needs</span></td>
      </tr>
      <tr>
        <td id="L4342" data-line-number="4342"></td>
        <td id="LC4342"><span><span>//</span>    load-order to match Whidbey semantics for dispatching fake load-assembly</span></td>
      </tr>
      <tr>
        <td id="L4343" data-line-number="4343"></td>
        <td id="LC4343"><span><span>//</span>    callbacks on attach. The debugger then uses the order</span></td>
      </tr>
      <tr>
        <td id="L4344" data-line-number="4344"></td>
        <td id="LC4344"><span><span>//</span>    in its module display window.</span></td>
      </tr>
      <tr>
        <td id="L4345" data-line-number="4345"></td>
        <td id="LC4345"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4346" data-line-number="4346"></td>
        <td id="LC4346"><span>void</span> <span>CordbProcess::GetAssembliesInLoadOrder</span>(</td>
      </tr>
      <tr>
        <td id="L4347" data-line-number="4347"></td>
        <td id="LC4347">    ICorDebugAppDomain * pAppDomain,</td>
      </tr>
      <tr>
        <td id="L4348" data-line-number="4348"></td>
        <td id="LC4348">    RSExtSmartPtr&lt;ICorDebugAssembly&gt;* pAssemblies,</td>
      </tr>
      <tr>
        <td id="L4349" data-line-number="4349"></td>
        <td id="LC4349">    ULONG countAssemblies)</td>
      </tr>
      <tr>
        <td id="L4350" data-line-number="4350"></td>
        <td id="LC4350">{</td>
      </tr>
      <tr>
        <td id="L4351" data-line-number="4351"></td>
        <td id="LC4351">    <span>PUBLIC_API_ENTRY_FOR_SHIM</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4352" data-line-number="4352"></td>
        <td id="LC4352">    RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L4353" data-line-number="4353"></td>
        <td id="LC4353">
</td>
      </tr>
      <tr>
        <td id="L4354" data-line-number="4354"></td>
        <td id="LC4354">    <span>_ASSERTE</span>(<span>GetShim</span>() != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4355" data-line-number="4355"></td>
        <td id="LC4355">
</td>
      </tr>
      <tr>
        <td id="L4356" data-line-number="4356"></td>
        <td id="LC4356">    CordbAppDomain * pAppDomainInternal = <span>static_cast</span>&lt;CordbAppDomain *&gt; (pAppDomain);</td>
      </tr>
      <tr>
        <td id="L4357" data-line-number="4357"></td>
        <td id="LC4357">
</td>
      </tr>
      <tr>
        <td id="L4358" data-line-number="4358"></td>
        <td id="LC4358">    ShimAssemblyCallbackData <span>data</span>(pAppDomainInternal, pAssemblies, countAssemblies);</td>
      </tr>
      <tr>
        <td id="L4359" data-line-number="4359"></td>
        <td id="LC4359">
</td>
      </tr>
      <tr>
        <td id="L4360" data-line-number="4360"></td>
        <td id="LC4360">    <span><span>//</span> Enumerate through and fill out pAssemblies table.</span></td>
      </tr>
      <tr>
        <td id="L4361" data-line-number="4361"></td>
        <td id="LC4361">    <span>GetDAC</span>()-&gt;<span>EnumerateAssembliesInAppDomain</span>(</td>
      </tr>
      <tr>
        <td id="L4362" data-line-number="4362"></td>
        <td id="LC4362">        pAppDomainInternal-&gt;<span>GetADToken</span>(),</td>
      </tr>
      <tr>
        <td id="L4363" data-line-number="4363"></td>
        <td id="LC4363">        ShimAssemblyCallbackData::Callback,</td>
      </tr>
      <tr>
        <td id="L4364" data-line-number="4364"></td>
        <td id="LC4364">        &amp;data); <span><span>//</span> user data</span></td>
      </tr>
      <tr>
        <td id="L4365" data-line-number="4365"></td>
        <td id="LC4365">
</td>
      </tr>
      <tr>
        <td id="L4366" data-line-number="4366"></td>
        <td id="LC4366">    <span><span>//</span> pAssemblies array has now been updated.</span></td>
      </tr>
      <tr>
        <td id="L4367" data-line-number="4367"></td>
        <td id="LC4367">}</td>
      </tr>
      <tr>
        <td id="L4368" data-line-number="4368"></td>
        <td id="LC4368">
</td>
      </tr>
      <tr>
        <td id="L4369" data-line-number="4369"></td>
        <td id="LC4369"><span><span>//</span> Callback data for code:CordbProcess::GetModulesInLoadOrder</span></td>
      </tr>
      <tr>
        <td id="L4370" data-line-number="4370"></td>
        <td id="LC4370"><span>class</span> <span>ShimModuleCallbackData</span></td>
      </tr>
      <tr>
        <td id="L4371" data-line-number="4371"></td>
        <td id="LC4371">{</td>
      </tr>
      <tr>
        <td id="L4372" data-line-number="4372"></td>
        <td id="LC4372"><span>public:</span></td>
      </tr>
      <tr>
        <td id="L4373" data-line-number="4373"></td>
        <td id="LC4373">    <span><span>//</span> Ctor to intialize callback data</span></td>
      </tr>
      <tr>
        <td id="L4374" data-line-number="4374"></td>
        <td id="LC4374">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4375" data-line-number="4375"></td>
        <td id="LC4375">    <span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4376" data-line-number="4376"></td>
        <td id="LC4376">    <span><span>//</span>   pAssembly - assembly that the Modules are in.</span></td>
      </tr>
      <tr>
        <td id="L4377" data-line-number="4377"></td>
        <td id="LC4377">    <span><span>//</span>   pModules - preallocated array of smart pointers to hold Modules</span></td>
      </tr>
      <tr>
        <td id="L4378" data-line-number="4378"></td>
        <td id="LC4378">    <span><span>//</span>   countModules - size of pModules in elements.</span></td>
      </tr>
      <tr>
        <td id="L4379" data-line-number="4379"></td>
        <td id="LC4379">    <span>ShimModuleCallbackData</span>(</td>
      </tr>
      <tr>
        <td id="L4380" data-line-number="4380"></td>
        <td id="LC4380">        CordbAssembly * pAssembly,</td>
      </tr>
      <tr>
        <td id="L4381" data-line-number="4381"></td>
        <td id="LC4381">        RSExtSmartPtr&lt;ICorDebugModule&gt;* pModules,</td>
      </tr>
      <tr>
        <td id="L4382" data-line-number="4382"></td>
        <td id="LC4382">        ULONG countModules)</td>
      </tr>
      <tr>
        <td id="L4383" data-line-number="4383"></td>
        <td id="LC4383">    {</td>
      </tr>
      <tr>
        <td id="L4384" data-line-number="4384"></td>
        <td id="LC4384">        <span>_ASSERTE</span>(pAssembly != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4385" data-line-number="4385"></td>
        <td id="LC4385">        <span>_ASSERTE</span>(pModules != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4386" data-line-number="4386"></td>
        <td id="LC4386">
</td>
      </tr>
      <tr>
        <td id="L4387" data-line-number="4387"></td>
        <td id="LC4387">        m_pProcess = pAssembly-&gt;<span>GetAppDomain</span>()-&gt;<span>GetProcess</span>();</td>
      </tr>
      <tr>
        <td id="L4388" data-line-number="4388"></td>
        <td id="LC4388">        m_pAssembly = pAssembly;</td>
      </tr>
      <tr>
        <td id="L4389" data-line-number="4389"></td>
        <td id="LC4389">        m_pModules = pModules;</td>
      </tr>
      <tr>
        <td id="L4390" data-line-number="4390"></td>
        <td id="LC4390">        m_countElements = countModules;</td>
      </tr>
      <tr>
        <td id="L4391" data-line-number="4391"></td>
        <td id="LC4391">        m_index = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4392" data-line-number="4392"></td>
        <td id="LC4392">
</td>
      </tr>
      <tr>
        <td id="L4393" data-line-number="4393"></td>
        <td id="LC4393">        <span><span>//</span> Just to be safe, clear them all out</span></td>
      </tr>
      <tr>
        <td id="L4394" data-line-number="4394"></td>
        <td id="LC4394">        <span>for</span>(ULONG i = <span>0</span>; i &lt; countModules; i++)</td>
      </tr>
      <tr>
        <td id="L4395" data-line-number="4395"></td>
        <td id="LC4395">        {</td>
      </tr>
      <tr>
        <td id="L4396" data-line-number="4396"></td>
        <td id="LC4396">            pModules[i].<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L4397" data-line-number="4397"></td>
        <td id="LC4397">        }</td>
      </tr>
      <tr>
        <td id="L4398" data-line-number="4398"></td>
        <td id="LC4398">    }</td>
      </tr>
      <tr>
        <td id="L4399" data-line-number="4399"></td>
        <td id="LC4399">
</td>
      </tr>
      <tr>
        <td id="L4400" data-line-number="4400"></td>
        <td id="LC4400">    <span><span>//</span> Dtor</span></td>
      </tr>
      <tr>
        <td id="L4401" data-line-number="4401"></td>
        <td id="LC4401">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4402" data-line-number="4402"></td>
        <td id="LC4402">    <span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L4403" data-line-number="4403"></td>
        <td id="LC4403">    <span><span>//</span>   This can assert end-of-enumeration invariants.</span></td>
      </tr>
      <tr>
        <td id="L4404" data-line-number="4404"></td>
        <td id="LC4404">    <span>~ShimModuleCallbackData</span>()</td>
      </tr>
      <tr>
        <td id="L4405" data-line-number="4405"></td>
        <td id="LC4405">    {</td>
      </tr>
      <tr>
        <td id="L4406" data-line-number="4406"></td>
        <td id="LC4406">        <span><span>//</span> Ensure that we went through all Modules.</span></td>
      </tr>
      <tr>
        <td id="L4407" data-line-number="4407"></td>
        <td id="LC4407">        <span>_ASSERTE</span>(m_index == m_countElements);</td>
      </tr>
      <tr>
        <td id="L4408" data-line-number="4408"></td>
        <td id="LC4408">    }</td>
      </tr>
      <tr>
        <td id="L4409" data-line-number="4409"></td>
        <td id="LC4409">
</td>
      </tr>
      <tr>
        <td id="L4410" data-line-number="4410"></td>
        <td id="LC4410">    <span><span>//</span> Callback invoked from DAC enumeration.</span></td>
      </tr>
      <tr>
        <td id="L4411" data-line-number="4411"></td>
        <td id="LC4411">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4412" data-line-number="4412"></td>
        <td id="LC4412">    <span><span>//</span> arguments:</span></td>
      </tr>
      <tr>
        <td id="L4413" data-line-number="4413"></td>
        <td id="LC4413">    <span><span>//</span>    vmDomainFile - VMPTR for Module</span></td>
      </tr>
      <tr>
        <td id="L4414" data-line-number="4414"></td>
        <td id="LC4414">    <span><span>//</span>    pData - a 'this' pointer</span></td>
      </tr>
      <tr>
        <td id="L4415" data-line-number="4415"></td>
        <td id="LC4415">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4416" data-line-number="4416"></td>
        <td id="LC4416">    <span>static</span> <span>void</span> <span>Callback</span>(VMPTR_DomainFile vmDomainFile, <span>void</span> * pData)</td>
      </tr>
      <tr>
        <td id="L4417" data-line-number="4417"></td>
        <td id="LC4417">    {</td>
      </tr>
      <tr>
        <td id="L4418" data-line-number="4418"></td>
        <td id="LC4418">        ShimModuleCallbackData * pThis = <span>static_cast</span>&lt;ShimModuleCallbackData *&gt; (pData);</td>
      </tr>
      <tr>
        <td id="L4419" data-line-number="4419"></td>
        <td id="LC4419">        <span>INTERNAL_DAC_CALLBACK</span>(pThis-&gt;<span>m_pProcess</span>);</td>
      </tr>
      <tr>
        <td id="L4420" data-line-number="4420"></td>
        <td id="LC4420">
</td>
      </tr>
      <tr>
        <td id="L4421" data-line-number="4421"></td>
        <td id="LC4421">        CordbModule * pModule = pThis-&gt;<span>m_pAssembly</span>-&gt;<span>GetAppDomain</span>()-&gt;<span>LookupOrCreateModule</span>(vmDomainFile);</td>
      </tr>
      <tr>
        <td id="L4422" data-line-number="4422"></td>
        <td id="LC4422">
</td>
      </tr>
      <tr>
        <td id="L4423" data-line-number="4423"></td>
        <td id="LC4423">        pThis-&gt;<span>SetAndMoveNext</span>(pModule);</td>
      </tr>
      <tr>
        <td id="L4424" data-line-number="4424"></td>
        <td id="LC4424">    }</td>
      </tr>
      <tr>
        <td id="L4425" data-line-number="4425"></td>
        <td id="LC4425">
</td>
      </tr>
      <tr>
        <td id="L4426" data-line-number="4426"></td>
        <td id="LC4426">    <span><span>//</span> Set the current index in the table and increment the cursor.</span></td>
      </tr>
      <tr>
        <td id="L4427" data-line-number="4427"></td>
        <td id="LC4427">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4428" data-line-number="4428"></td>
        <td id="LC4428">    <span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4429" data-line-number="4429"></td>
        <td id="LC4429">    <span><span>//</span>    pModule - Module from DAC enumerator</span></td>
      </tr>
      <tr>
        <td id="L4430" data-line-number="4430"></td>
        <td id="LC4430">    <span>void</span> <span>SetAndMoveNext</span>(CordbModule * pModule)</td>
      </tr>
      <tr>
        <td id="L4431" data-line-number="4431"></td>
        <td id="LC4431">    {</td>
      </tr>
      <tr>
        <td id="L4432" data-line-number="4432"></td>
        <td id="LC4432">        <span>_ASSERTE</span>(pModule != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4433" data-line-number="4433"></td>
        <td id="LC4433">
</td>
      </tr>
      <tr>
        <td id="L4434" data-line-number="4434"></td>
        <td id="LC4434">        <span>if</span> (m_index &gt;= m_countElements)</td>
      </tr>
      <tr>
        <td id="L4435" data-line-number="4435"></td>
        <td id="LC4435">        {</td>
      </tr>
      <tr>
        <td id="L4436" data-line-number="4436"></td>
        <td id="LC4436">            <span><span>//</span> Enumerating the Modules in the target should be fixed since</span></td>
      </tr>
      <tr>
        <td id="L4437" data-line-number="4437"></td>
        <td id="LC4437">            <span><span>//</span> the target is not running.</span></td>
      </tr>
      <tr>
        <td id="L4438" data-line-number="4438"></td>
        <td id="LC4438">            <span><span>//</span> We should never get here unless the target is unstable.</span></td>
      </tr>
      <tr>
        <td id="L4439" data-line-number="4439"></td>
        <td id="LC4439">            <span><span>//</span> The caller (the shim) pre-allocated the table of Modules.</span></td>
      </tr>
      <tr>
        <td id="L4440" data-line-number="4440"></td>
        <td id="LC4440">            m_pProcess-&gt;<span>TargetConsistencyCheck</span>(!<span><span>"</span>Target changed Module count<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4441" data-line-number="4441"></td>
        <td id="LC4441">            <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L4442" data-line-number="4442"></td>
        <td id="LC4442">        }</td>
      </tr>
      <tr>
        <td id="L4443" data-line-number="4443"></td>
        <td id="LC4443">
</td>
      </tr>
      <tr>
        <td id="L4444" data-line-number="4444"></td>
        <td id="LC4444">        m_pModules[m_index].<span>Assign</span>(pModule);</td>
      </tr>
      <tr>
        <td id="L4445" data-line-number="4445"></td>
        <td id="LC4445">        m_index++;</td>
      </tr>
      <tr>
        <td id="L4446" data-line-number="4446"></td>
        <td id="LC4446">    }</td>
      </tr>
      <tr>
        <td id="L4447" data-line-number="4447"></td>
        <td id="LC4447">
</td>
      </tr>
      <tr>
        <td id="L4448" data-line-number="4448"></td>
        <td id="LC4448"><span>protected:</span></td>
      </tr>
      <tr>
        <td id="L4449" data-line-number="4449"></td>
        <td id="LC4449">    CordbProcess * m_pProcess;</td>
      </tr>
      <tr>
        <td id="L4450" data-line-number="4450"></td>
        <td id="LC4450">    CordbAssembly * m_pAssembly;</td>
      </tr>
      <tr>
        <td id="L4451" data-line-number="4451"></td>
        <td id="LC4451">    RSExtSmartPtr&lt;ICorDebugModule&gt;* m_pModules;</td>
      </tr>
      <tr>
        <td id="L4452" data-line-number="4452"></td>
        <td id="LC4452">    ULONG m_countElements;</td>
      </tr>
      <tr>
        <td id="L4453" data-line-number="4453"></td>
        <td id="LC4453">    ULONG m_index;</td>
      </tr>
      <tr>
        <td id="L4454" data-line-number="4454"></td>
        <td id="LC4454">};</td>
      </tr>
      <tr>
        <td id="L4455" data-line-number="4455"></td>
        <td id="LC4455">
</td>
      </tr>
      <tr>
        <td id="L4456" data-line-number="4456"></td>
        <td id="LC4456"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4457" data-line-number="4457"></td>
        <td id="LC4457"><span><span>//</span> Shim Helper to enumerate the Modules in the load-order</span></td>
      </tr>
      <tr>
        <td id="L4458" data-line-number="4458"></td>
        <td id="LC4458"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4459" data-line-number="4459"></td>
        <td id="LC4459"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4460" data-line-number="4460"></td>
        <td id="LC4460"><span><span>//</span>    pAppdomain - non-null appdomain to enumerate Modules.</span></td>
      </tr>
      <tr>
        <td id="L4461" data-line-number="4461"></td>
        <td id="LC4461"><span><span>//</span>    pModules - caller pre-allocated array to hold Modules</span></td>
      </tr>
      <tr>
        <td id="L4462" data-line-number="4462"></td>
        <td id="LC4462"><span><span>//</span>    countModules - size of the array.</span></td>
      </tr>
      <tr>
        <td id="L4463" data-line-number="4463"></td>
        <td id="LC4463"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4464" data-line-number="4464"></td>
        <td id="LC4464"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L4465" data-line-number="4465"></td>
        <td id="LC4465"><span><span>//</span>    Caller preallocated array (likely from ICorDebugModuleEnum::GetCount),</span></td>
      </tr>
      <tr>
        <td id="L4466" data-line-number="4466"></td>
        <td id="LC4466"><span><span>//</span>    and now this function fills in the Modules in the order they were</span></td>
      </tr>
      <tr>
        <td id="L4467" data-line-number="4467"></td>
        <td id="LC4467"><span><span>//</span>    loaded.</span></td>
      </tr>
      <tr>
        <td id="L4468" data-line-number="4468"></td>
        <td id="LC4468"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4469" data-line-number="4469"></td>
        <td id="LC4469"><span><span>//</span>    The target should be stable, such that the number of Modules in the</span></td>
      </tr>
      <tr>
        <td id="L4470" data-line-number="4470"></td>
        <td id="LC4470"><span><span>//</span>    target is stable, and therefore countModules as determined by the</span></td>
      </tr>
      <tr>
        <td id="L4471" data-line-number="4471"></td>
        <td id="LC4471"><span><span>//</span>    shim via ICorDebugModuleEnum::GetCount should match the number of</span></td>
      </tr>
      <tr>
        <td id="L4472" data-line-number="4472"></td>
        <td id="LC4472"><span><span>//</span>    Modules enumerated here.</span></td>
      </tr>
      <tr>
        <td id="L4473" data-line-number="4473"></td>
        <td id="LC4473"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4474" data-line-number="4474"></td>
        <td id="LC4474"><span><span>//</span>    Called by code:ShimProcess::QueueFakeAssemblyAndModuleEvent.</span></td>
      </tr>
      <tr>
        <td id="L4475" data-line-number="4475"></td>
        <td id="LC4475"><span><span>//</span>    This provides the Modules in load-order. In contrast,</span></td>
      </tr>
      <tr>
        <td id="L4476" data-line-number="4476"></td>
        <td id="LC4476"><span><span>//</span>    ICorDebugAssembly::EnumerateModules is a random order. The shim needs</span></td>
      </tr>
      <tr>
        <td id="L4477" data-line-number="4477"></td>
        <td id="LC4477"><span><span>//</span>    load-order to match Whidbey semantics for dispatching fake load-Module</span></td>
      </tr>
      <tr>
        <td id="L4478" data-line-number="4478"></td>
        <td id="LC4478"><span><span>//</span>    callbacks on attach. The most important thing is that the manifest module</span></td>
      </tr>
      <tr>
        <td id="L4479" data-line-number="4479"></td>
        <td id="LC4479"><span><span>//</span>    gets a LodModule callback before any secondary modules.  For dynamic</span></td>
      </tr>
      <tr>
        <td id="L4480" data-line-number="4480"></td>
        <td id="LC4480"><span><span>//</span>    modules, this is necessary for operations on the secondary module</span></td>
      </tr>
      <tr>
        <td id="L4481" data-line-number="4481"></td>
        <td id="LC4481"><span><span>//</span>    that rely on manifest metadata (eg. GetSimpleName).</span></td>
      </tr>
      <tr>
        <td id="L4482" data-line-number="4482"></td>
        <td id="LC4482"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4483" data-line-number="4483"></td>
        <td id="LC4483"><span><span>//</span>    @dbgtodo : This is almost identical to GetAssembliesInLoadOrder, and</span></td>
      </tr>
      <tr>
        <td id="L4484" data-line-number="4484"></td>
        <td id="LC4484"><span><span>//</span>    (together wih the CallbackData classes) seems a HUGE amount of code and</span></td>
      </tr>
      <tr>
        <td id="L4485" data-line-number="4485"></td>
        <td id="LC4485"><span><span>//</span>    complexity for such a simple thing.  We also have extra code to order</span></td>
      </tr>
      <tr>
        <td id="L4486" data-line-number="4486"></td>
        <td id="LC4486"><span><span>//</span>    AppDomains and Threads.  We should try and rip all of this extra complexity</span></td>
      </tr>
      <tr>
        <td id="L4487" data-line-number="4487"></td>
        <td id="LC4487"><span><span>//</span>    out, and replace it with better data structures for storing these items.</span></td>
      </tr>
      <tr>
        <td id="L4488" data-line-number="4488"></td>
        <td id="LC4488"><span><span>//</span>    Eg., if we used std::map, we could have efficient lookups and ordered</span></td>
      </tr>
      <tr>
        <td id="L4489" data-line-number="4489"></td>
        <td id="LC4489"><span><span>//</span>    enumerations.  However, we do need to be careful about exposing new invariants</span></td>
      </tr>
      <tr>
        <td id="L4490" data-line-number="4490"></td>
        <td id="LC4490"><span><span>//</span>    through ICorDebug that customers may depend on, which could place a long-term</span></td>
      </tr>
      <tr>
        <td id="L4491" data-line-number="4491"></td>
        <td id="LC4491"><span><span>//</span>    compatibility burden on us.  We could have a simple generic data structure</span></td>
      </tr>
      <tr>
        <td id="L4492" data-line-number="4492"></td>
        <td id="LC4492"><span><span>//</span>    (eg. built on std::hash_map and std::list) which provided efficient look-up</span></td>
      </tr>
      <tr>
        <td id="L4493" data-line-number="4493"></td>
        <td id="LC4493"><span><span>//</span>    and both in-order and random enumeration.</span></td>
      </tr>
      <tr>
        <td id="L4494" data-line-number="4494"></td>
        <td id="LC4494"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4495" data-line-number="4495"></td>
        <td id="LC4495"><span>void</span> <span>CordbProcess::GetModulesInLoadOrder</span>(</td>
      </tr>
      <tr>
        <td id="L4496" data-line-number="4496"></td>
        <td id="LC4496">    ICorDebugAssembly * pAssembly,</td>
      </tr>
      <tr>
        <td id="L4497" data-line-number="4497"></td>
        <td id="LC4497">    RSExtSmartPtr&lt;ICorDebugModule&gt;* pModules,</td>
      </tr>
      <tr>
        <td id="L4498" data-line-number="4498"></td>
        <td id="LC4498">    ULONG countModules)</td>
      </tr>
      <tr>
        <td id="L4499" data-line-number="4499"></td>
        <td id="LC4499">{</td>
      </tr>
      <tr>
        <td id="L4500" data-line-number="4500"></td>
        <td id="LC4500">    <span>PUBLIC_API_ENTRY_FOR_SHIM</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4501" data-line-number="4501"></td>
        <td id="LC4501">    RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L4502" data-line-number="4502"></td>
        <td id="LC4502">
</td>
      </tr>
      <tr>
        <td id="L4503" data-line-number="4503"></td>
        <td id="LC4503">    <span>_ASSERTE</span>(<span>GetShim</span>() != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4504" data-line-number="4504"></td>
        <td id="LC4504">
</td>
      </tr>
      <tr>
        <td id="L4505" data-line-number="4505"></td>
        <td id="LC4505">    CordbAssembly * pAssemblyInternal = <span>static_cast</span>&lt;CordbAssembly *&gt; (pAssembly);</td>
      </tr>
      <tr>
        <td id="L4506" data-line-number="4506"></td>
        <td id="LC4506">
</td>
      </tr>
      <tr>
        <td id="L4507" data-line-number="4507"></td>
        <td id="LC4507">    ShimModuleCallbackData <span>data</span>(pAssemblyInternal, pModules, countModules);</td>
      </tr>
      <tr>
        <td id="L4508" data-line-number="4508"></td>
        <td id="LC4508">
</td>
      </tr>
      <tr>
        <td id="L4509" data-line-number="4509"></td>
        <td id="LC4509">    <span><span>//</span> Enumerate through and fill out pModules table.</span></td>
      </tr>
      <tr>
        <td id="L4510" data-line-number="4510"></td>
        <td id="LC4510">    <span>GetDAC</span>()-&gt;<span>EnumerateModulesInAssembly</span>(</td>
      </tr>
      <tr>
        <td id="L4511" data-line-number="4511"></td>
        <td id="LC4511">        pAssemblyInternal-&gt;<span>GetDomainAssemblyPtr</span>(),</td>
      </tr>
      <tr>
        <td id="L4512" data-line-number="4512"></td>
        <td id="LC4512">        ShimModuleCallbackData::Callback,</td>
      </tr>
      <tr>
        <td id="L4513" data-line-number="4513"></td>
        <td id="LC4513">        &amp;data); <span><span>//</span> user data</span></td>
      </tr>
      <tr>
        <td id="L4514" data-line-number="4514"></td>
        <td id="LC4514">
</td>
      </tr>
      <tr>
        <td id="L4515" data-line-number="4515"></td>
        <td id="LC4515">    <span><span>//</span> pModules array has now been updated.</span></td>
      </tr>
      <tr>
        <td id="L4516" data-line-number="4516"></td>
        <td id="LC4516">}</td>
      </tr>
      <tr>
        <td id="L4517" data-line-number="4517"></td>
        <td id="LC4517">
</td>
      </tr>
      <tr>
        <td id="L4518" data-line-number="4518"></td>
        <td id="LC4518">
</td>
      </tr>
      <tr>
        <td id="L4519" data-line-number="4519"></td>
        <td id="LC4519"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4520" data-line-number="4520"></td>
        <td id="LC4520"><span><span>//</span> Callback to count the number of enumerations in a process.</span></td>
      </tr>
      <tr>
        <td id="L4521" data-line-number="4521"></td>
        <td id="LC4521"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4522" data-line-number="4522"></td>
        <td id="LC4522"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4523" data-line-number="4523"></td>
        <td id="LC4523"><span><span>//</span>     id - the connection id.</span></td>
      </tr>
      <tr>
        <td id="L4524" data-line-number="4524"></td>
        <td id="LC4524"><span><span>//</span>     pName - name of the connection</span></td>
      </tr>
      <tr>
        <td id="L4525" data-line-number="4525"></td>
        <td id="LC4525"><span><span>//</span>     pUserData - an EnumerateConnectionsData</span></td>
      </tr>
      <tr>
        <td id="L4526" data-line-number="4526"></td>
        <td id="LC4526"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4527" data-line-number="4527"></td>
        <td id="LC4527"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L4528" data-line-number="4528"></td>
        <td id="LC4528"><span><span>//</span>    Helper function for code:CordbProcess::QueueFakeConnectionEvents</span></td>
      </tr>
      <tr>
        <td id="L4529" data-line-number="4529"></td>
        <td id="LC4529"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4530" data-line-number="4530"></td>
        <td id="LC4530"><span><span>//</span> static</span></td>
      </tr>
      <tr>
        <td id="L4531" data-line-number="4531"></td>
        <td id="LC4531"><span>void</span> <span>CordbProcess::CountConnectionsCallback</span>(DWORD id, LPCWSTR pName, <span>void</span> * pUserData)</td>
      </tr>
      <tr>
        <td id="L4532" data-line-number="4532"></td>
        <td id="LC4532">{</td>
      </tr>
      <tr>
        <td id="L4533" data-line-number="4533"></td>
        <td id="LC4533">}</td>
      </tr>
      <tr>
        <td id="L4534" data-line-number="4534"></td>
        <td id="LC4534">
</td>
      </tr>
      <tr>
        <td id="L4535" data-line-number="4535"></td>
        <td id="LC4535"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4536" data-line-number="4536"></td>
        <td id="LC4536"><span><span>//</span> Callback to enumerate all the connections in a process.</span></td>
      </tr>
      <tr>
        <td id="L4537" data-line-number="4537"></td>
        <td id="LC4537"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4538" data-line-number="4538"></td>
        <td id="LC4538"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4539" data-line-number="4539"></td>
        <td id="LC4539"><span><span>//</span>     id - the connection id.</span></td>
      </tr>
      <tr>
        <td id="L4540" data-line-number="4540"></td>
        <td id="LC4540"><span><span>//</span>     pName - name of the connection</span></td>
      </tr>
      <tr>
        <td id="L4541" data-line-number="4541"></td>
        <td id="LC4541"><span><span>//</span>     pUserData - an EnumerateConnectionsData</span></td>
      </tr>
      <tr>
        <td id="L4542" data-line-number="4542"></td>
        <td id="LC4542"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4543" data-line-number="4543"></td>
        <td id="LC4543"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L4544" data-line-number="4544"></td>
        <td id="LC4544"><span><span>//</span>    Helper function for code:CordbProcess::QueueFakeConnectionEvents</span></td>
      </tr>
      <tr>
        <td id="L4545" data-line-number="4545"></td>
        <td id="LC4545"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4546" data-line-number="4546"></td>
        <td id="LC4546"><span><span>//</span> static</span></td>
      </tr>
      <tr>
        <td id="L4547" data-line-number="4547"></td>
        <td id="LC4547"><span>void</span> <span>CordbProcess::EnumerateConnectionsCallback</span>(DWORD id, LPCWSTR pName, <span>void</span> * pUserData)</td>
      </tr>
      <tr>
        <td id="L4548" data-line-number="4548"></td>
        <td id="LC4548">{</td>
      </tr>
      <tr>
        <td id="L4549" data-line-number="4549"></td>
        <td id="LC4549">}</td>
      </tr>
      <tr>
        <td id="L4550" data-line-number="4550"></td>
        <td id="LC4550">
</td>
      </tr>
      <tr>
        <td id="L4551" data-line-number="4551"></td>
        <td id="LC4551"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4552" data-line-number="4552"></td>
        <td id="LC4552"><span><span>//</span> Callback from Shim to queue fake Connection events on attach.</span></td>
      </tr>
      <tr>
        <td id="L4553" data-line-number="4553"></td>
        <td id="LC4553"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4554" data-line-number="4554"></td>
        <td id="LC4554"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L4555" data-line-number="4555"></td>
        <td id="LC4555"><span><span>//</span>    See code:ShimProcess::QueueFakeAttachEvents</span></td>
      </tr>
      <tr>
        <td id="L4556" data-line-number="4556"></td>
        <td id="LC4556"><span>void</span> <span>CordbProcess::QueueFakeConnectionEvents</span>()</td>
      </tr>
      <tr>
        <td id="L4557" data-line-number="4557"></td>
        <td id="LC4557">{</td>
      </tr>
      <tr>
        <td id="L4558" data-line-number="4558"></td>
        <td id="LC4558">    <span>PUBLIC_API_ENTRY_FOR_SHIM</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4559" data-line-number="4559"></td>
        <td id="LC4559">
</td>
      </tr>
      <tr>
        <td id="L4560" data-line-number="4560"></td>
        <td id="LC4560">}</td>
      </tr>
      <tr>
        <td id="L4561" data-line-number="4561"></td>
        <td id="LC4561">
</td>
      </tr>
      <tr>
        <td id="L4562" data-line-number="4562"></td>
        <td id="LC4562"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4563" data-line-number="4563"></td>
        <td id="LC4563"><span><span>//</span> DispatchRCEvent -- dispatches a previously queued IPC event received</span></td>
      </tr>
      <tr>
        <td id="L4564" data-line-number="4564"></td>
        <td id="LC4564"><span><span>//</span> from the runtime controller. This represents the last amount of processing</span></td>
      </tr>
      <tr>
        <td id="L4565" data-line-number="4565"></td>
        <td id="LC4565"><span><span>//</span> the DI gets to do on an event before giving it to the user.</span></td>
      </tr>
      <tr>
        <td id="L4566" data-line-number="4566"></td>
        <td id="LC4566"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4567" data-line-number="4567"></td>
        <td id="LC4567"><span>void</span> <span>CordbProcess::DispatchRCEvent</span>()</td>
      </tr>
      <tr>
        <td id="L4568" data-line-number="4568"></td>
        <td id="LC4568">{</td>
      </tr>
      <tr>
        <td id="L4569" data-line-number="4569"></td>
        <td id="LC4569">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4570" data-line-number="4570"></td>
        <td id="LC4570">
</td>
      </tr>
      <tr>
        <td id="L4571" data-line-number="4571"></td>
        <td id="LC4571">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L4572" data-line-number="4572"></td>
        <td id="LC4572">    {</td>
      </tr>
      <tr>
        <td id="L4573" data-line-number="4573"></td>
        <td id="LC4573">        <span><span>//</span> This is happening on the RCET thread, so there's no place to propogate an error back up.</span></td>
      </tr>
      <tr>
        <td id="L4574" data-line-number="4574"></td>
        <td id="LC4574">        NOTHROW;</td>
      </tr>
      <tr>
        <td id="L4575" data-line-number="4575"></td>
        <td id="LC4575">    }</td>
      </tr>
      <tr>
        <td id="L4576" data-line-number="4576"></td>
        <td id="LC4576">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L4577" data-line-number="4577"></td>
        <td id="LC4577">
</td>
      </tr>
      <tr>
        <td id="L4578" data-line-number="4578"></td>
        <td id="LC4578">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>); <span><span>//</span> V2 case</span></td>
      </tr>
      <tr>
        <td id="L4579" data-line-number="4579"></td>
        <td id="LC4579">
</td>
      </tr>
      <tr>
        <td id="L4580" data-line-number="4580"></td>
        <td id="LC4580">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4581" data-line-number="4581"></td>
        <td id="LC4581">    <span><span>//</span> Note: the current thread should have the process locked when it</span></td>
      </tr>
      <tr>
        <td id="L4582" data-line-number="4582"></td>
        <td id="LC4582">    <span><span>//</span> enters this method.</span></td>
      </tr>
      <tr>
        <td id="L4583" data-line-number="4583"></td>
        <td id="LC4583">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4584" data-line-number="4584"></td>
        <td id="LC4584">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L4585" data-line-number="4585"></td>
        <td id="LC4585">
</td>
      </tr>
      <tr>
        <td id="L4586" data-line-number="4586"></td>
        <td id="LC4586">    <span><span>//</span> Create/Launch paths already ensured that we had a callback.</span></td>
      </tr>
      <tr>
        <td id="L4587" data-line-number="4587"></td>
        <td id="LC4587">    <span>_ASSERTE</span>(m_cordb != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4588" data-line-number="4588"></td>
        <td id="LC4588">    <span>_ASSERTE</span>(m_cordb-&gt;<span>m_managedCallback</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4589" data-line-number="4589"></td>
        <td id="LC4589">    <span>_ASSERTE</span>(m_cordb-&gt;<span>m_managedCallback2</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4590" data-line-number="4590"></td>
        <td id="LC4590">    <span>_ASSERTE</span>(m_cordb-&gt;<span>m_managedCallback3</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4591" data-line-number="4591"></td>
        <td id="LC4591">    <span>_ASSERTE</span>(m_cordb-&gt;<span>m_managedCallback4</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4592" data-line-number="4592"></td>
        <td id="LC4592">
</td>
      </tr>
      <tr>
        <td id="L4593" data-line-number="4593"></td>
        <td id="LC4593">
</td>
      </tr>
      <tr>
        <td id="L4594" data-line-number="4594"></td>
        <td id="LC4594">    <span><span>//</span> Bump up the stop count. Either we'll dispatch a managed event,</span></td>
      </tr>
      <tr>
        <td id="L4595" data-line-number="4595"></td>
        <td id="LC4595">    <span><span>//</span> or the logic below will decide not to dispatch one and call</span></td>
      </tr>
      <tr>
        <td id="L4596" data-line-number="4596"></td>
        <td id="LC4596">    <span><span>//</span> Continue itself. Either way, the stop count needs to go up by</span></td>
      </tr>
      <tr>
        <td id="L4597" data-line-number="4597"></td>
        <td id="LC4597">    <span><span>//</span> one...</span></td>
      </tr>
      <tr>
        <td id="L4598" data-line-number="4598"></td>
        <td id="LC4598">    <span>_ASSERTE</span>(<span>this</span>-&gt;<span>GetSyncCompleteRecv</span>());</td>
      </tr>
      <tr>
        <td id="L4599" data-line-number="4599"></td>
        <td id="LC4599">    <span>SetSynchronized</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L4600" data-line-number="4600"></td>
        <td id="LC4600">    <span>IncStopCount</span>();</td>
      </tr>
      <tr>
        <td id="L4601" data-line-number="4601"></td>
        <td id="LC4601">
</td>
      </tr>
      <tr>
        <td id="L4602" data-line-number="4602"></td>
        <td id="LC4602">    <span><span>//</span> As soon as we call Unlock(), we might get neutered and lose our reference to</span></td>
      </tr>
      <tr>
        <td id="L4603" data-line-number="4603"></td>
        <td id="LC4603">    <span><span>//</span> the shim.  Grab it now for use later.</span></td>
      </tr>
      <tr>
        <td id="L4604" data-line-number="4604"></td>
        <td id="LC4604">    RSExtSmartPtr&lt;ShimProcess&gt; <span>pShim</span>(m_pShim);</td>
      </tr>
      <tr>
        <td id="L4605" data-line-number="4605"></td>
        <td id="LC4605">
</td>
      </tr>
      <tr>
        <td id="L4606" data-line-number="4606"></td>
        <td id="LC4606">    <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L4607" data-line-number="4607"></td>
        <td id="LC4607">
</td>
      </tr>
      <tr>
        <td id="L4608" data-line-number="4608"></td>
        <td id="LC4608">    <span>_ASSERTE</span>(!<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L4609" data-line-number="4609"></td>
        <td id="LC4609">
</td>
      </tr>
      <tr>
        <td id="L4610" data-line-number="4610"></td>
        <td id="LC4610">
</td>
      </tr>
      <tr>
        <td id="L4611" data-line-number="4611"></td>
        <td id="LC4611">    <span><span>//</span> We want to stay synced until after the callbacks return. This is b/c we're on the RCET,</span></td>
      </tr>
      <tr>
        <td id="L4612" data-line-number="4612"></td>
        <td id="LC4612">    <span><span>//</span> and we may deadlock if we send IPC events on the RCET if we're not synced (see SendIPCEvent for details).</span></td>
      </tr>
      <tr>
        <td id="L4613" data-line-number="4613"></td>
        <td id="LC4613">    <span><span>//</span> So here, stopcount=1. The StopContinueHolder bumps it up to 2.</span></td>
      </tr>
      <tr>
        <td id="L4614" data-line-number="4614"></td>
        <td id="LC4614">    <span><span>//</span> - If Cordbg calls continue in the callback, that bumps it back down to 1, but doesn't actually continue.</span></td>
      </tr>
      <tr>
        <td id="L4615" data-line-number="4615"></td>
        <td id="LC4615">    <span><span>//</span>   The holder dtor then bumps it down to 0, doing the real continue.</span></td>
      </tr>
      <tr>
        <td id="L4616" data-line-number="4616"></td>
        <td id="LC4616">    <span><span>//</span> - If Cordbg doesn't call continue in the callback, then stopcount stays at 2, holder dtor drops it down to 1,</span></td>
      </tr>
      <tr>
        <td id="L4617" data-line-number="4617"></td>
        <td id="LC4617">    <span><span>//</span>   and then the holder was just a nop.</span></td>
      </tr>
      <tr>
        <td id="L4618" data-line-number="4618"></td>
        <td id="LC4618">    <span><span>//</span> This gives us delayed continues w/ no extra state flags.</span></td>
      </tr>
      <tr>
        <td id="L4619" data-line-number="4619"></td>
        <td id="LC4619">
</td>
      </tr>
      <tr>
        <td id="L4620" data-line-number="4620"></td>
        <td id="LC4620">
</td>
      </tr>
      <tr>
        <td id="L4621" data-line-number="4621"></td>
        <td id="LC4621">    <span><span>//</span> The debugger may call Detach() immediately after it returns from the callback, but before this thread returns</span></td>
      </tr>
      <tr>
        <td id="L4622" data-line-number="4622"></td>
        <td id="LC4622">    <span><span>//</span> from this function.  Thus after we execute the callbacks, it's possible the CordbProcess object has been neutered.</span></td>
      </tr>
      <tr>
        <td id="L4623" data-line-number="4623"></td>
        <td id="LC4623">
</td>
      </tr>
      <tr>
        <td id="L4624" data-line-number="4624"></td>
        <td id="LC4624">    <span><span>//</span> Since we're already sycned, the Stop from the holder here is practically a nop that just bumps up a count.</span></td>
      </tr>
      <tr>
        <td id="L4625" data-line-number="4625"></td>
        <td id="LC4625">    <span><span>//</span> Create an extra scope for the StopContinueHolder.</span></td>
      </tr>
      <tr>
        <td id="L4626" data-line-number="4626"></td>
        <td id="LC4626">    {</td>
      </tr>
      <tr>
        <td id="L4627" data-line-number="4627"></td>
        <td id="LC4627">        StopContinueHolder h;</td>
      </tr>
      <tr>
        <td id="L4628" data-line-number="4628"></td>
        <td id="LC4628">        HRESULT hr = h.<span>Init</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4629" data-line-number="4629"></td>
        <td id="LC4629">        <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L4630" data-line-number="4630"></td>
        <td id="LC4630">        {</td>
      </tr>
      <tr>
        <td id="L4631" data-line-number="4631"></td>
        <td id="LC4631">            <span>CORDBSetUnrecoverableError</span>(<span>this</span>, hr, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L4632" data-line-number="4632"></td>
        <td id="LC4632">        }</td>
      </tr>
      <tr>
        <td id="L4633" data-line-number="4633"></td>
        <td id="LC4633">
</td>
      </tr>
      <tr>
        <td id="L4634" data-line-number="4634"></td>
        <td id="LC4634">        HRESULT hrCallback = S_OK;</td>
      </tr>
      <tr>
        <td id="L4635" data-line-number="4635"></td>
        <td id="LC4635">        <span><span>//</span> It's possible a ICorDebugProcess::Detach() may have occurred by now.</span></td>
      </tr>
      <tr>
        <td id="L4636" data-line-number="4636"></td>
        <td id="LC4636">        {</td>
      </tr>
      <tr>
        <td id="L4637" data-line-number="4637"></td>
        <td id="LC4637">            <span><span>//</span> @dbgtodo shim: eventually the entire RCET should be considered outside the RS.</span></td>
      </tr>
      <tr>
        <td id="L4638" data-line-number="4638"></td>
        <td id="LC4638">            <span>PUBLIC_CALLBACK_IN_THIS_SCOPE0_NO_LOCK</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4639" data-line-number="4639"></td>
        <td id="LC4639">
</td>
      </tr>
      <tr>
        <td id="L4640" data-line-number="4640"></td>
        <td id="LC4640">
</td>
      </tr>
      <tr>
        <td id="L4641" data-line-number="4641"></td>
        <td id="LC4641">            <span><span>//</span> Snag the first event off the queue.</span></td>
      </tr>
      <tr>
        <td id="L4642" data-line-number="4642"></td>
        <td id="LC4642">            <span><span>//</span> Holder will call Delete, which will invoke virtual Dtor that will release ICD objects.</span></td>
      </tr>
      <tr>
        <td id="L4643" data-line-number="4643"></td>
        <td id="LC4643">            <span><span>//</span> Since these are external refs, we want to do it while "outside" the RS.</span></td>
      </tr>
      <tr>
        <td id="L4644" data-line-number="4644"></td>
        <td id="LC4644">            NewHolder&lt;ManagedEvent&gt; <span>pEvent</span>(pShim-&gt;<span>DequeueManagedEvent</span>());</td>
      </tr>
      <tr>
        <td id="L4645" data-line-number="4645"></td>
        <td id="LC4645">
</td>
      </tr>
      <tr>
        <td id="L4646" data-line-number="4646"></td>
        <td id="LC4646">            <span><span>//</span> Normally pEvent shouldn't be NULL, since this method is called when the queue is not empty.</span></td>
      </tr>
      <tr>
        <td id="L4647" data-line-number="4647"></td>
        <td id="LC4647">            <span><span>//</span> But due to a race between CordbProcess::Terminate(), CordbWin32EventThread::ExitProcess() and this method</span></td>
      </tr>
      <tr>
        <td id="L4648" data-line-number="4648"></td>
        <td id="LC4648">            <span><span>//</span> it is totally possible that the queue has already been cleaned up and we can't expect that event is always available.</span></td>
      </tr>
      <tr>
        <td id="L4649" data-line-number="4649"></td>
        <td id="LC4649">            <span>if</span> (pEvent != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L4650" data-line-number="4650"></td>
        <td id="LC4650">            {</td>
      </tr>
      <tr>
        <td id="L4651" data-line-number="4651"></td>
        <td id="LC4651">                <span><span>//</span> Since we need to access a member (m_cordb), protect this block with a</span></td>
      </tr>
      <tr>
        <td id="L4652" data-line-number="4652"></td>
        <td id="LC4652">                <span><span>//</span> lock and a check for Neutering (in case process detach has just</span></td>
      </tr>
      <tr>
        <td id="L4653" data-line-number="4653"></td>
        <td id="LC4653">                <span><span>//</span> occurred).  We'll release the lock around the dispatch later on.</span></td>
      </tr>
      <tr>
        <td id="L4654" data-line-number="4654"></td>
        <td id="LC4654">                RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L4655" data-line-number="4655"></td>
        <td id="LC4655">                <span>if</span> (!<span>IsNeutered</span>())</td>
      </tr>
      <tr>
        <td id="L4656" data-line-number="4656"></td>
        <td id="LC4656">                {</td>
      </tr>
      <tr>
        <td id="L4657" data-line-number="4657"></td>
        <td id="LC4657">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L4658" data-line-number="4658"></td>
        <td id="LC4658">                    <span><span>//</span> On a debug build, keep track of the last IPC event we dispatched.</span></td>
      </tr>
      <tr>
        <td id="L4659" data-line-number="4659"></td>
        <td id="LC4659">                    m_pDBGLastIPCEventType = pEvent-&gt;<span>GetDebugCookie</span>();</td>
      </tr>
      <tr>
        <td id="L4660" data-line-number="4660"></td>
        <td id="LC4660">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4661" data-line-number="4661"></td>
        <td id="LC4661">
</td>
      </tr>
      <tr>
        <td id="L4662" data-line-number="4662"></td>
        <td id="LC4662">                    ManagedEvent::DispatchArgs <span>args</span>(m_cordb-&gt;<span>m_managedCallback</span>, m_cordb-&gt;<span>m_managedCallback2</span>, m_cordb-&gt;<span>m_managedCallback3</span>, m_cordb-&gt;<span>m_managedCallback4</span>);</td>
      </tr>
      <tr>
        <td id="L4663" data-line-number="4663"></td>
        <td id="LC4663">
</td>
      </tr>
      <tr>
        <td id="L4664" data-line-number="4664"></td>
        <td id="LC4664">                    {</td>
      </tr>
      <tr>
        <td id="L4665" data-line-number="4665"></td>
        <td id="LC4665">                        <span><span>//</span> Release lock around the dispatch of the event</span></td>
      </tr>
      <tr>
        <td id="L4666" data-line-number="4666"></td>
        <td id="LC4666">                        RSInverseLockHolder <span>inverseLockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L4667" data-line-number="4667"></td>
        <td id="LC4667">
</td>
      </tr>
      <tr>
        <td id="L4668" data-line-number="4668"></td>
        <td id="LC4668">                        EX_TRY</td>
      </tr>
      <tr>
        <td id="L4669" data-line-number="4669"></td>
        <td id="LC4669">                        {</td>
      </tr>
      <tr>
        <td id="L4670" data-line-number="4670"></td>
        <td id="LC4670">                            <span><span>//</span> This dispatches almost directly into the user's callbacks.</span></td>
      </tr>
      <tr>
        <td id="L4671" data-line-number="4671"></td>
        <td id="LC4671">                            <span><span>//</span> It does not update any RS state.</span></td>
      </tr>
      <tr>
        <td id="L4672" data-line-number="4672"></td>
        <td id="LC4672">                            hrCallback = pEvent-&gt;<span>Dispatch</span>(args);</td>
      </tr>
      <tr>
        <td id="L4673" data-line-number="4673"></td>
        <td id="LC4673">                        }</td>
      </tr>
      <tr>
        <td id="L4674" data-line-number="4674"></td>
        <td id="LC4674">                        <span>EX_CATCH_HRESULT</span>(hrCallback);</td>
      </tr>
      <tr>
        <td id="L4675" data-line-number="4675"></td>
        <td id="LC4675">                    }</td>
      </tr>
      <tr>
        <td id="L4676" data-line-number="4676"></td>
        <td id="LC4676">                }</td>
      </tr>
      <tr>
        <td id="L4677" data-line-number="4677"></td>
        <td id="LC4677">            }</td>
      </tr>
      <tr>
        <td id="L4678" data-line-number="4678"></td>
        <td id="LC4678">
</td>
      </tr>
      <tr>
        <td id="L4679" data-line-number="4679"></td>
        <td id="LC4679">        } <span><span>//</span> we're now back inside the RS</span></td>
      </tr>
      <tr>
        <td id="L4680" data-line-number="4680"></td>
        <td id="LC4680">
</td>
      </tr>
      <tr>
        <td id="L4681" data-line-number="4681"></td>
        <td id="LC4681">        <span>if</span> (hrCallback == E_NOTIMPL)</td>
      </tr>
      <tr>
        <td id="L4682" data-line-number="4682"></td>
        <td id="LC4682">        {</td>
      </tr>
      <tr>
        <td id="L4683" data-line-number="4683"></td>
        <td id="LC4683">            <span>ContinueInternal</span>(<span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L4684" data-line-number="4684"></td>
        <td id="LC4684">        }</td>
      </tr>
      <tr>
        <td id="L4685" data-line-number="4685"></td>
        <td id="LC4685">
</td>
      </tr>
      <tr>
        <td id="L4686" data-line-number="4686"></td>
        <td id="LC4686">
</td>
      </tr>
      <tr>
        <td id="L4687" data-line-number="4687"></td>
        <td id="LC4687">    } <span><span>//</span> forces Continue to be called</span></td>
      </tr>
      <tr>
        <td id="L4688" data-line-number="4688"></td>
        <td id="LC4688">
</td>
      </tr>
      <tr>
        <td id="L4689" data-line-number="4689"></td>
        <td id="LC4689">    <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L4690" data-line-number="4690"></td>
        <td id="LC4690">
</td>
      </tr>
      <tr>
        <td id="L4691" data-line-number="4691"></td>
        <td id="LC4691">};</td>
      </tr>
      <tr>
        <td id="L4692" data-line-number="4692"></td>
        <td id="LC4692">
</td>
      </tr>
      <tr>
        <td id="L4693" data-line-number="4693"></td>
        <td id="LC4693">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L4694" data-line-number="4694"></td>
        <td id="LC4694"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4695" data-line-number="4695"></td>
        <td id="LC4695"><span><span>//</span> Debug-only callback to ensure that an appdomain is not available after the ExitAppDomain event.</span></td>
      </tr>
      <tr>
        <td id="L4696" data-line-number="4696"></td>
        <td id="LC4696"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4697" data-line-number="4697"></td>
        <td id="LC4697"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4698" data-line-number="4698"></td>
        <td id="LC4698"><span><span>//</span>    vmAppDomain - appdomain from enumeration</span></td>
      </tr>
      <tr>
        <td id="L4699" data-line-number="4699"></td>
        <td id="LC4699"><span><span>//</span>    pUserData - pointer to a DbgAssertAppDomainDeletedData which contains the VMAppDomain that was just deleted.</span></td>
      </tr>
      <tr>
        <td id="L4700" data-line-number="4700"></td>
        <td id="LC4700"><span><span>//</span> notes:</span></td>
      </tr>
      <tr>
        <td id="L4701" data-line-number="4701"></td>
        <td id="LC4701"><span><span>//</span>    see code:CordbProcess::DbgAssertAppDomainDeleted for details.</span></td>
      </tr>
      <tr>
        <td id="L4702" data-line-number="4702"></td>
        <td id="LC4702"><span>void</span> <span>CordbProcess::DbgAssertAppDomainDeletedCallback</span>(VMPTR_AppDomain vmAppDomain, <span>void</span> * pUserData)</td>
      </tr>
      <tr>
        <td id="L4703" data-line-number="4703"></td>
        <td id="LC4703">{</td>
      </tr>
      <tr>
        <td id="L4704" data-line-number="4704"></td>
        <td id="LC4704">    DbgAssertAppDomainDeletedData * pCallbackData = <span>reinterpret_cast</span>&lt;DbgAssertAppDomainDeletedData *&gt;(pUserData);</td>
      </tr>
      <tr>
        <td id="L4705" data-line-number="4705"></td>
        <td id="LC4705">    <span>INTERNAL_DAC_CALLBACK</span>(pCallbackData-&gt;<span>m_pThis</span>);</td>
      </tr>
      <tr>
        <td id="L4706" data-line-number="4706"></td>
        <td id="LC4706">
</td>
      </tr>
      <tr>
        <td id="L4707" data-line-number="4707"></td>
        <td id="LC4707">    VMPTR_AppDomain vmAppDomainDeleted = pCallbackData-&gt;<span>m_vmAppDomainDeleted</span>;</td>
      </tr>
      <tr>
        <td id="L4708" data-line-number="4708"></td>
        <td id="LC4708">    <span>CONSISTENCY_CHECK_MSGF</span>((vmAppDomain != vmAppDomainDeleted),</td>
      </tr>
      <tr>
        <td id="L4709" data-line-number="4709"></td>
        <td id="LC4709">        (<span><span>"</span>An ExitAppDomain event was sent for appdomain, but it still shows up in the enumeration.<span>\n</span> vmAppDomain=%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L4710" data-line-number="4710"></td>
        <td id="LC4710">        <span>VmPtrToCookie</span>(vmAppDomainDeleted)));</td>
      </tr>
      <tr>
        <td id="L4711" data-line-number="4711"></td>
        <td id="LC4711">}</td>
      </tr>
      <tr>
        <td id="L4712" data-line-number="4712"></td>
        <td id="LC4712">
</td>
      </tr>
      <tr>
        <td id="L4713" data-line-number="4713"></td>
        <td id="LC4713"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4714" data-line-number="4714"></td>
        <td id="LC4714"><span><span>//</span> Debug-only helper to Assert that VMPTR is actually removed.</span></td>
      </tr>
      <tr>
        <td id="L4715" data-line-number="4715"></td>
        <td id="LC4715"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4716" data-line-number="4716"></td>
        <td id="LC4716"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4717" data-line-number="4717"></td>
        <td id="LC4717"><span><span>//</span>    vmAppDomainDeleted - vmptr of appdomain that we just got exit event for.</span></td>
      </tr>
      <tr>
        <td id="L4718" data-line-number="4718"></td>
        <td id="LC4718"><span><span>//</span>       This should not be discoverable from the RS.</span></td>
      </tr>
      <tr>
        <td id="L4719" data-line-number="4719"></td>
        <td id="LC4719"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4720" data-line-number="4720"></td>
        <td id="LC4720"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L4721" data-line-number="4721"></td>
        <td id="LC4721"><span><span>//</span>   See code:IDacDbiInterface#Enumeration for rules that we're asserting.</span></td>
      </tr>
      <tr>
        <td id="L4722" data-line-number="4722"></td>
        <td id="LC4722"><span><span>//</span>   Once the exit appdomain event is dispatched, the appdomain should not be discoverable by the RS.</span></td>
      </tr>
      <tr>
        <td id="L4723" data-line-number="4723"></td>
        <td id="LC4723"><span><span>//</span>   Else the RS may use the AppDomain* after it's deleted.</span></td>
      </tr>
      <tr>
        <td id="L4724" data-line-number="4724"></td>
        <td id="LC4724"><span><span>//</span>   This asserts that the AppDomain* is not discoverable.</span></td>
      </tr>
      <tr>
        <td id="L4725" data-line-number="4725"></td>
        <td id="LC4725"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4726" data-line-number="4726"></td>
        <td id="LC4726"><span><span>//</span>   Since this is a debug-only function, it should have no side-effects.</span></td>
      </tr>
      <tr>
        <td id="L4727" data-line-number="4727"></td>
        <td id="LC4727"><span>void</span> <span>CordbProcess::DbgAssertAppDomainDeleted</span>(VMPTR_AppDomain vmAppDomainDeleted)</td>
      </tr>
      <tr>
        <td id="L4728" data-line-number="4728"></td>
        <td id="LC4728">{</td>
      </tr>
      <tr>
        <td id="L4729" data-line-number="4729"></td>
        <td id="LC4729">    DbgAssertAppDomainDeletedData callbackData;</td>
      </tr>
      <tr>
        <td id="L4730" data-line-number="4730"></td>
        <td id="LC4730">    callbackData.<span>m_pThis</span> = <span>this</span>;</td>
      </tr>
      <tr>
        <td id="L4731" data-line-number="4731"></td>
        <td id="LC4731">    callbackData.<span>m_vmAppDomainDeleted</span> = vmAppDomainDeleted;</td>
      </tr>
      <tr>
        <td id="L4732" data-line-number="4732"></td>
        <td id="LC4732">
</td>
      </tr>
      <tr>
        <td id="L4733" data-line-number="4733"></td>
        <td id="LC4733">    <span>GetDAC</span>()-&gt;<span>EnumerateAppDomains</span>(</td>
      </tr>
      <tr>
        <td id="L4734" data-line-number="4734"></td>
        <td id="LC4734">        CordbProcess::DbgAssertAppDomainDeletedCallback,</td>
      </tr>
      <tr>
        <td id="L4735" data-line-number="4735"></td>
        <td id="LC4735">        &amp;callbackData);</td>
      </tr>
      <tr>
        <td id="L4736" data-line-number="4736"></td>
        <td id="LC4736">}</td>
      </tr>
      <tr>
        <td id="L4737" data-line-number="4737"></td>
        <td id="LC4737">
</td>
      </tr>
      <tr>
        <td id="L4738" data-line-number="4738"></td>
        <td id="LC4738">#<span>endif</span>  <span><span>//</span> _DEBUG</span></td>
      </tr>
      <tr>
        <td id="L4739" data-line-number="4739"></td>
        <td id="LC4739">
</td>
      </tr>
      <tr>
        <td id="L4740" data-line-number="4740"></td>
        <td id="LC4740"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4741" data-line-number="4741"></td>
        <td id="LC4741"><span><span>//</span> Update state and potentially Dispatch a single event.</span></td>
      </tr>
      <tr>
        <td id="L4742" data-line-number="4742"></td>
        <td id="LC4742"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4743" data-line-number="4743"></td>
        <td id="LC4743"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L4744" data-line-number="4744"></td>
        <td id="LC4744"><span><span>//</span>    pEvent - non-null pointer to debug event.</span></td>
      </tr>
      <tr>
        <td id="L4745" data-line-number="4745"></td>
        <td id="LC4745"><span><span>//</span>    pCallback1 - callback object to dispatch on (for V1 callbacks)</span></td>
      </tr>
      <tr>
        <td id="L4746" data-line-number="4746"></td>
        <td id="LC4746"><span><span>//</span>    pCallback2 - 2nd callback object to dispatch on (for new V2 callbacks)</span></td>
      </tr>
      <tr>
        <td id="L4747" data-line-number="4747"></td>
        <td id="LC4747"><span><span>//</span>    pCallback3 - 3rd callback object to dispatch on (for new V4 callbacks)</span></td>
      </tr>
      <tr>
        <td id="L4748" data-line-number="4748"></td>
        <td id="LC4748"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4749" data-line-number="4749"></td>
        <td id="LC4749"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4750" data-line-number="4750"></td>
        <td id="LC4750"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L4751" data-line-number="4751"></td>
        <td id="LC4751"><span><span>//</span>    Nothing. Throws on error.</span></td>
      </tr>
      <tr>
        <td id="L4752" data-line-number="4752"></td>
        <td id="LC4752"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4753" data-line-number="4753"></td>
        <td id="LC4753"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L4754" data-line-number="4754"></td>
        <td id="LC4754"><span><span>//</span>    Generally, this will dispatch exactly 1 callback. It may dispatch 0 callbacks if there is an error</span></td>
      </tr>
      <tr>
        <td id="L4755" data-line-number="4755"></td>
        <td id="LC4755"><span><span>//</span>    or in other corner cases (documented within the dispatch code below).</span></td>
      </tr>
      <tr>
        <td id="L4756" data-line-number="4756"></td>
        <td id="LC4756"><span><span>//</span>    Errors could occur because:</span></td>
      </tr>
      <tr>
        <td id="L4757" data-line-number="4757"></td>
        <td id="LC4757"><span><span>//</span>    - the event is corrupted (exceptional case)</span></td>
      </tr>
      <tr>
        <td id="L4758" data-line-number="4758"></td>
        <td id="LC4758"><span><span>//</span>    - the RS is corrupted / OOM (exceptional case)</span></td>
      </tr>
      <tr>
        <td id="L4759" data-line-number="4759"></td>
        <td id="LC4759"><span><span>//</span>    Exception errors here will propogate back to the Filter() call, and there's not really anything</span></td>
      </tr>
      <tr>
        <td id="L4760" data-line-number="4760"></td>
        <td id="LC4760"><span><span>//</span>    a debugger can do about an error here (perhaps report it to the user).</span></td>
      </tr>
      <tr>
        <td id="L4761" data-line-number="4761"></td>
        <td id="LC4761"><span><span>//</span>    Errors must leave IcorDebug in a consistent state.</span></td>
      </tr>
      <tr>
        <td id="L4762" data-line-number="4762"></td>
        <td id="LC4762"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4763" data-line-number="4763"></td>
        <td id="LC4763"><span><span>//</span>    This is dispatched directly on the Win32Event Thread in response to calling Filter.</span></td>
      </tr>
      <tr>
        <td id="L4764" data-line-number="4764"></td>
        <td id="LC4764"><span><span>//</span>    Therefore, this can't send any IPC events (Not an issue once everything is DAC-ized).</span></td>
      </tr>
      <tr>
        <td id="L4765" data-line-number="4765"></td>
        <td id="LC4765"><span><span>//</span>    A V2 shim can provide a proxy calllack that takes these events and queues them and</span></td>
      </tr>
      <tr>
        <td id="L4766" data-line-number="4766"></td>
        <td id="LC4766"><span><span>//</span>    does the real dispatch to the user to emulate V2 semantics.</span></td>
      </tr>
      <tr>
        <td id="L4767" data-line-number="4767"></td>
        <td id="LC4767"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4768" data-line-number="4768"></td>
        <td id="LC4768">#<span>ifdef</span> _PREFAST_</td>
      </tr>
      <tr>
        <td id="L4769" data-line-number="4769"></td>
        <td id="LC4769">#<span>pragma</span> warning(push)</td>
      </tr>
      <tr>
        <td id="L4770" data-line-number="4770"></td>
        <td id="LC4770">#<span>pragma</span> warning(disable:21000) <span><span>//</span> Suppress PREFast warning about overly large function</span></td>
      </tr>
      <tr>
        <td id="L4771" data-line-number="4771"></td>
        <td id="LC4771">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4772" data-line-number="4772"></td>
        <td id="LC4772"><span>void</span> <span>CordbProcess::RawDispatchEvent</span>(</td>
      </tr>
      <tr>
        <td id="L4773" data-line-number="4773"></td>
        <td id="LC4773">    DebuggerIPCEvent *          pEvent,</td>
      </tr>
      <tr>
        <td id="L4774" data-line-number="4774"></td>
        <td id="LC4774">    RSLockHolder *              pLockHolder,</td>
      </tr>
      <tr>
        <td id="L4775" data-line-number="4775"></td>
        <td id="LC4775">    ICorDebugManagedCallback *  pCallback1,</td>
      </tr>
      <tr>
        <td id="L4776" data-line-number="4776"></td>
        <td id="LC4776">    ICorDebugManagedCallback2 * pCallback2,</td>
      </tr>
      <tr>
        <td id="L4777" data-line-number="4777"></td>
        <td id="LC4777">    ICorDebugManagedCallback3 * pCallback3,</td>
      </tr>
      <tr>
        <td id="L4778" data-line-number="4778"></td>
        <td id="LC4778">    ICorDebugManagedCallback4 * pCallback4)</td>
      </tr>
      <tr>
        <td id="L4779" data-line-number="4779"></td>
        <td id="LC4779">{</td>
      </tr>
      <tr>
        <td id="L4780" data-line-number="4780"></td>
        <td id="LC4780">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L4781" data-line-number="4781"></td>
        <td id="LC4781">    {</td>
      </tr>
      <tr>
        <td id="L4782" data-line-number="4782"></td>
        <td id="LC4782">        THROWS;</td>
      </tr>
      <tr>
        <td id="L4783" data-line-number="4783"></td>
        <td id="LC4783">    }</td>
      </tr>
      <tr>
        <td id="L4784" data-line-number="4784"></td>
        <td id="LC4784">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L4785" data-line-number="4785"></td>
        <td id="LC4785">
</td>
      </tr>
      <tr>
        <td id="L4786" data-line-number="4786"></td>
        <td id="LC4786">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L4787" data-line-number="4787"></td>
        <td id="LC4787">    <span><span>//</span> We start off with the lock, and we'll toggle it.</span></td>
      </tr>
      <tr>
        <td id="L4788" data-line-number="4788"></td>
        <td id="LC4788">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L4789" data-line-number="4789"></td>
        <td id="LC4789">
</td>
      </tr>
      <tr>
        <td id="L4790" data-line-number="4790"></td>
        <td id="LC4790">
</td>
      </tr>
      <tr>
        <td id="L4791" data-line-number="4791"></td>
        <td id="LC4791">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4792" data-line-number="4792"></td>
        <td id="LC4792">    <span><span>//</span> Call StartEventDispatch to true to guard against calls to Continue()</span></td>
      </tr>
      <tr>
        <td id="L4793" data-line-number="4793"></td>
        <td id="LC4793">    <span><span>//</span> from within the user's callback. We need Continue() to behave a little</span></td>
      </tr>
      <tr>
        <td id="L4794" data-line-number="4794"></td>
        <td id="LC4794">    <span><span>//</span> bit differently in such a case.</span></td>
      </tr>
      <tr>
        <td id="L4795" data-line-number="4795"></td>
        <td id="LC4795">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4796" data-line-number="4796"></td>
        <td id="LC4796">    <span><span>//</span> Also note that Win32EventThread::ExitProcess will take the lock and free all</span></td>
      </tr>
      <tr>
        <td id="L4797" data-line-number="4797"></td>
        <td id="LC4797">    <span><span>//</span> events in the queue. (the current event is already off the queue, so</span></td>
      </tr>
      <tr>
        <td id="L4798" data-line-number="4798"></td>
        <td id="LC4798">    <span><span>//</span> it will be ok). But we can't do the EP callback in the middle of this dispatch</span></td>
      </tr>
      <tr>
        <td id="L4799" data-line-number="4799"></td>
        <td id="LC4799">    <span><span>//</span> so if this flag is set, EP will wait on the miscWaitEvent (which will</span></td>
      </tr>
      <tr>
        <td id="L4800" data-line-number="4800"></td>
        <td id="LC4800">    <span><span>//</span> get set in FlushQueuedEvents when we return from here) and let us finish here.</span></td>
      </tr>
      <tr>
        <td id="L4801" data-line-number="4801"></td>
        <td id="LC4801">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4802" data-line-number="4802"></td>
        <td id="LC4802">    <span>StartEventDispatch</span>(pEvent-&gt;<span>type</span>);</td>
      </tr>
      <tr>
        <td id="L4803" data-line-number="4803"></td>
        <td id="LC4803">
</td>
      </tr>
      <tr>
        <td id="L4804" data-line-number="4804"></td>
        <td id="LC4804">    <span><span>//</span> Keep strong references to these objects in case a callback deletes them from underneath us.</span></td>
      </tr>
      <tr>
        <td id="L4805" data-line-number="4805"></td>
        <td id="LC4805">    RSSmartPtr&lt;CordbAppDomain&gt; pAppDomain;</td>
      </tr>
      <tr>
        <td id="L4806" data-line-number="4806"></td>
        <td id="LC4806">    CordbThread * pThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L4807" data-line-number="4807"></td>
        <td id="LC4807">
</td>
      </tr>
      <tr>
        <td id="L4808" data-line-number="4808"></td>
        <td id="LC4808">
</td>
      </tr>
      <tr>
        <td id="L4809" data-line-number="4809"></td>
        <td id="LC4809">    <span><span>//</span> Get thread that this event is on. In attach scenarios, this may be the first time ICorDebug has seen this thread.</span></td>
      </tr>
      <tr>
        <td id="L4810" data-line-number="4810"></td>
        <td id="LC4810">    <span>if</span> (!pEvent-&gt;<span>vmThread</span>.<span>IsNull</span>())</td>
      </tr>
      <tr>
        <td id="L4811" data-line-number="4811"></td>
        <td id="LC4811">    {</td>
      </tr>
      <tr>
        <td id="L4812" data-line-number="4812"></td>
        <td id="LC4812">        pThread = <span>LookupOrCreateThread</span>(pEvent-&gt;<span>vmThread</span>);</td>
      </tr>
      <tr>
        <td id="L4813" data-line-number="4813"></td>
        <td id="LC4813">    }</td>
      </tr>
      <tr>
        <td id="L4814" data-line-number="4814"></td>
        <td id="LC4814">
</td>
      </tr>
      <tr>
        <td id="L4815" data-line-number="4815"></td>
        <td id="LC4815">    <span>if</span> (!pEvent-&gt;<span>vmAppDomain</span>.<span>IsNull</span>())</td>
      </tr>
      <tr>
        <td id="L4816" data-line-number="4816"></td>
        <td id="LC4816">    {</td>
      </tr>
      <tr>
        <td id="L4817" data-line-number="4817"></td>
        <td id="LC4817">        pAppDomain.<span>Assign</span>(<span>LookupOrCreateAppDomain</span>(pEvent-&gt;<span>vmAppDomain</span>));</td>
      </tr>
      <tr>
        <td id="L4818" data-line-number="4818"></td>
        <td id="LC4818">    }</td>
      </tr>
      <tr>
        <td id="L4819" data-line-number="4819"></td>
        <td id="LC4819">
</td>
      </tr>
      <tr>
        <td id="L4820" data-line-number="4820"></td>
        <td id="LC4820">    DWORD dwVolatileThreadId = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4821" data-line-number="4821"></td>
        <td id="LC4821">    <span>if</span> (pThread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L4822" data-line-number="4822"></td>
        <td id="LC4822">    {</td>
      </tr>
      <tr>
        <td id="L4823" data-line-number="4823"></td>
        <td id="LC4823">        dwVolatileThreadId = pThread-&gt;<span>GetUniqueId</span>();</td>
      </tr>
      <tr>
        <td id="L4824" data-line-number="4824"></td>
        <td id="LC4824">    }</td>
      </tr>
      <tr>
        <td id="L4825" data-line-number="4825"></td>
        <td id="LC4825">
</td>
      </tr>
      <tr>
        <td id="L4826" data-line-number="4826"></td>
        <td id="LC4826">
</td>
      </tr>
      <tr>
        <td id="L4827" data-line-number="4827"></td>
        <td id="LC4827">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4828" data-line-number="4828"></td>
        <td id="LC4828">    <span><span>//</span> Update the app domain that this thread lives in.</span></td>
      </tr>
      <tr>
        <td id="L4829" data-line-number="4829"></td>
        <td id="LC4829">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4830" data-line-number="4830"></td>
        <td id="LC4830">    <span>if</span> ((pThread != <span>NULL</span>) &amp;&amp; (pAppDomain != <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L4831" data-line-number="4831"></td>
        <td id="LC4831">    {</td>
      </tr>
      <tr>
        <td id="L4832" data-line-number="4832"></td>
        <td id="LC4832">        <span><span>//</span> It shouldn't be possible for us to see an exited AppDomain here</span></td>
      </tr>
      <tr>
        <td id="L4833" data-line-number="4833"></td>
        <td id="LC4833">        <span>_ASSERTE</span>( !pAppDomain-&gt;<span>IsNeutered</span>() );</td>
      </tr>
      <tr>
        <td id="L4834" data-line-number="4834"></td>
        <td id="LC4834">
</td>
      </tr>
      <tr>
        <td id="L4835" data-line-number="4835"></td>
        <td id="LC4835">         pThread-&gt;<span>m_pAppDomain</span> = pAppDomain;</td>
      </tr>
      <tr>
        <td id="L4836" data-line-number="4836"></td>
        <td id="LC4836">    }</td>
      </tr>
      <tr>
        <td id="L4837" data-line-number="4837"></td>
        <td id="LC4837">
</td>
      </tr>
      <tr>
        <td id="L4838" data-line-number="4838"></td>
        <td id="LC4838">    <span>_ASSERTE</span>(pEvent != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4839" data-line-number="4839"></td>
        <td id="LC4839">    <span>_ASSERTE</span>(pCallback1 != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4840" data-line-number="4840"></td>
        <td id="LC4840">    <span>_ASSERTE</span>(pCallback2 != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4841" data-line-number="4841"></td>
        <td id="LC4841">    <span>_ASSERTE</span>(pCallback3 != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4842" data-line-number="4842"></td>
        <td id="LC4842">    <span>_ASSERTE</span>(pCallback4 != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4843" data-line-number="4843"></td>
        <td id="LC4843">
</td>
      </tr>
      <tr>
        <td id="L4844" data-line-number="4844"></td>
        <td id="LC4844">    <span>STRESS_LOG1</span>(LF_CORDB, LL_EVERYTHING, <span><span>"</span>Pre-Dispatch IPC event: %s<span>\n</span><span>"</span></span>, <span>IPCENames::GetName</span>(pEvent-&gt;<span>type</span>));</td>
      </tr>
      <tr>
        <td id="L4845" data-line-number="4845"></td>
        <td id="LC4845">
</td>
      </tr>
      <tr>
        <td id="L4846" data-line-number="4846"></td>
        <td id="LC4846">    <span>switch</span> (pEvent-&gt;<span>type</span> &amp; DB_IPCE_TYPE_MASK)</td>
      </tr>
      <tr>
        <td id="L4847" data-line-number="4847"></td>
        <td id="LC4847">    {</td>
      </tr>
      <tr>
        <td id="L4848" data-line-number="4848"></td>
        <td id="LC4848">    <span>case</span> DB_IPCE_CREATE_PROCESS:</td>
      </tr>
      <tr>
        <td id="L4849" data-line-number="4849"></td>
        <td id="LC4849">        {</td>
      </tr>
      <tr>
        <td id="L4850" data-line-number="4850"></td>
        <td id="LC4850">            <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L4851" data-line-number="4851"></td>
        <td id="LC4851">            pCallback1-&gt;<span>CreateProcess</span>(<span>static_cast</span>&lt;ICorDebugProcess*&gt; (<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L4852" data-line-number="4852"></td>
        <td id="LC4852">        }</td>
      </tr>
      <tr>
        <td id="L4853" data-line-number="4853"></td>
        <td id="LC4853">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4854" data-line-number="4854"></td>
        <td id="LC4854">
</td>
      </tr>
      <tr>
        <td id="L4855" data-line-number="4855"></td>
        <td id="LC4855">    <span>case</span> DB_IPCE_BREAKPOINT:</td>
      </tr>
      <tr>
        <td id="L4856" data-line-number="4856"></td>
        <td id="LC4856">        {</td>
      </tr>
      <tr>
        <td id="L4857" data-line-number="4857"></td>
        <td id="LC4857">            <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4858" data-line-number="4858"></td>
        <td id="LC4858">            <span>_ASSERTE</span>(pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4859" data-line-number="4859"></td>
        <td id="LC4859">
</td>
      </tr>
      <tr>
        <td id="L4860" data-line-number="4860"></td>
        <td id="LC4860">            <span><span>//</span> Find the breakpoint object on this side.</span></td>
      </tr>
      <tr>
        <td id="L4861" data-line-number="4861"></td>
        <td id="LC4861">            CordbBreakpoint *pBreakpoint = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L4862" data-line-number="4862"></td>
        <td id="LC4862">
</td>
      </tr>
      <tr>
        <td id="L4863" data-line-number="4863"></td>
        <td id="LC4863">            <span><span>//</span> We've found cases out in the wild where we get this event on a thread we don't recognize.</span></td>
      </tr>
      <tr>
        <td id="L4864" data-line-number="4864"></td>
        <td id="LC4864">            <span><span>//</span> We're not sure how this happens. Add a runtime check to protect ourselves to avoid the</span></td>
      </tr>
      <tr>
        <td id="L4865" data-line-number="4865"></td>
        <td id="LC4865">            <span><span>//</span> an AV. We still assert because this should not be happening.</span></td>
      </tr>
      <tr>
        <td id="L4866" data-line-number="4866"></td>
        <td id="LC4866">            <span><span>//</span> It likely means theres some issue where we failed to send a CreateThread notification.</span></td>
      </tr>
      <tr>
        <td id="L4867" data-line-number="4867"></td>
        <td id="LC4867">            <span>TargetConsistencyCheck</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4868" data-line-number="4868"></td>
        <td id="LC4868">            pBreakpoint = pAppDomain-&gt;<span>m_breakpoints</span>.<span>GetBase</span>(<span>LsPtrToCookie</span>(pEvent-&gt;<span>BreakpointData</span>.<span>breakpointToken</span>));</td>
      </tr>
      <tr>
        <td id="L4869" data-line-number="4869"></td>
        <td id="LC4869">
</td>
      </tr>
      <tr>
        <td id="L4870" data-line-number="4870"></td>
        <td id="LC4870">            <span>if</span> (pBreakpoint != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L4871" data-line-number="4871"></td>
        <td id="LC4871">            {</td>
      </tr>
      <tr>
        <td id="L4872" data-line-number="4872"></td>
        <td id="LC4872">                ICorDebugBreakpoint * pIBreakpoint = <span>CordbBreakpointToInterface</span>(pBreakpoint);</td>
      </tr>
      <tr>
        <td id="L4873" data-line-number="4873"></td>
        <td id="LC4873">                <span>_ASSERTE</span>(pIBreakpoint != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4874" data-line-number="4874"></td>
        <td id="LC4874">
</td>
      </tr>
      <tr>
        <td id="L4875" data-line-number="4875"></td>
        <td id="LC4875">                {</td>
      </tr>
      <tr>
        <td id="L4876" data-line-number="4876"></td>
        <td id="LC4876">                    <span>PUBLIC_CALLBACK_IN_THIS_SCOPE2</span>(<span>this</span>, pLockHolder, pEvent, <span><span>"</span>thread=0x%p, bp=0x%p<span>"</span></span>, pThread, pBreakpoint);</td>
      </tr>
      <tr>
        <td id="L4877" data-line-number="4877"></td>
        <td id="LC4877">                    pCallback1-&gt;<span>Breakpoint</span>(pAppDomain, pThread, pIBreakpoint);</td>
      </tr>
      <tr>
        <td id="L4878" data-line-number="4878"></td>
        <td id="LC4878">                }</td>
      </tr>
      <tr>
        <td id="L4879" data-line-number="4879"></td>
        <td id="LC4879">            }</td>
      </tr>
      <tr>
        <td id="L4880" data-line-number="4880"></td>
        <td id="LC4880">        }</td>
      </tr>
      <tr>
        <td id="L4881" data-line-number="4881"></td>
        <td id="LC4881">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4882" data-line-number="4882"></td>
        <td id="LC4882">
</td>
      </tr>
      <tr>
        <td id="L4883" data-line-number="4883"></td>
        <td id="LC4883">    <span>case</span> DB_IPCE_BEFORE_GARBAGE_COLLECTION:</td>
      </tr>
      <tr>
        <td id="L4884" data-line-number="4884"></td>
        <td id="LC4884">        {</td>
      </tr>
      <tr>
        <td id="L4885" data-line-number="4885"></td>
        <td id="LC4885">            {</td>
      </tr>
      <tr>
        <td id="L4886" data-line-number="4886"></td>
        <td id="LC4886">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L4887" data-line-number="4887"></td>
        <td id="LC4887">                pCallback4-&gt;<span>BeforeGarbageCollection</span>(<span>static_cast</span>&lt;ICorDebugProcess*&gt;(<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L4888" data-line-number="4888"></td>
        <td id="LC4888">            }</td>
      </tr>
      <tr>
        <td id="L4889" data-line-number="4889"></td>
        <td id="LC4889">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4890" data-line-number="4890"></td>
        <td id="LC4890">        }</td>
      </tr>
      <tr>
        <td id="L4891" data-line-number="4891"></td>
        <td id="LC4891">
</td>
      </tr>
      <tr>
        <td id="L4892" data-line-number="4892"></td>
        <td id="LC4892">    <span>case</span> DB_IPCE_AFTER_GARBAGE_COLLECTION:</td>
      </tr>
      <tr>
        <td id="L4893" data-line-number="4893"></td>
        <td id="LC4893">        {</td>
      </tr>
      <tr>
        <td id="L4894" data-line-number="4894"></td>
        <td id="LC4894">            {</td>
      </tr>
      <tr>
        <td id="L4895" data-line-number="4895"></td>
        <td id="LC4895">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L4896" data-line-number="4896"></td>
        <td id="LC4896">                pCallback4-&gt;<span>AfterGarbageCollection</span>(<span>static_cast</span>&lt;ICorDebugProcess*&gt;(<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L4897" data-line-number="4897"></td>
        <td id="LC4897">            }</td>
      </tr>
      <tr>
        <td id="L4898" data-line-number="4898"></td>
        <td id="LC4898">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4899" data-line-number="4899"></td>
        <td id="LC4899">        }</td>
      </tr>
      <tr>
        <td id="L4900" data-line-number="4900"></td>
        <td id="LC4900">#<span>ifdef</span> FEATURE_DATABREAKPOINT</td>
      </tr>
      <tr>
        <td id="L4901" data-line-number="4901"></td>
        <td id="LC4901">    <span>case</span> DB_IPCE_DATA_BREAKPOINT:</td>
      </tr>
      <tr>
        <td id="L4902" data-line-number="4902"></td>
        <td id="LC4902">        {</td>
      </tr>
      <tr>
        <td id="L4903" data-line-number="4903"></td>
        <td id="LC4903">            <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4904" data-line-number="4904"></td>
        <td id="LC4904">
</td>
      </tr>
      <tr>
        <td id="L4905" data-line-number="4905"></td>
        <td id="LC4905">            {</td>
      </tr>
      <tr>
        <td id="L4906" data-line-number="4906"></td>
        <td id="LC4906">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L4907" data-line-number="4907"></td>
        <td id="LC4907">                pCallback4-&gt;<span>DataBreakpoint</span>(<span>static_cast</span>&lt;ICorDebugProcess*&gt;(<span>this</span>), pThread, <span>reinterpret_cast</span>&lt;BYTE*&gt;(&amp;(pEvent-&gt;<span>DataBreakpointData</span>.<span>context</span>)), <span>sizeof</span>(CONTEXT));</td>
      </tr>
      <tr>
        <td id="L4908" data-line-number="4908"></td>
        <td id="LC4908">            }</td>
      </tr>
      <tr>
        <td id="L4909" data-line-number="4909"></td>
        <td id="LC4909">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4910" data-line-number="4910"></td>
        <td id="LC4910">        }</td>
      </tr>
      <tr>
        <td id="L4911" data-line-number="4911"></td>
        <td id="LC4911">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4912" data-line-number="4912"></td>
        <td id="LC4912">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4913" data-line-number="4913"></td>
        <td id="LC4913">    <span>case</span> DB_IPCE_USER_BREAKPOINT:</td>
      </tr>
      <tr>
        <td id="L4914" data-line-number="4914"></td>
        <td id="LC4914">        {</td>
      </tr>
      <tr>
        <td id="L4915" data-line-number="4915"></td>
        <td id="LC4915">            <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] RCET::DRCE: user breakpoint.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L4916" data-line-number="4916"></td>
        <td id="LC4916">                 <span>GetCurrentThreadId</span>());</td>
      </tr>
      <tr>
        <td id="L4917" data-line-number="4917"></td>
        <td id="LC4917">
</td>
      </tr>
      <tr>
        <td id="L4918" data-line-number="4918"></td>
        <td id="LC4918">            <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4919" data-line-number="4919"></td>
        <td id="LC4919">            <span>_ASSERTE</span>(pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4920" data-line-number="4920"></td>
        <td id="LC4920">            <span>_ASSERTE</span>(pThread-&gt;<span>m_pAppDomain</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4921" data-line-number="4921"></td>
        <td id="LC4921">
</td>
      </tr>
      <tr>
        <td id="L4922" data-line-number="4922"></td>
        <td id="LC4922">            {</td>
      </tr>
      <tr>
        <td id="L4923" data-line-number="4923"></td>
        <td id="LC4923">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L4924" data-line-number="4924"></td>
        <td id="LC4924">                pCallback1-&gt;<span>Break</span>(pThread-&gt;<span>m_pAppDomain</span>, pThread);</td>
      </tr>
      <tr>
        <td id="L4925" data-line-number="4925"></td>
        <td id="LC4925">            }</td>
      </tr>
      <tr>
        <td id="L4926" data-line-number="4926"></td>
        <td id="LC4926">
</td>
      </tr>
      <tr>
        <td id="L4927" data-line-number="4927"></td>
        <td id="LC4927">        }</td>
      </tr>
      <tr>
        <td id="L4928" data-line-number="4928"></td>
        <td id="LC4928">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4929" data-line-number="4929"></td>
        <td id="LC4929">
</td>
      </tr>
      <tr>
        <td id="L4930" data-line-number="4930"></td>
        <td id="LC4930">    <span>case</span> DB_IPCE_STEP_COMPLETE:</td>
      </tr>
      <tr>
        <td id="L4931" data-line-number="4931"></td>
        <td id="LC4931">        {</td>
      </tr>
      <tr>
        <td id="L4932" data-line-number="4932"></td>
        <td id="LC4932">            <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] RCET::DRCE: step complete.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L4933" data-line-number="4933"></td>
        <td id="LC4933">                 <span>GetCurrentThreadId</span>());</td>
      </tr>
      <tr>
        <td id="L4934" data-line-number="4934"></td>
        <td id="LC4934">
</td>
      </tr>
      <tr>
        <td id="L4935" data-line-number="4935"></td>
        <td id="LC4935">            <span>PREFIX_ASSUME</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4936" data-line-number="4936"></td>
        <td id="LC4936">
</td>
      </tr>
      <tr>
        <td id="L4937" data-line-number="4937"></td>
        <td id="LC4937">            CordbStepper * pStepper = m_steppers.<span>GetBase</span>(<span>LsPtrToCookie</span>(pEvent-&gt;<span>StepData</span>.<span>stepperToken</span>));</td>
      </tr>
      <tr>
        <td id="L4938" data-line-number="4938"></td>
        <td id="LC4938">
</td>
      </tr>
      <tr>
        <td id="L4939" data-line-number="4939"></td>
        <td id="LC4939">            <span><span>//</span> It's possible the stepper is NULL if:</span></td>
      </tr>
      <tr>
        <td id="L4940" data-line-number="4940"></td>
        <td id="LC4940">            <span><span>//</span> - event X &amp; step-complete are both in the queue</span></td>
      </tr>
      <tr>
        <td id="L4941" data-line-number="4941"></td>
        <td id="LC4941">            <span><span>//</span> - during dispatch for event X, Cordbg cancels the stepper (thus removing it from m_steppers)</span></td>
      </tr>
      <tr>
        <td id="L4942" data-line-number="4942"></td>
        <td id="LC4942">            <span><span>//</span> - the Step-Complete still stays in the queue, and so we're here, but out stepper's been removed.</span></td>
      </tr>
      <tr>
        <td id="L4943" data-line-number="4943"></td>
        <td id="LC4943">            <span><span>//</span> (This could happen for breakpoints too)</span></td>
      </tr>
      <tr>
        <td id="L4944" data-line-number="4944"></td>
        <td id="LC4944">            <span><span>//</span> Don't dispatch a callback if the stepper is NULL.</span></td>
      </tr>
      <tr>
        <td id="L4945" data-line-number="4945"></td>
        <td id="LC4945">            <span>if</span> (pStepper != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L4946" data-line-number="4946"></td>
        <td id="LC4946">            {</td>
      </tr>
      <tr>
        <td id="L4947" data-line-number="4947"></td>
        <td id="LC4947">                RSSmartPtr&lt;CordbStepper&gt; <span>pRef</span>(pStepper);</td>
      </tr>
      <tr>
        <td id="L4948" data-line-number="4948"></td>
        <td id="LC4948">                pStepper-&gt;<span>m_active</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L4949" data-line-number="4949"></td>
        <td id="LC4949">                m_steppers.<span>RemoveBase</span>((ULONG_PTR)pStepper-&gt;<span>m_id</span>);</td>
      </tr>
      <tr>
        <td id="L4950" data-line-number="4950"></td>
        <td id="LC4950">
</td>
      </tr>
      <tr>
        <td id="L4951" data-line-number="4951"></td>
        <td id="LC4951">                {</td>
      </tr>
      <tr>
        <td id="L4952" data-line-number="4952"></td>
        <td id="LC4952">                    <span>_ASSERTE</span>(pThread-&gt;<span>m_pAppDomain</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4953" data-line-number="4953"></td>
        <td id="LC4953">                    <span>PUBLIC_CALLBACK_IN_THIS_SCOPE2</span>(<span>this</span>, pLockHolder, pEvent, <span><span>"</span>thrad=0x%p, stepper=0x%p<span>"</span></span>, pThread, pStepper);</td>
      </tr>
      <tr>
        <td id="L4954" data-line-number="4954"></td>
        <td id="LC4954">                    pCallback1-&gt;<span>StepComplete</span>(pThread-&gt;<span>m_pAppDomain</span>, pThread, pStepper, pEvent-&gt;<span>StepData</span>.<span>reason</span>);</td>
      </tr>
      <tr>
        <td id="L4955" data-line-number="4955"></td>
        <td id="LC4955">                }</td>
      </tr>
      <tr>
        <td id="L4956" data-line-number="4956"></td>
        <td id="LC4956">
</td>
      </tr>
      <tr>
        <td id="L4957" data-line-number="4957"></td>
        <td id="LC4957">                <span><span>//</span> implicit Release on pRef</span></td>
      </tr>
      <tr>
        <td id="L4958" data-line-number="4958"></td>
        <td id="LC4958">            }</td>
      </tr>
      <tr>
        <td id="L4959" data-line-number="4959"></td>
        <td id="LC4959">        }</td>
      </tr>
      <tr>
        <td id="L4960" data-line-number="4960"></td>
        <td id="LC4960">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4961" data-line-number="4961"></td>
        <td id="LC4961">
</td>
      </tr>
      <tr>
        <td id="L4962" data-line-number="4962"></td>
        <td id="LC4962">    <span>case</span> DB_IPCE_EXCEPTION:</td>
      </tr>
      <tr>
        <td id="L4963" data-line-number="4963"></td>
        <td id="LC4963">        {</td>
      </tr>
      <tr>
        <td id="L4964" data-line-number="4964"></td>
        <td id="LC4964">            <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] RCET::DRCE: exception.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L4965" data-line-number="4965"></td>
        <td id="LC4965">                 <span>GetCurrentThreadId</span>());</td>
      </tr>
      <tr>
        <td id="L4966" data-line-number="4966"></td>
        <td id="LC4966">
</td>
      </tr>
      <tr>
        <td id="L4967" data-line-number="4967"></td>
        <td id="LC4967">            <span>_ASSERTE</span>(pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4968" data-line-number="4968"></td>
        <td id="LC4968">
</td>
      </tr>
      <tr>
        <td id="L4969" data-line-number="4969"></td>
        <td id="LC4969">            <span><span>//</span> For some exceptions very early in startup (eg, TypeLoad), this may have occurred before we</span></td>
      </tr>
      <tr>
        <td id="L4970" data-line-number="4970"></td>
        <td id="LC4970">            <span><span>//</span> even executed jitted code on the thread. We may have not received a CreateThread yet.</span></td>
      </tr>
      <tr>
        <td id="L4971" data-line-number="4971"></td>
        <td id="LC4971">            <span><span>//</span> In V2, we detected this and sent a LogMessage on a random thread.</span></td>
      </tr>
      <tr>
        <td id="L4972" data-line-number="4972"></td>
        <td id="LC4972">            <span><span>//</span> In V3, we lazily create the CordbThread objects (possibly before the CreateThread event),</span></td>
      </tr>
      <tr>
        <td id="L4973" data-line-number="4973"></td>
        <td id="LC4973">            <span><span>//</span> and so we know we should have one.</span></td>
      </tr>
      <tr>
        <td id="L4974" data-line-number="4974"></td>
        <td id="LC4974">            <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4975" data-line-number="4975"></td>
        <td id="LC4975">
</td>
      </tr>
      <tr>
        <td id="L4976" data-line-number="4976"></td>
        <td id="LC4976">            pThread-&gt;<span>SetExInfo</span>(pEvent-&gt;<span>Exception</span>.<span>vmExceptionHandle</span>);</td>
      </tr>
      <tr>
        <td id="L4977" data-line-number="4977"></td>
        <td id="LC4977">
</td>
      </tr>
      <tr>
        <td id="L4978" data-line-number="4978"></td>
        <td id="LC4978">            <span>_ASSERTE</span>(pThread-&gt;<span>m_pAppDomain</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4979" data-line-number="4979"></td>
        <td id="LC4979">
</td>
      </tr>
      <tr>
        <td id="L4980" data-line-number="4980"></td>
        <td id="LC4980">            {</td>
      </tr>
      <tr>
        <td id="L4981" data-line-number="4981"></td>
        <td id="LC4981">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L4982" data-line-number="4982"></td>
        <td id="LC4982">                pCallback1-&gt;<span>Exception</span>(pThread-&gt;<span>m_pAppDomain</span>, pThread, !pEvent-&gt;<span>Exception</span>.<span>firstChance</span>);</td>
      </tr>
      <tr>
        <td id="L4983" data-line-number="4983"></td>
        <td id="LC4983">            }</td>
      </tr>
      <tr>
        <td id="L4984" data-line-number="4984"></td>
        <td id="LC4984">
</td>
      </tr>
      <tr>
        <td id="L4985" data-line-number="4985"></td>
        <td id="LC4985">        }</td>
      </tr>
      <tr>
        <td id="L4986" data-line-number="4986"></td>
        <td id="LC4986">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4987" data-line-number="4987"></td>
        <td id="LC4987">
</td>
      </tr>
      <tr>
        <td id="L4988" data-line-number="4988"></td>
        <td id="LC4988">    <span>case</span> DB_IPCE_SYNC_COMPLETE:</td>
      </tr>
      <tr>
        <td id="L4989" data-line-number="4989"></td>
        <td id="LC4989">        <span>_ASSERTE</span>(!<span><span>"</span>Should have never queued a sync complete pEvent.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4990" data-line-number="4990"></td>
        <td id="LC4990">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4991" data-line-number="4991"></td>
        <td id="LC4991">
</td>
      </tr>
      <tr>
        <td id="L4992" data-line-number="4992"></td>
        <td id="LC4992">    <span>case</span> DB_IPCE_THREAD_ATTACH:</td>
      </tr>
      <tr>
        <td id="L4993" data-line-number="4993"></td>
        <td id="LC4993">        {</td>
      </tr>
      <tr>
        <td id="L4994" data-line-number="4994"></td>
        <td id="LC4994">            <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO100, <span><span>"</span>RCET::DRCE: thread attach : ID=%x.<span>\n</span><span>"</span></span>, dwVolatileThreadId);</td>
      </tr>
      <tr>
        <td id="L4995" data-line-number="4995"></td>
        <td id="LC4995">
</td>
      </tr>
      <tr>
        <td id="L4996" data-line-number="4996"></td>
        <td id="LC4996">            <span>TargetConsistencyCheck</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L4997" data-line-number="4997"></td>
        <td id="LC4997">            {</td>
      </tr>
      <tr>
        <td id="L4998" data-line-number="4998"></td>
        <td id="LC4998">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE1</span>(<span>this</span>, pLockHolder, pEvent, <span><span>"</span>thread=0x%p<span>"</span></span>, pThread);</td>
      </tr>
      <tr>
        <td id="L4999" data-line-number="4999"></td>
        <td id="LC4999">                pCallback1-&gt;<span>CreateThread</span>(pAppDomain, pThread);</td>
      </tr>
      <tr>
        <td id="L5000" data-line-number="5000"></td>
        <td id="LC5000">            }</td>
      </tr>
      <tr>
        <td id="L5001" data-line-number="5001"></td>
        <td id="LC5001">        }</td>
      </tr>
      <tr>
        <td id="L5002" data-line-number="5002"></td>
        <td id="LC5002">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5003" data-line-number="5003"></td>
        <td id="LC5003">
</td>
      </tr>
      <tr>
        <td id="L5004" data-line-number="5004"></td>
        <td id="LC5004">    <span>case</span> DB_IPCE_THREAD_DETACH:</td>
      </tr>
      <tr>
        <td id="L5005" data-line-number="5005"></td>
        <td id="LC5005">        {</td>
      </tr>
      <tr>
        <td id="L5006" data-line-number="5006"></td>
        <td id="LC5006">            <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO100, <span><span>"</span>[%x] RCET::HRCE: thread detach : ID=%x <span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5007" data-line-number="5007"></td>
        <td id="LC5007">                 <span>GetCurrentThreadId</span>(), dwVolatileThreadId);</td>
      </tr>
      <tr>
        <td id="L5008" data-line-number="5008"></td>
        <td id="LC5008">
</td>
      </tr>
      <tr>
        <td id="L5009" data-line-number="5009"></td>
        <td id="LC5009">            <span><span>//</span> If the runtime thread never entered managed code, there</span></td>
      </tr>
      <tr>
        <td id="L5010" data-line-number="5010"></td>
        <td id="LC5010">            <span><span>//</span> won't be a CordbThread, and CreateThread was never</span></td>
      </tr>
      <tr>
        <td id="L5011" data-line-number="5011"></td>
        <td id="LC5011">            <span><span>//</span> called, so don't bother calling ExitThread.</span></td>
      </tr>
      <tr>
        <td id="L5012" data-line-number="5012"></td>
        <td id="LC5012">            <span>if</span> (pThread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5013" data-line-number="5013"></td>
        <td id="LC5013">            {</td>
      </tr>
      <tr>
        <td id="L5014" data-line-number="5014"></td>
        <td id="LC5014">                <span>AddToNeuterOnContinueList</span>(pThread);</td>
      </tr>
      <tr>
        <td id="L5015" data-line-number="5015"></td>
        <td id="LC5015">
</td>
      </tr>
      <tr>
        <td id="L5016" data-line-number="5016"></td>
        <td id="LC5016">                RSSmartPtr&lt;CordbThread&gt;    <span>pRefThread</span>(pThread);</td>
      </tr>
      <tr>
        <td id="L5017" data-line-number="5017"></td>
        <td id="LC5017">
</td>
      </tr>
      <tr>
        <td id="L5018" data-line-number="5018"></td>
        <td id="LC5018">                <span>_ASSERTE</span>(pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5019" data-line-number="5019"></td>
        <td id="LC5019">
</td>
      </tr>
      <tr>
        <td id="L5020" data-line-number="5020"></td>
        <td id="LC5020">                <span><span>//</span> A thread is reported as dead before we get the exit event.</span></td>
      </tr>
      <tr>
        <td id="L5021" data-line-number="5021"></td>
        <td id="LC5021">                <span><span>//</span> See code:IDacDbiInterface#IsThreadMarkedDead for the invariant being asserted here.</span></td>
      </tr>
      <tr>
        <td id="L5022" data-line-number="5022"></td>
        <td id="LC5022">                <span>TargetConsistencyCheck</span>(pThread-&gt;<span>IsThreadDead</span>());</td>
      </tr>
      <tr>
        <td id="L5023" data-line-number="5023"></td>
        <td id="LC5023">
</td>
      </tr>
      <tr>
        <td id="L5024" data-line-number="5024"></td>
        <td id="LC5024">                <span><span>//</span> Enforce the enumeration invariants (see code:IDacDbiInterface#Enumeration)that the thread is not discoverable.</span></td>
      </tr>
      <tr>
        <td id="L5025" data-line-number="5025"></td>
        <td id="LC5025">                <span>INDEBUG</span>(pThread-&gt;<span>DbgAssertThreadDeleted</span>());</td>
      </tr>
      <tr>
        <td id="L5026" data-line-number="5026"></td>
        <td id="LC5026">
</td>
      </tr>
      <tr>
        <td id="L5027" data-line-number="5027"></td>
        <td id="LC5027">                <span><span>//</span> Remove the thread from the hash. If we've removed it from the hash, we really should</span></td>
      </tr>
      <tr>
        <td id="L5028" data-line-number="5028"></td>
        <td id="LC5028">                <span><span>//</span> neuter it ... but that causes test failures.</span></td>
      </tr>
      <tr>
        <td id="L5029" data-line-number="5029"></td>
        <td id="LC5029">                <span><span>//</span> We'll neuter it in continue.</span></td>
      </tr>
      <tr>
        <td id="L5030" data-line-number="5030"></td>
        <td id="LC5030">                m_userThreads.<span>RemoveBase</span>(<span>VmPtrToCookie</span>(pThread-&gt;<span>m_vmThreadToken</span>));</td>
      </tr>
      <tr>
        <td id="L5031" data-line-number="5031"></td>
        <td id="LC5031">
</td>
      </tr>
      <tr>
        <td id="L5032" data-line-number="5032"></td>
        <td id="LC5032">
</td>
      </tr>
      <tr>
        <td id="L5033" data-line-number="5033"></td>
        <td id="LC5033">                <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] RCET::HRCE: sending thread detach.<span>\n</span><span>"</span></span>, <span>GetCurrentThreadId</span>()));</td>
      </tr>
      <tr>
        <td id="L5034" data-line-number="5034"></td>
        <td id="LC5034">
</td>
      </tr>
      <tr>
        <td id="L5035" data-line-number="5035"></td>
        <td id="LC5035">                {</td>
      </tr>
      <tr>
        <td id="L5036" data-line-number="5036"></td>
        <td id="LC5036">                    <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5037" data-line-number="5037"></td>
        <td id="LC5037">                    pCallback1-&gt;<span>ExitThread</span>(pAppDomain, pThread);</td>
      </tr>
      <tr>
        <td id="L5038" data-line-number="5038"></td>
        <td id="LC5038">                }</td>
      </tr>
      <tr>
        <td id="L5039" data-line-number="5039"></td>
        <td id="LC5039">
</td>
      </tr>
      <tr>
        <td id="L5040" data-line-number="5040"></td>
        <td id="LC5040">                <span><span>//</span> Implicit release on thread &amp; pAppDomain</span></td>
      </tr>
      <tr>
        <td id="L5041" data-line-number="5041"></td>
        <td id="LC5041">            }</td>
      </tr>
      <tr>
        <td id="L5042" data-line-number="5042"></td>
        <td id="LC5042">        }</td>
      </tr>
      <tr>
        <td id="L5043" data-line-number="5043"></td>
        <td id="LC5043">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5044" data-line-number="5044"></td>
        <td id="LC5044">
</td>
      </tr>
      <tr>
        <td id="L5045" data-line-number="5045"></td>
        <td id="LC5045">    <span>case</span> DB_IPCE_METADATA_UPDATE:</td>
      </tr>
      <tr>
        <td id="L5046" data-line-number="5046"></td>
        <td id="LC5046">        {</td>
      </tr>
      <tr>
        <td id="L5047" data-line-number="5047"></td>
        <td id="LC5047">            CordbModule * pModule = pAppDomain-&gt;<span>LookupOrCreateModule</span>(pEvent-&gt;<span>MetadataUpdateData</span>.<span>vmDomainFile</span>);</td>
      </tr>
      <tr>
        <td id="L5048" data-line-number="5048"></td>
        <td id="LC5048">            pModule-&gt;<span>RefreshMetaData</span>();</td>
      </tr>
      <tr>
        <td id="L5049" data-line-number="5049"></td>
        <td id="LC5049">        }</td>
      </tr>
      <tr>
        <td id="L5050" data-line-number="5050"></td>
        <td id="LC5050">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5051" data-line-number="5051"></td>
        <td id="LC5051">
</td>
      </tr>
      <tr>
        <td id="L5052" data-line-number="5052"></td>
        <td id="LC5052">    <span>case</span> DB_IPCE_LOAD_MODULE:</td>
      </tr>
      <tr>
        <td id="L5053" data-line-number="5053"></td>
        <td id="LC5053">        {</td>
      </tr>
      <tr>
        <td id="L5054" data-line-number="5054"></td>
        <td id="LC5054">            <span>_ASSERTE</span> (pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5055" data-line-number="5055"></td>
        <td id="LC5055">            CordbModule * pModule = pAppDomain-&gt;<span>LookupOrCreateModule</span>(pEvent-&gt;<span>LoadModuleData</span>.<span>vmDomainFile</span>);</td>
      </tr>
      <tr>
        <td id="L5056" data-line-number="5056"></td>
        <td id="LC5056">
</td>
      </tr>
      <tr>
        <td id="L5057" data-line-number="5057"></td>
        <td id="LC5057">            {</td>
      </tr>
      <tr>
        <td id="L5058" data-line-number="5058"></td>
        <td id="LC5058">                pModule-&gt;<span>SetLoadEventContinueMarker</span>();</td>
      </tr>
      <tr>
        <td id="L5059" data-line-number="5059"></td>
        <td id="LC5059">
</td>
      </tr>
      <tr>
        <td id="L5060" data-line-number="5060"></td>
        <td id="LC5060">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5061" data-line-number="5061"></td>
        <td id="LC5061">                pCallback1-&gt;<span>LoadModule</span>(pAppDomain, pModule);</td>
      </tr>
      <tr>
        <td id="L5062" data-line-number="5062"></td>
        <td id="LC5062">            }</td>
      </tr>
      <tr>
        <td id="L5063" data-line-number="5063"></td>
        <td id="LC5063">
</td>
      </tr>
      <tr>
        <td id="L5064" data-line-number="5064"></td>
        <td id="LC5064">        }</td>
      </tr>
      <tr>
        <td id="L5065" data-line-number="5065"></td>
        <td id="LC5065">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5066" data-line-number="5066"></td>
        <td id="LC5066">
</td>
      </tr>
      <tr>
        <td id="L5067" data-line-number="5067"></td>
        <td id="LC5067">    <span>case</span> DB_IPCE_CREATE_CONNECTION:</td>
      </tr>
      <tr>
        <td id="L5068" data-line-number="5068"></td>
        <td id="LC5068">        {</td>
      </tr>
      <tr>
        <td id="L5069" data-line-number="5069"></td>
        <td id="LC5069">            <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO100,</td>
      </tr>
      <tr>
        <td id="L5070" data-line-number="5070"></td>
        <td id="LC5070">                <span><span>"</span>RCET::HRCE: Connection change %d <span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5071" data-line-number="5071"></td>
        <td id="LC5071">                pEvent-&gt;<span>CreateConnection</span>.<span>connectionId</span>);</td>
      </tr>
      <tr>
        <td id="L5072" data-line-number="5072"></td>
        <td id="LC5072">
</td>
      </tr>
      <tr>
        <td id="L5073" data-line-number="5073"></td>
        <td id="LC5073">            <span><span>//</span> pass back the connection id and the connection name.</span></td>
      </tr>
      <tr>
        <td id="L5074" data-line-number="5074"></td>
        <td id="LC5074">            <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5075" data-line-number="5075"></td>
        <td id="LC5075">            pCallback2-&gt;<span>CreateConnection</span>(</td>
      </tr>
      <tr>
        <td id="L5076" data-line-number="5076"></td>
        <td id="LC5076">                <span>this</span>,</td>
      </tr>
      <tr>
        <td id="L5077" data-line-number="5077"></td>
        <td id="LC5077">                pEvent-&gt;<span>CreateConnection</span>.<span>connectionId</span>,</td>
      </tr>
      <tr>
        <td id="L5078" data-line-number="5078"></td>
        <td id="LC5078">                <span>const_cast</span>&lt;WCHAR*&gt; (pEvent-&gt;<span>CreateConnection</span>.<span>wzConnectionName</span>.<span>GetString</span>()));</td>
      </tr>
      <tr>
        <td id="L5079" data-line-number="5079"></td>
        <td id="LC5079">        }</td>
      </tr>
      <tr>
        <td id="L5080" data-line-number="5080"></td>
        <td id="LC5080">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5081" data-line-number="5081"></td>
        <td id="LC5081">
</td>
      </tr>
      <tr>
        <td id="L5082" data-line-number="5082"></td>
        <td id="LC5082">    <span>case</span> DB_IPCE_DESTROY_CONNECTION:</td>
      </tr>
      <tr>
        <td id="L5083" data-line-number="5083"></td>
        <td id="LC5083">        {</td>
      </tr>
      <tr>
        <td id="L5084" data-line-number="5084"></td>
        <td id="LC5084">            <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO100,</td>
      </tr>
      <tr>
        <td id="L5085" data-line-number="5085"></td>
        <td id="LC5085">                 <span><span>"</span>RCET::HRCE: Connection destroyed %d <span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5086" data-line-number="5086"></td>
        <td id="LC5086">                 pEvent-&gt;<span>ConnectionChange</span>.<span>connectionId</span>);</td>
      </tr>
      <tr>
        <td id="L5087" data-line-number="5087"></td>
        <td id="LC5087">            <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5088" data-line-number="5088"></td>
        <td id="LC5088">            pCallback2-&gt;<span>DestroyConnection</span>(<span>this</span>, pEvent-&gt;<span>ConnectionChange</span>.<span>connectionId</span>);</td>
      </tr>
      <tr>
        <td id="L5089" data-line-number="5089"></td>
        <td id="LC5089">        }</td>
      </tr>
      <tr>
        <td id="L5090" data-line-number="5090"></td>
        <td id="LC5090">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5091" data-line-number="5091"></td>
        <td id="LC5091">
</td>
      </tr>
      <tr>
        <td id="L5092" data-line-number="5092"></td>
        <td id="LC5092">    <span>case</span> DB_IPCE_CHANGE_CONNECTION:</td>
      </tr>
      <tr>
        <td id="L5093" data-line-number="5093"></td>
        <td id="LC5093">        {</td>
      </tr>
      <tr>
        <td id="L5094" data-line-number="5094"></td>
        <td id="LC5094">            <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO100,</td>
      </tr>
      <tr>
        <td id="L5095" data-line-number="5095"></td>
        <td id="LC5095">                 <span><span>"</span>RCET::HRCE: Connection changed %d <span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5096" data-line-number="5096"></td>
        <td id="LC5096">                 pEvent-&gt;<span>ConnectionChange</span>.<span>connectionId</span>);</td>
      </tr>
      <tr>
        <td id="L5097" data-line-number="5097"></td>
        <td id="LC5097">
</td>
      </tr>
      <tr>
        <td id="L5098" data-line-number="5098"></td>
        <td id="LC5098">            <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5099" data-line-number="5099"></td>
        <td id="LC5099">            pCallback2-&gt;<span>ChangeConnection</span>(<span>this</span>, pEvent-&gt;<span>ConnectionChange</span>.<span>connectionId</span>);</td>
      </tr>
      <tr>
        <td id="L5100" data-line-number="5100"></td>
        <td id="LC5100">        }</td>
      </tr>
      <tr>
        <td id="L5101" data-line-number="5101"></td>
        <td id="LC5101">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5102" data-line-number="5102"></td>
        <td id="LC5102">
</td>
      </tr>
      <tr>
        <td id="L5103" data-line-number="5103"></td>
        <td id="LC5103">    <span>case</span> DB_IPCE_UNLOAD_MODULE:</td>
      </tr>
      <tr>
        <td id="L5104" data-line-number="5104"></td>
        <td id="LC5104">        {</td>
      </tr>
      <tr>
        <td id="L5105" data-line-number="5105"></td>
        <td id="LC5105">            <span>STRESS_LOG3</span>(LF_CORDB, LL_INFO100, <span><span>"</span>RCET::HRCE: unload module on thread %#x Mod:0x%x AD:0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5106" data-line-number="5106"></td>
        <td id="LC5106">                 dwVolatileThreadId,</td>
      </tr>
      <tr>
        <td id="L5107" data-line-number="5107"></td>
        <td id="LC5107">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>UnloadModuleData</span>.<span>vmDomainFile</span>),</td>
      </tr>
      <tr>
        <td id="L5108" data-line-number="5108"></td>
        <td id="LC5108">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>vmAppDomain</span>));</td>
      </tr>
      <tr>
        <td id="L5109" data-line-number="5109"></td>
        <td id="LC5109">
</td>
      </tr>
      <tr>
        <td id="L5110" data-line-number="5110"></td>
        <td id="LC5110">            <span>PREFIX_ASSUME</span> (pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5111" data-line-number="5111"></td>
        <td id="LC5111">
</td>
      </tr>
      <tr>
        <td id="L5112" data-line-number="5112"></td>
        <td id="LC5112">            CordbModule *module = pAppDomain-&gt;<span>LookupOrCreateModule</span>(pEvent-&gt;<span>UnloadModuleData</span>.<span>vmDomainFile</span>);</td>
      </tr>
      <tr>
        <td id="L5113" data-line-number="5113"></td>
        <td id="LC5113">
</td>
      </tr>
      <tr>
        <td id="L5114" data-line-number="5114"></td>
        <td id="LC5114">            <span>if</span> (module == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5115" data-line-number="5115"></td>
        <td id="LC5115">            {</td>
      </tr>
      <tr>
        <td id="L5116" data-line-number="5116"></td>
        <td id="LC5116">                <span>LOG</span>((LF_CORDB, LL_INFO100, <span><span>"</span>Already unloaded Module - continue()ing!<span>"</span></span> ));</td>
      </tr>
      <tr>
        <td id="L5117" data-line-number="5117"></td>
        <td id="LC5117">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5118" data-line-number="5118"></td>
        <td id="LC5118">            }</td>
      </tr>
      <tr>
        <td id="L5119" data-line-number="5119"></td>
        <td id="LC5119">            <span>_ASSERTE</span>(module != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5120" data-line-number="5120"></td>
        <td id="LC5120">            <span>INDEBUG</span>(module-&gt;<span>DbgAssertModuleDeleted</span>());</td>
      </tr>
      <tr>
        <td id="L5121" data-line-number="5121"></td>
        <td id="LC5121">
</td>
      </tr>
      <tr>
        <td id="L5122" data-line-number="5122"></td>
        <td id="LC5122">            <span><span>//</span> The appdomain we're unloading in must be the appdomain we were loaded in. Otherwise, we've got mismatched</span></td>
      </tr>
      <tr>
        <td id="L5123" data-line-number="5123"></td>
        <td id="LC5123">            <span><span>//</span> module and appdomain pointers. Bugs 65943 &amp; 81728.</span></td>
      </tr>
      <tr>
        <td id="L5124" data-line-number="5124"></td>
        <td id="LC5124">            <span>_ASSERTE</span>(pAppDomain == module-&gt;<span>GetAppDomain</span>());</td>
      </tr>
      <tr>
        <td id="L5125" data-line-number="5125"></td>
        <td id="LC5125">
</td>
      </tr>
      <tr>
        <td id="L5126" data-line-number="5126"></td>
        <td id="LC5126">            <span><span>//</span> Ensure the module gets neutered once we call continue.</span></td>
      </tr>
      <tr>
        <td id="L5127" data-line-number="5127"></td>
        <td id="LC5127">            <span>AddToNeuterOnContinueList</span>(module); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L5128" data-line-number="5128"></td>
        <td id="LC5128">            {</td>
      </tr>
      <tr>
        <td id="L5129" data-line-number="5129"></td>
        <td id="LC5129">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5130" data-line-number="5130"></td>
        <td id="LC5130">                pCallback1-&gt;<span>UnloadModule</span>(pAppDomain, module);</td>
      </tr>
      <tr>
        <td id="L5131" data-line-number="5131"></td>
        <td id="LC5131">            }</td>
      </tr>
      <tr>
        <td id="L5132" data-line-number="5132"></td>
        <td id="LC5132">
</td>
      </tr>
      <tr>
        <td id="L5133" data-line-number="5133"></td>
        <td id="LC5133">            pAppDomain-&gt;<span>m_modules</span>.<span>RemoveBase</span>(<span>VmPtrToCookie</span>(pEvent-&gt;<span>UnloadModuleData</span>.<span>vmDomainFile</span>));</td>
      </tr>
      <tr>
        <td id="L5134" data-line-number="5134"></td>
        <td id="LC5134">        }</td>
      </tr>
      <tr>
        <td id="L5135" data-line-number="5135"></td>
        <td id="LC5135">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5136" data-line-number="5136"></td>
        <td id="LC5136">
</td>
      </tr>
      <tr>
        <td id="L5137" data-line-number="5137"></td>
        <td id="LC5137">    <span>case</span> DB_IPCE_LOAD_CLASS:</td>
      </tr>
      <tr>
        <td id="L5138" data-line-number="5138"></td>
        <td id="LC5138">        {</td>
      </tr>
      <tr>
        <td id="L5139" data-line-number="5139"></td>
        <td id="LC5139">            CordbClass *pClass = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L5140" data-line-number="5140"></td>
        <td id="LC5140">
</td>
      </tr>
      <tr>
        <td id="L5141" data-line-number="5141"></td>
        <td id="LC5141">            <span>LOG</span>((LF_CORDB, LL_INFO10000,</td>
      </tr>
      <tr>
        <td id="L5142" data-line-number="5142"></td>
        <td id="LC5142">                 <span><span>"</span>RCET::HRCE: load class on thread %#x Tok:0x%08x Mod:0x%08x Asm:0x%08x AD:0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5143" data-line-number="5143"></td>
        <td id="LC5143">                 dwVolatileThreadId,</td>
      </tr>
      <tr>
        <td id="L5144" data-line-number="5144"></td>
        <td id="LC5144">                 pEvent-&gt;<span>LoadClass</span>.<span>classMetadataToken</span>,</td>
      </tr>
      <tr>
        <td id="L5145" data-line-number="5145"></td>
        <td id="LC5145">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>LoadClass</span>.<span>vmDomainFile</span>),</td>
      </tr>
      <tr>
        <td id="L5146" data-line-number="5146"></td>
        <td id="LC5146">                 <span>LsPtrToCookie</span>(pEvent-&gt;<span>LoadClass</span>.<span>classDebuggerAssemblyToken</span>),</td>
      </tr>
      <tr>
        <td id="L5147" data-line-number="5147"></td>
        <td id="LC5147">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>vmAppDomain</span>)));</td>
      </tr>
      <tr>
        <td id="L5148" data-line-number="5148"></td>
        <td id="LC5148">
</td>
      </tr>
      <tr>
        <td id="L5149" data-line-number="5149"></td>
        <td id="LC5149">            <span>_ASSERTE</span> (pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5150" data-line-number="5150"></td>
        <td id="LC5150">
</td>
      </tr>
      <tr>
        <td id="L5151" data-line-number="5151"></td>
        <td id="LC5151">            CordbModule* pModule = pAppDomain-&gt;<span>LookupOrCreateModule</span>(pEvent-&gt;<span>LoadClass</span>.<span>vmDomainFile</span>);</td>
      </tr>
      <tr>
        <td id="L5152" data-line-number="5152"></td>
        <td id="LC5152">            <span>if</span> (pModule == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5153" data-line-number="5153"></td>
        <td id="LC5153">            {</td>
      </tr>
      <tr>
        <td id="L5154" data-line-number="5154"></td>
        <td id="LC5154">                <span>LOG</span>((LF_CORDB, LL_INFO100, <span><span>"</span>Load Class on not-loaded Module - continue()ing!<span>"</span></span> ));</td>
      </tr>
      <tr>
        <td id="L5155" data-line-number="5155"></td>
        <td id="LC5155">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5156" data-line-number="5156"></td>
        <td id="LC5156">            }</td>
      </tr>
      <tr>
        <td id="L5157" data-line-number="5157"></td>
        <td id="LC5157">            <span>_ASSERTE</span>(pModule != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5158" data-line-number="5158"></td>
        <td id="LC5158">
</td>
      </tr>
      <tr>
        <td id="L5159" data-line-number="5159"></td>
        <td id="LC5159">            BOOL <span>fDynamic</span> = pModule-&gt;<span>IsDynamic</span>();</td>
      </tr>
      <tr>
        <td id="L5160" data-line-number="5160"></td>
        <td id="LC5160">
</td>
      </tr>
      <tr>
        <td id="L5161" data-line-number="5161"></td>
        <td id="LC5161">            <span><span>//</span> If this is a class load in a dynamic module, the metadata has become invalid.</span></td>
      </tr>
      <tr>
        <td id="L5162" data-line-number="5162"></td>
        <td id="LC5162">            <span>if</span> (<span>fDynamic</span>)</td>
      </tr>
      <tr>
        <td id="L5163" data-line-number="5163"></td>
        <td id="LC5163">            {</td>
      </tr>
      <tr>
        <td id="L5164" data-line-number="5164"></td>
        <td id="LC5164">                pModule-&gt;<span>RefreshMetaData</span>();</td>
      </tr>
      <tr>
        <td id="L5165" data-line-number="5165"></td>
        <td id="LC5165">            }</td>
      </tr>
      <tr>
        <td id="L5166" data-line-number="5166"></td>
        <td id="LC5166">
</td>
      </tr>
      <tr>
        <td id="L5167" data-line-number="5167"></td>
        <td id="LC5167">            hr = pModule-&gt;<span>LookupOrCreateClass</span>(pEvent-&gt;<span>LoadClass</span>.<span>classMetadataToken</span>, &amp;pClass);</td>
      </tr>
      <tr>
        <td id="L5168" data-line-number="5168"></td>
        <td id="LC5168">            <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr) == (pClass != <span>NULL</span>));</td>
      </tr>
      <tr>
        <td id="L5169" data-line-number="5169"></td>
        <td id="LC5169">            <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L5170" data-line-number="5170"></td>
        <td id="LC5170">
</td>
      </tr>
      <tr>
        <td id="L5171" data-line-number="5171"></td>
        <td id="LC5171">            <span><span>//</span> Prevent class load from being sent twice.</span></td>
      </tr>
      <tr>
        <td id="L5172" data-line-number="5172"></td>
        <td id="LC5172">            <span><span>//</span> @dbgtodo - Microsoft, cordbclass: this is legacy. Can this really happen? Investigate as we dac-ize CordbClass.</span></td>
      </tr>
      <tr>
        <td id="L5173" data-line-number="5173"></td>
        <td id="LC5173">            <span>if</span> (pClass-&gt;<span>LoadEventSent</span>())</td>
      </tr>
      <tr>
        <td id="L5174" data-line-number="5174"></td>
        <td id="LC5174">            {</td>
      </tr>
      <tr>
        <td id="L5175" data-line-number="5175"></td>
        <td id="LC5175">                <span><span>//</span> Dynamic modules are dynamic at the module level -</span></td>
      </tr>
      <tr>
        <td id="L5176" data-line-number="5176"></td>
        <td id="LC5176">                <span><span>//</span> you can't add a new version of a class once the module</span></td>
      </tr>
      <tr>
        <td id="L5177" data-line-number="5177"></td>
        <td id="LC5177">                <span><span>//</span> is baked.</span></td>
      </tr>
      <tr>
        <td id="L5178" data-line-number="5178"></td>
        <td id="LC5178">                <span><span>//</span> EnC adds completely new classes.</span></td>
      </tr>
      <tr>
        <td id="L5179" data-line-number="5179"></td>
        <td id="LC5179">                <span><span>//</span> There shouldn't be any other way to send multiple</span></td>
      </tr>
      <tr>
        <td id="L5180" data-line-number="5180"></td>
        <td id="LC5180">                <span><span>//</span> ClassLoad events.</span></td>
      </tr>
      <tr>
        <td id="L5181" data-line-number="5181"></td>
        <td id="LC5181">                <span><span>//</span> Except that there are race conditions between loading</span></td>
      </tr>
      <tr>
        <td id="L5182" data-line-number="5182"></td>
        <td id="LC5182">                <span><span>//</span> an appdomain, and loading a class, so if we get the extra</span></td>
      </tr>
      <tr>
        <td id="L5183" data-line-number="5183"></td>
        <td id="LC5183">                <span><span>//</span> class load, we should ignore it.</span></td>
      </tr>
      <tr>
        <td id="L5184" data-line-number="5184"></td>
        <td id="LC5184">                <span>break</span>; <span><span>//</span>out of the switch statement</span></td>
      </tr>
      <tr>
        <td id="L5185" data-line-number="5185"></td>
        <td id="LC5185">            }</td>
      </tr>
      <tr>
        <td id="L5186" data-line-number="5186"></td>
        <td id="LC5186">            pClass-&gt;<span>SetLoadEventSent</span>(<span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L5187" data-line-number="5187"></td>
        <td id="LC5187">
</td>
      </tr>
      <tr>
        <td id="L5188" data-line-number="5188"></td>
        <td id="LC5188">
</td>
      </tr>
      <tr>
        <td id="L5189" data-line-number="5189"></td>
        <td id="LC5189">            <span>if</span> (pClass != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5190" data-line-number="5190"></td>
        <td id="LC5190">            {</td>
      </tr>
      <tr>
        <td id="L5191" data-line-number="5191"></td>
        <td id="LC5191">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5192" data-line-number="5192"></td>
        <td id="LC5192">                pCallback1-&gt;<span>LoadClass</span>(pAppDomain, pClass);</td>
      </tr>
      <tr>
        <td id="L5193" data-line-number="5193"></td>
        <td id="LC5193">            }</td>
      </tr>
      <tr>
        <td id="L5194" data-line-number="5194"></td>
        <td id="LC5194">        }</td>
      </tr>
      <tr>
        <td id="L5195" data-line-number="5195"></td>
        <td id="LC5195">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5196" data-line-number="5196"></td>
        <td id="LC5196">
</td>
      </tr>
      <tr>
        <td id="L5197" data-line-number="5197"></td>
        <td id="LC5197">    <span>case</span> DB_IPCE_UNLOAD_CLASS:</td>
      </tr>
      <tr>
        <td id="L5198" data-line-number="5198"></td>
        <td id="LC5198">        {</td>
      </tr>
      <tr>
        <td id="L5199" data-line-number="5199"></td>
        <td id="LC5199">            <span>LOG</span>((LF_CORDB, LL_INFO10000,</td>
      </tr>
      <tr>
        <td id="L5200" data-line-number="5200"></td>
        <td id="LC5200">                 <span><span>"</span>RCET::HRCE: unload class on thread %#x Tok:0x%08x Mod:0x%08x AD:0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5201" data-line-number="5201"></td>
        <td id="LC5201">                 dwVolatileThreadId,</td>
      </tr>
      <tr>
        <td id="L5202" data-line-number="5202"></td>
        <td id="LC5202">                 pEvent-&gt;<span>UnloadClass</span>.<span>classMetadataToken</span>,</td>
      </tr>
      <tr>
        <td id="L5203" data-line-number="5203"></td>
        <td id="LC5203">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>UnloadClass</span>.<span>vmDomainFile</span>),</td>
      </tr>
      <tr>
        <td id="L5204" data-line-number="5204"></td>
        <td id="LC5204">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>vmAppDomain</span>)));</td>
      </tr>
      <tr>
        <td id="L5205" data-line-number="5205"></td>
        <td id="LC5205">
</td>
      </tr>
      <tr>
        <td id="L5206" data-line-number="5206"></td>
        <td id="LC5206">            <span><span>//</span> get the appdomain object</span></td>
      </tr>
      <tr>
        <td id="L5207" data-line-number="5207"></td>
        <td id="LC5207">            <span>_ASSERTE</span> (pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5208" data-line-number="5208"></td>
        <td id="LC5208">
</td>
      </tr>
      <tr>
        <td id="L5209" data-line-number="5209"></td>
        <td id="LC5209">            CordbModule *pModule = pAppDomain-&gt;<span>LookupOrCreateModule</span>(pEvent-&gt;<span>UnloadClass</span>.<span>vmDomainFile</span>);</td>
      </tr>
      <tr>
        <td id="L5210" data-line-number="5210"></td>
        <td id="LC5210">            <span>if</span> (pModule == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5211" data-line-number="5211"></td>
        <td id="LC5211">            {</td>
      </tr>
      <tr>
        <td id="L5212" data-line-number="5212"></td>
        <td id="LC5212">                <span>LOG</span>((LF_CORDB, LL_INFO100, <span><span>"</span>Unload Class on not-loaded Module - continue()ing!<span>"</span></span> ));</td>
      </tr>
      <tr>
        <td id="L5213" data-line-number="5213"></td>
        <td id="LC5213">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5214" data-line-number="5214"></td>
        <td id="LC5214">            }</td>
      </tr>
      <tr>
        <td id="L5215" data-line-number="5215"></td>
        <td id="LC5215">            <span>_ASSERTE</span>(pModule != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5216" data-line-number="5216"></td>
        <td id="LC5216">
</td>
      </tr>
      <tr>
        <td id="L5217" data-line-number="5217"></td>
        <td id="LC5217">            CordbClass *pClass = pModule-&gt;<span>LookupClass</span>(pEvent-&gt;<span>UnloadClass</span>.<span>classMetadataToken</span>);</td>
      </tr>
      <tr>
        <td id="L5218" data-line-number="5218"></td>
        <td id="LC5218">
</td>
      </tr>
      <tr>
        <td id="L5219" data-line-number="5219"></td>
        <td id="LC5219">            <span>if</span> (pClass != <span>NULL</span> &amp;&amp; !pClass-&gt;<span>HasBeenUnloaded</span>())</td>
      </tr>
      <tr>
        <td id="L5220" data-line-number="5220"></td>
        <td id="LC5220">            {</td>
      </tr>
      <tr>
        <td id="L5221" data-line-number="5221"></td>
        <td id="LC5221">                pClass-&gt;<span>SetHasBeenUnloaded</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L5222" data-line-number="5222"></td>
        <td id="LC5222">
</td>
      </tr>
      <tr>
        <td id="L5223" data-line-number="5223"></td>
        <td id="LC5223">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5224" data-line-number="5224"></td>
        <td id="LC5224">                pCallback1-&gt;<span>UnloadClass</span>(pAppDomain, pClass);</td>
      </tr>
      <tr>
        <td id="L5225" data-line-number="5225"></td>
        <td id="LC5225">            }</td>
      </tr>
      <tr>
        <td id="L5226" data-line-number="5226"></td>
        <td id="LC5226">        }</td>
      </tr>
      <tr>
        <td id="L5227" data-line-number="5227"></td>
        <td id="LC5227">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5228" data-line-number="5228"></td>
        <td id="LC5228">
</td>
      </tr>
      <tr>
        <td id="L5229" data-line-number="5229"></td>
        <td id="LC5229">    <span>case</span> DB_IPCE_FIRST_LOG_MESSAGE:</td>
      </tr>
      <tr>
        <td id="L5230" data-line-number="5230"></td>
        <td id="LC5230">        {</td>
      </tr>
      <tr>
        <td id="L5231" data-line-number="5231"></td>
        <td id="LC5231">            <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5232" data-line-number="5232"></td>
        <td id="LC5232">            <span>_ASSERTE</span>(pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5233" data-line-number="5233"></td>
        <td id="LC5233">
</td>
      </tr>
      <tr>
        <td id="L5234" data-line-number="5234"></td>
        <td id="LC5234">            <span>const</span> WCHAR * pszContent = pEvent-&gt;<span>FirstLogMessage</span>.<span>szContent</span>.<span>GetString</span>();</td>
      </tr>
      <tr>
        <td id="L5235" data-line-number="5235"></td>
        <td id="LC5235">            {</td>
      </tr>
      <tr>
        <td id="L5236" data-line-number="5236"></td>
        <td id="LC5236">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5237" data-line-number="5237"></td>
        <td id="LC5237">                pCallback1-&gt;<span>LogMessage</span>(</td>
      </tr>
      <tr>
        <td id="L5238" data-line-number="5238"></td>
        <td id="LC5238">                   pAppDomain,</td>
      </tr>
      <tr>
        <td id="L5239" data-line-number="5239"></td>
        <td id="LC5239">                   pThread,</td>
      </tr>
      <tr>
        <td id="L5240" data-line-number="5240"></td>
        <td id="LC5240">                   pEvent-&gt;<span>FirstLogMessage</span>.<span>iLevel</span>,</td>
      </tr>
      <tr>
        <td id="L5241" data-line-number="5241"></td>
        <td id="LC5241">                   <span>const_cast</span>&lt;WCHAR*&gt; (pEvent-&gt;<span>FirstLogMessage</span>.<span>szCategory</span>.<span>GetString</span>()),</td>
      </tr>
      <tr>
        <td id="L5242" data-line-number="5242"></td>
        <td id="LC5242">                   <span>const_cast</span>&lt;WCHAR*&gt; (pszContent));</td>
      </tr>
      <tr>
        <td id="L5243" data-line-number="5243"></td>
        <td id="LC5243">            }</td>
      </tr>
      <tr>
        <td id="L5244" data-line-number="5244"></td>
        <td id="LC5244">        }</td>
      </tr>
      <tr>
        <td id="L5245" data-line-number="5245"></td>
        <td id="LC5245">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5246" data-line-number="5246"></td>
        <td id="LC5246">
</td>
      </tr>
      <tr>
        <td id="L5247" data-line-number="5247"></td>
        <td id="LC5247">    <span>case</span> DB_IPCE_LOGSWITCH_SET_MESSAGE:</td>
      </tr>
      <tr>
        <td id="L5248" data-line-number="5248"></td>
        <td id="LC5248">        {</td>
      </tr>
      <tr>
        <td id="L5249" data-line-number="5249"></td>
        <td id="LC5249">
</td>
      </tr>
      <tr>
        <td id="L5250" data-line-number="5250"></td>
        <td id="LC5250">            <span>LOG</span>((LF_CORDB, LL_INFO10000,</td>
      </tr>
      <tr>
        <td id="L5251" data-line-number="5251"></td>
        <td id="LC5251">                <span><span>"</span>[%x] RCET::DRCE: Log Switch Setting Message.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5252" data-line-number="5252"></td>
        <td id="LC5252">                 <span>GetCurrentThreadId</span>()));</td>
      </tr>
      <tr>
        <td id="L5253" data-line-number="5253"></td>
        <td id="LC5253">
</td>
      </tr>
      <tr>
        <td id="L5254" data-line-number="5254"></td>
        <td id="LC5254">            <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5255" data-line-number="5255"></td>
        <td id="LC5255">
</td>
      </tr>
      <tr>
        <td id="L5256" data-line-number="5256"></td>
        <td id="LC5256">            <span>const</span> WCHAR *pstrLogSwitchName = pEvent-&gt;<span>LogSwitchSettingMessage</span>.<span>szSwitchName</span>.<span>GetString</span>();</td>
      </tr>
      <tr>
        <td id="L5257" data-line-number="5257"></td>
        <td id="LC5257">            <span>const</span> WCHAR *pstrParentName = pEvent-&gt;<span>LogSwitchSettingMessage</span>.<span>szParentSwitchName</span>.<span>GetString</span>();</td>
      </tr>
      <tr>
        <td id="L5258" data-line-number="5258"></td>
        <td id="LC5258">
</td>
      </tr>
      <tr>
        <td id="L5259" data-line-number="5259"></td>
        <td id="LC5259">            <span><span>//</span> from the thread object get the appdomain object</span></td>
      </tr>
      <tr>
        <td id="L5260" data-line-number="5260"></td>
        <td id="LC5260">            <span>_ASSERTE</span>(pAppDomain == pThread-&gt;<span>m_pAppDomain</span>);</td>
      </tr>
      <tr>
        <td id="L5261" data-line-number="5261"></td>
        <td id="LC5261">            <span>_ASSERTE</span> (pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5262" data-line-number="5262"></td>
        <td id="LC5262">
</td>
      </tr>
      <tr>
        <td id="L5263" data-line-number="5263"></td>
        <td id="LC5263">            {</td>
      </tr>
      <tr>
        <td id="L5264" data-line-number="5264"></td>
        <td id="LC5264">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5265" data-line-number="5265"></td>
        <td id="LC5265">                pCallback1-&gt;<span>LogSwitch</span>(</td>
      </tr>
      <tr>
        <td id="L5266" data-line-number="5266"></td>
        <td id="LC5266">                    pAppDomain,</td>
      </tr>
      <tr>
        <td id="L5267" data-line-number="5267"></td>
        <td id="LC5267">                    pThread,</td>
      </tr>
      <tr>
        <td id="L5268" data-line-number="5268"></td>
        <td id="LC5268">                    pEvent-&gt;<span>LogSwitchSettingMessage</span>.<span>iLevel</span>,</td>
      </tr>
      <tr>
        <td id="L5269" data-line-number="5269"></td>
        <td id="LC5269">                    pEvent-&gt;<span>LogSwitchSettingMessage</span>.<span>iReason</span>,</td>
      </tr>
      <tr>
        <td id="L5270" data-line-number="5270"></td>
        <td id="LC5270">                    <span>const_cast</span>&lt;WCHAR*&gt; (pstrLogSwitchName),</td>
      </tr>
      <tr>
        <td id="L5271" data-line-number="5271"></td>
        <td id="LC5271">                    <span>const_cast</span>&lt;WCHAR*&gt; (pstrParentName));</td>
      </tr>
      <tr>
        <td id="L5272" data-line-number="5272"></td>
        <td id="LC5272">
</td>
      </tr>
      <tr>
        <td id="L5273" data-line-number="5273"></td>
        <td id="LC5273">            }</td>
      </tr>
      <tr>
        <td id="L5274" data-line-number="5274"></td>
        <td id="LC5274">        }</td>
      </tr>
      <tr>
        <td id="L5275" data-line-number="5275"></td>
        <td id="LC5275">
</td>
      </tr>
      <tr>
        <td id="L5276" data-line-number="5276"></td>
        <td id="LC5276">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5277" data-line-number="5277"></td>
        <td id="LC5277">    <span>case</span> DB_IPCE_CUSTOM_NOTIFICATION:</td>
      </tr>
      <tr>
        <td id="L5278" data-line-number="5278"></td>
        <td id="LC5278">        {</td>
      </tr>
      <tr>
        <td id="L5279" data-line-number="5279"></td>
        <td id="LC5279">            <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5280" data-line-number="5280"></td>
        <td id="LC5280">            <span>_ASSERTE</span>(pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5281" data-line-number="5281"></td>
        <td id="LC5281">
</td>
      </tr>
      <tr>
        <td id="L5282" data-line-number="5282"></td>
        <td id="LC5282">
</td>
      </tr>
      <tr>
        <td id="L5283" data-line-number="5283"></td>
        <td id="LC5283">            <span><span>//</span> determine first whether custom notifications for this type are enabled -- if not</span></td>
      </tr>
      <tr>
        <td id="L5284" data-line-number="5284"></td>
        <td id="LC5284">            <span><span>//</span> we just return without doing anything.</span></td>
      </tr>
      <tr>
        <td id="L5285" data-line-number="5285"></td>
        <td id="LC5285">            CordbClass * pNotificationClass = <span>LookupClass</span>(pAppDomain,</td>
      </tr>
      <tr>
        <td id="L5286" data-line-number="5286"></td>
        <td id="LC5286">                                                          pEvent-&gt;<span>CustomNotification</span>.<span>vmDomainFile</span>,</td>
      </tr>
      <tr>
        <td id="L5287" data-line-number="5287"></td>
        <td id="LC5287">                                                          pEvent-&gt;<span>CustomNotification</span>.<span>classToken</span>);</td>
      </tr>
      <tr>
        <td id="L5288" data-line-number="5288"></td>
        <td id="LC5288">
</td>
      </tr>
      <tr>
        <td id="L5289" data-line-number="5289"></td>
        <td id="LC5289">            <span><span>//</span> if the class is NULL, that means the debugger never enabled notifications for it. Otherwise,</span></td>
      </tr>
      <tr>
        <td id="L5290" data-line-number="5290"></td>
        <td id="LC5290">            <span><span>//</span> the CordbClass instance would already have been created when the notifications were</span></td>
      </tr>
      <tr>
        <td id="L5291" data-line-number="5291"></td>
        <td id="LC5291">            <span><span>//</span> enabled.</span></td>
      </tr>
      <tr>
        <td id="L5292" data-line-number="5292"></td>
        <td id="LC5292">            <span>if</span> ((pNotificationClass != <span>NULL</span>) &amp;&amp; pNotificationClass-&gt;<span>CustomNotificationsEnabled</span>())</td>
      </tr>
      <tr>
        <td id="L5293" data-line-number="5293"></td>
        <td id="LC5293">
</td>
      </tr>
      <tr>
        <td id="L5294" data-line-number="5294"></td>
        <td id="LC5294">            {</td>
      </tr>
      <tr>
        <td id="L5295" data-line-number="5295"></td>
        <td id="LC5295">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5296" data-line-number="5296"></td>
        <td id="LC5296">                pCallback3-&gt;<span>CustomNotification</span>(pThread, pAppDomain);</td>
      </tr>
      <tr>
        <td id="L5297" data-line-number="5297"></td>
        <td id="LC5297">            }</td>
      </tr>
      <tr>
        <td id="L5298" data-line-number="5298"></td>
        <td id="LC5298">        }</td>
      </tr>
      <tr>
        <td id="L5299" data-line-number="5299"></td>
        <td id="LC5299">
</td>
      </tr>
      <tr>
        <td id="L5300" data-line-number="5300"></td>
        <td id="LC5300">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5301" data-line-number="5301"></td>
        <td id="LC5301">
</td>
      </tr>
      <tr>
        <td id="L5302" data-line-number="5302"></td>
        <td id="LC5302">    <span>case</span> DB_IPCE_CREATE_APP_DOMAIN:</td>
      </tr>
      <tr>
        <td id="L5303" data-line-number="5303"></td>
        <td id="LC5303">        {</td>
      </tr>
      <tr>
        <td id="L5304" data-line-number="5304"></td>
        <td id="LC5304">            <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO100,</td>
      </tr>
      <tr>
        <td id="L5305" data-line-number="5305"></td>
        <td id="LC5305">                 <span><span>"</span>RCET::HRCE: create appdomain on thread %#x AD:0x%08x <span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5306" data-line-number="5306"></td>
        <td id="LC5306">                 dwVolatileThreadId,</td>
      </tr>
      <tr>
        <td id="L5307" data-line-number="5307"></td>
        <td id="LC5307">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>vmAppDomain</span>));</td>
      </tr>
      <tr>
        <td id="L5308" data-line-number="5308"></td>
        <td id="LC5308">
</td>
      </tr>
      <tr>
        <td id="L5309" data-line-number="5309"></td>
        <td id="LC5309">
</td>
      </tr>
      <tr>
        <td id="L5310" data-line-number="5310"></td>
        <td id="LC5310">            <span><span>//</span> Enumerate may have prepopulated the appdomain, so check if it already exists.</span></td>
      </tr>
      <tr>
        <td id="L5311" data-line-number="5311"></td>
        <td id="LC5311">            <span><span>//</span> Either way, still send the CreateEvent. (We don't want to skip the Create event</span></td>
      </tr>
      <tr>
        <td id="L5312" data-line-number="5312"></td>
        <td id="LC5312">            <span><span>//</span> just because the debugger did an enumerate)</span></td>
      </tr>
      <tr>
        <td id="L5313" data-line-number="5313"></td>
        <td id="LC5313">            <span><span>//</span> We remove AppDomains from the hash as soon as they are exited.</span></td>
      </tr>
      <tr>
        <td id="L5314" data-line-number="5314"></td>
        <td id="LC5314">            pAppDomain.<span>Assign</span>(<span>LookupOrCreateAppDomain</span>(pEvent-&gt;<span>AppDomainData</span>.<span>vmAppDomain</span>));</td>
      </tr>
      <tr>
        <td id="L5315" data-line-number="5315"></td>
        <td id="LC5315">            <span>_ASSERTE</span>(pAppDomain != <span>NULL</span>); <span><span>//</span> throws on failure</span></td>
      </tr>
      <tr>
        <td id="L5316" data-line-number="5316"></td>
        <td id="LC5316">
</td>
      </tr>
      <tr>
        <td id="L5317" data-line-number="5317"></td>
        <td id="LC5317">            {</td>
      </tr>
      <tr>
        <td id="L5318" data-line-number="5318"></td>
        <td id="LC5318">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5319" data-line-number="5319"></td>
        <td id="LC5319">                hr = pCallback1-&gt;<span>CreateAppDomain</span>(<span>this</span>, pAppDomain);</td>
      </tr>
      <tr>
        <td id="L5320" data-line-number="5320"></td>
        <td id="LC5320">            }</td>
      </tr>
      <tr>
        <td id="L5321" data-line-number="5321"></td>
        <td id="LC5321">        }</td>
      </tr>
      <tr>
        <td id="L5322" data-line-number="5322"></td>
        <td id="LC5322">
</td>
      </tr>
      <tr>
        <td id="L5323" data-line-number="5323"></td>
        <td id="LC5323">
</td>
      </tr>
      <tr>
        <td id="L5324" data-line-number="5324"></td>
        <td id="LC5324">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5325" data-line-number="5325"></td>
        <td id="LC5325">
</td>
      </tr>
      <tr>
        <td id="L5326" data-line-number="5326"></td>
        <td id="LC5326">    <span>case</span> DB_IPCE_EXIT_APP_DOMAIN:</td>
      </tr>
      <tr>
        <td id="L5327" data-line-number="5327"></td>
        <td id="LC5327">        {</td>
      </tr>
      <tr>
        <td id="L5328" data-line-number="5328"></td>
        <td id="LC5328">            <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO100, <span><span>"</span>RCET::HRCE: exit appdomain on thread %#x AD:0x%08x <span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5329" data-line-number="5329"></td>
        <td id="LC5329">                 dwVolatileThreadId,</td>
      </tr>
      <tr>
        <td id="L5330" data-line-number="5330"></td>
        <td id="LC5330">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>vmAppDomain</span>));</td>
      </tr>
      <tr>
        <td id="L5331" data-line-number="5331"></td>
        <td id="LC5331">
</td>
      </tr>
      <tr>
        <td id="L5332" data-line-number="5332"></td>
        <td id="LC5332">            <span><span>//</span> In debug-only builds, assert that the appdomain is indeed deleted and not discoverable.</span></td>
      </tr>
      <tr>
        <td id="L5333" data-line-number="5333"></td>
        <td id="LC5333">            <span>INDEBUG</span>(<span>DbgAssertAppDomainDeleted</span>(pEvent-&gt;<span>vmAppDomain</span>));</td>
      </tr>
      <tr>
        <td id="L5334" data-line-number="5334"></td>
        <td id="LC5334">
</td>
      </tr>
      <tr>
        <td id="L5335" data-line-number="5335"></td>
        <td id="LC5335">            <span><span>//</span> If we get an ExitAD message for which we have no AppDomain, then ignore it.</span></td>
      </tr>
      <tr>
        <td id="L5336" data-line-number="5336"></td>
        <td id="LC5336">            <span><span>//</span> This can happen if an AD gets torn down very early (before the LS AD is to the</span></td>
      </tr>
      <tr>
        <td id="L5337" data-line-number="5337"></td>
        <td id="LC5337">            <span><span>//</span> point that it can be published).</span></td>
      </tr>
      <tr>
        <td id="L5338" data-line-number="5338"></td>
        <td id="LC5338">            <span><span>//</span> This could also happen if we attach a debugger right before the Exit event is sent.</span></td>
      </tr>
      <tr>
        <td id="L5339" data-line-number="5339"></td>
        <td id="LC5339">            <span><span>//</span> In this case, the debuggee is no longer publishing the appdomain.</span></td>
      </tr>
      <tr>
        <td id="L5340" data-line-number="5340"></td>
        <td id="LC5340">            <span>if</span> (pAppDomain == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5341" data-line-number="5341"></td>
        <td id="LC5341">            {</td>
      </tr>
      <tr>
        <td id="L5342" data-line-number="5342"></td>
        <td id="LC5342">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5343" data-line-number="5343"></td>
        <td id="LC5343">            }</td>
      </tr>
      <tr>
        <td id="L5344" data-line-number="5344"></td>
        <td id="LC5344">            <span>_ASSERTE</span> (pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5345" data-line-number="5345"></td>
        <td id="LC5345">
</td>
      </tr>
      <tr>
        <td id="L5346" data-line-number="5346"></td>
        <td id="LC5346">            <span><span>//</span> See if this is the default AppDomain exiting.  This should only happen very late in</span></td>
      </tr>
      <tr>
        <td id="L5347" data-line-number="5347"></td>
        <td id="LC5347">            <span><span>//</span> the shutdown cycle, and so we shouldn't do anything significant with m_pDefaultDomain==NULL.</span></td>
      </tr>
      <tr>
        <td id="L5348" data-line-number="5348"></td>
        <td id="LC5348">            <span><span>//</span> We should try and remove m_pDefaultDomain entirely since we can't count on it always existing.</span></td>
      </tr>
      <tr>
        <td id="L5349" data-line-number="5349"></td>
        <td id="LC5349">            <span>if</span> (pAppDomain == m_pDefaultAppDomain)</td>
      </tr>
      <tr>
        <td id="L5350" data-line-number="5350"></td>
        <td id="LC5350">            {</td>
      </tr>
      <tr>
        <td id="L5351" data-line-number="5351"></td>
        <td id="LC5351">                m_pDefaultAppDomain = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L5352" data-line-number="5352"></td>
        <td id="LC5352">            }</td>
      </tr>
      <tr>
        <td id="L5353" data-line-number="5353"></td>
        <td id="LC5353">
</td>
      </tr>
      <tr>
        <td id="L5354" data-line-number="5354"></td>
        <td id="LC5354">            <span><span>//</span> Update any threads which were last seen in this AppDomain.  We don't</span></td>
      </tr>
      <tr>
        <td id="L5355" data-line-number="5355"></td>
        <td id="LC5355">            <span><span>//</span> get any notification when a thread leaves an AppDomain, so our idea</span></td>
      </tr>
      <tr>
        <td id="L5356" data-line-number="5356"></td>
        <td id="LC5356">            <span><span>//</span> of what AppDomain the thread is in may be out of date.</span></td>
      </tr>
      <tr>
        <td id="L5357" data-line-number="5357"></td>
        <td id="LC5357">            <span>UpdateThreadsForAdUnload</span>( pAppDomain );</td>
      </tr>
      <tr>
        <td id="L5358" data-line-number="5358"></td>
        <td id="LC5358">
</td>
      </tr>
      <tr>
        <td id="L5359" data-line-number="5359"></td>
        <td id="LC5359">            <span><span>//</span> This will still maintain weak references so we could call Continue.</span></td>
      </tr>
      <tr>
        <td id="L5360" data-line-number="5360"></td>
        <td id="LC5360">            <span>AddToNeuterOnContinueList</span>(pAppDomain);</td>
      </tr>
      <tr>
        <td id="L5361" data-line-number="5361"></td>
        <td id="LC5361">
</td>
      </tr>
      <tr>
        <td id="L5362" data-line-number="5362"></td>
        <td id="LC5362">            {</td>
      </tr>
      <tr>
        <td id="L5363" data-line-number="5363"></td>
        <td id="LC5363">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5364" data-line-number="5364"></td>
        <td id="LC5364">                hr = pCallback1-&gt;<span>ExitAppDomain</span>(<span>this</span>, pAppDomain);</td>
      </tr>
      <tr>
        <td id="L5365" data-line-number="5365"></td>
        <td id="LC5365">            }</td>
      </tr>
      <tr>
        <td id="L5366" data-line-number="5366"></td>
        <td id="LC5366">
</td>
      </tr>
      <tr>
        <td id="L5367" data-line-number="5367"></td>
        <td id="LC5367">            <span><span>//</span> @dbgtodo appdomain: This should occur before the callback.</span></td>
      </tr>
      <tr>
        <td id="L5368" data-line-number="5368"></td>
        <td id="LC5368">            <span><span>//</span> Even after ExitAppDomain, the outside world will want to continue calling</span></td>
      </tr>
      <tr>
        <td id="L5369" data-line-number="5369"></td>
        <td id="LC5369">            <span><span>//</span> Continue (and thus they may need to call CordbAppDomain::GetProcess(), which Neutering</span></td>
      </tr>
      <tr>
        <td id="L5370" data-line-number="5370"></td>
        <td id="LC5370">            <span><span>//</span> would clear). Thus we can't neuter yet.</span></td>
      </tr>
      <tr>
        <td id="L5371" data-line-number="5371"></td>
        <td id="LC5371">
</td>
      </tr>
      <tr>
        <td id="L5372" data-line-number="5372"></td>
        <td id="LC5372">            <span><span>//</span> Remove this app domain. This means any attempt to lookup the AppDomain</span></td>
      </tr>
      <tr>
        <td id="L5373" data-line-number="5373"></td>
        <td id="LC5373">            <span><span>//</span> will fail (which we do at the top of this method).  Since any threads (incorrectly) referring</span></td>
      </tr>
      <tr>
        <td id="L5374" data-line-number="5374"></td>
        <td id="LC5374">            <span><span>//</span> to this AppDomain have been moved to the default AppDomain, no one should be</span></td>
      </tr>
      <tr>
        <td id="L5375" data-line-number="5375"></td>
        <td id="LC5375">            <span><span>//</span> interested in looking this AppDomain up anymore.</span></td>
      </tr>
      <tr>
        <td id="L5376" data-line-number="5376"></td>
        <td id="LC5376">            m_appDomains.<span>RemoveBase</span>(<span>VmPtrToCookie</span>(pEvent-&gt;<span>vmAppDomain</span>));</td>
      </tr>
      <tr>
        <td id="L5377" data-line-number="5377"></td>
        <td id="LC5377">        }</td>
      </tr>
      <tr>
        <td id="L5378" data-line-number="5378"></td>
        <td id="LC5378">
</td>
      </tr>
      <tr>
        <td id="L5379" data-line-number="5379"></td>
        <td id="LC5379">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5380" data-line-number="5380"></td>
        <td id="LC5380">
</td>
      </tr>
      <tr>
        <td id="L5381" data-line-number="5381"></td>
        <td id="LC5381">    <span>case</span> DB_IPCE_LOAD_ASSEMBLY:</td>
      </tr>
      <tr>
        <td id="L5382" data-line-number="5382"></td>
        <td id="LC5382">        {</td>
      </tr>
      <tr>
        <td id="L5383" data-line-number="5383"></td>
        <td id="LC5383">            <span>LOG</span>((LF_CORDB, LL_INFO100,</td>
      </tr>
      <tr>
        <td id="L5384" data-line-number="5384"></td>
        <td id="LC5384">                <span><span>"</span>RCET::HRCE: load assembly on thread %#x Asm:0x%08x AD:0x%08x <span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5385" data-line-number="5385"></td>
        <td id="LC5385">                dwVolatileThreadId,</td>
      </tr>
      <tr>
        <td id="L5386" data-line-number="5386"></td>
        <td id="LC5386">                <span>VmPtrToCookie</span>(pEvent-&gt;<span>AssemblyData</span>.<span>vmDomainAssembly</span>),</td>
      </tr>
      <tr>
        <td id="L5387" data-line-number="5387"></td>
        <td id="LC5387">                <span>VmPtrToCookie</span>(pEvent-&gt;<span>vmAppDomain</span>)));</td>
      </tr>
      <tr>
        <td id="L5388" data-line-number="5388"></td>
        <td id="LC5388">
</td>
      </tr>
      <tr>
        <td id="L5389" data-line-number="5389"></td>
        <td id="LC5389">            <span>_ASSERTE</span> (pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5390" data-line-number="5390"></td>
        <td id="LC5390">
</td>
      </tr>
      <tr>
        <td id="L5391" data-line-number="5391"></td>
        <td id="LC5391">            <span><span>//</span> Determine if this Assembly is cached.</span></td>
      </tr>
      <tr>
        <td id="L5392" data-line-number="5392"></td>
        <td id="LC5392">            CordbAssembly * pAssembly = pAppDomain-&gt;<span>LookupOrCreateAssembly</span>(pEvent-&gt;<span>AssemblyData</span>.<span>vmDomainAssembly</span>);</td>
      </tr>
      <tr>
        <td id="L5393" data-line-number="5393"></td>
        <td id="LC5393">            <span>_ASSERTE</span>(pAssembly != <span>NULL</span>); <span><span>//</span> throws on error</span></td>
      </tr>
      <tr>
        <td id="L5394" data-line-number="5394"></td>
        <td id="LC5394">
</td>
      </tr>
      <tr>
        <td id="L5395" data-line-number="5395"></td>
        <td id="LC5395">            <span><span>//</span> If created, or have, an Assembly, notify callback.</span></td>
      </tr>
      <tr>
        <td id="L5396" data-line-number="5396"></td>
        <td id="LC5396">            {</td>
      </tr>
      <tr>
        <td id="L5397" data-line-number="5397"></td>
        <td id="LC5397">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5398" data-line-number="5398"></td>
        <td id="LC5398">                hr = pCallback1-&gt;<span>LoadAssembly</span>(pAppDomain, pAssembly);</td>
      </tr>
      <tr>
        <td id="L5399" data-line-number="5399"></td>
        <td id="LC5399">            }</td>
      </tr>
      <tr>
        <td id="L5400" data-line-number="5400"></td>
        <td id="LC5400">        }</td>
      </tr>
      <tr>
        <td id="L5401" data-line-number="5401"></td>
        <td id="LC5401">
</td>
      </tr>
      <tr>
        <td id="L5402" data-line-number="5402"></td>
        <td id="LC5402">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5403" data-line-number="5403"></td>
        <td id="LC5403">
</td>
      </tr>
      <tr>
        <td id="L5404" data-line-number="5404"></td>
        <td id="LC5404">    <span>case</span> DB_IPCE_UNLOAD_ASSEMBLY:</td>
      </tr>
      <tr>
        <td id="L5405" data-line-number="5405"></td>
        <td id="LC5405">        {</td>
      </tr>
      <tr>
        <td id="L5406" data-line-number="5406"></td>
        <td id="LC5406">            <span>LOG</span>((LF_CORDB, LL_INFO100, <span><span>"</span>RCET::DRCE: unload assembly on thread %#x Asm:0x%x AD:0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5407" data-line-number="5407"></td>
        <td id="LC5407">                 dwVolatileThreadId,</td>
      </tr>
      <tr>
        <td id="L5408" data-line-number="5408"></td>
        <td id="LC5408">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>AssemblyData</span>.<span>vmDomainAssembly</span>),</td>
      </tr>
      <tr>
        <td id="L5409" data-line-number="5409"></td>
        <td id="LC5409">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>vmAppDomain</span>)));</td>
      </tr>
      <tr>
        <td id="L5410" data-line-number="5410"></td>
        <td id="LC5410">
</td>
      </tr>
      <tr>
        <td id="L5411" data-line-number="5411"></td>
        <td id="LC5411">            <span>_ASSERTE</span> (pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5412" data-line-number="5412"></td>
        <td id="LC5412">
</td>
      </tr>
      <tr>
        <td id="L5413" data-line-number="5413"></td>
        <td id="LC5413">            CordbAssembly * pAssembly = pAppDomain-&gt;<span>LookupOrCreateAssembly</span>(pEvent-&gt;<span>AssemblyData</span>.<span>vmDomainAssembly</span>);</td>
      </tr>
      <tr>
        <td id="L5414" data-line-number="5414"></td>
        <td id="LC5414">
</td>
      </tr>
      <tr>
        <td id="L5415" data-line-number="5415"></td>
        <td id="LC5415">            <span>if</span> (pAssembly == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5416" data-line-number="5416"></td>
        <td id="LC5416">            {</td>
      </tr>
      <tr>
        <td id="L5417" data-line-number="5417"></td>
        <td id="LC5417">                <span><span>//</span> No assembly. This could happen if we attach right before an unload event is sent.</span></td>
      </tr>
      <tr>
        <td id="L5418" data-line-number="5418"></td>
        <td id="LC5418">                <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L5419" data-line-number="5419"></td>
        <td id="LC5419">            }</td>
      </tr>
      <tr>
        <td id="L5420" data-line-number="5420"></td>
        <td id="LC5420">           <span>_ASSERTE</span>(pAssembly != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5421" data-line-number="5421"></td>
        <td id="LC5421">           <span>INDEBUG</span>(pAssembly-&gt;<span>DbgAssertAssemblyDeleted</span>());</td>
      </tr>
      <tr>
        <td id="L5422" data-line-number="5422"></td>
        <td id="LC5422">
</td>
      </tr>
      <tr>
        <td id="L5423" data-line-number="5423"></td>
        <td id="LC5423">            <span><span>//</span> Ensure the assembly gets neutered when we call continue.</span></td>
      </tr>
      <tr>
        <td id="L5424" data-line-number="5424"></td>
        <td id="LC5424">            <span>AddToNeuterOnContinueList</span>(pAssembly); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L5425" data-line-number="5425"></td>
        <td id="LC5425">
</td>
      </tr>
      <tr>
        <td id="L5426" data-line-number="5426"></td>
        <td id="LC5426">            {</td>
      </tr>
      <tr>
        <td id="L5427" data-line-number="5427"></td>
        <td id="LC5427">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5428" data-line-number="5428"></td>
        <td id="LC5428">                hr = pCallback1-&gt;<span>UnloadAssembly</span>(pAppDomain, pAssembly);</td>
      </tr>
      <tr>
        <td id="L5429" data-line-number="5429"></td>
        <td id="LC5429">            }</td>
      </tr>
      <tr>
        <td id="L5430" data-line-number="5430"></td>
        <td id="LC5430">
</td>
      </tr>
      <tr>
        <td id="L5431" data-line-number="5431"></td>
        <td id="LC5431">            pAppDomain-&gt;<span>RemoveAssemblyFromCache</span>(pEvent-&gt;<span>AssemblyData</span>.<span>vmDomainAssembly</span>);</td>
      </tr>
      <tr>
        <td id="L5432" data-line-number="5432"></td>
        <td id="LC5432">        }</td>
      </tr>
      <tr>
        <td id="L5433" data-line-number="5433"></td>
        <td id="LC5433">
</td>
      </tr>
      <tr>
        <td id="L5434" data-line-number="5434"></td>
        <td id="LC5434">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5435" data-line-number="5435"></td>
        <td id="LC5435">
</td>
      </tr>
      <tr>
        <td id="L5436" data-line-number="5436"></td>
        <td id="LC5436">    <span>case</span> DB_IPCE_FUNC_EVAL_COMPLETE:</td>
      </tr>
      <tr>
        <td id="L5437" data-line-number="5437"></td>
        <td id="LC5437">        {</td>
      </tr>
      <tr>
        <td id="L5438" data-line-number="5438"></td>
        <td id="LC5438">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>RCET::DRCE: func eval complete.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L5439" data-line-number="5439"></td>
        <td id="LC5439">
</td>
      </tr>
      <tr>
        <td id="L5440" data-line-number="5440"></td>
        <td id="LC5440">            CordbEval *pEval = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L5441" data-line-number="5441"></td>
        <td id="LC5441">            {</td>
      </tr>
      <tr>
        <td id="L5442" data-line-number="5442"></td>
        <td id="LC5442">                pEval = pEvent-&gt;<span>FuncEvalComplete</span>.<span>funcEvalKey</span>.<span>UnWrapAndRemove</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L5443" data-line-number="5443"></td>
        <td id="LC5443">                <span>if</span> (pEval  == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5444" data-line-number="5444"></td>
        <td id="LC5444">                {</td>
      </tr>
      <tr>
        <td id="L5445" data-line-number="5445"></td>
        <td id="LC5445">                    <span>_ASSERTE</span>(!<span><span>"</span>Bogus FuncEval handle in IPC block.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L5446" data-line-number="5446"></td>
        <td id="LC5446">                    <span><span>//</span> Bogus handle in IPC block.</span></td>
      </tr>
      <tr>
        <td id="L5447" data-line-number="5447"></td>
        <td id="LC5447">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5448" data-line-number="5448"></td>
        <td id="LC5448">                }</td>
      </tr>
      <tr>
        <td id="L5449" data-line-number="5449"></td>
        <td id="LC5449">            }</td>
      </tr>
      <tr>
        <td id="L5450" data-line-number="5450"></td>
        <td id="LC5450">            <span>_ASSERTE</span>(pEval != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5451" data-line-number="5451"></td>
        <td id="LC5451">
</td>
      </tr>
      <tr>
        <td id="L5452" data-line-number="5452"></td>
        <td id="LC5452">            <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5453" data-line-number="5453"></td>
        <td id="LC5453">            <span>_ASSERTE</span>(pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5454" data-line-number="5454"></td>
        <td id="LC5454">
</td>
      </tr>
      <tr>
        <td id="L5455" data-line-number="5455"></td>
        <td id="LC5455">            <span>CONSISTENCY_CHECK_MSGF</span>(pEval-&gt;<span>m_DbgAppDomainStarted</span> == pAppDomain,</td>
      </tr>
      <tr>
        <td id="L5456" data-line-number="5456"></td>
        <td id="LC5456">                (<span><span>"</span>AppDomain changed from Func-Eval. Eval=%p, Started=%p, Now=%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5457" data-line-number="5457"></td>
        <td id="LC5457">                pEval, pEval-&gt;<span>m_DbgAppDomainStarted</span>, (<span>void</span>*) pAppDomain));</td>
      </tr>
      <tr>
        <td id="L5458" data-line-number="5458"></td>
        <td id="LC5458">
</td>
      </tr>
      <tr>
        <td id="L5459" data-line-number="5459"></td>
        <td id="LC5459">            <span><span>//</span> Hold the data about the result in the CordbEval for later.</span></td>
      </tr>
      <tr>
        <td id="L5460" data-line-number="5460"></td>
        <td id="LC5460">            pEval-&gt;<span>m_complete</span>       = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L5461" data-line-number="5461"></td>
        <td id="LC5461">            pEval-&gt;<span>m_successful</span>     = !!pEvent-&gt;<span>FuncEvalComplete</span>.<span>successful</span>;</td>
      </tr>
      <tr>
        <td id="L5462" data-line-number="5462"></td>
        <td id="LC5462">            pEval-&gt;<span>m_aborted</span>        = !!pEvent-&gt;<span>FuncEvalComplete</span>.<span>aborted</span>;</td>
      </tr>
      <tr>
        <td id="L5463" data-line-number="5463"></td>
        <td id="LC5463">            pEval-&gt;<span>m_resultAddr</span>     = pEvent-&gt;<span>FuncEvalComplete</span>.<span>resultAddr</span>;</td>
      </tr>
      <tr>
        <td id="L5464" data-line-number="5464"></td>
        <td id="LC5464">            pEval-&gt;<span>m_vmObjectHandle</span> = pEvent-&gt;<span>FuncEvalComplete</span>.<span>vmObjectHandle</span>;</td>
      </tr>
      <tr>
        <td id="L5465" data-line-number="5465"></td>
        <td id="LC5465">            pEval-&gt;<span>m_resultType</span>     = pEvent-&gt;<span>FuncEvalComplete</span>.<span>resultType</span>;</td>
      </tr>
      <tr>
        <td id="L5466" data-line-number="5466"></td>
        <td id="LC5466">            pEval-&gt;<span>m_resultAppDomainToken</span> = pEvent-&gt;<span>FuncEvalComplete</span>.<span>vmAppDomain</span>;</td>
      </tr>
      <tr>
        <td id="L5467" data-line-number="5467"></td>
        <td id="LC5467">
</td>
      </tr>
      <tr>
        <td id="L5468" data-line-number="5468"></td>
        <td id="LC5468">            CordbAppDomain *pResultAppDomain = <span>LookupOrCreateAppDomain</span>(pEvent-&gt;<span>FuncEvalComplete</span>.<span>vmAppDomain</span>);</td>
      </tr>
      <tr>
        <td id="L5469" data-line-number="5469"></td>
        <td id="LC5469">
</td>
      </tr>
      <tr>
        <td id="L5470" data-line-number="5470"></td>
        <td id="LC5470">            <span>_ASSERTE</span>(<span>OutstandingEvalCount</span>() &gt; <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L5471" data-line-number="5471"></td>
        <td id="LC5471">            <span>DecrementOutstandingEvalCount</span>();</td>
      </tr>
      <tr>
        <td id="L5472" data-line-number="5472"></td>
        <td id="LC5472">
</td>
      </tr>
      <tr>
        <td id="L5473" data-line-number="5473"></td>
        <td id="LC5473">            <span>CONSISTENCY_CHECK_MSGF</span>(pEval-&gt;<span>m_DbgAppDomainStarted</span> == pAppDomain,</td>
      </tr>
      <tr>
        <td id="L5474" data-line-number="5474"></td>
        <td id="LC5474">                (<span><span>"</span>AppDomain changed from Func-Eval. Eval=%p, Started=%p, Now=%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5475" data-line-number="5475"></td>
        <td id="LC5475">                pEval, pEval-&gt;<span>m_DbgAppDomainStarted</span>, (<span>void</span>*) pAppDomain));</td>
      </tr>
      <tr>
        <td id="L5476" data-line-number="5476"></td>
        <td id="LC5476">
</td>
      </tr>
      <tr>
        <td id="L5477" data-line-number="5477"></td>
        <td id="LC5477">            <span><span>//</span> If we did this func eval with this thread stopped at an excpetion, then we need to pretend as if we</span></td>
      </tr>
      <tr>
        <td id="L5478" data-line-number="5478"></td>
        <td id="LC5478">            <span><span>//</span> really didn't continue from the exception, since, of course, we really didn't on the Left Side.</span></td>
      </tr>
      <tr>
        <td id="L5479" data-line-number="5479"></td>
        <td id="LC5479">            <span>if</span> (pEval-&gt;<span>IsEvalDuringException</span>())</td>
      </tr>
      <tr>
        <td id="L5480" data-line-number="5480"></td>
        <td id="LC5480">            {</td>
      </tr>
      <tr>
        <td id="L5481" data-line-number="5481"></td>
        <td id="LC5481">                pThread-&gt;<span>SetExInfo</span>(pEval-&gt;<span>m_vmThreadOldExceptionHandle</span>);</td>
      </tr>
      <tr>
        <td id="L5482" data-line-number="5482"></td>
        <td id="LC5482">            }</td>
      </tr>
      <tr>
        <td id="L5483" data-line-number="5483"></td>
        <td id="LC5483">
</td>
      </tr>
      <tr>
        <td id="L5484" data-line-number="5484"></td>
        <td id="LC5484">            <span>bool</span> <span>fEvalCompleted</span> = pEval-&gt;<span>m_successful</span> || pEval-&gt;<span>m_aborted</span>;</td>
      </tr>
      <tr>
        <td id="L5485" data-line-number="5485"></td>
        <td id="LC5485">
</td>
      </tr>
      <tr>
        <td id="L5486" data-line-number="5486"></td>
        <td id="LC5486">            <span><span>//</span> If a CallFunction() is aborted, the LHS may not complete the abort</span></td>
      </tr>
      <tr>
        <td id="L5487" data-line-number="5487"></td>
        <td id="LC5487">            <span><span>//</span> immediately and hence we cant do a SendCleanup() at that point. Also,</span></td>
      </tr>
      <tr>
        <td id="L5488" data-line-number="5488"></td>
        <td id="LC5488">            <span><span>//</span> the debugger may (incorrectly) release the CordbEval before this</span></td>
      </tr>
      <tr>
        <td id="L5489" data-line-number="5489"></td>
        <td id="LC5489">            <span><span>//</span> DB_IPCE_FUNC_EVAL_COMPLETE event is received. Hence, we maintain an</span></td>
      </tr>
      <tr>
        <td id="L5490" data-line-number="5490"></td>
        <td id="LC5490">            <span><span>//</span> extra ref-count to determine when this can be done.</span></td>
      </tr>
      <tr>
        <td id="L5491" data-line-number="5491"></td>
        <td id="LC5491">            <span><span>//</span> Note that this can cause a two-way DB_IPCE_FUNC_EVAL_CLEANUP event</span></td>
      </tr>
      <tr>
        <td id="L5492" data-line-number="5492"></td>
        <td id="LC5492">            <span><span>//</span> to be sent. Hence, it has to be done before the Continue (see issue 102745).</span></td>
      </tr>
      <tr>
        <td id="L5493" data-line-number="5493"></td>
        <td id="LC5493">
</td>
      </tr>
      <tr>
        <td id="L5494" data-line-number="5494"></td>
        <td id="LC5494">
</td>
      </tr>
      <tr>
        <td id="L5495" data-line-number="5495"></td>
        <td id="LC5495">            <span><span>//</span> Note that if the debugger has already (incorrectly) released the CordbEval,</span></td>
      </tr>
      <tr>
        <td id="L5496" data-line-number="5496"></td>
        <td id="LC5496">            <span><span>//</span> pEval will be pointing to garbage and should not be used by the debugger.</span></td>
      </tr>
      <tr>
        <td id="L5497" data-line-number="5497"></td>
        <td id="LC5497">            <span>if</span> (<span>fEvalCompleted</span>)</td>
      </tr>
      <tr>
        <td id="L5498" data-line-number="5498"></td>
        <td id="LC5498">            {</td>
      </tr>
      <tr>
        <td id="L5499" data-line-number="5499"></td>
        <td id="LC5499">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE2</span>(<span>this</span>, pLockHolder, pEvent, <span><span>"</span>thread=0x%p, eval=0x%p. (Complete)<span>"</span></span>, pThread, pEval);</td>
      </tr>
      <tr>
        <td id="L5500" data-line-number="5500"></td>
        <td id="LC5500">                pCallback1-&gt;<span>EvalComplete</span>(pResultAppDomain, pThread, pEval);</td>
      </tr>
      <tr>
        <td id="L5501" data-line-number="5501"></td>
        <td id="LC5501">            }</td>
      </tr>
      <tr>
        <td id="L5502" data-line-number="5502"></td>
        <td id="LC5502">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L5503" data-line-number="5503"></td>
        <td id="LC5503">            {</td>
      </tr>
      <tr>
        <td id="L5504" data-line-number="5504"></td>
        <td id="LC5504">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE2</span>(<span>this</span>, pLockHolder, pEvent, <span><span>"</span>pThread=0x%p, eval=0x%p. (Exception)<span>"</span></span>, pThread, pEval);</td>
      </tr>
      <tr>
        <td id="L5505" data-line-number="5505"></td>
        <td id="LC5505">                pCallback1-&gt;<span>EvalException</span>(pResultAppDomain, pThread, pEval);</td>
      </tr>
      <tr>
        <td id="L5506" data-line-number="5506"></td>
        <td id="LC5506">            }</td>
      </tr>
      <tr>
        <td id="L5507" data-line-number="5507"></td>
        <td id="LC5507">
</td>
      </tr>
      <tr>
        <td id="L5508" data-line-number="5508"></td>
        <td id="LC5508">            <span><span>//</span> This release may send an DB_IPCE_FUNC_EVAL_CLEANUP IPC event. That's ok b/c</span></td>
      </tr>
      <tr>
        <td id="L5509" data-line-number="5509"></td>
        <td id="LC5509">            <span><span>//</span> we're still synced even if if Continue was called inside the callback.</span></td>
      </tr>
      <tr>
        <td id="L5510" data-line-number="5510"></td>
        <td id="LC5510">            <span><span>//</span> That's because the StopContinueHolder bumped up the stopcount.</span></td>
      </tr>
      <tr>
        <td id="L5511" data-line-number="5511"></td>
        <td id="LC5511">            <span><span>//</span> Corresponding AddRef() in CallFunction().</span></td>
      </tr>
      <tr>
        <td id="L5512" data-line-number="5512"></td>
        <td id="LC5512">            <span><span>//</span> @todo - this is leaked if we don't get an EvalComplete event (eg, process exits with</span></td>
      </tr>
      <tr>
        <td id="L5513" data-line-number="5513"></td>
        <td id="LC5513">            <span><span>//</span> in middle of func-eval).</span></td>
      </tr>
      <tr>
        <td id="L5514" data-line-number="5514"></td>
        <td id="LC5514">            pEval-&gt;<span>Release</span>();</td>
      </tr>
      <tr>
        <td id="L5515" data-line-number="5515"></td>
        <td id="LC5515">        }</td>
      </tr>
      <tr>
        <td id="L5516" data-line-number="5516"></td>
        <td id="LC5516">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5517" data-line-number="5517"></td>
        <td id="LC5517">
</td>
      </tr>
      <tr>
        <td id="L5518" data-line-number="5518"></td>
        <td id="LC5518">
</td>
      </tr>
      <tr>
        <td id="L5519" data-line-number="5519"></td>
        <td id="LC5519">    <span>case</span> DB_IPCE_NAME_CHANGE:</td>
      </tr>
      <tr>
        <td id="L5520" data-line-number="5520"></td>
        <td id="LC5520">        {</td>
      </tr>
      <tr>
        <td id="L5521" data-line-number="5521"></td>
        <td id="LC5521">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>RCET::HRCE: Name Change %d  0x%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5522" data-line-number="5522"></td>
        <td id="LC5522">                 dwVolatileThreadId,</td>
      </tr>
      <tr>
        <td id="L5523" data-line-number="5523"></td>
        <td id="LC5523">                 <span>VmPtrToCookie</span>(pEvent-&gt;<span>NameChange</span>.<span>vmAppDomain</span>)));</td>
      </tr>
      <tr>
        <td id="L5524" data-line-number="5524"></td>
        <td id="LC5524">
</td>
      </tr>
      <tr>
        <td id="L5525" data-line-number="5525"></td>
        <td id="LC5525">            pThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L5526" data-line-number="5526"></td>
        <td id="LC5526">            pAppDomain.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L5527" data-line-number="5527"></td>
        <td id="LC5527">            <span>if</span> (pEvent-&gt;<span>NameChange</span>.<span>eventType</span> == THREAD_NAME_CHANGE)</td>
      </tr>
      <tr>
        <td id="L5528" data-line-number="5528"></td>
        <td id="LC5528">            {</td>
      </tr>
      <tr>
        <td id="L5529" data-line-number="5529"></td>
        <td id="LC5529">                <span><span>//</span> Lookup the CordbThread that matches this runtime thread.</span></td>
      </tr>
      <tr>
        <td id="L5530" data-line-number="5530"></td>
        <td id="LC5530">                <span>if</span> (!pEvent-&gt;<span>NameChange</span>.<span>vmThread</span>.<span>IsNull</span>())</td>
      </tr>
      <tr>
        <td id="L5531" data-line-number="5531"></td>
        <td id="LC5531">                {</td>
      </tr>
      <tr>
        <td id="L5532" data-line-number="5532"></td>
        <td id="LC5532">                    pThread = <span>LookupOrCreateThread</span>(pEvent-&gt;<span>NameChange</span>.<span>vmThread</span>);</td>
      </tr>
      <tr>
        <td id="L5533" data-line-number="5533"></td>
        <td id="LC5533">                }</td>
      </tr>
      <tr>
        <td id="L5534" data-line-number="5534"></td>
        <td id="LC5534">            }</td>
      </tr>
      <tr>
        <td id="L5535" data-line-number="5535"></td>
        <td id="LC5535">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L5536" data-line-number="5536"></td>
        <td id="LC5536">            {</td>
      </tr>
      <tr>
        <td id="L5537" data-line-number="5537"></td>
        <td id="LC5537">                <span>_ASSERTE</span> (pEvent-&gt;<span>NameChange</span>.<span>eventType</span> == APP_DOMAIN_NAME_CHANGE);</td>
      </tr>
      <tr>
        <td id="L5538" data-line-number="5538"></td>
        <td id="LC5538">                pAppDomain.<span>Assign</span>(<span>LookupOrCreateAppDomain</span>(pEvent-&gt;<span>NameChange</span>.<span>vmAppDomain</span>));</td>
      </tr>
      <tr>
        <td id="L5539" data-line-number="5539"></td>
        <td id="LC5539">                <span>if</span> (pAppDomain)</td>
      </tr>
      <tr>
        <td id="L5540" data-line-number="5540"></td>
        <td id="LC5540">                {</td>
      </tr>
      <tr>
        <td id="L5541" data-line-number="5541"></td>
        <td id="LC5541">                    pAppDomain-&gt;<span>InvalidateName</span>();</td>
      </tr>
      <tr>
        <td id="L5542" data-line-number="5542"></td>
        <td id="LC5542">                }</td>
      </tr>
      <tr>
        <td id="L5543" data-line-number="5543"></td>
        <td id="LC5543">            }</td>
      </tr>
      <tr>
        <td id="L5544" data-line-number="5544"></td>
        <td id="LC5544">
</td>
      </tr>
      <tr>
        <td id="L5545" data-line-number="5545"></td>
        <td id="LC5545">            <span>if</span> (pThread || pAppDomain)</td>
      </tr>
      <tr>
        <td id="L5546" data-line-number="5546"></td>
        <td id="LC5546">            {</td>
      </tr>
      <tr>
        <td id="L5547" data-line-number="5547"></td>
        <td id="LC5547">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5548" data-line-number="5548"></td>
        <td id="LC5548">                pCallback1-&gt;<span>NameChange</span>(pAppDomain, pThread);</td>
      </tr>
      <tr>
        <td id="L5549" data-line-number="5549"></td>
        <td id="LC5549">            }</td>
      </tr>
      <tr>
        <td id="L5550" data-line-number="5550"></td>
        <td id="LC5550">        }</td>
      </tr>
      <tr>
        <td id="L5551" data-line-number="5551"></td>
        <td id="LC5551">
</td>
      </tr>
      <tr>
        <td id="L5552" data-line-number="5552"></td>
        <td id="LC5552">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5553" data-line-number="5553"></td>
        <td id="LC5553">
</td>
      </tr>
      <tr>
        <td id="L5554" data-line-number="5554"></td>
        <td id="LC5554">    <span>case</span> DB_IPCE_UPDATE_MODULE_SYMS:</td>
      </tr>
      <tr>
        <td id="L5555" data-line-number="5555"></td>
        <td id="LC5555">        {</td>
      </tr>
      <tr>
        <td id="L5556" data-line-number="5556"></td>
        <td id="LC5556">            RSExtSmartPtr&lt;IStream&gt; pStream;</td>
      </tr>
      <tr>
        <td id="L5557" data-line-number="5557"></td>
        <td id="LC5557">
</td>
      </tr>
      <tr>
        <td id="L5558" data-line-number="5558"></td>
        <td id="LC5558">            <span><span>//</span> Find the app domain the module lives in.</span></td>
      </tr>
      <tr>
        <td id="L5559" data-line-number="5559"></td>
        <td id="LC5559">            <span>_ASSERTE</span> (pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5560" data-line-number="5560"></td>
        <td id="LC5560">
</td>
      </tr>
      <tr>
        <td id="L5561" data-line-number="5561"></td>
        <td id="LC5561">            <span><span>//</span> Find the Right Side module for this module.</span></td>
      </tr>
      <tr>
        <td id="L5562" data-line-number="5562"></td>
        <td id="LC5562">            CordbModule * pModule = pAppDomain-&gt;<span>LookupOrCreateModule</span>(pEvent-&gt;<span>UpdateModuleSymsData</span>.<span>vmDomainFile</span>);</td>
      </tr>
      <tr>
        <td id="L5563" data-line-number="5563"></td>
        <td id="LC5563">            <span>_ASSERTE</span>(pModule != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5564" data-line-number="5564"></td>
        <td id="LC5564">
</td>
      </tr>
      <tr>
        <td id="L5565" data-line-number="5565"></td>
        <td id="LC5565">            <span><span>//</span> This is a legacy event notification for updated PDBs.</span></td>
      </tr>
      <tr>
        <td id="L5566" data-line-number="5566"></td>
        <td id="LC5566">            <span><span>//</span> Creates a new IStream object. Ownership is handed off via callback.</span></td>
      </tr>
      <tr>
        <td id="L5567" data-line-number="5567"></td>
        <td id="LC5567">            IDacDbiInterface::SymbolFormat symFormat = pModule-&gt;<span>GetInMemorySymbolStream</span>(&amp;pStream);</td>
      </tr>
      <tr>
        <td id="L5568" data-line-number="5568"></td>
        <td id="LC5568">
</td>
      </tr>
      <tr>
        <td id="L5569" data-line-number="5569"></td>
        <td id="LC5569">            <span><span>//</span> We shouldn't get this event if there aren't PDB symbols waiting.  Specifically we don't want</span></td>
      </tr>
      <tr>
        <td id="L5570" data-line-number="5570"></td>
        <td id="LC5570">            <span><span>//</span> to incur the cost of copying over ILDB symbols here without the debugger asking for them.</span></td>
      </tr>
      <tr>
        <td id="L5571" data-line-number="5571"></td>
        <td id="LC5571">            <span><span>//</span> Eventually we may remove this callback as well and always rely on explicit requests.</span></td>
      </tr>
      <tr>
        <td id="L5572" data-line-number="5572"></td>
        <td id="LC5572">            <span>_ASSERTE</span>(symFormat == IDacDbiInterface::<span>kSymbolFormatPDB</span>);</td>
      </tr>
      <tr>
        <td id="L5573" data-line-number="5573"></td>
        <td id="LC5573">
</td>
      </tr>
      <tr>
        <td id="L5574" data-line-number="5574"></td>
        <td id="LC5574">            <span>if</span> (symFormat == IDacDbiInterface::<span>kSymbolFormatPDB</span>)</td>
      </tr>
      <tr>
        <td id="L5575" data-line-number="5575"></td>
        <td id="LC5575">            {</td>
      </tr>
      <tr>
        <td id="L5576" data-line-number="5576"></td>
        <td id="LC5576">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5577" data-line-number="5577"></td>
        <td id="LC5577">
</td>
      </tr>
      <tr>
        <td id="L5578" data-line-number="5578"></td>
        <td id="LC5578">                <span>_ASSERTE</span>(pStream != <span>NULL</span>); <span><span>//</span> Shouldn't send the event if we don't have a stream.</span></td>
      </tr>
      <tr>
        <td id="L5579" data-line-number="5579"></td>
        <td id="LC5579">
</td>
      </tr>
      <tr>
        <td id="L5580" data-line-number="5580"></td>
        <td id="LC5580">                pCallback1-&gt;<span>UpdateModuleSymbols</span>(pAppDomain, pModule, pStream);</td>
      </tr>
      <tr>
        <td id="L5581" data-line-number="5581"></td>
        <td id="LC5581">            }</td>
      </tr>
      <tr>
        <td id="L5582" data-line-number="5582"></td>
        <td id="LC5582">
</td>
      </tr>
      <tr>
        <td id="L5583" data-line-number="5583"></td>
        <td id="LC5583">        }</td>
      </tr>
      <tr>
        <td id="L5584" data-line-number="5584"></td>
        <td id="LC5584">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5585" data-line-number="5585"></td>
        <td id="LC5585">
</td>
      </tr>
      <tr>
        <td id="L5586" data-line-number="5586"></td>
        <td id="LC5586">    <span>case</span> DB_IPCE_MDA_NOTIFICATION:</td>
      </tr>
      <tr>
        <td id="L5587" data-line-number="5587"></td>
        <td id="LC5587">        {</td>
      </tr>
      <tr>
        <td id="L5588" data-line-number="5588"></td>
        <td id="LC5588">            RSInitHolder&lt;CordbMDA&gt; <span>pMDA</span>(<span>new</span> <span>CordbMDA</span>(<span>this</span>, &amp;pEvent-&gt;<span>MDANotification</span>)); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L5589" data-line-number="5589"></td>
        <td id="LC5589">
</td>
      </tr>
      <tr>
        <td id="L5590" data-line-number="5590"></td>
        <td id="LC5590">            <span><span>//</span> Ctor leaves both internal + ext Ref at 0, adding to neuter list bumps int-ref up to 1.</span></td>
      </tr>
      <tr>
        <td id="L5591" data-line-number="5591"></td>
        <td id="LC5591">            <span><span>//</span> Neutering will dump it back down to zero.</span></td>
      </tr>
      <tr>
        <td id="L5592" data-line-number="5592"></td>
        <td id="LC5592">            <span>this</span>-&gt;<span>AddToNeuterOnExitList</span>(pMDA);</td>
      </tr>
      <tr>
        <td id="L5593" data-line-number="5593"></td>
        <td id="LC5593">
</td>
      </tr>
      <tr>
        <td id="L5594" data-line-number="5594"></td>
        <td id="LC5594">            <span><span>//</span> We bump up and down the external ref so that even if the callback doensn't touch the refs,</span></td>
      </tr>
      <tr>
        <td id="L5595" data-line-number="5595"></td>
        <td id="LC5595">            <span><span>//</span> our Ext-Release here will still cause a 1-&gt;0 ext-ref transition, which will get it</span></td>
      </tr>
      <tr>
        <td id="L5596" data-line-number="5596"></td>
        <td id="LC5596">            <span><span>//</span> swept on the neuter list.</span></td>
      </tr>
      <tr>
        <td id="L5597" data-line-number="5597"></td>
        <td id="LC5597">            RSExtSmartPtr&lt;ICorDebugMDA&gt; pExternalMDARef;</td>
      </tr>
      <tr>
        <td id="L5598" data-line-number="5598"></td>
        <td id="LC5598">            pMDA.<span>TransferOwnershipExternal</span>(&amp;pExternalMDARef);</td>
      </tr>
      <tr>
        <td id="L5599" data-line-number="5599"></td>
        <td id="LC5599">            {</td>
      </tr>
      <tr>
        <td id="L5600" data-line-number="5600"></td>
        <td id="LC5600">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5601" data-line-number="5601"></td>
        <td id="LC5601">
</td>
      </tr>
      <tr>
        <td id="L5602" data-line-number="5602"></td>
        <td id="LC5602">                pCallback2-&gt;<span>MDANotification</span>(</td>
      </tr>
      <tr>
        <td id="L5603" data-line-number="5603"></td>
        <td id="LC5603">                    <span>this</span>,</td>
      </tr>
      <tr>
        <td id="L5604" data-line-number="5604"></td>
        <td id="LC5604">                    pThread, <span><span>//</span> may be null</span></td>
      </tr>
      <tr>
        <td id="L5605" data-line-number="5605"></td>
        <td id="LC5605">                    pExternalMDARef);</td>
      </tr>
      <tr>
        <td id="L5606" data-line-number="5606"></td>
        <td id="LC5606">
</td>
      </tr>
      <tr>
        <td id="L5607" data-line-number="5607"></td>
        <td id="LC5607">                <span><span>//</span> pExternalMDARef's dtor will do an external release,</span></td>
      </tr>
      <tr>
        <td id="L5608" data-line-number="5608"></td>
        <td id="LC5608">                <span><span>//</span> which is very significant because it may be the one that does the 1-&gt;0 ext ref transition,</span></td>
      </tr>
      <tr>
        <td id="L5609" data-line-number="5609"></td>
        <td id="LC5609">                <span><span>//</span> which may mean cause the "NeuterAtWill" bit to get flipped on this CordbMDA object.</span></td>
      </tr>
      <tr>
        <td id="L5610" data-line-number="5610"></td>
        <td id="LC5610">                <span><span>//</span> Since this is an external release, do it in the PUBLIC_CALLBACK scope.</span></td>
      </tr>
      <tr>
        <td id="L5611" data-line-number="5611"></td>
        <td id="LC5611">                pExternalMDARef.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L5612" data-line-number="5612"></td>
        <td id="LC5612">            }</td>
      </tr>
      <tr>
        <td id="L5613" data-line-number="5613"></td>
        <td id="LC5613">
</td>
      </tr>
      <tr>
        <td id="L5614" data-line-number="5614"></td>
        <td id="LC5614">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5615" data-line-number="5615"></td>
        <td id="LC5615">        }</td>
      </tr>
      <tr>
        <td id="L5616" data-line-number="5616"></td>
        <td id="LC5616">
</td>
      </tr>
      <tr>
        <td id="L5617" data-line-number="5617"></td>
        <td id="LC5617">    <span>case</span> DB_IPCE_CONTROL_C_EVENT:</td>
      </tr>
      <tr>
        <td id="L5618" data-line-number="5618"></td>
        <td id="LC5618">        {</td>
      </tr>
      <tr>
        <td id="L5619" data-line-number="5619"></td>
        <td id="LC5619">            hr = S_FALSE;</td>
      </tr>
      <tr>
        <td id="L5620" data-line-number="5620"></td>
        <td id="LC5620">
</td>
      </tr>
      <tr>
        <td id="L5621" data-line-number="5621"></td>
        <td id="LC5621">            {</td>
      </tr>
      <tr>
        <td id="L5622" data-line-number="5622"></td>
        <td id="LC5622">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5623" data-line-number="5623"></td>
        <td id="LC5623">                hr = pCallback1-&gt;<span>ControlCTrap</span>((ICorDebugProcess*) <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L5624" data-line-number="5624"></td>
        <td id="LC5624">            }</td>
      </tr>
      <tr>
        <td id="L5625" data-line-number="5625"></td>
        <td id="LC5625">        }</td>
      </tr>
      <tr>
        <td id="L5626" data-line-number="5626"></td>
        <td id="LC5626">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5627" data-line-number="5627"></td>
        <td id="LC5627">
</td>
      </tr>
      <tr>
        <td id="L5628" data-line-number="5628"></td>
        <td id="LC5628">        <span><span>//</span> EnC Remap opportunity</span></td>
      </tr>
      <tr>
        <td id="L5629" data-line-number="5629"></td>
        <td id="LC5629">        <span>case</span> DB_IPCE_ENC_REMAP:</td>
      </tr>
      <tr>
        <td id="L5630" data-line-number="5630"></td>
        <td id="LC5630">        {</td>
      </tr>
      <tr>
        <td id="L5631" data-line-number="5631"></td>
        <td id="LC5631">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] RCET::DRCE: EnC Remap!.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5632" data-line-number="5632"></td>
        <td id="LC5632">                 <span>GetCurrentThreadId</span>()));</td>
      </tr>
      <tr>
        <td id="L5633" data-line-number="5633"></td>
        <td id="LC5633">
</td>
      </tr>
      <tr>
        <td id="L5634" data-line-number="5634"></td>
        <td id="LC5634">            <span>_ASSERTE</span>(<span>NULL</span> != pAppDomain);</td>
      </tr>
      <tr>
        <td id="L5635" data-line-number="5635"></td>
        <td id="LC5635">
</td>
      </tr>
      <tr>
        <td id="L5636" data-line-number="5636"></td>
        <td id="LC5636">            CordbModule * pModule = pAppDomain-&gt;<span>LookupOrCreateModule</span>(pEvent-&gt;<span>EnCRemap</span>.<span>vmDomainFile</span>);</td>
      </tr>
      <tr>
        <td id="L5637" data-line-number="5637"></td>
        <td id="LC5637">            <span>PREFIX_ASSUME</span>(pModule != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5638" data-line-number="5638"></td>
        <td id="LC5638">
</td>
      </tr>
      <tr>
        <td id="L5639" data-line-number="5639"></td>
        <td id="LC5639">            CordbFunction * pCurFunction    = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L5640" data-line-number="5640"></td>
        <td id="LC5640">            CordbFunction * pResumeFunction = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L5641" data-line-number="5641"></td>
        <td id="LC5641">
</td>
      </tr>
      <tr>
        <td id="L5642" data-line-number="5642"></td>
        <td id="LC5642">            <span><span>//</span> lookup the version of the function that we are mapping from</span></td>
      </tr>
      <tr>
        <td id="L5643" data-line-number="5643"></td>
        <td id="LC5643">            <span><span>//</span> this is the one that is currently running</span></td>
      </tr>
      <tr>
        <td id="L5644" data-line-number="5644"></td>
        <td id="LC5644">            pCurFunction = pModule-&gt;<span>LookupOrCreateFunction</span>(</td>
      </tr>
      <tr>
        <td id="L5645" data-line-number="5645"></td>
        <td id="LC5645">                pEvent-&gt;<span>EnCRemap</span>.<span>funcMetadataToken</span>, pEvent-&gt;<span>EnCRemap</span>.<span>currentVersionNumber</span>);</td>
      </tr>
      <tr>
        <td id="L5646" data-line-number="5646"></td>
        <td id="LC5646">
</td>
      </tr>
      <tr>
        <td id="L5647" data-line-number="5647"></td>
        <td id="LC5647">            <span><span>//</span> lookup the version of the function that we are mapping to</span></td>
      </tr>
      <tr>
        <td id="L5648" data-line-number="5648"></td>
        <td id="LC5648">            <span><span>//</span> it will always be the most recent</span></td>
      </tr>
      <tr>
        <td id="L5649" data-line-number="5649"></td>
        <td id="LC5649">            pResumeFunction = pModule-&gt;<span>LookupOrCreateFunction</span>(</td>
      </tr>
      <tr>
        <td id="L5650" data-line-number="5650"></td>
        <td id="LC5650">                    pEvent-&gt;<span>EnCRemap</span>.<span>funcMetadataToken</span>, pEvent-&gt;<span>EnCRemap</span>.<span>resumeVersionNumber</span>);</td>
      </tr>
      <tr>
        <td id="L5651" data-line-number="5651"></td>
        <td id="LC5651">
</td>
      </tr>
      <tr>
        <td id="L5652" data-line-number="5652"></td>
        <td id="LC5652">            <span>_ASSERTE</span>(pCurFunction-&gt;<span>GetEnCVersionNumber</span>() &lt; pResumeFunction-&gt;<span>GetEnCVersionNumber</span>());</td>
      </tr>
      <tr>
        <td id="L5653" data-line-number="5653"></td>
        <td id="LC5653">
</td>
      </tr>
      <tr>
        <td id="L5654" data-line-number="5654"></td>
        <td id="LC5654">            RSSmartPtr&lt;CordbFunction&gt; <span>pRefCurFunction</span>(pCurFunction);</td>
      </tr>
      <tr>
        <td id="L5655" data-line-number="5655"></td>
        <td id="LC5655">            RSSmartPtr&lt;CordbFunction&gt; <span>pRefResumeFunction</span>(pResumeFunction);</td>
      </tr>
      <tr>
        <td id="L5656" data-line-number="5656"></td>
        <td id="LC5656">
</td>
      </tr>
      <tr>
        <td id="L5657" data-line-number="5657"></td>
        <td id="LC5657">            <span><span>//</span> Verify we're not about to overwrite an outstanding remap IP</span></td>
      </tr>
      <tr>
        <td id="L5658" data-line-number="5658"></td>
        <td id="LC5658">            <span><span>//</span> This should only be set while a remap opportunity is being handled,</span></td>
      </tr>
      <tr>
        <td id="L5659" data-line-number="5659"></td>
        <td id="LC5659">            <span><span>//</span> and cleared (by CordbThread::MarkStackFramesDirty) on Continue.</span></td>
      </tr>
      <tr>
        <td id="L5660" data-line-number="5660"></td>
        <td id="LC5660">            <span><span>//</span> We want to be absolutely sure we don't accidentally keep a stale pointer</span></td>
      </tr>
      <tr>
        <td id="L5661" data-line-number="5661"></td>
        <td id="LC5661">            <span><span>//</span> around because it would point to arbitrary stack space in the CLR potentially</span></td>
      </tr>
      <tr>
        <td id="L5662" data-line-number="5662"></td>
        <td id="LC5662">            <span><span>//</span> leading to stack corruption.</span></td>
      </tr>
      <tr>
        <td id="L5663" data-line-number="5663"></td>
        <td id="LC5663">            <span>_ASSERTE</span>( pThread-&gt;<span>m_EnCRemapFunctionIP</span> == <span>NULL</span> );</td>
      </tr>
      <tr>
        <td id="L5664" data-line-number="5664"></td>
        <td id="LC5664">
</td>
      </tr>
      <tr>
        <td id="L5665" data-line-number="5665"></td>
        <td id="LC5665">            <span><span>//</span> Stash the address of the remap IP buffer.  This indicates that calling</span></td>
      </tr>
      <tr>
        <td id="L5666" data-line-number="5666"></td>
        <td id="LC5666">            <span><span>//</span> RemapFunction is valid and provides a communications channel between the RS</span></td>
      </tr>
      <tr>
        <td id="L5667" data-line-number="5667"></td>
        <td id="LC5667">            <span><span>//</span> and LS for the remap IL offset.</span></td>
      </tr>
      <tr>
        <td id="L5668" data-line-number="5668"></td>
        <td id="LC5668">            pThread-&gt;<span>m_EnCRemapFunctionIP</span> = pEvent-&gt;<span>EnCRemap</span>.<span>resumeILOffset</span>;</td>
      </tr>
      <tr>
        <td id="L5669" data-line-number="5669"></td>
        <td id="LC5669">
</td>
      </tr>
      <tr>
        <td id="L5670" data-line-number="5670"></td>
        <td id="LC5670">            {</td>
      </tr>
      <tr>
        <td id="L5671" data-line-number="5671"></td>
        <td id="LC5671">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5672" data-line-number="5672"></td>
        <td id="LC5672">                pCallback2-&gt;<span>FunctionRemapOpportunity</span>(</td>
      </tr>
      <tr>
        <td id="L5673" data-line-number="5673"></td>
        <td id="LC5673">                    pAppDomain,</td>
      </tr>
      <tr>
        <td id="L5674" data-line-number="5674"></td>
        <td id="LC5674">                    pThread,</td>
      </tr>
      <tr>
        <td id="L5675" data-line-number="5675"></td>
        <td id="LC5675">                    pCurFunction,</td>
      </tr>
      <tr>
        <td id="L5676" data-line-number="5676"></td>
        <td id="LC5676">                    pResumeFunction,</td>
      </tr>
      <tr>
        <td id="L5677" data-line-number="5677"></td>
        <td id="LC5677">                    (ULONG32)pEvent-&gt;<span>EnCRemap</span>.<span>currentILOffset</span>);</td>
      </tr>
      <tr>
        <td id="L5678" data-line-number="5678"></td>
        <td id="LC5678">            }</td>
      </tr>
      <tr>
        <td id="L5679" data-line-number="5679"></td>
        <td id="LC5679">
</td>
      </tr>
      <tr>
        <td id="L5680" data-line-number="5680"></td>
        <td id="LC5680">            <span><span>//</span> Implicit release on pCurFunction and pResumeFunction.</span></td>
      </tr>
      <tr>
        <td id="L5681" data-line-number="5681"></td>
        <td id="LC5681">        }</td>
      </tr>
      <tr>
        <td id="L5682" data-line-number="5682"></td>
        <td id="LC5682">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5683" data-line-number="5683"></td>
        <td id="LC5683">
</td>
      </tr>
      <tr>
        <td id="L5684" data-line-number="5684"></td>
        <td id="LC5684">        <span><span>//</span> EnC Remap complete</span></td>
      </tr>
      <tr>
        <td id="L5685" data-line-number="5685"></td>
        <td id="LC5685">        <span>case</span> DB_IPCE_ENC_REMAP_COMPLETE:</td>
      </tr>
      <tr>
        <td id="L5686" data-line-number="5686"></td>
        <td id="LC5686">        {</td>
      </tr>
      <tr>
        <td id="L5687" data-line-number="5687"></td>
        <td id="LC5687">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] RCET::DRCE: EnC Remap Complete!.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5688" data-line-number="5688"></td>
        <td id="LC5688">                 <span>GetCurrentThreadId</span>()));</td>
      </tr>
      <tr>
        <td id="L5689" data-line-number="5689"></td>
        <td id="LC5689">
</td>
      </tr>
      <tr>
        <td id="L5690" data-line-number="5690"></td>
        <td id="LC5690">            <span>_ASSERTE</span>(<span>NULL</span> != pAppDomain);</td>
      </tr>
      <tr>
        <td id="L5691" data-line-number="5691"></td>
        <td id="LC5691">
</td>
      </tr>
      <tr>
        <td id="L5692" data-line-number="5692"></td>
        <td id="LC5692">            CordbModule* pModule = pAppDomain-&gt;<span>LookupOrCreateModule</span>(pEvent-&gt;<span>EnCRemap</span>.<span>vmDomainFile</span>);</td>
      </tr>
      <tr>
        <td id="L5693" data-line-number="5693"></td>
        <td id="LC5693">            <span>PREFIX_ASSUME</span>(pModule != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5694" data-line-number="5694"></td>
        <td id="LC5694">
</td>
      </tr>
      <tr>
        <td id="L5695" data-line-number="5695"></td>
        <td id="LC5695">            <span><span>//</span> Find the function we're remapping to, which must be the latest version</span></td>
      </tr>
      <tr>
        <td id="L5696" data-line-number="5696"></td>
        <td id="LC5696">            CordbFunction *pRemapFunction=</td>
      </tr>
      <tr>
        <td id="L5697" data-line-number="5697"></td>
        <td id="LC5697">                pModule-&gt;<span>LookupFunctionLatestVersion</span>(pEvent-&gt;<span>EnCRemapComplete</span>.<span>funcMetadataToken</span>);</td>
      </tr>
      <tr>
        <td id="L5698" data-line-number="5698"></td>
        <td id="LC5698">            <span>PREFIX_ASSUME</span>(pRemapFunction != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5699" data-line-number="5699"></td>
        <td id="LC5699">
</td>
      </tr>
      <tr>
        <td id="L5700" data-line-number="5700"></td>
        <td id="LC5700">            <span><span>//</span> Dispatch the FunctionRemapComplete callback</span></td>
      </tr>
      <tr>
        <td id="L5701" data-line-number="5701"></td>
        <td id="LC5701">            RSSmartPtr&lt;CordbFunction&gt; <span>pRef</span>(pRemapFunction);</td>
      </tr>
      <tr>
        <td id="L5702" data-line-number="5702"></td>
        <td id="LC5702">            {</td>
      </tr>
      <tr>
        <td id="L5703" data-line-number="5703"></td>
        <td id="LC5703">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pLockHolder, pEvent);</td>
      </tr>
      <tr>
        <td id="L5704" data-line-number="5704"></td>
        <td id="LC5704">                pCallback2-&gt;<span>FunctionRemapComplete</span>(pAppDomain, pThread, pRemapFunction);</td>
      </tr>
      <tr>
        <td id="L5705" data-line-number="5705"></td>
        <td id="LC5705">            }</td>
      </tr>
      <tr>
        <td id="L5706" data-line-number="5706"></td>
        <td id="LC5706">            <span><span>//</span> Implicit release on pRemapFunction via holder</span></td>
      </tr>
      <tr>
        <td id="L5707" data-line-number="5707"></td>
        <td id="LC5707">        }</td>
      </tr>
      <tr>
        <td id="L5708" data-line-number="5708"></td>
        <td id="LC5708">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5709" data-line-number="5709"></td>
        <td id="LC5709">
</td>
      </tr>
      <tr>
        <td id="L5710" data-line-number="5710"></td>
        <td id="LC5710">        <span>case</span> DB_IPCE_BREAKPOINT_SET_ERROR:</td>
      </tr>
      <tr>
        <td id="L5711" data-line-number="5711"></td>
        <td id="LC5711">        {</td>
      </tr>
      <tr>
        <td id="L5712" data-line-number="5712"></td>
        <td id="LC5712">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>RCET::DRCE: breakpoint set error.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L5713" data-line-number="5713"></td>
        <td id="LC5713">
</td>
      </tr>
      <tr>
        <td id="L5714" data-line-number="5714"></td>
        <td id="LC5714">            RSSmartPtr&lt;CordbBreakpoint&gt; pRef;</td>
      </tr>
      <tr>
        <td id="L5715" data-line-number="5715"></td>
        <td id="LC5715">
</td>
      </tr>
      <tr>
        <td id="L5716" data-line-number="5716"></td>
        <td id="LC5716">            <span>_ASSERTE</span>(pThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5717" data-line-number="5717"></td>
        <td id="LC5717">            <span>_ASSERTE</span>(pAppDomain != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5718" data-line-number="5718"></td>
        <td id="LC5718">
</td>
      </tr>
      <tr>
        <td id="L5719" data-line-number="5719"></td>
        <td id="LC5719">            <span><span>//</span> Find the breakpoint object on this side.</span></td>
      </tr>
      <tr>
        <td id="L5720" data-line-number="5720"></td>
        <td id="LC5720">            CordbBreakpoint * pBreakpoint = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L5721" data-line-number="5721"></td>
        <td id="LC5721">
</td>
      </tr>
      <tr>
        <td id="L5722" data-line-number="5722"></td>
        <td id="LC5722">
</td>
      </tr>
      <tr>
        <td id="L5723" data-line-number="5723"></td>
        <td id="LC5723">            <span>if</span> (pThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5724" data-line-number="5724"></td>
        <td id="LC5724">            {</td>
      </tr>
      <tr>
        <td id="L5725" data-line-number="5725"></td>
        <td id="LC5725">                <span><span>//</span> We've found cases out in the wild where we get this event on a thread we don't recognize.</span></td>
      </tr>
      <tr>
        <td id="L5726" data-line-number="5726"></td>
        <td id="LC5726">                <span><span>//</span> We're not sure how this happens. Add a runtime check to protect ourselves to avoid the</span></td>
      </tr>
      <tr>
        <td id="L5727" data-line-number="5727"></td>
        <td id="LC5727">                <span><span>//</span> an AV. We still assert because this should not be happening.</span></td>
      </tr>
      <tr>
        <td id="L5728" data-line-number="5728"></td>
        <td id="LC5728">                <span><span>//</span> It likely means theres some issue where we failed to send a CreateThread notification.</span></td>
      </tr>
      <tr>
        <td id="L5729" data-line-number="5729"></td>
        <td id="LC5729">                <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>BreakpointSetError on unrecognized thread. %p<span>\n</span><span>"</span></span>, pBreakpoint);</td>
      </tr>
      <tr>
        <td id="L5730" data-line-number="5730"></td>
        <td id="LC5730">
</td>
      </tr>
      <tr>
        <td id="L5731" data-line-number="5731"></td>
        <td id="LC5731">                <span>_ASSERTE</span>(!<span><span>"</span>Missing thread on bp set error<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L5732" data-line-number="5732"></td>
        <td id="LC5732">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5733" data-line-number="5733"></td>
        <td id="LC5733">            }</td>
      </tr>
      <tr>
        <td id="L5734" data-line-number="5734"></td>
        <td id="LC5734">
</td>
      </tr>
      <tr>
        <td id="L5735" data-line-number="5735"></td>
        <td id="LC5735">            pBreakpoint = pAppDomain-&gt;<span>m_breakpoints</span>.<span>GetBase</span>(<span>LsPtrToCookie</span>(pEvent-&gt;<span>BreakpointSetErrorData</span>.<span>breakpointToken</span>));</td>
      </tr>
      <tr>
        <td id="L5736" data-line-number="5736"></td>
        <td id="LC5736">
</td>
      </tr>
      <tr>
        <td id="L5737" data-line-number="5737"></td>
        <td id="LC5737">            <span>if</span> (pBreakpoint != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5738" data-line-number="5738"></td>
        <td id="LC5738">            {</td>
      </tr>
      <tr>
        <td id="L5739" data-line-number="5739"></td>
        <td id="LC5739">                ICorDebugBreakpoint * pIBreakpoint = <span>CordbBreakpointToInterface</span>(pBreakpoint);</td>
      </tr>
      <tr>
        <td id="L5740" data-line-number="5740"></td>
        <td id="LC5740">                <span>_ASSERTE</span>(pIBreakpoint != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L5741" data-line-number="5741"></td>
        <td id="LC5741">            {</td>
      </tr>
      <tr>
        <td id="L5742" data-line-number="5742"></td>
        <td id="LC5742">                    <span>PUBLIC_CALLBACK_IN_THIS_SCOPE2</span>(<span>this</span>, pLockHolder, pEvent, <span><span>"</span>thread=0x%p, bp=0x%p<span>"</span></span>, pThread, pBreakpoint);</td>
      </tr>
      <tr>
        <td id="L5743" data-line-number="5743"></td>
        <td id="LC5743">                    pCallback1-&gt;<span>BreakpointSetError</span>(pAppDomain, pThread, pIBreakpoint, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L5744" data-line-number="5744"></td>
        <td id="LC5744">            }</td>
      </tr>
      <tr>
        <td id="L5745" data-line-number="5745"></td>
        <td id="LC5745">            }</td>
      </tr>
      <tr>
        <td id="L5746" data-line-number="5746"></td>
        <td id="LC5746">            <span><span>//</span> Implicit release on pRef.</span></td>
      </tr>
      <tr>
        <td id="L5747" data-line-number="5747"></td>
        <td id="LC5747">        }</td>
      </tr>
      <tr>
        <td id="L5748" data-line-number="5748"></td>
        <td id="LC5748">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5749" data-line-number="5749"></td>
        <td id="LC5749">
</td>
      </tr>
      <tr>
        <td id="L5750" data-line-number="5750"></td>
        <td id="LC5750">
</td>
      </tr>
      <tr>
        <td id="L5751" data-line-number="5751"></td>
        <td id="LC5751">    <span>case</span> DB_IPCE_EXCEPTION_CALLBACK2:</td>
      </tr>
      <tr>
        <td id="L5752" data-line-number="5752"></td>
        <td id="LC5752">        {</td>
      </tr>
      <tr>
        <td id="L5753" data-line-number="5753"></td>
        <td id="LC5753">            <span>STRESS_LOG4</span>(LF_CORDB, LL_INFO100,</td>
      </tr>
      <tr>
        <td id="L5754" data-line-number="5754"></td>
        <td id="LC5754">                <span><span>"</span>RCET::DRCE: Exception2 0x%p 0x%X 0x%X 0x%X<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5755" data-line-number="5755"></td>
        <td id="LC5755">                 pEvent-&gt;<span>ExceptionCallback2</span>.<span>framePointer</span>.<span>GetSPValue</span>(),</td>
      </tr>
      <tr>
        <td id="L5756" data-line-number="5756"></td>
        <td id="LC5756">                 pEvent-&gt;<span>ExceptionCallback2</span>.<span>nOffset</span>,</td>
      </tr>
      <tr>
        <td id="L5757" data-line-number="5757"></td>
        <td id="LC5757">                 pEvent-&gt;<span>ExceptionCallback2</span>.<span>eventType</span>,</td>
      </tr>
      <tr>
        <td id="L5758" data-line-number="5758"></td>
        <td id="LC5758">                 pEvent-&gt;<span>ExceptionCallback2</span>.<span>dwFlags</span></td>
      </tr>
      <tr>
        <td id="L5759" data-line-number="5759"></td>
        <td id="LC5759">                 );</td>
      </tr>
      <tr>
        <td id="L5760" data-line-number="5760"></td>
        <td id="LC5760">
</td>
      </tr>
      <tr>
        <td id="L5761" data-line-number="5761"></td>
        <td id="LC5761">            <span>if</span> (pThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5762" data-line-number="5762"></td>
        <td id="LC5762">            {</td>
      </tr>
      <tr>
        <td id="L5763" data-line-number="5763"></td>
        <td id="LC5763">                <span><span>//</span> We've got an exception on a thread we don't know about.  This could be a thread that</span></td>
      </tr>
      <tr>
        <td id="L5764" data-line-number="5764"></td>
        <td id="LC5764">                <span><span>//</span> has never run any managed code, so let's just ignore the exception.  We should have</span></td>
      </tr>
      <tr>
        <td id="L5765" data-line-number="5765"></td>
        <td id="LC5765">                <span><span>//</span> already sent a log message about this situation for the EXCEPTION callback above.</span></td>
      </tr>
      <tr>
        <td id="L5766" data-line-number="5766"></td>
        <td id="LC5766">                <span>_ASSERTE</span>( pEvent-&gt;<span>ExceptionCallback2</span>.<span>eventType</span> == DEBUG_EXCEPTION_UNHANDLED );</td>
      </tr>
      <tr>
        <td id="L5767" data-line-number="5767"></td>
        <td id="LC5767">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5768" data-line-number="5768"></td>
        <td id="LC5768">            }</td>
      </tr>
      <tr>
        <td id="L5769" data-line-number="5769"></td>
        <td id="LC5769">
</td>
      </tr>
      <tr>
        <td id="L5770" data-line-number="5770"></td>
        <td id="LC5770">            pThread-&gt;<span>SetExInfo</span>(pEvent-&gt;<span>ExceptionCallback2</span>.<span>vmExceptionHandle</span>);</td>
      </tr>
      <tr>
        <td id="L5771" data-line-number="5771"></td>
        <td id="LC5771">
</td>
      </tr>
      <tr>
        <td id="L5772" data-line-number="5772"></td>
        <td id="LC5772">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5773" data-line-number="5773"></td>
        <td id="LC5773">            <span><span>//</span> Send all the information back to the debugger.</span></td>
      </tr>
      <tr>
        <td id="L5774" data-line-number="5774"></td>
        <td id="LC5774">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5775" data-line-number="5775"></td>
        <td id="LC5775">            RSSmartPtr&lt;CordbFrame&gt; pFrame;</td>
      </tr>
      <tr>
        <td id="L5776" data-line-number="5776"></td>
        <td id="LC5776">
</td>
      </tr>
      <tr>
        <td id="L5777" data-line-number="5777"></td>
        <td id="LC5777">            FramePointer fp = pEvent-&gt;<span>ExceptionCallback2</span>.<span>framePointer</span>;</td>
      </tr>
      <tr>
        <td id="L5778" data-line-number="5778"></td>
        <td id="LC5778">            <span>if</span> (fp != LEAF_MOST_FRAME)</td>
      </tr>
      <tr>
        <td id="L5779" data-line-number="5779"></td>
        <td id="LC5779">            {</td>
      </tr>
      <tr>
        <td id="L5780" data-line-number="5780"></td>
        <td id="LC5780">                <span><span>//</span> The interface forces us to to pass a FramePointer via an ICorDebugFrame.</span></td>
      </tr>
      <tr>
        <td id="L5781" data-line-number="5781"></td>
        <td id="LC5781">                <span><span>//</span> However, we can't get a real ICDFrame without a stackwalk, and we don't</span></td>
      </tr>
      <tr>
        <td id="L5782" data-line-number="5782"></td>
        <td id="LC5782">                <span><span>//</span> want to do a stackwalk now. so pass a netuered proxy frame. The shim</span></td>
      </tr>
      <tr>
        <td id="L5783" data-line-number="5783"></td>
        <td id="LC5783">                <span><span>//</span> can map this to a real frame.</span></td>
      </tr>
      <tr>
        <td id="L5784" data-line-number="5784"></td>
        <td id="LC5784">                <span><span>//</span> See comments at CordbPlaceHolderFrame class for details.</span></td>
      </tr>
      <tr>
        <td id="L5785" data-line-number="5785"></td>
        <td id="LC5785">                pFrame.<span>Assign</span>(<span>new</span> <span>CordbPlaceholderFrame</span>(<span>this</span>, fp));</td>
      </tr>
      <tr>
        <td id="L5786" data-line-number="5786"></td>
        <td id="LC5786">            }</td>
      </tr>
      <tr>
        <td id="L5787" data-line-number="5787"></td>
        <td id="LC5787">
</td>
      </tr>
      <tr>
        <td id="L5788" data-line-number="5788"></td>
        <td id="LC5788">            CorDebugExceptionCallbackType type = pEvent-&gt;<span>ExceptionCallback2</span>.<span>eventType</span>;</td>
      </tr>
      <tr>
        <td id="L5789" data-line-number="5789"></td>
        <td id="LC5789">            {</td>
      </tr>
      <tr>
        <td id="L5790" data-line-number="5790"></td>
        <td id="LC5790">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE3</span>(<span>this</span>, pLockHolder, pEvent, <span><span>"</span>pThread=0x%p, frame=%p, type=%d<span>"</span></span>, pThread, (ICorDebugFrame*) pFrame, type);</td>
      </tr>
      <tr>
        <td id="L5791" data-line-number="5791"></td>
        <td id="LC5791">                hr = pCallback2-&gt;<span>Exception</span>(</td>
      </tr>
      <tr>
        <td id="L5792" data-line-number="5792"></td>
        <td id="LC5792">                    pThread-&gt;<span>m_pAppDomain</span>,</td>
      </tr>
      <tr>
        <td id="L5793" data-line-number="5793"></td>
        <td id="LC5793">                    pThread,</td>
      </tr>
      <tr>
        <td id="L5794" data-line-number="5794"></td>
        <td id="LC5794">                    pFrame,</td>
      </tr>
      <tr>
        <td id="L5795" data-line-number="5795"></td>
        <td id="LC5795">                    (ULONG32)(pEvent-&gt;<span>ExceptionCallback2</span>.<span>nOffset</span>),</td>
      </tr>
      <tr>
        <td id="L5796" data-line-number="5796"></td>
        <td id="LC5796">                    type,</td>
      </tr>
      <tr>
        <td id="L5797" data-line-number="5797"></td>
        <td id="LC5797">                    pEvent-&gt;<span>ExceptionCallback2</span>.<span>dwFlags</span>);</td>
      </tr>
      <tr>
        <td id="L5798" data-line-number="5798"></td>
        <td id="LC5798">            }</td>
      </tr>
      <tr>
        <td id="L5799" data-line-number="5799"></td>
        <td id="LC5799">        }</td>
      </tr>
      <tr>
        <td id="L5800" data-line-number="5800"></td>
        <td id="LC5800">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5801" data-line-number="5801"></td>
        <td id="LC5801">
</td>
      </tr>
      <tr>
        <td id="L5802" data-line-number="5802"></td>
        <td id="LC5802">    <span>case</span> DB_IPCE_EXCEPTION_UNWIND:</td>
      </tr>
      <tr>
        <td id="L5803" data-line-number="5803"></td>
        <td id="LC5803">        {</td>
      </tr>
      <tr>
        <td id="L5804" data-line-number="5804"></td>
        <td id="LC5804">            <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO100,</td>
      </tr>
      <tr>
        <td id="L5805" data-line-number="5805"></td>
        <td id="LC5805">                <span><span>"</span>RCET::DRCE: Exception Unwind 0x%X 0x%X<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5806" data-line-number="5806"></td>
        <td id="LC5806">                 pEvent-&gt;<span>ExceptionCallback2</span>.<span>eventType</span>,</td>
      </tr>
      <tr>
        <td id="L5807" data-line-number="5807"></td>
        <td id="LC5807">                 pEvent-&gt;<span>ExceptionCallback2</span>.<span>dwFlags</span></td>
      </tr>
      <tr>
        <td id="L5808" data-line-number="5808"></td>
        <td id="LC5808">                 );</td>
      </tr>
      <tr>
        <td id="L5809" data-line-number="5809"></td>
        <td id="LC5809">
</td>
      </tr>
      <tr>
        <td id="L5810" data-line-number="5810"></td>
        <td id="LC5810">            <span>if</span> (pThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5811" data-line-number="5811"></td>
        <td id="LC5811">            {</td>
      </tr>
      <tr>
        <td id="L5812" data-line-number="5812"></td>
        <td id="LC5812">                <span><span>//</span> We've got an exception on a thread we don't know about.  This probably should never</span></td>
      </tr>
      <tr>
        <td id="L5813" data-line-number="5813"></td>
        <td id="LC5813">                <span><span>//</span> happen (if it's unwinding, then we expect a managed frame on the stack, and so we should</span></td>
      </tr>
      <tr>
        <td id="L5814" data-line-number="5814"></td>
        <td id="LC5814">                <span><span>//</span> know about the thread), but if it does fall back to ignoring the exception.</span></td>
      </tr>
      <tr>
        <td id="L5815" data-line-number="5815"></td>
        <td id="LC5815">                <span>_ASSERTE</span>( !<span><span>"</span>Got unwind event for unknown exception<span>"</span></span> );</td>
      </tr>
      <tr>
        <td id="L5816" data-line-number="5816"></td>
        <td id="LC5816">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5817" data-line-number="5817"></td>
        <td id="LC5817">            }</td>
      </tr>
      <tr>
        <td id="L5818" data-line-number="5818"></td>
        <td id="LC5818">
</td>
      </tr>
      <tr>
        <td id="L5819" data-line-number="5819"></td>
        <td id="LC5819">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5820" data-line-number="5820"></td>
        <td id="LC5820">            <span><span>//</span> Send all the information back to the debugger.</span></td>
      </tr>
      <tr>
        <td id="L5821" data-line-number="5821"></td>
        <td id="LC5821">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5822" data-line-number="5822"></td>
        <td id="LC5822">            {</td>
      </tr>
      <tr>
        <td id="L5823" data-line-number="5823"></td>
        <td id="LC5823">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE1</span>(<span>this</span>, pLockHolder, pEvent, <span><span>"</span>pThread=0x%p<span>"</span></span>, pThread);</td>
      </tr>
      <tr>
        <td id="L5824" data-line-number="5824"></td>
        <td id="LC5824">                hr = pCallback2-&gt;<span>ExceptionUnwind</span>(</td>
      </tr>
      <tr>
        <td id="L5825" data-line-number="5825"></td>
        <td id="LC5825">                    pThread-&gt;<span>m_pAppDomain</span>,</td>
      </tr>
      <tr>
        <td id="L5826" data-line-number="5826"></td>
        <td id="LC5826">                    pThread,</td>
      </tr>
      <tr>
        <td id="L5827" data-line-number="5827"></td>
        <td id="LC5827">                    pEvent-&gt;<span>ExceptionUnwind</span>.<span>eventType</span>,</td>
      </tr>
      <tr>
        <td id="L5828" data-line-number="5828"></td>
        <td id="LC5828">                    pEvent-&gt;<span>ExceptionUnwind</span>.<span>dwFlags</span>);</td>
      </tr>
      <tr>
        <td id="L5829" data-line-number="5829"></td>
        <td id="LC5829">            }</td>
      </tr>
      <tr>
        <td id="L5830" data-line-number="5830"></td>
        <td id="LC5830">        }</td>
      </tr>
      <tr>
        <td id="L5831" data-line-number="5831"></td>
        <td id="LC5831">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5832" data-line-number="5832"></td>
        <td id="LC5832">
</td>
      </tr>
      <tr>
        <td id="L5833" data-line-number="5833"></td>
        <td id="LC5833">
</td>
      </tr>
      <tr>
        <td id="L5834" data-line-number="5834"></td>
        <td id="LC5834">    <span>case</span> DB_IPCE_INTERCEPT_EXCEPTION_COMPLETE:</td>
      </tr>
      <tr>
        <td id="L5835" data-line-number="5835"></td>
        <td id="LC5835">        {</td>
      </tr>
      <tr>
        <td id="L5836" data-line-number="5836"></td>
        <td id="LC5836">            <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO100, <span><span>"</span>RCET::DRCE: Exception Interception Complete.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L5837" data-line-number="5837"></td>
        <td id="LC5837">
</td>
      </tr>
      <tr>
        <td id="L5838" data-line-number="5838"></td>
        <td id="LC5838">            <span>if</span> (pThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L5839" data-line-number="5839"></td>
        <td id="LC5839">            {</td>
      </tr>
      <tr>
        <td id="L5840" data-line-number="5840"></td>
        <td id="LC5840">                <span><span>//</span> We've got an exception on a thread we don't know about.  This probably should never</span></td>
      </tr>
      <tr>
        <td id="L5841" data-line-number="5841"></td>
        <td id="LC5841">                <span><span>//</span> happen (if it's unwinding, then we expect a managed frame on the stack, and so we should</span></td>
      </tr>
      <tr>
        <td id="L5842" data-line-number="5842"></td>
        <td id="LC5842">                <span><span>//</span> know about the thread), but if it does fall back to ignoring the exception.</span></td>
      </tr>
      <tr>
        <td id="L5843" data-line-number="5843"></td>
        <td id="LC5843">                <span>_ASSERTE</span>( !<span><span>"</span>Got complete event for unknown exception<span>"</span></span> );</td>
      </tr>
      <tr>
        <td id="L5844" data-line-number="5844"></td>
        <td id="LC5844">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5845" data-line-number="5845"></td>
        <td id="LC5845">            }</td>
      </tr>
      <tr>
        <td id="L5846" data-line-number="5846"></td>
        <td id="LC5846">
</td>
      </tr>
      <tr>
        <td id="L5847" data-line-number="5847"></td>
        <td id="LC5847">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5848" data-line-number="5848"></td>
        <td id="LC5848">            <span><span>//</span> Tell the debugger that the exception has been intercepted.  This is similar to the</span></td>
      </tr>
      <tr>
        <td id="L5849" data-line-number="5849"></td>
        <td id="LC5849">            <span><span>//</span> notification we give when we start unwinding for a non-intercepted exception, except that the</span></td>
      </tr>
      <tr>
        <td id="L5850" data-line-number="5850"></td>
        <td id="LC5850">            <span><span>//</span> interception has been completed at this point, which means that we are conceptually at the end</span></td>
      </tr>
      <tr>
        <td id="L5851" data-line-number="5851"></td>
        <td id="LC5851">            <span><span>//</span> of the second pass.</span></td>
      </tr>
      <tr>
        <td id="L5852" data-line-number="5852"></td>
        <td id="LC5852">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5853" data-line-number="5853"></td>
        <td id="LC5853">            {</td>
      </tr>
      <tr>
        <td id="L5854" data-line-number="5854"></td>
        <td id="LC5854">                <span>PUBLIC_CALLBACK_IN_THIS_SCOPE1</span>(<span>this</span>, pLockHolder, pEvent, <span><span>"</span>pThread=0x%p<span>"</span></span>, pThread);</td>
      </tr>
      <tr>
        <td id="L5855" data-line-number="5855"></td>
        <td id="LC5855">                hr = pCallback2-&gt;<span>ExceptionUnwind</span>(</td>
      </tr>
      <tr>
        <td id="L5856" data-line-number="5856"></td>
        <td id="LC5856">                    pThread-&gt;<span>m_pAppDomain</span>,</td>
      </tr>
      <tr>
        <td id="L5857" data-line-number="5857"></td>
        <td id="LC5857">                    pThread,</td>
      </tr>
      <tr>
        <td id="L5858" data-line-number="5858"></td>
        <td id="LC5858">                    DEBUG_EXCEPTION_INTERCEPTED,</td>
      </tr>
      <tr>
        <td id="L5859" data-line-number="5859"></td>
        <td id="LC5859">                    <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L5860" data-line-number="5860"></td>
        <td id="LC5860">            }</td>
      </tr>
      <tr>
        <td id="L5861" data-line-number="5861"></td>
        <td id="LC5861">        }</td>
      </tr>
      <tr>
        <td id="L5862" data-line-number="5862"></td>
        <td id="LC5862">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5863" data-line-number="5863"></td>
        <td id="LC5863">#<span>ifdef</span> TEST_DATA_CONSISTENCY</td>
      </tr>
      <tr>
        <td id="L5864" data-line-number="5864"></td>
        <td id="LC5864">    <span>case</span> DB_IPCE_TEST_CRST:</td>
      </tr>
      <tr>
        <td id="L5865" data-line-number="5865"></td>
        <td id="LC5865">        {</td>
      </tr>
      <tr>
        <td id="L5866" data-line-number="5866"></td>
        <td id="LC5866">            EX_TRY</td>
      </tr>
      <tr>
        <td id="L5867" data-line-number="5867"></td>
        <td id="LC5867">            {</td>
      </tr>
      <tr>
        <td id="L5868" data-line-number="5868"></td>
        <td id="LC5868">                <span><span>//</span> the left side has signaled that we should test whether pEvent-&gt;TestCrstData.vmCrst is held</span></td>
      </tr>
      <tr>
        <td id="L5869" data-line-number="5869"></td>
        <td id="LC5869">                <span>GetDAC</span>()-&gt;<span>TestCrst</span>(pEvent-&gt;<span>TestCrstData</span>.<span>vmCrst</span>);</td>
      </tr>
      <tr>
        <td id="L5870" data-line-number="5870"></td>
        <td id="LC5870">            }</td>
      </tr>
      <tr>
        <td id="L5871" data-line-number="5871"></td>
        <td id="LC5871">            <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L5872" data-line-number="5872"></td>
        <td id="LC5872">
</td>
      </tr>
      <tr>
        <td id="L5873" data-line-number="5873"></td>
        <td id="LC5873">            <span>if</span> (pEvent-&gt;<span>TestCrstData</span>.<span>fOkToTake</span>)</td>
      </tr>
      <tr>
        <td id="L5874" data-line-number="5874"></td>
        <td id="LC5874">            {</td>
      </tr>
      <tr>
        <td id="L5875" data-line-number="5875"></td>
        <td id="LC5875">                <span>_ASSERTE</span>(hr == S_OK);</td>
      </tr>
      <tr>
        <td id="L5876" data-line-number="5876"></td>
        <td id="LC5876">                <span>if</span> (hr != S_OK)</td>
      </tr>
      <tr>
        <td id="L5877" data-line-number="5877"></td>
        <td id="LC5877">                {</td>
      </tr>
      <tr>
        <td id="L5878" data-line-number="5878"></td>
        <td id="LC5878">                    <span><span>//</span> we want to catch this in retail builds too</span></td>
      </tr>
      <tr>
        <td id="L5879" data-line-number="5879"></td>
        <td id="LC5879">                    <span>ThrowHR</span>(E_FAIL);</td>
      </tr>
      <tr>
        <td id="L5880" data-line-number="5880"></td>
        <td id="LC5880">                }</td>
      </tr>
      <tr>
        <td id="L5881" data-line-number="5881"></td>
        <td id="LC5881">            }</td>
      </tr>
      <tr>
        <td id="L5882" data-line-number="5882"></td>
        <td id="LC5882">            <span>else</span> <span><span>//</span> the lock was already held</span></td>
      </tr>
      <tr>
        <td id="L5883" data-line-number="5883"></td>
        <td id="LC5883">            {</td>
      </tr>
      <tr>
        <td id="L5884" data-line-number="5884"></td>
        <td id="LC5884">                <span><span>//</span> see if we threw because the lock was held</span></td>
      </tr>
      <tr>
        <td id="L5885" data-line-number="5885"></td>
        <td id="LC5885">                <span>_ASSERTE</span>(hr == CORDBG_E_PROCESS_NOT_SYNCHRONIZED);</td>
      </tr>
      <tr>
        <td id="L5886" data-line-number="5886"></td>
        <td id="LC5886">                <span>if</span> (hr != CORDBG_E_PROCESS_NOT_SYNCHRONIZED)</td>
      </tr>
      <tr>
        <td id="L5887" data-line-number="5887"></td>
        <td id="LC5887">                {</td>
      </tr>
      <tr>
        <td id="L5888" data-line-number="5888"></td>
        <td id="LC5888">                    <span><span>//</span> we want to catch this in retail builds too</span></td>
      </tr>
      <tr>
        <td id="L5889" data-line-number="5889"></td>
        <td id="LC5889">                    <span>ThrowHR</span>(E_FAIL);</td>
      </tr>
      <tr>
        <td id="L5890" data-line-number="5890"></td>
        <td id="LC5890">                }</td>
      </tr>
      <tr>
        <td id="L5891" data-line-number="5891"></td>
        <td id="LC5891">            }</td>
      </tr>
      <tr>
        <td id="L5892" data-line-number="5892"></td>
        <td id="LC5892">
</td>
      </tr>
      <tr>
        <td id="L5893" data-line-number="5893"></td>
        <td id="LC5893">        }</td>
      </tr>
      <tr>
        <td id="L5894" data-line-number="5894"></td>
        <td id="LC5894">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5895" data-line-number="5895"></td>
        <td id="LC5895">
</td>
      </tr>
      <tr>
        <td id="L5896" data-line-number="5896"></td>
        <td id="LC5896">    <span>case</span> DB_IPCE_TEST_RWLOCK:</td>
      </tr>
      <tr>
        <td id="L5897" data-line-number="5897"></td>
        <td id="LC5897">        {</td>
      </tr>
      <tr>
        <td id="L5898" data-line-number="5898"></td>
        <td id="LC5898">            EX_TRY</td>
      </tr>
      <tr>
        <td id="L5899" data-line-number="5899"></td>
        <td id="LC5899">            {</td>
      </tr>
      <tr>
        <td id="L5900" data-line-number="5900"></td>
        <td id="LC5900">                <span><span>//</span> the left side has signaled that we should test whether pEvent-&gt;TestRWLockData.vmRWLock is held</span></td>
      </tr>
      <tr>
        <td id="L5901" data-line-number="5901"></td>
        <td id="LC5901">                <span>GetDAC</span>()-&gt;<span>TestRWLock</span>(pEvent-&gt;<span>TestRWLockData</span>.<span>vmRWLock</span>);</td>
      </tr>
      <tr>
        <td id="L5902" data-line-number="5902"></td>
        <td id="LC5902">            }</td>
      </tr>
      <tr>
        <td id="L5903" data-line-number="5903"></td>
        <td id="LC5903">            <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L5904" data-line-number="5904"></td>
        <td id="LC5904">
</td>
      </tr>
      <tr>
        <td id="L5905" data-line-number="5905"></td>
        <td id="LC5905">            <span>if</span> (pEvent-&gt;<span>TestRWLockData</span>.<span>fOkToTake</span>)</td>
      </tr>
      <tr>
        <td id="L5906" data-line-number="5906"></td>
        <td id="LC5906">            {</td>
      </tr>
      <tr>
        <td id="L5907" data-line-number="5907"></td>
        <td id="LC5907">                <span>_ASSERTE</span>(hr == S_OK);</td>
      </tr>
      <tr>
        <td id="L5908" data-line-number="5908"></td>
        <td id="LC5908">                <span>if</span> (hr != S_OK)</td>
      </tr>
      <tr>
        <td id="L5909" data-line-number="5909"></td>
        <td id="LC5909">                {</td>
      </tr>
      <tr>
        <td id="L5910" data-line-number="5910"></td>
        <td id="LC5910">                    <span><span>//</span> we want to catch this in retail builds too</span></td>
      </tr>
      <tr>
        <td id="L5911" data-line-number="5911"></td>
        <td id="LC5911">                    <span>ThrowHR</span>(E_FAIL);</td>
      </tr>
      <tr>
        <td id="L5912" data-line-number="5912"></td>
        <td id="LC5912">                }</td>
      </tr>
      <tr>
        <td id="L5913" data-line-number="5913"></td>
        <td id="LC5913">            }</td>
      </tr>
      <tr>
        <td id="L5914" data-line-number="5914"></td>
        <td id="LC5914">            <span>else</span> <span><span>//</span> the lock was already held</span></td>
      </tr>
      <tr>
        <td id="L5915" data-line-number="5915"></td>
        <td id="LC5915">            {</td>
      </tr>
      <tr>
        <td id="L5916" data-line-number="5916"></td>
        <td id="LC5916">                <span><span>//</span> see if we threw because the lock was held</span></td>
      </tr>
      <tr>
        <td id="L5917" data-line-number="5917"></td>
        <td id="LC5917">                <span>_ASSERTE</span>(hr == CORDBG_E_PROCESS_NOT_SYNCHRONIZED);</td>
      </tr>
      <tr>
        <td id="L5918" data-line-number="5918"></td>
        <td id="LC5918">                <span>if</span> (hr != CORDBG_E_PROCESS_NOT_SYNCHRONIZED)</td>
      </tr>
      <tr>
        <td id="L5919" data-line-number="5919"></td>
        <td id="LC5919">                {</td>
      </tr>
      <tr>
        <td id="L5920" data-line-number="5920"></td>
        <td id="LC5920">                    <span><span>//</span> we want to catch this in retail builds too</span></td>
      </tr>
      <tr>
        <td id="L5921" data-line-number="5921"></td>
        <td id="LC5921">                    <span>ThrowHR</span>(E_FAIL);</td>
      </tr>
      <tr>
        <td id="L5922" data-line-number="5922"></td>
        <td id="LC5922">                }</td>
      </tr>
      <tr>
        <td id="L5923" data-line-number="5923"></td>
        <td id="LC5923">            }</td>
      </tr>
      <tr>
        <td id="L5924" data-line-number="5924"></td>
        <td id="LC5924">        }</td>
      </tr>
      <tr>
        <td id="L5925" data-line-number="5925"></td>
        <td id="LC5925">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5926" data-line-number="5926"></td>
        <td id="LC5926">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5927" data-line-number="5927"></td>
        <td id="LC5927">
</td>
      </tr>
      <tr>
        <td id="L5928" data-line-number="5928"></td>
        <td id="LC5928">    <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L5929" data-line-number="5929"></td>
        <td id="LC5929">        <span>_ASSERTE</span>(!<span><span>"</span>Unknown event<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L5930" data-line-number="5930"></td>
        <td id="LC5930">        <span>LOG</span>((LF_CORDB, LL_INFO1000,</td>
      </tr>
      <tr>
        <td id="L5931" data-line-number="5931"></td>
        <td id="LC5931">             <span><span>"</span>[%x] RCET::HRCE: Unknown event: 0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5932" data-line-number="5932"></td>
        <td id="LC5932">             <span>GetCurrentThreadId</span>(), pEvent-&gt;<span>type</span>));</td>
      </tr>
      <tr>
        <td id="L5933" data-line-number="5933"></td>
        <td id="LC5933">    }</td>
      </tr>
      <tr>
        <td id="L5934" data-line-number="5934"></td>
        <td id="LC5934">
</td>
      </tr>
      <tr>
        <td id="L5935" data-line-number="5935"></td>
        <td id="LC5935">
</td>
      </tr>
      <tr>
        <td id="L5936" data-line-number="5936"></td>
        <td id="LC5936">    <span>FinishEventDispatch</span>();</td>
      </tr>
      <tr>
        <td id="L5937" data-line-number="5937"></td>
        <td id="LC5937">}</td>
      </tr>
      <tr>
        <td id="L5938" data-line-number="5938"></td>
        <td id="LC5938">#<span>ifdef</span> _PREFAST_</td>
      </tr>
      <tr>
        <td id="L5939" data-line-number="5939"></td>
        <td id="LC5939">#<span>pragma</span> warning(pop)</td>
      </tr>
      <tr>
        <td id="L5940" data-line-number="5940"></td>
        <td id="LC5940">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5941" data-line-number="5941"></td>
        <td id="LC5941">
</td>
      </tr>
      <tr>
        <td id="L5942" data-line-number="5942"></td>
        <td id="LC5942"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L5943" data-line-number="5943"></td>
        <td id="LC5943"><span><span>//</span> Callback for prepopulating threads.</span></td>
      </tr>
      <tr>
        <td id="L5944" data-line-number="5944"></td>
        <td id="LC5944"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5945" data-line-number="5945"></td>
        <td id="LC5945"><span><span>//</span> Arugments:</span></td>
      </tr>
      <tr>
        <td id="L5946" data-line-number="5946"></td>
        <td id="LC5946"><span><span>//</span>    vmThread - thread as part of the eunmeration.</span></td>
      </tr>
      <tr>
        <td id="L5947" data-line-number="5947"></td>
        <td id="LC5947"><span><span>//</span>    pUserData - data supplied with callback. It's a CordbProcess* object.</span></td>
      </tr>
      <tr>
        <td id="L5948" data-line-number="5948"></td>
        <td id="LC5948"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5949" data-line-number="5949"></td>
        <td id="LC5949">
</td>
      </tr>
      <tr>
        <td id="L5950" data-line-number="5950"></td>
        <td id="LC5950"><span><span>//</span> static</span></td>
      </tr>
      <tr>
        <td id="L5951" data-line-number="5951"></td>
        <td id="LC5951"><span>void</span> <span>CordbProcess::ThreadEnumerationCallback</span>(VMPTR_Thread vmThread, <span>void</span> * pUserData)</td>
      </tr>
      <tr>
        <td id="L5952" data-line-number="5952"></td>
        <td id="LC5952">{</td>
      </tr>
      <tr>
        <td id="L5953" data-line-number="5953"></td>
        <td id="LC5953">    CordbProcess * pThis = <span>reinterpret_cast</span>&lt;CordbProcess *&gt; (pUserData);</td>
      </tr>
      <tr>
        <td id="L5954" data-line-number="5954"></td>
        <td id="LC5954">    <span>INTERNAL_DAC_CALLBACK</span>(pThis);</td>
      </tr>
      <tr>
        <td id="L5955" data-line-number="5955"></td>
        <td id="LC5955">
</td>
      </tr>
      <tr>
        <td id="L5956" data-line-number="5956"></td>
        <td id="LC5956">    <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>ThreadEnumerationCallback()<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L5957" data-line-number="5957"></td>
        <td id="LC5957">
</td>
      </tr>
      <tr>
        <td id="L5958" data-line-number="5958"></td>
        <td id="LC5958">    <span><span>//</span> Do lookup / lazy-create.</span></td>
      </tr>
      <tr>
        <td id="L5959" data-line-number="5959"></td>
        <td id="LC5959">    pThis-&gt;<span>LookupOrCreateThread</span>(vmThread);</td>
      </tr>
      <tr>
        <td id="L5960" data-line-number="5960"></td>
        <td id="LC5960">}</td>
      </tr>
      <tr>
        <td id="L5961" data-line-number="5961"></td>
        <td id="LC5961">
</td>
      </tr>
      <tr>
        <td id="L5962" data-line-number="5962"></td>
        <td id="LC5962"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L5963" data-line-number="5963"></td>
        <td id="LC5963"><span><span>//</span> Fully build up the CordbThread cache to match VM state.</span></td>
      </tr>
      <tr>
        <td id="L5964" data-line-number="5964"></td>
        <td id="LC5964"><span>void</span> <span>CordbProcess::PrepopulateThreadsOrThrow</span>()</td>
      </tr>
      <tr>
        <td id="L5965" data-line-number="5965"></td>
        <td id="LC5965">{</td>
      </tr>
      <tr>
        <td id="L5966" data-line-number="5966"></td>
        <td id="LC5966">    RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L5967" data-line-number="5967"></td>
        <td id="LC5967">    <span>if</span> (<span>IsDacInitialized</span>())</td>
      </tr>
      <tr>
        <td id="L5968" data-line-number="5968"></td>
        <td id="LC5968">    {</td>
      </tr>
      <tr>
        <td id="L5969" data-line-number="5969"></td>
        <td id="LC5969">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>PrepopulateThreadsOrThrow()<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L5970" data-line-number="5970"></td>
        <td id="LC5970">        <span>GetDAC</span>()-&gt;<span>EnumerateThreads</span>(ThreadEnumerationCallback, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L5971" data-line-number="5971"></td>
        <td id="LC5971">    }</td>
      </tr>
      <tr>
        <td id="L5972" data-line-number="5972"></td>
        <td id="LC5972">}</td>
      </tr>
      <tr>
        <td id="L5973" data-line-number="5973"></td>
        <td id="LC5973">
</td>
      </tr>
      <tr>
        <td id="L5974" data-line-number="5974"></td>
        <td id="LC5974"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L5975" data-line-number="5975"></td>
        <td id="LC5975"><span><span>//</span> Create a Thread enumerator</span></td>
      </tr>
      <tr>
        <td id="L5976" data-line-number="5976"></td>
        <td id="LC5976"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5977" data-line-number="5977"></td>
        <td id="LC5977"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L5978" data-line-number="5978"></td>
        <td id="LC5978"><span><span>//</span>     pOwnerObj - object (a CordbProcess or CordbThread) that will own the enumerator.</span></td>
      </tr>
      <tr>
        <td id="L5979" data-line-number="5979"></td>
        <td id="LC5979"><span><span>//</span>     pOwnerList - the neuter list that the enumerator will live on</span></td>
      </tr>
      <tr>
        <td id="L5980" data-line-number="5980"></td>
        <td id="LC5980"><span><span>//</span>     pHolder - an outparameter for the enumerator to be initialized.</span></td>
      </tr>
      <tr>
        <td id="L5981" data-line-number="5981"></td>
        <td id="LC5981"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5982" data-line-number="5982"></td>
        <td id="LC5982"><span>void</span> <span>CordbProcess::BuildThreadEnum</span>(CordbBase * pOwnerObj, NeuterList * pOwnerList, RSInitHolder&lt;CordbHashTableEnum&gt; * pHolder)</td>
      </tr>
      <tr>
        <td id="L5983" data-line-number="5983"></td>
        <td id="LC5983">{</td>
      </tr>
      <tr>
        <td id="L5984" data-line-number="5984"></td>
        <td id="LC5984">    <span>CordbHashTableEnum::BuildOrThrow</span>(</td>
      </tr>
      <tr>
        <td id="L5985" data-line-number="5985"></td>
        <td id="LC5985">        pOwnerObj,</td>
      </tr>
      <tr>
        <td id="L5986" data-line-number="5986"></td>
        <td id="LC5986">        pOwnerList,</td>
      </tr>
      <tr>
        <td id="L5987" data-line-number="5987"></td>
        <td id="LC5987">        &amp;m_userThreads,</td>
      </tr>
      <tr>
        <td id="L5988" data-line-number="5988"></td>
        <td id="LC5988">        IID_ICorDebugThreadEnum,</td>
      </tr>
      <tr>
        <td id="L5989" data-line-number="5989"></td>
        <td id="LC5989">        pHolder);</td>
      </tr>
      <tr>
        <td id="L5990" data-line-number="5990"></td>
        <td id="LC5990">}</td>
      </tr>
      <tr>
        <td id="L5991" data-line-number="5991"></td>
        <td id="LC5991">
</td>
      </tr>
      <tr>
        <td id="L5992" data-line-number="5992"></td>
        <td id="LC5992"><span><span>//</span> Public implementation of ICorDebugProcess::EnumerateThreads</span></td>
      </tr>
      <tr>
        <td id="L5993" data-line-number="5993"></td>
        <td id="LC5993">HRESULT <span>CordbProcess::EnumerateThreads</span>(ICorDebugThreadEnum **ppThreads)</td>
      </tr>
      <tr>
        <td id="L5994" data-line-number="5994"></td>
        <td id="LC5994">{</td>
      </tr>
      <tr>
        <td id="L5995" data-line-number="5995"></td>
        <td id="LC5995">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L5996" data-line-number="5996"></td>
        <td id="LC5996">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L5997" data-line-number="5997"></td>
        <td id="LC5997">    {</td>
      </tr>
      <tr>
        <td id="L5998" data-line-number="5998"></td>
        <td id="LC5998">        <span>if</span> (m_detached)</td>
      </tr>
      <tr>
        <td id="L5999" data-line-number="5999"></td>
        <td id="LC5999">        {</td>
      </tr>
      <tr>
        <td id="L6000" data-line-number="6000"></td>
        <td id="LC6000">            <span><span>//</span> #Detach_Check:</span></td>
      </tr>
      <tr>
        <td id="L6001" data-line-number="6001"></td>
        <td id="LC6001">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6002" data-line-number="6002"></td>
        <td id="LC6002">            <span><span>//</span> FUTURE: Consider adding this IF block to the PUBLIC_API macros so that</span></td>
      </tr>
      <tr>
        <td id="L6003" data-line-number="6003"></td>
        <td id="LC6003">            <span><span>//</span> typical public APIs fail quickly if we're trying to do a detach.  For</span></td>
      </tr>
      <tr>
        <td id="L6004" data-line-number="6004"></td>
        <td id="LC6004">            <span><span>//</span> now, I'm hand-adding this check only to the few problematic APIs that get</span></td>
      </tr>
      <tr>
        <td id="L6005" data-line-number="6005"></td>
        <td id="LC6005">            <span><span>//</span> called while queuing the fake attach events.  In these cases, it is not</span></td>
      </tr>
      <tr>
        <td id="L6006" data-line-number="6006"></td>
        <td id="LC6006">            <span><span>//</span> enough to check if CordbProcess::IsNeutered(), as the detaching thread</span></td>
      </tr>
      <tr>
        <td id="L6007" data-line-number="6007"></td>
        <td id="LC6007">            <span><span>//</span> may have begun the detaching and neutering process, but not be</span></td>
      </tr>
      <tr>
        <td id="L6008" data-line-number="6008"></td>
        <td id="LC6008">            <span><span>//</span> finished--in which case m_detached is true, but</span></td>
      </tr>
      <tr>
        <td id="L6009" data-line-number="6009"></td>
        <td id="LC6009">            <span><span>//</span> CordbProcess::IsNeutered() is still false.</span></td>
      </tr>
      <tr>
        <td id="L6010" data-line-number="6010"></td>
        <td id="LC6010">            <span>ThrowHR</span>(CORDBG_E_PROCESS_DETACHED);</td>
      </tr>
      <tr>
        <td id="L6011" data-line-number="6011"></td>
        <td id="LC6011">        }</td>
      </tr>
      <tr>
        <td id="L6012" data-line-number="6012"></td>
        <td id="LC6012">
</td>
      </tr>
      <tr>
        <td id="L6013" data-line-number="6013"></td>
        <td id="LC6013">        <span>ValidateOrThrow</span>(ppThreads);</td>
      </tr>
      <tr>
        <td id="L6014" data-line-number="6014"></td>
        <td id="LC6014">
</td>
      </tr>
      <tr>
        <td id="L6015" data-line-number="6015"></td>
        <td id="LC6015">        RSInitHolder&lt;CordbHashTableEnum&gt; pEnum;</td>
      </tr>
      <tr>
        <td id="L6016" data-line-number="6016"></td>
        <td id="LC6016">        <span>InternalEnumerateThreads</span>(pEnum.<span>GetAddr</span>());</td>
      </tr>
      <tr>
        <td id="L6017" data-line-number="6017"></td>
        <td id="LC6017">
</td>
      </tr>
      <tr>
        <td id="L6018" data-line-number="6018"></td>
        <td id="LC6018">        pEnum.<span>TransferOwnershipExternal</span>(ppThreads);</td>
      </tr>
      <tr>
        <td id="L6019" data-line-number="6019"></td>
        <td id="LC6019">    }</td>
      </tr>
      <tr>
        <td id="L6020" data-line-number="6020"></td>
        <td id="LC6020">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L6021" data-line-number="6021"></td>
        <td id="LC6021">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L6022" data-line-number="6022"></td>
        <td id="LC6022">}</td>
      </tr>
      <tr>
        <td id="L6023" data-line-number="6023"></td>
        <td id="LC6023">
</td>
      </tr>
      <tr>
        <td id="L6024" data-line-number="6024"></td>
        <td id="LC6024"><span><span>//</span> Internal implementation of EnumerateThreads</span></td>
      </tr>
      <tr>
        <td id="L6025" data-line-number="6025"></td>
        <td id="LC6025">VOID <span>CordbProcess::InternalEnumerateThreads</span>(RSInitHolder&lt;CordbHashTableEnum&gt; *ppThreads)</td>
      </tr>
      <tr>
        <td id="L6026" data-line-number="6026"></td>
        <td id="LC6026">{</td>
      </tr>
      <tr>
        <td id="L6027" data-line-number="6027"></td>
        <td id="LC6027">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6028" data-line-number="6028"></td>
        <td id="LC6028">    <span><span>//</span> Needs to prepopulate</span></td>
      </tr>
      <tr>
        <td id="L6029" data-line-number="6029"></td>
        <td id="LC6029">    <span>PrepopulateThreadsOrThrow</span>();</td>
      </tr>
      <tr>
        <td id="L6030" data-line-number="6030"></td>
        <td id="LC6030">    <span>BuildThreadEnum</span>(<span>this</span>, <span>this</span>-&gt;<span>GetContinueNeuterList</span>(), ppThreads);</td>
      </tr>
      <tr>
        <td id="L6031" data-line-number="6031"></td>
        <td id="LC6031">}</td>
      </tr>
      <tr>
        <td id="L6032" data-line-number="6032"></td>
        <td id="LC6032">
</td>
      </tr>
      <tr>
        <td id="L6033" data-line-number="6033"></td>
        <td id="LC6033"><span><span>//</span> Implementation of ICorDebugProcess::GetThread</span></td>
      </tr>
      <tr>
        <td id="L6034" data-line-number="6034"></td>
        <td id="LC6034">HRESULT <span>CordbProcess::GetThread</span>(DWORD dwThreadId, ICorDebugThread **ppThread)</td>
      </tr>
      <tr>
        <td id="L6035" data-line-number="6035"></td>
        <td id="LC6035">{</td>
      </tr>
      <tr>
        <td id="L6036" data-line-number="6036"></td>
        <td id="LC6036">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6037" data-line-number="6037"></td>
        <td id="LC6037">    <span>VALIDATE_POINTER_TO_OBJECT</span>(ppThread, ICorDebugThread **);</td>
      </tr>
      <tr>
        <td id="L6038" data-line-number="6038"></td>
        <td id="LC6038">
</td>
      </tr>
      <tr>
        <td id="L6039" data-line-number="6039"></td>
        <td id="LC6039">    <span><span>//</span> No good pre-existing ATT_* contract for this.</span></td>
      </tr>
      <tr>
        <td id="L6040" data-line-number="6040"></td>
        <td id="LC6040">    <span><span>//</span> Because for legacy, we have to allow this on the win32 event thread.</span></td>
      </tr>
      <tr>
        <td id="L6041" data-line-number="6041"></td>
        <td id="LC6041">    *ppThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L6042" data-line-number="6042"></td>
        <td id="LC6042">
</td>
      </tr>
      <tr>
        <td id="L6043" data-line-number="6043"></td>
        <td id="LC6043">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L6044" data-line-number="6044"></td>
        <td id="LC6044">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L6045" data-line-number="6045"></td>
        <td id="LC6045">    {</td>
      </tr>
      <tr>
        <td id="L6046" data-line-number="6046"></td>
        <td id="LC6046">        RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6047" data-line-number="6047"></td>
        <td id="LC6047">        <span>if</span> (m_detached)</td>
      </tr>
      <tr>
        <td id="L6048" data-line-number="6048"></td>
        <td id="LC6048">        {</td>
      </tr>
      <tr>
        <td id="L6049" data-line-number="6049"></td>
        <td id="LC6049">            <span><span>//</span> See code:CordbProcess::EnumerateThreads#Detach_Check</span></td>
      </tr>
      <tr>
        <td id="L6050" data-line-number="6050"></td>
        <td id="LC6050">            <span>ThrowHR</span>(CORDBG_E_PROCESS_DETACHED);</td>
      </tr>
      <tr>
        <td id="L6051" data-line-number="6051"></td>
        <td id="LC6051">        }</td>
      </tr>
      <tr>
        <td id="L6052" data-line-number="6052"></td>
        <td id="LC6052">        CordbThread * pThread = <span>TryLookupOrCreateThreadByVolatileOSId</span>(dwThreadId);</td>
      </tr>
      <tr>
        <td id="L6053" data-line-number="6053"></td>
        <td id="LC6053">        <span>if</span> (pThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6054" data-line-number="6054"></td>
        <td id="LC6054">        {</td>
      </tr>
      <tr>
        <td id="L6055" data-line-number="6055"></td>
        <td id="LC6055">            <span><span>//</span> This is a common case because we may be looking up an unmanaged thread.</span></td>
      </tr>
      <tr>
        <td id="L6056" data-line-number="6056"></td>
        <td id="LC6056">            hr = E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L6057" data-line-number="6057"></td>
        <td id="LC6057">        }</td>
      </tr>
      <tr>
        <td id="L6058" data-line-number="6058"></td>
        <td id="LC6058">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L6059" data-line-number="6059"></td>
        <td id="LC6059">        {</td>
      </tr>
      <tr>
        <td id="L6060" data-line-number="6060"></td>
        <td id="LC6060">            *ppThread = <span>static_cast</span>&lt;ICorDebugThread*&gt; (pThread);</td>
      </tr>
      <tr>
        <td id="L6061" data-line-number="6061"></td>
        <td id="LC6061">            pThread-&gt;<span>ExternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L6062" data-line-number="6062"></td>
        <td id="LC6062">        }</td>
      </tr>
      <tr>
        <td id="L6063" data-line-number="6063"></td>
        <td id="LC6063">    }</td>
      </tr>
      <tr>
        <td id="L6064" data-line-number="6064"></td>
        <td id="LC6064">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L6065" data-line-number="6065"></td>
        <td id="LC6065">
</td>
      </tr>
      <tr>
        <td id="L6066" data-line-number="6066"></td>
        <td id="LC6066">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::GT returns id=0x%x hr=0x%x ppThread=0x%p<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L6067" data-line-number="6067"></td>
        <td id="LC6067">             dwThreadId, hr, *ppThread));</td>
      </tr>
      <tr>
        <td id="L6068" data-line-number="6068"></td>
        <td id="LC6068">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L6069" data-line-number="6069"></td>
        <td id="LC6069">}</td>
      </tr>
      <tr>
        <td id="L6070" data-line-number="6070"></td>
        <td id="LC6070">
</td>
      </tr>
      <tr>
        <td id="L6071" data-line-number="6071"></td>
        <td id="LC6071">HRESULT <span>CordbProcess::ThreadForFiberCookie</span>(DWORD fiberCookie,</td>
      </tr>
      <tr>
        <td id="L6072" data-line-number="6072"></td>
        <td id="LC6072">                                           ICorDebugThread **ppThread)</td>
      </tr>
      <tr>
        <td id="L6073" data-line-number="6073"></td>
        <td id="LC6073">{</td>
      </tr>
      <tr>
        <td id="L6074" data-line-number="6074"></td>
        <td id="LC6074">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L6075" data-line-number="6075"></td>
        <td id="LC6075">}</td>
      </tr>
      <tr>
        <td id="L6076" data-line-number="6076"></td>
        <td id="LC6076">
</td>
      </tr>
      <tr>
        <td id="L6077" data-line-number="6077"></td>
        <td id="LC6077">HRESULT <span>CordbProcess::GetHelperThreadID</span>(DWORD *pThreadID)</td>
      </tr>
      <tr>
        <td id="L6078" data-line-number="6078"></td>
        <td id="LC6078">{</td>
      </tr>
      <tr>
        <td id="L6079" data-line-number="6079"></td>
        <td id="LC6079">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6080" data-line-number="6080"></td>
        <td id="LC6080">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6081" data-line-number="6081"></td>
        <td id="LC6081">
</td>
      </tr>
      <tr>
        <td id="L6082" data-line-number="6082"></td>
        <td id="LC6082">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L6083" data-line-number="6083"></td>
        <td id="LC6083">    <span>if</span> (pThreadID == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6084" data-line-number="6084"></td>
        <td id="LC6084">    {</td>
      </tr>
      <tr>
        <td id="L6085" data-line-number="6085"></td>
        <td id="LC6085">        <span>return</span> (E_INVALIDARG);</td>
      </tr>
      <tr>
        <td id="L6086" data-line-number="6086"></td>
        <td id="LC6086">    }</td>
      </tr>
      <tr>
        <td id="L6087" data-line-number="6087"></td>
        <td id="LC6087">
</td>
      </tr>
      <tr>
        <td id="L6088" data-line-number="6088"></td>
        <td id="LC6088">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L6089" data-line-number="6089"></td>
        <td id="LC6089">    <span><span>//</span> Return the ID of the current helper thread. There may be no thread in the process, or there may be a true helper</span></td>
      </tr>
      <tr>
        <td id="L6090" data-line-number="6090"></td>
        <td id="LC6090">    <span><span>//</span> thread.</span></td>
      </tr>
      <tr>
        <td id="L6091" data-line-number="6091"></td>
        <td id="LC6091">    <span>if</span> ((m_helperThreadId != <span>0</span>) &amp;&amp; !m_helperThreadDead)</td>
      </tr>
      <tr>
        <td id="L6092" data-line-number="6092"></td>
        <td id="LC6092">    {</td>
      </tr>
      <tr>
        <td id="L6093" data-line-number="6093"></td>
        <td id="LC6093">        *pThreadID = m_helperThreadId;</td>
      </tr>
      <tr>
        <td id="L6094" data-line-number="6094"></td>
        <td id="LC6094">    }</td>
      </tr>
      <tr>
        <td id="L6095" data-line-number="6095"></td>
        <td id="LC6095">    <span>else</span> <span>if</span> ((<span>GetDCB</span>() != <span>NULL</span>) &amp;&amp; (<span>GetDCB</span>()-&gt;<span>m_helperThreadId</span> != <span>0</span>))</td>
      </tr>
      <tr>
        <td id="L6096" data-line-number="6096"></td>
        <td id="LC6096">    {</td>
      </tr>
      <tr>
        <td id="L6097" data-line-number="6097"></td>
        <td id="LC6097">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L6098" data-line-number="6098"></td>
        <td id="LC6098">        {</td>
      </tr>
      <tr>
        <td id="L6099" data-line-number="6099"></td>
        <td id="LC6099">            <span><span>//</span> be sure we have the latest information</span></td>
      </tr>
      <tr>
        <td id="L6100" data-line-number="6100"></td>
        <td id="LC6100">            <span>UpdateRightSideDCB</span>();</td>
      </tr>
      <tr>
        <td id="L6101" data-line-number="6101"></td>
        <td id="LC6101">            *pThreadID = <span>GetDCB</span>()-&gt;<span>m_helperThreadId</span>;</td>
      </tr>
      <tr>
        <td id="L6102" data-line-number="6102"></td>
        <td id="LC6102">        }</td>
      </tr>
      <tr>
        <td id="L6103" data-line-number="6103"></td>
        <td id="LC6103">        <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L6104" data-line-number="6104"></td>
        <td id="LC6104">
</td>
      </tr>
      <tr>
        <td id="L6105" data-line-number="6105"></td>
        <td id="LC6105">    }</td>
      </tr>
      <tr>
        <td id="L6106" data-line-number="6106"></td>
        <td id="LC6106">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L6107" data-line-number="6107"></td>
        <td id="LC6107">    {</td>
      </tr>
      <tr>
        <td id="L6108" data-line-number="6108"></td>
        <td id="LC6108">        *pThreadID = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6109" data-line-number="6109"></td>
        <td id="LC6109">    }</td>
      </tr>
      <tr>
        <td id="L6110" data-line-number="6110"></td>
        <td id="LC6110">
</td>
      </tr>
      <tr>
        <td id="L6111" data-line-number="6111"></td>
        <td id="LC6111">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L6112" data-line-number="6112"></td>
        <td id="LC6112">}</td>
      </tr>
      <tr>
        <td id="L6113" data-line-number="6113"></td>
        <td id="LC6113">
</td>
      </tr>
      <tr>
        <td id="L6114" data-line-number="6114"></td>
        <td id="LC6114"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L6115" data-line-number="6115"></td>
        <td id="LC6115"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6116" data-line-number="6116"></td>
        <td id="LC6116"><span><span>//</span> Sends IPC event to set all the managed threads, except for the one given, to the given state</span></td>
      </tr>
      <tr>
        <td id="L6117" data-line-number="6117"></td>
        <td id="LC6117"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6118" data-line-number="6118"></td>
        <td id="LC6118"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L6119" data-line-number="6119"></td>
        <td id="LC6119"><span><span>//</span>     state - The state to set the threads to.</span></td>
      </tr>
      <tr>
        <td id="L6120" data-line-number="6120"></td>
        <td id="LC6120"><span><span>//</span>     pExceptThread - The thread to not set.  This is usually the thread that is currently</span></td>
      </tr>
      <tr>
        <td id="L6121" data-line-number="6121"></td>
        <td id="LC6121"><span><span>//</span>         sending an IPC event to the RS, and should be excluded.</span></td>
      </tr>
      <tr>
        <td id="L6122" data-line-number="6122"></td>
        <td id="LC6122"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6123" data-line-number="6123"></td>
        <td id="LC6123"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L6124" data-line-number="6124"></td>
        <td id="LC6124"><span><span>//</span>     Typical HRESULT symantics, nothing abnormal.</span></td>
      </tr>
      <tr>
        <td id="L6125" data-line-number="6125"></td>
        <td id="LC6125"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6126" data-line-number="6126"></td>
        <td id="LC6126">HRESULT <span>CordbProcess::SetAllThreadsDebugState</span>(CorDebugThreadState state,</td>
      </tr>
      <tr>
        <td id="L6127" data-line-number="6127"></td>
        <td id="LC6127">                                              ICorDebugThread * pExceptThread)</td>
      </tr>
      <tr>
        <td id="L6128" data-line-number="6128"></td>
        <td id="LC6128">{</td>
      </tr>
      <tr>
        <td id="L6129" data-line-number="6129"></td>
        <td id="LC6129">    <span>PUBLIC_REENTRANT_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6130" data-line-number="6130"></td>
        <td id="LC6130">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6131" data-line-number="6131"></td>
        <td id="LC6131">    <span>VALIDATE_POINTER_TO_OBJECT_OR_NULL</span>(pExceptThread, ICorDebugThread *);</td>
      </tr>
      <tr>
        <td id="L6132" data-line-number="6132"></td>
        <td id="LC6132">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6133" data-line-number="6133"></td>
        <td id="LC6133">
</td>
      </tr>
      <tr>
        <td id="L6134" data-line-number="6134"></td>
        <td id="LC6134">    <span>if</span> (<span>GetShim</span>() == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6135" data-line-number="6135"></td>
        <td id="LC6135">    {</td>
      </tr>
      <tr>
        <td id="L6136" data-line-number="6136"></td>
        <td id="LC6136">        <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L6137" data-line-number="6137"></td>
        <td id="LC6137">    }</td>
      </tr>
      <tr>
        <td id="L6138" data-line-number="6138"></td>
        <td id="LC6138">    CordbThread * pCordbExceptThread = <span>static_cast</span>&lt;CordbThread *&gt; (pExceptThread);</td>
      </tr>
      <tr>
        <td id="L6139" data-line-number="6139"></td>
        <td id="LC6139">
</td>
      </tr>
      <tr>
        <td id="L6140" data-line-number="6140"></td>
        <td id="LC6140">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::SATDS: except thread=0x%08x 0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L6141" data-line-number="6141"></td>
        <td id="LC6141">         pExceptThread,</td>
      </tr>
      <tr>
        <td id="L6142" data-line-number="6142"></td>
        <td id="LC6142">         (pCordbExceptThread != <span>NULL</span>) ? pCordbExceptThread-&gt;<span>m_id</span> : <span>0</span>));</td>
      </tr>
      <tr>
        <td id="L6143" data-line-number="6143"></td>
        <td id="LC6143">
</td>
      </tr>
      <tr>
        <td id="L6144" data-line-number="6144"></td>
        <td id="LC6144">    <span><span>//</span> Send one event to the Left Side to twiddle each thread's state.</span></td>
      </tr>
      <tr>
        <td id="L6145" data-line-number="6145"></td>
        <td id="LC6145">    DebuggerIPCEvent event;</td>
      </tr>
      <tr>
        <td id="L6146" data-line-number="6146"></td>
        <td id="LC6146">
</td>
      </tr>
      <tr>
        <td id="L6147" data-line-number="6147"></td>
        <td id="LC6147">    <span>InitIPCEvent</span>(&amp;event, DB_IPCE_SET_ALL_DEBUG_STATE, <span>true</span>, <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L6148" data-line-number="6148"></td>
        <td id="LC6148">
</td>
      </tr>
      <tr>
        <td id="L6149" data-line-number="6149"></td>
        <td id="LC6149">    event.<span>SetAllDebugState</span>.<span>vmThreadToken</span> = ((pCordbExceptThread != <span>NULL</span>) ?</td>
      </tr>
      <tr>
        <td id="L6150" data-line-number="6150"></td>
        <td id="LC6150">                                            pCordbExceptThread-&gt;<span>m_vmThreadToken</span> : <span>VMPTR_Thread::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L6151" data-line-number="6151"></td>
        <td id="LC6151">
</td>
      </tr>
      <tr>
        <td id="L6152" data-line-number="6152"></td>
        <td id="LC6152">    event.<span>SetAllDebugState</span>.<span>debugState</span> = state;</td>
      </tr>
      <tr>
        <td id="L6153" data-line-number="6153"></td>
        <td id="LC6153">
</td>
      </tr>
      <tr>
        <td id="L6154" data-line-number="6154"></td>
        <td id="LC6154">    HRESULT hr = <span>SendIPCEvent</span>(&amp;event, <span>sizeof</span>(DebuggerIPCEvent));</td>
      </tr>
      <tr>
        <td id="L6155" data-line-number="6155"></td>
        <td id="LC6155">
</td>
      </tr>
      <tr>
        <td id="L6156" data-line-number="6156"></td>
        <td id="LC6156">    hr = <span>WORST_HR</span>(hr, event.<span>hr</span>);</td>
      </tr>
      <tr>
        <td id="L6157" data-line-number="6157"></td>
        <td id="LC6157">
</td>
      </tr>
      <tr>
        <td id="L6158" data-line-number="6158"></td>
        <td id="LC6158">    <span><span>//</span> If that worked, then loop over all the threads on this side and set their states.</span></td>
      </tr>
      <tr>
        <td id="L6159" data-line-number="6159"></td>
        <td id="LC6159">    <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L6160" data-line-number="6160"></td>
        <td id="LC6160">    {</td>
      </tr>
      <tr>
        <td id="L6161" data-line-number="6161"></td>
        <td id="LC6161">        RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6162" data-line-number="6162"></td>
        <td id="LC6162">        HASHFIND hashFind;</td>
      </tr>
      <tr>
        <td id="L6163" data-line-number="6163"></td>
        <td id="LC6163">        CordbThread * pThread;</td>
      </tr>
      <tr>
        <td id="L6164" data-line-number="6164"></td>
        <td id="LC6164">
</td>
      </tr>
      <tr>
        <td id="L6165" data-line-number="6165"></td>
        <td id="LC6165">        <span><span>//</span> We don't need to prepopulate here (to collect LS state) because we're just updating RS state.</span></td>
      </tr>
      <tr>
        <td id="L6166" data-line-number="6166"></td>
        <td id="LC6166">        <span>for</span> (pThread = m_userThreads.<span>FindFirst</span>(&amp;hashFind);</td>
      </tr>
      <tr>
        <td id="L6167" data-line-number="6167"></td>
        <td id="LC6167">              pThread != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L6168" data-line-number="6168"></td>
        <td id="LC6168">              pThread = m_userThreads.<span>FindNext</span>(&amp;hashFind))</td>
      </tr>
      <tr>
        <td id="L6169" data-line-number="6169"></td>
        <td id="LC6169">        {</td>
      </tr>
      <tr>
        <td id="L6170" data-line-number="6170"></td>
        <td id="LC6170">            <span>if</span> (pThread != pCordbExceptThread)</td>
      </tr>
      <tr>
        <td id="L6171" data-line-number="6171"></td>
        <td id="LC6171">            {</td>
      </tr>
      <tr>
        <td id="L6172" data-line-number="6172"></td>
        <td id="LC6172">                pThread-&gt;<span>m_debugState</span> = state;</td>
      </tr>
      <tr>
        <td id="L6173" data-line-number="6173"></td>
        <td id="LC6173">            }</td>
      </tr>
      <tr>
        <td id="L6174" data-line-number="6174"></td>
        <td id="LC6174">        }</td>
      </tr>
      <tr>
        <td id="L6175" data-line-number="6175"></td>
        <td id="LC6175">    }</td>
      </tr>
      <tr>
        <td id="L6176" data-line-number="6176"></td>
        <td id="LC6176">
</td>
      </tr>
      <tr>
        <td id="L6177" data-line-number="6177"></td>
        <td id="LC6177">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L6178" data-line-number="6178"></td>
        <td id="LC6178">}</td>
      </tr>
      <tr>
        <td id="L6179" data-line-number="6179"></td>
        <td id="LC6179">
</td>
      </tr>
      <tr>
        <td id="L6180" data-line-number="6180"></td>
        <td id="LC6180">
</td>
      </tr>
      <tr>
        <td id="L6181" data-line-number="6181"></td>
        <td id="LC6181">HRESULT <span>CordbProcess::EnumerateObjects</span>(ICorDebugObjectEnum **ppObjects)</td>
      </tr>
      <tr>
        <td id="L6182" data-line-number="6182"></td>
        <td id="LC6182">{</td>
      </tr>
      <tr>
        <td id="L6183" data-line-number="6183"></td>
        <td id="LC6183">    <span><span>/*</span> !!! <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6184" data-line-number="6184"></td>
        <td id="LC6184">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6185" data-line-number="6185"></td>
        <td id="LC6185">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6186" data-line-number="6186"></td>
        <td id="LC6186">    <span>VALIDATE_POINTER_TO_OBJECT</span>(ppObjects, ICorDebugObjectEnum **);</td>
      </tr>
      <tr>
        <td id="L6187" data-line-number="6187"></td>
        <td id="LC6187">
</td>
      </tr>
      <tr>
        <td id="L6188" data-line-number="6188"></td>
        <td id="LC6188">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L6189" data-line-number="6189"></td>
        <td id="LC6189">}</td>
      </tr>
      <tr>
        <td id="L6190" data-line-number="6190"></td>
        <td id="LC6190">
</td>
      </tr>
      <tr>
        <td id="L6191" data-line-number="6191"></td>
        <td id="LC6191"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L6192" data-line-number="6192"></td>
        <td id="LC6192"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6193" data-line-number="6193"></td>
        <td id="LC6193"><span><span>//</span> Determines if the target address is a "CLR transition stub".</span></td>
      </tr>
      <tr>
        <td id="L6194" data-line-number="6194"></td>
        <td id="LC6194"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6195" data-line-number="6195"></td>
        <td id="LC6195"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L6196" data-line-number="6196"></td>
        <td id="LC6196"><span><span>//</span>     address - The address of an instruction to check in the target address space.</span></td>
      </tr>
      <tr>
        <td id="L6197" data-line-number="6197"></td>
        <td id="LC6197"><span><span>//</span>     pfTransitionStub - Space to store the result, TRUE if the address belongs to a</span></td>
      </tr>
      <tr>
        <td id="L6198" data-line-number="6198"></td>
        <td id="LC6198"><span><span>//</span>         transition stub, FALSE if not.  Only valid if this method returns a success code.</span></td>
      </tr>
      <tr>
        <td id="L6199" data-line-number="6199"></td>
        <td id="LC6199"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6200" data-line-number="6200"></td>
        <td id="LC6200"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L6201" data-line-number="6201"></td>
        <td id="LC6201"><span><span>//</span>     Typical HRESULT symantics, nothing abnormal.</span></td>
      </tr>
      <tr>
        <td id="L6202" data-line-number="6202"></td>
        <td id="LC6202"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6203" data-line-number="6203"></td>
        <td id="LC6203"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L6204" data-line-number="6204"></td>
        <td id="LC6204">HRESULT <span>CordbProcess::IsTransitionStub</span>(CORDB_ADDRESS address, BOOL *pfTransitionStub)</td>
      </tr>
      <tr>
        <td id="L6205" data-line-number="6205"></td>
        <td id="LC6205">{</td>
      </tr>
      <tr>
        <td id="L6206" data-line-number="6206"></td>
        <td id="LC6206">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6207" data-line-number="6207"></td>
        <td id="LC6207">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6208" data-line-number="6208"></td>
        <td id="LC6208">    <span>VALIDATE_POINTER_TO_OBJECT</span>(pfTransitionStub, BOOL *);</td>
      </tr>
      <tr>
        <td id="L6209" data-line-number="6209"></td>
        <td id="LC6209">
</td>
      </tr>
      <tr>
        <td id="L6210" data-line-number="6210"></td>
        <td id="LC6210">    <span><span>//</span> Default to FALSE</span></td>
      </tr>
      <tr>
        <td id="L6211" data-line-number="6211"></td>
        <td id="LC6211">    *pfTransitionStub = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L6212" data-line-number="6212"></td>
        <td id="LC6212">
</td>
      </tr>
      <tr>
        <td id="L6213" data-line-number="6213"></td>
        <td id="LC6213">    <span>if</span> (<span>this</span>-&gt;<span>m_helperThreadDead</span>)</td>
      </tr>
      <tr>
        <td id="L6214" data-line-number="6214"></td>
        <td id="LC6214">    {</td>
      </tr>
      <tr>
        <td id="L6215" data-line-number="6215"></td>
        <td id="LC6215">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6216" data-line-number="6216"></td>
        <td id="LC6216">    }</td>
      </tr>
      <tr>
        <td id="L6217" data-line-number="6217"></td>
        <td id="LC6217">
</td>
      </tr>
      <tr>
        <td id="L6218" data-line-number="6218"></td>
        <td id="LC6218">    <span><span>//</span> If we're not initialized, then it can't be a stub...</span></td>
      </tr>
      <tr>
        <td id="L6219" data-line-number="6219"></td>
        <td id="LC6219">    <span>if</span> (!m_initialized)</td>
      </tr>
      <tr>
        <td id="L6220" data-line-number="6220"></td>
        <td id="LC6220">    {</td>
      </tr>
      <tr>
        <td id="L6221" data-line-number="6221"></td>
        <td id="LC6221">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6222" data-line-number="6222"></td>
        <td id="LC6222">    }</td>
      </tr>
      <tr>
        <td id="L6223" data-line-number="6223"></td>
        <td id="LC6223">
</td>
      </tr>
      <tr>
        <td id="L6224" data-line-number="6224"></td>
        <td id="LC6224">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6225" data-line-number="6225"></td>
        <td id="LC6225">
</td>
      </tr>
      <tr>
        <td id="L6226" data-line-number="6226"></td>
        <td id="LC6226">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L6227" data-line-number="6227"></td>
        <td id="LC6227">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L6228" data-line-number="6228"></td>
        <td id="LC6228">    {</td>
      </tr>
      <tr>
        <td id="L6229" data-line-number="6229"></td>
        <td id="LC6229">        DebuggerIPCEvent eventData;</td>
      </tr>
      <tr>
        <td id="L6230" data-line-number="6230"></td>
        <td id="LC6230">
</td>
      </tr>
      <tr>
        <td id="L6231" data-line-number="6231"></td>
        <td id="LC6231">        <span>InitIPCEvent</span>(&amp;eventData, DB_IPCE_IS_TRANSITION_STUB, <span>true</span>, <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L6232" data-line-number="6232"></td>
        <td id="LC6232">
</td>
      </tr>
      <tr>
        <td id="L6233" data-line-number="6233"></td>
        <td id="LC6233">        eventData.<span>IsTransitionStub</span>.<span>address</span> = <span>CORDB_ADDRESS_TO_PTR</span>(address);</td>
      </tr>
      <tr>
        <td id="L6234" data-line-number="6234"></td>
        <td id="LC6234">
</td>
      </tr>
      <tr>
        <td id="L6235" data-line-number="6235"></td>
        <td id="LC6235">        hr = <span>SendIPCEvent</span>(&amp;eventData, <span>sizeof</span>(eventData));</td>
      </tr>
      <tr>
        <td id="L6236" data-line-number="6236"></td>
        <td id="LC6236">        hr = <span>WORST_HR</span>(hr, eventData.<span>hr</span>);</td>
      </tr>
      <tr>
        <td id="L6237" data-line-number="6237"></td>
        <td id="LC6237">        <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L6238" data-line-number="6238"></td>
        <td id="LC6238">
</td>
      </tr>
      <tr>
        <td id="L6239" data-line-number="6239"></td>
        <td id="LC6239">        <span>_ASSERTE</span>(eventData.<span>type</span> == DB_IPCE_IS_TRANSITION_STUB_RESULT);</td>
      </tr>
      <tr>
        <td id="L6240" data-line-number="6240"></td>
        <td id="LC6240">
</td>
      </tr>
      <tr>
        <td id="L6241" data-line-number="6241"></td>
        <td id="LC6241">        *pfTransitionStub = eventData.<span>IsTransitionStubResult</span>.<span>isStub</span>;</td>
      </tr>
      <tr>
        <td id="L6242" data-line-number="6242"></td>
        <td id="LC6242">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::ITS: addr=0x%p result=%d<span>\n</span><span>"</span></span>, address, *pfTransitionStub));</td>
      </tr>
      <tr>
        <td id="L6243" data-line-number="6243"></td>
        <td id="LC6243">        <span><span>//</span> @todo - beware that IsTransitionStub has a very important sideeffect - it synchronizes the runtime!</span></td>
      </tr>
      <tr>
        <td id="L6244" data-line-number="6244"></td>
        <td id="LC6244">        <span><span>//</span> This for example covers an OS bug where SetThreadContext may silently fail if we're not synchronized.</span></td>
      </tr>
      <tr>
        <td id="L6245" data-line-number="6245"></td>
        <td id="LC6245">        <span><span>//</span> (See IMDArocess::SetThreadContext for details on that bug).</span></td>
      </tr>
      <tr>
        <td id="L6246" data-line-number="6246"></td>
        <td id="LC6246">        <span><span>//</span> If we ever stop using IPC events here and only use DAC; we need to be aware of that.</span></td>
      </tr>
      <tr>
        <td id="L6247" data-line-number="6247"></td>
        <td id="LC6247">
</td>
      </tr>
      <tr>
        <td id="L6248" data-line-number="6248"></td>
        <td id="LC6248">        <span><span>//</span> Check against DAC primitives</span></td>
      </tr>
      <tr>
        <td id="L6249" data-line-number="6249"></td>
        <td id="LC6249">        {</td>
      </tr>
      <tr>
        <td id="L6250" data-line-number="6250"></td>
        <td id="LC6250">            BOOL <span>fIsStub2</span> = <span>GetDAC</span>()-&gt;<span>IsTransitionStub</span>(address);</td>
      </tr>
      <tr>
        <td id="L6251" data-line-number="6251"></td>
        <td id="LC6251">            (<span>void</span>)<span>fIsStub2</span>; <span><span>//</span>prevent "unused variable" error from GCC</span></td>
      </tr>
      <tr>
        <td id="L6252" data-line-number="6252"></td>
        <td id="LC6252">            <span>CONSISTENCY_CHECK_MSGF</span>(*pfTransitionStub == <span>fIsStub2</span>, (<span><span>"</span>IsStub2 failed, DAC2:%d, IPC:%d, addr:0x%p<span>"</span></span>, (<span>int</span>) <span>fIsStub2</span>, (<span>int</span>) *pfTransitionStub, <span>CORDB_ADDRESS_TO_PTR</span>(address)));</td>
      </tr>
      <tr>
        <td id="L6253" data-line-number="6253"></td>
        <td id="LC6253">
</td>
      </tr>
      <tr>
        <td id="L6254" data-line-number="6254"></td>
        <td id="LC6254">        }</td>
      </tr>
      <tr>
        <td id="L6255" data-line-number="6255"></td>
        <td id="LC6255">    }</td>
      </tr>
      <tr>
        <td id="L6256" data-line-number="6256"></td>
        <td id="LC6256">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L6257" data-line-number="6257"></td>
        <td id="LC6257">    <span>if</span>(<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L6258" data-line-number="6258"></td>
        <td id="LC6258">    {</td>
      </tr>
      <tr>
        <td id="L6259" data-line-number="6259"></td>
        <td id="LC6259">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::ITS: FAILED hr=0x%x<span>\n</span><span>"</span></span>, hr));</td>
      </tr>
      <tr>
        <td id="L6260" data-line-number="6260"></td>
        <td id="LC6260">    }</td>
      </tr>
      <tr>
        <td id="L6261" data-line-number="6261"></td>
        <td id="LC6261">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L6262" data-line-number="6262"></td>
        <td id="LC6262">}</td>
      </tr>
      <tr>
        <td id="L6263" data-line-number="6263"></td>
        <td id="LC6263">
</td>
      </tr>
      <tr>
        <td id="L6264" data-line-number="6264"></td>
        <td id="LC6264">
</td>
      </tr>
      <tr>
        <td id="L6265" data-line-number="6265"></td>
        <td id="LC6265">HRESULT <span>CordbProcess::SetStopState</span>(DWORD threadID, CorDebugThreadState state)</td>
      </tr>
      <tr>
        <td id="L6266" data-line-number="6266"></td>
        <td id="LC6266">{</td>
      </tr>
      <tr>
        <td id="L6267" data-line-number="6267"></td>
        <td id="LC6267">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6268" data-line-number="6268"></td>
        <td id="LC6268">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6269" data-line-number="6269"></td>
        <td id="LC6269">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L6270" data-line-number="6270"></td>
        <td id="LC6270">}</td>
      </tr>
      <tr>
        <td id="L6271" data-line-number="6271"></td>
        <td id="LC6271">
</td>
      </tr>
      <tr>
        <td id="L6272" data-line-number="6272"></td>
        <td id="LC6272">HRESULT <span>CordbProcess::IsOSSuspended</span>(DWORD threadID, BOOL *pbSuspended)</td>
      </tr>
      <tr>
        <td id="L6273" data-line-number="6273"></td>
        <td id="LC6273">{</td>
      </tr>
      <tr>
        <td id="L6274" data-line-number="6274"></td>
        <td id="LC6274">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6275" data-line-number="6275"></td>
        <td id="LC6275">    <span><span>//</span> Gotta have a place for the result!</span></td>
      </tr>
      <tr>
        <td id="L6276" data-line-number="6276"></td>
        <td id="LC6276">    <span>if</span> (!pbSuspended)</td>
      </tr>
      <tr>
        <td id="L6277" data-line-number="6277"></td>
        <td id="LC6277">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L6278" data-line-number="6278"></td>
        <td id="LC6278">
</td>
      </tr>
      <tr>
        <td id="L6279" data-line-number="6279"></td>
        <td id="LC6279">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6280" data-line-number="6280"></td>
        <td id="LC6280">
</td>
      </tr>
      <tr>
        <td id="L6281" data-line-number="6281"></td>
        <td id="LC6281">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L6282" data-line-number="6282"></td>
        <td id="LC6282">    RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6283" data-line-number="6283"></td>
        <td id="LC6283">
</td>
      </tr>
      <tr>
        <td id="L6284" data-line-number="6284"></td>
        <td id="LC6284">    <span><span>//</span> Have we seen this thread?</span></td>
      </tr>
      <tr>
        <td id="L6285" data-line-number="6285"></td>
        <td id="LC6285">    CordbUnmanagedThread *ut = <span>GetUnmanagedThread</span>(threadID);</td>
      </tr>
      <tr>
        <td id="L6286" data-line-number="6286"></td>
        <td id="LC6286">
</td>
      </tr>
      <tr>
        <td id="L6287" data-line-number="6287"></td>
        <td id="LC6287">    <span><span>//</span> If we have, and if we've suspended it, then say so.</span></td>
      </tr>
      <tr>
        <td id="L6288" data-line-number="6288"></td>
        <td id="LC6288">    <span>if</span> (ut &amp;&amp; ut-&gt;<span>IsSuspended</span>())</td>
      </tr>
      <tr>
        <td id="L6289" data-line-number="6289"></td>
        <td id="LC6289">    {</td>
      </tr>
      <tr>
        <td id="L6290" data-line-number="6290"></td>
        <td id="LC6290">        *pbSuspended = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L6291" data-line-number="6291"></td>
        <td id="LC6291">    }</td>
      </tr>
      <tr>
        <td id="L6292" data-line-number="6292"></td>
        <td id="LC6292">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L6293" data-line-number="6293"></td>
        <td id="LC6293">    {</td>
      </tr>
      <tr>
        <td id="L6294" data-line-number="6294"></td>
        <td id="LC6294">        *pbSuspended = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L6295" data-line-number="6295"></td>
        <td id="LC6295">    }</td>
      </tr>
      <tr>
        <td id="L6296" data-line-number="6296"></td>
        <td id="LC6296">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L6297" data-line-number="6297"></td>
        <td id="LC6297">    <span><span>//</span> Not interop-debugging, we never OS suspend.</span></td>
      </tr>
      <tr>
        <td id="L6298" data-line-number="6298"></td>
        <td id="LC6298">    *pbSuspended = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L6299" data-line-number="6299"></td>
        <td id="LC6299">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6300" data-line-number="6300"></td>
        <td id="LC6300">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6301" data-line-number="6301"></td>
        <td id="LC6301">}</td>
      </tr>
      <tr>
        <td id="L6302" data-line-number="6302"></td>
        <td id="LC6302">
</td>
      </tr>
      <tr>
        <td id="L6303" data-line-number="6303"></td>
        <td id="LC6303"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6304" data-line-number="6304"></td>
        <td id="LC6304"><span><span>//</span> This routine reads a thread context from the process being debugged, taking into account the fact that the context</span></td>
      </tr>
      <tr>
        <td id="L6305" data-line-number="6305"></td>
        <td id="LC6305"><span><span>//</span> record may be a different size than the one we compiled with. On systems &lt; NT5, then OS doesn't usually allocate</span></td>
      </tr>
      <tr>
        <td id="L6306" data-line-number="6306"></td>
        <td id="LC6306"><span><span>//</span> space for the extended registers. However, the CONTEXT struct that we compile with does have this space.</span></td>
      </tr>
      <tr>
        <td id="L6307" data-line-number="6307"></td>
        <td id="LC6307"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6308" data-line-number="6308"></td>
        <td id="LC6308">HRESULT <span>CordbProcess::SafeReadThreadContext</span>(LSPTR_CONTEXT pContext, DT_CONTEXT * pCtx)</td>
      </tr>
      <tr>
        <td id="L6309" data-line-number="6309"></td>
        <td id="LC6309">{</td>
      </tr>
      <tr>
        <td id="L6310" data-line-number="6310"></td>
        <td id="LC6310">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L6311" data-line-number="6311"></td>
        <td id="LC6311">
</td>
      </tr>
      <tr>
        <td id="L6312" data-line-number="6312"></td>
        <td id="LC6312">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6313" data-line-number="6313"></td>
        <td id="LC6313">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6314" data-line-number="6314"></td>
        <td id="LC6314">
</td>
      </tr>
      <tr>
        <td id="L6315" data-line-number="6315"></td>
        <td id="LC6315">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L6316" data-line-number="6316"></td>
        <td id="LC6316">    {</td>
      </tr>
      <tr>
        <td id="L6317" data-line-number="6317"></td>
        <td id="LC6317">
</td>
      </tr>
      <tr>
        <td id="L6318" data-line-number="6318"></td>
        <td id="LC6318">        <span>void</span> *pRemoteContext = pContext.<span>UnsafeGet</span>();</td>
      </tr>
      <tr>
        <td id="L6319" data-line-number="6319"></td>
        <td id="LC6319">        TargetBuffer <span>tbFull</span>(pRemoteContext, <span>sizeof</span>(DT_CONTEXT));</td>
      </tr>
      <tr>
        <td id="L6320" data-line-number="6320"></td>
        <td id="LC6320">
</td>
      </tr>
      <tr>
        <td id="L6321" data-line-number="6321"></td>
        <td id="LC6321">        <span><span>//</span> The context may have 2 parts:</span></td>
      </tr>
      <tr>
        <td id="L6322" data-line-number="6322"></td>
        <td id="LC6322">        <span><span>//</span> 1. Base register, which are always present.</span></td>
      </tr>
      <tr>
        <td id="L6323" data-line-number="6323"></td>
        <td id="LC6323">        <span><span>//</span> 2. Optional extended registers, which are only present if CONTEXT_EXTENDED_REGISTERS is set</span></td>
      </tr>
      <tr>
        <td id="L6324" data-line-number="6324"></td>
        <td id="LC6324">        <span><span>//</span>    in the flags.</span></td>
      </tr>
      <tr>
        <td id="L6325" data-line-number="6325"></td>
        <td id="LC6325">
</td>
      </tr>
      <tr>
        <td id="L6326" data-line-number="6326"></td>
        <td id="LC6326">        <span><span>//</span> At a minimum we have room for a whole context up to the extended registers.</span></td>
      </tr>
      <tr>
        <td id="L6327" data-line-number="6327"></td>
        <td id="LC6327">    #<span>if</span> defined(DT_CONTEXT_EXTENDED_REGISTERS)</td>
      </tr>
      <tr>
        <td id="L6328" data-line-number="6328"></td>
        <td id="LC6328">        ULONG32 minContextSize = <span>offsetof</span>(DT_CONTEXT, ExtendedRegisters);</td>
      </tr>
      <tr>
        <td id="L6329" data-line-number="6329"></td>
        <td id="LC6329">    #<span>else</span></td>
      </tr>
      <tr>
        <td id="L6330" data-line-number="6330"></td>
        <td id="LC6330">        ULONG32 minContextSize = <span>sizeof</span>(DT_CONTEXT);</td>
      </tr>
      <tr>
        <td id="L6331" data-line-number="6331"></td>
        <td id="LC6331">    #<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6332" data-line-number="6332"></td>
        <td id="LC6332">
</td>
      </tr>
      <tr>
        <td id="L6333" data-line-number="6333"></td>
        <td id="LC6333">        <span><span>//</span> Read the minimum part.</span></td>
      </tr>
      <tr>
        <td id="L6334" data-line-number="6334"></td>
        <td id="LC6334">        TargetBuffer tbMin = tbFull.<span>SubBuffer</span>(<span>0</span>, minContextSize);</td>
      </tr>
      <tr>
        <td id="L6335" data-line-number="6335"></td>
        <td id="LC6335">        <span>SafeReadBuffer</span>(tbMin, (BYTE*) pCtx);</td>
      </tr>
      <tr>
        <td id="L6336" data-line-number="6336"></td>
        <td id="LC6336">
</td>
      </tr>
      <tr>
        <td id="L6337" data-line-number="6337"></td>
        <td id="LC6337">    #<span>if</span> defined(DT_CONTEXT_EXTENDED_REGISTERS)</td>
      </tr>
      <tr>
        <td id="L6338" data-line-number="6338"></td>
        <td id="LC6338">        <span>void</span> *pCurExtReg = (<span>void</span>*)((UINT_PTR)pCtx + minContextSize);</td>
      </tr>
      <tr>
        <td id="L6339" data-line-number="6339"></td>
        <td id="LC6339">        TargetBuffer tbExtended = tbFull.<span>SubBuffer</span>(minContextSize);</td>
      </tr>
      <tr>
        <td id="L6340" data-line-number="6340"></td>
        <td id="LC6340">
</td>
      </tr>
      <tr>
        <td id="L6341" data-line-number="6341"></td>
        <td id="LC6341">        <span><span>//</span> Now, read the extended registers if the context contains them. If the context does not have extended registers,</span></td>
      </tr>
      <tr>
        <td id="L6342" data-line-number="6342"></td>
        <td id="LC6342">        <span><span>//</span> just set them to zero.</span></td>
      </tr>
      <tr>
        <td id="L6343" data-line-number="6343"></td>
        <td id="LC6343">        <span>if</span> (<span>SUCCEEDED</span>(hr) &amp;&amp; (pCtx-&gt;<span>ContextFlags</span> &amp; CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS)</td>
      </tr>
      <tr>
        <td id="L6344" data-line-number="6344"></td>
        <td id="LC6344">        {</td>
      </tr>
      <tr>
        <td id="L6345" data-line-number="6345"></td>
        <td id="LC6345">            <span>SafeReadBuffer</span>(tbExtended, (BYTE*) pCurExtReg);</td>
      </tr>
      <tr>
        <td id="L6346" data-line-number="6346"></td>
        <td id="LC6346">        }</td>
      </tr>
      <tr>
        <td id="L6347" data-line-number="6347"></td>
        <td id="LC6347">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L6348" data-line-number="6348"></td>
        <td id="LC6348">        {</td>
      </tr>
      <tr>
        <td id="L6349" data-line-number="6349"></td>
        <td id="LC6349">            <span>memset</span>(pCurExtReg, <span>0</span>, tbExtended.<span>cbSize</span>);</td>
      </tr>
      <tr>
        <td id="L6350" data-line-number="6350"></td>
        <td id="LC6350">        }</td>
      </tr>
      <tr>
        <td id="L6351" data-line-number="6351"></td>
        <td id="LC6351">    #<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6352" data-line-number="6352"></td>
        <td id="LC6352">
</td>
      </tr>
      <tr>
        <td id="L6353" data-line-number="6353"></td>
        <td id="LC6353">    }</td>
      </tr>
      <tr>
        <td id="L6354" data-line-number="6354"></td>
        <td id="LC6354">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L6355" data-line-number="6355"></td>
        <td id="LC6355">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L6356" data-line-number="6356"></td>
        <td id="LC6356">}</td>
      </tr>
      <tr>
        <td id="L6357" data-line-number="6357"></td>
        <td id="LC6357">
</td>
      </tr>
      <tr>
        <td id="L6358" data-line-number="6358"></td>
        <td id="LC6358"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6359" data-line-number="6359"></td>
        <td id="LC6359"><span><span>//</span> This routine writes a thread context to the process being debugged, taking into account the fact that the context</span></td>
      </tr>
      <tr>
        <td id="L6360" data-line-number="6360"></td>
        <td id="LC6360"><span><span>//</span> record may be a different size than the one we compiled with. On systems &lt; NT5, then OS doesn't usually allocate</span></td>
      </tr>
      <tr>
        <td id="L6361" data-line-number="6361"></td>
        <td id="LC6361"><span><span>//</span> space for the extended registers. However, the CONTEXT struct that we compile with does have this space.</span></td>
      </tr>
      <tr>
        <td id="L6362" data-line-number="6362"></td>
        <td id="LC6362"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6363" data-line-number="6363"></td>
        <td id="LC6363">HRESULT <span>CordbProcess::SafeWriteThreadContext</span>(LSPTR_CONTEXT pContext, <span>const</span> DT_CONTEXT * pCtx)</td>
      </tr>
      <tr>
        <td id="L6364" data-line-number="6364"></td>
        <td id="LC6364">{</td>
      </tr>
      <tr>
        <td id="L6365" data-line-number="6365"></td>
        <td id="LC6365">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6366" data-line-number="6366"></td>
        <td id="LC6366">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6367" data-line-number="6367"></td>
        <td id="LC6367">
</td>
      </tr>
      <tr>
        <td id="L6368" data-line-number="6368"></td>
        <td id="LC6368">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L6369" data-line-number="6369"></td>
        <td id="LC6369">    DWORD sizeToWrite = <span>sizeof</span>(DT_CONTEXT);</td>
      </tr>
      <tr>
        <td id="L6370" data-line-number="6370"></td>
        <td id="LC6370">
</td>
      </tr>
      <tr>
        <td id="L6371" data-line-number="6371"></td>
        <td id="LC6371">    BYTE * pRemoteContext = (BYTE*) pContext.<span>UnsafeGet</span>();</td>
      </tr>
      <tr>
        <td id="L6372" data-line-number="6372"></td>
        <td id="LC6372">    BYTE * pCtxSource = (BYTE*) pCtx;</td>
      </tr>
      <tr>
        <td id="L6373" data-line-number="6373"></td>
        <td id="LC6373">
</td>
      </tr>
      <tr>
        <td id="L6374" data-line-number="6374"></td>
        <td id="LC6374">
</td>
      </tr>
      <tr>
        <td id="L6375" data-line-number="6375"></td>
        <td id="LC6375">#<span>if</span> defined(DT_CONTEXT_EXTENDED_REGISTERS)</td>
      </tr>
      <tr>
        <td id="L6376" data-line-number="6376"></td>
        <td id="LC6376">    <span><span>//</span> If our context has extended registers, then write the whole thing. Otherwise, just write the minimum part.</span></td>
      </tr>
      <tr>
        <td id="L6377" data-line-number="6377"></td>
        <td id="LC6377">    <span>if</span> ((pCtx-&gt;<span>ContextFlags</span> &amp; DT_CONTEXT_EXTENDED_REGISTERS) != DT_CONTEXT_EXTENDED_REGISTERS)</td>
      </tr>
      <tr>
        <td id="L6378" data-line-number="6378"></td>
        <td id="LC6378">    {</td>
      </tr>
      <tr>
        <td id="L6379" data-line-number="6379"></td>
        <td id="LC6379">        sizeToWrite = <span>offsetof</span>(DT_CONTEXT, ExtendedRegisters);</td>
      </tr>
      <tr>
        <td id="L6380" data-line-number="6380"></td>
        <td id="LC6380">    }</td>
      </tr>
      <tr>
        <td id="L6381" data-line-number="6381"></td>
        <td id="LC6381">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6382" data-line-number="6382"></td>
        <td id="LC6382">
</td>
      </tr>
      <tr>
        <td id="L6383" data-line-number="6383"></td>
        <td id="LC6383"><span><span>//</span> 64 bit windows puts space for the first 6 stack parameters in the CONTEXT structure so that</span></td>
      </tr>
      <tr>
        <td id="L6384" data-line-number="6384"></td>
        <td id="LC6384"><span><span>//</span> kernel to usermode transitions don't have to allocate a CONTEXT and do a seperate sub rsp</span></td>
      </tr>
      <tr>
        <td id="L6385" data-line-number="6385"></td>
        <td id="LC6385"><span><span>//</span> to allocate stack spill space for the arguments. This means that writing to P1Home - P6Home</span></td>
      </tr>
      <tr>
        <td id="L6386" data-line-number="6386"></td>
        <td id="LC6386"><span><span>//</span> will overwrite the arguments of some function higher on the stack, very bad. Conceptually you</span></td>
      </tr>
      <tr>
        <td id="L6387" data-line-number="6387"></td>
        <td id="LC6387"><span><span>//</span> can think of these members as not being part of the context, ie they don't represent something</span></td>
      </tr>
      <tr>
        <td id="L6388" data-line-number="6388"></td>
        <td id="LC6388"><span><span>//</span> which gets saved or restored on context switches. They are just space we shouldn't overwrite.</span></td>
      </tr>
      <tr>
        <td id="L6389" data-line-number="6389"></td>
        <td id="LC6389"><span><span>//</span> See issue 630276 for more details.</span></td>
      </tr>
      <tr>
        <td id="L6390" data-line-number="6390"></td>
        <td id="LC6390">#<span>if</span> defined DBG_TARGET_AMD64</td>
      </tr>
      <tr>
        <td id="L6391" data-line-number="6391"></td>
        <td id="LC6391">    pRemoteContext += <span>offsetof</span>(CONTEXT, ContextFlags); <span><span>//</span> immediately follows the 6 parameters P1-P6</span></td>
      </tr>
      <tr>
        <td id="L6392" data-line-number="6392"></td>
        <td id="LC6392">    pCtxSource += <span>offsetof</span>(CONTEXT, ContextFlags);</td>
      </tr>
      <tr>
        <td id="L6393" data-line-number="6393"></td>
        <td id="LC6393">    sizeToWrite -= <span>offsetof</span>(CONTEXT, ContextFlags);</td>
      </tr>
      <tr>
        <td id="L6394" data-line-number="6394"></td>
        <td id="LC6394">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6395" data-line-number="6395"></td>
        <td id="LC6395">
</td>
      </tr>
      <tr>
        <td id="L6396" data-line-number="6396"></td>
        <td id="LC6396">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L6397" data-line-number="6397"></td>
        <td id="LC6397">    {</td>
      </tr>
      <tr>
        <td id="L6398" data-line-number="6398"></td>
        <td id="LC6398">        <span><span>//</span> Write the context.</span></td>
      </tr>
      <tr>
        <td id="L6399" data-line-number="6399"></td>
        <td id="LC6399">        TargetBuffer <span>tb</span>(pRemoteContext, sizeToWrite);</td>
      </tr>
      <tr>
        <td id="L6400" data-line-number="6400"></td>
        <td id="LC6400">        <span>SafeWriteBuffer</span>(tb, (<span>const</span> BYTE*) pCtxSource);</td>
      </tr>
      <tr>
        <td id="L6401" data-line-number="6401"></td>
        <td id="LC6401">    }</td>
      </tr>
      <tr>
        <td id="L6402" data-line-number="6402"></td>
        <td id="LC6402">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L6403" data-line-number="6403"></td>
        <td id="LC6403">
</td>
      </tr>
      <tr>
        <td id="L6404" data-line-number="6404"></td>
        <td id="LC6404">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L6405" data-line-number="6405"></td>
        <td id="LC6405">}</td>
      </tr>
      <tr>
        <td id="L6406" data-line-number="6406"></td>
        <td id="LC6406">
</td>
      </tr>
      <tr>
        <td id="L6407" data-line-number="6407"></td>
        <td id="LC6407">
</td>
      </tr>
      <tr>
        <td id="L6408" data-line-number="6408"></td>
        <td id="LC6408">HRESULT <span>CordbProcess::GetThreadContext</span>(DWORD threadID, ULONG32 contextSize, BYTE context[])</td>
      </tr>
      <tr>
        <td id="L6409" data-line-number="6409"></td>
        <td id="LC6409">{</td>
      </tr>
      <tr>
        <td id="L6410" data-line-number="6410"></td>
        <td id="LC6410">    <span>PUBLIC_REENTRANT_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6411" data-line-number="6411"></td>
        <td id="LC6411">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6412" data-line-number="6412"></td>
        <td id="LC6412">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::GTC: thread=0x%x<span>\n</span><span>"</span></span>, threadID));</td>
      </tr>
      <tr>
        <td id="L6413" data-line-number="6413"></td>
        <td id="LC6413">
</td>
      </tr>
      <tr>
        <td id="L6414" data-line-number="6414"></td>
        <td id="LC6414">    DT_CONTEXT * pContext;</td>
      </tr>
      <tr>
        <td id="L6415" data-line-number="6415"></td>
        <td id="LC6415">
</td>
      </tr>
      <tr>
        <td id="L6416" data-line-number="6416"></td>
        <td id="LC6416">    <span>if</span> (contextSize != <span>sizeof</span>(DT_CONTEXT))</td>
      </tr>
      <tr>
        <td id="L6417" data-line-number="6417"></td>
        <td id="LC6417">    {</td>
      </tr>
      <tr>
        <td id="L6418" data-line-number="6418"></td>
        <td id="LC6418">        <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::GTC: thread=0x%x, context size is invalid.<span>\n</span><span>"</span></span>, threadID));</td>
      </tr>
      <tr>
        <td id="L6419" data-line-number="6419"></td>
        <td id="LC6419">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L6420" data-line-number="6420"></td>
        <td id="LC6420">    }</td>
      </tr>
      <tr>
        <td id="L6421" data-line-number="6421"></td>
        <td id="LC6421">
</td>
      </tr>
      <tr>
        <td id="L6422" data-line-number="6422"></td>
        <td id="LC6422">    pContext = <span>reinterpret_cast</span>&lt;DT_CONTEXT *&gt;(context);</td>
      </tr>
      <tr>
        <td id="L6423" data-line-number="6423"></td>
        <td id="LC6423">
</td>
      </tr>
      <tr>
        <td id="L6424" data-line-number="6424"></td>
        <td id="LC6424">    <span>VALIDATE_POINTER_TO_OBJECT_ARRAY</span>(context, BYTE, contextSize, <span>true</span>, <span>true</span>);</td>
      </tr>
      <tr>
        <td id="L6425" data-line-number="6425"></td>
        <td id="LC6425">
</td>
      </tr>
      <tr>
        <td id="L6426" data-line-number="6426"></td>
        <td id="LC6426">    <span>if</span> (<span>this</span>-&gt;<span>IsInteropDebugging</span>())</td>
      </tr>
      <tr>
        <td id="L6427" data-line-number="6427"></td>
        <td id="LC6427">    {</td>
      </tr>
      <tr>
        <td id="L6428" data-line-number="6428"></td>
        <td id="LC6428">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L6429" data-line-number="6429"></td>
        <td id="LC6429">        RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6430" data-line-number="6430"></td>
        <td id="LC6430">
</td>
      </tr>
      <tr>
        <td id="L6431" data-line-number="6431"></td>
        <td id="LC6431">        <span><span>//</span> Find the unmanaged thread</span></td>
      </tr>
      <tr>
        <td id="L6432" data-line-number="6432"></td>
        <td id="LC6432">        CordbUnmanagedThread *ut = <span>GetUnmanagedThread</span>(threadID);</td>
      </tr>
      <tr>
        <td id="L6433" data-line-number="6433"></td>
        <td id="LC6433">
</td>
      </tr>
      <tr>
        <td id="L6434" data-line-number="6434"></td>
        <td id="LC6434">        <span>if</span> (ut == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6435" data-line-number="6435"></td>
        <td id="LC6435">        {</td>
      </tr>
      <tr>
        <td id="L6436" data-line-number="6436"></td>
        <td id="LC6436">            <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::GTC: thread=0x%x, thread id is invalid.<span>\n</span><span>"</span></span>, threadID));</td>
      </tr>
      <tr>
        <td id="L6437" data-line-number="6437"></td>
        <td id="LC6437">
</td>
      </tr>
      <tr>
        <td id="L6438" data-line-number="6438"></td>
        <td id="LC6438">            <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L6439" data-line-number="6439"></td>
        <td id="LC6439">        }</td>
      </tr>
      <tr>
        <td id="L6440" data-line-number="6440"></td>
        <td id="LC6440">
</td>
      </tr>
      <tr>
        <td id="L6441" data-line-number="6441"></td>
        <td id="LC6441">        <span>return</span> ut-&gt;<span>GetThreadContext</span>((DT_CONTEXT*)context);</td>
      </tr>
      <tr>
        <td id="L6442" data-line-number="6442"></td>
        <td id="LC6442">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L6443" data-line-number="6443"></td>
        <td id="LC6443">        <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L6444" data-line-number="6444"></td>
        <td id="LC6444">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6445" data-line-number="6445"></td>
        <td id="LC6445">    }</td>
      </tr>
      <tr>
        <td id="L6446" data-line-number="6446"></td>
        <td id="LC6446">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L6447" data-line-number="6447"></td>
        <td id="LC6447">    {</td>
      </tr>
      <tr>
        <td id="L6448" data-line-number="6448"></td>
        <td id="LC6448">        RSLockHolder <span>ch</span>(<span>GetProcess</span>()-&gt;<span>GetStopGoLock</span>());</td>
      </tr>
      <tr>
        <td id="L6449" data-line-number="6449"></td>
        <td id="LC6449">        RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6450" data-line-number="6450"></td>
        <td id="LC6450">
</td>
      </tr>
      <tr>
        <td id="L6451" data-line-number="6451"></td>
        <td id="LC6451">        HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L6452" data-line-number="6452"></td>
        <td id="LC6452">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L6453" data-line-number="6453"></td>
        <td id="LC6453">        {</td>
      </tr>
      <tr>
        <td id="L6454" data-line-number="6454"></td>
        <td id="LC6454">            CordbThread* thread = <span>this</span>-&gt;<span>TryLookupThreadByVolatileOSId</span>(threadID);</td>
      </tr>
      <tr>
        <td id="L6455" data-line-number="6455"></td>
        <td id="LC6455">            <span>if</span> (thread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6456" data-line-number="6456"></td>
        <td id="LC6456">            {</td>
      </tr>
      <tr>
        <td id="L6457" data-line-number="6457"></td>
        <td id="LC6457">                <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::GTC: thread=0x%x, thread id is invalid.<span>\n</span><span>"</span></span>, threadID));</td>
      </tr>
      <tr>
        <td id="L6458" data-line-number="6458"></td>
        <td id="LC6458">
</td>
      </tr>
      <tr>
        <td id="L6459" data-line-number="6459"></td>
        <td id="LC6459">                hr = E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L6460" data-line-number="6460"></td>
        <td id="LC6460">            }</td>
      </tr>
      <tr>
        <td id="L6461" data-line-number="6461"></td>
        <td id="LC6461">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L6462" data-line-number="6462"></td>
        <td id="LC6462">            {</td>
      </tr>
      <tr>
        <td id="L6463" data-line-number="6463"></td>
        <td id="LC6463">                DT_CONTEXT* managedContext;</td>
      </tr>
      <tr>
        <td id="L6464" data-line-number="6464"></td>
        <td id="LC6464">                hr = thread-&gt;<span>GetManagedContext</span>(&amp;managedContext);</td>
      </tr>
      <tr>
        <td id="L6465" data-line-number="6465"></td>
        <td id="LC6465">                *pContext = *managedContext;</td>
      </tr>
      <tr>
        <td id="L6466" data-line-number="6466"></td>
        <td id="LC6466">            }</td>
      </tr>
      <tr>
        <td id="L6467" data-line-number="6467"></td>
        <td id="LC6467">        }</td>
      </tr>
      <tr>
        <td id="L6468" data-line-number="6468"></td>
        <td id="LC6468">        <span>EX_CATCH_HRESULT</span>(hr)</td>
      </tr>
      <tr>
        <td id="L6469" data-line-number="6469"></td>
        <td id="LC6469">        <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L6470" data-line-number="6470"></td>
        <td id="LC6470">    }</td>
      </tr>
      <tr>
        <td id="L6471" data-line-number="6471"></td>
        <td id="LC6471">}</td>
      </tr>
      <tr>
        <td id="L6472" data-line-number="6472"></td>
        <td id="LC6472">
</td>
      </tr>
      <tr>
        <td id="L6473" data-line-number="6473"></td>
        <td id="LC6473"><span><span>//</span> Public implementation of ICorDebugProcess::SetThreadContext.</span></td>
      </tr>
      <tr>
        <td id="L6474" data-line-number="6474"></td>
        <td id="LC6474"><span><span>//</span> @dbgtodo interop-debugging: this should go away in V3. Use the data-target instead. This is</span></td>
      </tr>
      <tr>
        <td id="L6475" data-line-number="6475"></td>
        <td id="LC6475"><span><span>//</span> interop-debugging aware (and cooperates with hijacks)</span></td>
      </tr>
      <tr>
        <td id="L6476" data-line-number="6476"></td>
        <td id="LC6476">HRESULT <span>CordbProcess::SetThreadContext</span>(DWORD threadID, ULONG32 contextSize, BYTE context[])</td>
      </tr>
      <tr>
        <td id="L6477" data-line-number="6477"></td>
        <td id="LC6477">{</td>
      </tr>
      <tr>
        <td id="L6478" data-line-number="6478"></td>
        <td id="LC6478">    <span>PUBLIC_REENTRANT_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6479" data-line-number="6479"></td>
        <td id="LC6479">
</td>
      </tr>
      <tr>
        <td id="L6480" data-line-number="6480"></td>
        <td id="LC6480">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L6481" data-line-number="6481"></td>
        <td id="LC6481">
</td>
      </tr>
      <tr>
        <td id="L6482" data-line-number="6482"></td>
        <td id="LC6482">    <span><span>//</span> @todo -  could we look at the context flags and return E_INVALIDARG if they're bad?</span></td>
      </tr>
      <tr>
        <td id="L6483" data-line-number="6483"></td>
        <td id="LC6483">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6484" data-line-number="6484"></td>
        <td id="LC6484">    <span>VALIDATE_POINTER_TO_OBJECT_ARRAY</span>(context, BYTE, contextSize, <span>true</span>, <span>true</span>);</td>
      </tr>
      <tr>
        <td id="L6485" data-line-number="6485"></td>
        <td id="LC6485">
</td>
      </tr>
      <tr>
        <td id="L6486" data-line-number="6486"></td>
        <td id="LC6486">    <span>if</span> (contextSize != <span>sizeof</span>(DT_CONTEXT))</td>
      </tr>
      <tr>
        <td id="L6487" data-line-number="6487"></td>
        <td id="LC6487">    {</td>
      </tr>
      <tr>
        <td id="L6488" data-line-number="6488"></td>
        <td id="LC6488">        <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::STC: thread=0x%x, context size is invalid.<span>\n</span><span>"</span></span>, threadID));</td>
      </tr>
      <tr>
        <td id="L6489" data-line-number="6489"></td>
        <td id="LC6489">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L6490" data-line-number="6490"></td>
        <td id="LC6490">    }</td>
      </tr>
      <tr>
        <td id="L6491" data-line-number="6491"></td>
        <td id="LC6491">
</td>
      </tr>
      <tr>
        <td id="L6492" data-line-number="6492"></td>
        <td id="LC6492">    DT_CONTEXT* pContext = (DT_CONTEXT*)context;</td>
      </tr>
      <tr>
        <td id="L6493" data-line-number="6493"></td>
        <td id="LC6493">
</td>
      </tr>
      <tr>
        <td id="L6494" data-line-number="6494"></td>
        <td id="LC6494">    <span>if</span> (<span>this</span>-&gt;<span>IsInteropDebugging</span>())</td>
      </tr>
      <tr>
        <td id="L6495" data-line-number="6495"></td>
        <td id="LC6495">    {</td>
      </tr>
      <tr>
        <td id="L6496" data-line-number="6496"></td>
        <td id="LC6496">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L6497" data-line-number="6497"></td>
        <td id="LC6497">        RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6498" data-line-number="6498"></td>
        <td id="LC6498">
</td>
      </tr>
      <tr>
        <td id="L6499" data-line-number="6499"></td>
        <td id="LC6499">        CordbUnmanagedThread *ut = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L6500" data-line-number="6500"></td>
        <td id="LC6500">
</td>
      </tr>
      <tr>
        <td id="L6501" data-line-number="6501"></td>
        <td id="LC6501">        <span><span>//</span> Find the unmanaged thread</span></td>
      </tr>
      <tr>
        <td id="L6502" data-line-number="6502"></td>
        <td id="LC6502">        ut = <span>GetUnmanagedThread</span>(threadID);</td>
      </tr>
      <tr>
        <td id="L6503" data-line-number="6503"></td>
        <td id="LC6503">
</td>
      </tr>
      <tr>
        <td id="L6504" data-line-number="6504"></td>
        <td id="LC6504">        <span>if</span> (ut == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6505" data-line-number="6505"></td>
        <td id="LC6505">        {</td>
      </tr>
      <tr>
        <td id="L6506" data-line-number="6506"></td>
        <td id="LC6506">            <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::STC: thread=0x%x, thread is invalid.<span>\n</span><span>"</span></span>, threadID));</td>
      </tr>
      <tr>
        <td id="L6507" data-line-number="6507"></td>
        <td id="LC6507">            <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L6508" data-line-number="6508"></td>
        <td id="LC6508">        }</td>
      </tr>
      <tr>
        <td id="L6509" data-line-number="6509"></td>
        <td id="LC6509">
</td>
      </tr>
      <tr>
        <td id="L6510" data-line-number="6510"></td>
        <td id="LC6510">        hr = ut-&gt;<span>SetThreadContext</span>(pContext);</td>
      </tr>
      <tr>
        <td id="L6511" data-line-number="6511"></td>
        <td id="LC6511">
</td>
      </tr>
      <tr>
        <td id="L6512" data-line-number="6512"></td>
        <td id="LC6512">        <span><span>//</span> Update the register set for the leaf-unmanaged chain so that it's consistent w/ the context.</span></td>
      </tr>
      <tr>
        <td id="L6513" data-line-number="6513"></td>
        <td id="LC6513">        <span><span>//</span> We may not necessarily be synchronized, and so these frames may be stale. Even so, no harm done.</span></td>
      </tr>
      <tr>
        <td id="L6514" data-line-number="6514"></td>
        <td id="LC6514">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L6515" data-line-number="6515"></td>
        <td id="LC6515">        {</td>
      </tr>
      <tr>
        <td id="L6516" data-line-number="6516"></td>
        <td id="LC6516">            <span><span>//</span> @dbgtodo stackwalk: this should all disappear with V3 stackwalker and getting rid of SetThreadContext.</span></td>
      </tr>
      <tr>
        <td id="L6517" data-line-number="6517"></td>
        <td id="LC6517">            EX_TRY</td>
      </tr>
      <tr>
        <td id="L6518" data-line-number="6518"></td>
        <td id="LC6518">            {</td>
      </tr>
      <tr>
        <td id="L6519" data-line-number="6519"></td>
        <td id="LC6519">                <span><span>//</span> Find the managed thread.  Returns NULL if thread is not managed.</span></td>
      </tr>
      <tr>
        <td id="L6520" data-line-number="6520"></td>
        <td id="LC6520">                <span><span>//</span> If we don't have a thread prveiously cached, then there's no state to update.</span></td>
      </tr>
      <tr>
        <td id="L6521" data-line-number="6521"></td>
        <td id="LC6521">                CordbThread * pThread = <span>TryLookupThreadByVolatileOSId</span>(threadID);</td>
      </tr>
      <tr>
        <td id="L6522" data-line-number="6522"></td>
        <td id="LC6522">
</td>
      </tr>
      <tr>
        <td id="L6523" data-line-number="6523"></td>
        <td id="LC6523">                <span>if</span> (pThread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6524" data-line-number="6524"></td>
        <td id="LC6524">                {</td>
      </tr>
      <tr>
        <td id="L6525" data-line-number="6525"></td>
        <td id="LC6525">                    <span><span>//</span> In V2, we used to update the CONTEXT of the leaf chain if the chain is an unmanaged chain.</span></td>
      </tr>
      <tr>
        <td id="L6526" data-line-number="6526"></td>
        <td id="LC6526">                    <span><span>//</span> In Arrowhead, we just force a cleanup of the stackwalk cache.  This is a more correct</span></td>
      </tr>
      <tr>
        <td id="L6527" data-line-number="6527"></td>
        <td id="LC6527">                    <span><span>//</span> thing to do anyway, since the CONTEXT being set could be anything.</span></td>
      </tr>
      <tr>
        <td id="L6528" data-line-number="6528"></td>
        <td id="LC6528">                    pThread-&gt;<span>CleanupStack</span>();</td>
      </tr>
      <tr>
        <td id="L6529" data-line-number="6529"></td>
        <td id="LC6529">                }</td>
      </tr>
      <tr>
        <td id="L6530" data-line-number="6530"></td>
        <td id="LC6530">            }</td>
      </tr>
      <tr>
        <td id="L6531" data-line-number="6531"></td>
        <td id="LC6531">            <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L6532" data-line-number="6532"></td>
        <td id="LC6532">        }</td>
      </tr>
      <tr>
        <td id="L6533" data-line-number="6533"></td>
        <td id="LC6533">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L6534" data-line-number="6534"></td>
        <td id="LC6534">        <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L6535" data-line-number="6535"></td>
        <td id="LC6535">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6536" data-line-number="6536"></td>
        <td id="LC6536">    }</td>
      </tr>
      <tr>
        <td id="L6537" data-line-number="6537"></td>
        <td id="LC6537">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L6538" data-line-number="6538"></td>
        <td id="LC6538">    {</td>
      </tr>
      <tr>
        <td id="L6539" data-line-number="6539"></td>
        <td id="LC6539">        RSLockHolder <span>ch</span>(<span>GetProcess</span>()-&gt;<span>GetStopGoLock</span>());</td>
      </tr>
      <tr>
        <td id="L6540" data-line-number="6540"></td>
        <td id="LC6540">        RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6541" data-line-number="6541"></td>
        <td id="LC6541">
</td>
      </tr>
      <tr>
        <td id="L6542" data-line-number="6542"></td>
        <td id="LC6542">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L6543" data-line-number="6543"></td>
        <td id="LC6543">        {</td>
      </tr>
      <tr>
        <td id="L6544" data-line-number="6544"></td>
        <td id="LC6544">            CordbThread* thread = <span>this</span>-&gt;<span>TryLookupThreadByVolatileOSId</span>(threadID);</td>
      </tr>
      <tr>
        <td id="L6545" data-line-number="6545"></td>
        <td id="LC6545">            <span>if</span> (thread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6546" data-line-number="6546"></td>
        <td id="LC6546">            {</td>
      </tr>
      <tr>
        <td id="L6547" data-line-number="6547"></td>
        <td id="LC6547">                <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::GTC: thread=0x%x, thread id is invalid.<span>\n</span><span>"</span></span>, threadID));</td>
      </tr>
      <tr>
        <td id="L6548" data-line-number="6548"></td>
        <td id="LC6548">
</td>
      </tr>
      <tr>
        <td id="L6549" data-line-number="6549"></td>
        <td id="LC6549">                hr = E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L6550" data-line-number="6550"></td>
        <td id="LC6550">            }</td>
      </tr>
      <tr>
        <td id="L6551" data-line-number="6551"></td>
        <td id="LC6551">
</td>
      </tr>
      <tr>
        <td id="L6552" data-line-number="6552"></td>
        <td id="LC6552">            hr = thread-&gt;<span>SetManagedContext</span>(pContext);</td>
      </tr>
      <tr>
        <td id="L6553" data-line-number="6553"></td>
        <td id="LC6553">        }</td>
      </tr>
      <tr>
        <td id="L6554" data-line-number="6554"></td>
        <td id="LC6554">        EX_CATCH</td>
      </tr>
      <tr>
        <td id="L6555" data-line-number="6555"></td>
        <td id="LC6555">        {</td>
      </tr>
      <tr>
        <td id="L6556" data-line-number="6556"></td>
        <td id="LC6556">            hr = E_FAIL;</td>
      </tr>
      <tr>
        <td id="L6557" data-line-number="6557"></td>
        <td id="LC6557">        }</td>
      </tr>
      <tr>
        <td id="L6558" data-line-number="6558"></td>
        <td id="LC6558">        <span>EX_END_CATCH</span>(SwallowAllExceptions)</td>
      </tr>
      <tr>
        <td id="L6559" data-line-number="6559"></td>
        <td id="LC6559">
</td>
      </tr>
      <tr>
        <td id="L6560" data-line-number="6560"></td>
        <td id="LC6560">
</td>
      </tr>
      <tr>
        <td id="L6561" data-line-number="6561"></td>
        <td id="LC6561">    }</td>
      </tr>
      <tr>
        <td id="L6562" data-line-number="6562"></td>
        <td id="LC6562">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L6563" data-line-number="6563"></td>
        <td id="LC6563">}</td>
      </tr>
      <tr>
        <td id="L6564" data-line-number="6564"></td>
        <td id="LC6564">
</td>
      </tr>
      <tr>
        <td id="L6565" data-line-number="6565"></td>
        <td id="LC6565">
</td>
      </tr>
      <tr>
        <td id="L6566" data-line-number="6566"></td>
        <td id="LC6566"><span><span>//</span> @dbgtodo  ICDProcess - When we DACize this function, we should use code:DacReplacePatches</span></td>
      </tr>
      <tr>
        <td id="L6567" data-line-number="6567"></td>
        <td id="LC6567">HRESULT <span>CordbProcess::ReadMemory</span>(CORDB_ADDRESS address,</td>
      </tr>
      <tr>
        <td id="L6568" data-line-number="6568"></td>
        <td id="LC6568">                                 DWORD size,</td>
      </tr>
      <tr>
        <td id="L6569" data-line-number="6569"></td>
        <td id="LC6569">                                 BYTE buffer[],</td>
      </tr>
      <tr>
        <td id="L6570" data-line-number="6570"></td>
        <td id="LC6570">                                 SIZE_T *read)</td>
      </tr>
      <tr>
        <td id="L6571" data-line-number="6571"></td>
        <td id="LC6571">{</td>
      </tr>
      <tr>
        <td id="L6572" data-line-number="6572"></td>
        <td id="LC6572">    <span>PUBLIC_REENTRANT_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6573" data-line-number="6573"></td>
        <td id="LC6573">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6574" data-line-number="6574"></td>
        <td id="LC6574">
</td>
      </tr>
      <tr>
        <td id="L6575" data-line-number="6575"></td>
        <td id="LC6575">    <span><span>//</span> A read of 0 bytes is okay.</span></td>
      </tr>
      <tr>
        <td id="L6576" data-line-number="6576"></td>
        <td id="LC6576">    <span>if</span> (size == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6577" data-line-number="6577"></td>
        <td id="LC6577">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6578" data-line-number="6578"></td>
        <td id="LC6578">
</td>
      </tr>
      <tr>
        <td id="L6579" data-line-number="6579"></td>
        <td id="LC6579">    <span>VALIDATE_POINTER_TO_OBJECT_ARRAY</span>(buffer, BYTE, size, <span>true</span>, <span>true</span>);</td>
      </tr>
      <tr>
        <td id="L6580" data-line-number="6580"></td>
        <td id="LC6580">    <span>VALIDATE_POINTER_TO_OBJECT</span>(buffer, SIZE_T *);</td>
      </tr>
      <tr>
        <td id="L6581" data-line-number="6581"></td>
        <td id="LC6581">
</td>
      </tr>
      <tr>
        <td id="L6582" data-line-number="6582"></td>
        <td id="LC6582">    <span>if</span> (address == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6583" data-line-number="6583"></td>
        <td id="LC6583">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L6584" data-line-number="6584"></td>
        <td id="LC6584">
</td>
      </tr>
      <tr>
        <td id="L6585" data-line-number="6585"></td>
        <td id="LC6585">    <span><span>//</span> If no read parameter is supplied, we ignore it. This matches the semantics of kernel32!ReadProcessMemory.</span></td>
      </tr>
      <tr>
        <td id="L6586" data-line-number="6586"></td>
        <td id="LC6586">    SIZE_T dummyRead;</td>
      </tr>
      <tr>
        <td id="L6587" data-line-number="6587"></td>
        <td id="LC6587">    <span>if</span> (<span>read</span> == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6588" data-line-number="6588"></td>
        <td id="LC6588">    {</td>
      </tr>
      <tr>
        <td id="L6589" data-line-number="6589"></td>
        <td id="LC6589">        <span>read</span> = &amp;dummyRead;</td>
      </tr>
      <tr>
        <td id="L6590" data-line-number="6590"></td>
        <td id="LC6590">    }</td>
      </tr>
      <tr>
        <td id="L6591" data-line-number="6591"></td>
        <td id="LC6591">    *<span>read</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6592" data-line-number="6592"></td>
        <td id="LC6592">
</td>
      </tr>
      <tr>
        <td id="L6593" data-line-number="6593"></td>
        <td id="LC6593">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L6594" data-line-number="6594"></td>
        <td id="LC6594">
</td>
      </tr>
      <tr>
        <td id="L6595" data-line-number="6595"></td>
        <td id="LC6595">    <span>CORDBRequireProcessStateOK</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6596" data-line-number="6596"></td>
        <td id="LC6596">
</td>
      </tr>
      <tr>
        <td id="L6597" data-line-number="6597"></td>
        <td id="LC6597">    <span><span>//</span> Grab the memory we want to read</span></td>
      </tr>
      <tr>
        <td id="L6598" data-line-number="6598"></td>
        <td id="LC6598">    <span><span>//</span> Note that this will return success on a partial read</span></td>
      </tr>
      <tr>
        <td id="L6599" data-line-number="6599"></td>
        <td id="LC6599">    ULONG32 cbRead;</td>
      </tr>
      <tr>
        <td id="L6600" data-line-number="6600"></td>
        <td id="LC6600">    hr = <span>GetDataTarget</span>()-&gt;<span>ReadVirtual</span>(address, buffer, size, &amp;cbRead);</td>
      </tr>
      <tr>
        <td id="L6601" data-line-number="6601"></td>
        <td id="LC6601">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L6602" data-line-number="6602"></td>
        <td id="LC6602">    {</td>
      </tr>
      <tr>
        <td id="L6603" data-line-number="6603"></td>
        <td id="LC6603">        hr = CORDBG_E_READVIRTUAL_FAILURE;</td>
      </tr>
      <tr>
        <td id="L6604" data-line-number="6604"></td>
        <td id="LC6604">        <span>goto</span> LExit;</td>
      </tr>
      <tr>
        <td id="L6605" data-line-number="6605"></td>
        <td id="LC6605">    }</td>
      </tr>
      <tr>
        <td id="L6606" data-line-number="6606"></td>
        <td id="LC6606">
</td>
      </tr>
      <tr>
        <td id="L6607" data-line-number="6607"></td>
        <td id="LC6607">    <span><span>//</span> Read at least one byte</span></td>
      </tr>
      <tr>
        <td id="L6608" data-line-number="6608"></td>
        <td id="LC6608">    *<span>read</span> = (SIZE_T) cbRead;</td>
      </tr>
      <tr>
        <td id="L6609" data-line-number="6609"></td>
        <td id="LC6609">
</td>
      </tr>
      <tr>
        <td id="L6610" data-line-number="6610"></td>
        <td id="LC6610">    <span><span>//</span> There seem to be strange cases where ReadProcessMemory will return a seemingly negative number into *read, which</span></td>
      </tr>
      <tr>
        <td id="L6611" data-line-number="6611"></td>
        <td id="LC6611">    <span><span>//</span> is an unsigned value. So we check the sanity of *read by ensuring that its no bigger than the size we tried to</span></td>
      </tr>
      <tr>
        <td id="L6612" data-line-number="6612"></td>
        <td id="LC6612">    <span><span>//</span> read.</span></td>
      </tr>
      <tr>
        <td id="L6613" data-line-number="6613"></td>
        <td id="LC6613">    <span>if</span> ((*<span>read</span> &gt; <span>0</span>) &amp;&amp; (*<span>read</span> &lt;= size))</td>
      </tr>
      <tr>
        <td id="L6614" data-line-number="6614"></td>
        <td id="LC6614">    {</td>
      </tr>
      <tr>
        <td id="L6615" data-line-number="6615"></td>
        <td id="LC6615">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>CP::RM: read %d bytes from 0x%08x, first byte is 0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L6616" data-line-number="6616"></td>
        <td id="LC6616">             *<span>read</span>, (DWORD)address, buffer[<span>0</span>]));</td>
      </tr>
      <tr>
        <td id="L6617" data-line-number="6617"></td>
        <td id="LC6617">
</td>
      </tr>
      <tr>
        <td id="L6618" data-line-number="6618"></td>
        <td id="LC6618">        <span>if</span> (m_initialized)</td>
      </tr>
      <tr>
        <td id="L6619" data-line-number="6619"></td>
        <td id="LC6619">        {</td>
      </tr>
      <tr>
        <td id="L6620" data-line-number="6620"></td>
        <td id="LC6620">            RSLockHolder <span>ch</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L6621" data-line-number="6621"></td>
        <td id="LC6621">
</td>
      </tr>
      <tr>
        <td id="L6622" data-line-number="6622"></td>
        <td id="LC6622">            <span><span>//</span> If m_pPatchTable is NULL, then it's been cleaned out b/c of a Continue for the left side.  Get the table</span></td>
      </tr>
      <tr>
        <td id="L6623" data-line-number="6623"></td>
        <td id="LC6623">            <span><span>//</span> again. Only do this, of course, if the managed state of the process is initialized.</span></td>
      </tr>
      <tr>
        <td id="L6624" data-line-number="6624"></td>
        <td id="LC6624">            <span>if</span> (m_pPatchTable == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6625" data-line-number="6625"></td>
        <td id="LC6625">            {</td>
      </tr>
      <tr>
        <td id="L6626" data-line-number="6626"></td>
        <td id="LC6626">                hr = <span>RefreshPatchTable</span>(address, *<span>read</span>, buffer);</td>
      </tr>
      <tr>
        <td id="L6627" data-line-number="6627"></td>
        <td id="LC6627">            }</td>
      </tr>
      <tr>
        <td id="L6628" data-line-number="6628"></td>
        <td id="LC6628">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L6629" data-line-number="6629"></td>
        <td id="LC6629">            {</td>
      </tr>
      <tr>
        <td id="L6630" data-line-number="6630"></td>
        <td id="LC6630">                <span><span>//</span> The previously fetched table is still good, so run through it &amp; see if any patches are applicable</span></td>
      </tr>
      <tr>
        <td id="L6631" data-line-number="6631"></td>
        <td id="LC6631">                hr = <span>AdjustBuffer</span>(address, *<span>read</span>, buffer, <span>NULL</span>, AB_READ);</td>
      </tr>
      <tr>
        <td id="L6632" data-line-number="6632"></td>
        <td id="LC6632">            }</td>
      </tr>
      <tr>
        <td id="L6633" data-line-number="6633"></td>
        <td id="LC6633">        }</td>
      </tr>
      <tr>
        <td id="L6634" data-line-number="6634"></td>
        <td id="LC6634">    }</td>
      </tr>
      <tr>
        <td id="L6635" data-line-number="6635"></td>
        <td id="LC6635">
</td>
      </tr>
      <tr>
        <td id="L6636" data-line-number="6636"></td>
        <td id="LC6636">LExit:</td>
      </tr>
      <tr>
        <td id="L6637" data-line-number="6637"></td>
        <td id="LC6637">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L6638" data-line-number="6638"></td>
        <td id="LC6638">    {</td>
      </tr>
      <tr>
        <td id="L6639" data-line-number="6639"></td>
        <td id="LC6639">        RSLockHolder <span>ch</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L6640" data-line-number="6640"></td>
        <td id="LC6640">        <span>ClearPatchTable</span>();</td>
      </tr>
      <tr>
        <td id="L6641" data-line-number="6641"></td>
        <td id="LC6641">    }</td>
      </tr>
      <tr>
        <td id="L6642" data-line-number="6642"></td>
        <td id="LC6642">    <span>else</span> <span>if</span> (*<span>read</span> &lt; size)</td>
      </tr>
      <tr>
        <td id="L6643" data-line-number="6643"></td>
        <td id="LC6643">    {</td>
      </tr>
      <tr>
        <td id="L6644" data-line-number="6644"></td>
        <td id="LC6644">        <span><span>//</span> Unlike the DT api, our API is supposed to return an error on partial read</span></td>
      </tr>
      <tr>
        <td id="L6645" data-line-number="6645"></td>
        <td id="LC6645">        hr = <span>HRESULT_FROM_WIN32</span>(ERROR_PARTIAL_COPY);</td>
      </tr>
      <tr>
        <td id="L6646" data-line-number="6646"></td>
        <td id="LC6646">    }</td>
      </tr>
      <tr>
        <td id="L6647" data-line-number="6647"></td>
        <td id="LC6647">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L6648" data-line-number="6648"></td>
        <td id="LC6648">}</td>
      </tr>
      <tr>
        <td id="L6649" data-line-number="6649"></td>
        <td id="LC6649">
</td>
      </tr>
      <tr>
        <td id="L6650" data-line-number="6650"></td>
        <td id="LC6650"><span><span>//</span> Update patches &amp; buffer to make the left-side's usage of patches transparent</span></td>
      </tr>
      <tr>
        <td id="L6651" data-line-number="6651"></td>
        <td id="LC6651"><span><span>//</span> to our client.  Behavior depends on AB_MODE:</span></td>
      </tr>
      <tr>
        <td id="L6652" data-line-number="6652"></td>
        <td id="LC6652"><span><span>//</span> AB_READ:</span></td>
      </tr>
      <tr>
        <td id="L6653" data-line-number="6653"></td>
        <td id="LC6653"><span><span>//</span> - use the RS patch table structure to replace patch opcodes in buffer.</span></td>
      </tr>
      <tr>
        <td id="L6654" data-line-number="6654"></td>
        <td id="LC6654"><span><span>//</span> AB_WRITE:</span></td>
      </tr>
      <tr>
        <td id="L6655" data-line-number="6655"></td>
        <td id="LC6655"><span><span>//</span> - update the RS patch table structure w/ new replace-opcode values</span></td>
      </tr>
      <tr>
        <td id="L6656" data-line-number="6656"></td>
        <td id="LC6656"><span><span>//</span> if we've written over them. And put the int3 back in for write-memory.</span></td>
      </tr>
      <tr>
        <td id="L6657" data-line-number="6657"></td>
        <td id="LC6657"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6658" data-line-number="6658"></td>
        <td id="LC6658"><span><span>//</span> Note: If we're writing memory over top of a patch, then it must be JITted or stub code.</span></td>
      </tr>
      <tr>
        <td id="L6659" data-line-number="6659"></td>
        <td id="LC6659"><span><span>//</span> Writing over JITed or Stub code can be dangerous since the CLR may not expect it</span></td>
      </tr>
      <tr>
        <td id="L6660" data-line-number="6660"></td>
        <td id="LC6660"><span><span>//</span> (eg. JIT data structures about the code layout may be incorrect), but in certain</span></td>
      </tr>
      <tr>
        <td id="L6661" data-line-number="6661"></td>
        <td id="LC6661"><span><span>//</span> narrow cases it may be safe (eg. replacing a constant).  VS says they wouldn't expect</span></td>
      </tr>
      <tr>
        <td id="L6662" data-line-number="6662"></td>
        <td id="LC6662"><span><span>//</span> this to work, but we'll keep the support in for legacy reasons.</span></td>
      </tr>
      <tr>
        <td id="L6663" data-line-number="6663"></td>
        <td id="LC6663"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6664" data-line-number="6664"></td>
        <td id="LC6664"><span><span>//</span> address, size - describe buffer in LS memory</span></td>
      </tr>
      <tr>
        <td id="L6665" data-line-number="6665"></td>
        <td id="LC6665"><span><span>//</span> buffer - local copy of buffer that will be read/written from/to LS.</span></td>
      </tr>
      <tr>
        <td id="L6666" data-line-number="6666"></td>
        <td id="LC6666"><span><span>//</span> bufferCopy - for writeprocessmemory, copy of original buffer (w/o injected patches)</span></td>
      </tr>
      <tr>
        <td id="L6667" data-line-number="6667"></td>
        <td id="LC6667"><span><span>//</span> pbUpdatePatchTable - flag if patchtable got dirty and needs to be updated.</span></td>
      </tr>
      <tr>
        <td id="L6668" data-line-number="6668"></td>
        <td id="LC6668">HRESULT <span>CordbProcess::AdjustBuffer</span>( CORDB_ADDRESS address,</td>
      </tr>
      <tr>
        <td id="L6669" data-line-number="6669"></td>
        <td id="LC6669">                                    SIZE_T size,</td>
      </tr>
      <tr>
        <td id="L6670" data-line-number="6670"></td>
        <td id="LC6670">                                    BYTE buffer[],</td>
      </tr>
      <tr>
        <td id="L6671" data-line-number="6671"></td>
        <td id="LC6671">                                    BYTE **bufferCopy,</td>
      </tr>
      <tr>
        <td id="L6672" data-line-number="6672"></td>
        <td id="LC6672">                                    AB_MODE mode,</td>
      </tr>
      <tr>
        <td id="L6673" data-line-number="6673"></td>
        <td id="LC6673">                                    BOOL *pbUpdatePatchTable)</td>
      </tr>
      <tr>
        <td id="L6674" data-line-number="6674"></td>
        <td id="LC6674">{</td>
      </tr>
      <tr>
        <td id="L6675" data-line-number="6675"></td>
        <td id="LC6675">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6676" data-line-number="6676"></td>
        <td id="LC6676">
</td>
      </tr>
      <tr>
        <td id="L6677" data-line-number="6677"></td>
        <td id="LC6677">    <span>_ASSERTE</span>(m_initialized);</td>
      </tr>
      <tr>
        <td id="L6678" data-line-number="6678"></td>
        <td id="LC6678">    <span>_ASSERTE</span>(<span>this</span>-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6679" data-line-number="6679"></td>
        <td id="LC6679">
</td>
      </tr>
      <tr>
        <td id="L6680" data-line-number="6680"></td>
        <td id="LC6680">    <span>if</span> (    address == <span>NULL</span></td>
      </tr>
      <tr>
        <td id="L6681" data-line-number="6681"></td>
        <td id="LC6681">         || size == <span>NULL</span></td>
      </tr>
      <tr>
        <td id="L6682" data-line-number="6682"></td>
        <td id="LC6682">         || buffer == <span>NULL</span></td>
      </tr>
      <tr>
        <td id="L6683" data-line-number="6683"></td>
        <td id="LC6683">         || (mode != AB_READ &amp;&amp; mode != AB_WRITE) )</td>
      </tr>
      <tr>
        <td id="L6684" data-line-number="6684"></td>
        <td id="LC6684">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L6685" data-line-number="6685"></td>
        <td id="LC6685">
</td>
      </tr>
      <tr>
        <td id="L6686" data-line-number="6686"></td>
        <td id="LC6686">    <span>if</span> (pbUpdatePatchTable != <span>NULL</span> )</td>
      </tr>
      <tr>
        <td id="L6687" data-line-number="6687"></td>
        <td id="LC6687">        *pbUpdatePatchTable = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L6688" data-line-number="6688"></td>
        <td id="LC6688">
</td>
      </tr>
      <tr>
        <td id="L6689" data-line-number="6689"></td>
        <td id="LC6689">    <span><span>//</span> If we don't have a patch table loaded, then return S_OK since there are no patches to adjust</span></td>
      </tr>
      <tr>
        <td id="L6690" data-line-number="6690"></td>
        <td id="LC6690">    <span>if</span> (m_pPatchTable == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L6691" data-line-number="6691"></td>
        <td id="LC6691">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6692" data-line-number="6692"></td>
        <td id="LC6692">
</td>
      </tr>
      <tr>
        <td id="L6693" data-line-number="6693"></td>
        <td id="LC6693">    <span><span>//</span>is the requested memory completely out-of-range?</span></td>
      </tr>
      <tr>
        <td id="L6694" data-line-number="6694"></td>
        <td id="LC6694">    <span>if</span> ((m_minPatchAddr &gt; (address + (size - <span>1</span>))) ||</td>
      </tr>
      <tr>
        <td id="L6695" data-line-number="6695"></td>
        <td id="LC6695">        (m_maxPatchAddr &lt; address))</td>
      </tr>
      <tr>
        <td id="L6696" data-line-number="6696"></td>
        <td id="LC6696">    {</td>
      </tr>
      <tr>
        <td id="L6697" data-line-number="6697"></td>
        <td id="LC6697">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6698" data-line-number="6698"></td>
        <td id="LC6698">    }</td>
      </tr>
      <tr>
        <td id="L6699" data-line-number="6699"></td>
        <td id="LC6699">
</td>
      </tr>
      <tr>
        <td id="L6700" data-line-number="6700"></td>
        <td id="LC6700">    <span><span>//</span> Without runtime offsets, we can't adjust - this should only ever happen on dumps, where there's</span></td>
      </tr>
      <tr>
        <td id="L6701" data-line-number="6701"></td>
        <td id="LC6701">    <span><span>//</span> no W32ET to get the offsets, and so they stay zeroed</span></td>
      </tr>
      <tr>
        <td id="L6702" data-line-number="6702"></td>
        <td id="LC6702">    <span>if</span> (!m_runtimeOffsetsInitialized)</td>
      </tr>
      <tr>
        <td id="L6703" data-line-number="6703"></td>
        <td id="LC6703">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6704" data-line-number="6704"></td>
        <td id="LC6704">
</td>
      </tr>
      <tr>
        <td id="L6705" data-line-number="6705"></td>
        <td id="LC6705">    <span>LOG</span>((LF_CORDB,LL_INFO10000, <span><span>"</span>CordbProcess::AdjustBuffer at addr 0x%p<span>\n</span><span>"</span></span>, address));</td>
      </tr>
      <tr>
        <td id="L6706" data-line-number="6706"></td>
        <td id="LC6706">
</td>
      </tr>
      <tr>
        <td id="L6707" data-line-number="6707"></td>
        <td id="LC6707">    <span>if</span> (mode == AB_WRITE)</td>
      </tr>
      <tr>
        <td id="L6708" data-line-number="6708"></td>
        <td id="LC6708">    {</td>
      </tr>
      <tr>
        <td id="L6709" data-line-number="6709"></td>
        <td id="LC6709">        <span><span>//</span> We don't want to mess up the original copy of the buffer, so</span></td>
      </tr>
      <tr>
        <td id="L6710" data-line-number="6710"></td>
        <td id="LC6710">        <span><span>//</span> for right now, just copy it wholesale.</span></td>
      </tr>
      <tr>
        <td id="L6711" data-line-number="6711"></td>
        <td id="LC6711">        (*bufferCopy) = <span>new</span> (nothrow) BYTE[size];</td>
      </tr>
      <tr>
        <td id="L6712" data-line-number="6712"></td>
        <td id="LC6712">        <span>if</span> (<span>NULL</span> == (*bufferCopy))</td>
      </tr>
      <tr>
        <td id="L6713" data-line-number="6713"></td>
        <td id="LC6713">            <span>return</span> E_OUTOFMEMORY;</td>
      </tr>
      <tr>
        <td id="L6714" data-line-number="6714"></td>
        <td id="LC6714">
</td>
      </tr>
      <tr>
        <td id="L6715" data-line-number="6715"></td>
        <td id="LC6715">        <span>memmove</span>((*bufferCopy), buffer, size);</td>
      </tr>
      <tr>
        <td id="L6716" data-line-number="6716"></td>
        <td id="LC6716">    }</td>
      </tr>
      <tr>
        <td id="L6717" data-line-number="6717"></td>
        <td id="LC6717">
</td>
      </tr>
      <tr>
        <td id="L6718" data-line-number="6718"></td>
        <td id="LC6718">    ULONG iNextFree = m_iFirstPatch;</td>
      </tr>
      <tr>
        <td id="L6719" data-line-number="6719"></td>
        <td id="LC6719">    <span>while</span>( iNextFree != DPT_TERMINATING_INDEX )</td>
      </tr>
      <tr>
        <td id="L6720" data-line-number="6720"></td>
        <td id="LC6720">    {</td>
      </tr>
      <tr>
        <td id="L6721" data-line-number="6721"></td>
        <td id="LC6721">        BYTE *DebuggerControllerPatch = m_pPatchTable + m_runtimeOffsets.<span>m_cbPatch</span>*iNextFree;</td>
      </tr>
      <tr>
        <td id="L6722" data-line-number="6722"></td>
        <td id="LC6722">        PRD_TYPE opcode = *(PRD_TYPE *)(DebuggerControllerPatch + m_runtimeOffsets.<span>m_offOpcode</span>);</td>
      </tr>
      <tr>
        <td id="L6723" data-line-number="6723"></td>
        <td id="LC6723">        CORDB_ADDRESS patchAddress = <span>PTR_TO_CORDB_ADDRESS</span>(*(BYTE**)(DebuggerControllerPatch + m_runtimeOffsets.<span>m_offAddr</span>));</td>
      </tr>
      <tr>
        <td id="L6724" data-line-number="6724"></td>
        <td id="LC6724">
</td>
      </tr>
      <tr>
        <td id="L6725" data-line-number="6725"></td>
        <td id="LC6725">        <span>if</span> (<span>IsPatchInRequestedRange</span>(address, size, patchAddress))</td>
      </tr>
      <tr>
        <td id="L6726" data-line-number="6726"></td>
        <td id="LC6726">        {</td>
      </tr>
      <tr>
        <td id="L6727" data-line-number="6727"></td>
        <td id="LC6727">            <span>if</span> (mode == AB_READ)</td>
      </tr>
      <tr>
        <td id="L6728" data-line-number="6728"></td>
        <td id="LC6728">            {</td>
      </tr>
      <tr>
        <td id="L6729" data-line-number="6729"></td>
        <td id="LC6729">                <span>CORDbgSetInstructionEx</span>(buffer, address, patchAddress, opcode, size);</td>
      </tr>
      <tr>
        <td id="L6730" data-line-number="6730"></td>
        <td id="LC6730">            }</td>
      </tr>
      <tr>
        <td id="L6731" data-line-number="6731"></td>
        <td id="LC6731">            <span>else</span> <span>if</span> (mode == AB_WRITE)</td>
      </tr>
      <tr>
        <td id="L6732" data-line-number="6732"></td>
        <td id="LC6732">            {</td>
      </tr>
      <tr>
        <td id="L6733" data-line-number="6733"></td>
        <td id="LC6733">                <span>_ASSERTE</span>( pbUpdatePatchTable != <span>NULL</span> );</td>
      </tr>
      <tr>
        <td id="L6734" data-line-number="6734"></td>
        <td id="LC6734">                <span>_ASSERTE</span>( bufferCopy != <span>NULL</span> );</td>
      </tr>
      <tr>
        <td id="L6735" data-line-number="6735"></td>
        <td id="LC6735">
</td>
      </tr>
      <tr>
        <td id="L6736" data-line-number="6736"></td>
        <td id="LC6736">                <span><span>//</span>There can be multiple patches at the same address: we don't want 2nd+ patches to get the</span></td>
      </tr>
      <tr>
        <td id="L6737" data-line-number="6737"></td>
        <td id="LC6737">                <span><span>//</span> break opcode, so we read from the unmodified copy.</span></td>
      </tr>
      <tr>
        <td id="L6738" data-line-number="6738"></td>
        <td id="LC6738">                m_rgUncommitedOpcode[iNextFree] =</td>
      </tr>
      <tr>
        <td id="L6739" data-line-number="6739"></td>
        <td id="LC6739">                    <span>CORDbgGetInstructionEx</span>(*bufferCopy, address, patchAddress, opcode, size);</td>
      </tr>
      <tr>
        <td id="L6740" data-line-number="6740"></td>
        <td id="LC6740">
</td>
      </tr>
      <tr>
        <td id="L6741" data-line-number="6741"></td>
        <td id="LC6741">                <span><span>//</span>put the breakpoint into the memory itself</span></td>
      </tr>
      <tr>
        <td id="L6742" data-line-number="6742"></td>
        <td id="LC6742">                <span>CORDbgInsertBreakpointEx</span>(buffer, address, patchAddress, opcode, size);</td>
      </tr>
      <tr>
        <td id="L6743" data-line-number="6743"></td>
        <td id="LC6743">
</td>
      </tr>
      <tr>
        <td id="L6744" data-line-number="6744"></td>
        <td id="LC6744">                *pbUpdatePatchTable = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L6745" data-line-number="6745"></td>
        <td id="LC6745">            }</td>
      </tr>
      <tr>
        <td id="L6746" data-line-number="6746"></td>
        <td id="LC6746">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L6747" data-line-number="6747"></td>
        <td id="LC6747">                <span>_ASSERTE</span>( !<span><span>"</span>CordbProcess::AdjustBuffergiven non(Read|Write) mode!<span>"</span></span> );</td>
      </tr>
      <tr>
        <td id="L6748" data-line-number="6748"></td>
        <td id="LC6748">        }</td>
      </tr>
      <tr>
        <td id="L6749" data-line-number="6749"></td>
        <td id="LC6749">
</td>
      </tr>
      <tr>
        <td id="L6750" data-line-number="6750"></td>
        <td id="LC6750">        iNextFree = m_rgNextPatch[iNextFree];</td>
      </tr>
      <tr>
        <td id="L6751" data-line-number="6751"></td>
        <td id="LC6751">    }</td>
      </tr>
      <tr>
        <td id="L6752" data-line-number="6752"></td>
        <td id="LC6752">
</td>
      </tr>
      <tr>
        <td id="L6753" data-line-number="6753"></td>
        <td id="LC6753">    <span><span>//</span> If we created a copy of the buffer but didn't modify it, then free it now.</span></td>
      </tr>
      <tr>
        <td id="L6754" data-line-number="6754"></td>
        <td id="LC6754">    <span>if</span>( ( mode == AB_WRITE ) &amp;&amp; ( !*pbUpdatePatchTable ) )</td>
      </tr>
      <tr>
        <td id="L6755" data-line-number="6755"></td>
        <td id="LC6755">    {</td>
      </tr>
      <tr>
        <td id="L6756" data-line-number="6756"></td>
        <td id="LC6756">        <span>delete []</span> *bufferCopy;</td>
      </tr>
      <tr>
        <td id="L6757" data-line-number="6757"></td>
        <td id="LC6757">        *bufferCopy = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L6758" data-line-number="6758"></td>
        <td id="LC6758">    }</td>
      </tr>
      <tr>
        <td id="L6759" data-line-number="6759"></td>
        <td id="LC6759">
</td>
      </tr>
      <tr>
        <td id="L6760" data-line-number="6760"></td>
        <td id="LC6760">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6761" data-line-number="6761"></td>
        <td id="LC6761">}</td>
      </tr>
      <tr>
        <td id="L6762" data-line-number="6762"></td>
        <td id="LC6762">
</td>
      </tr>
      <tr>
        <td id="L6763" data-line-number="6763"></td>
        <td id="LC6763">
</td>
      </tr>
      <tr>
        <td id="L6764" data-line-number="6764"></td>
        <td id="LC6764"><span>void</span> <span>CordbProcess::CommitBufferAdjustments</span>( CORDB_ADDRESS start,</td>
      </tr>
      <tr>
        <td id="L6765" data-line-number="6765"></td>
        <td id="LC6765">                                            CORDB_ADDRESS end )</td>
      </tr>
      <tr>
        <td id="L6766" data-line-number="6766"></td>
        <td id="LC6766">{</td>
      </tr>
      <tr>
        <td id="L6767" data-line-number="6767"></td>
        <td id="LC6767">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6768" data-line-number="6768"></td>
        <td id="LC6768">
</td>
      </tr>
      <tr>
        <td id="L6769" data-line-number="6769"></td>
        <td id="LC6769">    <span>_ASSERTE</span>(m_initialized);</td>
      </tr>
      <tr>
        <td id="L6770" data-line-number="6770"></td>
        <td id="LC6770">    <span>_ASSERTE</span>(<span>this</span>-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6771" data-line-number="6771"></td>
        <td id="LC6771">    <span>_ASSERTE</span>(m_runtimeOffsetsInitialized);</td>
      </tr>
      <tr>
        <td id="L6772" data-line-number="6772"></td>
        <td id="LC6772">
</td>
      </tr>
      <tr>
        <td id="L6773" data-line-number="6773"></td>
        <td id="LC6773">    ULONG iPatch = m_iFirstPatch;</td>
      </tr>
      <tr>
        <td id="L6774" data-line-number="6774"></td>
        <td id="LC6774">    <span>while</span>( iPatch != DPT_TERMINATING_INDEX )</td>
      </tr>
      <tr>
        <td id="L6775" data-line-number="6775"></td>
        <td id="LC6775">    {</td>
      </tr>
      <tr>
        <td id="L6776" data-line-number="6776"></td>
        <td id="LC6776">        BYTE *DebuggerControllerPatch = m_pPatchTable +</td>
      </tr>
      <tr>
        <td id="L6777" data-line-number="6777"></td>
        <td id="LC6777">            m_runtimeOffsets.<span>m_cbPatch</span>*iPatch;</td>
      </tr>
      <tr>
        <td id="L6778" data-line-number="6778"></td>
        <td id="LC6778">
</td>
      </tr>
      <tr>
        <td id="L6779" data-line-number="6779"></td>
        <td id="LC6779">        BYTE *patchAddress = *(BYTE**)(DebuggerControllerPatch + m_runtimeOffsets.<span>m_offAddr</span>);</td>
      </tr>
      <tr>
        <td id="L6780" data-line-number="6780"></td>
        <td id="LC6780">
</td>
      </tr>
      <tr>
        <td id="L6781" data-line-number="6781"></td>
        <td id="LC6781">        <span>if</span> (<span>IsPatchInRequestedRange</span>(start, (SIZE_T)(end - start), <span>PTR_TO_CORDB_ADDRESS</span>(patchAddress)) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L6782" data-line-number="6782"></td>
        <td id="LC6782">            !<span>PRDIsBreakInst</span>(&amp;(m_rgUncommitedOpcode[iPatch])))</td>
      </tr>
      <tr>
        <td id="L6783" data-line-number="6783"></td>
        <td id="LC6783">        {</td>
      </tr>
      <tr>
        <td id="L6784" data-line-number="6784"></td>
        <td id="LC6784">            <span><span>//</span>copy this back to the copy of the patch table</span></td>
      </tr>
      <tr>
        <td id="L6785" data-line-number="6785"></td>
        <td id="LC6785">            *(PRD_TYPE *)(DebuggerControllerPatch + m_runtimeOffsets.<span>m_offOpcode</span>) =</td>
      </tr>
      <tr>
        <td id="L6786" data-line-number="6786"></td>
        <td id="LC6786">                m_rgUncommitedOpcode[iPatch];</td>
      </tr>
      <tr>
        <td id="L6787" data-line-number="6787"></td>
        <td id="LC6787">        }</td>
      </tr>
      <tr>
        <td id="L6788" data-line-number="6788"></td>
        <td id="LC6788">
</td>
      </tr>
      <tr>
        <td id="L6789" data-line-number="6789"></td>
        <td id="LC6789">        iPatch = m_rgNextPatch[iPatch];</td>
      </tr>
      <tr>
        <td id="L6790" data-line-number="6790"></td>
        <td id="LC6790">    }</td>
      </tr>
      <tr>
        <td id="L6791" data-line-number="6791"></td>
        <td id="LC6791">}</td>
      </tr>
      <tr>
        <td id="L6792" data-line-number="6792"></td>
        <td id="LC6792">
</td>
      </tr>
      <tr>
        <td id="L6793" data-line-number="6793"></td>
        <td id="LC6793"><span>void</span> <span>CordbProcess::ClearBufferAdjustments</span>( )</td>
      </tr>
      <tr>
        <td id="L6794" data-line-number="6794"></td>
        <td id="LC6794">{</td>
      </tr>
      <tr>
        <td id="L6795" data-line-number="6795"></td>
        <td id="LC6795">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6796" data-line-number="6796"></td>
        <td id="LC6796">    <span>_ASSERTE</span>(<span>this</span>-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6797" data-line-number="6797"></td>
        <td id="LC6797">
</td>
      </tr>
      <tr>
        <td id="L6798" data-line-number="6798"></td>
        <td id="LC6798">    ULONG iPatch = m_iFirstPatch;</td>
      </tr>
      <tr>
        <td id="L6799" data-line-number="6799"></td>
        <td id="LC6799">    <span>while</span>( iPatch != DPT_TERMINATING_INDEX )</td>
      </tr>
      <tr>
        <td id="L6800" data-line-number="6800"></td>
        <td id="LC6800">    {</td>
      </tr>
      <tr>
        <td id="L6801" data-line-number="6801"></td>
        <td id="LC6801">        <span>InitializePRDToBreakInst</span>(&amp;(m_rgUncommitedOpcode[iPatch]));</td>
      </tr>
      <tr>
        <td id="L6802" data-line-number="6802"></td>
        <td id="LC6802">        iPatch = m_rgNextPatch[iPatch];</td>
      </tr>
      <tr>
        <td id="L6803" data-line-number="6803"></td>
        <td id="LC6803">    }</td>
      </tr>
      <tr>
        <td id="L6804" data-line-number="6804"></td>
        <td id="LC6804">}</td>
      </tr>
      <tr>
        <td id="L6805" data-line-number="6805"></td>
        <td id="LC6805">
</td>
      </tr>
      <tr>
        <td id="L6806" data-line-number="6806"></td>
        <td id="LC6806"><span>void</span> <span>CordbProcess::ClearPatchTable</span>(<span>void</span> )</td>
      </tr>
      <tr>
        <td id="L6807" data-line-number="6807"></td>
        <td id="LC6807">{</td>
      </tr>
      <tr>
        <td id="L6808" data-line-number="6808"></td>
        <td id="LC6808">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6809" data-line-number="6809"></td>
        <td id="LC6809">    <span>_ASSERTE</span>(<span>this</span>-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6810" data-line-number="6810"></td>
        <td id="LC6810">
</td>
      </tr>
      <tr>
        <td id="L6811" data-line-number="6811"></td>
        <td id="LC6811">    <span>if</span> (m_pPatchTable != <span>NULL</span> )</td>
      </tr>
      <tr>
        <td id="L6812" data-line-number="6812"></td>
        <td id="LC6812">    {</td>
      </tr>
      <tr>
        <td id="L6813" data-line-number="6813"></td>
        <td id="LC6813">        <span>delete []</span> m_pPatchTable;</td>
      </tr>
      <tr>
        <td id="L6814" data-line-number="6814"></td>
        <td id="LC6814">        m_pPatchTable = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L6815" data-line-number="6815"></td>
        <td id="LC6815">
</td>
      </tr>
      <tr>
        <td id="L6816" data-line-number="6816"></td>
        <td id="LC6816">        <span>delete []</span> m_rgNextPatch;</td>
      </tr>
      <tr>
        <td id="L6817" data-line-number="6817"></td>
        <td id="LC6817">        m_rgNextPatch = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L6818" data-line-number="6818"></td>
        <td id="LC6818">
</td>
      </tr>
      <tr>
        <td id="L6819" data-line-number="6819"></td>
        <td id="LC6819">        <span>delete []</span> m_rgUncommitedOpcode;</td>
      </tr>
      <tr>
        <td id="L6820" data-line-number="6820"></td>
        <td id="LC6820">        m_rgUncommitedOpcode = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L6821" data-line-number="6821"></td>
        <td id="LC6821">
</td>
      </tr>
      <tr>
        <td id="L6822" data-line-number="6822"></td>
        <td id="LC6822">        m_iFirstPatch = DPT_TERMINATING_INDEX;</td>
      </tr>
      <tr>
        <td id="L6823" data-line-number="6823"></td>
        <td id="LC6823">        m_minPatchAddr = MAX_ADDRESS;</td>
      </tr>
      <tr>
        <td id="L6824" data-line-number="6824"></td>
        <td id="LC6824">        m_maxPatchAddr = MIN_ADDRESS;</td>
      </tr>
      <tr>
        <td id="L6825" data-line-number="6825"></td>
        <td id="LC6825">        m_rgData = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L6826" data-line-number="6826"></td>
        <td id="LC6826">        m_cPatch = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6827" data-line-number="6827"></td>
        <td id="LC6827">    }</td>
      </tr>
      <tr>
        <td id="L6828" data-line-number="6828"></td>
        <td id="LC6828">}</td>
      </tr>
      <tr>
        <td id="L6829" data-line-number="6829"></td>
        <td id="LC6829">
</td>
      </tr>
      <tr>
        <td id="L6830" data-line-number="6830"></td>
        <td id="LC6830">HRESULT <span>CordbProcess::RefreshPatchTable</span>(CORDB_ADDRESS address, SIZE_T size, BYTE buffer[])</td>
      </tr>
      <tr>
        <td id="L6831" data-line-number="6831"></td>
        <td id="LC6831">{</td>
      </tr>
      <tr>
        <td id="L6832" data-line-number="6832"></td>
        <td id="LC6832">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L6833" data-line-number="6833"></td>
        <td id="LC6833">    {</td>
      </tr>
      <tr>
        <td id="L6834" data-line-number="6834"></td>
        <td id="LC6834">        NOTHROW;</td>
      </tr>
      <tr>
        <td id="L6835" data-line-number="6835"></td>
        <td id="LC6835">    }</td>
      </tr>
      <tr>
        <td id="L6836" data-line-number="6836"></td>
        <td id="LC6836">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L6837" data-line-number="6837"></td>
        <td id="LC6837">
</td>
      </tr>
      <tr>
        <td id="L6838" data-line-number="6838"></td>
        <td id="LC6838">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6839" data-line-number="6839"></td>
        <td id="LC6839">    <span>_ASSERTE</span>(m_initialized);</td>
      </tr>
      <tr>
        <td id="L6840" data-line-number="6840"></td>
        <td id="LC6840">    <span>_ASSERTE</span>(<span>this</span>-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L6841" data-line-number="6841"></td>
        <td id="LC6841">
</td>
      </tr>
      <tr>
        <td id="L6842" data-line-number="6842"></td>
        <td id="LC6842">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L6843" data-line-number="6843"></td>
        <td id="LC6843">    BYTE *rgb = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L6844" data-line-number="6844"></td>
        <td id="LC6844">
</td>
      </tr>
      <tr>
        <td id="L6845" data-line-number="6845"></td>
        <td id="LC6845">    <span><span>//</span> All of m_runtimeOffsets will be zeroed out if there's been no call to code:CordbProcess::GetRuntimeOffsets.</span></td>
      </tr>
      <tr>
        <td id="L6846" data-line-number="6846"></td>
        <td id="LC6846">    <span><span>//</span> Thus for things to work, we'd have to have a live target that went and got the real values.</span></td>
      </tr>
      <tr>
        <td id="L6847" data-line-number="6847"></td>
        <td id="LC6847">    <span><span>//</span> For dumps, things are still all zeroed out because we don't have any events sent to the W32ET, don't</span></td>
      </tr>
      <tr>
        <td id="L6848" data-line-number="6848"></td>
        <td id="LC6848">    <span><span>//</span> have a live process to investigate, etc.</span></td>
      </tr>
      <tr>
        <td id="L6849" data-line-number="6849"></td>
        <td id="LC6849">    <span>if</span> (!m_runtimeOffsetsInitialized)</td>
      </tr>
      <tr>
        <td id="L6850" data-line-number="6850"></td>
        <td id="LC6850">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6851" data-line-number="6851"></td>
        <td id="LC6851">
</td>
      </tr>
      <tr>
        <td id="L6852" data-line-number="6852"></td>
        <td id="LC6852">    <span>_ASSERTE</span>( m_runtimeOffsets.<span>m_cbOpcode</span> == <span>sizeof</span>(PRD_TYPE) );</td>
      </tr>
      <tr>
        <td id="L6853" data-line-number="6853"></td>
        <td id="LC6853">
</td>
      </tr>
      <tr>
        <td id="L6854" data-line-number="6854"></td>
        <td id="LC6854">    <span>CORDBRequireProcessStateOK</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L6855" data-line-number="6855"></td>
        <td id="LC6855">
</td>
      </tr>
      <tr>
        <td id="L6856" data-line-number="6856"></td>
        <td id="LC6856">    <span>if</span> (m_pPatchTable == <span>NULL</span> )</td>
      </tr>
      <tr>
        <td id="L6857" data-line-number="6857"></td>
        <td id="LC6857">    {</td>
      </tr>
      <tr>
        <td id="L6858" data-line-number="6858"></td>
        <td id="LC6858">        <span><span>//</span> First, check to be sure the patch table is valid on the Left Side. If its not, then we won't read it.</span></td>
      </tr>
      <tr>
        <td id="L6859" data-line-number="6859"></td>
        <td id="LC6859">        BOOL <span>fPatchTableValid</span> = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L6860" data-line-number="6860"></td>
        <td id="LC6860">
</td>
      </tr>
      <tr>
        <td id="L6861" data-line-number="6861"></td>
        <td id="LC6861">        hr = <span>SafeReadStruct</span>(<span>PTR_TO_CORDB_ADDRESS</span>(m_runtimeOffsets.<span>m_pPatchTableValid</span>), &amp;<span>fPatchTableValid</span>);</td>
      </tr>
      <tr>
        <td id="L6862" data-line-number="6862"></td>
        <td id="LC6862">        <span>if</span> (<span>FAILED</span>(hr) || !<span>fPatchTableValid</span>)</td>
      </tr>
      <tr>
        <td id="L6863" data-line-number="6863"></td>
        <td id="LC6863">        {</td>
      </tr>
      <tr>
        <td id="L6864" data-line-number="6864"></td>
        <td id="LC6864">            <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>Wont refresh patch table because its not valid now.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L6865" data-line-number="6865"></td>
        <td id="LC6865">            <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6866" data-line-number="6866"></td>
        <td id="LC6866">        }</td>
      </tr>
      <tr>
        <td id="L6867" data-line-number="6867"></td>
        <td id="LC6867">
</td>
      </tr>
      <tr>
        <td id="L6868" data-line-number="6868"></td>
        <td id="LC6868">        SIZE_T offStart = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6869" data-line-number="6869"></td>
        <td id="LC6869">        SIZE_T offEnd = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6870" data-line-number="6870"></td>
        <td id="LC6870">        UINT cbTableSlice = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6871" data-line-number="6871"></td>
        <td id="LC6871">
</td>
      </tr>
      <tr>
        <td id="L6872" data-line-number="6872"></td>
        <td id="LC6872">        <span><span>//</span> Grab the patch table info</span></td>
      </tr>
      <tr>
        <td id="L6873" data-line-number="6873"></td>
        <td id="LC6873">        offStart = <span>min</span>(m_runtimeOffsets.<span>m_offRgData</span>, m_runtimeOffsets.<span>m_offCData</span>);</td>
      </tr>
      <tr>
        <td id="L6874" data-line-number="6874"></td>
        <td id="LC6874">        offEnd   = <span>max</span>(m_runtimeOffsets.<span>m_offRgData</span>, m_runtimeOffsets.<span>m_offCData</span>) + <span>sizeof</span>(SIZE_T);</td>
      </tr>
      <tr>
        <td id="L6875" data-line-number="6875"></td>
        <td id="LC6875">        cbTableSlice = (UINT)(offEnd - offStart);</td>
      </tr>
      <tr>
        <td id="L6876" data-line-number="6876"></td>
        <td id="LC6876">
</td>
      </tr>
      <tr>
        <td id="L6877" data-line-number="6877"></td>
        <td id="LC6877">        <span>if</span> (cbTableSlice == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6878" data-line-number="6878"></td>
        <td id="LC6878">        {</td>
      </tr>
      <tr>
        <td id="L6879" data-line-number="6879"></td>
        <td id="LC6879">            <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>Wont refresh patch table because its not valid now.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L6880" data-line-number="6880"></td>
        <td id="LC6880">            <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L6881" data-line-number="6881"></td>
        <td id="LC6881">        }</td>
      </tr>
      <tr>
        <td id="L6882" data-line-number="6882"></td>
        <td id="LC6882">
</td>
      </tr>
      <tr>
        <td id="L6883" data-line-number="6883"></td>
        <td id="LC6883">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L6884" data-line-number="6884"></td>
        <td id="LC6884">        {</td>
      </tr>
      <tr>
        <td id="L6885" data-line-number="6885"></td>
        <td id="LC6885">            rgb = <span>new</span> BYTE[cbTableSlice]; <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L6886" data-line-number="6886"></td>
        <td id="LC6886">
</td>
      </tr>
      <tr>
        <td id="L6887" data-line-number="6887"></td>
        <td id="LC6887">            TargetBuffer <span>tbSlice</span>((BYTE*)m_runtimeOffsets.<span>m_pPatches</span> + offStart, cbTableSlice);</td>
      </tr>
      <tr>
        <td id="L6888" data-line-number="6888"></td>
        <td id="LC6888">            <span>this</span>-&gt;<span>SafeReadBuffer</span>(tbSlice, rgb); <span><span>//</span> Throws;</span></td>
      </tr>
      <tr>
        <td id="L6889" data-line-number="6889"></td>
        <td id="LC6889">
</td>
      </tr>
      <tr>
        <td id="L6890" data-line-number="6890"></td>
        <td id="LC6890">            <span><span>//</span> Note that rgData is a pointer in the left side address space</span></td>
      </tr>
      <tr>
        <td id="L6891" data-line-number="6891"></td>
        <td id="LC6891">            m_rgData = *(BYTE**)(rgb + m_runtimeOffsets.<span>m_offRgData</span> - offStart);</td>
      </tr>
      <tr>
        <td id="L6892" data-line-number="6892"></td>
        <td id="LC6892">            m_cPatch = *(ULONG*)(rgb + m_runtimeOffsets.<span>m_offCData</span> - offStart);</td>
      </tr>
      <tr>
        <td id="L6893" data-line-number="6893"></td>
        <td id="LC6893">
</td>
      </tr>
      <tr>
        <td id="L6894" data-line-number="6894"></td>
        <td id="LC6894">            <span><span>//</span> Grab the patch table</span></td>
      </tr>
      <tr>
        <td id="L6895" data-line-number="6895"></td>
        <td id="LC6895">            UINT cbPatchTable = (UINT)(m_cPatch * m_runtimeOffsets.<span>m_cbPatch</span>);</td>
      </tr>
      <tr>
        <td id="L6896" data-line-number="6896"></td>
        <td id="LC6896">
</td>
      </tr>
      <tr>
        <td id="L6897" data-line-number="6897"></td>
        <td id="LC6897">            <span>if</span> (cbPatchTable == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6898" data-line-number="6898"></td>
        <td id="LC6898">            {</td>
      </tr>
      <tr>
        <td id="L6899" data-line-number="6899"></td>
        <td id="LC6899">                <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>Wont refresh patch table because its not valid now.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L6900" data-line-number="6900"></td>
        <td id="LC6900">                <span>_ASSERTE</span>(hr == S_OK);</td>
      </tr>
      <tr>
        <td id="L6901" data-line-number="6901"></td>
        <td id="LC6901">                <span>goto</span> LExit; <span><span>//</span> can't return since we're in a Try/Catch</span></td>
      </tr>
      <tr>
        <td id="L6902" data-line-number="6902"></td>
        <td id="LC6902">            }</td>
      </tr>
      <tr>
        <td id="L6903" data-line-number="6903"></td>
        <td id="LC6903">
</td>
      </tr>
      <tr>
        <td id="L6904" data-line-number="6904"></td>
        <td id="LC6904">            <span><span>//</span> Throwing news</span></td>
      </tr>
      <tr>
        <td id="L6905" data-line-number="6905"></td>
        <td id="LC6905">            m_pPatchTable = <span>new</span> BYTE[ cbPatchTable ];</td>
      </tr>
      <tr>
        <td id="L6906" data-line-number="6906"></td>
        <td id="LC6906">            m_rgNextPatch = <span>new</span> ULONG[m_cPatch];</td>
      </tr>
      <tr>
        <td id="L6907" data-line-number="6907"></td>
        <td id="LC6907">            m_rgUncommitedOpcode = <span>new</span> PRD_TYPE[m_cPatch];</td>
      </tr>
      <tr>
        <td id="L6908" data-line-number="6908"></td>
        <td id="LC6908">
</td>
      </tr>
      <tr>
        <td id="L6909" data-line-number="6909"></td>
        <td id="LC6909">            TargetBuffer <span>tb</span>(m_rgData, cbPatchTable);</td>
      </tr>
      <tr>
        <td id="L6910" data-line-number="6910"></td>
        <td id="LC6910">            <span>this</span>-&gt;<span>SafeReadBuffer</span>(tb, m_pPatchTable); <span><span>//</span> Throws</span></td>
      </tr>
      <tr>
        <td id="L6911" data-line-number="6911"></td>
        <td id="LC6911">
</td>
      </tr>
      <tr>
        <td id="L6912" data-line-number="6912"></td>
        <td id="LC6912">            <span><span>//</span>As we go through the patch table we do a number of things:</span></td>
      </tr>
      <tr>
        <td id="L6913" data-line-number="6913"></td>
        <td id="LC6913">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6914" data-line-number="6914"></td>
        <td id="LC6914">            <span><span>//</span> 1. collect min,max address seen for quick fail check</span></td>
      </tr>
      <tr>
        <td id="L6915" data-line-number="6915"></td>
        <td id="LC6915">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6916" data-line-number="6916"></td>
        <td id="LC6916">            <span><span>//</span> 2. Link all valid entries into a linked list, the first entry of which is m_iFirstPatch</span></td>
      </tr>
      <tr>
        <td id="L6917" data-line-number="6917"></td>
        <td id="LC6917">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6918" data-line-number="6918"></td>
        <td id="LC6918">            <span><span>//</span> 3. Initialize m_rgUncommitedOpcode, so that we can undo local patch table changes if WriteMemory can't write</span></td>
      </tr>
      <tr>
        <td id="L6919" data-line-number="6919"></td>
        <td id="LC6919">            <span><span>//</span> atomically.</span></td>
      </tr>
      <tr>
        <td id="L6920" data-line-number="6920"></td>
        <td id="LC6920">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6921" data-line-number="6921"></td>
        <td id="LC6921">            <span><span>//</span> 4. If the patch is in the memory we grabbed, unapply it.</span></td>
      </tr>
      <tr>
        <td id="L6922" data-line-number="6922"></td>
        <td id="LC6922">
</td>
      </tr>
      <tr>
        <td id="L6923" data-line-number="6923"></td>
        <td id="LC6923">            ULONG iDebuggerControllerPatchPrev = DPT_TERMINATING_INDEX;</td>
      </tr>
      <tr>
        <td id="L6924" data-line-number="6924"></td>
        <td id="LC6924">
</td>
      </tr>
      <tr>
        <td id="L6925" data-line-number="6925"></td>
        <td id="LC6925">            m_minPatchAddr = MAX_ADDRESS;</td>
      </tr>
      <tr>
        <td id="L6926" data-line-number="6926"></td>
        <td id="LC6926">            m_maxPatchAddr = MIN_ADDRESS;</td>
      </tr>
      <tr>
        <td id="L6927" data-line-number="6927"></td>
        <td id="LC6927">            m_iFirstPatch = DPT_TERMINATING_INDEX;</td>
      </tr>
      <tr>
        <td id="L6928" data-line-number="6928"></td>
        <td id="LC6928">
</td>
      </tr>
      <tr>
        <td id="L6929" data-line-number="6929"></td>
        <td id="LC6929">            <span>for</span> (ULONG iPatch = <span>0</span>; iPatch &lt; m_cPatch;iPatch++)</td>
      </tr>
      <tr>
        <td id="L6930" data-line-number="6930"></td>
        <td id="LC6930">            {</td>
      </tr>
      <tr>
        <td id="L6931" data-line-number="6931"></td>
        <td id="LC6931">                <span><span>//</span> &lt;REVISIT_TODO&gt;@todo port: we're making assumptions about the size of opcodes,address pointers, etc&lt;/REVISIT_TODO&gt;</span></td>
      </tr>
      <tr>
        <td id="L6932" data-line-number="6932"></td>
        <td id="LC6932">                BYTE *DebuggerControllerPatch = m_pPatchTable + m_runtimeOffsets.<span>m_cbPatch</span> * iPatch;</td>
      </tr>
      <tr>
        <td id="L6933" data-line-number="6933"></td>
        <td id="LC6933">                PRD_TYPE opcode = *(PRD_TYPE*)(DebuggerControllerPatch + m_runtimeOffsets.<span>m_offOpcode</span>);</td>
      </tr>
      <tr>
        <td id="L6934" data-line-number="6934"></td>
        <td id="LC6934">                CORDB_ADDRESS patchAddress = <span>PTR_TO_CORDB_ADDRESS</span>(*(BYTE**)(DebuggerControllerPatch + m_runtimeOffsets.<span>m_offAddr</span>));</td>
      </tr>
      <tr>
        <td id="L6935" data-line-number="6935"></td>
        <td id="LC6935">
</td>
      </tr>
      <tr>
        <td id="L6936" data-line-number="6936"></td>
        <td id="LC6936">                <span><span>//</span> A non-zero opcode indicates to us that this patch is valid.</span></td>
      </tr>
      <tr>
        <td id="L6937" data-line-number="6937"></td>
        <td id="LC6937">                <span>if</span> (!<span>PRDIsEmpty</span>(opcode))</td>
      </tr>
      <tr>
        <td id="L6938" data-line-number="6938"></td>
        <td id="LC6938">                {</td>
      </tr>
      <tr>
        <td id="L6939" data-line-number="6939"></td>
        <td id="LC6939">                    <span>_ASSERTE</span>( patchAddress != <span>0</span> );</td>
      </tr>
      <tr>
        <td id="L6940" data-line-number="6940"></td>
        <td id="LC6940">
</td>
      </tr>
      <tr>
        <td id="L6941" data-line-number="6941"></td>
        <td id="LC6941">                    <span><span>//</span> (1), above</span></td>
      </tr>
      <tr>
        <td id="L6942" data-line-number="6942"></td>
        <td id="LC6942">                    <span><span>//</span> Note that GetPatchEndAddr() returns the address immediately AFTER the patch,</span></td>
      </tr>
      <tr>
        <td id="L6943" data-line-number="6943"></td>
        <td id="LC6943">                    <span><span>//</span> so we have to subtract 1 from it below.</span></td>
      </tr>
      <tr>
        <td id="L6944" data-line-number="6944"></td>
        <td id="LC6944">                    <span>if</span> (m_minPatchAddr &gt; patchAddress )</td>
      </tr>
      <tr>
        <td id="L6945" data-line-number="6945"></td>
        <td id="LC6945">                        m_minPatchAddr = patchAddress;</td>
      </tr>
      <tr>
        <td id="L6946" data-line-number="6946"></td>
        <td id="LC6946">                    <span>if</span> (m_maxPatchAddr &lt; patchAddress )</td>
      </tr>
      <tr>
        <td id="L6947" data-line-number="6947"></td>
        <td id="LC6947">                        m_maxPatchAddr = <span>GetPatchEndAddr</span>(patchAddress) - <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L6948" data-line-number="6948"></td>
        <td id="LC6948">
</td>
      </tr>
      <tr>
        <td id="L6949" data-line-number="6949"></td>
        <td id="LC6949">                    <span><span>//</span> (2), above</span></td>
      </tr>
      <tr>
        <td id="L6950" data-line-number="6950"></td>
        <td id="LC6950">                    <span>if</span> ( m_iFirstPatch == DPT_TERMINATING_INDEX)</td>
      </tr>
      <tr>
        <td id="L6951" data-line-number="6951"></td>
        <td id="LC6951">                    {</td>
      </tr>
      <tr>
        <td id="L6952" data-line-number="6952"></td>
        <td id="LC6952">                        m_iFirstPatch = iPatch;</td>
      </tr>
      <tr>
        <td id="L6953" data-line-number="6953"></td>
        <td id="LC6953">                        <span>_ASSERTE</span>( iPatch != DPT_TERMINATING_INDEX);</td>
      </tr>
      <tr>
        <td id="L6954" data-line-number="6954"></td>
        <td id="LC6954">                    }</td>
      </tr>
      <tr>
        <td id="L6955" data-line-number="6955"></td>
        <td id="LC6955">
</td>
      </tr>
      <tr>
        <td id="L6956" data-line-number="6956"></td>
        <td id="LC6956">                    <span>if</span> (iDebuggerControllerPatchPrev != DPT_TERMINATING_INDEX)</td>
      </tr>
      <tr>
        <td id="L6957" data-line-number="6957"></td>
        <td id="LC6957">                    {</td>
      </tr>
      <tr>
        <td id="L6958" data-line-number="6958"></td>
        <td id="LC6958">                        m_rgNextPatch[iDebuggerControllerPatchPrev] = iPatch;</td>
      </tr>
      <tr>
        <td id="L6959" data-line-number="6959"></td>
        <td id="LC6959">                    }</td>
      </tr>
      <tr>
        <td id="L6960" data-line-number="6960"></td>
        <td id="LC6960">
</td>
      </tr>
      <tr>
        <td id="L6961" data-line-number="6961"></td>
        <td id="LC6961">                    iDebuggerControllerPatchPrev = iPatch;</td>
      </tr>
      <tr>
        <td id="L6962" data-line-number="6962"></td>
        <td id="LC6962">
</td>
      </tr>
      <tr>
        <td id="L6963" data-line-number="6963"></td>
        <td id="LC6963">                    <span><span>//</span> (3), above</span></td>
      </tr>
      <tr>
        <td id="L6964" data-line-number="6964"></td>
        <td id="LC6964">                    <span>InitializePRDToBreakInst</span>(&amp;(m_rgUncommitedOpcode[iPatch]));</td>
      </tr>
      <tr>
        <td id="L6965" data-line-number="6965"></td>
        <td id="LC6965">
</td>
      </tr>
      <tr>
        <td id="L6966" data-line-number="6966"></td>
        <td id="LC6966">                    <span><span>//</span> (4), above</span></td>
      </tr>
      <tr>
        <td id="L6967" data-line-number="6967"></td>
        <td id="LC6967">                    <span>if</span> (<span>IsPatchInRequestedRange</span>(address, size, patchAddress))</td>
      </tr>
      <tr>
        <td id="L6968" data-line-number="6968"></td>
        <td id="LC6968">                    {</td>
      </tr>
      <tr>
        <td id="L6969" data-line-number="6969"></td>
        <td id="LC6969">                        <span>_ASSERTE</span>( buffer != <span>NULL</span> );</td>
      </tr>
      <tr>
        <td id="L6970" data-line-number="6970"></td>
        <td id="LC6970">                        <span>_ASSERTE</span>( size != <span>NULL</span> );</td>
      </tr>
      <tr>
        <td id="L6971" data-line-number="6971"></td>
        <td id="LC6971">
</td>
      </tr>
      <tr>
        <td id="L6972" data-line-number="6972"></td>
        <td id="LC6972">
</td>
      </tr>
      <tr>
        <td id="L6973" data-line-number="6973"></td>
        <td id="LC6973">                        <span><span>//</span>unapply the patch here.</span></td>
      </tr>
      <tr>
        <td id="L6974" data-line-number="6974"></td>
        <td id="LC6974">                        <span>CORDbgSetInstructionEx</span>(buffer, address, patchAddress, opcode, size);</td>
      </tr>
      <tr>
        <td id="L6975" data-line-number="6975"></td>
        <td id="LC6975">                    }</td>
      </tr>
      <tr>
        <td id="L6976" data-line-number="6976"></td>
        <td id="LC6976">
</td>
      </tr>
      <tr>
        <td id="L6977" data-line-number="6977"></td>
        <td id="LC6977">                }</td>
      </tr>
      <tr>
        <td id="L6978" data-line-number="6978"></td>
        <td id="LC6978">            }</td>
      </tr>
      <tr>
        <td id="L6979" data-line-number="6979"></td>
        <td id="LC6979">
</td>
      </tr>
      <tr>
        <td id="L6980" data-line-number="6980"></td>
        <td id="LC6980">            <span>if</span> (iDebuggerControllerPatchPrev != DPT_TERMINATING_INDEX)</td>
      </tr>
      <tr>
        <td id="L6981" data-line-number="6981"></td>
        <td id="LC6981">            {</td>
      </tr>
      <tr>
        <td id="L6982" data-line-number="6982"></td>
        <td id="LC6982">                m_rgNextPatch[iDebuggerControllerPatchPrev] = DPT_TERMINATING_INDEX;</td>
      </tr>
      <tr>
        <td id="L6983" data-line-number="6983"></td>
        <td id="LC6983">            }</td>
      </tr>
      <tr>
        <td id="L6984" data-line-number="6984"></td>
        <td id="LC6984">        }</td>
      </tr>
      <tr>
        <td id="L6985" data-line-number="6985"></td>
        <td id="LC6985">LExit:</td>
      </tr>
      <tr>
        <td id="L6986" data-line-number="6986"></td>
        <td id="LC6986">    ;</td>
      </tr>
      <tr>
        <td id="L6987" data-line-number="6987"></td>
        <td id="LC6987">        <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L6988" data-line-number="6988"></td>
        <td id="LC6988">    }</td>
      </tr>
      <tr>
        <td id="L6989" data-line-number="6989"></td>
        <td id="LC6989">
</td>
      </tr>
      <tr>
        <td id="L6990" data-line-number="6990"></td>
        <td id="LC6990">
</td>
      </tr>
      <tr>
        <td id="L6991" data-line-number="6991"></td>
        <td id="LC6991">    <span>if</span> (rgb != <span>NULL</span> )</td>
      </tr>
      <tr>
        <td id="L6992" data-line-number="6992"></td>
        <td id="LC6992">    {</td>
      </tr>
      <tr>
        <td id="L6993" data-line-number="6993"></td>
        <td id="LC6993">        <span>delete []</span> rgb;</td>
      </tr>
      <tr>
        <td id="L6994" data-line-number="6994"></td>
        <td id="LC6994">    }</td>
      </tr>
      <tr>
        <td id="L6995" data-line-number="6995"></td>
        <td id="LC6995">
</td>
      </tr>
      <tr>
        <td id="L6996" data-line-number="6996"></td>
        <td id="LC6996">    <span>if</span> (<span>FAILED</span>( hr ) )</td>
      </tr>
      <tr>
        <td id="L6997" data-line-number="6997"></td>
        <td id="LC6997">    {</td>
      </tr>
      <tr>
        <td id="L6998" data-line-number="6998"></td>
        <td id="LC6998">        <span>ClearPatchTable</span>();</td>
      </tr>
      <tr>
        <td id="L6999" data-line-number="6999"></td>
        <td id="LC6999">    }</td>
      </tr>
      <tr>
        <td id="L7000" data-line-number="7000"></td>
        <td id="LC7000">
</td>
      </tr>
      <tr>
        <td id="L7001" data-line-number="7001"></td>
        <td id="LC7001">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L7002" data-line-number="7002"></td>
        <td id="LC7002">}</td>
      </tr>
      <tr>
        <td id="L7003" data-line-number="7003"></td>
        <td id="LC7003">
</td>
      </tr>
      <tr>
        <td id="L7004" data-line-number="7004"></td>
        <td id="LC7004"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7005" data-line-number="7005"></td>
        <td id="LC7005"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7006" data-line-number="7006"></td>
        <td id="LC7006"><span><span>//</span> Given an address, see if there is a patch in the patch table that matches it and return</span></td>
      </tr>
      <tr>
        <td id="L7007" data-line-number="7007"></td>
        <td id="LC7007"><span><span>//</span> if its an unmanaged patch or not.</span></td>
      </tr>
      <tr>
        <td id="L7008" data-line-number="7008"></td>
        <td id="LC7008"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7009" data-line-number="7009"></td>
        <td id="LC7009"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L7010" data-line-number="7010"></td>
        <td id="LC7010"><span><span>//</span>     address - The address of an instruction to check in the target address space.</span></td>
      </tr>
      <tr>
        <td id="L7011" data-line-number="7011"></td>
        <td id="LC7011"><span><span>//</span>     pfPatchFound - Space to store the result, TRUE if the address belongs to a</span></td>
      </tr>
      <tr>
        <td id="L7012" data-line-number="7012"></td>
        <td id="LC7012"><span><span>//</span>         patch, FALSE if not.  Only valid if this method returns a success code.</span></td>
      </tr>
      <tr>
        <td id="L7013" data-line-number="7013"></td>
        <td id="LC7013"><span><span>//</span>     pfPatchIsUnmanaged - Space to store the result, TRUE if the address is a patch</span></td>
      </tr>
      <tr>
        <td id="L7014" data-line-number="7014"></td>
        <td id="LC7014"><span><span>//</span>         and the patch is unmanaged, FALSE if not.  Only valid if this method returns a</span></td>
      </tr>
      <tr>
        <td id="L7015" data-line-number="7015"></td>
        <td id="LC7015"><span><span>//</span>         success code.</span></td>
      </tr>
      <tr>
        <td id="L7016" data-line-number="7016"></td>
        <td id="LC7016"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7017" data-line-number="7017"></td>
        <td id="LC7017"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L7018" data-line-number="7018"></td>
        <td id="LC7018"><span><span>//</span>     Typical HRESULT symantics, nothing abnormal.</span></td>
      </tr>
      <tr>
        <td id="L7019" data-line-number="7019"></td>
        <td id="LC7019"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7020" data-line-number="7020"></td>
        <td id="LC7020"><span><span>//</span> Note: this method is pretty in-efficient. It refreshes the patch table, then scans it.</span></td>
      </tr>
      <tr>
        <td id="L7021" data-line-number="7021"></td>
        <td id="LC7021"><span><span>//</span>     Refreshing the patch table involves a scan, too, so this method could be folded</span></td>
      </tr>
      <tr>
        <td id="L7022" data-line-number="7022"></td>
        <td id="LC7022"><span><span>//</span>     with that.</span></td>
      </tr>
      <tr>
        <td id="L7023" data-line-number="7023"></td>
        <td id="LC7023"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7024" data-line-number="7024"></td>
        <td id="LC7024"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7025" data-line-number="7025"></td>
        <td id="LC7025">HRESULT <span>CordbProcess::FindPatchByAddress</span>(CORDB_ADDRESS address, <span>bool</span> *pfPatchFound, <span>bool</span> *pfPatchIsUnmanaged)</td>
      </tr>
      <tr>
        <td id="L7026" data-line-number="7026"></td>
        <td id="LC7026">{</td>
      </tr>
      <tr>
        <td id="L7027" data-line-number="7027"></td>
        <td id="LC7027">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7028" data-line-number="7028"></td>
        <td id="LC7028">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L7029" data-line-number="7029"></td>
        <td id="LC7029">    <span>_ASSERTE</span>((pfPatchFound != <span>NULL</span>) &amp;&amp; (pfPatchIsUnmanaged != <span>NULL</span>));</td>
      </tr>
      <tr>
        <td id="L7030" data-line-number="7030"></td>
        <td id="LC7030">    <span>_ASSERTE</span>(m_runtimeOffsetsInitialized);</td>
      </tr>
      <tr>
        <td id="L7031" data-line-number="7031"></td>
        <td id="LC7031">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7032" data-line-number="7032"></td>
        <td id="LC7032">
</td>
      </tr>
      <tr>
        <td id="L7033" data-line-number="7033"></td>
        <td id="LC7033">    *pfPatchFound = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L7034" data-line-number="7034"></td>
        <td id="LC7034">    *pfPatchIsUnmanaged = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L7035" data-line-number="7035"></td>
        <td id="LC7035">
</td>
      </tr>
      <tr>
        <td id="L7036" data-line-number="7036"></td>
        <td id="LC7036">    <span><span>//</span> First things first. If the process isn't initialized, then there can be no patch table, so we know the breakpoint</span></td>
      </tr>
      <tr>
        <td id="L7037" data-line-number="7037"></td>
        <td id="LC7037">    <span><span>//</span> doesn't belong to the Runtime.</span></td>
      </tr>
      <tr>
        <td id="L7038" data-line-number="7038"></td>
        <td id="LC7038">    <span>if</span> (!m_initialized)</td>
      </tr>
      <tr>
        <td id="L7039" data-line-number="7039"></td>
        <td id="LC7039">    {</td>
      </tr>
      <tr>
        <td id="L7040" data-line-number="7040"></td>
        <td id="LC7040">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L7041" data-line-number="7041"></td>
        <td id="LC7041">    }</td>
      </tr>
      <tr>
        <td id="L7042" data-line-number="7042"></td>
        <td id="LC7042">
</td>
      </tr>
      <tr>
        <td id="L7043" data-line-number="7043"></td>
        <td id="LC7043">    <span><span>//</span> This method is called from the main loop of the win32 event thread in response to a first chance breakpoint event</span></td>
      </tr>
      <tr>
        <td id="L7044" data-line-number="7044"></td>
        <td id="LC7044">    <span><span>//</span> that we know is not a flare. The process has been runnning, and it may have invalidated the patch table, so we'll</span></td>
      </tr>
      <tr>
        <td id="L7045" data-line-number="7045"></td>
        <td id="LC7045">    <span><span>//</span> flush it here before refreshing it to make sure we've got the right thing.</span></td>
      </tr>
      <tr>
        <td id="L7046" data-line-number="7046"></td>
        <td id="LC7046">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7047" data-line-number="7047"></td>
        <td id="LC7047">    <span><span>//</span> Note: we really should have the Left Side mark the patch table dirty to help optimize this.</span></td>
      </tr>
      <tr>
        <td id="L7048" data-line-number="7048"></td>
        <td id="LC7048">    <span>ClearPatchTable</span>();</td>
      </tr>
      <tr>
        <td id="L7049" data-line-number="7049"></td>
        <td id="LC7049">
</td>
      </tr>
      <tr>
        <td id="L7050" data-line-number="7050"></td>
        <td id="LC7050">    <span><span>//</span> Refresh the patch table.</span></td>
      </tr>
      <tr>
        <td id="L7051" data-line-number="7051"></td>
        <td id="LC7051">    HRESULT hr = <span>RefreshPatchTable</span>();</td>
      </tr>
      <tr>
        <td id="L7052" data-line-number="7052"></td>
        <td id="LC7052">
</td>
      </tr>
      <tr>
        <td id="L7053" data-line-number="7053"></td>
        <td id="LC7053">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L7054" data-line-number="7054"></td>
        <td id="LC7054">    {</td>
      </tr>
      <tr>
        <td id="L7055" data-line-number="7055"></td>
        <td id="LC7055">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::FPBA: failed to refresh the patch table<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L7056" data-line-number="7056"></td>
        <td id="LC7056">        <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L7057" data-line-number="7057"></td>
        <td id="LC7057">    }</td>
      </tr>
      <tr>
        <td id="L7058" data-line-number="7058"></td>
        <td id="LC7058">
</td>
      </tr>
      <tr>
        <td id="L7059" data-line-number="7059"></td>
        <td id="LC7059">    <span><span>//</span> If there is no patch table yet, then we know there is no patch at the given address, so return S_OK with</span></td>
      </tr>
      <tr>
        <td id="L7060" data-line-number="7060"></td>
        <td id="LC7060">    <span><span>//</span> *patchFound = false.</span></td>
      </tr>
      <tr>
        <td id="L7061" data-line-number="7061"></td>
        <td id="LC7061">    <span>if</span> (m_pPatchTable == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7062" data-line-number="7062"></td>
        <td id="LC7062">    {</td>
      </tr>
      <tr>
        <td id="L7063" data-line-number="7063"></td>
        <td id="LC7063">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::FPBA: no patch table<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L7064" data-line-number="7064"></td>
        <td id="LC7064">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L7065" data-line-number="7065"></td>
        <td id="LC7065">    }</td>
      </tr>
      <tr>
        <td id="L7066" data-line-number="7066"></td>
        <td id="LC7066">
</td>
      </tr>
      <tr>
        <td id="L7067" data-line-number="7067"></td>
        <td id="LC7067">    <span><span>//</span> Scan the patch table for a matching patch.</span></td>
      </tr>
      <tr>
        <td id="L7068" data-line-number="7068"></td>
        <td id="LC7068">    <span>for</span> (ULONG iNextPatch = m_iFirstPatch; iNextPatch != DPT_TERMINATING_INDEX; iNextPatch = m_rgNextPatch[iNextPatch])</td>
      </tr>
      <tr>
        <td id="L7069" data-line-number="7069"></td>
        <td id="LC7069">    {</td>
      </tr>
      <tr>
        <td id="L7070" data-line-number="7070"></td>
        <td id="LC7070">        BYTE *patch = m_pPatchTable + (m_runtimeOffsets.<span>m_cbPatch</span> * iNextPatch);</td>
      </tr>
      <tr>
        <td id="L7071" data-line-number="7071"></td>
        <td id="LC7071">        BYTE *patchAddress = *(BYTE**)(patch + m_runtimeOffsets.<span>m_offAddr</span>);</td>
      </tr>
      <tr>
        <td id="L7072" data-line-number="7072"></td>
        <td id="LC7072">        DWORD traceType = *(DWORD*)(patch + m_runtimeOffsets.<span>m_offTraceType</span>);</td>
      </tr>
      <tr>
        <td id="L7073" data-line-number="7073"></td>
        <td id="LC7073">
</td>
      </tr>
      <tr>
        <td id="L7074" data-line-number="7074"></td>
        <td id="LC7074">        <span>if</span> (address == <span>PTR_TO_CORDB_ADDRESS</span>(patchAddress))</td>
      </tr>
      <tr>
        <td id="L7075" data-line-number="7075"></td>
        <td id="LC7075">        {</td>
      </tr>
      <tr>
        <td id="L7076" data-line-number="7076"></td>
        <td id="LC7076">            *pfPatchFound = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7077" data-line-number="7077"></td>
        <td id="LC7077">
</td>
      </tr>
      <tr>
        <td id="L7078" data-line-number="7078"></td>
        <td id="LC7078">            <span>if</span> (traceType == m_runtimeOffsets.<span>m_traceTypeUnmanaged</span>)</td>
      </tr>
      <tr>
        <td id="L7079" data-line-number="7079"></td>
        <td id="LC7079">            {</td>
      </tr>
      <tr>
        <td id="L7080" data-line-number="7080"></td>
        <td id="LC7080">                *pfPatchIsUnmanaged = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7081" data-line-number="7081"></td>
        <td id="LC7081">
</td>
      </tr>
      <tr>
        <td id="L7082" data-line-number="7082"></td>
        <td id="LC7082">#<span>if</span> defined(_DEBUG)</td>
      </tr>
      <tr>
        <td id="L7083" data-line-number="7083"></td>
        <td id="LC7083">                HRESULT hrDac = S_OK;</td>
      </tr>
      <tr>
        <td id="L7084" data-line-number="7084"></td>
        <td id="LC7084">                EX_TRY</td>
      </tr>
      <tr>
        <td id="L7085" data-line-number="7085"></td>
        <td id="LC7085">                {</td>
      </tr>
      <tr>
        <td id="L7086" data-line-number="7086"></td>
        <td id="LC7086">                    <span><span>//</span> We should be able to double check w/ DAC that this really is outside of the runtime.</span></td>
      </tr>
      <tr>
        <td id="L7087" data-line-number="7087"></td>
        <td id="LC7087">                    IDacDbiInterface::AddressType addrType = <span>GetDAC</span>()-&gt;<span>GetAddressType</span>(address);</td>
      </tr>
      <tr>
        <td id="L7088" data-line-number="7088"></td>
        <td id="LC7088">                    <span>CONSISTENCY_CHECK_MSGF</span>(addrType == IDacDbiInterface::<span>kAddressUnrecognized</span>, (<span><span>"</span>Bad address type = %d<span>"</span></span>, addrType));</td>
      </tr>
      <tr>
        <td id="L7089" data-line-number="7089"></td>
        <td id="LC7089">                }</td>
      </tr>
      <tr>
        <td id="L7090" data-line-number="7090"></td>
        <td id="LC7090">                <span>EX_CATCH_HRESULT</span>(hrDac);</td>
      </tr>
      <tr>
        <td id="L7091" data-line-number="7091"></td>
        <td id="LC7091">                <span>CONSISTENCY_CHECK_MSGF</span>(<span>SUCCEEDED</span>(hrDac), (<span><span>"</span>DAC::GetAddressType failed, hr=0x%08x<span>"</span></span>, hrDac));</td>
      </tr>
      <tr>
        <td id="L7092" data-line-number="7092"></td>
        <td id="LC7092">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L7093" data-line-number="7093"></td>
        <td id="LC7093">            }</td>
      </tr>
      <tr>
        <td id="L7094" data-line-number="7094"></td>
        <td id="LC7094">
</td>
      </tr>
      <tr>
        <td id="L7095" data-line-number="7095"></td>
        <td id="LC7095">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L7096" data-line-number="7096"></td>
        <td id="LC7096">        }</td>
      </tr>
      <tr>
        <td id="L7097" data-line-number="7097"></td>
        <td id="LC7097">    }</td>
      </tr>
      <tr>
        <td id="L7098" data-line-number="7098"></td>
        <td id="LC7098">
</td>
      </tr>
      <tr>
        <td id="L7099" data-line-number="7099"></td>
        <td id="LC7099">    <span><span>//</span> If we didn't find a patch, its actually still possible that this breakpoint exception belongs to us. There are</span></td>
      </tr>
      <tr>
        <td id="L7100" data-line-number="7100"></td>
        <td id="LC7100">    <span><span>//</span> races with very large numbers of threads entering the Runtime through the same managed function. We will have</span></td>
      </tr>
      <tr>
        <td id="L7101" data-line-number="7101"></td>
        <td id="LC7101">    <span><span>//</span> multiple threads adding and removing ref counts to an int 3 in the code stream. Sometimes, this count will go to</span></td>
      </tr>
      <tr>
        <td id="L7102" data-line-number="7102"></td>
        <td id="LC7102">    <span><span>//</span> zero and the int 3 will be removed, then it will come back up and the int 3 will be replaced. The in-process</span></td>
      </tr>
      <tr>
        <td id="L7103" data-line-number="7103"></td>
        <td id="LC7103">    <span><span>//</span> logic takes pains to ensure that such cases are handled properly, therefore we need to perform the same check</span></td>
      </tr>
      <tr>
        <td id="L7104" data-line-number="7104"></td>
        <td id="LC7104">    <span><span>//</span> here to make the correct decision. Basically, the check is to see if there is indeed an int 3 at the exception</span></td>
      </tr>
      <tr>
        <td id="L7105" data-line-number="7105"></td>
        <td id="LC7105">    <span><span>//</span> address. If there is _not_ an int 3 there, then we've hit this race. We will lie and say a managed patch was</span></td>
      </tr>
      <tr>
        <td id="L7106" data-line-number="7106"></td>
        <td id="LC7106">    <span><span>//</span> found to cover this case. This is tracking the logic in DebuggerController::ScanForTriggers, where we call</span></td>
      </tr>
      <tr>
        <td id="L7107" data-line-number="7107"></td>
        <td id="LC7107">    <span><span>//</span> IsPatched.</span></td>
      </tr>
      <tr>
        <td id="L7108" data-line-number="7108"></td>
        <td id="LC7108">    <span>if</span> (*pfPatchFound == <span>false</span>)</td>
      </tr>
      <tr>
        <td id="L7109" data-line-number="7109"></td>
        <td id="LC7109">    {</td>
      </tr>
      <tr>
        <td id="L7110" data-line-number="7110"></td>
        <td id="LC7110">        <span><span>//</span> Read one instruction from the faulting address...</span></td>
      </tr>
      <tr>
        <td id="L7111" data-line-number="7111"></td>
        <td id="LC7111">#<span>if</span> defined(DBG_TARGET_ARM) || defined(DBG_TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L7112" data-line-number="7112"></td>
        <td id="LC7112">        PRD_TYPE TrapCheck = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L7113" data-line-number="7113"></td>
        <td id="LC7113">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L7114" data-line-number="7114"></td>
        <td id="LC7114">        BYTE TrapCheck = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L7115" data-line-number="7115"></td>
        <td id="LC7115">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L7116" data-line-number="7116"></td>
        <td id="LC7116">
</td>
      </tr>
      <tr>
        <td id="L7117" data-line-number="7117"></td>
        <td id="LC7117">        HRESULT hr2 = <span>SafeReadStruct</span>(address, &amp;TrapCheck);</td>
      </tr>
      <tr>
        <td id="L7118" data-line-number="7118"></td>
        <td id="LC7118">
</td>
      </tr>
      <tr>
        <td id="L7119" data-line-number="7119"></td>
        <td id="LC7119">        <span>if</span> (<span>SUCCEEDED</span>(hr2) &amp;&amp; (TrapCheck != CORDbg_BREAK_INSTRUCTION))</td>
      </tr>
      <tr>
        <td id="L7120" data-line-number="7120"></td>
        <td id="LC7120">        {</td>
      </tr>
      <tr>
        <td id="L7121" data-line-number="7121"></td>
        <td id="LC7121">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::FPBA: patchFound=true based on odd missing int 3 case.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L7122" data-line-number="7122"></td>
        <td id="LC7122">
</td>
      </tr>
      <tr>
        <td id="L7123" data-line-number="7123"></td>
        <td id="LC7123">            *pfPatchFound = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7124" data-line-number="7124"></td>
        <td id="LC7124">        }</td>
      </tr>
      <tr>
        <td id="L7125" data-line-number="7125"></td>
        <td id="LC7125">    }</td>
      </tr>
      <tr>
        <td id="L7126" data-line-number="7126"></td>
        <td id="LC7126">
</td>
      </tr>
      <tr>
        <td id="L7127" data-line-number="7127"></td>
        <td id="LC7127">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::FPBA: patchFound=%d, patchIsUnmanaged=%d<span>\n</span><span>"</span></span>, *pfPatchFound, *pfPatchIsUnmanaged));</td>
      </tr>
      <tr>
        <td id="L7128" data-line-number="7128"></td>
        <td id="LC7128">
</td>
      </tr>
      <tr>
        <td id="L7129" data-line-number="7129"></td>
        <td id="LC7129">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L7130" data-line-number="7130"></td>
        <td id="LC7130">}</td>
      </tr>
      <tr>
        <td id="L7131" data-line-number="7131"></td>
        <td id="LC7131">
</td>
      </tr>
      <tr>
        <td id="L7132" data-line-number="7132"></td>
        <td id="LC7132">HRESULT <span>CordbProcess::WriteMemory</span>(CORDB_ADDRESS address, DWORD size,</td>
      </tr>
      <tr>
        <td id="L7133" data-line-number="7133"></td>
        <td id="LC7133">                                  BYTE buffer[], SIZE_T *written)</td>
      </tr>
      <tr>
        <td id="L7134" data-line-number="7134"></td>
        <td id="LC7134">{</td>
      </tr>
      <tr>
        <td id="L7135" data-line-number="7135"></td>
        <td id="LC7135">    <span>PUBLIC_REENTRANT_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7136" data-line-number="7136"></td>
        <td id="LC7136">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7137" data-line-number="7137"></td>
        <td id="LC7137">    <span>CORDBRequireProcessStateOK</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7138" data-line-number="7138"></td>
        <td id="LC7138">    <span>_ASSERTE</span>(m_runtimeOffsetsInitialized);</td>
      </tr>
      <tr>
        <td id="L7139" data-line-number="7139"></td>
        <td id="LC7139">
</td>
      </tr>
      <tr>
        <td id="L7140" data-line-number="7140"></td>
        <td id="LC7140">
</td>
      </tr>
      <tr>
        <td id="L7141" data-line-number="7141"></td>
        <td id="LC7141">    <span>if</span> (size == <span>0</span> || address == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7142" data-line-number="7142"></td>
        <td id="LC7142">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L7143" data-line-number="7143"></td>
        <td id="LC7143">
</td>
      </tr>
      <tr>
        <td id="L7144" data-line-number="7144"></td>
        <td id="LC7144">    <span>VALIDATE_POINTER_TO_OBJECT_ARRAY</span>(buffer, BYTE, size, <span>true</span>, <span>true</span>);</td>
      </tr>
      <tr>
        <td id="L7145" data-line-number="7145"></td>
        <td id="LC7145">    <span>VALIDATE_POINTER_TO_OBJECT</span>(written, SIZE_T *);</td>
      </tr>
      <tr>
        <td id="L7146" data-line-number="7146"></td>
        <td id="LC7146">
</td>
      </tr>
      <tr>
        <td id="L7147" data-line-number="7147"></td>
        <td id="LC7147">
</td>
      </tr>
      <tr>
        <td id="L7148" data-line-number="7148"></td>
        <td id="LC7148">#<span>if</span> defined(_DEBUG) &amp;&amp; defined(FEATURE_INTEROP_DEBUGGING)</td>
      </tr>
      <tr>
        <td id="L7149" data-line-number="7149"></td>
        <td id="LC7149">    <span><span>//</span> Shouldn't be using this to write int3. Use UM BP API instead.</span></td>
      </tr>
      <tr>
        <td id="L7150" data-line-number="7150"></td>
        <td id="LC7150">    <span><span>//</span> This is technically legal (what if the '0xcc' is data or something), so we can't fail in retail.</span></td>
      </tr>
      <tr>
        <td id="L7151" data-line-number="7151"></td>
        <td id="LC7151">    <span><span>//</span> But we can add this debug-only check to help VS migrate to the new API.</span></td>
      </tr>
      <tr>
        <td id="L7152" data-line-number="7152"></td>
        <td id="LC7152">    <span>static</span> ConfigDWORD configCheckInt3;</td>
      </tr>
      <tr>
        <td id="L7153" data-line-number="7153"></td>
        <td id="LC7153">    DWORD <span>fCheckInt3</span> = configCheckInt3.<span>val</span>(CLRConfig::INTERNAL_DbgCheckInt3);</td>
      </tr>
      <tr>
        <td id="L7154" data-line-number="7154"></td>
        <td id="LC7154">    <span>if</span> (<span>fCheckInt3</span>)</td>
      </tr>
      <tr>
        <td id="L7155" data-line-number="7155"></td>
        <td id="LC7155">    {</td>
      </tr>
      <tr>
        <td id="L7156" data-line-number="7156"></td>
        <td id="LC7156">#<span>if</span> defined(DBG_TARGET_X86) || defined(DBG_TARGET_AMD64)</td>
      </tr>
      <tr>
        <td id="L7157" data-line-number="7157"></td>
        <td id="LC7157">        <span>if</span> (size == <span>1</span> &amp;&amp; buffer[<span>0</span>] == <span>0xCC</span>)</td>
      </tr>
      <tr>
        <td id="L7158" data-line-number="7158"></td>
        <td id="LC7158">        {</td>
      </tr>
      <tr>
        <td id="L7159" data-line-number="7159"></td>
        <td id="LC7159">            <span>CONSISTENCY_CHECK_MSGF</span>(<span>false</span>,</td>
      </tr>
      <tr>
        <td id="L7160" data-line-number="7160"></td>
        <td id="LC7160">                (<span><span>"</span>You're using ICorDebugProcess::WriteMemory() to write an 'int3' (1 byte 0xCC) at address 0x%p.<span>\n</span><span>"</span></span></td>
      </tr>
      <tr>
        <td id="L7161" data-line-number="7161"></td>
        <td id="LC7161">                <span><span>"</span>If you're trying to set a breakpoint, you should be using ICorDebugProcess::SetUnmanagedBreakpoint() instead.<span>\n</span><span>"</span></span></td>
      </tr>
      <tr>
        <td id="L7162" data-line-number="7162"></td>
        <td id="LC7162">                <span><span>"</span>(This assert is only enabled under the COM+ knob DbgCheckInt3.)<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7163" data-line-number="7163"></td>
        <td id="LC7163">                <span>CORDB_ADDRESS_TO_PTR</span>(address)));</td>
      </tr>
      <tr>
        <td id="L7164" data-line-number="7164"></td>
        <td id="LC7164">        }</td>
      </tr>
      <tr>
        <td id="L7165" data-line-number="7165"></td>
        <td id="LC7165">#<span>endif</span> <span><span>//</span> DBG_TARGET_X86 || DBG_TARGET_AMD64</span></td>
      </tr>
      <tr>
        <td id="L7166" data-line-number="7166"></td>
        <td id="LC7166">
</td>
      </tr>
      <tr>
        <td id="L7167" data-line-number="7167"></td>
        <td id="LC7167">        <span><span>//</span> check if we're replaced an opcode.</span></td>
      </tr>
      <tr>
        <td id="L7168" data-line-number="7168"></td>
        <td id="LC7168">        <span>if</span> (size == <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L7169" data-line-number="7169"></td>
        <td id="LC7169">        {</td>
      </tr>
      <tr>
        <td id="L7170" data-line-number="7170"></td>
        <td id="LC7170">            RSLockHolder <span>ch</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L7171" data-line-number="7171"></td>
        <td id="LC7171">
</td>
      </tr>
      <tr>
        <td id="L7172" data-line-number="7172"></td>
        <td id="LC7172">            NativePatch * p = <span>GetNativePatch</span>(<span>CORDB_ADDRESS_TO_PTR</span>(address));</td>
      </tr>
      <tr>
        <td id="L7173" data-line-number="7173"></td>
        <td id="LC7173">            <span>if</span> (p != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7174" data-line-number="7174"></td>
        <td id="LC7174">            {</td>
      </tr>
      <tr>
        <td id="L7175" data-line-number="7175"></td>
        <td id="LC7175">            <span>CONSISTENCY_CHECK_MSGF</span>(<span>false</span>,</td>
      </tr>
      <tr>
        <td id="L7176" data-line-number="7176"></td>
        <td id="LC7176">                (<span><span>"</span>You're using ICorDebugProcess::WriteMemory() to write an 'opcode (0x%x)' at address 0x%p.<span>\n</span><span>"</span></span></td>
      </tr>
      <tr>
        <td id="L7177" data-line-number="7177"></td>
        <td id="LC7177">                <span><span>"</span>There's already a native patch at that address from ICorDebugProcess::SetUnmanagedBreakpoint().<span>\n</span><span>"</span></span></td>
      </tr>
      <tr>
        <td id="L7178" data-line-number="7178"></td>
        <td id="LC7178">                <span><span>"</span>If you're trying to remove the breakpoint, use ICDProcess::ClearUnmanagedBreakpoint() instead.<span>\n</span><span>"</span></span></td>
      </tr>
      <tr>
        <td id="L7179" data-line-number="7179"></td>
        <td id="LC7179">                <span><span>"</span>(This assert is only enabled under the COM+ knob DbgCheckInt3.)<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7180" data-line-number="7180"></td>
        <td id="LC7180">                (DWORD) (buffer[<span>0</span>]), <span>CORDB_ADDRESS_TO_PTR</span>(address)));</td>
      </tr>
      <tr>
        <td id="L7181" data-line-number="7181"></td>
        <td id="LC7181">            }</td>
      </tr>
      <tr>
        <td id="L7182" data-line-number="7182"></td>
        <td id="LC7182">        }</td>
      </tr>
      <tr>
        <td id="L7183" data-line-number="7183"></td>
        <td id="LC7183">    }</td>
      </tr>
      <tr>
        <td id="L7184" data-line-number="7184"></td>
        <td id="LC7184">#<span>endif</span> <span><span>//</span> _DEBUG &amp;&amp; FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L7185" data-line-number="7185"></td>
        <td id="LC7185">
</td>
      </tr>
      <tr>
        <td id="L7186" data-line-number="7186"></td>
        <td id="LC7186">
</td>
      </tr>
      <tr>
        <td id="L7187" data-line-number="7187"></td>
        <td id="LC7187">    *written = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L7188" data-line-number="7188"></td>
        <td id="LC7188">
</td>
      </tr>
      <tr>
        <td id="L7189" data-line-number="7189"></td>
        <td id="LC7189">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L7190" data-line-number="7190"></td>
        <td id="LC7190">    HRESULT hrSaved = hr; <span><span>//</span> this will hold the 'real' hresult in case of a</span></td>
      </tr>
      <tr>
        <td id="L7191" data-line-number="7191"></td>
        <td id="LC7191">                          <span><span>//</span> partially completed operation</span></td>
      </tr>
      <tr>
        <td id="L7192" data-line-number="7192"></td>
        <td id="LC7192">    HRESULT hrPartialCopy = <span>HRESULT_FROM_WIN32</span>(ERROR_PARTIAL_COPY);</td>
      </tr>
      <tr>
        <td id="L7193" data-line-number="7193"></td>
        <td id="LC7193">
</td>
      </tr>
      <tr>
        <td id="L7194" data-line-number="7194"></td>
        <td id="LC7194">    BOOL bUpdateOriginalPatchTable = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L7195" data-line-number="7195"></td>
        <td id="LC7195">    BYTE *bufferCopy = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L7196" data-line-number="7196"></td>
        <td id="LC7196">
</td>
      </tr>
      <tr>
        <td id="L7197" data-line-number="7197"></td>
        <td id="LC7197">    <span><span>//</span> Only update the patch table if the managed state of the process</span></td>
      </tr>
      <tr>
        <td id="L7198" data-line-number="7198"></td>
        <td id="LC7198">    <span><span>//</span> is initialized.</span></td>
      </tr>
      <tr>
        <td id="L7199" data-line-number="7199"></td>
        <td id="LC7199">    <span>if</span> (m_initialized)</td>
      </tr>
      <tr>
        <td id="L7200" data-line-number="7200"></td>
        <td id="LC7200">    {</td>
      </tr>
      <tr>
        <td id="L7201" data-line-number="7201"></td>
        <td id="LC7201">        RSLockHolder <span>ch</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L7202" data-line-number="7202"></td>
        <td id="LC7202">
</td>
      </tr>
      <tr>
        <td id="L7203" data-line-number="7203"></td>
        <td id="LC7203">        <span>if</span> (m_pPatchTable == <span>NULL</span> )</td>
      </tr>
      <tr>
        <td id="L7204" data-line-number="7204"></td>
        <td id="LC7204">        {</td>
      </tr>
      <tr>
        <td id="L7205" data-line-number="7205"></td>
        <td id="LC7205">            <span>if</span> (!<span>SUCCEEDED</span>( hr = <span>RefreshPatchTable</span>() ) )</td>
      </tr>
      <tr>
        <td id="L7206" data-line-number="7206"></td>
        <td id="LC7206">            {</td>
      </tr>
      <tr>
        <td id="L7207" data-line-number="7207"></td>
        <td id="LC7207">                <span>goto</span> LExit;</td>
      </tr>
      <tr>
        <td id="L7208" data-line-number="7208"></td>
        <td id="LC7208">            }</td>
      </tr>
      <tr>
        <td id="L7209" data-line-number="7209"></td>
        <td id="LC7209">        }</td>
      </tr>
      <tr>
        <td id="L7210" data-line-number="7210"></td>
        <td id="LC7210">
</td>
      </tr>
      <tr>
        <td id="L7211" data-line-number="7211"></td>
        <td id="LC7211">        <span>if</span> ( !<span>SUCCEEDED</span>( hr = <span>AdjustBuffer</span>( address,</td>
      </tr>
      <tr>
        <td id="L7212" data-line-number="7212"></td>
        <td id="LC7212">                                            size,</td>
      </tr>
      <tr>
        <td id="L7213" data-line-number="7213"></td>
        <td id="LC7213">                                            buffer,</td>
      </tr>
      <tr>
        <td id="L7214" data-line-number="7214"></td>
        <td id="LC7214">                                            &amp;bufferCopy,</td>
      </tr>
      <tr>
        <td id="L7215" data-line-number="7215"></td>
        <td id="LC7215">                                            AB_WRITE,</td>
      </tr>
      <tr>
        <td id="L7216" data-line-number="7216"></td>
        <td id="LC7216">                                            &amp;bUpdateOriginalPatchTable)))</td>
      </tr>
      <tr>
        <td id="L7217" data-line-number="7217"></td>
        <td id="LC7217">        {</td>
      </tr>
      <tr>
        <td id="L7218" data-line-number="7218"></td>
        <td id="LC7218">            <span>goto</span> LExit;</td>
      </tr>
      <tr>
        <td id="L7219" data-line-number="7219"></td>
        <td id="LC7219">        }</td>
      </tr>
      <tr>
        <td id="L7220" data-line-number="7220"></td>
        <td id="LC7220">    }</td>
      </tr>
      <tr>
        <td id="L7221" data-line-number="7221"></td>
        <td id="LC7221">
</td>
      </tr>
      <tr>
        <td id="L7222" data-line-number="7222"></td>
        <td id="LC7222">    <span><span>//</span>conveniently enough, SafeWriteBuffer will throw if it can't complete the entire operation</span></td>
      </tr>
      <tr>
        <td id="L7223" data-line-number="7223"></td>
        <td id="LC7223">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L7224" data-line-number="7224"></td>
        <td id="LC7224">    {</td>
      </tr>
      <tr>
        <td id="L7225" data-line-number="7225"></td>
        <td id="LC7225">        TargetBuffer <span>tb</span>(address, size);</td>
      </tr>
      <tr>
        <td id="L7226" data-line-number="7226"></td>
        <td id="LC7226">        <span>SafeWriteBuffer</span>(tb, buffer); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L7227" data-line-number="7227"></td>
        <td id="LC7227">        *written = tb.<span>cbSize</span>; <span><span>//</span> DT's Write does everything or fails.</span></td>
      </tr>
      <tr>
        <td id="L7228" data-line-number="7228"></td>
        <td id="LC7228">    }</td>
      </tr>
      <tr>
        <td id="L7229" data-line-number="7229"></td>
        <td id="LC7229">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L7230" data-line-number="7230"></td>
        <td id="LC7230">
</td>
      </tr>
      <tr>
        <td id="L7231" data-line-number="7231"></td>
        <td id="LC7231">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L7232" data-line-number="7232"></td>
        <td id="LC7232">    {</td>
      </tr>
      <tr>
        <td id="L7233" data-line-number="7233"></td>
        <td id="LC7233">        <span>if</span>(hr != hrPartialCopy)</td>
      </tr>
      <tr>
        <td id="L7234" data-line-number="7234"></td>
        <td id="LC7234">            <span>goto</span> LExit;</td>
      </tr>
      <tr>
        <td id="L7235" data-line-number="7235"></td>
        <td id="LC7235">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L7236" data-line-number="7236"></td>
        <td id="LC7236">            hrSaved = hr;</td>
      </tr>
      <tr>
        <td id="L7237" data-line-number="7237"></td>
        <td id="LC7237">    }</td>
      </tr>
      <tr>
        <td id="L7238" data-line-number="7238"></td>
        <td id="LC7238">
</td>
      </tr>
      <tr>
        <td id="L7239" data-line-number="7239"></td>
        <td id="LC7239">
</td>
      </tr>
      <tr>
        <td id="L7240" data-line-number="7240"></td>
        <td id="LC7240">    <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>CP::WM: wrote %d bytes at 0x%08x, first byte is 0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7241" data-line-number="7241"></td>
        <td id="LC7241">         *written, (DWORD)address, buffer[<span>0</span>]));</td>
      </tr>
      <tr>
        <td id="L7242" data-line-number="7242"></td>
        <td id="LC7242">
</td>
      </tr>
      <tr>
        <td id="L7243" data-line-number="7243"></td>
        <td id="LC7243">    <span>if</span> (bUpdateOriginalPatchTable == <span>TRUE</span> )</td>
      </tr>
      <tr>
        <td id="L7244" data-line-number="7244"></td>
        <td id="LC7244">    {</td>
      </tr>
      <tr>
        <td id="L7245" data-line-number="7245"></td>
        <td id="LC7245">        {</td>
      </tr>
      <tr>
        <td id="L7246" data-line-number="7246"></td>
        <td id="LC7246">            RSLockHolder <span>ch</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L7247" data-line-number="7247"></td>
        <td id="LC7247">
</td>
      </tr>
      <tr>
        <td id="L7248" data-line-number="7248"></td>
        <td id="LC7248">            <span><span>//</span>don't tweak patch table for stuff that isn't written to LeftSide</span></td>
      </tr>
      <tr>
        <td id="L7249" data-line-number="7249"></td>
        <td id="LC7249">            <span>CommitBufferAdjustments</span>(address, address + *written);</td>
      </tr>
      <tr>
        <td id="L7250" data-line-number="7250"></td>
        <td id="LC7250">        }</td>
      </tr>
      <tr>
        <td id="L7251" data-line-number="7251"></td>
        <td id="LC7251">
</td>
      </tr>
      <tr>
        <td id="L7252" data-line-number="7252"></td>
        <td id="LC7252">        <span><span>//</span> The only way this should be able to fail is if</span></td>
      </tr>
      <tr>
        <td id="L7253" data-line-number="7253"></td>
        <td id="LC7253">        <span><span>//</span>someone else fiddles with the memory protections on the</span></td>
      </tr>
      <tr>
        <td id="L7254" data-line-number="7254"></td>
        <td id="LC7254">        <span><span>//</span>left side while it's frozen</span></td>
      </tr>
      <tr>
        <td id="L7255" data-line-number="7255"></td>
        <td id="LC7255">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L7256" data-line-number="7256"></td>
        <td id="LC7256">        {</td>
      </tr>
      <tr>
        <td id="L7257" data-line-number="7257"></td>
        <td id="LC7257">            TargetBuffer <span>tb</span>(m_rgData, (ULONG) (m_cPatch*m_runtimeOffsets.<span>m_cbPatch</span>));</td>
      </tr>
      <tr>
        <td id="L7258" data-line-number="7258"></td>
        <td id="LC7258">            <span>SafeWriteBuffer</span>(tb, m_pPatchTable);</td>
      </tr>
      <tr>
        <td id="L7259" data-line-number="7259"></td>
        <td id="LC7259">        }</td>
      </tr>
      <tr>
        <td id="L7260" data-line-number="7260"></td>
        <td id="LC7260">        <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L7261" data-line-number="7261"></td>
        <td id="LC7261">        <span>SIMPLIFYING_ASSUMPTION_SUCCEEDED</span>(hr);</td>
      </tr>
      <tr>
        <td id="L7262" data-line-number="7262"></td>
        <td id="LC7262">    }</td>
      </tr>
      <tr>
        <td id="L7263" data-line-number="7263"></td>
        <td id="LC7263">
</td>
      </tr>
      <tr>
        <td id="L7264" data-line-number="7264"></td>
        <td id="LC7264">    <span><span>//</span> Since we may have</span></td>
      </tr>
      <tr>
        <td id="L7265" data-line-number="7265"></td>
        <td id="LC7265">    <span><span>//</span> overwritten anything (objects, code, etc), we should mark</span></td>
      </tr>
      <tr>
        <td id="L7266" data-line-number="7266"></td>
        <td id="LC7266">    <span><span>//</span> everything as needing to be re-cached.</span></td>
      </tr>
      <tr>
        <td id="L7267" data-line-number="7267"></td>
        <td id="LC7267">    m_continueCounter++;</td>
      </tr>
      <tr>
        <td id="L7268" data-line-number="7268"></td>
        <td id="LC7268">
</td>
      </tr>
      <tr>
        <td id="L7269" data-line-number="7269"></td>
        <td id="LC7269"> LExit:</td>
      </tr>
      <tr>
        <td id="L7270" data-line-number="7270"></td>
        <td id="LC7270">    <span>if</span> (m_initialized)</td>
      </tr>
      <tr>
        <td id="L7271" data-line-number="7271"></td>
        <td id="LC7271">    {</td>
      </tr>
      <tr>
        <td id="L7272" data-line-number="7272"></td>
        <td id="LC7272">        RSLockHolder <span>ch</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L7273" data-line-number="7273"></td>
        <td id="LC7273">        <span>ClearBufferAdjustments</span>( );</td>
      </tr>
      <tr>
        <td id="L7274" data-line-number="7274"></td>
        <td id="LC7274">    }</td>
      </tr>
      <tr>
        <td id="L7275" data-line-number="7275"></td>
        <td id="LC7275">
</td>
      </tr>
      <tr>
        <td id="L7276" data-line-number="7276"></td>
        <td id="LC7276">    <span><span>//</span>we messed up our local copy, so get a clean copy the next time</span></td>
      </tr>
      <tr>
        <td id="L7277" data-line-number="7277"></td>
        <td id="LC7277">    <span><span>//</span>we need it</span></td>
      </tr>
      <tr>
        <td id="L7278" data-line-number="7278"></td>
        <td id="LC7278">    <span>if</span> (bUpdateOriginalPatchTable==<span>TRUE</span>)</td>
      </tr>
      <tr>
        <td id="L7279" data-line-number="7279"></td>
        <td id="LC7279">    {</td>
      </tr>
      <tr>
        <td id="L7280" data-line-number="7280"></td>
        <td id="LC7280">        <span>if</span> (bufferCopy != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7281" data-line-number="7281"></td>
        <td id="LC7281">        {</td>
      </tr>
      <tr>
        <td id="L7282" data-line-number="7282"></td>
        <td id="LC7282">            <span>memmove</span>(buffer, bufferCopy, size);</td>
      </tr>
      <tr>
        <td id="L7283" data-line-number="7283"></td>
        <td id="LC7283">            <span>delete []</span> bufferCopy;</td>
      </tr>
      <tr>
        <td id="L7284" data-line-number="7284"></td>
        <td id="LC7284">        }</td>
      </tr>
      <tr>
        <td id="L7285" data-line-number="7285"></td>
        <td id="LC7285">    }</td>
      </tr>
      <tr>
        <td id="L7286" data-line-number="7286"></td>
        <td id="LC7286">
</td>
      </tr>
      <tr>
        <td id="L7287" data-line-number="7287"></td>
        <td id="LC7287">    <span>if</span> (<span>FAILED</span>( hr ))</td>
      </tr>
      <tr>
        <td id="L7288" data-line-number="7288"></td>
        <td id="LC7288">    {</td>
      </tr>
      <tr>
        <td id="L7289" data-line-number="7289"></td>
        <td id="LC7289">        <span><span>//</span>we messed up our local copy, so get a clean copy the next time</span></td>
      </tr>
      <tr>
        <td id="L7290" data-line-number="7290"></td>
        <td id="LC7290">        <span><span>//</span>we need it</span></td>
      </tr>
      <tr>
        <td id="L7291" data-line-number="7291"></td>
        <td id="LC7291">        <span>if</span> (bUpdateOriginalPatchTable==<span>TRUE</span>)</td>
      </tr>
      <tr>
        <td id="L7292" data-line-number="7292"></td>
        <td id="LC7292">        {</td>
      </tr>
      <tr>
        <td id="L7293" data-line-number="7293"></td>
        <td id="LC7293">            RSLockHolder <span>ch</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L7294" data-line-number="7294"></td>
        <td id="LC7294">            <span>ClearPatchTable</span>();</td>
      </tr>
      <tr>
        <td id="L7295" data-line-number="7295"></td>
        <td id="LC7295">        }</td>
      </tr>
      <tr>
        <td id="L7296" data-line-number="7296"></td>
        <td id="LC7296">    }</td>
      </tr>
      <tr>
        <td id="L7297" data-line-number="7297"></td>
        <td id="LC7297">    <span>else</span> <span>if</span>( <span>FAILED</span>(hrSaved) )</td>
      </tr>
      <tr>
        <td id="L7298" data-line-number="7298"></td>
        <td id="LC7298">    {</td>
      </tr>
      <tr>
        <td id="L7299" data-line-number="7299"></td>
        <td id="LC7299">        hr = hrSaved;</td>
      </tr>
      <tr>
        <td id="L7300" data-line-number="7300"></td>
        <td id="LC7300">    }</td>
      </tr>
      <tr>
        <td id="L7301" data-line-number="7301"></td>
        <td id="LC7301">
</td>
      </tr>
      <tr>
        <td id="L7302" data-line-number="7302"></td>
        <td id="LC7302">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L7303" data-line-number="7303"></td>
        <td id="LC7303">}</td>
      </tr>
      <tr>
        <td id="L7304" data-line-number="7304"></td>
        <td id="LC7304">
</td>
      </tr>
      <tr>
        <td id="L7305" data-line-number="7305"></td>
        <td id="LC7305">HRESULT <span>CordbProcess::ClearCurrentException</span>(DWORD threadID)</td>
      </tr>
      <tr>
        <td id="L7306" data-line-number="7306"></td>
        <td id="LC7306">{</td>
      </tr>
      <tr>
        <td id="L7307" data-line-number="7307"></td>
        <td id="LC7307">#<span>ifndef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L7308" data-line-number="7308"></td>
        <td id="LC7308">    <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L7309" data-line-number="7309"></td>
        <td id="LC7309">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L7310" data-line-number="7310"></td>
        <td id="LC7310">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7311" data-line-number="7311"></td>
        <td id="LC7311">
</td>
      </tr>
      <tr>
        <td id="L7312" data-line-number="7312"></td>
        <td id="LC7312">    RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L7313" data-line-number="7313"></td>
        <td id="LC7313">
</td>
      </tr>
      <tr>
        <td id="L7314" data-line-number="7314"></td>
        <td id="LC7314">    <span><span>//</span> There's something wrong if you're calling this an there are no queued unmanaged events.</span></td>
      </tr>
      <tr>
        <td id="L7315" data-line-number="7315"></td>
        <td id="LC7315">    <span>if</span> ((m_unmanagedEventQueue == <span>NULL</span>) &amp;&amp; (m_outOfBandEventQueue == <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L7316" data-line-number="7316"></td>
        <td id="LC7316">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L7317" data-line-number="7317"></td>
        <td id="LC7317">
</td>
      </tr>
      <tr>
        <td id="L7318" data-line-number="7318"></td>
        <td id="LC7318">    <span><span>//</span> Grab the unmanaged thread object.</span></td>
      </tr>
      <tr>
        <td id="L7319" data-line-number="7319"></td>
        <td id="LC7319">    CordbUnmanagedThread *pUThread = <span>GetUnmanagedThread</span>(threadID);</td>
      </tr>
      <tr>
        <td id="L7320" data-line-number="7320"></td>
        <td id="LC7320">
</td>
      </tr>
      <tr>
        <td id="L7321" data-line-number="7321"></td>
        <td id="LC7321">    <span>if</span> (pUThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7322" data-line-number="7322"></td>
        <td id="LC7322">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L7323" data-line-number="7323"></td>
        <td id="LC7323">
</td>
      </tr>
      <tr>
        <td id="L7324" data-line-number="7324"></td>
        <td id="LC7324">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::CCE: tid=0x%x<span>\n</span><span>"</span></span>, threadID));</td>
      </tr>
      <tr>
        <td id="L7325" data-line-number="7325"></td>
        <td id="LC7325">
</td>
      </tr>
      <tr>
        <td id="L7326" data-line-number="7326"></td>
        <td id="LC7326">    <span><span>//</span> We clear both the IB and OOB event.</span></td>
      </tr>
      <tr>
        <td id="L7327" data-line-number="7327"></td>
        <td id="LC7327">    <span>if</span> (pUThread-&gt;<span>HasIBEvent</span>() &amp;&amp; !pUThread-&gt;<span>IBEvent</span>()-&gt;<span>IsEventUserContinued</span>())</td>
      </tr>
      <tr>
        <td id="L7328" data-line-number="7328"></td>
        <td id="LC7328">    {</td>
      </tr>
      <tr>
        <td id="L7329" data-line-number="7329"></td>
        <td id="LC7329">        pUThread-&gt;<span>IBEvent</span>()-&gt;<span>SetState</span>(CUES_ExceptionCleared);</td>
      </tr>
      <tr>
        <td id="L7330" data-line-number="7330"></td>
        <td id="LC7330">    }</td>
      </tr>
      <tr>
        <td id="L7331" data-line-number="7331"></td>
        <td id="LC7331">
</td>
      </tr>
      <tr>
        <td id="L7332" data-line-number="7332"></td>
        <td id="LC7332">    <span>if</span> (pUThread-&gt;<span>HasOOBEvent</span>())</td>
      </tr>
      <tr>
        <td id="L7333" data-line-number="7333"></td>
        <td id="LC7333">    {</td>
      </tr>
      <tr>
        <td id="L7334" data-line-number="7334"></td>
        <td id="LC7334">        <span><span>//</span> must decide exception status _before_ we continue the event.</span></td>
      </tr>
      <tr>
        <td id="L7335" data-line-number="7335"></td>
        <td id="LC7335">        <span>_ASSERTE</span>(!pUThread-&gt;<span>OOBEvent</span>()-&gt;<span>IsEventContinuedUnhijacked</span>());</td>
      </tr>
      <tr>
        <td id="L7336" data-line-number="7336"></td>
        <td id="LC7336">        pUThread-&gt;<span>OOBEvent</span>()-&gt;<span>SetState</span>(CUES_ExceptionCleared);</td>
      </tr>
      <tr>
        <td id="L7337" data-line-number="7337"></td>
        <td id="LC7337">    }</td>
      </tr>
      <tr>
        <td id="L7338" data-line-number="7338"></td>
        <td id="LC7338">
</td>
      </tr>
      <tr>
        <td id="L7339" data-line-number="7339"></td>
        <td id="LC7339">    <span><span>//</span> If the thread is hijacked, then set the thread's debugger word to 0 to indicate to it that the</span></td>
      </tr>
      <tr>
        <td id="L7340" data-line-number="7340"></td>
        <td id="LC7340">    <span><span>//</span> exception has been cleared.</span></td>
      </tr>
      <tr>
        <td id="L7341" data-line-number="7341"></td>
        <td id="LC7341">    <span>if</span> (pUThread-&gt;<span>IsGenericHijacked</span>())</td>
      </tr>
      <tr>
        <td id="L7342" data-line-number="7342"></td>
        <td id="LC7342">    {</td>
      </tr>
      <tr>
        <td id="L7343" data-line-number="7343"></td>
        <td id="LC7343">        HRESULT hr = pUThread-&gt;<span>SetEEDebuggerWord</span>(<span>0</span>);</td>
      </tr>
      <tr>
        <td id="L7344" data-line-number="7344"></td>
        <td id="LC7344">        <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L7345" data-line-number="7345"></td>
        <td id="LC7345">    }</td>
      </tr>
      <tr>
        <td id="L7346" data-line-number="7346"></td>
        <td id="LC7346">
</td>
      </tr>
      <tr>
        <td id="L7347" data-line-number="7347"></td>
        <td id="LC7347">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L7348" data-line-number="7348"></td>
        <td id="LC7348">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L7349" data-line-number="7349"></td>
        <td id="LC7349">}</td>
      </tr>
      <tr>
        <td id="L7350" data-line-number="7350"></td>
        <td id="LC7350">
</td>
      </tr>
      <tr>
        <td id="L7351" data-line-number="7351"></td>
        <td id="LC7351">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L7352" data-line-number="7352"></td>
        <td id="LC7352">CordbUnmanagedThread *<span>CordbProcess::HandleUnmanagedCreateThread</span>(DWORD dwThreadId, HANDLE hThread, <span>void</span> *lpThreadLocalBase)</td>
      </tr>
      <tr>
        <td id="L7353" data-line-number="7353"></td>
        <td id="LC7353">{</td>
      </tr>
      <tr>
        <td id="L7354" data-line-number="7354"></td>
        <td id="LC7354">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7355" data-line-number="7355"></td>
        <td id="LC7355">    CordbUnmanagedThread *ut = <span>new</span> (nothrow) <span>CordbUnmanagedThread</span>(<span>this</span>, dwThreadId, hThread, lpThreadLocalBase);</td>
      </tr>
      <tr>
        <td id="L7356" data-line-number="7356"></td>
        <td id="LC7356">
</td>
      </tr>
      <tr>
        <td id="L7357" data-line-number="7357"></td>
        <td id="LC7357">    <span>if</span> (ut != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7358" data-line-number="7358"></td>
        <td id="LC7358">    {</td>
      </tr>
      <tr>
        <td id="L7359" data-line-number="7359"></td>
        <td id="LC7359">        HRESULT hr = m_unmanagedThreads.<span>AddBase</span>(ut); <span><span>//</span> InternalAddRef, release on EXIT_THREAD events.</span></td>
      </tr>
      <tr>
        <td id="L7360" data-line-number="7360"></td>
        <td id="LC7360">
</td>
      </tr>
      <tr>
        <td id="L7361" data-line-number="7361"></td>
        <td id="LC7361">        <span>if</span> (!<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L7362" data-line-number="7362"></td>
        <td id="LC7362">        {</td>
      </tr>
      <tr>
        <td id="L7363" data-line-number="7363"></td>
        <td id="LC7363">            <span>delete</span> ut;</td>
      </tr>
      <tr>
        <td id="L7364" data-line-number="7364"></td>
        <td id="LC7364">            ut = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L7365" data-line-number="7365"></td>
        <td id="LC7365">
</td>
      </tr>
      <tr>
        <td id="L7366" data-line-number="7366"></td>
        <td id="LC7366">            <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>Failed adding unmanaged thread to process!<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L7367" data-line-number="7367"></td>
        <td id="LC7367">            <span>CORDBSetUnrecoverableError</span>(<span>this</span>, hr, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L7368" data-line-number="7368"></td>
        <td id="LC7368">        }</td>
      </tr>
      <tr>
        <td id="L7369" data-line-number="7369"></td>
        <td id="LC7369">    }</td>
      </tr>
      <tr>
        <td id="L7370" data-line-number="7370"></td>
        <td id="LC7370">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7371" data-line-number="7371"></td>
        <td id="LC7371">    {</td>
      </tr>
      <tr>
        <td id="L7372" data-line-number="7372"></td>
        <td id="LC7372">        <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>New CordbThread failed!<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L7373" data-line-number="7373"></td>
        <td id="LC7373">        <span>CORDBSetUnrecoverableError</span>(<span>this</span>, E_OUTOFMEMORY, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L7374" data-line-number="7374"></td>
        <td id="LC7374">    }</td>
      </tr>
      <tr>
        <td id="L7375" data-line-number="7375"></td>
        <td id="LC7375">
</td>
      </tr>
      <tr>
        <td id="L7376" data-line-number="7376"></td>
        <td id="LC7376">    <span>return</span> ut;</td>
      </tr>
      <tr>
        <td id="L7377" data-line-number="7377"></td>
        <td id="LC7377">}</td>
      </tr>
      <tr>
        <td id="L7378" data-line-number="7378"></td>
        <td id="LC7378">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L7379" data-line-number="7379"></td>
        <td id="LC7379">
</td>
      </tr>
      <tr>
        <td id="L7380" data-line-number="7380"></td>
        <td id="LC7380">
</td>
      </tr>
      <tr>
        <td id="L7381" data-line-number="7381"></td>
        <td id="LC7381"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7382" data-line-number="7382"></td>
        <td id="LC7382"><span><span>//</span> Initializes the DAC</span></td>
      </tr>
      <tr>
        <td id="L7383" data-line-number="7383"></td>
        <td id="LC7383"><span><span>//</span> Arguments: none--initializes the DAC for this CordbProcess instance</span></td>
      </tr>
      <tr>
        <td id="L7384" data-line-number="7384"></td>
        <td id="LC7384"><span><span>//</span> Note: Throws on error</span></td>
      </tr>
      <tr>
        <td id="L7385" data-line-number="7385"></td>
        <td id="LC7385"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7386" data-line-number="7386"></td>
        <td id="LC7386"><span>void</span> <span>CordbProcess::InitDac</span>()</td>
      </tr>
      <tr>
        <td id="L7387" data-line-number="7387"></td>
        <td id="LC7387">{</td>
      </tr>
      <tr>
        <td id="L7388" data-line-number="7388"></td>
        <td id="LC7388">    <span><span>//</span> Go-Go DAC power!!</span></td>
      </tr>
      <tr>
        <td id="L7389" data-line-number="7389"></td>
        <td id="LC7389">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L7390" data-line-number="7390"></td>
        <td id="LC7390">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L7391" data-line-number="7391"></td>
        <td id="LC7391">    {</td>
      </tr>
      <tr>
        <td id="L7392" data-line-number="7392"></td>
        <td id="LC7392">        <span>InitializeDac</span>();</td>
      </tr>
      <tr>
        <td id="L7393" data-line-number="7393"></td>
        <td id="LC7393">    }</td>
      </tr>
      <tr>
        <td id="L7394" data-line-number="7394"></td>
        <td id="LC7394">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L7395" data-line-number="7395"></td>
        <td id="LC7395">
</td>
      </tr>
      <tr>
        <td id="L7396" data-line-number="7396"></td>
        <td id="LC7396">    <span><span>//</span> We Need DAC to debug for both Managed &amp; Interop.</span></td>
      </tr>
      <tr>
        <td id="L7397" data-line-number="7397"></td>
        <td id="LC7397">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L7398" data-line-number="7398"></td>
        <td id="LC7398">    {</td>
      </tr>
      <tr>
        <td id="L7399" data-line-number="7399"></td>
        <td id="LC7399">        <span><span>//</span> We assert here b/c we're trying to be friendly. Most likely, the cause is either:</span></td>
      </tr>
      <tr>
        <td id="L7400" data-line-number="7400"></td>
        <td id="LC7400">        <span><span>//</span> - a bad installation</span></td>
      </tr>
      <tr>
        <td id="L7401" data-line-number="7401"></td>
        <td id="LC7401">        <span><span>//</span> - a CLR dev built mscorwks but didn't build DAC.</span></td>
      </tr>
      <tr>
        <td id="L7402" data-line-number="7402"></td>
        <td id="LC7402">        <span>SIMPLIFYING_ASSUMPTION_MSGF</span>(<span>false</span>, (<span><span>"</span>Failed to load DAC while for debugging. hr=0x%08x<span>"</span></span>, hr));</td>
      </tr>
      <tr>
        <td id="L7403" data-line-number="7403"></td>
        <td id="LC7403">        <span>ThrowHR</span>(hr);</td>
      </tr>
      <tr>
        <td id="L7404" data-line-number="7404"></td>
        <td id="LC7404">    }</td>
      </tr>
      <tr>
        <td id="L7405" data-line-number="7405"></td>
        <td id="LC7405">} <span><span>//</span>CordbProcess::InitDac</span></td>
      </tr>
      <tr>
        <td id="L7406" data-line-number="7406"></td>
        <td id="LC7406">
</td>
      </tr>
      <tr>
        <td id="L7407" data-line-number="7407"></td>
        <td id="LC7407"><span><span>//</span> Update the entire RS copy of the debugger control block by reading the LS copy. The RS copy is treated as</span></td>
      </tr>
      <tr>
        <td id="L7408" data-line-number="7408"></td>
        <td id="LC7408"><span><span>//</span> a throw-away temporary buffer, rather than a true cache. That is, we make no assumptions about the</span></td>
      </tr>
      <tr>
        <td id="L7409" data-line-number="7409"></td>
        <td id="LC7409"><span><span>//</span> validity of the information over time. Thus, before using any of the values, we need to update it. We</span></td>
      </tr>
      <tr>
        <td id="L7410" data-line-number="7410"></td>
        <td id="LC7410"><span><span>//</span> update everything for simplicity; any perf hit we take by doing this instead of updating the individual</span></td>
      </tr>
      <tr>
        <td id="L7411" data-line-number="7411"></td>
        <td id="LC7411"><span><span>//</span> fields we want at any given point isn't significant, particularly if we are updating multiple fields.</span></td>
      </tr>
      <tr>
        <td id="L7412" data-line-number="7412"></td>
        <td id="LC7412">
</td>
      </tr>
      <tr>
        <td id="L7413" data-line-number="7413"></td>
        <td id="LC7413"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L7414" data-line-number="7414"></td>
        <td id="LC7414"><span><span>//</span>     none, but reads process memory from the LS debugger control block</span></td>
      </tr>
      <tr>
        <td id="L7415" data-line-number="7415"></td>
        <td id="LC7415"><span><span>//</span> Return Value: none (copies from LS DCB to RS buffer GetDCB())</span></td>
      </tr>
      <tr>
        <td id="L7416" data-line-number="7416"></td>
        <td id="LC7416"><span><span>//</span> Note: throws if SafeReadBuffer fails</span></td>
      </tr>
      <tr>
        <td id="L7417" data-line-number="7417"></td>
        <td id="LC7417"><span>void</span> <span>CordbProcess::UpdateRightSideDCB</span>()</td>
      </tr>
      <tr>
        <td id="L7418" data-line-number="7418"></td>
        <td id="LC7418">{</td>
      </tr>
      <tr>
        <td id="L7419" data-line-number="7419"></td>
        <td id="LC7419">    <span>IfFailThrow</span>(m_pEventChannel-&gt;<span>UpdateRightSideDCB</span>());</td>
      </tr>
      <tr>
        <td id="L7420" data-line-number="7420"></td>
        <td id="LC7420">} <span><span>//</span> CordbProcess::UpdateRightSideDCB</span></td>
      </tr>
      <tr>
        <td id="L7421" data-line-number="7421"></td>
        <td id="LC7421">
</td>
      </tr>
      <tr>
        <td id="L7422" data-line-number="7422"></td>
        <td id="LC7422"><span><span>//</span> Update a single field with a value stored in the RS copy of the DCB. We can't update the entire LS DCB</span></td>
      </tr>
      <tr>
        <td id="L7423" data-line-number="7423"></td>
        <td id="LC7423"><span><span>//</span> because in some cases, the LS and RS are simultaneously initializing the DCB. If we initialize a field on</span></td>
      </tr>
      <tr>
        <td id="L7424" data-line-number="7424"></td>
        <td id="LC7424"><span><span>//</span> the RS and write back the whole thing, we may overwrite something the LS has initialized in the interim.</span></td>
      </tr>
      <tr>
        <td id="L7425" data-line-number="7425"></td>
        <td id="LC7425">
</td>
      </tr>
      <tr>
        <td id="L7426" data-line-number="7426"></td>
        <td id="LC7426"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L7427" data-line-number="7427"></td>
        <td id="LC7427"><span><span>//</span>     input: rsFieldAddr - the address of the field in the RS copy of the DCB that we want to write back to</span></td>
      </tr>
      <tr>
        <td id="L7428" data-line-number="7428"></td>
        <td id="LC7428"><span><span>//</span>                          the LS DCB. We use this to compute the offset of the field from the beginning of the</span></td>
      </tr>
      <tr>
        <td id="L7429" data-line-number="7429"></td>
        <td id="LC7429"><span><span>//</span>                          DCB and then add this offset to the starting address of the LS DCB to get the LS</span></td>
      </tr>
      <tr>
        <td id="L7430" data-line-number="7430"></td>
        <td id="LC7430"><span><span>//</span>                          address of the field we are updating</span></td>
      </tr>
      <tr>
        <td id="L7431" data-line-number="7431"></td>
        <td id="LC7431"><span><span>//</span>            size        - the size of the field we're updating.</span></td>
      </tr>
      <tr>
        <td id="L7432" data-line-number="7432"></td>
        <td id="LC7432"><span><span>//</span> Return value: none</span></td>
      </tr>
      <tr>
        <td id="L7433" data-line-number="7433"></td>
        <td id="LC7433"><span><span>//</span> Note: throws if SafeWriteBuffer fails</span></td>
      </tr>
      <tr>
        <td id="L7434" data-line-number="7434"></td>
        <td id="LC7434"><span>void</span> <span>CordbProcess::UpdateLeftSideDCBField</span>(<span>void</span> * rsFieldAddr, SIZE_T size)</td>
      </tr>
      <tr>
        <td id="L7435" data-line-number="7435"></td>
        <td id="LC7435">{</td>
      </tr>
      <tr>
        <td id="L7436" data-line-number="7436"></td>
        <td id="LC7436">    <span>IfFailThrow</span>(m_pEventChannel-&gt;<span>UpdateLeftSideDCBField</span>(rsFieldAddr, size));</td>
      </tr>
      <tr>
        <td id="L7437" data-line-number="7437"></td>
        <td id="LC7437">} <span><span>//</span> CordbProcess::UpdateRightSideDCB</span></td>
      </tr>
      <tr>
        <td id="L7438" data-line-number="7438"></td>
        <td id="LC7438">
</td>
      </tr>
      <tr>
        <td id="L7439" data-line-number="7439"></td>
        <td id="LC7439">
</td>
      </tr>
      <tr>
        <td id="L7440" data-line-number="7440"></td>
        <td id="LC7440"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7441" data-line-number="7441"></td>
        <td id="LC7441"><span><span>//</span> Gets the remote address of the event block for the Target and verifies that it's valid.</span></td>
      </tr>
      <tr>
        <td id="L7442" data-line-number="7442"></td>
        <td id="LC7442"><span><span>//</span> We use this address when we need to read from or write to the debugger control block.</span></td>
      </tr>
      <tr>
        <td id="L7443" data-line-number="7443"></td>
        <td id="LC7443"><span><span>//</span> Also allocates the RS buffer used for temporary storage for information from the DCB and</span></td>
      </tr>
      <tr>
        <td id="L7444" data-line-number="7444"></td>
        <td id="LC7444"><span><span>//</span> copies the LS DCB into the RS buffer.</span></td>
      </tr>
      <tr>
        <td id="L7445" data-line-number="7445"></td>
        <td id="LC7445"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L7446" data-line-number="7446"></td>
        <td id="LC7446"><span><span>//</span>     output: pfBlockExists - true iff the LS DCB has been successfully allocated.  Note that</span></td>
      </tr>
      <tr>
        <td id="L7447" data-line-number="7447"></td>
        <td id="LC7447"><span><span>//</span>             we need this information even if the function throws, so we can't simply send it back</span></td>
      </tr>
      <tr>
        <td id="L7448" data-line-number="7448"></td>
        <td id="LC7448"><span><span>//</span>             as a return value.</span></td>
      </tr>
      <tr>
        <td id="L7449" data-line-number="7449"></td>
        <td id="LC7449"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L7450" data-line-number="7450"></td>
        <td id="LC7450"><span><span>//</span>     None, but allocates GetDCB() on success. If the LS DCB has not</span></td>
      </tr>
      <tr>
        <td id="L7451" data-line-number="7451"></td>
        <td id="LC7451"><span><span>//</span>     been successfully initialized or if this throws, GetDCB() will be NULL.</span></td>
      </tr>
      <tr>
        <td id="L7452" data-line-number="7452"></td>
        <td id="LC7452"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7453" data-line-number="7453"></td>
        <td id="LC7453"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L7454" data-line-number="7454"></td>
        <td id="LC7454"><span><span>//</span>     Throws on error</span></td>
      </tr>
      <tr>
        <td id="L7455" data-line-number="7455"></td>
        <td id="LC7455"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7456" data-line-number="7456"></td>
        <td id="LC7456"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7457" data-line-number="7457"></td>
        <td id="LC7457"><span>void</span> <span>CordbProcess::GetEventBlock</span>(BOOL * pfBlockExists)</td>
      </tr>
      <tr>
        <td id="L7458" data-line-number="7458"></td>
        <td id="LC7458">{</td>
      </tr>
      <tr>
        <td id="L7459" data-line-number="7459"></td>
        <td id="LC7459">    <span>if</span> (<span>GetDCB</span>() == <span>NULL</span>) <span><span>//</span> we only need to do this once</span></td>
      </tr>
      <tr>
        <td id="L7460" data-line-number="7460"></td>
        <td id="LC7460">    {</td>
      </tr>
      <tr>
        <td id="L7461" data-line-number="7461"></td>
        <td id="LC7461">        <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7462" data-line-number="7462"></td>
        <td id="LC7462">        <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L7463" data-line-number="7463"></td>
        <td id="LC7463">
</td>
      </tr>
      <tr>
        <td id="L7464" data-line-number="7464"></td>
        <td id="LC7464">        <span><span>//</span> This will Initialize the DAC/DBI interface.</span></td>
      </tr>
      <tr>
        <td id="L7465" data-line-number="7465"></td>
        <td id="LC7465">        BOOL <span>fDacReady</span> = <span>TryInitializeDac</span>();</td>
      </tr>
      <tr>
        <td id="L7466" data-line-number="7466"></td>
        <td id="LC7466">
</td>
      </tr>
      <tr>
        <td id="L7467" data-line-number="7467"></td>
        <td id="LC7467">        <span>if</span> (<span>fDacReady</span>)</td>
      </tr>
      <tr>
        <td id="L7468" data-line-number="7468"></td>
        <td id="LC7468">        {</td>
      </tr>
      <tr>
        <td id="L7469" data-line-number="7469"></td>
        <td id="LC7469">            <span><span>//</span> Ensure that we have a DAC interface.</span></td>
      </tr>
      <tr>
        <td id="L7470" data-line-number="7470"></td>
        <td id="LC7470">            <span>_ASSERTE</span>(m_pDacPrimitives != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7471" data-line-number="7471"></td>
        <td id="LC7471">
</td>
      </tr>
      <tr>
        <td id="L7472" data-line-number="7472"></td>
        <td id="LC7472">            <span><span>//</span> This is not technically necessary for Mac debugging.  The event channel doesn't rely on</span></td>
      </tr>
      <tr>
        <td id="L7473" data-line-number="7473"></td>
        <td id="LC7473">            <span><span>//</span> knowing the target address of the DCB on the LS.</span></td>
      </tr>
      <tr>
        <td id="L7474" data-line-number="7474"></td>
        <td id="LC7474">            CORDB_ADDRESS pLeftSideDCB = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L7475" data-line-number="7475"></td>
        <td id="LC7475">            pLeftSideDCB = (<span>GetDAC</span>()-&gt;<span>GetDebuggerControlBlockAddress</span>());</td>
      </tr>
      <tr>
        <td id="L7476" data-line-number="7476"></td>
        <td id="LC7476">            <span>if</span> (pLeftSideDCB == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7477" data-line-number="7477"></td>
        <td id="LC7477">            {</td>
      </tr>
      <tr>
        <td id="L7478" data-line-number="7478"></td>
        <td id="LC7478">                *pfBlockExists = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L7479" data-line-number="7479"></td>
        <td id="LC7479">                <span>ThrowHR</span>(CORDBG_E_DEBUGGING_NOT_POSSIBLE);</td>
      </tr>
      <tr>
        <td id="L7480" data-line-number="7480"></td>
        <td id="LC7480">            }</td>
      </tr>
      <tr>
        <td id="L7481" data-line-number="7481"></td>
        <td id="LC7481">
</td>
      </tr>
      <tr>
        <td id="L7482" data-line-number="7482"></td>
        <td id="LC7482">            <span>IfFailThrow</span>(<span>NewEventChannelForThisPlatform</span>(pLeftSideDCB,</td>
      </tr>
      <tr>
        <td id="L7483" data-line-number="7483"></td>
        <td id="LC7483">                                                       m_pMutableDataTarget,</td>
      </tr>
      <tr>
        <td id="L7484" data-line-number="7484"></td>
        <td id="LC7484">                                                       <span>GetProcessDescriptor</span>(),</td>
      </tr>
      <tr>
        <td id="L7485" data-line-number="7485"></td>
        <td id="LC7485">                                                       m_pShim-&gt;<span>GetMachineInfo</span>(),</td>
      </tr>
      <tr>
        <td id="L7486" data-line-number="7486"></td>
        <td id="LC7486">                                                       &amp;m_pEventChannel));</td>
      </tr>
      <tr>
        <td id="L7487" data-line-number="7487"></td>
        <td id="LC7487">            <span>_ASSERTE</span>(m_pEventChannel != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7488" data-line-number="7488"></td>
        <td id="LC7488">
</td>
      </tr>
      <tr>
        <td id="L7489" data-line-number="7489"></td>
        <td id="LC7489">            <span><span>//</span> copy information from left side DCB</span></td>
      </tr>
      <tr>
        <td id="L7490" data-line-number="7490"></td>
        <td id="LC7490">            <span>UpdateRightSideDCB</span>();</td>
      </tr>
      <tr>
        <td id="L7491" data-line-number="7491"></td>
        <td id="LC7491">
</td>
      </tr>
      <tr>
        <td id="L7492" data-line-number="7492"></td>
        <td id="LC7492">            <span><span>//</span> Verify that the control block is valid.</span></td>
      </tr>
      <tr>
        <td id="L7493" data-line-number="7493"></td>
        <td id="LC7493">            <span><span>//</span> This  will throw on error.</span></td>
      </tr>
      <tr>
        <td id="L7494" data-line-number="7494"></td>
        <td id="LC7494">            <span>VerifyControlBlock</span>();</td>
      </tr>
      <tr>
        <td id="L7495" data-line-number="7495"></td>
        <td id="LC7495">
</td>
      </tr>
      <tr>
        <td id="L7496" data-line-number="7496"></td>
        <td id="LC7496">            *pfBlockExists = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7497" data-line-number="7497"></td>
        <td id="LC7497">        }</td>
      </tr>
      <tr>
        <td id="L7498" data-line-number="7498"></td>
        <td id="LC7498">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L7499" data-line-number="7499"></td>
        <td id="LC7499">        {</td>
      </tr>
      <tr>
        <td id="L7500" data-line-number="7500"></td>
        <td id="LC7500">            <span><span>//</span> we can't initialize the DAC, so we can't get the block</span></td>
      </tr>
      <tr>
        <td id="L7501" data-line-number="7501"></td>
        <td id="LC7501">            *pfBlockExists = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L7502" data-line-number="7502"></td>
        <td id="LC7502">        }</td>
      </tr>
      <tr>
        <td id="L7503" data-line-number="7503"></td>
        <td id="LC7503">    }</td>
      </tr>
      <tr>
        <td id="L7504" data-line-number="7504"></td>
        <td id="LC7504">    <span>else</span> <span><span>//</span> we got the block before</span></td>
      </tr>
      <tr>
        <td id="L7505" data-line-number="7505"></td>
        <td id="LC7505">    {</td>
      </tr>
      <tr>
        <td id="L7506" data-line-number="7506"></td>
        <td id="LC7506">        *pfBlockExists = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7507" data-line-number="7507"></td>
        <td id="LC7507">    }</td>
      </tr>
      <tr>
        <td id="L7508" data-line-number="7508"></td>
        <td id="LC7508">
</td>
      </tr>
      <tr>
        <td id="L7509" data-line-number="7509"></td>
        <td id="LC7509">} <span><span>//</span> CordbProcess::GetEventBlock()</span></td>
      </tr>
      <tr>
        <td id="L7510" data-line-number="7510"></td>
        <td id="LC7510">
</td>
      </tr>
      <tr>
        <td id="L7511" data-line-number="7511"></td>
        <td id="LC7511">
</td>
      </tr>
      <tr>
        <td id="L7512" data-line-number="7512"></td>
        <td id="LC7512"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7513" data-line-number="7513"></td>
        <td id="LC7513"><span><span>//</span> Verify that the version info in the control block matches what we expect. The minimum supported protocol from the</span></td>
      </tr>
      <tr>
        <td id="L7514" data-line-number="7514"></td>
        <td id="LC7514"><span><span>//</span> Left Side must be greater or equal to the minimum required protocol of the Right Side. Note: its the Left Side's job</span></td>
      </tr>
      <tr>
        <td id="L7515" data-line-number="7515"></td>
        <td id="LC7515"><span><span>//</span> to conform to whatever protocol the Right Side requires, so long as minimum is supported.</span></td>
      </tr>
      <tr>
        <td id="L7516" data-line-number="7516"></td>
        <td id="LC7516"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7517" data-line-number="7517"></td>
        <td id="LC7517"><span>void</span> <span>CordbProcess::VerifyControlBlock</span>()</td>
      </tr>
      <tr>
        <td id="L7518" data-line-number="7518"></td>
        <td id="LC7518">{</td>
      </tr>
      <tr>
        <td id="L7519" data-line-number="7519"></td>
        <td id="LC7519">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7520" data-line-number="7520"></td>
        <td id="LC7520">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7521" data-line-number="7521"></td>
        <td id="LC7521">
</td>
      </tr>
      <tr>
        <td id="L7522" data-line-number="7522"></td>
        <td id="LC7522">    <span>if</span> (<span>GetDCB</span>()-&gt;<span>m_DCBSize</span> == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L7523" data-line-number="7523"></td>
        <td id="LC7523">    {</td>
      </tr>
      <tr>
        <td id="L7524" data-line-number="7524"></td>
        <td id="LC7524">        <span><span>//</span> the LS is still initializing the DCB</span></td>
      </tr>
      <tr>
        <td id="L7525" data-line-number="7525"></td>
        <td id="LC7525">        <span>ThrowHR</span>(CORDBG_E_DEBUGGING_NOT_POSSIBLE);</td>
      </tr>
      <tr>
        <td id="L7526" data-line-number="7526"></td>
        <td id="LC7526">    }</td>
      </tr>
      <tr>
        <td id="L7527" data-line-number="7527"></td>
        <td id="LC7527">
</td>
      </tr>
      <tr>
        <td id="L7528" data-line-number="7528"></td>
        <td id="LC7528">    <span><span>//</span> Fill in the protocol numbers for the Right Side and update the LS DCB.</span></td>
      </tr>
      <tr>
        <td id="L7529" data-line-number="7529"></td>
        <td id="LC7529">    <span>GetDCB</span>()-&gt;<span>m_rightSideProtocolCurrent</span> = CorDB_RightSideProtocolCurrent;</td>
      </tr>
      <tr>
        <td id="L7530" data-line-number="7530"></td>
        <td id="LC7530">    <span>UpdateLeftSideDCBField</span>(&amp;(<span>GetDCB</span>()-&gt;<span>m_rightSideProtocolCurrent</span>), <span>sizeof</span>(<span>GetDCB</span>()-&gt;<span>m_rightSideProtocolCurrent</span>));</td>
      </tr>
      <tr>
        <td id="L7531" data-line-number="7531"></td>
        <td id="LC7531">
</td>
      </tr>
      <tr>
        <td id="L7532" data-line-number="7532"></td>
        <td id="LC7532">    <span>GetDCB</span>()-&gt;<span>m_rightSideProtocolMinSupported</span> = CorDB_RightSideProtocolMinSupported;</td>
      </tr>
      <tr>
        <td id="L7533" data-line-number="7533"></td>
        <td id="LC7533">    <span>UpdateLeftSideDCBField</span>(&amp;(<span>GetDCB</span>()-&gt;<span>m_rightSideProtocolMinSupported</span>),</td>
      </tr>
      <tr>
        <td id="L7534" data-line-number="7534"></td>
        <td id="LC7534">                           <span>sizeof</span>(<span>GetDCB</span>()-&gt;<span>m_rightSideProtocolMinSupported</span>));</td>
      </tr>
      <tr>
        <td id="L7535" data-line-number="7535"></td>
        <td id="LC7535">
</td>
      </tr>
      <tr>
        <td id="L7536" data-line-number="7536"></td>
        <td id="LC7536">    <span><span>//</span> For Telesto, Dbi and Wks have a more flexible versioning allowed, as described by the Debugger</span></td>
      </tr>
      <tr>
        <td id="L7537" data-line-number="7537"></td>
        <td id="LC7537">    <span><span>//</span> Version Protocol String in DEBUGGER_PROTOCOL_STRING in DbgIpcEvents.h. This allows different build</span></td>
      </tr>
      <tr>
        <td id="L7538" data-line-number="7538"></td>
        <td id="LC7538">    <span><span>//</span> numbers, but the other protocol numbers should still match.</span></td>
      </tr>
      <tr>
        <td id="L7539" data-line-number="7539"></td>
        <td id="LC7539">
</td>
      </tr>
      <tr>
        <td id="L7540" data-line-number="7540"></td>
        <td id="LC7540">    <span><span>//</span> These assertions verify that the debug manager is behaving correctly.</span></td>
      </tr>
      <tr>
        <td id="L7541" data-line-number="7541"></td>
        <td id="LC7541">    <span><span>//</span> An assertion failure here means that the runtime version of the debuggee is different from the runtime version of</span></td>
      </tr>
      <tr>
        <td id="L7542" data-line-number="7542"></td>
        <td id="LC7542">    <span><span>//</span> the debugger is capable of debugging.</span></td>
      </tr>
      <tr>
        <td id="L7543" data-line-number="7543"></td>
        <td id="LC7543">
</td>
      </tr>
      <tr>
        <td id="L7544" data-line-number="7544"></td>
        <td id="LC7544">    <span><span>//</span> The Debug Manager should properly match LS &amp; RS, and thus guarantee that this assert should never fire.</span></td>
      </tr>
      <tr>
        <td id="L7545" data-line-number="7545"></td>
        <td id="LC7545">    <span><span>//</span> But just in case the installation is corrupted, we'll check it.</span></td>
      </tr>
      <tr>
        <td id="L7546" data-line-number="7546"></td>
        <td id="LC7546">    <span>if</span> (<span>GetDCB</span>()-&gt;<span>m_DCBSize</span> != <span>sizeof</span>(DebuggerIPCControlBlock))</td>
      </tr>
      <tr>
        <td id="L7547" data-line-number="7547"></td>
        <td id="LC7547">    {</td>
      </tr>
      <tr>
        <td id="L7548" data-line-number="7548"></td>
        <td id="LC7548">        <span>CONSISTENCY_CHECK_MSGF</span>(<span>false</span>, (<span><span>"</span>DCB in LS is %d bytes, in RS is %d bytes. Version mismatch!!<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7549" data-line-number="7549"></td>
        <td id="LC7549">                               <span>GetDCB</span>()-&gt;<span>m_DCBSize</span>, <span>sizeof</span>(DebuggerIPCControlBlock)));</td>
      </tr>
      <tr>
        <td id="L7550" data-line-number="7550"></td>
        <td id="LC7550">        <span>ThrowHR</span>(CORDBG_E_INCOMPATIBLE_PROTOCOL);</td>
      </tr>
      <tr>
        <td id="L7551" data-line-number="7551"></td>
        <td id="LC7551">    }</td>
      </tr>
      <tr>
        <td id="L7552" data-line-number="7552"></td>
        <td id="LC7552">
</td>
      </tr>
      <tr>
        <td id="L7553" data-line-number="7553"></td>
        <td id="LC7553">    <span><span>//</span> The Left Side has to support at least our minimum required protocol.</span></td>
      </tr>
      <tr>
        <td id="L7554" data-line-number="7554"></td>
        <td id="LC7554">    <span>if</span> (<span>GetDCB</span>()-&gt;<span>m_leftSideProtocolCurrent</span> &lt; <span>GetDCB</span>()-&gt;<span>m_rightSideProtocolMinSupported</span>)</td>
      </tr>
      <tr>
        <td id="L7555" data-line-number="7555"></td>
        <td id="LC7555">    {</td>
      </tr>
      <tr>
        <td id="L7556" data-line-number="7556"></td>
        <td id="LC7556">        <span>_ASSERTE</span>(<span>GetDCB</span>()-&gt;<span>m_leftSideProtocolCurrent</span> &gt;= <span>GetDCB</span>()-&gt;<span>m_rightSideProtocolMinSupported</span>);</td>
      </tr>
      <tr>
        <td id="L7557" data-line-number="7557"></td>
        <td id="LC7557">        <span>ThrowHR</span>(CORDBG_E_INCOMPATIBLE_PROTOCOL);</td>
      </tr>
      <tr>
        <td id="L7558" data-line-number="7558"></td>
        <td id="LC7558">    }</td>
      </tr>
      <tr>
        <td id="L7559" data-line-number="7559"></td>
        <td id="LC7559">
</td>
      </tr>
      <tr>
        <td id="L7560" data-line-number="7560"></td>
        <td id="LC7560">    <span><span>//</span> The Left Side has to be able to emulate at least our minimum required protocol.</span></td>
      </tr>
      <tr>
        <td id="L7561" data-line-number="7561"></td>
        <td id="LC7561">    <span>if</span> (<span>GetDCB</span>()-&gt;<span>m_leftSideProtocolMinSupported</span> &gt; <span>GetDCB</span>()-&gt;<span>m_rightSideProtocolCurrent</span>)</td>
      </tr>
      <tr>
        <td id="L7562" data-line-number="7562"></td>
        <td id="LC7562">    {</td>
      </tr>
      <tr>
        <td id="L7563" data-line-number="7563"></td>
        <td id="LC7563">        <span>_ASSERTE</span>(<span>GetDCB</span>()-&gt;<span>m_leftSideProtocolMinSupported</span> &lt;= <span>GetDCB</span>()-&gt;<span>m_rightSideProtocolCurrent</span>);</td>
      </tr>
      <tr>
        <td id="L7564" data-line-number="7564"></td>
        <td id="LC7564">        <span>ThrowHR</span>(CORDBG_E_INCOMPATIBLE_PROTOCOL);</td>
      </tr>
      <tr>
        <td id="L7565" data-line-number="7565"></td>
        <td id="LC7565">    }</td>
      </tr>
      <tr>
        <td id="L7566" data-line-number="7566"></td>
        <td id="LC7566">
</td>
      </tr>
      <tr>
        <td id="L7567" data-line-number="7567"></td>
        <td id="LC7567">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L7568" data-line-number="7568"></td>
        <td id="LC7568">    <span>char</span> buf[MAX_LONGPATH];</td>
      </tr>
      <tr>
        <td id="L7569" data-line-number="7569"></td>
        <td id="LC7569">    DWORD len = <span>GetEnvironmentVariableA</span>(<span><span>"</span>CORDBG_NotCompatibleTest<span>"</span></span>, buf, <span>sizeof</span>(buf));</td>
      </tr>
      <tr>
        <td id="L7570" data-line-number="7570"></td>
        <td id="LC7570">    <span>_ASSERTE</span>(len &lt; <span>sizeof</span>(buf));</td>
      </tr>
      <tr>
        <td id="L7571" data-line-number="7571"></td>
        <td id="LC7571">
</td>
      </tr>
      <tr>
        <td id="L7572" data-line-number="7572"></td>
        <td id="LC7572">    <span>if</span> (len &gt; <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L7573" data-line-number="7573"></td>
        <td id="LC7573">        <span>ThrowHR</span>(CORDBG_E_INCOMPATIBLE_PROTOCOL);</td>
      </tr>
      <tr>
        <td id="L7574" data-line-number="7574"></td>
        <td id="LC7574">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L7575" data-line-number="7575"></td>
        <td id="LC7575">
</td>
      </tr>
      <tr>
        <td id="L7576" data-line-number="7576"></td>
        <td id="LC7576">    <span>if</span> (<span>GetDCB</span>()-&gt;<span>m_bHostingInFiber</span>)</td>
      </tr>
      <tr>
        <td id="L7577" data-line-number="7577"></td>
        <td id="LC7577">    {</td>
      </tr>
      <tr>
        <td id="L7578" data-line-number="7578"></td>
        <td id="LC7578">        <span>ThrowHR</span>(CORDBG_E_CANNOT_DEBUG_FIBER_PROCESS);</td>
      </tr>
      <tr>
        <td id="L7579" data-line-number="7579"></td>
        <td id="LC7579">    }</td>
      </tr>
      <tr>
        <td id="L7580" data-line-number="7580"></td>
        <td id="LC7580">
</td>
      </tr>
      <tr>
        <td id="L7581" data-line-number="7581"></td>
        <td id="LC7581">    <span>_ASSERTE</span>(!<span>GetDCB</span>()-&gt;<span>m_rightSideShouldCreateHelperThread</span>);</td>
      </tr>
      <tr>
        <td id="L7582" data-line-number="7582"></td>
        <td id="LC7582">} <span><span>//</span> CordbProcess::VerifyControlBlock</span></td>
      </tr>
      <tr>
        <td id="L7583" data-line-number="7583"></td>
        <td id="LC7583">
</td>
      </tr>
      <tr>
        <td id="L7584" data-line-number="7584"></td>
        <td id="LC7584"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7585" data-line-number="7585"></td>
        <td id="LC7585"><span><span>//</span> This is the CordbProcess objects chance to inspect the DCB and intialize stuff</span></td>
      </tr>
      <tr>
        <td id="L7586" data-line-number="7586"></td>
        <td id="LC7586"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7587" data-line-number="7587"></td>
        <td id="LC7587"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L7588" data-line-number="7588"></td>
        <td id="LC7588"><span><span>//</span>     Typical HRESULT return values, nothing abnormal.</span></td>
      </tr>
      <tr>
        <td id="L7589" data-line-number="7589"></td>
        <td id="LC7589"><span><span>//</span>     If succeeded, then the block exists and is valid.</span></td>
      </tr>
      <tr>
        <td id="L7590" data-line-number="7590"></td>
        <td id="LC7590"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7591" data-line-number="7591"></td>
        <td id="LC7591"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7592" data-line-number="7592"></td>
        <td id="LC7592">HRESULT <span>CordbProcess::GetRuntimeOffsets</span>()</td>
      </tr>
      <tr>
        <td id="L7593" data-line-number="7593"></td>
        <td id="LC7593">{</td>
      </tr>
      <tr>
        <td id="L7594" data-line-number="7594"></td>
        <td id="LC7594">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7595" data-line-number="7595"></td>
        <td id="LC7595">
</td>
      </tr>
      <tr>
        <td id="L7596" data-line-number="7596"></td>
        <td id="LC7596">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7597" data-line-number="7597"></td>
        <td id="LC7597">    <span>UpdateRightSideDCB</span>();</td>
      </tr>
      <tr>
        <td id="L7598" data-line-number="7598"></td>
        <td id="LC7598">
</td>
      </tr>
      <tr>
        <td id="L7599" data-line-number="7599"></td>
        <td id="LC7599">    <span><span>//</span> Can't get a handle to the helper thread if the target is remote.</span></td>
      </tr>
      <tr>
        <td id="L7600" data-line-number="7600"></td>
        <td id="LC7600">
</td>
      </tr>
      <tr>
        <td id="L7601" data-line-number="7601"></td>
        <td id="LC7601">    <span><span>//</span> If we got this far w/o failing, then we should be able to get the helper thread handle.</span></td>
      </tr>
      <tr>
        <td id="L7602" data-line-number="7602"></td>
        <td id="LC7602">    <span><span>//</span> RS will handle not having the helper-thread handle, so we just make a best effort here.</span></td>
      </tr>
      <tr>
        <td id="L7603" data-line-number="7603"></td>
        <td id="LC7603">    DWORD dwHelperTid = <span>GetDCB</span>()-&gt;<span>m_realHelperThreadId</span>;</td>
      </tr>
      <tr>
        <td id="L7604" data-line-number="7604"></td>
        <td id="LC7604">    <span>_ASSERTE</span>(dwHelperTid != <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L7605" data-line-number="7605"></td>
        <td id="LC7605">
</td>
      </tr>
      <tr>
        <td id="L7606" data-line-number="7606"></td>
        <td id="LC7606">
</td>
      </tr>
      <tr>
        <td id="L7607" data-line-number="7607"></td>
        <td id="LC7607">    {</td>
      </tr>
      <tr>
        <td id="L7608" data-line-number="7608"></td>
        <td id="LC7608">#<span>if</span> !defined FEATURE_CORESYSTEM</td>
      </tr>
      <tr>
        <td id="L7609" data-line-number="7609"></td>
        <td id="LC7609">        <span><span>//</span> kernel32!OpenThread does not exist on all platforms (missing on Win98).</span></td>
      </tr>
      <tr>
        <td id="L7610" data-line-number="7610"></td>
        <td id="LC7610">        <span><span>//</span> So we need to delay load it.</span></td>
      </tr>
      <tr>
        <td id="L7611" data-line-number="7611"></td>
        <td id="LC7611">        <span>typedef</span> <span>HANDLE</span> (WINAPI *FPOPENTHREAD)(DWORD dwDesiredAccess,</td>
      </tr>
      <tr>
        <td id="L7612" data-line-number="7612"></td>
        <td id="LC7612">                                              BOOL bInheritHandle,</td>
      </tr>
      <tr>
        <td id="L7613" data-line-number="7613"></td>
        <td id="LC7613">                                              DWORD dwThreadId);</td>
      </tr>
      <tr>
        <td id="L7614" data-line-number="7614"></td>
        <td id="LC7614">
</td>
      </tr>
      <tr>
        <td id="L7615" data-line-number="7615"></td>
        <td id="LC7615">
</td>
      </tr>
      <tr>
        <td id="L7616" data-line-number="7616"></td>
        <td id="LC7616">
</td>
      </tr>
      <tr>
        <td id="L7617" data-line-number="7617"></td>
        <td id="LC7617">        HMODULE mod = <span>WszGetModuleHandle</span>(<span>W</span>(<span><span>"</span>kernel32.dll<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L7618" data-line-number="7618"></td>
        <td id="LC7618">
</td>
      </tr>
      <tr>
        <td id="L7619" data-line-number="7619"></td>
        <td id="LC7619">        <span>_ASSERTE</span>(mod != <span>NULL</span>); <span><span>//</span> can't fail since Kernel32.dll is already loaded.</span></td>
      </tr>
      <tr>
        <td id="L7620" data-line-number="7620"></td>
        <td id="LC7620">
</td>
      </tr>
      <tr>
        <td id="L7621" data-line-number="7621"></td>
        <td id="LC7621">        <span>const</span> FPOPENTHREAD pfnOpenThread = (FPOPENTHREAD)<span>GetProcAddress</span>(mod, <span><span>"</span>OpenThread<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7622" data-line-number="7622"></td>
        <td id="LC7622">
</td>
      </tr>
      <tr>
        <td id="L7623" data-line-number="7623"></td>
        <td id="LC7623">        <span>if</span> (pfnOpenThread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7624" data-line-number="7624"></td>
        <td id="LC7624">        {</td>
      </tr>
      <tr>
        <td id="L7625" data-line-number="7625"></td>
        <td id="LC7625">            m_hHelperThread = <span>pfnOpenThread</span>(SYNCHRONIZE, <span>FALSE</span>, dwHelperTid);</td>
      </tr>
      <tr>
        <td id="L7626" data-line-number="7626"></td>
        <td id="LC7626">            <span>CONSISTENCY_CHECK_MSGF</span>(m_hHelperThread != <span>NULL</span>, (<span><span>"</span>Failed to get helper-thread handle. tid=0x%x<span>\n</span><span>"</span></span>, dwHelperTid));</td>
      </tr>
      <tr>
        <td id="L7627" data-line-number="7627"></td>
        <td id="LC7627">        }</td>
      </tr>
      <tr>
        <td id="L7628" data-line-number="7628"></td>
        <td id="LC7628">#<span>elif</span> FEATURE_PAL</td>
      </tr>
      <tr>
        <td id="L7629" data-line-number="7629"></td>
        <td id="LC7629">        m_hHelperThread = <span>NULL</span>; <span><span>//</span>RS is supposed to be able to live without a helper thread handle.</span></td>
      </tr>
      <tr>
        <td id="L7630" data-line-number="7630"></td>
        <td id="LC7630">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L7631" data-line-number="7631"></td>
        <td id="LC7631">        m_hHelperThread = <span>OpenThread</span>(SYNCHRONIZE, <span>FALSE</span>, dwHelperTid);</td>
      </tr>
      <tr>
        <td id="L7632" data-line-number="7632"></td>
        <td id="LC7632">        <span>CONSISTENCY_CHECK_MSGF</span>(m_hHelperThread != <span>NULL</span>, (<span><span>"</span>Failed to get helper-thread handle. tid=0x%x<span>\n</span><span>"</span></span>, dwHelperTid));</td>
      </tr>
      <tr>
        <td id="L7633" data-line-number="7633"></td>
        <td id="LC7633">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L7634" data-line-number="7634"></td>
        <td id="LC7634">    }</td>
      </tr>
      <tr>
        <td id="L7635" data-line-number="7635"></td>
        <td id="LC7635">
</td>
      </tr>
      <tr>
        <td id="L7636" data-line-number="7636"></td>
        <td id="LC7636">    <span><span>//</span> get the remote address of the runtime offsets structure and read the structure itself</span></td>
      </tr>
      <tr>
        <td id="L7637" data-line-number="7637"></td>
        <td id="LC7637">    HRESULT hrRead = <span>SafeReadStruct</span>(<span>PTR_TO_CORDB_ADDRESS</span>(<span>GetDCB</span>()-&gt;<span>m_pRuntimeOffsets</span>), &amp;m_runtimeOffsets);</td>
      </tr>
      <tr>
        <td id="L7638" data-line-number="7638"></td>
        <td id="LC7638">
</td>
      </tr>
      <tr>
        <td id="L7639" data-line-number="7639"></td>
        <td id="LC7639">    <span>if</span> (<span>FAILED</span>(hrRead))</td>
      </tr>
      <tr>
        <td id="L7640" data-line-number="7640"></td>
        <td id="LC7640">    {</td>
      </tr>
      <tr>
        <td id="L7641" data-line-number="7641"></td>
        <td id="LC7641">        <span>return</span> hrRead;</td>
      </tr>
      <tr>
        <td id="L7642" data-line-number="7642"></td>
        <td id="LC7642">    }</td>
      </tr>
      <tr>
        <td id="L7643" data-line-number="7643"></td>
        <td id="LC7643">
</td>
      </tr>
      <tr>
        <td id="L7644" data-line-number="7644"></td>
        <td id="LC7644">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::GRO: got runtime offsets: <span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L7645" data-line-number="7645"></td>
        <td id="LC7645">
</td>
      </tr>
      <tr>
        <td id="L7646" data-line-number="7646"></td>
        <td id="LC7646">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L7647" data-line-number="7647"></td>
        <td id="LC7647">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_genericHijackFuncAddr=          0x%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7648" data-line-number="7648"></td>
        <td id="LC7648">         m_runtimeOffsets.<span>m_genericHijackFuncAddr</span>));</td>
      </tr>
      <tr>
        <td id="L7649" data-line-number="7649"></td>
        <td id="LC7649">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_signalHijackStartedBPAddr=      0x%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7650" data-line-number="7650"></td>
        <td id="LC7650">         m_runtimeOffsets.<span>m_signalHijackStartedBPAddr</span>));</td>
      </tr>
      <tr>
        <td id="L7651" data-line-number="7651"></td>
        <td id="LC7651">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_excepNotForRuntimeBPAddr=       0x%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7652" data-line-number="7652"></td>
        <td id="LC7652">         m_runtimeOffsets.<span>m_excepNotForRuntimeBPAddr</span>));</td>
      </tr>
      <tr>
        <td id="L7653" data-line-number="7653"></td>
        <td id="LC7653">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_notifyRSOfSyncCompleteBPAddr=   0x%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7654" data-line-number="7654"></td>
        <td id="LC7654">         m_runtimeOffsets.<span>m_notifyRSOfSyncCompleteBPAddr</span>));</td>
      </tr>
      <tr>
        <td id="L7655" data-line-number="7655"></td>
        <td id="LC7655">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_raiseException=                 0x%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7656" data-line-number="7656"></td>
        <td id="LC7656">         m_runtimeOffsets.<span>m_raiseExceptionAddr</span>));</td>
      </tr>
      <tr>
        <td id="L7657" data-line-number="7657"></td>
        <td id="LC7657">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_debuggerWordTLSIndex=           0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7658" data-line-number="7658"></td>
        <td id="LC7658">         m_runtimeOffsets.<span>m_debuggerWordTLSIndex</span>));</td>
      </tr>
      <tr>
        <td id="L7659" data-line-number="7659"></td>
        <td id="LC7659">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L7660" data-line-number="7660"></td>
        <td id="LC7660">
</td>
      </tr>
      <tr>
        <td id="L7661" data-line-number="7661"></td>
        <td id="LC7661">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_TLSIndex=                       0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7662" data-line-number="7662"></td>
        <td id="LC7662">         m_runtimeOffsets.<span>m_TLSIndex</span>));</td>
      </tr>
      <tr>
        <td id="L7663" data-line-number="7663"></td>
        <td id="LC7663">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEThreadStateOffset=            0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7664" data-line-number="7664"></td>
        <td id="LC7664">         m_runtimeOffsets.<span>m_EEThreadStateOffset</span>));</td>
      </tr>
      <tr>
        <td id="L7665" data-line-number="7665"></td>
        <td id="LC7665">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEThreadStateNCOffset=          0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7666" data-line-number="7666"></td>
        <td id="LC7666">         m_runtimeOffsets.<span>m_EEThreadStateNCOffset</span>));</td>
      </tr>
      <tr>
        <td id="L7667" data-line-number="7667"></td>
        <td id="LC7667">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEThreadPGCDisabledOffset=      0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7668" data-line-number="7668"></td>
        <td id="LC7668">         m_runtimeOffsets.<span>m_EEThreadPGCDisabledOffset</span>));</td>
      </tr>
      <tr>
        <td id="L7669" data-line-number="7669"></td>
        <td id="LC7669">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEThreadPGCDisabledValue=       0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7670" data-line-number="7670"></td>
        <td id="LC7670">         m_runtimeOffsets.<span>m_EEThreadPGCDisabledValue</span>));</td>
      </tr>
      <tr>
        <td id="L7671" data-line-number="7671"></td>
        <td id="LC7671">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEThreadFrameOffset=            0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7672" data-line-number="7672"></td>
        <td id="LC7672">         m_runtimeOffsets.<span>m_EEThreadFrameOffset</span>));</td>
      </tr>
      <tr>
        <td id="L7673" data-line-number="7673"></td>
        <td id="LC7673">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEThreadMaxNeededSize=          0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7674" data-line-number="7674"></td>
        <td id="LC7674">         m_runtimeOffsets.<span>m_EEThreadMaxNeededSize</span>));</td>
      </tr>
      <tr>
        <td id="L7675" data-line-number="7675"></td>
        <td id="LC7675">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEThreadSteppingStateMask=      0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7676" data-line-number="7676"></td>
        <td id="LC7676">         m_runtimeOffsets.<span>m_EEThreadSteppingStateMask</span>));</td>
      </tr>
      <tr>
        <td id="L7677" data-line-number="7677"></td>
        <td id="LC7677">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEMaxFrameValue=                0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7678" data-line-number="7678"></td>
        <td id="LC7678">         m_runtimeOffsets.<span>m_EEMaxFrameValue</span>));</td>
      </tr>
      <tr>
        <td id="L7679" data-line-number="7679"></td>
        <td id="LC7679">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEThreadDebuggerFilterContextOffset= 0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7680" data-line-number="7680"></td>
        <td id="LC7680">         m_runtimeOffsets.<span>m_EEThreadDebuggerFilterContextOffset</span>));</td>
      </tr>
      <tr>
        <td id="L7681" data-line-number="7681"></td>
        <td id="LC7681">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEThreadCantStopOffset=         0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7682" data-line-number="7682"></td>
        <td id="LC7682">         m_runtimeOffsets.<span>m_EEThreadCantStopOffset</span>));</td>
      </tr>
      <tr>
        <td id="L7683" data-line-number="7683"></td>
        <td id="LC7683">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEFrameNextOffset=              0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7684" data-line-number="7684"></td>
        <td id="LC7684">         m_runtimeOffsets.<span>m_EEFrameNextOffset</span>));</td>
      </tr>
      <tr>
        <td id="L7685" data-line-number="7685"></td>
        <td id="LC7685">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_EEIsManagedExceptionStateMask=  0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7686" data-line-number="7686"></td>
        <td id="LC7686">         m_runtimeOffsets.<span>m_EEIsManagedExceptionStateMask</span>));</td>
      </tr>
      <tr>
        <td id="L7687" data-line-number="7687"></td>
        <td id="LC7687">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_pPatches=                       0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7688" data-line-number="7688"></td>
        <td id="LC7688">         m_runtimeOffsets.<span>m_pPatches</span>));</td>
      </tr>
      <tr>
        <td id="L7689" data-line-number="7689"></td>
        <td id="LC7689">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_offRgData=                      0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7690" data-line-number="7690"></td>
        <td id="LC7690">         m_runtimeOffsets.<span>m_offRgData</span>));</td>
      </tr>
      <tr>
        <td id="L7691" data-line-number="7691"></td>
        <td id="LC7691">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_offCData=                       0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7692" data-line-number="7692"></td>
        <td id="LC7692">         m_runtimeOffsets.<span>m_offCData</span>));</td>
      </tr>
      <tr>
        <td id="L7693" data-line-number="7693"></td>
        <td id="LC7693">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_cbPatch=                        0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7694" data-line-number="7694"></td>
        <td id="LC7694">         m_runtimeOffsets.<span>m_cbPatch</span>));</td>
      </tr>
      <tr>
        <td id="L7695" data-line-number="7695"></td>
        <td id="LC7695">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_offAddr=                        0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7696" data-line-number="7696"></td>
        <td id="LC7696">         m_runtimeOffsets.<span>m_offAddr</span>));</td>
      </tr>
      <tr>
        <td id="L7697" data-line-number="7697"></td>
        <td id="LC7697">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_offOpcode=                      0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7698" data-line-number="7698"></td>
        <td id="LC7698">         m_runtimeOffsets.<span>m_offOpcode</span>));</td>
      </tr>
      <tr>
        <td id="L7699" data-line-number="7699"></td>
        <td id="LC7699">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_cbOpcode=                       0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7700" data-line-number="7700"></td>
        <td id="LC7700">         m_runtimeOffsets.<span>m_cbOpcode</span>));</td>
      </tr>
      <tr>
        <td id="L7701" data-line-number="7701"></td>
        <td id="LC7701">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_offTraceType=                   0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7702" data-line-number="7702"></td>
        <td id="LC7702">         m_runtimeOffsets.<span>m_offTraceType</span>));</td>
      </tr>
      <tr>
        <td id="L7703" data-line-number="7703"></td>
        <td id="LC7703">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>    m_traceTypeUnmanaged=             0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7704" data-line-number="7704"></td>
        <td id="LC7704">         m_runtimeOffsets.<span>m_traceTypeUnmanaged</span>));</td>
      </tr>
      <tr>
        <td id="L7705" data-line-number="7705"></td>
        <td id="LC7705">
</td>
      </tr>
      <tr>
        <td id="L7706" data-line-number="7706"></td>
        <td id="LC7706">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L7707" data-line-number="7707"></td>
        <td id="LC7707">    <span><span>//</span> Flares are only used for interop debugging.</span></td>
      </tr>
      <tr>
        <td id="L7708" data-line-number="7708"></td>
        <td id="LC7708">
</td>
      </tr>
      <tr>
        <td id="L7709" data-line-number="7709"></td>
        <td id="LC7709">    <span><span>//</span> Do check that the flares are all at unique offsets.</span></td>
      </tr>
      <tr>
        <td id="L7710" data-line-number="7710"></td>
        <td id="LC7710">    <span><span>//</span> Since this is determined at link-time, we need a run-time check (an</span></td>
      </tr>
      <tr>
        <td id="L7711" data-line-number="7711"></td>
        <td id="LC7711">    <span><span>//</span> assert isn't good enough, since this would only happen in a super</span></td>
      </tr>
      <tr>
        <td id="L7712" data-line-number="7712"></td>
        <td id="LC7712">    <span><span>//</span> optimized / bbt run).</span></td>
      </tr>
      <tr>
        <td id="L7713" data-line-number="7713"></td>
        <td id="LC7713">    {</td>
      </tr>
      <tr>
        <td id="L7714" data-line-number="7714"></td>
        <td id="LC7714">        <span>const</span> <span>void</span> * flares[] = {</td>
      </tr>
      <tr>
        <td id="L7715" data-line-number="7715"></td>
        <td id="LC7715">            m_runtimeOffsets.<span>m_signalHijackStartedBPAddr</span>,</td>
      </tr>
      <tr>
        <td id="L7716" data-line-number="7716"></td>
        <td id="LC7716">            m_runtimeOffsets.<span>m_excepForRuntimeHandoffStartBPAddr</span>,</td>
      </tr>
      <tr>
        <td id="L7717" data-line-number="7717"></td>
        <td id="LC7717">            m_runtimeOffsets.<span>m_excepForRuntimeHandoffCompleteBPAddr</span>,</td>
      </tr>
      <tr>
        <td id="L7718" data-line-number="7718"></td>
        <td id="LC7718">            m_runtimeOffsets.<span>m_signalHijackCompleteBPAddr</span>,</td>
      </tr>
      <tr>
        <td id="L7719" data-line-number="7719"></td>
        <td id="LC7719">            m_runtimeOffsets.<span>m_excepNotForRuntimeBPAddr</span>,</td>
      </tr>
      <tr>
        <td id="L7720" data-line-number="7720"></td>
        <td id="LC7720">            m_runtimeOffsets.<span>m_notifyRSOfSyncCompleteBPAddr</span>,</td>
      </tr>
      <tr>
        <td id="L7721" data-line-number="7721"></td>
        <td id="LC7721">        };</td>
      </tr>
      <tr>
        <td id="L7722" data-line-number="7722"></td>
        <td id="LC7722">
</td>
      </tr>
      <tr>
        <td id="L7723" data-line-number="7723"></td>
        <td id="LC7723">        <span>const</span> <span>int</span> NumFlares = <span>NumItems</span>(flares);</td>
      </tr>
      <tr>
        <td id="L7724" data-line-number="7724"></td>
        <td id="LC7724">
</td>
      </tr>
      <tr>
        <td id="L7725" data-line-number="7725"></td>
        <td id="LC7725">        <span><span>//</span> Ensure that all of the flares are unique.</span></td>
      </tr>
      <tr>
        <td id="L7726" data-line-number="7726"></td>
        <td id="LC7726">        <span>for</span>(<span>int</span> i = <span>0</span>; i &lt; NumFlares; i++)</td>
      </tr>
      <tr>
        <td id="L7727" data-line-number="7727"></td>
        <td id="LC7727">        {</td>
      </tr>
      <tr>
        <td id="L7728" data-line-number="7728"></td>
        <td id="LC7728">            <span>for</span>(<span>int</span> j = i+<span>1</span>; j &lt; NumFlares; j++)</td>
      </tr>
      <tr>
        <td id="L7729" data-line-number="7729"></td>
        <td id="LC7729">            {</td>
      </tr>
      <tr>
        <td id="L7730" data-line-number="7730"></td>
        <td id="LC7730">                <span>if</span> (flares[i] == flares[j])</td>
      </tr>
      <tr>
        <td id="L7731" data-line-number="7731"></td>
        <td id="LC7731">                {</td>
      </tr>
      <tr>
        <td id="L7732" data-line-number="7732"></td>
        <td id="LC7732">                    <span><span>//</span> If we ever fail here, that means the LS build is busted.</span></td>
      </tr>
      <tr>
        <td id="L7733" data-line-number="7733"></td>
        <td id="LC7733">
</td>
      </tr>
      <tr>
        <td id="L7734" data-line-number="7734"></td>
        <td id="LC7734">                    <span><span>//</span> This assert is useful if we drop a checked RS onto a retail</span></td>
      </tr>
      <tr>
        <td id="L7735" data-line-number="7735"></td>
        <td id="LC7735">                    <span><span>//</span> LS (that's legal).</span></td>
      </tr>
      <tr>
        <td id="L7736" data-line-number="7736"></td>
        <td id="LC7736">                    <span>_ASSERTE</span>(!<span><span>"</span>LS has matching Flares.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7737" data-line-number="7737"></td>
        <td id="LC7737">                    <span>LOG</span>((LF_CORDB, LL_ALWAYS, <span><span>"</span>Failing because of matching flares.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L7738" data-line-number="7738"></td>
        <td id="LC7738">                    <span>return</span> CORDBG_E_INCOMPATIBLE_PROTOCOL;</td>
      </tr>
      <tr>
        <td id="L7739" data-line-number="7739"></td>
        <td id="LC7739">                }</td>
      </tr>
      <tr>
        <td id="L7740" data-line-number="7740"></td>
        <td id="LC7740">            }</td>
      </tr>
      <tr>
        <td id="L7741" data-line-number="7741"></td>
        <td id="LC7741">        }</td>
      </tr>
      <tr>
        <td id="L7742" data-line-number="7742"></td>
        <td id="LC7742">    }</td>
      </tr>
      <tr>
        <td id="L7743" data-line-number="7743"></td>
        <td id="LC7743">
</td>
      </tr>
      <tr>
        <td id="L7744" data-line-number="7744"></td>
        <td id="LC7744">#<span>endif</span>  <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L7745" data-line-number="7745"></td>
        <td id="LC7745">    m_runtimeOffsetsInitialized = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7746" data-line-number="7746"></td>
        <td id="LC7746">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L7747" data-line-number="7747"></td>
        <td id="LC7747">}</td>
      </tr>
      <tr>
        <td id="L7748" data-line-number="7748"></td>
        <td id="LC7748">
</td>
      </tr>
      <tr>
        <td id="L7749" data-line-number="7749"></td>
        <td id="LC7749">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L7750" data-line-number="7750"></td>
        <td id="LC7750">
</td>
      </tr>
      <tr>
        <td id="L7751" data-line-number="7751"></td>
        <td id="LC7751"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7752" data-line-number="7752"></td>
        <td id="LC7752"><span><span>//</span> Resume hijacked threads.</span></td>
      </tr>
      <tr>
        <td id="L7753" data-line-number="7753"></td>
        <td id="LC7753"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7754" data-line-number="7754"></td>
        <td id="LC7754"><span>void</span> <span>CordbProcess::ResumeHijackedThreads</span>()</td>
      </tr>
      <tr>
        <td id="L7755" data-line-number="7755"></td>
        <td id="LC7755">{</td>
      </tr>
      <tr>
        <td id="L7756" data-line-number="7756"></td>
        <td id="LC7756">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7757" data-line-number="7757"></td>
        <td id="LC7757">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7758" data-line-number="7758"></td>
        <td id="LC7758">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L7759" data-line-number="7759"></td>
        <td id="LC7759">
</td>
      </tr>
      <tr>
        <td id="L7760" data-line-number="7760"></td>
        <td id="LC7760">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::RHT: entered<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L7761" data-line-number="7761"></td>
        <td id="LC7761">    <span>if</span> (<span>this</span>-&gt;<span>m_state</span> &amp; (CordbProcess::PS_SOME_THREADS_SUSPENDED | CordbProcess::PS_HIJACKS_IN_PLACE))</td>
      </tr>
      <tr>
        <td id="L7762" data-line-number="7762"></td>
        <td id="LC7762">    {</td>
      </tr>
      <tr>
        <td id="L7763" data-line-number="7763"></td>
        <td id="LC7763">        <span><span>//</span> On XP, This will also resume the threads suspended for Sync.</span></td>
      </tr>
      <tr>
        <td id="L7764" data-line-number="7764"></td>
        <td id="LC7764">        <span>this</span>-&gt;<span>ResumeUnmanagedThreads</span>();</td>
      </tr>
      <tr>
        <td id="L7765" data-line-number="7765"></td>
        <td id="LC7765">    }</td>
      </tr>
      <tr>
        <td id="L7766" data-line-number="7766"></td>
        <td id="LC7766">
</td>
      </tr>
      <tr>
        <td id="L7767" data-line-number="7767"></td>
        <td id="LC7767">    <span><span>//</span> Hijacks send their ownership flares and then wait on this event. By setting this</span></td>
      </tr>
      <tr>
        <td id="L7768" data-line-number="7768"></td>
        <td id="LC7768">    <span><span>//</span> we let the hijacks run free.</span></td>
      </tr>
      <tr>
        <td id="L7769" data-line-number="7769"></td>
        <td id="LC7769">    <span>if</span> (<span>this</span>-&gt;<span>m_leftSideUnmanagedWaitEvent</span> != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7770" data-line-number="7770"></td>
        <td id="LC7770">    {</td>
      </tr>
      <tr>
        <td id="L7771" data-line-number="7771"></td>
        <td id="LC7771">        <span>SetEvent</span>(<span>this</span>-&gt;<span>m_leftSideUnmanagedWaitEvent</span>);</td>
      </tr>
      <tr>
        <td id="L7772" data-line-number="7772"></td>
        <td id="LC7772">    }</td>
      </tr>
      <tr>
        <td id="L7773" data-line-number="7773"></td>
        <td id="LC7773">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7774" data-line-number="7774"></td>
        <td id="LC7774">    {</td>
      </tr>
      <tr>
        <td id="L7775" data-line-number="7775"></td>
        <td id="LC7775">        <span><span>//</span> Only reason we expect to not have this event is if the CLR hasn't been loaded yet.</span></td>
      </tr>
      <tr>
        <td id="L7776" data-line-number="7776"></td>
        <td id="LC7776">        <span><span>//</span> In that case, we won't hijack, so nobody's listening for this event either.</span></td>
      </tr>
      <tr>
        <td id="L7777" data-line-number="7777"></td>
        <td id="LC7777">        <span>_ASSERTE</span>(!m_initialized);</td>
      </tr>
      <tr>
        <td id="L7778" data-line-number="7778"></td>
        <td id="LC7778">    }</td>
      </tr>
      <tr>
        <td id="L7779" data-line-number="7779"></td>
        <td id="LC7779">}</td>
      </tr>
      <tr>
        <td id="L7780" data-line-number="7780"></td>
        <td id="LC7780">
</td>
      </tr>
      <tr>
        <td id="L7781" data-line-number="7781"></td>
        <td id="LC7781"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7782" data-line-number="7782"></td>
        <td id="LC7782"><span><span>//</span> For debugging support, record the win32 events.</span></td>
      </tr>
      <tr>
        <td id="L7783" data-line-number="7783"></td>
        <td id="LC7783"><span><span>//</span> Note that although this is for debugging, we want it in retail because we'll</span></td>
      </tr>
      <tr>
        <td id="L7784" data-line-number="7784"></td>
        <td id="LC7784"><span><span>//</span> be debugging retail most of the time :(</span></td>
      </tr>
      <tr>
        <td id="L7785" data-line-number="7785"></td>
        <td id="LC7785"><span><span>//</span> pEvent - the win32 debug event we just received</span></td>
      </tr>
      <tr>
        <td id="L7786" data-line-number="7786"></td>
        <td id="LC7786"><span><span>//</span> pUThread - our unmanaged thread object for the event. We could look it up</span></td>
      </tr>
      <tr>
        <td id="L7787" data-line-number="7787"></td>
        <td id="LC7787"><span><span>//</span>           from pEvent-&gt;dwThreadId, but passed in for perf reasons.</span></td>
      </tr>
      <tr>
        <td id="L7788" data-line-number="7788"></td>
        <td id="LC7788"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7789" data-line-number="7789"></td>
        <td id="LC7789"><span>void</span> <span>CordbProcess::DebugRecordWin32Event</span>(<span>const</span> DEBUG_EVENT * pEvent, CordbUnmanagedThread * pUThread)</td>
      </tr>
      <tr>
        <td id="L7790" data-line-number="7790"></td>
        <td id="LC7790">{</td>
      </tr>
      <tr>
        <td id="L7791" data-line-number="7791"></td>
        <td id="LC7791">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L7792" data-line-number="7792"></td>
        <td id="LC7792">
</td>
      </tr>
      <tr>
        <td id="L7793" data-line-number="7793"></td>
        <td id="LC7793">    <span><span>//</span> Although we could look up the Unmanaged thread, it's faster to have it just passed in.</span></td>
      </tr>
      <tr>
        <td id="L7794" data-line-number="7794"></td>
        <td id="LC7794">    <span><span>//</span> So here we do a consistency check.</span></td>
      </tr>
      <tr>
        <td id="L7795" data-line-number="7795"></td>
        <td id="LC7795">    <span>_ASSERTE</span>(pUThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7796" data-line-number="7796"></td>
        <td id="LC7796">    <span>_ASSERTE</span>(pUThread-&gt;<span>m_id</span> == pEvent-&gt;<span>dwThreadId</span>);</td>
      </tr>
      <tr>
        <td id="L7797" data-line-number="7797"></td>
        <td id="LC7797">
</td>
      </tr>
      <tr>
        <td id="L7798" data-line-number="7798"></td>
        <td id="LC7798">    m_DbgSupport.<span>m_TotalNativeEvents</span>++; <span><span>//</span> bump up the counter.</span></td>
      </tr>
      <tr>
        <td id="L7799" data-line-number="7799"></td>
        <td id="LC7799">
</td>
      </tr>
      <tr>
        <td id="L7800" data-line-number="7800"></td>
        <td id="LC7800">    MiniDebugEvent * pMiniEvent = &amp;m_DbgSupport.<span>m_DebugEventQueue</span>[m_DbgSupport.<span>m_DebugEventQueueIdx</span>];</td>
      </tr>
      <tr>
        <td id="L7801" data-line-number="7801"></td>
        <td id="LC7801">    pMiniEvent-&gt;<span>code</span>        = (BYTE) pEvent-&gt;<span>dwDebugEventCode</span>;</td>
      </tr>
      <tr>
        <td id="L7802" data-line-number="7802"></td>
        <td id="LC7802">    pMiniEvent-&gt;<span>pUThread</span>    = pUThread;</td>
      </tr>
      <tr>
        <td id="L7803" data-line-number="7803"></td>
        <td id="LC7803">
</td>
      </tr>
      <tr>
        <td id="L7804" data-line-number="7804"></td>
        <td id="LC7804">    DWORD tid = pEvent-&gt;<span>dwThreadId</span>;</td>
      </tr>
      <tr>
        <td id="L7805" data-line-number="7805"></td>
        <td id="LC7805">
</td>
      </tr>
      <tr>
        <td id="L7806" data-line-number="7806"></td>
        <td id="LC7806">    <span><span>//</span> Record debug-event specific data.</span></td>
      </tr>
      <tr>
        <td id="L7807" data-line-number="7807"></td>
        <td id="LC7807">    <span>switch</span>(pEvent-&gt;<span>dwDebugEventCode</span>)</td>
      </tr>
      <tr>
        <td id="L7808" data-line-number="7808"></td>
        <td id="LC7808">    {</td>
      </tr>
      <tr>
        <td id="L7809" data-line-number="7809"></td>
        <td id="LC7809">    <span>case</span> LOAD_DLL_DEBUG_EVENT:</td>
      </tr>
      <tr>
        <td id="L7810" data-line-number="7810"></td>
        <td id="LC7810">        pMiniEvent-&gt;<span>u</span>.<span>ModuleData</span>.<span>pBaseAddress</span> = pEvent-&gt;<span>u</span>.<span>LoadDll</span>.<span>lpBaseOfDll</span>;</td>
      </tr>
      <tr>
        <td id="L7811" data-line-number="7811"></td>
        <td id="LC7811">        <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>Win32 Debug Event received: tid=0x%8x, Load Dll. Addr=%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7812" data-line-number="7812"></td>
        <td id="LC7812">            tid,</td>
      </tr>
      <tr>
        <td id="L7813" data-line-number="7813"></td>
        <td id="LC7813">            pEvent-&gt;<span>u</span>.<span>LoadDll</span>.<span>lpBaseOfDll</span>);</td>
      </tr>
      <tr>
        <td id="L7814" data-line-number="7814"></td>
        <td id="LC7814">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L7815" data-line-number="7815"></td>
        <td id="LC7815">    <span>case</span> UNLOAD_DLL_DEBUG_EVENT:</td>
      </tr>
      <tr>
        <td id="L7816" data-line-number="7816"></td>
        <td id="LC7816">        pMiniEvent-&gt;<span>u</span>.<span>ModuleData</span>.<span>pBaseAddress</span> = pEvent-&gt;<span>u</span>.<span>UnloadDll</span>.<span>lpBaseOfDll</span>;</td>
      </tr>
      <tr>
        <td id="L7817" data-line-number="7817"></td>
        <td id="LC7817">        <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>Win32 Debug Event received: tid=0x%8x, Unload Dll. Addr=%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7818" data-line-number="7818"></td>
        <td id="LC7818">            tid,</td>
      </tr>
      <tr>
        <td id="L7819" data-line-number="7819"></td>
        <td id="LC7819">            pEvent-&gt;<span>u</span>.<span>UnloadDll</span>.<span>lpBaseOfDll</span>);</td>
      </tr>
      <tr>
        <td id="L7820" data-line-number="7820"></td>
        <td id="LC7820">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L7821" data-line-number="7821"></td>
        <td id="LC7821">    <span>case</span> EXCEPTION_DEBUG_EVENT:</td>
      </tr>
      <tr>
        <td id="L7822" data-line-number="7822"></td>
        <td id="LC7822">        pMiniEvent-&gt;<span>u</span>.<span>ExceptionData</span>.<span>pAddress</span> = pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionAddress</span>;</td>
      </tr>
      <tr>
        <td id="L7823" data-line-number="7823"></td>
        <td id="LC7823">        pMiniEvent-&gt;<span>u</span>.<span>ExceptionData</span>.<span>dwCode</span>   = pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span>;</td>
      </tr>
      <tr>
        <td id="L7824" data-line-number="7824"></td>
        <td id="LC7824">
</td>
      </tr>
      <tr>
        <td id="L7825" data-line-number="7825"></td>
        <td id="LC7825">        <span>STRESS_LOG3</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>Win32 Debug Event received: tid=%8x, (1) Exception. Code=0x%08x, Addr=%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7826" data-line-number="7826"></td>
        <td id="LC7826">            tid,</td>
      </tr>
      <tr>
        <td id="L7827" data-line-number="7827"></td>
        <td id="LC7827">            pMiniEvent-&gt;<span>u</span>.<span>ExceptionData</span>.<span>dwCode</span>,</td>
      </tr>
      <tr>
        <td id="L7828" data-line-number="7828"></td>
        <td id="LC7828">            pMiniEvent-&gt;<span>u</span>.<span>ExceptionData</span>.<span>pAddress</span></td>
      </tr>
      <tr>
        <td id="L7829" data-line-number="7829"></td>
        <td id="LC7829">        );</td>
      </tr>
      <tr>
        <td id="L7830" data-line-number="7830"></td>
        <td id="LC7830">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L7831" data-line-number="7831"></td>
        <td id="LC7831">    <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L7832" data-line-number="7832"></td>
        <td id="LC7832">        <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>Win32 Debug Event received tid=%8x, %d<span>\n</span><span>"</span></span>, tid, pEvent-&gt;<span>dwDebugEventCode</span>);</td>
      </tr>
      <tr>
        <td id="L7833" data-line-number="7833"></td>
        <td id="LC7833">        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L7834" data-line-number="7834"></td>
        <td id="LC7834">    }</td>
      </tr>
      <tr>
        <td id="L7835" data-line-number="7835"></td>
        <td id="LC7835">
</td>
      </tr>
      <tr>
        <td id="L7836" data-line-number="7836"></td>
        <td id="LC7836">
</td>
      </tr>
      <tr>
        <td id="L7837" data-line-number="7837"></td>
        <td id="LC7837">    <span><span>//</span> Go to the next entry in the queue.</span></td>
      </tr>
      <tr>
        <td id="L7838" data-line-number="7838"></td>
        <td id="LC7838">    m_DbgSupport.<span>m_DebugEventQueueIdx</span> = (m_DbgSupport.<span>m_DebugEventQueueIdx</span> + <span>1</span>) % DEBUG_EVENTQUEUE_SIZE;</td>
      </tr>
      <tr>
        <td id="L7839" data-line-number="7839"></td>
        <td id="LC7839">}</td>
      </tr>
      <tr>
        <td id="L7840" data-line-number="7840"></td>
        <td id="LC7840">
</td>
      </tr>
      <tr>
        <td id="L7841" data-line-number="7841"></td>
        <td id="LC7841"><span>void</span> <span>CordbProcess::QueueUnmanagedEvent</span>(CordbUnmanagedThread *pUThread, <span>const</span> DEBUG_EVENT *pEvent)</td>
      </tr>
      <tr>
        <td id="L7842" data-line-number="7842"></td>
        <td id="LC7842">{</td>
      </tr>
      <tr>
        <td id="L7843" data-line-number="7843"></td>
        <td id="LC7843">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7844" data-line-number="7844"></td>
        <td id="LC7844">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L7845" data-line-number="7845"></td>
        <td id="LC7845">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7846" data-line-number="7846"></td>
        <td id="LC7846">
</td>
      </tr>
      <tr>
        <td id="L7847" data-line-number="7847"></td>
        <td id="LC7847">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::QUE: queued unmanaged event %d for thread 0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7848" data-line-number="7848"></td>
        <td id="LC7848">         pEvent-&gt;<span>dwDebugEventCode</span>, pUThread-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L7849" data-line-number="7849"></td>
        <td id="LC7849">
</td>
      </tr>
      <tr>
        <td id="L7850" data-line-number="7850"></td>
        <td id="LC7850">
</td>
      </tr>
      <tr>
        <td id="L7851" data-line-number="7851"></td>
        <td id="LC7851">    <span>_ASSERTE</span>(pEvent-&gt;<span>dwDebugEventCode</span> == EXCEPTION_DEBUG_EVENT);</td>
      </tr>
      <tr>
        <td id="L7852" data-line-number="7852"></td>
        <td id="LC7852">
</td>
      </tr>
      <tr>
        <td id="L7853" data-line-number="7853"></td>
        <td id="LC7853">    <span><span>//</span> Copy the event into the given thread</span></td>
      </tr>
      <tr>
        <td id="L7854" data-line-number="7854"></td>
        <td id="LC7854">    CordbUnmanagedEvent *ue;</td>
      </tr>
      <tr>
        <td id="L7855" data-line-number="7855"></td>
        <td id="LC7855">
</td>
      </tr>
      <tr>
        <td id="L7856" data-line-number="7856"></td>
        <td id="LC7856">    <span><span>//</span> Use the primary IB event slot unless this is the special stack overflow event case.</span></td>
      </tr>
      <tr>
        <td id="L7857" data-line-number="7857"></td>
        <td id="LC7857">    <span>if</span> (!pUThread-&gt;<span>HasSpecialStackOverflowCase</span>())</td>
      </tr>
      <tr>
        <td id="L7858" data-line-number="7858"></td>
        <td id="LC7858">        ue = pUThread-&gt;<span>IBEvent</span>();</td>
      </tr>
      <tr>
        <td id="L7859" data-line-number="7859"></td>
        <td id="LC7859">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7860" data-line-number="7860"></td>
        <td id="LC7860">        ue = pUThread-&gt;<span>IBEvent2</span>();</td>
      </tr>
      <tr>
        <td id="L7861" data-line-number="7861"></td>
        <td id="LC7861">
</td>
      </tr>
      <tr>
        <td id="L7862" data-line-number="7862"></td>
        <td id="LC7862">    <span>if</span>(pUThread-&gt;<span>HasIBEvent</span>() &amp;&amp; !pUThread-&gt;<span>HasSpecialStackOverflowCase</span>())</td>
      </tr>
      <tr>
        <td id="L7863" data-line-number="7863"></td>
        <td id="LC7863">    {</td>
      </tr>
      <tr>
        <td id="L7864" data-line-number="7864"></td>
        <td id="LC7864">        <span><span>//</span> Any event being replaced should at least have been continued outside of the hijack</span></td>
      </tr>
      <tr>
        <td id="L7865" data-line-number="7865"></td>
        <td id="LC7865">        <span><span>//</span> We don't track whether or not we expect the exception to retrigger but if we are replacing</span></td>
      </tr>
      <tr>
        <td id="L7866" data-line-number="7866"></td>
        <td id="LC7866">        <span><span>//</span> the event then it did not.</span></td>
      </tr>
      <tr>
        <td id="L7867" data-line-number="7867"></td>
        <td id="LC7867">        <span>_ASSERTE</span>(ue-&gt;<span>IsEventContinuedUnhijacked</span>());</td>
      </tr>
      <tr>
        <td id="L7868" data-line-number="7868"></td>
        <td id="LC7868">        <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::QUE: A previously seen event is being discarded 0x%x 0x%p<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7869" data-line-number="7869"></td>
        <td id="LC7869">         ue-&gt;<span>m_currentDebugEvent</span>.<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span>,</td>
      </tr>
      <tr>
        <td id="L7870" data-line-number="7870"></td>
        <td id="LC7870">         ue-&gt;<span>m_currentDebugEvent</span>.<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionAddress</span>));</td>
      </tr>
      <tr>
        <td id="L7871" data-line-number="7871"></td>
        <td id="LC7871">        <span>DequeueUnmanagedEvent</span>(ue-&gt;<span>m_owner</span>);</td>
      </tr>
      <tr>
        <td id="L7872" data-line-number="7872"></td>
        <td id="LC7872">    }</td>
      </tr>
      <tr>
        <td id="L7873" data-line-number="7873"></td>
        <td id="LC7873">
</td>
      </tr>
      <tr>
        <td id="L7874" data-line-number="7874"></td>
        <td id="LC7874">    <span>memcpy</span>(&amp;(ue-&gt;<span>m_currentDebugEvent</span>), pEvent, <span>sizeof</span>(DEBUG_EVENT));</td>
      </tr>
      <tr>
        <td id="L7875" data-line-number="7875"></td>
        <td id="LC7875">    ue-&gt;<span>m_state</span> = CUES_IsIBEvent;</td>
      </tr>
      <tr>
        <td id="L7876" data-line-number="7876"></td>
        <td id="LC7876">    ue-&gt;<span>m_next</span> = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L7877" data-line-number="7877"></td>
        <td id="LC7877">
</td>
      </tr>
      <tr>
        <td id="L7878" data-line-number="7878"></td>
        <td id="LC7878">    <span><span>//</span> Enqueue the event.</span></td>
      </tr>
      <tr>
        <td id="L7879" data-line-number="7879"></td>
        <td id="LC7879">    pUThread-&gt;<span>SetState</span>(CUTS_HasIBEvent);</td>
      </tr>
      <tr>
        <td id="L7880" data-line-number="7880"></td>
        <td id="LC7880">
</td>
      </tr>
      <tr>
        <td id="L7881" data-line-number="7881"></td>
        <td id="LC7881">    <span>if</span> (m_unmanagedEventQueue == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7882" data-line-number="7882"></td>
        <td id="LC7882">        m_unmanagedEventQueue = ue;</td>
      </tr>
      <tr>
        <td id="L7883" data-line-number="7883"></td>
        <td id="LC7883">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7884" data-line-number="7884"></td>
        <td id="LC7884">        m_lastQueuedUnmanagedEvent-&gt;<span>m_next</span> = ue;</td>
      </tr>
      <tr>
        <td id="L7885" data-line-number="7885"></td>
        <td id="LC7885">
</td>
      </tr>
      <tr>
        <td id="L7886" data-line-number="7886"></td>
        <td id="LC7886">    m_lastQueuedUnmanagedEvent = ue;</td>
      </tr>
      <tr>
        <td id="L7887" data-line-number="7887"></td>
        <td id="LC7887">}</td>
      </tr>
      <tr>
        <td id="L7888" data-line-number="7888"></td>
        <td id="LC7888">
</td>
      </tr>
      <tr>
        <td id="L7889" data-line-number="7889"></td>
        <td id="LC7889"><span>void</span> <span>CordbProcess::DequeueUnmanagedEvent</span>(CordbUnmanagedThread *ut)</td>
      </tr>
      <tr>
        <td id="L7890" data-line-number="7890"></td>
        <td id="LC7890">{</td>
      </tr>
      <tr>
        <td id="L7891" data-line-number="7891"></td>
        <td id="LC7891">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7892" data-line-number="7892"></td>
        <td id="LC7892">
</td>
      </tr>
      <tr>
        <td id="L7893" data-line-number="7893"></td>
        <td id="LC7893">    <span>_ASSERTE</span>(m_unmanagedEventQueue != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7894" data-line-number="7894"></td>
        <td id="LC7894">    <span>_ASSERTE</span>(ut-&gt;<span>HasIBEvent</span>() || ut-&gt;<span>HasSpecialStackOverflowCase</span>());</td>
      </tr>
      <tr>
        <td id="L7895" data-line-number="7895"></td>
        <td id="LC7895">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L7896" data-line-number="7896"></td>
        <td id="LC7896">
</td>
      </tr>
      <tr>
        <td id="L7897" data-line-number="7897"></td>
        <td id="LC7897">
</td>
      </tr>
      <tr>
        <td id="L7898" data-line-number="7898"></td>
        <td id="LC7898">    CordbUnmanagedEvent *ue;</td>
      </tr>
      <tr>
        <td id="L7899" data-line-number="7899"></td>
        <td id="LC7899">
</td>
      </tr>
      <tr>
        <td id="L7900" data-line-number="7900"></td>
        <td id="LC7900">    <span>if</span> (ut-&gt;<span>HasIBEvent</span>())</td>
      </tr>
      <tr>
        <td id="L7901" data-line-number="7901"></td>
        <td id="LC7901">        ue = ut-&gt;<span>IBEvent</span>();</td>
      </tr>
      <tr>
        <td id="L7902" data-line-number="7902"></td>
        <td id="LC7902">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7903" data-line-number="7903"></td>
        <td id="LC7903">    {</td>
      </tr>
      <tr>
        <td id="L7904" data-line-number="7904"></td>
        <td id="LC7904">        ue = ut-&gt;<span>IBEvent2</span>();</td>
      </tr>
      <tr>
        <td id="L7905" data-line-number="7905"></td>
        <td id="LC7905">
</td>
      </tr>
      <tr>
        <td id="L7906" data-line-number="7906"></td>
        <td id="LC7906">        <span><span>//</span> Since we're dequeuing the special stack overflow event, we're no longer in the special stack overflow case.</span></td>
      </tr>
      <tr>
        <td id="L7907" data-line-number="7907"></td>
        <td id="LC7907">        ut-&gt;<span>ClearState</span>(CUTS_HasSpecialStackOverflowCase);</td>
      </tr>
      <tr>
        <td id="L7908" data-line-number="7908"></td>
        <td id="LC7908">    }</td>
      </tr>
      <tr>
        <td id="L7909" data-line-number="7909"></td>
        <td id="LC7909">
</td>
      </tr>
      <tr>
        <td id="L7910" data-line-number="7910"></td>
        <td id="LC7910">    DWORD ec = ue-&gt;<span>m_currentDebugEvent</span>.<span>dwDebugEventCode</span>;</td>
      </tr>
      <tr>
        <td id="L7911" data-line-number="7911"></td>
        <td id="LC7911">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::DUE: dequeue unmanaged event %d for thread 0x%x<span>\n</span><span>"</span></span>, ec, ut-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L7912" data-line-number="7912"></td>
        <td id="LC7912">
</td>
      </tr>
      <tr>
        <td id="L7913" data-line-number="7913"></td>
        <td id="LC7913">    <span>_ASSERTE</span>(ec == EXCEPTION_DEBUG_EVENT);</td>
      </tr>
      <tr>
        <td id="L7914" data-line-number="7914"></td>
        <td id="LC7914">
</td>
      </tr>
      <tr>
        <td id="L7915" data-line-number="7915"></td>
        <td id="LC7915">    CordbUnmanagedEvent **tmp = &amp;m_unmanagedEventQueue;</td>
      </tr>
      <tr>
        <td id="L7916" data-line-number="7916"></td>
        <td id="LC7916">    CordbUnmanagedEvent **prev = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L7917" data-line-number="7917"></td>
        <td id="LC7917">
</td>
      </tr>
      <tr>
        <td id="L7918" data-line-number="7918"></td>
        <td id="LC7918">    <span><span>//</span> Note: this supports out-of-order dequeing of unmanaged events. This is necessary because we queue events even if</span></td>
      </tr>
      <tr>
        <td id="L7919" data-line-number="7919"></td>
        <td id="LC7919">    <span><span>//</span> we're not clear on the ownership question. When we get the answer, and if the event belongs to the Runtime, we go</span></td>
      </tr>
      <tr>
        <td id="L7920" data-line-number="7920"></td>
        <td id="LC7920">    <span><span>//</span> ahead and yank the event out of the queue, wherever it may be.</span></td>
      </tr>
      <tr>
        <td id="L7921" data-line-number="7921"></td>
        <td id="LC7921">    <span>while</span> (*tmp &amp;&amp; *tmp != ue)</td>
      </tr>
      <tr>
        <td id="L7922" data-line-number="7922"></td>
        <td id="LC7922">    {</td>
      </tr>
      <tr>
        <td id="L7923" data-line-number="7923"></td>
        <td id="LC7923">        prev = tmp;</td>
      </tr>
      <tr>
        <td id="L7924" data-line-number="7924"></td>
        <td id="LC7924">        tmp = &amp;((*tmp)-&gt;<span>m_next</span>);</td>
      </tr>
      <tr>
        <td id="L7925" data-line-number="7925"></td>
        <td id="LC7925">    }</td>
      </tr>
      <tr>
        <td id="L7926" data-line-number="7926"></td>
        <td id="LC7926">
</td>
      </tr>
      <tr>
        <td id="L7927" data-line-number="7927"></td>
        <td id="LC7927">    <span>_ASSERTE</span>(*tmp == ue);</td>
      </tr>
      <tr>
        <td id="L7928" data-line-number="7928"></td>
        <td id="LC7928">
</td>
      </tr>
      <tr>
        <td id="L7929" data-line-number="7929"></td>
        <td id="LC7929">    *tmp = (*tmp)-&gt;<span>m_next</span>;</td>
      </tr>
      <tr>
        <td id="L7930" data-line-number="7930"></td>
        <td id="LC7930">
</td>
      </tr>
      <tr>
        <td id="L7931" data-line-number="7931"></td>
        <td id="LC7931">    <span>if</span> (m_unmanagedEventQueue == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7932" data-line-number="7932"></td>
        <td id="LC7932">        m_lastQueuedUnmanagedEvent = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L7933" data-line-number="7933"></td>
        <td id="LC7933">    <span>else</span> <span>if</span> (m_lastQueuedUnmanagedEvent == ue)</td>
      </tr>
      <tr>
        <td id="L7934" data-line-number="7934"></td>
        <td id="LC7934">    {</td>
      </tr>
      <tr>
        <td id="L7935" data-line-number="7935"></td>
        <td id="LC7935">        <span>_ASSERTE</span>(prev != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7936" data-line-number="7936"></td>
        <td id="LC7936">        m_lastQueuedUnmanagedEvent = *prev;</td>
      </tr>
      <tr>
        <td id="L7937" data-line-number="7937"></td>
        <td id="LC7937">    }</td>
      </tr>
      <tr>
        <td id="L7938" data-line-number="7938"></td>
        <td id="LC7938">
</td>
      </tr>
      <tr>
        <td id="L7939" data-line-number="7939"></td>
        <td id="LC7939">    ut-&gt;<span>ClearState</span>(CUTS_HasIBEvent);</td>
      </tr>
      <tr>
        <td id="L7940" data-line-number="7940"></td>
        <td id="LC7940">
</td>
      </tr>
      <tr>
        <td id="L7941" data-line-number="7941"></td>
        <td id="LC7941">}</td>
      </tr>
      <tr>
        <td id="L7942" data-line-number="7942"></td>
        <td id="LC7942">
</td>
      </tr>
      <tr>
        <td id="L7943" data-line-number="7943"></td>
        <td id="LC7943"><span>void</span> <span>CordbProcess::QueueOOBUnmanagedEvent</span>(CordbUnmanagedThread *pUThread, <span>const</span> DEBUG_EVENT * pEvent)</td>
      </tr>
      <tr>
        <td id="L7944" data-line-number="7944"></td>
        <td id="LC7944">{</td>
      </tr>
      <tr>
        <td id="L7945" data-line-number="7945"></td>
        <td id="LC7945">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7946" data-line-number="7946"></td>
        <td id="LC7946">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L7947" data-line-number="7947"></td>
        <td id="LC7947">    <span>_ASSERTE</span>(!pUThread-&gt;<span>HasOOBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L7948" data-line-number="7948"></td>
        <td id="LC7948">    <span>_ASSERTE</span>(<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L7949" data-line-number="7949"></td>
        <td id="LC7949">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7950" data-line-number="7950"></td>
        <td id="LC7950">
</td>
      </tr>
      <tr>
        <td id="L7951" data-line-number="7951"></td>
        <td id="LC7951">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::QUE: queued OOB unmanaged event %d for thread 0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7952" data-line-number="7952"></td>
        <td id="LC7952">         pEvent-&gt;<span>dwDebugEventCode</span>, pUThread-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L7953" data-line-number="7953"></td>
        <td id="LC7953">
</td>
      </tr>
      <tr>
        <td id="L7954" data-line-number="7954"></td>
        <td id="LC7954">    <span><span>//</span> Copy the event into the given thread</span></td>
      </tr>
      <tr>
        <td id="L7955" data-line-number="7955"></td>
        <td id="LC7955">    CordbUnmanagedEvent *ue = pUThread-&gt;<span>OOBEvent</span>();</td>
      </tr>
      <tr>
        <td id="L7956" data-line-number="7956"></td>
        <td id="LC7956">    <span>memcpy</span>(&amp;(ue-&gt;<span>m_currentDebugEvent</span>), pEvent, <span>sizeof</span>(DEBUG_EVENT));</td>
      </tr>
      <tr>
        <td id="L7957" data-line-number="7957"></td>
        <td id="LC7957">    ue-&gt;<span>m_state</span> = CUES_None;</td>
      </tr>
      <tr>
        <td id="L7958" data-line-number="7958"></td>
        <td id="LC7958">    ue-&gt;<span>m_next</span> = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L7959" data-line-number="7959"></td>
        <td id="LC7959">
</td>
      </tr>
      <tr>
        <td id="L7960" data-line-number="7960"></td>
        <td id="LC7960">    <span><span>//</span> Enqueue the event.</span></td>
      </tr>
      <tr>
        <td id="L7961" data-line-number="7961"></td>
        <td id="LC7961">    pUThread-&gt;<span>SetState</span>(CUTS_HasOOBEvent);</td>
      </tr>
      <tr>
        <td id="L7962" data-line-number="7962"></td>
        <td id="LC7962">
</td>
      </tr>
      <tr>
        <td id="L7963" data-line-number="7963"></td>
        <td id="LC7963">    <span>if</span> (m_outOfBandEventQueue == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L7964" data-line-number="7964"></td>
        <td id="LC7964">        m_outOfBandEventQueue = ue;</td>
      </tr>
      <tr>
        <td id="L7965" data-line-number="7965"></td>
        <td id="LC7965">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7966" data-line-number="7966"></td>
        <td id="LC7966">        m_lastQueuedOOBEvent-&gt;<span>m_next</span> = ue;</td>
      </tr>
      <tr>
        <td id="L7967" data-line-number="7967"></td>
        <td id="LC7967">
</td>
      </tr>
      <tr>
        <td id="L7968" data-line-number="7968"></td>
        <td id="LC7968">    m_lastQueuedOOBEvent = ue;</td>
      </tr>
      <tr>
        <td id="L7969" data-line-number="7969"></td>
        <td id="LC7969">}</td>
      </tr>
      <tr>
        <td id="L7970" data-line-number="7970"></td>
        <td id="LC7970">
</td>
      </tr>
      <tr>
        <td id="L7971" data-line-number="7971"></td>
        <td id="LC7971"><span>void</span> <span>CordbProcess::DequeueOOBUnmanagedEvent</span>(CordbUnmanagedThread *ut)</td>
      </tr>
      <tr>
        <td id="L7972" data-line-number="7972"></td>
        <td id="LC7972">{</td>
      </tr>
      <tr>
        <td id="L7973" data-line-number="7973"></td>
        <td id="LC7973">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L7974" data-line-number="7974"></td>
        <td id="LC7974">    <span>_ASSERTE</span>(m_outOfBandEventQueue != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L7975" data-line-number="7975"></td>
        <td id="LC7975">    <span>_ASSERTE</span>(ut-&gt;<span>HasOOBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L7976" data-line-number="7976"></td>
        <td id="LC7976">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L7977" data-line-number="7977"></td>
        <td id="LC7977">
</td>
      </tr>
      <tr>
        <td id="L7978" data-line-number="7978"></td>
        <td id="LC7978">    CordbUnmanagedEvent *ue = ut-&gt;<span>OOBEvent</span>();</td>
      </tr>
      <tr>
        <td id="L7979" data-line-number="7979"></td>
        <td id="LC7979">    DWORD ec = ue-&gt;<span>m_currentDebugEvent</span>.<span>dwDebugEventCode</span>;</td>
      </tr>
      <tr>
        <td id="L7980" data-line-number="7980"></td>
        <td id="LC7980">
</td>
      </tr>
      <tr>
        <td id="L7981" data-line-number="7981"></td>
        <td id="LC7981">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::DUE: dequeue OOB unmanaged event %d for thread 0x%x<span>\n</span><span>"</span></span>, ec, ut-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L7982" data-line-number="7982"></td>
        <td id="LC7982">
</td>
      </tr>
      <tr>
        <td id="L7983" data-line-number="7983"></td>
        <td id="LC7983">    CordbUnmanagedEvent **tmp = &amp;m_outOfBandEventQueue;</td>
      </tr>
      <tr>
        <td id="L7984" data-line-number="7984"></td>
        <td id="LC7984">    CordbUnmanagedEvent **prev = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L7985" data-line-number="7985"></td>
        <td id="LC7985">
</td>
      </tr>
      <tr>
        <td id="L7986" data-line-number="7986"></td>
        <td id="LC7986">    <span><span>//</span> Note: this supports out-of-order dequeing of unmanaged events. This is necessary because we queue events even if</span></td>
      </tr>
      <tr>
        <td id="L7987" data-line-number="7987"></td>
        <td id="LC7987">    <span><span>//</span> we're not clear on the ownership question. When we get the answer, and if the event belongs to the Runtime, we go</span></td>
      </tr>
      <tr>
        <td id="L7988" data-line-number="7988"></td>
        <td id="LC7988">    <span><span>//</span> ahead and yank the event out of the queue, wherever it may be.</span></td>
      </tr>
      <tr>
        <td id="L7989" data-line-number="7989"></td>
        <td id="LC7989">    <span>while</span> (*tmp &amp;&amp; *tmp != ue)</td>
      </tr>
      <tr>
        <td id="L7990" data-line-number="7990"></td>
        <td id="LC7990">    {</td>
      </tr>
      <tr>
        <td id="L7991" data-line-number="7991"></td>
        <td id="LC7991">        prev = tmp;</td>
      </tr>
      <tr>
        <td id="L7992" data-line-number="7992"></td>
        <td id="LC7992">        tmp = &amp;((*tmp)-&gt;<span>m_next</span>);</td>
      </tr>
      <tr>
        <td id="L7993" data-line-number="7993"></td>
        <td id="LC7993">    }</td>
      </tr>
      <tr>
        <td id="L7994" data-line-number="7994"></td>
        <td id="LC7994">
</td>
      </tr>
      <tr>
        <td id="L7995" data-line-number="7995"></td>
        <td id="LC7995">    <span>_ASSERTE</span>(*tmp == ue);</td>
      </tr>
      <tr>
        <td id="L7996" data-line-number="7996"></td>
        <td id="LC7996">
</td>
      </tr>
      <tr>
        <td id="L7997" data-line-number="7997"></td>
        <td id="LC7997">    *tmp = (*tmp)-&gt;<span>m_next</span>;</td>
      </tr>
      <tr>
        <td id="L7998" data-line-number="7998"></td>
        <td id="LC7998">
</td>
      </tr>
      <tr>
        <td id="L7999" data-line-number="7999"></td>
        <td id="LC7999">    <span>if</span> (m_outOfBandEventQueue == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8000" data-line-number="8000"></td>
        <td id="LC8000">        m_lastQueuedOOBEvent = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L8001" data-line-number="8001"></td>
        <td id="LC8001">    <span>else</span> <span>if</span> (m_lastQueuedOOBEvent == ue)</td>
      </tr>
      <tr>
        <td id="L8002" data-line-number="8002"></td>
        <td id="LC8002">    {</td>
      </tr>
      <tr>
        <td id="L8003" data-line-number="8003"></td>
        <td id="LC8003">        <span>_ASSERTE</span>(prev != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8004" data-line-number="8004"></td>
        <td id="LC8004">        m_lastQueuedOOBEvent = *prev;</td>
      </tr>
      <tr>
        <td id="L8005" data-line-number="8005"></td>
        <td id="LC8005">    }</td>
      </tr>
      <tr>
        <td id="L8006" data-line-number="8006"></td>
        <td id="LC8006">
</td>
      </tr>
      <tr>
        <td id="L8007" data-line-number="8007"></td>
        <td id="LC8007">    ut-&gt;<span>ClearState</span>(CUTS_HasOOBEvent);</td>
      </tr>
      <tr>
        <td id="L8008" data-line-number="8008"></td>
        <td id="LC8008">}</td>
      </tr>
      <tr>
        <td id="L8009" data-line-number="8009"></td>
        <td id="LC8009">
</td>
      </tr>
      <tr>
        <td id="L8010" data-line-number="8010"></td>
        <td id="LC8010">HRESULT <span>CordbProcess::SuspendUnmanagedThreads</span>()</td>
      </tr>
      <tr>
        <td id="L8011" data-line-number="8011"></td>
        <td id="LC8011">{</td>
      </tr>
      <tr>
        <td id="L8012" data-line-number="8012"></td>
        <td id="LC8012">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8013" data-line-number="8013"></td>
        <td id="LC8013">
</td>
      </tr>
      <tr>
        <td id="L8014" data-line-number="8014"></td>
        <td id="LC8014">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L8015" data-line-number="8015"></td>
        <td id="LC8015">
</td>
      </tr>
      <tr>
        <td id="L8016" data-line-number="8016"></td>
        <td id="LC8016">    <span><span>//</span> Iterate over all unmanaged threads...</span></td>
      </tr>
      <tr>
        <td id="L8017" data-line-number="8017"></td>
        <td id="LC8017">    CordbUnmanagedThread* ut;</td>
      </tr>
      <tr>
        <td id="L8018" data-line-number="8018"></td>
        <td id="LC8018">    HASHFIND find;</td>
      </tr>
      <tr>
        <td id="L8019" data-line-number="8019"></td>
        <td id="LC8019">
</td>
      </tr>
      <tr>
        <td id="L8020" data-line-number="8020"></td>
        <td id="LC8020">    <span>for</span> (ut =  m_unmanagedThreads.<span>FindFirst</span>(&amp;find); ut != <span>NULL</span>; ut =  m_unmanagedThreads.<span>FindNext</span>(&amp;find))</td>
      </tr>
      <tr>
        <td id="L8021" data-line-number="8021"></td>
        <td id="LC8021">    {</td>
      </tr>
      <tr>
        <td id="L8022" data-line-number="8022"></td>
        <td id="LC8022">
</td>
      </tr>
      <tr>
        <td id="L8023" data-line-number="8023"></td>
        <td id="LC8023">        <span><span>//</span> Don't suspend any thread in a can't stop region. This includes cooperative mode threads &amp; preemptive</span></td>
      </tr>
      <tr>
        <td id="L8024" data-line-number="8024"></td>
        <td id="LC8024">        <span><span>//</span> threads that haven't pushed a NativeTransitionFrame. The ultimate problem here is that a thread</span></td>
      </tr>
      <tr>
        <td id="L8025" data-line-number="8025"></td>
        <td id="LC8025">        <span><span>//</span> in this state is effectively inside the runtime, and thus may take a lock  that blocks the helper thread.</span></td>
      </tr>
      <tr>
        <td id="L8026" data-line-number="8026"></td>
        <td id="LC8026">        <span><span>//</span> IsCan'tStop also includes the helper thread &amp; hijacked threads - which we shouldn't suspend anyways.</span></td>
      </tr>
      <tr>
        <td id="L8027" data-line-number="8027"></td>
        <td id="LC8027">
</td>
      </tr>
      <tr>
        <td id="L8028" data-line-number="8028"></td>
        <td id="LC8028">        <span><span>//</span> Only suspend those unmanaged threads that aren't already suspended by us and that aren't already hijacked by</span></td>
      </tr>
      <tr>
        <td id="L8029" data-line-number="8029"></td>
        <td id="LC8029">        <span><span>//</span> us.</span></td>
      </tr>
      <tr>
        <td id="L8030" data-line-number="8030"></td>
        <td id="LC8030">
</td>
      </tr>
      <tr>
        <td id="L8031" data-line-number="8031"></td>
        <td id="LC8031">        <span>if</span> (!ut-&gt;<span>IsSuspended</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L8032" data-line-number="8032"></td>
        <td id="LC8032">            !ut-&gt;<span>IsDeleted</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L8033" data-line-number="8033"></td>
        <td id="LC8033">            !ut-&gt;<span>IsCantStop</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L8034" data-line-number="8034"></td>
        <td id="LC8034">            !ut-&gt;<span>IsBlockingForSync</span>()</td>
      </tr>
      <tr>
        <td id="L8035" data-line-number="8035"></td>
        <td id="LC8035">        )</td>
      </tr>
      <tr>
        <td id="L8036" data-line-number="8036"></td>
        <td id="LC8036">        {</td>
      </tr>
      <tr>
        <td id="L8037" data-line-number="8037"></td>
        <td id="LC8037">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::SUT: suspending unmanaged thread 0x%x, handle 0x%x<span>\n</span><span>"</span></span>, ut-&gt;<span>m_id</span>, ut-&gt;<span>m_handle</span>));</td>
      </tr>
      <tr>
        <td id="L8038" data-line-number="8038"></td>
        <td id="LC8038">
</td>
      </tr>
      <tr>
        <td id="L8039" data-line-number="8039"></td>
        <td id="LC8039">            DWORD succ = <span>SuspendThread</span>(ut-&gt;<span>m_handle</span>);</td>
      </tr>
      <tr>
        <td id="L8040" data-line-number="8040"></td>
        <td id="LC8040">
</td>
      </tr>
      <tr>
        <td id="L8041" data-line-number="8041"></td>
        <td id="LC8041">            <span>if</span> (succ == <span>0xFFFFFFFF</span>)</td>
      </tr>
      <tr>
        <td id="L8042" data-line-number="8042"></td>
        <td id="LC8042">            {</td>
      </tr>
      <tr>
        <td id="L8043" data-line-number="8043"></td>
        <td id="LC8043">                <span><span>//</span> This is okay... the thread may be dying after an ExitThread event.</span></td>
      </tr>
      <tr>
        <td id="L8044" data-line-number="8044"></td>
        <td id="LC8044">                <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::SUT: failed to suspend thread 0x%x<span>\n</span><span>"</span></span>, ut-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L8045" data-line-number="8045"></td>
        <td id="LC8045">            }</td>
      </tr>
      <tr>
        <td id="L8046" data-line-number="8046"></td>
        <td id="LC8046">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L8047" data-line-number="8047"></td>
        <td id="LC8047">            {</td>
      </tr>
      <tr>
        <td id="L8048" data-line-number="8048"></td>
        <td id="LC8048">                m_state |= PS_SOME_THREADS_SUSPENDED;</td>
      </tr>
      <tr>
        <td id="L8049" data-line-number="8049"></td>
        <td id="LC8049">
</td>
      </tr>
      <tr>
        <td id="L8050" data-line-number="8050"></td>
        <td id="LC8050">                ut-&gt;<span>SetState</span>(CUTS_Suspended);</td>
      </tr>
      <tr>
        <td id="L8051" data-line-number="8051"></td>
        <td id="LC8051">            }</td>
      </tr>
      <tr>
        <td id="L8052" data-line-number="8052"></td>
        <td id="LC8052">        }</td>
      </tr>
      <tr>
        <td id="L8053" data-line-number="8053"></td>
        <td id="LC8053">    }</td>
      </tr>
      <tr>
        <td id="L8054" data-line-number="8054"></td>
        <td id="LC8054">
</td>
      </tr>
      <tr>
        <td id="L8055" data-line-number="8055"></td>
        <td id="LC8055">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L8056" data-line-number="8056"></td>
        <td id="LC8056">}</td>
      </tr>
      <tr>
        <td id="L8057" data-line-number="8057"></td>
        <td id="LC8057">
</td>
      </tr>
      <tr>
        <td id="L8058" data-line-number="8058"></td>
        <td id="LC8058">HRESULT <span>CordbProcess::ResumeUnmanagedThreads</span>()</td>
      </tr>
      <tr>
        <td id="L8059" data-line-number="8059"></td>
        <td id="LC8059">{</td>
      </tr>
      <tr>
        <td id="L8060" data-line-number="8060"></td>
        <td id="LC8060">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8061" data-line-number="8061"></td>
        <td id="LC8061">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L8062" data-line-number="8062"></td>
        <td id="LC8062">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8063" data-line-number="8063"></td>
        <td id="LC8063">
</td>
      </tr>
      <tr>
        <td id="L8064" data-line-number="8064"></td>
        <td id="LC8064">    <span><span>//</span> Iterate over all unmanaged threads...</span></td>
      </tr>
      <tr>
        <td id="L8065" data-line-number="8065"></td>
        <td id="LC8065">    CordbUnmanagedThread* ut;</td>
      </tr>
      <tr>
        <td id="L8066" data-line-number="8066"></td>
        <td id="LC8066">    HASHFIND find;</td>
      </tr>
      <tr>
        <td id="L8067" data-line-number="8067"></td>
        <td id="LC8067">
</td>
      </tr>
      <tr>
        <td id="L8068" data-line-number="8068"></td>
        <td id="LC8068">    <span>for</span> (ut =  m_unmanagedThreads.<span>FindFirst</span>(&amp;find); ut != <span>NULL</span>; ut =  m_unmanagedThreads.<span>FindNext</span>(&amp;find))</td>
      </tr>
      <tr>
        <td id="L8069" data-line-number="8069"></td>
        <td id="LC8069">    {</td>
      </tr>
      <tr>
        <td id="L8070" data-line-number="8070"></td>
        <td id="LC8070">        <span><span>//</span> Only resume those unmanaged threads that were suspended by us.</span></td>
      </tr>
      <tr>
        <td id="L8071" data-line-number="8071"></td>
        <td id="LC8071">        <span>if</span> (ut-&gt;<span>IsSuspended</span>())</td>
      </tr>
      <tr>
        <td id="L8072" data-line-number="8072"></td>
        <td id="LC8072">        {</td>
      </tr>
      <tr>
        <td id="L8073" data-line-number="8073"></td>
        <td id="LC8073">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::RUT: resuming unmanaged thread 0x%x<span>\n</span><span>"</span></span>, ut-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L8074" data-line-number="8074"></td>
        <td id="LC8074">
</td>
      </tr>
      <tr>
        <td id="L8075" data-line-number="8075"></td>
        <td id="LC8075">            DWORD succ = <span>ResumeThread</span>(ut-&gt;<span>m_handle</span>);</td>
      </tr>
      <tr>
        <td id="L8076" data-line-number="8076"></td>
        <td id="LC8076">
</td>
      </tr>
      <tr>
        <td id="L8077" data-line-number="8077"></td>
        <td id="LC8077">            <span>if</span> (succ == <span>0xFFFFFFFF</span>)</td>
      </tr>
      <tr>
        <td id="L8078" data-line-number="8078"></td>
        <td id="LC8078">            {</td>
      </tr>
      <tr>
        <td id="L8079" data-line-number="8079"></td>
        <td id="LC8079">                <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::RUT: failed to resume thread 0x%x<span>\n</span><span>"</span></span>, ut-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L8080" data-line-number="8080"></td>
        <td id="LC8080">            }</td>
      </tr>
      <tr>
        <td id="L8081" data-line-number="8081"></td>
        <td id="LC8081">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L8082" data-line-number="8082"></td>
        <td id="LC8082">                ut-&gt;<span>ClearState</span>(CUTS_Suspended);</td>
      </tr>
      <tr>
        <td id="L8083" data-line-number="8083"></td>
        <td id="LC8083">        }</td>
      </tr>
      <tr>
        <td id="L8084" data-line-number="8084"></td>
        <td id="LC8084">    }</td>
      </tr>
      <tr>
        <td id="L8085" data-line-number="8085"></td>
        <td id="LC8085">
</td>
      </tr>
      <tr>
        <td id="L8086" data-line-number="8086"></td>
        <td id="LC8086">    m_state &amp;= ~PS_SOME_THREADS_SUSPENDED;</td>
      </tr>
      <tr>
        <td id="L8087" data-line-number="8087"></td>
        <td id="LC8087">
</td>
      </tr>
      <tr>
        <td id="L8088" data-line-number="8088"></td>
        <td id="LC8088">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L8089" data-line-number="8089"></td>
        <td id="LC8089">}</td>
      </tr>
      <tr>
        <td id="L8090" data-line-number="8090"></td>
        <td id="LC8090">
</td>
      </tr>
      <tr>
        <td id="L8091" data-line-number="8091"></td>
        <td id="LC8091"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8092" data-line-number="8092"></td>
        <td id="LC8092"><span><span>//</span> DispatchUnmanagedInBandEvent</span></td>
      </tr>
      <tr>
        <td id="L8093" data-line-number="8093"></td>
        <td id="LC8093"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8094" data-line-number="8094"></td>
        <td id="LC8094"><span><span>//</span> Handler for Win32 events already known to be Unmanaged and in-band.</span></td>
      </tr>
      <tr>
        <td id="L8095" data-line-number="8095"></td>
        <td id="LC8095"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8096" data-line-number="8096"></td>
        <td id="LC8096"><span>void</span> <span>CordbProcess::DispatchUnmanagedInBandEvent</span>()</td>
      </tr>
      <tr>
        <td id="L8097" data-line-number="8097"></td>
        <td id="LC8097">{</td>
      </tr>
      <tr>
        <td id="L8098" data-line-number="8098"></td>
        <td id="LC8098">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8099" data-line-number="8099"></td>
        <td id="LC8099">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L8100" data-line-number="8100"></td>
        <td id="LC8100">
</td>
      </tr>
      <tr>
        <td id="L8101" data-line-number="8101"></td>
        <td id="LC8101">    <span><span>//</span> There should be no queued OOB events!!! If there are, then we have a breakdown in our protocol, since all OOB</span></td>
      </tr>
      <tr>
        <td id="L8102" data-line-number="8102"></td>
        <td id="LC8102">    <span><span>//</span> events should be dispatched before attempting to really continue from any in-band event.</span></td>
      </tr>
      <tr>
        <td id="L8103" data-line-number="8103"></td>
        <td id="LC8103">    <span>_ASSERTE</span>(m_outOfBandEventQueue == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8104" data-line-number="8104"></td>
        <td id="LC8104">    <span>_ASSERTE</span>(m_cordb != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8105" data-line-number="8105"></td>
        <td id="LC8105">    <span>_ASSERTE</span>(m_cordb-&gt;<span>m_unmanagedCallback</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8106" data-line-number="8106"></td>
        <td id="LC8106">    <span>_ASSERTE</span>(!m_dispatchingUnmanagedEvent);</td>
      </tr>
      <tr>
        <td id="L8107" data-line-number="8107"></td>
        <td id="LC8107">
</td>
      </tr>
      <tr>
        <td id="L8108" data-line-number="8108"></td>
        <td id="LC8108">    CordbUnmanagedThread * pUnmanagedThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L8109" data-line-number="8109"></td>
        <td id="LC8109">    CordbUnmanagedEvent * pUnmanagedEvent = m_unmanagedEventQueue;</td>
      </tr>
      <tr>
        <td id="L8110" data-line-number="8110"></td>
        <td id="LC8110">
</td>
      </tr>
      <tr>
        <td id="L8111" data-line-number="8111"></td>
        <td id="LC8111">    <span>while</span> (<span>true</span>)</td>
      </tr>
      <tr>
        <td id="L8112" data-line-number="8112"></td>
        <td id="LC8112">    {</td>
      </tr>
      <tr>
        <td id="L8113" data-line-number="8113"></td>
        <td id="LC8113">        <span><span>//</span> get the next queued event that isn't dispatched yet</span></td>
      </tr>
      <tr>
        <td id="L8114" data-line-number="8114"></td>
        <td id="LC8114">        <span>while</span>(pUnmanagedEvent != <span>NULL</span> &amp;&amp; pUnmanagedEvent-&gt;<span>IsDispatched</span>())</td>
      </tr>
      <tr>
        <td id="L8115" data-line-number="8115"></td>
        <td id="LC8115">        {</td>
      </tr>
      <tr>
        <td id="L8116" data-line-number="8116"></td>
        <td id="LC8116">            pUnmanagedEvent = pUnmanagedEvent-&gt;<span>m_next</span>;</td>
      </tr>
      <tr>
        <td id="L8117" data-line-number="8117"></td>
        <td id="LC8117">        }</td>
      </tr>
      <tr>
        <td id="L8118" data-line-number="8118"></td>
        <td id="LC8118">
</td>
      </tr>
      <tr>
        <td id="L8119" data-line-number="8119"></td>
        <td id="LC8119">        <span>if</span>(pUnmanagedEvent == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8120" data-line-number="8120"></td>
        <td id="LC8120">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L8121" data-line-number="8121"></td>
        <td id="LC8121">
</td>
      </tr>
      <tr>
        <td id="L8122" data-line-number="8122"></td>
        <td id="LC8122">        <span><span>//</span> Get the thread for this event</span></td>
      </tr>
      <tr>
        <td id="L8123" data-line-number="8123"></td>
        <td id="LC8123">        <span>_ASSERTE</span>(pUnmanagedThread == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8124" data-line-number="8124"></td>
        <td id="LC8124">        pUnmanagedThread = pUnmanagedEvent-&gt;<span>m_owner</span>;</td>
      </tr>
      <tr>
        <td id="L8125" data-line-number="8125"></td>
        <td id="LC8125">        <span>_ASSERTE</span>(pUnmanagedThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8126" data-line-number="8126"></td>
        <td id="LC8126">
</td>
      </tr>
      <tr>
        <td id="L8127" data-line-number="8127"></td>
        <td id="LC8127">        <span><span>//</span> We better not have dispatched it yet!</span></td>
      </tr>
      <tr>
        <td id="L8128" data-line-number="8128"></td>
        <td id="LC8128">        <span>_ASSERTE</span>(!pUnmanagedEvent-&gt;<span>IsDispatched</span>());</td>
      </tr>
      <tr>
        <td id="L8129" data-line-number="8129"></td>
        <td id="LC8129">
</td>
      </tr>
      <tr>
        <td id="L8130" data-line-number="8130"></td>
        <td id="LC8130">        <span><span>//</span> We shouldn't be dispatching IB events on a thread that has exited.</span></td>
      </tr>
      <tr>
        <td id="L8131" data-line-number="8131"></td>
        <td id="LC8131">        <span><span>//</span> Though it's possible that the thread may exit *after* the IB event has been dispatched</span></td>
      </tr>
      <tr>
        <td id="L8132" data-line-number="8132"></td>
        <td id="LC8132">        <span><span>//</span> if it gets hijacked.</span></td>
      </tr>
      <tr>
        <td id="L8133" data-line-number="8133"></td>
        <td id="LC8133">        <span>_ASSERTE</span>(!pUnmanagedThread-&gt;<span>IsDeleted</span>());</td>
      </tr>
      <tr>
        <td id="L8134" data-line-number="8134"></td>
        <td id="LC8134">
</td>
      </tr>
      <tr>
        <td id="L8135" data-line-number="8135"></td>
        <td id="LC8135">        <span><span>//</span> Make sure we keep the thread alive while we're playing with it.</span></td>
      </tr>
      <tr>
        <td id="L8136" data-line-number="8136"></td>
        <td id="LC8136">        pUnmanagedThread-&gt;<span>InternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L8137" data-line-number="8137"></td>
        <td id="LC8137">
</td>
      </tr>
      <tr>
        <td id="L8138" data-line-number="8138"></td>
        <td id="LC8138">        <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::DUE: dispatching unmanaged event %d for thread 0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L8139" data-line-number="8139"></td>
        <td id="LC8139">             pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>dwDebugEventCode</span>, pUnmanagedThread-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L8140" data-line-number="8140"></td>
        <td id="LC8140">
</td>
      </tr>
      <tr>
        <td id="L8141" data-line-number="8141"></td>
        <td id="LC8141">        m_dispatchingUnmanagedEvent = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L8142" data-line-number="8142"></td>
        <td id="LC8142">
</td>
      </tr>
      <tr>
        <td id="L8143" data-line-number="8143"></td>
        <td id="LC8143">        <span><span>//</span> Add/Remove a reference which is scoped to the time that m_lastDispatchedIBEvent</span></td>
      </tr>
      <tr>
        <td id="L8144" data-line-number="8144"></td>
        <td id="LC8144">        <span><span>//</span> is set to pUnmanagedEvent (it is an interior pointer)</span></td>
      </tr>
      <tr>
        <td id="L8145" data-line-number="8145"></td>
        <td id="LC8145">        <span><span>//</span> see DevDiv issue 818301 for more details</span></td>
      </tr>
      <tr>
        <td id="L8146" data-line-number="8146"></td>
        <td id="LC8146">        <span>if</span>(m_lastDispatchedIBEvent != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8147" data-line-number="8147"></td>
        <td id="LC8147">        {</td>
      </tr>
      <tr>
        <td id="L8148" data-line-number="8148"></td>
        <td id="LC8148">            m_lastDispatchedIBEvent-&gt;<span>m_owner</span>-&gt;<span>InternalRelease</span>();</td>
      </tr>
      <tr>
        <td id="L8149" data-line-number="8149"></td>
        <td id="LC8149">            m_lastDispatchedIBEvent = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L8150" data-line-number="8150"></td>
        <td id="LC8150">        }</td>
      </tr>
      <tr>
        <td id="L8151" data-line-number="8151"></td>
        <td id="LC8151">        pUnmanagedThread-&gt;<span>InternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L8152" data-line-number="8152"></td>
        <td id="LC8152">        m_lastDispatchedIBEvent = pUnmanagedEvent;</td>
      </tr>
      <tr>
        <td id="L8153" data-line-number="8153"></td>
        <td id="LC8153">        pUnmanagedEvent-&gt;<span>SetState</span>(CUES_Dispatched);</td>
      </tr>
      <tr>
        <td id="L8154" data-line-number="8154"></td>
        <td id="LC8154">
</td>
      </tr>
      <tr>
        <td id="L8155" data-line-number="8155"></td>
        <td id="LC8155">        <span>IncStopCount</span>();</td>
      </tr>
      <tr>
        <td id="L8156" data-line-number="8156"></td>
        <td id="LC8156">
</td>
      </tr>
      <tr>
        <td id="L8157" data-line-number="8157"></td>
        <td id="LC8157">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L8158" data-line-number="8158"></td>
        <td id="LC8158">
</td>
      </tr>
      <tr>
        <td id="L8159" data-line-number="8159"></td>
        <td id="LC8159">        {</td>
      </tr>
      <tr>
        <td id="L8160" data-line-number="8160"></td>
        <td id="LC8160">            <span><span>//</span> Interface is semantically const, but does not include const in signature.</span></td>
      </tr>
      <tr>
        <td id="L8161" data-line-number="8161"></td>
        <td id="LC8161">            DEBUG_EVENT * pEvent = <span>const_cast</span>&lt;DEBUG_EVENT *&gt; (&amp;(pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>));</td>
      </tr>
      <tr>
        <td id="L8162" data-line-number="8162"></td>
        <td id="LC8162">            <span>PUBLIC_WIN32_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>,pEvent, <span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L8163" data-line-number="8163"></td>
        <td id="LC8163">            m_cordb-&gt;<span>m_unmanagedCallback</span>-&gt;<span>DebugEvent</span>(pEvent, <span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L8164" data-line-number="8164"></td>
        <td id="LC8164">        }</td>
      </tr>
      <tr>
        <td id="L8165" data-line-number="8165"></td>
        <td id="LC8165">
</td>
      </tr>
      <tr>
        <td id="L8166" data-line-number="8166"></td>
        <td id="LC8166">        <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L8167" data-line-number="8167"></td>
        <td id="LC8167">
</td>
      </tr>
      <tr>
        <td id="L8168" data-line-number="8168"></td>
        <td id="LC8168">        <span><span>//</span> Calling IMDA::Continue() will set m_dispatchingUnmanagedEvent = false.</span></td>
      </tr>
      <tr>
        <td id="L8169" data-line-number="8169"></td>
        <td id="LC8169">        <span><span>//</span> So if Continue() was called &amp;&amp; we have more events, we'll loop and dispatch more events.</span></td>
      </tr>
      <tr>
        <td id="L8170" data-line-number="8170"></td>
        <td id="LC8170">        <span><span>//</span> Else we'll break out of the while loop.</span></td>
      </tr>
      <tr>
        <td id="L8171" data-line-number="8171"></td>
        <td id="LC8171">        <span>if</span>(m_dispatchingUnmanagedEvent)</td>
      </tr>
      <tr>
        <td id="L8172" data-line-number="8172"></td>
        <td id="LC8172">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L8173" data-line-number="8173"></td>
        <td id="LC8173">
</td>
      </tr>
      <tr>
        <td id="L8174" data-line-number="8174"></td>
        <td id="LC8174">        <span><span>//</span> Continue was called in the dispatch callback, but that continue path just</span></td>
      </tr>
      <tr>
        <td id="L8175" data-line-number="8175"></td>
        <td id="LC8175">        <span><span>//</span> clears the dispatch flag and returns. The continue right here is the logical</span></td>
      </tr>
      <tr>
        <td id="L8176" data-line-number="8176"></td>
        <td id="LC8176">        <span><span>//</span> completion of the user's continue request</span></td>
      </tr>
      <tr>
        <td id="L8177" data-line-number="8177"></td>
        <td id="LC8177">        <span><span>//</span> Note it is sometimes the case that these events have already been continued because</span></td>
      </tr>
      <tr>
        <td id="L8178" data-line-number="8178"></td>
        <td id="LC8178">        <span><span>//</span> they had defered dispatching. At the time of deferal they were immediately continued.</span></td>
      </tr>
      <tr>
        <td id="L8179" data-line-number="8179"></td>
        <td id="LC8179">        <span><span>//</span> If the event is already continued then this continue becomes a no-op.</span></td>
      </tr>
      <tr>
        <td id="L8180" data-line-number="8180"></td>
        <td id="LC8180">        m_pShim-&gt;<span>GetWin32EventThread</span>()-&gt;<span>DoDbgContinue</span>(<span>this</span>, pUnmanagedEvent);</td>
      </tr>
      <tr>
        <td id="L8181" data-line-number="8181"></td>
        <td id="LC8181">
</td>
      </tr>
      <tr>
        <td id="L8182" data-line-number="8182"></td>
        <td id="LC8182">        <span><span>//</span> Release our reference to the unmanaged thread that we dispatched</span></td>
      </tr>
      <tr>
        <td id="L8183" data-line-number="8183"></td>
        <td id="LC8183">        <span><span>//</span> This event should have been continued long ago...</span></td>
      </tr>
      <tr>
        <td id="L8184" data-line-number="8184"></td>
        <td id="LC8184">        <span>_ASSERTE</span>(!pUnmanagedThread-&gt;<span>IBEvent</span>()-&gt;<span>IsEventWaitingForContinue</span>());</td>
      </tr>
      <tr>
        <td id="L8185" data-line-number="8185"></td>
        <td id="LC8185">        pUnmanagedThread-&gt;<span>InternalRelease</span>();</td>
      </tr>
      <tr>
        <td id="L8186" data-line-number="8186"></td>
        <td id="LC8186">        pUnmanagedThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L8187" data-line-number="8187"></td>
        <td id="LC8187">    }</td>
      </tr>
      <tr>
        <td id="L8188" data-line-number="8188"></td>
        <td id="LC8188">
</td>
      </tr>
      <tr>
        <td id="L8189" data-line-number="8189"></td>
        <td id="LC8189">    m_dispatchingUnmanagedEvent = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L8190" data-line-number="8190"></td>
        <td id="LC8190">
</td>
      </tr>
      <tr>
        <td id="L8191" data-line-number="8191"></td>
        <td id="LC8191">    <span><span>//</span> Release our reference to the last thread that we dispatched now...</span></td>
      </tr>
      <tr>
        <td id="L8192" data-line-number="8192"></td>
        <td id="LC8192">    <span>if</span>(pUnmanagedThread)</td>
      </tr>
      <tr>
        <td id="L8193" data-line-number="8193"></td>
        <td id="LC8193">    {</td>
      </tr>
      <tr>
        <td id="L8194" data-line-number="8194"></td>
        <td id="LC8194">        pUnmanagedThread-&gt;<span>InternalRelease</span>();</td>
      </tr>
      <tr>
        <td id="L8195" data-line-number="8195"></td>
        <td id="LC8195">        pUnmanagedThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L8196" data-line-number="8196"></td>
        <td id="LC8196">    }</td>
      </tr>
      <tr>
        <td id="L8197" data-line-number="8197"></td>
        <td id="LC8197">}</td>
      </tr>
      <tr>
        <td id="L8198" data-line-number="8198"></td>
        <td id="LC8198">
</td>
      </tr>
      <tr>
        <td id="L8199" data-line-number="8199"></td>
        <td id="LC8199"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8200" data-line-number="8200"></td>
        <td id="LC8200"><span><span>//</span> DispatchUnmanagedOOBEvent</span></td>
      </tr>
      <tr>
        <td id="L8201" data-line-number="8201"></td>
        <td id="LC8201"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8202" data-line-number="8202"></td>
        <td id="LC8202"><span><span>//</span> Handler for Win32 events already known to be Unmanaged and out-of-band.</span></td>
      </tr>
      <tr>
        <td id="L8203" data-line-number="8203"></td>
        <td id="LC8203"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8204" data-line-number="8204"></td>
        <td id="LC8204"><span>void</span> <span>CordbProcess::DispatchUnmanagedOOBEvent</span>()</td>
      </tr>
      <tr>
        <td id="L8205" data-line-number="8205"></td>
        <td id="LC8205">{</td>
      </tr>
      <tr>
        <td id="L8206" data-line-number="8206"></td>
        <td id="LC8206">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8207" data-line-number="8207"></td>
        <td id="LC8207">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L8208" data-line-number="8208"></td>
        <td id="LC8208">    <span>_ASSERTE</span>(<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L8209" data-line-number="8209"></td>
        <td id="LC8209">
</td>
      </tr>
      <tr>
        <td id="L8210" data-line-number="8210"></td>
        <td id="LC8210">    <span><span>//</span> There should be OOB events queued...</span></td>
      </tr>
      <tr>
        <td id="L8211" data-line-number="8211"></td>
        <td id="LC8211">    <span>_ASSERTE</span>(m_outOfBandEventQueue != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8212" data-line-number="8212"></td>
        <td id="LC8212">    <span>_ASSERTE</span>(m_cordb-&gt;<span>m_unmanagedCallback</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8213" data-line-number="8213"></td>
        <td id="LC8213">
</td>
      </tr>
      <tr>
        <td id="L8214" data-line-number="8214"></td>
        <td id="LC8214">    <span>do</span></td>
      </tr>
      <tr>
        <td id="L8215" data-line-number="8215"></td>
        <td id="LC8215">    {</td>
      </tr>
      <tr>
        <td id="L8216" data-line-number="8216"></td>
        <td id="LC8216">        <span><span>//</span> Get the first event in the OOB Queue...</span></td>
      </tr>
      <tr>
        <td id="L8217" data-line-number="8217"></td>
        <td id="LC8217">        CordbUnmanagedEvent * pUnmanagedEvent = m_outOfBandEventQueue;</td>
      </tr>
      <tr>
        <td id="L8218" data-line-number="8218"></td>
        <td id="LC8218">        CordbUnmanagedThread * pUnmanagedThread = pUnmanagedEvent-&gt;<span>m_owner</span>;</td>
      </tr>
      <tr>
        <td id="L8219" data-line-number="8219"></td>
        <td id="LC8219">
</td>
      </tr>
      <tr>
        <td id="L8220" data-line-number="8220"></td>
        <td id="LC8220">        <span><span>//</span> Make sure we keep the thread alive while we're playing with it.</span></td>
      </tr>
      <tr>
        <td id="L8221" data-line-number="8221"></td>
        <td id="LC8221">        RSSmartPtr&lt;CordbUnmanagedThread&gt; <span>pRef</span>(pUnmanagedThread);</td>
      </tr>
      <tr>
        <td id="L8222" data-line-number="8222"></td>
        <td id="LC8222">
</td>
      </tr>
      <tr>
        <td id="L8223" data-line-number="8223"></td>
        <td id="LC8223">        <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>[%x] CP::DUE: dispatching OOB unmanaged event %d for thread 0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L8224" data-line-number="8224"></td>
        <td id="LC8224">             <span>GetCurrentThreadId</span>(), pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>dwDebugEventCode</span>, pUnmanagedThread-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L8225" data-line-number="8225"></td>
        <td id="LC8225">
</td>
      </tr>
      <tr>
        <td id="L8226" data-line-number="8226"></td>
        <td id="LC8226">        m_dispatchingOOBEvent = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L8227" data-line-number="8227"></td>
        <td id="LC8227">        pUnmanagedEvent-&gt;<span>SetState</span>(CUES_Dispatched);</td>
      </tr>
      <tr>
        <td id="L8228" data-line-number="8228"></td>
        <td id="LC8228">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L8229" data-line-number="8229"></td>
        <td id="LC8229">
</td>
      </tr>
      <tr>
        <td id="L8230" data-line-number="8230"></td>
        <td id="LC8230">        {</td>
      </tr>
      <tr>
        <td id="L8231" data-line-number="8231"></td>
        <td id="LC8231">            <span><span>//</span> Interface is semantically const, but does not include const in signature.</span></td>
      </tr>
      <tr>
        <td id="L8232" data-line-number="8232"></td>
        <td id="LC8232">            DEBUG_EVENT * pEvent = <span>const_cast</span>&lt;DEBUG_EVENT *&gt; (&amp;(pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>));</td>
      </tr>
      <tr>
        <td id="L8233" data-line-number="8233"></td>
        <td id="LC8233">            <span>PUBLIC_WIN32_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pEvent, <span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L8234" data-line-number="8234"></td>
        <td id="LC8234">            m_cordb-&gt;<span>m_unmanagedCallback</span>-&gt;<span>DebugEvent</span>(pEvent, <span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L8235" data-line-number="8235"></td>
        <td id="LC8235">        }</td>
      </tr>
      <tr>
        <td id="L8236" data-line-number="8236"></td>
        <td id="LC8236">
</td>
      </tr>
      <tr>
        <td id="L8237" data-line-number="8237"></td>
        <td id="LC8237">        <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L8238" data-line-number="8238"></td>
        <td id="LC8238">
</td>
      </tr>
      <tr>
        <td id="L8239" data-line-number="8239"></td>
        <td id="LC8239">        <span><span>//</span> If they called Continue from the callback, then continue the OOB event right now before dispatching the next</span></td>
      </tr>
      <tr>
        <td id="L8240" data-line-number="8240"></td>
        <td id="LC8240">        <span><span>//</span> one.</span></td>
      </tr>
      <tr>
        <td id="L8241" data-line-number="8241"></td>
        <td id="LC8241">        <span>if</span> (!m_dispatchingOOBEvent)</td>
      </tr>
      <tr>
        <td id="L8242" data-line-number="8242"></td>
        <td id="LC8242">        {</td>
      </tr>
      <tr>
        <td id="L8243" data-line-number="8243"></td>
        <td id="LC8243">            <span>DequeueOOBUnmanagedEvent</span>(pUnmanagedThread);</td>
      </tr>
      <tr>
        <td id="L8244" data-line-number="8244"></td>
        <td id="LC8244">
</td>
      </tr>
      <tr>
        <td id="L8245" data-line-number="8245"></td>
        <td id="LC8245">            <span><span>//</span> Should not have continued from this debug event yet.</span></td>
      </tr>
      <tr>
        <td id="L8246" data-line-number="8246"></td>
        <td id="LC8246">            <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsEventWaitingForContinue</span>());</td>
      </tr>
      <tr>
        <td id="L8247" data-line-number="8247"></td>
        <td id="LC8247">
</td>
      </tr>
      <tr>
        <td id="L8248" data-line-number="8248"></td>
        <td id="LC8248">            <span><span>//</span> Do a little extra work if that was an OOB exception event...</span></td>
      </tr>
      <tr>
        <td id="L8249" data-line-number="8249"></td>
        <td id="LC8249">            HRESULT hr = pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>FixupAfterOOBException</span>(pUnmanagedEvent);</td>
      </tr>
      <tr>
        <td id="L8250" data-line-number="8250"></td>
        <td id="LC8250">            <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L8251" data-line-number="8251"></td>
        <td id="LC8251">
</td>
      </tr>
      <tr>
        <td id="L8252" data-line-number="8252"></td>
        <td id="LC8252">            <span><span>//</span> Go ahead and continue now...</span></td>
      </tr>
      <tr>
        <td id="L8253" data-line-number="8253"></td>
        <td id="LC8253">            <span>this</span>-&gt;<span>m_pShim</span>-&gt;<span>GetWin32EventThread</span>()-&gt;<span>DoDbgContinue</span>(<span>this</span>, pUnmanagedEvent);</td>
      </tr>
      <tr>
        <td id="L8254" data-line-number="8254"></td>
        <td id="LC8254">        }</td>
      </tr>
      <tr>
        <td id="L8255" data-line-number="8255"></td>
        <td id="LC8255">
</td>
      </tr>
      <tr>
        <td id="L8256" data-line-number="8256"></td>
        <td id="LC8256">        <span><span>//</span> Implicit release of pUnmanagedThread via pRef</span></td>
      </tr>
      <tr>
        <td id="L8257" data-line-number="8257"></td>
        <td id="LC8257">    }</td>
      </tr>
      <tr>
        <td id="L8258" data-line-number="8258"></td>
        <td id="LC8258">    <span>while</span> (!m_dispatchingOOBEvent &amp;&amp; (m_outOfBandEventQueue != <span>NULL</span>));</td>
      </tr>
      <tr>
        <td id="L8259" data-line-number="8259"></td>
        <td id="LC8259">
</td>
      </tr>
      <tr>
        <td id="L8260" data-line-number="8260"></td>
        <td id="LC8260">    m_dispatchingOOBEvent = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L8261" data-line-number="8261"></td>
        <td id="LC8261">
</td>
      </tr>
      <tr>
        <td id="L8262" data-line-number="8262"></td>
        <td id="LC8262">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::DUE: done dispatching OOB events. Queue=0x%08x<span>\n</span><span>"</span></span>, m_outOfBandEventQueue));</td>
      </tr>
      <tr>
        <td id="L8263" data-line-number="8263"></td>
        <td id="LC8263">}</td>
      </tr>
      <tr>
        <td id="L8264" data-line-number="8264"></td>
        <td id="LC8264">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L8265" data-line-number="8265"></td>
        <td id="LC8265">
</td>
      </tr>
      <tr>
        <td id="L8266" data-line-number="8266"></td>
        <td id="LC8266"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8267" data-line-number="8267"></td>
        <td id="LC8267"><span><span>//</span> StartSyncFromWin32Stop</span></td>
      </tr>
      <tr>
        <td id="L8268" data-line-number="8268"></td>
        <td id="LC8268"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8269" data-line-number="8269"></td>
        <td id="LC8269"><span><span>//</span> Get the process from a Fozen state or a Live state to a Synchronized State.</span></td>
      </tr>
      <tr>
        <td id="L8270" data-line-number="8270"></td>
        <td id="LC8270"><span><span>//</span> Note that Process Exit is considered to be synchronized.</span></td>
      </tr>
      <tr>
        <td id="L8271" data-line-number="8271"></td>
        <td id="LC8271"><span><span>//</span> This is a nop if we're not Interop Debugging.</span></td>
      </tr>
      <tr>
        <td id="L8272" data-line-number="8272"></td>
        <td id="LC8272"><span><span>//</span> If this function succeeds, we're in a synchronized state.</span></td>
      </tr>
      <tr>
        <td id="L8273" data-line-number="8273"></td>
        <td id="LC8273"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8274" data-line-number="8274"></td>
        <td id="LC8274"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L8275" data-line-number="8275"></td>
        <td id="LC8275"><span><span>//</span>    pfAsyncBreakSent - returns if this method sent an async-break or not.</span></td>
      </tr>
      <tr>
        <td id="L8276" data-line-number="8276"></td>
        <td id="LC8276"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8277" data-line-number="8277"></td>
        <td id="LC8277"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L8278" data-line-number="8278"></td>
        <td id="LC8278"><span><span>//</span>    typical HRESULT return values, nothing sinister here.</span></td>
      </tr>
      <tr>
        <td id="L8279" data-line-number="8279"></td>
        <td id="LC8279"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8280" data-line-number="8280"></td>
        <td id="LC8280">HRESULT <span>CordbProcess::StartSyncFromWin32Stop</span>(BOOL * pfAsyncBreakSent)</td>
      </tr>
      <tr>
        <td id="L8281" data-line-number="8281"></td>
        <td id="LC8281">{</td>
      </tr>
      <tr>
        <td id="L8282" data-line-number="8282"></td>
        <td id="LC8282">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8283" data-line-number="8283"></td>
        <td id="LC8283">    <span>if</span> (m_pShim == <span>NULL</span>) <span><span>//</span> This API is moved off to the shim</span></td>
      </tr>
      <tr>
        <td id="L8284" data-line-number="8284"></td>
        <td id="LC8284">    {</td>
      </tr>
      <tr>
        <td id="L8285" data-line-number="8285"></td>
        <td id="LC8285">        <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L8286" data-line-number="8286"></td>
        <td id="LC8286">    }</td>
      </tr>
      <tr>
        <td id="L8287" data-line-number="8287"></td>
        <td id="LC8287">
</td>
      </tr>
      <tr>
        <td id="L8288" data-line-number="8288"></td>
        <td id="LC8288">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L8289" data-line-number="8289"></td>
        <td id="LC8289">
</td>
      </tr>
      <tr>
        <td id="L8290" data-line-number="8290"></td>
        <td id="LC8290">    <span><span>//</span> Caller should have taken the stop-go lock. This prevents us from racing w/ a continue.</span></td>
      </tr>
      <tr>
        <td id="L8291" data-line-number="8291"></td>
        <td id="LC8291">    <span>_ASSERTE</span>(m_StopGoLock.<span>HasLock</span>());</td>
      </tr>
      <tr>
        <td id="L8292" data-line-number="8292"></td>
        <td id="LC8292">
</td>
      </tr>
      <tr>
        <td id="L8293" data-line-number="8293"></td>
        <td id="LC8293">    <span><span>//</span> Process should be init before we try to sync it.</span></td>
      </tr>
      <tr>
        <td id="L8294" data-line-number="8294"></td>
        <td id="LC8294">    <span>_ASSERTE</span>(<span>this</span>-&gt;<span>m_initialized</span>);</td>
      </tr>
      <tr>
        <td id="L8295" data-line-number="8295"></td>
        <td id="LC8295">
</td>
      </tr>
      <tr>
        <td id="L8296" data-line-number="8296"></td>
        <td id="LC8296">    <span><span>//</span> If nobody's listening for an AsyncBreak, and we're not stopped, then our caller</span></td>
      </tr>
      <tr>
        <td id="L8297" data-line-number="8297"></td>
        <td id="LC8297">    <span><span>//</span> doesn't know if we're sending an AsyncBreak or not; and thus we may not continue.</span></td>
      </tr>
      <tr>
        <td id="L8298" data-line-number="8298"></td>
        <td id="LC8298">    <span><span>//</span> Failing this assert means that we're stopping but we don't think we're going to get a continue</span></td>
      </tr>
      <tr>
        <td id="L8299" data-line-number="8299"></td>
        <td id="LC8299">    <span><span>//</span> down the road, and thus we're headed for a deadlock.</span></td>
      </tr>
      <tr>
        <td id="L8300" data-line-number="8300"></td>
        <td id="LC8300">    <span>_ASSERTE</span>((pfAsyncBreakSent != <span>NULL</span>) || (m_stopCount &gt; <span>0</span>));</td>
      </tr>
      <tr>
        <td id="L8301" data-line-number="8301"></td>
        <td id="LC8301">
</td>
      </tr>
      <tr>
        <td id="L8302" data-line-number="8302"></td>
        <td id="LC8302">    <span>if</span> (pfAsyncBreakSent)</td>
      </tr>
      <tr>
        <td id="L8303" data-line-number="8303"></td>
        <td id="LC8303">    {</td>
      </tr>
      <tr>
        <td id="L8304" data-line-number="8304"></td>
        <td id="LC8304">        *pfAsyncBreakSent = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L8305" data-line-number="8305"></td>
        <td id="LC8305">    }</td>
      </tr>
      <tr>
        <td id="L8306" data-line-number="8306"></td>
        <td id="LC8306">
</td>
      </tr>
      <tr>
        <td id="L8307" data-line-number="8307"></td>
        <td id="LC8307">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L8308" data-line-number="8308"></td>
        <td id="LC8308">
</td>
      </tr>
      <tr>
        <td id="L8309" data-line-number="8309"></td>
        <td id="LC8309">    <span><span>//</span> If we're win32 stopped (but not out-of-band win32 stopped), or if we're running free on the Left Side but we're</span></td>
      </tr>
      <tr>
        <td id="L8310" data-line-number="8310"></td>
        <td id="LC8310">    <span><span>//</span> just not synchronized (and we're win32 attached), then go ahead and do an internal continue and send an async</span></td>
      </tr>
      <tr>
        <td id="L8311" data-line-number="8311"></td>
        <td id="LC8311">    <span><span>//</span> break event to get the Left Side sync'd up.</span></td>
      </tr>
      <tr>
        <td id="L8312" data-line-number="8312"></td>
        <td id="LC8312">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8313" data-line-number="8313"></td>
        <td id="LC8313">    <span><span>//</span> The process can be running free as far as Win32 events are concerned, but still not synchronized as far as the</span></td>
      </tr>
      <tr>
        <td id="L8314" data-line-number="8314"></td>
        <td id="LC8314">    <span><span>//</span> Runtime is concerned. This can happen in a lot of cases where we end up with the Runtime not sync'd but with the</span></td>
      </tr>
      <tr>
        <td id="L8315" data-line-number="8315"></td>
        <td id="LC8315">    <span><span>//</span> process running free due to hijacking, etc...</span></td>
      </tr>
      <tr>
        <td id="L8316" data-line-number="8316"></td>
        <td id="LC8316">    <span>if</span> (((m_state &amp; CordbProcess::PS_WIN32_STOPPED) &amp;&amp; (m_outOfBandEventQueue == <span>NULL</span>)) ||</td>
      </tr>
      <tr>
        <td id="L8317" data-line-number="8317"></td>
        <td id="LC8317">        (!<span>GetSynchronized</span>() &amp;&amp; <span>IsInteropDebugging</span>()))</td>
      </tr>
      <tr>
        <td id="L8318" data-line-number="8318"></td>
        <td id="LC8318">    {</td>
      </tr>
      <tr>
        <td id="L8319" data-line-number="8319"></td>
        <td id="LC8319">        <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L8320" data-line-number="8320"></td>
        <td id="LC8320">
</td>
      </tr>
      <tr>
        <td id="L8321" data-line-number="8321"></td>
        <td id="LC8321">        <span>if</span> (((m_state &amp; CordbProcess::PS_WIN32_STOPPED) &amp;&amp; (m_outOfBandEventQueue == <span>NULL</span>)) ||</td>
      </tr>
      <tr>
        <td id="L8322" data-line-number="8322"></td>
        <td id="LC8322">            (!<span>GetSynchronized</span>() &amp;&amp; <span>IsInteropDebugging</span>()))</td>
      </tr>
      <tr>
        <td id="L8323" data-line-number="8323"></td>
        <td id="LC8323">        {</td>
      </tr>
      <tr>
        <td id="L8324" data-line-number="8324"></td>
        <td id="LC8324">            <span><span>//</span> This can't be the win32 ET b/c we need that thread to be alive and pumping win32 DE so that</span></td>
      </tr>
      <tr>
        <td id="L8325" data-line-number="8325"></td>
        <td id="LC8325">            <span><span>//</span> our Async Break can get across.</span></td>
      </tr>
      <tr>
        <td id="L8326" data-line-number="8326"></td>
        <td id="LC8326">            <span><span>//</span> So nobody should ever be calling this on the w32 ET. But they could, since we do trickle in from</span></td>
      </tr>
      <tr>
        <td id="L8327" data-line-number="8327"></td>
        <td id="LC8327">            <span><span>//</span> outside APIs. So we need a retail check.</span></td>
      </tr>
      <tr>
        <td id="L8328" data-line-number="8328"></td>
        <td id="LC8328">            <span>if</span> (<span>IsWin32EventThread</span>())</td>
      </tr>
      <tr>
        <td id="L8329" data-line-number="8329"></td>
        <td id="LC8329">            {</td>
      </tr>
      <tr>
        <td id="L8330" data-line-number="8330"></td>
        <td id="LC8330">                <span>_ASSERTE</span>(!<span><span>"</span>Don't call this API on the W32 Event Thread<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L8331" data-line-number="8331"></td>
        <td id="LC8331">
</td>
      </tr>
      <tr>
        <td id="L8332" data-line-number="8332"></td>
        <td id="LC8332">                <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L8333" data-line-number="8333"></td>
        <td id="LC8333">                <span>return</span> <span>ErrWrapper</span>(CORDBG_E_CANT_CALL_ON_THIS_THREAD);</td>
      </tr>
      <tr>
        <td id="L8334" data-line-number="8334"></td>
        <td id="LC8334">            }</td>
      </tr>
      <tr>
        <td id="L8335" data-line-number="8335"></td>
        <td id="LC8335">
</td>
      </tr>
      <tr>
        <td id="L8336" data-line-number="8336"></td>
        <td id="LC8336">            <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] CP::SSFW32S: sending internal continue<span>\n</span><span>"</span></span>, <span>GetCurrentThreadId</span>());</td>
      </tr>
      <tr>
        <td id="L8337" data-line-number="8337"></td>
        <td id="LC8337">
</td>
      </tr>
      <tr>
        <td id="L8338" data-line-number="8338"></td>
        <td id="LC8338">            <span><span>//</span> Can't do this on the win32 event thread.</span></td>
      </tr>
      <tr>
        <td id="L8339" data-line-number="8339"></td>
        <td id="LC8339">            <span>_ASSERTE</span>(!<span>this</span>-&gt;<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L8340" data-line-number="8340"></td>
        <td id="LC8340">
</td>
      </tr>
      <tr>
        <td id="L8341" data-line-number="8341"></td>
        <td id="LC8341">            <span><span>//</span> If the helper thread is already dead, then we just return as if we sync'd the process.</span></td>
      </tr>
      <tr>
        <td id="L8342" data-line-number="8342"></td>
        <td id="LC8342">            <span>if</span> (m_helperThreadDead)</td>
      </tr>
      <tr>
        <td id="L8343" data-line-number="8343"></td>
        <td id="LC8343">            {</td>
      </tr>
      <tr>
        <td id="L8344" data-line-number="8344"></td>
        <td id="LC8344">                <span>if</span> (pfAsyncBreakSent)</td>
      </tr>
      <tr>
        <td id="L8345" data-line-number="8345"></td>
        <td id="LC8345">                {</td>
      </tr>
      <tr>
        <td id="L8346" data-line-number="8346"></td>
        <td id="LC8346">                    *pfAsyncBreakSent = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L8347" data-line-number="8347"></td>
        <td id="LC8347">                }</td>
      </tr>
      <tr>
        <td id="L8348" data-line-number="8348"></td>
        <td id="LC8348">
</td>
      </tr>
      <tr>
        <td id="L8349" data-line-number="8349"></td>
        <td id="LC8349">                <span><span>//</span> Mark the process as synchronized so no events will be dispatched until the thing is</span></td>
      </tr>
      <tr>
        <td id="L8350" data-line-number="8350"></td>
        <td id="LC8350">                <span><span>//</span> continued. However, the marking here is not a usual marking for synchronized. It has special</span></td>
      </tr>
      <tr>
        <td id="L8351" data-line-number="8351"></td>
        <td id="LC8351">                <span><span>//</span> semantics when we're interop debugging. We use m_oddSync to remember this so that we can take special</span></td>
      </tr>
      <tr>
        <td id="L8352" data-line-number="8352"></td>
        <td id="LC8352">                <span><span>//</span> action in Continue().</span></td>
      </tr>
      <tr>
        <td id="L8353" data-line-number="8353"></td>
        <td id="LC8353">                <span>SetSynchronized</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L8354" data-line-number="8354"></td>
        <td id="LC8354">                m_oddSync = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L8355" data-line-number="8355"></td>
        <td id="LC8355">
</td>
      </tr>
      <tr>
        <td id="L8356" data-line-number="8356"></td>
        <td id="LC8356">                <span><span>//</span> Get the RC Event Thread to stop listening to the process.</span></td>
      </tr>
      <tr>
        <td id="L8357" data-line-number="8357"></td>
        <td id="LC8357">                m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L8358" data-line-number="8358"></td>
        <td id="LC8358">
</td>
      </tr>
      <tr>
        <td id="L8359" data-line-number="8359"></td>
        <td id="LC8359">                <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L8360" data-line-number="8360"></td>
        <td id="LC8360">
</td>
      </tr>
      <tr>
        <td id="L8361" data-line-number="8361"></td>
        <td id="LC8361">                <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L8362" data-line-number="8362"></td>
        <td id="LC8362">            }</td>
      </tr>
      <tr>
        <td id="L8363" data-line-number="8363"></td>
        <td id="LC8363">
</td>
      </tr>
      <tr>
        <td id="L8364" data-line-number="8364"></td>
        <td id="LC8364">            m_stopRequested = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L8365" data-line-number="8365"></td>
        <td id="LC8365">
</td>
      </tr>
      <tr>
        <td id="L8366" data-line-number="8366"></td>
        <td id="LC8366">            <span><span>//</span> See ::Stop for why we defer this. The delayed events will be dispatched when some one calls continue.</span></td>
      </tr>
      <tr>
        <td id="L8367" data-line-number="8367"></td>
        <td id="LC8367">            <span><span>//</span> And we know they'll call continue b/c (stopCount &gt; 0) || (our caller knows we're sending an AsyncBreak).</span></td>
      </tr>
      <tr>
        <td id="L8368" data-line-number="8368"></td>
        <td id="LC8368">            m_specialDeferment = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L8369" data-line-number="8369"></td>
        <td id="LC8369">
</td>
      </tr>
      <tr>
        <td id="L8370" data-line-number="8370"></td>
        <td id="LC8370">            <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L8371" data-line-number="8371"></td>
        <td id="LC8371">
</td>
      </tr>
      <tr>
        <td id="L8372" data-line-number="8372"></td>
        <td id="LC8372">            <span><span>//</span> If the process gets synchronized between the Unlock() and here, then SendUnmanagedContinue() will end up</span></td>
      </tr>
      <tr>
        <td id="L8373" data-line-number="8373"></td>
        <td id="LC8373">            <span><span>//</span> not doing anything at all since a) it holds the process lock when working and b) it gates everything on</span></td>
      </tr>
      <tr>
        <td id="L8374" data-line-number="8374"></td>
        <td id="LC8374">            <span><span>//</span> if the process is sync'd or not. This is exactly what we want.</span></td>
      </tr>
      <tr>
        <td id="L8375" data-line-number="8375"></td>
        <td id="LC8375">            hr = <span>this</span>-&gt;<span>m_pShim</span>-&gt;<span>GetWin32EventThread</span>()-&gt;<span>SendUnmanagedContinue</span>(<span>this</span>, cInternalUMContinue);</td>
      </tr>
      <tr>
        <td id="L8376" data-line-number="8376"></td>
        <td id="LC8376">
</td>
      </tr>
      <tr>
        <td id="L8377" data-line-number="8377"></td>
        <td id="LC8377">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] CP::SSFW32S: internal continue returned<span>\n</span><span>"</span></span>, <span>GetCurrentThreadId</span>()));</td>
      </tr>
      <tr>
        <td id="L8378" data-line-number="8378"></td>
        <td id="LC8378">
</td>
      </tr>
      <tr>
        <td id="L8379" data-line-number="8379"></td>
        <td id="LC8379">            <span><span>//</span> Send an async break to the left side now that its running.</span></td>
      </tr>
      <tr>
        <td id="L8380" data-line-number="8380"></td>
        <td id="LC8380">            DebuggerIPCEvent * pEvent = (DebuggerIPCEvent *) <span>_alloca</span>(CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L8381" data-line-number="8381"></td>
        <td id="LC8381">            <span>InitIPCEvent</span>(pEvent, DB_IPCE_ASYNC_BREAK, <span>false</span>, <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L8382" data-line-number="8382"></td>
        <td id="LC8382">
</td>
      </tr>
      <tr>
        <td id="L8383" data-line-number="8383"></td>
        <td id="LC8383">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] CP::SSFW32S: sending async stop<span>\n</span><span>"</span></span>, <span>GetCurrentThreadId</span>()));</td>
      </tr>
      <tr>
        <td id="L8384" data-line-number="8384"></td>
        <td id="LC8384">
</td>
      </tr>
      <tr>
        <td id="L8385" data-line-number="8385"></td>
        <td id="LC8385">            <span><span>//</span> If the process gets synchronized between the Unlock() and here, then this message will do nothing (Left</span></td>
      </tr>
      <tr>
        <td id="L8386" data-line-number="8386"></td>
        <td id="LC8386">            <span><span>//</span> Side catches it) and we'll never get a response, and it won't hurt anything.</span></td>
      </tr>
      <tr>
        <td id="L8387" data-line-number="8387"></td>
        <td id="LC8387">            hr = m_cordb-&gt;<span>SendIPCEvent</span>(<span>this</span>, pEvent, CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L8388" data-line-number="8388"></td>
        <td id="LC8388">            <span><span>//</span> @Todo- how do we handle a failure here?</span></td>
      </tr>
      <tr>
        <td id="L8389" data-line-number="8389"></td>
        <td id="LC8389">
</td>
      </tr>
      <tr>
        <td id="L8390" data-line-number="8390"></td>
        <td id="LC8390">            <span><span>//</span> If the send returns with the helper thread being dead, then we know we don't need to wait for the process</span></td>
      </tr>
      <tr>
        <td id="L8391" data-line-number="8391"></td>
        <td id="LC8391">            <span><span>//</span> to sync.</span></td>
      </tr>
      <tr>
        <td id="L8392" data-line-number="8392"></td>
        <td id="LC8392">            <span>if</span> (!m_helperThreadDead)</td>
      </tr>
      <tr>
        <td id="L8393" data-line-number="8393"></td>
        <td id="LC8393">            {</td>
      </tr>
      <tr>
        <td id="L8394" data-line-number="8394"></td>
        <td id="LC8394">                <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] CP::SSFW32S: sent async stop, waiting for event<span>\n</span><span>"</span></span>, <span>GetCurrentThreadId</span>());</td>
      </tr>
      <tr>
        <td id="L8395" data-line-number="8395"></td>
        <td id="LC8395">
</td>
      </tr>
      <tr>
        <td id="L8396" data-line-number="8396"></td>
        <td id="LC8396">                <span><span>//</span> If we got synchronized between the Unlock() and here its okay since m_stopWaitEvent is still high</span></td>
      </tr>
      <tr>
        <td id="L8397" data-line-number="8397"></td>
        <td id="LC8397">                <span><span>//</span> from the last sync.</span></td>
      </tr>
      <tr>
        <td id="L8398" data-line-number="8398"></td>
        <td id="LC8398">                DWORD dwWaitResult = <span>SafeWaitForSingleObject</span>(<span>this</span>, m_stopWaitEvent, INFINITE);</td>
      </tr>
      <tr>
        <td id="L8399" data-line-number="8399"></td>
        <td id="LC8399">
</td>
      </tr>
      <tr>
        <td id="L8400" data-line-number="8400"></td>
        <td id="LC8400">                <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] CP::SSFW32S: got event, %d<span>\n</span><span>"</span></span>, <span>GetCurrentThreadId</span>(), dwWaitResult);</td>
      </tr>
      <tr>
        <td id="L8401" data-line-number="8401"></td>
        <td id="LC8401">
</td>
      </tr>
      <tr>
        <td id="L8402" data-line-number="8402"></td>
        <td id="LC8402">                <span>_ASSERTE</span>(dwWaitResult == WAIT_OBJECT_0);</td>
      </tr>
      <tr>
        <td id="L8403" data-line-number="8403"></td>
        <td id="LC8403">            }</td>
      </tr>
      <tr>
        <td id="L8404" data-line-number="8404"></td>
        <td id="LC8404">
</td>
      </tr>
      <tr>
        <td id="L8405" data-line-number="8405"></td>
        <td id="LC8405">            <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L8406" data-line-number="8406"></td>
        <td id="LC8406">
</td>
      </tr>
      <tr>
        <td id="L8407" data-line-number="8407"></td>
        <td id="LC8407">            m_specialDeferment = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L8408" data-line-number="8408"></td>
        <td id="LC8408">
</td>
      </tr>
      <tr>
        <td id="L8409" data-line-number="8409"></td>
        <td id="LC8409">            <span>if</span> (pfAsyncBreakSent)</td>
      </tr>
      <tr>
        <td id="L8410" data-line-number="8410"></td>
        <td id="LC8410">            {</td>
      </tr>
      <tr>
        <td id="L8411" data-line-number="8411"></td>
        <td id="LC8411">                *pfAsyncBreakSent = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L8412" data-line-number="8412"></td>
        <td id="LC8412">            }</td>
      </tr>
      <tr>
        <td id="L8413" data-line-number="8413"></td>
        <td id="LC8413">
</td>
      </tr>
      <tr>
        <td id="L8414" data-line-number="8414"></td>
        <td id="LC8414">            <span><span>//</span> If the helper thread died while we were trying to send an event to it, then we just do the same odd sync</span></td>
      </tr>
      <tr>
        <td id="L8415" data-line-number="8415"></td>
        <td id="LC8415">            <span><span>//</span> logic we do above.</span></td>
      </tr>
      <tr>
        <td id="L8416" data-line-number="8416"></td>
        <td id="LC8416">            <span>if</span> (m_helperThreadDead)</td>
      </tr>
      <tr>
        <td id="L8417" data-line-number="8417"></td>
        <td id="LC8417">            {</td>
      </tr>
      <tr>
        <td id="L8418" data-line-number="8418"></td>
        <td id="LC8418">                <span>SetSynchronized</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L8419" data-line-number="8419"></td>
        <td id="LC8419">                m_oddSync = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L8420" data-line-number="8420"></td>
        <td id="LC8420">                hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L8421" data-line-number="8421"></td>
        <td id="LC8421">            }</td>
      </tr>
      <tr>
        <td id="L8422" data-line-number="8422"></td>
        <td id="LC8422">
</td>
      </tr>
      <tr>
        <td id="L8423" data-line-number="8423"></td>
        <td id="LC8423">            m_stopRequested = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L8424" data-line-number="8424"></td>
        <td id="LC8424">            m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L8425" data-line-number="8425"></td>
        <td id="LC8425">        }</td>
      </tr>
      <tr>
        <td id="L8426" data-line-number="8426"></td>
        <td id="LC8426">
</td>
      </tr>
      <tr>
        <td id="L8427" data-line-number="8427"></td>
        <td id="LC8427">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L8428" data-line-number="8428"></td>
        <td id="LC8428">    }</td>
      </tr>
      <tr>
        <td id="L8429" data-line-number="8429"></td>
        <td id="LC8429">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L8430" data-line-number="8430"></td>
        <td id="LC8430">
</td>
      </tr>
      <tr>
        <td id="L8431" data-line-number="8431"></td>
        <td id="LC8431">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L8432" data-line-number="8432"></td>
        <td id="LC8432">}</td>
      </tr>
      <tr>
        <td id="L8433" data-line-number="8433"></td>
        <td id="LC8433">
</td>
      </tr>
      <tr>
        <td id="L8434" data-line-number="8434"></td>
        <td id="LC8434"><span><span>//</span> Check if the left side has exited. If so, get the right-side</span></td>
      </tr>
      <tr>
        <td id="L8435" data-line-number="8435"></td>
        <td id="LC8435"><span><span>//</span> into shutdown mode. Only use this to avert us from going into</span></td>
      </tr>
      <tr>
        <td id="L8436" data-line-number="8436"></td>
        <td id="LC8436"><span><span>//</span> an unrecoverable error.</span></td>
      </tr>
      <tr>
        <td id="L8437" data-line-number="8437"></td>
        <td id="LC8437"><span>bool</span> <span>CordbProcess::CheckIfLSExited</span>()</td>
      </tr>
      <tr>
        <td id="L8438" data-line-number="8438"></td>
        <td id="LC8438">{</td>
      </tr>
      <tr>
        <td id="L8439" data-line-number="8439"></td>
        <td id="LC8439"><span><span>//</span> Check by waiting on the handle with no timeout.</span></td>
      </tr>
      <tr>
        <td id="L8440" data-line-number="8440"></td>
        <td id="LC8440">    <span>if</span> (<span>WaitForSingleObject</span>(m_handle, <span>0</span>) == WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L8441" data-line-number="8441"></td>
        <td id="LC8441">    {</td>
      </tr>
      <tr>
        <td id="L8442" data-line-number="8442"></td>
        <td id="LC8442">        <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L8443" data-line-number="8443"></td>
        <td id="LC8443">        m_terminated = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L8444" data-line-number="8444"></td>
        <td id="LC8444">        m_exiting = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L8445" data-line-number="8445"></td>
        <td id="LC8445">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L8446" data-line-number="8446"></td>
        <td id="LC8446">    }</td>
      </tr>
      <tr>
        <td id="L8447" data-line-number="8447"></td>
        <td id="LC8447">
</td>
      </tr>
      <tr>
        <td id="L8448" data-line-number="8448"></td>
        <td id="LC8448">    <span>LOG</span>((LF_CORDB, LL_INFO10, <span><span>"</span>CP::IsLSExited() returning '%s'<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L8449" data-line-number="8449"></td>
        <td id="LC8449">        m_exiting ? <span><span>"</span>true<span>"</span></span> : <span><span>"</span>false<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L8450" data-line-number="8450"></td>
        <td id="LC8450">
</td>
      </tr>
      <tr>
        <td id="L8451" data-line-number="8451"></td>
        <td id="LC8451">    <span>return</span> m_exiting;</td>
      </tr>
      <tr>
        <td id="L8452" data-line-number="8452"></td>
        <td id="LC8452">}</td>
      </tr>
      <tr>
        <td id="L8453" data-line-number="8453"></td>
        <td id="LC8453">
</td>
      </tr>
      <tr>
        <td id="L8454" data-line-number="8454"></td>
        <td id="LC8454"><span><span>//</span> Call this if something really bad happened and we can't do</span></td>
      </tr>
      <tr>
        <td id="L8455" data-line-number="8455"></td>
        <td id="LC8455"><span><span>//</span> anything meaningful with the CordbProcess.</span></td>
      </tr>
      <tr>
        <td id="L8456" data-line-number="8456"></td>
        <td id="LC8456"><span>void</span> <span>CordbProcess::UnrecoverableError</span>(HRESULT errorHR,</td>
      </tr>
      <tr>
        <td id="L8457" data-line-number="8457"></td>
        <td id="LC8457">                                      <span>unsigned</span> <span>int</span> errorCode,</td>
      </tr>
      <tr>
        <td id="L8458" data-line-number="8458"></td>
        <td id="LC8458">                                      <span>const</span> <span>char</span> *errorFile,</td>
      </tr>
      <tr>
        <td id="L8459" data-line-number="8459"></td>
        <td id="LC8459">                                      <span>unsigned</span> <span>int</span> errorLine)</td>
      </tr>
      <tr>
        <td id="L8460" data-line-number="8460"></td>
        <td id="LC8460">{</td>
      </tr>
      <tr>
        <td id="L8461" data-line-number="8461"></td>
        <td id="LC8461">    <span>LOG</span>((LF_CORDB, LL_INFO10, <span><span>"</span>[%x] CP::UE: unrecoverable error 0x%08x <span>"</span></span></td>
      </tr>
      <tr>
        <td id="L8462" data-line-number="8462"></td>
        <td id="LC8462">         <span><span>"</span>(%d) %s:%d<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L8463" data-line-number="8463"></td>
        <td id="LC8463">         <span>GetCurrentThreadId</span>(),</td>
      </tr>
      <tr>
        <td id="L8464" data-line-number="8464"></td>
        <td id="LC8464">         errorHR, errorCode, errorFile, errorLine));</td>
      </tr>
      <tr>
        <td id="L8465" data-line-number="8465"></td>
        <td id="LC8465">
</td>
      </tr>
      <tr>
        <td id="L8466" data-line-number="8466"></td>
        <td id="LC8466">    <span><span>//</span> We definitely want to know about any of these.</span></td>
      </tr>
      <tr>
        <td id="L8467" data-line-number="8467"></td>
        <td id="LC8467">    <span>STRESS_LOG3</span>(LF_CORDB, LL_EVERYTHING, <span><span>"</span>Unrecoverable Error:0x%08x, File=%s, line=%d<span>\n</span><span>"</span></span>, errorHR, errorFile, errorLine);</td>
      </tr>
      <tr>
        <td id="L8468" data-line-number="8468"></td>
        <td id="LC8468">
</td>
      </tr>
      <tr>
        <td id="L8469" data-line-number="8469"></td>
        <td id="LC8469">    <span><span>//</span> It's possible for an unrecoverable error to occur if the user detaches the</span></td>
      </tr>
      <tr>
        <td id="L8470" data-line-number="8470"></td>
        <td id="LC8470">    <span><span>//</span> debugger while inside CordbProcess::DispatchRCEvent() (as that function deliberately</span></td>
      </tr>
      <tr>
        <td id="L8471" data-line-number="8471"></td>
        <td id="LC8471">    <span><span>//</span> calls Unlock() while calling into the Shim).  Detect such cases here &amp; bail before we</span></td>
      </tr>
      <tr>
        <td id="L8472" data-line-number="8472"></td>
        <td id="LC8472">    <span><span>//</span> try to access invalid fields on this CordbProcess.</span></td>
      </tr>
      <tr>
        <td id="L8473" data-line-number="8473"></td>
        <td id="LC8473">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8474" data-line-number="8474"></td>
        <td id="LC8474">    <span><span>//</span> Normally, we'd need to take the cordb process lock around the IsNeutered check</span></td>
      </tr>
      <tr>
        <td id="L8475" data-line-number="8475"></td>
        <td id="LC8475">    <span><span>//</span> (and the code that follows).  And perhaps this is a good thing to do in the</span></td>
      </tr>
      <tr>
        <td id="L8476" data-line-number="8476"></td>
        <td id="LC8476">    <span><span>//</span> future.  But for now we're not for two reasons:</span></td>
      </tr>
      <tr>
        <td id="L8477" data-line-number="8477"></td>
        <td id="LC8477">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8478" data-line-number="8478"></td>
        <td id="LC8478">    <span><span>//</span> 1) It's scary.  We're in UnrecoverableError() for gosh sake.  I don't know all</span></td>
      </tr>
      <tr>
        <td id="L8479" data-line-number="8479"></td>
        <td id="LC8479">    <span><span>//</span> the possible bad states we can be in to get here.  Will taking the process lock</span></td>
      </tr>
      <tr>
        <td id="L8480" data-line-number="8480"></td>
        <td id="LC8480">    <span><span>//</span> have ordering issues?  Will the process lock even be valid to take here (or might</span></td>
      </tr>
      <tr>
        <td id="L8481" data-line-number="8481"></td>
        <td id="LC8481">    <span><span>//</span> we AV)?  Since this is error handling, we should probably be as light as we can</span></td>
      </tr>
      <tr>
        <td id="L8482" data-line-number="8482"></td>
        <td id="LC8482">    <span><span>//</span> not to cause more errors.</span></td>
      </tr>
      <tr>
        <td id="L8483" data-line-number="8483"></td>
        <td id="LC8483">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8484" data-line-number="8484"></td>
        <td id="LC8484">    <span><span>//</span> 2) It's unnecessary.  For the Watson dump I investigated that caused this fix in</span></td>
      </tr>
      <tr>
        <td id="L8485" data-line-number="8485"></td>
        <td id="LC8485">    <span><span>//</span> the first place, we already detached before entering UnrecoverableError()</span></td>
      </tr>
      <tr>
        <td id="L8486" data-line-number="8486"></td>
        <td id="LC8486">    <span><span>//</span> (indeed, the only reason we're in UnrecoverableError is that we already detached</span></td>
      </tr>
      <tr>
        <td id="L8487" data-line-number="8487"></td>
        <td id="LC8487">    <span><span>//</span> and that caused a prior API to fail).  Thus, there's no timing issue (in that</span></td>
      </tr>
      <tr>
        <td id="L8488" data-line-number="8488"></td>
        <td id="LC8488">    <span><span>//</span> case, anyway), wrt to entering UnrecoverableError() and detaching / neutering.</span></td>
      </tr>
      <tr>
        <td id="L8489" data-line-number="8489"></td>
        <td id="LC8489">    <span>if</span> (<span>IsNeutered</span>())</td>
      </tr>
      <tr>
        <td id="L8490" data-line-number="8490"></td>
        <td id="LC8490">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L8491" data-line-number="8491"></td>
        <td id="LC8491">
</td>
      </tr>
      <tr>
        <td id="L8492" data-line-number="8492"></td>
        <td id="LC8492">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L8493" data-line-number="8493"></td>
        <td id="LC8493">    <span><span>//</span> Ping our error trapping logic</span></td>
      </tr>
      <tr>
        <td id="L8494" data-line-number="8494"></td>
        <td id="LC8494">    HRESULT hrDummy;</td>
      </tr>
      <tr>
        <td id="L8495" data-line-number="8495"></td>
        <td id="LC8495">    hrDummy = <span>ErrWrapper</span>(errorHR);</td>
      </tr>
      <tr>
        <td id="L8496" data-line-number="8496"></td>
        <td id="LC8496">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L8497" data-line-number="8497"></td>
        <td id="LC8497">
</td>
      </tr>
      <tr>
        <td id="L8498" data-line-number="8498"></td>
        <td id="LC8498">    <span>if</span> (m_pShim == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8499" data-line-number="8499"></td>
        <td id="LC8499">    {</td>
      </tr>
      <tr>
        <td id="L8500" data-line-number="8500"></td>
        <td id="LC8500">        <span><span>//</span> @dbgtodo - , shim: Once everything is hoisted, we can remove</span></td>
      </tr>
      <tr>
        <td id="L8501" data-line-number="8501"></td>
        <td id="LC8501">        <span><span>//</span> this code.</span></td>
      </tr>
      <tr>
        <td id="L8502" data-line-number="8502"></td>
        <td id="LC8502">        <span><span>//</span> In the v3 case, we should never get an unrecoverable error. Instead, the HR should be propogated</span></td>
      </tr>
      <tr>
        <td id="L8503" data-line-number="8503"></td>
        <td id="LC8503">        <span><span>//</span> and returned at the top-level public API.</span></td>
      </tr>
      <tr>
        <td id="L8504" data-line-number="8504"></td>
        <td id="LC8504">        <span>_ASSERTE</span>(!<span><span>"</span>Unrecoverable error dispatched in V3 case.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L8505" data-line-number="8505"></td>
        <td id="LC8505">    }</td>
      </tr>
      <tr>
        <td id="L8506" data-line-number="8506"></td>
        <td id="LC8506">
</td>
      </tr>
      <tr>
        <td id="L8507" data-line-number="8507"></td>
        <td id="LC8507">    <span>CONSISTENCY_CHECK_MSGF</span>(<span>IsLegalFatalError</span>(errorHR), (<span><span>"</span>Unrecoverable internal error: hr=0x%08x!<span>"</span></span>, errorHR));</td>
      </tr>
      <tr>
        <td id="L8508" data-line-number="8508"></td>
        <td id="LC8508">
</td>
      </tr>
      <tr>
        <td id="L8509" data-line-number="8509"></td>
        <td id="LC8509">    <span>if</span> (!<span>IsLegalFatalError</span>(errorHR) || (errorHR != CORDBG_E_CANNOT_DEBUG_FIBER_PROCESS))</td>
      </tr>
      <tr>
        <td id="L8510" data-line-number="8510"></td>
        <td id="LC8510">    {</td>
      </tr>
      <tr>
        <td id="L8511" data-line-number="8511"></td>
        <td id="LC8511">        <span><span>//</span> This will throw everything into a Zombie state. The ATT_ macros will check this and fail immediately.</span></td>
      </tr>
      <tr>
        <td id="L8512" data-line-number="8512"></td>
        <td id="LC8512">        m_unrecoverableError = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L8513" data-line-number="8513"></td>
        <td id="LC8513">
</td>
      </tr>
      <tr>
        <td id="L8514" data-line-number="8514"></td>
        <td id="LC8514">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8515" data-line-number="8515"></td>
        <td id="LC8515">        <span><span>//</span> Mark the process as no longer synchronized.</span></td>
      </tr>
      <tr>
        <td id="L8516" data-line-number="8516"></td>
        <td id="LC8516">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8517" data-line-number="8517"></td>
        <td id="LC8517">        <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L8518" data-line-number="8518"></td>
        <td id="LC8518">        <span>SetSynchronized</span>(<span>false</span>);</td>
      </tr>
      <tr>
        <td id="L8519" data-line-number="8519"></td>
        <td id="LC8519">        <span>IncStopCount</span>();</td>
      </tr>
      <tr>
        <td id="L8520" data-line-number="8520"></td>
        <td id="LC8520">        <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L8521" data-line-number="8521"></td>
        <td id="LC8521">    }</td>
      </tr>
      <tr>
        <td id="L8522" data-line-number="8522"></td>
        <td id="LC8522">
</td>
      </tr>
      <tr>
        <td id="L8523" data-line-number="8523"></td>
        <td id="LC8523">    <span><span>//</span> Set the error flags in the process so that if parts of it are</span></td>
      </tr>
      <tr>
        <td id="L8524" data-line-number="8524"></td>
        <td id="LC8524">    <span><span>//</span> still alive, it will realize that its in this mode and do the</span></td>
      </tr>
      <tr>
        <td id="L8525" data-line-number="8525"></td>
        <td id="LC8525">    <span><span>//</span> right thing.</span></td>
      </tr>
      <tr>
        <td id="L8526" data-line-number="8526"></td>
        <td id="LC8526">    <span>if</span> (<span>GetDCB</span>() != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8527" data-line-number="8527"></td>
        <td id="LC8527">    {</td>
      </tr>
      <tr>
        <td id="L8528" data-line-number="8528"></td>
        <td id="LC8528">        <span>GetDCB</span>()-&gt;<span>m_errorHR</span> = errorHR;</td>
      </tr>
      <tr>
        <td id="L8529" data-line-number="8529"></td>
        <td id="LC8529">        <span>GetDCB</span>()-&gt;<span>m_errorCode</span> = errorCode;</td>
      </tr>
      <tr>
        <td id="L8530" data-line-number="8530"></td>
        <td id="LC8530">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L8531" data-line-number="8531"></td>
        <td id="LC8531">        {</td>
      </tr>
      <tr>
        <td id="L8532" data-line-number="8532"></td>
        <td id="LC8532">            <span>UpdateLeftSideDCBField</span>(&amp;(<span>GetDCB</span>()-&gt;<span>m_errorHR</span>), <span>sizeof</span>(<span>GetDCB</span>()-&gt;<span>m_errorHR</span>));</td>
      </tr>
      <tr>
        <td id="L8533" data-line-number="8533"></td>
        <td id="LC8533">            <span>UpdateLeftSideDCBField</span>(&amp;(<span>GetDCB</span>()-&gt;<span>m_errorCode</span>), <span>sizeof</span>(<span>GetDCB</span>()-&gt;<span>m_errorCode</span>));</td>
      </tr>
      <tr>
        <td id="L8534" data-line-number="8534"></td>
        <td id="LC8534">        }</td>
      </tr>
      <tr>
        <td id="L8535" data-line-number="8535"></td>
        <td id="LC8535">        EX_CATCH</td>
      </tr>
      <tr>
        <td id="L8536" data-line-number="8536"></td>
        <td id="LC8536">        {</td>
      </tr>
      <tr>
        <td id="L8537" data-line-number="8537"></td>
        <td id="LC8537">            <span>_ASSERTE</span>(!<span><span>"</span>Writing process memory failed, perhaps due to an unexpected disconnection from the target.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L8538" data-line-number="8538"></td>
        <td id="LC8538">        }</td>
      </tr>
      <tr>
        <td id="L8539" data-line-number="8539"></td>
        <td id="LC8539">        <span>EX_END_CATCH</span>(SwallowAllExceptions);</td>
      </tr>
      <tr>
        <td id="L8540" data-line-number="8540"></td>
        <td id="LC8540">    }</td>
      </tr>
      <tr>
        <td id="L8541" data-line-number="8541"></td>
        <td id="LC8541">
</td>
      </tr>
      <tr>
        <td id="L8542" data-line-number="8542"></td>
        <td id="LC8542">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8543" data-line-number="8543"></td>
        <td id="LC8543">    <span><span>//</span> Let the user know that we've hit an unrecoverable error.</span></td>
      </tr>
      <tr>
        <td id="L8544" data-line-number="8544"></td>
        <td id="LC8544">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8545" data-line-number="8545"></td>
        <td id="LC8545">    <span>if</span> (m_cordb-&gt;<span>m_managedCallback</span>)</td>
      </tr>
      <tr>
        <td id="L8546" data-line-number="8546"></td>
        <td id="LC8546">    {</td>
      </tr>
      <tr>
        <td id="L8547" data-line-number="8547"></td>
        <td id="LC8547">        <span><span>//</span> We are about to send DebuggerError call back. The state of RS is undefined.</span></td>
      </tr>
      <tr>
        <td id="L8548" data-line-number="8548"></td>
        <td id="LC8548">        <span><span>//</span> So we use the special Public Callback. We may be holding locks and stuff.</span></td>
      </tr>
      <tr>
        <td id="L8549" data-line-number="8549"></td>
        <td id="LC8549">        <span><span>//</span> We may also be deeply nested within the RS.</span></td>
      </tr>
      <tr>
        <td id="L8550" data-line-number="8550"></td>
        <td id="LC8550">        <span>PUBLIC_CALLBACK_IN_THIS_SCOPE_DEBUGGERERROR</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8551" data-line-number="8551"></td>
        <td id="LC8551">        m_cordb-&gt;<span>m_managedCallback</span>-&gt;<span>DebuggerError</span>((ICorDebugProcess*) <span>this</span>,</td>
      </tr>
      <tr>
        <td id="L8552" data-line-number="8552"></td>
        <td id="LC8552">                                                  errorHR,</td>
      </tr>
      <tr>
        <td id="L8553" data-line-number="8553"></td>
        <td id="LC8553">                                                  errorCode);</td>
      </tr>
      <tr>
        <td id="L8554" data-line-number="8554"></td>
        <td id="LC8554">    }</td>
      </tr>
      <tr>
        <td id="L8555" data-line-number="8555"></td>
        <td id="LC8555">}</td>
      </tr>
      <tr>
        <td id="L8556" data-line-number="8556"></td>
        <td id="LC8556">
</td>
      </tr>
      <tr>
        <td id="L8557" data-line-number="8557"></td>
        <td id="LC8557">
</td>
      </tr>
      <tr>
        <td id="L8558" data-line-number="8558"></td>
        <td id="LC8558">HRESULT <span>CordbProcess::CheckForUnrecoverableError</span>()</td>
      </tr>
      <tr>
        <td id="L8559" data-line-number="8559"></td>
        <td id="LC8559">{</td>
      </tr>
      <tr>
        <td id="L8560" data-line-number="8560"></td>
        <td id="LC8560">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L8561" data-line-number="8561"></td>
        <td id="LC8561">
</td>
      </tr>
      <tr>
        <td id="L8562" data-line-number="8562"></td>
        <td id="LC8562">    <span>if</span> (<span>GetDCB</span>() != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8563" data-line-number="8563"></td>
        <td id="LC8563">    {</td>
      </tr>
      <tr>
        <td id="L8564" data-line-number="8564"></td>
        <td id="LC8564">        <span><span>//</span> be sure we have the latest information</span></td>
      </tr>
      <tr>
        <td id="L8565" data-line-number="8565"></td>
        <td id="LC8565">        <span>UpdateRightSideDCB</span>();</td>
      </tr>
      <tr>
        <td id="L8566" data-line-number="8566"></td>
        <td id="LC8566">
</td>
      </tr>
      <tr>
        <td id="L8567" data-line-number="8567"></td>
        <td id="LC8567">        <span>if</span> (<span>GetDCB</span>()-&gt;<span>m_errorHR</span> != S_OK)</td>
      </tr>
      <tr>
        <td id="L8568" data-line-number="8568"></td>
        <td id="LC8568">        {</td>
      </tr>
      <tr>
        <td id="L8569" data-line-number="8569"></td>
        <td id="LC8569">            <span>UnrecoverableError</span>(<span>GetDCB</span>()-&gt;<span>m_errorHR</span>,</td>
      </tr>
      <tr>
        <td id="L8570" data-line-number="8570"></td>
        <td id="LC8570">                               <span>GetDCB</span>()-&gt;<span>m_errorCode</span>,</td>
      </tr>
      <tr>
        <td id="L8571" data-line-number="8571"></td>
        <td id="LC8571">                           __FILE__, __LINE__);</td>
      </tr>
      <tr>
        <td id="L8572" data-line-number="8572"></td>
        <td id="LC8572">
</td>
      </tr>
      <tr>
        <td id="L8573" data-line-number="8573"></td>
        <td id="LC8573">            hr = <span>GetDCB</span>()-&gt;<span>m_errorHR</span>;</td>
      </tr>
      <tr>
        <td id="L8574" data-line-number="8574"></td>
        <td id="LC8574">        }</td>
      </tr>
      <tr>
        <td id="L8575" data-line-number="8575"></td>
        <td id="LC8575">    }</td>
      </tr>
      <tr>
        <td id="L8576" data-line-number="8576"></td>
        <td id="LC8576">
</td>
      </tr>
      <tr>
        <td id="L8577" data-line-number="8577"></td>
        <td id="LC8577">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L8578" data-line-number="8578"></td>
        <td id="LC8578">}</td>
      </tr>
      <tr>
        <td id="L8579" data-line-number="8579"></td>
        <td id="LC8579">
</td>
      </tr>
      <tr>
        <td id="L8580" data-line-number="8580"></td>
        <td id="LC8580">
</td>
      </tr>
      <tr>
        <td id="L8581" data-line-number="8581"></td>
        <td id="LC8581"><span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L8582" data-line-number="8582"></td>
        <td id="LC8582"><span> * EnableLogMessages enables/disables sending of log messages to the</span></td>
      </tr>
      <tr>
        <td id="L8583" data-line-number="8583"></td>
        <td id="LC8583"><span> * debugger for logging.</span></td>
      </tr>
      <tr>
        <td id="L8584" data-line-number="8584"></td>
        <td id="LC8584"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L8585" data-line-number="8585"></td>
        <td id="LC8585">HRESULT <span>CordbProcess::EnableLogMessages</span>(BOOL <span>fOnOff</span>)</td>
      </tr>
      <tr>
        <td id="L8586" data-line-number="8586"></td>
        <td id="LC8586">{</td>
      </tr>
      <tr>
        <td id="L8587" data-line-number="8587"></td>
        <td id="LC8587">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8588" data-line-number="8588"></td>
        <td id="LC8588">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8589" data-line-number="8589"></td>
        <td id="LC8589">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8590" data-line-number="8590"></td>
        <td id="LC8590">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L8591" data-line-number="8591"></td>
        <td id="LC8591">
</td>
      </tr>
      <tr>
        <td id="L8592" data-line-number="8592"></td>
        <td id="LC8592">    DebuggerIPCEvent *event = (DebuggerIPCEvent*) <span>_alloca</span>(CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L8593" data-line-number="8593"></td>
        <td id="LC8593">    <span>InitIPCEvent</span>(event, DB_IPCE_ENABLE_LOG_MESSAGES, <span>false</span>, <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L8594" data-line-number="8594"></td>
        <td id="LC8594">    event-&gt;<span>LogSwitchSettingMessage</span>.<span>iLevel</span> = (<span>int</span>)<span>fOnOff</span>;</td>
      </tr>
      <tr>
        <td id="L8595" data-line-number="8595"></td>
        <td id="LC8595">
</td>
      </tr>
      <tr>
        <td id="L8596" data-line-number="8596"></td>
        <td id="LC8596">    hr = m_cordb-&gt;<span>SendIPCEvent</span>(<span>this</span>, event, CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L8597" data-line-number="8597"></td>
        <td id="LC8597">    hr = <span>WORST_HR</span>(hr, event-&gt;<span>hr</span>);</td>
      </tr>
      <tr>
        <td id="L8598" data-line-number="8598"></td>
        <td id="LC8598">
</td>
      </tr>
      <tr>
        <td id="L8599" data-line-number="8599"></td>
        <td id="LC8599">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>[%x] CP::EnableLogMessages: EnableLogMessages=%d sent.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L8600" data-line-number="8600"></td>
        <td id="LC8600">         <span>GetCurrentThreadId</span>(), <span>fOnOff</span>));</td>
      </tr>
      <tr>
        <td id="L8601" data-line-number="8601"></td>
        <td id="LC8601">
</td>
      </tr>
      <tr>
        <td id="L8602" data-line-number="8602"></td>
        <td id="LC8602">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L8603" data-line-number="8603"></td>
        <td id="LC8603">}</td>
      </tr>
      <tr>
        <td id="L8604" data-line-number="8604"></td>
        <td id="LC8604">
</td>
      </tr>
      <tr>
        <td id="L8605" data-line-number="8605"></td>
        <td id="LC8605"><span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L8606" data-line-number="8606"></td>
        <td id="LC8606"><span> * ModifyLogSwitch modifies the specified switch's severity level.</span></td>
      </tr>
      <tr>
        <td id="L8607" data-line-number="8607"></td>
        <td id="LC8607"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L8608" data-line-number="8608"></td>
        <td id="LC8608">COM_METHOD <span>CordbProcess::ModifyLogSwitch</span>(__in_z WCHAR *pLogSwitchName, LONG lLevel)</td>
      </tr>
      <tr>
        <td id="L8609" data-line-number="8609"></td>
        <td id="LC8609">{</td>
      </tr>
      <tr>
        <td id="L8610" data-line-number="8610"></td>
        <td id="LC8610">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8611" data-line-number="8611"></td>
        <td id="LC8611">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8612" data-line-number="8612"></td>
        <td id="LC8612">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8613" data-line-number="8613"></td>
        <td id="LC8613">
</td>
      </tr>
      <tr>
        <td id="L8614" data-line-number="8614"></td>
        <td id="LC8614">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L8615" data-line-number="8615"></td>
        <td id="LC8615">
</td>
      </tr>
      <tr>
        <td id="L8616" data-line-number="8616"></td>
        <td id="LC8616">    <span>_ASSERTE</span> (pLogSwitchName != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8617" data-line-number="8617"></td>
        <td id="LC8617">
</td>
      </tr>
      <tr>
        <td id="L8618" data-line-number="8618"></td>
        <td id="LC8618">    DebuggerIPCEvent *event = (DebuggerIPCEvent*) <span>_alloca</span>(CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L8619" data-line-number="8619"></td>
        <td id="LC8619">    <span>InitIPCEvent</span>(event, DB_IPCE_MODIFY_LOGSWITCH, <span>false</span>, <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L8620" data-line-number="8620"></td>
        <td id="LC8620">    event-&gt;<span>LogSwitchSettingMessage</span>.<span>iLevel</span> = lLevel;</td>
      </tr>
      <tr>
        <td id="L8621" data-line-number="8621"></td>
        <td id="LC8621">    event-&gt;<span>LogSwitchSettingMessage</span>.<span>szSwitchName</span>.<span>SetStringTruncate</span>(pLogSwitchName);</td>
      </tr>
      <tr>
        <td id="L8622" data-line-number="8622"></td>
        <td id="LC8622">
</td>
      </tr>
      <tr>
        <td id="L8623" data-line-number="8623"></td>
        <td id="LC8623">    hr = m_cordb-&gt;<span>SendIPCEvent</span>(<span>this</span>, event, CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L8624" data-line-number="8624"></td>
        <td id="LC8624">    hr = <span>WORST_HR</span>(hr, event-&gt;<span>hr</span>);</td>
      </tr>
      <tr>
        <td id="L8625" data-line-number="8625"></td>
        <td id="LC8625">
</td>
      </tr>
      <tr>
        <td id="L8626" data-line-number="8626"></td>
        <td id="LC8626">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>[%x] CP::ModifyLogSwitch: ModifyLogSwitch sent.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L8627" data-line-number="8627"></td>
        <td id="LC8627">         <span>GetCurrentThreadId</span>()));</td>
      </tr>
      <tr>
        <td id="L8628" data-line-number="8628"></td>
        <td id="LC8628">
</td>
      </tr>
      <tr>
        <td id="L8629" data-line-number="8629"></td>
        <td id="LC8629">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L8630" data-line-number="8630"></td>
        <td id="LC8630">}</td>
      </tr>
      <tr>
        <td id="L8631" data-line-number="8631"></td>
        <td id="LC8631">
</td>
      </tr>
      <tr>
        <td id="L8632" data-line-number="8632"></td>
        <td id="LC8632"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8633" data-line-number="8633"></td>
        <td id="LC8633"><span><span>//</span> Writes a buffer from the target and performs checks similar to SafeWriteStruct</span></td>
      </tr>
      <tr>
        <td id="L8634" data-line-number="8634"></td>
        <td id="LC8634"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8635" data-line-number="8635"></td>
        <td id="LC8635"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L8636" data-line-number="8636"></td>
        <td id="LC8636"><span><span>//</span>    tb - TargetBuffer which represents the target memory we want to write to</span></td>
      </tr>
      <tr>
        <td id="L8637" data-line-number="8637"></td>
        <td id="LC8637"><span><span>//</span>    pLocalBuffer - local pointer into source buffer</span></td>
      </tr>
      <tr>
        <td id="L8638" data-line-number="8638"></td>
        <td id="LC8638"><span><span>//</span>    cbSize - the size of local buffer</span></td>
      </tr>
      <tr>
        <td id="L8639" data-line-number="8639"></td>
        <td id="LC8639"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8640" data-line-number="8640"></td>
        <td id="LC8640"><span><span>//</span> Exceptions</span></td>
      </tr>
      <tr>
        <td id="L8641" data-line-number="8641"></td>
        <td id="LC8641"><span><span>//</span>    On error throws the result of WriteVirtual unless a short write is performed,</span></td>
      </tr>
      <tr>
        <td id="L8642" data-line-number="8642"></td>
        <td id="LC8642"><span><span>//</span>    in which case throws ERROR_PARTIAL_COPY</span></td>
      </tr>
      <tr>
        <td id="L8643" data-line-number="8643"></td>
        <td id="LC8643"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8644" data-line-number="8644"></td>
        <td id="LC8644"><span>void</span> <span>CordbProcess::SafeWriteBuffer</span>(TargetBuffer tb,</td>
      </tr>
      <tr>
        <td id="L8645" data-line-number="8645"></td>
        <td id="LC8645">                                   <span>const</span> BYTE * pLocalBuffer)</td>
      </tr>
      <tr>
        <td id="L8646" data-line-number="8646"></td>
        <td id="LC8646">{</td>
      </tr>
      <tr>
        <td id="L8647" data-line-number="8647"></td>
        <td id="LC8647">    <span>_ASSERTE</span>(m_pMutableDataTarget != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8648" data-line-number="8648"></td>
        <td id="LC8648">    HRESULT hr = m_pMutableDataTarget-&gt;<span>WriteVirtual</span>(tb.<span>pAddress</span>,</td>
      </tr>
      <tr>
        <td id="L8649" data-line-number="8649"></td>
        <td id="LC8649">        pLocalBuffer,</td>
      </tr>
      <tr>
        <td id="L8650" data-line-number="8650"></td>
        <td id="LC8650">        tb.<span>cbSize</span>);</td>
      </tr>
      <tr>
        <td id="L8651" data-line-number="8651"></td>
        <td id="LC8651">    <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L8652" data-line-number="8652"></td>
        <td id="LC8652">}</td>
      </tr>
      <tr>
        <td id="L8653" data-line-number="8653"></td>
        <td id="LC8653">
</td>
      </tr>
      <tr>
        <td id="L8654" data-line-number="8654"></td>
        <td id="LC8654"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8655" data-line-number="8655"></td>
        <td id="LC8655"><span><span>//</span> Reads a buffer from the target and performs checks similar to SafeWriteStruct</span></td>
      </tr>
      <tr>
        <td id="L8656" data-line-number="8656"></td>
        <td id="LC8656"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8657" data-line-number="8657"></td>
        <td id="LC8657"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L8658" data-line-number="8658"></td>
        <td id="LC8658"><span><span>//</span>    tb - TargetBuffer which represents the target memory to read from</span></td>
      </tr>
      <tr>
        <td id="L8659" data-line-number="8659"></td>
        <td id="LC8659"><span><span>//</span>    pLocalBuffer - local pointer into source buffer</span></td>
      </tr>
      <tr>
        <td id="L8660" data-line-number="8660"></td>
        <td id="LC8660"><span><span>//</span>    cbSize - the size of the remote buffer</span></td>
      </tr>
      <tr>
        <td id="L8661" data-line-number="8661"></td>
        <td id="LC8661"><span><span>//</span>    throwOnError - determines whether the function throws exceptions or returns HRESULTs</span></td>
      </tr>
      <tr>
        <td id="L8662" data-line-number="8662"></td>
        <td id="LC8662"><span><span>//</span>                   in failure cases</span></td>
      </tr>
      <tr>
        <td id="L8663" data-line-number="8663"></td>
        <td id="LC8663"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8664" data-line-number="8664"></td>
        <td id="LC8664"><span><span>//</span> Exceptions:</span></td>
      </tr>
      <tr>
        <td id="L8665" data-line-number="8665"></td>
        <td id="LC8665"><span><span>//</span>    If throwOnError is TRUE</span></td>
      </tr>
      <tr>
        <td id="L8666" data-line-number="8666"></td>
        <td id="LC8666"><span><span>//</span>      On error always throws the special CORDBG_E_READVIRTUAL_FAILURE, unless a short write is performed</span></td>
      </tr>
      <tr>
        <td id="L8667" data-line-number="8667"></td>
        <td id="LC8667"><span><span>//</span>      in which case throws ERROR_PARTIAL_COPY</span></td>
      </tr>
      <tr>
        <td id="L8668" data-line-number="8668"></td>
        <td id="LC8668"><span><span>//</span>   If throwOnError is FALSE</span></td>
      </tr>
      <tr>
        <td id="L8669" data-line-number="8669"></td>
        <td id="LC8669"><span><span>//</span>      No exceptions are thrown, and instead the same error codes are returned as HRESULTs</span></td>
      </tr>
      <tr>
        <td id="L8670" data-line-number="8670"></td>
        <td id="LC8670"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8671" data-line-number="8671"></td>
        <td id="LC8671">HRESULT <span>CordbProcess::SafeReadBuffer</span>(TargetBuffer tb, BYTE * pLocalBuffer, BOOL throwOnError)</td>
      </tr>
      <tr>
        <td id="L8672" data-line-number="8672"></td>
        <td id="LC8672">{</td>
      </tr>
      <tr>
        <td id="L8673" data-line-number="8673"></td>
        <td id="LC8673">    ULONG32 cbRead;</td>
      </tr>
      <tr>
        <td id="L8674" data-line-number="8674"></td>
        <td id="LC8674">    HRESULT hr = m_pDACDataTarget-&gt;<span>ReadVirtual</span>(tb.<span>pAddress</span>,</td>
      </tr>
      <tr>
        <td id="L8675" data-line-number="8675"></td>
        <td id="LC8675">        pLocalBuffer,</td>
      </tr>
      <tr>
        <td id="L8676" data-line-number="8676"></td>
        <td id="LC8676">        tb.<span>cbSize</span>,</td>
      </tr>
      <tr>
        <td id="L8677" data-line-number="8677"></td>
        <td id="LC8677">        &amp;cbRead);</td>
      </tr>
      <tr>
        <td id="L8678" data-line-number="8678"></td>
        <td id="LC8678">
</td>
      </tr>
      <tr>
        <td id="L8679" data-line-number="8679"></td>
        <td id="LC8679">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L8680" data-line-number="8680"></td>
        <td id="LC8680">    {</td>
      </tr>
      <tr>
        <td id="L8681" data-line-number="8681"></td>
        <td id="LC8681">        <span>if</span> (throwOnError)</td>
      </tr>
      <tr>
        <td id="L8682" data-line-number="8682"></td>
        <td id="LC8682">            <span>ThrowHR</span>(CORDBG_E_READVIRTUAL_FAILURE);</td>
      </tr>
      <tr>
        <td id="L8683" data-line-number="8683"></td>
        <td id="LC8683">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L8684" data-line-number="8684"></td>
        <td id="LC8684">            <span>return</span> CORDBG_E_READVIRTUAL_FAILURE;</td>
      </tr>
      <tr>
        <td id="L8685" data-line-number="8685"></td>
        <td id="LC8685">    }</td>
      </tr>
      <tr>
        <td id="L8686" data-line-number="8686"></td>
        <td id="LC8686">
</td>
      </tr>
      <tr>
        <td id="L8687" data-line-number="8687"></td>
        <td id="LC8687">    <span>if</span> (cbRead != tb.<span>cbSize</span>)</td>
      </tr>
      <tr>
        <td id="L8688" data-line-number="8688"></td>
        <td id="LC8688">    {</td>
      </tr>
      <tr>
        <td id="L8689" data-line-number="8689"></td>
        <td id="LC8689">        <span>if</span> (throwOnError)</td>
      </tr>
      <tr>
        <td id="L8690" data-line-number="8690"></td>
        <td id="LC8690">            <span>ThrowWin32</span>(ERROR_PARTIAL_COPY);</td>
      </tr>
      <tr>
        <td id="L8691" data-line-number="8691"></td>
        <td id="LC8691">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L8692" data-line-number="8692"></td>
        <td id="LC8692">            <span>return</span> <span>HRESULT_FROM_WIN32</span>(ERROR_PARTIAL_COPY);</td>
      </tr>
      <tr>
        <td id="L8693" data-line-number="8693"></td>
        <td id="LC8693">    }</td>
      </tr>
      <tr>
        <td id="L8694" data-line-number="8694"></td>
        <td id="LC8694">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L8695" data-line-number="8695"></td>
        <td id="LC8695">}</td>
      </tr>
      <tr>
        <td id="L8696" data-line-number="8696"></td>
        <td id="LC8696">
</td>
      </tr>
      <tr>
        <td id="L8697" data-line-number="8697"></td>
        <td id="LC8697">
</td>
      </tr>
      <tr>
        <td id="L8698" data-line-number="8698"></td>
        <td id="LC8698"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8699" data-line-number="8699"></td>
        <td id="LC8699"><span><span>//</span> Lookup or create an appdomain.</span></td>
      </tr>
      <tr>
        <td id="L8700" data-line-number="8700"></td>
        <td id="LC8700"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8701" data-line-number="8701"></td>
        <td id="LC8701"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L8702" data-line-number="8702"></td>
        <td id="LC8702"><span><span>//</span>     vmAppDomain - CLR appdomain to lookup</span></td>
      </tr>
      <tr>
        <td id="L8703" data-line-number="8703"></td>
        <td id="LC8703"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8704" data-line-number="8704"></td>
        <td id="LC8704"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L8705" data-line-number="8705"></td>
        <td id="LC8705"><span><span>//</span>     Instance of CordbAppDomain for the given appdomain. This is a cached instance.</span></td>
      </tr>
      <tr>
        <td id="L8706" data-line-number="8706"></td>
        <td id="LC8706"><span><span>//</span>     If the CordbAppDomain does not yet exist, it will be created and added to the cache.</span></td>
      </tr>
      <tr>
        <td id="L8707" data-line-number="8707"></td>
        <td id="LC8707"><span><span>//</span>     Never returns NULL. Throw on error.</span></td>
      </tr>
      <tr>
        <td id="L8708" data-line-number="8708"></td>
        <td id="LC8708">CordbAppDomain * <span>CordbProcess::LookupOrCreateAppDomain</span>(VMPTR_AppDomain vmAppDomain)</td>
      </tr>
      <tr>
        <td id="L8709" data-line-number="8709"></td>
        <td id="LC8709">{</td>
      </tr>
      <tr>
        <td id="L8710" data-line-number="8710"></td>
        <td id="LC8710">    CordbAppDomain * pAppDomain = m_appDomains.<span>GetBase</span>(<span>VmPtrToCookie</span>(vmAppDomain));</td>
      </tr>
      <tr>
        <td id="L8711" data-line-number="8711"></td>
        <td id="LC8711">    <span>if</span> (pAppDomain != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8712" data-line-number="8712"></td>
        <td id="LC8712">    {</td>
      </tr>
      <tr>
        <td id="L8713" data-line-number="8713"></td>
        <td id="LC8713">        <span>return</span> pAppDomain;</td>
      </tr>
      <tr>
        <td id="L8714" data-line-number="8714"></td>
        <td id="LC8714">    }</td>
      </tr>
      <tr>
        <td id="L8715" data-line-number="8715"></td>
        <td id="LC8715">    <span>return</span> <span>CacheAppDomain</span>(vmAppDomain);</td>
      </tr>
      <tr>
        <td id="L8716" data-line-number="8716"></td>
        <td id="LC8716">}</td>
      </tr>
      <tr>
        <td id="L8717" data-line-number="8717"></td>
        <td id="LC8717">
</td>
      </tr>
      <tr>
        <td id="L8718" data-line-number="8718"></td>
        <td id="LC8718">CordbAppDomain * <span>CordbProcess::GetSharedAppDomain</span>()</td>
      </tr>
      <tr>
        <td id="L8719" data-line-number="8719"></td>
        <td id="LC8719">{</td>
      </tr>
      <tr>
        <td id="L8720" data-line-number="8720"></td>
        <td id="LC8720">    <span>if</span> (m_sharedAppDomain == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8721" data-line-number="8721"></td>
        <td id="LC8721">    {</td>
      </tr>
      <tr>
        <td id="L8722" data-line-number="8722"></td>
        <td id="LC8722">        CordbAppDomain *pAD = <span>new</span> <span>CordbAppDomain</span>(<span>this</span>, <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L8723" data-line-number="8723"></td>
        <td id="LC8723">        <span>if</span> (InterlockedCompareExchangeT&lt;CordbAppDomain*&gt;(&amp;m_sharedAppDomain, pAD, <span>NULL</span>) != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8724" data-line-number="8724"></td>
        <td id="LC8724">        {</td>
      </tr>
      <tr>
        <td id="L8725" data-line-number="8725"></td>
        <td id="LC8725">            <span>delete</span> pAD;</td>
      </tr>
      <tr>
        <td id="L8726" data-line-number="8726"></td>
        <td id="LC8726">        }</td>
      </tr>
      <tr>
        <td id="L8727" data-line-number="8727"></td>
        <td id="LC8727">		m_sharedAppDomain-&gt;<span>InternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L8728" data-line-number="8728"></td>
        <td id="LC8728">    }</td>
      </tr>
      <tr>
        <td id="L8729" data-line-number="8729"></td>
        <td id="LC8729">
</td>
      </tr>
      <tr>
        <td id="L8730" data-line-number="8730"></td>
        <td id="LC8730">    <span>return</span> m_sharedAppDomain;</td>
      </tr>
      <tr>
        <td id="L8731" data-line-number="8731"></td>
        <td id="LC8731">}</td>
      </tr>
      <tr>
        <td id="L8732" data-line-number="8732"></td>
        <td id="LC8732">
</td>
      </tr>
      <tr>
        <td id="L8733" data-line-number="8733"></td>
        <td id="LC8733"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8734" data-line-number="8734"></td>
        <td id="LC8734"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8735" data-line-number="8735"></td>
        <td id="LC8735"><span><span>//</span> Add a new appdomain to the cache.</span></td>
      </tr>
      <tr>
        <td id="L8736" data-line-number="8736"></td>
        <td id="LC8736"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8737" data-line-number="8737"></td>
        <td id="LC8737"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L8738" data-line-number="8738"></td>
        <td id="LC8738"><span><span>//</span>      vmAppDomain - appdomain to add.</span></td>
      </tr>
      <tr>
        <td id="L8739" data-line-number="8739"></td>
        <td id="LC8739"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8740" data-line-number="8740"></td>
        <td id="LC8740"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L8741" data-line-number="8741"></td>
        <td id="LC8741"><span><span>//</span>    Pointer to newly created appdomain, which should be the normal case.</span></td>
      </tr>
      <tr>
        <td id="L8742" data-line-number="8742"></td>
        <td id="LC8742"><span><span>//</span>    Throws on failure. Never returns null.</span></td>
      </tr>
      <tr>
        <td id="L8743" data-line-number="8743"></td>
        <td id="LC8743"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8744" data-line-number="8744"></td>
        <td id="LC8744"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L8745" data-line-number="8745"></td>
        <td id="LC8745"><span><span>//</span>    Caller ensure the appdomain is not already cached.</span></td>
      </tr>
      <tr>
        <td id="L8746" data-line-number="8746"></td>
        <td id="LC8746"><span><span>//</span>    Caller should have stop-go lock, which provides thread-safety.</span></td>
      </tr>
      <tr>
        <td id="L8747" data-line-number="8747"></td>
        <td id="LC8747"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8748" data-line-number="8748"></td>
        <td id="LC8748"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L8749" data-line-number="8749"></td>
        <td id="LC8749"><span><span>//</span>    This sets unrecoverable error on failure.</span></td>
      </tr>
      <tr>
        <td id="L8750" data-line-number="8750"></td>
        <td id="LC8750"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8751" data-line-number="8751"></td>
        <td id="LC8751"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8752" data-line-number="8752"></td>
        <td id="LC8752">CordbAppDomain * <span>CordbProcess::CacheAppDomain</span>(VMPTR_AppDomain vmAppDomain)</td>
      </tr>
      <tr>
        <td id="L8753" data-line-number="8753"></td>
        <td id="LC8753">{</td>
      </tr>
      <tr>
        <td id="L8754" data-line-number="8754"></td>
        <td id="LC8754">    <span>INTERNAL_API_ENTRY</span>(<span>GetProcess</span>());</td>
      </tr>
      <tr>
        <td id="L8755" data-line-number="8755"></td>
        <td id="LC8755">
</td>
      </tr>
      <tr>
        <td id="L8756" data-line-number="8756"></td>
        <td id="LC8756">    <span>_ASSERTE</span>(<span>GetProcessLock</span>()-&gt;<span>HasLock</span>());</td>
      </tr>
      <tr>
        <td id="L8757" data-line-number="8757"></td>
        <td id="LC8757">
</td>
      </tr>
      <tr>
        <td id="L8758" data-line-number="8758"></td>
        <td id="LC8758">    RSInitHolder&lt;CordbAppDomain&gt; pAppDomain;</td>
      </tr>
      <tr>
        <td id="L8759" data-line-number="8759"></td>
        <td id="LC8759">    pAppDomain.<span>Assign</span>(<span>new</span> <span>CordbAppDomain</span>(<span>this</span>, vmAppDomain));  <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L8760" data-line-number="8760"></td>
        <td id="LC8760">
</td>
      </tr>
      <tr>
        <td id="L8761" data-line-number="8761"></td>
        <td id="LC8761">    <span><span>//</span> Add to the hash. This will addref the pAppDomain.</span></td>
      </tr>
      <tr>
        <td id="L8762" data-line-number="8762"></td>
        <td id="LC8762">    <span><span>//</span> Caller ensures we're not already cached.</span></td>
      </tr>
      <tr>
        <td id="L8763" data-line-number="8763"></td>
        <td id="LC8763">    <span><span>//</span> The cache will take ownership.</span></td>
      </tr>
      <tr>
        <td id="L8764" data-line-number="8764"></td>
        <td id="LC8764">    m_appDomains.<span>AddBaseOrThrow</span>(pAppDomain);</td>
      </tr>
      <tr>
        <td id="L8765" data-line-number="8765"></td>
        <td id="LC8765">
</td>
      </tr>
      <tr>
        <td id="L8766" data-line-number="8766"></td>
        <td id="LC8766">    <span><span>//</span> see if this is the default AppDomain</span></td>
      </tr>
      <tr>
        <td id="L8767" data-line-number="8767"></td>
        <td id="LC8767">    IDacDbiInterface * pDac = m_pProcess-&gt;<span>GetDAC</span>();</td>
      </tr>
      <tr>
        <td id="L8768" data-line-number="8768"></td>
        <td id="LC8768">    BOOL               <span>fIsDefaultDomain</span> = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L8769" data-line-number="8769"></td>
        <td id="LC8769">
</td>
      </tr>
      <tr>
        <td id="L8770" data-line-number="8770"></td>
        <td id="LC8770">    <span>fIsDefaultDomain</span> = pDac-&gt;<span>IsDefaultDomain</span>(vmAppDomain); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L8771" data-line-number="8771"></td>
        <td id="LC8771">
</td>
      </tr>
      <tr>
        <td id="L8772" data-line-number="8772"></td>
        <td id="LC8772">    <span>if</span> (<span>fIsDefaultDomain</span>)</td>
      </tr>
      <tr>
        <td id="L8773" data-line-number="8773"></td>
        <td id="LC8773">    {</td>
      </tr>
      <tr>
        <td id="L8774" data-line-number="8774"></td>
        <td id="LC8774">        <span><span>//</span> If this assert fires, then it likely means the target is corrupted.</span></td>
      </tr>
      <tr>
        <td id="L8775" data-line-number="8775"></td>
        <td id="LC8775">        <span>TargetConsistencyCheck</span>(m_pDefaultAppDomain == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8776" data-line-number="8776"></td>
        <td id="LC8776">        m_pDefaultAppDomain = pAppDomain;</td>
      </tr>
      <tr>
        <td id="L8777" data-line-number="8777"></td>
        <td id="LC8777">    }</td>
      </tr>
      <tr>
        <td id="L8778" data-line-number="8778"></td>
        <td id="LC8778">
</td>
      </tr>
      <tr>
        <td id="L8779" data-line-number="8779"></td>
        <td id="LC8779">    CordbAppDomain * pReturn = pAppDomain;</td>
      </tr>
      <tr>
        <td id="L8780" data-line-number="8780"></td>
        <td id="LC8780">    pAppDomain.<span>ClearAndMarkDontNeuter</span>();</td>
      </tr>
      <tr>
        <td id="L8781" data-line-number="8781"></td>
        <td id="LC8781">
</td>
      </tr>
      <tr>
        <td id="L8782" data-line-number="8782"></td>
        <td id="LC8782">    <span>_ASSERTE</span>(pReturn != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L8783" data-line-number="8783"></td>
        <td id="LC8783">    <span>return</span> pReturn;</td>
      </tr>
      <tr>
        <td id="L8784" data-line-number="8784"></td>
        <td id="LC8784">}</td>
      </tr>
      <tr>
        <td id="L8785" data-line-number="8785"></td>
        <td id="LC8785">
</td>
      </tr>
      <tr>
        <td id="L8786" data-line-number="8786"></td>
        <td id="LC8786"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8787" data-line-number="8787"></td>
        <td id="LC8787"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8788" data-line-number="8788"></td>
        <td id="LC8788"><span><span>//</span> Callback for Appdomain enumeration.</span></td>
      </tr>
      <tr>
        <td id="L8789" data-line-number="8789"></td>
        <td id="LC8789"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8790" data-line-number="8790"></td>
        <td id="LC8790"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L8791" data-line-number="8791"></td>
        <td id="LC8791"><span><span>//</span>      vmAppDomain - new appdomain to add to enumeration</span></td>
      </tr>
      <tr>
        <td id="L8792" data-line-number="8792"></td>
        <td id="LC8792"><span><span>//</span>      pUserData - data passed with callback (a 'this' ptr for CordbProcess)</span></td>
      </tr>
      <tr>
        <td id="L8793" data-line-number="8793"></td>
        <td id="LC8793"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8794" data-line-number="8794"></td>
        <td id="LC8794"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8795" data-line-number="8795"></td>
        <td id="LC8795"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L8796" data-line-number="8796"></td>
        <td id="LC8796"><span><span>//</span>    Invoked as callback from code:CordbProcess::PrepopulateAppDomains</span></td>
      </tr>
      <tr>
        <td id="L8797" data-line-number="8797"></td>
        <td id="LC8797"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8798" data-line-number="8798"></td>
        <td id="LC8798"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8799" data-line-number="8799"></td>
        <td id="LC8799"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8800" data-line-number="8800"></td>
        <td id="LC8800">
</td>
      </tr>
      <tr>
        <td id="L8801" data-line-number="8801"></td>
        <td id="LC8801"><span><span>//</span> static</span></td>
      </tr>
      <tr>
        <td id="L8802" data-line-number="8802"></td>
        <td id="LC8802"><span>void</span> <span>CordbProcess::AppDomainEnumerationCallback</span>(VMPTR_AppDomain vmAppDomain, <span>void</span> * pUserData)</td>
      </tr>
      <tr>
        <td id="L8803" data-line-number="8803"></td>
        <td id="LC8803">{</td>
      </tr>
      <tr>
        <td id="L8804" data-line-number="8804"></td>
        <td id="LC8804">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L8805" data-line-number="8805"></td>
        <td id="LC8805">    {</td>
      </tr>
      <tr>
        <td id="L8806" data-line-number="8806"></td>
        <td id="LC8806">        THROWS;</td>
      </tr>
      <tr>
        <td id="L8807" data-line-number="8807"></td>
        <td id="LC8807">    }</td>
      </tr>
      <tr>
        <td id="L8808" data-line-number="8808"></td>
        <td id="LC8808">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L8809" data-line-number="8809"></td>
        <td id="LC8809">
</td>
      </tr>
      <tr>
        <td id="L8810" data-line-number="8810"></td>
        <td id="LC8810">    CordbProcess * pProcess = <span>static_cast</span>&lt;CordbProcess *&gt; (pUserData);</td>
      </tr>
      <tr>
        <td id="L8811" data-line-number="8811"></td>
        <td id="LC8811">    <span>INTERNAL_DAC_CALLBACK</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L8812" data-line-number="8812"></td>
        <td id="LC8812">
</td>
      </tr>
      <tr>
        <td id="L8813" data-line-number="8813"></td>
        <td id="LC8813">    pProcess-&gt;<span>LookupOrCreateAppDomain</span>(vmAppDomain);</td>
      </tr>
      <tr>
        <td id="L8814" data-line-number="8814"></td>
        <td id="LC8814">}</td>
      </tr>
      <tr>
        <td id="L8815" data-line-number="8815"></td>
        <td id="LC8815">
</td>
      </tr>
      <tr>
        <td id="L8816" data-line-number="8816"></td>
        <td id="LC8816"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8817" data-line-number="8817"></td>
        <td id="LC8817"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8818" data-line-number="8818"></td>
        <td id="LC8818"><span><span>//</span> Traverse appdomains in the target and build up our list.</span></td>
      </tr>
      <tr>
        <td id="L8819" data-line-number="8819"></td>
        <td id="LC8819"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8820" data-line-number="8820"></td>
        <td id="LC8820"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L8821" data-line-number="8821"></td>
        <td id="LC8821"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8822" data-line-number="8822"></td>
        <td id="LC8822"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L8823" data-line-number="8823"></td>
        <td id="LC8823"><span><span>//</span>    returns on success.</span></td>
      </tr>
      <tr>
        <td id="L8824" data-line-number="8824"></td>
        <td id="LC8824"><span><span>//</span>    Throws on error. AppDomain cache may be partially populated.</span></td>
      </tr>
      <tr>
        <td id="L8825" data-line-number="8825"></td>
        <td id="LC8825"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8826" data-line-number="8826"></td>
        <td id="LC8826"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L8827" data-line-number="8827"></td>
        <td id="LC8827"><span><span>//</span>    This is an non-invasive inspection operation called when the debuggee is stopped.</span></td>
      </tr>
      <tr>
        <td id="L8828" data-line-number="8828"></td>
        <td id="LC8828"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8829" data-line-number="8829"></td>
        <td id="LC8829"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L8830" data-line-number="8830"></td>
        <td id="LC8830"><span><span>//</span>    This can be called multiple times. If the list is non-empty, it will nop.</span></td>
      </tr>
      <tr>
        <td id="L8831" data-line-number="8831"></td>
        <td id="LC8831"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8832" data-line-number="8832"></td>
        <td id="LC8832"><span>void</span> <span>CordbProcess::PrepopulateAppDomainsOrThrow</span>()</td>
      </tr>
      <tr>
        <td id="L8833" data-line-number="8833"></td>
        <td id="LC8833">{</td>
      </tr>
      <tr>
        <td id="L8834" data-line-number="8834"></td>
        <td id="LC8834">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L8835" data-line-number="8835"></td>
        <td id="LC8835">    {</td>
      </tr>
      <tr>
        <td id="L8836" data-line-number="8836"></td>
        <td id="LC8836">        THROWS;</td>
      </tr>
      <tr>
        <td id="L8837" data-line-number="8837"></td>
        <td id="LC8837">    }</td>
      </tr>
      <tr>
        <td id="L8838" data-line-number="8838"></td>
        <td id="LC8838">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L8839" data-line-number="8839"></td>
        <td id="LC8839">
</td>
      </tr>
      <tr>
        <td id="L8840" data-line-number="8840"></td>
        <td id="LC8840">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8841" data-line-number="8841"></td>
        <td id="LC8841">
</td>
      </tr>
      <tr>
        <td id="L8842" data-line-number="8842"></td>
        <td id="LC8842">    <span>if</span> (!<span>IsDacInitialized</span>())</td>
      </tr>
      <tr>
        <td id="L8843" data-line-number="8843"></td>
        <td id="LC8843">    {</td>
      </tr>
      <tr>
        <td id="L8844" data-line-number="8844"></td>
        <td id="LC8844">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L8845" data-line-number="8845"></td>
        <td id="LC8845">    }</td>
      </tr>
      <tr>
        <td id="L8846" data-line-number="8846"></td>
        <td id="LC8846">
</td>
      </tr>
      <tr>
        <td id="L8847" data-line-number="8847"></td>
        <td id="LC8847">    <span><span>//</span> DD-primitive  that invokes a callback.  This may throw.</span></td>
      </tr>
      <tr>
        <td id="L8848" data-line-number="8848"></td>
        <td id="LC8848">    <span>GetDAC</span>()-&gt;<span>EnumerateAppDomains</span>(</td>
      </tr>
      <tr>
        <td id="L8849" data-line-number="8849"></td>
        <td id="LC8849">        CordbProcess::AppDomainEnumerationCallback,</td>
      </tr>
      <tr>
        <td id="L8850" data-line-number="8850"></td>
        <td id="LC8850">        <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8851" data-line-number="8851"></td>
        <td id="LC8851">}</td>
      </tr>
      <tr>
        <td id="L8852" data-line-number="8852"></td>
        <td id="LC8852">
</td>
      </tr>
      <tr>
        <td id="L8853" data-line-number="8853"></td>
        <td id="LC8853"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8854" data-line-number="8854"></td>
        <td id="LC8854"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8855" data-line-number="8855"></td>
        <td id="LC8855"><span><span>//</span> EnumerateAppDomains enumerates all app domains in the process.</span></td>
      </tr>
      <tr>
        <td id="L8856" data-line-number="8856"></td>
        <td id="LC8856"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8857" data-line-number="8857"></td>
        <td id="LC8857"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L8858" data-line-number="8858"></td>
        <td id="LC8858"><span><span>//</span>      ppAppDomains - get appdomain enumerator</span></td>
      </tr>
      <tr>
        <td id="L8859" data-line-number="8859"></td>
        <td id="LC8859"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8860" data-line-number="8860"></td>
        <td id="LC8860"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L8861" data-line-number="8861"></td>
        <td id="LC8861"><span><span>//</span>    S_OK on success.</span></td>
      </tr>
      <tr>
        <td id="L8862" data-line-number="8862"></td>
        <td id="LC8862"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8863" data-line-number="8863"></td>
        <td id="LC8863"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L8864" data-line-number="8864"></td>
        <td id="LC8864"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8865" data-line-number="8865"></td>
        <td id="LC8865"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8866" data-line-number="8866"></td>
        <td id="LC8866"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L8867" data-line-number="8867"></td>
        <td id="LC8867"><span><span>//</span>    This operation is non-invasive target.</span></td>
      </tr>
      <tr>
        <td id="L8868" data-line-number="8868"></td>
        <td id="LC8868"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8869" data-line-number="8869"></td>
        <td id="LC8869"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8870" data-line-number="8870"></td>
        <td id="LC8870">HRESULT <span>CordbProcess::EnumerateAppDomains</span>(ICorDebugAppDomainEnum **ppAppDomains)</td>
      </tr>
      <tr>
        <td id="L8871" data-line-number="8871"></td>
        <td id="LC8871">{</td>
      </tr>
      <tr>
        <td id="L8872" data-line-number="8872"></td>
        <td id="LC8872">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L8873" data-line-number="8873"></td>
        <td id="LC8873">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8874" data-line-number="8874"></td>
        <td id="LC8874">    {</td>
      </tr>
      <tr>
        <td id="L8875" data-line-number="8875"></td>
        <td id="LC8875">        <span>ValidateOrThrow</span>(ppAppDomains);</td>
      </tr>
      <tr>
        <td id="L8876" data-line-number="8876"></td>
        <td id="LC8876">
</td>
      </tr>
      <tr>
        <td id="L8877" data-line-number="8877"></td>
        <td id="LC8877">        <span><span>//</span> Ensure list is populated.</span></td>
      </tr>
      <tr>
        <td id="L8878" data-line-number="8878"></td>
        <td id="LC8878">        <span>PrepopulateAppDomainsOrThrow</span>();</td>
      </tr>
      <tr>
        <td id="L8879" data-line-number="8879"></td>
        <td id="LC8879">
</td>
      </tr>
      <tr>
        <td id="L8880" data-line-number="8880"></td>
        <td id="LC8880">        RSInitHolder&lt;CordbHashTableEnum&gt; pEnum;</td>
      </tr>
      <tr>
        <td id="L8881" data-line-number="8881"></td>
        <td id="LC8881">        <span>CordbHashTableEnum::BuildOrThrow</span>(</td>
      </tr>
      <tr>
        <td id="L8882" data-line-number="8882"></td>
        <td id="LC8882">            <span>this</span>,</td>
      </tr>
      <tr>
        <td id="L8883" data-line-number="8883"></td>
        <td id="LC8883">            <span>GetContinueNeuterList</span>(),</td>
      </tr>
      <tr>
        <td id="L8884" data-line-number="8884"></td>
        <td id="LC8884">            &amp;m_appDomains,</td>
      </tr>
      <tr>
        <td id="L8885" data-line-number="8885"></td>
        <td id="LC8885">            IID_ICorDebugAppDomainEnum,</td>
      </tr>
      <tr>
        <td id="L8886" data-line-number="8886"></td>
        <td id="LC8886">            pEnum.<span>GetAddr</span>());</td>
      </tr>
      <tr>
        <td id="L8887" data-line-number="8887"></td>
        <td id="LC8887">
</td>
      </tr>
      <tr>
        <td id="L8888" data-line-number="8888"></td>
        <td id="LC8888">        *ppAppDomains = <span>static_cast</span>&lt;ICorDebugAppDomainEnum*&gt; (pEnum);</td>
      </tr>
      <tr>
        <td id="L8889" data-line-number="8889"></td>
        <td id="LC8889">        pEnum-&gt;<span>ExternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L8890" data-line-number="8890"></td>
        <td id="LC8890">
</td>
      </tr>
      <tr>
        <td id="L8891" data-line-number="8891"></td>
        <td id="LC8891">        pEnum.<span>ClearAndMarkDontNeuter</span>();</td>
      </tr>
      <tr>
        <td id="L8892" data-line-number="8892"></td>
        <td id="LC8892">    }</td>
      </tr>
      <tr>
        <td id="L8893" data-line-number="8893"></td>
        <td id="LC8893">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L8894" data-line-number="8894"></td>
        <td id="LC8894">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L8895" data-line-number="8895"></td>
        <td id="LC8895">}</td>
      </tr>
      <tr>
        <td id="L8896" data-line-number="8896"></td>
        <td id="LC8896">
</td>
      </tr>
      <tr>
        <td id="L8897" data-line-number="8897"></td>
        <td id="LC8897"><span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L8898" data-line-number="8898"></td>
        <td id="LC8898"><span> * GetObject returns the runtime process object.</span></td>
      </tr>
      <tr>
        <td id="L8899" data-line-number="8899"></td>
        <td id="LC8899"><span> * Note: This method is not yet implemented.</span></td>
      </tr>
      <tr>
        <td id="L8900" data-line-number="8900"></td>
        <td id="LC8900"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L8901" data-line-number="8901"></td>
        <td id="LC8901">HRESULT <span>CordbProcess::GetObject</span>(ICorDebugValue **ppObject)</td>
      </tr>
      <tr>
        <td id="L8902" data-line-number="8902"></td>
        <td id="LC8902">{</td>
      </tr>
      <tr>
        <td id="L8903" data-line-number="8903"></td>
        <td id="LC8903">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8904" data-line-number="8904"></td>
        <td id="LC8904">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8905" data-line-number="8905"></td>
        <td id="LC8905">    <span>VALIDATE_POINTER_TO_OBJECT</span>(ppObject, ICorDebugObjectValue **);</td>
      </tr>
      <tr>
        <td id="L8906" data-line-number="8906"></td>
        <td id="LC8906">
</td>
      </tr>
      <tr>
        <td id="L8907" data-line-number="8907"></td>
        <td id="LC8907">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L8908" data-line-number="8908"></td>
        <td id="LC8908">}</td>
      </tr>
      <tr>
        <td id="L8909" data-line-number="8909"></td>
        <td id="LC8909">
</td>
      </tr>
      <tr>
        <td id="L8910" data-line-number="8910"></td>
        <td id="LC8910">
</td>
      </tr>
      <tr>
        <td id="L8911" data-line-number="8911"></td>
        <td id="LC8911"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L8912" data-line-number="8912"></td>
        <td id="LC8912"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8913" data-line-number="8913"></td>
        <td id="LC8913"><span><span>//</span> Given a taskid, finding the corresponding thread. The function can fail if we do not</span></td>
      </tr>
      <tr>
        <td id="L8914" data-line-number="8914"></td>
        <td id="LC8914"><span><span>//</span> find any thread with the given taskid</span></td>
      </tr>
      <tr>
        <td id="L8915" data-line-number="8915"></td>
        <td id="LC8915"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8916" data-line-number="8916"></td>
        <td id="LC8916"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L8917" data-line-number="8917"></td>
        <td id="LC8917"><span><span>//</span>     taskId - The task ID to look for.</span></td>
      </tr>
      <tr>
        <td id="L8918" data-line-number="8918"></td>
        <td id="LC8918"><span><span>//</span>     ppThread - OUT: Space for storing the thread corresponding to the taskId given.</span></td>
      </tr>
      <tr>
        <td id="L8919" data-line-number="8919"></td>
        <td id="LC8919"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8920" data-line-number="8920"></td>
        <td id="LC8920"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L8921" data-line-number="8921"></td>
        <td id="LC8921"><span><span>//</span>     Typical HRESULT symantics, nothing abnormal.</span></td>
      </tr>
      <tr>
        <td id="L8922" data-line-number="8922"></td>
        <td id="LC8922"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8923" data-line-number="8923"></td>
        <td id="LC8923">HRESULT <span>CordbProcess::GetThreadForTaskID</span>(TASKID taskId, ICorDebugThread2 ** ppThread)</td>
      </tr>
      <tr>
        <td id="L8924" data-line-number="8924"></td>
        <td id="LC8924">{</td>
      </tr>
      <tr>
        <td id="L8925" data-line-number="8925"></td>
        <td id="LC8925">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8926" data-line-number="8926"></td>
        <td id="LC8926">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L8927" data-line-number="8927"></td>
        <td id="LC8927">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>GetProcess</span>());</td>
      </tr>
      <tr>
        <td id="L8928" data-line-number="8928"></td>
        <td id="LC8928">
</td>
      </tr>
      <tr>
        <td id="L8929" data-line-number="8929"></td>
        <td id="LC8929">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L8930" data-line-number="8930"></td>
        <td id="LC8930">
</td>
      </tr>
      <tr>
        <td id="L8931" data-line-number="8931"></td>
        <td id="LC8931">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L8932" data-line-number="8932"></td>
        <td id="LC8932">    {</td>
      </tr>
      <tr>
        <td id="L8933" data-line-number="8933"></td>
        <td id="LC8933">        RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L8934" data-line-number="8934"></td>
        <td id="LC8934">
</td>
      </tr>
      <tr>
        <td id="L8935" data-line-number="8935"></td>
        <td id="LC8935">        <span>if</span> (ppThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8936" data-line-number="8936"></td>
        <td id="LC8936">        {</td>
      </tr>
      <tr>
        <td id="L8937" data-line-number="8937"></td>
        <td id="LC8937">            <span>ThrowHR</span>(E_INVALIDARG);</td>
      </tr>
      <tr>
        <td id="L8938" data-line-number="8938"></td>
        <td id="LC8938">        }</td>
      </tr>
      <tr>
        <td id="L8939" data-line-number="8939"></td>
        <td id="LC8939">
</td>
      </tr>
      <tr>
        <td id="L8940" data-line-number="8940"></td>
        <td id="LC8940">        <span><span>//</span> On initialization, the task ID of every thread is INVALID_TASK_ID, unless a host is present and</span></td>
      </tr>
      <tr>
        <td id="L8941" data-line-number="8941"></td>
        <td id="LC8941">        <span><span>//</span> the host calls IClrTask::SetTaskIdentifier().  So we need to explicitly check for INVALID_TASK_ID</span></td>
      </tr>
      <tr>
        <td id="L8942" data-line-number="8942"></td>
        <td id="LC8942">        <span><span>//</span> here and return NULL if necessary.  We return S_FALSE because that's the return value for the case</span></td>
      </tr>
      <tr>
        <td id="L8943" data-line-number="8943"></td>
        <td id="LC8943">        <span><span>//</span> where we can't find a thread for the specified task ID.</span></td>
      </tr>
      <tr>
        <td id="L8944" data-line-number="8944"></td>
        <td id="LC8944">        <span>if</span> (taskId == INVALID_TASK_ID)</td>
      </tr>
      <tr>
        <td id="L8945" data-line-number="8945"></td>
        <td id="LC8945">        {</td>
      </tr>
      <tr>
        <td id="L8946" data-line-number="8946"></td>
        <td id="LC8946">            *ppThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L8947" data-line-number="8947"></td>
        <td id="LC8947">            hr = S_FALSE;</td>
      </tr>
      <tr>
        <td id="L8948" data-line-number="8948"></td>
        <td id="LC8948">        }</td>
      </tr>
      <tr>
        <td id="L8949" data-line-number="8949"></td>
        <td id="LC8949">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L8950" data-line-number="8950"></td>
        <td id="LC8950">        {</td>
      </tr>
      <tr>
        <td id="L8951" data-line-number="8951"></td>
        <td id="LC8951">            <span>PrepopulateThreadsOrThrow</span>();</td>
      </tr>
      <tr>
        <td id="L8952" data-line-number="8952"></td>
        <td id="LC8952">
</td>
      </tr>
      <tr>
        <td id="L8953" data-line-number="8953"></td>
        <td id="LC8953">            <span><span>//</span> now find the ICorDebugThread corresponding to it</span></td>
      </tr>
      <tr>
        <td id="L8954" data-line-number="8954"></td>
        <td id="LC8954">            CordbThread * pThread;</td>
      </tr>
      <tr>
        <td id="L8955" data-line-number="8955"></td>
        <td id="LC8955">            HASHFIND hashFind;</td>
      </tr>
      <tr>
        <td id="L8956" data-line-number="8956"></td>
        <td id="LC8956">
</td>
      </tr>
      <tr>
        <td id="L8957" data-line-number="8957"></td>
        <td id="LC8957">
</td>
      </tr>
      <tr>
        <td id="L8958" data-line-number="8958"></td>
        <td id="LC8958">            <span>for</span> (pThread  = m_userThreads.<span>FindFirst</span>(&amp;hashFind);</td>
      </tr>
      <tr>
        <td id="L8959" data-line-number="8959"></td>
        <td id="LC8959">                 pThread != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L8960" data-line-number="8960"></td>
        <td id="LC8960">                 pThread  = m_userThreads.<span>FindNext</span>(&amp;hashFind))</td>
      </tr>
      <tr>
        <td id="L8961" data-line-number="8961"></td>
        <td id="LC8961">            {</td>
      </tr>
      <tr>
        <td id="L8962" data-line-number="8962"></td>
        <td id="LC8962">                <span>if</span> (pThread-&gt;<span>GetTaskID</span>() == taskId)</td>
      </tr>
      <tr>
        <td id="L8963" data-line-number="8963"></td>
        <td id="LC8963">                {</td>
      </tr>
      <tr>
        <td id="L8964" data-line-number="8964"></td>
        <td id="LC8964">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L8965" data-line-number="8965"></td>
        <td id="LC8965">                }</td>
      </tr>
      <tr>
        <td id="L8966" data-line-number="8966"></td>
        <td id="LC8966">            }</td>
      </tr>
      <tr>
        <td id="L8967" data-line-number="8967"></td>
        <td id="LC8967">
</td>
      </tr>
      <tr>
        <td id="L8968" data-line-number="8968"></td>
        <td id="LC8968">            <span>if</span> (pThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L8969" data-line-number="8969"></td>
        <td id="LC8969">            {</td>
      </tr>
      <tr>
        <td id="L8970" data-line-number="8970"></td>
        <td id="LC8970">                *ppThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L8971" data-line-number="8971"></td>
        <td id="LC8971">                hr = S_FALSE;</td>
      </tr>
      <tr>
        <td id="L8972" data-line-number="8972"></td>
        <td id="LC8972">            }</td>
      </tr>
      <tr>
        <td id="L8973" data-line-number="8973"></td>
        <td id="LC8973">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L8974" data-line-number="8974"></td>
        <td id="LC8974">            {</td>
      </tr>
      <tr>
        <td id="L8975" data-line-number="8975"></td>
        <td id="LC8975">                *ppThread = pThread;</td>
      </tr>
      <tr>
        <td id="L8976" data-line-number="8976"></td>
        <td id="LC8976">                pThread-&gt;<span>ExternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L8977" data-line-number="8977"></td>
        <td id="LC8977">            }</td>
      </tr>
      <tr>
        <td id="L8978" data-line-number="8978"></td>
        <td id="LC8978">        }</td>
      </tr>
      <tr>
        <td id="L8979" data-line-number="8979"></td>
        <td id="LC8979">    }</td>
      </tr>
      <tr>
        <td id="L8980" data-line-number="8980"></td>
        <td id="LC8980">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L8981" data-line-number="8981"></td>
        <td id="LC8981">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L8982" data-line-number="8982"></td>
        <td id="LC8982">}   <span><span>//</span> CordbProcess::GetThreadForTaskid</span></td>
      </tr>
      <tr>
        <td id="L8983" data-line-number="8983"></td>
        <td id="LC8983">
</td>
      </tr>
      <tr>
        <td id="L8984" data-line-number="8984"></td>
        <td id="LC8984">HRESULT</td>
      </tr>
      <tr>
        <td id="L8985" data-line-number="8985"></td>
        <td id="LC8985"><span>CordbProcess::GetVersion</span>(COR_VERSION* pVersion)</td>
      </tr>
      <tr>
        <td id="L8986" data-line-number="8986"></td>
        <td id="LC8986">{</td>
      </tr>
      <tr>
        <td id="L8987" data-line-number="8987"></td>
        <td id="LC8987">    <span>if</span> (<span>NULL</span> == pVersion)</td>
      </tr>
      <tr>
        <td id="L8988" data-line-number="8988"></td>
        <td id="LC8988">    {</td>
      </tr>
      <tr>
        <td id="L8989" data-line-number="8989"></td>
        <td id="LC8989">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L8990" data-line-number="8990"></td>
        <td id="LC8990">    }</td>
      </tr>
      <tr>
        <td id="L8991" data-line-number="8991"></td>
        <td id="LC8991">
</td>
      </tr>
      <tr>
        <td id="L8992" data-line-number="8992"></td>
        <td id="LC8992">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L8993" data-line-number="8993"></td>
        <td id="LC8993">    <span><span>//</span> Because we require a matching version of mscordbi.dll to debug a certain version of the runtime,</span></td>
      </tr>
      <tr>
        <td id="L8994" data-line-number="8994"></td>
        <td id="LC8994">    <span><span>//</span> we can just use constants found in this particular mscordbi.dll to determine the version of the left side.</span></td>
      </tr>
      <tr>
        <td id="L8995" data-line-number="8995"></td>
        <td id="LC8995">    pVersion-&gt;<span>dwMajor</span> = CLR_MAJOR_VERSION;</td>
      </tr>
      <tr>
        <td id="L8996" data-line-number="8996"></td>
        <td id="LC8996">    pVersion-&gt;<span>dwMinor</span> = CLR_MINOR_VERSION;</td>
      </tr>
      <tr>
        <td id="L8997" data-line-number="8997"></td>
        <td id="LC8997">    pVersion-&gt;<span>dwBuild</span> = CLR_BUILD_VERSION;</td>
      </tr>
      <tr>
        <td id="L8998" data-line-number="8998"></td>
        <td id="LC8998">    pVersion-&gt;<span>dwSubBuild</span> = CLR_BUILD_VERSION_QFE;</td>
      </tr>
      <tr>
        <td id="L8999" data-line-number="8999"></td>
        <td id="LC8999">
</td>
      </tr>
      <tr>
        <td id="L9000" data-line-number="9000"></td>
        <td id="LC9000">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L9001" data-line-number="9001"></td>
        <td id="LC9001">}</td>
      </tr>
      <tr>
        <td id="L9002" data-line-number="9002"></td>
        <td id="LC9002">
</td>
      </tr>
      <tr>
        <td id="L9003" data-line-number="9003"></td>
        <td id="LC9003">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L9004" data-line-number="9004"></td>
        <td id="LC9004"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9005" data-line-number="9005"></td>
        <td id="LC9005"><span><span>//</span> Search for a native patch given the address. Return null if not found.</span></td>
      </tr>
      <tr>
        <td id="L9006" data-line-number="9006"></td>
        <td id="LC9006"><span><span>//</span> Since we return an address, this is only valid until the table is disturbed.</span></td>
      </tr>
      <tr>
        <td id="L9007" data-line-number="9007"></td>
        <td id="LC9007"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9008" data-line-number="9008"></td>
        <td id="LC9008">NativePatch * <span>CordbProcess::GetNativePatch</span>(<span>const</span> <span>void</span> * pAddress)</td>
      </tr>
      <tr>
        <td id="L9009" data-line-number="9009"></td>
        <td id="LC9009">{</td>
      </tr>
      <tr>
        <td id="L9010" data-line-number="9010"></td>
        <td id="LC9010">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L9011" data-line-number="9011"></td>
        <td id="LC9011">
</td>
      </tr>
      <tr>
        <td id="L9012" data-line-number="9012"></td>
        <td id="LC9012">    <span>int</span> cTotal = m_NativePatchList.<span>Count</span>();</td>
      </tr>
      <tr>
        <td id="L9013" data-line-number="9013"></td>
        <td id="LC9013">    NativePatch * pTable = m_NativePatchList.<span>Table</span>();</td>
      </tr>
      <tr>
        <td id="L9014" data-line-number="9014"></td>
        <td id="LC9014">    <span>if</span> (pTable == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9015" data-line-number="9015"></td>
        <td id="LC9015">    {</td>
      </tr>
      <tr>
        <td id="L9016" data-line-number="9016"></td>
        <td id="LC9016">        <span>return</span> <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L9017" data-line-number="9017"></td>
        <td id="LC9017">    }</td>
      </tr>
      <tr>
        <td id="L9018" data-line-number="9018"></td>
        <td id="LC9018">
</td>
      </tr>
      <tr>
        <td id="L9019" data-line-number="9019"></td>
        <td id="LC9019">    <span>for</span>(<span>int</span> i = <span>0</span>; i  &lt; cTotal; i++)</td>
      </tr>
      <tr>
        <td id="L9020" data-line-number="9020"></td>
        <td id="LC9020">    {</td>
      </tr>
      <tr>
        <td id="L9021" data-line-number="9021"></td>
        <td id="LC9021">        <span>if</span> (pTable[i].<span>pAddress</span> == pAddress)</td>
      </tr>
      <tr>
        <td id="L9022" data-line-number="9022"></td>
        <td id="LC9022">        {</td>
      </tr>
      <tr>
        <td id="L9023" data-line-number="9023"></td>
        <td id="LC9023">            <span>return</span> &amp;pTable[i];</td>
      </tr>
      <tr>
        <td id="L9024" data-line-number="9024"></td>
        <td id="LC9024">        }</td>
      </tr>
      <tr>
        <td id="L9025" data-line-number="9025"></td>
        <td id="LC9025">    }</td>
      </tr>
      <tr>
        <td id="L9026" data-line-number="9026"></td>
        <td id="LC9026">    <span>return</span> <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L9027" data-line-number="9027"></td>
        <td id="LC9027">}</td>
      </tr>
      <tr>
        <td id="L9028" data-line-number="9028"></td>
        <td id="LC9028">
</td>
      </tr>
      <tr>
        <td id="L9029" data-line-number="9029"></td>
        <td id="LC9029"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9030" data-line-number="9030"></td>
        <td id="LC9030"><span><span>//</span> Is there an break-opcode (int3 on x86) at the address in the debuggee?</span></td>
      </tr>
      <tr>
        <td id="L9031" data-line-number="9031"></td>
        <td id="LC9031"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9032" data-line-number="9032"></td>
        <td id="LC9032"><span>bool</span> <span>CordbProcess::IsBreakOpcodeAtAddress</span>(<span>const</span> <span>void</span> * address)</td>
      </tr>
      <tr>
        <td id="L9033" data-line-number="9033"></td>
        <td id="LC9033">{</td>
      </tr>
      <tr>
        <td id="L9034" data-line-number="9034"></td>
        <td id="LC9034">    <span><span>//</span> There should have been an int3 there already. Since we already put it in there,</span></td>
      </tr>
      <tr>
        <td id="L9035" data-line-number="9035"></td>
        <td id="LC9035">    <span><span>//</span> we should be able to safely read it out.</span></td>
      </tr>
      <tr>
        <td id="L9036" data-line-number="9036"></td>
        <td id="LC9036">#<span>if</span> defined(DBG_TARGET_ARM) || defined(DBG_TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L9037" data-line-number="9037"></td>
        <td id="LC9037">    PRD_TYPE opcodeTest = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L9038" data-line-number="9038"></td>
        <td id="LC9038">#<span>elif</span> defined(DBG_TARGET_AMD64) || defined(DBG_TARGET_X86)</td>
      </tr>
      <tr>
        <td id="L9039" data-line-number="9039"></td>
        <td id="LC9039">    BYTE opcodeTest = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L9040" data-line-number="9040"></td>
        <td id="LC9040">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L9041" data-line-number="9041"></td>
        <td id="LC9041">    <span>PORTABILITY_ASSERT</span>(<span><span>"</span>NYI: Architecture specific opcode type to read<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L9042" data-line-number="9042"></td>
        <td id="LC9042">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L9043" data-line-number="9043"></td>
        <td id="LC9043">
</td>
      </tr>
      <tr>
        <td id="L9044" data-line-number="9044"></td>
        <td id="LC9044">    HRESULT hr = <span>SafeReadStruct</span>(<span>PTR_TO_CORDB_ADDRESS</span>(address), &amp;opcodeTest);</td>
      </tr>
      <tr>
        <td id="L9045" data-line-number="9045"></td>
        <td id="LC9045">    <span>SIMPLIFYING_ASSUMPTION_SUCCEEDED</span>(hr);</td>
      </tr>
      <tr>
        <td id="L9046" data-line-number="9046"></td>
        <td id="LC9046">
</td>
      </tr>
      <tr>
        <td id="L9047" data-line-number="9047"></td>
        <td id="LC9047">    <span>return</span> (opcodeTest == CORDbg_BREAK_INSTRUCTION);</td>
      </tr>
      <tr>
        <td id="L9048" data-line-number="9048"></td>
        <td id="LC9048">}</td>
      </tr>
      <tr>
        <td id="L9049" data-line-number="9049"></td>
        <td id="LC9049">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L9050" data-line-number="9050"></td>
        <td id="LC9050">
</td>
      </tr>
      <tr>
        <td id="L9051" data-line-number="9051"></td>
        <td id="LC9051"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9052" data-line-number="9052"></td>
        <td id="LC9052"><span><span>//</span> CordbProcess::SetUnmanagedBreakpoint</span></td>
      </tr>
      <tr>
        <td id="L9053" data-line-number="9053"></td>
        <td id="LC9053"><span><span>//</span> Called by a native debugger to add breakpoints during Interop.</span></td>
      </tr>
      <tr>
        <td id="L9054" data-line-number="9054"></td>
        <td id="LC9054"><span><span>//</span> address - remote address into the debuggee</span></td>
      </tr>
      <tr>
        <td id="L9055" data-line-number="9055"></td>
        <td id="LC9055"><span><span>//</span> bufsize, buffer[] - initial size &amp; buffer for the opcode that we're replacing.</span></td>
      </tr>
      <tr>
        <td id="L9056" data-line-number="9056"></td>
        <td id="LC9056"><span><span>//</span> buflen - size of the buffer that we write to.</span></td>
      </tr>
      <tr>
        <td id="L9057" data-line-number="9057"></td>
        <td id="LC9057"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9058" data-line-number="9058"></td>
        <td id="LC9058">HRESULT</td>
      </tr>
      <tr>
        <td id="L9059" data-line-number="9059"></td>
        <td id="LC9059"><span>CordbProcess::SetUnmanagedBreakpoint</span>(CORDB_ADDRESS address, ULONG32 bufsize, BYTE buffer[], ULONG32 * bufLen)</td>
      </tr>
      <tr>
        <td id="L9060" data-line-number="9060"></td>
        <td id="LC9060">{</td>
      </tr>
      <tr>
        <td id="L9061" data-line-number="9061"></td>
        <td id="LC9061">    <span>LOG</span>((LF_CORDB, LL_INFO100, <span><span>"</span>CP::SetUnBP: pProcess=%x, address=%p.<span>\n</span><span>"</span></span>, <span>this</span>, <span>CORDB_ADDRESS_TO_PTR</span>(address)));</td>
      </tr>
      <tr>
        <td id="L9062" data-line-number="9062"></td>
        <td id="LC9062">#<span>ifndef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L9063" data-line-number="9063"></td>
        <td id="LC9063">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L9064" data-line-number="9064"></td>
        <td id="LC9064">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L9065" data-line-number="9065"></td>
        <td id="LC9065">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9066" data-line-number="9066"></td>
        <td id="LC9066">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9067" data-line-number="9067"></td>
        <td id="LC9067">    <span>FAIL_IF_MANAGED_ONLY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9068" data-line-number="9068"></td>
        <td id="LC9068">    <span>_ASSERTE</span>(!<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L9069" data-line-number="9069"></td>
        <td id="LC9069">    <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L9070" data-line-number="9070"></td>
        <td id="LC9070">    HRESULT hr = <span>SetUnmanagedBreakpointInternal</span>(address, bufsize, buffer, bufLen);</td>
      </tr>
      <tr>
        <td id="L9071" data-line-number="9071"></td>
        <td id="LC9071">    <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L9072" data-line-number="9072"></td>
        <td id="LC9072">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L9073" data-line-number="9073"></td>
        <td id="LC9073">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L9074" data-line-number="9074"></td>
        <td id="LC9074">}</td>
      </tr>
      <tr>
        <td id="L9075" data-line-number="9075"></td>
        <td id="LC9075">
</td>
      </tr>
      <tr>
        <td id="L9076" data-line-number="9076"></td>
        <td id="LC9076"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9077" data-line-number="9077"></td>
        <td id="LC9077"><span><span>//</span> CordbProcess::SetUnmanagedBreakpointInternal</span></td>
      </tr>
      <tr>
        <td id="L9078" data-line-number="9078"></td>
        <td id="LC9078"><span><span>//</span> The worker behind SetUnmanagedBreakpoint, this function can set both public</span></td>
      </tr>
      <tr>
        <td id="L9079" data-line-number="9079"></td>
        <td id="LC9079"><span><span>//</span> breakpoints used by the debugger and internal breakpoints used for utility</span></td>
      </tr>
      <tr>
        <td id="L9080" data-line-number="9080"></td>
        <td id="LC9080"><span><span>//</span> purposes in interop debugging.</span></td>
      </tr>
      <tr>
        <td id="L9081" data-line-number="9081"></td>
        <td id="LC9081"><span><span>//</span> address - remote address into the debuggee</span></td>
      </tr>
      <tr>
        <td id="L9082" data-line-number="9082"></td>
        <td id="LC9082"><span><span>//</span> bufsize, buffer[] - initial size &amp; buffer for the opcode that we're replacing.</span></td>
      </tr>
      <tr>
        <td id="L9083" data-line-number="9083"></td>
        <td id="LC9083"><span><span>//</span> buflen - size of the buffer that we write to.</span></td>
      </tr>
      <tr>
        <td id="L9084" data-line-number="9084"></td>
        <td id="LC9084"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9085" data-line-number="9085"></td>
        <td id="LC9085">HRESULT</td>
      </tr>
      <tr>
        <td id="L9086" data-line-number="9086"></td>
        <td id="LC9086"><span>CordbProcess::SetUnmanagedBreakpointInternal</span>(CORDB_ADDRESS address, ULONG32 bufsize, BYTE buffer[], ULONG32 * bufLen)</td>
      </tr>
      <tr>
        <td id="L9087" data-line-number="9087"></td>
        <td id="LC9087">{</td>
      </tr>
      <tr>
        <td id="L9088" data-line-number="9088"></td>
        <td id="LC9088">    <span>LOG</span>((LF_CORDB, LL_INFO100, <span><span>"</span>CP::SetUnBPI: pProcess=%x, address=%p.<span>\n</span><span>"</span></span>, <span>this</span>, <span>CORDB_ADDRESS_TO_PTR</span>(address)));</td>
      </tr>
      <tr>
        <td id="L9089" data-line-number="9089"></td>
        <td id="LC9089">#<span>ifndef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L9090" data-line-number="9090"></td>
        <td id="LC9090">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L9091" data-line-number="9091"></td>
        <td id="LC9091">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L9092" data-line-number="9092"></td>
        <td id="LC9092">
</td>
      </tr>
      <tr>
        <td id="L9093" data-line-number="9093"></td>
        <td id="LC9093">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9094" data-line-number="9094"></td>
        <td id="LC9094">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9095" data-line-number="9095"></td>
        <td id="LC9095">    <span>FAIL_IF_MANAGED_ONLY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9096" data-line-number="9096"></td>
        <td id="LC9096">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L9097" data-line-number="9097"></td>
        <td id="LC9097">
</td>
      </tr>
      <tr>
        <td id="L9098" data-line-number="9098"></td>
        <td id="LC9098">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L9099" data-line-number="9099"></td>
        <td id="LC9099">
</td>
      </tr>
      <tr>
        <td id="L9100" data-line-number="9100"></td>
        <td id="LC9100">    NativePatch * p = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L9101" data-line-number="9101"></td>
        <td id="LC9101">#<span>if</span> defined(DBG_TARGET_X86) || defined(DBG_TARGET_AMD64)</td>
      </tr>
      <tr>
        <td id="L9102" data-line-number="9102"></td>
        <td id="LC9102">    <span>const</span> BYTE patch = CORDbg_BREAK_INSTRUCTION;</td>
      </tr>
      <tr>
        <td id="L9103" data-line-number="9103"></td>
        <td id="LC9103">    BYTE opcode;</td>
      </tr>
      <tr>
        <td id="L9104" data-line-number="9104"></td>
        <td id="LC9104">#<span>elif</span> defined(DBG_TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L9105" data-line-number="9105"></td>
        <td id="LC9105">    <span>const</span> PRD_TYPE patch = CORDbg_BREAK_INSTRUCTION;</td>
      </tr>
      <tr>
        <td id="L9106" data-line-number="9106"></td>
        <td id="LC9106">    PRD_TYPE opcode;</td>
      </tr>
      <tr>
        <td id="L9107" data-line-number="9107"></td>
        <td id="LC9107">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L9108" data-line-number="9108"></td>
        <td id="LC9108">    <span>PORTABILITY_ASSERT</span>(<span><span>"</span>NYI: CordbProcess::SetUnmanagedBreakpoint, interop debugging NYI on this platform<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L9109" data-line-number="9109"></td>
        <td id="LC9109">    hr = E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L9110" data-line-number="9110"></td>
        <td id="LC9110">    <span>goto</span> ErrExit;</td>
      </tr>
      <tr>
        <td id="L9111" data-line-number="9111"></td>
        <td id="LC9111">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L9112" data-line-number="9112"></td>
        <td id="LC9112">
</td>
      </tr>
      <tr>
        <td id="L9113" data-line-number="9113"></td>
        <td id="LC9113">    <span><span>//</span> Make sure args are good</span></td>
      </tr>
      <tr>
        <td id="L9114" data-line-number="9114"></td>
        <td id="LC9114">    <span>if</span> ((buffer == <span>NULL</span>) || (bufsize &lt; <span>sizeof</span>(patch)) || (bufLen == <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L9115" data-line-number="9115"></td>
        <td id="LC9115">    {</td>
      </tr>
      <tr>
        <td id="L9116" data-line-number="9116"></td>
        <td id="LC9116">        hr = E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L9117" data-line-number="9117"></td>
        <td id="LC9117">        <span>goto</span> ErrExit;</td>
      </tr>
      <tr>
        <td id="L9118" data-line-number="9118"></td>
        <td id="LC9118">    }</td>
      </tr>
      <tr>
        <td id="L9119" data-line-number="9119"></td>
        <td id="LC9119">
</td>
      </tr>
      <tr>
        <td id="L9120" data-line-number="9120"></td>
        <td id="LC9120">    <span><span>//</span> Fail if there's already a patch at this address.</span></td>
      </tr>
      <tr>
        <td id="L9121" data-line-number="9121"></td>
        <td id="LC9121">    <span>if</span> (<span>GetNativePatch</span>(<span>CORDB_ADDRESS_TO_PTR</span>(address)) != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9122" data-line-number="9122"></td>
        <td id="LC9122">    {</td>
      </tr>
      <tr>
        <td id="L9123" data-line-number="9123"></td>
        <td id="LC9123">        hr = CORDBG_E_NATIVE_PATCH_ALREADY_AT_ADDR;</td>
      </tr>
      <tr>
        <td id="L9124" data-line-number="9124"></td>
        <td id="LC9124">        <span>goto</span> ErrExit;</td>
      </tr>
      <tr>
        <td id="L9125" data-line-number="9125"></td>
        <td id="LC9125">    }</td>
      </tr>
      <tr>
        <td id="L9126" data-line-number="9126"></td>
        <td id="LC9126">
</td>
      </tr>
      <tr>
        <td id="L9127" data-line-number="9127"></td>
        <td id="LC9127">    <span><span>//</span> Preallocate this now so that if are oom, we can fail before we get half-way through.</span></td>
      </tr>
      <tr>
        <td id="L9128" data-line-number="9128"></td>
        <td id="LC9128">    p = m_NativePatchList.<span>Append</span>();</td>
      </tr>
      <tr>
        <td id="L9129" data-line-number="9129"></td>
        <td id="LC9129">    <span>if</span> (p == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9130" data-line-number="9130"></td>
        <td id="LC9130">    {</td>
      </tr>
      <tr>
        <td id="L9131" data-line-number="9131"></td>
        <td id="LC9131">        hr = E_OUTOFMEMORY;</td>
      </tr>
      <tr>
        <td id="L9132" data-line-number="9132"></td>
        <td id="LC9132">        <span>goto</span> ErrExit;</td>
      </tr>
      <tr>
        <td id="L9133" data-line-number="9133"></td>
        <td id="LC9133">    }</td>
      </tr>
      <tr>
        <td id="L9134" data-line-number="9134"></td>
        <td id="LC9134">
</td>
      </tr>
      <tr>
        <td id="L9135" data-line-number="9135"></td>
        <td id="LC9135">
</td>
      </tr>
      <tr>
        <td id="L9136" data-line-number="9136"></td>
        <td id="LC9136">    <span><span>//</span> Read out opcode. 1 byte on x86</span></td>
      </tr>
      <tr>
        <td id="L9137" data-line-number="9137"></td>
        <td id="LC9137">
</td>
      </tr>
      <tr>
        <td id="L9138" data-line-number="9138"></td>
        <td id="LC9138">    hr = <span>ApplyRemotePatch</span>(<span>this</span>, <span>CORDB_ADDRESS_TO_PTR</span>(address), &amp;p-&gt;<span>opcode</span>);</td>
      </tr>
      <tr>
        <td id="L9139" data-line-number="9139"></td>
        <td id="LC9139">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L9140" data-line-number="9140"></td>
        <td id="LC9140">        <span>goto</span> ErrExit;</td>
      </tr>
      <tr>
        <td id="L9141" data-line-number="9141"></td>
        <td id="LC9141">
</td>
      </tr>
      <tr>
        <td id="L9142" data-line-number="9142"></td>
        <td id="LC9142">    <span><span>//</span> It's all successful, so now update our out-params &amp; internal bookkeaping.</span></td>
      </tr>
      <tr>
        <td id="L9143" data-line-number="9143"></td>
        <td id="LC9143">#<span>if</span> defined(DBG_TARGET_X86) || defined(DBG_TARGET_AMD64)</td>
      </tr>
      <tr>
        <td id="L9144" data-line-number="9144"></td>
        <td id="LC9144">    opcode = (BYTE)p-&gt;<span>opcode</span>;</td>
      </tr>
      <tr>
        <td id="L9145" data-line-number="9145"></td>
        <td id="LC9145">    buffer[<span>0</span>] = opcode;</td>
      </tr>
      <tr>
        <td id="L9146" data-line-number="9146"></td>
        <td id="LC9146">#<span>elif</span> defined(DBG_TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L9147" data-line-number="9147"></td>
        <td id="LC9147">    opcode = p-&gt;<span>opcode</span>;</td>
      </tr>
      <tr>
        <td id="L9148" data-line-number="9148"></td>
        <td id="LC9148">    <span>memcpy_s</span>(buffer, bufsize, &amp;opcode, <span>sizeof</span>(opcode));</td>
      </tr>
      <tr>
        <td id="L9149" data-line-number="9149"></td>
        <td id="LC9149">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L9150" data-line-number="9150"></td>
        <td id="LC9150">    <span>PORTABILITY_ASSERT</span>(<span><span>"</span>NYI: CordbProcess::SetUnmanagedBreakpoint, interop debugging NYI on this platform<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L9151" data-line-number="9151"></td>
        <td id="LC9151">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L9152" data-line-number="9152"></td>
        <td id="LC9152">    *bufLen = <span>sizeof</span>(opcode);</td>
      </tr>
      <tr>
        <td id="L9153" data-line-number="9153"></td>
        <td id="LC9153">
</td>
      </tr>
      <tr>
        <td id="L9154" data-line-number="9154"></td>
        <td id="LC9154">    p-&gt;<span>pAddress</span> = <span>CORDB_ADDRESS_TO_PTR</span>(address);</td>
      </tr>
      <tr>
        <td id="L9155" data-line-number="9155"></td>
        <td id="LC9155">    p-&gt;<span>opcode</span> = opcode;</td>
      </tr>
      <tr>
        <td id="L9156" data-line-number="9156"></td>
        <td id="LC9156">
</td>
      </tr>
      <tr>
        <td id="L9157" data-line-number="9157"></td>
        <td id="LC9157">    <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L9158" data-line-number="9158"></td>
        <td id="LC9158">
</td>
      </tr>
      <tr>
        <td id="L9159" data-line-number="9159"></td>
        <td id="LC9159">ErrExit:</td>
      </tr>
      <tr>
        <td id="L9160" data-line-number="9160"></td>
        <td id="LC9160">    <span><span>//</span> If we failed, then free the patch</span></td>
      </tr>
      <tr>
        <td id="L9161" data-line-number="9161"></td>
        <td id="LC9161">    <span>if</span> (<span>FAILED</span>(hr) &amp;&amp; (p != <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L9162" data-line-number="9162"></td>
        <td id="LC9162">    {</td>
      </tr>
      <tr>
        <td id="L9163" data-line-number="9163"></td>
        <td id="LC9163">        m_NativePatchList.<span>Delete</span>(*p);</td>
      </tr>
      <tr>
        <td id="L9164" data-line-number="9164"></td>
        <td id="LC9164">    }</td>
      </tr>
      <tr>
        <td id="L9165" data-line-number="9165"></td>
        <td id="LC9165">
</td>
      </tr>
      <tr>
        <td id="L9166" data-line-number="9166"></td>
        <td id="LC9166">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L9167" data-line-number="9167"></td>
        <td id="LC9167">
</td>
      </tr>
      <tr>
        <td id="L9168" data-line-number="9168"></td>
        <td id="LC9168">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L9169" data-line-number="9169"></td>
        <td id="LC9169">}</td>
      </tr>
      <tr>
        <td id="L9170" data-line-number="9170"></td>
        <td id="LC9170">
</td>
      </tr>
      <tr>
        <td id="L9171" data-line-number="9171"></td>
        <td id="LC9171">
</td>
      </tr>
      <tr>
        <td id="L9172" data-line-number="9172"></td>
        <td id="LC9172"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9173" data-line-number="9173"></td>
        <td id="LC9173"><span><span>//</span> CordbProcess::ClearUnmanagedBreakpoint</span></td>
      </tr>
      <tr>
        <td id="L9174" data-line-number="9174"></td>
        <td id="LC9174"><span><span>//</span> Called by a native debugger to remove breakpoints during Interop.</span></td>
      </tr>
      <tr>
        <td id="L9175" data-line-number="9175"></td>
        <td id="LC9175"><span><span>//</span> The patch is deleted even if the function fails.</span></td>
      </tr>
      <tr>
        <td id="L9176" data-line-number="9176"></td>
        <td id="LC9176"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9177" data-line-number="9177"></td>
        <td id="LC9177">HRESULT</td>
      </tr>
      <tr>
        <td id="L9178" data-line-number="9178"></td>
        <td id="LC9178"><span>CordbProcess::ClearUnmanagedBreakpoint</span>(CORDB_ADDRESS address)</td>
      </tr>
      <tr>
        <td id="L9179" data-line-number="9179"></td>
        <td id="LC9179">{</td>
      </tr>
      <tr>
        <td id="L9180" data-line-number="9180"></td>
        <td id="LC9180">    <span>LOG</span>((LF_CORDB, LL_INFO100, <span><span>"</span>CP::ClearUnBP: pProcess=%x, address=%p.<span>\n</span><span>"</span></span>, <span>this</span>, <span>CORDB_ADDRESS_TO_PTR</span>(address)));</td>
      </tr>
      <tr>
        <td id="L9181" data-line-number="9181"></td>
        <td id="LC9181">#<span>ifndef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L9182" data-line-number="9182"></td>
        <td id="LC9182">    <span>return</span> E_NOTIMPL;</td>
      </tr>
      <tr>
        <td id="L9183" data-line-number="9183"></td>
        <td id="LC9183">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L9184" data-line-number="9184"></td>
        <td id="LC9184">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9185" data-line-number="9185"></td>
        <td id="LC9185">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9186" data-line-number="9186"></td>
        <td id="LC9186">    <span>FAIL_IF_MANAGED_ONLY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9187" data-line-number="9187"></td>
        <td id="LC9187">
</td>
      </tr>
      <tr>
        <td id="L9188" data-line-number="9188"></td>
        <td id="LC9188">    <span>_ASSERTE</span>(!<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L9189" data-line-number="9189"></td>
        <td id="LC9189">
</td>
      </tr>
      <tr>
        <td id="L9190" data-line-number="9190"></td>
        <td id="LC9190">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L9191" data-line-number="9191"></td>
        <td id="LC9191">    PRD_TYPE opcode;</td>
      </tr>
      <tr>
        <td id="L9192" data-line-number="9192"></td>
        <td id="LC9192">
</td>
      </tr>
      <tr>
        <td id="L9193" data-line-number="9193"></td>
        <td id="LC9193">    <span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L9194" data-line-number="9194"></td>
        <td id="LC9194">
</td>
      </tr>
      <tr>
        <td id="L9195" data-line-number="9195"></td>
        <td id="LC9195">    <span><span>//</span> Make sure this is a valid patch.</span></td>
      </tr>
      <tr>
        <td id="L9196" data-line-number="9196"></td>
        <td id="LC9196">    <span>int</span> cTotal = m_NativePatchList.<span>Count</span>();</td>
      </tr>
      <tr>
        <td id="L9197" data-line-number="9197"></td>
        <td id="LC9197">    NativePatch * pTable = m_NativePatchList.<span>Table</span>();</td>
      </tr>
      <tr>
        <td id="L9198" data-line-number="9198"></td>
        <td id="LC9198">    <span>if</span> (pTable == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9199" data-line-number="9199"></td>
        <td id="LC9199">    {</td>
      </tr>
      <tr>
        <td id="L9200" data-line-number="9200"></td>
        <td id="LC9200">        hr = CORDBG_E_NO_NATIVE_PATCH_AT_ADDR;</td>
      </tr>
      <tr>
        <td id="L9201" data-line-number="9201"></td>
        <td id="LC9201">        <span>goto</span> ErrExit;</td>
      </tr>
      <tr>
        <td id="L9202" data-line-number="9202"></td>
        <td id="LC9202">    }</td>
      </tr>
      <tr>
        <td id="L9203" data-line-number="9203"></td>
        <td id="LC9203">
</td>
      </tr>
      <tr>
        <td id="L9204" data-line-number="9204"></td>
        <td id="LC9204">    <span>int</span> i;</td>
      </tr>
      <tr>
        <td id="L9205" data-line-number="9205"></td>
        <td id="LC9205">    <span>for</span>(i = <span>0</span>; i  &lt; cTotal; i++)</td>
      </tr>
      <tr>
        <td id="L9206" data-line-number="9206"></td>
        <td id="LC9206">    {</td>
      </tr>
      <tr>
        <td id="L9207" data-line-number="9207"></td>
        <td id="LC9207">        <span>if</span> (pTable[i].<span>pAddress</span> == <span>CORDB_ADDRESS_TO_PTR</span>(address))</td>
      </tr>
      <tr>
        <td id="L9208" data-line-number="9208"></td>
        <td id="LC9208">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L9209" data-line-number="9209"></td>
        <td id="LC9209">    }</td>
      </tr>
      <tr>
        <td id="L9210" data-line-number="9210"></td>
        <td id="LC9210">
</td>
      </tr>
      <tr>
        <td id="L9211" data-line-number="9211"></td>
        <td id="LC9211">    <span>if</span> (i &gt;= cTotal)</td>
      </tr>
      <tr>
        <td id="L9212" data-line-number="9212"></td>
        <td id="LC9212">    {</td>
      </tr>
      <tr>
        <td id="L9213" data-line-number="9213"></td>
        <td id="LC9213">        hr = CORDBG_E_NO_NATIVE_PATCH_AT_ADDR;</td>
      </tr>
      <tr>
        <td id="L9214" data-line-number="9214"></td>
        <td id="LC9214">        <span>goto</span> ErrExit;</td>
      </tr>
      <tr>
        <td id="L9215" data-line-number="9215"></td>
        <td id="LC9215">    }</td>
      </tr>
      <tr>
        <td id="L9216" data-line-number="9216"></td>
        <td id="LC9216">
</td>
      </tr>
      <tr>
        <td id="L9217" data-line-number="9217"></td>
        <td id="LC9217">    <span><span>//</span> Found it! Remove it from our table. Note that this may shuffle table contents</span></td>
      </tr>
      <tr>
        <td id="L9218" data-line-number="9218"></td>
        <td id="LC9218">    <span><span>//</span> around, so don't keep pointers into the table.</span></td>
      </tr>
      <tr>
        <td id="L9219" data-line-number="9219"></td>
        <td id="LC9219">    opcode = pTable[i].<span>opcode</span>;</td>
      </tr>
      <tr>
        <td id="L9220" data-line-number="9220"></td>
        <td id="LC9220">
</td>
      </tr>
      <tr>
        <td id="L9221" data-line-number="9221"></td>
        <td id="LC9221">    m_NativePatchList.<span>Delete</span>(pTable[i]);</td>
      </tr>
      <tr>
        <td id="L9222" data-line-number="9222"></td>
        <td id="LC9222">    <span>_ASSERTE</span>(m_NativePatchList.<span>Count</span>() == cTotal - <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L9223" data-line-number="9223"></td>
        <td id="LC9223">
</td>
      </tr>
      <tr>
        <td id="L9224" data-line-number="9224"></td>
        <td id="LC9224">    <span><span>//</span> Now remove the patch.</span></td>
      </tr>
      <tr>
        <td id="L9225" data-line-number="9225"></td>
        <td id="LC9225">
</td>
      </tr>
      <tr>
        <td id="L9226" data-line-number="9226"></td>
        <td id="LC9226">
</td>
      </tr>
      <tr>
        <td id="L9227" data-line-number="9227"></td>
        <td id="LC9227">
</td>
      </tr>
      <tr>
        <td id="L9228" data-line-number="9228"></td>
        <td id="LC9228">    <span><span>//</span> Just call through to Write ProcessMemory</span></td>
      </tr>
      <tr>
        <td id="L9229" data-line-number="9229"></td>
        <td id="LC9229">    hr = <span>RemoveRemotePatch</span>(<span>this</span>, <span>CORDB_ADDRESS_TO_PTR</span>(address), opcode);</td>
      </tr>
      <tr>
        <td id="L9230" data-line-number="9230"></td>
        <td id="LC9230">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L9231" data-line-number="9231"></td>
        <td id="LC9231">        <span>goto</span> ErrExit;</td>
      </tr>
      <tr>
        <td id="L9232" data-line-number="9232"></td>
        <td id="LC9232">
</td>
      </tr>
      <tr>
        <td id="L9233" data-line-number="9233"></td>
        <td id="LC9233">
</td>
      </tr>
      <tr>
        <td id="L9234" data-line-number="9234"></td>
        <td id="LC9234">    <span><span>//</span> Our internal bookeaping was already updated to remove the patch, so now we're done.</span></td>
      </tr>
      <tr>
        <td id="L9235" data-line-number="9235"></td>
        <td id="LC9235">    <span><span>//</span> If we had a failure, we should have already bailed.</span></td>
      </tr>
      <tr>
        <td id="L9236" data-line-number="9236"></td>
        <td id="LC9236">    <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L9237" data-line-number="9237"></td>
        <td id="LC9237">
</td>
      </tr>
      <tr>
        <td id="L9238" data-line-number="9238"></td>
        <td id="LC9238">ErrExit:</td>
      </tr>
      <tr>
        <td id="L9239" data-line-number="9239"></td>
        <td id="LC9239">    <span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L9240" data-line-number="9240"></td>
        <td id="LC9240">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L9241" data-line-number="9241"></td>
        <td id="LC9241">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L9242" data-line-number="9242"></td>
        <td id="LC9242">}</td>
      </tr>
      <tr>
        <td id="L9243" data-line-number="9243"></td>
        <td id="LC9243">
</td>
      </tr>
      <tr>
        <td id="L9244" data-line-number="9244"></td>
        <td id="LC9244">
</td>
      </tr>
      <tr>
        <td id="L9245" data-line-number="9245"></td>
        <td id="LC9245"><span><span>//</span>------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9246" data-line-number="9246"></td>
        <td id="LC9246"><span><span>//</span> StopCount, Sync, SyncReceived form our stop-status. This status is super-critical</span></td>
      </tr>
      <tr>
        <td id="L9247" data-line-number="9247"></td>
        <td id="LC9247"><span><span>//</span> to most hangs, so we stress log it.</span></td>
      </tr>
      <tr>
        <td id="L9248" data-line-number="9248"></td>
        <td id="LC9248"><span><span>//</span>------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9249" data-line-number="9249"></td>
        <td id="LC9249"><span>void</span> <span>CordbProcess::SetSynchronized</span>(<span>bool</span> <span>fSynch</span>)</td>
      </tr>
      <tr>
        <td id="L9250" data-line-number="9250"></td>
        <td id="LC9250">{</td>
      </tr>
      <tr>
        <td id="L9251" data-line-number="9251"></td>
        <td id="LC9251">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>() || !<span><span>"</span>Must have process lock to toggle SyncStatus<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L9252" data-line-number="9252"></td>
        <td id="LC9252">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP:: set sync=%d<span>\n</span><span>"</span></span>, <span>fSynch</span>);</td>
      </tr>
      <tr>
        <td id="L9253" data-line-number="9253"></td>
        <td id="LC9253">    m_synchronized = <span>fSynch</span>;</td>
      </tr>
      <tr>
        <td id="L9254" data-line-number="9254"></td>
        <td id="LC9254">}</td>
      </tr>
      <tr>
        <td id="L9255" data-line-number="9255"></td>
        <td id="LC9255">
</td>
      </tr>
      <tr>
        <td id="L9256" data-line-number="9256"></td>
        <td id="LC9256"><span>bool</span> <span>CordbProcess::GetSynchronized</span>()</td>
      </tr>
      <tr>
        <td id="L9257" data-line-number="9257"></td>
        <td id="LC9257">{</td>
      </tr>
      <tr>
        <td id="L9258" data-line-number="9258"></td>
        <td id="LC9258">    <span><span>//</span> This can be accessed whether we're Locked or not. This means that the result</span></td>
      </tr>
      <tr>
        <td id="L9259" data-line-number="9259"></td>
        <td id="LC9259">    <span><span>//</span> may change underneath us.</span></td>
      </tr>
      <tr>
        <td id="L9260" data-line-number="9260"></td>
        <td id="LC9260">    <span>return</span> m_synchronized;</td>
      </tr>
      <tr>
        <td id="L9261" data-line-number="9261"></td>
        <td id="LC9261">}</td>
      </tr>
      <tr>
        <td id="L9262" data-line-number="9262"></td>
        <td id="LC9262">
</td>
      </tr>
      <tr>
        <td id="L9263" data-line-number="9263"></td>
        <td id="LC9263"><span>void</span> <span>CordbProcess::IncStopCount</span>()</td>
      </tr>
      <tr>
        <td id="L9264" data-line-number="9264"></td>
        <td id="LC9264">{</td>
      </tr>
      <tr>
        <td id="L9265" data-line-number="9265"></td>
        <td id="LC9265">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L9266" data-line-number="9266"></td>
        <td id="LC9266">    m_stopCount++;</td>
      </tr>
      <tr>
        <td id="L9267" data-line-number="9267"></td>
        <td id="LC9267">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP:: Inc StopCount=%d<span>\n</span><span>"</span></span>, m_stopCount);</td>
      </tr>
      <tr>
        <td id="L9268" data-line-number="9268"></td>
        <td id="LC9268">}</td>
      </tr>
      <tr>
        <td id="L9269" data-line-number="9269"></td>
        <td id="LC9269"><span>void</span> <span>CordbProcess::DecStopCount</span>()</td>
      </tr>
      <tr>
        <td id="L9270" data-line-number="9270"></td>
        <td id="LC9270">{</td>
      </tr>
      <tr>
        <td id="L9271" data-line-number="9271"></td>
        <td id="LC9271">    <span><span>//</span> We can inc w/ just the process lock (b/c we can dispatch events from the W32ET)</span></td>
      </tr>
      <tr>
        <td id="L9272" data-line-number="9272"></td>
        <td id="LC9272">    <span><span>//</span> But decrementing (eg, Continue), requires the stop-go lock.</span></td>
      </tr>
      <tr>
        <td id="L9273" data-line-number="9273"></td>
        <td id="LC9273">    <span><span>//</span> This if an operation takes the SG lock, it ensures we don't continue from underneath it.</span></td>
      </tr>
      <tr>
        <td id="L9274" data-line-number="9274"></td>
        <td id="LC9274">    <span>ASSERT_SINGLE_THREAD_ONLY</span>(<span>HoldsLock</span>(&amp;m_StopGoLock));</td>
      </tr>
      <tr>
        <td id="L9275" data-line-number="9275"></td>
        <td id="LC9275">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L9276" data-line-number="9276"></td>
        <td id="LC9276">
</td>
      </tr>
      <tr>
        <td id="L9277" data-line-number="9277"></td>
        <td id="LC9277">    m_stopCount--;</td>
      </tr>
      <tr>
        <td id="L9278" data-line-number="9278"></td>
        <td id="LC9278">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP:: Dec StopCount=%d<span>\n</span><span>"</span></span>, m_stopCount);</td>
      </tr>
      <tr>
        <td id="L9279" data-line-number="9279"></td>
        <td id="LC9279">}</td>
      </tr>
      <tr>
        <td id="L9280" data-line-number="9280"></td>
        <td id="LC9280">
</td>
      </tr>
      <tr>
        <td id="L9281" data-line-number="9281"></td>
        <td id="LC9281"><span><span>//</span> Just gets whether we're stopped or not (m_stopped &gt; 0).</span></td>
      </tr>
      <tr>
        <td id="L9282" data-line-number="9282"></td>
        <td id="LC9282"><span><span>//</span> You only need the StopGo lock for this.</span></td>
      </tr>
      <tr>
        <td id="L9283" data-line-number="9283"></td>
        <td id="LC9283"><span>bool</span> <span>CordbProcess::IsStopped</span>()</td>
      </tr>
      <tr>
        <td id="L9284" data-line-number="9284"></td>
        <td id="LC9284">{</td>
      </tr>
      <tr>
        <td id="L9285" data-line-number="9285"></td>
        <td id="LC9285">    <span><span>//</span> We don't require the process-lock, just the SG-lock.</span></td>
      </tr>
      <tr>
        <td id="L9286" data-line-number="9286"></td>
        <td id="LC9286">    <span><span>//</span> Holding the SG lock prevents another thread from continuing underneath you.</span></td>
      </tr>
      <tr>
        <td id="L9287" data-line-number="9287"></td>
        <td id="LC9287">    <span><span>//</span> (see DecStopCount()).</span></td>
      </tr>
      <tr>
        <td id="L9288" data-line-number="9288"></td>
        <td id="LC9288">    <span><span>//</span> But you could still be running free, and have another thread stop-underneath you.</span></td>
      </tr>
      <tr>
        <td id="L9289" data-line-number="9289"></td>
        <td id="LC9289">    <span><span>//</span> Thus IsStopped() leans towards returning false.</span></td>
      </tr>
      <tr>
        <td id="L9290" data-line-number="9290"></td>
        <td id="LC9290">    <span>ASSERT_SINGLE_THREAD_ONLY</span>(<span>HoldsLock</span>(&amp;m_StopGoLock));</td>
      </tr>
      <tr>
        <td id="L9291" data-line-number="9291"></td>
        <td id="LC9291">
</td>
      </tr>
      <tr>
        <td id="L9292" data-line-number="9292"></td>
        <td id="LC9292">    <span>return</span> (m_stopCount &gt; <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L9293" data-line-number="9293"></td>
        <td id="LC9293">}</td>
      </tr>
      <tr>
        <td id="L9294" data-line-number="9294"></td>
        <td id="LC9294">
</td>
      </tr>
      <tr>
        <td id="L9295" data-line-number="9295"></td>
        <td id="LC9295"><span>int</span> <span>CordbProcess::GetStopCount</span>()</td>
      </tr>
      <tr>
        <td id="L9296" data-line-number="9296"></td>
        <td id="LC9296">{</td>
      </tr>
      <tr>
        <td id="L9297" data-line-number="9297"></td>
        <td id="LC9297">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L9298" data-line-number="9298"></td>
        <td id="LC9298">    <span>return</span> m_stopCount;</td>
      </tr>
      <tr>
        <td id="L9299" data-line-number="9299"></td>
        <td id="LC9299">}</td>
      </tr>
      <tr>
        <td id="L9300" data-line-number="9300"></td>
        <td id="LC9300">
</td>
      </tr>
      <tr>
        <td id="L9301" data-line-number="9301"></td>
        <td id="LC9301"><span>bool</span> <span>CordbProcess::GetSyncCompleteRecv</span>()</td>
      </tr>
      <tr>
        <td id="L9302" data-line-number="9302"></td>
        <td id="LC9302">{</td>
      </tr>
      <tr>
        <td id="L9303" data-line-number="9303"></td>
        <td id="LC9303">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L9304" data-line-number="9304"></td>
        <td id="LC9304">    <span>return</span> m_syncCompleteReceived;</td>
      </tr>
      <tr>
        <td id="L9305" data-line-number="9305"></td>
        <td id="LC9305">}</td>
      </tr>
      <tr>
        <td id="L9306" data-line-number="9306"></td>
        <td id="LC9306">
</td>
      </tr>
      <tr>
        <td id="L9307" data-line-number="9307"></td>
        <td id="LC9307"><span>void</span> <span>CordbProcess::SetSyncCompleteRecv</span>(<span>bool</span> <span>fSyncRecv</span>)</td>
      </tr>
      <tr>
        <td id="L9308" data-line-number="9308"></td>
        <td id="LC9308">{</td>
      </tr>
      <tr>
        <td id="L9309" data-line-number="9309"></td>
        <td id="LC9309">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L9310" data-line-number="9310"></td>
        <td id="LC9310">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP:: set syncRecv=%d<span>\n</span><span>"</span></span>, <span>fSyncRecv</span>);</td>
      </tr>
      <tr>
        <td id="L9311" data-line-number="9311"></td>
        <td id="LC9311">    m_syncCompleteReceived = <span>fSyncRecv</span>;</td>
      </tr>
      <tr>
        <td id="L9312" data-line-number="9312"></td>
        <td id="LC9312">}</td>
      </tr>
      <tr>
        <td id="L9313" data-line-number="9313"></td>
        <td id="LC9313">
</td>
      </tr>
      <tr>
        <td id="L9314" data-line-number="9314"></td>
        <td id="LC9314"><span><span>//</span> This can be used if we ever need the RS to emulate old behavior of previous versions.</span></td>
      </tr>
      <tr>
        <td id="L9315" data-line-number="9315"></td>
        <td id="LC9315"><span><span>//</span> This can not be used in QIs to deny queries for new interfaces.</span></td>
      </tr>
      <tr>
        <td id="L9316" data-line-number="9316"></td>
        <td id="LC9316"><span><span>//</span> QIs must be consistent across the lifetime of an object. Say CordbThread used this in a QI</span></td>
      </tr>
      <tr>
        <td id="L9317" data-line-number="9317"></td>
        <td id="LC9317"><span><span>//</span> do deny returning a ICorDebugThread2 interface when emulating v1.1. Once that Thread is neutered,</span></td>
      </tr>
      <tr>
        <td id="L9318" data-line-number="9318"></td>
        <td id="LC9318"><span><span>//</span> it no longer has a pointer to the process, and it no longer knows if it should be denying</span></td>
      </tr>
      <tr>
        <td id="L9319" data-line-number="9319"></td>
        <td id="LC9319"><span><span>//</span> the v2.0 query. An object's QI can't start returning new interfaces onces its neutered.</span></td>
      </tr>
      <tr>
        <td id="L9320" data-line-number="9320"></td>
        <td id="LC9320"><span>bool</span> <span>CordbProcess::SupportsVersion</span>(CorDebugInterfaceVersion featureVersion)</td>
      </tr>
      <tr>
        <td id="L9321" data-line-number="9321"></td>
        <td id="LC9321">{</td>
      </tr>
      <tr>
        <td id="L9322" data-line-number="9322"></td>
        <td id="LC9322">    <span>_ASSERTE</span>(featureVersion == CorDebugVersion_2_0);</td>
      </tr>
      <tr>
        <td id="L9323" data-line-number="9323"></td>
        <td id="LC9323">    <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L9324" data-line-number="9324"></td>
        <td id="LC9324">}</td>
      </tr>
      <tr>
        <td id="L9325" data-line-number="9325"></td>
        <td id="LC9325">
</td>
      </tr>
      <tr>
        <td id="L9326" data-line-number="9326"></td>
        <td id="LC9326">
</td>
      </tr>
      <tr>
        <td id="L9327" data-line-number="9327"></td>
        <td id="LC9327"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9328" data-line-number="9328"></td>
        <td id="LC9328"><span><span>//</span> Add an object to the process's Left-Side resource cleanup list</span></td>
      </tr>
      <tr>
        <td id="L9329" data-line-number="9329"></td>
        <td id="LC9329"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9330" data-line-number="9330"></td>
        <td id="LC9330"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L9331" data-line-number="9331"></td>
        <td id="LC9331"><span><span>//</span>    pObject - non-null object to be added</span></td>
      </tr>
      <tr>
        <td id="L9332" data-line-number="9332"></td>
        <td id="LC9332"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9333" data-line-number="9333"></td>
        <td id="LC9333"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L9334" data-line-number="9334"></td>
        <td id="LC9334"><span><span>//</span>    This list tracks objects with process-scope that hold left-side</span></td>
      </tr>
      <tr>
        <td id="L9335" data-line-number="9335"></td>
        <td id="LC9335"><span><span>//</span>    resources (like func-eval).</span></td>
      </tr>
      <tr>
        <td id="L9336" data-line-number="9336"></td>
        <td id="LC9336"><span><span>//</span>    See code:CordbAppDomain::GetSweepableExitNeuterList for per-appdomain</span></td>
      </tr>
      <tr>
        <td id="L9337" data-line-number="9337"></td>
        <td id="LC9337"><span><span>//</span>    objects with left-side resources.</span></td>
      </tr>
      <tr>
        <td id="L9338" data-line-number="9338"></td>
        <td id="LC9338"><span>void</span> <span>CordbProcess::AddToLeftSideResourceCleanupList</span>(CordbBase * pObject)</td>
      </tr>
      <tr>
        <td id="L9339" data-line-number="9339"></td>
        <td id="LC9339">{</td>
      </tr>
      <tr>
        <td id="L9340" data-line-number="9340"></td>
        <td id="LC9340">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9341" data-line-number="9341"></td>
        <td id="LC9341">    <span>_ASSERTE</span>(pObject != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9342" data-line-number="9342"></td>
        <td id="LC9342">
</td>
      </tr>
      <tr>
        <td id="L9343" data-line-number="9343"></td>
        <td id="LC9343">    m_LeftSideResourceCleanupList.<span>Add</span>(<span>this</span>, pObject);</td>
      </tr>
      <tr>
        <td id="L9344" data-line-number="9344"></td>
        <td id="LC9344">}</td>
      </tr>
      <tr>
        <td id="L9345" data-line-number="9345"></td>
        <td id="LC9345">
</td>
      </tr>
      <tr>
        <td id="L9346" data-line-number="9346"></td>
        <td id="LC9346"><span><span>//</span> This list will get actively swept (looking for objects w/ external ref = 0) between continues.</span></td>
      </tr>
      <tr>
        <td id="L9347" data-line-number="9347"></td>
        <td id="LC9347"><span>void</span> <span>CordbProcess::AddToNeuterOnExitList</span>(CordbBase *pObject)</td>
      </tr>
      <tr>
        <td id="L9348" data-line-number="9348"></td>
        <td id="LC9348">{</td>
      </tr>
      <tr>
        <td id="L9349" data-line-number="9349"></td>
        <td id="LC9349">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9350" data-line-number="9350"></td>
        <td id="LC9350">    <span>_ASSERTE</span>(pObject != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9351" data-line-number="9351"></td>
        <td id="LC9351">
</td>
      </tr>
      <tr>
        <td id="L9352" data-line-number="9352"></td>
        <td id="LC9352">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L9353" data-line-number="9353"></td>
        <td id="LC9353">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L9354" data-line-number="9354"></td>
        <td id="LC9354">    {</td>
      </tr>
      <tr>
        <td id="L9355" data-line-number="9355"></td>
        <td id="LC9355">        <span>this</span>-&gt;<span>m_ExitNeuterList</span>.<span>Add</span>(<span>this</span>, pObject);</td>
      </tr>
      <tr>
        <td id="L9356" data-line-number="9356"></td>
        <td id="LC9356">    }</td>
      </tr>
      <tr>
        <td id="L9357" data-line-number="9357"></td>
        <td id="LC9357">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L9358" data-line-number="9358"></td>
        <td id="LC9358">    <span>SetUnrecoverableIfFailed</span>(<span>GetProcess</span>(), hr);</td>
      </tr>
      <tr>
        <td id="L9359" data-line-number="9359"></td>
        <td id="LC9359">}</td>
      </tr>
      <tr>
        <td id="L9360" data-line-number="9360"></td>
        <td id="LC9360">
</td>
      </tr>
      <tr>
        <td id="L9361" data-line-number="9361"></td>
        <td id="LC9361"><span><span>//</span> Mark that this object should be neutered the next time we Continue the process.</span></td>
      </tr>
      <tr>
        <td id="L9362" data-line-number="9362"></td>
        <td id="LC9362"><span>void</span> <span>CordbProcess::AddToNeuterOnContinueList</span>(CordbBase *pObject)</td>
      </tr>
      <tr>
        <td id="L9363" data-line-number="9363"></td>
        <td id="LC9363">{</td>
      </tr>
      <tr>
        <td id="L9364" data-line-number="9364"></td>
        <td id="LC9364">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9365" data-line-number="9365"></td>
        <td id="LC9365">    <span>_ASSERTE</span>(pObject != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9366" data-line-number="9366"></td>
        <td id="LC9366">
</td>
      </tr>
      <tr>
        <td id="L9367" data-line-number="9367"></td>
        <td id="LC9367">    m_ContinueNeuterList.<span>Add</span>(<span>this</span>, pObject); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L9368" data-line-number="9368"></td>
        <td id="LC9368">}</td>
      </tr>
      <tr>
        <td id="L9369" data-line-number="9369"></td>
        <td id="LC9369">
</td>
      </tr>
      <tr>
        <td id="L9370" data-line-number="9370"></td>
        <td id="LC9370">
</td>
      </tr>
      <tr>
        <td id="L9371" data-line-number="9371"></td>
        <td id="LC9371"><span><span>/*</span> ------------------------------------------------------------------------- *</span></td>
      </tr>
      <tr>
        <td id="L9372" data-line-number="9372"></td>
        <td id="LC9372"><span> * Runtime Controller Event Thread class</span></td>
      </tr>
      <tr>
        <td id="L9373" data-line-number="9373"></td>
        <td id="LC9373"><span> * ------------------------------------------------------------------------- <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L9374" data-line-number="9374"></td>
        <td id="LC9374">
</td>
      </tr>
      <tr>
        <td id="L9375" data-line-number="9375"></td>
        <td id="LC9375"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9376" data-line-number="9376"></td>
        <td id="LC9376"><span><span>//</span> Constructor</span></td>
      </tr>
      <tr>
        <td id="L9377" data-line-number="9377"></td>
        <td id="LC9377"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9378" data-line-number="9378"></td>
        <td id="LC9378"><span>CordbRCEventThread::CordbRCEventThread</span>(Cordb* cordb)</td>
      </tr>
      <tr>
        <td id="L9379" data-line-number="9379"></td>
        <td id="LC9379">{</td>
      </tr>
      <tr>
        <td id="L9380" data-line-number="9380"></td>
        <td id="LC9380">    <span>_ASSERTE</span>(cordb != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9381" data-line-number="9381"></td>
        <td id="LC9381">
</td>
      </tr>
      <tr>
        <td id="L9382" data-line-number="9382"></td>
        <td id="LC9382">    m_cordb.<span>Assign</span>(cordb);</td>
      </tr>
      <tr>
        <td id="L9383" data-line-number="9383"></td>
        <td id="LC9383">    m_thread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L9384" data-line-number="9384"></td>
        <td id="LC9384">    m_threadId = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L9385" data-line-number="9385"></td>
        <td id="LC9385">    m_run = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L9386" data-line-number="9386"></td>
        <td id="LC9386">    m_threadControlEvent = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L9387" data-line-number="9387"></td>
        <td id="LC9387">    m_processStateChanged = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L9388" data-line-number="9388"></td>
        <td id="LC9388">
</td>
      </tr>
      <tr>
        <td id="L9389" data-line-number="9389"></td>
        <td id="LC9389">    g_pRSDebuggingInfo-&gt;<span>m_RCET</span> = <span>this</span>;</td>
      </tr>
      <tr>
        <td id="L9390" data-line-number="9390"></td>
        <td id="LC9390">}</td>
      </tr>
      <tr>
        <td id="L9391" data-line-number="9391"></td>
        <td id="LC9391">
</td>
      </tr>
      <tr>
        <td id="L9392" data-line-number="9392"></td>
        <td id="LC9392">
</td>
      </tr>
      <tr>
        <td id="L9393" data-line-number="9393"></td>
        <td id="LC9393"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9394" data-line-number="9394"></td>
        <td id="LC9394"><span><span>//</span> Destructor. Cleans up all of the open handles and such.</span></td>
      </tr>
      <tr>
        <td id="L9395" data-line-number="9395"></td>
        <td id="LC9395"><span><span>//</span> This expects that the thread has been stopped and has terminated</span></td>
      </tr>
      <tr>
        <td id="L9396" data-line-number="9396"></td>
        <td id="LC9396"><span><span>//</span> before being called.</span></td>
      </tr>
      <tr>
        <td id="L9397" data-line-number="9397"></td>
        <td id="LC9397"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9398" data-line-number="9398"></td>
        <td id="LC9398"><span>CordbRCEventThread::~CordbRCEventThread</span>()</td>
      </tr>
      <tr>
        <td id="L9399" data-line-number="9399"></td>
        <td id="LC9399">{</td>
      </tr>
      <tr>
        <td id="L9400" data-line-number="9400"></td>
        <td id="LC9400">    <span>if</span> (m_threadControlEvent != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9401" data-line-number="9401"></td>
        <td id="LC9401">        <span>CloseHandle</span>(m_threadControlEvent);</td>
      </tr>
      <tr>
        <td id="L9402" data-line-number="9402"></td>
        <td id="LC9402">
</td>
      </tr>
      <tr>
        <td id="L9403" data-line-number="9403"></td>
        <td id="LC9403">    <span>if</span> (m_thread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9404" data-line-number="9404"></td>
        <td id="LC9404">        <span>CloseHandle</span>(m_thread);</td>
      </tr>
      <tr>
        <td id="L9405" data-line-number="9405"></td>
        <td id="LC9405">
</td>
      </tr>
      <tr>
        <td id="L9406" data-line-number="9406"></td>
        <td id="LC9406">    g_pRSDebuggingInfo-&gt;<span>m_RCET</span> = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L9407" data-line-number="9407"></td>
        <td id="LC9407">}</td>
      </tr>
      <tr>
        <td id="L9408" data-line-number="9408"></td>
        <td id="LC9408">
</td>
      </tr>
      <tr>
        <td id="L9409" data-line-number="9409"></td>
        <td id="LC9409"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9410" data-line-number="9410"></td>
        <td id="LC9410"><span><span>//</span> Init sets up all the objects that the thread will need to run.</span></td>
      </tr>
      <tr>
        <td id="L9411" data-line-number="9411"></td>
        <td id="LC9411"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9412" data-line-number="9412"></td>
        <td id="LC9412">HRESULT <span>CordbRCEventThread::Init</span>()</td>
      </tr>
      <tr>
        <td id="L9413" data-line-number="9413"></td>
        <td id="LC9413">{</td>
      </tr>
      <tr>
        <td id="L9414" data-line-number="9414"></td>
        <td id="LC9414">    <span>if</span> (m_cordb == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9415" data-line-number="9415"></td>
        <td id="LC9415">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L9416" data-line-number="9416"></td>
        <td id="LC9416">
</td>
      </tr>
      <tr>
        <td id="L9417" data-line-number="9417"></td>
        <td id="LC9417">    m_threadControlEvent = <span>WszCreateEvent</span>(<span>NULL</span>, <span>FALSE</span>, <span>FALSE</span>, <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9418" data-line-number="9418"></td>
        <td id="LC9418">
</td>
      </tr>
      <tr>
        <td id="L9419" data-line-number="9419"></td>
        <td id="LC9419">    <span>if</span> (m_threadControlEvent == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9420" data-line-number="9420"></td>
        <td id="LC9420">        <span>return</span> <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L9421" data-line-number="9421"></td>
        <td id="LC9421">
</td>
      </tr>
      <tr>
        <td id="L9422" data-line-number="9422"></td>
        <td id="LC9422">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L9423" data-line-number="9423"></td>
        <td id="LC9423">}</td>
      </tr>
      <tr>
        <td id="L9424" data-line-number="9424"></td>
        <td id="LC9424">
</td>
      </tr>
      <tr>
        <td id="L9425" data-line-number="9425"></td>
        <td id="LC9425">
</td>
      </tr>
      <tr>
        <td id="L9426" data-line-number="9426"></td>
        <td id="LC9426">#<span>if</span> defined(FEATURE_INTEROP_DEBUGGING)</td>
      </tr>
      <tr>
        <td id="L9427" data-line-number="9427"></td>
        <td id="LC9427"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9428" data-line-number="9428"></td>
        <td id="LC9428"><span><span>//</span> Helper to duplicate a handle or thorw</span></td>
      </tr>
      <tr>
        <td id="L9429" data-line-number="9429"></td>
        <td id="LC9429"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9430" data-line-number="9430"></td>
        <td id="LC9430"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L9431" data-line-number="9431"></td>
        <td id="LC9431"><span><span>//</span>     pLocalHandle - handle to duplicate into the remote process</span></td>
      </tr>
      <tr>
        <td id="L9432" data-line-number="9432"></td>
        <td id="LC9432"><span><span>//</span>     pRemoteHandle - RemoteHandle structure in IPC block to hold the remote handle.</span></td>
      </tr>
      <tr>
        <td id="L9433" data-line-number="9433"></td>
        <td id="LC9433"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L9434" data-line-number="9434"></td>
        <td id="LC9434"><span><span>//</span>     None. Throws on error.</span></td>
      </tr>
      <tr>
        <td id="L9435" data-line-number="9435"></td>
        <td id="LC9435"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9436" data-line-number="9436"></td>
        <td id="LC9436"><span>void</span> <span>CordbProcess::DuplicateHandleToLocalProcess</span>(HANDLE * pLocalHandle, RemoteHANDLE * pRemoteHandle)</td>
      </tr>
      <tr>
        <td id="L9437" data-line-number="9437"></td>
        <td id="LC9437">{</td>
      </tr>
      <tr>
        <td id="L9438" data-line-number="9438"></td>
        <td id="LC9438">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9439" data-line-number="9439"></td>
        <td id="LC9439">
</td>
      </tr>
      <tr>
        <td id="L9440" data-line-number="9440"></td>
        <td id="LC9440">    <span><span>//</span> Dup RSEA and RSER into this process if we don't already have them.</span></td>
      </tr>
      <tr>
        <td id="L9441" data-line-number="9441"></td>
        <td id="LC9441">    <span><span>//</span> On Launch, we don't have them yet, but on attach we do.</span></td>
      </tr>
      <tr>
        <td id="L9442" data-line-number="9442"></td>
        <td id="LC9442">    <span>if</span> (*pLocalHandle == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9443" data-line-number="9443"></td>
        <td id="LC9443">    {</td>
      </tr>
      <tr>
        <td id="L9444" data-line-number="9444"></td>
        <td id="LC9444">        BOOL <span>fSuccess</span> = pRemoteHandle-&gt;<span>DuplicateToLocalProcess</span>(m_handle, pLocalHandle);</td>
      </tr>
      <tr>
        <td id="L9445" data-line-number="9445"></td>
        <td id="LC9445">        <span>if</span> (!<span>fSuccess</span>)</td>
      </tr>
      <tr>
        <td id="L9446" data-line-number="9446"></td>
        <td id="LC9446">        {</td>
      </tr>
      <tr>
        <td id="L9447" data-line-number="9447"></td>
        <td id="LC9447">            <span>ThrowLastError</span>();</td>
      </tr>
      <tr>
        <td id="L9448" data-line-number="9448"></td>
        <td id="LC9448">        }</td>
      </tr>
      <tr>
        <td id="L9449" data-line-number="9449"></td>
        <td id="LC9449">    }</td>
      </tr>
      <tr>
        <td id="L9450" data-line-number="9450"></td>
        <td id="LC9450">
</td>
      </tr>
      <tr>
        <td id="L9451" data-line-number="9451"></td>
        <td id="LC9451">}</td>
      </tr>
      <tr>
        <td id="L9452" data-line-number="9452"></td>
        <td id="LC9452">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L9453" data-line-number="9453"></td>
        <td id="LC9453">
</td>
      </tr>
      <tr>
        <td id="L9454" data-line-number="9454"></td>
        <td id="LC9454"><span><span>//</span> Public entry wrapper for code:CordbProcess::FinishInitializeIPCChannelWorker</span></td>
      </tr>
      <tr>
        <td id="L9455" data-line-number="9455"></td>
        <td id="LC9455"><span>void</span> <span>CordbProcess::FinishInitializeIPCChannel</span>()</td>
      </tr>
      <tr>
        <td id="L9456" data-line-number="9456"></td>
        <td id="LC9456">{</td>
      </tr>
      <tr>
        <td id="L9457" data-line-number="9457"></td>
        <td id="LC9457">    <span><span>//</span> This is called directly from a shim callback.</span></td>
      </tr>
      <tr>
        <td id="L9458" data-line-number="9458"></td>
        <td id="LC9458">    <span>PUBLIC_API_ENTRY_FOR_SHIM</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L9459" data-line-number="9459"></td>
        <td id="LC9459">    <span>FinishInitializeIPCChannelWorker</span>();</td>
      </tr>
      <tr>
        <td id="L9460" data-line-number="9460"></td>
        <td id="LC9460">}</td>
      </tr>
      <tr>
        <td id="L9461" data-line-number="9461"></td>
        <td id="LC9461">
</td>
      </tr>
      <tr>
        <td id="L9462" data-line-number="9462"></td>
        <td id="LC9462"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9463" data-line-number="9463"></td>
        <td id="LC9463"><span><span>//</span> Initialize the IPC channel. After this, IPC events can flow in both ways.</span></td>
      </tr>
      <tr>
        <td id="L9464" data-line-number="9464"></td>
        <td id="LC9464"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9465" data-line-number="9465"></td>
        <td id="LC9465"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L9466" data-line-number="9466"></td>
        <td id="LC9466"><span><span>//</span>     Returns S_OK on success.</span></td>
      </tr>
      <tr>
        <td id="L9467" data-line-number="9467"></td>
        <td id="LC9467"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9468" data-line-number="9468"></td>
        <td id="LC9468"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L9469" data-line-number="9469"></td>
        <td id="LC9469"><span><span>//</span>     This will dispatch an UnrecoverableError callback if it fails.</span></td>
      </tr>
      <tr>
        <td id="L9470" data-line-number="9470"></td>
        <td id="LC9470"><span><span>//</span>     This will also initialize key state in the CordbProcess object.</span></td>
      </tr>
      <tr>
        <td id="L9471" data-line-number="9471"></td>
        <td id="LC9471"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9472" data-line-number="9472"></td>
        <td id="LC9472"><span><span>//</span> @dbgtodo remove helper-thread: this should eventually go away once we get rid of IPC events.</span></td>
      </tr>
      <tr>
        <td id="L9473" data-line-number="9473"></td>
        <td id="LC9473"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9474" data-line-number="9474"></td>
        <td id="LC9474"><span>void</span> <span>CordbProcess::FinishInitializeIPCChannelWorker</span>()</td>
      </tr>
      <tr>
        <td id="L9475" data-line-number="9475"></td>
        <td id="LC9475">{</td>
      </tr>
      <tr>
        <td id="L9476" data-line-number="9476"></td>
        <td id="LC9476">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L9477" data-line-number="9477"></td>
        <td id="LC9477">    {</td>
      </tr>
      <tr>
        <td id="L9478" data-line-number="9478"></td>
        <td id="LC9478">        THROWS;</td>
      </tr>
      <tr>
        <td id="L9479" data-line-number="9479"></td>
        <td id="LC9479">    }</td>
      </tr>
      <tr>
        <td id="L9480" data-line-number="9480"></td>
        <td id="LC9480">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L9481" data-line-number="9481"></td>
        <td id="LC9481">
</td>
      </tr>
      <tr>
        <td id="L9482" data-line-number="9482"></td>
        <td id="LC9482">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L9483" data-line-number="9483"></td>
        <td id="LC9483">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9484" data-line-number="9484"></td>
        <td id="LC9484">
</td>
      </tr>
      <tr>
        <td id="L9485" data-line-number="9485"></td>
        <td id="LC9485">    RSLockHolder <span>lockHolder</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L9486" data-line-number="9486"></td>
        <td id="LC9486">
</td>
      </tr>
      <tr>
        <td id="L9487" data-line-number="9487"></td>
        <td id="LC9487">    <span><span>//</span> If it's already initialized, then nothing left to do.</span></td>
      </tr>
      <tr>
        <td id="L9488" data-line-number="9488"></td>
        <td id="LC9488">    <span><span>//</span> this protects us if this function is called multiple times.</span></td>
      </tr>
      <tr>
        <td id="L9489" data-line-number="9489"></td>
        <td id="LC9489">    <span>if</span> (m_initialized)</td>
      </tr>
      <tr>
        <td id="L9490" data-line-number="9490"></td>
        <td id="LC9490">    {</td>
      </tr>
      <tr>
        <td id="L9491" data-line-number="9491"></td>
        <td id="LC9491">        <span>_ASSERTE</span>(<span>GetDCB</span>() != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9492" data-line-number="9492"></td>
        <td id="LC9492">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L9493" data-line-number="9493"></td>
        <td id="LC9493">    }</td>
      </tr>
      <tr>
        <td id="L9494" data-line-number="9494"></td>
        <td id="LC9494">
</td>
      </tr>
      <tr>
        <td id="L9495" data-line-number="9495"></td>
        <td id="LC9495">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L9496" data-line-number="9496"></td>
        <td id="LC9496">    {</td>
      </tr>
      <tr>
        <td id="L9497" data-line-number="9497"></td>
        <td id="LC9497">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] RCET::HFRCE: first event..., process %p<span>\n</span><span>"</span></span>, <span>GetCurrentThreadId</span>(), <span>this</span>));</td>
      </tr>
      <tr>
        <td id="L9498" data-line-number="9498"></td>
        <td id="LC9498">
</td>
      </tr>
      <tr>
        <td id="L9499" data-line-number="9499"></td>
        <td id="LC9499">        BOOL <span>fBlockExists</span>;</td>
      </tr>
      <tr>
        <td id="L9500" data-line-number="9500"></td>
        <td id="LC9500">        <span>GetEventBlock</span>(&amp;<span>fBlockExists</span>); <span><span>//</span> throws on error</span></td>
      </tr>
      <tr>
        <td id="L9501" data-line-number="9501"></td>
        <td id="LC9501">
</td>
      </tr>
      <tr>
        <td id="L9502" data-line-number="9502"></td>
        <td id="LC9502">        <span>LOG</span>((LF_CORDB, LL_EVERYTHING, <span><span>"</span>Size of CdbP is %d<span>\n</span><span>"</span></span>, <span>sizeof</span>(CordbProcess)));</td>
      </tr>
      <tr>
        <td id="L9503" data-line-number="9503"></td>
        <td id="LC9503">
</td>
      </tr>
      <tr>
        <td id="L9504" data-line-number="9504"></td>
        <td id="LC9504">        m_pEventChannel-&gt;<span>Init</span>(m_handle);</td>
      </tr>
      <tr>
        <td id="L9505" data-line-number="9505"></td>
        <td id="LC9505">
</td>
      </tr>
      <tr>
        <td id="L9506" data-line-number="9506"></td>
        <td id="LC9506">#<span>if</span> defined(FEATURE_INTEROP_DEBUGGING)</td>
      </tr>
      <tr>
        <td id="L9507" data-line-number="9507"></td>
        <td id="LC9507">        <span>DuplicateHandleToLocalProcess</span>(&amp;m_leftSideUnmanagedWaitEvent, &amp;<span>GetDCB</span>()-&gt;<span>m_leftSideUnmanagedWaitEvent</span>);</td>
      </tr>
      <tr>
        <td id="L9508" data-line-number="9508"></td>
        <td id="LC9508">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L9509" data-line-number="9509"></td>
        <td id="LC9509">
</td>
      </tr>
      <tr>
        <td id="L9510" data-line-number="9510"></td>
        <td id="LC9510">        <span><span>//</span> Read the Runtime Offsets struct out of the debuggee.</span></td>
      </tr>
      <tr>
        <td id="L9511" data-line-number="9511"></td>
        <td id="LC9511">        hr = <span>GetRuntimeOffsets</span>();</td>
      </tr>
      <tr>
        <td id="L9512" data-line-number="9512"></td>
        <td id="LC9512">        <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L9513" data-line-number="9513"></td>
        <td id="LC9513">
</td>
      </tr>
      <tr>
        <td id="L9514" data-line-number="9514"></td>
        <td id="LC9514">        <span><span>//</span> we need to be careful here. The LS will have a thread running free that may be initializing</span></td>
      </tr>
      <tr>
        <td id="L9515" data-line-number="9515"></td>
        <td id="LC9515">        <span><span>//</span> fields of the DCB (specifically it may be setting up the helper thread), so we need to make sure</span></td>
      </tr>
      <tr>
        <td id="L9516" data-line-number="9516"></td>
        <td id="LC9516">        <span><span>//</span> we don't overwrite any fields that the LS is writing. We need to be sure we only write to RS</span></td>
      </tr>
      <tr>
        <td id="L9517" data-line-number="9517"></td>
        <td id="LC9517">        <span><span>//</span> status fields.</span></td>
      </tr>
      <tr>
        <td id="L9518" data-line-number="9518"></td>
        <td id="LC9518">        m_initialized = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L9519" data-line-number="9519"></td>
        <td id="LC9519">        <span>GetDCB</span>()-&gt;<span>m_rightSideIsWin32Debugger</span> = <span>IsInteropDebugging</span>();</td>
      </tr>
      <tr>
        <td id="L9520" data-line-number="9520"></td>
        <td id="LC9520">        <span>UpdateLeftSideDCBField</span>(&amp;(<span>GetDCB</span>()-&gt;<span>m_rightSideIsWin32Debugger</span>), <span>sizeof</span>(<span>GetDCB</span>()-&gt;<span>m_rightSideIsWin32Debugger</span>));</td>
      </tr>
      <tr>
        <td id="L9521" data-line-number="9521"></td>
        <td id="LC9521">
</td>
      </tr>
      <tr>
        <td id="L9522" data-line-number="9522"></td>
        <td id="LC9522">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>[%x] RCET::HFRCE: ...went fine<span>\n</span><span>"</span></span>, <span>GetCurrentThreadId</span>()));</td>
      </tr>
      <tr>
        <td id="L9523" data-line-number="9523"></td>
        <td id="LC9523">        <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L9524" data-line-number="9524"></td>
        <td id="LC9524">
</td>
      </tr>
      <tr>
        <td id="L9525" data-line-number="9525"></td>
        <td id="LC9525">    } <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L9526" data-line-number="9526"></td>
        <td id="LC9526">    <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L9527" data-line-number="9527"></td>
        <td id="LC9527">    {</td>
      </tr>
      <tr>
        <td id="L9528" data-line-number="9528"></td>
        <td id="LC9528">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L9529" data-line-number="9529"></td>
        <td id="LC9529">    }</td>
      </tr>
      <tr>
        <td id="L9530" data-line-number="9530"></td>
        <td id="LC9530">
</td>
      </tr>
      <tr>
        <td id="L9531" data-line-number="9531"></td>
        <td id="LC9531">    <span><span>//</span> We only land here on failure cases.</span></td>
      </tr>
      <tr>
        <td id="L9532" data-line-number="9532"></td>
        <td id="LC9532">    <span><span>//</span> We must have jumped to this label. Maybe we didn't set HR, so check now.</span></td>
      </tr>
      <tr>
        <td id="L9533" data-line-number="9533"></td>
        <td id="LC9533">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>HFCR: FAILED hr=0x%08x<span>\n</span><span>"</span></span>, hr);</td>
      </tr>
      <tr>
        <td id="L9534" data-line-number="9534"></td>
        <td id="LC9534">
</td>
      </tr>
      <tr>
        <td id="L9535" data-line-number="9535"></td>
        <td id="LC9535">    <span>CloseIPCHandles</span>();</td>
      </tr>
      <tr>
        <td id="L9536" data-line-number="9536"></td>
        <td id="LC9536">
</td>
      </tr>
      <tr>
        <td id="L9537" data-line-number="9537"></td>
        <td id="LC9537">    <span><span>//</span> Rethrow</span></td>
      </tr>
      <tr>
        <td id="L9538" data-line-number="9538"></td>
        <td id="LC9538">    <span>ThrowHR</span>(hr);</td>
      </tr>
      <tr>
        <td id="L9539" data-line-number="9539"></td>
        <td id="LC9539">}</td>
      </tr>
      <tr>
        <td id="L9540" data-line-number="9540"></td>
        <td id="LC9540">
</td>
      </tr>
      <tr>
        <td id="L9541" data-line-number="9541"></td>
        <td id="LC9541">
</td>
      </tr>
      <tr>
        <td id="L9542" data-line-number="9542"></td>
        <td id="LC9542"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9543" data-line-number="9543"></td>
        <td id="LC9543"><span><span>//</span> Marshals over a string buffer in a managed event</span></td>
      </tr>
      <tr>
        <td id="L9544" data-line-number="9544"></td>
        <td id="LC9544"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9545" data-line-number="9545"></td>
        <td id="LC9545"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L9546" data-line-number="9546"></td>
        <td id="LC9546"><span><span>//</span>    pTarget - data-target for read the buffer from the LeftSide.</span></td>
      </tr>
      <tr>
        <td id="L9547" data-line-number="9547"></td>
        <td id="LC9547"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9548" data-line-number="9548"></td>
        <td id="LC9548"><span><span>//</span> Throws on error</span></td>
      </tr>
      <tr>
        <td id="L9549" data-line-number="9549"></td>
        <td id="LC9549"><span>void</span> <span>Ls_Rs_BaseBuffer::CopyLSDataToRSWorker</span>(ICorDebugDataTarget * pTarget)</td>
      </tr>
      <tr>
        <td id="L9550" data-line-number="9550"></td>
        <td id="LC9550">{</td>
      </tr>
      <tr>
        <td id="L9551" data-line-number="9551"></td>
        <td id="LC9551">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9552" data-line-number="9552"></td>
        <td id="LC9552">    <span>const</span> DWORD cbCacheSize = m_cbSize;</td>
      </tr>
      <tr>
        <td id="L9553" data-line-number="9553"></td>
        <td id="LC9553">
</td>
      </tr>
      <tr>
        <td id="L9554" data-line-number="9554"></td>
        <td id="LC9554">    <span><span>//</span> SHOULD not happen for more than once in well-behaved case.</span></td>
      </tr>
      <tr>
        <td id="L9555" data-line-number="9555"></td>
        <td id="LC9555">    <span>if</span> (m_pbRS != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9556" data-line-number="9556"></td>
        <td id="LC9556">    {</td>
      </tr>
      <tr>
        <td id="L9557" data-line-number="9557"></td>
        <td id="LC9557">        <span>SIMPLIFYING_ASSUMPTION</span>(!<span><span>"</span>m_pbRS is non-null; is this a corrupted event?<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L9558" data-line-number="9558"></td>
        <td id="LC9558">        <span>ThrowHR</span>(E_INVALIDARG);</td>
      </tr>
      <tr>
        <td id="L9559" data-line-number="9559"></td>
        <td id="LC9559">    }</td>
      </tr>
      <tr>
        <td id="L9560" data-line-number="9560"></td>
        <td id="LC9560">
</td>
      </tr>
      <tr>
        <td id="L9561" data-line-number="9561"></td>
        <td id="LC9561">    NewArrayHolder&lt;BYTE&gt; <span>pData</span>(<span>new</span> BYTE[cbCacheSize]);</td>
      </tr>
      <tr>
        <td id="L9562" data-line-number="9562"></td>
        <td id="LC9562">
</td>
      </tr>
      <tr>
        <td id="L9563" data-line-number="9563"></td>
        <td id="LC9563">    ULONG32 cbRead;</td>
      </tr>
      <tr>
        <td id="L9564" data-line-number="9564"></td>
        <td id="LC9564">    HRESULT hrRead = pTarget-&gt;<span>ReadVirtual</span>(<span>PTR_TO_CORDB_ADDRESS</span>(m_pbLS), pData, cbCacheSize , &amp;cbRead);</td>
      </tr>
      <tr>
        <td id="L9565" data-line-number="9565"></td>
        <td id="LC9565">
</td>
      </tr>
      <tr>
        <td id="L9566" data-line-number="9566"></td>
        <td id="LC9566">    <span>if</span>(<span>FAILED</span>(hrRead))</td>
      </tr>
      <tr>
        <td id="L9567" data-line-number="9567"></td>
        <td id="LC9567">    {</td>
      </tr>
      <tr>
        <td id="L9568" data-line-number="9568"></td>
        <td id="LC9568">        hrRead = CORDBG_E_READVIRTUAL_FAILURE;</td>
      </tr>
      <tr>
        <td id="L9569" data-line-number="9569"></td>
        <td id="LC9569">    }</td>
      </tr>
      <tr>
        <td id="L9570" data-line-number="9570"></td>
        <td id="LC9570">
</td>
      </tr>
      <tr>
        <td id="L9571" data-line-number="9571"></td>
        <td id="LC9571">    <span>if</span> (<span>SUCCEEDED</span>(hrRead) &amp;&amp; (cbCacheSize != cbRead))</td>
      </tr>
      <tr>
        <td id="L9572" data-line-number="9572"></td>
        <td id="LC9572">    {</td>
      </tr>
      <tr>
        <td id="L9573" data-line-number="9573"></td>
        <td id="LC9573">        hrRead = <span>HRESULT_FROM_WIN32</span>(ERROR_PARTIAL_COPY);</td>
      </tr>
      <tr>
        <td id="L9574" data-line-number="9574"></td>
        <td id="LC9574">    }</td>
      </tr>
      <tr>
        <td id="L9575" data-line-number="9575"></td>
        <td id="LC9575">    <span>IfFailThrow</span>(hrRead);</td>
      </tr>
      <tr>
        <td id="L9576" data-line-number="9576"></td>
        <td id="LC9576">
</td>
      </tr>
      <tr>
        <td id="L9577" data-line-number="9577"></td>
        <td id="LC9577">    <span><span>//</span> Now do Transfer</span></td>
      </tr>
      <tr>
        <td id="L9578" data-line-number="9578"></td>
        <td id="LC9578">    m_pbRS = pData;</td>
      </tr>
      <tr>
        <td id="L9579" data-line-number="9579"></td>
        <td id="LC9579">    pData.<span>SuppressRelease</span>();</td>
      </tr>
      <tr>
        <td id="L9580" data-line-number="9580"></td>
        <td id="LC9580">}</td>
      </tr>
      <tr>
        <td id="L9581" data-line-number="9581"></td>
        <td id="LC9581">
</td>
      </tr>
      <tr>
        <td id="L9582" data-line-number="9582"></td>
        <td id="LC9582"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9583" data-line-number="9583"></td>
        <td id="LC9583"><span><span>//</span> Marshals over a Byte buffer in a managed event</span></td>
      </tr>
      <tr>
        <td id="L9584" data-line-number="9584"></td>
        <td id="LC9584"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9585" data-line-number="9585"></td>
        <td id="LC9585"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L9586" data-line-number="9586"></td>
        <td id="LC9586"><span><span>//</span>    pTarget - data-target for read the buffer from the LeftSide.</span></td>
      </tr>
      <tr>
        <td id="L9587" data-line-number="9587"></td>
        <td id="LC9587"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9588" data-line-number="9588"></td>
        <td id="LC9588"><span><span>//</span> Throws on error</span></td>
      </tr>
      <tr>
        <td id="L9589" data-line-number="9589"></td>
        <td id="LC9589"><span>void</span> <span>Ls_Rs_ByteBuffer::CopyLSDataToRS</span>(ICorDebugDataTarget * pTarget)</td>
      </tr>
      <tr>
        <td id="L9590" data-line-number="9590"></td>
        <td id="LC9590">{</td>
      </tr>
      <tr>
        <td id="L9591" data-line-number="9591"></td>
        <td id="LC9591">    <span>CopyLSDataToRSWorker</span>(pTarget);</td>
      </tr>
      <tr>
        <td id="L9592" data-line-number="9592"></td>
        <td id="LC9592">}</td>
      </tr>
      <tr>
        <td id="L9593" data-line-number="9593"></td>
        <td id="LC9593">
</td>
      </tr>
      <tr>
        <td id="L9594" data-line-number="9594"></td>
        <td id="LC9594"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9595" data-line-number="9595"></td>
        <td id="LC9595"><span><span>//</span> Marshals over a string buffer in a managed event</span></td>
      </tr>
      <tr>
        <td id="L9596" data-line-number="9596"></td>
        <td id="LC9596"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9597" data-line-number="9597"></td>
        <td id="LC9597"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L9598" data-line-number="9598"></td>
        <td id="LC9598"><span><span>//</span>    pTarget - data-target for read the buffer from the LeftSide.</span></td>
      </tr>
      <tr>
        <td id="L9599" data-line-number="9599"></td>
        <td id="LC9599"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9600" data-line-number="9600"></td>
        <td id="LC9600"><span><span>//</span> Throws on error</span></td>
      </tr>
      <tr>
        <td id="L9601" data-line-number="9601"></td>
        <td id="LC9601"><span>void</span> <span>Ls_Rs_StringBuffer::CopyLSDataToRS</span>(ICorDebugDataTarget * pTarget)</td>
      </tr>
      <tr>
        <td id="L9602" data-line-number="9602"></td>
        <td id="LC9602">{</td>
      </tr>
      <tr>
        <td id="L9603" data-line-number="9603"></td>
        <td id="LC9603">    <span>CopyLSDataToRSWorker</span>(pTarget);</td>
      </tr>
      <tr>
        <td id="L9604" data-line-number="9604"></td>
        <td id="LC9604">
</td>
      </tr>
      <tr>
        <td id="L9605" data-line-number="9605"></td>
        <td id="LC9605">    <span><span>//</span> Ensure we're a valid, well-formed string.</span></td>
      </tr>
      <tr>
        <td id="L9606" data-line-number="9606"></td>
        <td id="LC9606">    <span><span>//</span> @dbgtodo - this should only happen in corrupted scenarios. Perhaps a better HR here?</span></td>
      </tr>
      <tr>
        <td id="L9607" data-line-number="9607"></td>
        <td id="LC9607">    <span><span>//</span> - null terminated.</span></td>
      </tr>
      <tr>
        <td id="L9608" data-line-number="9608"></td>
        <td id="LC9608">    <span><span>//</span> - no embedded nulls.</span></td>
      </tr>
      <tr>
        <td id="L9609" data-line-number="9609"></td>
        <td id="LC9609">
</td>
      </tr>
      <tr>
        <td id="L9610" data-line-number="9610"></td>
        <td id="LC9610">    <span>const</span> WCHAR * pString = <span>GetString</span>();</td>
      </tr>
      <tr>
        <td id="L9611" data-line-number="9611"></td>
        <td id="LC9611">    SIZE_T dwExpectedLenWithNull = m_cbSize / <span>sizeof</span>(WCHAR);</td>
      </tr>
      <tr>
        <td id="L9612" data-line-number="9612"></td>
        <td id="LC9612">
</td>
      </tr>
      <tr>
        <td id="L9613" data-line-number="9613"></td>
        <td id="LC9613">    <span><span>//</span> Should at least have 1 character for the null-terminator.</span></td>
      </tr>
      <tr>
        <td id="L9614" data-line-number="9614"></td>
        <td id="LC9614">    <span>if</span> (dwExpectedLenWithNull == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L9615" data-line-number="9615"></td>
        <td id="LC9615">    {</td>
      </tr>
      <tr>
        <td id="L9616" data-line-number="9616"></td>
        <td id="LC9616">        <span>ThrowHR</span>(CORDBG_E_TARGET_INCONSISTENT);</td>
      </tr>
      <tr>
        <td id="L9617" data-line-number="9617"></td>
        <td id="LC9617">    }</td>
      </tr>
      <tr>
        <td id="L9618" data-line-number="9618"></td>
        <td id="LC9618">
</td>
      </tr>
      <tr>
        <td id="L9619" data-line-number="9619"></td>
        <td id="LC9619">    <span><span>//</span> Ensure that there's a null where we expect it to be.</span></td>
      </tr>
      <tr>
        <td id="L9620" data-line-number="9620"></td>
        <td id="LC9620">    <span>if</span> (pString[dwExpectedLenWithNull-<span>1</span>] != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L9621" data-line-number="9621"></td>
        <td id="LC9621">    {</td>
      </tr>
      <tr>
        <td id="L9622" data-line-number="9622"></td>
        <td id="LC9622">        <span>ThrowHR</span>(CORDBG_E_TARGET_INCONSISTENT);</td>
      </tr>
      <tr>
        <td id="L9623" data-line-number="9623"></td>
        <td id="LC9623">    }</td>
      </tr>
      <tr>
        <td id="L9624" data-line-number="9624"></td>
        <td id="LC9624">
</td>
      </tr>
      <tr>
        <td id="L9625" data-line-number="9625"></td>
        <td id="LC9625">    <span><span>//</span> Now we know it's safe to call wcslen. The buffer is local, so we know the pages are there.</span></td>
      </tr>
      <tr>
        <td id="L9626" data-line-number="9626"></td>
        <td id="LC9626">    <span><span>//</span> And we know there's a null capping the max length of the string.</span></td>
      </tr>
      <tr>
        <td id="L9627" data-line-number="9627"></td>
        <td id="LC9627">    SIZE_T dwActualLenWithNull = <span>wcslen</span>(pString) + <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L9628" data-line-number="9628"></td>
        <td id="LC9628">    <span>if</span> (dwActualLenWithNull != dwExpectedLenWithNull)</td>
      </tr>
      <tr>
        <td id="L9629" data-line-number="9629"></td>
        <td id="LC9629">    {</td>
      </tr>
      <tr>
        <td id="L9630" data-line-number="9630"></td>
        <td id="LC9630">        <span>ThrowHR</span>(CORDBG_E_TARGET_INCONSISTENT);</td>
      </tr>
      <tr>
        <td id="L9631" data-line-number="9631"></td>
        <td id="LC9631">    }</td>
      </tr>
      <tr>
        <td id="L9632" data-line-number="9632"></td>
        <td id="LC9632">}</td>
      </tr>
      <tr>
        <td id="L9633" data-line-number="9633"></td>
        <td id="LC9633">
</td>
      </tr>
      <tr>
        <td id="L9634" data-line-number="9634"></td>
        <td id="LC9634"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9635" data-line-number="9635"></td>
        <td id="LC9635"><span><span>//</span> Marshals the arguments in a managed-debug event.</span></td>
      </tr>
      <tr>
        <td id="L9636" data-line-number="9636"></td>
        <td id="LC9636"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9637" data-line-number="9637"></td>
        <td id="LC9637"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L9638" data-line-number="9638"></td>
        <td id="LC9638"><span><span>//</span>    pManagedEvent - (IN/OUT) debug event to marshal. Events are not usable in the host process</span></td>
      </tr>
      <tr>
        <td id="L9639" data-line-number="9639"></td>
        <td id="LC9639"><span><span>//</span>       until they are marshalled. This will marshal the event in-place, and may convert</span></td>
      </tr>
      <tr>
        <td id="L9640" data-line-number="9640"></td>
        <td id="LC9640"><span><span>//</span>       some target addresses to host addresses.</span></td>
      </tr>
      <tr>
        <td id="L9641" data-line-number="9641"></td>
        <td id="LC9641"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9642" data-line-number="9642"></td>
        <td id="LC9642"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L9643" data-line-number="9643"></td>
        <td id="LC9643"><span><span>//</span>    S_OK on success. Else Error.</span></td>
      </tr>
      <tr>
        <td id="L9644" data-line-number="9644"></td>
        <td id="LC9644"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9645" data-line-number="9645"></td>
        <td id="LC9645"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L9646" data-line-number="9646"></td>
        <td id="LC9646"><span><span>//</span>    Target is currently stopped and inspectable.</span></td>
      </tr>
      <tr>
        <td id="L9647" data-line-number="9647"></td>
        <td id="LC9647"><span><span>//</span>    After the event is marshalled, it has resources that must be cleaned up</span></td>
      </tr>
      <tr>
        <td id="L9648" data-line-number="9648"></td>
        <td id="LC9648"><span><span>//</span>    by calling code:DeleteIPCEventHelper.</span></td>
      </tr>
      <tr>
        <td id="L9649" data-line-number="9649"></td>
        <td id="LC9649"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9650" data-line-number="9650"></td>
        <td id="LC9650"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L9651" data-line-number="9651"></td>
        <td id="LC9651"><span><span>//</span>     Call a Copy function (CopyManagedEventFromTarget, CopyRCEventFromIPCBlock)to</span></td>
      </tr>
      <tr>
        <td id="L9652" data-line-number="9652"></td>
        <td id="LC9652"><span><span>//</span>     get the event to marshal.</span></td>
      </tr>
      <tr>
        <td id="L9653" data-line-number="9653"></td>
        <td id="LC9653"><span><span>//</span>     This will marshal args from the target into the host.</span></td>
      </tr>
      <tr>
        <td id="L9654" data-line-number="9654"></td>
        <td id="LC9654"><span><span>//</span>     The debug event is fixed size. But since the debuggee is stopped, this can copy</span></td>
      </tr>
      <tr>
        <td id="L9655" data-line-number="9655"></td>
        <td id="LC9655"><span><span>//</span>     arbitrary-length buffers out of of the debuggee.</span></td>
      </tr>
      <tr>
        <td id="L9656" data-line-number="9656"></td>
        <td id="LC9656"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9657" data-line-number="9657"></td>
        <td id="LC9657"><span><span>//</span>     This could be rolled into code:CordbProcess::RawDispatchEvent</span></td>
      </tr>
      <tr>
        <td id="L9658" data-line-number="9658"></td>
        <td id="LC9658"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9659" data-line-number="9659"></td>
        <td id="LC9659"><span>void</span> <span>CordbProcess::MarshalManagedEvent</span>(DebuggerIPCEvent * pManagedEvent)</td>
      </tr>
      <tr>
        <td id="L9660" data-line-number="9660"></td>
        <td id="LC9660">{</td>
      </tr>
      <tr>
        <td id="L9661" data-line-number="9661"></td>
        <td id="LC9661">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L9662" data-line-number="9662"></td>
        <td id="LC9662">    {</td>
      </tr>
      <tr>
        <td id="L9663" data-line-number="9663"></td>
        <td id="LC9663">        THROWS;</td>
      </tr>
      <tr>
        <td id="L9664" data-line-number="9664"></td>
        <td id="LC9664">
</td>
      </tr>
      <tr>
        <td id="L9665" data-line-number="9665"></td>
        <td id="LC9665">        <span><span>//</span> Event has already been copied, now we do some quick Marshalling.</span></td>
      </tr>
      <tr>
        <td id="L9666" data-line-number="9666"></td>
        <td id="LC9666">        <span><span>//</span> Thsi should be a private local copy, and not the one in the IPC block or Target.</span></td>
      </tr>
      <tr>
        <td id="L9667" data-line-number="9667"></td>
        <td id="LC9667">        <span>PRECONDITION</span>(<span>CheckPointer</span>(pManagedEvent));</td>
      </tr>
      <tr>
        <td id="L9668" data-line-number="9668"></td>
        <td id="LC9668">    }</td>
      </tr>
      <tr>
        <td id="L9669" data-line-number="9669"></td>
        <td id="LC9669">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L9670" data-line-number="9670"></td>
        <td id="LC9670">
</td>
      </tr>
      <tr>
        <td id="L9671" data-line-number="9671"></td>
        <td id="LC9671">    <span>IfFailThrow</span>(pManagedEvent-&gt;<span>hr</span>);</td>
      </tr>
      <tr>
        <td id="L9672" data-line-number="9672"></td>
        <td id="LC9672">
</td>
      </tr>
      <tr>
        <td id="L9673" data-line-number="9673"></td>
        <td id="LC9673">    <span><span>//</span> This may throw part way through marshalling. But that's ok because</span></td>
      </tr>
      <tr>
        <td id="L9674" data-line-number="9674"></td>
        <td id="LC9674">    <span><span>//</span> code:DeleteIPCEventHelper can cleanup a partially-marshalled event.</span></td>
      </tr>
      <tr>
        <td id="L9675" data-line-number="9675"></td>
        <td id="LC9675">
</td>
      </tr>
      <tr>
        <td id="L9676" data-line-number="9676"></td>
        <td id="LC9676">    <span><span>//</span> Do a pre-processing on the event</span></td>
      </tr>
      <tr>
        <td id="L9677" data-line-number="9677"></td>
        <td id="LC9677">    <span>switch</span> (pManagedEvent-&gt;<span>type</span> &amp; DB_IPCE_TYPE_MASK)</td>
      </tr>
      <tr>
        <td id="L9678" data-line-number="9678"></td>
        <td id="LC9678">    {</td>
      </tr>
      <tr>
        <td id="L9679" data-line-number="9679"></td>
        <td id="LC9679">        <span>case</span> DB_IPCE_MDA_NOTIFICATION:</td>
      </tr>
      <tr>
        <td id="L9680" data-line-number="9680"></td>
        <td id="LC9680">        {</td>
      </tr>
      <tr>
        <td id="L9681" data-line-number="9681"></td>
        <td id="LC9681">            pManagedEvent-&gt;<span>MDANotification</span>.<span>szName</span>.<span>CopyLSDataToRS</span>(<span>this</span>-&gt;<span>m_pDACDataTarget</span>);</td>
      </tr>
      <tr>
        <td id="L9682" data-line-number="9682"></td>
        <td id="LC9682">            pManagedEvent-&gt;<span>MDANotification</span>.<span>szDescription</span>.<span>CopyLSDataToRS</span>(<span>this</span>-&gt;<span>m_pDACDataTarget</span>);</td>
      </tr>
      <tr>
        <td id="L9683" data-line-number="9683"></td>
        <td id="LC9683">            pManagedEvent-&gt;<span>MDANotification</span>.<span>szXml</span>.<span>CopyLSDataToRS</span>(<span>this</span>-&gt;<span>m_pDACDataTarget</span>);</td>
      </tr>
      <tr>
        <td id="L9684" data-line-number="9684"></td>
        <td id="LC9684">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L9685" data-line-number="9685"></td>
        <td id="LC9685">        }</td>
      </tr>
      <tr>
        <td id="L9686" data-line-number="9686"></td>
        <td id="LC9686">
</td>
      </tr>
      <tr>
        <td id="L9687" data-line-number="9687"></td>
        <td id="LC9687">        <span>case</span> DB_IPCE_FIRST_LOG_MESSAGE:</td>
      </tr>
      <tr>
        <td id="L9688" data-line-number="9688"></td>
        <td id="LC9688">        {</td>
      </tr>
      <tr>
        <td id="L9689" data-line-number="9689"></td>
        <td id="LC9689">            pManagedEvent-&gt;<span>FirstLogMessage</span>.<span>szContent</span>.<span>CopyLSDataToRS</span>(<span>this</span>-&gt;<span>m_pDACDataTarget</span>);</td>
      </tr>
      <tr>
        <td id="L9690" data-line-number="9690"></td>
        <td id="LC9690">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L9691" data-line-number="9691"></td>
        <td id="LC9691">        }</td>
      </tr>
      <tr>
        <td id="L9692" data-line-number="9692"></td>
        <td id="LC9692">
</td>
      </tr>
      <tr>
        <td id="L9693" data-line-number="9693"></td>
        <td id="LC9693">        <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L9694" data-line-number="9694"></td>
        <td id="LC9694">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L9695" data-line-number="9695"></td>
        <td id="LC9695">    }</td>
      </tr>
      <tr>
        <td id="L9696" data-line-number="9696"></td>
        <td id="LC9696">
</td>
      </tr>
      <tr>
        <td id="L9697" data-line-number="9697"></td>
        <td id="LC9697">
</td>
      </tr>
      <tr>
        <td id="L9698" data-line-number="9698"></td>
        <td id="LC9698">}</td>
      </tr>
      <tr>
        <td id="L9699" data-line-number="9699"></td>
        <td id="LC9699">
</td>
      </tr>
      <tr>
        <td id="L9700" data-line-number="9700"></td>
        <td id="LC9700">
</td>
      </tr>
      <tr>
        <td id="L9701" data-line-number="9701"></td>
        <td id="LC9701"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9702" data-line-number="9702"></td>
        <td id="LC9702"><span><span>//</span> Copy a managed debug event from the target process into this local process</span></td>
      </tr>
      <tr>
        <td id="L9703" data-line-number="9703"></td>
        <td id="LC9703"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9704" data-line-number="9704"></td>
        <td id="LC9704"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L9705" data-line-number="9705"></td>
        <td id="LC9705"><span><span>//</span>    pRecord - native-debug event serving as the envelope for the managed event.</span></td>
      </tr>
      <tr>
        <td id="L9706" data-line-number="9706"></td>
        <td id="LC9706"><span><span>//</span>    pLocalManagedEvent - (dst) required local buffer to hold managed event.</span></td>
      </tr>
      <tr>
        <td id="L9707" data-line-number="9707"></td>
        <td id="LC9707"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9708" data-line-number="9708"></td>
        <td id="LC9708"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L9709" data-line-number="9709"></td>
        <td id="LC9709"><span><span>//</span>    * True if the event belongs to this runtime. This is very useful when multiple CLRs are</span></td>
      </tr>
      <tr>
        <td id="L9710" data-line-number="9710"></td>
        <td id="LC9710"><span><span>//</span>    loaded into the target and all sending events wit the same exception code.</span></td>
      </tr>
      <tr>
        <td id="L9711" data-line-number="9711"></td>
        <td id="LC9711"><span><span>//</span>    * False if this does not belong to this instance of ICorDebug. (perhaps it's an event</span></td>
      </tr>
      <tr>
        <td id="L9712" data-line-number="9712"></td>
        <td id="LC9712"><span><span>//</span>    intended for another instance of the CLR in the target, or some rogue user code happening</span></td>
      </tr>
      <tr>
        <td id="L9713" data-line-number="9713"></td>
        <td id="LC9713"><span><span>//</span>    to use our exception code).</span></td>
      </tr>
      <tr>
        <td id="L9714" data-line-number="9714"></td>
        <td id="LC9714"><span><span>//</span>    In either case, the event can still be cleaned up via code:DeleteIPCEventHelper.</span></td>
      </tr>
      <tr>
        <td id="L9715" data-line-number="9715"></td>
        <td id="LC9715"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9716" data-line-number="9716"></td>
        <td id="LC9716"><span><span>//</span>    Throws on error. In the error case, the contents of pLocalManagedEvent are undefined.</span></td>
      </tr>
      <tr>
        <td id="L9717" data-line-number="9717"></td>
        <td id="LC9717"><span><span>//</span>    They may have been partially copied from the target. The local managed event does not own</span></td>
      </tr>
      <tr>
        <td id="L9718" data-line-number="9718"></td>
        <td id="LC9718"><span><span>//</span>    any resources until it's marshalled, so the buffer can be ignored if this function fails.</span></td>
      </tr>
      <tr>
        <td id="L9719" data-line-number="9719"></td>
        <td id="LC9719"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9720" data-line-number="9720"></td>
        <td id="LC9720"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L9721" data-line-number="9721"></td>
        <td id="LC9721"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9722" data-line-number="9722"></td>
        <td id="LC9722"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L9723" data-line-number="9723"></td>
        <td id="LC9723"><span><span>//</span>    The events are sent form the target via code:Debugger::SendRawEvent</span></td>
      </tr>
      <tr>
        <td id="L9724" data-line-number="9724"></td>
        <td id="LC9724"><span><span>//</span>    This just does a raw Byte copy, but does not do any Marshalling.</span></td>
      </tr>
      <tr>
        <td id="L9725" data-line-number="9725"></td>
        <td id="LC9725"><span><span>//</span>    This should always succeed in the well-behaved case. However, A bad debuggee can</span></td>
      </tr>
      <tr>
        <td id="L9726" data-line-number="9726"></td>
        <td id="LC9726"><span><span>//</span>    always send a poor-formed debug event.</span></td>
      </tr>
      <tr>
        <td id="L9727" data-line-number="9727"></td>
        <td id="LC9727"><span><span>//</span>    We don't distinguish between a badly formed event and an event that's not ours.</span></td>
      </tr>
      <tr>
        <td id="L9728" data-line-number="9728"></td>
        <td id="LC9728"><span><span>//</span>    The event still needs to be Marshaled before being used. (see code:CordbProcess::MarshalManagedEvent)</span></td>
      </tr>
      <tr>
        <td id="L9729" data-line-number="9729"></td>
        <td id="LC9729"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9730" data-line-number="9730"></td>
        <td id="LC9730"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9731" data-line-number="9731"></td>
        <td id="LC9731">#<span>if</span> defined(_MSC_VER) &amp;&amp; defined(_TARGET_ARM_)</td>
      </tr>
      <tr>
        <td id="L9732" data-line-number="9732"></td>
        <td id="LC9732"><span><span>//</span> This is a temporary workaround for an ARM specific MS C++ compiler bug (internal LKG build 18.1).</span></td>
      </tr>
      <tr>
        <td id="L9733" data-line-number="9733"></td>
        <td id="LC9733"><span><span>//</span> Branch &lt; if (ptrRemoteManagedEvent == NULL) &gt; was always taken and the function always returned false.</span></td>
      </tr>
      <tr>
        <td id="L9734" data-line-number="9734"></td>
        <td id="LC9734"><span><span>//</span> TODO: It should be removed once the bug is fixed.</span></td>
      </tr>
      <tr>
        <td id="L9735" data-line-number="9735"></td>
        <td id="LC9735">#<span>pragma</span> optimize("", off)</td>
      </tr>
      <tr>
        <td id="L9736" data-line-number="9736"></td>
        <td id="LC9736">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L9737" data-line-number="9737"></td>
        <td id="LC9737"><span>bool</span> <span>CordbProcess::CopyManagedEventFromTarget</span>(</td>
      </tr>
      <tr>
        <td id="L9738" data-line-number="9738"></td>
        <td id="LC9738">    <span>const</span> EXCEPTION_RECORD * pRecord,</td>
      </tr>
      <tr>
        <td id="L9739" data-line-number="9739"></td>
        <td id="LC9739">    DebuggerIPCEvent * pLocalManagedEvent)</td>
      </tr>
      <tr>
        <td id="L9740" data-line-number="9740"></td>
        <td id="LC9740">{</td>
      </tr>
      <tr>
        <td id="L9741" data-line-number="9741"></td>
        <td id="LC9741">    <span>_ASSERTE</span>(pRecord != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9742" data-line-number="9742"></td>
        <td id="LC9742">    <span>_ASSERTE</span>(pLocalManagedEvent != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9743" data-line-number="9743"></td>
        <td id="LC9743">
</td>
      </tr>
      <tr>
        <td id="L9744" data-line-number="9744"></td>
        <td id="LC9744">    <span><span>//</span> Initialize the event enough such backout code can call code:DeleteIPCEventHelper.</span></td>
      </tr>
      <tr>
        <td id="L9745" data-line-number="9745"></td>
        <td id="LC9745">    pLocalManagedEvent-&gt;<span>type</span> = DB_IPCE_DEBUGGER_INVALID;</td>
      </tr>
      <tr>
        <td id="L9746" data-line-number="9746"></td>
        <td id="LC9746">
</td>
      </tr>
      <tr>
        <td id="L9747" data-line-number="9747"></td>
        <td id="LC9747">    <span><span>//</span> Ensure we have a CLR instance ID by now.  Either we had one already, or we're in</span></td>
      </tr>
      <tr>
        <td id="L9748" data-line-number="9748"></td>
        <td id="LC9748">    <span><span>//</span> V2 mode and this is the startup event, and so we'll set it now.</span></td>
      </tr>
      <tr>
        <td id="L9749" data-line-number="9749"></td>
        <td id="LC9749">    HRESULT hr = <span>EnsureClrInstanceIdSet</span>();</td>
      </tr>
      <tr>
        <td id="L9750" data-line-number="9750"></td>
        <td id="LC9750">    <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L9751" data-line-number="9751"></td>
        <td id="LC9751">    <span>_ASSERTE</span>(m_clrInstanceId != <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L9752" data-line-number="9752"></td>
        <td id="LC9752">
</td>
      </tr>
      <tr>
        <td id="L9753" data-line-number="9753"></td>
        <td id="LC9753">    <span><span>//</span> Determine if the event is really a debug event, and for our instance.</span></td>
      </tr>
      <tr>
        <td id="L9754" data-line-number="9754"></td>
        <td id="LC9754">    CORDB_ADDRESS ptrRemoteManagedEvent = <span>IsEventDebuggerNotification</span>(pRecord, m_clrInstanceId);</td>
      </tr>
      <tr>
        <td id="L9755" data-line-number="9755"></td>
        <td id="LC9755">
</td>
      </tr>
      <tr>
        <td id="L9756" data-line-number="9756"></td>
        <td id="LC9756">    <span>if</span> (ptrRemoteManagedEvent == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L9757" data-line-number="9757"></td>
        <td id="LC9757">    {</td>
      </tr>
      <tr>
        <td id="L9758" data-line-number="9758"></td>
        <td id="LC9758">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L9759" data-line-number="9759"></td>
        <td id="LC9759">    }</td>
      </tr>
      <tr>
        <td id="L9760" data-line-number="9760"></td>
        <td id="LC9760">
</td>
      </tr>
      <tr>
        <td id="L9761" data-line-number="9761"></td>
        <td id="LC9761">    <span><span>//</span> What we are doing on Windows here is dangerous.  Any buffer for IPC events must be at least</span></td>
      </tr>
      <tr>
        <td id="L9762" data-line-number="9762"></td>
        <td id="LC9762">    <span><span>//</span> CorDBIPC_BUFFER_SIZE big, but here we are only copying sizeof(DebuggerIPCEvent).  Fortunately, the</span></td>
      </tr>
      <tr>
        <td id="L9763" data-line-number="9763"></td>
        <td id="LC9763">    <span><span>//</span> only case where an IPC event is bigger than sizeof(DebuggerIPCEvent) is for the second category</span></td>
      </tr>
      <tr>
        <td id="L9764" data-line-number="9764"></td>
        <td id="LC9764">    <span><span>//</span> described in the comment for code:IEventChannel.  In this case, we are just transferring the IPC</span></td>
      </tr>
      <tr>
        <td id="L9765" data-line-number="9765"></td>
        <td id="LC9765">    <span><span>//</span> event from the native pipeline to the event channel, and the event channel will read it directly from</span></td>
      </tr>
      <tr>
        <td id="L9766" data-line-number="9766"></td>
        <td id="LC9766">    <span><span>//</span> the send buffer on the LS.  See code:CordbRCEventThread::WaitForIPCEventFromProcess.</span></td>
      </tr>
      <tr>
        <td id="L9767" data-line-number="9767"></td>
        <td id="LC9767">#<span>if</span> !defined(FEATURE_DBGIPC_TRANSPORT_DI)</td>
      </tr>
      <tr>
        <td id="L9768" data-line-number="9768"></td>
        <td id="LC9768">    hr = <span>SafeReadStruct</span>(ptrRemoteManagedEvent, pLocalManagedEvent);</td>
      </tr>
      <tr>
        <td id="L9769" data-line-number="9769"></td>
        <td id="LC9769">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L9770" data-line-number="9770"></td>
        <td id="LC9770">    <span><span>//</span> For Mac remote debugging the address returned above is actually a local address.</span></td>
      </tr>
      <tr>
        <td id="L9771" data-line-number="9771"></td>
        <td id="LC9771">    <span><span>//</span> Also, we need to copy the entire buffer because once a debug event is read from the debugger</span></td>
      </tr>
      <tr>
        <td id="L9772" data-line-number="9772"></td>
        <td id="LC9772">    <span><span>//</span> transport, it won't be available afterwards.</span></td>
      </tr>
      <tr>
        <td id="L9773" data-line-number="9773"></td>
        <td id="LC9773">    <span>memcpy</span>(<span>reinterpret_cast</span>&lt;BYTE *&gt;(pLocalManagedEvent),</td>
      </tr>
      <tr>
        <td id="L9774" data-line-number="9774"></td>
        <td id="LC9774">           <span>CORDB_ADDRESS_TO_PTR</span>(ptrRemoteManagedEvent),</td>
      </tr>
      <tr>
        <td id="L9775" data-line-number="9775"></td>
        <td id="LC9775">           CorDBIPC_BUFFER_SIZE);</td>
      </tr>
      <tr>
        <td id="L9776" data-line-number="9776"></td>
        <td id="LC9776">    hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L9777" data-line-number="9777"></td>
        <td id="LC9777">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L9778" data-line-number="9778"></td>
        <td id="LC9778">    <span>SIMPLIFYING_ASSUMPTION</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L9779" data-line-number="9779"></td>
        <td id="LC9779">    <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L9780" data-line-number="9780"></td>
        <td id="LC9780">
</td>
      </tr>
      <tr>
        <td id="L9781" data-line-number="9781"></td>
        <td id="LC9781">    <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L9782" data-line-number="9782"></td>
        <td id="LC9782">}</td>
      </tr>
      <tr>
        <td id="L9783" data-line-number="9783"></td>
        <td id="LC9783">#<span>if</span> defined(_MSC_VER) &amp;&amp; defined(_TARGET_ARM_)</td>
      </tr>
      <tr>
        <td id="L9784" data-line-number="9784"></td>
        <td id="LC9784">#<span>pragma</span> optimize("", on)</td>
      </tr>
      <tr>
        <td id="L9785" data-line-number="9785"></td>
        <td id="LC9785">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L9786" data-line-number="9786"></td>
        <td id="LC9786">
</td>
      </tr>
      <tr>
        <td id="L9787" data-line-number="9787"></td>
        <td id="LC9787"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9788" data-line-number="9788"></td>
        <td id="LC9788"><span><span>//</span> EnsureClrInstanceIdSet - Ensure we have a CLR Instance ID to debug</span></td>
      </tr>
      <tr>
        <td id="L9789" data-line-number="9789"></td>
        <td id="LC9789"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9790" data-line-number="9790"></td>
        <td id="LC9790"><span><span>//</span> In Arrowhead scenarios, the debugger is required to pass a valid CLR instance ID</span></td>
      </tr>
      <tr>
        <td id="L9791" data-line-number="9791"></td>
        <td id="LC9791"><span><span>//</span> to us in OpenVirtualProcess.  In V2 scenarios, for compatibility, we'll allow a</span></td>
      </tr>
      <tr>
        <td id="L9792" data-line-number="9792"></td>
        <td id="LC9792"><span><span>//</span> CordbProcess object to exist for a process that doesn't yet have the CLR loaded.</span></td>
      </tr>
      <tr>
        <td id="L9793" data-line-number="9793"></td>
        <td id="LC9793"><span><span>//</span> In this case the CLR instance ID will start off as 0, but be filled in when we see the</span></td>
      </tr>
      <tr>
        <td id="L9794" data-line-number="9794"></td>
        <td id="LC9794"><span><span>//</span> startup exception indicating the CLR has been loaded.</span></td>
      </tr>
      <tr>
        <td id="L9795" data-line-number="9795"></td>
        <td id="LC9795"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9796" data-line-number="9796"></td>
        <td id="LC9796"><span><span>//</span> If we don't already have an instance ID, this function sets it to the only CLR in the</span></td>
      </tr>
      <tr>
        <td id="L9797" data-line-number="9797"></td>
        <td id="LC9797"><span><span>//</span> target process.  This requires that a CLR be loaded in the target process.</span></td>
      </tr>
      <tr>
        <td id="L9798" data-line-number="9798"></td>
        <td id="LC9798"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9799" data-line-number="9799"></td>
        <td id="LC9799"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L9800" data-line-number="9800"></td>
        <td id="LC9800"><span><span>//</span>    S_OK - if m_clrInstanceId was already set, or is now set to a valid CLR instance ID</span></td>
      </tr>
      <tr>
        <td id="L9801" data-line-number="9801"></td>
        <td id="LC9801"><span><span>//</span>    an error HRESULT - if m_clrInstanceId was 0, and cannot be set to a valid value</span></td>
      </tr>
      <tr>
        <td id="L9802" data-line-number="9802"></td>
        <td id="LC9802"><span><span>//</span>                       (i.e. because we cannot find a CLR in the target process).</span></td>
      </tr>
      <tr>
        <td id="L9803" data-line-number="9803"></td>
        <td id="LC9803"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9804" data-line-number="9804"></td>
        <td id="LC9804"><span><span>//</span>    Note that we need to probe for this on attach, and it's common to attach before the</span></td>
      </tr>
      <tr>
        <td id="L9805" data-line-number="9805"></td>
        <td id="LC9805"><span><span>//</span>    CLR has been loaded, so we avoid using exceptions for this common case.</span></td>
      </tr>
      <tr>
        <td id="L9806" data-line-number="9806"></td>
        <td id="LC9806"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9807" data-line-number="9807"></td>
        <td id="LC9807">HRESULT <span>CordbProcess::EnsureClrInstanceIdSet</span>()</td>
      </tr>
      <tr>
        <td id="L9808" data-line-number="9808"></td>
        <td id="LC9808">{</td>
      </tr>
      <tr>
        <td id="L9809" data-line-number="9809"></td>
        <td id="LC9809">    <span><span>//</span> If we didn't expect a specific CLR, then attempt to attach to any.</span></td>
      </tr>
      <tr>
        <td id="L9810" data-line-number="9810"></td>
        <td id="LC9810">    <span>if</span> (m_clrInstanceId == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L9811" data-line-number="9811"></td>
        <td id="LC9811">    {</td>
      </tr>
      <tr>
        <td id="L9812" data-line-number="9812"></td>
        <td id="LC9812">
</td>
      </tr>
      <tr>
        <td id="L9813" data-line-number="9813"></td>
        <td id="LC9813">#<span>ifdef</span> FEATURE_CORESYSTEM</td>
      </tr>
      <tr>
        <td id="L9814" data-line-number="9814"></td>
        <td id="LC9814">        <span>if</span>(m_cordb-&gt;<span>GetTargetCLR</span>() != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L9815" data-line-number="9815"></td>
        <td id="LC9815">        {</td>
      </tr>
      <tr>
        <td id="L9816" data-line-number="9816"></td>
        <td id="LC9816">            m_clrInstanceId = <span>PTR_TO_CORDB_ADDRESS</span>(m_cordb-&gt;<span>GetTargetCLR</span>());</td>
      </tr>
      <tr>
        <td id="L9817" data-line-number="9817"></td>
        <td id="LC9817">            <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L9818" data-line-number="9818"></td>
        <td id="LC9818">        }</td>
      </tr>
      <tr>
        <td id="L9819" data-line-number="9819"></td>
        <td id="LC9819">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L9820" data-line-number="9820"></td>
        <td id="LC9820">
</td>
      </tr>
      <tr>
        <td id="L9821" data-line-number="9821"></td>
        <td id="LC9821">        <span><span>//</span> The only case in which we're allowed to request the "default" CLR instance</span></td>
      </tr>
      <tr>
        <td id="L9822" data-line-number="9822"></td>
        <td id="LC9822">        <span><span>//</span> ID is when we're running in V2 mode.  In V3, the client is required to pass</span></td>
      </tr>
      <tr>
        <td id="L9823" data-line-number="9823"></td>
        <td id="LC9823">        <span><span>//</span> a non-zero value to OpenVirtualProcess.</span></td>
      </tr>
      <tr>
        <td id="L9824" data-line-number="9824"></td>
        <td id="LC9824">        <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9825" data-line-number="9825"></td>
        <td id="LC9825">
</td>
      </tr>
      <tr>
        <td id="L9826" data-line-number="9826"></td>
        <td id="LC9826">        HRESULT hr = m_pShim-&gt;<span>FindLoadedCLR</span>(&amp;m_clrInstanceId);</td>
      </tr>
      <tr>
        <td id="L9827" data-line-number="9827"></td>
        <td id="LC9827">        <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L9828" data-line-number="9828"></td>
        <td id="LC9828">        {</td>
      </tr>
      <tr>
        <td id="L9829" data-line-number="9829"></td>
        <td id="LC9829">            <span><span>//</span> Couldn't find a loaded clr - no CLR instance ID yet</span></td>
      </tr>
      <tr>
        <td id="L9830" data-line-number="9830"></td>
        <td id="LC9830">            <span>_ASSERTE</span>(m_clrInstanceId == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L9831" data-line-number="9831"></td>
        <td id="LC9831">            <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L9832" data-line-number="9832"></td>
        <td id="LC9832">        }</td>
      </tr>
      <tr>
        <td id="L9833" data-line-number="9833"></td>
        <td id="LC9833">    }</td>
      </tr>
      <tr>
        <td id="L9834" data-line-number="9834"></td>
        <td id="LC9834">
</td>
      </tr>
      <tr>
        <td id="L9835" data-line-number="9835"></td>
        <td id="LC9835">    <span><span>//</span> We've (now) got a valid CLR instance id</span></td>
      </tr>
      <tr>
        <td id="L9836" data-line-number="9836"></td>
        <td id="LC9836">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L9837" data-line-number="9837"></td>
        <td id="LC9837">}</td>
      </tr>
      <tr>
        <td id="L9838" data-line-number="9838"></td>
        <td id="LC9838">
</td>
      </tr>
      <tr>
        <td id="L9839" data-line-number="9839"></td>
        <td id="LC9839"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9840" data-line-number="9840"></td>
        <td id="LC9840"><span><span>//</span> // Copy event from IPC block into local.</span></td>
      </tr>
      <tr>
        <td id="L9841" data-line-number="9841"></td>
        <td id="LC9841"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9842" data-line-number="9842"></td>
        <td id="LC9842"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L9843" data-line-number="9843"></td>
        <td id="LC9843"><span><span>//</span>    pLocalManagedEvent - required local buffer to hold managed event.</span></td>
      </tr>
      <tr>
        <td id="L9844" data-line-number="9844"></td>
        <td id="LC9844"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9845" data-line-number="9845"></td>
        <td id="LC9845"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L9846" data-line-number="9846"></td>
        <td id="LC9846"><span><span>//</span>    None. Always succeeds.</span></td>
      </tr>
      <tr>
        <td id="L9847" data-line-number="9847"></td>
        <td id="LC9847"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9848" data-line-number="9848"></td>
        <td id="LC9848"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L9849" data-line-number="9849"></td>
        <td id="LC9849"><span><span>//</span>    The IPC block has already been opened and filled in with an event.</span></td>
      </tr>
      <tr>
        <td id="L9850" data-line-number="9850"></td>
        <td id="LC9850"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9851" data-line-number="9851"></td>
        <td id="LC9851"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L9852" data-line-number="9852"></td>
        <td id="LC9852"><span><span>//</span>    This is copying from a shared-memory block, which is treated as local memory.</span></td>
      </tr>
      <tr>
        <td id="L9853" data-line-number="9853"></td>
        <td id="LC9853"><span><span>//</span>    This just does a raw Byte copy, but does not do any Marshalling.</span></td>
      </tr>
      <tr>
        <td id="L9854" data-line-number="9854"></td>
        <td id="LC9854"><span><span>//</span>    This does no validation on the event.</span></td>
      </tr>
      <tr>
        <td id="L9855" data-line-number="9855"></td>
        <td id="LC9855"><span><span>//</span>    The event still needs to be Marshaled before being used. (see code:CordbProcess::MarshalManagedEvent)</span></td>
      </tr>
      <tr>
        <td id="L9856" data-line-number="9856"></td>
        <td id="LC9856"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9857" data-line-number="9857"></td>
        <td id="LC9857"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9858" data-line-number="9858"></td>
        <td id="LC9858"><span>void</span> <span>inline</span> <span>CordbProcess::CopyRCEventFromIPCBlock</span>(DebuggerIPCEvent * pLocalManagedEvent)</td>
      </tr>
      <tr>
        <td id="L9859" data-line-number="9859"></td>
        <td id="LC9859">{</td>
      </tr>
      <tr>
        <td id="L9860" data-line-number="9860"></td>
        <td id="LC9860">    <span>_ASSERTE</span>(pLocalManagedEvent != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9861" data-line-number="9861"></td>
        <td id="LC9861">
</td>
      </tr>
      <tr>
        <td id="L9862" data-line-number="9862"></td>
        <td id="LC9862">    <span>IfFailThrow</span>(m_pEventChannel-&gt;<span>GetEventFromLeftSide</span>(pLocalManagedEvent));</td>
      </tr>
      <tr>
        <td id="L9863" data-line-number="9863"></td>
        <td id="LC9863">}</td>
      </tr>
      <tr>
        <td id="L9864" data-line-number="9864"></td>
        <td id="LC9864">
</td>
      </tr>
      <tr>
        <td id="L9865" data-line-number="9865"></td>
        <td id="LC9865"><span><span>//</span> Return true if this is the RCEvent thread, else false.</span></td>
      </tr>
      <tr>
        <td id="L9866" data-line-number="9866"></td>
        <td id="LC9866"><span>bool</span> <span>CordbRCEventThread::IsRCEventThread</span>()</td>
      </tr>
      <tr>
        <td id="L9867" data-line-number="9867"></td>
        <td id="LC9867">{</td>
      </tr>
      <tr>
        <td id="L9868" data-line-number="9868"></td>
        <td id="LC9868">    <span>return</span> (m_threadId == <span>GetCurrentThreadId</span>());</td>
      </tr>
      <tr>
        <td id="L9869" data-line-number="9869"></td>
        <td id="LC9869">}</td>
      </tr>
      <tr>
        <td id="L9870" data-line-number="9870"></td>
        <td id="LC9870">
</td>
      </tr>
      <tr>
        <td id="L9871" data-line-number="9871"></td>
        <td id="LC9871"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L9872" data-line-number="9872"></td>
        <td id="LC9872"><span><span>//</span> Runtime assert, throws CORDBG_E_TARGET_INCONSISTENT if the expression is not true.</span></td>
      </tr>
      <tr>
        <td id="L9873" data-line-number="9873"></td>
        <td id="LC9873"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9874" data-line-number="9874"></td>
        <td id="LC9874"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L9875" data-line-number="9875"></td>
        <td id="LC9875"><span><span>//</span>     fExpression - assert parameter. If true, this function is a nop. If false,</span></td>
      </tr>
      <tr>
        <td id="L9876" data-line-number="9876"></td>
        <td id="LC9876"><span><span>//</span>             this will throw a CORDBG_E_TARGET_INCONSISTENT error.</span></td>
      </tr>
      <tr>
        <td id="L9877" data-line-number="9877"></td>
        <td id="LC9877"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9878" data-line-number="9878"></td>
        <td id="LC9878"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L9879" data-line-number="9879"></td>
        <td id="LC9879"><span><span>//</span>     Use this for runtime checks to validate assumptions about the data-target.</span></td>
      </tr>
      <tr>
        <td id="L9880" data-line-number="9880"></td>
        <td id="LC9880"><span><span>//</span>     IcorDebug can't trust that data from the debugee is consistent (perhaps it's</span></td>
      </tr>
      <tr>
        <td id="L9881" data-line-number="9881"></td>
        <td id="LC9881"><span><span>//</span>     corrupted).</span></td>
      </tr>
      <tr>
        <td id="L9882" data-line-number="9882"></td>
        <td id="LC9882"><span>void</span> <span>CordbProcess::TargetConsistencyCheck</span>(<span>bool</span> <span>fExpression</span>)</td>
      </tr>
      <tr>
        <td id="L9883" data-line-number="9883"></td>
        <td id="LC9883">{</td>
      </tr>
      <tr>
        <td id="L9884" data-line-number="9884"></td>
        <td id="LC9884">    <span>if</span> (!<span>fExpression</span>)</td>
      </tr>
      <tr>
        <td id="L9885" data-line-number="9885"></td>
        <td id="LC9885">    {</td>
      </tr>
      <tr>
        <td id="L9886" data-line-number="9886"></td>
        <td id="LC9886">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO10000, <span><span>"</span>Target consistency check failed<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L9887" data-line-number="9887"></td>
        <td id="LC9887">
</td>
      </tr>
      <tr>
        <td id="L9888" data-line-number="9888"></td>
        <td id="LC9888">        <span><span>//</span> When debugging possibly corrupt targets, this failure may be expected.  For debugging purposes,</span></td>
      </tr>
      <tr>
        <td id="L9889" data-line-number="9889"></td>
        <td id="LC9889">        <span><span>//</span> assert if we're not expecting any target inconsistencies.</span></td>
      </tr>
      <tr>
        <td id="L9890" data-line-number="9890"></td>
        <td id="LC9890">        <span>CONSISTENCY_CHECK_MSG</span>( !m_fAssertOnTargetInconsistency, <span><span>"</span>Target consistency check failed unexpectedly<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L9891" data-line-number="9891"></td>
        <td id="LC9891">
</td>
      </tr>
      <tr>
        <td id="L9892" data-line-number="9892"></td>
        <td id="LC9892">        <span>ThrowHR</span>(CORDBG_E_TARGET_INCONSISTENT);</td>
      </tr>
      <tr>
        <td id="L9893" data-line-number="9893"></td>
        <td id="LC9893">    }</td>
      </tr>
      <tr>
        <td id="L9894" data-line-number="9894"></td>
        <td id="LC9894">}</td>
      </tr>
      <tr>
        <td id="L9895" data-line-number="9895"></td>
        <td id="LC9895">
</td>
      </tr>
      <tr>
        <td id="L9896" data-line-number="9896"></td>
        <td id="LC9896"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9897" data-line-number="9897"></td>
        <td id="LC9897"><span><span>//</span> SendIPCEvent -- send an IPC event to the runtime controller. All this</span></td>
      </tr>
      <tr>
        <td id="L9898" data-line-number="9898"></td>
        <td id="LC9898"><span><span>//</span> really does is copy the event into the process's send buffer and sets</span></td>
      </tr>
      <tr>
        <td id="L9899" data-line-number="9899"></td>
        <td id="LC9899"><span><span>//</span> the RSEA then waits on RSER.</span></td>
      </tr>
      <tr>
        <td id="L9900" data-line-number="9900"></td>
        <td id="LC9900"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9901" data-line-number="9901"></td>
        <td id="LC9901"><span><span>//</span> Note: when sending a two-way event (replyRequired = true), the</span></td>
      </tr>
      <tr>
        <td id="L9902" data-line-number="9902"></td>
        <td id="LC9902"><span><span>//</span> eventSize must be large enough for both the event sent and the</span></td>
      </tr>
      <tr>
        <td id="L9903" data-line-number="9903"></td>
        <td id="LC9903"><span><span>//</span> result event.</span></td>
      </tr>
      <tr>
        <td id="L9904" data-line-number="9904"></td>
        <td id="LC9904"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9905" data-line-number="9905"></td>
        <td id="LC9905"><span><span>//</span> Returns whether the event was sent successfully. This is different than event-&gt;eventHr.</span></td>
      </tr>
      <tr>
        <td id="L9906" data-line-number="9906"></td>
        <td id="LC9906"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9907" data-line-number="9907"></td>
        <td id="LC9907">HRESULT <span>CordbRCEventThread::SendIPCEvent</span>(CordbProcess* process,</td>
      </tr>
      <tr>
        <td id="L9908" data-line-number="9908"></td>
        <td id="LC9908">                                         DebuggerIPCEvent* event,</td>
      </tr>
      <tr>
        <td id="L9909" data-line-number="9909"></td>
        <td id="LC9909">                                         SIZE_T eventSize)</td>
      </tr>
      <tr>
        <td id="L9910" data-line-number="9910"></td>
        <td id="LC9910">{</td>
      </tr>
      <tr>
        <td id="L9911" data-line-number="9911"></td>
        <td id="LC9911">
</td>
      </tr>
      <tr>
        <td id="L9912" data-line-number="9912"></td>
        <td id="LC9912">    <span>_ASSERTE</span>(process != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9913" data-line-number="9913"></td>
        <td id="LC9913">    <span>_ASSERTE</span>(event != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9914" data-line-number="9914"></td>
        <td id="LC9914">    <span>_ASSERTE</span>(process-&gt;<span>GetShim</span>() != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L9915" data-line-number="9915"></td>
        <td id="LC9915">
</td>
      </tr>
      <tr>
        <td id="L9916" data-line-number="9916"></td>
        <td id="LC9916">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L9917" data-line-number="9917"></td>
        <td id="LC9917">    <span><span>//</span> We need to be synchronized whenever we're sending an IPC Event.</span></td>
      </tr>
      <tr>
        <td id="L9918" data-line-number="9918"></td>
        <td id="LC9918">    <span><span>//</span> This may require our callers' using a Stop-Continue holder.</span></td>
      </tr>
      <tr>
        <td id="L9919" data-line-number="9919"></td>
        <td id="LC9919">    <span><span>//</span> Attach + AsyncBreak are the only (obvious) exceptions.</span></td>
      </tr>
      <tr>
        <td id="L9920" data-line-number="9920"></td>
        <td id="LC9920">    <span><span>//</span> For continue, we set Sync-Status to false before sending, so we exclude that too.</span></td>
      </tr>
      <tr>
        <td id="L9921" data-line-number="9921"></td>
        <td id="LC9921">    <span><span>//</span> Everybody else should only be sending events when synced. We should never ever ever</span></td>
      </tr>
      <tr>
        <td id="L9922" data-line-number="9922"></td>
        <td id="LC9922">    <span><span>//</span> send an event from a CorbXYZ dtor (b/c that would be called at any random time). Instead,</span></td>
      </tr>
      <tr>
        <td id="L9923" data-line-number="9923"></td>
        <td id="LC9923">    <span><span>//</span> use a NeuterList.</span></td>
      </tr>
      <tr>
        <td id="L9924" data-line-number="9924"></td>
        <td id="LC9924">    <span>switch</span> (event-&gt;<span>type</span>)</td>
      </tr>
      <tr>
        <td id="L9925" data-line-number="9925"></td>
        <td id="LC9925">    {</td>
      </tr>
      <tr>
        <td id="L9926" data-line-number="9926"></td>
        <td id="LC9926">        <span>case</span> DB_IPCE_ATTACHING:</td>
      </tr>
      <tr>
        <td id="L9927" data-line-number="9927"></td>
        <td id="LC9927">        <span>case</span> DB_IPCE_ASYNC_BREAK:</td>
      </tr>
      <tr>
        <td id="L9928" data-line-number="9928"></td>
        <td id="LC9928">        <span>case</span> DB_IPCE_CONTINUE:</td>
      </tr>
      <tr>
        <td id="L9929" data-line-number="9929"></td>
        <td id="LC9929">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L9930" data-line-number="9930"></td>
        <td id="LC9930">
</td>
      </tr>
      <tr>
        <td id="L9931" data-line-number="9931"></td>
        <td id="LC9931">        <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L9932" data-line-number="9932"></td>
        <td id="LC9932">            <span>CONSISTENCY_CHECK_MSGF</span>(process-&gt;<span>GetSynchronized</span>(), (<span><span>"</span>Must by synced while sending IPC event: %s (0x%x)<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L9933" data-line-number="9933"></td>
        <td id="LC9933">                <span>IPCENames::GetName</span>(event-&gt;<span>type</span>), event-&gt;<span>type</span>));</td>
      </tr>
      <tr>
        <td id="L9934" data-line-number="9934"></td>
        <td id="LC9934">    }</td>
      </tr>
      <tr>
        <td id="L9935" data-line-number="9935"></td>
        <td id="LC9935">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L9936" data-line-number="9936"></td>
        <td id="LC9936">
</td>
      </tr>
      <tr>
        <td id="L9937" data-line-number="9937"></td>
        <td id="LC9937">
</td>
      </tr>
      <tr>
        <td id="L9938" data-line-number="9938"></td>
        <td id="LC9938">    <span>LOG</span>((LF_CORDB, LL_EVERYTHING, <span><span>"</span>SendIPCEvent in CordbRCEventThread called<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L9939" data-line-number="9939"></td>
        <td id="LC9939">
</td>
      </tr>
      <tr>
        <td id="L9940" data-line-number="9940"></td>
        <td id="LC9940">    <span><span>//</span> For simplicity sake, we have the following conservative invariants when sending IPC events:</span></td>
      </tr>
      <tr>
        <td id="L9941" data-line-number="9941"></td>
        <td id="LC9941">    <span><span>//</span> - Always hold the Stop-Go lock.</span></td>
      </tr>
      <tr>
        <td id="L9942" data-line-number="9942"></td>
        <td id="LC9942">    <span><span>//</span> - never on the W32ET.</span></td>
      </tr>
      <tr>
        <td id="L9943" data-line-number="9943"></td>
        <td id="LC9943">    <span><span>//</span> - Never hold the Process-lock (this allows the w32et to take that lock to pump)</span></td>
      </tr>
      <tr>
        <td id="L9944" data-line-number="9944"></td>
        <td id="LC9944">
</td>
      </tr>
      <tr>
        <td id="L9945" data-line-number="9945"></td>
        <td id="LC9945">    <span><span>//</span> Must have the stop-go lock to send an IPC event.</span></td>
      </tr>
      <tr>
        <td id="L9946" data-line-number="9946"></td>
        <td id="LC9946">    <span>CONSISTENCY_CHECK_MSGF</span>(process-&gt;<span>GetStopGoLock</span>()-&gt;<span>HasLock</span>(), (<span><span>"</span>Must have stop-go lock to send event. proc=%p, event=%s<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L9947" data-line-number="9947"></td>
        <td id="LC9947">        process, <span>IPCENames::GetName</span>(event-&gt;<span>type</span>)));</td>
      </tr>
      <tr>
        <td id="L9948" data-line-number="9948"></td>
        <td id="LC9948">
</td>
      </tr>
      <tr>
        <td id="L9949" data-line-number="9949"></td>
        <td id="LC9949">    <span><span>//</span> The w32 ET will need to take the process lock. So if we're holding it here, then we'll</span></td>
      </tr>
      <tr>
        <td id="L9950" data-line-number="9950"></td>
        <td id="LC9950">    <span><span>//</span> deadlock (since W32 ET is blocked on lock, which we would hold; and we're blocked on W32 ET</span></td>
      </tr>
      <tr>
        <td id="L9951" data-line-number="9951"></td>
        <td id="LC9951">    <span><span>//</span> to keep pumping.</span></td>
      </tr>
      <tr>
        <td id="L9952" data-line-number="9952"></td>
        <td id="LC9952">    <span>_ASSERTE</span>(!process-&gt;<span>ThreadHoldsProcessLock</span>() || !<span><span>"</span>Can't hold P-lock while sending blocking IPC event<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L9953" data-line-number="9953"></td>
        <td id="LC9953">
</td>
      </tr>
      <tr>
        <td id="L9954" data-line-number="9954"></td>
        <td id="LC9954">
</td>
      </tr>
      <tr>
        <td id="L9955" data-line-number="9955"></td>
        <td id="LC9955">    <span><span>//</span> Can't be on the w32 ET, or we can't be pumping.</span></td>
      </tr>
      <tr>
        <td id="L9956" data-line-number="9956"></td>
        <td id="LC9956">    <span><span>//</span> Although we can trickle in here from public APIs, our caller should have validated</span></td>
      </tr>
      <tr>
        <td id="L9957" data-line-number="9957"></td>
        <td id="LC9957">    <span><span>//</span> that we weren't on the w32et, so the assert here is justified. But just in case there's something we missed,</span></td>
      </tr>
      <tr>
        <td id="L9958" data-line-number="9958"></td>
        <td id="LC9958">    <span><span>//</span> we have a runtime check (as a final backstop against a deadlock).</span></td>
      </tr>
      <tr>
        <td id="L9959" data-line-number="9959"></td>
        <td id="LC9959">    <span>_ASSERTE</span>(!process-&gt;<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L9960" data-line-number="9960"></td>
        <td id="LC9960">    <span>CORDBFailIfOnWin32EventThread</span>(process);</td>
      </tr>
      <tr>
        <td id="L9961" data-line-number="9961"></td>
        <td id="LC9961">
</td>
      </tr>
      <tr>
        <td id="L9962" data-line-number="9962"></td>
        <td id="LC9962">
</td>
      </tr>
      <tr>
        <td id="L9963" data-line-number="9963"></td>
        <td id="LC9963">    <span><span>//</span> If this is an async event, then we expect it to be sent while the process is locked.</span></td>
      </tr>
      <tr>
        <td id="L9964" data-line-number="9964"></td>
        <td id="LC9964">    <span>if</span> (event-&gt;<span>asyncSend</span>)</td>
      </tr>
      <tr>
        <td id="L9965" data-line-number="9965"></td>
        <td id="LC9965">    {</td>
      </tr>
      <tr>
        <td id="L9966" data-line-number="9966"></td>
        <td id="LC9966">        <span><span>//</span> This may be on the w32et, so we can't hold the stop-go lock.</span></td>
      </tr>
      <tr>
        <td id="L9967" data-line-number="9967"></td>
        <td id="LC9967">        <span>_ASSERTE</span>(event-&gt;<span>type</span> == DB_IPCE_ATTACHING); <span><span>//</span> only async event should be attaching.</span></td>
      </tr>
      <tr>
        <td id="L9968" data-line-number="9968"></td>
        <td id="LC9968">    }</td>
      </tr>
      <tr>
        <td id="L9969" data-line-number="9969"></td>
        <td id="LC9969">
</td>
      </tr>
      <tr>
        <td id="L9970" data-line-number="9970"></td>
        <td id="LC9970">
</td>
      </tr>
      <tr>
        <td id="L9971" data-line-number="9971"></td>
        <td id="LC9971">    <span><span>//</span> This will catch us if we've detached or exited.</span></td>
      </tr>
      <tr>
        <td id="L9972" data-line-number="9972"></td>
        <td id="LC9972">    <span><span>//</span> Note if we exited, then we should have been neutered and so shouldn't even be sending an IPC event,</span></td>
      </tr>
      <tr>
        <td id="L9973" data-line-number="9973"></td>
        <td id="LC9973">    <span><span>//</span> but just in case, we'll check.</span></td>
      </tr>
      <tr>
        <td id="L9974" data-line-number="9974"></td>
        <td id="LC9974">    <span>CORDBRequireProcessStateOK</span>(process);</td>
      </tr>
      <tr>
        <td id="L9975" data-line-number="9975"></td>
        <td id="LC9975">
</td>
      </tr>
      <tr>
        <td id="L9976" data-line-number="9976"></td>
        <td id="LC9976">
</td>
      </tr>
      <tr>
        <td id="L9977" data-line-number="9977"></td>
        <td id="LC9977">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L9978" data-line-number="9978"></td>
        <td id="LC9978">    <span><span>//</span> We should never send an Async Break on the RCET. This will deadlock.</span></td>
      </tr>
      <tr>
        <td id="L9979" data-line-number="9979"></td>
        <td id="LC9979">    <span><span>//</span> - if we're on the RCET, we should be stopped, and thus Stop() should just bump up a stop count,</span></td>
      </tr>
      <tr>
        <td id="L9980" data-line-number="9980"></td>
        <td id="LC9980">    <span><span>//</span>   and not actually send an AsyncBreak.</span></td>
      </tr>
      <tr>
        <td id="L9981" data-line-number="9981"></td>
        <td id="LC9981">    <span><span>//</span> - Delayed-Continues help enforce this.</span></td>
      </tr>
      <tr>
        <td id="L9982" data-line-number="9982"></td>
        <td id="LC9982">    <span><span>//</span> This is a special case of the deadlock check below.</span></td>
      </tr>
      <tr>
        <td id="L9983" data-line-number="9983"></td>
        <td id="LC9983">    <span>if</span> (<span>IsRCEventThread</span>())</td>
      </tr>
      <tr>
        <td id="L9984" data-line-number="9984"></td>
        <td id="LC9984">    {</td>
      </tr>
      <tr>
        <td id="L9985" data-line-number="9985"></td>
        <td id="LC9985">        <span>_ASSERTE</span>(event-&gt;<span>type</span> != DB_IPCE_ASYNC_BREAK);</td>
      </tr>
      <tr>
        <td id="L9986" data-line-number="9986"></td>
        <td id="LC9986">    }</td>
      </tr>
      <tr>
        <td id="L9987" data-line-number="9987"></td>
        <td id="LC9987">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L9988" data-line-number="9988"></td>
        <td id="LC9988">
</td>
      </tr>
      <tr>
        <td id="L9989" data-line-number="9989"></td>
        <td id="LC9989">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L9990" data-line-number="9990"></td>
        <td id="LC9990">    <span><span>//</span> This assert protects us against a deadlock.</span></td>
      </tr>
      <tr>
        <td id="L9991" data-line-number="9991"></td>
        <td id="LC9991">    <span><span>//</span> 1) (RCET) blocked on (This function): If we're on the RCET, then the RCET is blocked until we return (duh).</span></td>
      </tr>
      <tr>
        <td id="L9992" data-line-number="9992"></td>
        <td id="LC9992">    <span><span>//</span> 2) (LS) blocked on (RCET): If the LS is not synchronized, then it may be sending an event to the RCET, and thus blocked on the RCET.</span></td>
      </tr>
      <tr>
        <td id="L9993" data-line-number="9993"></td>
        <td id="LC9993">    <span><span>//</span> 3) (Helper thread) blocked on (LS): That LS thread may be holding a lock that the helper thread needs, thus blocking the helper thread.</span></td>
      </tr>
      <tr>
        <td id="L9994" data-line-number="9994"></td>
        <td id="LC9994">    <span><span>//</span> 4) (This function) blocked on (Helper Thread): We block until the helper thread can process our IPC event.</span></td>
      </tr>
      <tr>
        <td id="L9995" data-line-number="9995"></td>
        <td id="LC9995">    <span><span>//</span>     #4 is not true for async events.</span></td>
      </tr>
      <tr>
        <td id="L9996" data-line-number="9996"></td>
        <td id="LC9996">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L9997" data-line-number="9997"></td>
        <td id="LC9997">    <span><span>//</span> If we hit this assert, it means we may get the deadlock above and we're calling SendIPCEvent at a time we shouldn't.</span></td>
      </tr>
      <tr>
        <td id="L9998" data-line-number="9998"></td>
        <td id="LC9998">    <span><span>//</span> Note this race is as old as dirt.</span></td>
      </tr>
      <tr>
        <td id="L9999" data-line-number="9999"></td>
        <td id="LC9999">    <span>if</span> (<span>IsRCEventThread</span>() &amp;&amp; !event-&gt;<span>asyncSend</span>)</td>
      </tr>
      <tr>
        <td id="L10000" data-line-number="10000"></td>
        <td id="LC10000">    {</td>
      </tr>
      <tr>
        <td id="L10001" data-line-number="10001"></td>
        <td id="LC10001">        <span><span>//</span> Note that w/ Continue &amp; Attach, GetSynchronized() has a different meaning and the race above won't happen.</span></td>
      </tr>
      <tr>
        <td id="L10002" data-line-number="10002"></td>
        <td id="LC10002">        BOOL <span>fPossibleDeadlock</span> = process-&gt;<span>GetSynchronized</span>() || (event-&gt;<span>type</span> == DB_IPCE_CONTINUE) || (event-&gt;<span>type</span> == DB_IPCE_ATTACHING);</td>
      </tr>
      <tr>
        <td id="L10003" data-line-number="10003"></td>
        <td id="LC10003">        <span>CONSISTENCY_CHECK_MSGF</span>(<span>fPossibleDeadlock</span>, (<span><span>"</span>Possible deadlock while sending: '%s'<span>\n</span><span>"</span></span>, <span>IPCENames::GetName</span>(event-&gt;<span>type</span>)));</td>
      </tr>
      <tr>
        <td id="L10004" data-line-number="10004"></td>
        <td id="LC10004">    }</td>
      </tr>
      <tr>
        <td id="L10005" data-line-number="10005"></td>
        <td id="LC10005">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L10006" data-line-number="10006"></td>
        <td id="LC10006">
</td>
      </tr>
      <tr>
        <td id="L10007" data-line-number="10007"></td>
        <td id="LC10007">
</td>
      </tr>
      <tr>
        <td id="L10008" data-line-number="10008"></td>
        <td id="LC10008">
</td>
      </tr>
      <tr>
        <td id="L10009" data-line-number="10009"></td>
        <td id="LC10009">    <span><span>//</span> Cache this process into the MRU so that we can find it if we're debugging in retail.</span></td>
      </tr>
      <tr>
        <td id="L10010" data-line-number="10010"></td>
        <td id="LC10010">    g_pRSDebuggingInfo-&gt;<span>m_MRUprocess</span> = process;</td>
      </tr>
      <tr>
        <td id="L10011" data-line-number="10011"></td>
        <td id="LC10011">
</td>
      </tr>
      <tr>
        <td id="L10012" data-line-number="10012"></td>
        <td id="LC10012">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L10013" data-line-number="10013"></td>
        <td id="LC10013">    HRESULT hrEvent = S_OK;</td>
      </tr>
      <tr>
        <td id="L10014" data-line-number="10014"></td>
        <td id="LC10014">    <span>_ASSERTE</span>(event != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L10015" data-line-number="10015"></td>
        <td id="LC10015">
</td>
      </tr>
      <tr>
        <td id="L10016" data-line-number="10016"></td>
        <td id="LC10016">    <span><span>//</span> NOTE: the eventSize parameter is only so you can specify an event size that is SMALLER than the process send</span></td>
      </tr>
      <tr>
        <td id="L10017" data-line-number="10017"></td>
        <td id="LC10017">    <span><span>//</span> buffer size!!</span></td>
      </tr>
      <tr>
        <td id="L10018" data-line-number="10018"></td>
        <td id="LC10018">    <span>if</span> (eventSize &gt; CorDBIPC_BUFFER_SIZE)</td>
      </tr>
      <tr>
        <td id="L10019" data-line-number="10019"></td>
        <td id="LC10019">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L10020" data-line-number="10020"></td>
        <td id="LC10020">
</td>
      </tr>
      <tr>
        <td id="L10021" data-line-number="10021"></td>
        <td id="LC10021">    <span>STRESS_LOG4</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CRCET::SIPCE: sending %s to AD 0x%x, proc 0x%x(%d)<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L10022" data-line-number="10022"></td>
        <td id="LC10022">         <span>IPCENames::GetName</span>(event-&gt;<span>type</span>), <span>VmPtrToCookie</span>(event-&gt;<span>vmAppDomain</span>), process-&gt;<span>m_id</span>, process-&gt;<span>m_id</span>);</td>
      </tr>
      <tr>
        <td id="L10023" data-line-number="10023"></td>
        <td id="LC10023">
</td>
      </tr>
      <tr>
        <td id="L10024" data-line-number="10024"></td>
        <td id="LC10024">    <span><span>//</span> For 2-way events, this check is unnecessary (since we already check for LS exit)</span></td>
      </tr>
      <tr>
        <td id="L10025" data-line-number="10025"></td>
        <td id="LC10025">    <span><span>//</span> But for async events, we need this.</span></td>
      </tr>
      <tr>
        <td id="L10026" data-line-number="10026"></td>
        <td id="LC10026">    <span><span>//</span> So just check it up here and make everyone's life easier.</span></td>
      </tr>
      <tr>
        <td id="L10027" data-line-number="10027"></td>
        <td id="LC10027">    <span>if</span> (process-&gt;<span>m_terminated</span>)</td>
      </tr>
      <tr>
        <td id="L10028" data-line-number="10028"></td>
        <td id="LC10028">    {</td>
      </tr>
      <tr>
        <td id="L10029" data-line-number="10029"></td>
        <td id="LC10029">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO10000, <span><span>"</span>CRCET::SIPCE: LS already terminated, shortcut exiting<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10030" data-line-number="10030"></td>
        <td id="LC10030">        <span>return</span> CORDBG_E_PROCESS_TERMINATED;</td>
      </tr>
      <tr>
        <td id="L10031" data-line-number="10031"></td>
        <td id="LC10031">    }</td>
      </tr>
      <tr>
        <td id="L10032" data-line-number="10032"></td>
        <td id="LC10032">
</td>
      </tr>
      <tr>
        <td id="L10033" data-line-number="10033"></td>
        <td id="LC10033">    <span><span>//</span> If the helper thread has died, we can't send an IPC event (and it's never coming back either).</span></td>
      </tr>
      <tr>
        <td id="L10034" data-line-number="10034"></td>
        <td id="LC10034">    <span><span>//</span> Although we do wait on the thread's handle, there are strange windows where the thread's handle</span></td>
      </tr>
      <tr>
        <td id="L10035" data-line-number="10035"></td>
        <td id="LC10035">    <span><span>//</span> is not yet signaled even though we've continued from the exit-thread event for the helper.</span></td>
      </tr>
      <tr>
        <td id="L10036" data-line-number="10036"></td>
        <td id="LC10036">    <span>if</span> (process-&gt;<span>m_helperThreadDead</span>)</td>
      </tr>
      <tr>
        <td id="L10037" data-line-number="10037"></td>
        <td id="LC10037">    {</td>
      </tr>
      <tr>
        <td id="L10038" data-line-number="10038"></td>
        <td id="LC10038">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO10000, <span><span>"</span>CRCET::SIPCE: Helper-thread dead, shortcut exiting<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10039" data-line-number="10039"></td>
        <td id="LC10039">        <span>return</span> CORDBG_E_PROCESS_TERMINATED;</td>
      </tr>
      <tr>
        <td id="L10040" data-line-number="10040"></td>
        <td id="LC10040">    }</td>
      </tr>
      <tr>
        <td id="L10041" data-line-number="10041"></td>
        <td id="LC10041">
</td>
      </tr>
      <tr>
        <td id="L10042" data-line-number="10042"></td>
        <td id="LC10042">    BOOL <span>fUnrecoverableError</span> = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L10043" data-line-number="10043"></td>
        <td id="LC10043">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L10044" data-line-number="10044"></td>
        <td id="LC10044">    {</td>
      </tr>
      <tr>
        <td id="L10045" data-line-number="10045"></td>
        <td id="LC10045">        hr = process-&gt;<span>GetEventChannel</span>()-&gt;<span>SendEventToLeftSide</span>(event, eventSize);</td>
      </tr>
      <tr>
        <td id="L10046" data-line-number="10046"></td>
        <td id="LC10046">        <span>fUnrecoverableError</span> = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L10047" data-line-number="10047"></td>
        <td id="LC10047">    }</td>
      </tr>
      <tr>
        <td id="L10048" data-line-number="10048"></td>
        <td id="LC10048">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L10049" data-line-number="10049"></td>
        <td id="LC10049">
</td>
      </tr>
      <tr>
        <td id="L10050" data-line-number="10050"></td>
        <td id="LC10050">
</td>
      </tr>
      <tr>
        <td id="L10051" data-line-number="10051"></td>
        <td id="LC10051">    <span><span>//</span> If we're sending a Continue() event, then after this, the LS may run free.</span></td>
      </tr>
      <tr>
        <td id="L10052" data-line-number="10052"></td>
        <td id="LC10052">    <span><span>//</span> If this is the last managed event before the LS exits, (which is the case</span></td>
      </tr>
      <tr>
        <td id="L10053" data-line-number="10053"></td>
        <td id="LC10053">    <span><span>//</span> if we're responding to either an Exit-Thread or if we respond to a Detach)</span></td>
      </tr>
      <tr>
        <td id="L10054" data-line-number="10054"></td>
        <td id="LC10054">    <span><span>//</span> the LS may exit at anytime from here on, so we need to be careful.</span></td>
      </tr>
      <tr>
        <td id="L10055" data-line-number="10055"></td>
        <td id="LC10055">
</td>
      </tr>
      <tr>
        <td id="L10056" data-line-number="10056"></td>
        <td id="LC10056">
</td>
      </tr>
      <tr>
        <td id="L10057" data-line-number="10057"></td>
        <td id="LC10057">    <span>if</span> (<span>fUnrecoverableError</span>)</td>
      </tr>
      <tr>
        <td id="L10058" data-line-number="10058"></td>
        <td id="LC10058">    {</td>
      </tr>
      <tr>
        <td id="L10059" data-line-number="10059"></td>
        <td id="LC10059">        <span>_ASSERTE</span>(<span>FAILED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L10060" data-line-number="10060"></td>
        <td id="LC10060">        <span>CORDBSetUnrecoverableError</span>(process, hr, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L10061" data-line-number="10061"></td>
        <td id="LC10061">    }</td>
      </tr>
      <tr>
        <td id="L10062" data-line-number="10062"></td>
        <td id="LC10062">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L10063" data-line-number="10063"></td>
        <td id="LC10063">    {</td>
      </tr>
      <tr>
        <td id="L10064" data-line-number="10064"></td>
        <td id="LC10064">        <span><span>//</span> Get a handle to the target process - this call always succeeds</span></td>
      </tr>
      <tr>
        <td id="L10065" data-line-number="10065"></td>
        <td id="LC10065">        HANDLE hLSProcess = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L10066" data-line-number="10066"></td>
        <td id="LC10066">        process-&gt;<span>GetHandle</span>(&amp;hLSProcess);</td>
      </tr>
      <tr>
        <td id="L10067" data-line-number="10067"></td>
        <td id="LC10067">
</td>
      </tr>
      <tr>
        <td id="L10068" data-line-number="10068"></td>
        <td id="LC10068">        <span><span>//</span> We take locks to ensure that the CordbProcess object is still alive,</span></td>
      </tr>
      <tr>
        <td id="L10069" data-line-number="10069"></td>
        <td id="LC10069">        <span><span>//</span> even if the OS process exited.</span></td>
      </tr>
      <tr>
        <td id="L10070" data-line-number="10070"></td>
        <td id="LC10070">        <span>_ASSERTE</span>(hLSProcess != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L10071" data-line-number="10071"></td>
        <td id="LC10071">
</td>
      </tr>
      <tr>
        <td id="L10072" data-line-number="10072"></td>
        <td id="LC10072">        <span><span>//</span> Check if Sending the IPC event failed</span></td>
      </tr>
      <tr>
        <td id="L10073" data-line-number="10073"></td>
        <td id="LC10073">        <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L10074" data-line-number="10074"></td>
        <td id="LC10074">        {</td>
      </tr>
      <tr>
        <td id="L10075" data-line-number="10075"></td>
        <td id="LC10075">            <span><span>//</span> The failure to send an event may be due to the target process terminating</span></td>
      </tr>
      <tr>
        <td id="L10076" data-line-number="10076"></td>
        <td id="LC10076">            <span><span>//</span> (especially, but not exclusively, in the case of async events).</span></td>
      </tr>
      <tr>
        <td id="L10077" data-line-number="10077"></td>
        <td id="LC10077">            <span><span>//</span> There is a race here - we can't rely on any check above SendEventToLeftSide</span></td>
      </tr>
      <tr>
        <td id="L10078" data-line-number="10078"></td>
        <td id="LC10078">            <span><span>//</span> to tell us whether the process has exited yet.</span></td>
      </tr>
      <tr>
        <td id="L10079" data-line-number="10079"></td>
        <td id="LC10079">            <span><span>//</span> Check for that case and return an accurate hresult.</span></td>
      </tr>
      <tr>
        <td id="L10080" data-line-number="10080"></td>
        <td id="LC10080">            DWORD ret = <span>WaitForSingleObject</span>(hLSProcess, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L10081" data-line-number="10081"></td>
        <td id="LC10081">            <span>if</span> (ret == WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L10082" data-line-number="10082"></td>
        <td id="LC10082">            {</td>
      </tr>
      <tr>
        <td id="L10083" data-line-number="10083"></td>
        <td id="LC10083">                <span>return</span> CORDBG_E_PROCESS_TERMINATED;</td>
      </tr>
      <tr>
        <td id="L10084" data-line-number="10084"></td>
        <td id="LC10084">            }</td>
      </tr>
      <tr>
        <td id="L10085" data-line-number="10085"></td>
        <td id="LC10085">
</td>
      </tr>
      <tr>
        <td id="L10086" data-line-number="10086"></td>
        <td id="LC10086">            <span><span>//</span> Some other failure sending the IPC event - just return it.</span></td>
      </tr>
      <tr>
        <td id="L10087" data-line-number="10087"></td>
        <td id="LC10087">            <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L10088" data-line-number="10088"></td>
        <td id="LC10088">        }</td>
      </tr>
      <tr>
        <td id="L10089" data-line-number="10089"></td>
        <td id="LC10089">
</td>
      </tr>
      <tr>
        <td id="L10090" data-line-number="10090"></td>
        <td id="LC10090">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CRCET::SIPCE: sent...<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10091" data-line-number="10091"></td>
        <td id="LC10091">
</td>
      </tr>
      <tr>
        <td id="L10092" data-line-number="10092"></td>
        <td id="LC10092">        <span><span>//</span> If this is an async send, then don't wait for the left side to acknowledge that its read the event.</span></td>
      </tr>
      <tr>
        <td id="L10093" data-line-number="10093"></td>
        <td id="LC10093">        <span>_ASSERTE</span>(!event-&gt;<span>asyncSend</span> || !event-&gt;<span>replyRequired</span>);</td>
      </tr>
      <tr>
        <td id="L10094" data-line-number="10094"></td>
        <td id="LC10094">
</td>
      </tr>
      <tr>
        <td id="L10095" data-line-number="10095"></td>
        <td id="LC10095">        <span>if</span> (process-&gt;<span>GetEventChannel</span>()-&gt;<span>NeedToWaitForAck</span>(event))</td>
      </tr>
      <tr>
        <td id="L10096" data-line-number="10096"></td>
        <td id="LC10096">        {</td>
      </tr>
      <tr>
        <td id="L10097" data-line-number="10097"></td>
        <td id="LC10097">            <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000,<span><span>"</span>CRCET::SIPCE: waiting for left side to read event. (on RSER)<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10098" data-line-number="10098"></td>
        <td id="LC10098">
</td>
      </tr>
      <tr>
        <td id="L10099" data-line-number="10099"></td>
        <td id="LC10099">            DWORD ret;</td>
      </tr>
      <tr>
        <td id="L10100" data-line-number="10100"></td>
        <td id="LC10100">
</td>
      </tr>
      <tr>
        <td id="L10101" data-line-number="10101"></td>
        <td id="LC10101">            <span><span>//</span> Wait for either a reply (common case) or the left side to go away.</span></td>
      </tr>
      <tr>
        <td id="L10102" data-line-number="10102"></td>
        <td id="LC10102">            <span><span>//</span> We can't detach while waiting for a reply (because detach needs to send events).</span></td>
      </tr>
      <tr>
        <td id="L10103" data-line-number="10103"></td>
        <td id="LC10103">            <span><span>//</span> All of the outcomes from this wait are completely disjoint.</span></td>
      </tr>
      <tr>
        <td id="L10104" data-line-number="10104"></td>
        <td id="LC10104">            <span><span>//</span> It's possible for the LS to reply and then exit normally (Thread_Detach, Process_Detach)</span></td>
      </tr>
      <tr>
        <td id="L10105" data-line-number="10105"></td>
        <td id="LC10105">            <span><span>//</span> and so ExitProcess may have been called, but it doesn't matter.</span></td>
      </tr>
      <tr>
        <td id="L10106" data-line-number="10106"></td>
        <td id="LC10106">
</td>
      </tr>
      <tr>
        <td id="L10107" data-line-number="10107"></td>
        <td id="LC10107">            <span>enum</span> {</td>
      </tr>
      <tr>
        <td id="L10108" data-line-number="10108"></td>
        <td id="LC10108">                ID_RSER = WAIT_OBJECT_0,</td>
      </tr>
      <tr>
        <td id="L10109" data-line-number="10109"></td>
        <td id="LC10109">                ID_LSPROCESS,</td>
      </tr>
      <tr>
        <td id="L10110" data-line-number="10110"></td>
        <td id="LC10110">                ID_HELPERTHREAD,</td>
      </tr>
      <tr>
        <td id="L10111" data-line-number="10111"></td>
        <td id="LC10111">            };</td>
      </tr>
      <tr>
        <td id="L10112" data-line-number="10112"></td>
        <td id="LC10112">
</td>
      </tr>
      <tr>
        <td id="L10113" data-line-number="10113"></td>
        <td id="LC10113">            <span><span>//</span> Only wait on the helper thread for cases where the process is stopped (and thus we don't expect it do exit on us).</span></td>
      </tr>
      <tr>
        <td id="L10114" data-line-number="10114"></td>
        <td id="LC10114">            <span><span>//</span> If the process is running and we lose our helper thread, it ought to be during shutdown and we ough to</span></td>
      </tr>
      <tr>
        <td id="L10115" data-line-number="10115"></td>
        <td id="LC10115">            <span><span>//</span> follow up with an exit.</span></td>
      </tr>
      <tr>
        <td id="L10116" data-line-number="10116"></td>
        <td id="LC10116">            <span><span>//</span> This includes when we've dispatch Native events, and it includes the AsyncBreak sent to get us from a</span></td>
      </tr>
      <tr>
        <td id="L10117" data-line-number="10117"></td>
        <td id="LC10117">            <span><span>//</span> win32 frozen state to a synchronized state).</span></td>
      </tr>
      <tr>
        <td id="L10118" data-line-number="10118"></td>
        <td id="LC10118">            HANDLE hHelperThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L10119" data-line-number="10119"></td>
        <td id="LC10119">            <span>if</span> (process-&gt;<span>IsStopped</span>())</td>
      </tr>
      <tr>
        <td id="L10120" data-line-number="10120"></td>
        <td id="LC10120">            {</td>
      </tr>
      <tr>
        <td id="L10121" data-line-number="10121"></td>
        <td id="LC10121">                hHelperThread = process-&gt;<span>GetHelperThreadHandle</span>();</td>
      </tr>
      <tr>
        <td id="L10122" data-line-number="10122"></td>
        <td id="LC10122">            }</td>
      </tr>
      <tr>
        <td id="L10123" data-line-number="10123"></td>
        <td id="LC10123">
</td>
      </tr>
      <tr>
        <td id="L10124" data-line-number="10124"></td>
        <td id="LC10124">
</td>
      </tr>
      <tr>
        <td id="L10125" data-line-number="10125"></td>
        <td id="LC10125">            <span><span>//</span> Note that in case of a tie (multiple handles signaled), WaitForMultipleObjects gives</span></td>
      </tr>
      <tr>
        <td id="L10126" data-line-number="10126"></td>
        <td id="LC10126">            <span><span>//</span> priority to the handle earlier in the array.</span></td>
      </tr>
      <tr>
        <td id="L10127" data-line-number="10127"></td>
        <td id="LC10127">            HANDLE waitSet[] = { process-&gt;<span>GetEventChannel</span>()-&gt;<span>GetRightSideEventAckHandle</span>(), hLSProcess, hHelperThread};</td>
      </tr>
      <tr>
        <td id="L10128" data-line-number="10128"></td>
        <td id="LC10128">            DWORD cWaitSet = <span>NumItems</span>(waitSet);</td>
      </tr>
      <tr>
        <td id="L10129" data-line-number="10129"></td>
        <td id="LC10129">            <span>if</span> (hHelperThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10130" data-line-number="10130"></td>
        <td id="LC10130">            {</td>
      </tr>
      <tr>
        <td id="L10131" data-line-number="10131"></td>
        <td id="LC10131">                cWaitSet--;</td>
      </tr>
      <tr>
        <td id="L10132" data-line-number="10132"></td>
        <td id="LC10132">            }</td>
      </tr>
      <tr>
        <td id="L10133" data-line-number="10133"></td>
        <td id="LC10133">
</td>
      </tr>
      <tr>
        <td id="L10134" data-line-number="10134"></td>
        <td id="LC10134">            <span>do</span></td>
      </tr>
      <tr>
        <td id="L10135" data-line-number="10135"></td>
        <td id="LC10135">            {</td>
      </tr>
      <tr>
        <td id="L10136" data-line-number="10136"></td>
        <td id="LC10136">                ret = <span>WaitForMultipleObjectsEx</span>(cWaitSet, waitSet, <span>FALSE</span>, <span>CordbGetWaitTimeout</span>(), <span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L10137" data-line-number="10137"></td>
        <td id="LC10137">                <span><span>//</span> If we timeout because we're waiting for an uncontinued OOB event, we need to just keep waiting.</span></td>
      </tr>
      <tr>
        <td id="L10138" data-line-number="10138"></td>
        <td id="LC10138">            } <span>while</span> ((ret == WAIT_TIMEOUT) &amp;&amp; process-&gt;<span>IsWaitingForOOBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L10139" data-line-number="10139"></td>
        <td id="LC10139">
</td>
      </tr>
      <tr>
        <td id="L10140" data-line-number="10140"></td>
        <td id="LC10140">            <span>switch</span>(ret)</td>
      </tr>
      <tr>
        <td id="L10141" data-line-number="10141"></td>
        <td id="LC10141">            {</td>
      </tr>
      <tr>
        <td id="L10142" data-line-number="10142"></td>
        <td id="LC10142">            <span>case</span> ID_RSER:</td>
      </tr>
      <tr>
        <td id="L10143" data-line-number="10143"></td>
        <td id="LC10143">                <span><span>//</span> Normal reply from LS.</span></td>
      </tr>
      <tr>
        <td id="L10144" data-line-number="10144"></td>
        <td id="LC10144">                <span><span>//</span> This is set iff the LS replied to our event. The LS may have exited since it replied</span></td>
      </tr>
      <tr>
        <td id="L10145" data-line-number="10145"></td>
        <td id="LC10145">                <span><span>//</span> but we don't care. We still have the reply and we'll pass it on.</span></td>
      </tr>
      <tr>
        <td id="L10146" data-line-number="10146"></td>
        <td id="LC10146">                <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CRCET::SIPCE: left side read the event.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10147" data-line-number="10147"></td>
        <td id="LC10147">
</td>
      </tr>
      <tr>
        <td id="L10148" data-line-number="10148"></td>
        <td id="LC10148">                <span><span>//</span> If this was a two-way event, then the result is already ready for us. Simply copy the result back</span></td>
      </tr>
      <tr>
        <td id="L10149" data-line-number="10149"></td>
        <td id="LC10149">                <span><span>//</span> over the original event that was sent. Otherwise, the left side has simply read the event and is</span></td>
      </tr>
      <tr>
        <td id="L10150" data-line-number="10150"></td>
        <td id="LC10150">                <span><span>//</span> processing it...</span></td>
      </tr>
      <tr>
        <td id="L10151" data-line-number="10151"></td>
        <td id="LC10151">                <span>if</span> (event-&gt;<span>replyRequired</span>)</td>
      </tr>
      <tr>
        <td id="L10152" data-line-number="10152"></td>
        <td id="LC10152">                {</td>
      </tr>
      <tr>
        <td id="L10153" data-line-number="10153"></td>
        <td id="LC10153">                    process-&gt;<span>GetEventChannel</span>()-&gt;<span>GetReplyFromLeftSide</span>(event, eventSize);</td>
      </tr>
      <tr>
        <td id="L10154" data-line-number="10154"></td>
        <td id="LC10154">                    hrEvent = event-&gt;<span>hr</span>;</td>
      </tr>
      <tr>
        <td id="L10155" data-line-number="10155"></td>
        <td id="LC10155">                }</td>
      </tr>
      <tr>
        <td id="L10156" data-line-number="10156"></td>
        <td id="LC10156">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L10157" data-line-number="10157"></td>
        <td id="LC10157">
</td>
      </tr>
      <tr>
        <td id="L10158" data-line-number="10158"></td>
        <td id="LC10158">            <span>case</span> ID_LSPROCESS:</td>
      </tr>
      <tr>
        <td id="L10159" data-line-number="10159"></td>
        <td id="LC10159">                <span><span>//</span> Left side exited on us.</span></td>
      </tr>
      <tr>
        <td id="L10160" data-line-number="10160"></td>
        <td id="LC10160">                <span><span>//</span> ExitProcess may or may not have been called here (since it's on a different thread).</span></td>
      </tr>
      <tr>
        <td id="L10161" data-line-number="10161"></td>
        <td id="LC10161">                <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CRCET::SIPCE: left side exiting while RS was waiting for reply.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10162" data-line-number="10162"></td>
        <td id="LC10162">                hr = CORDBG_E_PROCESS_TERMINATED;</td>
      </tr>
      <tr>
        <td id="L10163" data-line-number="10163"></td>
        <td id="LC10163">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L10164" data-line-number="10164"></td>
        <td id="LC10164">
</td>
      </tr>
      <tr>
        <td id="L10165" data-line-number="10165"></td>
        <td id="LC10165">            <span>case</span> ID_HELPERTHREAD:</td>
      </tr>
      <tr>
        <td id="L10166" data-line-number="10166"></td>
        <td id="LC10166">                <span><span>//</span> We can only send most IPC events while the LS is synchronized. We shouldn't lose our helper thread</span></td>
      </tr>
      <tr>
        <td id="L10167" data-line-number="10167"></td>
        <td id="LC10167">                <span><span>//</span> when synced under any sort of normal conditions.</span></td>
      </tr>
      <tr>
        <td id="L10168" data-line-number="10168"></td>
        <td id="LC10168">                <span><span>//</span> This won't fire if the process already exited, because LSPROCESS gets higher priority in the wait</span></td>
      </tr>
      <tr>
        <td id="L10169" data-line-number="10169"></td>
        <td id="LC10169">                <span><span>//</span> (since it was placed earlier).</span></td>
      </tr>
      <tr>
        <td id="L10170" data-line-number="10170"></td>
        <td id="LC10170">                <span><span>//</span> Thus the only "legitimate" window where this could happen would be in a shutdown scenario after</span></td>
      </tr>
      <tr>
        <td id="L10171" data-line-number="10171"></td>
        <td id="LC10171">                <span><span>//</span> the helper is dead but before the process has died. We shouldn't be synced in that scenario,</span></td>
      </tr>
      <tr>
        <td id="L10172" data-line-number="10172"></td>
        <td id="LC10172">                <span><span>//</span> so we shouldn't be sending IPC events during it.</span></td>
      </tr>
      <tr>
        <td id="L10173" data-line-number="10173"></td>
        <td id="LC10173">                <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CRCET::SIPCE: lost helper thread.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10174" data-line-number="10174"></td>
        <td id="LC10174">
</td>
      </tr>
      <tr>
        <td id="L10175" data-line-number="10175"></td>
        <td id="LC10175">
</td>
      </tr>
      <tr>
        <td id="L10176" data-line-number="10176"></td>
        <td id="LC10176">                <span><span>//</span> Assert because we want to know if we ever actually hit this in any detectable scenario.</span></td>
      </tr>
      <tr>
        <td id="L10177" data-line-number="10177"></td>
        <td id="LC10177">                <span><span>//</span> However, shutdown can occur in preemptive mode. Thus if the RS does an AsyncBreak late</span></td>
      </tr>
      <tr>
        <td id="L10178" data-line-number="10178"></td>
        <td id="LC10178">                <span><span>//</span> enough, then the LS will appear to be stopped but may still shutdown.</span></td>
      </tr>
      <tr>
        <td id="L10179" data-line-number="10179"></td>
        <td id="LC10179">                <span><span>//</span> Since the debuggee can exit asynchronously at any time (eg, suppose somebody forcefully</span></td>
      </tr>
      <tr>
        <td id="L10180" data-line-number="10180"></td>
        <td id="LC10180">                <span><span>//</span> kills it with taskman), this doesn't introduce a new case.</span></td>
      </tr>
      <tr>
        <td id="L10181" data-line-number="10181"></td>
        <td id="LC10181">                <span><span>//</span> That aside, it would be great to be able to assert this:</span></td>
      </tr>
      <tr>
        <td id="L10182" data-line-number="10182"></td>
        <td id="LC10182">                <span><span>//</span>_ASSERTE(!"Potential deadlock - Randomly Lost helper thread");</span></td>
      </tr>
      <tr>
        <td id="L10183" data-line-number="10183"></td>
        <td id="LC10183">
</td>
      </tr>
      <tr>
        <td id="L10184" data-line-number="10184"></td>
        <td id="LC10184">                <span><span>//</span> We'll piggy back this on the terminated case.</span></td>
      </tr>
      <tr>
        <td id="L10185" data-line-number="10185"></td>
        <td id="LC10185">                hr = CORDBG_E_PROCESS_TERMINATED;</td>
      </tr>
      <tr>
        <td id="L10186" data-line-number="10186"></td>
        <td id="LC10186">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L10187" data-line-number="10187"></td>
        <td id="LC10187">
</td>
      </tr>
      <tr>
        <td id="L10188" data-line-number="10188"></td>
        <td id="LC10188">            <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L10189" data-line-number="10189"></td>
        <td id="LC10189">                {</td>
      </tr>
      <tr>
        <td id="L10190" data-line-number="10190"></td>
        <td id="LC10190">                    <span><span>//</span> If we timed out/failed, check the left side to see if it is in the unrecoverable error mode. If it is,</span></td>
      </tr>
      <tr>
        <td id="L10191" data-line-number="10191"></td>
        <td id="LC10191">                    <span><span>//</span> return the HR from the left side that caused the error.  Otherwise, return that we timed out and that</span></td>
      </tr>
      <tr>
        <td id="L10192" data-line-number="10192"></td>
        <td id="LC10192">                    <span><span>//</span> we don't really know why.</span></td>
      </tr>
      <tr>
        <td id="L10193" data-line-number="10193"></td>
        <td id="LC10193">                    HRESULT realHR = (ret == WAIT_FAILED) ? <span>HRESULT_FROM_GetLastError</span>() : <span>ErrWrapper</span>(CORDBG_E_TIMEOUT);</td>
      </tr>
      <tr>
        <td id="L10194" data-line-number="10194"></td>
        <td id="LC10194">
</td>
      </tr>
      <tr>
        <td id="L10195" data-line-number="10195"></td>
        <td id="LC10195">                    hr = process-&gt;<span>CheckForUnrecoverableError</span>();</td>
      </tr>
      <tr>
        <td id="L10196" data-line-number="10196"></td>
        <td id="LC10196">
</td>
      </tr>
      <tr>
        <td id="L10197" data-line-number="10197"></td>
        <td id="LC10197">                    <span>if</span> (hr == S_OK)</td>
      </tr>
      <tr>
        <td id="L10198" data-line-number="10198"></td>
        <td id="LC10198">                    {</td>
      </tr>
      <tr>
        <td id="L10199" data-line-number="10199"></td>
        <td id="LC10199">                        <span>CORDBSetUnrecoverableError</span>(process, realHR, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L10200" data-line-number="10200"></td>
        <td id="LC10200">                        hr = realHR;</td>
      </tr>
      <tr>
        <td id="L10201" data-line-number="10201"></td>
        <td id="LC10201">                    }</td>
      </tr>
      <tr>
        <td id="L10202" data-line-number="10202"></td>
        <td id="LC10202">
</td>
      </tr>
      <tr>
        <td id="L10203" data-line-number="10203"></td>
        <td id="LC10203">                    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CRCET::SIPCE: left side timeout/fail while RS waiting for reply. hr = 0x%08x<span>\n</span><span>"</span></span>, hr);</td>
      </tr>
      <tr>
        <td id="L10204" data-line-number="10204"></td>
        <td id="LC10204">                }</td>
      </tr>
      <tr>
        <td id="L10205" data-line-number="10205"></td>
        <td id="LC10205">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L10206" data-line-number="10206"></td>
        <td id="LC10206">            }</td>
      </tr>
      <tr>
        <td id="L10207" data-line-number="10207"></td>
        <td id="LC10207">
</td>
      </tr>
      <tr>
        <td id="L10208" data-line-number="10208"></td>
        <td id="LC10208">            <span><span>//</span> If the LS picked up RSEA, it will be reset (since it's an auto event).</span></td>
      </tr>
      <tr>
        <td id="L10209" data-line-number="10209"></td>
        <td id="LC10209">            <span><span>//</span> But in the case that the wait failed or  that the LS exited, we need to explicitly reset RSEA</span></td>
      </tr>
      <tr>
        <td id="L10210" data-line-number="10210"></td>
        <td id="LC10210">            <span>if</span> (hr != S_OK)</td>
      </tr>
      <tr>
        <td id="L10211" data-line-number="10211"></td>
        <td id="LC10211">            {</td>
      </tr>
      <tr>
        <td id="L10212" data-line-number="10212"></td>
        <td id="LC10212">                process-&gt;<span>GetEventChannel</span>()-&gt;<span>ClearEventForLeftSide</span>();</td>
      </tr>
      <tr>
        <td id="L10213" data-line-number="10213"></td>
        <td id="LC10213">            }</td>
      </tr>
      <tr>
        <td id="L10214" data-line-number="10214"></td>
        <td id="LC10214">
</td>
      </tr>
      <tr>
        <td id="L10215" data-line-number="10215"></td>
        <td id="LC10215">            <span><span>//</span> Done waiting for reply.</span></td>
      </tr>
      <tr>
        <td id="L10216" data-line-number="10216"></td>
        <td id="LC10216">
</td>
      </tr>
      <tr>
        <td id="L10217" data-line-number="10217"></td>
        <td id="LC10217">        }</td>
      </tr>
      <tr>
        <td id="L10218" data-line-number="10218"></td>
        <td id="LC10218">    }</td>
      </tr>
      <tr>
        <td id="L10219" data-line-number="10219"></td>
        <td id="LC10219">
</td>
      </tr>
      <tr>
        <td id="L10220" data-line-number="10220"></td>
        <td id="LC10220">    process-&gt;<span>ForceDacFlush</span>();</td>
      </tr>
      <tr>
        <td id="L10221" data-line-number="10221"></td>
        <td id="LC10221">
</td>
      </tr>
      <tr>
        <td id="L10222" data-line-number="10222"></td>
        <td id="LC10222">    <span><span>//</span> The hr and hrEvent are 2 very different things.</span></td>
      </tr>
      <tr>
        <td id="L10223" data-line-number="10223"></td>
        <td id="LC10223">    <span><span>//</span> hr tells us whether the event was sent successfully.</span></td>
      </tr>
      <tr>
        <td id="L10224" data-line-number="10224"></td>
        <td id="LC10224">    <span><span>//</span> hrEvent tells us how the LS responded to it.</span></td>
      </tr>
      <tr>
        <td id="L10225" data-line-number="10225"></td>
        <td id="LC10225">    <span><span>//</span> if FAILED(hr), then hrEvent is useless b/c the LS never got it.</span></td>
      </tr>
      <tr>
        <td id="L10226" data-line-number="10226"></td>
        <td id="LC10226">    <span><span>//</span> But if SUCCEEDED(hr), then hrEvent may still have failed and that could be</span></td>
      </tr>
      <tr>
        <td id="L10227" data-line-number="10227"></td>
        <td id="LC10227">    <span><span>//</span> valuable information.</span></td>
      </tr>
      <tr>
        <td id="L10228" data-line-number="10228"></td>
        <td id="LC10228">
</td>
      </tr>
      <tr>
        <td id="L10229" data-line-number="10229"></td>
        <td id="LC10229">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L10230" data-line-number="10230"></td>
        <td id="LC10230">}</td>
      </tr>
      <tr>
        <td id="L10231" data-line-number="10231"></td>
        <td id="LC10231">
</td>
      </tr>
      <tr>
        <td id="L10232" data-line-number="10232"></td>
        <td id="LC10232"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L10233" data-line-number="10233"></td>
        <td id="LC10233"><span><span>//</span> FlushQueuedEvents flushes a process's event queue.</span></td>
      </tr>
      <tr>
        <td id="L10234" data-line-number="10234"></td>
        <td id="LC10234"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10235" data-line-number="10235"></td>
        <td id="LC10235"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L10236" data-line-number="10236"></td>
        <td id="LC10236"><span><span>//</span>    pProcess - non-null process object whose queue will be drained</span></td>
      </tr>
      <tr>
        <td id="L10237" data-line-number="10237"></td>
        <td id="LC10237"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10238" data-line-number="10238"></td>
        <td id="LC10238"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L10239" data-line-number="10239"></td>
        <td id="LC10239"><span><span>//</span>    @dbgtodo shim: this should be part of the shim.</span></td>
      </tr>
      <tr>
        <td id="L10240" data-line-number="10240"></td>
        <td id="LC10240"><span><span>//</span>    This dispatches events that are queued up. The queue is populated by</span></td>
      </tr>
      <tr>
        <td id="L10241" data-line-number="10241"></td>
        <td id="LC10241"><span><span>//</span>    the shim's proxy callback (see code:ShimProxyCallback). This will dispatch events</span></td>
      </tr>
      <tr>
        <td id="L10242" data-line-number="10242"></td>
        <td id="LC10242"><span><span>//</span>    to the 'real' callback supplied by the debugger. This will dispatch events</span></td>
      </tr>
      <tr>
        <td id="L10243" data-line-number="10243"></td>
        <td id="LC10243"><span><span>//</span>    as long as the debugger keeps calling continue.</span></td>
      </tr>
      <tr>
        <td id="L10244" data-line-number="10244"></td>
        <td id="LC10244"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10245" data-line-number="10245"></td>
        <td id="LC10245"><span><span>//</span>    This requires that the process lock be held, although it will toggle the lock.</span></td>
      </tr>
      <tr>
        <td id="L10246" data-line-number="10246"></td>
        <td id="LC10246"><span>void</span> <span>CordbRCEventThread::FlushQueuedEvents</span>(CordbProcess* process)</td>
      </tr>
      <tr>
        <td id="L10247" data-line-number="10247"></td>
        <td id="LC10247">{</td>
      </tr>
      <tr>
        <td id="L10248" data-line-number="10248"></td>
        <td id="LC10248">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L10249" data-line-number="10249"></td>
        <td id="LC10249">    {</td>
      </tr>
      <tr>
        <td id="L10250" data-line-number="10250"></td>
        <td id="LC10250">        NOTHROW; <span><span>//</span> This is happening on the RCET thread, so there's no place to propogate an error back up.</span></td>
      </tr>
      <tr>
        <td id="L10251" data-line-number="10251"></td>
        <td id="LC10251">    }</td>
      </tr>
      <tr>
        <td id="L10252" data-line-number="10252"></td>
        <td id="LC10252">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L10253" data-line-number="10253"></td>
        <td id="LC10253">
</td>
      </tr>
      <tr>
        <td id="L10254" data-line-number="10254"></td>
        <td id="LC10254">    <span>STRESS_LOG0</span>(LF_CORDB,LL_INFO10000, <span><span>"</span>CRCET::FQE: Beginning to flush queue<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10255" data-line-number="10255"></td>
        <td id="LC10255">
</td>
      </tr>
      <tr>
        <td id="L10256" data-line-number="10256"></td>
        <td id="LC10256">    <span>_ASSERTE</span>(process-&gt;<span>GetShim</span>() != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L10257" data-line-number="10257"></td>
        <td id="LC10257">
</td>
      </tr>
      <tr>
        <td id="L10258" data-line-number="10258"></td>
        <td id="LC10258">    <span><span>//</span> We should only call this is we already have queued events</span></td>
      </tr>
      <tr>
        <td id="L10259" data-line-number="10259"></td>
        <td id="LC10259">    <span>_ASSERTE</span>(!process-&gt;<span>GetShim</span>()-&gt;<span>GetManagedEventQueue</span>()-&gt;<span>IsEmpty</span>());</td>
      </tr>
      <tr>
        <td id="L10260" data-line-number="10260"></td>
        <td id="LC10260">
</td>
      </tr>
      <tr>
        <td id="L10261" data-line-number="10261"></td>
        <td id="LC10261">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10262" data-line-number="10262"></td>
        <td id="LC10262">    <span><span>//</span> Dispatch queued events so long as they keep calling Continue()</span></td>
      </tr>
      <tr>
        <td id="L10263" data-line-number="10263"></td>
        <td id="LC10263">    <span><span>//</span> before returning from their callback. If they call Continue(),</span></td>
      </tr>
      <tr>
        <td id="L10264" data-line-number="10264"></td>
        <td id="LC10264">    <span><span>//</span> process-&gt;m_synchronized will be false again and we know to</span></td>
      </tr>
      <tr>
        <td id="L10265" data-line-number="10265"></td>
        <td id="LC10265">    <span><span>//</span> loop around and dispatch the next event.</span></td>
      </tr>
      <tr>
        <td id="L10266" data-line-number="10266"></td>
        <td id="LC10266">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10267" data-line-number="10267"></td>
        <td id="LC10267">    <span>_ASSERTE</span>(process-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L10268" data-line-number="10268"></td>
        <td id="LC10268">
</td>
      </tr>
      <tr>
        <td id="L10269" data-line-number="10269"></td>
        <td id="LC10269">
</td>
      </tr>
      <tr>
        <td id="L10270" data-line-number="10270"></td>
        <td id="LC10270">    <span><span>//</span> Give shim a chance to queue any faked attach events.  Grab a pointer to the</span></td>
      </tr>
      <tr>
        <td id="L10271" data-line-number="10271"></td>
        <td id="LC10271">    <span><span>//</span> ShimProcess now, while we still hold the process lock.  Once we release the lock,</span></td>
      </tr>
      <tr>
        <td id="L10272" data-line-number="10272"></td>
        <td id="LC10272">    <span><span>//</span> GetShim() may not work.</span></td>
      </tr>
      <tr>
        <td id="L10273" data-line-number="10273"></td>
        <td id="LC10273">    RSExtSmartPtr&lt;ShimProcess&gt; <span>pShim</span>(process-&gt;<span>GetShim</span>());</td>
      </tr>
      <tr>
        <td id="L10274" data-line-number="10274"></td>
        <td id="LC10274">
</td>
      </tr>
      <tr>
        <td id="L10275" data-line-number="10275"></td>
        <td id="LC10275">    <span><span>//</span> Release lock before we call out to shim to Queue fake events.</span></td>
      </tr>
      <tr>
        <td id="L10276" data-line-number="10276"></td>
        <td id="LC10276">    {</td>
      </tr>
      <tr>
        <td id="L10277" data-line-number="10277"></td>
        <td id="LC10277">        RSInverseLockHolder <span>inverseLockHolder</span>(process-&gt;<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L10278" data-line-number="10278"></td>
        <td id="LC10278">        {</td>
      </tr>
      <tr>
        <td id="L10279" data-line-number="10279"></td>
        <td id="LC10279">            <span>PUBLIC_CALLBACK_IN_THIS_SCOPE0_NO_LOCK</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L10280" data-line-number="10280"></td>
        <td id="LC10280">
</td>
      </tr>
      <tr>
        <td id="L10281" data-line-number="10281"></td>
        <td id="LC10281">            <span><span>//</span> Because we've released the lock, at any point from here forward the</span></td>
      </tr>
      <tr>
        <td id="L10282" data-line-number="10282"></td>
        <td id="LC10282">            <span><span>//</span> CorDbProcess may suddenly get neutered if the user detaches the debugger.</span></td>
      </tr>
      <tr>
        <td id="L10283" data-line-number="10283"></td>
        <td id="LC10283">
</td>
      </tr>
      <tr>
        <td id="L10284" data-line-number="10284"></td>
        <td id="LC10284">            pShim-&gt;<span>QueueFakeAttachEventsIfNeeded</span>(<span>false</span>);</td>
      </tr>
      <tr>
        <td id="L10285" data-line-number="10285"></td>
        <td id="LC10285">        }</td>
      </tr>
      <tr>
        <td id="L10286" data-line-number="10286"></td>
        <td id="LC10286">    }</td>
      </tr>
      <tr>
        <td id="L10287" data-line-number="10287"></td>
        <td id="LC10287">
</td>
      </tr>
      <tr>
        <td id="L10288" data-line-number="10288"></td>
        <td id="LC10288">    <span><span>//</span> Now that we're holding the process lock again, we can safely check whether</span></td>
      </tr>
      <tr>
        <td id="L10289" data-line-number="10289"></td>
        <td id="LC10289">    <span><span>//</span> process has become neutered</span></td>
      </tr>
      <tr>
        <td id="L10290" data-line-number="10290"></td>
        <td id="LC10290">    <span>if</span> (process-&gt;<span>IsNeutered</span>())</td>
      </tr>
      <tr>
        <td id="L10291" data-line-number="10291"></td>
        <td id="LC10291">    {</td>
      </tr>
      <tr>
        <td id="L10292" data-line-number="10292"></td>
        <td id="LC10292">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L10293" data-line-number="10293"></td>
        <td id="LC10293">    }</td>
      </tr>
      <tr>
        <td id="L10294" data-line-number="10294"></td>
        <td id="LC10294">
</td>
      </tr>
      <tr>
        <td id="L10295" data-line-number="10295"></td>
        <td id="LC10295">    {</td>
      </tr>
      <tr>
        <td id="L10296" data-line-number="10296"></td>
        <td id="LC10296">
</td>
      </tr>
      <tr>
        <td id="L10297" data-line-number="10297"></td>
        <td id="LC10297">        <span><span>//</span> Main dispatch loop here. DispatchRCEvent will take events out of the</span></td>
      </tr>
      <tr>
        <td id="L10298" data-line-number="10298"></td>
        <td id="LC10298">        <span><span>//</span> queue and invoke callbacks</span></td>
      </tr>
      <tr>
        <td id="L10299" data-line-number="10299"></td>
        <td id="LC10299">        <span>do</span></td>
      </tr>
      <tr>
        <td id="L10300" data-line-number="10300"></td>
        <td id="LC10300">        {</td>
      </tr>
      <tr>
        <td id="L10301" data-line-number="10301"></td>
        <td id="LC10301">            <span><span>//</span> DispatchRCEvent will mark the process as stopped before dispatching.</span></td>
      </tr>
      <tr>
        <td id="L10302" data-line-number="10302"></td>
        <td id="LC10302">            process-&gt;<span>DispatchRCEvent</span>();</td>
      </tr>
      <tr>
        <td id="L10303" data-line-number="10303"></td>
        <td id="LC10303">
</td>
      </tr>
      <tr>
        <td id="L10304" data-line-number="10304"></td>
        <td id="LC10304">            <span>LOG</span>((LF_CORDB,LL_INFO10000, <span><span>"</span>CRCET::FQE: Finished w/ <span>"</span></span></td>
      </tr>
      <tr>
        <td id="L10305" data-line-number="10305"></td>
        <td id="LC10305">                 <span><span>"</span>DispatchRCEvent<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L10306" data-line-number="10306"></td>
        <td id="LC10306">        }</td>
      </tr>
      <tr>
        <td id="L10307" data-line-number="10307"></td>
        <td id="LC10307">        <span>while</span> (process-&gt;<span>GetSyncCompleteRecv</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L10308" data-line-number="10308"></td>
        <td id="LC10308">               (process-&gt;<span>GetSynchronized</span>() == <span>false</span>) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L10309" data-line-number="10309"></td>
        <td id="LC10309">               (process-&gt;<span>GetShim</span>() != <span>NULL</span>) &amp;&amp; <span><span>//</span> may have lost Shim if we detached while dispatch</span></td>
      </tr>
      <tr>
        <td id="L10310" data-line-number="10310"></td>
        <td id="LC10310">               (!process-&gt;<span>GetShim</span>()-&gt;<span>GetManagedEventQueue</span>()-&gt;<span>IsEmpty</span>()) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L10311" data-line-number="10311"></td>
        <td id="LC10311">               (process-&gt;<span>m_unrecoverableError</span> == <span>false</span>));</td>
      </tr>
      <tr>
        <td id="L10312" data-line-number="10312"></td>
        <td id="LC10312">    }</td>
      </tr>
      <tr>
        <td id="L10313" data-line-number="10313"></td>
        <td id="LC10313">
</td>
      </tr>
      <tr>
        <td id="L10314" data-line-number="10314"></td>
        <td id="LC10314">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10315" data-line-number="10315"></td>
        <td id="LC10315">    <span><span>//</span> If they returned from a callback without calling Continue() then</span></td>
      </tr>
      <tr>
        <td id="L10316" data-line-number="10316"></td>
        <td id="LC10316">    <span><span>//</span> the process is still synchronized, so let the rc event thread</span></td>
      </tr>
      <tr>
        <td id="L10317" data-line-number="10317"></td>
        <td id="LC10317">    <span><span>//</span> know that it need to update its process list and remove the</span></td>
      </tr>
      <tr>
        <td id="L10318" data-line-number="10318"></td>
        <td id="LC10318">    <span><span>//</span> process's event.</span></td>
      </tr>
      <tr>
        <td id="L10319" data-line-number="10319"></td>
        <td id="LC10319">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10320" data-line-number="10320"></td>
        <td id="LC10320">    <span>if</span> (process-&gt;<span>GetSynchronized</span>())</td>
      </tr>
      <tr>
        <td id="L10321" data-line-number="10321"></td>
        <td id="LC10321">    {</td>
      </tr>
      <tr>
        <td id="L10322" data-line-number="10322"></td>
        <td id="LC10322">        <span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L10323" data-line-number="10323"></td>
        <td id="LC10323">    }</td>
      </tr>
      <tr>
        <td id="L10324" data-line-number="10324"></td>
        <td id="LC10324">
</td>
      </tr>
      <tr>
        <td id="L10325" data-line-number="10325"></td>
        <td id="LC10325">    <span>LOG</span>((LF_CORDB,LL_INFO10000, <span><span>"</span>CRCET::FQE: finished<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L10326" data-line-number="10326"></td>
        <td id="LC10326">}</td>
      </tr>
      <tr>
        <td id="L10327" data-line-number="10327"></td>
        <td id="LC10327">
</td>
      </tr>
      <tr>
        <td id="L10328" data-line-number="10328"></td>
        <td id="LC10328"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L10329" data-line-number="10329"></td>
        <td id="LC10329"><span><span>//</span> Preliminary Handle an Notification event from the target. This may queue the event,</span></td>
      </tr>
      <tr>
        <td id="L10330" data-line-number="10330"></td>
        <td id="LC10330"><span><span>//</span> but does not actually dispatch the event.</span></td>
      </tr>
      <tr>
        <td id="L10331" data-line-number="10331"></td>
        <td id="LC10331"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10332" data-line-number="10332"></td>
        <td id="LC10332"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L10333" data-line-number="10333"></td>
        <td id="LC10333"><span><span>//</span>    pManagedEvent - local managed-event. On success, this function assumes ownership of the</span></td>
      </tr>
      <tr>
        <td id="L10334" data-line-number="10334"></td>
        <td id="LC10334"><span><span>//</span>        event and will delete its memory. Assumed that caller allocated via 'new'.</span></td>
      </tr>
      <tr>
        <td id="L10335" data-line-number="10335"></td>
        <td id="LC10335"><span><span>//</span>    pCallback - callback obecjt to dispatch events on.</span></td>
      </tr>
      <tr>
        <td id="L10336" data-line-number="10336"></td>
        <td id="LC10336"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10337" data-line-number="10337"></td>
        <td id="LC10337"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L10338" data-line-number="10338"></td>
        <td id="LC10338"><span><span>//</span>    None. Throws on error. On error, caller still owns the pManagedEvent and must free it.</span></td>
      </tr>
      <tr>
        <td id="L10339" data-line-number="10339"></td>
        <td id="LC10339"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10340" data-line-number="10340"></td>
        <td id="LC10340"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L10341" data-line-number="10341"></td>
        <td id="LC10341"><span><span>//</span>    This should be called once a notification event is received from the target.</span></td>
      </tr>
      <tr>
        <td id="L10342" data-line-number="10342"></td>
        <td id="LC10342"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10343" data-line-number="10343"></td>
        <td id="LC10343"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L10344" data-line-number="10344"></td>
        <td id="LC10344"><span><span>//</span>    HandleRCEvent -- handle an IPC event received from the runtime controller.</span></td>
      </tr>
      <tr>
        <td id="L10345" data-line-number="10345"></td>
        <td id="LC10345"><span><span>//</span>    This will update ICorDebug state and immediately dispatch the event.</span></td>
      </tr>
      <tr>
        <td id="L10346" data-line-number="10346"></td>
        <td id="LC10346"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10347" data-line-number="10347"></td>
        <td id="LC10347"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L10348" data-line-number="10348"></td>
        <td id="LC10348"><span>void</span> <span>CordbProcess::HandleRCEvent</span>(</td>
      </tr>
      <tr>
        <td id="L10349" data-line-number="10349"></td>
        <td id="LC10349">    DebuggerIPCEvent *         pManagedEvent,</td>
      </tr>
      <tr>
        <td id="L10350" data-line-number="10350"></td>
        <td id="LC10350">    RSLockHolder *             pLockHolder,</td>
      </tr>
      <tr>
        <td id="L10351" data-line-number="10351"></td>
        <td id="LC10351">    ICorDebugManagedCallback * pCallback)</td>
      </tr>
      <tr>
        <td id="L10352" data-line-number="10352"></td>
        <td id="LC10352">{</td>
      </tr>
      <tr>
        <td id="L10353" data-line-number="10353"></td>
        <td id="LC10353">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L10354" data-line-number="10354"></td>
        <td id="LC10354">    {</td>
      </tr>
      <tr>
        <td id="L10355" data-line-number="10355"></td>
        <td id="LC10355">        THROWS;</td>
      </tr>
      <tr>
        <td id="L10356" data-line-number="10356"></td>
        <td id="LC10356">        <span>PRECONDITION</span>(<span>CheckPointer</span>(pManagedEvent));</td>
      </tr>
      <tr>
        <td id="L10357" data-line-number="10357"></td>
        <td id="LC10357">        <span>PRECONDITION</span>(<span>CheckPointer</span>(pCallback));</td>
      </tr>
      <tr>
        <td id="L10358" data-line-number="10358"></td>
        <td id="LC10358">        <span>PRECONDITION</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L10359" data-line-number="10359"></td>
        <td id="LC10359">    }</td>
      </tr>
      <tr>
        <td id="L10360" data-line-number="10360"></td>
        <td id="LC10360">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L10361" data-line-number="10361"></td>
        <td id="LC10361">
</td>
      </tr>
      <tr>
        <td id="L10362" data-line-number="10362"></td>
        <td id="LC10362">    <span>if</span> (!<span>this</span>-&gt;<span>IsSafeToSendEvents</span>() || <span>this</span>-&gt;<span>m_exiting</span>)</td>
      </tr>
      <tr>
        <td id="L10363" data-line-number="10363"></td>
        <td id="LC10363">    {</td>
      </tr>
      <tr>
        <td id="L10364" data-line-number="10364"></td>
        <td id="LC10364">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L10365" data-line-number="10365"></td>
        <td id="LC10365">    }</td>
      </tr>
      <tr>
        <td id="L10366" data-line-number="10366"></td>
        <td id="LC10366">
</td>
      </tr>
      <tr>
        <td id="L10367" data-line-number="10367"></td>
        <td id="LC10367">    <span><span>//</span> Marshals over some standard data from event.</span></td>
      </tr>
      <tr>
        <td id="L10368" data-line-number="10368"></td>
        <td id="LC10368">    <span>MarshalManagedEvent</span>(pManagedEvent);</td>
      </tr>
      <tr>
        <td id="L10369" data-line-number="10369"></td>
        <td id="LC10369">
</td>
      </tr>
      <tr>
        <td id="L10370" data-line-number="10370"></td>
        <td id="LC10370">    <span>STRESS_LOG4</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>RCET::TP: Got %s for AD 0x%x, proc 0x%x(%d)<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L10371" data-line-number="10371"></td>
        <td id="LC10371">        <span>IPCENames::GetName</span>(pManagedEvent-&gt;<span>type</span>), <span>VmPtrToCookie</span>(pManagedEvent-&gt;<span>vmAppDomain</span>), <span>this</span>-&gt;<span>m_id</span>, <span>this</span>-&gt;<span>m_id</span>);</td>
      </tr>
      <tr>
        <td id="L10372" data-line-number="10372"></td>
        <td id="LC10372">
</td>
      </tr>
      <tr>
        <td id="L10373" data-line-number="10373"></td>
        <td id="LC10373">    RSExtSmartPtr&lt;ICorDebugManagedCallback2&gt; pCallback2;</td>
      </tr>
      <tr>
        <td id="L10374" data-line-number="10374"></td>
        <td id="LC10374">    pCallback-&gt;<span>QueryInterface</span>(IID_ICorDebugManagedCallback2, <span>reinterpret_cast</span>&lt;<span>void</span> **&gt; (&amp;pCallback2));</td>
      </tr>
      <tr>
        <td id="L10375" data-line-number="10375"></td>
        <td id="LC10375">
</td>
      </tr>
      <tr>
        <td id="L10376" data-line-number="10376"></td>
        <td id="LC10376">    RSExtSmartPtr&lt;ICorDebugManagedCallback3&gt; pCallback3;</td>
      </tr>
      <tr>
        <td id="L10377" data-line-number="10377"></td>
        <td id="LC10377">    pCallback-&gt;<span>QueryInterface</span>(IID_ICorDebugManagedCallback3, <span>reinterpret_cast</span>&lt;<span>void</span> **&gt; (&amp;pCallback3));</td>
      </tr>
      <tr>
        <td id="L10378" data-line-number="10378"></td>
        <td id="LC10378">
</td>
      </tr>
      <tr>
        <td id="L10379" data-line-number="10379"></td>
        <td id="LC10379">    RSExtSmartPtr&lt;ICorDebugManagedCallback4&gt; pCallback4;</td>
      </tr>
      <tr>
        <td id="L10380" data-line-number="10380"></td>
        <td id="LC10380">    pCallback-&gt;<span>QueryInterface</span>(IID_ICorDebugManagedCallback4, <span>reinterpret_cast</span>&lt;<span>void</span> **&gt; (&amp;pCallback4));</td>
      </tr>
      <tr>
        <td id="L10381" data-line-number="10381"></td>
        <td id="LC10381">
</td>
      </tr>
      <tr>
        <td id="L10382" data-line-number="10382"></td>
        <td id="LC10382">    <span><span>//</span> Dispatch directly. May not necessarily dispatch an event.</span></td>
      </tr>
      <tr>
        <td id="L10383" data-line-number="10383"></td>
        <td id="LC10383">    <span><span>//</span> Toggles the lock to dispatch callbacks.</span></td>
      </tr>
      <tr>
        <td id="L10384" data-line-number="10384"></td>
        <td id="LC10384">    <span>RawDispatchEvent</span>(pManagedEvent, pLockHolder, pCallback, pCallback2, pCallback3, pCallback4);</td>
      </tr>
      <tr>
        <td id="L10385" data-line-number="10385"></td>
        <td id="LC10385">}</td>
      </tr>
      <tr>
        <td id="L10386" data-line-number="10386"></td>
        <td id="LC10386">
</td>
      </tr>
      <tr>
        <td id="L10387" data-line-number="10387"></td>
        <td id="LC10387"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10388" data-line-number="10388"></td>
        <td id="LC10388"><span><span>//</span> ProcessStateChanged -- tell the rc event thread that the ICorDebug's</span></td>
      </tr>
      <tr>
        <td id="L10389" data-line-number="10389"></td>
        <td id="LC10389"><span><span>//</span> process list has changed by setting its flag and thread control event.</span></td>
      </tr>
      <tr>
        <td id="L10390" data-line-number="10390"></td>
        <td id="LC10390"><span><span>//</span> This will cause the rc event thread to update its set of handles to wait</span></td>
      </tr>
      <tr>
        <td id="L10391" data-line-number="10391"></td>
        <td id="LC10391"><span><span>//</span> on.</span></td>
      </tr>
      <tr>
        <td id="L10392" data-line-number="10392"></td>
        <td id="LC10392"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10393" data-line-number="10393"></td>
        <td id="LC10393"><span>void</span> <span>CordbRCEventThread::ProcessStateChanged</span>()</td>
      </tr>
      <tr>
        <td id="L10394" data-line-number="10394"></td>
        <td id="LC10394">{</td>
      </tr>
      <tr>
        <td id="L10395" data-line-number="10395"></td>
        <td id="LC10395">    m_cordb-&gt;<span>LockProcessList</span>();</td>
      </tr>
      <tr>
        <td id="L10396" data-line-number="10396"></td>
        <td id="LC10396">    <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO100000, <span><span>"</span>CRCET::ProcessStateChanged<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10397" data-line-number="10397"></td>
        <td id="LC10397">    m_processStateChanged = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L10398" data-line-number="10398"></td>
        <td id="LC10398">    <span>SetEvent</span>(m_threadControlEvent);</td>
      </tr>
      <tr>
        <td id="L10399" data-line-number="10399"></td>
        <td id="LC10399">    m_cordb-&gt;<span>UnlockProcessList</span>();</td>
      </tr>
      <tr>
        <td id="L10400" data-line-number="10400"></td>
        <td id="LC10400">}</td>
      </tr>
      <tr>
        <td id="L10401" data-line-number="10401"></td>
        <td id="LC10401">
</td>
      </tr>
      <tr>
        <td id="L10402" data-line-number="10402"></td>
        <td id="LC10402">
</td>
      </tr>
      <tr>
        <td id="L10403" data-line-number="10403"></td>
        <td id="LC10403"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L10404" data-line-number="10404"></td>
        <td id="LC10404"><span><span>//</span> Primary loop of the Runtime Controller event thread.  This routine loops during the</span></td>
      </tr>
      <tr>
        <td id="L10405" data-line-number="10405"></td>
        <td id="LC10405"><span><span>//</span> debug session taking IPC events from the IPC block and calling out to process them.</span></td>
      </tr>
      <tr>
        <td id="L10406" data-line-number="10406"></td>
        <td id="LC10406"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10407" data-line-number="10407"></td>
        <td id="LC10407"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L10408" data-line-number="10408"></td>
        <td id="LC10408"><span><span>//</span>    None.</span></td>
      </tr>
      <tr>
        <td id="L10409" data-line-number="10409"></td>
        <td id="LC10409"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10410" data-line-number="10410"></td>
        <td id="LC10410"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L10411" data-line-number="10411"></td>
        <td id="LC10411"><span><span>//</span>    None.</span></td>
      </tr>
      <tr>
        <td id="L10412" data-line-number="10412"></td>
        <td id="LC10412"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10413" data-line-number="10413"></td>
        <td id="LC10413"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L10414" data-line-number="10414"></td>
        <td id="LC10414"><span><span>//</span>    @dbgtodo shim: eventually hoist the entire RCET into the shim.</span></td>
      </tr>
      <tr>
        <td id="L10415" data-line-number="10415"></td>
        <td id="LC10415"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L10416" data-line-number="10416"></td>
        <td id="LC10416"><span>void</span> <span>CordbRCEventThread::ThreadProc</span>()</td>
      </tr>
      <tr>
        <td id="L10417" data-line-number="10417"></td>
        <td id="LC10417">{</td>
      </tr>
      <tr>
        <td id="L10418" data-line-number="10418"></td>
        <td id="LC10418">    HANDLE         waitSet[MAXIMUM_WAIT_OBJECTS];</td>
      </tr>
      <tr>
        <td id="L10419" data-line-number="10419"></td>
        <td id="LC10419">    CordbProcess * rgProcessSet[MAXIMUM_WAIT_OBJECTS];</td>
      </tr>
      <tr>
        <td id="L10420" data-line-number="10420"></td>
        <td id="LC10420">    <span>unsigned</span> <span>int</span>   waitCount;</td>
      </tr>
      <tr>
        <td id="L10421" data-line-number="10421"></td>
        <td id="LC10421">
</td>
      </tr>
      <tr>
        <td id="L10422" data-line-number="10422"></td>
        <td id="LC10422">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L10423" data-line-number="10423"></td>
        <td id="LC10423">    <span>memset</span>(&amp;rgProcessSet, <span>NULL</span>, MAXIMUM_WAIT_OBJECTS * <span>sizeof</span>(CordbProcess *));</td>
      </tr>
      <tr>
        <td id="L10424" data-line-number="10424"></td>
        <td id="LC10424">    <span>memset</span>(&amp;waitSet, <span>NULL</span>, MAXIMUM_WAIT_OBJECTS * <span>sizeof</span>(HANDLE));</td>
      </tr>
      <tr>
        <td id="L10425" data-line-number="10425"></td>
        <td id="LC10425">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L10426" data-line-number="10426"></td>
        <td id="LC10426">
</td>
      </tr>
      <tr>
        <td id="L10427" data-line-number="10427"></td>
        <td id="LC10427">
</td>
      </tr>
      <tr>
        <td id="L10428" data-line-number="10428"></td>
        <td id="LC10428">    <span><span>//</span> First event to wait on is always the thread control event.</span></td>
      </tr>
      <tr>
        <td id="L10429" data-line-number="10429"></td>
        <td id="LC10429">    waitSet[<span>0</span>] = m_threadControlEvent;</td>
      </tr>
      <tr>
        <td id="L10430" data-line-number="10430"></td>
        <td id="LC10430">    rgProcessSet[<span>0</span>] = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L10431" data-line-number="10431"></td>
        <td id="LC10431">    waitCount = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L10432" data-line-number="10432"></td>
        <td id="LC10432">
</td>
      </tr>
      <tr>
        <td id="L10433" data-line-number="10433"></td>
        <td id="LC10433">    <span>while</span> (m_run)</td>
      </tr>
      <tr>
        <td id="L10434" data-line-number="10434"></td>
        <td id="LC10434">    {</td>
      </tr>
      <tr>
        <td id="L10435" data-line-number="10435"></td>
        <td id="LC10435">        DWORD dwStatus = <span>WaitForMultipleObjectsEx</span>(waitCount, waitSet, <span>FALSE</span>, <span>2000</span>, <span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L10436" data-line-number="10436"></td>
        <td id="LC10436">
</td>
      </tr>
      <tr>
        <td id="L10437" data-line-number="10437"></td>
        <td id="LC10437">        <span>if</span> (dwStatus == WAIT_FAILED)</td>
      </tr>
      <tr>
        <td id="L10438" data-line-number="10438"></td>
        <td id="LC10438">        {</td>
      </tr>
      <tr>
        <td id="L10439" data-line-number="10439"></td>
        <td id="LC10439">            <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO10000, <span><span>"</span>CordbRCEventThread::ThreadProc WaitFor<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L10440" data-line-number="10440"></td>
        <td id="LC10440">                        <span><span>"</span>MultipleObjects failed: 0x%x<span>\n</span><span>"</span></span>, <span>GetLastError</span>());</td>
      </tr>
      <tr>
        <td id="L10441" data-line-number="10441"></td>
        <td id="LC10441">        }</td>
      </tr>
      <tr>
        <td id="L10442" data-line-number="10442"></td>
        <td id="LC10442">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L10443" data-line-number="10443"></td>
        <td id="LC10443">        <span>else</span> <span>if</span> ((dwStatus &gt;= WAIT_OBJECT_0) &amp;&amp; (dwStatus &lt; WAIT_OBJECT_0 + waitCount) &amp;&amp; m_run)</td>
      </tr>
      <tr>
        <td id="L10444" data-line-number="10444"></td>
        <td id="LC10444">        {</td>
      </tr>
      <tr>
        <td id="L10445" data-line-number="10445"></td>
        <td id="LC10445">            <span><span>//</span> Got an event. Figure out which process it came from.</span></td>
      </tr>
      <tr>
        <td id="L10446" data-line-number="10446"></td>
        <td id="LC10446">            <span>unsigned</span> <span>int</span> procNumber = dwStatus - WAIT_OBJECT_0;</td>
      </tr>
      <tr>
        <td id="L10447" data-line-number="10447"></td>
        <td id="LC10447">
</td>
      </tr>
      <tr>
        <td id="L10448" data-line-number="10448"></td>
        <td id="LC10448">            <span>if</span> (procNumber != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L10449" data-line-number="10449"></td>
        <td id="LC10449">            {</td>
      </tr>
      <tr>
        <td id="L10450" data-line-number="10450"></td>
        <td id="LC10450">                <span><span>//</span> @dbgtodo shim: rip all of this out. Leave the assert in for now to verify that we're not accidentally</span></td>
      </tr>
      <tr>
        <td id="L10451" data-line-number="10451"></td>
        <td id="LC10451">                <span><span>//</span> going down this codepath. Once we rip this out, we can also simplify some of the code below.</span></td>
      </tr>
      <tr>
        <td id="L10452" data-line-number="10452"></td>
        <td id="LC10452">                <span><span>//</span> Notification events  (including Sync-complete) should be coming from Win32 event thread via</span></td>
      </tr>
      <tr>
        <td id="L10453" data-line-number="10453"></td>
        <td id="LC10453">                <span><span>//</span> V3 pipeline.</span></td>
      </tr>
      <tr>
        <td id="L10454" data-line-number="10454"></td>
        <td id="LC10454">                <span>_ASSERTE</span>(!<span><span>"</span>Shouldn't be here<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10455" data-line-number="10455"></td>
        <td id="LC10455">
</td>
      </tr>
      <tr>
        <td id="L10456" data-line-number="10456"></td>
        <td id="LC10456">            }</td>
      </tr>
      <tr>
        <td id="L10457" data-line-number="10457"></td>
        <td id="LC10457">        }</td>
      </tr>
      <tr>
        <td id="L10458" data-line-number="10458"></td>
        <td id="LC10458">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L10459" data-line-number="10459"></td>
        <td id="LC10459">
</td>
      </tr>
      <tr>
        <td id="L10460" data-line-number="10460"></td>
        <td id="LC10460">        <span><span>//</span> Empty any queued work items.</span></td>
      </tr>
      <tr>
        <td id="L10461" data-line-number="10461"></td>
        <td id="LC10461">        <span>DrainWorkerQueue</span>();</td>
      </tr>
      <tr>
        <td id="L10462" data-line-number="10462"></td>
        <td id="LC10462">
</td>
      </tr>
      <tr>
        <td id="L10463" data-line-number="10463"></td>
        <td id="LC10463">        <span><span>//</span> Check a flag to see if we need to update our list of processes to wait on.</span></td>
      </tr>
      <tr>
        <td id="L10464" data-line-number="10464"></td>
        <td id="LC10464">        <span>if</span> (m_processStateChanged)</td>
      </tr>
      <tr>
        <td id="L10465" data-line-number="10465"></td>
        <td id="LC10465">        {</td>
      </tr>
      <tr>
        <td id="L10466" data-line-number="10466"></td>
        <td id="LC10466">            <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>RCET::TP: refreshing process list.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L10467" data-line-number="10467"></td>
        <td id="LC10467">
</td>
      </tr>
      <tr>
        <td id="L10468" data-line-number="10468"></td>
        <td id="LC10468">            <span>unsigned</span> <span>int</span> i;</td>
      </tr>
      <tr>
        <td id="L10469" data-line-number="10469"></td>
        <td id="LC10469">
</td>
      </tr>
      <tr>
        <td id="L10470" data-line-number="10470"></td>
        <td id="LC10470">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10471" data-line-number="10471"></td>
        <td id="LC10471">            <span><span>//</span> free the old wait list</span></td>
      </tr>
      <tr>
        <td id="L10472" data-line-number="10472"></td>
        <td id="LC10472">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10473" data-line-number="10473"></td>
        <td id="LC10473">            <span>for</span> (i = <span>1</span>; i &lt; waitCount; i++)</td>
      </tr>
      <tr>
        <td id="L10474" data-line-number="10474"></td>
        <td id="LC10474">            {</td>
      </tr>
      <tr>
        <td id="L10475" data-line-number="10475"></td>
        <td id="LC10475">                rgProcessSet[i]-&gt;<span>InternalRelease</span>();</td>
      </tr>
      <tr>
        <td id="L10476" data-line-number="10476"></td>
        <td id="LC10476">            }</td>
      </tr>
      <tr>
        <td id="L10477" data-line-number="10477"></td>
        <td id="LC10477">
</td>
      </tr>
      <tr>
        <td id="L10478" data-line-number="10478"></td>
        <td id="LC10478">            <span><span>//</span> Pass 1: iterate the hash of all processes and collect the unsynchronized ones into the wait list.</span></td>
      </tr>
      <tr>
        <td id="L10479" data-line-number="10479"></td>
        <td id="LC10479">            <span><span>//</span> Note that Stop / Continue can still be called on a different thread while we're doing this.</span></td>
      </tr>
      <tr>
        <td id="L10480" data-line-number="10480"></td>
        <td id="LC10480">            m_cordb-&gt;<span>LockProcessList</span>();</td>
      </tr>
      <tr>
        <td id="L10481" data-line-number="10481"></td>
        <td id="LC10481">            m_processStateChanged = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L10482" data-line-number="10482"></td>
        <td id="LC10482">
</td>
      </tr>
      <tr>
        <td id="L10483" data-line-number="10483"></td>
        <td id="LC10483">            waitCount = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L10484" data-line-number="10484"></td>
        <td id="LC10484">
</td>
      </tr>
      <tr>
        <td id="L10485" data-line-number="10485"></td>
        <td id="LC10485">            CordbSafeHashTable&lt;CordbProcess&gt; * pHashTable = m_cordb-&gt;<span>GetProcessList</span>();</td>
      </tr>
      <tr>
        <td id="L10486" data-line-number="10486"></td>
        <td id="LC10486">            HASHFIND hashFind;</td>
      </tr>
      <tr>
        <td id="L10487" data-line-number="10487"></td>
        <td id="LC10487">            CordbProcess * pProcess;</td>
      </tr>
      <tr>
        <td id="L10488" data-line-number="10488"></td>
        <td id="LC10488">
</td>
      </tr>
      <tr>
        <td id="L10489" data-line-number="10489"></td>
        <td id="LC10489">            <span>for</span> (pProcess =  pHashTable-&gt;<span>FindFirst</span>(&amp;hashFind); pProcess != <span>NULL</span>; pProcess = pHashTable-&gt;<span>FindNext</span>(&amp;hashFind))</td>
      </tr>
      <tr>
        <td id="L10490" data-line-number="10490"></td>
        <td id="LC10490">            {</td>
      </tr>
      <tr>
        <td id="L10491" data-line-number="10491"></td>
        <td id="LC10491">                <span>_ASSERTE</span>(waitCount &lt; MAXIMUM_WAIT_OBJECTS);</td>
      </tr>
      <tr>
        <td id="L10492" data-line-number="10492"></td>
        <td id="LC10492">
</td>
      </tr>
      <tr>
        <td id="L10493" data-line-number="10493"></td>
        <td id="LC10493">                <span>if</span>( waitCount &gt;= MAXIMUM_WAIT_OBJECTS )</td>
      </tr>
      <tr>
        <td id="L10494" data-line-number="10494"></td>
        <td id="LC10494">                {</td>
      </tr>
      <tr>
        <td id="L10495" data-line-number="10495"></td>
        <td id="LC10495">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L10496" data-line-number="10496"></td>
        <td id="LC10496">                }</td>
      </tr>
      <tr>
        <td id="L10497" data-line-number="10497"></td>
        <td id="LC10497">
</td>
      </tr>
      <tr>
        <td id="L10498" data-line-number="10498"></td>
        <td id="LC10498">                <span><span>//</span> Only listen to unsynchronized processes. Processes that are synchronized will not send events without</span></td>
      </tr>
      <tr>
        <td id="L10499" data-line-number="10499"></td>
        <td id="LC10499">                <span><span>//</span> being asked by us first, so there is no need to async listen to them.</span></td>
      </tr>
      <tr>
        <td id="L10500" data-line-number="10500"></td>
        <td id="LC10500">                <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10501" data-line-number="10501"></td>
        <td id="LC10501">                <span><span>//</span> Note: if a process is not synchronized then there is no way for it to transition to the syncrhonized</span></td>
      </tr>
      <tr>
        <td id="L10502" data-line-number="10502"></td>
        <td id="LC10502">                <span><span>//</span> state without this thread receiving an event and taking action. So there is no need to lock the</span></td>
      </tr>
      <tr>
        <td id="L10503" data-line-number="10503"></td>
        <td id="LC10503">                <span><span>//</span> per-process mutex when checking the process's synchronized flag here.</span></td>
      </tr>
      <tr>
        <td id="L10504" data-line-number="10504"></td>
        <td id="LC10504">                <span>if</span> (!pProcess-&gt;<span>GetSynchronized</span>() &amp;&amp; pProcess-&gt;<span>IsSafeToSendEvents</span>())</td>
      </tr>
      <tr>
        <td id="L10505" data-line-number="10505"></td>
        <td id="LC10505">                {</td>
      </tr>
      <tr>
        <td id="L10506" data-line-number="10506"></td>
        <td id="LC10506">                    <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>RCET::TP: listening to process 0x%x(%d)<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L10507" data-line-number="10507"></td>
        <td id="LC10507">                                pProcess-&gt;<span>m_id</span>, pProcess-&gt;<span>m_id</span>);</td>
      </tr>
      <tr>
        <td id="L10508" data-line-number="10508"></td>
        <td id="LC10508">
</td>
      </tr>
      <tr>
        <td id="L10509" data-line-number="10509"></td>
        <td id="LC10509">                    waitSet[waitCount] = pProcess-&gt;<span>m_leftSideEventAvailable</span>;</td>
      </tr>
      <tr>
        <td id="L10510" data-line-number="10510"></td>
        <td id="LC10510">                    rgProcessSet[waitCount] = pProcess;</td>
      </tr>
      <tr>
        <td id="L10511" data-line-number="10511"></td>
        <td id="LC10511">                    rgProcessSet[waitCount]-&gt;<span>InternalAddRef</span>();</td>
      </tr>
      <tr>
        <td id="L10512" data-line-number="10512"></td>
        <td id="LC10512">                    waitCount++;</td>
      </tr>
      <tr>
        <td id="L10513" data-line-number="10513"></td>
        <td id="LC10513">                }</td>
      </tr>
      <tr>
        <td id="L10514" data-line-number="10514"></td>
        <td id="LC10514">            }</td>
      </tr>
      <tr>
        <td id="L10515" data-line-number="10515"></td>
        <td id="LC10515">
</td>
      </tr>
      <tr>
        <td id="L10516" data-line-number="10516"></td>
        <td id="LC10516">            m_cordb-&gt;<span>UnlockProcessList</span>();</td>
      </tr>
      <tr>
        <td id="L10517" data-line-number="10517"></td>
        <td id="LC10517">
</td>
      </tr>
      <tr>
        <td id="L10518" data-line-number="10518"></td>
        <td id="LC10518">            <span><span>//</span> Pass 2: for each process that we placed in the wait list, determine if there are any existing queued</span></td>
      </tr>
      <tr>
        <td id="L10519" data-line-number="10519"></td>
        <td id="LC10519">            <span><span>//</span> events that need to be flushed.</span></td>
      </tr>
      <tr>
        <td id="L10520" data-line-number="10520"></td>
        <td id="LC10520">
</td>
      </tr>
      <tr>
        <td id="L10521" data-line-number="10521"></td>
        <td id="LC10521">            <span><span>//</span> Start i at 1 to skip the control event...</span></td>
      </tr>
      <tr>
        <td id="L10522" data-line-number="10522"></td>
        <td id="LC10522">            i = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L10523" data-line-number="10523"></td>
        <td id="LC10523">
</td>
      </tr>
      <tr>
        <td id="L10524" data-line-number="10524"></td>
        <td id="LC10524">            <span>while</span>(i &lt; waitCount)</td>
      </tr>
      <tr>
        <td id="L10525" data-line-number="10525"></td>
        <td id="LC10525">            {</td>
      </tr>
      <tr>
        <td id="L10526" data-line-number="10526"></td>
        <td id="LC10526">                pProcess = rgProcessSet[i];</td>
      </tr>
      <tr>
        <td id="L10527" data-line-number="10527"></td>
        <td id="LC10527">
</td>
      </tr>
      <tr>
        <td id="L10528" data-line-number="10528"></td>
        <td id="LC10528">                <span><span>//</span> Take the process lock so we can check the queue safely</span></td>
      </tr>
      <tr>
        <td id="L10529" data-line-number="10529"></td>
        <td id="LC10529">                pProcess-&gt;<span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L10530" data-line-number="10530"></td>
        <td id="LC10530">
</td>
      </tr>
      <tr>
        <td id="L10531" data-line-number="10531"></td>
        <td id="LC10531">                <span><span>//</span> Now that we've just locked the processes, we can safely inspect it and dispatch events.</span></td>
      </tr>
      <tr>
        <td id="L10532" data-line-number="10532"></td>
        <td id="LC10532">                <span><span>//</span> The process may have changed since when we first added it to the process list in Pass 1,</span></td>
      </tr>
      <tr>
        <td id="L10533" data-line-number="10533"></td>
        <td id="LC10533">                <span><span>//</span> so we can't make any assumptions about whether it's sync, live, or exiting.</span></td>
      </tr>
      <tr>
        <td id="L10534" data-line-number="10534"></td>
        <td id="LC10534">
</td>
      </tr>
      <tr>
        <td id="L10535" data-line-number="10535"></td>
        <td id="LC10535">                <span><span>//</span> Flush the queue if necessary. Note, we only do this if we've actually received a SyncComplete message</span></td>
      </tr>
      <tr>
        <td id="L10536" data-line-number="10536"></td>
        <td id="LC10536">                <span><span>//</span> from this process. If we haven't received a SyncComplete yet, then we don't attempt to drain any</span></td>
      </tr>
      <tr>
        <td id="L10537" data-line-number="10537"></td>
        <td id="LC10537">                <span><span>//</span> queued events yet. They'll be drained when the SyncComplete event is actually received.</span></td>
      </tr>
      <tr>
        <td id="L10538" data-line-number="10538"></td>
        <td id="LC10538">                <span>if</span> (pProcess-&gt;<span>GetSyncCompleteRecv</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L10539" data-line-number="10539"></td>
        <td id="LC10539">                    (pProcess-&gt;<span>GetShim</span>() != <span>NULL</span>) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L10540" data-line-number="10540"></td>
        <td id="LC10540">                    !pProcess-&gt;<span>GetSynchronized</span>())</td>
      </tr>
      <tr>
        <td id="L10541" data-line-number="10541"></td>
        <td id="LC10541">                {</td>
      </tr>
      <tr>
        <td id="L10542" data-line-number="10542"></td>
        <td id="LC10542">                    <span>if</span> (pProcess-&gt;<span>GetShim</span>()-&gt;<span>GetManagedEventQueue</span>()-&gt;<span>IsEmpty</span>())</td>
      </tr>
      <tr>
        <td id="L10543" data-line-number="10543"></td>
        <td id="LC10543">                    {</td>
      </tr>
      <tr>
        <td id="L10544" data-line-number="10544"></td>
        <td id="LC10544">                        <span><span>//</span> Effectively what we are doing here is to continue everything without actually</span></td>
      </tr>
      <tr>
        <td id="L10545" data-line-number="10545"></td>
        <td id="LC10545">                        <span><span>//</span> handling an event.  We can get here if the event raised by the LS is a duplicate</span></td>
      </tr>
      <tr>
        <td id="L10546" data-line-number="10546"></td>
        <td id="LC10546">                        <span><span>//</span> creation event, which the shim discards without adding it to the event queue.</span></td>
      </tr>
      <tr>
        <td id="L10547" data-line-number="10547"></td>
        <td id="LC10547">                        <span><span>//</span> See code:ShimProcess::IsDuplicateCreationEvent.</span></td>
      </tr>
      <tr>
        <td id="L10548" data-line-number="10548"></td>
        <td id="LC10548">                        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10549" data-line-number="10549"></td>
        <td id="LC10549">                        <span><span>//</span> To continue, we need to increment the stop count first.  Also, we can't call</span></td>
      </tr>
      <tr>
        <td id="L10550" data-line-number="10550"></td>
        <td id="LC10550">                        <span><span>//</span> Continue() while holding the process lock.</span></td>
      </tr>
      <tr>
        <td id="L10551" data-line-number="10551"></td>
        <td id="LC10551">                        pProcess-&gt;<span>SetSynchronized</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L10552" data-line-number="10552"></td>
        <td id="LC10552">                        pProcess-&gt;<span>IncStopCount</span>();</td>
      </tr>
      <tr>
        <td id="L10553" data-line-number="10553"></td>
        <td id="LC10553">                        pProcess-&gt;<span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L10554" data-line-number="10554"></td>
        <td id="LC10554">                        pProcess-&gt;<span>ContinueInternal</span>(<span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L10555" data-line-number="10555"></td>
        <td id="LC10555">                        pProcess-&gt;<span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L10556" data-line-number="10556"></td>
        <td id="LC10556">                    }</td>
      </tr>
      <tr>
        <td id="L10557" data-line-number="10557"></td>
        <td id="LC10557">                    <span>else</span></td>
      </tr>
      <tr>
        <td id="L10558" data-line-number="10558"></td>
        <td id="LC10558">                    {</td>
      </tr>
      <tr>
        <td id="L10559" data-line-number="10559"></td>
        <td id="LC10559">                        <span><span>//</span> This may toggle the process-lock</span></td>
      </tr>
      <tr>
        <td id="L10560" data-line-number="10560"></td>
        <td id="LC10560">                        <span>FlushQueuedEvents</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L10561" data-line-number="10561"></td>
        <td id="LC10561">                    }</td>
      </tr>
      <tr>
        <td id="L10562" data-line-number="10562"></td>
        <td id="LC10562">                }</td>
      </tr>
      <tr>
        <td id="L10563" data-line-number="10563"></td>
        <td id="LC10563">
</td>
      </tr>
      <tr>
        <td id="L10564" data-line-number="10564"></td>
        <td id="LC10564">                <span><span>//</span> Flushing could have left the process synchronized...</span></td>
      </tr>
      <tr>
        <td id="L10565" data-line-number="10565"></td>
        <td id="LC10565">                <span><span>//</span> Common case is if the callback didn't call Continue().</span></td>
      </tr>
      <tr>
        <td id="L10566" data-line-number="10566"></td>
        <td id="LC10566">                <span>if</span> (pProcess-&gt;<span>GetSynchronized</span>())</td>
      </tr>
      <tr>
        <td id="L10567" data-line-number="10567"></td>
        <td id="LC10567">                {</td>
      </tr>
      <tr>
        <td id="L10568" data-line-number="10568"></td>
        <td id="LC10568">                    <span><span>//</span> remove the process from the wait list by moving all the other processes down one.</span></td>
      </tr>
      <tr>
        <td id="L10569" data-line-number="10569"></td>
        <td id="LC10569">                    <span>if</span> ((i + <span>1</span>) &lt; waitCount)</td>
      </tr>
      <tr>
        <td id="L10570" data-line-number="10570"></td>
        <td id="LC10570">                    {</td>
      </tr>
      <tr>
        <td id="L10571" data-line-number="10571"></td>
        <td id="LC10571">                        <span>memcpy</span>(&amp;rgProcessSet[i], &amp;(rgProcessSet[i+<span>1</span>]), <span>sizeof</span>(rgProcessSet[<span>0</span>]) * (waitCount - i - <span>1</span>));</td>
      </tr>
      <tr>
        <td id="L10572" data-line-number="10572"></td>
        <td id="LC10572">                        <span>memcpy</span>(&amp;waitSet[i], &amp;waitSet[i+<span>1</span>], <span>sizeof</span>(waitSet[<span>0</span>]) * (waitCount - i - <span>1</span>));</td>
      </tr>
      <tr>
        <td id="L10573" data-line-number="10573"></td>
        <td id="LC10573">                    }</td>
      </tr>
      <tr>
        <td id="L10574" data-line-number="10574"></td>
        <td id="LC10574">
</td>
      </tr>
      <tr>
        <td id="L10575" data-line-number="10575"></td>
        <td id="LC10575">                    <span><span>//</span> drop the count of processes to wait on</span></td>
      </tr>
      <tr>
        <td id="L10576" data-line-number="10576"></td>
        <td id="LC10576">                    waitCount--;</td>
      </tr>
      <tr>
        <td id="L10577" data-line-number="10577"></td>
        <td id="LC10577">
</td>
      </tr>
      <tr>
        <td id="L10578" data-line-number="10578"></td>
        <td id="LC10578">                    pProcess-&gt;<span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L10579" data-line-number="10579"></td>
        <td id="LC10579">
</td>
      </tr>
      <tr>
        <td id="L10580" data-line-number="10580"></td>
        <td id="LC10580">                    <span><span>//</span> make sure to release the reference we added when the process was added to the wait list.</span></td>
      </tr>
      <tr>
        <td id="L10581" data-line-number="10581"></td>
        <td id="LC10581">                    pProcess-&gt;<span>InternalRelease</span>();</td>
      </tr>
      <tr>
        <td id="L10582" data-line-number="10582"></td>
        <td id="LC10582">
</td>
      </tr>
      <tr>
        <td id="L10583" data-line-number="10583"></td>
        <td id="LC10583">                    <span><span>//</span> We don't have to increment i because we've copied the next element into</span></td>
      </tr>
      <tr>
        <td id="L10584" data-line-number="10584"></td>
        <td id="LC10584">                    <span><span>//</span> the current value at i.</span></td>
      </tr>
      <tr>
        <td id="L10585" data-line-number="10585"></td>
        <td id="LC10585">                }</td>
      </tr>
      <tr>
        <td id="L10586" data-line-number="10586"></td>
        <td id="LC10586">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L10587" data-line-number="10587"></td>
        <td id="LC10587">                {</td>
      </tr>
      <tr>
        <td id="L10588" data-line-number="10588"></td>
        <td id="LC10588">                    <span><span>//</span> Even after flushing, its still not syncd, so leave it in the wait list.</span></td>
      </tr>
      <tr>
        <td id="L10589" data-line-number="10589"></td>
        <td id="LC10589">                    pProcess-&gt;<span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L10590" data-line-number="10590"></td>
        <td id="LC10590">
</td>
      </tr>
      <tr>
        <td id="L10591" data-line-number="10591"></td>
        <td id="LC10591">                    <span><span>//</span> Increment i normally.</span></td>
      </tr>
      <tr>
        <td id="L10592" data-line-number="10592"></td>
        <td id="LC10592">                    i++;</td>
      </tr>
      <tr>
        <td id="L10593" data-line-number="10593"></td>
        <td id="LC10593">                }</td>
      </tr>
      <tr>
        <td id="L10594" data-line-number="10594"></td>
        <td id="LC10594">            }</td>
      </tr>
      <tr>
        <td id="L10595" data-line-number="10595"></td>
        <td id="LC10595">        } <span><span>//</span> end ProcessStateChanged</span></td>
      </tr>
      <tr>
        <td id="L10596" data-line-number="10596"></td>
        <td id="LC10596">    }  <span><span>//</span> while (m_run)</span></td>
      </tr>
      <tr>
        <td id="L10597" data-line-number="10597"></td>
        <td id="LC10597">
</td>
      </tr>
      <tr>
        <td id="L10598" data-line-number="10598"></td>
        <td id="LC10598">#<span>ifdef</span> _DEBUG_IMPL</td>
      </tr>
      <tr>
        <td id="L10599" data-line-number="10599"></td>
        <td id="LC10599">    <span><span>//</span> We intentionally return while leaking some CordbProcess objects inside</span></td>
      </tr>
      <tr>
        <td id="L10600" data-line-number="10600"></td>
        <td id="LC10600">    <span><span>//</span> rgProcessSet, in some cases (e.g., I've seen this happen when detaching from a</span></td>
      </tr>
      <tr>
        <td id="L10601" data-line-number="10601"></td>
        <td id="LC10601">    <span><span>//</span> debuggee almost immediately after attaching to it). In the future, we should</span></td>
      </tr>
      <tr>
        <td id="L10602" data-line-number="10602"></td>
        <td id="LC10602">    <span><span>//</span> really consider not leaking these anymore. However, I'm unsure how safe it is to just</span></td>
      </tr>
      <tr>
        <td id="L10603" data-line-number="10603"></td>
        <td id="LC10603">    <span><span>//</span> go and InternalRelease() those guys, as above we intentionally DON'T release them when</span></td>
      </tr>
      <tr>
        <td id="L10604" data-line-number="10604"></td>
        <td id="LC10604">    <span><span>//</span> they're not synchronized. So for now, to make debug builds happy, exclude those</span></td>
      </tr>
      <tr>
        <td id="L10605" data-line-number="10605"></td>
        <td id="LC10605">    <span><span>//</span> references when we run CheckMemLeaks() later on. In our next side-by-side release,</span></td>
      </tr>
      <tr>
        <td id="L10606" data-line-number="10606"></td>
        <td id="LC10606">    <span><span>//</span> consider actually doing InternalRelease() on the remaining CordbProcesses on</span></td>
      </tr>
      <tr>
        <td id="L10607" data-line-number="10607"></td>
        <td id="LC10607">    <span><span>//</span> retail, and then we can remove the following loop.</span></td>
      </tr>
      <tr>
        <td id="L10608" data-line-number="10608"></td>
        <td id="LC10608">    <span>for</span> (UINT i=<span>1</span>; i &lt; waitCount; i++)</td>
      </tr>
      <tr>
        <td id="L10609" data-line-number="10609"></td>
        <td id="LC10609">    {</td>
      </tr>
      <tr>
        <td id="L10610" data-line-number="10610"></td>
        <td id="LC10610">        <span>InterlockedDecrement</span>(&amp;Cordb::s_DbgMemTotalOutstandingInternalRefs);</td>
      </tr>
      <tr>
        <td id="L10611" data-line-number="10611"></td>
        <td id="LC10611">    }</td>
      </tr>
      <tr>
        <td id="L10612" data-line-number="10612"></td>
        <td id="LC10612">#<span>endif</span> <span><span>//</span>_DEBUG_IMPL</span></td>
      </tr>
      <tr>
        <td id="L10613" data-line-number="10613"></td>
        <td id="LC10613">}</td>
      </tr>
      <tr>
        <td id="L10614" data-line-number="10614"></td>
        <td id="LC10614">
</td>
      </tr>
      <tr>
        <td id="L10615" data-line-number="10615"></td>
        <td id="LC10615">
</td>
      </tr>
      <tr>
        <td id="L10616" data-line-number="10616"></td>
        <td id="LC10616"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10617" data-line-number="10617"></td>
        <td id="LC10617"><span><span>//</span> This is the thread's real thread proc. It simply calls to the</span></td>
      </tr>
      <tr>
        <td id="L10618" data-line-number="10618"></td>
        <td id="LC10618"><span><span>//</span> thread proc on the given object.</span></td>
      </tr>
      <tr>
        <td id="L10619" data-line-number="10619"></td>
        <td id="LC10619"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10620" data-line-number="10620"></td>
        <td id="LC10620"><span><span>/*</span>static<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L10621" data-line-number="10621"></td>
        <td id="LC10621">DWORD WINAPI <span>CordbRCEventThread::ThreadProc</span>(LPVOID parameter)</td>
      </tr>
      <tr>
        <td id="L10622" data-line-number="10622"></td>
        <td id="LC10622">{</td>
      </tr>
      <tr>
        <td id="L10623" data-line-number="10623"></td>
        <td id="LC10623">    CordbRCEventThread * pThread = (CordbRCEventThread *) parameter;</td>
      </tr>
      <tr>
        <td id="L10624" data-line-number="10624"></td>
        <td id="LC10624">
</td>
      </tr>
      <tr>
        <td id="L10625" data-line-number="10625"></td>
        <td id="LC10625">    <span>INTERNAL_THREAD_ENTRY</span>(pThread);</td>
      </tr>
      <tr>
        <td id="L10626" data-line-number="10626"></td>
        <td id="LC10626">    pThread-&gt;<span>ThreadProc</span>();</td>
      </tr>
      <tr>
        <td id="L10627" data-line-number="10627"></td>
        <td id="LC10627">    <span>return</span> <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L10628" data-line-number="10628"></td>
        <td id="LC10628">}</td>
      </tr>
      <tr>
        <td id="L10629" data-line-number="10629"></td>
        <td id="LC10629">
</td>
      </tr>
      <tr>
        <td id="L10630" data-line-number="10630"></td>
        <td id="LC10630"><span>template</span>&lt;<span>typename</span> T&gt;</td>
      </tr>
      <tr>
        <td id="L10631" data-line-number="10631"></td>
        <td id="LC10631">InterlockedStack&lt;T&gt;::InterlockedStack()</td>
      </tr>
      <tr>
        <td id="L10632" data-line-number="10632"></td>
        <td id="LC10632">{</td>
      </tr>
      <tr>
        <td id="L10633" data-line-number="10633"></td>
        <td id="LC10633">    m_pHead = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L10634" data-line-number="10634"></td>
        <td id="LC10634">}</td>
      </tr>
      <tr>
        <td id="L10635" data-line-number="10635"></td>
        <td id="LC10635">
</td>
      </tr>
      <tr>
        <td id="L10636" data-line-number="10636"></td>
        <td id="LC10636"><span>template</span>&lt;<span>typename</span> T&gt;</td>
      </tr>
      <tr>
        <td id="L10637" data-line-number="10637"></td>
        <td id="LC10637">InterlockedStack&lt;T&gt;::<span>~InterlockedStack</span>()</td>
      </tr>
      <tr>
        <td id="L10638" data-line-number="10638"></td>
        <td id="LC10638">{</td>
      </tr>
      <tr>
        <td id="L10639" data-line-number="10639"></td>
        <td id="LC10639">    <span><span>//</span> This is an arbitrary choice. We expect the stacks be drained.</span></td>
      </tr>
      <tr>
        <td id="L10640" data-line-number="10640"></td>
        <td id="LC10640">    <span>_ASSERTE</span>(m_pHead == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L10641" data-line-number="10641"></td>
        <td id="LC10641">}</td>
      </tr>
      <tr>
        <td id="L10642" data-line-number="10642"></td>
        <td id="LC10642">
</td>
      </tr>
      <tr>
        <td id="L10643" data-line-number="10643"></td>
        <td id="LC10643"><span><span>//</span> Thread safe pushes + pops.</span></td>
      </tr>
      <tr>
        <td id="L10644" data-line-number="10644"></td>
        <td id="LC10644"><span><span>//</span> Many threads can push simultaneously.</span></td>
      </tr>
      <tr>
        <td id="L10645" data-line-number="10645"></td>
        <td id="LC10645"><span><span>//</span> Only 1 thread can pop.</span></td>
      </tr>
      <tr>
        <td id="L10646" data-line-number="10646"></td>
        <td id="LC10646"><span>template</span>&lt;<span>typename</span> T&gt;</td>
      </tr>
      <tr>
        <td id="L10647" data-line-number="10647"></td>
        <td id="LC10647"><span>void</span> InterlockedStack&lt;T&gt;::Push(T * pItem)</td>
      </tr>
      <tr>
        <td id="L10648" data-line-number="10648"></td>
        <td id="LC10648">{</td>
      </tr>
      <tr>
        <td id="L10649" data-line-number="10649"></td>
        <td id="LC10649">    <span><span>//</span> InterlockedCompareExchangePointer(&amp;dest, ex, comp).</span></td>
      </tr>
      <tr>
        <td id="L10650" data-line-number="10650"></td>
        <td id="LC10650">    <span><span>//</span> Really behaves like:</span></td>
      </tr>
      <tr>
        <td id="L10651" data-line-number="10651"></td>
        <td id="LC10651">    <span><span>//</span>     val = *dest;</span></td>
      </tr>
      <tr>
        <td id="L10652" data-line-number="10652"></td>
        <td id="LC10652">    <span><span>//</span>     if (*dest == comp) { *dest = ex; }</span></td>
      </tr>
      <tr>
        <td id="L10653" data-line-number="10653"></td>
        <td id="LC10653">    <span><span>//</span>     return val;</span></td>
      </tr>
      <tr>
        <td id="L10654" data-line-number="10654"></td>
        <td id="LC10654">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10655" data-line-number="10655"></td>
        <td id="LC10655">    <span><span>//</span> We can do a thread-safe assign { comp = dest; dest = ex } via:</span></td>
      </tr>
      <tr>
        <td id="L10656" data-line-number="10656"></td>
        <td id="LC10656">    <span><span>//</span>     do { comp = dest } while (ICExPtr(&amp;dest, ex, comp) != comp));</span></td>
      </tr>
      <tr>
        <td id="L10657" data-line-number="10657"></td>
        <td id="LC10657">
</td>
      </tr>
      <tr>
        <td id="L10658" data-line-number="10658"></td>
        <td id="LC10658">
</td>
      </tr>
      <tr>
        <td id="L10659" data-line-number="10659"></td>
        <td id="LC10659">    <span>do</span></td>
      </tr>
      <tr>
        <td id="L10660" data-line-number="10660"></td>
        <td id="LC10660">    {</td>
      </tr>
      <tr>
        <td id="L10661" data-line-number="10661"></td>
        <td id="LC10661">        pItem-&gt;<span>m_next</span> = m_pHead;</td>
      </tr>
      <tr>
        <td id="L10662" data-line-number="10662"></td>
        <td id="LC10662">    }</td>
      </tr>
      <tr>
        <td id="L10663" data-line-number="10663"></td>
        <td id="LC10663">    <span>while</span>(<span>InterlockedCompareExchangeT</span>(&amp;m_pHead, pItem, pItem-&gt;<span>m_next</span>) != pItem-&gt;<span>m_next</span>);</td>
      </tr>
      <tr>
        <td id="L10664" data-line-number="10664"></td>
        <td id="LC10664">}</td>
      </tr>
      <tr>
        <td id="L10665" data-line-number="10665"></td>
        <td id="LC10665">
</td>
      </tr>
      <tr>
        <td id="L10666" data-line-number="10666"></td>
        <td id="LC10666"><span><span>//</span> Returns NULL on empty,</span></td>
      </tr>
      <tr>
        <td id="L10667" data-line-number="10667"></td>
        <td id="LC10667"><span><span>//</span> else returns the head of the list.</span></td>
      </tr>
      <tr>
        <td id="L10668" data-line-number="10668"></td>
        <td id="LC10668"><span>template</span>&lt;<span>typename</span> T&gt;</td>
      </tr>
      <tr>
        <td id="L10669" data-line-number="10669"></td>
        <td id="LC10669">T * InterlockedStack&lt;T&gt;::Pop()</td>
      </tr>
      <tr>
        <td id="L10670" data-line-number="10670"></td>
        <td id="LC10670">{</td>
      </tr>
      <tr>
        <td id="L10671" data-line-number="10671"></td>
        <td id="LC10671">    <span>if</span> (m_pHead == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10672" data-line-number="10672"></td>
        <td id="LC10672">    {</td>
      </tr>
      <tr>
        <td id="L10673" data-line-number="10673"></td>
        <td id="LC10673">        <span>return</span> <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L10674" data-line-number="10674"></td>
        <td id="LC10674">    }</td>
      </tr>
      <tr>
        <td id="L10675" data-line-number="10675"></td>
        <td id="LC10675">
</td>
      </tr>
      <tr>
        <td id="L10676" data-line-number="10676"></td>
        <td id="LC10676">    <span><span>//</span> This allows 1 thread to Pop() and race against N threads doing a Push().</span></td>
      </tr>
      <tr>
        <td id="L10677" data-line-number="10677"></td>
        <td id="LC10677">    T * pItem = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L10678" data-line-number="10678"></td>
        <td id="LC10678">    <span>do</span></td>
      </tr>
      <tr>
        <td id="L10679" data-line-number="10679"></td>
        <td id="LC10679">    {</td>
      </tr>
      <tr>
        <td id="L10680" data-line-number="10680"></td>
        <td id="LC10680">        pItem = m_pHead;</td>
      </tr>
      <tr>
        <td id="L10681" data-line-number="10681"></td>
        <td id="LC10681">    } <span>while</span>(<span>InterlockedCompareExchangeT</span>(&amp;m_pHead, pItem-&gt;<span>m_next</span>, pItem) != pItem);</td>
      </tr>
      <tr>
        <td id="L10682" data-line-number="10682"></td>
        <td id="LC10682">
</td>
      </tr>
      <tr>
        <td id="L10683" data-line-number="10683"></td>
        <td id="LC10683">    <span>return</span> pItem;</td>
      </tr>
      <tr>
        <td id="L10684" data-line-number="10684"></td>
        <td id="LC10684">}</td>
      </tr>
      <tr>
        <td id="L10685" data-line-number="10685"></td>
        <td id="LC10685">
</td>
      </tr>
      <tr>
        <td id="L10686" data-line-number="10686"></td>
        <td id="LC10686">
</td>
      </tr>
      <tr>
        <td id="L10687" data-line-number="10687"></td>
        <td id="LC10687"><span><span>//</span> RCET will take ownership of this item and delete it.</span></td>
      </tr>
      <tr>
        <td id="L10688" data-line-number="10688"></td>
        <td id="LC10688"><span><span>//</span> This can be done w/o taking any locks (thus it can be called from any lock context)</span></td>
      </tr>
      <tr>
        <td id="L10689" data-line-number="10689"></td>
        <td id="LC10689"><span><span>//</span> This may race w/ the RCET draining the queue.</span></td>
      </tr>
      <tr>
        <td id="L10690" data-line-number="10690"></td>
        <td id="LC10690"><span>void</span> <span>CordbRCEventThread::QueueAsyncWorkItem</span>(RCETWorkItem * pItem)</td>
      </tr>
      <tr>
        <td id="L10691" data-line-number="10691"></td>
        <td id="LC10691">{</td>
      </tr>
      <tr>
        <td id="L10692" data-line-number="10692"></td>
        <td id="LC10692">    <span><span>//</span> @todo -</span></td>
      </tr>
      <tr>
        <td id="L10693" data-line-number="10693"></td>
        <td id="LC10693">    <span><span>//</span> Non-blocking insert into queue.</span></td>
      </tr>
      <tr>
        <td id="L10694" data-line-number="10694"></td>
        <td id="LC10694">
</td>
      </tr>
      <tr>
        <td id="L10695" data-line-number="10695"></td>
        <td id="LC10695">    <span>_ASSERTE</span>(pItem != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L10696" data-line-number="10696"></td>
        <td id="LC10696">
</td>
      </tr>
      <tr>
        <td id="L10697" data-line-number="10697"></td>
        <td id="LC10697">    m_WorkerStack.<span>Push</span>(pItem);</td>
      </tr>
      <tr>
        <td id="L10698" data-line-number="10698"></td>
        <td id="LC10698">
</td>
      </tr>
      <tr>
        <td id="L10699" data-line-number="10699"></td>
        <td id="LC10699">    <span><span>//</span> Ping the RCET so that it drains the queue.</span></td>
      </tr>
      <tr>
        <td id="L10700" data-line-number="10700"></td>
        <td id="LC10700">    <span>SetEvent</span>(m_threadControlEvent);</td>
      </tr>
      <tr>
        <td id="L10701" data-line-number="10701"></td>
        <td id="LC10701">}</td>
      </tr>
      <tr>
        <td id="L10702" data-line-number="10702"></td>
        <td id="LC10702">
</td>
      </tr>
      <tr>
        <td id="L10703" data-line-number="10703"></td>
        <td id="LC10703"><span><span>//</span> Execute &amp; delete all workitems in the queue.</span></td>
      </tr>
      <tr>
        <td id="L10704" data-line-number="10704"></td>
        <td id="LC10704"><span><span>//</span> This can be done w/o taking any locks. (though individual items may take locks).</span></td>
      </tr>
      <tr>
        <td id="L10705" data-line-number="10705"></td>
        <td id="LC10705"><span>void</span> <span>CordbRCEventThread::DrainWorkerQueue</span>()</td>
      </tr>
      <tr>
        <td id="L10706" data-line-number="10706"></td>
        <td id="LC10706">{</td>
      </tr>
      <tr>
        <td id="L10707" data-line-number="10707"></td>
        <td id="LC10707">    <span>_ASSERTE</span>(<span>IsRCEventThread</span>());</td>
      </tr>
      <tr>
        <td id="L10708" data-line-number="10708"></td>
        <td id="LC10708">
</td>
      </tr>
      <tr>
        <td id="L10709" data-line-number="10709"></td>
        <td id="LC10709">    <span>while</span>(<span>true</span>)</td>
      </tr>
      <tr>
        <td id="L10710" data-line-number="10710"></td>
        <td id="LC10710">    {</td>
      </tr>
      <tr>
        <td id="L10711" data-line-number="10711"></td>
        <td id="LC10711">        RCETWorkItem* pCur = m_WorkerStack.<span>Pop</span>();</td>
      </tr>
      <tr>
        <td id="L10712" data-line-number="10712"></td>
        <td id="LC10712">        <span>if</span> (pCur == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10713" data-line-number="10713"></td>
        <td id="LC10713">        {</td>
      </tr>
      <tr>
        <td id="L10714" data-line-number="10714"></td>
        <td id="LC10714">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L10715" data-line-number="10715"></td>
        <td id="LC10715">        }</td>
      </tr>
      <tr>
        <td id="L10716" data-line-number="10716"></td>
        <td id="LC10716">
</td>
      </tr>
      <tr>
        <td id="L10717" data-line-number="10717"></td>
        <td id="LC10717">        pCur-&gt;<span>Do</span>();</td>
      </tr>
      <tr>
        <td id="L10718" data-line-number="10718"></td>
        <td id="LC10718">        <span>delete</span> pCur;</td>
      </tr>
      <tr>
        <td id="L10719" data-line-number="10719"></td>
        <td id="LC10719">    }</td>
      </tr>
      <tr>
        <td id="L10720" data-line-number="10720"></td>
        <td id="LC10720">}</td>
      </tr>
      <tr>
        <td id="L10721" data-line-number="10721"></td>
        <td id="LC10721">
</td>
      </tr>
      <tr>
        <td id="L10722" data-line-number="10722"></td>
        <td id="LC10722">
</td>
      </tr>
      <tr>
        <td id="L10723" data-line-number="10723"></td>
        <td id="LC10723"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L10724" data-line-number="10724"></td>
        <td id="LC10724"><span><span>//</span> Wait for an reply from the debuggee.</span></td>
      </tr>
      <tr>
        <td id="L10725" data-line-number="10725"></td>
        <td id="LC10725"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10726" data-line-number="10726"></td>
        <td id="LC10726"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L10727" data-line-number="10727"></td>
        <td id="LC10727"><span><span>//</span>    pProcess - process for debuggee.</span></td>
      </tr>
      <tr>
        <td id="L10728" data-line-number="10728"></td>
        <td id="LC10728"><span><span>//</span>    pAppDomain - not used.</span></td>
      </tr>
      <tr>
        <td id="L10729" data-line-number="10729"></td>
        <td id="LC10729"><span><span>//</span>    pEvent - caller-allocated event to be filled out.</span></td>
      </tr>
      <tr>
        <td id="L10730" data-line-number="10730"></td>
        <td id="LC10730"><span><span>//</span>             This is expected to be at least as big as CorDBIPC_BUFFER_SIZE.</span></td>
      </tr>
      <tr>
        <td id="L10731" data-line-number="10731"></td>
        <td id="LC10731"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10732" data-line-number="10732"></td>
        <td id="LC10732"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L10733" data-line-number="10733"></td>
        <td id="LC10733"><span><span>//</span>    S_OK on success. else failure.</span></td>
      </tr>
      <tr>
        <td id="L10734" data-line-number="10734"></td>
        <td id="LC10734"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10735" data-line-number="10735"></td>
        <td id="LC10735"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L10736" data-line-number="10736"></td>
        <td id="LC10736"><span><span>//</span>    Caller allocates</span></td>
      </tr>
      <tr>
        <td id="L10737" data-line-number="10737"></td>
        <td id="LC10737"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10738" data-line-number="10738"></td>
        <td id="LC10738"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L10739" data-line-number="10739"></td>
        <td id="LC10739"><span><span>//</span>   WaitForIPCEventFromProcess waits for an event from just the specified</span></td>
      </tr>
      <tr>
        <td id="L10740" data-line-number="10740"></td>
        <td id="LC10740"><span><span>//</span>   process. This should only be called when the process is in a synchronized</span></td>
      </tr>
      <tr>
        <td id="L10741" data-line-number="10741"></td>
        <td id="LC10741"><span><span>//</span>   state, which ensures that the RCEventThread isn't listening to the</span></td>
      </tr>
      <tr>
        <td id="L10742" data-line-number="10742"></td>
        <td id="LC10742"><span><span>//</span>   process's event, too, which would get confusing.</span></td>
      </tr>
      <tr>
        <td id="L10743" data-line-number="10743"></td>
        <td id="LC10743"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10744" data-line-number="10744"></td>
        <td id="LC10744"><span><span>//</span>   @dbgtodo - this function should eventually be obsolete once everything</span></td>
      </tr>
      <tr>
        <td id="L10745" data-line-number="10745"></td>
        <td id="LC10745"><span><span>//</span>   is using DAC calls instead of helper-thread.</span></td>
      </tr>
      <tr>
        <td id="L10746" data-line-number="10746"></td>
        <td id="LC10746"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10747" data-line-number="10747"></td>
        <td id="LC10747"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L10748" data-line-number="10748"></td>
        <td id="LC10748">HRESULT <span>CordbRCEventThread::WaitForIPCEventFromProcess</span>(CordbProcess * pProcess,</td>
      </tr>
      <tr>
        <td id="L10749" data-line-number="10749"></td>
        <td id="LC10749">                                                       CordbAppDomain * pAppDomain,</td>
      </tr>
      <tr>
        <td id="L10750" data-line-number="10750"></td>
        <td id="LC10750">                                                       DebuggerIPCEvent * pEvent)</td>
      </tr>
      <tr>
        <td id="L10751" data-line-number="10751"></td>
        <td id="LC10751">{</td>
      </tr>
      <tr>
        <td id="L10752" data-line-number="10752"></td>
        <td id="LC10752">    <span>CORDBRequireProcessStateOKAndSync</span>(pProcess, pAppDomain);</td>
      </tr>
      <tr>
        <td id="L10753" data-line-number="10753"></td>
        <td id="LC10753">
</td>
      </tr>
      <tr>
        <td id="L10754" data-line-number="10754"></td>
        <td id="LC10754">    DWORD dwStatus;</td>
      </tr>
      <tr>
        <td id="L10755" data-line-number="10755"></td>
        <td id="LC10755">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L10756" data-line-number="10756"></td>
        <td id="LC10756">
</td>
      </tr>
      <tr>
        <td id="L10757" data-line-number="10757"></td>
        <td id="LC10757">    <span>do</span></td>
      </tr>
      <tr>
        <td id="L10758" data-line-number="10758"></td>
        <td id="LC10758">    {</td>
      </tr>
      <tr>
        <td id="L10759" data-line-number="10759"></td>
        <td id="LC10759">        dwStatus = <span>SafeWaitForSingleObject</span>(pProcess,</td>
      </tr>
      <tr>
        <td id="L10760" data-line-number="10760"></td>
        <td id="LC10760">                                           pProcess-&gt;<span>m_leftSideEventAvailable</span>,</td>
      </tr>
      <tr>
        <td id="L10761" data-line-number="10761"></td>
        <td id="LC10761">                                           <span>CordbGetWaitTimeout</span>());</td>
      </tr>
      <tr>
        <td id="L10762" data-line-number="10762"></td>
        <td id="LC10762">
</td>
      </tr>
      <tr>
        <td id="L10763" data-line-number="10763"></td>
        <td id="LC10763">        <span>if</span> (pProcess-&gt;<span>m_terminated</span>)</td>
      </tr>
      <tr>
        <td id="L10764" data-line-number="10764"></td>
        <td id="LC10764">        {</td>
      </tr>
      <tr>
        <td id="L10765" data-line-number="10765"></td>
        <td id="LC10765">            <span>return</span> CORDBG_E_PROCESS_TERMINATED;</td>
      </tr>
      <tr>
        <td id="L10766" data-line-number="10766"></td>
        <td id="LC10766">        }</td>
      </tr>
      <tr>
        <td id="L10767" data-line-number="10767"></td>
        <td id="LC10767">        <span><span>//</span> If we timeout because we're waiting for an uncontinued OOB event, we need to just keep waiting.</span></td>
      </tr>
      <tr>
        <td id="L10768" data-line-number="10768"></td>
        <td id="LC10768">    } <span>while</span> ((dwStatus == WAIT_TIMEOUT) &amp;&amp; pProcess-&gt;<span>IsWaitingForOOBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L10769" data-line-number="10769"></td>
        <td id="LC10769">
</td>
      </tr>
      <tr>
        <td id="L10770" data-line-number="10770"></td>
        <td id="LC10770">
</td>
      </tr>
      <tr>
        <td id="L10771" data-line-number="10771"></td>
        <td id="LC10771">
</td>
      </tr>
      <tr>
        <td id="L10772" data-line-number="10772"></td>
        <td id="LC10772">
</td>
      </tr>
      <tr>
        <td id="L10773" data-line-number="10773"></td>
        <td id="LC10773">    <span>if</span> (dwStatus == WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L10774" data-line-number="10774"></td>
        <td id="LC10774">    {</td>
      </tr>
      <tr>
        <td id="L10775" data-line-number="10775"></td>
        <td id="LC10775">        pProcess-&gt;<span>CopyRCEventFromIPCBlock</span>(pEvent);</td>
      </tr>
      <tr>
        <td id="L10776" data-line-number="10776"></td>
        <td id="LC10776">
</td>
      </tr>
      <tr>
        <td id="L10777" data-line-number="10777"></td>
        <td id="LC10777">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L10778" data-line-number="10778"></td>
        <td id="LC10778">        {</td>
      </tr>
      <tr>
        <td id="L10779" data-line-number="10779"></td>
        <td id="LC10779">            pProcess-&gt;<span>MarshalManagedEvent</span>(pEvent);</td>
      </tr>
      <tr>
        <td id="L10780" data-line-number="10780"></td>
        <td id="LC10780">
</td>
      </tr>
      <tr>
        <td id="L10781" data-line-number="10781"></td>
        <td id="LC10781">            <span>STRESS_LOG4</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CRCET::SIPCE: Got %s for AD 0x%x, proc 0x%x(%d)<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L10782" data-line-number="10782"></td>
        <td id="LC10782">                        <span>IPCENames::GetName</span>(pEvent-&gt;<span>type</span>),</td>
      </tr>
      <tr>
        <td id="L10783" data-line-number="10783"></td>
        <td id="LC10783">                        <span>VmPtrToCookie</span>(pEvent-&gt;<span>vmAppDomain</span>),</td>
      </tr>
      <tr>
        <td id="L10784" data-line-number="10784"></td>
        <td id="LC10784">                        pProcess-&gt;<span>m_id</span>,</td>
      </tr>
      <tr>
        <td id="L10785" data-line-number="10785"></td>
        <td id="LC10785">                        pProcess-&gt;<span>m_id</span>);</td>
      </tr>
      <tr>
        <td id="L10786" data-line-number="10786"></td>
        <td id="LC10786">
</td>
      </tr>
      <tr>
        <td id="L10787" data-line-number="10787"></td>
        <td id="LC10787">        }</td>
      </tr>
      <tr>
        <td id="L10788" data-line-number="10788"></td>
        <td id="LC10788">        <span>EX_CATCH_HRESULT</span>(hr)</td>
      </tr>
      <tr>
        <td id="L10789" data-line-number="10789"></td>
        <td id="LC10789">
</td>
      </tr>
      <tr>
        <td id="L10790" data-line-number="10790"></td>
        <td id="LC10790">        <span>SetEvent</span>(pProcess-&gt;<span>m_leftSideEventRead</span>);</td>
      </tr>
      <tr>
        <td id="L10791" data-line-number="10791"></td>
        <td id="LC10791">
</td>
      </tr>
      <tr>
        <td id="L10792" data-line-number="10792"></td>
        <td id="LC10792">        <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L10793" data-line-number="10793"></td>
        <td id="LC10793">    }</td>
      </tr>
      <tr>
        <td id="L10794" data-line-number="10794"></td>
        <td id="LC10794">    <span>else</span> <span>if</span> (dwStatus == WAIT_TIMEOUT)</td>
      </tr>
      <tr>
        <td id="L10795" data-line-number="10795"></td>
        <td id="LC10795">    {</td>
      </tr>
      <tr>
        <td id="L10796" data-line-number="10796"></td>
        <td id="LC10796">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10797" data-line-number="10797"></td>
        <td id="LC10797">        <span><span>//</span> If we timed out, check the left side to see if it is in the</span></td>
      </tr>
      <tr>
        <td id="L10798" data-line-number="10798"></td>
        <td id="LC10798">        <span><span>//</span> unrecoverable error mode. If it is, return the HR from the</span></td>
      </tr>
      <tr>
        <td id="L10799" data-line-number="10799"></td>
        <td id="LC10799">        <span><span>//</span> left side that caused the error. Otherwise, return that we timed</span></td>
      </tr>
      <tr>
        <td id="L10800" data-line-number="10800"></td>
        <td id="LC10800">        <span><span>//</span> out and that we don't really know why.</span></td>
      </tr>
      <tr>
        <td id="L10801" data-line-number="10801"></td>
        <td id="LC10801">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10802" data-line-number="10802"></td>
        <td id="LC10802">        HRESULT realHR = <span>ErrWrapper</span>(CORDBG_E_TIMEOUT);</td>
      </tr>
      <tr>
        <td id="L10803" data-line-number="10803"></td>
        <td id="LC10803">
</td>
      </tr>
      <tr>
        <td id="L10804" data-line-number="10804"></td>
        <td id="LC10804">        hr = pProcess-&gt;<span>CheckForUnrecoverableError</span>();</td>
      </tr>
      <tr>
        <td id="L10805" data-line-number="10805"></td>
        <td id="LC10805">
</td>
      </tr>
      <tr>
        <td id="L10806" data-line-number="10806"></td>
        <td id="LC10806">        <span>if</span> (hr == S_OK)</td>
      </tr>
      <tr>
        <td id="L10807" data-line-number="10807"></td>
        <td id="LC10807">        {</td>
      </tr>
      <tr>
        <td id="L10808" data-line-number="10808"></td>
        <td id="LC10808">            <span>CORDBSetUnrecoverableError</span>(pProcess, realHR, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L10809" data-line-number="10809"></td>
        <td id="LC10809">            <span>return</span> realHR;</td>
      </tr>
      <tr>
        <td id="L10810" data-line-number="10810"></td>
        <td id="LC10810">        }</td>
      </tr>
      <tr>
        <td id="L10811" data-line-number="10811"></td>
        <td id="LC10811">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L10812" data-line-number="10812"></td>
        <td id="LC10812">            <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L10813" data-line-number="10813"></td>
        <td id="LC10813">    }</td>
      </tr>
      <tr>
        <td id="L10814" data-line-number="10814"></td>
        <td id="LC10814">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L10815" data-line-number="10815"></td>
        <td id="LC10815">    {</td>
      </tr>
      <tr>
        <td id="L10816" data-line-number="10816"></td>
        <td id="LC10816">        <span>_ASSERTE</span>(dwStatus == WAIT_FAILED);</td>
      </tr>
      <tr>
        <td id="L10817" data-line-number="10817"></td>
        <td id="LC10817">
</td>
      </tr>
      <tr>
        <td id="L10818" data-line-number="10818"></td>
        <td id="LC10818">        hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L10819" data-line-number="10819"></td>
        <td id="LC10819">
</td>
      </tr>
      <tr>
        <td id="L10820" data-line-number="10820"></td>
        <td id="LC10820">        <span>CORDBSetUnrecoverableError</span>(pProcess, hr, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L10821" data-line-number="10821"></td>
        <td id="LC10821">
</td>
      </tr>
      <tr>
        <td id="L10822" data-line-number="10822"></td>
        <td id="LC10822">        <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L10823" data-line-number="10823"></td>
        <td id="LC10823">    }</td>
      </tr>
      <tr>
        <td id="L10824" data-line-number="10824"></td>
        <td id="LC10824">}</td>
      </tr>
      <tr>
        <td id="L10825" data-line-number="10825"></td>
        <td id="LC10825">
</td>
      </tr>
      <tr>
        <td id="L10826" data-line-number="10826"></td>
        <td id="LC10826">
</td>
      </tr>
      <tr>
        <td id="L10827" data-line-number="10827"></td>
        <td id="LC10827"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10828" data-line-number="10828"></td>
        <td id="LC10828"><span><span>//</span> Start actually creates and starts the thread.</span></td>
      </tr>
      <tr>
        <td id="L10829" data-line-number="10829"></td>
        <td id="LC10829"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10830" data-line-number="10830"></td>
        <td id="LC10830">HRESULT <span>CordbRCEventThread::Start</span>()</td>
      </tr>
      <tr>
        <td id="L10831" data-line-number="10831"></td>
        <td id="LC10831">{</td>
      </tr>
      <tr>
        <td id="L10832" data-line-number="10832"></td>
        <td id="LC10832">    <span>if</span> (m_threadControlEvent == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10833" data-line-number="10833"></td>
        <td id="LC10833">    {</td>
      </tr>
      <tr>
        <td id="L10834" data-line-number="10834"></td>
        <td id="LC10834">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L10835" data-line-number="10835"></td>
        <td id="LC10835">    }</td>
      </tr>
      <tr>
        <td id="L10836" data-line-number="10836"></td>
        <td id="LC10836">
</td>
      </tr>
      <tr>
        <td id="L10837" data-line-number="10837"></td>
        <td id="LC10837">    m_thread = <span>CreateThread</span>(<span>NULL</span>,</td>
      </tr>
      <tr>
        <td id="L10838" data-line-number="10838"></td>
        <td id="LC10838">                            <span>0</span>,</td>
      </tr>
      <tr>
        <td id="L10839" data-line-number="10839"></td>
        <td id="LC10839">                            &amp;CordbRCEventThread::ThreadProc,</td>
      </tr>
      <tr>
        <td id="L10840" data-line-number="10840"></td>
        <td id="LC10840">                            (LPVOID) <span>this</span>,</td>
      </tr>
      <tr>
        <td id="L10841" data-line-number="10841"></td>
        <td id="LC10841">                            <span>0</span>,</td>
      </tr>
      <tr>
        <td id="L10842" data-line-number="10842"></td>
        <td id="LC10842">                            &amp;m_threadId);</td>
      </tr>
      <tr>
        <td id="L10843" data-line-number="10843"></td>
        <td id="LC10843">
</td>
      </tr>
      <tr>
        <td id="L10844" data-line-number="10844"></td>
        <td id="LC10844">    <span>if</span> (m_thread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10845" data-line-number="10845"></td>
        <td id="LC10845">    {</td>
      </tr>
      <tr>
        <td id="L10846" data-line-number="10846"></td>
        <td id="LC10846">        <span>return</span> <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L10847" data-line-number="10847"></td>
        <td id="LC10847">    }</td>
      </tr>
      <tr>
        <td id="L10848" data-line-number="10848"></td>
        <td id="LC10848">
</td>
      </tr>
      <tr>
        <td id="L10849" data-line-number="10849"></td>
        <td id="LC10849">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L10850" data-line-number="10850"></td>
        <td id="LC10850">}</td>
      </tr>
      <tr>
        <td id="L10851" data-line-number="10851"></td>
        <td id="LC10851">
</td>
      </tr>
      <tr>
        <td id="L10852" data-line-number="10852"></td>
        <td id="LC10852">
</td>
      </tr>
      <tr>
        <td id="L10853" data-line-number="10853"></td>
        <td id="LC10853"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10854" data-line-number="10854"></td>
        <td id="LC10854"><span><span>//</span> Stop causes the thread to stop receiving events and exit. It</span></td>
      </tr>
      <tr>
        <td id="L10855" data-line-number="10855"></td>
        <td id="LC10855"><span><span>//</span> waits for it to exit before returning.</span></td>
      </tr>
      <tr>
        <td id="L10856" data-line-number="10856"></td>
        <td id="LC10856"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10857" data-line-number="10857"></td>
        <td id="LC10857">HRESULT <span>CordbRCEventThread::Stop</span>()</td>
      </tr>
      <tr>
        <td id="L10858" data-line-number="10858"></td>
        <td id="LC10858">{</td>
      </tr>
      <tr>
        <td id="L10859" data-line-number="10859"></td>
        <td id="LC10859">    <span>if</span> (m_thread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10860" data-line-number="10860"></td>
        <td id="LC10860">    {</td>
      </tr>
      <tr>
        <td id="L10861" data-line-number="10861"></td>
        <td id="LC10861">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>CRCET::Stop<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L10862" data-line-number="10862"></td>
        <td id="LC10862">
</td>
      </tr>
      <tr>
        <td id="L10863" data-line-number="10863"></td>
        <td id="LC10863">        m_run = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L10864" data-line-number="10864"></td>
        <td id="LC10864">
</td>
      </tr>
      <tr>
        <td id="L10865" data-line-number="10865"></td>
        <td id="LC10865">        <span>SetEvent</span>(m_threadControlEvent);</td>
      </tr>
      <tr>
        <td id="L10866" data-line-number="10866"></td>
        <td id="LC10866">
</td>
      </tr>
      <tr>
        <td id="L10867" data-line-number="10867"></td>
        <td id="LC10867">        DWORD ret = <span>WaitForSingleObject</span>(m_thread, INFINITE);</td>
      </tr>
      <tr>
        <td id="L10868" data-line-number="10868"></td>
        <td id="LC10868">
</td>
      </tr>
      <tr>
        <td id="L10869" data-line-number="10869"></td>
        <td id="LC10869">        <span>if</span> (ret != WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L10870" data-line-number="10870"></td>
        <td id="LC10870">        {</td>
      </tr>
      <tr>
        <td id="L10871" data-line-number="10871"></td>
        <td id="LC10871">            <span>return</span> <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L10872" data-line-number="10872"></td>
        <td id="LC10872">        }</td>
      </tr>
      <tr>
        <td id="L10873" data-line-number="10873"></td>
        <td id="LC10873">    }</td>
      </tr>
      <tr>
        <td id="L10874" data-line-number="10874"></td>
        <td id="LC10874">
</td>
      </tr>
      <tr>
        <td id="L10875" data-line-number="10875"></td>
        <td id="LC10875">    m_cordb.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L10876" data-line-number="10876"></td>
        <td id="LC10876">
</td>
      </tr>
      <tr>
        <td id="L10877" data-line-number="10877"></td>
        <td id="LC10877">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L10878" data-line-number="10878"></td>
        <td id="LC10878">}</td>
      </tr>
      <tr>
        <td id="L10879" data-line-number="10879"></td>
        <td id="LC10879">
</td>
      </tr>
      <tr>
        <td id="L10880" data-line-number="10880"></td>
        <td id="LC10880">
</td>
      </tr>
      <tr>
        <td id="L10881" data-line-number="10881"></td>
        <td id="LC10881"><span><span>/*</span> ------------------------------------------------------------------------- *</span></td>
      </tr>
      <tr>
        <td id="L10882" data-line-number="10882"></td>
        <td id="LC10882"><span> * Win32 Event Thread class</span></td>
      </tr>
      <tr>
        <td id="L10883" data-line-number="10883"></td>
        <td id="LC10883"><span> * ------------------------------------------------------------------------- <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L10884" data-line-number="10884"></td>
        <td id="LC10884">
</td>
      </tr>
      <tr>
        <td id="L10885" data-line-number="10885"></td>
        <td id="LC10885"><span>enum</span></td>
      </tr>
      <tr>
        <td id="L10886" data-line-number="10886"></td>
        <td id="LC10886">{</td>
      </tr>
      <tr>
        <td id="L10887" data-line-number="10887"></td>
        <td id="LC10887">    W32ETA_NONE              = <span>0</span>,</td>
      </tr>
      <tr>
        <td id="L10888" data-line-number="10888"></td>
        <td id="LC10888">    W32ETA_CREATE_PROCESS    = <span>1</span>,</td>
      </tr>
      <tr>
        <td id="L10889" data-line-number="10889"></td>
        <td id="LC10889">    W32ETA_ATTACH_PROCESS    = <span>2</span>,</td>
      </tr>
      <tr>
        <td id="L10890" data-line-number="10890"></td>
        <td id="LC10890">    W32ETA_CONTINUE          = <span>3</span>,</td>
      </tr>
      <tr>
        <td id="L10891" data-line-number="10891"></td>
        <td id="LC10891">    W32ETA_DETACH            = <span>4</span></td>
      </tr>
      <tr>
        <td id="L10892" data-line-number="10892"></td>
        <td id="LC10892">};</td>
      </tr>
      <tr>
        <td id="L10893" data-line-number="10893"></td>
        <td id="LC10893">
</td>
      </tr>
      <tr>
        <td id="L10894" data-line-number="10894"></td>
        <td id="LC10894">
</td>
      </tr>
      <tr>
        <td id="L10895" data-line-number="10895"></td>
        <td id="LC10895">
</td>
      </tr>
      <tr>
        <td id="L10896" data-line-number="10896"></td>
        <td id="LC10896"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L10897" data-line-number="10897"></td>
        <td id="LC10897"><span><span>//</span> Constructor</span></td>
      </tr>
      <tr>
        <td id="L10898" data-line-number="10898"></td>
        <td id="LC10898"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10899" data-line-number="10899"></td>
        <td id="LC10899"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L10900" data-line-number="10900"></td>
        <td id="LC10900"><span><span>//</span>    pCordb - Pointer to the owning cordb object for this event thread.</span></td>
      </tr>
      <tr>
        <td id="L10901" data-line-number="10901"></td>
        <td id="LC10901"><span><span>//</span>    pShim - Pointer to the shim for supporting V2 debuggers on V3 architecture.</span></td>
      </tr>
      <tr>
        <td id="L10902" data-line-number="10902"></td>
        <td id="LC10902"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10903" data-line-number="10903"></td>
        <td id="LC10903"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L10904" data-line-number="10904"></td>
        <td id="LC10904"><span>CordbWin32EventThread::CordbWin32EventThread</span>(</td>
      </tr>
      <tr>
        <td id="L10905" data-line-number="10905"></td>
        <td id="LC10905">    Cordb * pCordb,</td>
      </tr>
      <tr>
        <td id="L10906" data-line-number="10906"></td>
        <td id="LC10906">    ShimProcess * pShim</td>
      </tr>
      <tr>
        <td id="L10907" data-line-number="10907"></td>
        <td id="LC10907">    ) :</td>
      </tr>
      <tr>
        <td id="L10908" data-line-number="10908"></td>
        <td id="LC10908">    m_thread(<span>NULL</span>), m_threadControlEvent(<span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L10909" data-line-number="10909"></td>
        <td id="LC10909">    m_actionTakenEvent(<span>NULL</span>), m_run(<span>TRUE</span>),</td>
      </tr>
      <tr>
        <td id="L10910" data-line-number="10910"></td>
        <td id="LC10910">    m_action(W32ETA_NONE)</td>
      </tr>
      <tr>
        <td id="L10911" data-line-number="10911"></td>
        <td id="LC10911">{</td>
      </tr>
      <tr>
        <td id="L10912" data-line-number="10912"></td>
        <td id="LC10912">    m_cordb.<span>Assign</span>(pCordb);</td>
      </tr>
      <tr>
        <td id="L10913" data-line-number="10913"></td>
        <td id="LC10913">    <span>_ASSERTE</span>(pCordb != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L10914" data-line-number="10914"></td>
        <td id="LC10914">
</td>
      </tr>
      <tr>
        <td id="L10915" data-line-number="10915"></td>
        <td id="LC10915">    m_pShim = pShim;</td>
      </tr>
      <tr>
        <td id="L10916" data-line-number="10916"></td>
        <td id="LC10916">
</td>
      </tr>
      <tr>
        <td id="L10917" data-line-number="10917"></td>
        <td id="LC10917">    m_pNativePipeline = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L10918" data-line-number="10918"></td>
        <td id="LC10918">}</td>
      </tr>
      <tr>
        <td id="L10919" data-line-number="10919"></td>
        <td id="LC10919">
</td>
      </tr>
      <tr>
        <td id="L10920" data-line-number="10920"></td>
        <td id="LC10920">
</td>
      </tr>
      <tr>
        <td id="L10921" data-line-number="10921"></td>
        <td id="LC10921"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10922" data-line-number="10922"></td>
        <td id="LC10922"><span><span>//</span> Destructor. Cleans up all of the open handles and such.</span></td>
      </tr>
      <tr>
        <td id="L10923" data-line-number="10923"></td>
        <td id="LC10923"><span><span>//</span> This expects that the thread has been stopped and has terminated</span></td>
      </tr>
      <tr>
        <td id="L10924" data-line-number="10924"></td>
        <td id="LC10924"><span><span>//</span> before being called.</span></td>
      </tr>
      <tr>
        <td id="L10925" data-line-number="10925"></td>
        <td id="LC10925"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10926" data-line-number="10926"></td>
        <td id="LC10926"><span>CordbWin32EventThread::~CordbWin32EventThread</span>()</td>
      </tr>
      <tr>
        <td id="L10927" data-line-number="10927"></td>
        <td id="LC10927">{</td>
      </tr>
      <tr>
        <td id="L10928" data-line-number="10928"></td>
        <td id="LC10928">    <span>if</span> (m_thread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10929" data-line-number="10929"></td>
        <td id="LC10929">        <span>CloseHandle</span>(m_thread);</td>
      </tr>
      <tr>
        <td id="L10930" data-line-number="10930"></td>
        <td id="LC10930">
</td>
      </tr>
      <tr>
        <td id="L10931" data-line-number="10931"></td>
        <td id="LC10931">    <span>if</span> (m_threadControlEvent != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10932" data-line-number="10932"></td>
        <td id="LC10932">        <span>CloseHandle</span>(m_threadControlEvent);</td>
      </tr>
      <tr>
        <td id="L10933" data-line-number="10933"></td>
        <td id="LC10933">
</td>
      </tr>
      <tr>
        <td id="L10934" data-line-number="10934"></td>
        <td id="LC10934">    <span>if</span> (m_actionTakenEvent != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10935" data-line-number="10935"></td>
        <td id="LC10935">        <span>CloseHandle</span>(m_actionTakenEvent);</td>
      </tr>
      <tr>
        <td id="L10936" data-line-number="10936"></td>
        <td id="LC10936">
</td>
      </tr>
      <tr>
        <td id="L10937" data-line-number="10937"></td>
        <td id="LC10937">    <span>if</span> (m_pNativePipeline != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10938" data-line-number="10938"></td>
        <td id="LC10938">    {</td>
      </tr>
      <tr>
        <td id="L10939" data-line-number="10939"></td>
        <td id="LC10939">        m_pNativePipeline-&gt;<span>Delete</span>();</td>
      </tr>
      <tr>
        <td id="L10940" data-line-number="10940"></td>
        <td id="LC10940">        m_pNativePipeline = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L10941" data-line-number="10941"></td>
        <td id="LC10941">    }</td>
      </tr>
      <tr>
        <td id="L10942" data-line-number="10942"></td>
        <td id="LC10942">
</td>
      </tr>
      <tr>
        <td id="L10943" data-line-number="10943"></td>
        <td id="LC10943">    m_sendToWin32EventThreadMutex.<span>Destroy</span>();</td>
      </tr>
      <tr>
        <td id="L10944" data-line-number="10944"></td>
        <td id="LC10944">}</td>
      </tr>
      <tr>
        <td id="L10945" data-line-number="10945"></td>
        <td id="LC10945">
</td>
      </tr>
      <tr>
        <td id="L10946" data-line-number="10946"></td>
        <td id="LC10946">
</td>
      </tr>
      <tr>
        <td id="L10947" data-line-number="10947"></td>
        <td id="LC10947"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10948" data-line-number="10948"></td>
        <td id="LC10948"><span><span>//</span> Init sets up all the objects that the thread will need to run.</span></td>
      </tr>
      <tr>
        <td id="L10949" data-line-number="10949"></td>
        <td id="LC10949"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10950" data-line-number="10950"></td>
        <td id="LC10950">HRESULT <span>CordbWin32EventThread::Init</span>()</td>
      </tr>
      <tr>
        <td id="L10951" data-line-number="10951"></td>
        <td id="LC10951">{</td>
      </tr>
      <tr>
        <td id="L10952" data-line-number="10952"></td>
        <td id="LC10952">    <span>if</span> (m_cordb == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10953" data-line-number="10953"></td>
        <td id="LC10953">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L10954" data-line-number="10954"></td>
        <td id="LC10954">
</td>
      </tr>
      <tr>
        <td id="L10955" data-line-number="10955"></td>
        <td id="LC10955">    m_sendToWin32EventThreadMutex.<span>Init</span>(<span><span>"</span>Win32-Send lock<span>"</span></span>, RSLock::cLockFlat, RSLock::LL_WIN32_SEND_LOCK);</td>
      </tr>
      <tr>
        <td id="L10956" data-line-number="10956"></td>
        <td id="LC10956">
</td>
      </tr>
      <tr>
        <td id="L10957" data-line-number="10957"></td>
        <td id="LC10957">    m_threadControlEvent = <span>WszCreateEvent</span>(<span>NULL</span>, <span>FALSE</span>, <span>FALSE</span>, <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L10958" data-line-number="10958"></td>
        <td id="LC10958">    <span>if</span> (m_threadControlEvent == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10959" data-line-number="10959"></td>
        <td id="LC10959">        <span>return</span> <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L10960" data-line-number="10960"></td>
        <td id="LC10960">
</td>
      </tr>
      <tr>
        <td id="L10961" data-line-number="10961"></td>
        <td id="LC10961">    m_actionTakenEvent = <span>WszCreateEvent</span>(<span>NULL</span>, <span>FALSE</span>, <span>FALSE</span>, <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L10962" data-line-number="10962"></td>
        <td id="LC10962">    <span>if</span> (m_actionTakenEvent == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10963" data-line-number="10963"></td>
        <td id="LC10963">        <span>return</span> <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L10964" data-line-number="10964"></td>
        <td id="LC10964">
</td>
      </tr>
      <tr>
        <td id="L10965" data-line-number="10965"></td>
        <td id="LC10965">    m_pNativePipeline = <span>NewPipelineWithDebugChecks</span>();</td>
      </tr>
      <tr>
        <td id="L10966" data-line-number="10966"></td>
        <td id="LC10966">    <span>if</span> (m_pNativePipeline == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L10967" data-line-number="10967"></td>
        <td id="LC10967">    {</td>
      </tr>
      <tr>
        <td id="L10968" data-line-number="10968"></td>
        <td id="LC10968">        <span>return</span> E_OUTOFMEMORY;</td>
      </tr>
      <tr>
        <td id="L10969" data-line-number="10969"></td>
        <td id="LC10969">    }</td>
      </tr>
      <tr>
        <td id="L10970" data-line-number="10970"></td>
        <td id="LC10970">
</td>
      </tr>
      <tr>
        <td id="L10971" data-line-number="10971"></td>
        <td id="LC10971">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L10972" data-line-number="10972"></td>
        <td id="LC10972">}</td>
      </tr>
      <tr>
        <td id="L10973" data-line-number="10973"></td>
        <td id="LC10973">
</td>
      </tr>
      <tr>
        <td id="L10974" data-line-number="10974"></td>
        <td id="LC10974"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10975" data-line-number="10975"></td>
        <td id="LC10975"><span><span>//</span> Main function of the Win32 Event Thread</span></td>
      </tr>
      <tr>
        <td id="L10976" data-line-number="10976"></td>
        <td id="LC10976"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L10977" data-line-number="10977"></td>
        <td id="LC10977"><span>void</span> <span>CordbWin32EventThread::ThreadProc</span>()</td>
      </tr>
      <tr>
        <td id="L10978" data-line-number="10978"></td>
        <td id="LC10978">{</td>
      </tr>
      <tr>
        <td id="L10979" data-line-number="10979"></td>
        <td id="LC10979">#<span>if</span> defined(RSCONTRACTS)</td>
      </tr>
      <tr>
        <td id="L10980" data-line-number="10980"></td>
        <td id="LC10980">    <span>DbgRSThread::GetThread</span>()-&gt;<span>SetThreadType</span>(DbgRSThread::cW32ET);</td>
      </tr>
      <tr>
        <td id="L10981" data-line-number="10981"></td>
        <td id="LC10981">
</td>
      </tr>
      <tr>
        <td id="L10982" data-line-number="10982"></td>
        <td id="LC10982">    <span><span>//</span> The win32 ET conceptually holds a lock (all threads do).</span></td>
      </tr>
      <tr>
        <td id="L10983" data-line-number="10983"></td>
        <td id="LC10983">    <span>DbgRSThread::GetThread</span>()-&gt;<span>TakeVirtualLock</span>(RSLock::LL_WIN32_EVENT_THREAD);</td>
      </tr>
      <tr>
        <td id="L10984" data-line-number="10984"></td>
        <td id="LC10984">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L10985" data-line-number="10985"></td>
        <td id="LC10985">
</td>
      </tr>
      <tr>
        <td id="L10986" data-line-number="10986"></td>
        <td id="LC10986">    <span><span>//</span> In V2, the debuggee decides what to do if the debugger rudely exits / detaches. (This is</span></td>
      </tr>
      <tr>
        <td id="L10987" data-line-number="10987"></td>
        <td id="LC10987">    <span><span>//</span> handled by host policy). With the OS native-debuggging pipeline, the debugger by default</span></td>
      </tr>
      <tr>
        <td id="L10988" data-line-number="10988"></td>
        <td id="LC10988">    <span><span>//</span> kills the debuggee if it exits. To emulate V2 behavior, we need to override that default.</span></td>
      </tr>
      <tr>
        <td id="L10989" data-line-number="10989"></td>
        <td id="LC10989">    BOOL <span>fOk</span> = m_pNativePipeline-&gt;<span>DebugSetProcessKillOnExit</span>(<span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L10990" data-line-number="10990"></td>
        <td id="LC10990">    (<span>void</span>)<span>fOk</span>; <span><span>//</span>prevent "unused variable" error from GCC</span></td>
      </tr>
      <tr>
        <td id="L10991" data-line-number="10991"></td>
        <td id="LC10991">    <span>_ASSERTE</span>(<span>fOk</span>);</td>
      </tr>
      <tr>
        <td id="L10992" data-line-number="10992"></td>
        <td id="LC10992">
</td>
      </tr>
      <tr>
        <td id="L10993" data-line-number="10993"></td>
        <td id="LC10993">
</td>
      </tr>
      <tr>
        <td id="L10994" data-line-number="10994"></td>
        <td id="LC10994">    <span><span>//</span> Run the top-level event loop.</span></td>
      </tr>
      <tr>
        <td id="L10995" data-line-number="10995"></td>
        <td id="LC10995">    <span>Win32EventLoop</span>();</td>
      </tr>
      <tr>
        <td id="L10996" data-line-number="10996"></td>
        <td id="LC10996">
</td>
      </tr>
      <tr>
        <td id="L10997" data-line-number="10997"></td>
        <td id="LC10997">#<span>if</span> defined(RSCONTRACTS)</td>
      </tr>
      <tr>
        <td id="L10998" data-line-number="10998"></td>
        <td id="LC10998">    <span><span>//</span> The win32 ET conceptually holds a lock (all threads do).</span></td>
      </tr>
      <tr>
        <td id="L10999" data-line-number="10999"></td>
        <td id="LC10999">    <span>DbgRSThread::GetThread</span>()-&gt;<span>ReleaseVirtualLock</span>(RSLock::LL_WIN32_EVENT_THREAD);</td>
      </tr>
      <tr>
        <td id="L11000" data-line-number="11000"></td>
        <td id="LC11000">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L11001" data-line-number="11001"></td>
        <td id="LC11001">}</td>
      </tr>
      <tr>
        <td id="L11002" data-line-number="11002"></td>
        <td id="LC11002">
</td>
      </tr>
      <tr>
        <td id="L11003" data-line-number="11003"></td>
        <td id="LC11003"><span><span>//</span> Define a holder that calls code:DeleteIPCEventHelper</span></td>
      </tr>
      <tr>
        <td id="L11004" data-line-number="11004"></td>
        <td id="LC11004"><span>NEW_WRAPPER_TEMPLATE1</span>(DeleteIPCEventHolderHelper, DeleteIPCEventHelper);</td>
      </tr>
      <tr>
        <td id="L11005" data-line-number="11005"></td>
        <td id="LC11005"><span>typedef</span> DeleteIPCEventHolderHelper&lt;DebuggerIPCEvent&gt;  DeleteIPCEventHolder;</td>
      </tr>
      <tr>
        <td id="L11006" data-line-number="11006"></td>
        <td id="LC11006">
</td>
      </tr>
      <tr>
        <td id="L11007" data-line-number="11007"></td>
        <td id="LC11007"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11008" data-line-number="11008"></td>
        <td id="LC11008"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11009" data-line-number="11009"></td>
        <td id="LC11009"><span><span>//</span> Helper to clean up IPCEvent before deleting it.</span></td>
      </tr>
      <tr>
        <td id="L11010" data-line-number="11010"></td>
        <td id="LC11010"><span><span>//</span> This must be called after an event is marshalled via code:CordbProcess::MarshalManagedEvent</span></td>
      </tr>
      <tr>
        <td id="L11011" data-line-number="11011"></td>
        <td id="LC11011"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11012" data-line-number="11012"></td>
        <td id="LC11012"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L11013" data-line-number="11013"></td>
        <td id="LC11013"><span><span>//</span>     pManagedEvent - managed event to delete.</span></td>
      </tr>
      <tr>
        <td id="L11014" data-line-number="11014"></td>
        <td id="LC11014"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11015" data-line-number="11015"></td>
        <td id="LC11015"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L11016" data-line-number="11016"></td>
        <td id="LC11016"><span><span>//</span>     This can delete a partially marshalled event.</span></td>
      </tr>
      <tr>
        <td id="L11017" data-line-number="11017"></td>
        <td id="LC11017"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11018" data-line-number="11018"></td>
        <td id="LC11018"><span>void</span> <span>DeleteIPCEventHelper</span>(DebuggerIPCEvent *pManagedEvent)</td>
      </tr>
      <tr>
        <td id="L11019" data-line-number="11019"></td>
        <td id="LC11019">{</td>
      </tr>
      <tr>
        <td id="L11020" data-line-number="11020"></td>
        <td id="LC11020">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L11021" data-line-number="11021"></td>
        <td id="LC11021">    {</td>
      </tr>
      <tr>
        <td id="L11022" data-line-number="11022"></td>
        <td id="LC11022">        <span><span>//</span> This is backout code that shouldn't need to throw.</span></td>
      </tr>
      <tr>
        <td id="L11023" data-line-number="11023"></td>
        <td id="LC11023">        NOTHROW;</td>
      </tr>
      <tr>
        <td id="L11024" data-line-number="11024"></td>
        <td id="LC11024">    }</td>
      </tr>
      <tr>
        <td id="L11025" data-line-number="11025"></td>
        <td id="LC11025">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L11026" data-line-number="11026"></td>
        <td id="LC11026">    <span>if</span> (pManagedEvent == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L11027" data-line-number="11027"></td>
        <td id="LC11027">    {</td>
      </tr>
      <tr>
        <td id="L11028" data-line-number="11028"></td>
        <td id="LC11028">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L11029" data-line-number="11029"></td>
        <td id="LC11029">    }</td>
      </tr>
      <tr>
        <td id="L11030" data-line-number="11030"></td>
        <td id="LC11030">    <span>switch</span> (pManagedEvent-&gt;<span>type</span> &amp; DB_IPCE_TYPE_MASK)</td>
      </tr>
      <tr>
        <td id="L11031" data-line-number="11031"></td>
        <td id="LC11031">    {</td>
      </tr>
      <tr>
        <td id="L11032" data-line-number="11032"></td>
        <td id="LC11032">        <span><span>//</span> so far only this event need to cleanup.</span></td>
      </tr>
      <tr>
        <td id="L11033" data-line-number="11033"></td>
        <td id="LC11033">        <span>case</span> DB_IPCE_MDA_NOTIFICATION:</td>
      </tr>
      <tr>
        <td id="L11034" data-line-number="11034"></td>
        <td id="LC11034">            pManagedEvent-&gt;<span>MDANotification</span>.<span>szName</span>.<span>CleanUp</span>();</td>
      </tr>
      <tr>
        <td id="L11035" data-line-number="11035"></td>
        <td id="LC11035">            pManagedEvent-&gt;<span>MDANotification</span>.<span>szDescription</span>.<span>CleanUp</span>();</td>
      </tr>
      <tr>
        <td id="L11036" data-line-number="11036"></td>
        <td id="LC11036">            pManagedEvent-&gt;<span>MDANotification</span>.<span>szXml</span>.<span>CleanUp</span>();</td>
      </tr>
      <tr>
        <td id="L11037" data-line-number="11037"></td>
        <td id="LC11037">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L11038" data-line-number="11038"></td>
        <td id="LC11038">
</td>
      </tr>
      <tr>
        <td id="L11039" data-line-number="11039"></td>
        <td id="LC11039">        <span>case</span> DB_IPCE_FIRST_LOG_MESSAGE:</td>
      </tr>
      <tr>
        <td id="L11040" data-line-number="11040"></td>
        <td id="LC11040">            pManagedEvent-&gt;<span>FirstLogMessage</span>.<span>szContent</span>.<span>CleanUp</span>();</td>
      </tr>
      <tr>
        <td id="L11041" data-line-number="11041"></td>
        <td id="LC11041">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L11042" data-line-number="11042"></td>
        <td id="LC11042">
</td>
      </tr>
      <tr>
        <td id="L11043" data-line-number="11043"></td>
        <td id="LC11043">        <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L11044" data-line-number="11044"></td>
        <td id="LC11044">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L11045" data-line-number="11045"></td>
        <td id="LC11045">    }</td>
      </tr>
      <tr>
        <td id="L11046" data-line-number="11046"></td>
        <td id="LC11046">    <span>delete []</span> (BYTE *)pManagedEvent;</td>
      </tr>
      <tr>
        <td id="L11047" data-line-number="11047"></td>
        <td id="LC11047">}</td>
      </tr>
      <tr>
        <td id="L11048" data-line-number="11048"></td>
        <td id="LC11048">
</td>
      </tr>
      <tr>
        <td id="L11049" data-line-number="11049"></td>
        <td id="LC11049"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11050" data-line-number="11050"></td>
        <td id="LC11050"><span><span>//</span> Handle a CLR specific notification event.</span></td>
      </tr>
      <tr>
        <td id="L11051" data-line-number="11051"></td>
        <td id="LC11051"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11052" data-line-number="11052"></td>
        <td id="LC11052"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L11053" data-line-number="11053"></td>
        <td id="LC11053"><span><span>//</span>    pManagedEvent - non-null pointer to a managed event.</span></td>
      </tr>
      <tr>
        <td id="L11054" data-line-number="11054"></td>
        <td id="LC11054"><span><span>//</span>    pLockHolder - hold to process lock that gets toggled if this dispatches an event.</span></td>
      </tr>
      <tr>
        <td id="L11055" data-line-number="11055"></td>
        <td id="LC11055"><span><span>//</span>    pCallback - callback to dispatch potential managed events.</span></td>
      </tr>
      <tr>
        <td id="L11056" data-line-number="11056"></td>
        <td id="LC11056"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11057" data-line-number="11057"></td>
        <td id="LC11057"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L11058" data-line-number="11058"></td>
        <td id="LC11058"><span><span>//</span>    Throws on error.</span></td>
      </tr>
      <tr>
        <td id="L11059" data-line-number="11059"></td>
        <td id="LC11059"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11060" data-line-number="11060"></td>
        <td id="LC11060"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L11061" data-line-number="11061"></td>
        <td id="LC11061"><span><span>//</span>    Target is stopped. Record was already determined to be a CLR event.</span></td>
      </tr>
      <tr>
        <td id="L11062" data-line-number="11062"></td>
        <td id="LC11062"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11063" data-line-number="11063"></td>
        <td id="LC11063"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L11064" data-line-number="11064"></td>
        <td id="LC11064"><span><span>//</span>    This is called after caller does WaitForDebugEvent.</span></td>
      </tr>
      <tr>
        <td id="L11065" data-line-number="11065"></td>
        <td id="LC11065"><span><span>//</span>    Any exception this Filter does not recognize is treated as kNotClr.</span></td>
      </tr>
      <tr>
        <td id="L11066" data-line-number="11066"></td>
        <td id="LC11066"><span><span>//</span>    Currently, this includes both managed-exceptions and unmanaged ones.</span></td>
      </tr>
      <tr>
        <td id="L11067" data-line-number="11067"></td>
        <td id="LC11067"><span><span>//</span>    For interop-debugging, the interop logic will handle all kNotClr and triage if</span></td>
      </tr>
      <tr>
        <td id="L11068" data-line-number="11068"></td>
        <td id="LC11068"><span><span>//</span>    it's really a non-CLR exception.</span></td>
      </tr>
      <tr>
        <td id="L11069" data-line-number="11069"></td>
        <td id="LC11069"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11070" data-line-number="11070"></td>
        <td id="LC11070"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11071" data-line-number="11071"></td>
        <td id="LC11071"><span>void</span> <span>CordbProcess::FilterClrNotification</span>(</td>
      </tr>
      <tr>
        <td id="L11072" data-line-number="11072"></td>
        <td id="LC11072">    DebuggerIPCEvent * pManagedEvent,</td>
      </tr>
      <tr>
        <td id="L11073" data-line-number="11073"></td>
        <td id="LC11073">    RSLockHolder * pLockHolder,</td>
      </tr>
      <tr>
        <td id="L11074" data-line-number="11074"></td>
        <td id="LC11074">    ICorDebugManagedCallback * pCallback)</td>
      </tr>
      <tr>
        <td id="L11075" data-line-number="11075"></td>
        <td id="LC11075">{</td>
      </tr>
      <tr>
        <td id="L11076" data-line-number="11076"></td>
        <td id="LC11076">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L11077" data-line-number="11077"></td>
        <td id="LC11077">    {</td>
      </tr>
      <tr>
        <td id="L11078" data-line-number="11078"></td>
        <td id="LC11078">        THROWS;</td>
      </tr>
      <tr>
        <td id="L11079" data-line-number="11079"></td>
        <td id="LC11079">        <span>PRECONDITION</span>(<span>CheckPointer</span>(pManagedEvent));</td>
      </tr>
      <tr>
        <td id="L11080" data-line-number="11080"></td>
        <td id="LC11080">        <span>PRECONDITION</span>(<span>CheckPointer</span>(pCallback));</td>
      </tr>
      <tr>
        <td id="L11081" data-line-number="11081"></td>
        <td id="LC11081">        <span>PRECONDITION</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L11082" data-line-number="11082"></td>
        <td id="LC11082">    }</td>
      </tr>
      <tr>
        <td id="L11083" data-line-number="11083"></td>
        <td id="LC11083">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L11084" data-line-number="11084"></td>
        <td id="LC11084">
</td>
      </tr>
      <tr>
        <td id="L11085" data-line-number="11085"></td>
        <td id="LC11085">    <span><span>//</span> There are 3 types of events from the LS:</span></td>
      </tr>
      <tr>
        <td id="L11086" data-line-number="11086"></td>
        <td id="LC11086">    <span><span>//</span> 1) Replies (eg, corresponding to WaitForIPCEvent)</span></td>
      </tr>
      <tr>
        <td id="L11087" data-line-number="11087"></td>
        <td id="LC11087">    <span><span>//</span>       we need to set LSEA/wait on LSER.</span></td>
      </tr>
      <tr>
        <td id="L11088" data-line-number="11088"></td>
        <td id="LC11088">    <span><span>//</span> 2) Sync-Complete (kind of like a special notification)</span></td>
      </tr>
      <tr>
        <td id="L11089" data-line-number="11089"></td>
        <td id="LC11089">    <span><span>//</span>       Ping the helper</span></td>
      </tr>
      <tr>
        <td id="L11090" data-line-number="11090"></td>
        <td id="LC11090">    <span><span>//</span> 3) Notifications (eg, Module-load):</span></td>
      </tr>
      <tr>
        <td id="L11091" data-line-number="11091"></td>
        <td id="LC11091">    <span><span>//</span>       these are dispatched immediately.</span></td>
      </tr>
      <tr>
        <td id="L11092" data-line-number="11092"></td>
        <td id="LC11092">    <span><span>//</span> 4) Left-side Startup event</span></td>
      </tr>
      <tr>
        <td id="L11093" data-line-number="11093"></td>
        <td id="LC11093">
</td>
      </tr>
      <tr>
        <td id="L11094" data-line-number="11094"></td>
        <td id="LC11094">
</td>
      </tr>
      <tr>
        <td id="L11095" data-line-number="11095"></td>
        <td id="LC11095">    <span><span>//</span> IF we're synced, then we must be getting a "Reply".</span></td>
      </tr>
      <tr>
        <td id="L11096" data-line-number="11096"></td>
        <td id="LC11096">    <span>bool</span> <span>fReply</span> = <span>this</span>-&gt;<span>GetSynchronized</span>();</td>
      </tr>
      <tr>
        <td id="L11097" data-line-number="11097"></td>
        <td id="LC11097">
</td>
      </tr>
      <tr>
        <td id="L11098" data-line-number="11098"></td>
        <td id="LC11098">    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::FCN - Received event %s; fReply: %d<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L11099" data-line-number="11099"></td>
        <td id="LC11099">         <span>IPCENames::GetName</span>(pManagedEvent-&gt;<span>type</span>),</td>
      </tr>
      <tr>
        <td id="L11100" data-line-number="11100"></td>
        <td id="LC11100">         <span>fReply</span>));</td>
      </tr>
      <tr>
        <td id="L11101" data-line-number="11101"></td>
        <td id="LC11101">
</td>
      </tr>
      <tr>
        <td id="L11102" data-line-number="11102"></td>
        <td id="LC11102">    <span>if</span> (<span>fReply</span>)</td>
      </tr>
      <tr>
        <td id="L11103" data-line-number="11103"></td>
        <td id="LC11103">    {</td>
      </tr>
      <tr>
        <td id="L11104" data-line-number="11104"></td>
        <td id="LC11104">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11105" data-line-number="11105"></td>
        <td id="LC11105">        <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L11106" data-line-number="11106"></td>
        <td id="LC11106">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11107" data-line-number="11107"></td>
        <td id="LC11107">        <span><span>//</span> Case 1: Reply</span></td>
      </tr>
      <tr>
        <td id="L11108" data-line-number="11108"></td>
        <td id="LC11108">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11109" data-line-number="11109"></td>
        <td id="LC11109">
</td>
      </tr>
      <tr>
        <td id="L11110" data-line-number="11110"></td>
        <td id="LC11110">        pLockHolder-&gt;<span>Release</span>();</td>
      </tr>
      <tr>
        <td id="L11111" data-line-number="11111"></td>
        <td id="LC11111">        <span>_ASSERTE</span>(!<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L11112" data-line-number="11112"></td>
        <td id="LC11112">
</td>
      </tr>
      <tr>
        <td id="L11113" data-line-number="11113"></td>
        <td id="LC11113">        <span><span>//</span> Save the IPC event and wake up the thread which is waiting for it from the LS.</span></td>
      </tr>
      <tr>
        <td id="L11114" data-line-number="11114"></td>
        <td id="LC11114">        <span>GetEventChannel</span>()-&gt;<span>SaveEventFromLeftSide</span>(pManagedEvent);</td>
      </tr>
      <tr>
        <td id="L11115" data-line-number="11115"></td>
        <td id="LC11115">        <span>SetEvent</span>(<span>this</span>-&gt;<span>m_leftSideEventAvailable</span>);</td>
      </tr>
      <tr>
        <td id="L11116" data-line-number="11116"></td>
        <td id="LC11116">
</td>
      </tr>
      <tr>
        <td id="L11117" data-line-number="11117"></td>
        <td id="LC11117">        <span><span>//</span> Some other thread called code:CordbRCEventThread::WaitForIPCEventFromProcess, and</span></td>
      </tr>
      <tr>
        <td id="L11118" data-line-number="11118"></td>
        <td id="LC11118">        <span><span>//</span> that will respond here and set the event.</span></td>
      </tr>
      <tr>
        <td id="L11119" data-line-number="11119"></td>
        <td id="LC11119">
</td>
      </tr>
      <tr>
        <td id="L11120" data-line-number="11120"></td>
        <td id="LC11120">        DWORD dwResult = <span>WaitForSingleObject</span>(<span>this</span>-&gt;<span>m_leftSideEventRead</span>, <span>CordbGetWaitTimeout</span>());</td>
      </tr>
      <tr>
        <td id="L11121" data-line-number="11121"></td>
        <td id="LC11121">        pLockHolder-&gt;<span>Acquire</span>();</td>
      </tr>
      <tr>
        <td id="L11122" data-line-number="11122"></td>
        <td id="LC11122">        <span>if</span> (dwResult != WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L11123" data-line-number="11123"></td>
        <td id="LC11123">        {</td>
      </tr>
      <tr>
        <td id="L11124" data-line-number="11124"></td>
        <td id="LC11124">            <span><span>//</span> The wait failed.  This is probably WAIT_TIMEOUT which suggests a deadlock/assert on</span></td>
      </tr>
      <tr>
        <td id="L11125" data-line-number="11125"></td>
        <td id="LC11125">            <span><span>//</span> the RCEventThread.</span></td>
      </tr>
      <tr>
        <td id="L11126" data-line-number="11126"></td>
        <td id="LC11126">            <span>CONSISTENCY_CHECK_MSGF</span>(<span>false</span>, (<span><span>"</span>WaitForSingleObject failed: %d<span>"</span></span>, dwResult));</td>
      </tr>
      <tr>
        <td id="L11127" data-line-number="11127"></td>
        <td id="LC11127">            <span>ThrowHR</span>(CORDBG_E_TIMEOUT);</td>
      </tr>
      <tr>
        <td id="L11128" data-line-number="11128"></td>
        <td id="LC11128">        }</td>
      </tr>
      <tr>
        <td id="L11129" data-line-number="11129"></td>
        <td id="LC11129">    }</td>
      </tr>
      <tr>
        <td id="L11130" data-line-number="11130"></td>
        <td id="LC11130">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L11131" data-line-number="11131"></td>
        <td id="LC11131">    {</td>
      </tr>
      <tr>
        <td id="L11132" data-line-number="11132"></td>
        <td id="LC11132">        <span>if</span> (pManagedEvent-&gt;<span>type</span> == DB_IPCE_LEFTSIDE_STARTUP)</td>
      </tr>
      <tr>
        <td id="L11133" data-line-number="11133"></td>
        <td id="LC11133">        {</td>
      </tr>
      <tr>
        <td id="L11134" data-line-number="11134"></td>
        <td id="LC11134">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11135" data-line-number="11135"></td>
        <td id="LC11135">            <span><span>//</span> Case 4: Left-side startup event. We'll mark that we're attached from oop.</span></td>
      </tr>
      <tr>
        <td id="L11136" data-line-number="11136"></td>
        <td id="LC11136">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11137" data-line-number="11137"></td>
        <td id="LC11137">
</td>
      </tr>
      <tr>
        <td id="L11138" data-line-number="11138"></td>
        <td id="LC11138">            <span><span>//</span> Now that LS is started, we should definitely be able to instantiate DAC.</span></td>
      </tr>
      <tr>
        <td id="L11139" data-line-number="11139"></td>
        <td id="LC11139">            <span>InitializeDac</span>();</td>
      </tr>
      <tr>
        <td id="L11140" data-line-number="11140"></td>
        <td id="LC11140">
</td>
      </tr>
      <tr>
        <td id="L11141" data-line-number="11141"></td>
        <td id="LC11141">            <span><span>//</span> @dbgtodo 'attach-bit': we don't want the debugger automatically invading the process.</span></td>
      </tr>
      <tr>
        <td id="L11142" data-line-number="11142"></td>
        <td id="LC11142">            <span>GetDAC</span>()-&gt;<span>MarkDebuggerAttached</span>(<span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L11143" data-line-number="11143"></td>
        <td id="LC11143">        }</td>
      </tr>
      <tr>
        <td id="L11144" data-line-number="11144"></td>
        <td id="LC11144">        <span>else</span> <span>if</span> (pManagedEvent-&gt;<span>type</span> == DB_IPCE_SYNC_COMPLETE)</td>
      </tr>
      <tr>
        <td id="L11145" data-line-number="11145"></td>
        <td id="LC11145">        {</td>
      </tr>
      <tr>
        <td id="L11146" data-line-number="11146"></td>
        <td id="LC11146">            <span><span>//</span> Since V3 doesn't request syncs, it shouldn't get sync-complete.</span></td>
      </tr>
      <tr>
        <td id="L11147" data-line-number="11147"></td>
        <td id="LC11147">            <span><span>//</span> @dbgtodo sync: this changes when V3 can explicitly request an AsyncBreak.</span></td>
      </tr>
      <tr>
        <td id="L11148" data-line-number="11148"></td>
        <td id="LC11148">            <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L11149" data-line-number="11149"></td>
        <td id="LC11149">
</td>
      </tr>
      <tr>
        <td id="L11150" data-line-number="11150"></td>
        <td id="LC11150">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11151" data-line-number="11151"></td>
        <td id="LC11151">            <span><span>//</span> Case 2: Sync Complete</span></td>
      </tr>
      <tr>
        <td id="L11152" data-line-number="11152"></td>
        <td id="LC11152">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11153" data-line-number="11153"></td>
        <td id="LC11153">
</td>
      </tr>
      <tr>
        <td id="L11154" data-line-number="11154"></td>
        <td id="LC11154">            <span>HandleSyncCompleteRecieved</span>();</td>
      </tr>
      <tr>
        <td id="L11155" data-line-number="11155"></td>
        <td id="LC11155">        }</td>
      </tr>
      <tr>
        <td id="L11156" data-line-number="11156"></td>
        <td id="LC11156">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L11157" data-line-number="11157"></td>
        <td id="LC11157">        {</td>
      </tr>
      <tr>
        <td id="L11158" data-line-number="11158"></td>
        <td id="LC11158">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11159" data-line-number="11159"></td>
        <td id="LC11159">            <span><span>//</span> Case 3: Notification. This will dispatch the event immediately.</span></td>
      </tr>
      <tr>
        <td id="L11160" data-line-number="11160"></td>
        <td id="LC11160">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11161" data-line-number="11161"></td>
        <td id="LC11161">
</td>
      </tr>
      <tr>
        <td id="L11162" data-line-number="11162"></td>
        <td id="LC11162">            <span><span>//</span> Toggles the process-lock if it dispatches callbacks.</span></td>
      </tr>
      <tr>
        <td id="L11163" data-line-number="11163"></td>
        <td id="LC11163">            <span>HandleRCEvent</span>(pManagedEvent, pLockHolder, pCallback);</td>
      </tr>
      <tr>
        <td id="L11164" data-line-number="11164"></td>
        <td id="LC11164">
</td>
      </tr>
      <tr>
        <td id="L11165" data-line-number="11165"></td>
        <td id="LC11165">        } <span><span>//</span> end Notification</span></td>
      </tr>
      <tr>
        <td id="L11166" data-line-number="11166"></td>
        <td id="LC11166">    }</td>
      </tr>
      <tr>
        <td id="L11167" data-line-number="11167"></td>
        <td id="LC11167">}</td>
      </tr>
      <tr>
        <td id="L11168" data-line-number="11168"></td>
        <td id="LC11168">
</td>
      </tr>
      <tr>
        <td id="L11169" data-line-number="11169"></td>
        <td id="LC11169">
</td>
      </tr>
      <tr>
        <td id="L11170" data-line-number="11170"></td>
        <td id="LC11170">
</td>
      </tr>
      <tr>
        <td id="L11171" data-line-number="11171"></td>
        <td id="LC11171"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11172" data-line-number="11172"></td>
        <td id="LC11172"><span><span>//</span> If the thread has an unhandled managed exception, hijack it.</span></td>
      </tr>
      <tr>
        <td id="L11173" data-line-number="11173"></td>
        <td id="LC11173"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11174" data-line-number="11174"></td>
        <td id="LC11174"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L11175" data-line-number="11175"></td>
        <td id="LC11175"><span><span>//</span>     dwThreadId - OS Thread id.</span></td>
      </tr>
      <tr>
        <td id="L11176" data-line-number="11176"></td>
        <td id="LC11176"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11177" data-line-number="11177"></td>
        <td id="LC11177"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L11178" data-line-number="11178"></td>
        <td id="LC11178"><span><span>//</span>     True if hijacked; false if not.</span></td>
      </tr>
      <tr>
        <td id="L11179" data-line-number="11179"></td>
        <td id="LC11179"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11180" data-line-number="11180"></td>
        <td id="LC11180"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L11181" data-line-number="11181"></td>
        <td id="LC11181"><span><span>//</span>     This is called from shim to emulate being synchronized at an unhandled</span></td>
      </tr>
      <tr>
        <td id="L11182" data-line-number="11182"></td>
        <td id="LC11182"><span><span>//</span>     exception.</span></td>
      </tr>
      <tr>
        <td id="L11183" data-line-number="11183"></td>
        <td id="LC11183"><span><span>//</span>     Other ICorDebug operations could calls this (eg, func-eval at 2nd chance).</span></td>
      </tr>
      <tr>
        <td id="L11184" data-line-number="11184"></td>
        <td id="LC11184">BOOL <span>CordbProcess::HijackThreadForUnhandledExceptionIfNeeded</span>(DWORD dwThreadId)</td>
      </tr>
      <tr>
        <td id="L11185" data-line-number="11185"></td>
        <td id="LC11185">{</td>
      </tr>
      <tr>
        <td id="L11186" data-line-number="11186"></td>
        <td id="LC11186">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>); <span><span>//</span> from Shim</span></td>
      </tr>
      <tr>
        <td id="L11187" data-line-number="11187"></td>
        <td id="LC11187">
</td>
      </tr>
      <tr>
        <td id="L11188" data-line-number="11188"></td>
        <td id="LC11188">    BOOL <span>fHijacked</span> = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L11189" data-line-number="11189"></td>
        <td id="LC11189">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L11190" data-line-number="11190"></td>
        <td id="LC11190">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L11191" data-line-number="11191"></td>
        <td id="LC11191">    {</td>
      </tr>
      <tr>
        <td id="L11192" data-line-number="11192"></td>
        <td id="LC11192">        RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L11193" data-line-number="11193"></td>
        <td id="LC11193">
</td>
      </tr>
      <tr>
        <td id="L11194" data-line-number="11194"></td>
        <td id="LC11194">        <span><span>//</span> OS will not execute the Unhandled Exception Filter under native debugger, so</span></td>
      </tr>
      <tr>
        <td id="L11195" data-line-number="11195"></td>
        <td id="LC11195">        <span><span>//</span> we need to hijack the thread to get it to execute the UEF, which will then do</span></td>
      </tr>
      <tr>
        <td id="L11196" data-line-number="11196"></td>
        <td id="LC11196">        <span><span>//</span> work for unhandled managed exceptions.</span></td>
      </tr>
      <tr>
        <td id="L11197" data-line-number="11197"></td>
        <td id="LC11197">        CordbThread * pThread = <span>TryLookupOrCreateThreadByVolatileOSId</span>(dwThreadId);</td>
      </tr>
      <tr>
        <td id="L11198" data-line-number="11198"></td>
        <td id="LC11198">        <span>if</span> (pThread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L11199" data-line-number="11199"></td>
        <td id="LC11199">        {</td>
      </tr>
      <tr>
        <td id="L11200" data-line-number="11200"></td>
        <td id="LC11200">            <span><span>//</span> If the thread has a managed exception, then we should have a pThread object.</span></td>
      </tr>
      <tr>
        <td id="L11201" data-line-number="11201"></td>
        <td id="LC11201">
</td>
      </tr>
      <tr>
        <td id="L11202" data-line-number="11202"></td>
        <td id="LC11202">            <span>if</span> (pThread-&gt;<span>HasUnhandledNativeException</span>())</td>
      </tr>
      <tr>
        <td id="L11203" data-line-number="11203"></td>
        <td id="LC11203">            {</td>
      </tr>
      <tr>
        <td id="L11204" data-line-number="11204"></td>
        <td id="LC11204">                <span>_ASSERTE</span>(pThread-&gt;<span>IsThreadExceptionManaged</span>()); <span><span>//</span> should have been marked earlier</span></td>
      </tr>
      <tr>
        <td id="L11205" data-line-number="11205"></td>
        <td id="LC11205">
</td>
      </tr>
      <tr>
        <td id="L11206" data-line-number="11206"></td>
        <td id="LC11206">                pThread-&gt;<span>HijackForUnhandledException</span>();</td>
      </tr>
      <tr>
        <td id="L11207" data-line-number="11207"></td>
        <td id="LC11207">                <span>fHijacked</span> = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L11208" data-line-number="11208"></td>
        <td id="LC11208">            }</td>
      </tr>
      <tr>
        <td id="L11209" data-line-number="11209"></td>
        <td id="LC11209">        }</td>
      </tr>
      <tr>
        <td id="L11210" data-line-number="11210"></td>
        <td id="LC11210">    }</td>
      </tr>
      <tr>
        <td id="L11211" data-line-number="11211"></td>
        <td id="LC11211">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L11212" data-line-number="11212"></td>
        <td id="LC11212">    <span>SIMPLIFYING_ASSUMPTION</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L11213" data-line-number="11213"></td>
        <td id="LC11213">
</td>
      </tr>
      <tr>
        <td id="L11214" data-line-number="11214"></td>
        <td id="LC11214">    <span>return</span> <span>fHijacked</span>;</td>
      </tr>
      <tr>
        <td id="L11215" data-line-number="11215"></td>
        <td id="LC11215">}</td>
      </tr>
      <tr>
        <td id="L11216" data-line-number="11216"></td>
        <td id="LC11216">
</td>
      </tr>
      <tr>
        <td id="L11217" data-line-number="11217"></td>
        <td id="LC11217"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11218" data-line-number="11218"></td>
        <td id="LC11218"><span><span>//</span> Validate the given exception record or throw.</span></td>
      </tr>
      <tr>
        <td id="L11219" data-line-number="11219"></td>
        <td id="LC11219"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11220" data-line-number="11220"></td>
        <td id="LC11220"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L11221" data-line-number="11221"></td>
        <td id="LC11221"><span><span>//</span>    pRawRecord - non-null raw bytes of the exception</span></td>
      </tr>
      <tr>
        <td id="L11222" data-line-number="11222"></td>
        <td id="LC11222"><span><span>//</span>    countBytes - number of bytes in pRawRecord buffer.</span></td>
      </tr>
      <tr>
        <td id="L11223" data-line-number="11223"></td>
        <td id="LC11223"><span><span>//</span>    format - format of pRawRecord</span></td>
      </tr>
      <tr>
        <td id="L11224" data-line-number="11224"></td>
        <td id="LC11224"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11225" data-line-number="11225"></td>
        <td id="LC11225"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L11226" data-line-number="11226"></td>
        <td id="LC11226"><span><span>//</span>    A type-safe exception record from the raw buffer.</span></td>
      </tr>
      <tr>
        <td id="L11227" data-line-number="11227"></td>
        <td id="LC11227"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11228" data-line-number="11228"></td>
        <td id="LC11228"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L11229" data-line-number="11229"></td>
        <td id="LC11229"><span><span>//</span>   This is a helper for code:CordbProcess::Filter.</span></td>
      </tr>
      <tr>
        <td id="L11230" data-line-number="11230"></td>
        <td id="LC11230"><span><span>//</span>   This can do consistency checks on the incoming parameters such as:</span></td>
      </tr>
      <tr>
        <td id="L11231" data-line-number="11231"></td>
        <td id="LC11231"><span><span>//</span>    * verify countBytes matches the expected size for the given format.</span></td>
      </tr>
      <tr>
        <td id="L11232" data-line-number="11232"></td>
        <td id="LC11232"><span><span>//</span>    * verify the format is supported.</span></td>
      </tr>
      <tr>
        <td id="L11233" data-line-number="11233"></td>
        <td id="LC11233"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11234" data-line-number="11234"></td>
        <td id="LC11234"><span><span>//</span>   If we let a given ICD understand multiple formats (eg, have x86 understand both Exr32 and</span></td>
      </tr>
      <tr>
        <td id="L11235" data-line-number="11235"></td>
        <td id="LC11235"><span><span>//</span>    Exr64), this would be the spot to allow the conversion.</span></td>
      </tr>
      <tr>
        <td id="L11236" data-line-number="11236"></td>
        <td id="LC11236"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11237" data-line-number="11237"></td>
        <td id="LC11237"><span>const</span> EXCEPTION_RECORD * <span>CordbProcess::ValidateExceptionRecord</span>(</td>
      </tr>
      <tr>
        <td id="L11238" data-line-number="11238"></td>
        <td id="LC11238">        <span>const</span> BYTE pRawRecord[],</td>
      </tr>
      <tr>
        <td id="L11239" data-line-number="11239"></td>
        <td id="LC11239">        DWORD countBytes,</td>
      </tr>
      <tr>
        <td id="L11240" data-line-number="11240"></td>
        <td id="LC11240">        CorDebugRecordFormat format)</td>
      </tr>
      <tr>
        <td id="L11241" data-line-number="11241"></td>
        <td id="LC11241">{</td>
      </tr>
      <tr>
        <td id="L11242" data-line-number="11242"></td>
        <td id="LC11242">    <span>ValidateOrThrow</span>(pRawRecord);</td>
      </tr>
      <tr>
        <td id="L11243" data-line-number="11243"></td>
        <td id="LC11243">
</td>
      </tr>
      <tr>
        <td id="L11244" data-line-number="11244"></td>
        <td id="LC11244">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11245" data-line-number="11245"></td>
        <td id="LC11245">    <span><span>//</span> Check format against expected platform.</span></td>
      </tr>
      <tr>
        <td id="L11246" data-line-number="11246"></td>
        <td id="LC11246">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11247" data-line-number="11247"></td>
        <td id="LC11247">
</td>
      </tr>
      <tr>
        <td id="L11248" data-line-number="11248"></td>
        <td id="LC11248">    <span><span>//</span> @dbgtodo - , cross-plat: Once we do cross-plat, these should be based off target-architecture not host's.</span></td>
      </tr>
      <tr>
        <td id="L11249" data-line-number="11249"></td>
        <td id="LC11249">#<span>if</span> defined(BIT64)</td>
      </tr>
      <tr>
        <td id="L11250" data-line-number="11250"></td>
        <td id="LC11250">    <span>if</span> (format != FORMAT_WINDOWS_EXCEPTIONRECORD64)</td>
      </tr>
      <tr>
        <td id="L11251" data-line-number="11251"></td>
        <td id="LC11251">    {</td>
      </tr>
      <tr>
        <td id="L11252" data-line-number="11252"></td>
        <td id="LC11252">        <span>ThrowHR</span>(E_INVALIDARG);</td>
      </tr>
      <tr>
        <td id="L11253" data-line-number="11253"></td>
        <td id="LC11253">    }</td>
      </tr>
      <tr>
        <td id="L11254" data-line-number="11254"></td>
        <td id="LC11254">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L11255" data-line-number="11255"></td>
        <td id="LC11255">    <span>if</span> (format != FORMAT_WINDOWS_EXCEPTIONRECORD32)</td>
      </tr>
      <tr>
        <td id="L11256" data-line-number="11256"></td>
        <td id="LC11256">    {</td>
      </tr>
      <tr>
        <td id="L11257" data-line-number="11257"></td>
        <td id="LC11257">        <span>ThrowHR</span>(E_INVALIDARG);</td>
      </tr>
      <tr>
        <td id="L11258" data-line-number="11258"></td>
        <td id="LC11258">    }</td>
      </tr>
      <tr>
        <td id="L11259" data-line-number="11259"></td>
        <td id="LC11259">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L11260" data-line-number="11260"></td>
        <td id="LC11260">
</td>
      </tr>
      <tr>
        <td id="L11261" data-line-number="11261"></td>
        <td id="LC11261">    <span><span>//</span> @dbgtodo cross-plat: once we do cross-plat, need to use correct EXCEPTION_RECORD variant.</span></td>
      </tr>
      <tr>
        <td id="L11262" data-line-number="11262"></td>
        <td id="LC11262">    <span>if</span> (countBytes != <span>sizeof</span>(EXCEPTION_RECORD))</td>
      </tr>
      <tr>
        <td id="L11263" data-line-number="11263"></td>
        <td id="LC11263">    {</td>
      </tr>
      <tr>
        <td id="L11264" data-line-number="11264"></td>
        <td id="LC11264">        <span>ThrowHR</span>(E_INVALIDARG);</td>
      </tr>
      <tr>
        <td id="L11265" data-line-number="11265"></td>
        <td id="LC11265">    }</td>
      </tr>
      <tr>
        <td id="L11266" data-line-number="11266"></td>
        <td id="LC11266">
</td>
      </tr>
      <tr>
        <td id="L11267" data-line-number="11267"></td>
        <td id="LC11267">
</td>
      </tr>
      <tr>
        <td id="L11268" data-line-number="11268"></td>
        <td id="LC11268">    <span>const</span> EXCEPTION_RECORD * pRecord = <span>reinterpret_cast</span>&lt;<span>const</span> EXCEPTION_RECORD *&gt; (pRawRecord);</td>
      </tr>
      <tr>
        <td id="L11269" data-line-number="11269"></td>
        <td id="LC11269">
</td>
      </tr>
      <tr>
        <td id="L11270" data-line-number="11270"></td>
        <td id="LC11270">    <span>return</span> pRecord;</td>
      </tr>
      <tr>
        <td id="L11271" data-line-number="11271"></td>
        <td id="LC11271">};</td>
      </tr>
      <tr>
        <td id="L11272" data-line-number="11272"></td>
        <td id="LC11272">
</td>
      </tr>
      <tr>
        <td id="L11273" data-line-number="11273"></td>
        <td id="LC11273"><span><span>//</span> Return value: S_OK or indication that no more room exists for enabled types</span></td>
      </tr>
      <tr>
        <td id="L11274" data-line-number="11274"></td>
        <td id="LC11274">HRESULT <span>CordbProcess::SetEnableCustomNotification</span>(ICorDebugClass * pClass, BOOL <span>fEnable</span>)</td>
      </tr>
      <tr>
        <td id="L11275" data-line-number="11275"></td>
        <td id="LC11275">{</td>
      </tr>
      <tr>
        <td id="L11276" data-line-number="11276"></td>
        <td id="LC11276">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L11277" data-line-number="11277"></td>
        <td id="LC11277">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>); <span><span>//</span> takes the lock</span></td>
      </tr>
      <tr>
        <td id="L11278" data-line-number="11278"></td>
        <td id="LC11278">
</td>
      </tr>
      <tr>
        <td id="L11279" data-line-number="11279"></td>
        <td id="LC11279">    <span>ValidateOrThrow</span>(pClass);</td>
      </tr>
      <tr>
        <td id="L11280" data-line-number="11280"></td>
        <td id="LC11280">
</td>
      </tr>
      <tr>
        <td id="L11281" data-line-number="11281"></td>
        <td id="LC11281">    ((CordbClass *)pClass)-&gt;<span>SetCustomNotifications</span>(<span>fEnable</span>);</td>
      </tr>
      <tr>
        <td id="L11282" data-line-number="11282"></td>
        <td id="LC11282">
</td>
      </tr>
      <tr>
        <td id="L11283" data-line-number="11283"></td>
        <td id="LC11283">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L11284" data-line-number="11284"></td>
        <td id="LC11284">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L11285" data-line-number="11285"></td>
        <td id="LC11285">} <span><span>//</span> CordbProcess::SetEnableCustomNotification</span></td>
      </tr>
      <tr>
        <td id="L11286" data-line-number="11286"></td>
        <td id="LC11286">
</td>
      </tr>
      <tr>
        <td id="L11287" data-line-number="11287"></td>
        <td id="LC11287"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11288" data-line-number="11288"></td>
        <td id="LC11288"><span><span>//</span> Public implementation of ICDProcess4::Filter</span></td>
      </tr>
      <tr>
        <td id="L11289" data-line-number="11289"></td>
        <td id="LC11289"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11290" data-line-number="11290"></td>
        <td id="LC11290"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L11291" data-line-number="11291"></td>
        <td id="LC11291"><span><span>//</span>    pRawRecord - non-null raw bytes of the exception</span></td>
      </tr>
      <tr>
        <td id="L11292" data-line-number="11292"></td>
        <td id="LC11292"><span><span>//</span>    countBytes - number of bytes in pRawRecord buffer.</span></td>
      </tr>
      <tr>
        <td id="L11293" data-line-number="11293"></td>
        <td id="LC11293"><span><span>//</span>    format - format of pRawRecord</span></td>
      </tr>
      <tr>
        <td id="L11294" data-line-number="11294"></td>
        <td id="LC11294"><span><span>//</span>    dwFlags - flags providing auxillary info for exception record.</span></td>
      </tr>
      <tr>
        <td id="L11295" data-line-number="11295"></td>
        <td id="LC11295"><span><span>//</span>    dwThreadId - thread that exception occurred on.</span></td>
      </tr>
      <tr>
        <td id="L11296" data-line-number="11296"></td>
        <td id="LC11296"><span><span>//</span>    pCallback - callback to dispatch potential managed events on.</span></td>
      </tr>
      <tr>
        <td id="L11297" data-line-number="11297"></td>
        <td id="LC11297"><span><span>//</span>    pContinueStatus - Continuation status for exception. This dictates what</span></td>
      </tr>
      <tr>
        <td id="L11298" data-line-number="11298"></td>
        <td id="LC11298"><span><span>//</span>         to pass to kernel32!ContinueDebugEvent().</span></td>
      </tr>
      <tr>
        <td id="L11299" data-line-number="11299"></td>
        <td id="LC11299"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11300" data-line-number="11300"></td>
        <td id="LC11300"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L11301" data-line-number="11301"></td>
        <td id="LC11301"><span><span>//</span>    S_OK on success.</span></td>
      </tr>
      <tr>
        <td id="L11302" data-line-number="11302"></td>
        <td id="LC11302"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11303" data-line-number="11303"></td>
        <td id="LC11303"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L11304" data-line-number="11304"></td>
        <td id="LC11304"><span><span>//</span>    Target is stopped.</span></td>
      </tr>
      <tr>
        <td id="L11305" data-line-number="11305"></td>
        <td id="LC11305"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11306" data-line-number="11306"></td>
        <td id="LC11306"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L11307" data-line-number="11307"></td>
        <td id="LC11307"><span><span>//</span>    The exception could be anything, including:</span></td>
      </tr>
      <tr>
        <td id="L11308" data-line-number="11308"></td>
        <td id="LC11308"><span><span>//</span>    - a CLR notification,</span></td>
      </tr>
      <tr>
        <td id="L11309" data-line-number="11309"></td>
        <td id="LC11309"><span><span>//</span>    - a random managed exception (both from managed code or the runtime),</span></td>
      </tr>
      <tr>
        <td id="L11310" data-line-number="11310"></td>
        <td id="LC11310"><span><span>//</span>    - a non-CLR exception</span></td>
      </tr>
      <tr>
        <td id="L11311" data-line-number="11311"></td>
        <td id="LC11311"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11312" data-line-number="11312"></td>
        <td id="LC11312"><span><span>//</span>    This is cross-platform. The {pRawRecord, countBytes, format} describe events</span></td>
      </tr>
      <tr>
        <td id="L11313" data-line-number="11313"></td>
        <td id="LC11313"><span><span>//</span>    on an arbitrary target architecture. On windows, this will be an EXCEPTION_RECORD.</span></td>
      </tr>
      <tr>
        <td id="L11314" data-line-number="11314"></td>
        <td id="LC11314"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11315" data-line-number="11315"></td>
        <td id="LC11315">HRESULT <span>CordbProcess::Filter</span>(</td>
      </tr>
      <tr>
        <td id="L11316" data-line-number="11316"></td>
        <td id="LC11316">        <span>const</span> BYTE pRawRecord[],</td>
      </tr>
      <tr>
        <td id="L11317" data-line-number="11317"></td>
        <td id="LC11317">        DWORD countBytes,</td>
      </tr>
      <tr>
        <td id="L11318" data-line-number="11318"></td>
        <td id="LC11318">        CorDebugRecordFormat format,</td>
      </tr>
      <tr>
        <td id="L11319" data-line-number="11319"></td>
        <td id="LC11319">        DWORD dwFlags,</td>
      </tr>
      <tr>
        <td id="L11320" data-line-number="11320"></td>
        <td id="LC11320">        DWORD dwThreadId,</td>
      </tr>
      <tr>
        <td id="L11321" data-line-number="11321"></td>
        <td id="LC11321">        ICorDebugManagedCallback * pCallback,</td>
      </tr>
      <tr>
        <td id="L11322" data-line-number="11322"></td>
        <td id="LC11322">        DWORD * pContinueStatus</td>
      </tr>
      <tr>
        <td id="L11323" data-line-number="11323"></td>
        <td id="LC11323">)</td>
      </tr>
      <tr>
        <td id="L11324" data-line-number="11324"></td>
        <td id="LC11324">{</td>
      </tr>
      <tr>
        <td id="L11325" data-line-number="11325"></td>
        <td id="LC11325">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L11326" data-line-number="11326"></td>
        <td id="LC11326">    <span>PUBLIC_API_BEGIN</span>(<span>this</span>); <span><span>//</span> takes the lock</span></td>
      </tr>
      <tr>
        <td id="L11327" data-line-number="11327"></td>
        <td id="LC11327">    {</td>
      </tr>
      <tr>
        <td id="L11328" data-line-number="11328"></td>
        <td id="LC11328">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11329" data-line-number="11329"></td>
        <td id="LC11329">        <span><span>//</span> Validate parameters</span></td>
      </tr>
      <tr>
        <td id="L11330" data-line-number="11330"></td>
        <td id="LC11330">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11331" data-line-number="11331"></td>
        <td id="LC11331">
</td>
      </tr>
      <tr>
        <td id="L11332" data-line-number="11332"></td>
        <td id="LC11332">        <span><span>//</span> If we don't care about the continue status, we leave it untouched.</span></td>
      </tr>
      <tr>
        <td id="L11333" data-line-number="11333"></td>
        <td id="LC11333">        <span>ValidateOrThrow</span>(pContinueStatus);</td>
      </tr>
      <tr>
        <td id="L11334" data-line-number="11334"></td>
        <td id="LC11334">        <span>ValidateOrThrow</span>(pCallback);</td>
      </tr>
      <tr>
        <td id="L11335" data-line-number="11335"></td>
        <td id="LC11335">
</td>
      </tr>
      <tr>
        <td id="L11336" data-line-number="11336"></td>
        <td id="LC11336">        <span>const</span> EXCEPTION_RECORD * pRecord = <span>ValidateExceptionRecord</span>(pRawRecord, countBytes, format);</td>
      </tr>
      <tr>
        <td id="L11337" data-line-number="11337"></td>
        <td id="LC11337">
</td>
      </tr>
      <tr>
        <td id="L11338" data-line-number="11338"></td>
        <td id="LC11338">        DWORD dwFirstChance = (dwFlags &amp; IS_FIRST_CHANCE);</td>
      </tr>
      <tr>
        <td id="L11339" data-line-number="11339"></td>
        <td id="LC11339">
</td>
      </tr>
      <tr>
        <td id="L11340" data-line-number="11340"></td>
        <td id="LC11340">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11341" data-line-number="11341"></td>
        <td id="LC11341">        <span><span>//</span> Deal with 2nd-chance exceptions. Don't actually hijack now (that's too invasive),</span></td>
      </tr>
      <tr>
        <td id="L11342" data-line-number="11342"></td>
        <td id="LC11342">        <span><span>//</span> but mark that we have the exception in case a future operation (eg, func-eval) needs to hijack.</span></td>
      </tr>
      <tr>
        <td id="L11343" data-line-number="11343"></td>
        <td id="LC11343">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11344" data-line-number="11344"></td>
        <td id="LC11344">        <span>if</span> (!dwFirstChance)</td>
      </tr>
      <tr>
        <td id="L11345" data-line-number="11345"></td>
        <td id="LC11345">        {</td>
      </tr>
      <tr>
        <td id="L11346" data-line-number="11346"></td>
        <td id="LC11346">            CordbThread * pThread = <span>TryLookupOrCreateThreadByVolatileOSId</span>(dwThreadId);</td>
      </tr>
      <tr>
        <td id="L11347" data-line-number="11347"></td>
        <td id="LC11347">
</td>
      </tr>
      <tr>
        <td id="L11348" data-line-number="11348"></td>
        <td id="LC11348">            <span><span>//</span> If we don't have a managed-thread object, then it certainly can't have a throwable.</span></td>
      </tr>
      <tr>
        <td id="L11349" data-line-number="11349"></td>
        <td id="LC11349">            <span><span>//</span> It's possible this is still an exception from the native portion of the runtime,</span></td>
      </tr>
      <tr>
        <td id="L11350" data-line-number="11350"></td>
        <td id="LC11350">            <span><span>//</span> but that's ok, we'll just treat it as a native exception.</span></td>
      </tr>
      <tr>
        <td id="L11351" data-line-number="11351"></td>
        <td id="LC11351">            <span><span>//</span> This could be expensive, don't want to do it often... (definitely not on every Filter).</span></td>
      </tr>
      <tr>
        <td id="L11352" data-line-number="11352"></td>
        <td id="LC11352">
</td>
      </tr>
      <tr>
        <td id="L11353" data-line-number="11353"></td>
        <td id="LC11353">
</td>
      </tr>
      <tr>
        <td id="L11354" data-line-number="11354"></td>
        <td id="LC11354">            <span><span>//</span> OS will not execute the Unhandled Exception Filter under native debugger, so</span></td>
      </tr>
      <tr>
        <td id="L11355" data-line-number="11355"></td>
        <td id="LC11355">            <span><span>//</span> we need to hijack the thread to get it to execute the UEF, which will then do</span></td>
      </tr>
      <tr>
        <td id="L11356" data-line-number="11356"></td>
        <td id="LC11356">            <span><span>//</span> work for unhandled managed exceptions.</span></td>
      </tr>
      <tr>
        <td id="L11357" data-line-number="11357"></td>
        <td id="LC11357">            <span>if</span> ((pThread != <span>NULL</span>) &amp;&amp; pThread-&gt;<span>IsThreadExceptionManaged</span>())</td>
      </tr>
      <tr>
        <td id="L11358" data-line-number="11358"></td>
        <td id="LC11358">            {</td>
      </tr>
      <tr>
        <td id="L11359" data-line-number="11359"></td>
        <td id="LC11359">                <span><span>//</span> Copy exception record for future use in case we decide to hijack.</span></td>
      </tr>
      <tr>
        <td id="L11360" data-line-number="11360"></td>
        <td id="LC11360">                pThread-&gt;<span>SetUnhandledNativeException</span>(pRecord);</td>
      </tr>
      <tr>
        <td id="L11361" data-line-number="11361"></td>
        <td id="LC11361">            }</td>
      </tr>
      <tr>
        <td id="L11362" data-line-number="11362"></td>
        <td id="LC11362">            <span><span>//</span> we don't care about 2nd-chance exceptions, unless we decide to hijack it later.</span></td>
      </tr>
      <tr>
        <td id="L11363" data-line-number="11363"></td>
        <td id="LC11363">        }</td>
      </tr>
      <tr>
        <td id="L11364" data-line-number="11364"></td>
        <td id="LC11364">
</td>
      </tr>
      <tr>
        <td id="L11365" data-line-number="11365"></td>
        <td id="LC11365">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11366" data-line-number="11366"></td>
        <td id="LC11366">        <span><span>//</span> Deal with CLR notifications</span></td>
      </tr>
      <tr>
        <td id="L11367" data-line-number="11367"></td>
        <td id="LC11367">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11368" data-line-number="11368"></td>
        <td id="LC11368">        <span>else</span> <span>if</span> (pRecord-&gt;<span>ExceptionCode</span> == CLRDBG_NOTIFICATION_EXCEPTION_CODE) <span><span>//</span> Special event code</span></td>
      </tr>
      <tr>
        <td id="L11369" data-line-number="11369"></td>
        <td id="LC11369">        {</td>
      </tr>
      <tr>
        <td id="L11370" data-line-number="11370"></td>
        <td id="LC11370">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11371" data-line-number="11371"></td>
        <td id="LC11371">            <span><span>//</span> This may not be for us, or we may not have a managed thread object:</span></td>
      </tr>
      <tr>
        <td id="L11372" data-line-number="11372"></td>
        <td id="LC11372">            <span><span>//</span> 1. Anybody can raise an exception with this exception code, so can't assume this belongs to us yet.</span></td>
      </tr>
      <tr>
        <td id="L11373" data-line-number="11373"></td>
        <td id="LC11373">            <span><span>//</span> 2. Notifications may come on unmanaged threads if they're coming from MDAs or CLR internal events</span></td>
      </tr>
      <tr>
        <td id="L11374" data-line-number="11374"></td>
        <td id="LC11374">            <span><span>//</span>    fired before the thread is created.</span></td>
      </tr>
      <tr>
        <td id="L11375" data-line-number="11375"></td>
        <td id="LC11375">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11376" data-line-number="11376"></td>
        <td id="LC11376">            BYTE * pManagedEventBuffer = <span>new</span> BYTE[CorDBIPC_BUFFER_SIZE];</td>
      </tr>
      <tr>
        <td id="L11377" data-line-number="11377"></td>
        <td id="LC11377">            DeleteIPCEventHolder <span>pManagedEvent</span>(<span>reinterpret_cast</span>&lt;DebuggerIPCEvent *&gt;(pManagedEventBuffer));</td>
      </tr>
      <tr>
        <td id="L11378" data-line-number="11378"></td>
        <td id="LC11378">
</td>
      </tr>
      <tr>
        <td id="L11379" data-line-number="11379"></td>
        <td id="LC11379">            <span>bool</span> <span>fOwner</span> = <span>CopyManagedEventFromTarget</span>(pRecord, pManagedEvent);</td>
      </tr>
      <tr>
        <td id="L11380" data-line-number="11380"></td>
        <td id="LC11380">            <span>if</span> (<span>fOwner</span>)</td>
      </tr>
      <tr>
        <td id="L11381" data-line-number="11381"></td>
        <td id="LC11381">            {</td>
      </tr>
      <tr>
        <td id="L11382" data-line-number="11382"></td>
        <td id="LC11382">                <span><span>//</span> This toggles the lock if it dispatches callbacks</span></td>
      </tr>
      <tr>
        <td id="L11383" data-line-number="11383"></td>
        <td id="LC11383">                <span>FilterClrNotification</span>(pManagedEvent, <span>GET_PUBLIC_LOCK_HOLDER</span>(), pCallback);</td>
      </tr>
      <tr>
        <td id="L11384" data-line-number="11384"></td>
        <td id="LC11384">
</td>
      </tr>
      <tr>
        <td id="L11385" data-line-number="11385"></td>
        <td id="LC11385">                <span><span>//</span> Cancel any notification events from target. These are just supposed to notify ICD and not</span></td>
      </tr>
      <tr>
        <td id="L11386" data-line-number="11386"></td>
        <td id="LC11386">                <span><span>//</span> actually be real exceptions in the target.</span></td>
      </tr>
      <tr>
        <td id="L11387" data-line-number="11387"></td>
        <td id="LC11387">                <span><span>//</span> Canceling here also prevents a VectoredExceptionHandler in the target from picking</span></td>
      </tr>
      <tr>
        <td id="L11388" data-line-number="11388"></td>
        <td id="LC11388">                <span><span>//</span> up exceptions for the CLR.</span></td>
      </tr>
      <tr>
        <td id="L11389" data-line-number="11389"></td>
        <td id="LC11389">                *pContinueStatus = DBG_CONTINUE;</td>
      </tr>
      <tr>
        <td id="L11390" data-line-number="11390"></td>
        <td id="LC11390">            }</td>
      </tr>
      <tr>
        <td id="L11391" data-line-number="11391"></td>
        <td id="LC11391">
</td>
      </tr>
      <tr>
        <td id="L11392" data-line-number="11392"></td>
        <td id="LC11392">            <span><span>//</span> holder will invoke DeleteIPCEventHelper(pManagedEvent).</span></td>
      </tr>
      <tr>
        <td id="L11393" data-line-number="11393"></td>
        <td id="LC11393">        }</td>
      </tr>
      <tr>
        <td id="L11394" data-line-number="11394"></td>
        <td id="LC11394">
</td>
      </tr>
      <tr>
        <td id="L11395" data-line-number="11395"></td>
        <td id="LC11395">    }</td>
      </tr>
      <tr>
        <td id="L11396" data-line-number="11396"></td>
        <td id="LC11396">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L11397" data-line-number="11397"></td>
        <td id="LC11397">    <span><span>//</span> we may not find the correct mscordacwks so fail gracefully</span></td>
      </tr>
      <tr>
        <td id="L11398" data-line-number="11398"></td>
        <td id="LC11398">    <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr) || (hr != <span>HRESULT_FROM_WIN32</span>(ERROR_MOD_NOT_FOUND)));</td>
      </tr>
      <tr>
        <td id="L11399" data-line-number="11399"></td>
        <td id="LC11399">
</td>
      </tr>
      <tr>
        <td id="L11400" data-line-number="11400"></td>
        <td id="LC11400">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L11401" data-line-number="11401"></td>
        <td id="LC11401">}</td>
      </tr>
      <tr>
        <td id="L11402" data-line-number="11402"></td>
        <td id="LC11402">
</td>
      </tr>
      <tr>
        <td id="L11403" data-line-number="11403"></td>
        <td id="LC11403"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11404" data-line-number="11404"></td>
        <td id="LC11404"><span><span>//</span> Wrapper to invoke ICorDebugMutableDataTarget::ContinueStatusChanged</span></td>
      </tr>
      <tr>
        <td id="L11405" data-line-number="11405"></td>
        <td id="LC11405"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11406" data-line-number="11406"></td>
        <td id="LC11406"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L11407" data-line-number="11407"></td>
        <td id="LC11407"><span><span>//</span>   dwContinueStatus - new continue status</span></td>
      </tr>
      <tr>
        <td id="L11408" data-line-number="11408"></td>
        <td id="LC11408"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11409" data-line-number="11409"></td>
        <td id="LC11409"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L11410" data-line-number="11410"></td>
        <td id="LC11410"><span><span>//</span>   None. Throw on error.</span></td>
      </tr>
      <tr>
        <td id="L11411" data-line-number="11411"></td>
        <td id="LC11411"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11412" data-line-number="11412"></td>
        <td id="LC11412"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L11413" data-line-number="11413"></td>
        <td id="LC11413"><span><span>//</span>   Initial continue status is returned from code:CordbProcess::Filter.</span></td>
      </tr>
      <tr>
        <td id="L11414" data-line-number="11414"></td>
        <td id="LC11414"><span><span>//</span>   Some operations (mainly hijacking on a 2nd-chance exception), may need to</span></td>
      </tr>
      <tr>
        <td id="L11415" data-line-number="11415"></td>
        <td id="LC11415"><span><span>//</span>   override that continue status.</span></td>
      </tr>
      <tr>
        <td id="L11416" data-line-number="11416"></td>
        <td id="LC11416"><span><span>//</span>   ICorDebug operations invoke a callback on the data-target to notify the debugger</span></td>
      </tr>
      <tr>
        <td id="L11417" data-line-number="11417"></td>
        <td id="LC11417"><span><span>//</span>   of a change in status. Debugger may fail the request.</span></td>
      </tr>
      <tr>
        <td id="L11418" data-line-number="11418"></td>
        <td id="LC11418"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11419" data-line-number="11419"></td>
        <td id="LC11419"><span>void</span> <span>CordbProcess::ContinueStatusChanged</span>(DWORD dwThreadId, CORDB_CONTINUE_STATUS dwContinueStatus)</td>
      </tr>
      <tr>
        <td id="L11420" data-line-number="11420"></td>
        <td id="LC11420">{</td>
      </tr>
      <tr>
        <td id="L11421" data-line-number="11421"></td>
        <td id="LC11421">    HRESULT hr = m_pMutableDataTarget-&gt;<span>ContinueStatusChanged</span>(dwThreadId, dwContinueStatus);</td>
      </tr>
      <tr>
        <td id="L11422" data-line-number="11422"></td>
        <td id="LC11422">    <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L11423" data-line-number="11423"></td>
        <td id="LC11423">}</td>
      </tr>
      <tr>
        <td id="L11424" data-line-number="11424"></td>
        <td id="LC11424">
</td>
      </tr>
      <tr>
        <td id="L11425" data-line-number="11425"></td>
        <td id="LC11425"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11426" data-line-number="11426"></td>
        <td id="LC11426"><span><span>//</span> Request a synchronization to occur after a debug event is dispatched.</span></td>
      </tr>
      <tr>
        <td id="L11427" data-line-number="11427"></td>
        <td id="LC11427"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11428" data-line-number="11428"></td>
        <td id="LC11428"><span><span>//</span> Note:</span></td>
      </tr>
      <tr>
        <td id="L11429" data-line-number="11429"></td>
        <td id="LC11429"><span><span>//</span>    This is called in response to a managed debug event, and so we know that we have</span></td>
      </tr>
      <tr>
        <td id="L11430" data-line-number="11430"></td>
        <td id="LC11430"><span><span>//</span>    a worker thread in the process (the one that just sent the event!)</span></td>
      </tr>
      <tr>
        <td id="L11431" data-line-number="11431"></td>
        <td id="LC11431"><span><span>//</span>    This can not be called asynchronously.</span></td>
      </tr>
      <tr>
        <td id="L11432" data-line-number="11432"></td>
        <td id="LC11432"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11433" data-line-number="11433"></td>
        <td id="LC11433"><span>void</span> <span>CordbProcess::RequestSyncAtEvent</span>()</td>
      </tr>
      <tr>
        <td id="L11434" data-line-number="11434"></td>
        <td id="LC11434">{</td>
      </tr>
      <tr>
        <td id="L11435" data-line-number="11435"></td>
        <td id="LC11435">    <span>GetDAC</span>()-&gt;<span>RequestSyncAtEvent</span>();</td>
      </tr>
      <tr>
        <td id="L11436" data-line-number="11436"></td>
        <td id="LC11436">}</td>
      </tr>
      <tr>
        <td id="L11437" data-line-number="11437"></td>
        <td id="LC11437">
</td>
      </tr>
      <tr>
        <td id="L11438" data-line-number="11438"></td>
        <td id="LC11438"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11439" data-line-number="11439"></td>
        <td id="LC11439"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11440" data-line-number="11440"></td>
        <td id="LC11440"><span><span>//</span> Primary loop of the Win32 debug event thread.</span></td>
      </tr>
      <tr>
        <td id="L11441" data-line-number="11441"></td>
        <td id="LC11441"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11442" data-line-number="11442"></td>
        <td id="LC11442"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11443" data-line-number="11443"></td>
        <td id="LC11443"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L11444" data-line-number="11444"></td>
        <td id="LC11444"><span><span>//</span>    None.</span></td>
      </tr>
      <tr>
        <td id="L11445" data-line-number="11445"></td>
        <td id="LC11445"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11446" data-line-number="11446"></td>
        <td id="LC11446"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L11447" data-line-number="11447"></td>
        <td id="LC11447"><span><span>//</span>    None.</span></td>
      </tr>
      <tr>
        <td id="L11448" data-line-number="11448"></td>
        <td id="LC11448"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11449" data-line-number="11449"></td>
        <td id="LC11449"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L11450" data-line-number="11450"></td>
        <td id="LC11450"><span><span>//</span>    This is it, you've found it, the main guy.  This function loops as long as the</span></td>
      </tr>
      <tr>
        <td id="L11451" data-line-number="11451"></td>
        <td id="LC11451"><span><span>//</span>    debugger is around calling the OS WaitForDebugEvent() API.  It takes the OS Debug</span></td>
      </tr>
      <tr>
        <td id="L11452" data-line-number="11452"></td>
        <td id="LC11452"><span><span>//</span>    Event and filters it thru the right-side, continuing the process if not recognized.</span></td>
      </tr>
      <tr>
        <td id="L11453" data-line-number="11453"></td>
        <td id="LC11453"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11454" data-line-number="11454"></td>
        <td id="LC11454"><span><span>//</span> @dbgtodo shim: this will become part of the shim.</span></td>
      </tr>
      <tr>
        <td id="L11455" data-line-number="11455"></td>
        <td id="LC11455"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11456" data-line-number="11456"></td>
        <td id="LC11456"><span>void</span> <span>CordbWin32EventThread::Win32EventLoop</span>()</td>
      </tr>
      <tr>
        <td id="L11457" data-line-number="11457"></td>
        <td id="LC11457">{</td>
      </tr>
      <tr>
        <td id="L11458" data-line-number="11458"></td>
        <td id="LC11458">    <span><span>//</span> This must be called from the win32 event thread.</span></td>
      </tr>
      <tr>
        <td id="L11459" data-line-number="11459"></td>
        <td id="LC11459">    <span>_ASSERTE</span>(<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L11460" data-line-number="11460"></td>
        <td id="LC11460">
</td>
      </tr>
      <tr>
        <td id="L11461" data-line-number="11461"></td>
        <td id="LC11461">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: entered win32 event loop<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L11462" data-line-number="11462"></td>
        <td id="LC11462">
</td>
      </tr>
      <tr>
        <td id="L11463" data-line-number="11463"></td>
        <td id="LC11463">
</td>
      </tr>
      <tr>
        <td id="L11464" data-line-number="11464"></td>
        <td id="LC11464">    DEBUG_EVENT event;</td>
      </tr>
      <tr>
        <td id="L11465" data-line-number="11465"></td>
        <td id="LC11465">
</td>
      </tr>
      <tr>
        <td id="L11466" data-line-number="11466"></td>
        <td id="LC11466">    <span><span>//</span> Allow the timeout for WFDE to be adjustable. Default to 25 ms based off perf numbers (see issue VSWhidbey 132368).</span></td>
      </tr>
      <tr>
        <td id="L11467" data-line-number="11467"></td>
        <td id="LC11467">    DWORD dwWFDETimeout = <span>CLRConfig::GetConfigValue</span>(CLRConfig::UNSUPPORTED_DbgWFDETimeout);</td>
      </tr>
      <tr>
        <td id="L11468" data-line-number="11468"></td>
        <td id="LC11468">
</td>
      </tr>
      <tr>
        <td id="L11469" data-line-number="11469"></td>
        <td id="LC11469">    <span>while</span> (m_run)</td>
      </tr>
      <tr>
        <td id="L11470" data-line-number="11470"></td>
        <td id="LC11470">    {</td>
      </tr>
      <tr>
        <td id="L11471" data-line-number="11471"></td>
        <td id="LC11471">        BOOL <span>fEventAvailable</span> = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L11472" data-line-number="11472"></td>
        <td id="LC11472">
</td>
      </tr>
      <tr>
        <td id="L11473" data-line-number="11473"></td>
        <td id="LC11473">        <span><span>//</span> We should not have any locks right now.</span></td>
      </tr>
      <tr>
        <td id="L11474" data-line-number="11474"></td>
        <td id="LC11474">
</td>
      </tr>
      <tr>
        <td id="L11475" data-line-number="11475"></td>
        <td id="LC11475">
</td>
      </tr>
      <tr>
        <td id="L11476" data-line-number="11476"></td>
        <td id="LC11476">        <span><span>//</span> Have to wait on 2 sources:</span></td>
      </tr>
      <tr>
        <td id="L11477" data-line-number="11477"></td>
        <td id="LC11477">        <span><span>//</span> WaitForMultipleObjects - ping for messages (create, attach, Continue, detach) and also</span></td>
      </tr>
      <tr>
        <td id="L11478" data-line-number="11478"></td>
        <td id="LC11478">        <span><span>//</span>    process exits in the managed-only case.</span></td>
      </tr>
      <tr>
        <td id="L11479" data-line-number="11479"></td>
        <td id="LC11479">        <span><span>//</span> Native Debug Events - This is a huge perf hit so we want to avoid it whenever we can.</span></td>
      </tr>
      <tr>
        <td id="L11480" data-line-number="11480"></td>
        <td id="LC11480">        <span><span>//</span>    Only wait on these if we're interop debugging and if the process is not frozen.</span></td>
      </tr>
      <tr>
        <td id="L11481" data-line-number="11481"></td>
        <td id="LC11481">        <span><span>//</span>    A frozen process can't send any debug events, so don't bother looking for them.</span></td>
      </tr>
      <tr>
        <td id="L11482" data-line-number="11482"></td>
        <td id="LC11482">
</td>
      </tr>
      <tr>
        <td id="L11483" data-line-number="11483"></td>
        <td id="LC11483">
</td>
      </tr>
      <tr>
        <td id="L11484" data-line-number="11484"></td>
        <td id="LC11484">        <span>unsigned</span> <span>int</span> cWaitCount = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L11485" data-line-number="11485"></td>
        <td id="LC11485">
</td>
      </tr>
      <tr>
        <td id="L11486" data-line-number="11486"></td>
        <td id="LC11486">        HANDLE rghWaitSet[<span>2</span>];</td>
      </tr>
      <tr>
        <td id="L11487" data-line-number="11487"></td>
        <td id="LC11487">
</td>
      </tr>
      <tr>
        <td id="L11488" data-line-number="11488"></td>
        <td id="LC11488">        rghWaitSet[<span>0</span>] = m_threadControlEvent;</td>
      </tr>
      <tr>
        <td id="L11489" data-line-number="11489"></td>
        <td id="LC11489">
</td>
      </tr>
      <tr>
        <td id="L11490" data-line-number="11490"></td>
        <td id="LC11490">        DWORD dwWaitTimeout = INFINITE;</td>
      </tr>
      <tr>
        <td id="L11491" data-line-number="11491"></td>
        <td id="LC11491">
</td>
      </tr>
      <tr>
        <td id="L11492" data-line-number="11492"></td>
        <td id="LC11492">        <span>if</span> (m_pProcess != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L11493" data-line-number="11493"></td>
        <td id="LC11493">        {</td>
      </tr>
      <tr>
        <td id="L11494" data-line-number="11494"></td>
        <td id="LC11494">            <span><span>//</span> Process is always built on Native debugging pipeline, so it needs to always be prepared to call WFDE</span></td>
      </tr>
      <tr>
        <td id="L11495" data-line-number="11495"></td>
        <td id="LC11495">            <span><span>//</span> As an optimization, if the target is stopped, then we can avoid calling WFDE.</span></td>
      </tr>
      <tr>
        <td id="L11496" data-line-number="11496"></td>
        <td id="LC11496">            {</td>
      </tr>
      <tr>
        <td id="L11497" data-line-number="11497"></td>
        <td id="LC11497">#<span>ifndef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L11498" data-line-number="11498"></td>
        <td id="LC11498">                <span><span>//</span> Managed-only, never win32 stopped, so always check for an event.</span></td>
      </tr>
      <tr>
        <td id="L11499" data-line-number="11499"></td>
        <td id="LC11499">                dwWaitTimeout = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L11500" data-line-number="11500"></td>
        <td id="LC11500">                <span>fEventAvailable</span> = m_pNativePipeline-&gt;<span>WaitForDebugEvent</span>(&amp;event, dwWFDETimeout, m_pProcess);</td>
      </tr>
      <tr>
        <td id="L11501" data-line-number="11501"></td>
        <td id="LC11501">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L11502" data-line-number="11502"></td>
        <td id="LC11502">                <span><span>//</span> Wait for a Win32 debug event from any processes that we may be attached to as the Win32 debugger.</span></td>
      </tr>
      <tr>
        <td id="L11503" data-line-number="11503"></td>
        <td id="LC11503">                <span>const</span> <span>bool</span> <span>fIsWin32Stopped</span> = (m_pProcess-&gt;<span>m_state</span> &amp; CordbProcess::PS_WIN32_STOPPED) != <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L11504" data-line-number="11504"></td>
        <td id="LC11504">                <span>const</span> <span>bool</span> <span>fSkipWFDE</span> = <span>fIsWin32Stopped</span>;</td>
      </tr>
      <tr>
        <td id="L11505" data-line-number="11505"></td>
        <td id="LC11505">
</td>
      </tr>
      <tr>
        <td id="L11506" data-line-number="11506"></td>
        <td id="LC11506">
</td>
      </tr>
      <tr>
        <td id="L11507" data-line-number="11507"></td>
        <td id="LC11507">                <span>const</span> <span>bool</span> <span>fIsInteropDebugging</span> = m_pProcess-&gt;<span>IsInteropDebugging</span>();</td>
      </tr>
      <tr>
        <td id="L11508" data-line-number="11508"></td>
        <td id="LC11508">                (<span>void</span>)<span>fIsInteropDebugging</span>; <span><span>//</span>prevent "unused variable" error from GCC</span></td>
      </tr>
      <tr>
        <td id="L11509" data-line-number="11509"></td>
        <td id="LC11509">
</td>
      </tr>
      <tr>
        <td id="L11510" data-line-number="11510"></td>
        <td id="LC11510">                <span><span>//</span> Assert checks</span></td>
      </tr>
      <tr>
        <td id="L11511" data-line-number="11511"></td>
        <td id="LC11511">                <span>_ASSERTE</span>(<span>fIsInteropDebugging</span> == m_pShim-&gt;<span>IsInteropDebugging</span>());</td>
      </tr>
      <tr>
        <td id="L11512" data-line-number="11512"></td>
        <td id="LC11512">
</td>
      </tr>
      <tr>
        <td id="L11513" data-line-number="11513"></td>
        <td id="LC11513">                <span>if</span> (!<span>fSkipWFDE</span>)</td>
      </tr>
      <tr>
        <td id="L11514" data-line-number="11514"></td>
        <td id="LC11514">                {</td>
      </tr>
      <tr>
        <td id="L11515" data-line-number="11515"></td>
        <td id="LC11515">                    dwWaitTimeout = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L11516" data-line-number="11516"></td>
        <td id="LC11516">                    <span>fEventAvailable</span> = m_pNativePipeline-&gt;<span>WaitForDebugEvent</span>(&amp;event, dwWFDETimeout, m_pProcess);</td>
      </tr>
      <tr>
        <td id="L11517" data-line-number="11517"></td>
        <td id="LC11517">                }</td>
      </tr>
      <tr>
        <td id="L11518" data-line-number="11518"></td>
        <td id="LC11518">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L11519" data-line-number="11519"></td>
        <td id="LC11519">                {</td>
      </tr>
      <tr>
        <td id="L11520" data-line-number="11520"></td>
        <td id="LC11520">                    <span><span>//</span> If we're managed-only debugging, then the process should always be running,</span></td>
      </tr>
      <tr>
        <td id="L11521" data-line-number="11521"></td>
        <td id="LC11521">                    <span><span>//</span> which means we always need to be calling WFDE to pump potential debug events.</span></td>
      </tr>
      <tr>
        <td id="L11522" data-line-number="11522"></td>
        <td id="LC11522">                    <span><span>//</span> If we're interop-debugging, then the process can be stopped at a native-debug event,</span></td>
      </tr>
      <tr>
        <td id="L11523" data-line-number="11523"></td>
        <td id="LC11523">                    <span><span>//</span> in which case we don't have to call WFDE until we resume it again.</span></td>
      </tr>
      <tr>
        <td id="L11524" data-line-number="11524"></td>
        <td id="LC11524">                    <span><span>//</span> So we can only skip the WFDE when we're interop-debugging.</span></td>
      </tr>
      <tr>
        <td id="L11525" data-line-number="11525"></td>
        <td id="LC11525">                    <span>_ASSERTE</span>(<span>fIsInteropDebugging</span>);</td>
      </tr>
      <tr>
        <td id="L11526" data-line-number="11526"></td>
        <td id="LC11526">                }</td>
      </tr>
      <tr>
        <td id="L11527" data-line-number="11527"></td>
        <td id="LC11527">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L11528" data-line-number="11528"></td>
        <td id="LC11528">            }</td>
      </tr>
      <tr>
        <td id="L11529" data-line-number="11529"></td>
        <td id="LC11529">
</td>
      </tr>
      <tr>
        <td id="L11530" data-line-number="11530"></td>
        <td id="LC11530">
</td>
      </tr>
      <tr>
        <td id="L11531" data-line-number="11531"></td>
        <td id="LC11531">        } <span><span>//</span> end m_pProcess != NULL</span></td>
      </tr>
      <tr>
        <td id="L11532" data-line-number="11532"></td>
        <td id="LC11532">
</td>
      </tr>
      <tr>
        <td id="L11533" data-line-number="11533"></td>
        <td id="LC11533">#<span>if</span> defined(FEATURE_INTEROP_DEBUGGING)</td>
      </tr>
      <tr>
        <td id="L11534" data-line-number="11534"></td>
        <td id="LC11534">        <span><span>//</span> While interop-debugging, the process may get killed rudely underneath us, even if we haven't</span></td>
      </tr>
      <tr>
        <td id="L11535" data-line-number="11535"></td>
        <td id="LC11535">        <span><span>//</span> continued the last debug event. In such cases, The process object will get signalled normally.</span></td>
      </tr>
      <tr>
        <td id="L11536" data-line-number="11536"></td>
        <td id="LC11536">        <span><span>//</span> If we didn't just get a native-exitProcess event, then listen on the process handle for exit.</span></td>
      </tr>
      <tr>
        <td id="L11537" data-line-number="11537"></td>
        <td id="LC11537">        <span><span>//</span> (this includes all managed-only debugging)</span></td>
      </tr>
      <tr>
        <td id="L11538" data-line-number="11538"></td>
        <td id="LC11538">        <span><span>//</span> It's very important to establish this before we go into the WaitForMutlipleObjects below</span></td>
      </tr>
      <tr>
        <td id="L11539" data-line-number="11539"></td>
        <td id="LC11539">        <span><span>//</span> because the debuggee may exit while we're sitting in that loop (waiting for the debugger to call Continue).</span></td>
      </tr>
      <tr>
        <td id="L11540" data-line-number="11540"></td>
        <td id="LC11540">        <span>bool</span> <span>fDidNotJustGetExitProcessEvent</span> = !<span>fEventAvailable</span> || (event.<span>dwDebugEventCode</span> != EXIT_PROCESS_DEBUG_EVENT);</td>
      </tr>
      <tr>
        <td id="L11541" data-line-number="11541"></td>
        <td id="LC11541">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L11542" data-line-number="11542"></td>
        <td id="LC11542">        <span><span>//</span> In non-interop scenarios, we'll never get any native debug events, let alone an ExitProcess native event.</span></td>
      </tr>
      <tr>
        <td id="L11543" data-line-number="11543"></td>
        <td id="LC11543">        <span>bool</span> <span>fDidNotJustGetExitProcessEvent</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L11544" data-line-number="11544"></td>
        <td id="LC11544">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L11545" data-line-number="11545"></td>
        <td id="LC11545">
</td>
      </tr>
      <tr>
        <td id="L11546" data-line-number="11546"></td>
        <td id="LC11546">
</td>
      </tr>
      <tr>
        <td id="L11547" data-line-number="11547"></td>
        <td id="LC11547">        <span><span>//</span> The m_pProcess handle will get nulled out after we process the ExitProcess event, and</span></td>
      </tr>
      <tr>
        <td id="L11548" data-line-number="11548"></td>
        <td id="LC11548">        <span><span>//</span> that will ensure that we only wait for an Exit event once.</span></td>
      </tr>
      <tr>
        <td id="L11549" data-line-number="11549"></td>
        <td id="LC11549">        <span>if</span> ((m_pProcess != <span>NULL</span>) &amp;&amp; <span>fDidNotJustGetExitProcessEvent</span>)</td>
      </tr>
      <tr>
        <td id="L11550" data-line-number="11550"></td>
        <td id="LC11550">        {</td>
      </tr>
      <tr>
        <td id="L11551" data-line-number="11551"></td>
        <td id="LC11551">            rghWaitSet[<span>1</span>] = m_pProcess-&gt;<span>UnsafeGetProcessHandle</span>();</td>
      </tr>
      <tr>
        <td id="L11552" data-line-number="11552"></td>
        <td id="LC11552">            cWaitCount = <span>2</span>;</td>
      </tr>
      <tr>
        <td id="L11553" data-line-number="11553"></td>
        <td id="LC11553">        }</td>
      </tr>
      <tr>
        <td id="L11554" data-line-number="11554"></td>
        <td id="LC11554">
</td>
      </tr>
      <tr>
        <td id="L11555" data-line-number="11555"></td>
        <td id="LC11555">        <span><span>//</span> See if any process that we aren't attached to as the Win32 debugger have exited. (Note: this is a</span></td>
      </tr>
      <tr>
        <td id="L11556" data-line-number="11556"></td>
        <td id="LC11556">        <span><span>//</span> polling action if we are also waiting for Win32 debugger events. We're also looking at the thread</span></td>
      </tr>
      <tr>
        <td id="L11557" data-line-number="11557"></td>
        <td id="LC11557">        <span><span>//</span> control event here, too, to see if we're supposed to do something, like attach.</span></td>
      </tr>
      <tr>
        <td id="L11558" data-line-number="11558"></td>
        <td id="LC11558">        DWORD dwStatus = <span>WaitForMultipleObjectsEx</span>(cWaitCount, rghWaitSet, <span>FALSE</span>, dwWaitTimeout, <span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L11559" data-line-number="11559"></td>
        <td id="LC11559">
</td>
      </tr>
      <tr>
        <td id="L11560" data-line-number="11560"></td>
        <td id="LC11560">        <span>_ASSERTE</span>((dwStatus == WAIT_TIMEOUT) || (dwStatus &lt; cWaitCount));</td>
      </tr>
      <tr>
        <td id="L11561" data-line-number="11561"></td>
        <td id="LC11561">
</td>
      </tr>
      <tr>
        <td id="L11562" data-line-number="11562"></td>
        <td id="LC11562">        <span>if</span> (!m_run)</td>
      </tr>
      <tr>
        <td id="L11563" data-line-number="11563"></td>
        <td id="LC11563">        {</td>
      </tr>
      <tr>
        <td id="L11564" data-line-number="11564"></td>
        <td id="LC11564">            <span>_ASSERTE</span>(m_action == W32ETA_NONE);</td>
      </tr>
      <tr>
        <td id="L11565" data-line-number="11565"></td>
        <td id="LC11565">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L11566" data-line-number="11566"></td>
        <td id="LC11566">        }</td>
      </tr>
      <tr>
        <td id="L11567" data-line-number="11567"></td>
        <td id="LC11567">
</td>
      </tr>
      <tr>
        <td id="L11568" data-line-number="11568"></td>
        <td id="LC11568">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::W32EL - got event , ret=%d, has w32 dbg event=%d<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L11569" data-line-number="11569"></td>
        <td id="LC11569">             dwStatus, <span>fEventAvailable</span>));</td>
      </tr>
      <tr>
        <td id="L11570" data-line-number="11570"></td>
        <td id="LC11570">
</td>
      </tr>
      <tr>
        <td id="L11571" data-line-number="11571"></td>
        <td id="LC11571">        <span><span>//</span> If we haven't timed out, or if it wasn't the thread control event</span></td>
      </tr>
      <tr>
        <td id="L11572" data-line-number="11572"></td>
        <td id="LC11572">        <span><span>//</span> that was set, then a process has</span></td>
      </tr>
      <tr>
        <td id="L11573" data-line-number="11573"></td>
        <td id="LC11573">        <span><span>//</span> exited...</span></td>
      </tr>
      <tr>
        <td id="L11574" data-line-number="11574"></td>
        <td id="LC11574">        <span>if</span> ((dwStatus != WAIT_TIMEOUT) &amp;&amp; (dwStatus != WAIT_OBJECT_0))</td>
      </tr>
      <tr>
        <td id="L11575" data-line-number="11575"></td>
        <td id="LC11575">        {</td>
      </tr>
      <tr>
        <td id="L11576" data-line-number="11576"></td>
        <td id="LC11576">            <span><span>//</span> Grab the process that exited.</span></td>
      </tr>
      <tr>
        <td id="L11577" data-line-number="11577"></td>
        <td id="LC11577">            <span>_ASSERTE</span>((dwStatus - WAIT_OBJECT_0) == <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L11578" data-line-number="11578"></td>
        <td id="LC11578">            <span>ExitProcess</span>(<span>false</span>); <span><span>//</span> not detach</span></td>
      </tr>
      <tr>
        <td id="L11579" data-line-number="11579"></td>
        <td id="LC11579">            <span>fEventAvailable</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L11580" data-line-number="11580"></td>
        <td id="LC11580">        }</td>
      </tr>
      <tr>
        <td id="L11581" data-line-number="11581"></td>
        <td id="LC11581">        <span><span>//</span> Should we create a process?</span></td>
      </tr>
      <tr>
        <td id="L11582" data-line-number="11582"></td>
        <td id="LC11582">        <span>else</span> <span>if</span> (m_action == W32ETA_CREATE_PROCESS)</td>
      </tr>
      <tr>
        <td id="L11583" data-line-number="11583"></td>
        <td id="LC11583">        {</td>
      </tr>
      <tr>
        <td id="L11584" data-line-number="11584"></td>
        <td id="LC11584">            <span>CreateProcess</span>();</td>
      </tr>
      <tr>
        <td id="L11585" data-line-number="11585"></td>
        <td id="LC11585">        }</td>
      </tr>
      <tr>
        <td id="L11586" data-line-number="11586"></td>
        <td id="LC11586">        <span><span>//</span> Should we attach to a process?</span></td>
      </tr>
      <tr>
        <td id="L11587" data-line-number="11587"></td>
        <td id="LC11587">        <span>else</span> <span>if</span> (m_action == W32ETA_ATTACH_PROCESS)</td>
      </tr>
      <tr>
        <td id="L11588" data-line-number="11588"></td>
        <td id="LC11588">        {</td>
      </tr>
      <tr>
        <td id="L11589" data-line-number="11589"></td>
        <td id="LC11589">            <span>AttachProcess</span>();</td>
      </tr>
      <tr>
        <td id="L11590" data-line-number="11590"></td>
        <td id="LC11590">        }</td>
      </tr>
      <tr>
        <td id="L11591" data-line-number="11591"></td>
        <td id="LC11591">        <span><span>//</span> Should we detach from a process?</span></td>
      </tr>
      <tr>
        <td id="L11592" data-line-number="11592"></td>
        <td id="LC11592">        <span>else</span> <span>if</span> (m_action == W32ETA_DETACH)</td>
      </tr>
      <tr>
        <td id="L11593" data-line-number="11593"></td>
        <td id="LC11593">        {</td>
      </tr>
      <tr>
        <td id="L11594" data-line-number="11594"></td>
        <td id="LC11594">            <span>ExitProcess</span>(<span>true</span>); <span><span>//</span> detach case</span></td>
      </tr>
      <tr>
        <td id="L11595" data-line-number="11595"></td>
        <td id="LC11595">
</td>
      </tr>
      <tr>
        <td id="L11596" data-line-number="11596"></td>
        <td id="LC11596">            <span><span>//</span> Once we detach, we don't need to continue any outstanding event.</span></td>
      </tr>
      <tr>
        <td id="L11597" data-line-number="11597"></td>
        <td id="LC11597">            <span><span>//</span> So act like we never got the event.</span></td>
      </tr>
      <tr>
        <td id="L11598" data-line-number="11598"></td>
        <td id="LC11598">            <span>fEventAvailable</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L11599" data-line-number="11599"></td>
        <td id="LC11599">            <span>PREFIX_ASSUME</span>(m_pProcess == <span>NULL</span>); <span><span>//</span> W32 cleared process pointer</span></td>
      </tr>
      <tr>
        <td id="L11600" data-line-number="11600"></td>
        <td id="LC11600">        }</td>
      </tr>
      <tr>
        <td id="L11601" data-line-number="11601"></td>
        <td id="LC11601">
</td>
      </tr>
      <tr>
        <td id="L11602" data-line-number="11602"></td>
        <td id="LC11602">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L11603" data-line-number="11603"></td>
        <td id="LC11603">        <span><span>//</span> Should we continue the process?</span></td>
      </tr>
      <tr>
        <td id="L11604" data-line-number="11604"></td>
        <td id="LC11604">        <span>else</span> <span>if</span> (m_action == W32ETA_CONTINUE)</td>
      </tr>
      <tr>
        <td id="L11605" data-line-number="11605"></td>
        <td id="LC11605">        {</td>
      </tr>
      <tr>
        <td id="L11606" data-line-number="11606"></td>
        <td id="LC11606">            <span>HandleUnmanagedContinue</span>();</td>
      </tr>
      <tr>
        <td id="L11607" data-line-number="11607"></td>
        <td id="LC11607">        }</td>
      </tr>
      <tr>
        <td id="L11608" data-line-number="11608"></td>
        <td id="LC11608">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L11609" data-line-number="11609"></td>
        <td id="LC11609">
</td>
      </tr>
      <tr>
        <td id="L11610" data-line-number="11610"></td>
        <td id="LC11610">        <span><span>//</span> We don't need to sweep the FCH threads since we never hijack a thread in cooperative mode.</span></td>
      </tr>
      <tr>
        <td id="L11611" data-line-number="11611"></td>
        <td id="LC11611">
</td>
      </tr>
      <tr>
        <td id="L11612" data-line-number="11612"></td>
        <td id="LC11612">
</td>
      </tr>
      <tr>
        <td id="L11613" data-line-number="11613"></td>
        <td id="LC11613">        <span><span>//</span> Only process an event if one is available.</span></td>
      </tr>
      <tr>
        <td id="L11614" data-line-number="11614"></td>
        <td id="LC11614">        <span>if</span> (!<span>fEventAvailable</span>)</td>
      </tr>
      <tr>
        <td id="L11615" data-line-number="11615"></td>
        <td id="LC11615">        {</td>
      </tr>
      <tr>
        <td id="L11616" data-line-number="11616"></td>
        <td id="LC11616">            <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L11617" data-line-number="11617"></td>
        <td id="LC11617">        }</td>
      </tr>
      <tr>
        <td id="L11618" data-line-number="11618"></td>
        <td id="LC11618">
</td>
      </tr>
      <tr>
        <td id="L11619" data-line-number="11619"></td>
        <td id="LC11619">        <span><span>//</span> The only ref we have is the one in the ProcessList hash;</span></td>
      </tr>
      <tr>
        <td id="L11620" data-line-number="11620"></td>
        <td id="LC11620">        <span><span>//</span> If we dispatch an ExitProcess event, we may even lose that.</span></td>
      </tr>
      <tr>
        <td id="L11621" data-line-number="11621"></td>
        <td id="LC11621">        <span><span>//</span> But since the CordbProcess is our parent object, we know it won't go away until</span></td>
      </tr>
      <tr>
        <td id="L11622" data-line-number="11622"></td>
        <td id="LC11622">        <span><span>//</span> it neuters us, so we can safely proceed.</span></td>
      </tr>
      <tr>
        <td id="L11623" data-line-number="11623"></td>
        <td id="LC11623">        <span><span>//</span> Find the process this event is for.</span></td>
      </tr>
      <tr>
        <td id="L11624" data-line-number="11624"></td>
        <td id="LC11624">        <span>PREFIX_ASSUME</span>(m_pProcess != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L11625" data-line-number="11625"></td>
        <td id="LC11625">        <span>_ASSERTE</span>(m_pProcess-&gt;<span>m_id</span> == <span>GetProcessId</span>(&amp;event)); <span><span>//</span> should only get events for our proc</span></td>
      </tr>
      <tr>
        <td id="L11626" data-line-number="11626"></td>
        <td id="LC11626">        g_pRSDebuggingInfo-&gt;<span>m_MRUprocess</span> = m_pProcess;</td>
      </tr>
      <tr>
        <td id="L11627" data-line-number="11627"></td>
        <td id="LC11627">
</td>
      </tr>
      <tr>
        <td id="L11628" data-line-number="11628"></td>
        <td id="LC11628">        <span><span>//</span> Must flush the dac cache since we were just running.</span></td>
      </tr>
      <tr>
        <td id="L11629" data-line-number="11629"></td>
        <td id="LC11629">        m_pProcess-&gt;<span>ForceDacFlush</span>();</td>
      </tr>
      <tr>
        <td id="L11630" data-line-number="11630"></td>
        <td id="LC11630">
</td>
      </tr>
      <tr>
        <td id="L11631" data-line-number="11631"></td>
        <td id="LC11631">        <span><span>//</span> So we've filtered out CLR events.</span></td>
      </tr>
      <tr>
        <td id="L11632" data-line-number="11632"></td>
        <td id="LC11632">        <span><span>//</span> Let the shim handle the remaining events. This will call back into Filter() if appropriate.</span></td>
      </tr>
      <tr>
        <td id="L11633" data-line-number="11633"></td>
        <td id="LC11633">        <span><span>//</span> This will also ensure the debug event gets continued.</span></td>
      </tr>
      <tr>
        <td id="L11634" data-line-number="11634"></td>
        <td id="LC11634">        HRESULT hrShim = S_OK;</td>
      </tr>
      <tr>
        <td id="L11635" data-line-number="11635"></td>
        <td id="LC11635">        {</td>
      </tr>
      <tr>
        <td id="L11636" data-line-number="11636"></td>
        <td id="LC11636">            <span>PUBLIC_CALLBACK_IN_THIS_SCOPE0_NO_LOCK</span>(<span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L11637" data-line-number="11637"></td>
        <td id="LC11637">            hrShim = m_pShim-&gt;<span>HandleWin32DebugEvent</span>(&amp;event);</td>
      </tr>
      <tr>
        <td id="L11638" data-line-number="11638"></td>
        <td id="LC11638">        }</td>
      </tr>
      <tr>
        <td id="L11639" data-line-number="11639"></td>
        <td id="LC11639">        <span><span>//</span> Any errors from the shim (eg. failure to load DAC) are unrecoverable</span></td>
      </tr>
      <tr>
        <td id="L11640" data-line-number="11640"></td>
        <td id="LC11640">        <span>SetUnrecoverableIfFailed</span>(m_pProcess, hrShim);</td>
      </tr>
      <tr>
        <td id="L11641" data-line-number="11641"></td>
        <td id="LC11641">
</td>
      </tr>
      <tr>
        <td id="L11642" data-line-number="11642"></td>
        <td id="LC11642">    } <span><span>//</span> loop</span></td>
      </tr>
      <tr>
        <td id="L11643" data-line-number="11643"></td>
        <td id="LC11643">
</td>
      </tr>
      <tr>
        <td id="L11644" data-line-number="11644"></td>
        <td id="LC11644">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: exiting event loop<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L11645" data-line-number="11645"></td>
        <td id="LC11645">
</td>
      </tr>
      <tr>
        <td id="L11646" data-line-number="11646"></td>
        <td id="LC11646">    <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L11647" data-line-number="11647"></td>
        <td id="LC11647">}</td>
      </tr>
      <tr>
        <td id="L11648" data-line-number="11648"></td>
        <td id="LC11648">
</td>
      </tr>
      <tr>
        <td id="L11649" data-line-number="11649"></td>
        <td id="LC11649"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11650" data-line-number="11650"></td>
        <td id="LC11650"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11651" data-line-number="11651"></td>
        <td id="LC11651"><span><span>//</span> Returns if the current thread is the win32 thread.</span></td>
      </tr>
      <tr>
        <td id="L11652" data-line-number="11652"></td>
        <td id="LC11652"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11653" data-line-number="11653"></td>
        <td id="LC11653"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L11654" data-line-number="11654"></td>
        <td id="LC11654"><span><span>//</span>    true iff this is the win32 event thread.</span></td>
      </tr>
      <tr>
        <td id="L11655" data-line-number="11655"></td>
        <td id="LC11655"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11656" data-line-number="11656"></td>
        <td id="LC11656"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11657" data-line-number="11657"></td>
        <td id="LC11657"><span>bool</span> <span>CordbProcess::IsWin32EventThread</span>()</td>
      </tr>
      <tr>
        <td id="L11658" data-line-number="11658"></td>
        <td id="LC11658">{</td>
      </tr>
      <tr>
        <td id="L11659" data-line-number="11659"></td>
        <td id="LC11659">    <span>_ASSERTE</span>((m_pShim != <span>NULL</span>) || !<span><span>"</span>Don't check win32 event thread in V3 cases<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L11660" data-line-number="11660"></td>
        <td id="LC11660">    <span>return</span> m_pShim-&gt;<span>IsWin32EventThread</span>();</td>
      </tr>
      <tr>
        <td id="L11661" data-line-number="11661"></td>
        <td id="LC11661">}</td>
      </tr>
      <tr>
        <td id="L11662" data-line-number="11662"></td>
        <td id="LC11662">
</td>
      </tr>
      <tr>
        <td id="L11663" data-line-number="11663"></td>
        <td id="LC11663"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11664" data-line-number="11664"></td>
        <td id="LC11664"><span><span>//</span> Call when the sync complete event is received and can be processed.</span></td>
      </tr>
      <tr>
        <td id="L11665" data-line-number="11665"></td>
        <td id="LC11665"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11666" data-line-number="11666"></td>
        <td id="LC11666"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L11667" data-line-number="11667"></td>
        <td id="LC11667"><span><span>//</span>    This is called when the RS gets the sync-complete from the LS and can process it.</span></td>
      </tr>
      <tr>
        <td id="L11668" data-line-number="11668"></td>
        <td id="LC11668"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11669" data-line-number="11669"></td>
        <td id="LC11669"><span><span>//</span>    This has a somewhat elaborate contract to fill between Interop-debugging, Async-Break, draining the</span></td>
      </tr>
      <tr>
        <td id="L11670" data-line-number="11670"></td>
        <td id="LC11670"><span><span>//</span>    managed event-queue, and coordinating with the dispatch thread (RCET).</span></td>
      </tr>
      <tr>
        <td id="L11671" data-line-number="11671"></td>
        <td id="LC11671"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11672" data-line-number="11672"></td>
        <td id="LC11672"><span><span>//</span>    @dbgtodo - this should eventually get hoisted into the shim.</span></td>
      </tr>
      <tr>
        <td id="L11673" data-line-number="11673"></td>
        <td id="LC11673"><span>void</span> <span>CordbProcess::HandleSyncCompleteRecieved</span>()</td>
      </tr>
      <tr>
        <td id="L11674" data-line-number="11674"></td>
        <td id="LC11674">{</td>
      </tr>
      <tr>
        <td id="L11675" data-line-number="11675"></td>
        <td id="LC11675">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L11676" data-line-number="11676"></td>
        <td id="LC11676">
</td>
      </tr>
      <tr>
        <td id="L11677" data-line-number="11677"></td>
        <td id="LC11677">    <span>this</span>-&gt;<span>SetSyncCompleteRecv</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L11678" data-line-number="11678"></td>
        <td id="LC11678">
</td>
      </tr>
      <tr>
        <td id="L11679" data-line-number="11679"></td>
        <td id="LC11679">    <span><span>//</span> If some thread is waiting for the process to sync, notify that it can go now.</span></td>
      </tr>
      <tr>
        <td id="L11680" data-line-number="11680"></td>
        <td id="LC11680">    <span>if</span> (<span>this</span>-&gt;<span>m_stopRequested</span>)</td>
      </tr>
      <tr>
        <td id="L11681" data-line-number="11681"></td>
        <td id="LC11681">    {</td>
      </tr>
      <tr>
        <td id="L11682" data-line-number="11682"></td>
        <td id="LC11682">        <span>this</span>-&gt;<span>SetSynchronized</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L11683" data-line-number="11683"></td>
        <td id="LC11683">        <span>SetEvent</span>(<span>this</span>-&gt;<span>m_stopWaitEvent</span>);</td>
      </tr>
      <tr>
        <td id="L11684" data-line-number="11684"></td>
        <td id="LC11684">    }</td>
      </tr>
      <tr>
        <td id="L11685" data-line-number="11685"></td>
        <td id="LC11685">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L11686" data-line-number="11686"></td>
        <td id="LC11686">    {</td>
      </tr>
      <tr>
        <td id="L11687" data-line-number="11687"></td>
        <td id="LC11687">        <span><span>//</span> Note: we set the m_stopWaitEvent all the time and leave it high while we're stopped. This</span></td>
      </tr>
      <tr>
        <td id="L11688" data-line-number="11688"></td>
        <td id="LC11688">        <span><span>//</span> must be done after we've checked m_stopRequested.</span></td>
      </tr>
      <tr>
        <td id="L11689" data-line-number="11689"></td>
        <td id="LC11689">        <span>SetEvent</span>(<span>this</span>-&gt;<span>m_stopWaitEvent</span>);</td>
      </tr>
      <tr>
        <td id="L11690" data-line-number="11690"></td>
        <td id="LC11690">
</td>
      </tr>
      <tr>
        <td id="L11691" data-line-number="11691"></td>
        <td id="LC11691">        <span><span>//</span> Otherwise, simply mark that the state of the process has changed and let the</span></td>
      </tr>
      <tr>
        <td id="L11692" data-line-number="11692"></td>
        <td id="LC11692">        <span><span>//</span> managed event dispatch logic take over.</span></td>
      </tr>
      <tr>
        <td id="L11693" data-line-number="11693"></td>
        <td id="LC11693">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11694" data-line-number="11694"></td>
        <td id="LC11694">        <span><span>//</span> Note: process-&gt;m_synchronized remains false, which indicates to the RC event</span></td>
      </tr>
      <tr>
        <td id="L11695" data-line-number="11695"></td>
        <td id="LC11695">        <span><span>//</span> thread that it can dispatch the next managed event.</span></td>
      </tr>
      <tr>
        <td id="L11696" data-line-number="11696"></td>
        <td id="LC11696">        m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L11697" data-line-number="11697"></td>
        <td id="LC11697">    }</td>
      </tr>
      <tr>
        <td id="L11698" data-line-number="11698"></td>
        <td id="LC11698">}</td>
      </tr>
      <tr>
        <td id="L11699" data-line-number="11699"></td>
        <td id="LC11699">
</td>
      </tr>
      <tr>
        <td id="L11700" data-line-number="11700"></td>
        <td id="LC11700">
</td>
      </tr>
      <tr>
        <td id="L11701" data-line-number="11701"></td>
        <td id="LC11701">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L11702" data-line-number="11702"></td>
        <td id="LC11702">
</td>
      </tr>
      <tr>
        <td id="L11703" data-line-number="11703"></td>
        <td id="LC11703"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11704" data-line-number="11704"></td>
        <td id="LC11704"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11705" data-line-number="11705"></td>
        <td id="LC11705"><span><span>//</span> Get (create if needed) the unmanaged thread for an unmanaged debug event.</span></td>
      </tr>
      <tr>
        <td id="L11706" data-line-number="11706"></td>
        <td id="LC11706"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11707" data-line-number="11707"></td>
        <td id="LC11707"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L11708" data-line-number="11708"></td>
        <td id="LC11708"><span><span>//</span>    event - native debug event.</span></td>
      </tr>
      <tr>
        <td id="L11709" data-line-number="11709"></td>
        <td id="LC11709"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11710" data-line-number="11710"></td>
        <td id="LC11710"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L11711" data-line-number="11711"></td>
        <td id="LC11711"><span><span>//</span>    Unmanaged thread corresponding to the native debug event.</span></td>
      </tr>
      <tr>
        <td id="L11712" data-line-number="11712"></td>
        <td id="LC11712"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11713" data-line-number="11713"></td>
        <td id="LC11713"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11714" data-line-number="11714"></td>
        <td id="LC11714"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L11715" data-line-number="11715"></td>
        <td id="LC11715"><span><span>//</span>    Thread may be newly allocated, or may be existing. CordbProcess holds</span></td>
      </tr>
      <tr>
        <td id="L11716" data-line-number="11716"></td>
        <td id="LC11716"><span><span>//</span>    list of all CordbUnmanagedThreads, and will handle freeing memory.</span></td>
      </tr>
      <tr>
        <td id="L11717" data-line-number="11717"></td>
        <td id="LC11717"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11718" data-line-number="11718"></td>
        <td id="LC11718"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11719" data-line-number="11719"></td>
        <td id="LC11719">CordbUnmanagedThread * <span>CordbProcess::GetUnmanagedThreadFromEvent</span>(<span>const</span> DEBUG_EVENT * pEvent)</td>
      </tr>
      <tr>
        <td id="L11720" data-line-number="11720"></td>
        <td id="LC11720">{</td>
      </tr>
      <tr>
        <td id="L11721" data-line-number="11721"></td>
        <td id="LC11721">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L11722" data-line-number="11722"></td>
        <td id="LC11722">    HRESULT hr;</td>
      </tr>
      <tr>
        <td id="L11723" data-line-number="11723"></td>
        <td id="LC11723">
</td>
      </tr>
      <tr>
        <td id="L11724" data-line-number="11724"></td>
        <td id="LC11724">    CordbUnmanagedThread * pUnmanagedThread = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L11725" data-line-number="11725"></td>
        <td id="LC11725">
</td>
      </tr>
      <tr>
        <td id="L11726" data-line-number="11726"></td>
        <td id="LC11726">    <span><span>//</span> Remember newly created threads.</span></td>
      </tr>
      <tr>
        <td id="L11727" data-line-number="11727"></td>
        <td id="LC11727">    <span>if</span> (pEvent-&gt;<span>dwDebugEventCode</span> == CREATE_PROCESS_DEBUG_EVENT)</td>
      </tr>
      <tr>
        <td id="L11728" data-line-number="11728"></td>
        <td id="LC11728">    {</td>
      </tr>
      <tr>
        <td id="L11729" data-line-number="11729"></td>
        <td id="LC11729">        <span><span>//</span> We absolutely should have an unmanaged callback by this point.</span></td>
      </tr>
      <tr>
        <td id="L11730" data-line-number="11730"></td>
        <td id="LC11730">        <span><span>//</span> That means that the client debugger should have called ICorDebug::SetUnmanagedHandler by now.</span></td>
      </tr>
      <tr>
        <td id="L11731" data-line-number="11731"></td>
        <td id="LC11731">        <span><span>//</span> However, we can't actually enforce that (see comment  in ICorDebug::SetUnmanagedHandler for details),</span></td>
      </tr>
      <tr>
        <td id="L11732" data-line-number="11732"></td>
        <td id="LC11732">        <span><span>//</span> so we do a runtime check to check this.</span></td>
      </tr>
      <tr>
        <td id="L11733" data-line-number="11733"></td>
        <td id="LC11733">        <span><span>//</span> This is an extremely gross API misuse and an issue in the client if the callback is not set yet.</span></td>
      </tr>
      <tr>
        <td id="L11734" data-line-number="11734"></td>
        <td id="LC11734">        <span><span>//</span> Without the unmanaged callback, we absolutely can't do interop-debugging. We assert (checked builds) and</span></td>
      </tr>
      <tr>
        <td id="L11735" data-line-number="11735"></td>
        <td id="LC11735">        <span><span>//</span> dispatch unrecoverable error (retail builds) to avoid an AV.</span></td>
      </tr>
      <tr>
        <td id="L11736" data-line-number="11736"></td>
        <td id="LC11736">
</td>
      </tr>
      <tr>
        <td id="L11737" data-line-number="11737"></td>
        <td id="LC11737">
</td>
      </tr>
      <tr>
        <td id="L11738" data-line-number="11738"></td>
        <td id="LC11738">        <span>if</span> (<span>this</span>-&gt;<span>m_cordb</span>-&gt;<span>m_unmanagedCallback</span> == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L11739" data-line-number="11739"></td>
        <td id="LC11739">        {</td>
      </tr>
      <tr>
        <td id="L11740" data-line-number="11740"></td>
        <td id="LC11740">            <span>CONSISTENCY_CHECK_MSGF</span>((<span>this</span>-&gt;<span>m_cordb</span>-&gt;<span>m_unmanagedCallback</span> != <span>NULL</span>),</td>
      </tr>
      <tr>
        <td id="L11741" data-line-number="11741"></td>
        <td id="LC11741">                (<span><span>"</span>GROSS API misuse!!<span>\n</span>No unmanaged callback set by the time we've received CreateProcess debug event for proces 0x%x.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L11742" data-line-number="11742"></td>
        <td id="LC11742">                pEvent-&gt;<span>dwProcessId</span>));</td>
      </tr>
      <tr>
        <td id="L11743" data-line-number="11743"></td>
        <td id="LC11743">
</td>
      </tr>
      <tr>
        <td id="L11744" data-line-number="11744"></td>
        <td id="LC11744">            <span>CORDBSetUnrecoverableError</span>(<span>this</span>, CORDBG_E_INTEROP_NOT_SUPPORTED, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L11745" data-line-number="11745"></td>
        <td id="LC11745">
</td>
      </tr>
      <tr>
        <td id="L11746" data-line-number="11746"></td>
        <td id="LC11746">            <span><span>//</span> Returning NULL will tell caller not to dispatch event to client. We have no callback object to dispatch upon.</span></td>
      </tr>
      <tr>
        <td id="L11747" data-line-number="11747"></td>
        <td id="LC11747">            <span>return</span> <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L11748" data-line-number="11748"></td>
        <td id="LC11748">        }</td>
      </tr>
      <tr>
        <td id="L11749" data-line-number="11749"></td>
        <td id="LC11749">
</td>
      </tr>
      <tr>
        <td id="L11750" data-line-number="11750"></td>
        <td id="LC11750">        pUnmanagedThread = <span>this</span>-&gt;<span>HandleUnmanagedCreateThread</span>(pEvent-&gt;<span>dwThreadId</span>,</td>
      </tr>
      <tr>
        <td id="L11751" data-line-number="11751"></td>
        <td id="LC11751">                                                             pEvent-&gt;<span>u</span>.<span>CreateProcessInfo</span>.<span>hThread</span>,</td>
      </tr>
      <tr>
        <td id="L11752" data-line-number="11752"></td>
        <td id="LC11752">                                                             pEvent-&gt;<span>u</span>.<span>CreateProcessInfo</span>.<span>lpThreadLocalBase</span>);</td>
      </tr>
      <tr>
        <td id="L11753" data-line-number="11753"></td>
        <td id="LC11753">
</td>
      </tr>
      <tr>
        <td id="L11754" data-line-number="11754"></td>
        <td id="LC11754">        <span><span>//</span> Managed-attach won't start until after Cordbg continues from the loader-bp.</span></td>
      </tr>
      <tr>
        <td id="L11755" data-line-number="11755"></td>
        <td id="LC11755">    }</td>
      </tr>
      <tr>
        <td id="L11756" data-line-number="11756"></td>
        <td id="LC11756">    <span>else</span> <span>if</span> (pEvent-&gt;<span>dwDebugEventCode</span> == CREATE_THREAD_DEBUG_EVENT)</td>
      </tr>
      <tr>
        <td id="L11757" data-line-number="11757"></td>
        <td id="LC11757">    {</td>
      </tr>
      <tr>
        <td id="L11758" data-line-number="11758"></td>
        <td id="LC11758">        pUnmanagedThread = <span>this</span>-&gt;<span>HandleUnmanagedCreateThread</span>(pEvent-&gt;<span>dwThreadId</span>,</td>
      </tr>
      <tr>
        <td id="L11759" data-line-number="11759"></td>
        <td id="LC11759">                                                             pEvent-&gt;<span>u</span>.<span>CreateThread</span>.<span>hThread</span>,</td>
      </tr>
      <tr>
        <td id="L11760" data-line-number="11760"></td>
        <td id="LC11760">                                                             pEvent-&gt;<span>u</span>.<span>CreateThread</span>.<span>lpThreadLocalBase</span>);</td>
      </tr>
      <tr>
        <td id="L11761" data-line-number="11761"></td>
        <td id="LC11761">
</td>
      </tr>
      <tr>
        <td id="L11762" data-line-number="11762"></td>
        <td id="LC11762">        BOOL <span>fBlockExists</span> = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L11763" data-line-number="11763"></td>
        <td id="LC11763">        hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L11764" data-line-number="11764"></td>
        <td id="LC11764">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L11765" data-line-number="11765"></td>
        <td id="LC11765">        {</td>
      </tr>
      <tr>
        <td id="L11766" data-line-number="11766"></td>
        <td id="LC11766">            <span><span>//</span> See if we have the debugger control block yet...</span></td>
      </tr>
      <tr>
        <td id="L11767" data-line-number="11767"></td>
        <td id="LC11767">
</td>
      </tr>
      <tr>
        <td id="L11768" data-line-number="11768"></td>
        <td id="LC11768">            <span>this</span>-&gt;<span>GetEventBlock</span>(&amp;<span>fBlockExists</span>);</td>
      </tr>
      <tr>
        <td id="L11769" data-line-number="11769"></td>
        <td id="LC11769">
</td>
      </tr>
      <tr>
        <td id="L11770" data-line-number="11770"></td>
        <td id="LC11770">            <span><span>//</span> If we have the debugger control block, and if that control block has the address of the thread proc for</span></td>
      </tr>
      <tr>
        <td id="L11771" data-line-number="11771"></td>
        <td id="LC11771">            <span><span>//</span> the helper thread, then we're initialized enough on the Left Side to recgonize the helper thread based on</span></td>
      </tr>
      <tr>
        <td id="L11772" data-line-number="11772"></td>
        <td id="LC11772">            <span><span>//</span> its thread proc's address.</span></td>
      </tr>
      <tr>
        <td id="L11773" data-line-number="11773"></td>
        <td id="LC11773">            <span>if</span> (<span>this</span>-&gt;<span>GetDCB</span>() != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L11774" data-line-number="11774"></td>
        <td id="LC11774">            {</td>
      </tr>
      <tr>
        <td id="L11775" data-line-number="11775"></td>
        <td id="LC11775">                <span><span>//</span> get the latest LS DCB information</span></td>
      </tr>
      <tr>
        <td id="L11776" data-line-number="11776"></td>
        <td id="LC11776">                <span>UpdateRightSideDCB</span>();</td>
      </tr>
      <tr>
        <td id="L11777" data-line-number="11777"></td>
        <td id="LC11777">                <span>if</span> ((<span>this</span>-&gt;<span>GetDCB</span>()-&gt;<span>m_helperThreadStartAddr</span> != <span>NULL</span>) &amp;&amp; (pUnmanagedThread != <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L11778" data-line-number="11778"></td>
        <td id="LC11778">                {</td>
      </tr>
      <tr>
        <td id="L11779" data-line-number="11779"></td>
        <td id="LC11779">                    <span>void</span> * pStartAddr = pEvent-&gt;<span>u</span>.<span>CreateThread</span>.<span>lpStartAddress</span>;</td>
      </tr>
      <tr>
        <td id="L11780" data-line-number="11780"></td>
        <td id="LC11780">
</td>
      </tr>
      <tr>
        <td id="L11781" data-line-number="11781"></td>
        <td id="LC11781">                    <span>if</span> (pStartAddr == <span>this</span>-&gt;<span>GetDCB</span>()-&gt;<span>m_helperThreadStartAddr</span>)</td>
      </tr>
      <tr>
        <td id="L11782" data-line-number="11782"></td>
        <td id="LC11782">                    {</td>
      </tr>
      <tr>
        <td id="L11783" data-line-number="11783"></td>
        <td id="LC11783">                        <span><span>//</span> Remember the ID of the helper thread.</span></td>
      </tr>
      <tr>
        <td id="L11784" data-line-number="11784"></td>
        <td id="LC11784">                        <span>this</span>-&gt;<span>m_helperThreadId</span> = pEvent-&gt;<span>dwThreadId</span>;</td>
      </tr>
      <tr>
        <td id="L11785" data-line-number="11785"></td>
        <td id="LC11785">
</td>
      </tr>
      <tr>
        <td id="L11786" data-line-number="11786"></td>
        <td id="LC11786">                        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: Left Side Helper Thread is 0x%x<span>\n</span><span>"</span></span>, pEvent-&gt;<span>dwThreadId</span>));</td>
      </tr>
      <tr>
        <td id="L11787" data-line-number="11787"></td>
        <td id="LC11787">                    }</td>
      </tr>
      <tr>
        <td id="L11788" data-line-number="11788"></td>
        <td id="LC11788">                }</td>
      </tr>
      <tr>
        <td id="L11789" data-line-number="11789"></td>
        <td id="LC11789">            }</td>
      </tr>
      <tr>
        <td id="L11790" data-line-number="11790"></td>
        <td id="LC11790">        }</td>
      </tr>
      <tr>
        <td id="L11791" data-line-number="11791"></td>
        <td id="LC11791">        <span>EX_CATCH_HRESULT</span>(hr)</td>
      </tr>
      <tr>
        <td id="L11792" data-line-number="11792"></td>
        <td id="LC11792">        {</td>
      </tr>
      <tr>
        <td id="L11793" data-line-number="11793"></td>
        <td id="LC11793">            <span>if</span> (<span>fBlockExists</span> &amp;&amp; <span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L11794" data-line-number="11794"></td>
        <td id="LC11794">            {</td>
      </tr>
      <tr>
        <td id="L11795" data-line-number="11795"></td>
        <td id="LC11795">                <span>_ASSERTE</span>(<span>IsLegalFatalError</span>(hr));</td>
      </tr>
      <tr>
        <td id="L11796" data-line-number="11796"></td>
        <td id="LC11796">                <span><span>//</span> Send up the DebuggerError event</span></td>
      </tr>
      <tr>
        <td id="L11797" data-line-number="11797"></td>
        <td id="LC11797">                <span>this</span>-&gt;<span>UnrecoverableError</span>(hr, <span>0</span>, <span>NULL</span>, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L11798" data-line-number="11798"></td>
        <td id="LC11798">
</td>
      </tr>
      <tr>
        <td id="L11799" data-line-number="11799"></td>
        <td id="LC11799">                <span><span>//</span> Kill the process.</span></td>
      </tr>
      <tr>
        <td id="L11800" data-line-number="11800"></td>
        <td id="LC11800">                <span><span>//</span> RS will pump events until we LS process exits.</span></td>
      </tr>
      <tr>
        <td id="L11801" data-line-number="11801"></td>
        <td id="LC11801">                <span>TerminateProcess</span>(<span>this</span>-&gt;<span>m_handle</span>, hr);</td>
      </tr>
      <tr>
        <td id="L11802" data-line-number="11802"></td>
        <td id="LC11802">
</td>
      </tr>
      <tr>
        <td id="L11803" data-line-number="11803"></td>
        <td id="LC11803">                <span>return</span> pUnmanagedThread;</td>
      </tr>
      <tr>
        <td id="L11804" data-line-number="11804"></td>
        <td id="LC11804">            }</td>
      </tr>
      <tr>
        <td id="L11805" data-line-number="11805"></td>
        <td id="LC11805">        }</td>
      </tr>
      <tr>
        <td id="L11806" data-line-number="11806"></td>
        <td id="LC11806">    }</td>
      </tr>
      <tr>
        <td id="L11807" data-line-number="11807"></td>
        <td id="LC11807">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L11808" data-line-number="11808"></td>
        <td id="LC11808">    {</td>
      </tr>
      <tr>
        <td id="L11809" data-line-number="11809"></td>
        <td id="LC11809">        <span><span>//</span> Find the unmanaged thread that this event is for.</span></td>
      </tr>
      <tr>
        <td id="L11810" data-line-number="11810"></td>
        <td id="LC11810">        pUnmanagedThread = <span>this</span>-&gt;<span>GetUnmanagedThread</span>(pEvent-&gt;<span>dwThreadId</span>);</td>
      </tr>
      <tr>
        <td id="L11811" data-line-number="11811"></td>
        <td id="LC11811">    }</td>
      </tr>
      <tr>
        <td id="L11812" data-line-number="11812"></td>
        <td id="LC11812">
</td>
      </tr>
      <tr>
        <td id="L11813" data-line-number="11813"></td>
        <td id="LC11813">    <span>return</span> pUnmanagedThread;</td>
      </tr>
      <tr>
        <td id="L11814" data-line-number="11814"></td>
        <td id="LC11814">}</td>
      </tr>
      <tr>
        <td id="L11815" data-line-number="11815"></td>
        <td id="LC11815">
</td>
      </tr>
      <tr>
        <td id="L11816" data-line-number="11816"></td>
        <td id="LC11816"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11817" data-line-number="11817"></td>
        <td id="LC11817"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11818" data-line-number="11818"></td>
        <td id="LC11818"><span><span>//</span> Handle a native-debug event representing a managed sync-complete event.</span></td>
      </tr>
      <tr>
        <td id="L11819" data-line-number="11819"></td>
        <td id="LC11819"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11820" data-line-number="11820"></td>
        <td id="LC11820"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11821" data-line-number="11821"></td>
        <td id="LC11821"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L11822" data-line-number="11822"></td>
        <td id="LC11822"><span><span>//</span>    Reaction telling caller how to respond to the native-debug event.</span></td>
      </tr>
      <tr>
        <td id="L11823" data-line-number="11823"></td>
        <td id="LC11823"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11824" data-line-number="11824"></td>
        <td id="LC11824"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L11825" data-line-number="11825"></td>
        <td id="LC11825"><span><span>//</span>    Called within the Triage process after receiving a native-debug event.</span></td>
      </tr>
      <tr>
        <td id="L11826" data-line-number="11826"></td>
        <td id="LC11826"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11827" data-line-number="11827"></td>
        <td id="LC11827"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11828" data-line-number="11828"></td>
        <td id="LC11828">Reaction <span>CordbProcess::TriageSyncComplete</span>()</td>
      </tr>
      <tr>
        <td id="L11829" data-line-number="11829"></td>
        <td id="LC11829">{</td>
      </tr>
      <tr>
        <td id="L11830" data-line-number="11830"></td>
        <td id="LC11830">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L11831" data-line-number="11831"></td>
        <td id="LC11831">
</td>
      </tr>
      <tr>
        <td id="L11832" data-line-number="11832"></td>
        <td id="LC11832">    <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TSC: received 'sync complete' flare.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L11833" data-line-number="11833"></td>
        <td id="LC11833">
</td>
      </tr>
      <tr>
        <td id="L11834" data-line-number="11834"></td>
        <td id="LC11834">    <span>_ASSERTE</span>(<span>IsInteropDebugging</span>());</td>
      </tr>
      <tr>
        <td id="L11835" data-line-number="11835"></td>
        <td id="LC11835">
</td>
      </tr>
      <tr>
        <td id="L11836" data-line-number="11836"></td>
        <td id="LC11836">    <span><span>//</span> Note: we really don't need to be suspending Runtime threads that we know have tripped</span></td>
      </tr>
      <tr>
        <td id="L11837" data-line-number="11837"></td>
        <td id="LC11837">    <span><span>//</span> here. If we ever end up with a nice, quick way to know that about each unmanaged thread, then</span></td>
      </tr>
      <tr>
        <td id="L11838" data-line-number="11838"></td>
        <td id="LC11838">    <span><span>//</span> we should put that to good use here.</span></td>
      </tr>
      <tr>
        <td id="L11839" data-line-number="11839"></td>
        <td id="LC11839">    <span>this</span>-&gt;<span>SuspendUnmanagedThreads</span>();</td>
      </tr>
      <tr>
        <td id="L11840" data-line-number="11840"></td>
        <td id="LC11840">
</td>
      </tr>
      <tr>
        <td id="L11841" data-line-number="11841"></td>
        <td id="LC11841">    <span>this</span>-&gt;<span>HandleSyncCompleteRecieved</span>();</td>
      </tr>
      <tr>
        <td id="L11842" data-line-number="11842"></td>
        <td id="LC11842">
</td>
      </tr>
      <tr>
        <td id="L11843" data-line-number="11843"></td>
        <td id="LC11843">    <span><span>//</span> Let the process run free.</span></td>
      </tr>
      <tr>
        <td id="L11844" data-line-number="11844"></td>
        <td id="LC11844">    <span>return</span> <span>REACTION</span>(cIgnore);</td>
      </tr>
      <tr>
        <td id="L11845" data-line-number="11845"></td>
        <td id="LC11845">
</td>
      </tr>
      <tr>
        <td id="L11846" data-line-number="11846"></td>
        <td id="LC11846">    <span><span>//</span> At this point, all managed threads are stopped at safe places and all unmanaged</span></td>
      </tr>
      <tr>
        <td id="L11847" data-line-number="11847"></td>
        <td id="LC11847">    <span><span>//</span> threads are either suspended or hijacked. All stopped managed threads are also hard</span></td>
      </tr>
      <tr>
        <td id="L11848" data-line-number="11848"></td>
        <td id="LC11848">    <span><span>//</span> suspended (due to the call to SuspendUnmanagedThreads above) except for the thread</span></td>
      </tr>
      <tr>
        <td id="L11849" data-line-number="11849"></td>
        <td id="LC11849">    <span><span>//</span> that sent the sync complete flare.</span></td>
      </tr>
      <tr>
        <td id="L11850" data-line-number="11850"></td>
        <td id="LC11850">
</td>
      </tr>
      <tr>
        <td id="L11851" data-line-number="11851"></td>
        <td id="LC11851">    <span><span>//</span> We've handled this exception, so skip all further processing.</span></td>
      </tr>
      <tr>
        <td id="L11852" data-line-number="11852"></td>
        <td id="LC11852">    <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L11853" data-line-number="11853"></td>
        <td id="LC11853">}</td>
      </tr>
      <tr>
        <td id="L11854" data-line-number="11854"></td>
        <td id="LC11854">
</td>
      </tr>
      <tr>
        <td id="L11855" data-line-number="11855"></td>
        <td id="LC11855"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11856" data-line-number="11856"></td>
        <td id="LC11856"><span><span>//</span> Triage a breakpoint (non-flare) on a "normal" thread.</span></td>
      </tr>
      <tr>
        <td id="L11857" data-line-number="11857"></td>
        <td id="LC11857"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11858" data-line-number="11858"></td>
        <td id="LC11858">Reaction <span>CordbProcess::TriageBreakpoint</span>(CordbUnmanagedThread * pUnmanagedThread, <span>const</span> DEBUG_EVENT * pEvent)</td>
      </tr>
      <tr>
        <td id="L11859" data-line-number="11859"></td>
        <td id="LC11859">{</td>
      </tr>
      <tr>
        <td id="L11860" data-line-number="11860"></td>
        <td id="LC11860">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L11861" data-line-number="11861"></td>
        <td id="LC11861">
</td>
      </tr>
      <tr>
        <td id="L11862" data-line-number="11862"></td>
        <td id="LC11862">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L11863" data-line-number="11863"></td>
        <td id="LC11863">
</td>
      </tr>
      <tr>
        <td id="L11864" data-line-number="11864"></td>
        <td id="LC11864">    DWORD dwExCode = pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span>;</td>
      </tr>
      <tr>
        <td id="L11865" data-line-number="11865"></td>
        <td id="LC11865">    <span>const</span> <span>void</span> * pExAddress = pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionAddress</span>;</td>
      </tr>
      <tr>
        <td id="L11866" data-line-number="11866"></td>
        <td id="LC11866">
</td>
      </tr>
      <tr>
        <td id="L11867" data-line-number="11867"></td>
        <td id="LC11867">    <span>_ASSERTE</span>(dwExCode == STATUS_BREAKPOINT);</td>
      </tr>
      <tr>
        <td id="L11868" data-line-number="11868"></td>
        <td id="LC11868">
</td>
      </tr>
      <tr>
        <td id="L11869" data-line-number="11869"></td>
        <td id="LC11869">    <span><span>//</span> There are three cases here:</span></td>
      </tr>
      <tr>
        <td id="L11870" data-line-number="11870"></td>
        <td id="LC11870">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11871" data-line-number="11871"></td>
        <td id="LC11871">    <span><span>//</span> 1. The breakpoint definetly belongs to the Runtime. (I.e., a BP in our patch table that</span></td>
      </tr>
      <tr>
        <td id="L11872" data-line-number="11872"></td>
        <td id="LC11872">    <span><span>//</span> is in managed code.) In this case, we continue the process with</span></td>
      </tr>
      <tr>
        <td id="L11873" data-line-number="11873"></td>
        <td id="LC11873">    <span><span>//</span> DBG_EXCEPTION_NOT_HANDLED, which lets the in-process exception logic kick in as if we</span></td>
      </tr>
      <tr>
        <td id="L11874" data-line-number="11874"></td>
        <td id="LC11874">    <span><span>//</span> weren't here.</span></td>
      </tr>
      <tr>
        <td id="L11875" data-line-number="11875"></td>
        <td id="LC11875">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11876" data-line-number="11876"></td>
        <td id="LC11876">    <span><span>//</span> 2. The breakpoint is definetly not ours. (I.e., a BP that is not in our patch table.) We</span></td>
      </tr>
      <tr>
        <td id="L11877" data-line-number="11877"></td>
        <td id="LC11877">    <span><span>//</span> pass these up as regular exception events, doing the can't stop check as usual.</span></td>
      </tr>
      <tr>
        <td id="L11878" data-line-number="11878"></td>
        <td id="LC11878">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11879" data-line-number="11879"></td>
        <td id="LC11879">    <span><span>//</span> 3. We're not sure. (I.e., a BP in our patch table, but set in unmangaed code.) In this</span></td>
      </tr>
      <tr>
        <td id="L11880" data-line-number="11880"></td>
        <td id="LC11880">    <span><span>//</span> case, we hijack as usual, also with can't stop check as usual.</span></td>
      </tr>
      <tr>
        <td id="L11881" data-line-number="11881"></td>
        <td id="LC11881">
</td>
      </tr>
      <tr>
        <td id="L11882" data-line-number="11882"></td>
        <td id="LC11882">    <span>bool</span> <span>fPatchFound</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L11883" data-line-number="11883"></td>
        <td id="LC11883">    <span>bool</span> <span>fPatchIsUnmanaged</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L11884" data-line-number="11884"></td>
        <td id="LC11884">
</td>
      </tr>
      <tr>
        <td id="L11885" data-line-number="11885"></td>
        <td id="LC11885">    hr = <span>this</span>-&gt;<span>FindPatchByAddress</span>(<span>PTR_TO_CORDB_ADDRESS</span>(pExAddress),</td>
      </tr>
      <tr>
        <td id="L11886" data-line-number="11886"></td>
        <td id="LC11886">                                  &amp;<span>fPatchFound</span>,</td>
      </tr>
      <tr>
        <td id="L11887" data-line-number="11887"></td>
        <td id="LC11887">                                  &amp;<span>fPatchIsUnmanaged</span>);</td>
      </tr>
      <tr>
        <td id="L11888" data-line-number="11888"></td>
        <td id="LC11888">
</td>
      </tr>
      <tr>
        <td id="L11889" data-line-number="11889"></td>
        <td id="LC11889">    <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L11890" data-line-number="11890"></td>
        <td id="LC11890">    {</td>
      </tr>
      <tr>
        <td id="L11891" data-line-number="11891"></td>
        <td id="LC11891">        <span>if</span> (<span>fPatchFound</span>)</td>
      </tr>
      <tr>
        <td id="L11892" data-line-number="11892"></td>
        <td id="LC11892">        {</td>
      </tr>
      <tr>
        <td id="L11893" data-line-number="11893"></td>
        <td id="LC11893">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L11894" data-line-number="11894"></td>
        <td id="LC11894">            <span><span>//</span> What if managed &amp; native patch the same address? That could happen on a step out M --&gt; U.</span></td>
      </tr>
      <tr>
        <td id="L11895" data-line-number="11895"></td>
        <td id="LC11895">            {</td>
      </tr>
      <tr>
        <td id="L11896" data-line-number="11896"></td>
        <td id="LC11896">                NativePatch * pNativePatch = <span>GetNativePatch</span>(pExAddress);</td>
      </tr>
      <tr>
        <td id="L11897" data-line-number="11897"></td>
        <td id="LC11897">                <span>SIMPLIFYING_ASSUMPTION_MSGF</span>(pNativePatch == <span>NULL</span>, (<span><span>"</span>Have Managed &amp; native patch at 0x%p<span>"</span></span>, pExAddress));</td>
      </tr>
      <tr>
        <td id="L11898" data-line-number="11898"></td>
        <td id="LC11898">            }</td>
      </tr>
      <tr>
        <td id="L11899" data-line-number="11899"></td>
        <td id="LC11899">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L11900" data-line-number="11900"></td>
        <td id="LC11900">
</td>
      </tr>
      <tr>
        <td id="L11901" data-line-number="11901"></td>
        <td id="LC11901">            <span><span>//</span> BP could be ours... if its unmanaged, then we still need to hijack, so fall</span></td>
      </tr>
      <tr>
        <td id="L11902" data-line-number="11902"></td>
        <td id="LC11902">            <span><span>//</span> through to that logic. Otherwise, its ours.</span></td>
      </tr>
      <tr>
        <td id="L11903" data-line-number="11903"></td>
        <td id="LC11903">            <span>if</span> (!<span>fPatchIsUnmanaged</span>)</td>
      </tr>
      <tr>
        <td id="L11904" data-line-number="11904"></td>
        <td id="LC11904">            {</td>
      </tr>
      <tr>
        <td id="L11905" data-line-number="11905"></td>
        <td id="LC11905">                <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: breakpoint exception <span>"</span></span></td>
      </tr>
      <tr>
        <td id="L11906" data-line-number="11906"></td>
        <td id="LC11906">                     <span><span>"</span>belongs to runtime due to patch table match.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L11907" data-line-number="11907"></td>
        <td id="LC11907">
</td>
      </tr>
      <tr>
        <td id="L11908" data-line-number="11908"></td>
        <td id="LC11908">                <span>return</span> <span>REACTION</span>(cCLR);</td>
      </tr>
      <tr>
        <td id="L11909" data-line-number="11909"></td>
        <td id="LC11909">            }</td>
      </tr>
      <tr>
        <td id="L11910" data-line-number="11910"></td>
        <td id="LC11910">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L11911" data-line-number="11911"></td>
        <td id="LC11911">            {</td>
      </tr>
      <tr>
        <td id="L11912" data-line-number="11912"></td>
        <td id="LC11912">                <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: breakpoint exception <span>"</span></span></td>
      </tr>
      <tr>
        <td id="L11913" data-line-number="11913"></td>
        <td id="LC11913">                     <span><span>"</span>matched in patch table, but its unmanaged so might hijack anyway.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L11914" data-line-number="11914"></td>
        <td id="LC11914">
</td>
      </tr>
      <tr>
        <td id="L11915" data-line-number="11915"></td>
        <td id="LC11915">                <span><span>//</span> If we're in cooperative mode, then we must have a inproc handler, and don't need to hijack</span></td>
      </tr>
      <tr>
        <td id="L11916" data-line-number="11916"></td>
        <td id="LC11916">                <span><span>//</span> One way this can happen is the patch placed for a func-eval complete is hit in coop-mode.</span></td>
      </tr>
      <tr>
        <td id="L11917" data-line-number="11917"></td>
        <td id="LC11917">                <span>if</span> (pUnmanagedThread-&gt;<span>GetEEPGCDisabled</span>())</td>
      </tr>
      <tr>
        <td id="L11918" data-line-number="11918"></td>
        <td id="LC11918">                {</td>
      </tr>
      <tr>
        <td id="L11919" data-line-number="11919"></td>
        <td id="LC11919">                    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>Already in coop-mode, don't need to hijack<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L11920" data-line-number="11920"></td>
        <td id="LC11920">                    <span>return</span> <span>REACTION</span>(cCLR);</td>
      </tr>
      <tr>
        <td id="L11921" data-line-number="11921"></td>
        <td id="LC11921">                }</td>
      </tr>
      <tr>
        <td id="L11922" data-line-number="11922"></td>
        <td id="LC11922">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L11923" data-line-number="11923"></td>
        <td id="LC11923">                {</td>
      </tr>
      <tr>
        <td id="L11924" data-line-number="11924"></td>
        <td id="LC11924">                    <span>return</span> <span>REACTION</span>(cBreakpointRequiringHijack);</td>
      </tr>
      <tr>
        <td id="L11925" data-line-number="11925"></td>
        <td id="LC11925">                }</td>
      </tr>
      <tr>
        <td id="L11926" data-line-number="11926"></td>
        <td id="LC11926">            }</td>
      </tr>
      <tr>
        <td id="L11927" data-line-number="11927"></td>
        <td id="LC11927">
</td>
      </tr>
      <tr>
        <td id="L11928" data-line-number="11928"></td>
        <td id="LC11928">            <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L11929" data-line-number="11929"></td>
        <td id="LC11929">        }</td>
      </tr>
      <tr>
        <td id="L11930" data-line-number="11930"></td>
        <td id="LC11930">        <span>else</span> <span><span>//</span> Patch not found</span></td>
      </tr>
      <tr>
        <td id="L11931" data-line-number="11931"></td>
        <td id="LC11931">        {</td>
      </tr>
      <tr>
        <td id="L11932" data-line-number="11932"></td>
        <td id="LC11932">            <span><span>//</span> If we're here, then we have a BP that's not in the managed patch table, and not</span></td>
      </tr>
      <tr>
        <td id="L11933" data-line-number="11933"></td>
        <td id="LC11933">            <span><span>//</span> in the native patch list. This should be rare. Perhaps an int3 / DebugBreak() / Assert in</span></td>
      </tr>
      <tr>
        <td id="L11934" data-line-number="11934"></td>
        <td id="LC11934">            <span><span>//</span> the native code stream.</span></td>
      </tr>
      <tr>
        <td id="L11935" data-line-number="11935"></td>
        <td id="LC11935">            <span><span>//</span> Anyway, we don't know about this patch so we can't skip it. The only thing we can do</span></td>
      </tr>
      <tr>
        <td id="L11936" data-line-number="11936"></td>
        <td id="LC11936">            <span><span>//</span> is chuck it up to Cordbg and hope they can help us. Note that this is the same case</span></td>
      </tr>
      <tr>
        <td id="L11937" data-line-number="11937"></td>
        <td id="LC11937">            <span><span>//</span> we were in w. V1.</span></td>
      </tr>
      <tr>
        <td id="L11938" data-line-number="11938"></td>
        <td id="LC11938">
</td>
      </tr>
      <tr>
        <td id="L11939" data-line-number="11939"></td>
        <td id="LC11939">            <span><span>//</span> BP doesn't belong to CLR ... so dispatch it to Cordbg as either make it IB or OOB.</span></td>
      </tr>
      <tr>
        <td id="L11940" data-line-number="11940"></td>
        <td id="LC11940">            <span><span>//</span> @todo - make the runtime 1 giant Can't stop region.</span></td>
      </tr>
      <tr>
        <td id="L11941" data-line-number="11941"></td>
        <td id="LC11941">            <span>bool</span> <span>fCantStop</span> = pUnmanagedThread-&gt;<span>IsCantStop</span>();</td>
      </tr>
      <tr>
        <td id="L11942" data-line-number="11942"></td>
        <td id="LC11942">
</td>
      </tr>
      <tr>
        <td id="L11943" data-line-number="11943"></td>
        <td id="LC11943">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L11944" data-line-number="11944"></td>
        <td id="LC11944">            <span><span>//</span> We rarely expect a raw int3 here. Add a debug check that will assert.</span></td>
      </tr>
      <tr>
        <td id="L11945" data-line-number="11945"></td>
        <td id="LC11945">            <span><span>//</span> Tests that know they don't have raw int3 can enable this regkey to get</span></td>
      </tr>
      <tr>
        <td id="L11946" data-line-number="11946"></td>
        <td id="LC11946">            <span><span>//</span> extra coverage.</span></td>
      </tr>
      <tr>
        <td id="L11947" data-line-number="11947"></td>
        <td id="LC11947">            <span>static</span> DWORD s_fBreakOnRawInt3 = -<span>1</span>;</td>
      </tr>
      <tr>
        <td id="L11948" data-line-number="11948"></td>
        <td id="LC11948">
</td>
      </tr>
      <tr>
        <td id="L11949" data-line-number="11949"></td>
        <td id="LC11949">            <span>if</span> (s_fBreakOnRawInt3 == -<span>1</span>)</td>
      </tr>
      <tr>
        <td id="L11950" data-line-number="11950"></td>
        <td id="LC11950">                s_fBreakOnRawInt3 = <span>CLRConfig::GetConfigValue</span>(CLRConfig::INTERNAL_DbgBreakOnRawInt3);</td>
      </tr>
      <tr>
        <td id="L11951" data-line-number="11951"></td>
        <td id="LC11951">
</td>
      </tr>
      <tr>
        <td id="L11952" data-line-number="11952"></td>
        <td id="LC11952">            <span>if</span> (s_fBreakOnRawInt3)</td>
      </tr>
      <tr>
        <td id="L11953" data-line-number="11953"></td>
        <td id="LC11953">            {</td>
      </tr>
      <tr>
        <td id="L11954" data-line-number="11954"></td>
        <td id="LC11954">                <span>CONSISTENCY_CHECK_MSGF</span>(<span>false</span>, (<span><span>"</span>Unexpected Raw int3 at:%p on tid 0x%x (%d). CantStop=%d.<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L11955" data-line-number="11955"></td>
        <td id="LC11955">                    <span><span>"</span>This assert is used by specific tests to get extra checks.<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L11956" data-line-number="11956"></td>
        <td id="LC11956">                    <span><span>"</span>For normal cases it's ignorable and is enabled by setting DbgBreakOnRawInt3==1.<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L11957" data-line-number="11957"></td>
        <td id="LC11957">                    pExAddress, pEvent-&gt;<span>dwThreadId</span>, pEvent-&gt;<span>dwThreadId</span>, <span>fCantStop</span>));</td>
      </tr>
      <tr>
        <td id="L11958" data-line-number="11958"></td>
        <td id="LC11958">            }</td>
      </tr>
      <tr>
        <td id="L11959" data-line-number="11959"></td>
        <td id="LC11959">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L11960" data-line-number="11960"></td>
        <td id="LC11960">
</td>
      </tr>
      <tr>
        <td id="L11961" data-line-number="11961"></td>
        <td id="LC11961">            <span>if</span> (<span>fCantStop</span>)</td>
      </tr>
      <tr>
        <td id="L11962" data-line-number="11962"></td>
        <td id="LC11962">            {</td>
      </tr>
      <tr>
        <td id="L11963" data-line-number="11963"></td>
        <td id="LC11963">                <span><span>//</span> If we're in a can't stop region, then its OOB no matter what at this point.</span></td>
      </tr>
      <tr>
        <td id="L11964" data-line-number="11964"></td>
        <td id="LC11964">                <span>return</span> <span>REACTION</span>(cOOB);</td>
      </tr>
      <tr>
        <td id="L11965" data-line-number="11965"></td>
        <td id="LC11965">            }</td>
      </tr>
      <tr>
        <td id="L11966" data-line-number="11966"></td>
        <td id="LC11966">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L11967" data-line-number="11967"></td>
        <td id="LC11967">            {</td>
      </tr>
      <tr>
        <td id="L11968" data-line-number="11968"></td>
        <td id="LC11968">                <span><span>//</span> PGC must be enabled if we're going to stop for an IB event.</span></td>
      </tr>
      <tr>
        <td id="L11969" data-line-number="11969"></td>
        <td id="LC11969">                <span>bool</span> PGCDisabled = pUnmanagedThread-&gt;<span>GetEEPGCDisabled</span>();</td>
      </tr>
      <tr>
        <td id="L11970" data-line-number="11970"></td>
        <td id="LC11970">                <span>_ASSERTE</span>(!PGCDisabled);</td>
      </tr>
      <tr>
        <td id="L11971" data-line-number="11971"></td>
        <td id="LC11971">
</td>
      </tr>
      <tr>
        <td id="L11972" data-line-number="11972"></td>
        <td id="LC11972">                <span><span>//</span> Bp is definitely not ours, and PGC is not disabled, so in-band exception.</span></td>
      </tr>
      <tr>
        <td id="L11973" data-line-number="11973"></td>
        <td id="LC11973">                <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: breakpoint exception <span>"</span></span></td>
      </tr>
      <tr>
        <td id="L11974" data-line-number="11974"></td>
        <td id="LC11974">                     <span><span>"</span>does not belong to the runtime due to failed patch table match.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L11975" data-line-number="11975"></td>
        <td id="LC11975">
</td>
      </tr>
      <tr>
        <td id="L11976" data-line-number="11976"></td>
        <td id="LC11976">                <span>return</span> <span>REACTION</span>(cInband);</td>
      </tr>
      <tr>
        <td id="L11977" data-line-number="11977"></td>
        <td id="LC11977">            }</td>
      </tr>
      <tr>
        <td id="L11978" data-line-number="11978"></td>
        <td id="LC11978">
</td>
      </tr>
      <tr>
        <td id="L11979" data-line-number="11979"></td>
        <td id="LC11979">            <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L11980" data-line-number="11980"></td>
        <td id="LC11980">        }</td>
      </tr>
      <tr>
        <td id="L11981" data-line-number="11981"></td>
        <td id="LC11981">
</td>
      </tr>
      <tr>
        <td id="L11982" data-line-number="11982"></td>
        <td id="LC11982">        <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L11983" data-line-number="11983"></td>
        <td id="LC11983">    }</td>
      </tr>
      <tr>
        <td id="L11984" data-line-number="11984"></td>
        <td id="LC11984">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L11985" data-line-number="11985"></td>
        <td id="LC11985">    {</td>
      </tr>
      <tr>
        <td id="L11986" data-line-number="11986"></td>
        <td id="LC11986">        <span><span>//</span> Patch table lookup failed? Only on OOM or if ReadProcessMemory fails...</span></td>
      </tr>
      <tr>
        <td id="L11987" data-line-number="11987"></td>
        <td id="LC11987">        <span>_ASSERTE</span>(!<span><span>"</span>Patch table lookup failed!<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L11988" data-line-number="11988"></td>
        <td id="LC11988">        <span>CORDBSetUnrecoverableError</span>(<span>this</span>, hr, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L11989" data-line-number="11989"></td>
        <td id="LC11989">        <span>return</span> <span>REACTION</span>(cOOB);</td>
      </tr>
      <tr>
        <td id="L11990" data-line-number="11990"></td>
        <td id="LC11990">    }</td>
      </tr>
      <tr>
        <td id="L11991" data-line-number="11991"></td>
        <td id="LC11991">
</td>
      </tr>
      <tr>
        <td id="L11992" data-line-number="11992"></td>
        <td id="LC11992">    <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L11993" data-line-number="11993"></td>
        <td id="LC11993">}</td>
      </tr>
      <tr>
        <td id="L11994" data-line-number="11994"></td>
        <td id="LC11994">
</td>
      </tr>
      <tr>
        <td id="L11995" data-line-number="11995"></td>
        <td id="LC11995"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L11996" data-line-number="11996"></td>
        <td id="LC11996"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L11997" data-line-number="11997"></td>
        <td id="LC11997"><span><span>//</span> Triage a "normal" 1st chance exception on a "normal" thread.</span></td>
      </tr>
      <tr>
        <td id="L11998" data-line-number="11998"></td>
        <td id="LC11998"><span><span>//</span> Not hijacked, not the helper thread, not a flare, etc.. This is the common</span></td>
      </tr>
      <tr>
        <td id="L11999" data-line-number="11999"></td>
        <td id="LC11999"><span><span>//</span> case for a native exception from native code.</span></td>
      </tr>
      <tr>
        <td id="L12000" data-line-number="12000"></td>
        <td id="LC12000"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12001" data-line-number="12001"></td>
        <td id="LC12001"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L12002" data-line-number="12002"></td>
        <td id="LC12002"><span><span>//</span>     pUnmanagedThread - Pointer to the CordbUnmanagedThread object that we want to hijack.</span></td>
      </tr>
      <tr>
        <td id="L12003" data-line-number="12003"></td>
        <td id="LC12003"><span><span>//</span>     pEvent - Pointer to the debug event which contains the exception code and address.</span></td>
      </tr>
      <tr>
        <td id="L12004" data-line-number="12004"></td>
        <td id="LC12004"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12005" data-line-number="12005"></td>
        <td id="LC12005"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L12006" data-line-number="12006"></td>
        <td id="LC12006"><span><span>//</span>     The Reaction tells if the event is in-band, out-of-band, CLR specific or ignorable.</span></td>
      </tr>
      <tr>
        <td id="L12007" data-line-number="12007"></td>
        <td id="LC12007"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12008" data-line-number="12008"></td>
        <td id="LC12008"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L12009" data-line-number="12009"></td>
        <td id="LC12009">Reaction <span>CordbProcess::Triage1stChanceNonSpecial</span>(CordbUnmanagedThread * pUnmanagedThread, <span>const</span> DEBUG_EVENT * pEvent)</td>
      </tr>
      <tr>
        <td id="L12010" data-line-number="12010"></td>
        <td id="LC12010">{</td>
      </tr>
      <tr>
        <td id="L12011" data-line-number="12011"></td>
        <td id="LC12011">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L12012" data-line-number="12012"></td>
        <td id="LC12012">    CONTRACTL</td>
      </tr>
      <tr>
        <td id="L12013" data-line-number="12013"></td>
        <td id="LC12013">    {</td>
      </tr>
      <tr>
        <td id="L12014" data-line-number="12014"></td>
        <td id="LC12014">        THROWS;</td>
      </tr>
      <tr>
        <td id="L12015" data-line-number="12015"></td>
        <td id="LC12015">    }</td>
      </tr>
      <tr>
        <td id="L12016" data-line-number="12016"></td>
        <td id="LC12016">    CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L12017" data-line-number="12017"></td>
        <td id="LC12017">
</td>
      </tr>
      <tr>
        <td id="L12018" data-line-number="12018"></td>
        <td id="LC12018">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L12019" data-line-number="12019"></td>
        <td id="LC12019">
</td>
      </tr>
      <tr>
        <td id="L12020" data-line-number="12020"></td>
        <td id="LC12020">    DWORD dwExCode = pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span>;</td>
      </tr>
      <tr>
        <td id="L12021" data-line-number="12021"></td>
        <td id="LC12021">    <span>const</span> <span>void</span> * pExAddress = pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionAddress</span>;</td>
      </tr>
      <tr>
        <td id="L12022" data-line-number="12022"></td>
        <td id="LC12022">
</td>
      </tr>
      <tr>
        <td id="L12023" data-line-number="12023"></td>
        <td id="LC12023">    <span><span>//</span> This had better not be a flare. If it is, that means we have some race that unmarked</span></td>
      </tr>
      <tr>
        <td id="L12024" data-line-number="12024"></td>
        <td id="LC12024">    <span><span>//</span> the hijacks.</span></td>
      </tr>
      <tr>
        <td id="L12025" data-line-number="12025"></td>
        <td id="LC12025">    <span>_ASSERTE</span>(!<span>ExceptionIsFlare</span>(dwExCode, pExAddress));</td>
      </tr>
      <tr>
        <td id="L12026" data-line-number="12026"></td>
        <td id="LC12026">
</td>
      </tr>
      <tr>
        <td id="L12027" data-line-number="12027"></td>
        <td id="LC12027">    <span><span>//</span> Any first chance exception could belong to the Runtime, so long as the Runtime has actually been</span></td>
      </tr>
      <tr>
        <td id="L12028" data-line-number="12028"></td>
        <td id="LC12028">    <span><span>//</span> initialized. Here we'll setup a first-chance hijack for this thread so that it can give us the</span></td>
      </tr>
      <tr>
        <td id="L12029" data-line-number="12029"></td>
        <td id="LC12029">    <span><span>//</span> true answer that we need.</span></td>
      </tr>
      <tr>
        <td id="L12030" data-line-number="12030"></td>
        <td id="LC12030">
</td>
      </tr>
      <tr>
        <td id="L12031" data-line-number="12031"></td>
        <td id="LC12031">    <span><span>//</span> But none of those exceptions could possibly be ours unless we have a managed thread to go with</span></td>
      </tr>
      <tr>
        <td id="L12032" data-line-number="12032"></td>
        <td id="LC12032">    <span><span>//</span> this unmanaged thread. A non-NULL EEThreadPtr tells us that there is indeed a managed thread for</span></td>
      </tr>
      <tr>
        <td id="L12033" data-line-number="12033"></td>
        <td id="LC12033">    <span><span>//</span> this unmanaged thread, even if the Right Side hasn't received a managed ThreadCreate message yet.</span></td>
      </tr>
      <tr>
        <td id="L12034" data-line-number="12034"></td>
        <td id="LC12034">    REMOTE_PTR pEEThread;</td>
      </tr>
      <tr>
        <td id="L12035" data-line-number="12035"></td>
        <td id="LC12035">    hr = pUnmanagedThread-&gt;<span>GetEEThreadPtr</span>(&amp;pEEThread);</td>
      </tr>
      <tr>
        <td id="L12036" data-line-number="12036"></td>
        <td id="LC12036">    <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L12037" data-line-number="12037"></td>
        <td id="LC12037">
</td>
      </tr>
      <tr>
        <td id="L12038" data-line-number="12038"></td>
        <td id="LC12038">    <span>if</span> (pEEThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L12039" data-line-number="12039"></td>
        <td id="LC12039">    {</td>
      </tr>
      <tr>
        <td id="L12040" data-line-number="12040"></td>
        <td id="LC12040">        <span><span>//</span> No managed thread, so it can't possibly belong to the runtime!</span></td>
      </tr>
      <tr>
        <td id="L12041" data-line-number="12041"></td>
        <td id="LC12041">        <span><span>//</span> But it may still be in a can't-stop region (think some goofy shutdown case).</span></td>
      </tr>
      <tr>
        <td id="L12042" data-line-number="12042"></td>
        <td id="LC12042">        <span>if</span> (pUnmanagedThread-&gt;<span>IsCantStop</span>())</td>
      </tr>
      <tr>
        <td id="L12043" data-line-number="12043"></td>
        <td id="LC12043">        {</td>
      </tr>
      <tr>
        <td id="L12044" data-line-number="12044"></td>
        <td id="LC12044">            <span>return</span> <span>REACTION</span>(cOOB);</td>
      </tr>
      <tr>
        <td id="L12045" data-line-number="12045"></td>
        <td id="LC12045">        }</td>
      </tr>
      <tr>
        <td id="L12046" data-line-number="12046"></td>
        <td id="LC12046">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L12047" data-line-number="12047"></td>
        <td id="LC12047">        {</td>
      </tr>
      <tr>
        <td id="L12048" data-line-number="12048"></td>
        <td id="LC12048">            <span>return</span> <span>REACTION</span>(cInband);</td>
      </tr>
      <tr>
        <td id="L12049" data-line-number="12049"></td>
        <td id="LC12049">        }</td>
      </tr>
      <tr>
        <td id="L12050" data-line-number="12050"></td>
        <td id="LC12050">    }</td>
      </tr>
      <tr>
        <td id="L12051" data-line-number="12051"></td>
        <td id="LC12051">
</td>
      </tr>
      <tr>
        <td id="L12052" data-line-number="12052"></td>
        <td id="LC12052">
</td>
      </tr>
      <tr>
        <td id="L12053" data-line-number="12053"></td>
        <td id="LC12053">
</td>
      </tr>
      <tr>
        <td id="L12054" data-line-number="12054"></td>
        <td id="LC12054">    <span><span>//</span> We have to be careful here. A Runtime thread may be in a place where we cannot let an</span></td>
      </tr>
      <tr>
        <td id="L12055" data-line-number="12055"></td>
        <td id="LC12055">    <span><span>//</span> unmanaged exception stop it. For instance, an unmanaged user breakpoint set on</span></td>
      </tr>
      <tr>
        <td id="L12056" data-line-number="12056"></td>
        <td id="LC12056">    <span><span>//</span> WaitForSingleObject will prevent Runtime threads from sending events to the Right Side. So at</span></td>
      </tr>
      <tr>
        <td id="L12057" data-line-number="12057"></td>
        <td id="LC12057">    <span><span>//</span> various points below, we check to see if this Runtime thread is in a place were we can't let</span></td>
      </tr>
      <tr>
        <td id="L12058" data-line-number="12058"></td>
        <td id="LC12058">    <span><span>//</span> it stop, and if so then we jump over to the out-of-band dispatch logic and treat this</span></td>
      </tr>
      <tr>
        <td id="L12059" data-line-number="12059"></td>
        <td id="LC12059">    <span><span>//</span> exception as out-of-band. The debugger is supposed to continue from the out-of-band event</span></td>
      </tr>
      <tr>
        <td id="L12060" data-line-number="12060"></td>
        <td id="LC12060">    <span><span>//</span> properly and help us avoid this problem altogether.</span></td>
      </tr>
      <tr>
        <td id="L12061" data-line-number="12061"></td>
        <td id="LC12061">
</td>
      </tr>
      <tr>
        <td id="L12062" data-line-number="12062"></td>
        <td id="LC12062">    <span><span>//</span> Grab a few flags from the thread's state...</span></td>
      </tr>
      <tr>
        <td id="L12063" data-line-number="12063"></td>
        <td id="LC12063">    <span>bool</span> <span>fThreadStepping</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L12064" data-line-number="12064"></td>
        <td id="LC12064">    <span>bool</span> <span>fSpecialManagedException</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L12065" data-line-number="12065"></td>
        <td id="LC12065">
</td>
      </tr>
      <tr>
        <td id="L12066" data-line-number="12066"></td>
        <td id="LC12066">    pUnmanagedThread-&gt;<span>GetEEState</span>(&amp;<span>fThreadStepping</span>, &amp;<span>fSpecialManagedException</span>);</td>
      </tr>
      <tr>
        <td id="L12067" data-line-number="12067"></td>
        <td id="LC12067">
</td>
      </tr>
      <tr>
        <td id="L12068" data-line-number="12068"></td>
        <td id="LC12068">    <span><span>//</span> If we've got a single step exception, and if the Left Side has indicated that it was</span></td>
      </tr>
      <tr>
        <td id="L12069" data-line-number="12069"></td>
        <td id="LC12069">    <span><span>//</span> stepping the thread, then the exception is ours.</span></td>
      </tr>
      <tr>
        <td id="L12070" data-line-number="12070"></td>
        <td id="LC12070">    <span>if</span> (dwExCode == STATUS_SINGLE_STEP)</td>
      </tr>
      <tr>
        <td id="L12071" data-line-number="12071"></td>
        <td id="LC12071">    {</td>
      </tr>
      <tr>
        <td id="L12072" data-line-number="12072"></td>
        <td id="LC12072">        <span>if</span> (<span>fThreadStepping</span>)</td>
      </tr>
      <tr>
        <td id="L12073" data-line-number="12073"></td>
        <td id="LC12073">        {</td>
      </tr>
      <tr>
        <td id="L12074" data-line-number="12074"></td>
        <td id="LC12074">            <span><span>//</span> Yup, its the Left Side that was stepping the thread...</span></td>
      </tr>
      <tr>
        <td id="L12075" data-line-number="12075"></td>
        <td id="LC12075">            <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: single step exception belongs to the runtime.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12076" data-line-number="12076"></td>
        <td id="LC12076">
</td>
      </tr>
      <tr>
        <td id="L12077" data-line-number="12077"></td>
        <td id="LC12077">            <span>return</span> <span>REACTION</span>(cCLR);</td>
      </tr>
      <tr>
        <td id="L12078" data-line-number="12078"></td>
        <td id="LC12078">        }</td>
      </tr>
      <tr>
        <td id="L12079" data-line-number="12079"></td>
        <td id="LC12079">
</td>
      </tr>
      <tr>
        <td id="L12080" data-line-number="12080"></td>
        <td id="LC12080">        <span><span>//</span> Any single step that is triggered when the thread's state doesn't indicate that</span></td>
      </tr>
      <tr>
        <td id="L12081" data-line-number="12081"></td>
        <td id="LC12081">        <span><span>//</span> we were stepping the thread automatically gets passed out as an unmanged event.</span></td>
      </tr>
      <tr>
        <td id="L12082" data-line-number="12082"></td>
        <td id="LC12082">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: single step exception <span>"</span></span></td>
      </tr>
      <tr>
        <td id="L12083" data-line-number="12083"></td>
        <td id="LC12083">             <span><span>"</span>does not belong to the runtime.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12084" data-line-number="12084"></td>
        <td id="LC12084">
</td>
      </tr>
      <tr>
        <td id="L12085" data-line-number="12085"></td>
        <td id="LC12085">        <span>if</span> (pUnmanagedThread-&gt;<span>IsCantStop</span>())</td>
      </tr>
      <tr>
        <td id="L12086" data-line-number="12086"></td>
        <td id="LC12086">        {</td>
      </tr>
      <tr>
        <td id="L12087" data-line-number="12087"></td>
        <td id="LC12087">            <span>return</span> <span>REACTION</span>(cOOB);</td>
      </tr>
      <tr>
        <td id="L12088" data-line-number="12088"></td>
        <td id="LC12088">        }</td>
      </tr>
      <tr>
        <td id="L12089" data-line-number="12089"></td>
        <td id="LC12089">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L12090" data-line-number="12090"></td>
        <td id="LC12090">        {</td>
      </tr>
      <tr>
        <td id="L12091" data-line-number="12091"></td>
        <td id="LC12091">            <span>return</span> <span>REACTION</span>(cInband);</td>
      </tr>
      <tr>
        <td id="L12092" data-line-number="12092"></td>
        <td id="LC12092">        }</td>
      </tr>
      <tr>
        <td id="L12093" data-line-number="12093"></td>
        <td id="LC12093">
</td>
      </tr>
      <tr>
        <td id="L12094" data-line-number="12094"></td>
        <td id="LC12094">        <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L12095" data-line-number="12095"></td>
        <td id="LC12095">    }</td>
      </tr>
      <tr>
        <td id="L12096" data-line-number="12096"></td>
        <td id="LC12096">
</td>
      </tr>
      <tr>
        <td id="L12097" data-line-number="12097"></td>
        <td id="LC12097">#<span>ifdef</span> CorDB_Short_Circuit_First_Chance_Ownership</td>
      </tr>
      <tr>
        <td id="L12098" data-line-number="12098"></td>
        <td id="LC12098">    <span><span>//</span> If the runtime indicates that this is a special exception being thrown within the runtime,</span></td>
      </tr>
      <tr>
        <td id="L12099" data-line-number="12099"></td>
        <td id="LC12099">    <span><span>//</span> then its ours no matter what.</span></td>
      </tr>
      <tr>
        <td id="L12100" data-line-number="12100"></td>
        <td id="LC12100">    <span>else</span> <span>if</span> (<span>fSpecialManagedException</span>)</td>
      </tr>
      <tr>
        <td id="L12101" data-line-number="12101"></td>
        <td id="LC12101">    {</td>
      </tr>
      <tr>
        <td id="L12102" data-line-number="12102"></td>
        <td id="LC12102">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: exception belongs to the runtime due to <span>"</span></span></td>
      </tr>
      <tr>
        <td id="L12103" data-line-number="12103"></td>
        <td id="LC12103">             <span><span>"</span>special managed exception marking.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12104" data-line-number="12104"></td>
        <td id="LC12104">
</td>
      </tr>
      <tr>
        <td id="L12105" data-line-number="12105"></td>
        <td id="LC12105">        <span>return</span> <span>REACTION</span>(cCLR);</td>
      </tr>
      <tr>
        <td id="L12106" data-line-number="12106"></td>
        <td id="LC12106">    }</td>
      </tr>
      <tr>
        <td id="L12107" data-line-number="12107"></td>
        <td id="LC12107">    <span>else</span> <span>if</span> ((dwExCode == EXCEPTION_COMPLUS) || (dwExCode == EXCEPTION_HIJACK))</td>
      </tr>
      <tr>
        <td id="L12108" data-line-number="12108"></td>
        <td id="LC12108">    {</td>
      </tr>
      <tr>
        <td id="L12109" data-line-number="12109"></td>
        <td id="LC12109">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000,</td>
      </tr>
      <tr>
        <td id="L12110" data-line-number="12110"></td>
        <td id="LC12110">             <span><span>"</span>W32ET::W32EL: exception belongs to Runtime due to match on built in exception code<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12111" data-line-number="12111"></td>
        <td id="LC12111">
</td>
      </tr>
      <tr>
        <td id="L12112" data-line-number="12112"></td>
        <td id="LC12112">        <span>return</span> <span>REACTION</span>(cCLR);</td>
      </tr>
      <tr>
        <td id="L12113" data-line-number="12113"></td>
        <td id="LC12113">    }</td>
      </tr>
      <tr>
        <td id="L12114" data-line-number="12114"></td>
        <td id="LC12114">    <span>else</span> <span>if</span> (dwExCode == EXCEPTION_MSVC)</td>
      </tr>
      <tr>
        <td id="L12115" data-line-number="12115"></td>
        <td id="LC12115">    {</td>
      </tr>
      <tr>
        <td id="L12116" data-line-number="12116"></td>
        <td id="LC12116">        <span><span>//</span> The runtime may use C++ exceptions internally. We can still report these</span></td>
      </tr>
      <tr>
        <td id="L12117" data-line-number="12117"></td>
        <td id="LC12117">        <span><span>//</span> to the debugger as long as we're outside of a can't-stop region.</span></td>
      </tr>
      <tr>
        <td id="L12118" data-line-number="12118"></td>
        <td id="LC12118">        <span>if</span> (pUnmanagedThread-&gt;<span>IsCantStop</span>())</td>
      </tr>
      <tr>
        <td id="L12119" data-line-number="12119"></td>
        <td id="LC12119">        {</td>
      </tr>
      <tr>
        <td id="L12120" data-line-number="12120"></td>
        <td id="LC12120">            <span>return</span> <span>REACTION</span>(cCLR);</td>
      </tr>
      <tr>
        <td id="L12121" data-line-number="12121"></td>
        <td id="LC12121">        }</td>
      </tr>
      <tr>
        <td id="L12122" data-line-number="12122"></td>
        <td id="LC12122">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L12123" data-line-number="12123"></td>
        <td id="LC12123">        {</td>
      </tr>
      <tr>
        <td id="L12124" data-line-number="12124"></td>
        <td id="LC12124">            <span>return</span> <span>REACTION</span>(cInband);</td>
      </tr>
      <tr>
        <td id="L12125" data-line-number="12125"></td>
        <td id="LC12125">        }</td>
      </tr>
      <tr>
        <td id="L12126" data-line-number="12126"></td>
        <td id="LC12126">    }</td>
      </tr>
      <tr>
        <td id="L12127" data-line-number="12127"></td>
        <td id="LC12127">    <span>else</span> <span>if</span> (dwExCode == STATUS_BREAKPOINT)</td>
      </tr>
      <tr>
        <td id="L12128" data-line-number="12128"></td>
        <td id="LC12128">    {</td>
      </tr>
      <tr>
        <td id="L12129" data-line-number="12129"></td>
        <td id="LC12129">        <span>return</span> <span>TriageBreakpoint</span>(pUnmanagedThread, pEvent);</td>
      </tr>
      <tr>
        <td id="L12130" data-line-number="12130"></td>
        <td id="LC12130">    }<span><span>//</span> end BP case</span></td>
      </tr>
      <tr>
        <td id="L12131" data-line-number="12131"></td>
        <td id="LC12131">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L12132" data-line-number="12132"></td>
        <td id="LC12132">
</td>
      </tr>
      <tr>
        <td id="L12133" data-line-number="12133"></td>
        <td id="LC12133">    <span><span>//</span> It's not a breakpoint or single-step. Now it just comes down to the address from where</span></td>
      </tr>
      <tr>
        <td id="L12134" data-line-number="12134"></td>
        <td id="LC12134">    <span><span>//</span> the exception is coming from. If it's managed, we give it back to the CLR. If it's</span></td>
      </tr>
      <tr>
        <td id="L12135" data-line-number="12135"></td>
        <td id="LC12135">    <span><span>//</span> from native, then we dispatch to Cordbg.</span></td>
      </tr>
      <tr>
        <td id="L12136" data-line-number="12136"></td>
        <td id="LC12136">    <span><span>//</span> We can use DAC to figure this out from Out-of-process.</span></td>
      </tr>
      <tr>
        <td id="L12137" data-line-number="12137"></td>
        <td id="LC12137">    <span>_ASSERTE</span>(dwExCode != STATUS_BREAKPOINT); <span><span>//</span> BP were already handled.</span></td>
      </tr>
      <tr>
        <td id="L12138" data-line-number="12138"></td>
        <td id="LC12138">
</td>
      </tr>
      <tr>
        <td id="L12139" data-line-number="12139"></td>
        <td id="LC12139">
</td>
      </tr>
      <tr>
        <td id="L12140" data-line-number="12140"></td>
        <td id="LC12140">    <span><span>//</span> Use DAC to decide if it's ours or not w/o going inproc.</span></td>
      </tr>
      <tr>
        <td id="L12141" data-line-number="12141"></td>
        <td id="LC12141">    CORDB_ADDRESS address = <span>PTR_TO_CORDB_ADDRESS</span>(pExAddress);</td>
      </tr>
      <tr>
        <td id="L12142" data-line-number="12142"></td>
        <td id="LC12142">
</td>
      </tr>
      <tr>
        <td id="L12143" data-line-number="12143"></td>
        <td id="LC12143">    IDacDbiInterface::AddressType addrType;</td>
      </tr>
      <tr>
        <td id="L12144" data-line-number="12144"></td>
        <td id="LC12144">
</td>
      </tr>
      <tr>
        <td id="L12145" data-line-number="12145"></td>
        <td id="LC12145">    addrType = <span>GetDAC</span>()-&gt;<span>GetAddressType</span>(address);</td>
      </tr>
      <tr>
        <td id="L12146" data-line-number="12146"></td>
        <td id="LC12146">    <span>bool</span> <span>fIsCorCode</span> =((addrType == IDacDbiInterface::<span>kAddressManagedMethod</span>) ||</td>
      </tr>
      <tr>
        <td id="L12147" data-line-number="12147"></td>
        <td id="LC12147">                      (addrType == IDacDbiInterface::<span>kAddressRuntimeManagedCode</span>) ||</td>
      </tr>
      <tr>
        <td id="L12148" data-line-number="12148"></td>
        <td id="LC12148">                      (addrType == IDacDbiInterface::<span>kAddressRuntimeUnmanagedCode</span>));</td>
      </tr>
      <tr>
        <td id="L12149" data-line-number="12149"></td>
        <td id="LC12149">
</td>
      </tr>
      <tr>
        <td id="L12150" data-line-number="12150"></td>
        <td id="LC12150">    <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: IsCorCode(0x%I64p)=%d<span>\n</span><span>"</span></span>, address, <span>fIsCorCode</span>);</td>
      </tr>
      <tr>
        <td id="L12151" data-line-number="12151"></td>
        <td id="LC12151">
</td>
      </tr>
      <tr>
        <td id="L12152" data-line-number="12152"></td>
        <td id="LC12152">
</td>
      </tr>
      <tr>
        <td id="L12153" data-line-number="12153"></td>
        <td id="LC12153">    <span>if</span> (<span>fIsCorCode</span>)</td>
      </tr>
      <tr>
        <td id="L12154" data-line-number="12154"></td>
        <td id="LC12154">    {</td>
      </tr>
      <tr>
        <td id="L12155" data-line-number="12155"></td>
        <td id="LC12155">        <span>return</span> <span>REACTION</span>(cCLR);</td>
      </tr>
      <tr>
        <td id="L12156" data-line-number="12156"></td>
        <td id="LC12156">    }</td>
      </tr>
      <tr>
        <td id="L12157" data-line-number="12157"></td>
        <td id="LC12157">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L12158" data-line-number="12158"></td>
        <td id="LC12158">    {</td>
      </tr>
      <tr>
        <td id="L12159" data-line-number="12159"></td>
        <td id="LC12159">        <span>if</span> (pUnmanagedThread-&gt;<span>IsCantStop</span>())</td>
      </tr>
      <tr>
        <td id="L12160" data-line-number="12160"></td>
        <td id="LC12160">        {</td>
      </tr>
      <tr>
        <td id="L12161" data-line-number="12161"></td>
        <td id="LC12161">            <span>return</span> <span>REACTION</span>(cOOB);</td>
      </tr>
      <tr>
        <td id="L12162" data-line-number="12162"></td>
        <td id="LC12162">        }</td>
      </tr>
      <tr>
        <td id="L12163" data-line-number="12163"></td>
        <td id="LC12163">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L12164" data-line-number="12164"></td>
        <td id="LC12164">        {</td>
      </tr>
      <tr>
        <td id="L12165" data-line-number="12165"></td>
        <td id="LC12165">            <span>return</span> <span>REACTION</span>(cInband);</td>
      </tr>
      <tr>
        <td id="L12166" data-line-number="12166"></td>
        <td id="LC12166">        }</td>
      </tr>
      <tr>
        <td id="L12167" data-line-number="12167"></td>
        <td id="LC12167">    }</td>
      </tr>
      <tr>
        <td id="L12168" data-line-number="12168"></td>
        <td id="LC12168">
</td>
      </tr>
      <tr>
        <td id="L12169" data-line-number="12169"></td>
        <td id="LC12169">    <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L12170" data-line-number="12170"></td>
        <td id="LC12170">}</td>
      </tr>
      <tr>
        <td id="L12171" data-line-number="12171"></td>
        <td id="LC12171">
</td>
      </tr>
      <tr>
        <td id="L12172" data-line-number="12172"></td>
        <td id="LC12172"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L12173" data-line-number="12173"></td>
        <td id="LC12173"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12174" data-line-number="12174"></td>
        <td id="LC12174"><span><span>//</span> Triage a 1st-chance exception when the CLR is initialized.</span></td>
      </tr>
      <tr>
        <td id="L12175" data-line-number="12175"></td>
        <td id="LC12175"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12176" data-line-number="12176"></td>
        <td id="LC12176"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L12177" data-line-number="12177"></td>
        <td id="LC12177"><span><span>//</span>    pUnmanagedThread - thread that the event has occurred on.</span></td>
      </tr>
      <tr>
        <td id="L12178" data-line-number="12178"></td>
        <td id="LC12178"><span><span>//</span>    pEvent - native debug event for the exception that occurred that this is triaging.</span></td>
      </tr>
      <tr>
        <td id="L12179" data-line-number="12179"></td>
        <td id="LC12179"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12180" data-line-number="12180"></td>
        <td id="LC12180"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L12181" data-line-number="12181"></td>
        <td id="LC12181"><span><span>//</span>    Reaction for how to handle this event.</span></td>
      </tr>
      <tr>
        <td id="L12182" data-line-number="12182"></td>
        <td id="LC12182"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12183" data-line-number="12183"></td>
        <td id="LC12183"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L12184" data-line-number="12184"></td>
        <td id="LC12184"><span><span>//</span>    Called when receiving a debug event when the process is stopped.</span></td>
      </tr>
      <tr>
        <td id="L12185" data-line-number="12185"></td>
        <td id="LC12185"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12186" data-line-number="12186"></td>
        <td id="LC12186"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L12187" data-line-number="12187"></td>
        <td id="LC12187"><span><span>//</span>    A 1st-chance event has a wide spectrum of possibility including:</span></td>
      </tr>
      <tr>
        <td id="L12188" data-line-number="12188"></td>
        <td id="LC12188"><span><span>//</span>    - It may be unmanaged or managed.</span></td>
      </tr>
      <tr>
        <td id="L12189" data-line-number="12189"></td>
        <td id="LC12189"><span><span>//</span>    - Or it may be an execution control exception for managed-exceution</span></td>
      </tr>
      <tr>
        <td id="L12190" data-line-number="12190"></td>
        <td id="LC12190"><span><span>//</span>    - thread skipping an OOB event.</span></td>
      </tr>
      <tr>
        <td id="L12191" data-line-number="12191"></td>
        <td id="LC12191"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12192" data-line-number="12192"></td>
        <td id="LC12192"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L12193" data-line-number="12193"></td>
        <td id="LC12193">Reaction <span>CordbProcess::TriageExcep1stChanceAndInit</span>(CordbUnmanagedThread * pUnmanagedThread,</td>
      </tr>
      <tr>
        <td id="L12194" data-line-number="12194"></td>
        <td id="LC12194">                                                   <span>const</span> DEBUG_EVENT * pEvent)</td>
      </tr>
      <tr>
        <td id="L12195" data-line-number="12195"></td>
        <td id="LC12195">{</td>
      </tr>
      <tr>
        <td id="L12196" data-line-number="12196"></td>
        <td id="LC12196">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L12197" data-line-number="12197"></td>
        <td id="LC12197">    <span>_ASSERTE</span>(m_runtimeOffsetsInitialized);</td>
      </tr>
      <tr>
        <td id="L12198" data-line-number="12198"></td>
        <td id="LC12198">
</td>
      </tr>
      <tr>
        <td id="L12199" data-line-number="12199"></td>
        <td id="LC12199">    NativePatch * pNativePatch = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L12200" data-line-number="12200"></td>
        <td id="LC12200">    DebuggerIPCRuntimeOffsets * pIPCRuntimeOffsets = &amp;(<span>this</span>-&gt;<span>m_runtimeOffsets</span>);</td>
      </tr>
      <tr>
        <td id="L12201" data-line-number="12201"></td>
        <td id="LC12201">
</td>
      </tr>
      <tr>
        <td id="L12202" data-line-number="12202"></td>
        <td id="LC12202">    DWORD dwExCode = pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span>;</td>
      </tr>
      <tr>
        <td id="L12203" data-line-number="12203"></td>
        <td id="LC12203">    <span>const</span> <span>void</span> * pExAddress = pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionAddress</span>;</td>
      </tr>
      <tr>
        <td id="L12204" data-line-number="12204"></td>
        <td id="LC12204">
</td>
      </tr>
      <tr>
        <td id="L12205" data-line-number="12205"></td>
        <td id="LC12205">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TE1stCAI: Enter<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L12206" data-line-number="12206"></td>
        <td id="LC12206">
</td>
      </tr>
      <tr>
        <td id="L12207" data-line-number="12207"></td>
        <td id="LC12207">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L12208" data-line-number="12208"></td>
        <td id="LC12208">    <span><span>//</span> Some Interop bugs involve threads that land at a bad IP. Since we're interop-debugging, we can't</span></td>
      </tr>
      <tr>
        <td id="L12209" data-line-number="12209"></td>
        <td id="LC12209">    <span><span>//</span> attach a debugger to the LS. So we have some debug mode where we enable the SS flag and thus</span></td>
      </tr>
      <tr>
        <td id="L12210" data-line-number="12210"></td>
        <td id="LC12210">    <span><span>//</span> produce a trace of where a thread is going.</span></td>
      </tr>
      <tr>
        <td id="L12211" data-line-number="12211"></td>
        <td id="LC12211">    <span>if</span> (pUnmanagedThread-&gt;<span>IsDEBUGTrace</span>() &amp;&amp; (dwExCode == STATUS_SINGLE_STEP))</td>
      </tr>
      <tr>
        <td id="L12212" data-line-number="12212"></td>
        <td id="LC12212">    {</td>
      </tr>
      <tr>
        <td id="L12213" data-line-number="12213"></td>
        <td id="LC12213">        pUnmanagedThread-&gt;<span>ClearState</span>(CUTS_DEBUG_SingleStep);</td>
      </tr>
      <tr>
        <td id="L12214" data-line-number="12214"></td>
        <td id="LC12214">        <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>DEBUG TRACE, thread %4x at IP: 0x%p<span>\n</span><span>"</span></span>, pUnmanagedThread-&gt;<span>m_id</span>, pExAddress));</td>
      </tr>
      <tr>
        <td id="L12215" data-line-number="12215"></td>
        <td id="LC12215">
</td>
      </tr>
      <tr>
        <td id="L12216" data-line-number="12216"></td>
        <td id="LC12216">        <span><span>//</span> Clear the exception and pretend this never happened.</span></td>
      </tr>
      <tr>
        <td id="L12217" data-line-number="12217"></td>
        <td id="LC12217">        <span>return</span> <span>REACTION</span>(cIgnore);</td>
      </tr>
      <tr>
        <td id="L12218" data-line-number="12218"></td>
        <td id="LC12218">    }</td>
      </tr>
      <tr>
        <td id="L12219" data-line-number="12219"></td>
        <td id="LC12219">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L12220" data-line-number="12220"></td>
        <td id="LC12220">
</td>
      </tr>
      <tr>
        <td id="L12221" data-line-number="12221"></td>
        <td id="LC12221">    <span><span>//</span> If we were stepping for exception retrigger and got the single step and it should be hidden then just ignore it.</span></td>
      </tr>
      <tr>
        <td id="L12222" data-line-number="12222"></td>
        <td id="LC12222">    <span><span>//</span> Anything that isn't cInbandExceptionRetrigger will cause the debug event to be dequeued, stepping turned off, and</span></td>
      </tr>
      <tr>
        <td id="L12223" data-line-number="12223"></td>
        <td id="LC12223">    <span><span>//</span> it will count as not retriggering</span></td>
      </tr>
      <tr>
        <td id="L12224" data-line-number="12224"></td>
        <td id="LC12224">    <span><span>//</span> TODO: I don't think the IsSSFlagNeeded() check is needed here though it doesn't break anything</span></td>
      </tr>
      <tr>
        <td id="L12225" data-line-number="12225"></td>
        <td id="LC12225">    <span>if</span> (pUnmanagedThread-&gt;<span>IsSSFlagNeeded</span>() &amp;&amp; pUnmanagedThread-&gt;<span>IsSSFlagHidden</span>() &amp;&amp; (dwExCode == STATUS_SINGLE_STEP))</td>
      </tr>
      <tr>
        <td id="L12226" data-line-number="12226"></td>
        <td id="LC12226">    {</td>
      </tr>
      <tr>
        <td id="L12227" data-line-number="12227"></td>
        <td id="LC12227">        <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>CP::TE1stCAI: ignoring hidden single step<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L12228" data-line-number="12228"></td>
        <td id="LC12228">        <span>return</span> <span>REACTION</span>(cIgnore);</td>
      </tr>
      <tr>
        <td id="L12229" data-line-number="12229"></td>
        <td id="LC12229">    }</td>
      </tr>
      <tr>
        <td id="L12230" data-line-number="12230"></td>
        <td id="LC12230">
</td>
      </tr>
      <tr>
        <td id="L12231" data-line-number="12231"></td>
        <td id="LC12231">    <span><span>//</span> Is this a breakpoint indicating that the Left Side is now synchronized?</span></td>
      </tr>
      <tr>
        <td id="L12232" data-line-number="12232"></td>
        <td id="LC12232">    <span>if</span> ((dwExCode == STATUS_BREAKPOINT) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L12233" data-line-number="12233"></td>
        <td id="LC12233">        (pExAddress == pIPCRuntimeOffsets-&gt;<span>m_notifyRSOfSyncCompleteBPAddr</span>))</td>
      </tr>
      <tr>
        <td id="L12234" data-line-number="12234"></td>
        <td id="LC12234">    {</td>
      </tr>
      <tr>
        <td id="L12235" data-line-number="12235"></td>
        <td id="LC12235">        <span>return</span> <span>TriageSyncComplete</span>();</td>
      </tr>
      <tr>
        <td id="L12236" data-line-number="12236"></td>
        <td id="LC12236">    }</td>
      </tr>
      <tr>
        <td id="L12237" data-line-number="12237"></td>
        <td id="LC12237">    <span>else</span> <span>if</span> ((dwExCode == STATUS_BREAKPOINT) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L12238" data-line-number="12238"></td>
        <td id="LC12238">             (pExAddress == pIPCRuntimeOffsets-&gt;<span>m_excepForRuntimeHandoffCompleteBPAddr</span>))</td>
      </tr>
      <tr>
        <td id="L12239" data-line-number="12239"></td>
        <td id="LC12239">    {</td>
      </tr>
      <tr>
        <td id="L12240" data-line-number="12240"></td>
        <td id="LC12240">        <span>_ASSERTE</span>(!<span><span>"</span>This should be unused now<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12241" data-line-number="12241"></td>
        <td id="LC12241">
</td>
      </tr>
      <tr>
        <td id="L12242" data-line-number="12242"></td>
        <td id="LC12242">        <span><span>//</span> This notification means that a thread that had been first-chance hijacked is now</span></td>
      </tr>
      <tr>
        <td id="L12243" data-line-number="12243"></td>
        <td id="LC12243">        <span><span>//</span> finally leaving the hijack.</span></td>
      </tr>
      <tr>
        <td id="L12244" data-line-number="12244"></td>
        <td id="LC12244">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TE1stCAI: received 'first chance hijack handoff complete' flare.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12245" data-line-number="12245"></td>
        <td id="LC12245">
</td>
      </tr>
      <tr>
        <td id="L12246" data-line-number="12246"></td>
        <td id="LC12246">        <span><span>//</span> Let the process run.</span></td>
      </tr>
      <tr>
        <td id="L12247" data-line-number="12247"></td>
        <td id="LC12247">        <span>return</span> <span>REACTION</span>(cIgnore);</td>
      </tr>
      <tr>
        <td id="L12248" data-line-number="12248"></td>
        <td id="LC12248">    }</td>
      </tr>
      <tr>
        <td id="L12249" data-line-number="12249"></td>
        <td id="LC12249">    <span>else</span> <span>if</span> ((dwExCode == STATUS_BREAKPOINT) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L12250" data-line-number="12250"></td>
        <td id="LC12250">             (pExAddress == pIPCRuntimeOffsets-&gt;<span>m_signalHijackCompleteBPAddr</span>))</td>
      </tr>
      <tr>
        <td id="L12251" data-line-number="12251"></td>
        <td id="LC12251">    {</td>
      </tr>
      <tr>
        <td id="L12252" data-line-number="12252"></td>
        <td id="LC12252">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TE1stCAI: received 'hijack complete' flare.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12253" data-line-number="12253"></td>
        <td id="LC12253">        <span>return</span> <span>REACTION</span>(cInbandHijackComplete);</td>
      </tr>
      <tr>
        <td id="L12254" data-line-number="12254"></td>
        <td id="LC12254">    }</td>
      </tr>
      <tr>
        <td id="L12255" data-line-number="12255"></td>
        <td id="LC12255">    <span>else</span> <span>if</span> ((dwExCode == STATUS_BREAKPOINT) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L12256" data-line-number="12256"></td>
        <td id="LC12256">             (pExAddress == m_runtimeOffsets.<span>m_signalHijackStartedBPAddr</span>))</td>
      </tr>
      <tr>
        <td id="L12257" data-line-number="12257"></td>
        <td id="LC12257">    {</td>
      </tr>
      <tr>
        <td id="L12258" data-line-number="12258"></td>
        <td id="LC12258">        <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TE1stCAI: received 'hijack started' flare.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12259" data-line-number="12259"></td>
        <td id="LC12259">        <span>return</span> <span>REACTION</span>(cFirstChanceHijackStarted);</td>
      </tr>
      <tr>
        <td id="L12260" data-line-number="12260"></td>
        <td id="LC12260">    }</td>
      </tr>
      <tr>
        <td id="L12261" data-line-number="12261"></td>
        <td id="LC12261">    <span>else</span> <span>if</span> ((dwExCode == STATUS_BREAKPOINT) &amp;&amp; ((pNativePatch = <span>GetNativePatch</span>(pExAddress)) != <span>NULL</span>) )</td>
      </tr>
      <tr>
        <td id="L12262" data-line-number="12262"></td>
        <td id="LC12262">    {</td>
      </tr>
      <tr>
        <td id="L12263" data-line-number="12263"></td>
        <td id="LC12263">        <span><span>//</span> We hit a native BP placed by Cordbg.  This could happen on any thread (including helper)</span></td>
      </tr>
      <tr>
        <td id="L12264" data-line-number="12264"></td>
        <td id="LC12264">        <span>bool</span> <span>fCantStop</span> = pUnmanagedThread-&gt;<span>IsCantStop</span>();</td>
      </tr>
      <tr>
        <td id="L12265" data-line-number="12265"></td>
        <td id="LC12265">
</td>
      </tr>
      <tr>
        <td id="L12266" data-line-number="12266"></td>
        <td id="LC12266">        <span><span>//</span> REVISIT_TODO: if the user also set a breakpoint here then we should dispatch to the debugger</span></td>
      </tr>
      <tr>
        <td id="L12267" data-line-number="12267"></td>
        <td id="LC12267">        <span><span>//</span> and rely on the debugger to get us past this. Should be a rare case though.</span></td>
      </tr>
      <tr>
        <td id="L12268" data-line-number="12268"></td>
        <td id="LC12268">        <span>if</span> (<span>fCantStop</span>)</td>
      </tr>
      <tr>
        <td id="L12269" data-line-number="12269"></td>
        <td id="LC12269">        {</td>
      </tr>
      <tr>
        <td id="L12270" data-line-number="12270"></td>
        <td id="LC12270">            <span><span>//</span> Need to skip it completely; never dispatch.</span></td>
      </tr>
      <tr>
        <td id="L12271" data-line-number="12271"></td>
        <td id="LC12271">            pUnmanagedThread-&gt;<span>SetupForSkipBreakpoint</span>(pNativePatch);</td>
      </tr>
      <tr>
        <td id="L12272" data-line-number="12272"></td>
        <td id="LC12272">
</td>
      </tr>
      <tr>
        <td id="L12273" data-line-number="12273"></td>
        <td id="LC12273">            <span><span>//</span> Debuggee will single step over the patch, and fire a SS exception.</span></td>
      </tr>
      <tr>
        <td id="L12274" data-line-number="12274"></td>
        <td id="LC12274">            <span><span>//</span> We'll then call FixupForSkipBreakpoint, and continue the process.</span></td>
      </tr>
      <tr>
        <td id="L12275" data-line-number="12275"></td>
        <td id="LC12275">            <span>return</span> <span>REACTION</span>(cIgnore);</td>
      </tr>
      <tr>
        <td id="L12276" data-line-number="12276"></td>
        <td id="LC12276">        }</td>
      </tr>
      <tr>
        <td id="L12277" data-line-number="12277"></td>
        <td id="LC12277">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L12278" data-line-number="12278"></td>
        <td id="LC12278">        {</td>
      </tr>
      <tr>
        <td id="L12279" data-line-number="12279"></td>
        <td id="LC12279">            <span><span>//</span> Native patch in native code. A very common scenario.</span></td>
      </tr>
      <tr>
        <td id="L12280" data-line-number="12280"></td>
        <td id="LC12280">            <span><span>//</span> Dispatch as an IB event to Cordbg.</span></td>
      </tr>
      <tr>
        <td id="L12281" data-line-number="12281"></td>
        <td id="LC12281">            <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO10000, <span><span>"</span>Native patch in native code (at %p), dispatching as IB event.<span>\n</span><span>"</span></span>, pExAddress);</td>
      </tr>
      <tr>
        <td id="L12282" data-line-number="12282"></td>
        <td id="LC12282">            <span>return</span> <span>REACTION</span>(cInband);</td>
      </tr>
      <tr>
        <td id="L12283" data-line-number="12283"></td>
        <td id="LC12283">        }</td>
      </tr>
      <tr>
        <td id="L12284" data-line-number="12284"></td>
        <td id="LC12284">
</td>
      </tr>
      <tr>
        <td id="L12285" data-line-number="12285"></td>
        <td id="LC12285">        <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L12286" data-line-number="12286"></td>
        <td id="LC12286">    }</td>
      </tr>
      <tr>
        <td id="L12287" data-line-number="12287"></td>
        <td id="LC12287">
</td>
      </tr>
      <tr>
        <td id="L12288" data-line-number="12288"></td>
        <td id="LC12288">    <span>else</span> <span>if</span> ((dwExCode == STATUS_BREAKPOINT) &amp;&amp; !<span>IsBreakOpcodeAtAddress</span>(pExAddress))</td>
      </tr>
      <tr>
        <td id="L12289" data-line-number="12289"></td>
        <td id="LC12289">    {</td>
      </tr>
      <tr>
        <td id="L12290" data-line-number="12290"></td>
        <td id="LC12290">        <span><span>//</span> If we got an int3 exception, but there's not actually an int3 at the address, then just reset the IP</span></td>
      </tr>
      <tr>
        <td id="L12291" data-line-number="12291"></td>
        <td id="LC12291">        <span><span>//</span> to the address. This can happen if the int 3 is cleared after the thread has dispatched it (in which case</span></td>
      </tr>
      <tr>
        <td id="L12292" data-line-number="12292"></td>
        <td id="LC12292">        <span><span>//</span> WFDE will pick it up) but before we realize it's one of ours.</span></td>
      </tr>
      <tr>
        <td id="L12293" data-line-number="12293"></td>
        <td id="LC12293">        <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TE1stCAI: Phantom Int3: Tid=0x%x, addr=%p<span>\n</span><span>"</span></span>, pEvent-&gt;<span>dwThreadId</span>, pExAddress);</td>
      </tr>
      <tr>
        <td id="L12294" data-line-number="12294"></td>
        <td id="LC12294">
</td>
      </tr>
      <tr>
        <td id="L12295" data-line-number="12295"></td>
        <td id="LC12295">        DT_CONTEXT context;</td>
      </tr>
      <tr>
        <td id="L12296" data-line-number="12296"></td>
        <td id="LC12296">
</td>
      </tr>
      <tr>
        <td id="L12297" data-line-number="12297"></td>
        <td id="LC12297">        context.<span>ContextFlags</span> = DT_CONTEXT_FULL;</td>
      </tr>
      <tr>
        <td id="L12298" data-line-number="12298"></td>
        <td id="LC12298">
</td>
      </tr>
      <tr>
        <td id="L12299" data-line-number="12299"></td>
        <td id="LC12299">        BOOL <span>fSuccess</span> = <span>DbiGetThreadContext</span>(pUnmanagedThread-&gt;<span>m_handle</span>, &amp;context);</td>
      </tr>
      <tr>
        <td id="L12300" data-line-number="12300"></td>
        <td id="LC12300">
</td>
      </tr>
      <tr>
        <td id="L12301" data-line-number="12301"></td>
        <td id="LC12301">        <span>_ASSERTE</span>(<span>fSuccess</span>);</td>
      </tr>
      <tr>
        <td id="L12302" data-line-number="12302"></td>
        <td id="LC12302">
</td>
      </tr>
      <tr>
        <td id="L12303" data-line-number="12303"></td>
        <td id="LC12303">        <span>if</span> (<span>fSuccess</span>)</td>
      </tr>
      <tr>
        <td id="L12304" data-line-number="12304"></td>
        <td id="LC12304">        {</td>
      </tr>
      <tr>
        <td id="L12305" data-line-number="12305"></td>
        <td id="LC12305">            <span><span>//</span> Backup IP to point to the instruction we need to execute. Continuing from a breakpoint exception</span></td>
      </tr>
      <tr>
        <td id="L12306" data-line-number="12306"></td>
        <td id="LC12306">            <span><span>//</span> continues execution at the instruction after the breakpoint, but we need to continue where the</span></td>
      </tr>
      <tr>
        <td id="L12307" data-line-number="12307"></td>
        <td id="LC12307">            <span><span>//</span> breakpoint was.</span></td>
      </tr>
      <tr>
        <td id="L12308" data-line-number="12308"></td>
        <td id="LC12308">            <span>CORDbgSetIP</span>(&amp;context, (LPVOID) pExAddress);</td>
      </tr>
      <tr>
        <td id="L12309" data-line-number="12309"></td>
        <td id="LC12309">
</td>
      </tr>
      <tr>
        <td id="L12310" data-line-number="12310"></td>
        <td id="LC12310">            <span>fSuccess</span> = <span>DbiSetThreadContext</span>(pUnmanagedThread-&gt;<span>m_handle</span>, &amp;context);</td>
      </tr>
      <tr>
        <td id="L12311" data-line-number="12311"></td>
        <td id="LC12311">            <span>_ASSERTE</span>(<span>fSuccess</span>);</td>
      </tr>
      <tr>
        <td id="L12312" data-line-number="12312"></td>
        <td id="LC12312">        }</td>
      </tr>
      <tr>
        <td id="L12313" data-line-number="12313"></td>
        <td id="LC12313">
</td>
      </tr>
      <tr>
        <td id="L12314" data-line-number="12314"></td>
        <td id="LC12314">        <span>return</span> <span>REACTION</span>(cIgnore);</td>
      </tr>
      <tr>
        <td id="L12315" data-line-number="12315"></td>
        <td id="LC12315">    }</td>
      </tr>
      <tr>
        <td id="L12316" data-line-number="12316"></td>
        <td id="LC12316">    <span>else</span> <span>if</span> (pUnmanagedThread-&gt;<span>IsSkippingNativePatch</span>())</td>
      </tr>
      <tr>
        <td id="L12317" data-line-number="12317"></td>
        <td id="LC12317">    {</td>
      </tr>
      <tr>
        <td id="L12318" data-line-number="12318"></td>
        <td id="LC12318">        <span><span>//</span> If we Single-Step over an exception, then the OS never gives us the single-step event.</span></td>
      </tr>
      <tr>
        <td id="L12319" data-line-number="12319"></td>
        <td id="LC12319">        <span><span>//</span> Thus if we're skipping a native patch, we don't care what exception event we got.</span></td>
      </tr>
      <tr>
        <td id="L12320" data-line-number="12320"></td>
        <td id="LC12320">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>Done skipping native patch. Ex=0x%x<span>\n</span>, IsSS=%d<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12321" data-line-number="12321"></td>
        <td id="LC12321">             dwExCode,</td>
      </tr>
      <tr>
        <td id="L12322" data-line-number="12322"></td>
        <td id="LC12322">             (dwExCode == STATUS_SINGLE_STEP)));</td>
      </tr>
      <tr>
        <td id="L12323" data-line-number="12323"></td>
        <td id="LC12323">
</td>
      </tr>
      <tr>
        <td id="L12324" data-line-number="12324"></td>
        <td id="LC12324">        <span><span>//</span> This is the 2nd half of skipping a native patch.</span></td>
      </tr>
      <tr>
        <td id="L12325" data-line-number="12325"></td>
        <td id="LC12325">        <span><span>//</span> This could happen on any thread (including helper)</span></td>
      </tr>
      <tr>
        <td id="L12326" data-line-number="12326"></td>
        <td id="LC12326">        <span><span>//</span> We've already removed the opcode and now we just finished a single-step over it.</span></td>
      </tr>
      <tr>
        <td id="L12327" data-line-number="12327"></td>
        <td id="LC12327">        <span><span>//</span> So put the patch back in, and continue the process.</span></td>
      </tr>
      <tr>
        <td id="L12328" data-line-number="12328"></td>
        <td id="LC12328">        pUnmanagedThread-&gt;<span>FixupForSkipBreakpoint</span>();</td>
      </tr>
      <tr>
        <td id="L12329" data-line-number="12329"></td>
        <td id="LC12329">
</td>
      </tr>
      <tr>
        <td id="L12330" data-line-number="12330"></td>
        <td id="LC12330">        <span>return</span> <span>REACTION</span>(cIgnore);</td>
      </tr>
      <tr>
        <td id="L12331" data-line-number="12331"></td>
        <td id="LC12331">    }</td>
      </tr>
      <tr>
        <td id="L12332" data-line-number="12332"></td>
        <td id="LC12332">    <span>else</span> <span>if</span> (<span>this</span>-&gt;<span>IsHelperThreadWorked</span>(pUnmanagedThread-&gt;<span>GetOSTid</span>()))</td>
      </tr>
      <tr>
        <td id="L12333" data-line-number="12333"></td>
        <td id="LC12333">    {</td>
      </tr>
      <tr>
        <td id="L12334" data-line-number="12334"></td>
        <td id="LC12334">        <span><span>//</span> We should never ever get a single-step event from the helper thread.</span></td>
      </tr>
      <tr>
        <td id="L12335" data-line-number="12335"></td>
        <td id="LC12335">        <span>CONSISTENCY_CHECK_MSGF</span>(dwExCode != STATUS_SINGLE_STEP, (</td>
      </tr>
      <tr>
        <td id="L12336" data-line-number="12336"></td>
        <td id="LC12336">                <span><span>"</span>Single-Step exception on helper thread (tid=0x%x/%d) in debuggee process (pid=0x%x/%d).<span>\n</span><span>"</span></span></td>
      </tr>
      <tr>
        <td id="L12337" data-line-number="12337"></td>
        <td id="LC12337">                <span><span>"</span>For more information, attach a debuggee non-invasively to the LS to get the callstack.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12338" data-line-number="12338"></td>
        <td id="LC12338">                pUnmanagedThread-&gt;<span>m_id</span>,</td>
      </tr>
      <tr>
        <td id="L12339" data-line-number="12339"></td>
        <td id="LC12339">                pUnmanagedThread-&gt;<span>m_id</span>,</td>
      </tr>
      <tr>
        <td id="L12340" data-line-number="12340"></td>
        <td id="LC12340">                <span>this</span>-&gt;<span>m_id</span>,</td>
      </tr>
      <tr>
        <td id="L12341" data-line-number="12341"></td>
        <td id="LC12341">                <span>this</span>-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L12342" data-line-number="12342"></td>
        <td id="LC12342">
</td>
      </tr>
      <tr>
        <td id="L12343" data-line-number="12343"></td>
        <td id="LC12343">        <span><span>//</span> We ignore any first chance exceptions from the helper thread. There are lots of places</span></td>
      </tr>
      <tr>
        <td id="L12344" data-line-number="12344"></td>
        <td id="LC12344">        <span><span>//</span> on the left side where we attempt to dereference bad object refs and such that will be</span></td>
      </tr>
      <tr>
        <td id="L12345" data-line-number="12345"></td>
        <td id="LC12345">        <span><span>//</span> handled by exception handlers already in place.</span></td>
      </tr>
      <tr>
        <td id="L12346" data-line-number="12346"></td>
        <td id="LC12346">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12347" data-line-number="12347"></td>
        <td id="LC12347">        <span><span>//</span> Note: we check this after checking for the sync complete notification, since that can</span></td>
      </tr>
      <tr>
        <td id="L12348" data-line-number="12348"></td>
        <td id="LC12348">        <span><span>//</span> come from the helper thread.</span></td>
      </tr>
      <tr>
        <td id="L12349" data-line-number="12349"></td>
        <td id="LC12349">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12350" data-line-number="12350"></td>
        <td id="LC12350">        <span><span>//</span> Note: we do let single step and breakpoint exceptions go through to the debugger for processing.</span></td>
      </tr>
      <tr>
        <td id="L12351" data-line-number="12351"></td>
        <td id="LC12351">        <span>if</span> ((dwExCode != STATUS_BREAKPOINT) &amp;&amp; (dwExCode != STATUS_SINGLE_STEP))</td>
      </tr>
      <tr>
        <td id="L12352" data-line-number="12352"></td>
        <td id="LC12352">        {</td>
      </tr>
      <tr>
        <td id="L12353" data-line-number="12353"></td>
        <td id="LC12353">            <span>return</span> <span>REACTION</span>(cCLR);</td>
      </tr>
      <tr>
        <td id="L12354" data-line-number="12354"></td>
        <td id="LC12354">        }</td>
      </tr>
      <tr>
        <td id="L12355" data-line-number="12355"></td>
        <td id="LC12355">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L12356" data-line-number="12356"></td>
        <td id="LC12356">        {</td>
      </tr>
      <tr>
        <td id="L12357" data-line-number="12357"></td>
        <td id="LC12357">            <span><span>//</span> Since the helper thread is part of the "can't stop" region, we should have already</span></td>
      </tr>
      <tr>
        <td id="L12358" data-line-number="12358"></td>
        <td id="LC12358">            <span><span>//</span> skipped any BPs on it.</span></td>
      </tr>
      <tr>
        <td id="L12359" data-line-number="12359"></td>
        <td id="LC12359">            <span><span>//</span> However, any Assert on the helper thread will hit this case.</span></td>
      </tr>
      <tr>
        <td id="L12360" data-line-number="12360"></td>
        <td id="LC12360">            <span>CONSISTENCY_CHECK_MSGF</span>((dwExCode != STATUS_BREAKPOINT), (</td>
      </tr>
      <tr>
        <td id="L12361" data-line-number="12361"></td>
        <td id="LC12361">                <span><span>"</span>Assert on helper thread (tid=0x%x/%d) in debuggee process (pid=0x%x/%d).<span>\n</span><span>"</span></span></td>
      </tr>
      <tr>
        <td id="L12362" data-line-number="12362"></td>
        <td id="LC12362">                <span><span>"</span>For more information, attach a debuggee non-invasively to the LS to get the callstack.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12363" data-line-number="12363"></td>
        <td id="LC12363">                pUnmanagedThread-&gt;<span>m_id</span>,</td>
      </tr>
      <tr>
        <td id="L12364" data-line-number="12364"></td>
        <td id="LC12364">                pUnmanagedThread-&gt;<span>m_id</span>,</td>
      </tr>
      <tr>
        <td id="L12365" data-line-number="12365"></td>
        <td id="LC12365">                <span>this</span>-&gt;<span>m_id</span>,</td>
      </tr>
      <tr>
        <td id="L12366" data-line-number="12366"></td>
        <td id="LC12366">                <span>this</span>-&gt;<span>m_id</span>));</td>
      </tr>
      <tr>
        <td id="L12367" data-line-number="12367"></td>
        <td id="LC12367">
</td>
      </tr>
      <tr>
        <td id="L12368" data-line-number="12368"></td>
        <td id="LC12368">            <span><span>//</span> These breakpoint and single step exceptions have to be dispatched to the debugger as</span></td>
      </tr>
      <tr>
        <td id="L12369" data-line-number="12369"></td>
        <td id="LC12369">            <span><span>//</span> out-of-band events. This tells the debugger that they must continue from these events</span></td>
      </tr>
      <tr>
        <td id="L12370" data-line-number="12370"></td>
        <td id="LC12370">            <span><span>//</span> immediatly, and that no interaction with the Left Side is allowed until they do so. This</span></td>
      </tr>
      <tr>
        <td id="L12371" data-line-number="12371"></td>
        <td id="LC12371">            <span><span>//</span> makes sense, since these events are on the helper thread.</span></td>
      </tr>
      <tr>
        <td id="L12372" data-line-number="12372"></td>
        <td id="LC12372">            <span>return</span> <span>REACTION</span>(cOOB);</td>
      </tr>
      <tr>
        <td id="L12373" data-line-number="12373"></td>
        <td id="LC12373">        }</td>
      </tr>
      <tr>
        <td id="L12374" data-line-number="12374"></td>
        <td id="LC12374">        <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L12375" data-line-number="12375"></td>
        <td id="LC12375">    }</td>
      </tr>
      <tr>
        <td id="L12376" data-line-number="12376"></td>
        <td id="LC12376">    <span>else</span> <span>if</span> (pUnmanagedThread-&gt;<span>IsFirstChanceHijacked</span>() &amp;&amp; <span>this</span>-&gt;<span>ExceptionIsFlare</span>(dwExCode, pExAddress))</td>
      </tr>
      <tr>
        <td id="L12377" data-line-number="12377"></td>
        <td id="LC12377">    {</td>
      </tr>
      <tr>
        <td id="L12378" data-line-number="12378"></td>
        <td id="LC12378">        <span>_ASSERTE</span>(!<span><span>"</span>This should be unused now<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12379" data-line-number="12379"></td>
        <td id="LC12379">    }</td>
      </tr>
      <tr>
        <td id="L12380" data-line-number="12380"></td>
        <td id="LC12380">    <span>else</span> <span>if</span> (pUnmanagedThread-&gt;<span>IsGenericHijacked</span>())</td>
      </tr>
      <tr>
        <td id="L12381" data-line-number="12381"></td>
        <td id="LC12381">    {</td>
      </tr>
      <tr>
        <td id="L12382" data-line-number="12382"></td>
        <td id="LC12382">        <span>if</span> (<span>this</span>-&gt;<span>ExceptionIsFlare</span>(dwExCode, pExAddress))</td>
      </tr>
      <tr>
        <td id="L12383" data-line-number="12383"></td>
        <td id="LC12383">        {</td>
      </tr>
      <tr>
        <td id="L12384" data-line-number="12384"></td>
        <td id="LC12384">            <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TE1stCAI: fixing up from generic hijack.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12385" data-line-number="12385"></td>
        <td id="LC12385">
</td>
      </tr>
      <tr>
        <td id="L12386" data-line-number="12386"></td>
        <td id="LC12386">            <span>_ASSERTE</span>(dwExCode == STATUS_BREAKPOINT);</td>
      </tr>
      <tr>
        <td id="L12387" data-line-number="12387"></td>
        <td id="LC12387">
</td>
      </tr>
      <tr>
        <td id="L12388" data-line-number="12388"></td>
        <td id="LC12388">            <span><span>//</span> Fixup the thread from the generic hijack.</span></td>
      </tr>
      <tr>
        <td id="L12389" data-line-number="12389"></td>
        <td id="LC12389">            pUnmanagedThread-&gt;<span>FixupFromGenericHijack</span>();</td>
      </tr>
      <tr>
        <td id="L12390" data-line-number="12390"></td>
        <td id="LC12390">
</td>
      </tr>
      <tr>
        <td id="L12391" data-line-number="12391"></td>
        <td id="LC12391">            <span><span>//</span> We force continue from this flare, since its only purpose was to notify us that we had to</span></td>
      </tr>
      <tr>
        <td id="L12392" data-line-number="12392"></td>
        <td id="LC12392">            <span><span>//</span> fixup the thread from a generic hijack.</span></td>
      </tr>
      <tr>
        <td id="L12393" data-line-number="12393"></td>
        <td id="LC12393">            <span>return</span> <span>REACTION</span>(cIgnore);</td>
      </tr>
      <tr>
        <td id="L12394" data-line-number="12394"></td>
        <td id="LC12394">        }</td>
      </tr>
      <tr>
        <td id="L12395" data-line-number="12395"></td>
        <td id="LC12395">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L12396" data-line-number="12396"></td>
        <td id="LC12396">        {</td>
      </tr>
      <tr>
        <td id="L12397" data-line-number="12397"></td>
        <td id="LC12397">            <span><span>//</span> We might reach here due to the stack overflow issue, due to target</span></td>
      </tr>
      <tr>
        <td id="L12398" data-line-number="12398"></td>
        <td id="LC12398">            <span><span>//</span> memory corruption, or even due to an exception thrown during hijacking</span></td>
      </tr>
      <tr>
        <td id="L12399" data-line-number="12399"></td>
        <td id="LC12399">
</td>
      </tr>
      <tr>
        <td id="L12400" data-line-number="12400"></td>
        <td id="LC12400">            BOOL bStackOverflow = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L12401" data-line-number="12401"></td>
        <td id="LC12401">
</td>
      </tr>
      <tr>
        <td id="L12402" data-line-number="12402"></td>
        <td id="LC12402">            <span>if</span> (dwExCode == STATUS_ACCESS_VIOLATION || dwExCode == STATUS_STACK_OVERFLOW)</td>
      </tr>
      <tr>
        <td id="L12403" data-line-number="12403"></td>
        <td id="LC12403">            {</td>
      </tr>
      <tr>
        <td id="L12404" data-line-number="12404"></td>
        <td id="LC12404">                CORDB_ADDRESS stackLimit;</td>
      </tr>
      <tr>
        <td id="L12405" data-line-number="12405"></td>
        <td id="LC12405">                CORDB_ADDRESS stackBase;</td>
      </tr>
      <tr>
        <td id="L12406" data-line-number="12406"></td>
        <td id="LC12406">                <span>if</span> (pUnmanagedThread-&gt;<span>GetStackRange</span>(&amp;stackBase, &amp;stackLimit))</td>
      </tr>
      <tr>
        <td id="L12407" data-line-number="12407"></td>
        <td id="LC12407">                {</td>
      </tr>
      <tr>
        <td id="L12408" data-line-number="12408"></td>
        <td id="LC12408">                    TADDR addr = pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionInformation</span>[<span>1</span>];</td>
      </tr>
      <tr>
        <td id="L12409" data-line-number="12409"></td>
        <td id="LC12409">                    <span>if</span> (stackLimit &lt;= addr &amp;&amp; addr &lt; stackBase)</td>
      </tr>
      <tr>
        <td id="L12410" data-line-number="12410"></td>
        <td id="LC12410">                        bStackOverflow = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L12411" data-line-number="12411"></td>
        <td id="LC12411">                }</td>
      </tr>
      <tr>
        <td id="L12412" data-line-number="12412"></td>
        <td id="LC12412">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L12413" data-line-number="12413"></td>
        <td id="LC12413">                {</td>
      </tr>
      <tr>
        <td id="L12414" data-line-number="12414"></td>
        <td id="LC12414">                    <span><span>//</span> to limit the impact of the change we'll consider failure to retrieve the stack</span></td>
      </tr>
      <tr>
        <td id="L12415" data-line-number="12415"></td>
        <td id="LC12415">                    <span><span>//</span> bounds as stack overflow as well</span></td>
      </tr>
      <tr>
        <td id="L12416" data-line-number="12416"></td>
        <td id="LC12416">                    bStackOverflow = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L12417" data-line-number="12417"></td>
        <td id="LC12417">                }</td>
      </tr>
      <tr>
        <td id="L12418" data-line-number="12418"></td>
        <td id="LC12418">            }</td>
      </tr>
      <tr>
        <td id="L12419" data-line-number="12419"></td>
        <td id="LC12419">
</td>
      </tr>
      <tr>
        <td id="L12420" data-line-number="12420"></td>
        <td id="LC12420">            <span>if</span> (!bStackOverflow)</td>
      </tr>
      <tr>
        <td id="L12421" data-line-number="12421"></td>
        <td id="LC12421">            {</td>
      </tr>
      <tr>
        <td id="L12422" data-line-number="12422"></td>
        <td id="LC12422">                <span><span>//</span> generic hijack means we're in CantStop, so return cOOB</span></td>
      </tr>
      <tr>
        <td id="L12423" data-line-number="12423"></td>
        <td id="LC12423">                <span>return</span> <span>REACTION</span>(cOOB);</td>
      </tr>
      <tr>
        <td id="L12424" data-line-number="12424"></td>
        <td id="LC12424">            }</td>
      </tr>
      <tr>
        <td id="L12425" data-line-number="12425"></td>
        <td id="LC12425">
</td>
      </tr>
      <tr>
        <td id="L12426" data-line-number="12426"></td>
        <td id="LC12426">            <span><span>//</span> If generichijacked and its not a flare, and the address referenced is on the stack then we've</span></td>
      </tr>
      <tr>
        <td id="L12427" data-line-number="12427"></td>
        <td id="LC12427">            <span><span>//</span> got our special stack overflow case. Take off generic hijacked, mark that the helper thread</span></td>
      </tr>
      <tr>
        <td id="L12428" data-line-number="12428"></td>
        <td id="LC12428">            <span><span>//</span> is dead, throw this event on the floor, and pop anyone in SendIPCEvent out of their wait.</span></td>
      </tr>
      <tr>
        <td id="L12429" data-line-number="12429"></td>
        <td id="LC12429">            pUnmanagedThread-&gt;<span>ClearState</span>(CUTS_GenericHijacked);</td>
      </tr>
      <tr>
        <td id="L12430" data-line-number="12430"></td>
        <td id="LC12430">
</td>
      </tr>
      <tr>
        <td id="L12431" data-line-number="12431"></td>
        <td id="LC12431">            <span>this</span>-&gt;<span>m_helperThreadDead</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L12432" data-line-number="12432"></td>
        <td id="LC12432">
</td>
      </tr>
      <tr>
        <td id="L12433" data-line-number="12433"></td>
        <td id="LC12433">            <span><span>//</span> This only works on Windows, not on Mac.  We don't support interop-debugging on Mac anyway.</span></td>
      </tr>
      <tr>
        <td id="L12434" data-line-number="12434"></td>
        <td id="LC12434">            <span>SetEvent</span>(m_pEventChannel-&gt;<span>GetRightSideEventAckHandle</span>());</td>
      </tr>
      <tr>
        <td id="L12435" data-line-number="12435"></td>
        <td id="LC12435">
</td>
      </tr>
      <tr>
        <td id="L12436" data-line-number="12436"></td>
        <td id="LC12436">            <span><span>//</span> Note: we remember that this was a second chance event from one of the special stack overflow</span></td>
      </tr>
      <tr>
        <td id="L12437" data-line-number="12437"></td>
        <td id="LC12437">            <span><span>//</span> cases with CUES_ExceptionUnclearable. This tells us to force the process to terminate when we</span></td>
      </tr>
      <tr>
        <td id="L12438" data-line-number="12438"></td>
        <td id="LC12438">            <span><span>//</span> continue from the event. Since for some odd reason the OS decides to re-raise this exception</span></td>
      </tr>
      <tr>
        <td id="L12439" data-line-number="12439"></td>
        <td id="LC12439">            <span><span>//</span> (first chance then second chance) infinitely.</span></td>
      </tr>
      <tr>
        <td id="L12440" data-line-number="12440"></td>
        <td id="LC12440">
</td>
      </tr>
      <tr>
        <td id="L12441" data-line-number="12441"></td>
        <td id="LC12441">            <span>_ASSERTE</span>(pUnmanagedThread-&gt;<span>HasIBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L12442" data-line-number="12442"></td>
        <td id="LC12442">
</td>
      </tr>
      <tr>
        <td id="L12443" data-line-number="12443"></td>
        <td id="LC12443">            pUnmanagedThread-&gt;<span>IBEvent</span>()-&gt;<span>SetState</span>(CUES_ExceptionUnclearable);</td>
      </tr>
      <tr>
        <td id="L12444" data-line-number="12444"></td>
        <td id="LC12444">
</td>
      </tr>
      <tr>
        <td id="L12445" data-line-number="12445"></td>
        <td id="LC12445">            <span><span>//</span>newEvent = false;</span></td>
      </tr>
      <tr>
        <td id="L12446" data-line-number="12446"></td>
        <td id="LC12446">            <span>return</span> <span>REACTION</span>(cInband_NotNewEvent);</td>
      </tr>
      <tr>
        <td id="L12447" data-line-number="12447"></td>
        <td id="LC12447">        }</td>
      </tr>
      <tr>
        <td id="L12448" data-line-number="12448"></td>
        <td id="LC12448">    }</td>
      </tr>
      <tr>
        <td id="L12449" data-line-number="12449"></td>
        <td id="LC12449">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L12450" data-line-number="12450"></td>
        <td id="LC12450">    {</td>
      </tr>
      <tr>
        <td id="L12451" data-line-number="12451"></td>
        <td id="LC12451">	    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TE1stCAI: Triage1stChanceNonSpecial<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L12452" data-line-number="12452"></td>
        <td id="LC12452">
</td>
      </tr>
      <tr>
        <td id="L12453" data-line-number="12453"></td>
        <td id="LC12453">        Reaction <span>r</span>(<span>REACTION</span>(cOOB));</td>
      </tr>
      <tr>
        <td id="L12454" data-line-number="12454"></td>
        <td id="LC12454">        HRESULT hrCheck = S_OK;;</td>
      </tr>
      <tr>
        <td id="L12455" data-line-number="12455"></td>
        <td id="LC12455">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L12456" data-line-number="12456"></td>
        <td id="LC12456">        {</td>
      </tr>
      <tr>
        <td id="L12457" data-line-number="12457"></td>
        <td id="LC12457">            r = <span>Triage1stChanceNonSpecial</span>(pUnmanagedThread, pEvent);</td>
      </tr>
      <tr>
        <td id="L12458" data-line-number="12458"></td>
        <td id="LC12458">        }</td>
      </tr>
      <tr>
        <td id="L12459" data-line-number="12459"></td>
        <td id="LC12459">        <span>EX_CATCH_HRESULT</span>(hrCheck);</td>
      </tr>
      <tr>
        <td id="L12460" data-line-number="12460"></td>
        <td id="LC12460">        <span>SIMPLIFYING_ASSUMPTION</span>(<span>SUCCEEDED</span>(hrCheck));</td>
      </tr>
      <tr>
        <td id="L12461" data-line-number="12461"></td>
        <td id="LC12461">        <span>SetUnrecoverableIfFailed</span>(<span>this</span>, hrCheck);</td>
      </tr>
      <tr>
        <td id="L12462" data-line-number="12462"></td>
        <td id="LC12462">
</td>
      </tr>
      <tr>
        <td id="L12463" data-line-number="12463"></td>
        <td id="LC12463">        <span>return</span> r;</td>
      </tr>
      <tr>
        <td id="L12464" data-line-number="12464"></td>
        <td id="LC12464">
</td>
      </tr>
      <tr>
        <td id="L12465" data-line-number="12465"></td>
        <td id="LC12465">    }</td>
      </tr>
      <tr>
        <td id="L12466" data-line-number="12466"></td>
        <td id="LC12466">
</td>
      </tr>
      <tr>
        <td id="L12467" data-line-number="12467"></td>
        <td id="LC12467">    <span><span>//</span> At this point, any first-chance exceptions that could be special have been handled. Any</span></td>
      </tr>
      <tr>
        <td id="L12468" data-line-number="12468"></td>
        <td id="LC12468">    <span><span>//</span> first-chance exception that we're still processing at this point is destined to be</span></td>
      </tr>
      <tr>
        <td id="L12469" data-line-number="12469"></td>
        <td id="LC12469">    <span><span>//</span> dispatched as an unmanaged event.</span></td>
      </tr>
      <tr>
        <td id="L12470" data-line-number="12470"></td>
        <td id="LC12470">    <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L12471" data-line-number="12471"></td>
        <td id="LC12471">}</td>
      </tr>
      <tr>
        <td id="L12472" data-line-number="12472"></td>
        <td id="LC12472">
</td>
      </tr>
      <tr>
        <td id="L12473" data-line-number="12473"></td>
        <td id="LC12473">
</td>
      </tr>
      <tr>
        <td id="L12474" data-line-number="12474"></td>
        <td id="LC12474"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L12475" data-line-number="12475"></td>
        <td id="LC12475"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12476" data-line-number="12476"></td>
        <td id="LC12476"><span><span>//</span> Triage a 2nd-chance exception when the CLR is initialized.</span></td>
      </tr>
      <tr>
        <td id="L12477" data-line-number="12477"></td>
        <td id="LC12477"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12478" data-line-number="12478"></td>
        <td id="LC12478"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L12479" data-line-number="12479"></td>
        <td id="LC12479"><span><span>//</span>    pUnmanagedThread - thread that the event has occurred on.</span></td>
      </tr>
      <tr>
        <td id="L12480" data-line-number="12480"></td>
        <td id="LC12480"><span><span>//</span>    pEvent - native debug event for the exception that occurred that this is triaging.</span></td>
      </tr>
      <tr>
        <td id="L12481" data-line-number="12481"></td>
        <td id="LC12481"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12482" data-line-number="12482"></td>
        <td id="LC12482"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L12483" data-line-number="12483"></td>
        <td id="LC12483"><span><span>//</span>    Reaction for how to handle this event.</span></td>
      </tr>
      <tr>
        <td id="L12484" data-line-number="12484"></td>
        <td id="LC12484"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12485" data-line-number="12485"></td>
        <td id="LC12485"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L12486" data-line-number="12486"></td>
        <td id="LC12486"><span><span>//</span>    Called when receiving a debug event when the process is stopped.</span></td>
      </tr>
      <tr>
        <td id="L12487" data-line-number="12487"></td>
        <td id="LC12487"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12488" data-line-number="12488"></td>
        <td id="LC12488"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L12489" data-line-number="12489"></td>
        <td id="LC12489"><span><span>//</span>    We already hijacked 2nd-chance managed exceptions, so this is just handling</span></td>
      </tr>
      <tr>
        <td id="L12490" data-line-number="12490"></td>
        <td id="LC12490"><span><span>//</span>    some V2 Interop corner cases.</span></td>
      </tr>
      <tr>
        <td id="L12491" data-line-number="12491"></td>
        <td id="LC12491"><span><span>//</span>    @dbgtodo interop: this should eventually completely go away with the V3 design.</span></td>
      </tr>
      <tr>
        <td id="L12492" data-line-number="12492"></td>
        <td id="LC12492"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12493" data-line-number="12493"></td>
        <td id="LC12493"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L12494" data-line-number="12494"></td>
        <td id="LC12494">Reaction <span>CordbProcess::TriageExcep2ndChanceAndInit</span>(CordbUnmanagedThread * pUnmanagedThread, <span>const</span> DEBUG_EVENT * pEvent)</td>
      </tr>
      <tr>
        <td id="L12495" data-line-number="12495"></td>
        <td id="LC12495">{</td>
      </tr>
      <tr>
        <td id="L12496" data-line-number="12496"></td>
        <td id="LC12496">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L12497" data-line-number="12497"></td>
        <td id="LC12497">
</td>
      </tr>
      <tr>
        <td id="L12498" data-line-number="12498"></td>
        <td id="LC12498">    DWORD dwExCode = pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span>;</td>
      </tr>
      <tr>
        <td id="L12499" data-line-number="12499"></td>
        <td id="LC12499">
</td>
      </tr>
      <tr>
        <td id="L12500" data-line-number="12500"></td>
        <td id="LC12500">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L12501" data-line-number="12501"></td>
        <td id="LC12501">    <span><span>//</span> For debugging, add an extra knob that let us break on any 2nd chance exceptions.</span></td>
      </tr>
      <tr>
        <td id="L12502" data-line-number="12502"></td>
        <td id="LC12502">    <span><span>//</span> Most tests don't throw 2nd-chance, so we could have this enabled most of the time and</span></td>
      </tr>
      <tr>
        <td id="L12503" data-line-number="12503"></td>
        <td id="LC12503">    <span><span>//</span> catch bogus 2nd chance exceptions</span></td>
      </tr>
      <tr>
        <td id="L12504" data-line-number="12504"></td>
        <td id="LC12504">    <span>static</span> DWORD dwNo2ndChance = -<span>1</span>;</td>
      </tr>
      <tr>
        <td id="L12505" data-line-number="12505"></td>
        <td id="LC12505">
</td>
      </tr>
      <tr>
        <td id="L12506" data-line-number="12506"></td>
        <td id="LC12506">    <span>if</span> (dwNo2ndChance == -<span>1</span>)</td>
      </tr>
      <tr>
        <td id="L12507" data-line-number="12507"></td>
        <td id="LC12507">    {</td>
      </tr>
      <tr>
        <td id="L12508" data-line-number="12508"></td>
        <td id="LC12508">        dwNo2ndChance = <span>CLRConfig::GetConfigValue</span>(CLRConfig::INTERNAL_DbgNo2ndChance);</td>
      </tr>
      <tr>
        <td id="L12509" data-line-number="12509"></td>
        <td id="LC12509">    }</td>
      </tr>
      <tr>
        <td id="L12510" data-line-number="12510"></td>
        <td id="LC12510">
</td>
      </tr>
      <tr>
        <td id="L12511" data-line-number="12511"></td>
        <td id="LC12511">    <span>if</span> (dwNo2ndChance)</td>
      </tr>
      <tr>
        <td id="L12512" data-line-number="12512"></td>
        <td id="LC12512">    {</td>
      </tr>
      <tr>
        <td id="L12513" data-line-number="12513"></td>
        <td id="LC12513">        <span>CONSISTENCY_CHECK_MSGF</span>(<span>false</span>, (<span><span>"</span>2nd chance exception occurred on LS thread=0x%x, code=0x%08x, address=0x%p<span>\n</span><span>"</span></span></td>
      </tr>
      <tr>
        <td id="L12514" data-line-number="12514"></td>
        <td id="LC12514">            <span><span>"</span>This assert is firing b/c you explicitly requested it by having the 'DbgNo2ndChance' knob enabled.<span>\n</span><span>"</span></span></td>
      </tr>
      <tr>
        <td id="L12515" data-line-number="12515"></td>
        <td id="LC12515">            <span><span>"</span>Disable it to avoid asserts on 2nd chance.<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12516" data-line-number="12516"></td>
        <td id="LC12516">            pUnmanagedThread-&gt;<span>m_id</span>,</td>
      </tr>
      <tr>
        <td id="L12517" data-line-number="12517"></td>
        <td id="LC12517">            dwExCode,</td>
      </tr>
      <tr>
        <td id="L12518" data-line-number="12518"></td>
        <td id="LC12518">            pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionAddress</span>));</td>
      </tr>
      <tr>
        <td id="L12519" data-line-number="12519"></td>
        <td id="LC12519">    }</td>
      </tr>
      <tr>
        <td id="L12520" data-line-number="12520"></td>
        <td id="LC12520">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L12521" data-line-number="12521"></td>
        <td id="LC12521">
</td>
      </tr>
      <tr>
        <td id="L12522" data-line-number="12522"></td>
        <td id="LC12522">
</td>
      </tr>
      <tr>
        <td id="L12523" data-line-number="12523"></td>
        <td id="LC12523">    <span><span>//</span> Second chance exception, Runtime initialized. It could belong to the Runtime, so we'll check. If it</span></td>
      </tr>
      <tr>
        <td id="L12524" data-line-number="12524"></td>
        <td id="LC12524">    <span><span>//</span> does, then we'll hijack the thread. Otherwise, well just fall through and let it get</span></td>
      </tr>
      <tr>
        <td id="L12525" data-line-number="12525"></td>
        <td id="LC12525">    <span><span>//</span> dispatched. Note: we do this so that the CLR's unhandled exception logic gets a chance to run even</span></td>
      </tr>
      <tr>
        <td id="L12526" data-line-number="12526"></td>
        <td id="LC12526">    <span><span>//</span> though we've got a win32 debugger attached. But the unhandled exception logic never touches</span></td>
      </tr>
      <tr>
        <td id="L12527" data-line-number="12527"></td>
        <td id="LC12527">    <span><span>//</span> breakpoint or single step exceptions, so we ignore those here, too.</span></td>
      </tr>
      <tr>
        <td id="L12528" data-line-number="12528"></td>
        <td id="LC12528">
</td>
      </tr>
      <tr>
        <td id="L12529" data-line-number="12529"></td>
        <td id="LC12529">    <span><span>//</span> There are strange cases with stack overflow exceptions. If a nieve application catches a stack</span></td>
      </tr>
      <tr>
        <td id="L12530" data-line-number="12530"></td>
        <td id="LC12530">    <span><span>//</span> overflow exception and handles it, without resetting the guard page, then the app will get an AV when</span></td>
      </tr>
      <tr>
        <td id="L12531" data-line-number="12531"></td>
        <td id="LC12531">    <span><span>//</span> it overflows the stack a second time. We will get the first chance AV, but when we continue from it the</span></td>
      </tr>
      <tr>
        <td id="L12532" data-line-number="12532"></td>
        <td id="LC12532">    <span><span>//</span> OS won't run any SEH handlers, so our FCH won't actually work. Instead, we'll get the AV back on</span></td>
      </tr>
      <tr>
        <td id="L12533" data-line-number="12533"></td>
        <td id="LC12533">    <span><span>//</span> second chance right away, and we'll end up right here.</span></td>
      </tr>
      <tr>
        <td id="L12534" data-line-number="12534"></td>
        <td id="LC12534">    <span>if</span> (<span>this</span>-&gt;<span>IsSpecialStackOverflowCase</span>(pUnmanagedThread, pEvent))</td>
      </tr>
      <tr>
        <td id="L12535" data-line-number="12535"></td>
        <td id="LC12535">    {</td>
      </tr>
      <tr>
        <td id="L12536" data-line-number="12536"></td>
        <td id="LC12536">        <span><span>//</span> IsSpecialStackOverflowCase will queue the event for us, so its no longer a "new event". Setting</span></td>
      </tr>
      <tr>
        <td id="L12537" data-line-number="12537"></td>
        <td id="LC12537">        <span><span>//</span> newEvent = false here basically prevents us from playing with the event anymore and we fall down</span></td>
      </tr>
      <tr>
        <td id="L12538" data-line-number="12538"></td>
        <td id="LC12538">        <span><span>//</span> to the dispatch logic below, which will get our already queued first chance AV dispatched for</span></td>
      </tr>
      <tr>
        <td id="L12539" data-line-number="12539"></td>
        <td id="LC12539">        <span><span>//</span> this thread.</span></td>
      </tr>
      <tr>
        <td id="L12540" data-line-number="12540"></td>
        <td id="LC12540">        <span><span>//</span>newEvent = false;</span></td>
      </tr>
      <tr>
        <td id="L12541" data-line-number="12541"></td>
        <td id="LC12541">        <span>return</span> <span>REACTION</span>(cInband_NotNewEvent);</td>
      </tr>
      <tr>
        <td id="L12542" data-line-number="12542"></td>
        <td id="LC12542">    }</td>
      </tr>
      <tr>
        <td id="L12543" data-line-number="12543"></td>
        <td id="LC12543">    <span>else</span> <span>if</span> (<span>this</span>-&gt;<span>IsHelperThreadWorked</span>(pUnmanagedThread-&gt;<span>GetOSTid</span>()))</td>
      </tr>
      <tr>
        <td id="L12544" data-line-number="12544"></td>
        <td id="LC12544">    {</td>
      </tr>
      <tr>
        <td id="L12545" data-line-number="12545"></td>
        <td id="LC12545">        <span><span>//</span> A second chance exception from the helper thread. This is pretty bad... we just force continue</span></td>
      </tr>
      <tr>
        <td id="L12546" data-line-number="12546"></td>
        <td id="LC12546">        <span><span>//</span> from them and hope for the best.</span></td>
      </tr>
      <tr>
        <td id="L12547" data-line-number="12547"></td>
        <td id="LC12547">        <span>return</span> <span>REACTION</span>(cCLR);</td>
      </tr>
      <tr>
        <td id="L12548" data-line-number="12548"></td>
        <td id="LC12548">    }</td>
      </tr>
      <tr>
        <td id="L12549" data-line-number="12549"></td>
        <td id="LC12549">
</td>
      </tr>
      <tr>
        <td id="L12550" data-line-number="12550"></td>
        <td id="LC12550">    <span>if</span>(pUnmanagedThread-&gt;<span>IsCantStop</span>())</td>
      </tr>
      <tr>
        <td id="L12551" data-line-number="12551"></td>
        <td id="LC12551">    {</td>
      </tr>
      <tr>
        <td id="L12552" data-line-number="12552"></td>
        <td id="LC12552">        <span>return</span> <span>REACTION</span>(cOOB);</td>
      </tr>
      <tr>
        <td id="L12553" data-line-number="12553"></td>
        <td id="LC12553">    }</td>
      </tr>
      <tr>
        <td id="L12554" data-line-number="12554"></td>
        <td id="LC12554">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L12555" data-line-number="12555"></td>
        <td id="LC12555">    {</td>
      </tr>
      <tr>
        <td id="L12556" data-line-number="12556"></td>
        <td id="LC12556">        <span>return</span> <span>REACTION</span>(cInband);</td>
      </tr>
      <tr>
        <td id="L12557" data-line-number="12557"></td>
        <td id="LC12557">    }</td>
      </tr>
      <tr>
        <td id="L12558" data-line-number="12558"></td>
        <td id="LC12558">}</td>
      </tr>
      <tr>
        <td id="L12559" data-line-number="12559"></td>
        <td id="LC12559">
</td>
      </tr>
      <tr>
        <td id="L12560" data-line-number="12560"></td>
        <td id="LC12560">
</td>
      </tr>
      <tr>
        <td id="L12561" data-line-number="12561"></td>
        <td id="LC12561"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L12562" data-line-number="12562"></td>
        <td id="LC12562"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12563" data-line-number="12563"></td>
        <td id="LC12563"><span><span>//</span> Triage a win32 Debug event to get a reaction</span></td>
      </tr>
      <tr>
        <td id="L12564" data-line-number="12564"></td>
        <td id="LC12564"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12565" data-line-number="12565"></td>
        <td id="LC12565"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L12566" data-line-number="12566"></td>
        <td id="LC12566"><span><span>//</span>    pUnmanagedThread - thread that the event has occurred on.</span></td>
      </tr>
      <tr>
        <td id="L12567" data-line-number="12567"></td>
        <td id="LC12567"><span><span>//</span>    pEvent - native debug event for the exception that occurred that this is triaging.</span></td>
      </tr>
      <tr>
        <td id="L12568" data-line-number="12568"></td>
        <td id="LC12568"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12569" data-line-number="12569"></td>
        <td id="LC12569"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L12570" data-line-number="12570"></td>
        <td id="LC12570"><span><span>//</span>    Reaction for how to handle this event.</span></td>
      </tr>
      <tr>
        <td id="L12571" data-line-number="12571"></td>
        <td id="LC12571"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12572" data-line-number="12572"></td>
        <td id="LC12572"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L12573" data-line-number="12573"></td>
        <td id="LC12573"><span><span>//</span>    Called when receiving a debug event when the process is stopped.</span></td>
      </tr>
      <tr>
        <td id="L12574" data-line-number="12574"></td>
        <td id="LC12574"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12575" data-line-number="12575"></td>
        <td id="LC12575"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L12576" data-line-number="12576"></td>
        <td id="LC12576"><span><span>//</span>    This is the main triage routine for Win32 debug events, this delegates to the</span></td>
      </tr>
      <tr>
        <td id="L12577" data-line-number="12577"></td>
        <td id="LC12577"><span><span>//</span>    1st and 2nd chance routines above appropriately.</span></td>
      </tr>
      <tr>
        <td id="L12578" data-line-number="12578"></td>
        <td id="LC12578"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12579" data-line-number="12579"></td>
        <td id="LC12579"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L12580" data-line-number="12580"></td>
        <td id="LC12580">Reaction <span>CordbProcess::TriageWin32DebugEvent</span>(CordbUnmanagedThread * pUnmanagedThread, <span>const</span> DEBUG_EVENT * pEvent)</td>
      </tr>
      <tr>
        <td id="L12581" data-line-number="12581"></td>
        <td id="LC12581">{</td>
      </tr>
      <tr>
        <td id="L12582" data-line-number="12582"></td>
        <td id="LC12582">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L12583" data-line-number="12583"></td>
        <td id="LC12583">
</td>
      </tr>
      <tr>
        <td id="L12584" data-line-number="12584"></td>
        <td id="LC12584">    <span><span>//</span> Lots of special cases for exception events. The vast majority of hybrid debugging work that takes</span></td>
      </tr>
      <tr>
        <td id="L12585" data-line-number="12585"></td>
        <td id="LC12585">    <span><span>//</span> place is in response to exception events. The work below will consider certian exception events</span></td>
      </tr>
      <tr>
        <td id="L12586" data-line-number="12586"></td>
        <td id="LC12586">    <span><span>//</span> special cases and rather than letting them be queued and dispatched, they will be handled right</span></td>
      </tr>
      <tr>
        <td id="L12587" data-line-number="12587"></td>
        <td id="LC12587">    <span><span>//</span> here.</span></td>
      </tr>
      <tr>
        <td id="L12588" data-line-number="12588"></td>
        <td id="LC12588">    <span>if</span> (pEvent-&gt;<span>dwDebugEventCode</span> == EXCEPTION_DEBUG_EVENT)</td>
      </tr>
      <tr>
        <td id="L12589" data-line-number="12589"></td>
        <td id="LC12589">    {</td>
      </tr>
      <tr>
        <td id="L12590" data-line-number="12590"></td>
        <td id="LC12590">        <span>STRESS_LOG4</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TW32DE: unmanaged exception on <span>"</span></span></td>
      </tr>
      <tr>
        <td id="L12591" data-line-number="12591"></td>
        <td id="LC12591">             <span><span>"</span>tid 0x%x, code 0x%08x, addr 0x%08x, chance %d<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12592" data-line-number="12592"></td>
        <td id="LC12592">             pEvent-&gt;<span>dwThreadId</span>,</td>
      </tr>
      <tr>
        <td id="L12593" data-line-number="12593"></td>
        <td id="LC12593">             pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span>,</td>
      </tr>
      <tr>
        <td id="L12594" data-line-number="12594"></td>
        <td id="LC12594">             pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionAddress</span>,</td>
      </tr>
      <tr>
        <td id="L12595" data-line-number="12595"></td>
        <td id="LC12595">             <span>2</span>-pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>dwFirstChance</span>);</td>
      </tr>
      <tr>
        <td id="L12596" data-line-number="12596"></td>
        <td id="LC12596">
</td>
      </tr>
      <tr>
        <td id="L12597" data-line-number="12597"></td>
        <td id="LC12597">#<span>ifdef</span> LOGGING</td>
      </tr>
      <tr>
        <td id="L12598" data-line-number="12598"></td>
        <td id="LC12598">        <span>if</span> (pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span> == STATUS_ACCESS_VIOLATION)</td>
      </tr>
      <tr>
        <td id="L12599" data-line-number="12599"></td>
        <td id="LC12599">        {</td>
      </tr>
      <tr>
        <td id="L12600" data-line-number="12600"></td>
        <td id="LC12600">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span><span>\t</span>&lt;%s&gt; address 0x%08x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12601" data-line-number="12601"></td>
        <td id="LC12601">                 pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionInformation</span>[<span>0</span>] ? <span><span>"</span>write to<span>"</span></span> : <span><span>"</span>read from<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12602" data-line-number="12602"></td>
        <td id="LC12602">                 pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionInformation</span>[<span>1</span>]));</td>
      </tr>
      <tr>
        <td id="L12603" data-line-number="12603"></td>
        <td id="LC12603">        }</td>
      </tr>
      <tr>
        <td id="L12604" data-line-number="12604"></td>
        <td id="LC12604">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L12605" data-line-number="12605"></td>
        <td id="LC12605">
</td>
      </tr>
      <tr>
        <td id="L12606" data-line-number="12606"></td>
        <td id="LC12606">        <span><span>//</span> Mark the loader bp for kicks. We won't start managed attach until native attach is finished.</span></td>
      </tr>
      <tr>
        <td id="L12607" data-line-number="12607"></td>
        <td id="LC12607">        <span>if</span> (!<span>this</span>-&gt;<span>m_loaderBPReceived</span>)</td>
      </tr>
      <tr>
        <td id="L12608" data-line-number="12608"></td>
        <td id="LC12608">        {</td>
      </tr>
      <tr>
        <td id="L12609" data-line-number="12609"></td>
        <td id="LC12609">            <span><span>//</span> If its a first chance breakpoint, and its the first one, then its the loader breakpoint.</span></td>
      </tr>
      <tr>
        <td id="L12610" data-line-number="12610"></td>
        <td id="LC12610">            <span>if</span> (pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>dwFirstChance</span> &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L12611" data-line-number="12611"></td>
        <td id="LC12611">                (pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span> == STATUS_BREAKPOINT))</td>
      </tr>
      <tr>
        <td id="L12612" data-line-number="12612"></td>
        <td id="LC12612">            {</td>
      </tr>
      <tr>
        <td id="L12613" data-line-number="12613"></td>
        <td id="LC12613">                <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TW32DE: loader breakpoint received.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L12614" data-line-number="12614"></td>
        <td id="LC12614">
</td>
      </tr>
      <tr>
        <td id="L12615" data-line-number="12615"></td>
        <td id="LC12615">                <span><span>//</span> Remember that we've received the loader BP event.</span></td>
      </tr>
      <tr>
        <td id="L12616" data-line-number="12616"></td>
        <td id="LC12616">                <span>this</span>-&gt;<span>m_loaderBPReceived</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L12617" data-line-number="12617"></td>
        <td id="LC12617">
</td>
      </tr>
      <tr>
        <td id="L12618" data-line-number="12618"></td>
        <td id="LC12618">                <span><span>//</span> We never hijack the loader BP anymore (CLR 2.0+).</span></td>
      </tr>
      <tr>
        <td id="L12619" data-line-number="12619"></td>
        <td id="LC12619">                <span><span>//</span> This is b/c w/ interop-attach, we don't start the managed-attach until _after_ Cordbg</span></td>
      </tr>
      <tr>
        <td id="L12620" data-line-number="12620"></td>
        <td id="LC12620">                <span><span>//</span> continues from the loader-bp.</span></td>
      </tr>
      <tr>
        <td id="L12621" data-line-number="12621"></td>
        <td id="LC12621">            }</td>
      </tr>
      <tr>
        <td id="L12622" data-line-number="12622"></td>
        <td id="LC12622">        } <span><span>//</span> end of loader bp.</span></td>
      </tr>
      <tr>
        <td id="L12623" data-line-number="12623"></td>
        <td id="LC12623">
</td>
      </tr>
      <tr>
        <td id="L12624" data-line-number="12624"></td>
        <td id="LC12624">        <span><span>//</span> This event might be the retriggering of an event we already saw but previously had to hijack</span></td>
      </tr>
      <tr>
        <td id="L12625" data-line-number="12625"></td>
        <td id="LC12625">        <span>if</span>(pUnmanagedThread-&gt;<span>HasIBEvent</span>())</td>
      </tr>
      <tr>
        <td id="L12626" data-line-number="12626"></td>
        <td id="LC12626">        {</td>
      </tr>
      <tr>
        <td id="L12627" data-line-number="12627"></td>
        <td id="LC12627">            <span>const</span> EXCEPTION_RECORD* pRecord1 = &amp;(pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>);</td>
      </tr>
      <tr>
        <td id="L12628" data-line-number="12628"></td>
        <td id="LC12628">            <span>const</span> EXCEPTION_RECORD* pRecord2 = &amp;(pUnmanagedThread-&gt;<span>IBEvent</span>()-&gt;<span>m_currentDebugEvent</span>.<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>);</td>
      </tr>
      <tr>
        <td id="L12629" data-line-number="12629"></td>
        <td id="LC12629">            <span>if</span>(pRecord1-&gt;<span>ExceptionCode</span> == pRecord2-&gt;<span>ExceptionCode</span> &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L12630" data-line-number="12630"></td>
        <td id="LC12630">                pRecord1-&gt;<span>ExceptionFlags</span> == pRecord2-&gt;<span>ExceptionFlags</span> &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L12631" data-line-number="12631"></td>
        <td id="LC12631">                pRecord1-&gt;<span>ExceptionAddress</span> == pRecord2-&gt;<span>ExceptionAddress</span>)</td>
      </tr>
      <tr>
        <td id="L12632" data-line-number="12632"></td>
        <td id="LC12632">            {</td>
      </tr>
      <tr>
        <td id="L12633" data-line-number="12633"></td>
        <td id="LC12633">                <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>CP::TW32DE: event is continuation of previously hijacked event.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12634" data-line-number="12634"></td>
        <td id="LC12634">                <span><span>//</span> if we continued from the hijack then we should have already dispatched this event</span></td>
      </tr>
      <tr>
        <td id="L12635" data-line-number="12635"></td>
        <td id="LC12635">                <span>_ASSERTE</span>(pUnmanagedThread-&gt;<span>IBEvent</span>()-&gt;<span>IsDispatched</span>());</td>
      </tr>
      <tr>
        <td id="L12636" data-line-number="12636"></td>
        <td id="LC12636">                <span>return</span> <span>REACTION</span>(cInbandExceptionRetrigger);</td>
      </tr>
      <tr>
        <td id="L12637" data-line-number="12637"></td>
        <td id="LC12637">            }</td>
      </tr>
      <tr>
        <td id="L12638" data-line-number="12638"></td>
        <td id="LC12638">        }</td>
      </tr>
      <tr>
        <td id="L12639" data-line-number="12639"></td>
        <td id="LC12639">
</td>
      </tr>
      <tr>
        <td id="L12640" data-line-number="12640"></td>
        <td id="LC12640">        <span><span>//</span> We only care about exception events if they are first chance events and if the Runtime is</span></td>
      </tr>
      <tr>
        <td id="L12641" data-line-number="12641"></td>
        <td id="LC12641">        <span><span>//</span> initialized within the process. Otherwise, we don't do anything special with them.</span></td>
      </tr>
      <tr>
        <td id="L12642" data-line-number="12642"></td>
        <td id="LC12642">        <span>if</span> (pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>dwFirstChance</span> &amp;&amp; <span>this</span>-&gt;<span>m_initialized</span>)</td>
      </tr>
      <tr>
        <td id="L12643" data-line-number="12643"></td>
        <td id="LC12643">        {</td>
      </tr>
      <tr>
        <td id="L12644" data-line-number="12644"></td>
        <td id="LC12644">            <span>return</span> <span>TriageExcep1stChanceAndInit</span>(pUnmanagedThread, pEvent);</td>
      </tr>
      <tr>
        <td id="L12645" data-line-number="12645"></td>
        <td id="LC12645">        }</td>
      </tr>
      <tr>
        <td id="L12646" data-line-number="12646"></td>
        <td id="LC12646">        <span>else</span> <span>if</span> (!pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>dwFirstChance</span> &amp;&amp; <span>this</span>-&gt;<span>m_initialized</span>)</td>
      </tr>
      <tr>
        <td id="L12647" data-line-number="12647"></td>
        <td id="LC12647">        {</td>
      </tr>
      <tr>
        <td id="L12648" data-line-number="12648"></td>
        <td id="LC12648">            <span>return</span> <span>TriageExcep2ndChanceAndInit</span>(pUnmanagedThread, pEvent);</td>
      </tr>
      <tr>
        <td id="L12649" data-line-number="12649"></td>
        <td id="LC12649">        }</td>
      </tr>
      <tr>
        <td id="L12650" data-line-number="12650"></td>
        <td id="LC12650">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L12651" data-line-number="12651"></td>
        <td id="LC12651">        {</td>
      </tr>
      <tr>
        <td id="L12652" data-line-number="12652"></td>
        <td id="LC12652">            <span><span>//</span> An exception event, but the Runtime hasn't been initialize. I.e., its an exception event</span></td>
      </tr>
      <tr>
        <td id="L12653" data-line-number="12653"></td>
        <td id="LC12653">            <span><span>//</span> that we will never try to hijack.</span></td>
      </tr>
      <tr>
        <td id="L12654" data-line-number="12654"></td>
        <td id="LC12654">            <span>return</span> <span>REACTION</span>(cInband);</td>
      </tr>
      <tr>
        <td id="L12655" data-line-number="12655"></td>
        <td id="LC12655">        }</td>
      </tr>
      <tr>
        <td id="L12656" data-line-number="12656"></td>
        <td id="LC12656">
</td>
      </tr>
      <tr>
        <td id="L12657" data-line-number="12657"></td>
        <td id="LC12657">        <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L12658" data-line-number="12658"></td>
        <td id="LC12658">    }</td>
      </tr>
      <tr>
        <td id="L12659" data-line-number="12659"></td>
        <td id="LC12659">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L12660" data-line-number="12660"></td>
        <td id="LC12660">    <span><span>//</span> OOB</span></td>
      </tr>
      <tr>
        <td id="L12661" data-line-number="12661"></td>
        <td id="LC12661">    {</td>
      </tr>
      <tr>
        <td id="L12662" data-line-number="12662"></td>
        <td id="LC12662">        <span>return</span> <span>REACTION</span>(cOOB);</td>
      </tr>
      <tr>
        <td id="L12663" data-line-number="12663"></td>
        <td id="LC12663">    }</td>
      </tr>
      <tr>
        <td id="L12664" data-line-number="12664"></td>
        <td id="LC12664">
</td>
      </tr>
      <tr>
        <td id="L12665" data-line-number="12665"></td>
        <td id="LC12665">}</td>
      </tr>
      <tr>
        <td id="L12666" data-line-number="12666"></td>
        <td id="LC12666">
</td>
      </tr>
      <tr>
        <td id="L12667" data-line-number="12667"></td>
        <td id="LC12667"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L12668" data-line-number="12668"></td>
        <td id="LC12668"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12669" data-line-number="12669"></td>
        <td id="LC12669"><span><span>//</span> Top-level handler for a win32 debug event during Interop-debugging.</span></td>
      </tr>
      <tr>
        <td id="L12670" data-line-number="12670"></td>
        <td id="LC12670"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12671" data-line-number="12671"></td>
        <td id="LC12671"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L12672" data-line-number="12672"></td>
        <td id="LC12672"><span><span>//</span>    event - native debug event to handle.</span></td>
      </tr>
      <tr>
        <td id="L12673" data-line-number="12673"></td>
        <td id="LC12673"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12674" data-line-number="12674"></td>
        <td id="LC12674"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L12675" data-line-number="12675"></td>
        <td id="LC12675"><span><span>//</span>    The process just got a native debug event via WaitForDebugEvent</span></td>
      </tr>
      <tr>
        <td id="L12676" data-line-number="12676"></td>
        <td id="LC12676"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12677" data-line-number="12677"></td>
        <td id="LC12677"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L12678" data-line-number="12678"></td>
        <td id="LC12678"><span><span>//</span>    The function will Triage the excpetion and then handle it based on the</span></td>
      </tr>
      <tr>
        <td id="L12679" data-line-number="12679"></td>
        <td id="LC12679"><span><span>//</span>    appropriate reaction (see: code:Reaction).</span></td>
      </tr>
      <tr>
        <td id="L12680" data-line-number="12680"></td>
        <td id="LC12680"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12681" data-line-number="12681"></td>
        <td id="LC12681"><span><span>//</span> @dbgtodo interop: this should all go into the shim.</span></td>
      </tr>
      <tr>
        <td id="L12682" data-line-number="12682"></td>
        <td id="LC12682"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L12683" data-line-number="12683"></td>
        <td id="LC12683"><span>void</span> <span>CordbProcess::HandleDebugEventForInteropDebugging</span>(<span>const</span> DEBUG_EVENT * pEvent)</td>
      </tr>
      <tr>
        <td id="L12684" data-line-number="12684"></td>
        <td id="LC12684">{</td>
      </tr>
      <tr>
        <td id="L12685" data-line-number="12685"></td>
        <td id="LC12685">    <span>PUBLIC_API_ENTRY_FOR_SHIM</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L12686" data-line-number="12686"></td>
        <td id="LC12686">    <span>_ASSERTE</span>(<span>IsInteropDebugging</span>() || !<span><span>"</span>Only do this in real interop handling path<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12687" data-line-number="12687"></td>
        <td id="LC12687">
</td>
      </tr>
      <tr>
        <td id="L12688" data-line-number="12688"></td>
        <td id="LC12688">
</td>
      </tr>
      <tr>
        <td id="L12689" data-line-number="12689"></td>
        <td id="LC12689">    <span>STRESS_LOG3</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: got unmanaged event %d on thread 0x%x, proc 0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12690" data-line-number="12690"></td>
        <td id="LC12690">         pEvent-&gt;<span>dwDebugEventCode</span>, pEvent-&gt;<span>dwThreadId</span>, pEvent-&gt;<span>dwProcessId</span>);</td>
      </tr>
      <tr>
        <td id="L12691" data-line-number="12691"></td>
        <td id="LC12691">
</td>
      </tr>
      <tr>
        <td id="L12692" data-line-number="12692"></td>
        <td id="LC12692">    <span><span>//</span> Get the Lock.</span></td>
      </tr>
      <tr>
        <td id="L12693" data-line-number="12693"></td>
        <td id="LC12693">    <span>_ASSERTE</span>(!<span>this</span>-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L12694" data-line-number="12694"></td>
        <td id="LC12694">
</td>
      </tr>
      <tr>
        <td id="L12695" data-line-number="12695"></td>
        <td id="LC12695">    RSSmartPtr&lt;CordbProcess&gt; <span>pRef</span>(<span>this</span>); <span><span>//</span> make sure we're alive...</span></td>
      </tr>
      <tr>
        <td id="L12696" data-line-number="12696"></td>
        <td id="LC12696">
</td>
      </tr>
      <tr>
        <td id="L12697" data-line-number="12697"></td>
        <td id="LC12697">    RSLockHolder <span>processLockHolder</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L12698" data-line-number="12698"></td>
        <td id="LC12698">
</td>
      </tr>
      <tr>
        <td id="L12699" data-line-number="12699"></td>
        <td id="LC12699">    <span><span>//</span> If we get a new Win32 Debug event, then we need to flush any cached oop data structures.</span></td>
      </tr>
      <tr>
        <td id="L12700" data-line-number="12700"></td>
        <td id="LC12700">    <span><span>//</span> This includes refreshing DAC and our patch table.</span></td>
      </tr>
      <tr>
        <td id="L12701" data-line-number="12701"></td>
        <td id="LC12701">    <span>ForceDacFlush</span>();</td>
      </tr>
      <tr>
        <td id="L12702" data-line-number="12702"></td>
        <td id="LC12702">    <span>ClearPatchTable</span>();</td>
      </tr>
      <tr>
        <td id="L12703" data-line-number="12703"></td>
        <td id="LC12703">
</td>
      </tr>
      <tr>
        <td id="L12704" data-line-number="12704"></td>
        <td id="LC12704">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L12705" data-line-number="12705"></td>
        <td id="LC12705">    <span><span>//</span> We want to detect if we've deadlocked. Unfortunately, w/ interop debugging, there can be a lot of</span></td>
      </tr>
      <tr>
        <td id="L12706" data-line-number="12706"></td>
        <td id="LC12706">    <span><span>//</span> deadtime since we need to wait for a debug event. Thus the CPU usage may appear to be at 0%, but</span></td>
      </tr>
      <tr>
        <td id="L12707" data-line-number="12707"></td>
        <td id="LC12707">    <span><span>//</span> we're not deadlocked b/c we're still receiving debug events.</span></td>
      </tr>
      <tr>
        <td id="L12708" data-line-number="12708"></td>
        <td id="LC12708">    <span><span>//</span> So ping every X debug events.</span></td>
      </tr>
      <tr>
        <td id="L12709" data-line-number="12709"></td>
        <td id="LC12709">    <span>static</span> <span>int</span> s_cCount = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L12710" data-line-number="12710"></td>
        <td id="LC12710">    <span>static</span> <span>int</span> s_iPingLevel = -<span>1</span>;</td>
      </tr>
      <tr>
        <td id="L12711" data-line-number="12711"></td>
        <td id="LC12711">    <span>if</span> (s_iPingLevel == -<span>1</span>)</td>
      </tr>
      <tr>
        <td id="L12712" data-line-number="12712"></td>
        <td id="LC12712">    {</td>
      </tr>
      <tr>
        <td id="L12713" data-line-number="12713"></td>
        <td id="LC12713">        s_iPingLevel = <span>CLRConfig::GetConfigValue</span>(CLRConfig::INTERNAL_DbgPingInterop);</td>
      </tr>
      <tr>
        <td id="L12714" data-line-number="12714"></td>
        <td id="LC12714">    }</td>
      </tr>
      <tr>
        <td id="L12715" data-line-number="12715"></td>
        <td id="LC12715">    <span>if</span> (s_iPingLevel != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L12716" data-line-number="12716"></td>
        <td id="LC12716">    {</td>
      </tr>
      <tr>
        <td id="L12717" data-line-number="12717"></td>
        <td id="LC12717">        s_cCount++;</td>
      </tr>
      <tr>
        <td id="L12718" data-line-number="12718"></td>
        <td id="LC12718">        <span>if</span> (s_cCount &gt;= s_iPingLevel)</td>
      </tr>
      <tr>
        <td id="L12719" data-line-number="12719"></td>
        <td id="LC12719">        {</td>
      </tr>
      <tr>
        <td id="L12720" data-line-number="12720"></td>
        <td id="LC12720">            s_cCount = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L12721" data-line-number="12721"></td>
        <td id="LC12721">            <span>::Beep</span>(<span>1000</span>,<span>100</span>);</td>
      </tr>
      <tr>
        <td id="L12722" data-line-number="12722"></td>
        <td id="LC12722">
</td>
      </tr>
      <tr>
        <td id="L12723" data-line-number="12723"></td>
        <td id="LC12723">            <span><span>//</span> Refresh so we can adjust ping level midstream.</span></td>
      </tr>
      <tr>
        <td id="L12724" data-line-number="12724"></td>
        <td id="LC12724">            s_iPingLevel = <span>CLRConfig::GetConfigValue</span>(CLRConfig::INTERNAL_DbgPingInterop);</td>
      </tr>
      <tr>
        <td id="L12725" data-line-number="12725"></td>
        <td id="LC12725">        }</td>
      </tr>
      <tr>
        <td id="L12726" data-line-number="12726"></td>
        <td id="LC12726">    }</td>
      </tr>
      <tr>
        <td id="L12727" data-line-number="12727"></td>
        <td id="LC12727">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L12728" data-line-number="12728"></td>
        <td id="LC12728">
</td>
      </tr>
      <tr>
        <td id="L12729" data-line-number="12729"></td>
        <td id="LC12729">    <span>bool</span> <span>fNewEvent</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L12730" data-line-number="12730"></td>
        <td id="LC12730">
</td>
      </tr>
      <tr>
        <td id="L12731" data-line-number="12731"></td>
        <td id="LC12731">    <span><span>//</span> Mark the process as stopped.</span></td>
      </tr>
      <tr>
        <td id="L12732" data-line-number="12732"></td>
        <td id="LC12732">    <span>this</span>-&gt;<span>m_state</span> |= CordbProcess::PS_WIN32_STOPPED;</td>
      </tr>
      <tr>
        <td id="L12733" data-line-number="12733"></td>
        <td id="LC12733">
</td>
      </tr>
      <tr>
        <td id="L12734" data-line-number="12734"></td>
        <td id="LC12734">    CordbUnmanagedThread * pUnmanagedThread = <span>GetUnmanagedThreadFromEvent</span>(pEvent);</td>
      </tr>
      <tr>
        <td id="L12735" data-line-number="12735"></td>
        <td id="LC12735">
</td>
      </tr>
      <tr>
        <td id="L12736" data-line-number="12736"></td>
        <td id="LC12736">    <span><span>//</span> In retail, if there is no unmanaged thread then we just continue and loop back around. UnrecoverableError has</span></td>
      </tr>
      <tr>
        <td id="L12737" data-line-number="12737"></td>
        <td id="LC12737">    <span><span>//</span> already been set in this case. Note: there is an issue in the Win32 debugging API that can cause duplicate</span></td>
      </tr>
      <tr>
        <td id="L12738" data-line-number="12738"></td>
        <td id="LC12738">    <span><span>//</span> ExitThread events. We therefore must handle not finding an unmanaged thread gracefully.</span></td>
      </tr>
      <tr>
        <td id="L12739" data-line-number="12739"></td>
        <td id="LC12739">
</td>
      </tr>
      <tr>
        <td id="L12740" data-line-number="12740"></td>
        <td id="LC12740">    <span>_ASSERTE</span>((pUnmanagedThread != <span>NULL</span>) || (pEvent-&gt;<span>dwDebugEventCode</span> == EXIT_THREAD_DEBUG_EVENT));</td>
      </tr>
      <tr>
        <td id="L12741" data-line-number="12741"></td>
        <td id="LC12741">
</td>
      </tr>
      <tr>
        <td id="L12742" data-line-number="12742"></td>
        <td id="LC12742">    <span>if</span> (pUnmanagedThread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L12743" data-line-number="12743"></td>
        <td id="LC12743">    {</td>
      </tr>
      <tr>
        <td id="L12744" data-line-number="12744"></td>
        <td id="LC12744">        <span><span>//</span> Note: we use ContinueDebugEvent directly here since our continue is very simple and all of our other</span></td>
      </tr>
      <tr>
        <td id="L12745" data-line-number="12745"></td>
        <td id="LC12745">        <span><span>//</span> continue mechanisms rely on having an UnmanagedThread object to play with ;)</span></td>
      </tr>
      <tr>
        <td id="L12746" data-line-number="12746"></td>
        <td id="LC12746">        <span>STRESS_LOG2</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: Continuing without thread on tid 0x%x, code=0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12747" data-line-number="12747"></td>
        <td id="LC12747">                    pEvent-&gt;<span>dwThreadId</span>,</td>
      </tr>
      <tr>
        <td id="L12748" data-line-number="12748"></td>
        <td id="LC12748">                    pEvent-&gt;<span>dwDebugEventCode</span>);</td>
      </tr>
      <tr>
        <td id="L12749" data-line-number="12749"></td>
        <td id="LC12749">
</td>
      </tr>
      <tr>
        <td id="L12750" data-line-number="12750"></td>
        <td id="LC12750">        <span>this</span>-&gt;<span>m_state</span> &amp;= ~CordbProcess::PS_WIN32_STOPPED;</td>
      </tr>
      <tr>
        <td id="L12751" data-line-number="12751"></td>
        <td id="LC12751">
</td>
      </tr>
      <tr>
        <td id="L12752" data-line-number="12752"></td>
        <td id="LC12752">        BOOL <span>fOk</span> = <span>ContinueDebugEvent</span>(pEvent-&gt;<span>dwProcessId</span>, pEvent-&gt;<span>dwThreadId</span>, DBG_EXCEPTION_NOT_HANDLED);</td>
      </tr>
      <tr>
        <td id="L12753" data-line-number="12753"></td>
        <td id="LC12753">
</td>
      </tr>
      <tr>
        <td id="L12754" data-line-number="12754"></td>
        <td id="LC12754">        <span>_ASSERTE</span>(<span>fOk</span> || !<span><span>"</span>ContinueDebugEvent failed when he have no thread. Debuggee is likely hung<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12755" data-line-number="12755"></td>
        <td id="LC12755">
</td>
      </tr>
      <tr>
        <td id="L12756" data-line-number="12756"></td>
        <td id="LC12756">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L12757" data-line-number="12757"></td>
        <td id="LC12757">    }</td>
      </tr>
      <tr>
        <td id="L12758" data-line-number="12758"></td>
        <td id="LC12758">
</td>
      </tr>
      <tr>
        <td id="L12759" data-line-number="12759"></td>
        <td id="LC12759">    <span><span>//</span> There's an innate race such that we can get a Debug Event even after we've suspended a thread.</span></td>
      </tr>
      <tr>
        <td id="L12760" data-line-number="12760"></td>
        <td id="LC12760">    <span><span>//</span> This can happen if the thread has already dispatched the debug event but we haven't called WFDE to pick it up</span></td>
      </tr>
      <tr>
        <td id="L12761" data-line-number="12761"></td>
        <td id="LC12761">    <span><span>//</span> yet. This is sufficiently goofy that we want to stress log it.</span></td>
      </tr>
      <tr>
        <td id="L12762" data-line-number="12762"></td>
        <td id="LC12762">    <span>if</span> (pUnmanagedThread-&gt;<span>IsSuspended</span>())</td>
      </tr>
      <tr>
        <td id="L12763" data-line-number="12763"></td>
        <td id="LC12763">    {</td>
      </tr>
      <tr>
        <td id="L12764" data-line-number="12764"></td>
        <td id="LC12764">        <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: Thread 0x%x is suspended<span>\n</span><span>"</span></span>, pEvent-&gt;<span>dwThreadId</span>);</td>
      </tr>
      <tr>
        <td id="L12765" data-line-number="12765"></td>
        <td id="LC12765">    }</td>
      </tr>
      <tr>
        <td id="L12766" data-line-number="12766"></td>
        <td id="LC12766">
</td>
      </tr>
      <tr>
        <td id="L12767" data-line-number="12767"></td>
        <td id="LC12767">    <span><span>//</span> For debugging races in retail, we'll keep a rolling queue of win32 debug events.</span></td>
      </tr>
      <tr>
        <td id="L12768" data-line-number="12768"></td>
        <td id="LC12768">    <span>this</span>-&gt;<span>DebugRecordWin32Event</span>(pEvent, pUnmanagedThread);</td>
      </tr>
      <tr>
        <td id="L12769" data-line-number="12769"></td>
        <td id="LC12769">
</td>
      </tr>
      <tr>
        <td id="L12770" data-line-number="12770"></td>
        <td id="LC12770">
</td>
      </tr>
      <tr>
        <td id="L12771" data-line-number="12771"></td>
        <td id="LC12771">    <span><span>//</span> Check to see if shutdown of the in-proc debugging services has begun. If it has, then we know we'll no longer</span></td>
      </tr>
      <tr>
        <td id="L12772" data-line-number="12772"></td>
        <td id="LC12772">    <span><span>//</span> be running any managed code, and we know that we can stop hijacking threads. We remember this by setting</span></td>
      </tr>
      <tr>
        <td id="L12773" data-line-number="12773"></td>
        <td id="LC12773">    <span><span>//</span> m_initialized to false, thus preventing most things from happening elsewhere.</span></td>
      </tr>
      <tr>
        <td id="L12774" data-line-number="12774"></td>
        <td id="LC12774">    <span><span>//</span> Don't even bother checking the DCB fields until it's been verified (m_initialized == true)</span></td>
      </tr>
      <tr>
        <td id="L12775" data-line-number="12775"></td>
        <td id="LC12775">    <span>if</span> (<span>this</span>-&gt;<span>m_initialized</span> &amp;&amp; (<span>this</span>-&gt;<span>GetDCB</span>() != <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L12776" data-line-number="12776"></td>
        <td id="LC12776">    {</td>
      </tr>
      <tr>
        <td id="L12777" data-line-number="12777"></td>
        <td id="LC12777">        <span>UpdateRightSideDCB</span>();</td>
      </tr>
      <tr>
        <td id="L12778" data-line-number="12778"></td>
        <td id="LC12778">        <span>if</span> (<span>this</span>-&gt;<span>GetDCB</span>()-&gt;<span>m_shutdownBegun</span>)</td>
      </tr>
      <tr>
        <td id="L12779" data-line-number="12779"></td>
        <td id="LC12779">        {</td>
      </tr>
      <tr>
        <td id="L12780" data-line-number="12780"></td>
        <td id="LC12780">            <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: shutdown begun...<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12781" data-line-number="12781"></td>
        <td id="LC12781">            <span>this</span>-&gt;<span>m_initialized</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L12782" data-line-number="12782"></td>
        <td id="LC12782">        }</td>
      </tr>
      <tr>
        <td id="L12783" data-line-number="12783"></td>
        <td id="LC12783">    }</td>
      </tr>
      <tr>
        <td id="L12784" data-line-number="12784"></td>
        <td id="LC12784">
</td>
      </tr>
      <tr>
        <td id="L12785" data-line-number="12785"></td>
        <td id="LC12785">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L12786" data-line-number="12786"></td>
        <td id="LC12786">    <span><span>//</span>Verify that GetThreadContext agrees with the exception address</span></td>
      </tr>
      <tr>
        <td id="L12787" data-line-number="12787"></td>
        <td id="LC12787">    <span>if</span> (pEvent-&gt;<span>dwDebugEventCode</span> == EXCEPTION_DEBUG_EVENT)</td>
      </tr>
      <tr>
        <td id="L12788" data-line-number="12788"></td>
        <td id="LC12788">    {</td>
      </tr>
      <tr>
        <td id="L12789" data-line-number="12789"></td>
        <td id="LC12789">        DT_CONTEXT tempDebugContext;</td>
      </tr>
      <tr>
        <td id="L12790" data-line-number="12790"></td>
        <td id="LC12790">        tempDebugContext.<span>ContextFlags</span> = DT_CONTEXT_FULL;</td>
      </tr>
      <tr>
        <td id="L12791" data-line-number="12791"></td>
        <td id="LC12791">        <span>DbiGetThreadContext</span>(pUnmanagedThread-&gt;<span>m_handle</span>, &amp;tempDebugContext);</td>
      </tr>
      <tr>
        <td id="L12792" data-line-number="12792"></td>
        <td id="LC12792">        <span>CordbUnmanagedThread::LogContext</span>(&amp;tempDebugContext);</td>
      </tr>
      <tr>
        <td id="L12793" data-line-number="12793"></td>
        <td id="LC12793">#<span>if</span> defined(DBG_TARGET_X86) || defined(DBG_TARGET_AMD64)</td>
      </tr>
      <tr>
        <td id="L12794" data-line-number="12794"></td>
        <td id="LC12794">        <span>const</span> ULONG_PTR breakpointOpcodeSize = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L12795" data-line-number="12795"></td>
        <td id="LC12795">#<span>elif</span> defined(DBG_TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L12796" data-line-number="12796"></td>
        <td id="LC12796">        <span>const</span> ULONG_PTR breakpointOpcodeSize = <span>4</span>;</td>
      </tr>
      <tr>
        <td id="L12797" data-line-number="12797"></td>
        <td id="LC12797">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L12798" data-line-number="12798"></td>
        <td id="LC12798">        <span>const</span> ULONG_PTR breakpointOpcodeSize = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L12799" data-line-number="12799"></td>
        <td id="LC12799">        <span>PORTABILITY_ASSERT</span>(<span><span>"</span>NYI: Breakpoint size offset for this platform<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L12800" data-line-number="12800"></td>
        <td id="LC12800">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L12801" data-line-number="12801"></td>
        <td id="LC12801">        <span>_ASSERTE</span>(<span>CORDbgGetIP</span>(&amp;tempDebugContext) == pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionAddress</span> ||</td>
      </tr>
      <tr>
        <td id="L12802" data-line-number="12802"></td>
        <td id="LC12802">            (DWORD)<span>CORDbgGetIP</span>(&amp;tempDebugContext) == ((DWORD)pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionAddress</span>)+breakpointOpcodeSize);</td>
      </tr>
      <tr>
        <td id="L12803" data-line-number="12803"></td>
        <td id="LC12803">    }</td>
      </tr>
      <tr>
        <td id="L12804" data-line-number="12804"></td>
        <td id="LC12804">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L12805" data-line-number="12805"></td>
        <td id="LC12805">
</td>
      </tr>
      <tr>
        <td id="L12806" data-line-number="12806"></td>
        <td id="LC12806">    <span><span>//</span> This call will decide what to do w/ the the win32 event we just got. It does a lot of work.</span></td>
      </tr>
      <tr>
        <td id="L12807" data-line-number="12807"></td>
        <td id="LC12807">    Reaction reaction = <span>TriageWin32DebugEvent</span>(pUnmanagedThread, pEvent);</td>
      </tr>
      <tr>
        <td id="L12808" data-line-number="12808"></td>
        <td id="LC12808">
</td>
      </tr>
      <tr>
        <td id="L12809" data-line-number="12809"></td>
        <td id="LC12809">
</td>
      </tr>
      <tr>
        <td id="L12810" data-line-number="12810"></td>
        <td id="LC12810">    <span><span>//</span> Stress-log the reaction.</span></td>
      </tr>
      <tr>
        <td id="L12811" data-line-number="12811"></td>
        <td id="LC12811">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L12812" data-line-number="12812"></td>
        <td id="LC12812">    <span>STRESS_LOG3</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>Reaction: %d (%s), line=%d<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12813" data-line-number="12813"></td>
        <td id="LC12813">                reaction.<span>GetType</span>(),</td>
      </tr>
      <tr>
        <td id="L12814" data-line-number="12814"></td>
        <td id="LC12814">                reaction.<span>GetReactionName</span>(),</td>
      </tr>
      <tr>
        <td id="L12815" data-line-number="12815"></td>
        <td id="LC12815">                reaction.<span>GetLine</span>());</td>
      </tr>
      <tr>
        <td id="L12816" data-line-number="12816"></td>
        <td id="LC12816">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L12817" data-line-number="12817"></td>
        <td id="LC12817">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>Reaction: %d<span>\n</span><span>"</span></span>, reaction.<span>GetType</span>());</td>
      </tr>
      <tr>
        <td id="L12818" data-line-number="12818"></td>
        <td id="LC12818">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L12819" data-line-number="12819"></td>
        <td id="LC12819">
</td>
      </tr>
      <tr>
        <td id="L12820" data-line-number="12820"></td>
        <td id="LC12820">    <span><span>//</span> Make sure the lock wasn't accidentally released.</span></td>
      </tr>
      <tr>
        <td id="L12821" data-line-number="12821"></td>
        <td id="LC12821">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L12822" data-line-number="12822"></td>
        <td id="LC12822">    CordbWin32EventThread * pW32EventThread = <span>this</span>-&gt;<span>m_pShim</span>-&gt;<span>GetWin32EventThread</span>();</td>
      </tr>
      <tr>
        <td id="L12823" data-line-number="12823"></td>
        <td id="LC12823">    <span>_ASSERTE</span>(pW32EventThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L12824" data-line-number="12824"></td>
        <td id="LC12824">
</td>
      </tr>
      <tr>
        <td id="L12825" data-line-number="12825"></td>
        <td id="LC12825">    <span><span>//</span> if we were waiting for a retriggered exception but recieved any other event then turn</span></td>
      </tr>
      <tr>
        <td id="L12826" data-line-number="12826"></td>
        <td id="LC12826">    <span><span>//</span> off the single stepping and dequeue the IB event. Right now we only use the SS flag internally</span></td>
      </tr>
      <tr>
        <td id="L12827" data-line-number="12827"></td>
        <td id="LC12827">    <span><span>//</span> for stepping during possible retrigger.</span></td>
      </tr>
      <tr>
        <td id="L12828" data-line-number="12828"></td>
        <td id="LC12828">    <span>if</span>(reaction.<span>GetType</span>() != Reaction::cInbandExceptionRetrigger &amp;&amp; pUnmanagedThread-&gt;<span>IsSSFlagNeeded</span>())</td>
      </tr>
      <tr>
        <td id="L12829" data-line-number="12829"></td>
        <td id="LC12829">    {</td>
      </tr>
      <tr>
        <td id="L12830" data-line-number="12830"></td>
        <td id="LC12830">        <span>_ASSERTE</span>(pUnmanagedThread-&gt;<span>HasIBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L12831" data-line-number="12831"></td>
        <td id="LC12831">        CordbUnmanagedEvent* pUnmanagedEvent = pUnmanagedThread-&gt;<span>IBEvent</span>();</td>
      </tr>
      <tr>
        <td id="L12832" data-line-number="12832"></td>
        <td id="LC12832">        <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsIBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L12833" data-line-number="12833"></td>
        <td id="LC12833">        <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsEventContinuedUnhijacked</span>());</td>
      </tr>
      <tr>
        <td id="L12834" data-line-number="12834"></td>
        <td id="LC12834">        <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsDispatched</span>());</td>
      </tr>
      <tr>
        <td id="L12835" data-line-number="12835"></td>
        <td id="LC12835">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>CP::HDEFID: IB event did not retrigger ue=0x%p<span>\n</span><span>"</span></span>, pUnmanagedEvent));</td>
      </tr>
      <tr>
        <td id="L12836" data-line-number="12836"></td>
        <td id="LC12836">
</td>
      </tr>
      <tr>
        <td id="L12837" data-line-number="12837"></td>
        <td id="LC12837">        <span>DequeueUnmanagedEvent</span>(pUnmanagedThread);</td>
      </tr>
      <tr>
        <td id="L12838" data-line-number="12838"></td>
        <td id="LC12838">        pUnmanagedThread-&gt;<span>EndStepping</span>();</td>
      </tr>
      <tr>
        <td id="L12839" data-line-number="12839"></td>
        <td id="LC12839">    }</td>
      </tr>
      <tr>
        <td id="L12840" data-line-number="12840"></td>
        <td id="LC12840">
</td>
      </tr>
      <tr>
        <td id="L12841" data-line-number="12841"></td>
        <td id="LC12841">    <span>switch</span>(reaction.<span>GetType</span>())</td>
      </tr>
      <tr>
        <td id="L12842" data-line-number="12842"></td>
        <td id="LC12842">    {</td>
      </tr>
      <tr>
        <td id="L12843" data-line-number="12843"></td>
        <td id="LC12843">    <span><span>//</span> Common for flares.</span></td>
      </tr>
      <tr>
        <td id="L12844" data-line-number="12844"></td>
        <td id="LC12844">    <span>case</span> Reaction::cIgnore:</td>
      </tr>
      <tr>
        <td id="L12845" data-line-number="12845"></td>
        <td id="LC12845">
</td>
      </tr>
      <tr>
        <td id="L12846" data-line-number="12846"></td>
        <td id="LC12846">        <span><span>//</span> Shouldn't be suspending in the first place with outstanding flares.</span></td>
      </tr>
      <tr>
        <td id="L12847" data-line-number="12847"></td>
        <td id="LC12847">        <span>_ASSERTE</span>(!pUnmanagedThread-&gt;<span>IsSuspended</span>());</td>
      </tr>
      <tr>
        <td id="L12848" data-line-number="12848"></td>
        <td id="LC12848">
</td>
      </tr>
      <tr>
        <td id="L12849" data-line-number="12849"></td>
        <td id="LC12849">        pW32EventThread-&gt;<span>ForceDbgContinue</span>(<span>this</span>, pUnmanagedThread, DBG_CONTINUE, <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L12850" data-line-number="12850"></td>
        <td id="LC12850">        <span>goto</span> LDone;</td>
      </tr>
      <tr>
        <td id="L12851" data-line-number="12851"></td>
        <td id="LC12851">
</td>
      </tr>
      <tr>
        <td id="L12852" data-line-number="12852"></td>
        <td id="LC12852">    <span>case</span> Reaction::cCLR:</td>
      </tr>
      <tr>
        <td id="L12853" data-line-number="12853"></td>
        <td id="LC12853">        <span><span>//</span> Don't care if thread is suspended here. We'll just let the thread continue whatever it's doing.</span></td>
      </tr>
      <tr>
        <td id="L12854" data-line-number="12854"></td>
        <td id="LC12854">
</td>
      </tr>
      <tr>
        <td id="L12855" data-line-number="12855"></td>
        <td id="LC12855">        <span>this</span>-&gt;<span>m_DbgSupport</span>.<span>m_TotalCLR</span>++;</td>
      </tr>
      <tr>
        <td id="L12856" data-line-number="12856"></td>
        <td id="LC12856">
</td>
      </tr>
      <tr>
        <td id="L12857" data-line-number="12857"></td>
        <td id="LC12857">        <span><span>//</span> If this is for the CLR, then we just continue unhandled and know that the CLR has</span></td>
      </tr>
      <tr>
        <td id="L12858" data-line-number="12858"></td>
        <td id="LC12858">        <span><span>//</span> a handler inplace to deal w/ this exception.</span></td>
      </tr>
      <tr>
        <td id="L12859" data-line-number="12859"></td>
        <td id="LC12859">        pW32EventThread-&gt;<span>ForceDbgContinue</span>(<span>this</span>, pUnmanagedThread, DBG_EXCEPTION_NOT_HANDLED, <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L12860" data-line-number="12860"></td>
        <td id="LC12860">        <span>goto</span> LDone;</td>
      </tr>
      <tr>
        <td id="L12861" data-line-number="12861"></td>
        <td id="LC12861">
</td>
      </tr>
      <tr>
        <td id="L12862" data-line-number="12862"></td>
        <td id="LC12862">
</td>
      </tr>
      <tr>
        <td id="L12863" data-line-number="12863"></td>
        <td id="LC12863">    <span>case</span> Reaction::cInband_NotNewEvent:</td>
      </tr>
      <tr>
        <td id="L12864" data-line-number="12864"></td>
        <td id="LC12864">        <span>fNewEvent</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L12865" data-line-number="12865"></td>
        <td id="LC12865">
</td>
      </tr>
      <tr>
        <td id="L12866" data-line-number="12866"></td>
        <td id="LC12866">        <span><span>//</span> fall through to Inband case...</span></td>
      </tr>
      <tr>
        <td id="L12867" data-line-number="12867"></td>
        <td id="LC12867">
</td>
      </tr>
      <tr>
        <td id="L12868" data-line-number="12868"></td>
        <td id="LC12868">    <span>case</span> Reaction::cInband:</td>
      </tr>
      <tr>
        <td id="L12869" data-line-number="12869"></td>
        <td id="LC12869">    {</td>
      </tr>
      <tr>
        <td id="L12870" data-line-number="12870"></td>
        <td id="LC12870">        <span>this</span>-&gt;<span>m_DbgSupport</span>.<span>m_TotalIB</span>++;</td>
      </tr>
      <tr>
        <td id="L12871" data-line-number="12871"></td>
        <td id="LC12871">
</td>
      </tr>
      <tr>
        <td id="L12872" data-line-number="12872"></td>
        <td id="LC12872">        <span><span>//</span> Hijack in-band events (exception events, exit threads) if there is already an event at the head</span></td>
      </tr>
      <tr>
        <td id="L12873" data-line-number="12873"></td>
        <td id="LC12873">        <span><span>//</span> of the queue or if the process is currently synchronized. Of course, we only do this if the</span></td>
      </tr>
      <tr>
        <td id="L12874" data-line-number="12874"></td>
        <td id="LC12874">        <span><span>//</span> process is initialized.</span></td>
      </tr>
      <tr>
        <td id="L12875" data-line-number="12875"></td>
        <td id="LC12875">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L12876" data-line-number="12876"></td>
        <td id="LC12876">        <span><span>//</span> Note: we also hijack these left over in-band events if we're actively trying to send the</span></td>
      </tr>
      <tr>
        <td id="L12877" data-line-number="12877"></td>
        <td id="LC12877">        <span><span>//</span> managed continue message to the Left Side. This is controlled by m_specialDeferment below.</span></td>
      </tr>
      <tr>
        <td id="L12878" data-line-number="12878"></td>
        <td id="LC12878">
</td>
      </tr>
      <tr>
        <td id="L12879" data-line-number="12879"></td>
        <td id="LC12879">        <span><span>//</span> Only exceptions can be IB events - everything else is OOB.</span></td>
      </tr>
      <tr>
        <td id="L12880" data-line-number="12880"></td>
        <td id="LC12880">        <span>_ASSERTE</span>(pEvent-&gt;<span>dwDebugEventCode</span> == EXCEPTION_DEBUG_EVENT);</td>
      </tr>
      <tr>
        <td id="L12881" data-line-number="12881"></td>
        <td id="LC12881">
</td>
      </tr>
      <tr>
        <td id="L12882" data-line-number="12882"></td>
        <td id="LC12882">        <span><span>//</span> CLR internal exceptions should be sent back to the CLR and never treated as inband events.</span></td>
      </tr>
      <tr>
        <td id="L12883" data-line-number="12883"></td>
        <td id="LC12883">        <span><span>//</span> If this assert fires, the event was triaged wrong.</span></td>
      </tr>
      <tr>
        <td id="L12884" data-line-number="12884"></td>
        <td id="LC12884">        <span>CONSISTENCY_CHECK_MSGF</span>((pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span> != EXCEPTION_COMPLUS),</td>
      </tr>
      <tr>
        <td id="L12885" data-line-number="12885"></td>
        <td id="LC12885">            (<span><span>"</span>Attempting to dispatch a CLR internal exception as an Inband event. Reaction line=%d<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12886" data-line-number="12886"></td>
        <td id="LC12886">             reaction.<span>GetLine</span>()));</td>
      </tr>
      <tr>
        <td id="L12887" data-line-number="12887"></td>
        <td id="LC12887">
</td>
      </tr>
      <tr>
        <td id="L12888" data-line-number="12888"></td>
        <td id="LC12888">
</td>
      </tr>
      <tr>
        <td id="L12889" data-line-number="12889"></td>
        <td id="LC12889">        <span>_ASSERTE</span>(!pUnmanagedThread-&gt;<span>IsCantStop</span>());</td>
      </tr>
      <tr>
        <td id="L12890" data-line-number="12890"></td>
        <td id="LC12890">
</td>
      </tr>
      <tr>
        <td id="L12891" data-line-number="12891"></td>
        <td id="LC12891">        <span><span>//</span> We need to decide whether or not to dispatch this event immediately</span></td>
      </tr>
      <tr>
        <td id="L12892" data-line-number="12892"></td>
        <td id="LC12892">        <span><span>//</span> We defer it to enforce that we only dispatch 1 IB event at a time (managed events are</span></td>
      </tr>
      <tr>
        <td id="L12893" data-line-number="12893"></td>
        <td id="LC12893">        <span><span>//</span> considered IB here).</span></td>
      </tr>
      <tr>
        <td id="L12894" data-line-number="12894"></td>
        <td id="LC12894">        <span><span>//</span> This means if:</span></td>
      </tr>
      <tr>
        <td id="L12895" data-line-number="12895"></td>
        <td id="LC12895">        <span><span>//</span> 1) there's already an outstanding unmanaged inband event (an event the user has not continued from)</span></td>
      </tr>
      <tr>
        <td id="L12896" data-line-number="12896"></td>
        <td id="LC12896">        <span><span>//</span> 2) If the process is synchronized (since that means we've already dispatched a managed event).</span></td>
      </tr>
      <tr>
        <td id="L12897" data-line-number="12897"></td>
        <td id="LC12897">        <span><span>//</span> 3) If we've received a SyncComplete event, but aren't yet Sync.  This will almost always be the same as</span></td>
      </tr>
      <tr>
        <td id="L12898" data-line-number="12898"></td>
        <td id="LC12898">        <span><span>//</span>    whether we're synced, but has a distict quality. It's always set by the w32 event thread in Interop,</span></td>
      </tr>
      <tr>
        <td id="L12899" data-line-number="12899"></td>
        <td id="LC12899">        <span><span>//</span>    and so it's guaranteed to be serialized against this check here (also on the w32et).</span></td>
      </tr>
      <tr>
        <td id="L12900" data-line-number="12900"></td>
        <td id="LC12900">        <span><span>//</span> 4) Special deferment - This covers the region where we're sending a Stop/Continue IPC event across.</span></td>
      </tr>
      <tr>
        <td id="L12901" data-line-number="12901"></td>
        <td id="LC12901">        <span><span>//</span>    We defer it here to keep the Helper thread alive so that it can handle these IPC events.</span></td>
      </tr>
      <tr>
        <td id="L12902" data-line-number="12902"></td>
        <td id="LC12902">        <span><span>//</span> Queued events will be dispatched when continue is called.</span></td>
      </tr>
      <tr>
        <td id="L12903" data-line-number="12903"></td>
        <td id="LC12903">        BOOL <span>fHasUserUncontinuedNativeEvents</span> = <span>HasUserUncontinuedNativeEvents</span>();</td>
      </tr>
      <tr>
        <td id="L12904" data-line-number="12904"></td>
        <td id="LC12904">        <span>bool</span> <span>fDeferInbandEvent</span> = (<span>fHasUserUncontinuedNativeEvents</span> ||</td>
      </tr>
      <tr>
        <td id="L12905" data-line-number="12905"></td>
        <td id="LC12905">                                  <span>GetSynchronized</span>() ||</td>
      </tr>
      <tr>
        <td id="L12906" data-line-number="12906"></td>
        <td id="LC12906">                                  <span>GetSyncCompleteRecv</span>() ||</td>
      </tr>
      <tr>
        <td id="L12907" data-line-number="12907"></td>
        <td id="LC12907">                                  m_specialDeferment);</td>
      </tr>
      <tr>
        <td id="L12908" data-line-number="12908"></td>
        <td id="LC12908">
</td>
      </tr>
      <tr>
        <td id="L12909" data-line-number="12909"></td>
        <td id="LC12909">        <span><span>//</span> If we've got a new event, queue it.</span></td>
      </tr>
      <tr>
        <td id="L12910" data-line-number="12910"></td>
        <td id="LC12910">        <span>if</span> (<span>fNewEvent</span>)</td>
      </tr>
      <tr>
        <td id="L12911" data-line-number="12911"></td>
        <td id="LC12911">        {</td>
      </tr>
      <tr>
        <td id="L12912" data-line-number="12912"></td>
        <td id="LC12912">            <span>this</span>-&gt;<span>QueueUnmanagedEvent</span>(pUnmanagedThread, pEvent);</td>
      </tr>
      <tr>
        <td id="L12913" data-line-number="12913"></td>
        <td id="LC12913">        }</td>
      </tr>
      <tr>
        <td id="L12914" data-line-number="12914"></td>
        <td id="LC12914">
</td>
      </tr>
      <tr>
        <td id="L12915" data-line-number="12915"></td>
        <td id="LC12915">        <span>if</span> (<span>fNewEvent</span> &amp;&amp; <span>this</span>-&gt;<span>m_initialized</span> &amp;&amp; <span>fDeferInbandEvent</span>)</td>
      </tr>
      <tr>
        <td id="L12916" data-line-number="12916"></td>
        <td id="LC12916">        {</td>
      </tr>
      <tr>
        <td id="L12917" data-line-number="12917"></td>
        <td id="LC12917">            <span>STRESS_LOG4</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: Needed to defer dispatching event: %d %d %d %d<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L12918" data-line-number="12918"></td>
        <td id="LC12918">                 <span>fHasUserUncontinuedNativeEvents</span>,</td>
      </tr>
      <tr>
        <td id="L12919" data-line-number="12919"></td>
        <td id="LC12919">                 <span>GetSynchronized</span>(),</td>
      </tr>
      <tr>
        <td id="L12920" data-line-number="12920"></td>
        <td id="LC12920">                 <span>GetSyncCompleteRecv</span>(),</td>
      </tr>
      <tr>
        <td id="L12921" data-line-number="12921"></td>
        <td id="LC12921">                 m_specialDeferment);</td>
      </tr>
      <tr>
        <td id="L12922" data-line-number="12922"></td>
        <td id="LC12922">
</td>
      </tr>
      <tr>
        <td id="L12923" data-line-number="12923"></td>
        <td id="LC12923">            <span><span>//</span> this continues the IB debug event into the hijack</span></td>
      </tr>
      <tr>
        <td id="L12924" data-line-number="12924"></td>
        <td id="LC12924">            <span><span>//</span> the process is now running again</span></td>
      </tr>
      <tr>
        <td id="L12925" data-line-number="12925"></td>
        <td id="LC12925">            pW32EventThread-&gt;<span>DoDbgContinue</span>(<span>this</span>, pUnmanagedThread-&gt;<span>IBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L12926" data-line-number="12926"></td>
        <td id="LC12926">
</td>
      </tr>
      <tr>
        <td id="L12927" data-line-number="12927"></td>
        <td id="LC12927">            <span><span>//</span> Since we've hijacked this event, we don't need to do any further processing.</span></td>
      </tr>
      <tr>
        <td id="L12928" data-line-number="12928"></td>
        <td id="LC12928">            <span>goto</span> LDone;</td>
      </tr>
      <tr>
        <td id="L12929" data-line-number="12929"></td>
        <td id="LC12929">        }</td>
      </tr>
      <tr>
        <td id="L12930" data-line-number="12930"></td>
        <td id="LC12930">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L12931" data-line-number="12931"></td>
        <td id="LC12931">        {</td>
      </tr>
      <tr>
        <td id="L12932" data-line-number="12932"></td>
        <td id="LC12932">            <span><span>//</span> No need to defer the dispatch, do it now</span></td>
      </tr>
      <tr>
        <td id="L12933" data-line-number="12933"></td>
        <td id="LC12933">            <span>this</span>-&gt;<span>DispatchUnmanagedInBandEvent</span>();</td>
      </tr>
      <tr>
        <td id="L12934" data-line-number="12934"></td>
        <td id="LC12934">
</td>
      </tr>
      <tr>
        <td id="L12935" data-line-number="12935"></td>
        <td id="LC12935">            <span>goto</span> LDone;</td>
      </tr>
      <tr>
        <td id="L12936" data-line-number="12936"></td>
        <td id="LC12936">        }</td>
      </tr>
      <tr>
        <td id="L12937" data-line-number="12937"></td>
        <td id="LC12937">        <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L12938" data-line-number="12938"></td>
        <td id="LC12938">    }</td>
      </tr>
      <tr>
        <td id="L12939" data-line-number="12939"></td>
        <td id="LC12939">
</td>
      </tr>
      <tr>
        <td id="L12940" data-line-number="12940"></td>
        <td id="LC12940">    <span>case</span> Reaction::cFirstChanceHijackStarted:</td>
      </tr>
      <tr>
        <td id="L12941" data-line-number="12941"></td>
        <td id="LC12941">    {</td>
      </tr>
      <tr>
        <td id="L12942" data-line-number="12942"></td>
        <td id="LC12942">        <span><span>//</span> determine the logical event we are handling, if any</span></td>
      </tr>
      <tr>
        <td id="L12943" data-line-number="12943"></td>
        <td id="LC12943">        CordbUnmanagedEvent* pUnmanagedEvent = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L12944" data-line-number="12944"></td>
        <td id="LC12944">        <span>if</span>(pUnmanagedThread-&gt;<span>HasIBEvent</span>())</td>
      </tr>
      <tr>
        <td id="L12945" data-line-number="12945"></td>
        <td id="LC12945">        {</td>
      </tr>
      <tr>
        <td id="L12946" data-line-number="12946"></td>
        <td id="LC12946">            pUnmanagedEvent = pUnmanagedThread-&gt;<span>IBEvent</span>();</td>
      </tr>
      <tr>
        <td id="L12947" data-line-number="12947"></td>
        <td id="LC12947">        }</td>
      </tr>
      <tr>
        <td id="L12948" data-line-number="12948"></td>
        <td id="LC12948">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::W32EL: IB hijack starting, ue=0x%p<span>\n</span><span>"</span></span>, pUnmanagedEvent));</td>
      </tr>
      <tr>
        <td id="L12949" data-line-number="12949"></td>
        <td id="LC12949">
</td>
      </tr>
      <tr>
        <td id="L12950" data-line-number="12950"></td>
        <td id="LC12950">        <span><span>//</span> fetch the LS memory set up for this hijack</span></td>
      </tr>
      <tr>
        <td id="L12951" data-line-number="12951"></td>
        <td id="LC12951">        REMOTE_PTR pDebuggerWord = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L12952" data-line-number="12952"></td>
        <td id="LC12952">        DebuggerIPCFirstChanceData fcd;</td>
      </tr>
      <tr>
        <td id="L12953" data-line-number="12953"></td>
        <td id="LC12953">        pUnmanagedThread-&gt;<span>GetEEDebuggerWord</span>(&amp;pDebuggerWord);</td>
      </tr>
      <tr>
        <td id="L12954" data-line-number="12954"></td>
        <td id="LC12954">        <span>SafeReadStruct</span>(<span>PTR_TO_CORDB_ADDRESS</span>(pDebuggerWord), &amp;fcd);</td>
      </tr>
      <tr>
        <td id="L12955" data-line-number="12955"></td>
        <td id="LC12955">
</td>
      </tr>
      <tr>
        <td id="L12956" data-line-number="12956"></td>
        <td id="LC12956">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::W32EL: old fcd DebugCounter=0x%x<span>\n</span><span>"</span></span>, fcd.<span>debugCounter</span>));</td>
      </tr>
      <tr>
        <td id="L12957" data-line-number="12957"></td>
        <td id="LC12957">
</td>
      </tr>
      <tr>
        <td id="L12958" data-line-number="12958"></td>
        <td id="LC12958">        <span><span>//</span> determine what action the LS should take</span></td>
      </tr>
      <tr>
        <td id="L12959" data-line-number="12959"></td>
        <td id="LC12959">        <span>if</span>(pUnmanagedThread-&gt;<span>IsBlockingForSync</span>())</td>
      </tr>
      <tr>
        <td id="L12960" data-line-number="12960"></td>
        <td id="LC12960">        {</td>
      </tr>
      <tr>
        <td id="L12961" data-line-number="12961"></td>
        <td id="LC12961">            <span><span>//</span> there should be an event we hijacked in this case</span></td>
      </tr>
      <tr>
        <td id="L12962" data-line-number="12962"></td>
        <td id="LC12962">            <span>_ASSERTE</span>(pUnmanagedEvent != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L12963" data-line-number="12963"></td>
        <td id="LC12963">
</td>
      </tr>
      <tr>
        <td id="L12964" data-line-number="12964"></td>
        <td id="LC12964">            <span><span>//</span> block that event</span></td>
      </tr>
      <tr>
        <td id="L12965" data-line-number="12965"></td>
        <td id="LC12965">            <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::W32EL: blocking<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L12966" data-line-number="12966"></td>
        <td id="LC12966">            fcd.<span>action</span> = HIJACK_ACTION_WAIT;</td>
      </tr>
      <tr>
        <td id="L12967" data-line-number="12967"></td>
        <td id="LC12967">            fcd.<span>debugCounter</span> = <span>0x2</span>;</td>
      </tr>
      <tr>
        <td id="L12968" data-line-number="12968"></td>
        <td id="LC12968">            <span>SafeWriteStruct</span>(<span>PTR_TO_CORDB_ADDRESS</span>(pDebuggerWord), &amp;fcd);</td>
      </tr>
      <tr>
        <td id="L12969" data-line-number="12969"></td>
        <td id="LC12969">        }</td>
      </tr>
      <tr>
        <td id="L12970" data-line-number="12970"></td>
        <td id="LC12970">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L12971" data-line-number="12971"></td>
        <td id="LC12971">        {</td>
      </tr>
      <tr>
        <td id="L12972" data-line-number="12972"></td>
        <td id="LC12972">            <span><span>//</span> we don't need to block. We want the vectored handler to just exit</span></td>
      </tr>
      <tr>
        <td id="L12973" data-line-number="12973"></td>
        <td id="LC12973">            <span><span>//</span> as if it wasn't there</span></td>
      </tr>
      <tr>
        <td id="L12974" data-line-number="12974"></td>
        <td id="LC12974">            <span>_ASSERTE</span>(fcd.<span>action</span> == HIJACK_ACTION_EXIT_UNHANDLED);</td>
      </tr>
      <tr>
        <td id="L12975" data-line-number="12975"></td>
        <td id="LC12975">            <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::W32EL: not blocking<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L12976" data-line-number="12976"></td>
        <td id="LC12976">        }</td>
      </tr>
      <tr>
        <td id="L12977" data-line-number="12977"></td>
        <td id="LC12977">
</td>
      </tr>
      <tr>
        <td id="L12978" data-line-number="12978"></td>
        <td id="LC12978">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::W32EL: continuing from flare<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L12979" data-line-number="12979"></td>
        <td id="LC12979">        pW32EventThread-&gt;<span>ForceDbgContinue</span>(<span>this</span>, pUnmanagedThread, DBG_CONTINUE, <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L12980" data-line-number="12980"></td>
        <td id="LC12980">        <span>goto</span> LDone;</td>
      </tr>
      <tr>
        <td id="L12981" data-line-number="12981"></td>
        <td id="LC12981">    }</td>
      </tr>
      <tr>
        <td id="L12982" data-line-number="12982"></td>
        <td id="LC12982">
</td>
      </tr>
      <tr>
        <td id="L12983" data-line-number="12983"></td>
        <td id="LC12983">    <span>case</span> Reaction::cInbandHijackComplete:</td>
      </tr>
      <tr>
        <td id="L12984" data-line-number="12984"></td>
        <td id="LC12984">    {</td>
      </tr>
      <tr>
        <td id="L12985" data-line-number="12985"></td>
        <td id="LC12985">        <span><span>//</span> We now execute the hijack worker even when not actually hijacked</span></td>
      </tr>
      <tr>
        <td id="L12986" data-line-number="12986"></td>
        <td id="LC12986">        <span><span>//</span> so can't assert this</span></td>
      </tr>
      <tr>
        <td id="L12987" data-line-number="12987"></td>
        <td id="LC12987">        <span><span>//</span>_ASSERTE(pUnmanagedThread-&gt;IsFirstChanceHijacked());</span></td>
      </tr>
      <tr>
        <td id="L12988" data-line-number="12988"></td>
        <td id="LC12988">
</td>
      </tr>
      <tr>
        <td id="L12989" data-line-number="12989"></td>
        <td id="LC12989">        <span><span>//</span> we should not be stepping at the end of hijacks</span></td>
      </tr>
      <tr>
        <td id="L12990" data-line-number="12990"></td>
        <td id="LC12990">        <span>_ASSERTE</span>(!pUnmanagedThread-&gt;<span>IsSSFlagHidden</span>());</td>
      </tr>
      <tr>
        <td id="L12991" data-line-number="12991"></td>
        <td id="LC12991">        <span>_ASSERTE</span>(!pUnmanagedThread-&gt;<span>IsSSFlagNeeded</span>());</td>
      </tr>
      <tr>
        <td id="L12992" data-line-number="12992"></td>
        <td id="LC12992">
</td>
      </tr>
      <tr>
        <td id="L12993" data-line-number="12993"></td>
        <td id="LC12993">        <span><span>//</span> if we were hijacked then clean up</span></td>
      </tr>
      <tr>
        <td id="L12994" data-line-number="12994"></td>
        <td id="LC12994">        <span>if</span>(pUnmanagedThread-&gt;<span>IsFirstChanceHijacked</span>())</td>
      </tr>
      <tr>
        <td id="L12995" data-line-number="12995"></td>
        <td id="LC12995">        {</td>
      </tr>
      <tr>
        <td id="L12996" data-line-number="12996"></td>
        <td id="LC12996">            <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::W32EL: hijack complete will restore context...<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L12997" data-line-number="12997"></td>
        <td id="LC12997">            DT_CONTEXT tempContext = { <span>0</span> };</td>
      </tr>
      <tr>
        <td id="L12998" data-line-number="12998"></td>
        <td id="LC12998">            tempContext.<span>ContextFlags</span> = DT_CONTEXT_FULL;</td>
      </tr>
      <tr>
        <td id="L12999" data-line-number="12999"></td>
        <td id="LC12999">            HRESULT hr = pUnmanagedThread-&gt;<span>GetThreadContext</span>(&amp;tempContext);</td>
      </tr>
      <tr>
        <td id="L13000" data-line-number="13000"></td>
        <td id="LC13000">            <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L13001" data-line-number="13001"></td>
        <td id="LC13001">
</td>
      </tr>
      <tr>
        <td id="L13002" data-line-number="13002"></td>
        <td id="LC13002">            <span><span>//</span> The sync hijack returns normally but the m2uHandoff hijack needs to have the IP</span></td>
      </tr>
      <tr>
        <td id="L13003" data-line-number="13003"></td>
        <td id="LC13003">            <span><span>//</span> deliberately restored</span></td>
      </tr>
      <tr>
        <td id="L13004" data-line-number="13004"></td>
        <td id="LC13004">            <span>if</span>(!pUnmanagedThread-&gt;<span>IsBlockingForSync</span>())</td>
      </tr>
      <tr>
        <td id="L13005" data-line-number="13005"></td>
        <td id="LC13005">            {</td>
      </tr>
      <tr>
        <td id="L13006" data-line-number="13006"></td>
        <td id="LC13006">                <span><span>//</span> restore the context to the current un-hijacked context</span></td>
      </tr>
      <tr>
        <td id="L13007" data-line-number="13007"></td>
        <td id="LC13007">                BOOL succ = <span>DbiSetThreadContext</span>(pUnmanagedThread-&gt;<span>m_handle</span>, &amp;tempContext);</td>
      </tr>
      <tr>
        <td id="L13008" data-line-number="13008"></td>
        <td id="LC13008">                <span>_ASSERTE</span>(succ);</td>
      </tr>
      <tr>
        <td id="L13009" data-line-number="13009"></td>
        <td id="LC13009">
</td>
      </tr>
      <tr>
        <td id="L13010" data-line-number="13010"></td>
        <td id="LC13010">                <span><span>//</span> Because hijacks don't return normally they might have pushed handlers without poping them</span></td>
      </tr>
      <tr>
        <td id="L13011" data-line-number="13011"></td>
        <td id="LC13011">                <span><span>//</span> back off. To take care of that we explicitly restore the old SEH chain.</span></td>
      </tr>
      <tr>
        <td id="L13012" data-line-number="13012"></td>
        <td id="LC13012">    #<span>ifdef</span> DBG_TARGET_X86</td>
      </tr>
      <tr>
        <td id="L13013" data-line-number="13013"></td>
        <td id="LC13013">                hr = pUnmanagedThread-&gt;<span>RestoreLeafSeh</span>();</td>
      </tr>
      <tr>
        <td id="L13014" data-line-number="13014"></td>
        <td id="LC13014">                <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L13015" data-line-number="13015"></td>
        <td id="LC13015">    #<span>endif</span></td>
      </tr>
      <tr>
        <td id="L13016" data-line-number="13016"></td>
        <td id="LC13016">            }</td>
      </tr>
      <tr>
        <td id="L13017" data-line-number="13017"></td>
        <td id="LC13017">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L13018" data-line-number="13018"></td>
        <td id="LC13018">            {</td>
      </tr>
      <tr>
        <td id="L13019" data-line-number="13019"></td>
        <td id="LC13019">                <span>_ASSERTE</span>(pUnmanagedThread-&gt;<span>HasIBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L13020" data-line-number="13020"></td>
        <td id="LC13020">                CordbUnmanagedEvent* pUnmanagedEvent = pUnmanagedThread-&gt;<span>IBEvent</span>();</td>
      </tr>
      <tr>
        <td id="L13021" data-line-number="13021"></td>
        <td id="LC13021">                <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::W32EL: IB hijack completing, continuing unhijacked ue=0x%p<span>\n</span><span>"</span></span>, pUnmanagedEvent));</td>
      </tr>
      <tr>
        <td id="L13022" data-line-number="13022"></td>
        <td id="LC13022">                <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsEventContinuedHijacked</span>());</td>
      </tr>
      <tr>
        <td id="L13023" data-line-number="13023"></td>
        <td id="LC13023">                <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsDispatched</span>());</td>
      </tr>
      <tr>
        <td id="L13024" data-line-number="13024"></td>
        <td id="LC13024">                <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsEventUserContinued</span>());</td>
      </tr>
      <tr>
        <td id="L13025" data-line-number="13025"></td>
        <td id="LC13025">                <span>_ASSERTE</span>(!pUnmanagedEvent-&gt;<span>IsEventContinuedUnhijacked</span>());</td>
      </tr>
      <tr>
        <td id="L13026" data-line-number="13026"></td>
        <td id="LC13026">                pUnmanagedEvent-&gt;<span>SetState</span>(CUES_EventContinuedUnhijacked);</td>
      </tr>
      <tr>
        <td id="L13027" data-line-number="13027"></td>
        <td id="LC13027">
</td>
      </tr>
      <tr>
        <td id="L13028" data-line-number="13028"></td>
        <td id="LC13028">                <span><span>//</span> fetch the LS memory set up for this hijack</span></td>
      </tr>
      <tr>
        <td id="L13029" data-line-number="13029"></td>
        <td id="LC13029">                REMOTE_PTR pDebuggerWord = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L13030" data-line-number="13030"></td>
        <td id="LC13030">                DebuggerIPCFirstChanceData fcd;</td>
      </tr>
      <tr>
        <td id="L13031" data-line-number="13031"></td>
        <td id="LC13031">                pUnmanagedThread-&gt;<span>GetEEDebuggerWord</span>(&amp;pDebuggerWord);</td>
      </tr>
      <tr>
        <td id="L13032" data-line-number="13032"></td>
        <td id="LC13032">                <span>SafeReadStruct</span>(<span>PTR_TO_CORDB_ADDRESS</span>(pDebuggerWord), &amp;fcd);</td>
      </tr>
      <tr>
        <td id="L13033" data-line-number="13033"></td>
        <td id="LC13033">
</td>
      </tr>
      <tr>
        <td id="L13034" data-line-number="13034"></td>
        <td id="LC13034">                <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>W32ET::W32EL: pDebuggerWord is 0x%p<span>\n</span><span>"</span></span>, pDebuggerWord));</td>
      </tr>
      <tr>
        <td id="L13035" data-line-number="13035"></td>
        <td id="LC13035">
</td>
      </tr>
      <tr>
        <td id="L13036" data-line-number="13036"></td>
        <td id="LC13036">                <span><span>//</span>set the correct continuation action based upon the user's selection</span></td>
      </tr>
      <tr>
        <td id="L13037" data-line-number="13037"></td>
        <td id="LC13037">                <span>if</span>(pUnmanagedEvent-&gt;<span>IsExceptionCleared</span>())</td>
      </tr>
      <tr>
        <td id="L13038" data-line-number="13038"></td>
        <td id="LC13038">                {</td>
      </tr>
      <tr>
        <td id="L13039" data-line-number="13039"></td>
        <td id="LC13039">                    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>W32ET::W32EL: exception cleared<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L13040" data-line-number="13040"></td>
        <td id="LC13040">                    fcd.<span>action</span> = HIJACK_ACTION_EXIT_HANDLED;</td>
      </tr>
      <tr>
        <td id="L13041" data-line-number="13041"></td>
        <td id="LC13041">                }</td>
      </tr>
      <tr>
        <td id="L13042" data-line-number="13042"></td>
        <td id="LC13042">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L13043" data-line-number="13043"></td>
        <td id="LC13043">                {</td>
      </tr>
      <tr>
        <td id="L13044" data-line-number="13044"></td>
        <td id="LC13044">                    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>W32ET::W32EL: exception not cleared<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L13045" data-line-number="13045"></td>
        <td id="LC13045">                    fcd.<span>action</span> = HIJACK_ACTION_EXIT_UNHANDLED;</td>
      </tr>
      <tr>
        <td id="L13046" data-line-number="13046"></td>
        <td id="LC13046">                }</td>
      </tr>
      <tr>
        <td id="L13047" data-line-number="13047"></td>
        <td id="LC13047">
</td>
      </tr>
      <tr>
        <td id="L13048" data-line-number="13048"></td>
        <td id="LC13048">                <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13049" data-line-number="13049"></td>
        <td id="LC13049">                <span><span>//</span> LS context is restored here so that execution continues from next instruction that caused the hijack.</span></td>
      </tr>
      <tr>
        <td id="L13050" data-line-number="13050"></td>
        <td id="LC13050">                <span><span>//</span> We shouldn't always restore the LS context though.</span></td>
      </tr>
      <tr>
        <td id="L13051" data-line-number="13051"></td>
        <td id="LC13051">                <span><span>//</span> Consider the following case where this can cause issues:</span></td>
      </tr>
      <tr>
        <td id="L13052" data-line-number="13052"></td>
        <td id="LC13052">                <span><span>//</span> Debuggee process hits an exception and calls KERNELBASE!RaiseException, debugger gets the notification and</span></td>
      </tr>
      <tr>
        <td id="L13053" data-line-number="13053"></td>
        <td id="LC13053">                <span><span>//</span> prepares for first-chance hijack. Debugger(DBI) saves the current thread context (see SetupFirstChanceHijackForSync) which is restored</span></td>
      </tr>
      <tr>
        <td id="L13054" data-line-number="13054"></td>
        <td id="LC13054">                <span><span>//</span> later below (see SafeWriteThreadContext call) when the process is in VEH (CLRVectoredExceptionHandlerShim-&gt;FirstChanceSuspendHijackWorker).</span></td>
      </tr>
      <tr>
        <td id="L13055" data-line-number="13055"></td>
        <td id="LC13055">                <span><span>//</span> The thread context that got saved(by SetupFirstChanceHijackForSync) was for when the thread was executing RaiseException and when</span></td>
      </tr>
      <tr>
        <td id="L13056" data-line-number="13056"></td>
        <td id="LC13056">                <span><span>//</span> this context gets restored in VEH, the thread resumes after the exception handler with a context that is not same as one with which</span></td>
      </tr>
      <tr>
        <td id="L13057" data-line-number="13057"></td>
        <td id="LC13057">                <span><span>//</span> it entered. This inconsistency can lead to bad execution code-paths or even a debuggee crash.</span></td>
      </tr>
      <tr>
        <td id="L13058" data-line-number="13058"></td>
        <td id="LC13058">                <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13059" data-line-number="13059"></td>
        <td id="LC13059">                <span><span>//</span> Example case where we should definitely update the LS context:</span></td>
      </tr>
      <tr>
        <td id="L13060" data-line-number="13060"></td>
        <td id="LC13060">                <span><span>//</span> After a DbgBreakPoint call, IP gets updated to point to the instruction after int 3 and this is the context saved by debugger.</span></td>
      </tr>
      <tr>
        <td id="L13061" data-line-number="13061"></td>
        <td id="LC13061">                <span><span>//</span> The IP in context passed to VEH still points to int 3 though and if we don't update the LS context in VEH, the breakpoint</span></td>
      </tr>
      <tr>
        <td id="L13062" data-line-number="13062"></td>
        <td id="LC13062">                <span><span>//</span> instruction will get executed again.</span></td>
      </tr>
      <tr>
        <td id="L13063" data-line-number="13063"></td>
        <td id="LC13063">                <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13064" data-line-number="13064"></td>
        <td id="LC13064">                <span><span>//</span> Here's a list of cases when we update the LS context:</span></td>
      </tr>
      <tr>
        <td id="L13065" data-line-number="13065"></td>
        <td id="LC13065">                <span><span>//</span> * we know that context was explicitly updated during this hijack, OR</span></td>
      </tr>
      <tr>
        <td id="L13066" data-line-number="13066"></td>
        <td id="LC13066">                <span><span>//</span> * if single-stepping flag was set on it originally, OR</span></td>
      </tr>
      <tr>
        <td id="L13067" data-line-number="13067"></td>
        <td id="LC13067">                <span><span>//</span> * if this was a breakpoint event</span></td>
      </tr>
      <tr>
        <td id="L13068" data-line-number="13068"></td>
        <td id="LC13068">                <span><span>//</span> Note that above list is a heuristic and it is possible that we need to add more such cases in future.</span></td>
      </tr>
      <tr>
        <td id="L13069" data-line-number="13069"></td>
        <td id="LC13069">                <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13070" data-line-number="13070"></td>
        <td id="LC13070">                BOOL isBreakPointEvent = (pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>dwDebugEventCode</span> == EXCEPTION_DEBUG_EVENT &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L13071" data-line-number="13071"></td>
        <td id="LC13071">                    pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span> == STATUS_BREAKPOINT);</td>
      </tr>
      <tr>
        <td id="L13072" data-line-number="13072"></td>
        <td id="LC13072">                <span>if</span> (pUnmanagedThread-&gt;<span>IsContextSet</span>() || <span>IsSSFlagEnabled</span>(&amp;tempContext) || isBreakPointEvent)</td>
      </tr>
      <tr>
        <td id="L13073" data-line-number="13073"></td>
        <td id="LC13073">                {</td>
      </tr>
      <tr>
        <td id="L13074" data-line-number="13074"></td>
        <td id="LC13074">                    <span>_ASSERTE</span>(fcd.<span>pLeftSideContext</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L13075" data-line-number="13075"></td>
        <td id="LC13075">                    <span>LOG</span>((LF_CORDB, LL_INFO10000, <span><span>"</span>W32ET::W32EL: updating LS context at 0x%p<span>\n</span><span>"</span></span>, fcd.<span>pLeftSideContext</span>));</td>
      </tr>
      <tr>
        <td id="L13076" data-line-number="13076"></td>
        <td id="LC13076">                    <span><span>//</span> write the new context over the old one on the LS</span></td>
      </tr>
      <tr>
        <td id="L13077" data-line-number="13077"></td>
        <td id="LC13077">                    <span>SafeWriteThreadContext</span>(fcd.<span>pLeftSideContext</span>, &amp;tempContext);</td>
      </tr>
      <tr>
        <td id="L13078" data-line-number="13078"></td>
        <td id="LC13078">                }</td>
      </tr>
      <tr>
        <td id="L13079" data-line-number="13079"></td>
        <td id="LC13079">
</td>
      </tr>
      <tr>
        <td id="L13080" data-line-number="13080"></td>
        <td id="LC13080">                <span><span>//</span> Write the new Fcd data to the LS</span></td>
      </tr>
      <tr>
        <td id="L13081" data-line-number="13081"></td>
        <td id="LC13081">                fcd.<span>debugCounter</span> = <span>0x1</span>;</td>
      </tr>
      <tr>
        <td id="L13082" data-line-number="13082"></td>
        <td id="LC13082">                <span>SafeWriteStruct</span>(<span>PTR_TO_CORDB_ADDRESS</span>(pDebuggerWord), &amp;fcd);</td>
      </tr>
      <tr>
        <td id="L13083" data-line-number="13083"></td>
        <td id="LC13083">
</td>
      </tr>
      <tr>
        <td id="L13084" data-line-number="13084"></td>
        <td id="LC13084">                fcd.<span>debugCounter</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L13085" data-line-number="13085"></td>
        <td id="LC13085">                <span>SafeReadStruct</span>(<span>PTR_TO_CORDB_ADDRESS</span>(pDebuggerWord), &amp;fcd);</td>
      </tr>
      <tr>
        <td id="L13086" data-line-number="13086"></td>
        <td id="LC13086">                <span>_ASSERTE</span>(fcd.<span>debugCounter</span> == <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L13087" data-line-number="13087"></td>
        <td id="LC13087">
</td>
      </tr>
      <tr>
        <td id="L13088" data-line-number="13088"></td>
        <td id="LC13088">                <span>DequeueUnmanagedEvent</span>(pUnmanagedThread);</td>
      </tr>
      <tr>
        <td id="L13089" data-line-number="13089"></td>
        <td id="LC13089">            }</td>
      </tr>
      <tr>
        <td id="L13090" data-line-number="13090"></td>
        <td id="LC13090">
</td>
      </tr>
      <tr>
        <td id="L13091" data-line-number="13091"></td>
        <td id="LC13091">            <span>_ASSERTE</span>(m_cFirstChanceHijackedThreads &gt; <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L13092" data-line-number="13092"></td>
        <td id="LC13092">            m_cFirstChanceHijackedThreads--;</td>
      </tr>
      <tr>
        <td id="L13093" data-line-number="13093"></td>
        <td id="LC13093">            <span>if</span>(m_cFirstChanceHijackedThreads == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L13094" data-line-number="13094"></td>
        <td id="LC13094">            {</td>
      </tr>
      <tr>
        <td id="L13095" data-line-number="13095"></td>
        <td id="LC13095">                m_state &amp;= ~PS_HIJACKS_IN_PLACE;</td>
      </tr>
      <tr>
        <td id="L13096" data-line-number="13096"></td>
        <td id="LC13096">            }</td>
      </tr>
      <tr>
        <td id="L13097" data-line-number="13097"></td>
        <td id="LC13097">
</td>
      </tr>
      <tr>
        <td id="L13098" data-line-number="13098"></td>
        <td id="LC13098">            pUnmanagedThread-&gt;<span>ClearState</span>(CUTS_FirstChanceHijacked);</td>
      </tr>
      <tr>
        <td id="L13099" data-line-number="13099"></td>
        <td id="LC13099">            pUnmanagedThread-&gt;<span>ClearState</span>(CUTS_BlockingForSync);</td>
      </tr>
      <tr>
        <td id="L13100" data-line-number="13100"></td>
        <td id="LC13100">
</td>
      </tr>
      <tr>
        <td id="L13101" data-line-number="13101"></td>
        <td id="LC13101">            <span><span>//</span> if the user set the context it either was already applied (m2uHandoff hijack)</span></td>
      </tr>
      <tr>
        <td id="L13102" data-line-number="13102"></td>
        <td id="LC13102">            <span><span>//</span> or is about to be applied when the hijack returns (sync hijack).</span></td>
      </tr>
      <tr>
        <td id="L13103" data-line-number="13103"></td>
        <td id="LC13103">            <span><span>//</span> There may still a small window where it won't appear accurate that</span></td>
      </tr>
      <tr>
        <td id="L13104" data-line-number="13104"></td>
        <td id="LC13104">            <span><span>//</span> we just have to live with</span></td>
      </tr>
      <tr>
        <td id="L13105" data-line-number="13105"></td>
        <td id="LC13105">            pUnmanagedThread-&gt;<span>ClearState</span>(CUTS_HasContextSet);</td>
      </tr>
      <tr>
        <td id="L13106" data-line-number="13106"></td>
        <td id="LC13106">        }</td>
      </tr>
      <tr>
        <td id="L13107" data-line-number="13107"></td>
        <td id="LC13107">
</td>
      </tr>
      <tr>
        <td id="L13108" data-line-number="13108"></td>
        <td id="LC13108">        pW32EventThread-&gt;<span>ForceDbgContinue</span>(<span>this</span>, pUnmanagedThread, DBG_CONTINUE, <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L13109" data-line-number="13109"></td>
        <td id="LC13109">
</td>
      </tr>
      <tr>
        <td id="L13110" data-line-number="13110"></td>
        <td id="LC13110">        <span><span>//</span> We've handled this event. Skip further processing.</span></td>
      </tr>
      <tr>
        <td id="L13111" data-line-number="13111"></td>
        <td id="LC13111">        <span>goto</span> LDone;</td>
      </tr>
      <tr>
        <td id="L13112" data-line-number="13112"></td>
        <td id="LC13112">    }</td>
      </tr>
      <tr>
        <td id="L13113" data-line-number="13113"></td>
        <td id="LC13113">
</td>
      </tr>
      <tr>
        <td id="L13114" data-line-number="13114"></td>
        <td id="LC13114">    <span>case</span> Reaction::cBreakpointRequiringHijack:</td>
      </tr>
      <tr>
        <td id="L13115" data-line-number="13115"></td>
        <td id="LC13115">    {</td>
      </tr>
      <tr>
        <td id="L13116" data-line-number="13116"></td>
        <td id="LC13116">        HRESULT hr = pUnmanagedThread-&gt;<span>SetupFirstChanceHijack</span>(EHijackReason::<span>kM2UHandoff</span>, &amp;(pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>));</td>
      </tr>
      <tr>
        <td id="L13117" data-line-number="13117"></td>
        <td id="LC13117">        <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L13118" data-line-number="13118"></td>
        <td id="LC13118">        pW32EventThread-&gt;<span>ForceDbgContinue</span>(<span>this</span>, pUnmanagedThread, DBG_CONTINUE, <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L13119" data-line-number="13119"></td>
        <td id="LC13119">        <span>goto</span> LDone;</td>
      </tr>
      <tr>
        <td id="L13120" data-line-number="13120"></td>
        <td id="LC13120">    }</td>
      </tr>
      <tr>
        <td id="L13121" data-line-number="13121"></td>
        <td id="LC13121">
</td>
      </tr>
      <tr>
        <td id="L13122" data-line-number="13122"></td>
        <td id="LC13122">    <span>case</span> Reaction::cInbandExceptionRetrigger:</td>
      </tr>
      <tr>
        <td id="L13123" data-line-number="13123"></td>
        <td id="LC13123">    {</td>
      </tr>
      <tr>
        <td id="L13124" data-line-number="13124"></td>
        <td id="LC13124">        <span><span>//</span> this should be unused now</span></td>
      </tr>
      <tr>
        <td id="L13125" data-line-number="13125"></td>
        <td id="LC13125">        <span>_ASSERTE</span>(<span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L13126" data-line-number="13126"></td>
        <td id="LC13126">        <span>_ASSERTE</span>(pUnmanagedThread-&gt;<span>HasIBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L13127" data-line-number="13127"></td>
        <td id="LC13127">        CordbUnmanagedEvent* pUnmanagedEvent = pUnmanagedThread-&gt;<span>IBEvent</span>();</td>
      </tr>
      <tr>
        <td id="L13128" data-line-number="13128"></td>
        <td id="LC13128">        <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsIBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L13129" data-line-number="13129"></td>
        <td id="LC13129">        <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsEventContinuedUnhijacked</span>());</td>
      </tr>
      <tr>
        <td id="L13130" data-line-number="13130"></td>
        <td id="LC13130">        <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsDispatched</span>());</td>
      </tr>
      <tr>
        <td id="L13131" data-line-number="13131"></td>
        <td id="LC13131">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::W32EL: IB event completing, continuing ue=0x%p<span>\n</span><span>"</span></span>, pUnmanagedEvent));</td>
      </tr>
      <tr>
        <td id="L13132" data-line-number="13132"></td>
        <td id="LC13132">
</td>
      </tr>
      <tr>
        <td id="L13133" data-line-number="13133"></td>
        <td id="LC13133">        <span>DequeueUnmanagedEvent</span>(pUnmanagedThread);</td>
      </tr>
      <tr>
        <td id="L13134" data-line-number="13134"></td>
        <td id="LC13134">        <span><span>//</span> If this event came from RaiseException then flush the context to ensure we won't use it until we re-enter</span></td>
      </tr>
      <tr>
        <td id="L13135" data-line-number="13135"></td>
        <td id="LC13135">        <span>if</span>(pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>IsRaiseExceptionHijacked</span>())</td>
      </tr>
      <tr>
        <td id="L13136" data-line-number="13136"></td>
        <td id="LC13136">        {</td>
      </tr>
      <tr>
        <td id="L13137" data-line-number="13137"></td>
        <td id="LC13137">            pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>RestoreFromRaiseExceptionHijack</span>();</td>
      </tr>
      <tr>
        <td id="L13138" data-line-number="13138"></td>
        <td id="LC13138">            pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>ClearRaiseExceptionEntryContext</span>();</td>
      </tr>
      <tr>
        <td id="L13139" data-line-number="13139"></td>
        <td id="LC13139">        }</td>
      </tr>
      <tr>
        <td id="L13140" data-line-number="13140"></td>
        <td id="LC13140">        <span>else</span> <span><span>//</span> otherwise we should have been stepping</span></td>
      </tr>
      <tr>
        <td id="L13141" data-line-number="13141"></td>
        <td id="LC13141">        {</td>
      </tr>
      <tr>
        <td id="L13142" data-line-number="13142"></td>
        <td id="LC13142">            pUnmanagedThread-&gt;<span>EndStepping</span>();</td>
      </tr>
      <tr>
        <td id="L13143" data-line-number="13143"></td>
        <td id="LC13143">        }</td>
      </tr>
      <tr>
        <td id="L13144" data-line-number="13144"></td>
        <td id="LC13144">        pW32EventThread-&gt;<span>ForceDbgContinue</span>(<span>this</span>, pUnmanagedThread,</td>
      </tr>
      <tr>
        <td id="L13145" data-line-number="13145"></td>
        <td id="LC13145">            pUnmanagedEvent-&gt;<span>IsExceptionCleared</span>() ? DBG_CONTINUE : DBG_EXCEPTION_NOT_HANDLED, <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L13146" data-line-number="13146"></td>
        <td id="LC13146">
</td>
      </tr>
      <tr>
        <td id="L13147" data-line-number="13147"></td>
        <td id="LC13147">        <span><span>//</span> We've handled this event. Skip further processing.</span></td>
      </tr>
      <tr>
        <td id="L13148" data-line-number="13148"></td>
        <td id="LC13148">        <span>goto</span> LDone;</td>
      </tr>
      <tr>
        <td id="L13149" data-line-number="13149"></td>
        <td id="LC13149">    }</td>
      </tr>
      <tr>
        <td id="L13150" data-line-number="13150"></td>
        <td id="LC13150">
</td>
      </tr>
      <tr>
        <td id="L13151" data-line-number="13151"></td>
        <td id="LC13151">    <span>case</span> Reaction::cOOB:</td>
      </tr>
      <tr>
        <td id="L13152" data-line-number="13152"></td>
        <td id="LC13152">    {</td>
      </tr>
      <tr>
        <td id="L13153" data-line-number="13153"></td>
        <td id="LC13153">        <span><span>//</span> Don't care if this thread claimed to be suspended or not. Dispatch event anyways. After all,</span></td>
      </tr>
      <tr>
        <td id="L13154" data-line-number="13154"></td>
        <td id="LC13154">        <span><span>//</span> OOB events can come at *any* time.</span></td>
      </tr>
      <tr>
        <td id="L13155" data-line-number="13155"></td>
        <td id="LC13155">
</td>
      </tr>
      <tr>
        <td id="L13156" data-line-number="13156"></td>
        <td id="LC13156">        <span><span>//</span> This thread may be suspended. We don't care.</span></td>
      </tr>
      <tr>
        <td id="L13157" data-line-number="13157"></td>
        <td id="LC13157">        <span>this</span>-&gt;<span>m_DbgSupport</span>.<span>m_TotalOOB</span>++;</td>
      </tr>
      <tr>
        <td id="L13158" data-line-number="13158"></td>
        <td id="LC13158">
</td>
      </tr>
      <tr>
        <td id="L13159" data-line-number="13159"></td>
        <td id="LC13159">        <span><span>//</span> Not an  inband event. This includes ALL non-exception events (including EXIT_THREAD) as</span></td>
      </tr>
      <tr>
        <td id="L13160" data-line-number="13160"></td>
        <td id="LC13160">        <span><span>//</span> well as any exception that can't be hijacked (ex, an exception on the helper thread).</span></td>
      </tr>
      <tr>
        <td id="L13161" data-line-number="13161"></td>
        <td id="LC13161">
</td>
      </tr>
      <tr>
        <td id="L13162" data-line-number="13162"></td>
        <td id="LC13162">        <span><span>//</span> If this is an exit thread or exit process event, then we need to mark the unmanaged thread as</span></td>
      </tr>
      <tr>
        <td id="L13163" data-line-number="13163"></td>
        <td id="LC13163">        <span><span>//</span> exited for later.</span></td>
      </tr>
      <tr>
        <td id="L13164" data-line-number="13164"></td>
        <td id="LC13164">        <span>if</span> ((pEvent-&gt;<span>dwDebugEventCode</span> == EXIT_PROCESS_DEBUG_EVENT) ||</td>
      </tr>
      <tr>
        <td id="L13165" data-line-number="13165"></td>
        <td id="LC13165">            (pEvent-&gt;<span>dwDebugEventCode</span> == EXIT_THREAD_DEBUG_EVENT))</td>
      </tr>
      <tr>
        <td id="L13166" data-line-number="13166"></td>
        <td id="LC13166">        {</td>
      </tr>
      <tr>
        <td id="L13167" data-line-number="13167"></td>
        <td id="LC13167">            pUnmanagedThread-&gt;<span>SetState</span>(CUTS_Deleted);</td>
      </tr>
      <tr>
        <td id="L13168" data-line-number="13168"></td>
        <td id="LC13168">        }</td>
      </tr>
      <tr>
        <td id="L13169" data-line-number="13169"></td>
        <td id="LC13169">
</td>
      </tr>
      <tr>
        <td id="L13170" data-line-number="13170"></td>
        <td id="LC13170">        <span><span>//</span> If we get an exit process or exit thread event on the helper thread, then we know we're loosing</span></td>
      </tr>
      <tr>
        <td id="L13171" data-line-number="13171"></td>
        <td id="LC13171">        <span><span>//</span> the Left Side, so go ahead and remember that the helper thread has died.</span></td>
      </tr>
      <tr>
        <td id="L13172" data-line-number="13172"></td>
        <td id="LC13172">        <span>if</span> (<span>this</span>-&gt;<span>IsHelperThreadWorked</span>(pUnmanagedThread-&gt;<span>GetOSTid</span>()))</td>
      </tr>
      <tr>
        <td id="L13173" data-line-number="13173"></td>
        <td id="LC13173">        {</td>
      </tr>
      <tr>
        <td id="L13174" data-line-number="13174"></td>
        <td id="LC13174">            <span>if</span> ((pEvent-&gt;<span>dwDebugEventCode</span> == EXIT_PROCESS_DEBUG_EVENT) ||</td>
      </tr>
      <tr>
        <td id="L13175" data-line-number="13175"></td>
        <td id="LC13175">                (pEvent-&gt;<span>dwDebugEventCode</span> == EXIT_THREAD_DEBUG_EVENT))</td>
      </tr>
      <tr>
        <td id="L13176" data-line-number="13176"></td>
        <td id="LC13176">            {</td>
      </tr>
      <tr>
        <td id="L13177" data-line-number="13177"></td>
        <td id="LC13177">                <span>this</span>-&gt;<span>m_helperThreadDead</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L13178" data-line-number="13178"></td>
        <td id="LC13178">            }</td>
      </tr>
      <tr>
        <td id="L13179" data-line-number="13179"></td>
        <td id="LC13179">        }</td>
      </tr>
      <tr>
        <td id="L13180" data-line-number="13180"></td>
        <td id="LC13180">
</td>
      </tr>
      <tr>
        <td id="L13181" data-line-number="13181"></td>
        <td id="LC13181">        <span><span>//</span> Queue the current out-of-band event.</span></td>
      </tr>
      <tr>
        <td id="L13182" data-line-number="13182"></td>
        <td id="LC13182">        <span>this</span>-&gt;<span>QueueOOBUnmanagedEvent</span>(pUnmanagedThread, pEvent);</td>
      </tr>
      <tr>
        <td id="L13183" data-line-number="13183"></td>
        <td id="LC13183">
</td>
      </tr>
      <tr>
        <td id="L13184" data-line-number="13184"></td>
        <td id="LC13184">        <span><span>//</span> Go ahead and dispatch the event if its the first one.</span></td>
      </tr>
      <tr>
        <td id="L13185" data-line-number="13185"></td>
        <td id="LC13185">        <span>if</span> (<span>this</span>-&gt;<span>m_outOfBandEventQueue</span> == pUnmanagedThread-&gt;<span>OOBEvent</span>())</td>
      </tr>
      <tr>
        <td id="L13186" data-line-number="13186"></td>
        <td id="LC13186">        {</td>
      </tr>
      <tr>
        <td id="L13187" data-line-number="13187"></td>
        <td id="LC13187">            <span><span>//</span> Set this to true to indicate to Continue() that we're in the unamnaged callback.</span></td>
      </tr>
      <tr>
        <td id="L13188" data-line-number="13188"></td>
        <td id="LC13188">            CordbUnmanagedEvent * pUnmanagedEvent = pUnmanagedThread-&gt;<span>OOBEvent</span>();</td>
      </tr>
      <tr>
        <td id="L13189" data-line-number="13189"></td>
        <td id="LC13189">
</td>
      </tr>
      <tr>
        <td id="L13190" data-line-number="13190"></td>
        <td id="LC13190">            <span>this</span>-&gt;<span>m_dispatchingOOBEvent</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L13191" data-line-number="13191"></td>
        <td id="LC13191">
</td>
      </tr>
      <tr>
        <td id="L13192" data-line-number="13192"></td>
        <td id="LC13192">            pUnmanagedEvent-&gt;<span>SetState</span>(CUES_Dispatched);</td>
      </tr>
      <tr>
        <td id="L13193" data-line-number="13193"></td>
        <td id="LC13193">
</td>
      </tr>
      <tr>
        <td id="L13194" data-line-number="13194"></td>
        <td id="LC13194">            <span>this</span>-&gt;<span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L13195" data-line-number="13195"></td>
        <td id="LC13195">
</td>
      </tr>
      <tr>
        <td id="L13196" data-line-number="13196"></td>
        <td id="LC13196">            <span><span>//</span> Handler should have been registered by now.</span></td>
      </tr>
      <tr>
        <td id="L13197" data-line-number="13197"></td>
        <td id="LC13197">            <span>_ASSERTE</span>(<span>this</span>-&gt;<span>m_cordb</span>-&gt;<span>m_unmanagedCallback</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L13198" data-line-number="13198"></td>
        <td id="LC13198">
</td>
      </tr>
      <tr>
        <td id="L13199" data-line-number="13199"></td>
        <td id="LC13199">            <span><span>//</span> Call the callback with fIsOutOfBand = TRUE.</span></td>
      </tr>
      <tr>
        <td id="L13200" data-line-number="13200"></td>
        <td id="LC13200">            {</td>
      </tr>
      <tr>
        <td id="L13201" data-line-number="13201"></td>
        <td id="LC13201">                <span>PUBLIC_WIN32_CALLBACK_IN_THIS_SCOPE</span>(<span>this</span>, pEvent, <span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L13202" data-line-number="13202"></td>
        <td id="LC13202">                <span>this</span>-&gt;<span>m_cordb</span>-&gt;<span>m_unmanagedCallback</span>-&gt;<span>DebugEvent</span>(<span>const_cast</span>&lt;DEBUG_EVENT*&gt; (pEvent), <span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L13203" data-line-number="13203"></td>
        <td id="LC13203">            }</td>
      </tr>
      <tr>
        <td id="L13204" data-line-number="13204"></td>
        <td id="LC13204">
</td>
      </tr>
      <tr>
        <td id="L13205" data-line-number="13205"></td>
        <td id="LC13205">            <span>this</span>-&gt;<span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L13206" data-line-number="13206"></td>
        <td id="LC13206">
</td>
      </tr>
      <tr>
        <td id="L13207" data-line-number="13207"></td>
        <td id="LC13207">            <span><span>//</span> If m_dispatchingOOBEvent is false, that means that the user called Continue() from within</span></td>
      </tr>
      <tr>
        <td id="L13208" data-line-number="13208"></td>
        <td id="LC13208">            <span><span>//</span> the callback. We know that we can go ahead and continue the process now.</span></td>
      </tr>
      <tr>
        <td id="L13209" data-line-number="13209"></td>
        <td id="LC13209">            <span>if</span> (<span>this</span>-&gt;<span>m_dispatchingOOBEvent</span> == <span>false</span>)</td>
      </tr>
      <tr>
        <td id="L13210" data-line-number="13210"></td>
        <td id="LC13210">            {</td>
      </tr>
      <tr>
        <td id="L13211" data-line-number="13211"></td>
        <td id="LC13211">                <span><span>//</span> Note: this call will dispatch more OOB events if necessary.</span></td>
      </tr>
      <tr>
        <td id="L13212" data-line-number="13212"></td>
        <td id="LC13212">                pW32EventThread-&gt;<span>UnmanagedContinue</span>(<span>this</span>, cOobUMContinue);</td>
      </tr>
      <tr>
        <td id="L13213" data-line-number="13213"></td>
        <td id="LC13213">            }</td>
      </tr>
      <tr>
        <td id="L13214" data-line-number="13214"></td>
        <td id="LC13214">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L13215" data-line-number="13215"></td>
        <td id="LC13215">            {</td>
      </tr>
      <tr>
        <td id="L13216" data-line-number="13216"></td>
        <td id="LC13216">                <span><span>//</span> We're not dispatching anymore, so set this back to false.</span></td>
      </tr>
      <tr>
        <td id="L13217" data-line-number="13217"></td>
        <td id="LC13217">                <span>this</span>-&gt;<span>m_dispatchingOOBEvent</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L13218" data-line-number="13218"></td>
        <td id="LC13218">            }</td>
      </tr>
      <tr>
        <td id="L13219" data-line-number="13219"></td>
        <td id="LC13219">        }</td>
      </tr>
      <tr>
        <td id="L13220" data-line-number="13220"></td>
        <td id="LC13220">
</td>
      </tr>
      <tr>
        <td id="L13221" data-line-number="13221"></td>
        <td id="LC13221">        <span><span>//</span> We've handled this event. Skip further processing.</span></td>
      </tr>
      <tr>
        <td id="L13222" data-line-number="13222"></td>
        <td id="LC13222">        <span>goto</span> LDone;</td>
      </tr>
      <tr>
        <td id="L13223" data-line-number="13223"></td>
        <td id="LC13223">    }</td>
      </tr>
      <tr>
        <td id="L13224" data-line-number="13224"></td>
        <td id="LC13224">    } <span><span>//</span> end Switch on Reaction</span></td>
      </tr>
      <tr>
        <td id="L13225" data-line-number="13225"></td>
        <td id="LC13225">
</td>
      </tr>
      <tr>
        <td id="L13226" data-line-number="13226"></td>
        <td id="LC13226">    <span>UNREACHABLE</span>();</td>
      </tr>
      <tr>
        <td id="L13227" data-line-number="13227"></td>
        <td id="LC13227">
</td>
      </tr>
      <tr>
        <td id="L13228" data-line-number="13228"></td>
        <td id="LC13228">LDone:</td>
      </tr>
      <tr>
        <td id="L13229" data-line-number="13229"></td>
        <td id="LC13229">    <span><span>//</span> Process Lock implicitly released by holder.</span></td>
      </tr>
      <tr>
        <td id="L13230" data-line-number="13230"></td>
        <td id="LC13230">
</td>
      </tr>
      <tr>
        <td id="L13231" data-line-number="13231"></td>
        <td id="LC13231">    <span>STRESS_LOG0</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::W32EL: done processing event.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L13232" data-line-number="13232"></td>
        <td id="LC13232">
</td>
      </tr>
      <tr>
        <td id="L13233" data-line-number="13233"></td>
        <td id="LC13233">    <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L13234" data-line-number="13234"></td>
        <td id="LC13234">}</td>
      </tr>
      <tr>
        <td id="L13235" data-line-number="13235"></td>
        <td id="LC13235">
</td>
      </tr>
      <tr>
        <td id="L13236" data-line-number="13236"></td>
        <td id="LC13236"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13237" data-line-number="13237"></td>
        <td id="LC13237"><span><span>//</span> Returns true if the exception is a flare from the left side, false otherwise.</span></td>
      </tr>
      <tr>
        <td id="L13238" data-line-number="13238"></td>
        <td id="LC13238"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13239" data-line-number="13239"></td>
        <td id="LC13239"><span>bool</span> <span>CordbProcess::ExceptionIsFlare</span>(DWORD exceptionCode, <span>const</span> <span>void</span> *exceptionAddress)</td>
      </tr>
      <tr>
        <td id="L13240" data-line-number="13240"></td>
        <td id="LC13240">{</td>
      </tr>
      <tr>
        <td id="L13241" data-line-number="13241"></td>
        <td id="LC13241">    <span>_ASSERTE</span>(m_runtimeOffsetsInitialized);</td>
      </tr>
      <tr>
        <td id="L13242" data-line-number="13242"></td>
        <td id="LC13242">
</td>
      </tr>
      <tr>
        <td id="L13243" data-line-number="13243"></td>
        <td id="LC13243">    <span><span>//</span> Can't have a flare if the left side isn't initialized</span></td>
      </tr>
      <tr>
        <td id="L13244" data-line-number="13244"></td>
        <td id="LC13244">    <span>if</span> (m_initialized)</td>
      </tr>
      <tr>
        <td id="L13245" data-line-number="13245"></td>
        <td id="LC13245">    {</td>
      </tr>
      <tr>
        <td id="L13246" data-line-number="13246"></td>
        <td id="LC13246">        DebuggerIPCRuntimeOffsets *pRO = &amp;m_runtimeOffsets;</td>
      </tr>
      <tr>
        <td id="L13247" data-line-number="13247"></td>
        <td id="LC13247">
</td>
      </tr>
      <tr>
        <td id="L13248" data-line-number="13248"></td>
        <td id="LC13248">        <span><span>//</span> All flares are breakpoints...</span></td>
      </tr>
      <tr>
        <td id="L13249" data-line-number="13249"></td>
        <td id="LC13249">        <span>if</span> (exceptionCode == STATUS_BREAKPOINT)</td>
      </tr>
      <tr>
        <td id="L13250" data-line-number="13250"></td>
        <td id="LC13250">        {</td>
      </tr>
      <tr>
        <td id="L13251" data-line-number="13251"></td>
        <td id="LC13251">            <span><span>//</span> Does the breakpoint address match a flare address?</span></td>
      </tr>
      <tr>
        <td id="L13252" data-line-number="13252"></td>
        <td id="LC13252">            <span>if</span> ((exceptionAddress == pRO-&gt;<span>m_signalHijackStartedBPAddr</span>) ||</td>
      </tr>
      <tr>
        <td id="L13253" data-line-number="13253"></td>
        <td id="LC13253">                (exceptionAddress == pRO-&gt;<span>m_excepForRuntimeHandoffStartBPAddr</span>) ||</td>
      </tr>
      <tr>
        <td id="L13254" data-line-number="13254"></td>
        <td id="LC13254">                (exceptionAddress == pRO-&gt;<span>m_excepForRuntimeHandoffCompleteBPAddr</span>) ||</td>
      </tr>
      <tr>
        <td id="L13255" data-line-number="13255"></td>
        <td id="LC13255">                (exceptionAddress == pRO-&gt;<span>m_signalHijackCompleteBPAddr</span>) ||</td>
      </tr>
      <tr>
        <td id="L13256" data-line-number="13256"></td>
        <td id="LC13256">                (exceptionAddress == pRO-&gt;<span>m_excepNotForRuntimeBPAddr</span>) ||</td>
      </tr>
      <tr>
        <td id="L13257" data-line-number="13257"></td>
        <td id="LC13257">                (exceptionAddress == pRO-&gt;<span>m_notifyRSOfSyncCompleteBPAddr</span>))</td>
      </tr>
      <tr>
        <td id="L13258" data-line-number="13258"></td>
        <td id="LC13258">                <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L13259" data-line-number="13259"></td>
        <td id="LC13259">        }</td>
      </tr>
      <tr>
        <td id="L13260" data-line-number="13260"></td>
        <td id="LC13260">    }</td>
      </tr>
      <tr>
        <td id="L13261" data-line-number="13261"></td>
        <td id="LC13261">
</td>
      </tr>
      <tr>
        <td id="L13262" data-line-number="13262"></td>
        <td id="LC13262">    <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L13263" data-line-number="13263"></td>
        <td id="LC13263">}</td>
      </tr>
      <tr>
        <td id="L13264" data-line-number="13264"></td>
        <td id="LC13264">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L13265" data-line-number="13265"></td>
        <td id="LC13265">
</td>
      </tr>
      <tr>
        <td id="L13266" data-line-number="13266"></td>
        <td id="LC13266"><span><span>//</span> Allocate a buffer in the target and copy data into it.</span></td>
      </tr>
      <tr>
        <td id="L13267" data-line-number="13267"></td>
        <td id="LC13267"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13268" data-line-number="13268"></td>
        <td id="LC13268"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L13269" data-line-number="13269"></td>
        <td id="LC13269"><span><span>//</span>    pDomain - an appdomain associated with the allocation request.</span></td>
      </tr>
      <tr>
        <td id="L13270" data-line-number="13270"></td>
        <td id="LC13270"><span><span>//</span>    bufferSize - size of the buffer in bytes</span></td>
      </tr>
      <tr>
        <td id="L13271" data-line-number="13271"></td>
        <td id="LC13271"><span><span>//</span>    bufferFrom - local buffer of data (bufferSize bytes) to copy data from.</span></td>
      </tr>
      <tr>
        <td id="L13272" data-line-number="13272"></td>
        <td id="LC13272"><span><span>//</span>    ppRes - address into target of allocated buffer</span></td>
      </tr>
      <tr>
        <td id="L13273" data-line-number="13273"></td>
        <td id="LC13273"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13274" data-line-number="13274"></td>
        <td id="LC13274"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L13275" data-line-number="13275"></td>
        <td id="LC13275"><span><span>//</span>    S_OK on success, else error.</span></td>
      </tr>
      <tr>
        <td id="L13276" data-line-number="13276"></td>
        <td id="LC13276">HRESULT <span>CordbProcess::GetAndWriteRemoteBuffer</span>(CordbAppDomain *pDomain, <span>unsigned</span> <span>int</span> bufferSize, <span>const</span> <span>void</span> *bufferFrom, <span>void</span> **ppRes)</td>
      </tr>
      <tr>
        <td id="L13277" data-line-number="13277"></td>
        <td id="LC13277">{</td>
      </tr>
      <tr>
        <td id="L13278" data-line-number="13278"></td>
        <td id="LC13278">    <span>_ASSERTE</span>(ppRes != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L13279" data-line-number="13279"></td>
        <td id="LC13279">    *ppRes = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L13280" data-line-number="13280"></td>
        <td id="LC13280">
</td>
      </tr>
      <tr>
        <td id="L13281" data-line-number="13281"></td>
        <td id="LC13281">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L13282" data-line-number="13282"></td>
        <td id="LC13282">
</td>
      </tr>
      <tr>
        <td id="L13283" data-line-number="13283"></td>
        <td id="LC13283">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L13284" data-line-number="13284"></td>
        <td id="LC13284">    {</td>
      </tr>
      <tr>
        <td id="L13285" data-line-number="13285"></td>
        <td id="LC13285">        TargetBuffer tbTarget = <span>GetRemoteBuffer</span>(bufferSize); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L13286" data-line-number="13286"></td>
        <td id="LC13286">        <span>SafeWriteBuffer</span>(tbTarget, (<span>const</span> BYTE*) bufferFrom); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L13287" data-line-number="13287"></td>
        <td id="LC13287">
</td>
      </tr>
      <tr>
        <td id="L13288" data-line-number="13288"></td>
        <td id="LC13288">        <span><span>//</span> Succeeded.</span></td>
      </tr>
      <tr>
        <td id="L13289" data-line-number="13289"></td>
        <td id="LC13289">        *ppRes = <span>CORDB_ADDRESS_TO_PTR</span>(tbTarget.<span>pAddress</span>);</td>
      </tr>
      <tr>
        <td id="L13290" data-line-number="13290"></td>
        <td id="LC13290">    }</td>
      </tr>
      <tr>
        <td id="L13291" data-line-number="13291"></td>
        <td id="LC13291">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L13292" data-line-number="13292"></td>
        <td id="LC13292">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L13293" data-line-number="13293"></td>
        <td id="LC13293">}</td>
      </tr>
      <tr>
        <td id="L13294" data-line-number="13294"></td>
        <td id="LC13294">
</td>
      </tr>
      <tr>
        <td id="L13295" data-line-number="13295"></td>
        <td id="LC13295">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L13296" data-line-number="13296"></td>
        <td id="LC13296">
</td>
      </tr>
      <tr>
        <td id="L13297" data-line-number="13297"></td>
        <td id="LC13297"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13298" data-line-number="13298"></td>
        <td id="LC13298"><span><span>//</span> Checks to see if the given second chance exception event actually signifies the death of the process due to a second</span></td>
      </tr>
      <tr>
        <td id="L13299" data-line-number="13299"></td>
        <td id="LC13299"><span><span>//</span> stack overflow special case.</span></td>
      </tr>
      <tr>
        <td id="L13300" data-line-number="13300"></td>
        <td id="LC13300"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13301" data-line-number="13301"></td>
        <td id="LC13301"><span><span>//</span> There are strange cases with stack overflow exceptions. If a nieve application catches a stack overflow exception and</span></td>
      </tr>
      <tr>
        <td id="L13302" data-line-number="13302"></td>
        <td id="LC13302"><span><span>//</span> handles it, without resetting the guard page, then the app will get an AV when it overflows the stack a second time. We</span></td>
      </tr>
      <tr>
        <td id="L13303" data-line-number="13303"></td>
        <td id="LC13303"><span><span>//</span> will get the first chance AV, but when we continue from it the OS won't run any SEH handlers, so our FCH won't</span></td>
      </tr>
      <tr>
        <td id="L13304" data-line-number="13304"></td>
        <td id="LC13304"><span><span>//</span> actually work. Instead, we'll get the AV back on second chance right away.</span></td>
      </tr>
      <tr>
        <td id="L13305" data-line-number="13305"></td>
        <td id="LC13305"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13306" data-line-number="13306"></td>
        <td id="LC13306"><span>bool</span> <span>CordbProcess::IsSpecialStackOverflowCase</span>(CordbUnmanagedThread *pUThread, <span>const</span> DEBUG_EVENT *pEvent)</td>
      </tr>
      <tr>
        <td id="L13307" data-line-number="13307"></td>
        <td id="LC13307">{</td>
      </tr>
      <tr>
        <td id="L13308" data-line-number="13308"></td>
        <td id="LC13308">    <span>_ASSERTE</span>(pEvent-&gt;<span>dwDebugEventCode</span> == EXCEPTION_DEBUG_EVENT);</td>
      </tr>
      <tr>
        <td id="L13309" data-line-number="13309"></td>
        <td id="LC13309">    <span>_ASSERTE</span>(pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>dwFirstChance</span> == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L13310" data-line-number="13310"></td>
        <td id="LC13310">
</td>
      </tr>
      <tr>
        <td id="L13311" data-line-number="13311"></td>
        <td id="LC13311">    <span><span>//</span> If this is not an AV, it can't be our special case.</span></td>
      </tr>
      <tr>
        <td id="L13312" data-line-number="13312"></td>
        <td id="LC13312">    <span>if</span> (pEvent-&gt;<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span> != STATUS_ACCESS_VIOLATION)</td>
      </tr>
      <tr>
        <td id="L13313" data-line-number="13313"></td>
        <td id="LC13313">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L13314" data-line-number="13314"></td>
        <td id="LC13314">
</td>
      </tr>
      <tr>
        <td id="L13315" data-line-number="13315"></td>
        <td id="LC13315">    <span><span>//</span> If the thread isn't already first chance hijacked, it can't be our special case.</span></td>
      </tr>
      <tr>
        <td id="L13316" data-line-number="13316"></td>
        <td id="LC13316">    <span>if</span> (!pUThread-&gt;<span>IsFirstChanceHijacked</span>())</td>
      </tr>
      <tr>
        <td id="L13317" data-line-number="13317"></td>
        <td id="LC13317">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L13318" data-line-number="13318"></td>
        <td id="LC13318">
</td>
      </tr>
      <tr>
        <td id="L13319" data-line-number="13319"></td>
        <td id="LC13319">    <span><span>//</span> The first chance hijack didn't take, so we're not FCH anymore and we're not waiting for an answer</span></td>
      </tr>
      <tr>
        <td id="L13320" data-line-number="13320"></td>
        <td id="LC13320">    <span><span>//</span> anymore... Note: by leaving this thread completely unhijacked, we'll report its true context, which is correct.</span></td>
      </tr>
      <tr>
        <td id="L13321" data-line-number="13321"></td>
        <td id="LC13321">    pUThread-&gt;<span>ClearState</span>(CUTS_FirstChanceHijacked);</td>
      </tr>
      <tr>
        <td id="L13322" data-line-number="13322"></td>
        <td id="LC13322">
</td>
      </tr>
      <tr>
        <td id="L13323" data-line-number="13323"></td>
        <td id="LC13323">    <span><span>//</span> The process is techincally dead as a door nail here, so we'll mark that the helper thread is dead so our managed</span></td>
      </tr>
      <tr>
        <td id="L13324" data-line-number="13324"></td>
        <td id="LC13324">    <span><span>//</span> API bails nicely.</span></td>
      </tr>
      <tr>
        <td id="L13325" data-line-number="13325"></td>
        <td id="LC13325">    m_helperThreadDead = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L13326" data-line-number="13326"></td>
        <td id="LC13326">
</td>
      </tr>
      <tr>
        <td id="L13327" data-line-number="13327"></td>
        <td id="LC13327">    <span><span>//</span> Remember we're in our special case.</span></td>
      </tr>
      <tr>
        <td id="L13328" data-line-number="13328"></td>
        <td id="LC13328">    pUThread-&gt;<span>SetState</span>(CUTS_HasSpecialStackOverflowCase);</td>
      </tr>
      <tr>
        <td id="L13329" data-line-number="13329"></td>
        <td id="LC13329">
</td>
      </tr>
      <tr>
        <td id="L13330" data-line-number="13330"></td>
        <td id="LC13330">    <span><span>//</span> Now, remember the second chance AV event in the second IB event slot for this thread and add it to the end of the</span></td>
      </tr>
      <tr>
        <td id="L13331" data-line-number="13331"></td>
        <td id="LC13331">    <span><span>//</span> IB event queue.</span></td>
      </tr>
      <tr>
        <td id="L13332" data-line-number="13332"></td>
        <td id="LC13332">    <span>QueueUnmanagedEvent</span>(pUThread, pEvent);</td>
      </tr>
      <tr>
        <td id="L13333" data-line-number="13333"></td>
        <td id="LC13333">
</td>
      </tr>
      <tr>
        <td id="L13334" data-line-number="13334"></td>
        <td id="LC13334">    <span><span>//</span> Note: returning true will ensure that the queued first chance AV for this thread is dispatched.</span></td>
      </tr>
      <tr>
        <td id="L13335" data-line-number="13335"></td>
        <td id="LC13335">    <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L13336" data-line-number="13336"></td>
        <td id="LC13336">}</td>
      </tr>
      <tr>
        <td id="L13337" data-line-number="13337"></td>
        <td id="LC13337">
</td>
      </tr>
      <tr>
        <td id="L13338" data-line-number="13338"></td>
        <td id="LC13338"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13339" data-line-number="13339"></td>
        <td id="LC13339"><span><span>//</span> Longhorn broke ContinueDebugEvent.</span></td>
      </tr>
      <tr>
        <td id="L13340" data-line-number="13340"></td>
        <td id="LC13340"><span><span>//</span> In previous OS releases, DBG_CONTINUE would continue a  non-continuable exception.</span></td>
      </tr>
      <tr>
        <td id="L13341" data-line-number="13341"></td>
        <td id="LC13341"><span><span>//</span> In longhorn, we need to pass the DBG_FORCE_CONTINUE flag to do that.</span></td>
      </tr>
      <tr>
        <td id="L13342" data-line-number="13342"></td>
        <td id="LC13342"><span><span>//</span> Note that all CLR exceptions are non-continuable.</span></td>
      </tr>
      <tr>
        <td id="L13343" data-line-number="13343"></td>
        <td id="LC13343"><span><span>//</span> Now instead of DBG_CONTINUE, we need to pass DBG_FORCE_CONTINUE.</span></td>
      </tr>
      <tr>
        <td id="L13344" data-line-number="13344"></td>
        <td id="LC13344"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13345" data-line-number="13345"></td>
        <td id="LC13345">
</td>
      </tr>
      <tr>
        <td id="L13346" data-line-number="13346"></td>
        <td id="LC13346"><span><span>//</span> Currently we don't have headers for the longhorn winnt.h. So we need to privately declare</span></td>
      </tr>
      <tr>
        <td id="L13347" data-line-number="13347"></td>
        <td id="LC13347"><span><span>//</span> this here. We have a check such that if we do get headers, the value won't change underneath us.</span></td>
      </tr>
      <tr>
        <td id="L13348" data-line-number="13348"></td>
        <td id="LC13348">#<span>define</span> <span>MY_DBG_FORCE_CONTINUE</span>               ((DWORD   )<span>0x00010003L</span>)</td>
      </tr>
      <tr>
        <td id="L13349" data-line-number="13349"></td>
        <td id="LC13349">#<span>ifndef</span> DBG_FORCE_CONTINUE</td>
      </tr>
      <tr>
        <td id="L13350" data-line-number="13350"></td>
        <td id="LC13350">#<span>define</span> <span>DBG_FORCE_CONTINUE</span> MY_DBG_FORCE_CONTINUE</td>
      </tr>
      <tr>
        <td id="L13351" data-line-number="13351"></td>
        <td id="LC13351">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L13352" data-line-number="13352"></td>
        <td id="LC13352"><span>static_assert_no_msg</span>(DBG_FORCE_CONTINUE == MY_DBG_FORCE_CONTINUE);</td>
      </tr>
      <tr>
        <td id="L13353" data-line-number="13353"></td>
        <td id="LC13353">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L13354" data-line-number="13354"></td>
        <td id="LC13354">
</td>
      </tr>
      <tr>
        <td id="L13355" data-line-number="13355"></td>
        <td id="LC13355">DWORD <span>GetDbgContinueFlag</span>()</td>
      </tr>
      <tr>
        <td id="L13356" data-line-number="13356"></td>
        <td id="LC13356">{</td>
      </tr>
      <tr>
        <td id="L13357" data-line-number="13357"></td>
        <td id="LC13357">    <span><span>//</span> Currently, default to not using the new DBG_FORCE_CONTINUE flag.</span></td>
      </tr>
      <tr>
        <td id="L13358" data-line-number="13358"></td>
        <td id="LC13358">    <span>static</span> ConfigDWORD <span>fNoFlagKey</span>;</td>
      </tr>
      <tr>
        <td id="L13359" data-line-number="13359"></td>
        <td id="LC13359">    <span>bool</span> <span>fNoFlag</span> = <span>fNoFlagKey</span>.<span>val</span>(CLRConfig::UNSUPPORTED_DbgNoForceContinue) != <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L13360" data-line-number="13360"></td>
        <td id="LC13360">
</td>
      </tr>
      <tr>
        <td id="L13361" data-line-number="13361"></td>
        <td id="LC13361">
</td>
      </tr>
      <tr>
        <td id="L13362" data-line-number="13362"></td>
        <td id="LC13362">    <span>if</span> (!<span>fNoFlag</span>)</td>
      </tr>
      <tr>
        <td id="L13363" data-line-number="13363"></td>
        <td id="LC13363">    {</td>
      </tr>
      <tr>
        <td id="L13364" data-line-number="13364"></td>
        <td id="LC13364">        <span>return</span> DBG_FORCE_CONTINUE;</td>
      </tr>
      <tr>
        <td id="L13365" data-line-number="13365"></td>
        <td id="LC13365">    }</td>
      </tr>
      <tr>
        <td id="L13366" data-line-number="13366"></td>
        <td id="LC13366">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L13367" data-line-number="13367"></td>
        <td id="LC13367">    {</td>
      </tr>
      <tr>
        <td id="L13368" data-line-number="13368"></td>
        <td id="LC13368">        <span>return</span> DBG_CONTINUE;</td>
      </tr>
      <tr>
        <td id="L13369" data-line-number="13369"></td>
        <td id="LC13369">    }</td>
      </tr>
      <tr>
        <td id="L13370" data-line-number="13370"></td>
        <td id="LC13370">}</td>
      </tr>
      <tr>
        <td id="L13371" data-line-number="13371"></td>
        <td id="LC13371">
</td>
      </tr>
      <tr>
        <td id="L13372" data-line-number="13372"></td>
        <td id="LC13372">
</td>
      </tr>
      <tr>
        <td id="L13373" data-line-number="13373"></td>
        <td id="LC13373"><span><span>//</span> Some Interop bugs involve threads that land at a bad IP. Since we're interop-debugging, we can't</span></td>
      </tr>
      <tr>
        <td id="L13374" data-line-number="13374"></td>
        <td id="LC13374"><span><span>//</span> attach a debugger to the LS. So we have some debug mode where we enable the SS flag and thus</span></td>
      </tr>
      <tr>
        <td id="L13375" data-line-number="13375"></td>
        <td id="LC13375"><span><span>//</span> produce a trace of where a thread is going.</span></td>
      </tr>
      <tr>
        <td id="L13376" data-line-number="13376"></td>
        <td id="LC13376">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L13377" data-line-number="13377"></td>
        <td id="LC13377"><span>void</span> <span>EnableDebugTrace</span>(CordbUnmanagedThread *ut)</td>
      </tr>
      <tr>
        <td id="L13378" data-line-number="13378"></td>
        <td id="LC13378">{</td>
      </tr>
      <tr>
        <td id="L13379" data-line-number="13379"></td>
        <td id="LC13379">    <span><span>//</span> To enable, attach w/ a debugger and either set fTrace==true, or setip.</span></td>
      </tr>
      <tr>
        <td id="L13380" data-line-number="13380"></td>
        <td id="LC13380">    <span>static</span> <span>bool</span> <span>fTrace</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L13381" data-line-number="13381"></td>
        <td id="LC13381">    <span>if</span> (!<span>fTrace</span>)</td>
      </tr>
      <tr>
        <td id="L13382" data-line-number="13382"></td>
        <td id="LC13382">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L13383" data-line-number="13383"></td>
        <td id="LC13383">
</td>
      </tr>
      <tr>
        <td id="L13384" data-line-number="13384"></td>
        <td id="LC13384">    <span><span>//</span> Give us a nop so that we can setip in the optimized case.</span></td>
      </tr>
      <tr>
        <td id="L13385" data-line-number="13385"></td>
        <td id="LC13385">#<span>ifdef</span> _TARGET_X86_</td>
      </tr>
      <tr>
        <td id="L13386" data-line-number="13386"></td>
        <td id="LC13386">    __asm {</td>
      </tr>
      <tr>
        <td id="L13387" data-line-number="13387"></td>
        <td id="LC13387">        nop</td>
      </tr>
      <tr>
        <td id="L13388" data-line-number="13388"></td>
        <td id="LC13388">    }</td>
      </tr>
      <tr>
        <td id="L13389" data-line-number="13389"></td>
        <td id="LC13389">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L13390" data-line-number="13390"></td>
        <td id="LC13390">
</td>
      </tr>
      <tr>
        <td id="L13391" data-line-number="13391"></td>
        <td id="LC13391">    <span>fTrace</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L13392" data-line-number="13392"></td>
        <td id="LC13392">    CordbProcess *pProcess = ut-&gt;<span>GetProcess</span>();</td>
      </tr>
      <tr>
        <td id="L13393" data-line-number="13393"></td>
        <td id="LC13393">
</td>
      </tr>
      <tr>
        <td id="L13394" data-line-number="13394"></td>
        <td id="LC13394">    <span><span>//</span> Get the context</span></td>
      </tr>
      <tr>
        <td id="L13395" data-line-number="13395"></td>
        <td id="LC13395">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L13396" data-line-number="13396"></td>
        <td id="LC13396">    DT_CONTEXT context;</td>
      </tr>
      <tr>
        <td id="L13397" data-line-number="13397"></td>
        <td id="LC13397">    context.<span>ContextFlags</span> = DT_CONTEXT_FULL;</td>
      </tr>
      <tr>
        <td id="L13398" data-line-number="13398"></td>
        <td id="LC13398">
</td>
      </tr>
      <tr>
        <td id="L13399" data-line-number="13399"></td>
        <td id="LC13399">
</td>
      </tr>
      <tr>
        <td id="L13400" data-line-number="13400"></td>
        <td id="LC13400">    hr = pProcess-&gt;<span>GetThreadContext</span>((DWORD) ut-&gt;<span>m_id</span>, <span>sizeof</span>(context), (BYTE*)&amp;context);</td>
      </tr>
      <tr>
        <td id="L13401" data-line-number="13401"></td>
        <td id="LC13401">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L13402" data-line-number="13402"></td>
        <td id="LC13402">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L13403" data-line-number="13403"></td>
        <td id="LC13403">
</td>
      </tr>
      <tr>
        <td id="L13404" data-line-number="13404"></td>
        <td id="LC13404">    <span><span>//</span> If the flag is already set, then don't set it again - that will just get confusing.</span></td>
      </tr>
      <tr>
        <td id="L13405" data-line-number="13405"></td>
        <td id="LC13405">    <span>if</span> (<span>IsSSFlagEnabled</span>(&amp;context))</td>
      </tr>
      <tr>
        <td id="L13406" data-line-number="13406"></td>
        <td id="LC13406">    {</td>
      </tr>
      <tr>
        <td id="L13407" data-line-number="13407"></td>
        <td id="LC13407">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L13408" data-line-number="13408"></td>
        <td id="LC13408">    }</td>
      </tr>
      <tr>
        <td id="L13409" data-line-number="13409"></td>
        <td id="LC13409">    <span>_ASSERTE</span>(<span>CORDbgGetIP</span>(&amp;context) != <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L13410" data-line-number="13410"></td>
        <td id="LC13410">    <span>SetSSFlag</span>(&amp;context);</td>
      </tr>
      <tr>
        <td id="L13411" data-line-number="13411"></td>
        <td id="LC13411">
</td>
      </tr>
      <tr>
        <td id="L13412" data-line-number="13412"></td>
        <td id="LC13412">    <span><span>//</span> If SS flag not set, enable it. And remeber that it's us so we know how to handle</span></td>
      </tr>
      <tr>
        <td id="L13413" data-line-number="13413"></td>
        <td id="LC13413">    <span><span>//</span> it when we get the debug event.</span></td>
      </tr>
      <tr>
        <td id="L13414" data-line-number="13414"></td>
        <td id="LC13414">    hr = pProcess-&gt;<span>SetThreadContext</span>((DWORD)ut-&gt;<span>m_id</span>, <span>sizeof</span>(context), (BYTE*)&amp;context);</td>
      </tr>
      <tr>
        <td id="L13415" data-line-number="13415"></td>
        <td id="LC13415">    ut-&gt;<span>SetState</span>(CUTS_DEBUG_SingleStep);</td>
      </tr>
      <tr>
        <td id="L13416" data-line-number="13416"></td>
        <td id="LC13416">}</td>
      </tr>
      <tr>
        <td id="L13417" data-line-number="13417"></td>
        <td id="LC13417">#<span>endif</span> <span><span>//</span> _DEBUG</span></td>
      </tr>
      <tr>
        <td id="L13418" data-line-number="13418"></td>
        <td id="LC13418">
</td>
      </tr>
      <tr>
        <td id="L13419" data-line-number="13419"></td>
        <td id="LC13419"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13420" data-line-number="13420"></td>
        <td id="LC13420"><span><span>//</span> DoDbgContinue</span></td>
      </tr>
      <tr>
        <td id="L13421" data-line-number="13421"></td>
        <td id="LC13421"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13422" data-line-number="13422"></td>
        <td id="LC13422"><span><span>//</span> Continues from a specific Win32 DEBUG_EVENT.</span></td>
      </tr>
      <tr>
        <td id="L13423" data-line-number="13423"></td>
        <td id="LC13423"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13424" data-line-number="13424"></td>
        <td id="LC13424"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L13425" data-line-number="13425"></td>
        <td id="LC13425"><span><span>//</span>    pProcess - The process to continue.</span></td>
      </tr>
      <tr>
        <td id="L13426" data-line-number="13426"></td>
        <td id="LC13426"><span><span>//</span>    pUnmanagedEvent - The event to continue.</span></td>
      </tr>
      <tr>
        <td id="L13427" data-line-number="13427"></td>
        <td id="LC13427"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13428" data-line-number="13428"></td>
        <td id="LC13428"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13429" data-line-number="13429"></td>
        <td id="LC13429"><span>void</span> <span>CordbWin32EventThread::DoDbgContinue</span>(CordbProcess *pProcess,</td>
      </tr>
      <tr>
        <td id="L13430" data-line-number="13430"></td>
        <td id="LC13430">                                          CordbUnmanagedEvent *pUnmanagedEvent)</td>
      </tr>
      <tr>
        <td id="L13431" data-line-number="13431"></td>
        <td id="LC13431">{</td>
      </tr>
      <tr>
        <td id="L13432" data-line-number="13432"></td>
        <td id="LC13432">    <span>_ASSERTE</span>(pProcess-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L13433" data-line-number="13433"></td>
        <td id="LC13433">    <span>_ASSERTE</span>(<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L13434" data-line-number="13434"></td>
        <td id="LC13434">    <span>_ASSERTE</span>(pUnmanagedEvent != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L13435" data-line-number="13435"></td>
        <td id="LC13435">    <span>_ASSERTE</span>(!pUnmanagedEvent-&gt;<span>IsEventContinuedUnhijacked</span>());</td>
      </tr>
      <tr>
        <td id="L13436" data-line-number="13436"></td>
        <td id="LC13436">
</td>
      </tr>
      <tr>
        <td id="L13437" data-line-number="13437"></td>
        <td id="LC13437">    <span>STRESS_LOG3</span>(LF_CORDB, LL_INFO1000,</td>
      </tr>
      <tr>
        <td id="L13438" data-line-number="13438"></td>
        <td id="LC13438">         <span><span>"</span>W32ET::DDC: continue with ue=0x%p, thread=0x%p, tid=0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L13439" data-line-number="13439"></td>
        <td id="LC13439">         pUnmanagedEvent,</td>
      </tr>
      <tr>
        <td id="L13440" data-line-number="13440"></td>
        <td id="LC13440">         pUnmanagedEvent-&gt;<span>m_owner</span>,</td>
      </tr>
      <tr>
        <td id="L13441" data-line-number="13441"></td>
        <td id="LC13441">         pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>m_id</span>);</td>
      </tr>
      <tr>
        <td id="L13442" data-line-number="13442"></td>
        <td id="LC13442">
</td>
      </tr>
      <tr>
        <td id="L13443" data-line-number="13443"></td>
        <td id="LC13443">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L13444" data-line-number="13444"></td>
        <td id="LC13444">    <span>EnableDebugTrace</span>(pUnmanagedEvent-&gt;<span>m_owner</span>);</td>
      </tr>
      <tr>
        <td id="L13445" data-line-number="13445"></td>
        <td id="LC13445">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L13446" data-line-number="13446"></td>
        <td id="LC13446">
</td>
      </tr>
      <tr>
        <td id="L13447" data-line-number="13447"></td>
        <td id="LC13447">
</td>
      </tr>
      <tr>
        <td id="L13448" data-line-number="13448"></td>
        <td id="LC13448">    <span>if</span> (pUnmanagedEvent-&gt;<span>IsEventContinuedHijacked</span>())</td>
      </tr>
      <tr>
        <td id="L13449" data-line-number="13449"></td>
        <td id="LC13449">    {</td>
      </tr>
      <tr>
        <td id="L13450" data-line-number="13450"></td>
        <td id="LC13450">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::DDC: Skiping DoDbgContinue because event was already<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L13451" data-line-number="13451"></td>
        <td id="LC13451">            <span><span>"</span> continued hijacked, ue=0x%p<span>\n</span><span>"</span></span>, pUnmanagedEvent));</td>
      </tr>
      <tr>
        <td id="L13452" data-line-number="13452"></td>
        <td id="LC13452">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L13453" data-line-number="13453"></td>
        <td id="LC13453">    }</td>
      </tr>
      <tr>
        <td id="L13454" data-line-number="13454"></td>
        <td id="LC13454">
</td>
      </tr>
      <tr>
        <td id="L13455" data-line-number="13455"></td>
        <td id="LC13455">    BOOL threadIsHijacked = (pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>IsFirstChanceHijacked</span>() ||</td>
      </tr>
      <tr>
        <td id="L13456" data-line-number="13456"></td>
        <td id="LC13456">                             pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>IsGenericHijacked</span>());</td>
      </tr>
      <tr>
        <td id="L13457" data-line-number="13457"></td>
        <td id="LC13457">
</td>
      </tr>
      <tr>
        <td id="L13458" data-line-number="13458"></td>
        <td id="LC13458">    BOOL eventIsIB = (pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>HasIBEvent</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L13459" data-line-number="13459"></td>
        <td id="LC13459">                      pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>IBEvent</span>() == pUnmanagedEvent);</td>
      </tr>
      <tr>
        <td id="L13460" data-line-number="13460"></td>
        <td id="LC13460">
</td>
      </tr>
      <tr>
        <td id="L13461" data-line-number="13461"></td>
        <td id="LC13461">    <span>_ASSERTE</span>((DWORD) pProcess-&gt;<span>m_id</span> == pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>dwProcessId</span>);</td>
      </tr>
      <tr>
        <td id="L13462" data-line-number="13462"></td>
        <td id="LC13462">    <span>_ASSERTE</span>(pProcess-&gt;<span>m_state</span> &amp; CordbProcess::PS_WIN32_STOPPED);</td>
      </tr>
      <tr>
        <td id="L13463" data-line-number="13463"></td>
        <td id="LC13463">
</td>
      </tr>
      <tr>
        <td id="L13464" data-line-number="13464"></td>
        <td id="LC13464">    DWORD dwContType;</td>
      </tr>
      <tr>
        <td id="L13465" data-line-number="13465"></td>
        <td id="LC13465">    <span>if</span>(eventIsIB)</td>
      </tr>
      <tr>
        <td id="L13466" data-line-number="13466"></td>
        <td id="LC13466">    {</td>
      </tr>
      <tr>
        <td id="L13467" data-line-number="13467"></td>
        <td id="LC13467">        <span><span>//</span> 3 cases here...</span></td>
      </tr>
      <tr>
        <td id="L13468" data-line-number="13468"></td>
        <td id="LC13468">        <span><span>//</span> event was already hijacked</span></td>
      </tr>
      <tr>
        <td id="L13469" data-line-number="13469"></td>
        <td id="LC13469">        <span>if</span>(threadIsHijacked)</td>
      </tr>
      <tr>
        <td id="L13470" data-line-number="13470"></td>
        <td id="LC13470">        {</td>
      </tr>
      <tr>
        <td id="L13471" data-line-number="13471"></td>
        <td id="LC13471">            <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::DDC: Continuing IB, already hijacked, ue=0x%p<span>\n</span><span>"</span></span>, pUnmanagedEvent));</td>
      </tr>
      <tr>
        <td id="L13472" data-line-number="13472"></td>
        <td id="LC13472">            pUnmanagedEvent-&gt;<span>SetState</span>(CUES_EventContinuedHijacked);</td>
      </tr>
      <tr>
        <td id="L13473" data-line-number="13473"></td>
        <td id="LC13473">            dwContType = !pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>IsBlockingForSync</span>() ? <span>GetDbgContinueFlag</span>() : DBG_EXCEPTION_NOT_HANDLED;</td>
      </tr>
      <tr>
        <td id="L13474" data-line-number="13474"></td>
        <td id="LC13474">        }</td>
      </tr>
      <tr>
        <td id="L13475" data-line-number="13475"></td>
        <td id="LC13475">        <span><span>//</span> event was not hijacked but has been dispatched</span></td>
      </tr>
      <tr>
        <td id="L13476" data-line-number="13476"></td>
        <td id="LC13476">        <span>else</span> <span>if</span>(!threadIsHijacked &amp;&amp; pUnmanagedEvent-&gt;<span>IsDispatched</span>())</td>
      </tr>
      <tr>
        <td id="L13477" data-line-number="13477"></td>
        <td id="LC13477">        {</td>
      </tr>
      <tr>
        <td id="L13478" data-line-number="13478"></td>
        <td id="LC13478">            <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::DDC: Continuing IB, not hijacked, ue=0x%p<span>\n</span><span>"</span></span>, pUnmanagedEvent));</td>
      </tr>
      <tr>
        <td id="L13479" data-line-number="13479"></td>
        <td id="LC13479">            <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsDispatched</span>());</td>
      </tr>
      <tr>
        <td id="L13480" data-line-number="13480"></td>
        <td id="LC13480">            <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsEventUserContinued</span>());</td>
      </tr>
      <tr>
        <td id="L13481" data-line-number="13481"></td>
        <td id="LC13481">            <span>_ASSERTE</span>(!pUnmanagedEvent-&gt;<span>IsEventContinuedUnhijacked</span>());</td>
      </tr>
      <tr>
        <td id="L13482" data-line-number="13482"></td>
        <td id="LC13482">            pUnmanagedEvent-&gt;<span>SetState</span>(CUES_EventContinuedUnhijacked);</td>
      </tr>
      <tr>
        <td id="L13483" data-line-number="13483"></td>
        <td id="LC13483">            dwContType = pUnmanagedEvent-&gt;<span>IsExceptionCleared</span>() ? <span>GetDbgContinueFlag</span>() : DBG_EXCEPTION_NOT_HANDLED;</td>
      </tr>
      <tr>
        <td id="L13484" data-line-number="13484"></td>
        <td id="LC13484">
</td>
      </tr>
      <tr>
        <td id="L13485" data-line-number="13485"></td>
        <td id="LC13485">            <span><span>//</span> The event was never hijacked and so will never need to retrigger, get rid</span></td>
      </tr>
      <tr>
        <td id="L13486" data-line-number="13486"></td>
        <td id="LC13486">            <span><span>//</span> of it right now. If it had been hijacked then we would dequeue it either after the</span></td>
      </tr>
      <tr>
        <td id="L13487" data-line-number="13487"></td>
        <td id="LC13487">            <span><span>//</span> hijack complete flare or one instruction after that when it has had a chance to retrigger</span></td>
      </tr>
      <tr>
        <td id="L13488" data-line-number="13488"></td>
        <td id="LC13488">            pProcess-&gt;<span>DequeueUnmanagedEvent</span>(pUnmanagedEvent-&gt;<span>m_owner</span>);</td>
      </tr>
      <tr>
        <td id="L13489" data-line-number="13489"></td>
        <td id="LC13489">        }</td>
      </tr>
      <tr>
        <td id="L13490" data-line-number="13490"></td>
        <td id="LC13490">        <span><span>//</span> event was not hijacked nor dispatched</span></td>
      </tr>
      <tr>
        <td id="L13491" data-line-number="13491"></td>
        <td id="LC13491">        <span>else</span> <span><span>//</span> if(!threadIsHijacked &amp;&amp; !pUnmanagedEvent-&gt;IsDispatched())</span></td>
      </tr>
      <tr>
        <td id="L13492" data-line-number="13492"></td>
        <td id="LC13492">        {</td>
      </tr>
      <tr>
        <td id="L13493" data-line-number="13493"></td>
        <td id="LC13493">            <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::DDC: Continuing IB, now hijacked, ue=0x%p<span>\n</span><span>"</span></span>, pUnmanagedEvent));</td>
      </tr>
      <tr>
        <td id="L13494" data-line-number="13494"></td>
        <td id="LC13494">            HRESULT hr = pProcess-&gt;<span>HijackIBEvent</span>(pUnmanagedEvent);</td>
      </tr>
      <tr>
        <td id="L13495" data-line-number="13495"></td>
        <td id="LC13495">            <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L13496" data-line-number="13496"></td>
        <td id="LC13496">            pUnmanagedEvent-&gt;<span>SetState</span>(CUES_EventContinuedHijacked);</td>
      </tr>
      <tr>
        <td id="L13497" data-line-number="13497"></td>
        <td id="LC13497">            dwContType = !pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>IsBlockingForSync</span>() ? <span>GetDbgContinueFlag</span>() : DBG_EXCEPTION_NOT_HANDLED;</td>
      </tr>
      <tr>
        <td id="L13498" data-line-number="13498"></td>
        <td id="LC13498">        }</td>
      </tr>
      <tr>
        <td id="L13499" data-line-number="13499"></td>
        <td id="LC13499">    }</td>
      </tr>
      <tr>
        <td id="L13500" data-line-number="13500"></td>
        <td id="LC13500">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L13501" data-line-number="13501"></td>
        <td id="LC13501">    {</td>
      </tr>
      <tr>
        <td id="L13502" data-line-number="13502"></td>
        <td id="LC13502">        <span>LOG</span>((LF_CORDB, LL_INFO100000, <span><span>"</span>W32ET::DDC: Continuing OB, ue=0x%p<span>\n</span><span>"</span></span>, pUnmanagedEvent));</td>
      </tr>
      <tr>
        <td id="L13503" data-line-number="13503"></td>
        <td id="LC13503">        <span><span>//</span> we might actually be hijacked here, but if we are it should be for a previous IB event</span></td>
      </tr>
      <tr>
        <td id="L13504" data-line-number="13504"></td>
        <td id="LC13504">        <span><span>//</span> we just mark all OB events as continued unhijacked</span></td>
      </tr>
      <tr>
        <td id="L13505" data-line-number="13505"></td>
        <td id="LC13505">        pUnmanagedEvent-&gt;<span>SetState</span>(CUES_EventContinuedUnhijacked);</td>
      </tr>
      <tr>
        <td id="L13506" data-line-number="13506"></td>
        <td id="LC13506">        dwContType = pUnmanagedEvent-&gt;<span>IsExceptionCleared</span>() ? <span>GetDbgContinueFlag</span>() : DBG_EXCEPTION_NOT_HANDLED;</td>
      </tr>
      <tr>
        <td id="L13507" data-line-number="13507"></td>
        <td id="LC13507">    }</td>
      </tr>
      <tr>
        <td id="L13508" data-line-number="13508"></td>
        <td id="LC13508">
</td>
      </tr>
      <tr>
        <td id="L13509" data-line-number="13509"></td>
        <td id="LC13509">    <span><span>//</span> If the exception is marked as unclearable, then make sure the continue type is correct and force the process</span></td>
      </tr>
      <tr>
        <td id="L13510" data-line-number="13510"></td>
        <td id="LC13510">    <span><span>//</span> to terminate.</span></td>
      </tr>
      <tr>
        <td id="L13511" data-line-number="13511"></td>
        <td id="LC13511">    <span>if</span> (pUnmanagedEvent-&gt;<span>IsExceptionUnclearable</span>())</td>
      </tr>
      <tr>
        <td id="L13512" data-line-number="13512"></td>
        <td id="LC13512">    {</td>
      </tr>
      <tr>
        <td id="L13513" data-line-number="13513"></td>
        <td id="LC13513">        <span>TerminateProcess</span>(pProcess-&gt;<span>UnsafeGetProcessHandle</span>(), pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>.<span>ExceptionCode</span>);</td>
      </tr>
      <tr>
        <td id="L13514" data-line-number="13514"></td>
        <td id="LC13514">        dwContType = DBG_EXCEPTION_NOT_HANDLED;</td>
      </tr>
      <tr>
        <td id="L13515" data-line-number="13515"></td>
        <td id="LC13515">    }</td>
      </tr>
      <tr>
        <td id="L13516" data-line-number="13516"></td>
        <td id="LC13516">
</td>
      </tr>
      <tr>
        <td id="L13517" data-line-number="13517"></td>
        <td id="LC13517">    <span><span>//</span> If we're continuing from the loader-bp, then send the managed attach here.</span></td>
      </tr>
      <tr>
        <td id="L13518" data-line-number="13518"></td>
        <td id="LC13518">    <span><span>//</span> (Note this will only be set if the runtime was loaded when we first tried to attach).</span></td>
      </tr>
      <tr>
        <td id="L13519" data-line-number="13519"></td>
        <td id="LC13519">    <span><span>//</span> We assume that the loader-bp is the 1st BP exception. This is naive,</span></td>
      </tr>
      <tr>
        <td id="L13520" data-line-number="13520"></td>
        <td id="LC13520">    <span><span>//</span> since it's not 100% accurate (someone could CreateThread w/ a threadproc of DebugBreak).</span></td>
      </tr>
      <tr>
        <td id="L13521" data-line-number="13521"></td>
        <td id="LC13521">    <span><span>//</span> But it's the best we can do.</span></td>
      </tr>
      <tr>
        <td id="L13522" data-line-number="13522"></td>
        <td id="LC13522">    <span><span>//</span> Note that it's critical we do this BEFORE continuing the process.  If this is mixed-mode, we've already</span></td>
      </tr>
      <tr>
        <td id="L13523" data-line-number="13523"></td>
        <td id="LC13523">    <span><span>//</span> told VS about this breakpoint, and so it's set the attach-complete event.  As soon as we continue this debug</span></td>
      </tr>
      <tr>
        <td id="L13524" data-line-number="13524"></td>
        <td id="LC13524">    <span><span>//</span> event the process can start moving again, so the CLR needs to know to wait for a managed attach.</span></td>
      </tr>
      <tr>
        <td id="L13525" data-line-number="13525"></td>
        <td id="LC13525">    DWORD dwEventCode = pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>dwDebugEventCode</span>;</td>
      </tr>
      <tr>
        <td id="L13526" data-line-number="13526"></td>
        <td id="LC13526">    <span>if</span> (dwEventCode == EXCEPTION_DEBUG_EVENT)</td>
      </tr>
      <tr>
        <td id="L13527" data-line-number="13527"></td>
        <td id="LC13527">    {</td>
      </tr>
      <tr>
        <td id="L13528" data-line-number="13528"></td>
        <td id="LC13528">        EXCEPTION_DEBUG_INFO * pDebugInfo = &amp;pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>u</span>.<span>Exception</span>;</td>
      </tr>
      <tr>
        <td id="L13529" data-line-number="13529"></td>
        <td id="LC13529">        <span>if</span> (pDebugInfo-&gt;<span>dwFirstChance</span> &amp;&amp; pDebugInfo-&gt;<span>ExceptionRecord</span>.<span>ExceptionCode</span> == STATUS_BREAKPOINT)</td>
      </tr>
      <tr>
        <td id="L13530" data-line-number="13530"></td>
        <td id="LC13530">        {</td>
      </tr>
      <tr>
        <td id="L13531" data-line-number="13531"></td>
        <td id="LC13531">            HRESULT hrIgnore = S_OK;</td>
      </tr>
      <tr>
        <td id="L13532" data-line-number="13532"></td>
        <td id="LC13532">            EX_TRY</td>
      </tr>
      <tr>
        <td id="L13533" data-line-number="13533"></td>
        <td id="LC13533">            {</td>
      </tr>
      <tr>
        <td id="L13534" data-line-number="13534"></td>
        <td id="LC13534">                <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::DDC: Continuing from LdrBp, doing managed attach.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L13535" data-line-number="13535"></td>
        <td id="LC13535">                pProcess-&gt;<span>QueueManagedAttachIfNeededWorker</span>();</td>
      </tr>
      <tr>
        <td id="L13536" data-line-number="13536"></td>
        <td id="LC13536">            }</td>
      </tr>
      <tr>
        <td id="L13537" data-line-number="13537"></td>
        <td id="LC13537">            <span>EX_CATCH_HRESULT</span>(hrIgnore);</td>
      </tr>
      <tr>
        <td id="L13538" data-line-number="13538"></td>
        <td id="LC13538">            <span>SIMPLIFYING_ASSUMPTION</span>(<span>SUCCEEDED</span>(hrIgnore));</td>
      </tr>
      <tr>
        <td id="L13539" data-line-number="13539"></td>
        <td id="LC13539">        }</td>
      </tr>
      <tr>
        <td id="L13540" data-line-number="13540"></td>
        <td id="LC13540">    }</td>
      </tr>
      <tr>
        <td id="L13541" data-line-number="13541"></td>
        <td id="LC13541">
</td>
      </tr>
      <tr>
        <td id="L13542" data-line-number="13542"></td>
        <td id="LC13542">    <span>STRESS_LOG4</span>(LF_CORDB, LL_INFO1000,</td>
      </tr>
      <tr>
        <td id="L13543" data-line-number="13543"></td>
        <td id="LC13543">        <span><span>"</span>W32ET::DDC: calling ContinueDebugEvent(0x%x, 0x%x, 0x%x), process state=0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L13544" data-line-number="13544"></td>
        <td id="LC13544">        pProcess-&gt;<span>m_id</span>, pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>m_id</span>, dwContType, pProcess-&gt;<span>m_state</span>);</td>
      </tr>
      <tr>
        <td id="L13545" data-line-number="13545"></td>
        <td id="LC13545">
</td>
      </tr>
      <tr>
        <td id="L13546" data-line-number="13546"></td>
        <td id="LC13546">    <span><span>//</span> Actually continue the debug event</span></td>
      </tr>
      <tr>
        <td id="L13547" data-line-number="13547"></td>
        <td id="LC13547">    pProcess-&gt;<span>m_state</span> &amp;= ~CordbProcess::PS_WIN32_STOPPED;</td>
      </tr>
      <tr>
        <td id="L13548" data-line-number="13548"></td>
        <td id="LC13548">    BOOL <span>fSuccess</span> = m_pNativePipeline-&gt;<span>ContinueDebugEvent</span>((DWORD)pProcess-&gt;<span>m_id</span>, (DWORD)pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>m_id</span>, dwContType);</td>
      </tr>
      <tr>
        <td id="L13549" data-line-number="13549"></td>
        <td id="LC13549">
</td>
      </tr>
      <tr>
        <td id="L13550" data-line-number="13550"></td>
        <td id="LC13550">    <span><span>//</span> ContinueDebugEvent may 'fail' if we force kill the debuggee while stopped at the exit-process event.</span></td>
      </tr>
      <tr>
        <td id="L13551" data-line-number="13551"></td>
        <td id="LC13551">    <span>if</span> (!<span>fSuccess</span> &amp;&amp; (dwEventCode != EXIT_PROCESS_DEBUG_EVENT))</td>
      </tr>
      <tr>
        <td id="L13552" data-line-number="13552"></td>
        <td id="LC13552">    {</td>
      </tr>
      <tr>
        <td id="L13553" data-line-number="13553"></td>
        <td id="LC13553">        <span>_ASSERTE</span>(!<span><span>"</span>ContinueDebugEvent failed!<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L13554" data-line-number="13554"></td>
        <td id="LC13554">        <span>CORDBSetUnrecoverableError</span>(pProcess, <span>HRESULT_FROM_GetLastError</span>(), <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L13555" data-line-number="13555"></td>
        <td id="LC13555">        <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::DDC: Last error after ContinueDebugEvent is %d<span>\n</span><span>"</span></span>, <span>GetLastError</span>());</td>
      </tr>
      <tr>
        <td id="L13556" data-line-number="13556"></td>
        <td id="LC13556">    }</td>
      </tr>
      <tr>
        <td id="L13557" data-line-number="13557"></td>
        <td id="LC13557">
</td>
      </tr>
      <tr>
        <td id="L13558" data-line-number="13558"></td>
        <td id="LC13558">    <span><span>//</span> If this thread is marked for deletion (exit thread or exit process event on it), then we need to delete the</span></td>
      </tr>
      <tr>
        <td id="L13559" data-line-number="13559"></td>
        <td id="LC13559">    <span><span>//</span> unmanaged thread object.</span></td>
      </tr>
      <tr>
        <td id="L13560" data-line-number="13560"></td>
        <td id="LC13560">    <span>if</span> ((dwEventCode == EXIT_PROCESS_DEBUG_EVENT) || (dwEventCode == EXIT_THREAD_DEBUG_EVENT))</td>
      </tr>
      <tr>
        <td id="L13561" data-line-number="13561"></td>
        <td id="LC13561">    {</td>
      </tr>
      <tr>
        <td id="L13562" data-line-number="13562"></td>
        <td id="LC13562">        CordbUnmanagedThread * pUnmanagedThread = pUnmanagedEvent-&gt;<span>m_owner</span>;</td>
      </tr>
      <tr>
        <td id="L13563" data-line-number="13563"></td>
        <td id="LC13563">        <span>_ASSERTE</span>(pUnmanagedThread-&gt;<span>IsDeleted</span>());</td>
      </tr>
      <tr>
        <td id="L13564" data-line-number="13564"></td>
        <td id="LC13564">
</td>
      </tr>
      <tr>
        <td id="L13565" data-line-number="13565"></td>
        <td id="LC13565">
</td>
      </tr>
      <tr>
        <td id="L13566" data-line-number="13566"></td>
        <td id="LC13566">        <span><span>//</span> Thread may have a hijacked inband event on it. Thus it's actually running free from the OS perspective,</span></td>
      </tr>
      <tr>
        <td id="L13567" data-line-number="13567"></td>
        <td id="LC13567">        <span><span>//</span> and fair game to be terminated. In that case, we need to auto-dequeue the event.</span></td>
      </tr>
      <tr>
        <td id="L13568" data-line-number="13568"></td>
        <td id="LC13568">        <span><span>//</span> This will just prevent the RS from making the underlying call to ContinueDebugEvent on this thread</span></td>
      </tr>
      <tr>
        <td id="L13569" data-line-number="13569"></td>
        <td id="LC13569">        <span><span>//</span> for the inband event. Since we've already lost the thread, that's actually exactly what we want.</span></td>
      </tr>
      <tr>
        <td id="L13570" data-line-number="13570"></td>
        <td id="LC13570">        <span>if</span> (pUnmanagedThread-&gt;<span>HasIBEvent</span>())</td>
      </tr>
      <tr>
        <td id="L13571" data-line-number="13571"></td>
        <td id="LC13571">        {</td>
      </tr>
      <tr>
        <td id="L13572" data-line-number="13572"></td>
        <td id="LC13572">            pProcess-&gt;<span>DequeueUnmanagedEvent</span>(pUnmanagedThread);</td>
      </tr>
      <tr>
        <td id="L13573" data-line-number="13573"></td>
        <td id="LC13573">        }</td>
      </tr>
      <tr>
        <td id="L13574" data-line-number="13574"></td>
        <td id="LC13574">
</td>
      </tr>
      <tr>
        <td id="L13575" data-line-number="13575"></td>
        <td id="LC13575">        <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>Removing thread 0x%x (%d) from process list<span>\n</span><span>"</span></span>, pUnmanagedThread-&gt;<span>m_id</span>);</td>
      </tr>
      <tr>
        <td id="L13576" data-line-number="13576"></td>
        <td id="LC13576">        pProcess-&gt;<span>m_unmanagedThreads</span>.<span>RemoveBase</span>((ULONG_PTR)pUnmanagedThread-&gt;<span>m_id</span>);</td>
      </tr>
      <tr>
        <td id="L13577" data-line-number="13577"></td>
        <td id="LC13577">    }</td>
      </tr>
      <tr>
        <td id="L13578" data-line-number="13578"></td>
        <td id="LC13578">
</td>
      </tr>
      <tr>
        <td id="L13579" data-line-number="13579"></td>
        <td id="LC13579">
</td>
      </tr>
      <tr>
        <td id="L13580" data-line-number="13580"></td>
        <td id="LC13580">    <span><span>//</span> If we just continued from an exit process event, then its time to do the exit processing.</span></td>
      </tr>
      <tr>
        <td id="L13581" data-line-number="13581"></td>
        <td id="LC13581">    <span>if</span> (dwEventCode == EXIT_PROCESS_DEBUG_EVENT)</td>
      </tr>
      <tr>
        <td id="L13582" data-line-number="13582"></td>
        <td id="LC13582">    {</td>
      </tr>
      <tr>
        <td id="L13583" data-line-number="13583"></td>
        <td id="LC13583">        pProcess-&gt;<span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L13584" data-line-number="13584"></td>
        <td id="LC13584">        <span>ExitProcess</span>(<span>false</span>); <span><span>//</span> not detach case</span></td>
      </tr>
      <tr>
        <td id="L13585" data-line-number="13585"></td>
        <td id="LC13585">        pProcess-&gt;<span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L13586" data-line-number="13586"></td>
        <td id="LC13586">    }</td>
      </tr>
      <tr>
        <td id="L13587" data-line-number="13587"></td>
        <td id="LC13587">
</td>
      </tr>
      <tr>
        <td id="L13588" data-line-number="13588"></td>
        <td id="LC13588">}</td>
      </tr>
      <tr>
        <td id="L13589" data-line-number="13589"></td>
        <td id="LC13589">
</td>
      </tr>
      <tr>
        <td id="L13590" data-line-number="13590"></td>
        <td id="LC13590"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13591" data-line-number="13591"></td>
        <td id="LC13591"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13592" data-line-number="13592"></td>
        <td id="LC13592"><span><span>//</span> ForceDbgContinue continues from the last Win32 DEBUG_EVENT on the given thread, no matter what it was.</span></td>
      </tr>
      <tr>
        <td id="L13593" data-line-number="13593"></td>
        <td id="LC13593"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13594" data-line-number="13594"></td>
        <td id="LC13594"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L13595" data-line-number="13595"></td>
        <td id="LC13595"><span><span>//</span>      pProcess - process object to continue</span></td>
      </tr>
      <tr>
        <td id="L13596" data-line-number="13596"></td>
        <td id="LC13596"><span><span>//</span>      pUnmanagedThread - unmanaged thread object (maybe null if we're doing a raw cotninue)</span></td>
      </tr>
      <tr>
        <td id="L13597" data-line-number="13597"></td>
        <td id="LC13597"><span><span>//</span>      contType - continuation status (DBG_CONTINUE or DBG_EXCEPTION_NOT_HANDLED)</span></td>
      </tr>
      <tr>
        <td id="L13598" data-line-number="13598"></td>
        <td id="LC13598"><span><span>//</span>      fContinueProcess - do we resume hijacks?</span></td>
      </tr>
      <tr>
        <td id="L13599" data-line-number="13599"></td>
        <td id="LC13599"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13600" data-line-number="13600"></td>
        <td id="LC13600"><span>void</span> <span>CordbWin32EventThread::ForceDbgContinue</span>(CordbProcess *pProcess, CordbUnmanagedThread *pUnmanagedThread, DWORD contType,</td>
      </tr>
      <tr>
        <td id="L13601" data-line-number="13601"></td>
        <td id="LC13601">                                             <span>bool</span> <span>fContinueProcess</span>)</td>
      </tr>
      <tr>
        <td id="L13602" data-line-number="13602"></td>
        <td id="LC13602">{</td>
      </tr>
      <tr>
        <td id="L13603" data-line-number="13603"></td>
        <td id="LC13603">    <span>_ASSERTE</span>(pProcess-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L13604" data-line-number="13604"></td>
        <td id="LC13604">    <span>_ASSERTE</span>(pUnmanagedThread != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L13605" data-line-number="13605"></td>
        <td id="LC13605">    <span>STRESS_LOG4</span>(LF_CORDB, LL_INFO1000,</td>
      </tr>
      <tr>
        <td id="L13606" data-line-number="13606"></td>
        <td id="LC13606">         <span><span>"</span>W32ET::FDC: force continue with 0x%x (%s), contProcess=%d, tid=0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L13607" data-line-number="13607"></td>
        <td id="LC13607">         contType,</td>
      </tr>
      <tr>
        <td id="L13608" data-line-number="13608"></td>
        <td id="LC13608">         (contType == DBG_CONTINUE) ? <span><span>"</span>DBG_CONTINUE<span>"</span></span> : <span><span>"</span>DBG_EXCEPTION_NOT_HANDLED<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L13609" data-line-number="13609"></td>
        <td id="LC13609">         <span>fContinueProcess</span>,</td>
      </tr>
      <tr>
        <td id="L13610" data-line-number="13610"></td>
        <td id="LC13610">         pUnmanagedThread-&gt;<span>m_id</span>);</td>
      </tr>
      <tr>
        <td id="L13611" data-line-number="13611"></td>
        <td id="LC13611">
</td>
      </tr>
      <tr>
        <td id="L13612" data-line-number="13612"></td>
        <td id="LC13612">    <span>if</span> (<span>fContinueProcess</span>)</td>
      </tr>
      <tr>
        <td id="L13613" data-line-number="13613"></td>
        <td id="LC13613">    {</td>
      </tr>
      <tr>
        <td id="L13614" data-line-number="13614"></td>
        <td id="LC13614">        pProcess-&gt;<span>ResumeHijackedThreads</span>();</td>
      </tr>
      <tr>
        <td id="L13615" data-line-number="13615"></td>
        <td id="LC13615">    }</td>
      </tr>
      <tr>
        <td id="L13616" data-line-number="13616"></td>
        <td id="LC13616">
</td>
      </tr>
      <tr>
        <td id="L13617" data-line-number="13617"></td>
        <td id="LC13617">    <span>if</span> (contType == DBG_CONTINUE)</td>
      </tr>
      <tr>
        <td id="L13618" data-line-number="13618"></td>
        <td id="LC13618">    {</td>
      </tr>
      <tr>
        <td id="L13619" data-line-number="13619"></td>
        <td id="LC13619">        contType = <span>GetDbgContinueFlag</span>();</td>
      </tr>
      <tr>
        <td id="L13620" data-line-number="13620"></td>
        <td id="LC13620">    }</td>
      </tr>
      <tr>
        <td id="L13621" data-line-number="13621"></td>
        <td id="LC13621">
</td>
      </tr>
      <tr>
        <td id="L13622" data-line-number="13622"></td>
        <td id="LC13622">    <span>_ASSERTE</span>(pProcess-&gt;<span>m_state</span> &amp; CordbProcess::PS_WIN32_STOPPED);</td>
      </tr>
      <tr>
        <td id="L13623" data-line-number="13623"></td>
        <td id="LC13623">
</td>
      </tr>
      <tr>
        <td id="L13624" data-line-number="13624"></td>
        <td id="LC13624">    <span><span>//</span> Remove the Win32 stopped flag so long as the OOB event queue is empty. We're forcing a continue here, so by</span></td>
      </tr>
      <tr>
        <td id="L13625" data-line-number="13625"></td>
        <td id="LC13625">    <span><span>//</span> definition this should be the case...</span></td>
      </tr>
      <tr>
        <td id="L13626" data-line-number="13626"></td>
        <td id="LC13626">    <span>_ASSERTE</span>(pProcess-&gt;<span>m_outOfBandEventQueue</span> == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L13627" data-line-number="13627"></td>
        <td id="LC13627">
</td>
      </tr>
      <tr>
        <td id="L13628" data-line-number="13628"></td>
        <td id="LC13628">    pProcess-&gt;<span>m_state</span> &amp;= ~CordbProcess::PS_WIN32_STOPPED;</td>
      </tr>
      <tr>
        <td id="L13629" data-line-number="13629"></td>
        <td id="LC13629">
</td>
      </tr>
      <tr>
        <td id="L13630" data-line-number="13630"></td>
        <td id="LC13630">    <span>STRESS_LOG4</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::FDC: calling ContinueDebugEvent(0x%x, 0x%x, 0x%x), process state=0x%x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L13631" data-line-number="13631"></td>
        <td id="LC13631">         pProcess-&gt;<span>m_id</span>, pUnmanagedThread-&gt;<span>m_id</span>, contType, pProcess-&gt;<span>m_state</span>);</td>
      </tr>
      <tr>
        <td id="L13632" data-line-number="13632"></td>
        <td id="LC13632">
</td>
      </tr>
      <tr>
        <td id="L13633" data-line-number="13633"></td>
        <td id="LC13633">
</td>
      </tr>
      <tr>
        <td id="L13634" data-line-number="13634"></td>
        <td id="LC13634">    #<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L13635" data-line-number="13635"></td>
        <td id="LC13635">    <span>EnableDebugTrace</span>(pUnmanagedThread);</td>
      </tr>
      <tr>
        <td id="L13636" data-line-number="13636"></td>
        <td id="LC13636">    #<span>endif</span></td>
      </tr>
      <tr>
        <td id="L13637" data-line-number="13637"></td>
        <td id="LC13637">    BOOL ret = m_pNativePipeline-&gt;<span>ContinueDebugEvent</span>((DWORD)pProcess-&gt;<span>m_id</span>, (DWORD)pUnmanagedThread-&gt;<span>m_id</span>, contType);</td>
      </tr>
      <tr>
        <td id="L13638" data-line-number="13638"></td>
        <td id="LC13638">
</td>
      </tr>
      <tr>
        <td id="L13639" data-line-number="13639"></td>
        <td id="LC13639">    <span>if</span> (!ret)</td>
      </tr>
      <tr>
        <td id="L13640" data-line-number="13640"></td>
        <td id="LC13640">    {</td>
      </tr>
      <tr>
        <td id="L13641" data-line-number="13641"></td>
        <td id="LC13641">        <span><span>//</span> This could in theory fail from Process exit, but that really would only be on the DoDbgContinue path.</span></td>
      </tr>
      <tr>
        <td id="L13642" data-line-number="13642"></td>
        <td id="LC13642">         <span>_ASSERTE</span>(!<span><span>"</span>ContinueDebugEvent failed #2!<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L13643" data-line-number="13643"></td>
        <td id="LC13643">        <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::DDC: Last error after ContinueDebugEvent is %d<span>\n</span><span>"</span></span>, <span>GetLastError</span>());</td>
      </tr>
      <tr>
        <td id="L13644" data-line-number="13644"></td>
        <td id="LC13644">    }</td>
      </tr>
      <tr>
        <td id="L13645" data-line-number="13645"></td>
        <td id="LC13645">}</td>
      </tr>
      <tr>
        <td id="L13646" data-line-number="13646"></td>
        <td id="LC13646">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L13647" data-line-number="13647"></td>
        <td id="LC13647">
</td>
      </tr>
      <tr>
        <td id="L13648" data-line-number="13648"></td>
        <td id="LC13648"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13649" data-line-number="13649"></td>
        <td id="LC13649"><span><span>//</span> This is the thread's real thread proc. It simply calls to the</span></td>
      </tr>
      <tr>
        <td id="L13650" data-line-number="13650"></td>
        <td id="LC13650"><span><span>//</span> thread proc on the given object.</span></td>
      </tr>
      <tr>
        <td id="L13651" data-line-number="13651"></td>
        <td id="LC13651"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13652" data-line-number="13652"></td>
        <td id="LC13652"><span><span>/*</span>static<span>*/</span></span> DWORD WINAPI <span>CordbWin32EventThread::ThreadProc</span>(LPVOID parameter)</td>
      </tr>
      <tr>
        <td id="L13653" data-line-number="13653"></td>
        <td id="LC13653">{</td>
      </tr>
      <tr>
        <td id="L13654" data-line-number="13654"></td>
        <td id="LC13654">    CordbWin32EventThread* t = (CordbWin32EventThread*) parameter;</td>
      </tr>
      <tr>
        <td id="L13655" data-line-number="13655"></td>
        <td id="LC13655">    <span>INTERNAL_THREAD_ENTRY</span>(t);</td>
      </tr>
      <tr>
        <td id="L13656" data-line-number="13656"></td>
        <td id="LC13656">    t-&gt;<span>ThreadProc</span>();</td>
      </tr>
      <tr>
        <td id="L13657" data-line-number="13657"></td>
        <td id="LC13657">    <span>return</span> <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L13658" data-line-number="13658"></td>
        <td id="LC13658">}</td>
      </tr>
      <tr>
        <td id="L13659" data-line-number="13659"></td>
        <td id="LC13659">
</td>
      </tr>
      <tr>
        <td id="L13660" data-line-number="13660"></td>
        <td id="LC13660">
</td>
      </tr>
      <tr>
        <td id="L13661" data-line-number="13661"></td>
        <td id="LC13661"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13662" data-line-number="13662"></td>
        <td id="LC13662"><span><span>//</span> Send a CreateProcess event to the Win32 thread to have it create us</span></td>
      </tr>
      <tr>
        <td id="L13663" data-line-number="13663"></td>
        <td id="LC13663"><span><span>//</span> a new process.</span></td>
      </tr>
      <tr>
        <td id="L13664" data-line-number="13664"></td>
        <td id="LC13664"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13665" data-line-number="13665"></td>
        <td id="LC13665">HRESULT <span>CordbWin32EventThread::SendCreateProcessEvent</span>(</td>
      </tr>
      <tr>
        <td id="L13666" data-line-number="13666"></td>
        <td id="LC13666">                                  MachineInfo machineInfo,</td>
      </tr>
      <tr>
        <td id="L13667" data-line-number="13667"></td>
        <td id="LC13667">                                  LPCWSTR programName,</td>
      </tr>
      <tr>
        <td id="L13668" data-line-number="13668"></td>
        <td id="LC13668">                                  __in_z LPWSTR  programArgs,</td>
      </tr>
      <tr>
        <td id="L13669" data-line-number="13669"></td>
        <td id="LC13669">                                  LPSECURITY_ATTRIBUTES lpProcessAttributes,</td>
      </tr>
      <tr>
        <td id="L13670" data-line-number="13670"></td>
        <td id="LC13670">                                  LPSECURITY_ATTRIBUTES lpThreadAttributes,</td>
      </tr>
      <tr>
        <td id="L13671" data-line-number="13671"></td>
        <td id="LC13671">                                  BOOL bInheritHandles,</td>
      </tr>
      <tr>
        <td id="L13672" data-line-number="13672"></td>
        <td id="LC13672">                                  DWORD dwCreationFlags,</td>
      </tr>
      <tr>
        <td id="L13673" data-line-number="13673"></td>
        <td id="LC13673">                                  PVOID lpEnvironment,</td>
      </tr>
      <tr>
        <td id="L13674" data-line-number="13674"></td>
        <td id="LC13674">                                  LPCWSTR lpCurrentDirectory,</td>
      </tr>
      <tr>
        <td id="L13675" data-line-number="13675"></td>
        <td id="LC13675">                                  LPSTARTUPINFOW lpStartupInfo,</td>
      </tr>
      <tr>
        <td id="L13676" data-line-number="13676"></td>
        <td id="LC13676">                                  LPPROCESS_INFORMATION lpProcessInformation,</td>
      </tr>
      <tr>
        <td id="L13677" data-line-number="13677"></td>
        <td id="LC13677">                                  CorDebugCreateProcessFlags corDebugFlags)</td>
      </tr>
      <tr>
        <td id="L13678" data-line-number="13678"></td>
        <td id="LC13678">{</td>
      </tr>
      <tr>
        <td id="L13679" data-line-number="13679"></td>
        <td id="LC13679">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L13680" data-line-number="13680"></td>
        <td id="LC13680">
</td>
      </tr>
      <tr>
        <td id="L13681" data-line-number="13681"></td>
        <td id="LC13681">    <span>LockSendToWin32EventThreadMutex</span>();</td>
      </tr>
      <tr>
        <td id="L13682" data-line-number="13682"></td>
        <td id="LC13682">    <span>LOG</span>((LF_CORDB, LL_EVERYTHING, <span><span>"</span>CordbWin32EventThread::SCPE Called<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L13683" data-line-number="13683"></td>
        <td id="LC13683">    m_actionData.<span>createData</span>.<span>machineInfo</span> = machineInfo;</td>
      </tr>
      <tr>
        <td id="L13684" data-line-number="13684"></td>
        <td id="LC13684">    m_actionData.<span>createData</span>.<span>programName</span> = programName;</td>
      </tr>
      <tr>
        <td id="L13685" data-line-number="13685"></td>
        <td id="LC13685">    m_actionData.<span>createData</span>.<span>programArgs</span> = programArgs;</td>
      </tr>
      <tr>
        <td id="L13686" data-line-number="13686"></td>
        <td id="LC13686">    m_actionData.<span>createData</span>.<span>lpProcessAttributes</span> = lpProcessAttributes;</td>
      </tr>
      <tr>
        <td id="L13687" data-line-number="13687"></td>
        <td id="LC13687">    m_actionData.<span>createData</span>.<span>lpThreadAttributes</span> = lpThreadAttributes;</td>
      </tr>
      <tr>
        <td id="L13688" data-line-number="13688"></td>
        <td id="LC13688">    m_actionData.<span>createData</span>.<span>bInheritHandles</span> = bInheritHandles;</td>
      </tr>
      <tr>
        <td id="L13689" data-line-number="13689"></td>
        <td id="LC13689">    m_actionData.<span>createData</span>.<span>dwCreationFlags</span> = dwCreationFlags;</td>
      </tr>
      <tr>
        <td id="L13690" data-line-number="13690"></td>
        <td id="LC13690">    m_actionData.<span>createData</span>.<span>lpEnvironment</span> = lpEnvironment;</td>
      </tr>
      <tr>
        <td id="L13691" data-line-number="13691"></td>
        <td id="LC13691">    m_actionData.<span>createData</span>.<span>lpCurrentDirectory</span> = lpCurrentDirectory;</td>
      </tr>
      <tr>
        <td id="L13692" data-line-number="13692"></td>
        <td id="LC13692">    m_actionData.<span>createData</span>.<span>lpStartupInfo</span> = lpStartupInfo;</td>
      </tr>
      <tr>
        <td id="L13693" data-line-number="13693"></td>
        <td id="LC13693">    m_actionData.<span>createData</span>.<span>lpProcessInformation</span> = lpProcessInformation;</td>
      </tr>
      <tr>
        <td id="L13694" data-line-number="13694"></td>
        <td id="LC13694">    m_actionData.<span>createData</span>.<span>corDebugFlags</span> = corDebugFlags;</td>
      </tr>
      <tr>
        <td id="L13695" data-line-number="13695"></td>
        <td id="LC13695">
</td>
      </tr>
      <tr>
        <td id="L13696" data-line-number="13696"></td>
        <td id="LC13696">    <span><span>//</span> m_action is set last so that the win32 event thread can inspect</span></td>
      </tr>
      <tr>
        <td id="L13697" data-line-number="13697"></td>
        <td id="LC13697">    <span><span>//</span> it and take action without actually having to take any</span></td>
      </tr>
      <tr>
        <td id="L13698" data-line-number="13698"></td>
        <td id="LC13698">    <span><span>//</span> locks. The lock around this here is simply to prevent multiple</span></td>
      </tr>
      <tr>
        <td id="L13699" data-line-number="13699"></td>
        <td id="LC13699">    <span><span>//</span> threads from making requests at the same time.</span></td>
      </tr>
      <tr>
        <td id="L13700" data-line-number="13700"></td>
        <td id="LC13700">    m_action = W32ETA_CREATE_PROCESS;</td>
      </tr>
      <tr>
        <td id="L13701" data-line-number="13701"></td>
        <td id="LC13701">
</td>
      </tr>
      <tr>
        <td id="L13702" data-line-number="13702"></td>
        <td id="LC13702">    BOOL succ = <span>SetEvent</span>(m_threadControlEvent);</td>
      </tr>
      <tr>
        <td id="L13703" data-line-number="13703"></td>
        <td id="LC13703">
</td>
      </tr>
      <tr>
        <td id="L13704" data-line-number="13704"></td>
        <td id="LC13704">    <span>if</span> (succ)</td>
      </tr>
      <tr>
        <td id="L13705" data-line-number="13705"></td>
        <td id="LC13705">    {</td>
      </tr>
      <tr>
        <td id="L13706" data-line-number="13706"></td>
        <td id="LC13706">      DWORD ret = <span>WaitForSingleObject</span>(m_actionTakenEvent, INFINITE);</td>
      </tr>
      <tr>
        <td id="L13707" data-line-number="13707"></td>
        <td id="LC13707">
</td>
      </tr>
      <tr>
        <td id="L13708" data-line-number="13708"></td>
        <td id="LC13708">        <span>LOG</span>((LF_CORDB, LL_EVERYTHING, <span><span>"</span>Process Handle is: %x, m_threadControlEvent is %x<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L13709" data-line-number="13709"></td>
        <td id="LC13709">             (UINT_PTR)m_actionData.<span>createData</span>.<span>lpProcessInformation</span>-&gt;<span>hProcess</span>, (UINT_PTR)m_threadControlEvent));</td>
      </tr>
      <tr>
        <td id="L13710" data-line-number="13710"></td>
        <td id="LC13710">
</td>
      </tr>
      <tr>
        <td id="L13711" data-line-number="13711"></td>
        <td id="LC13711">        <span>if</span> (ret == WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L13712" data-line-number="13712"></td>
        <td id="LC13712">            hr = m_actionResult;</td>
      </tr>
      <tr>
        <td id="L13713" data-line-number="13713"></td>
        <td id="LC13713">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L13714" data-line-number="13714"></td>
        <td id="LC13714">            hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L13715" data-line-number="13715"></td>
        <td id="LC13715">    }</td>
      </tr>
      <tr>
        <td id="L13716" data-line-number="13716"></td>
        <td id="LC13716">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L13717" data-line-number="13717"></td>
        <td id="LC13717">        hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L13718" data-line-number="13718"></td>
        <td id="LC13718">
</td>
      </tr>
      <tr>
        <td id="L13719" data-line-number="13719"></td>
        <td id="LC13719">    <span>UnlockSendToWin32EventThreadMutex</span>();</td>
      </tr>
      <tr>
        <td id="L13720" data-line-number="13720"></td>
        <td id="LC13720">
</td>
      </tr>
      <tr>
        <td id="L13721" data-line-number="13721"></td>
        <td id="LC13721">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L13722" data-line-number="13722"></td>
        <td id="LC13722">}</td>
      </tr>
      <tr>
        <td id="L13723" data-line-number="13723"></td>
        <td id="LC13723">
</td>
      </tr>
      <tr>
        <td id="L13724" data-line-number="13724"></td>
        <td id="LC13724">
</td>
      </tr>
      <tr>
        <td id="L13725" data-line-number="13725"></td>
        <td id="LC13725"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13726" data-line-number="13726"></td>
        <td id="LC13726"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13727" data-line-number="13727"></td>
        <td id="LC13727"><span><span>//</span> Create a process</span></td>
      </tr>
      <tr>
        <td id="L13728" data-line-number="13728"></td>
        <td id="LC13728"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13729" data-line-number="13729"></td>
        <td id="LC13729"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L13730" data-line-number="13730"></td>
        <td id="LC13730"><span><span>//</span>    This occurs on the win32 event thread. It is invokved via</span></td>
      </tr>
      <tr>
        <td id="L13731" data-line-number="13731"></td>
        <td id="LC13731"><span><span>//</span>    a message sent from code:CordbWin32EventThread::SendCreateProcessEvent</span></td>
      </tr>
      <tr>
        <td id="L13732" data-line-number="13732"></td>
        <td id="LC13732"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13733" data-line-number="13733"></td>
        <td id="LC13733"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L13734" data-line-number="13734"></td>
        <td id="LC13734"><span><span>//</span>    Create a new process. This is called in the context of the Win32</span></td>
      </tr>
      <tr>
        <td id="L13735" data-line-number="13735"></td>
        <td id="LC13735"><span><span>//</span>    event thread to ensure that if we're Win32 debugging the process</span></td>
      </tr>
      <tr>
        <td id="L13736" data-line-number="13736"></td>
        <td id="LC13736"><span><span>//</span>    that the same thread that waits for debugging events will be the</span></td>
      </tr>
      <tr>
        <td id="L13737" data-line-number="13737"></td>
        <td id="LC13737"><span><span>//</span>    thread that creates the process.</span></td>
      </tr>
      <tr>
        <td id="L13738" data-line-number="13738"></td>
        <td id="LC13738"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13739" data-line-number="13739"></td>
        <td id="LC13739"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13740" data-line-number="13740"></td>
        <td id="LC13740"><span>void</span> <span>CordbWin32EventThread::CreateProcess</span>()</td>
      </tr>
      <tr>
        <td id="L13741" data-line-number="13741"></td>
        <td id="LC13741">{</td>
      </tr>
      <tr>
        <td id="L13742" data-line-number="13742"></td>
        <td id="LC13742">    m_action = W32ETA_NONE;</td>
      </tr>
      <tr>
        <td id="L13743" data-line-number="13743"></td>
        <td id="LC13743">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L13744" data-line-number="13744"></td>
        <td id="LC13744">
</td>
      </tr>
      <tr>
        <td id="L13745" data-line-number="13745"></td>
        <td id="LC13745">    DWORD dwCreationFlags = m_actionData.<span>createData</span>.<span>dwCreationFlags</span>;</td>
      </tr>
      <tr>
        <td id="L13746" data-line-number="13746"></td>
        <td id="LC13746">
</td>
      </tr>
      <tr>
        <td id="L13747" data-line-number="13747"></td>
        <td id="LC13747">    <span><span>//</span> If the creation flags has DEBUG_PROCESS in them, then we're</span></td>
      </tr>
      <tr>
        <td id="L13748" data-line-number="13748"></td>
        <td id="LC13748">    <span><span>//</span> Win32 debugging this process. Otherwise, we have to create</span></td>
      </tr>
      <tr>
        <td id="L13749" data-line-number="13749"></td>
        <td id="LC13749">    <span><span>//</span> suspended to give us time to setup up our side of the IPC</span></td>
      </tr>
      <tr>
        <td id="L13750" data-line-number="13750"></td>
        <td id="LC13750">    <span><span>//</span> channel.</span></td>
      </tr>
      <tr>
        <td id="L13751" data-line-number="13751"></td>
        <td id="LC13751">    BOOL <span>fInteropDebugging</span>   =</td>
      </tr>
      <tr>
        <td id="L13752" data-line-number="13752"></td>
        <td id="LC13752">#<span>if</span> defined(FEATURE_INTEROP_DEBUGGING)</td>
      </tr>
      <tr>
        <td id="L13753" data-line-number="13753"></td>
        <td id="LC13753">        (dwCreationFlags &amp; (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS));</td>
      </tr>
      <tr>
        <td id="L13754" data-line-number="13754"></td>
        <td id="LC13754">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L13755" data-line-number="13755"></td>
        <td id="LC13755">        <span>false</span>; <span><span>//</span> Interop not supported.</span></td>
      </tr>
      <tr>
        <td id="L13756" data-line-number="13756"></td>
        <td id="LC13756">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L13757" data-line-number="13757"></td>
        <td id="LC13757">
</td>
      </tr>
      <tr>
        <td id="L13758" data-line-number="13758"></td>
        <td id="LC13758">    <span><span>//</span> Have Win32 create the process...</span></td>
      </tr>
      <tr>
        <td id="L13759" data-line-number="13759"></td>
        <td id="LC13759">    hr = m_pNativePipeline-&gt;<span>CreateProcessUnderDebugger</span>(</td>
      </tr>
      <tr>
        <td id="L13760" data-line-number="13760"></td>
        <td id="LC13760">                                      m_actionData.<span>createData</span>.<span>machineInfo</span>,</td>
      </tr>
      <tr>
        <td id="L13761" data-line-number="13761"></td>
        <td id="LC13761">                                      m_actionData.<span>createData</span>.<span>programName</span>,</td>
      </tr>
      <tr>
        <td id="L13762" data-line-number="13762"></td>
        <td id="LC13762">                                      m_actionData.<span>createData</span>.<span>programArgs</span>,</td>
      </tr>
      <tr>
        <td id="L13763" data-line-number="13763"></td>
        <td id="LC13763">                                      m_actionData.<span>createData</span>.<span>lpProcessAttributes</span>,</td>
      </tr>
      <tr>
        <td id="L13764" data-line-number="13764"></td>
        <td id="LC13764">                                      m_actionData.<span>createData</span>.<span>lpThreadAttributes</span>,</td>
      </tr>
      <tr>
        <td id="L13765" data-line-number="13765"></td>
        <td id="LC13765">                                      m_actionData.<span>createData</span>.<span>bInheritHandles</span>,</td>
      </tr>
      <tr>
        <td id="L13766" data-line-number="13766"></td>
        <td id="LC13766">                                      dwCreationFlags,</td>
      </tr>
      <tr>
        <td id="L13767" data-line-number="13767"></td>
        <td id="LC13767">                                      m_actionData.<span>createData</span>.<span>lpEnvironment</span>,</td>
      </tr>
      <tr>
        <td id="L13768" data-line-number="13768"></td>
        <td id="LC13768">                                      m_actionData.<span>createData</span>.<span>lpCurrentDirectory</span>,</td>
      </tr>
      <tr>
        <td id="L13769" data-line-number="13769"></td>
        <td id="LC13769">                                      m_actionData.<span>createData</span>.<span>lpStartupInfo</span>,</td>
      </tr>
      <tr>
        <td id="L13770" data-line-number="13770"></td>
        <td id="LC13770">                                      m_actionData.<span>createData</span>.<span>lpProcessInformation</span>);</td>
      </tr>
      <tr>
        <td id="L13771" data-line-number="13771"></td>
        <td id="LC13771">
</td>
      </tr>
      <tr>
        <td id="L13772" data-line-number="13772"></td>
        <td id="LC13772">    <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L13773" data-line-number="13773"></td>
        <td id="LC13773">    {</td>
      </tr>
      <tr>
        <td id="L13774" data-line-number="13774"></td>
        <td id="LC13774">        <span><span>//</span> Process ID is filled in after process is succesfully created.</span></td>
      </tr>
      <tr>
        <td id="L13775" data-line-number="13775"></td>
        <td id="LC13775">        DWORD dwProcessId = m_actionData.<span>createData</span>.<span>lpProcessInformation</span>-&gt;<span>dwProcessId</span>;</td>
      </tr>
      <tr>
        <td id="L13776" data-line-number="13776"></td>
        <td id="LC13776">        ProcessDescriptor pd = <span>ProcessDescriptor::FromPid</span>(dwProcessId);</td>
      </tr>
      <tr>
        <td id="L13777" data-line-number="13777"></td>
        <td id="LC13777">
</td>
      </tr>
      <tr>
        <td id="L13778" data-line-number="13778"></td>
        <td id="LC13778">        RSUnsafeExternalSmartPtr&lt;CordbProcess&gt; pProcess;</td>
      </tr>
      <tr>
        <td id="L13779" data-line-number="13779"></td>
        <td id="LC13779">        hr = m_pShim-&gt;<span>InitializeDataTarget</span>(&amp;pd);</td>
      </tr>
      <tr>
        <td id="L13780" data-line-number="13780"></td>
        <td id="LC13780">
</td>
      </tr>
      <tr>
        <td id="L13781" data-line-number="13781"></td>
        <td id="LC13781">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L13782" data-line-number="13782"></td>
        <td id="LC13782">        {</td>
      </tr>
      <tr>
        <td id="L13783" data-line-number="13783"></td>
        <td id="LC13783">            <span><span>//</span> To emulate V2 semantics, we pass 0 for the clrInstanceID into</span></td>
      </tr>
      <tr>
        <td id="L13784" data-line-number="13784"></td>
        <td id="LC13784">            <span><span>//</span> OpenVirtualProcess. This will then connect to the first CLR</span></td>
      </tr>
      <tr>
        <td id="L13785" data-line-number="13785"></td>
        <td id="LC13785">            <span><span>//</span> loaded.</span></td>
      </tr>
      <tr>
        <td id="L13786" data-line-number="13786"></td>
        <td id="LC13786">            <span>const</span> ULONG64 cFirstClrLoaded = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L13787" data-line-number="13787"></td>
        <td id="LC13787">            hr = <span>CordbProcess::OpenVirtualProcess</span>(cFirstClrLoaded, m_pShim-&gt;<span>GetDataTarget</span>(), <span>NULL</span>, m_cordb, &amp;pd, m_pShim, &amp;pProcess);</td>
      </tr>
      <tr>
        <td id="L13788" data-line-number="13788"></td>
        <td id="LC13788">        }</td>
      </tr>
      <tr>
        <td id="L13789" data-line-number="13789"></td>
        <td id="LC13789">
</td>
      </tr>
      <tr>
        <td id="L13790" data-line-number="13790"></td>
        <td id="LC13790">        <span><span>//</span> Shouldn't happen on a create, only an attach</span></td>
      </tr>
      <tr>
        <td id="L13791" data-line-number="13791"></td>
        <td id="LC13791">        <span>_ASSERTE</span>(hr != CORDBG_E_DEBUGGER_ALREADY_ATTACHED);</td>
      </tr>
      <tr>
        <td id="L13792" data-line-number="13792"></td>
        <td id="LC13792">
</td>
      </tr>
      <tr>
        <td id="L13793" data-line-number="13793"></td>
        <td id="LC13793">        <span><span>//</span> Remember the process in the global list of processes.</span></td>
      </tr>
      <tr>
        <td id="L13794" data-line-number="13794"></td>
        <td id="LC13794">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L13795" data-line-number="13795"></td>
        <td id="LC13795">        {</td>
      </tr>
      <tr>
        <td id="L13796" data-line-number="13796"></td>
        <td id="LC13796">            EX_TRY</td>
      </tr>
      <tr>
        <td id="L13797" data-line-number="13797"></td>
        <td id="LC13797">            {</td>
      </tr>
      <tr>
        <td id="L13798" data-line-number="13798"></td>
        <td id="LC13798">                <span><span>//</span> Mark if we're interop-debugging</span></td>
      </tr>
      <tr>
        <td id="L13799" data-line-number="13799"></td>
        <td id="LC13799">                <span>if</span> (<span>fInteropDebugging</span>)</td>
      </tr>
      <tr>
        <td id="L13800" data-line-number="13800"></td>
        <td id="LC13800">                {</td>
      </tr>
      <tr>
        <td id="L13801" data-line-number="13801"></td>
        <td id="LC13801">                    pProcess-&gt;<span>EnableInteropDebugging</span>();</td>
      </tr>
      <tr>
        <td id="L13802" data-line-number="13802"></td>
        <td id="LC13802">                }</td>
      </tr>
      <tr>
        <td id="L13803" data-line-number="13803"></td>
        <td id="LC13803">
</td>
      </tr>
      <tr>
        <td id="L13804" data-line-number="13804"></td>
        <td id="LC13804">                m_cordb-&gt;<span>AddProcess</span>(pProcess); <span><span>//</span> will take ref if it succeeds</span></td>
      </tr>
      <tr>
        <td id="L13805" data-line-number="13805"></td>
        <td id="LC13805">            }</td>
      </tr>
      <tr>
        <td id="L13806" data-line-number="13806"></td>
        <td id="LC13806">            <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L13807" data-line-number="13807"></td>
        <td id="LC13807">        }</td>
      </tr>
      <tr>
        <td id="L13808" data-line-number="13808"></td>
        <td id="LC13808">
</td>
      </tr>
      <tr>
        <td id="L13809" data-line-number="13809"></td>
        <td id="LC13809">        <span><span>//</span> If we're Win32 attached to this process, then increment the</span></td>
      </tr>
      <tr>
        <td id="L13810" data-line-number="13810"></td>
        <td id="LC13810">        <span><span>//</span> proper count, otherwise add this process to the wait set</span></td>
      </tr>
      <tr>
        <td id="L13811" data-line-number="13811"></td>
        <td id="LC13811">        <span><span>//</span> and resume the process's main thread.</span></td>
      </tr>
      <tr>
        <td id="L13812" data-line-number="13812"></td>
        <td id="LC13812">        <span>if</span> (<span>SUCCEEDED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L13813" data-line-number="13813"></td>
        <td id="LC13813">        {</td>
      </tr>
      <tr>
        <td id="L13814" data-line-number="13814"></td>
        <td id="LC13814">            <span>_ASSERTE</span>(m_pProcess == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L13815" data-line-number="13815"></td>
        <td id="LC13815">            m_pProcess.<span>Assign</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L13816" data-line-number="13816"></td>
        <td id="LC13816">        }</td>
      </tr>
      <tr>
        <td id="L13817" data-line-number="13817"></td>
        <td id="LC13817">    }</td>
      </tr>
      <tr>
        <td id="L13818" data-line-number="13818"></td>
        <td id="LC13818">
</td>
      </tr>
      <tr>
        <td id="L13819" data-line-number="13819"></td>
        <td id="LC13819">
</td>
      </tr>
      <tr>
        <td id="L13820" data-line-number="13820"></td>
        <td id="LC13820">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13821" data-line-number="13821"></td>
        <td id="LC13821">    <span><span>//</span> Signal the hr to the caller.</span></td>
      </tr>
      <tr>
        <td id="L13822" data-line-number="13822"></td>
        <td id="LC13822">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13823" data-line-number="13823"></td>
        <td id="LC13823">    m_actionResult = hr;</td>
      </tr>
      <tr>
        <td id="L13824" data-line-number="13824"></td>
        <td id="LC13824">    <span>SetEvent</span>(m_actionTakenEvent);</td>
      </tr>
      <tr>
        <td id="L13825" data-line-number="13825"></td>
        <td id="LC13825">}</td>
      </tr>
      <tr>
        <td id="L13826" data-line-number="13826"></td>
        <td id="LC13826">
</td>
      </tr>
      <tr>
        <td id="L13827" data-line-number="13827"></td>
        <td id="LC13827">
</td>
      </tr>
      <tr>
        <td id="L13828" data-line-number="13828"></td>
        <td id="LC13828"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13829" data-line-number="13829"></td>
        <td id="LC13829"><span><span>//</span> Send a DebugActiveProcess event to the Win32 thread to have it attach to</span></td>
      </tr>
      <tr>
        <td id="L13830" data-line-number="13830"></td>
        <td id="LC13830"><span><span>//</span> a new process.</span></td>
      </tr>
      <tr>
        <td id="L13831" data-line-number="13831"></td>
        <td id="LC13831"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13832" data-line-number="13832"></td>
        <td id="LC13832">HRESULT <span>CordbWin32EventThread::SendDebugActiveProcessEvent</span>(</td>
      </tr>
      <tr>
        <td id="L13833" data-line-number="13833"></td>
        <td id="LC13833">                                                  MachineInfo machineInfo,</td>
      </tr>
      <tr>
        <td id="L13834" data-line-number="13834"></td>
        <td id="LC13834">                                                  <span>const</span> ProcessDescriptor *pProcessDescriptor,</td>
      </tr>
      <tr>
        <td id="L13835" data-line-number="13835"></td>
        <td id="LC13835">                                                  <span>bool</span> <span>fWin32Attach</span>,</td>
      </tr>
      <tr>
        <td id="L13836" data-line-number="13836"></td>
        <td id="LC13836">                                                  CordbProcess *pProcess)</td>
      </tr>
      <tr>
        <td id="L13837" data-line-number="13837"></td>
        <td id="LC13837">{</td>
      </tr>
      <tr>
        <td id="L13838" data-line-number="13838"></td>
        <td id="LC13838">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L13839" data-line-number="13839"></td>
        <td id="LC13839">
</td>
      </tr>
      <tr>
        <td id="L13840" data-line-number="13840"></td>
        <td id="LC13840">    <span>LockSendToWin32EventThreadMutex</span>();</td>
      </tr>
      <tr>
        <td id="L13841" data-line-number="13841"></td>
        <td id="LC13841">
</td>
      </tr>
      <tr>
        <td id="L13842" data-line-number="13842"></td>
        <td id="LC13842">    m_actionData.<span>attachData</span>.<span>machineInfo</span> = machineInfo;</td>
      </tr>
      <tr>
        <td id="L13843" data-line-number="13843"></td>
        <td id="LC13843">    m_actionData.<span>attachData</span>.<span>processDescriptor</span> = *pProcessDescriptor;</td>
      </tr>
      <tr>
        <td id="L13844" data-line-number="13844"></td>
        <td id="LC13844">#<span>if</span> !defined(FEATURE_DBGIPC_TRANSPORT_DI)</td>
      </tr>
      <tr>
        <td id="L13845" data-line-number="13845"></td>
        <td id="LC13845">    m_actionData.<span>attachData</span>.<span>fWin32Attach</span> = <span>fWin32Attach</span>;</td>
      </tr>
      <tr>
        <td id="L13846" data-line-number="13846"></td>
        <td id="LC13846">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L13847" data-line-number="13847"></td>
        <td id="LC13847">    m_actionData.<span>attachData</span>.<span>pProcess</span> = pProcess;</td>
      </tr>
      <tr>
        <td id="L13848" data-line-number="13848"></td>
        <td id="LC13848">
</td>
      </tr>
      <tr>
        <td id="L13849" data-line-number="13849"></td>
        <td id="LC13849">    <span><span>//</span> m_action is set last so that the win32 event thread can inspect</span></td>
      </tr>
      <tr>
        <td id="L13850" data-line-number="13850"></td>
        <td id="LC13850">    <span><span>//</span> it and take action without actually having to take any</span></td>
      </tr>
      <tr>
        <td id="L13851" data-line-number="13851"></td>
        <td id="LC13851">    <span><span>//</span> locks. The lock around this here is simply to prevent multiple</span></td>
      </tr>
      <tr>
        <td id="L13852" data-line-number="13852"></td>
        <td id="LC13852">    <span><span>//</span> threads from making requests at the same time.</span></td>
      </tr>
      <tr>
        <td id="L13853" data-line-number="13853"></td>
        <td id="LC13853">    m_action = W32ETA_ATTACH_PROCESS;</td>
      </tr>
      <tr>
        <td id="L13854" data-line-number="13854"></td>
        <td id="LC13854">
</td>
      </tr>
      <tr>
        <td id="L13855" data-line-number="13855"></td>
        <td id="LC13855">    BOOL succ = <span>SetEvent</span>(m_threadControlEvent);</td>
      </tr>
      <tr>
        <td id="L13856" data-line-number="13856"></td>
        <td id="LC13856">
</td>
      </tr>
      <tr>
        <td id="L13857" data-line-number="13857"></td>
        <td id="LC13857">    <span>if</span> (succ)</td>
      </tr>
      <tr>
        <td id="L13858" data-line-number="13858"></td>
        <td id="LC13858">    {</td>
      </tr>
      <tr>
        <td id="L13859" data-line-number="13859"></td>
        <td id="LC13859">        DWORD ret = <span>WaitForSingleObject</span>(m_actionTakenEvent, INFINITE);</td>
      </tr>
      <tr>
        <td id="L13860" data-line-number="13860"></td>
        <td id="LC13860">
</td>
      </tr>
      <tr>
        <td id="L13861" data-line-number="13861"></td>
        <td id="LC13861">        <span>if</span> (ret == WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L13862" data-line-number="13862"></td>
        <td id="LC13862">            hr = m_actionResult;</td>
      </tr>
      <tr>
        <td id="L13863" data-line-number="13863"></td>
        <td id="LC13863">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L13864" data-line-number="13864"></td>
        <td id="LC13864">            hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L13865" data-line-number="13865"></td>
        <td id="LC13865">    }</td>
      </tr>
      <tr>
        <td id="L13866" data-line-number="13866"></td>
        <td id="LC13866">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L13867" data-line-number="13867"></td>
        <td id="LC13867">        hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L13868" data-line-number="13868"></td>
        <td id="LC13868">
</td>
      </tr>
      <tr>
        <td id="L13869" data-line-number="13869"></td>
        <td id="LC13869">    <span>UnlockSendToWin32EventThreadMutex</span>();</td>
      </tr>
      <tr>
        <td id="L13870" data-line-number="13870"></td>
        <td id="LC13870">
</td>
      </tr>
      <tr>
        <td id="L13871" data-line-number="13871"></td>
        <td id="LC13871">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L13872" data-line-number="13872"></td>
        <td id="LC13872">}</td>
      </tr>
      <tr>
        <td id="L13873" data-line-number="13873"></td>
        <td id="LC13873">
</td>
      </tr>
      <tr>
        <td id="L13874" data-line-number="13874"></td>
        <td id="LC13874"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13875" data-line-number="13875"></td>
        <td id="LC13875"><span><span>//</span> Is the given thread id a helper thread (real or worker?)</span></td>
      </tr>
      <tr>
        <td id="L13876" data-line-number="13876"></td>
        <td id="LC13876"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13877" data-line-number="13877"></td>
        <td id="LC13877"><span>bool</span> <span>CordbProcess::IsHelperThreadWorked</span>(DWORD tid)</td>
      </tr>
      <tr>
        <td id="L13878" data-line-number="13878"></td>
        <td id="LC13878">{</td>
      </tr>
      <tr>
        <td id="L13879" data-line-number="13879"></td>
        <td id="LC13879">    <span><span>//</span> Check against the id gained by sniffing Thread-Create events.</span></td>
      </tr>
      <tr>
        <td id="L13880" data-line-number="13880"></td>
        <td id="LC13880">    <span>if</span> (tid == <span>this</span>-&gt;<span>m_helperThreadId</span>)</td>
      </tr>
      <tr>
        <td id="L13881" data-line-number="13881"></td>
        <td id="LC13881">    {</td>
      </tr>
      <tr>
        <td id="L13882" data-line-number="13882"></td>
        <td id="LC13882">        <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L13883" data-line-number="13883"></td>
        <td id="LC13883">    }</td>
      </tr>
      <tr>
        <td id="L13884" data-line-number="13884"></td>
        <td id="LC13884">
</td>
      </tr>
      <tr>
        <td id="L13885" data-line-number="13885"></td>
        <td id="LC13885">    <span><span>//</span> Now check for potential datate in the IPC block. If not there,</span></td>
      </tr>
      <tr>
        <td id="L13886" data-line-number="13886"></td>
        <td id="LC13886">    <span><span>//</span> then we know it can't be the helper.</span></td>
      </tr>
      <tr>
        <td id="L13887" data-line-number="13887"></td>
        <td id="LC13887">    DebuggerIPCControlBlock * pDCB = <span>this</span>-&gt;<span>GetDCB</span>();</td>
      </tr>
      <tr>
        <td id="L13888" data-line-number="13888"></td>
        <td id="LC13888">
</td>
      </tr>
      <tr>
        <td id="L13889" data-line-number="13889"></td>
        <td id="LC13889">    <span>if</span> (pDCB == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L13890" data-line-number="13890"></td>
        <td id="LC13890">    {</td>
      </tr>
      <tr>
        <td id="L13891" data-line-number="13891"></td>
        <td id="LC13891">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L13892" data-line-number="13892"></td>
        <td id="LC13892">    }</td>
      </tr>
      <tr>
        <td id="L13893" data-line-number="13893"></td>
        <td id="LC13893">
</td>
      </tr>
      <tr>
        <td id="L13894" data-line-number="13894"></td>
        <td id="LC13894">    <span><span>//</span> get the latest information from the LS DCB</span></td>
      </tr>
      <tr>
        <td id="L13895" data-line-number="13895"></td>
        <td id="LC13895">    <span>UpdateRightSideDCB</span>();</td>
      </tr>
      <tr>
        <td id="L13896" data-line-number="13896"></td>
        <td id="LC13896">    <span>return</span></td>
      </tr>
      <tr>
        <td id="L13897" data-line-number="13897"></td>
        <td id="LC13897">        (tid == pDCB-&gt;<span>m_realHelperThreadId</span>) ||</td>
      </tr>
      <tr>
        <td id="L13898" data-line-number="13898"></td>
        <td id="LC13898">        (tid == pDCB-&gt;<span>m_temporaryHelperThreadId</span>);</td>
      </tr>
      <tr>
        <td id="L13899" data-line-number="13899"></td>
        <td id="LC13899">
</td>
      </tr>
      <tr>
        <td id="L13900" data-line-number="13900"></td>
        <td id="LC13900">}</td>
      </tr>
      <tr>
        <td id="L13901" data-line-number="13901"></td>
        <td id="LC13901">
</td>
      </tr>
      <tr>
        <td id="L13902" data-line-number="13902"></td>
        <td id="LC13902"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13903" data-line-number="13903"></td>
        <td id="LC13903"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13904" data-line-number="13904"></td>
        <td id="LC13904"><span><span>//</span> Cleans up the Left Side's DCB after a failed attach attempt.</span></td>
      </tr>
      <tr>
        <td id="L13905" data-line-number="13905"></td>
        <td id="LC13905"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13906" data-line-number="13906"></td>
        <td id="LC13906"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L13907" data-line-number="13907"></td>
        <td id="LC13907"><span><span>//</span>    Called when the left-site failed initialization</span></td>
      </tr>
      <tr>
        <td id="L13908" data-line-number="13908"></td>
        <td id="LC13908"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13909" data-line-number="13909"></td>
        <td id="LC13909"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L13910" data-line-number="13910"></td>
        <td id="LC13910"><span><span>//</span>    This can be called multiple times.</span></td>
      </tr>
      <tr>
        <td id="L13911" data-line-number="13911"></td>
        <td id="LC13911"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13912" data-line-number="13912"></td>
        <td id="LC13912"><span>void</span> <span>CordbProcess::CleanupHalfBakedLeftSide</span>()</td>
      </tr>
      <tr>
        <td id="L13913" data-line-number="13913"></td>
        <td id="LC13913">{</td>
      </tr>
      <tr>
        <td id="L13914" data-line-number="13914"></td>
        <td id="LC13914">    <span>if</span> (<span>GetDCB</span>() != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L13915" data-line-number="13915"></td>
        <td id="LC13915">    {</td>
      </tr>
      <tr>
        <td id="L13916" data-line-number="13916"></td>
        <td id="LC13916">        EX_TRY</td>
      </tr>
      <tr>
        <td id="L13917" data-line-number="13917"></td>
        <td id="LC13917">        {</td>
      </tr>
      <tr>
        <td id="L13918" data-line-number="13918"></td>
        <td id="LC13918">            <span>GetDCB</span>()-&gt;<span>m_rightSideIsWin32Debugger</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L13919" data-line-number="13919"></td>
        <td id="LC13919">            <span>UpdateLeftSideDCBField</span>(&amp;(<span>GetDCB</span>()-&gt;<span>m_rightSideIsWin32Debugger</span>), <span>sizeof</span>(<span>GetDCB</span>()-&gt;<span>m_rightSideIsWin32Debugger</span>));</td>
      </tr>
      <tr>
        <td id="L13920" data-line-number="13920"></td>
        <td id="LC13920">
</td>
      </tr>
      <tr>
        <td id="L13921" data-line-number="13921"></td>
        <td id="LC13921">            <span>if</span> (m_pEventChannel != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L13922" data-line-number="13922"></td>
        <td id="LC13922">            {</td>
      </tr>
      <tr>
        <td id="L13923" data-line-number="13923"></td>
        <td id="LC13923">                m_pEventChannel-&gt;<span>Delete</span>();</td>
      </tr>
      <tr>
        <td id="L13924" data-line-number="13924"></td>
        <td id="LC13924">                m_pEventChannel = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L13925" data-line-number="13925"></td>
        <td id="LC13925">            }</td>
      </tr>
      <tr>
        <td id="L13926" data-line-number="13926"></td>
        <td id="LC13926">        }</td>
      </tr>
      <tr>
        <td id="L13927" data-line-number="13927"></td>
        <td id="LC13927">        EX_CATCH</td>
      </tr>
      <tr>
        <td id="L13928" data-line-number="13928"></td>
        <td id="LC13928">        {</td>
      </tr>
      <tr>
        <td id="L13929" data-line-number="13929"></td>
        <td id="LC13929">            <span>_ASSERTE</span>(!<span><span>"</span>Writing process memory failed, perhaps due to an unexpected disconnection from the target.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L13930" data-line-number="13930"></td>
        <td id="LC13930">        }</td>
      </tr>
      <tr>
        <td id="L13931" data-line-number="13931"></td>
        <td id="LC13931">        <span>EX_END_CATCH</span>(SwallowAllExceptions);</td>
      </tr>
      <tr>
        <td id="L13932" data-line-number="13932"></td>
        <td id="LC13932">    }</td>
      </tr>
      <tr>
        <td id="L13933" data-line-number="13933"></td>
        <td id="LC13933">
</td>
      </tr>
      <tr>
        <td id="L13934" data-line-number="13934"></td>
        <td id="LC13934">    <span><span>//</span> Close and null out the various handles and events, including our process handle m_handle.</span></td>
      </tr>
      <tr>
        <td id="L13935" data-line-number="13935"></td>
        <td id="LC13935">    <span>CloseIPCHandles</span>();</td>
      </tr>
      <tr>
        <td id="L13936" data-line-number="13936"></td>
        <td id="LC13936">
</td>
      </tr>
      <tr>
        <td id="L13937" data-line-number="13937"></td>
        <td id="LC13937">    m_cordb.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L13938" data-line-number="13938"></td>
        <td id="LC13938">
</td>
      </tr>
      <tr>
        <td id="L13939" data-line-number="13939"></td>
        <td id="LC13939">    <span><span>//</span> This process object is Dead-On-Arrival, so it doesn't really have anything to neuter.</span></td>
      </tr>
      <tr>
        <td id="L13940" data-line-number="13940"></td>
        <td id="LC13940">    <span><span>//</span> But for safekeeping, we'll mark it as neutered.</span></td>
      </tr>
      <tr>
        <td id="L13941" data-line-number="13941"></td>
        <td id="LC13941">    <span>UnsafeNeuterDeadObject</span>();</td>
      </tr>
      <tr>
        <td id="L13942" data-line-number="13942"></td>
        <td id="LC13942">}</td>
      </tr>
      <tr>
        <td id="L13943" data-line-number="13943"></td>
        <td id="LC13943">
</td>
      </tr>
      <tr>
        <td id="L13944" data-line-number="13944"></td>
        <td id="LC13944">
</td>
      </tr>
      <tr>
        <td id="L13945" data-line-number="13945"></td>
        <td id="LC13945"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13946" data-line-number="13946"></td>
        <td id="LC13946"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13947" data-line-number="13947"></td>
        <td id="LC13947"><span><span>//</span> Attach to an existing process.</span></td>
      </tr>
      <tr>
        <td id="L13948" data-line-number="13948"></td>
        <td id="LC13948"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13949" data-line-number="13949"></td>
        <td id="LC13949"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13950" data-line-number="13950"></td>
        <td id="LC13950"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L13951" data-line-number="13951"></td>
        <td id="LC13951"><span><span>//</span>    Called on W32Event Thread, in response to event sent by</span></td>
      </tr>
      <tr>
        <td id="L13952" data-line-number="13952"></td>
        <td id="LC13952"><span><span>//</span>    code:CordbWin32EventThread::SendDebugActiveProcessEvent</span></td>
      </tr>
      <tr>
        <td id="L13953" data-line-number="13953"></td>
        <td id="LC13953"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13954" data-line-number="13954"></td>
        <td id="LC13954"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L13955" data-line-number="13955"></td>
        <td id="LC13955"><span><span>//</span>    Attach to a process. This is called in the context of the Win32</span></td>
      </tr>
      <tr>
        <td id="L13956" data-line-number="13956"></td>
        <td id="LC13956"><span><span>//</span>    event thread to ensure that if we're Win32 debugging the process</span></td>
      </tr>
      <tr>
        <td id="L13957" data-line-number="13957"></td>
        <td id="LC13957"><span><span>//</span>    that the same thread that waits for debugging events will be the</span></td>
      </tr>
      <tr>
        <td id="L13958" data-line-number="13958"></td>
        <td id="LC13958"><span><span>//</span>    thread that attaches the process.</span></td>
      </tr>
      <tr>
        <td id="L13959" data-line-number="13959"></td>
        <td id="LC13959"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L13960" data-line-number="13960"></td>
        <td id="LC13960"><span><span>//</span>    @dbgtodo shim: this will be part of the shim</span></td>
      </tr>
      <tr>
        <td id="L13961" data-line-number="13961"></td>
        <td id="LC13961"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L13962" data-line-number="13962"></td>
        <td id="LC13962"><span>void</span> <span>CordbWin32EventThread::AttachProcess</span>()</td>
      </tr>
      <tr>
        <td id="L13963" data-line-number="13963"></td>
        <td id="LC13963">{</td>
      </tr>
      <tr>
        <td id="L13964" data-line-number="13964"></td>
        <td id="LC13964">    <span>_ASSERTE</span>(<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L13965" data-line-number="13965"></td>
        <td id="LC13965">
</td>
      </tr>
      <tr>
        <td id="L13966" data-line-number="13966"></td>
        <td id="LC13966">    RSUnsafeExternalSmartPtr&lt;CordbProcess&gt; pProcess;</td>
      </tr>
      <tr>
        <td id="L13967" data-line-number="13967"></td>
        <td id="LC13967">
</td>
      </tr>
      <tr>
        <td id="L13968" data-line-number="13968"></td>
        <td id="LC13968">    m_action = W32ETA_NONE;</td>
      </tr>
      <tr>
        <td id="L13969" data-line-number="13969"></td>
        <td id="LC13969">
</td>
      </tr>
      <tr>
        <td id="L13970" data-line-number="13970"></td>
        <td id="LC13970">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L13971" data-line-number="13971"></td>
        <td id="LC13971">
</td>
      </tr>
      <tr>
        <td id="L13972" data-line-number="13972"></td>
        <td id="LC13972">    ProcessDescriptor processDescriptor = m_actionData.<span>attachData</span>.<span>processDescriptor</span>;</td>
      </tr>
      <tr>
        <td id="L13973" data-line-number="13973"></td>
        <td id="LC13973">    <span>bool</span> <span>fNativeAttachSucceeded</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L13974" data-line-number="13974"></td>
        <td id="LC13974">
</td>
      </tr>
      <tr>
        <td id="L13975" data-line-number="13975"></td>
        <td id="LC13975">    <span><span>//</span> Always do OS attach to the target.</span></td>
      </tr>
      <tr>
        <td id="L13976" data-line-number="13976"></td>
        <td id="LC13976">    <span><span>//</span> By this point, the pid should be valid (because OpenProcess above), pending some race where the process just exited.</span></td>
      </tr>
      <tr>
        <td id="L13977" data-line-number="13977"></td>
        <td id="LC13977">    <span><span>//</span> The OS will enforce that only 1 debugger is attached.</span></td>
      </tr>
      <tr>
        <td id="L13978" data-line-number="13978"></td>
        <td id="LC13978">    <span><span>//</span> Common failure paths here would be: access denied, double-attach</span></td>
      </tr>
      <tr>
        <td id="L13979" data-line-number="13979"></td>
        <td id="LC13979">    {</td>
      </tr>
      <tr>
        <td id="L13980" data-line-number="13980"></td>
        <td id="LC13980">        hr = m_pNativePipeline-&gt;<span>DebugActiveProcess</span>(m_actionData.<span>attachData</span>.<span>machineInfo</span>,</td>
      </tr>
      <tr>
        <td id="L13981" data-line-number="13981"></td>
        <td id="LC13981">                                                   processDescriptor);</td>
      </tr>
      <tr>
        <td id="L13982" data-line-number="13982"></td>
        <td id="LC13982">        <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L13983" data-line-number="13983"></td>
        <td id="LC13983">        {</td>
      </tr>
      <tr>
        <td id="L13984" data-line-number="13984"></td>
        <td id="LC13984">            <span>goto</span> LExit;</td>
      </tr>
      <tr>
        <td id="L13985" data-line-number="13985"></td>
        <td id="LC13985">        }</td>
      </tr>
      <tr>
        <td id="L13986" data-line-number="13986"></td>
        <td id="LC13986">        <span>fNativeAttachSucceeded</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L13987" data-line-number="13987"></td>
        <td id="LC13987">    }</td>
      </tr>
      <tr>
        <td id="L13988" data-line-number="13988"></td>
        <td id="LC13988">
</td>
      </tr>
      <tr>
        <td id="L13989" data-line-number="13989"></td>
        <td id="LC13989">
</td>
      </tr>
      <tr>
        <td id="L13990" data-line-number="13990"></td>
        <td id="LC13990">    hr = m_pShim-&gt;<span>InitializeDataTarget</span>(&amp;processDescriptor);</td>
      </tr>
      <tr>
        <td id="L13991" data-line-number="13991"></td>
        <td id="LC13991">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L13992" data-line-number="13992"></td>
        <td id="LC13992">    {</td>
      </tr>
      <tr>
        <td id="L13993" data-line-number="13993"></td>
        <td id="LC13993">        <span>goto</span> LExit;</td>
      </tr>
      <tr>
        <td id="L13994" data-line-number="13994"></td>
        <td id="LC13994">    }</td>
      </tr>
      <tr>
        <td id="L13995" data-line-number="13995"></td>
        <td id="LC13995">
</td>
      </tr>
      <tr>
        <td id="L13996" data-line-number="13996"></td>
        <td id="LC13996">    <span><span>//</span> To emulate V2 semantics, we pass 0 for the clrInstanceID into</span></td>
      </tr>
      <tr>
        <td id="L13997" data-line-number="13997"></td>
        <td id="LC13997">    <span><span>//</span> OpenVirtualProcess. This will then connect to the first CLR</span></td>
      </tr>
      <tr>
        <td id="L13998" data-line-number="13998"></td>
        <td id="LC13998">    <span><span>//</span> loaded.</span></td>
      </tr>
      <tr>
        <td id="L13999" data-line-number="13999"></td>
        <td id="LC13999">    {</td>
      </tr>
      <tr>
        <td id="L14000" data-line-number="14000"></td>
        <td id="LC14000">        <span>const</span> ULONG64 cFirstClrLoaded = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L14001" data-line-number="14001"></td>
        <td id="LC14001">        hr = <span>CordbProcess::OpenVirtualProcess</span>(cFirstClrLoaded, m_pShim-&gt;<span>GetDataTarget</span>(), <span>NULL</span>, m_cordb, &amp;processDescriptor, m_pShim, &amp;pProcess);</td>
      </tr>
      <tr>
        <td id="L14002" data-line-number="14002"></td>
        <td id="LC14002">        <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L14003" data-line-number="14003"></td>
        <td id="LC14003">        {</td>
      </tr>
      <tr>
        <td id="L14004" data-line-number="14004"></td>
        <td id="LC14004">            <span>goto</span> LExit;</td>
      </tr>
      <tr>
        <td id="L14005" data-line-number="14005"></td>
        <td id="LC14005">        }</td>
      </tr>
      <tr>
        <td id="L14006" data-line-number="14006"></td>
        <td id="LC14006">    }</td>
      </tr>
      <tr>
        <td id="L14007" data-line-number="14007"></td>
        <td id="LC14007">
</td>
      </tr>
      <tr>
        <td id="L14008" data-line-number="14008"></td>
        <td id="LC14008">    <span><span>//</span> Remember the process in the global list of processes.</span></td>
      </tr>
      <tr>
        <td id="L14009" data-line-number="14009"></td>
        <td id="LC14009">    <span><span>//</span> The caller back in code:Cordb::DebugActiveProcess will then get this by fetching it from the list.</span></td>
      </tr>
      <tr>
        <td id="L14010" data-line-number="14010"></td>
        <td id="LC14010">
</td>
      </tr>
      <tr>
        <td id="L14011" data-line-number="14011"></td>
        <td id="LC14011">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L14012" data-line-number="14012"></td>
        <td id="LC14012">    {</td>
      </tr>
      <tr>
        <td id="L14013" data-line-number="14013"></td>
        <td id="LC14013">        <span><span>//</span> Mark interop-debugging</span></td>
      </tr>
      <tr>
        <td id="L14014" data-line-number="14014"></td>
        <td id="LC14014">        <span>if</span> (m_actionData.<span>attachData</span>.<span>IsInteropDebugging</span>())</td>
      </tr>
      <tr>
        <td id="L14015" data-line-number="14015"></td>
        <td id="LC14015">        {</td>
      </tr>
      <tr>
        <td id="L14016" data-line-number="14016"></td>
        <td id="LC14016">            pProcess-&gt;<span>EnableInteropDebugging</span>(); <span><span>//</span> Throwing</span></td>
      </tr>
      <tr>
        <td id="L14017" data-line-number="14017"></td>
        <td id="LC14017">        }</td>
      </tr>
      <tr>
        <td id="L14018" data-line-number="14018"></td>
        <td id="LC14018">
</td>
      </tr>
      <tr>
        <td id="L14019" data-line-number="14019"></td>
        <td id="LC14019">        m_cordb-&gt;<span>AddProcess</span>(pProcess); <span><span>//</span> will take ref if it succeeds</span></td>
      </tr>
      <tr>
        <td id="L14020" data-line-number="14020"></td>
        <td id="LC14020">
</td>
      </tr>
      <tr>
        <td id="L14021" data-line-number="14021"></td>
        <td id="LC14021">
</td>
      </tr>
      <tr>
        <td id="L14022" data-line-number="14022"></td>
        <td id="LC14022">        <span><span>//</span> Queue fake Attach event for CreateProcess</span></td>
      </tr>
      <tr>
        <td id="L14023" data-line-number="14023"></td>
        <td id="LC14023">        {</td>
      </tr>
      <tr>
        <td id="L14024" data-line-number="14024"></td>
        <td id="LC14024">            <span>PUBLIC_CALLBACK_IN_THIS_SCOPE0_NO_LOCK</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L14025" data-line-number="14025"></td>
        <td id="LC14025">            m_pShim-&gt;<span>BeginQueueFakeAttachEvents</span>();</td>
      </tr>
      <tr>
        <td id="L14026" data-line-number="14026"></td>
        <td id="LC14026">        }</td>
      </tr>
      <tr>
        <td id="L14027" data-line-number="14027"></td>
        <td id="LC14027">    }</td>
      </tr>
      <tr>
        <td id="L14028" data-line-number="14028"></td>
        <td id="LC14028">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L14029" data-line-number="14029"></td>
        <td id="LC14029">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L14030" data-line-number="14030"></td>
        <td id="LC14030">    {</td>
      </tr>
      <tr>
        <td id="L14031" data-line-number="14031"></td>
        <td id="LC14031">        <span>goto</span> LExit;</td>
      </tr>
      <tr>
        <td id="L14032" data-line-number="14032"></td>
        <td id="LC14032">    }</td>
      </tr>
      <tr>
        <td id="L14033" data-line-number="14033"></td>
        <td id="LC14033">
</td>
      </tr>
      <tr>
        <td id="L14034" data-line-number="14034"></td>
        <td id="LC14034">    <span>_ASSERTE</span>(m_pProcess == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14035" data-line-number="14035"></td>
        <td id="LC14035">    m_pProcess.<span>Assign</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L14036" data-line-number="14036"></td>
        <td id="LC14036">    pProcess.<span>Clear</span>();     <span><span>//</span> ownership transfered to m_pProcess</span></td>
      </tr>
      <tr>
        <td id="L14037" data-line-number="14037"></td>
        <td id="LC14037">
</td>
      </tr>
      <tr>
        <td id="L14038" data-line-number="14038"></td>
        <td id="LC14038">    <span><span>//</span> Should have succeeded if we got to this point.</span></td>
      </tr>
      <tr>
        <td id="L14039" data-line-number="14039"></td>
        <td id="LC14039">    <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L14040" data-line-number="14040"></td>
        <td id="LC14040">
</td>
      </tr>
      <tr>
        <td id="L14041" data-line-number="14041"></td>
        <td id="LC14041">
</td>
      </tr>
      <tr>
        <td id="L14042" data-line-number="14042"></td>
        <td id="LC14042">LExit:</td>
      </tr>
      <tr>
        <td id="L14043" data-line-number="14043"></td>
        <td id="LC14043">    <span>if</span> (<span>FAILED</span>(hr))</td>
      </tr>
      <tr>
        <td id="L14044" data-line-number="14044"></td>
        <td id="LC14044">    {</td>
      </tr>
      <tr>
        <td id="L14045" data-line-number="14045"></td>
        <td id="LC14045">        <span><span>//</span> If we succeed to do a native-attach, but then failed elsewhere, try to native-detach.</span></td>
      </tr>
      <tr>
        <td id="L14046" data-line-number="14046"></td>
        <td id="LC14046">        <span>if</span> (<span>fNativeAttachSucceeded</span>)</td>
      </tr>
      <tr>
        <td id="L14047" data-line-number="14047"></td>
        <td id="LC14047">        {</td>
      </tr>
      <tr>
        <td id="L14048" data-line-number="14048"></td>
        <td id="LC14048">            m_pNativePipeline-&gt;<span>DebugActiveProcessStop</span>(processDescriptor.<span>m_Pid</span>);</td>
      </tr>
      <tr>
        <td id="L14049" data-line-number="14049"></td>
        <td id="LC14049">        }</td>
      </tr>
      <tr>
        <td id="L14050" data-line-number="14050"></td>
        <td id="LC14050">
</td>
      </tr>
      <tr>
        <td id="L14051" data-line-number="14051"></td>
        <td id="LC14051">        <span>if</span> (pProcess != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14052" data-line-number="14052"></td>
        <td id="LC14052">        {</td>
      </tr>
      <tr>
        <td id="L14053" data-line-number="14053"></td>
        <td id="LC14053">            <span><span>//</span> Safe to call this even if the process wasn't added.</span></td>
      </tr>
      <tr>
        <td id="L14054" data-line-number="14054"></td>
        <td id="LC14054">            m_cordb-&gt;<span>RemoveProcess</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L14055" data-line-number="14055"></td>
        <td id="LC14055">            pProcess-&gt;<span>CleanupHalfBakedLeftSide</span>();</td>
      </tr>
      <tr>
        <td id="L14056" data-line-number="14056"></td>
        <td id="LC14056">            pProcess.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L14057" data-line-number="14057"></td>
        <td id="LC14057">        }</td>
      </tr>
      <tr>
        <td id="L14058" data-line-number="14058"></td>
        <td id="LC14058">        m_pProcess.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L14059" data-line-number="14059"></td>
        <td id="LC14059">    }</td>
      </tr>
      <tr>
        <td id="L14060" data-line-number="14060"></td>
        <td id="LC14060">
</td>
      </tr>
      <tr>
        <td id="L14061" data-line-number="14061"></td>
        <td id="LC14061">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14062" data-line-number="14062"></td>
        <td id="LC14062">    <span><span>//</span> Signal the hr to the caller.</span></td>
      </tr>
      <tr>
        <td id="L14063" data-line-number="14063"></td>
        <td id="LC14063">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14064" data-line-number="14064"></td>
        <td id="LC14064">    m_actionResult = hr;</td>
      </tr>
      <tr>
        <td id="L14065" data-line-number="14065"></td>
        <td id="LC14065">    <span>SetEvent</span>(m_actionTakenEvent);</td>
      </tr>
      <tr>
        <td id="L14066" data-line-number="14066"></td>
        <td id="LC14066">}</td>
      </tr>
      <tr>
        <td id="L14067" data-line-number="14067"></td>
        <td id="LC14067">
</td>
      </tr>
      <tr>
        <td id="L14068" data-line-number="14068"></td>
        <td id="LC14068">
</td>
      </tr>
      <tr>
        <td id="L14069" data-line-number="14069"></td>
        <td id="LC14069"><span><span>//</span> Note that the actual 'DetachProcess' method is really ExitProcess with CW32ET_UNKNOWN_PROCESS_SLOT ==</span></td>
      </tr>
      <tr>
        <td id="L14070" data-line-number="14070"></td>
        <td id="LC14070"><span><span>//</span> processSlot</span></td>
      </tr>
      <tr>
        <td id="L14071" data-line-number="14071"></td>
        <td id="LC14071">HRESULT <span>CordbWin32EventThread::SendDetachProcessEvent</span>(CordbProcess *pProcess)</td>
      </tr>
      <tr>
        <td id="L14072" data-line-number="14072"></td>
        <td id="LC14072">{</td>
      </tr>
      <tr>
        <td id="L14073" data-line-number="14073"></td>
        <td id="LC14073">    <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::SDPE<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14074" data-line-number="14074"></td>
        <td id="LC14074">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L14075" data-line-number="14075"></td>
        <td id="LC14075">
</td>
      </tr>
      <tr>
        <td id="L14076" data-line-number="14076"></td>
        <td id="LC14076">    <span>LockSendToWin32EventThreadMutex</span>();</td>
      </tr>
      <tr>
        <td id="L14077" data-line-number="14077"></td>
        <td id="LC14077">
</td>
      </tr>
      <tr>
        <td id="L14078" data-line-number="14078"></td>
        <td id="LC14078">    m_actionData.<span>detachData</span>.<span>pProcess</span> = pProcess;</td>
      </tr>
      <tr>
        <td id="L14079" data-line-number="14079"></td>
        <td id="LC14079">
</td>
      </tr>
      <tr>
        <td id="L14080" data-line-number="14080"></td>
        <td id="LC14080">    <span><span>//</span> m_action is set last so that the win32 event thread can inspect it and take action without actually</span></td>
      </tr>
      <tr>
        <td id="L14081" data-line-number="14081"></td>
        <td id="LC14081">    <span><span>//</span> having to take any locks. The lock around this here is simply to prevent multiple threads from making</span></td>
      </tr>
      <tr>
        <td id="L14082" data-line-number="14082"></td>
        <td id="LC14082">    <span><span>//</span> requests at the same time.</span></td>
      </tr>
      <tr>
        <td id="L14083" data-line-number="14083"></td>
        <td id="LC14083">    m_action = W32ETA_DETACH;</td>
      </tr>
      <tr>
        <td id="L14084" data-line-number="14084"></td>
        <td id="LC14084">
</td>
      </tr>
      <tr>
        <td id="L14085" data-line-number="14085"></td>
        <td id="LC14085">    BOOL succ = <span>SetEvent</span>(m_threadControlEvent);</td>
      </tr>
      <tr>
        <td id="L14086" data-line-number="14086"></td>
        <td id="LC14086">
</td>
      </tr>
      <tr>
        <td id="L14087" data-line-number="14087"></td>
        <td id="LC14087">    <span>if</span> (succ)</td>
      </tr>
      <tr>
        <td id="L14088" data-line-number="14088"></td>
        <td id="LC14088">    {</td>
      </tr>
      <tr>
        <td id="L14089" data-line-number="14089"></td>
        <td id="LC14089">        DWORD ret = <span>WaitForSingleObject</span>(m_actionTakenEvent, INFINITE);</td>
      </tr>
      <tr>
        <td id="L14090" data-line-number="14090"></td>
        <td id="LC14090">
</td>
      </tr>
      <tr>
        <td id="L14091" data-line-number="14091"></td>
        <td id="LC14091">        <span>if</span> (ret == WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L14092" data-line-number="14092"></td>
        <td id="LC14092">            hr = m_actionResult;</td>
      </tr>
      <tr>
        <td id="L14093" data-line-number="14093"></td>
        <td id="LC14093">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L14094" data-line-number="14094"></td>
        <td id="LC14094">            hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L14095" data-line-number="14095"></td>
        <td id="LC14095">    }</td>
      </tr>
      <tr>
        <td id="L14096" data-line-number="14096"></td>
        <td id="LC14096">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L14097" data-line-number="14097"></td>
        <td id="LC14097">        hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L14098" data-line-number="14098"></td>
        <td id="LC14098">
</td>
      </tr>
      <tr>
        <td id="L14099" data-line-number="14099"></td>
        <td id="LC14099">    <span>UnlockSendToWin32EventThreadMutex</span>();</td>
      </tr>
      <tr>
        <td id="L14100" data-line-number="14100"></td>
        <td id="LC14100">
</td>
      </tr>
      <tr>
        <td id="L14101" data-line-number="14101"></td>
        <td id="LC14101">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L14102" data-line-number="14102"></td>
        <td id="LC14102">}</td>
      </tr>
      <tr>
        <td id="L14103" data-line-number="14103"></td>
        <td id="LC14103">
</td>
      </tr>
      <tr>
        <td id="L14104" data-line-number="14104"></td>
        <td id="LC14104">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L14105" data-line-number="14105"></td>
        <td id="LC14105"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14106" data-line-number="14106"></td>
        <td id="LC14106"><span><span>//</span> Send a UnmanagedContinue event to the Win32 thread to have it</span></td>
      </tr>
      <tr>
        <td id="L14107" data-line-number="14107"></td>
        <td id="LC14107"><span><span>//</span> continue from an unmanged debug event.</span></td>
      </tr>
      <tr>
        <td id="L14108" data-line-number="14108"></td>
        <td id="LC14108"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14109" data-line-number="14109"></td>
        <td id="LC14109">HRESULT <span>CordbWin32EventThread::SendUnmanagedContinue</span>(CordbProcess *pProcess,</td>
      </tr>
      <tr>
        <td id="L14110" data-line-number="14110"></td>
        <td id="LC14110">                                                     EUMContinueType eContType)</td>
      </tr>
      <tr>
        <td id="L14111" data-line-number="14111"></td>
        <td id="LC14111">{</td>
      </tr>
      <tr>
        <td id="L14112" data-line-number="14112"></td>
        <td id="LC14112">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L14113" data-line-number="14113"></td>
        <td id="LC14113">
</td>
      </tr>
      <tr>
        <td id="L14114" data-line-number="14114"></td>
        <td id="LC14114">    <span><span>//</span> If this were being called on the win32 EventThread, we'd deadlock.</span></td>
      </tr>
      <tr>
        <td id="L14115" data-line-number="14115"></td>
        <td id="LC14115">    <span>_ASSERTE</span>(!<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L14116" data-line-number="14116"></td>
        <td id="LC14116">
</td>
      </tr>
      <tr>
        <td id="L14117" data-line-number="14117"></td>
        <td id="LC14117">    <span><span>//</span> This can't hold the process lock, b/c we're making a cross-thread call,</span></td>
      </tr>
      <tr>
        <td id="L14118" data-line-number="14118"></td>
        <td id="LC14118">    <span><span>//</span> and our target will need the process lock.</span></td>
      </tr>
      <tr>
        <td id="L14119" data-line-number="14119"></td>
        <td id="LC14119">    <span>_ASSERTE</span>(!pProcess-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L14120" data-line-number="14120"></td>
        <td id="LC14120">
</td>
      </tr>
      <tr>
        <td id="L14121" data-line-number="14121"></td>
        <td id="LC14121">    <span>LockSendToWin32EventThreadMutex</span>();</td>
      </tr>
      <tr>
        <td id="L14122" data-line-number="14122"></td>
        <td id="LC14122">
</td>
      </tr>
      <tr>
        <td id="L14123" data-line-number="14123"></td>
        <td id="LC14123">    m_actionData.<span>continueData</span>.<span>process</span> = pProcess;</td>
      </tr>
      <tr>
        <td id="L14124" data-line-number="14124"></td>
        <td id="LC14124">    m_actionData.<span>continueData</span>.<span>eContType</span> = eContType;</td>
      </tr>
      <tr>
        <td id="L14125" data-line-number="14125"></td>
        <td id="LC14125">
</td>
      </tr>
      <tr>
        <td id="L14126" data-line-number="14126"></td>
        <td id="LC14126">    <span><span>//</span> m_action is set last so that the win32 event thread can inspect</span></td>
      </tr>
      <tr>
        <td id="L14127" data-line-number="14127"></td>
        <td id="LC14127">    <span><span>//</span> it and take action without actually having to take any</span></td>
      </tr>
      <tr>
        <td id="L14128" data-line-number="14128"></td>
        <td id="LC14128">    <span><span>//</span> locks. The lock around this here is simply to prevent multiple</span></td>
      </tr>
      <tr>
        <td id="L14129" data-line-number="14129"></td>
        <td id="LC14129">    <span><span>//</span> threads from making requests at the same time.</span></td>
      </tr>
      <tr>
        <td id="L14130" data-line-number="14130"></td>
        <td id="LC14130">    m_action = W32ETA_CONTINUE;</td>
      </tr>
      <tr>
        <td id="L14131" data-line-number="14131"></td>
        <td id="LC14131">
</td>
      </tr>
      <tr>
        <td id="L14132" data-line-number="14132"></td>
        <td id="LC14132">    BOOL succ = <span>SetEvent</span>(m_threadControlEvent);</td>
      </tr>
      <tr>
        <td id="L14133" data-line-number="14133"></td>
        <td id="LC14133">
</td>
      </tr>
      <tr>
        <td id="L14134" data-line-number="14134"></td>
        <td id="LC14134">    <span>if</span> (succ)</td>
      </tr>
      <tr>
        <td id="L14135" data-line-number="14135"></td>
        <td id="LC14135">    {</td>
      </tr>
      <tr>
        <td id="L14136" data-line-number="14136"></td>
        <td id="LC14136">        DWORD ret = <span>WaitForSingleObject</span>(m_actionTakenEvent, INFINITE);</td>
      </tr>
      <tr>
        <td id="L14137" data-line-number="14137"></td>
        <td id="LC14137">
</td>
      </tr>
      <tr>
        <td id="L14138" data-line-number="14138"></td>
        <td id="LC14138">        <span>if</span> (ret == WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L14139" data-line-number="14139"></td>
        <td id="LC14139">            hr = m_actionResult;</td>
      </tr>
      <tr>
        <td id="L14140" data-line-number="14140"></td>
        <td id="LC14140">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L14141" data-line-number="14141"></td>
        <td id="LC14141">            hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L14142" data-line-number="14142"></td>
        <td id="LC14142">    }</td>
      </tr>
      <tr>
        <td id="L14143" data-line-number="14143"></td>
        <td id="LC14143">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L14144" data-line-number="14144"></td>
        <td id="LC14144">        hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L14145" data-line-number="14145"></td>
        <td id="LC14145">
</td>
      </tr>
      <tr>
        <td id="L14146" data-line-number="14146"></td>
        <td id="LC14146">    <span>UnlockSendToWin32EventThreadMutex</span>();</td>
      </tr>
      <tr>
        <td id="L14147" data-line-number="14147"></td>
        <td id="LC14147">
</td>
      </tr>
      <tr>
        <td id="L14148" data-line-number="14148"></td>
        <td id="LC14148">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L14149" data-line-number="14149"></td>
        <td id="LC14149">}</td>
      </tr>
      <tr>
        <td id="L14150" data-line-number="14150"></td>
        <td id="LC14150">
</td>
      </tr>
      <tr>
        <td id="L14151" data-line-number="14151"></td>
        <td id="LC14151">
</td>
      </tr>
      <tr>
        <td id="L14152" data-line-number="14152"></td>
        <td id="LC14152"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14153" data-line-number="14153"></td>
        <td id="LC14153"><span><span>//</span> Handle unmanaged continue. Continue an unmanaged debug</span></td>
      </tr>
      <tr>
        <td id="L14154" data-line-number="14154"></td>
        <td id="LC14154"><span><span>//</span> event. Deferes to UnmanagedContinue. This is called in the context</span></td>
      </tr>
      <tr>
        <td id="L14155" data-line-number="14155"></td>
        <td id="LC14155"><span><span>//</span> of the Win32 event thread to ensure that if we're Win32 debugging</span></td>
      </tr>
      <tr>
        <td id="L14156" data-line-number="14156"></td>
        <td id="LC14156"><span><span>//</span> the process that the same thread that waits for debugging events</span></td>
      </tr>
      <tr>
        <td id="L14157" data-line-number="14157"></td>
        <td id="LC14157"><span><span>//</span> will be the thread that continues the process.</span></td>
      </tr>
      <tr>
        <td id="L14158" data-line-number="14158"></td>
        <td id="LC14158"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14159" data-line-number="14159"></td>
        <td id="LC14159"><span>void</span> <span>CordbWin32EventThread::HandleUnmanagedContinue</span>()</td>
      </tr>
      <tr>
        <td id="L14160" data-line-number="14160"></td>
        <td id="LC14160">{</td>
      </tr>
      <tr>
        <td id="L14161" data-line-number="14161"></td>
        <td id="LC14161">    <span>_ASSERTE</span>(<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L14162" data-line-number="14162"></td>
        <td id="LC14162">
</td>
      </tr>
      <tr>
        <td id="L14163" data-line-number="14163"></td>
        <td id="LC14163">    m_action = W32ETA_NONE;</td>
      </tr>
      <tr>
        <td id="L14164" data-line-number="14164"></td>
        <td id="LC14164">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L14165" data-line-number="14165"></td>
        <td id="LC14165">
</td>
      </tr>
      <tr>
        <td id="L14166" data-line-number="14166"></td>
        <td id="LC14166">    <span><span>//</span> Continue the process</span></td>
      </tr>
      <tr>
        <td id="L14167" data-line-number="14167"></td>
        <td id="LC14167">    CordbProcess *pProcess = m_actionData.<span>continueData</span>.<span>process</span>;</td>
      </tr>
      <tr>
        <td id="L14168" data-line-number="14168"></td>
        <td id="LC14168">
</td>
      </tr>
      <tr>
        <td id="L14169" data-line-number="14169"></td>
        <td id="LC14169">    <span><span>//</span> If we lost the process object, we must have exited.</span></td>
      </tr>
      <tr>
        <td id="L14170" data-line-number="14170"></td>
        <td id="LC14170">    <span>if</span> (m_pProcess != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14171" data-line-number="14171"></td>
        <td id="LC14171">    {</td>
      </tr>
      <tr>
        <td id="L14172" data-line-number="14172"></td>
        <td id="LC14172">        <span>_ASSERTE</span>(m_pProcess != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14173" data-line-number="14173"></td>
        <td id="LC14173">        <span>_ASSERTE</span>(pProcess == m_pProcess);</td>
      </tr>
      <tr>
        <td id="L14174" data-line-number="14174"></td>
        <td id="LC14174">
</td>
      </tr>
      <tr>
        <td id="L14175" data-line-number="14175"></td>
        <td id="LC14175">        <span>_ASSERTE</span>(!pProcess-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L14176" data-line-number="14176"></td>
        <td id="LC14176">
</td>
      </tr>
      <tr>
        <td id="L14177" data-line-number="14177"></td>
        <td id="LC14177">        RSSmartPtr&lt;CordbProcess&gt; <span>proc</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L14178" data-line-number="14178"></td>
        <td id="LC14178">        RSLockHolder <span>ch</span>(&amp;pProcess-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L14179" data-line-number="14179"></td>
        <td id="LC14179">
</td>
      </tr>
      <tr>
        <td id="L14180" data-line-number="14180"></td>
        <td id="LC14180">        hr = <span>UnmanagedContinue</span>(pProcess, m_actionData.<span>continueData</span>.<span>eContType</span>);</td>
      </tr>
      <tr>
        <td id="L14181" data-line-number="14181"></td>
        <td id="LC14181">    }</td>
      </tr>
      <tr>
        <td id="L14182" data-line-number="14182"></td>
        <td id="LC14182">
</td>
      </tr>
      <tr>
        <td id="L14183" data-line-number="14183"></td>
        <td id="LC14183">    <span><span>//</span> Signal the hr to the caller.</span></td>
      </tr>
      <tr>
        <td id="L14184" data-line-number="14184"></td>
        <td id="LC14184">    m_actionResult = hr;</td>
      </tr>
      <tr>
        <td id="L14185" data-line-number="14185"></td>
        <td id="LC14185">    <span>SetEvent</span>(m_actionTakenEvent);</td>
      </tr>
      <tr>
        <td id="L14186" data-line-number="14186"></td>
        <td id="LC14186">}</td>
      </tr>
      <tr>
        <td id="L14187" data-line-number="14187"></td>
        <td id="LC14187">
</td>
      </tr>
      <tr>
        <td id="L14188" data-line-number="14188"></td>
        <td id="LC14188"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14189" data-line-number="14189"></td>
        <td id="LC14189"><span><span>//</span> Continue an unmanaged debug event. This is called in the context of the Win32 Event thread to ensure that the same</span></td>
      </tr>
      <tr>
        <td id="L14190" data-line-number="14190"></td>
        <td id="LC14190"><span><span>//</span> thread that waits for debug events will be the thread that continues the process.</span></td>
      </tr>
      <tr>
        <td id="L14191" data-line-number="14191"></td>
        <td id="LC14191"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14192" data-line-number="14192"></td>
        <td id="LC14192">HRESULT <span>CordbWin32EventThread::UnmanagedContinue</span>(CordbProcess *pProcess,</td>
      </tr>
      <tr>
        <td id="L14193" data-line-number="14193"></td>
        <td id="LC14193">                                                 EUMContinueType eContType)</td>
      </tr>
      <tr>
        <td id="L14194" data-line-number="14194"></td>
        <td id="LC14194">{</td>
      </tr>
      <tr>
        <td id="L14195" data-line-number="14195"></td>
        <td id="LC14195">    <span>_ASSERTE</span>(pProcess-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L14196" data-line-number="14196"></td>
        <td id="LC14196">    <span>_ASSERTE</span>(<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L14197" data-line-number="14197"></td>
        <td id="LC14197">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14198" data-line-number="14198"></td>
        <td id="LC14198">
</td>
      </tr>
      <tr>
        <td id="L14199" data-line-number="14199"></td>
        <td id="LC14199">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L14200" data-line-number="14200"></td>
        <td id="LC14200">
</td>
      </tr>
      <tr>
        <td id="L14201" data-line-number="14201"></td>
        <td id="LC14201">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>UM Continue. type=%d<span>\n</span><span>"</span></span>, eContType);</td>
      </tr>
      <tr>
        <td id="L14202" data-line-number="14202"></td>
        <td id="LC14202">
</td>
      </tr>
      <tr>
        <td id="L14203" data-line-number="14203"></td>
        <td id="LC14203">    <span>if</span> (eContType == cOobUMContinue)</td>
      </tr>
      <tr>
        <td id="L14204" data-line-number="14204"></td>
        <td id="LC14204">    {</td>
      </tr>
      <tr>
        <td id="L14205" data-line-number="14205"></td>
        <td id="LC14205">        <span>_ASSERTE</span>(pProcess-&gt;<span>m_outOfBandEventQueue</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14206" data-line-number="14206"></td>
        <td id="LC14206">
</td>
      </tr>
      <tr>
        <td id="L14207" data-line-number="14207"></td>
        <td id="LC14207">        <span><span>//</span> Dequeue the OOB event.</span></td>
      </tr>
      <tr>
        <td id="L14208" data-line-number="14208"></td>
        <td id="LC14208">        CordbUnmanagedEvent *ue = pProcess-&gt;<span>m_outOfBandEventQueue</span>;</td>
      </tr>
      <tr>
        <td id="L14209" data-line-number="14209"></td>
        <td id="LC14209">        CordbUnmanagedThread *ut = ue-&gt;<span>m_owner</span>;</td>
      </tr>
      <tr>
        <td id="L14210" data-line-number="14210"></td>
        <td id="LC14210">        pProcess-&gt;<span>DequeueOOBUnmanagedEvent</span>(ut);</td>
      </tr>
      <tr>
        <td id="L14211" data-line-number="14211"></td>
        <td id="LC14211">
</td>
      </tr>
      <tr>
        <td id="L14212" data-line-number="14212"></td>
        <td id="LC14212">        <span><span>//</span> Do a little extra work if that was an OOB exception event...</span></td>
      </tr>
      <tr>
        <td id="L14213" data-line-number="14213"></td>
        <td id="LC14213">        hr = ue-&gt;<span>m_owner</span>-&gt;<span>FixupAfterOOBException</span>(ue);</td>
      </tr>
      <tr>
        <td id="L14214" data-line-number="14214"></td>
        <td id="LC14214">        <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L14215" data-line-number="14215"></td>
        <td id="LC14215">
</td>
      </tr>
      <tr>
        <td id="L14216" data-line-number="14216"></td>
        <td id="LC14216">        <span><span>//</span> Continue from the event.</span></td>
      </tr>
      <tr>
        <td id="L14217" data-line-number="14217"></td>
        <td id="LC14217">        <span>DoDbgContinue</span>(pProcess, ue);</td>
      </tr>
      <tr>
        <td id="L14218" data-line-number="14218"></td>
        <td id="LC14218">
</td>
      </tr>
      <tr>
        <td id="L14219" data-line-number="14219"></td>
        <td id="LC14219">        <span><span>//</span> If there are more queued OOB events, dispatch them now.</span></td>
      </tr>
      <tr>
        <td id="L14220" data-line-number="14220"></td>
        <td id="LC14220">        <span>if</span> (pProcess-&gt;<span>m_outOfBandEventQueue</span> != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14221" data-line-number="14221"></td>
        <td id="LC14221">            pProcess-&gt;<span>DispatchUnmanagedOOBEvent</span>();</td>
      </tr>
      <tr>
        <td id="L14222" data-line-number="14222"></td>
        <td id="LC14222">
</td>
      </tr>
      <tr>
        <td id="L14223" data-line-number="14223"></td>
        <td id="LC14223">        <span><span>//</span> Note: if we previously skipped letting the entire process go on an IB continue due to a blocking OOB event,</span></td>
      </tr>
      <tr>
        <td id="L14224" data-line-number="14224"></td>
        <td id="LC14224">        <span><span>//</span> and if the OOB event queue is now empty, then go ahead and let the process continue now...</span></td>
      </tr>
      <tr>
        <td id="L14225" data-line-number="14225"></td>
        <td id="LC14225">        <span>if</span> ((pProcess-&gt;<span>m_doRealContinueAfterOOBBlock</span> == <span>true</span>) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L14226" data-line-number="14226"></td>
        <td id="LC14226">            (pProcess-&gt;<span>m_outOfBandEventQueue</span> == <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L14227" data-line-number="14227"></td>
        <td id="LC14227">            <span>goto</span> doRealContinue;</td>
      </tr>
      <tr>
        <td id="L14228" data-line-number="14228"></td>
        <td id="LC14228">    }</td>
      </tr>
      <tr>
        <td id="L14229" data-line-number="14229"></td>
        <td id="LC14229">    <span>else</span> <span>if</span> (eContType == cInternalUMContinue)</td>
      </tr>
      <tr>
        <td id="L14230" data-line-number="14230"></td>
        <td id="LC14230">    {</td>
      </tr>
      <tr>
        <td id="L14231" data-line-number="14231"></td>
        <td id="LC14231">        <span><span>//</span> We're trying to get into a synced state which means we need the process running (potentially</span></td>
      </tr>
      <tr>
        <td id="L14232" data-line-number="14232"></td>
        <td id="LC14232">        <span><span>//</span> with some threads hijacked) in order to have the helper thread do the sync.</span></td>
      </tr>
      <tr>
        <td id="L14233" data-line-number="14233"></td>
        <td id="LC14233">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::UC: internal continue.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14234" data-line-number="14234"></td>
        <td id="LC14234">
</td>
      </tr>
      <tr>
        <td id="L14235" data-line-number="14235"></td>
        <td id="LC14235">        <span>if</span> (!pProcess-&gt;<span>GetSynchronized</span>())</td>
      </tr>
      <tr>
        <td id="L14236" data-line-number="14236"></td>
        <td id="LC14236">        {</td>
      </tr>
      <tr>
        <td id="L14237" data-line-number="14237"></td>
        <td id="LC14237">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::UC: internal continue, !sync'd.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14238" data-line-number="14238"></td>
        <td id="LC14238">            pProcess-&gt;<span>ResumeUnmanagedThreads</span>();</td>
      </tr>
      <tr>
        <td id="L14239" data-line-number="14239"></td>
        <td id="LC14239">
</td>
      </tr>
      <tr>
        <td id="L14240" data-line-number="14240"></td>
        <td id="LC14240">            <span><span>//</span> the event we may need to hijack and continue;</span></td>
      </tr>
      <tr>
        <td id="L14241" data-line-number="14241"></td>
        <td id="LC14241">            CordbUnmanagedEvent* pEvent = pProcess-&gt;<span>m_lastQueuedUnmanagedEvent</span>;</td>
      </tr>
      <tr>
        <td id="L14242" data-line-number="14242"></td>
        <td id="LC14242">
</td>
      </tr>
      <tr>
        <td id="L14243" data-line-number="14243"></td>
        <td id="LC14243">            <span><span>//</span> It is possible to be stopped at either an IB or an OOB event here. We only want to</span></td>
      </tr>
      <tr>
        <td id="L14244" data-line-number="14244"></td>
        <td id="LC14244">            <span><span>//</span> continue from an IB event here though</span></td>
      </tr>
      <tr>
        <td id="L14245" data-line-number="14245"></td>
        <td id="LC14245">            <span>if</span>(pProcess-&gt;<span>m_state</span> &amp; CordbProcess::PS_WIN32_STOPPED &amp;&amp; pEvent != <span>NULL</span> &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L14246" data-line-number="14246"></td>
        <td id="LC14246">                pEvent-&gt;<span>IsEventWaitingForContinue</span>())</td>
      </tr>
      <tr>
        <td id="L14247" data-line-number="14247"></td>
        <td id="LC14247">            {</td>
      </tr>
      <tr>
        <td id="L14248" data-line-number="14248"></td>
        <td id="LC14248">                <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::UC: internal continue, frozen on IB event.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14249" data-line-number="14249"></td>
        <td id="LC14249">
</td>
      </tr>
      <tr>
        <td id="L14250" data-line-number="14250"></td>
        <td id="LC14250">                <span><span>//</span> There should be a uncontinued IB event at the head of the queue</span></td>
      </tr>
      <tr>
        <td id="L14251" data-line-number="14251"></td>
        <td id="LC14251">                <span>_ASSERTE</span>(pEvent-&gt;<span>IsIBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L14252" data-line-number="14252"></td>
        <td id="LC14252">                <span>_ASSERTE</span>(!pEvent-&gt;<span>IsEventContinuedUnhijacked</span>());</td>
      </tr>
      <tr>
        <td id="L14253" data-line-number="14253"></td>
        <td id="LC14253">                <span>_ASSERTE</span>(!pEvent-&gt;<span>IsEventContinuedHijacked</span>());</td>
      </tr>
      <tr>
        <td id="L14254" data-line-number="14254"></td>
        <td id="LC14254">
</td>
      </tr>
      <tr>
        <td id="L14255" data-line-number="14255"></td>
        <td id="LC14255">                <span><span>//</span> Ensure that the event is hijacked now (it may not have been before) so that the</span></td>
      </tr>
      <tr>
        <td id="L14256" data-line-number="14256"></td>
        <td id="LC14256">                <span><span>//</span> thread does not slip forward during the sync process. After that we can safely continue</span></td>
      </tr>
      <tr>
        <td id="L14257" data-line-number="14257"></td>
        <td id="LC14257">                <span><span>//</span> it.</span></td>
      </tr>
      <tr>
        <td id="L14258" data-line-number="14258"></td>
        <td id="LC14258">                pProcess-&gt;<span>HijackIBEvent</span>(pEvent);</td>
      </tr>
      <tr>
        <td id="L14259" data-line-number="14259"></td>
        <td id="LC14259">                m_pShim-&gt;<span>GetWin32EventThread</span>()-&gt;<span>DoDbgContinue</span>(pProcess, pEvent);</td>
      </tr>
      <tr>
        <td id="L14260" data-line-number="14260"></td>
        <td id="LC14260">            }</td>
      </tr>
      <tr>
        <td id="L14261" data-line-number="14261"></td>
        <td id="LC14261">        }</td>
      </tr>
      <tr>
        <td id="L14262" data-line-number="14262"></td>
        <td id="LC14262">
</td>
      </tr>
      <tr>
        <td id="L14263" data-line-number="14263"></td>
        <td id="LC14263">        <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::UC: internal continue, done.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14264" data-line-number="14264"></td>
        <td id="LC14264">    }</td>
      </tr>
      <tr>
        <td id="L14265" data-line-number="14265"></td>
        <td id="LC14265">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L14266" data-line-number="14266"></td>
        <td id="LC14266">    {</td>
      </tr>
      <tr>
        <td id="L14267" data-line-number="14267"></td>
        <td id="LC14267">        <span><span>//</span> If we're here, then we know 100% for sure that we've successfully gotten the managed continue event to the</span></td>
      </tr>
      <tr>
        <td id="L14268" data-line-number="14268"></td>
        <td id="LC14268">        <span><span>//</span> Left Side, so we can stop force hijacking left over in-band events now. Note: if we had hijacked any such</span></td>
      </tr>
      <tr>
        <td id="L14269" data-line-number="14269"></td>
        <td id="LC14269">        <span><span>//</span> events, they'll be dispatched below since they're properly queued.</span></td>
      </tr>
      <tr>
        <td id="L14270" data-line-number="14270"></td>
        <td id="LC14270">        pProcess-&gt;<span>m_specialDeferment</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L14271" data-line-number="14271"></td>
        <td id="LC14271">
</td>
      </tr>
      <tr>
        <td id="L14272" data-line-number="14272"></td>
        <td id="LC14272">        <span><span>//</span> We don't actually do any work if there is an outstanding out-of-band event. When we do continue from the</span></td>
      </tr>
      <tr>
        <td id="L14273" data-line-number="14273"></td>
        <td id="LC14273">        <span><span>//</span> out-of-band event, we'll do this work, too.</span></td>
      </tr>
      <tr>
        <td id="L14274" data-line-number="14274"></td>
        <td id="LC14274">        <span>if</span> (pProcess-&gt;<span>m_outOfBandEventQueue</span> != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14275" data-line-number="14275"></td>
        <td id="LC14275">        {</td>
      </tr>
      <tr>
        <td id="L14276" data-line-number="14276"></td>
        <td id="LC14276">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::UC: ignoring real continue due to block by out-of-band event(s).<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14277" data-line-number="14277"></td>
        <td id="LC14277">
</td>
      </tr>
      <tr>
        <td id="L14278" data-line-number="14278"></td>
        <td id="LC14278">            <span>_ASSERTE</span>(pProcess-&gt;<span>m_doRealContinueAfterOOBBlock</span> == <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L14279" data-line-number="14279"></td>
        <td id="LC14279">            pProcess-&gt;<span>m_doRealContinueAfterOOBBlock</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L14280" data-line-number="14280"></td>
        <td id="LC14280">        }</td>
      </tr>
      <tr>
        <td id="L14281" data-line-number="14281"></td>
        <td id="LC14281">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L14282" data-line-number="14282"></td>
        <td id="LC14282">        {</td>
      </tr>
      <tr>
        <td id="L14283" data-line-number="14283"></td>
        <td id="LC14283">doRealContinue:</td>
      </tr>
      <tr>
        <td id="L14284" data-line-number="14284"></td>
        <td id="LC14284">            <span><span>//</span> This is either the Frozen -&gt; Running transition or a</span></td>
      </tr>
      <tr>
        <td id="L14285" data-line-number="14285"></td>
        <td id="LC14285">            <span><span>//</span> Synced -&gt; Running transition</span></td>
      </tr>
      <tr>
        <td id="L14286" data-line-number="14286"></td>
        <td id="LC14286">            <span>_ASSERTE</span>(pProcess-&gt;<span>m_outOfBandEventQueue</span> == <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14287" data-line-number="14287"></td>
        <td id="LC14287">
</td>
      </tr>
      <tr>
        <td id="L14288" data-line-number="14288"></td>
        <td id="LC14288">
</td>
      </tr>
      <tr>
        <td id="L14289" data-line-number="14289"></td>
        <td id="LC14289">            pProcess-&gt;<span>m_doRealContinueAfterOOBBlock</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L14290" data-line-number="14290"></td>
        <td id="LC14290">
</td>
      </tr>
      <tr>
        <td id="L14291" data-line-number="14291"></td>
        <td id="LC14291">            <span>LOG</span>((LF_CORDB, LL_INFO1000, <span><span>"</span>W32ET::UC: continuing the process.<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14292" data-line-number="14292"></td>
        <td id="LC14292">            <span><span>//</span> Dispatch any more queued in-band events, or if there are none then just continue the process.</span></td>
      </tr>
      <tr>
        <td id="L14293" data-line-number="14293"></td>
        <td id="LC14293">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14294" data-line-number="14294"></td>
        <td id="LC14294">            <span><span>//</span> Note: don't dispatch more events if we've already sent up the ExitProcess event... those events are just</span></td>
      </tr>
      <tr>
        <td id="L14295" data-line-number="14295"></td>
        <td id="LC14295">            <span><span>//</span> lost.</span></td>
      </tr>
      <tr>
        <td id="L14296" data-line-number="14296"></td>
        <td id="LC14296">            <span>if</span> ((pProcess-&gt;<span>HasUndispatchedNativeEvents</span>()) &amp;&amp; (pProcess-&gt;<span>m_exiting</span> == <span>false</span>))</td>
      </tr>
      <tr>
        <td id="L14297" data-line-number="14297"></td>
        <td id="LC14297">            {</td>
      </tr>
      <tr>
        <td id="L14298" data-line-number="14298"></td>
        <td id="LC14298">                pProcess-&gt;<span>DispatchUnmanagedInBandEvent</span>();</td>
      </tr>
      <tr>
        <td id="L14299" data-line-number="14299"></td>
        <td id="LC14299">            }</td>
      </tr>
      <tr>
        <td id="L14300" data-line-number="14300"></td>
        <td id="LC14300">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L14301" data-line-number="14301"></td>
        <td id="LC14301">            {</td>
      </tr>
      <tr>
        <td id="L14302" data-line-number="14302"></td>
        <td id="LC14302">                <span><span>//</span> If the unmanaged event queue is empty now, and the process is synchronized, and there are queued</span></td>
      </tr>
      <tr>
        <td id="L14303" data-line-number="14303"></td>
        <td id="LC14303">                <span><span>//</span> managed events, then go ahead and get more managed events dispatched.</span></td>
      </tr>
      <tr>
        <td id="L14304" data-line-number="14304"></td>
        <td id="LC14304">                <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14305" data-line-number="14305"></td>
        <td id="LC14305">                <span><span>//</span> Note: don't dispatch more events if we've already sent up the ExitProcess event... those events are</span></td>
      </tr>
      <tr>
        <td id="L14306" data-line-number="14306"></td>
        <td id="LC14306">                <span><span>//</span> just lost.</span></td>
      </tr>
      <tr>
        <td id="L14307" data-line-number="14307"></td>
        <td id="LC14307">                <span>if</span> (pProcess-&gt;<span>GetSynchronized</span>() &amp;&amp; (!m_pShim-&gt;<span>GetManagedEventQueue</span>()-&gt;<span>IsEmpty</span>()) &amp;&amp; (pProcess-&gt;<span>m_exiting</span> == <span>false</span>))</td>
      </tr>
      <tr>
        <td id="L14308" data-line-number="14308"></td>
        <td id="LC14308">                {</td>
      </tr>
      <tr>
        <td id="L14309" data-line-number="14309"></td>
        <td id="LC14309">                    <span>if</span>(pProcess-&gt;<span>m_state</span> &amp; CordbProcess::PS_WIN32_STOPPED)</td>
      </tr>
      <tr>
        <td id="L14310" data-line-number="14310"></td>
        <td id="LC14310">                    {</td>
      </tr>
      <tr>
        <td id="L14311" data-line-number="14311"></td>
        <td id="LC14311">                        <span>DoDbgContinue</span>(pProcess, pProcess-&gt;<span>m_lastDispatchedIBEvent</span>);</td>
      </tr>
      <tr>
        <td id="L14312" data-line-number="14312"></td>
        <td id="LC14312">
</td>
      </tr>
      <tr>
        <td id="L14313" data-line-number="14313"></td>
        <td id="LC14313">                        <span><span>//</span> This if should not be necessary, I am just being extra careful because this</span></td>
      </tr>
      <tr>
        <td id="L14314" data-line-number="14314"></td>
        <td id="LC14314">                        <span><span>//</span> fix is going in late - see issue 818301</span></td>
      </tr>
      <tr>
        <td id="L14315" data-line-number="14315"></td>
        <td id="LC14315">                        <span>_ASSERTE</span>(pProcess-&gt;<span>m_lastDispatchedIBEvent</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14316" data-line-number="14316"></td>
        <td id="LC14316">                        <span>if</span>(pProcess-&gt;<span>m_lastDispatchedIBEvent</span> != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14317" data-line-number="14317"></td>
        <td id="LC14317">                        {</td>
      </tr>
      <tr>
        <td id="L14318" data-line-number="14318"></td>
        <td id="LC14318">                            pProcess-&gt;<span>m_lastDispatchedIBEvent</span>-&gt;<span>m_owner</span>-&gt;<span>InternalRelease</span>();</td>
      </tr>
      <tr>
        <td id="L14319" data-line-number="14319"></td>
        <td id="LC14319">                        pProcess-&gt;<span>m_lastDispatchedIBEvent</span> = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L14320" data-line-number="14320"></td>
        <td id="LC14320">                    }</td>
      </tr>
      <tr>
        <td id="L14321" data-line-number="14321"></td>
        <td id="LC14321">                    }</td>
      </tr>
      <tr>
        <td id="L14322" data-line-number="14322"></td>
        <td id="LC14322">
</td>
      </tr>
      <tr>
        <td id="L14323" data-line-number="14323"></td>
        <td id="LC14323">                    <span><span>//</span> Now, get more managed events dispatched.</span></td>
      </tr>
      <tr>
        <td id="L14324" data-line-number="14324"></td>
        <td id="LC14324">                    pProcess-&gt;<span>SetSynchronized</span>(<span>false</span>);</td>
      </tr>
      <tr>
        <td id="L14325" data-line-number="14325"></td>
        <td id="LC14325">                    pProcess-&gt;<span>MarkAllThreadsDirty</span>();</td>
      </tr>
      <tr>
        <td id="L14326" data-line-number="14326"></td>
        <td id="LC14326">                    m_cordb-&gt;<span>ProcessStateChanged</span>();</td>
      </tr>
      <tr>
        <td id="L14327" data-line-number="14327"></td>
        <td id="LC14327">                }</td>
      </tr>
      <tr>
        <td id="L14328" data-line-number="14328"></td>
        <td id="LC14328">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L14329" data-line-number="14329"></td>
        <td id="LC14329">                {</td>
      </tr>
      <tr>
        <td id="L14330" data-line-number="14330"></td>
        <td id="LC14330">                    <span><span>//</span> free all the hijacked threads that hit native debug events</span></td>
      </tr>
      <tr>
        <td id="L14331" data-line-number="14331"></td>
        <td id="LC14331">                    pProcess-&gt;<span>ResumeHijackedThreads</span>();</td>
      </tr>
      <tr>
        <td id="L14332" data-line-number="14332"></td>
        <td id="LC14332">
</td>
      </tr>
      <tr>
        <td id="L14333" data-line-number="14333"></td>
        <td id="LC14333">                    <span><span>//</span> after continuing the here the process should be running completely</span></td>
      </tr>
      <tr>
        <td id="L14334" data-line-number="14334"></td>
        <td id="LC14334">                    <span><span>//</span> free... no hijacks, no suspended threads, and of course not frozen</span></td>
      </tr>
      <tr>
        <td id="L14335" data-line-number="14335"></td>
        <td id="LC14335">                    <span>if</span>(pProcess-&gt;<span>m_state</span> &amp; CordbProcess::PS_WIN32_STOPPED)</td>
      </tr>
      <tr>
        <td id="L14336" data-line-number="14336"></td>
        <td id="LC14336">                    {</td>
      </tr>
      <tr>
        <td id="L14337" data-line-number="14337"></td>
        <td id="LC14337">                        <span>DoDbgContinue</span>(pProcess, pProcess-&gt;<span>m_lastDispatchedIBEvent</span>);</td>
      </tr>
      <tr>
        <td id="L14338" data-line-number="14338"></td>
        <td id="LC14338">                        <span><span>//</span> This if should not be necessary, I am just being extra careful because this</span></td>
      </tr>
      <tr>
        <td id="L14339" data-line-number="14339"></td>
        <td id="LC14339">                        <span><span>//</span> fix is going in late - see issue 818301</span></td>
      </tr>
      <tr>
        <td id="L14340" data-line-number="14340"></td>
        <td id="LC14340">                        <span>_ASSERTE</span>(pProcess-&gt;<span>m_lastDispatchedIBEvent</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14341" data-line-number="14341"></td>
        <td id="LC14341">                        <span>if</span>(pProcess-&gt;<span>m_lastDispatchedIBEvent</span> != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14342" data-line-number="14342"></td>
        <td id="LC14342">                        {</td>
      </tr>
      <tr>
        <td id="L14343" data-line-number="14343"></td>
        <td id="LC14343">                            pProcess-&gt;<span>m_lastDispatchedIBEvent</span>-&gt;<span>m_owner</span>-&gt;<span>InternalRelease</span>();</td>
      </tr>
      <tr>
        <td id="L14344" data-line-number="14344"></td>
        <td id="LC14344">                        pProcess-&gt;<span>m_lastDispatchedIBEvent</span> = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L14345" data-line-number="14345"></td>
        <td id="LC14345">                    }</td>
      </tr>
      <tr>
        <td id="L14346" data-line-number="14346"></td>
        <td id="LC14346">                }</td>
      </tr>
      <tr>
        <td id="L14347" data-line-number="14347"></td>
        <td id="LC14347">            }</td>
      </tr>
      <tr>
        <td id="L14348" data-line-number="14348"></td>
        <td id="LC14348">            }</td>
      </tr>
      <tr>
        <td id="L14349" data-line-number="14349"></td>
        <td id="LC14349">
</td>
      </tr>
      <tr>
        <td id="L14350" data-line-number="14350"></td>
        <td id="LC14350">            <span><span>//</span> Implicit Release on UT</span></td>
      </tr>
      <tr>
        <td id="L14351" data-line-number="14351"></td>
        <td id="LC14351">        }</td>
      </tr>
      <tr>
        <td id="L14352" data-line-number="14352"></td>
        <td id="LC14352">    }</td>
      </tr>
      <tr>
        <td id="L14353" data-line-number="14353"></td>
        <td id="LC14353">
</td>
      </tr>
      <tr>
        <td id="L14354" data-line-number="14354"></td>
        <td id="LC14354">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L14355" data-line-number="14355"></td>
        <td id="LC14355">}</td>
      </tr>
      <tr>
        <td id="L14356" data-line-number="14356"></td>
        <td id="LC14356">#<span>endif</span> <span><span>//</span> FEATURE_INTEROP_DEBUGGING</span></td>
      </tr>
      <tr>
        <td id="L14357" data-line-number="14357"></td>
        <td id="LC14357">
</td>
      </tr>
      <tr>
        <td id="L14358" data-line-number="14358"></td>
        <td id="LC14358"><span>void</span> <span>ExitProcessWorkItem::Do</span>()</td>
      </tr>
      <tr>
        <td id="L14359" data-line-number="14359"></td>
        <td id="LC14359">{</td>
      </tr>
      <tr>
        <td id="L14360" data-line-number="14360"></td>
        <td id="LC14360">    <span>STRESS_LOG1</span>(LF_CORDB, LL_INFO1000, <span><span>"</span>ExitProcessWorkItem proc=%p<span>\n</span><span>"</span></span>, <span>GetProcess</span>());</td>
      </tr>
      <tr>
        <td id="L14361" data-line-number="14361"></td>
        <td id="LC14361">
</td>
      </tr>
      <tr>
        <td id="L14362" data-line-number="14362"></td>
        <td id="LC14362">    <span><span>//</span> This is being called on the RCET.</span></td>
      </tr>
      <tr>
        <td id="L14363" data-line-number="14363"></td>
        <td id="LC14363">    <span><span>//</span> That's the thread that dispatches managed events. Since it's calling us now, we know</span></td>
      </tr>
      <tr>
        <td id="L14364" data-line-number="14364"></td>
        <td id="LC14364">    <span><span>//</span> it can't be dispatching a managed event, and so we don't need to both waiting for it</span></td>
      </tr>
      <tr>
        <td id="L14365" data-line-number="14365"></td>
        <td id="LC14365">
</td>
      </tr>
      <tr>
        <td id="L14366" data-line-number="14366"></td>
        <td id="LC14366">    {</td>
      </tr>
      <tr>
        <td id="L14367" data-line-number="14367"></td>
        <td id="LC14367">        <span><span>//</span> Get the SG lock here to coordinate against any other continues.</span></td>
      </tr>
      <tr>
        <td id="L14368" data-line-number="14368"></td>
        <td id="LC14368">        RSLockHolder <span>ch</span>(<span>GetProcess</span>()-&gt;<span>GetStopGoLock</span>());</td>
      </tr>
      <tr>
        <td id="L14369" data-line-number="14369"></td>
        <td id="LC14369">        RSLockHolder <span>ch2</span>(&amp;(<span>GetProcess</span>()-&gt;<span>m_processMutex</span>));</td>
      </tr>
      <tr>
        <td id="L14370" data-line-number="14370"></td>
        <td id="LC14370">
</td>
      </tr>
      <tr>
        <td id="L14371" data-line-number="14371"></td>
        <td id="LC14371">        <span>LOG</span>((LF_CORDB, LL_INFO1000,<span><span>"</span>W32ET::EP: ExitProcess callback<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14372" data-line-number="14372"></td>
        <td id="LC14372">
</td>
      </tr>
      <tr>
        <td id="L14373" data-line-number="14373"></td>
        <td id="LC14373">        <span><span>//</span> We're synchronized now, so mark the process as such.</span></td>
      </tr>
      <tr>
        <td id="L14374" data-line-number="14374"></td>
        <td id="LC14374">        <span>GetProcess</span>()-&gt;<span>SetSynchronized</span>(<span>true</span>);</td>
      </tr>
      <tr>
        <td id="L14375" data-line-number="14375"></td>
        <td id="LC14375">        <span>GetProcess</span>()-&gt;<span>IncStopCount</span>();</td>
      </tr>
      <tr>
        <td id="L14376" data-line-number="14376"></td>
        <td id="LC14376">
</td>
      </tr>
      <tr>
        <td id="L14377" data-line-number="14377"></td>
        <td id="LC14377">        <span><span>//</span> By the time we release the SG + Process locks here, the process object has been</span></td>
      </tr>
      <tr>
        <td id="L14378" data-line-number="14378"></td>
        <td id="LC14378">        <span><span>//</span> marked as exiting + terminated (by the w32et which queued us). Future attemps to</span></td>
      </tr>
      <tr>
        <td id="L14379" data-line-number="14379"></td>
        <td id="LC14379">        <span><span>//</span> continue should fail, and thus we should remain synchronized.</span></td>
      </tr>
      <tr>
        <td id="L14380" data-line-number="14380"></td>
        <td id="LC14380">    }</td>
      </tr>
      <tr>
        <td id="L14381" data-line-number="14381"></td>
        <td id="LC14381">
</td>
      </tr>
      <tr>
        <td id="L14382" data-line-number="14382"></td>
        <td id="LC14382">
</td>
      </tr>
      <tr>
        <td id="L14383" data-line-number="14383"></td>
        <td id="LC14383">    <span><span>//</span>  Just to be safe, neuter any children before the exit process callback.</span></td>
      </tr>
      <tr>
        <td id="L14384" data-line-number="14384"></td>
        <td id="LC14384">    {</td>
      </tr>
      <tr>
        <td id="L14385" data-line-number="14385"></td>
        <td id="LC14385">        RSLockHolder <span>ch</span>(<span>GetProcess</span>()-&gt;<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L14386" data-line-number="14386"></td>
        <td id="LC14386">
</td>
      </tr>
      <tr>
        <td id="L14387" data-line-number="14387"></td>
        <td id="LC14387">        <span><span>//</span> Release the process.</span></td>
      </tr>
      <tr>
        <td id="L14388" data-line-number="14388"></td>
        <td id="LC14388">        <span>GetProcess</span>()-&gt;<span>NeuterChildren</span>();</td>
      </tr>
      <tr>
        <td id="L14389" data-line-number="14389"></td>
        <td id="LC14389">    }</td>
      </tr>
      <tr>
        <td id="L14390" data-line-number="14390"></td>
        <td id="LC14390">
</td>
      </tr>
      <tr>
        <td id="L14391" data-line-number="14391"></td>
        <td id="LC14391">    RSSmartPtr&lt;Cordb&gt; <span>pCordb</span>(<span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14392" data-line-number="14392"></td>
        <td id="LC14392">
</td>
      </tr>
      <tr>
        <td id="L14393" data-line-number="14393"></td>
        <td id="LC14393">    <span><span>//</span> There is a race condition here where the debuggee process is killed while we are processing a process</span></td>
      </tr>
      <tr>
        <td id="L14394" data-line-number="14394"></td>
        <td id="LC14394">    <span><span>//</span> detach.  We queue the process exit event for the Win32 event thread before queueing the process detach</span></td>
      </tr>
      <tr>
        <td id="L14395" data-line-number="14395"></td>
        <td id="LC14395">    <span><span>//</span> event.  By the time this function is executed, we may have neutered the CordbProcess already as a</span></td>
      </tr>
      <tr>
        <td id="L14396" data-line-number="14396"></td>
        <td id="LC14396">    <span><span>//</span> result of code:CordbProcess::Detach.  Detect that case here under the SG lock.</span></td>
      </tr>
      <tr>
        <td id="L14397" data-line-number="14397"></td>
        <td id="LC14397">    {</td>
      </tr>
      <tr>
        <td id="L14398" data-line-number="14398"></td>
        <td id="LC14398">        RSLockHolder <span>ch</span>(<span>GetProcess</span>()-&gt;<span>GetStopGoLock</span>());</td>
      </tr>
      <tr>
        <td id="L14399" data-line-number="14399"></td>
        <td id="LC14399">        <span>if</span> (!<span>GetProcess</span>()-&gt;<span>IsNeutered</span>())</td>
      </tr>
      <tr>
        <td id="L14400" data-line-number="14400"></td>
        <td id="LC14400">        {</td>
      </tr>
      <tr>
        <td id="L14401" data-line-number="14401"></td>
        <td id="LC14401">            <span>_ASSERTE</span>(<span>GetProcess</span>()-&gt;<span>m_cordb</span> != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14402" data-line-number="14402"></td>
        <td id="LC14402">            pCordb.<span>Assign</span>(<span>GetProcess</span>()-&gt;<span>m_cordb</span>);</td>
      </tr>
      <tr>
        <td id="L14403" data-line-number="14403"></td>
        <td id="LC14403">        }</td>
      </tr>
      <tr>
        <td id="L14404" data-line-number="14404"></td>
        <td id="LC14404">    }</td>
      </tr>
      <tr>
        <td id="L14405" data-line-number="14405"></td>
        <td id="LC14405">
</td>
      </tr>
      <tr>
        <td id="L14406" data-line-number="14406"></td>
        <td id="LC14406">    <span><span>//</span> Move this into Shim?</span></td>
      </tr>
      <tr>
        <td id="L14407" data-line-number="14407"></td>
        <td id="LC14407">
</td>
      </tr>
      <tr>
        <td id="L14408" data-line-number="14408"></td>
        <td id="LC14408">    <span><span>//</span> Invoke the ExitProcess callback. This is very important since the a shell</span></td>
      </tr>
      <tr>
        <td id="L14409" data-line-number="14409"></td>
        <td id="LC14409">    <span><span>//</span> may rely on it for proper shutdown and may hang if they don't get it.</span></td>
      </tr>
      <tr>
        <td id="L14410" data-line-number="14410"></td>
        <td id="LC14410">    <span><span>//</span> We don't expect Cordbg to continue from this (we're certainly not going to wait for it).</span></td>
      </tr>
      <tr>
        <td id="L14411" data-line-number="14411"></td>
        <td id="LC14411">    <span>if</span> ((pCordb != <span>NULL</span>) &amp;&amp; (pCordb-&gt;<span>m_managedCallback</span> != <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L14412" data-line-number="14412"></td>
        <td id="LC14412">    {</td>
      </tr>
      <tr>
        <td id="L14413" data-line-number="14413"></td>
        <td id="LC14413">        <span>PUBLIC_CALLBACK_IN_THIS_SCOPE0_NO_LOCK</span>(<span>GetProcess</span>());</td>
      </tr>
      <tr>
        <td id="L14414" data-line-number="14414"></td>
        <td id="LC14414">        pCordb-&gt;<span>m_managedCallback</span>-&gt;<span>ExitProcess</span>(<span>GetProcess</span>());</td>
      </tr>
      <tr>
        <td id="L14415" data-line-number="14415"></td>
        <td id="LC14415">    }</td>
      </tr>
      <tr>
        <td id="L14416" data-line-number="14416"></td>
        <td id="LC14416">
</td>
      </tr>
      <tr>
        <td id="L14417" data-line-number="14417"></td>
        <td id="LC14417">    <span><span>//</span> This CordbProcess object now has no reservations against a client calling ICorDebug::Terminate.</span></td>
      </tr>
      <tr>
        <td id="L14418" data-line-number="14418"></td>
        <td id="LC14418">    <span><span>//</span> That call may race against the CordbProcess::Neuter below, but since we already neutered the children,</span></td>
      </tr>
      <tr>
        <td id="L14419" data-line-number="14419"></td>
        <td id="LC14419">    <span><span>//</span> that neuter call will not do anything interesting that will conflict with Terminate.</span></td>
      </tr>
      <tr>
        <td id="L14420" data-line-number="14420"></td>
        <td id="LC14420">
</td>
      </tr>
      <tr>
        <td id="L14421" data-line-number="14421"></td>
        <td id="LC14421">    <span>LOG</span>((LF_CORDB, LL_INFO1000,<span><span>"</span>W32ET::EP: returned from ExitProcess callback<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14422" data-line-number="14422"></td>
        <td id="LC14422">
</td>
      </tr>
      <tr>
        <td id="L14423" data-line-number="14423"></td>
        <td id="LC14423">    {</td>
      </tr>
      <tr>
        <td id="L14424" data-line-number="14424"></td>
        <td id="LC14424">        RSLockHolder <span>ch</span>(<span>GetProcess</span>()-&gt;<span>GetStopGoLock</span>());</td>
      </tr>
      <tr>
        <td id="L14425" data-line-number="14425"></td>
        <td id="LC14425">
</td>
      </tr>
      <tr>
        <td id="L14426" data-line-number="14426"></td>
        <td id="LC14426">        <span><span>//</span> Release the process.</span></td>
      </tr>
      <tr>
        <td id="L14427" data-line-number="14427"></td>
        <td id="LC14427">        <span>GetProcess</span>()-&gt;<span>Neuter</span>();</td>
      </tr>
      <tr>
        <td id="L14428" data-line-number="14428"></td>
        <td id="LC14428">    }</td>
      </tr>
      <tr>
        <td id="L14429" data-line-number="14429"></td>
        <td id="LC14429">
</td>
      </tr>
      <tr>
        <td id="L14430" data-line-number="14430"></td>
        <td id="LC14430">    <span><span>//</span> Our dtor will release the Process object.</span></td>
      </tr>
      <tr>
        <td id="L14431" data-line-number="14431"></td>
        <td id="LC14431">    <span><span>//</span> This may be the final release on the process.</span></td>
      </tr>
      <tr>
        <td id="L14432" data-line-number="14432"></td>
        <td id="LC14432">}</td>
      </tr>
      <tr>
        <td id="L14433" data-line-number="14433"></td>
        <td id="LC14433">
</td>
      </tr>
      <tr>
        <td id="L14434" data-line-number="14434"></td>
        <td id="LC14434">
</td>
      </tr>
      <tr>
        <td id="L14435" data-line-number="14435"></td>
        <td id="LC14435"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L14436" data-line-number="14436"></td>
        <td id="LC14436"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14437" data-line-number="14437"></td>
        <td id="LC14437"><span><span>//</span> Handles process exiting and detach cases</span></td>
      </tr>
      <tr>
        <td id="L14438" data-line-number="14438"></td>
        <td id="LC14438"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14439" data-line-number="14439"></td>
        <td id="LC14439"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L14440" data-line-number="14440"></td>
        <td id="LC14440"><span><span>//</span>    fDetach - true if detaching, false if process is exiting.</span></td>
      </tr>
      <tr>
        <td id="L14441" data-line-number="14441"></td>
        <td id="LC14441"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14442" data-line-number="14442"></td>
        <td id="LC14442"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L14443" data-line-number="14443"></td>
        <td id="LC14443"><span><span>//</span>    The type of the next argument in the signature,</span></td>
      </tr>
      <tr>
        <td id="L14444" data-line-number="14444"></td>
        <td id="LC14444"><span><span>//</span>    normalized.</span></td>
      </tr>
      <tr>
        <td id="L14445" data-line-number="14445"></td>
        <td id="LC14445"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14446" data-line-number="14446"></td>
        <td id="LC14446"><span><span>//</span> Assumptions:</span></td>
      </tr>
      <tr>
        <td id="L14447" data-line-number="14447"></td>
        <td id="LC14447"><span><span>//</span>    On exit, the process has already exited and we detected this by either an EXIT_PROCESS</span></td>
      </tr>
      <tr>
        <td id="L14448" data-line-number="14448"></td>
        <td id="LC14448"><span><span>//</span>    native debug event, or by waiting on the process handle.</span></td>
      </tr>
      <tr>
        <td id="L14449" data-line-number="14449"></td>
        <td id="LC14449"><span><span>//</span>    On detach, the process is stil live.</span></td>
      </tr>
      <tr>
        <td id="L14450" data-line-number="14450"></td>
        <td id="LC14450"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14451" data-line-number="14451"></td>
        <td id="LC14451"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L14452" data-line-number="14452"></td>
        <td id="LC14452"><span><span>//</span>    ExitProcess is called when a process exits or detaches.</span></td>
      </tr>
      <tr>
        <td id="L14453" data-line-number="14453"></td>
        <td id="LC14453"><span><span>//</span>    This does our final cleanup and removes the process from our wait sets.</span></td>
      </tr>
      <tr>
        <td id="L14454" data-line-number="14454"></td>
        <td id="LC14454"><span><span>//</span>    We're either here because we're detaching (fDetach == TRUE), or because the process has really exited,</span></td>
      </tr>
      <tr>
        <td id="L14455" data-line-number="14455"></td>
        <td id="LC14455"><span><span>//</span>    and we're doing shutdown logic.</span></td>
      </tr>
      <tr>
        <td id="L14456" data-line-number="14456"></td>
        <td id="LC14456"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14457" data-line-number="14457"></td>
        <td id="LC14457"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L14458" data-line-number="14458"></td>
        <td id="LC14458"><span>void</span> <span>CordbWin32EventThread::ExitProcess</span>(<span>bool</span> <span>fDetach</span>)</td>
      </tr>
      <tr>
        <td id="L14459" data-line-number="14459"></td>
        <td id="LC14459">{</td>
      </tr>
      <tr>
        <td id="L14460" data-line-number="14460"></td>
        <td id="LC14460">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L14461" data-line-number="14461"></td>
        <td id="LC14461">
</td>
      </tr>
      <tr>
        <td id="L14462" data-line-number="14462"></td>
        <td id="LC14462">    <span><span>//</span> Consider the following when you're modifying this function:</span></td>
      </tr>
      <tr>
        <td id="L14463" data-line-number="14463"></td>
        <td id="LC14463">    <span><span>//</span> - The OS can kill the debuggee at any time.</span></td>
      </tr>
      <tr>
        <td id="L14464" data-line-number="14464"></td>
        <td id="LC14464">    <span><span>//</span> - ExitProcess can race with detach.</span></td>
      </tr>
      <tr>
        <td id="L14465" data-line-number="14465"></td>
        <td id="LC14465">
</td>
      </tr>
      <tr>
        <td id="L14466" data-line-number="14466"></td>
        <td id="LC14466">    <span>LOG</span>((LF_CORDB, LL_INFO1000,<span><span>"</span>W32ET::EP: begin ExitProcess, detach=%d<span>\n</span><span>"</span></span>, <span>fDetach</span>));</td>
      </tr>
      <tr>
        <td id="L14467" data-line-number="14467"></td>
        <td id="LC14467">
</td>
      </tr>
      <tr>
        <td id="L14468" data-line-number="14468"></td>
        <td id="LC14468">
</td>
      </tr>
      <tr>
        <td id="L14469" data-line-number="14469"></td>
        <td id="LC14469">    <span><span>//</span> For the Mac remote debugging transport, DebugActiveProcessStop() is a nop.  The transport will be</span></td>
      </tr>
      <tr>
        <td id="L14470" data-line-number="14470"></td>
        <td id="LC14470">    <span><span>//</span> shut down later when we neuter the CordbProcess.</span></td>
      </tr>
      <tr>
        <td id="L14471" data-line-number="14471"></td>
        <td id="LC14471">#<span>if</span> !defined(FEATURE_DBGIPC_TRANSPORT_DI)</td>
      </tr>
      <tr>
        <td id="L14472" data-line-number="14472"></td>
        <td id="LC14472">    <span><span>//</span> @dbgtodo shim: this is a primitive workaround for interop-detach</span></td>
      </tr>
      <tr>
        <td id="L14473" data-line-number="14473"></td>
        <td id="LC14473">    <span><span>//</span> Eventually, the Debugger owns the detach pipeline, so this won't be necessary.</span></td>
      </tr>
      <tr>
        <td id="L14474" data-line-number="14474"></td>
        <td id="LC14474">    <span>if</span> (<span>fDetach</span> &amp;&amp; (m_pProcess != <span>NULL</span>))</td>
      </tr>
      <tr>
        <td id="L14475" data-line-number="14475"></td>
        <td id="LC14475">    {</td>
      </tr>
      <tr>
        <td id="L14476" data-line-number="14476"></td>
        <td id="LC14476">        HRESULT hr = m_pNativePipeline-&gt;<span>DebugActiveProcessStop</span>(m_pProcess-&gt;<span>GetProcessDescriptor</span>()-&gt;<span>m_Pid</span>);</td>
      </tr>
      <tr>
        <td id="L14477" data-line-number="14477"></td>
        <td id="LC14477">
</td>
      </tr>
      <tr>
        <td id="L14478" data-line-number="14478"></td>
        <td id="LC14478">        <span><span>//</span> We don't expect detach to fail (we check earlier for common conditions that</span></td>
      </tr>
      <tr>
        <td id="L14479" data-line-number="14479"></td>
        <td id="LC14479">        <span><span>//</span> may cause it to fail)</span></td>
      </tr>
      <tr>
        <td id="L14480" data-line-number="14480"></td>
        <td id="LC14480">        <span>SIMPLIFYING_ASSUMPTION</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L14481" data-line-number="14481"></td>
        <td id="LC14481">        <span>if</span>( <span>FAILED</span>(hr) )</td>
      </tr>
      <tr>
        <td id="L14482" data-line-number="14482"></td>
        <td id="LC14482">        {</td>
      </tr>
      <tr>
        <td id="L14483" data-line-number="14483"></td>
        <td id="LC14483">            m_actionResult = hr;</td>
      </tr>
      <tr>
        <td id="L14484" data-line-number="14484"></td>
        <td id="LC14484">            <span>SetEvent</span>(m_actionTakenEvent);</td>
      </tr>
      <tr>
        <td id="L14485" data-line-number="14485"></td>
        <td id="LC14485">            <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L14486" data-line-number="14486"></td>
        <td id="LC14486">        }</td>
      </tr>
      <tr>
        <td id="L14487" data-line-number="14487"></td>
        <td id="LC14487">    }</td>
      </tr>
      <tr>
        <td id="L14488" data-line-number="14488"></td>
        <td id="LC14488">#<span>endif</span> <span><span>//</span> !FEATURE_DBGIPC_TRANSPORT_DI</span></td>
      </tr>
      <tr>
        <td id="L14489" data-line-number="14489"></td>
        <td id="LC14489">
</td>
      </tr>
      <tr>
        <td id="L14490" data-line-number="14490"></td>
        <td id="LC14490">
</td>
      </tr>
      <tr>
        <td id="L14491" data-line-number="14491"></td>
        <td id="LC14491">    <span><span>//</span> We don't really care if we're on the Win32 thread or not here. We just want to be sure that</span></td>
      </tr>
      <tr>
        <td id="L14492" data-line-number="14492"></td>
        <td id="LC14492">    <span><span>//</span> the LS Exit case and the Detach case both occur on the same thread. This makes it much easier</span></td>
      </tr>
      <tr>
        <td id="L14493" data-line-number="14493"></td>
        <td id="LC14493">    <span><span>//</span> to assert that if we exit while detaching, EP is only called once.</span></td>
      </tr>
      <tr>
        <td id="L14494" data-line-number="14494"></td>
        <td id="LC14494">    <span><span>//</span> If we ever decide to make the RCET listen on the LS process handle for EP(exit), then we should also</span></td>
      </tr>
      <tr>
        <td id="L14495" data-line-number="14495"></td>
        <td id="LC14495">    <span><span>//</span> make the EP(detach) handled on the RCET (via DoFavor() ).</span></td>
      </tr>
      <tr>
        <td id="L14496" data-line-number="14496"></td>
        <td id="LC14496">    <span>_ASSERTE</span>(<span>IsWin32EventThread</span>());</td>
      </tr>
      <tr>
        <td id="L14497" data-line-number="14497"></td>
        <td id="LC14497">
</td>
      </tr>
      <tr>
        <td id="L14498" data-line-number="14498"></td>
        <td id="LC14498">    <span><span>//</span> So either the Exit case or Detach case must happen first.</span></td>
      </tr>
      <tr>
        <td id="L14499" data-line-number="14499"></td>
        <td id="LC14499">    <span><span>//</span> 1) If Detach first, then LS process is removed from wait set and so EP(Exit) will never happen</span></td>
      </tr>
      <tr>
        <td id="L14500" data-line-number="14500"></td>
        <td id="LC14500">    <span><span>//</span>    because we check wait set after returning from EP(Detach).</span></td>
      </tr>
      <tr>
        <td id="L14501" data-line-number="14501"></td>
        <td id="LC14501">    <span><span>//</span> 2) If Exit is first, m_pProcess gets set=NULL. EP(detach) will still get called, so explicitly check that.</span></td>
      </tr>
      <tr>
        <td id="L14502" data-line-number="14502"></td>
        <td id="LC14502">    <span>if</span> (<span>fDetach</span> &amp;&amp; ((m_pProcess == <span>NULL</span>) || m_pProcess-&gt;<span>m_terminated</span>))</td>
      </tr>
      <tr>
        <td id="L14503" data-line-number="14503"></td>
        <td id="LC14503">    {</td>
      </tr>
      <tr>
        <td id="L14504" data-line-number="14504"></td>
        <td id="LC14504">        <span><span>//</span> m_terminated is only set after the LS exits.</span></td>
      </tr>
      <tr>
        <td id="L14505" data-line-number="14505"></td>
        <td id="LC14505">        <span><span>//</span> So the only way (fDetach &amp;&amp; m_terminated) is true is if the LS exited while detaching. In that case</span></td>
      </tr>
      <tr>
        <td id="L14506" data-line-number="14506"></td>
        <td id="LC14506">        <span><span>//</span> we already called EP(exit) and we don't want to call it again for EP(detach). So return here.</span></td>
      </tr>
      <tr>
        <td id="L14507" data-line-number="14507"></td>
        <td id="LC14507">        <span>LOG</span>((LF_CORDB, LL_INFO1000,<span><span>"</span>W32ET::EP: In EP(detach), but EP(exit) already called. Early failure<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14508" data-line-number="14508"></td>
        <td id="LC14508">
</td>
      </tr>
      <tr>
        <td id="L14509" data-line-number="14509"></td>
        <td id="LC14509">        m_actionResult = CORDBG_E_PROCESS_TERMINATED;</td>
      </tr>
      <tr>
        <td id="L14510" data-line-number="14510"></td>
        <td id="LC14510">        <span>SetEvent</span>(m_actionTakenEvent);</td>
      </tr>
      <tr>
        <td id="L14511" data-line-number="14511"></td>
        <td id="LC14511">
</td>
      </tr>
      <tr>
        <td id="L14512" data-line-number="14512"></td>
        <td id="LC14512">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L14513" data-line-number="14513"></td>
        <td id="LC14513">    }</td>
      </tr>
      <tr>
        <td id="L14514" data-line-number="14514"></td>
        <td id="LC14514">
</td>
      </tr>
      <tr>
        <td id="L14515" data-line-number="14515"></td>
        <td id="LC14515">    <span><span>//</span> We null m_pProcess at the end here, so</span></td>
      </tr>
      <tr>
        <td id="L14516" data-line-number="14516"></td>
        <td id="LC14516">    <span><span>//</span> Only way we could get here w/ null process is if we're called twice. We can only be called</span></td>
      </tr>
      <tr>
        <td id="L14517" data-line-number="14517"></td>
        <td id="LC14517">    <span><span>//</span> by detach or exit. Can't detach twice, can't exit twice, so must have been one of each.</span></td>
      </tr>
      <tr>
        <td id="L14518" data-line-number="14518"></td>
        <td id="LC14518">    <span><span>//</span> If exit is first, we got removed from the wait set, so 2nd call must be detach and we'd catch</span></td>
      </tr>
      <tr>
        <td id="L14519" data-line-number="14519"></td>
        <td id="LC14519">    <span><span>//</span> that above. If detach is first, we'd get removed from the wait set and so exit would never happen.</span></td>
      </tr>
      <tr>
        <td id="L14520" data-line-number="14520"></td>
        <td id="LC14520">    <span>_ASSERTE</span>(m_pProcess != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14521" data-line-number="14521"></td>
        <td id="LC14521">    <span>_ASSERTE</span>(!m_pProcess-&gt;<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L14522" data-line-number="14522"></td>
        <td id="LC14522">
</td>
      </tr>
      <tr>
        <td id="L14523" data-line-number="14523"></td>
        <td id="LC14523">
</td>
      </tr>
      <tr>
        <td id="L14524" data-line-number="14524"></td>
        <td id="LC14524">
</td>
      </tr>
      <tr>
        <td id="L14525" data-line-number="14525"></td>
        <td id="LC14525">    <span><span>//</span> Mark the process teminated. After this, the RCET will never call FlushQueuedEvents. It will</span></td>
      </tr>
      <tr>
        <td id="L14526" data-line-number="14526"></td>
        <td id="LC14526">    <span><span>//</span> ignore all events it receives (including a SyncComplete) and the RCET also does not listen</span></td>
      </tr>
      <tr>
        <td id="L14527" data-line-number="14527"></td>
        <td id="LC14527">    <span><span>//</span> to terminated processes (so ProcessStateChange() won't cause a FQE either).</span></td>
      </tr>
      <tr>
        <td id="L14528" data-line-number="14528"></td>
        <td id="LC14528">    m_pProcess-&gt;<span>Terminating</span>(<span>fDetach</span>);</td>
      </tr>
      <tr>
        <td id="L14529" data-line-number="14529"></td>
        <td id="LC14529">
</td>
      </tr>
      <tr>
        <td id="L14530" data-line-number="14530"></td>
        <td id="LC14530">    <span><span>//</span> Take care of the race where the process exits right after the user calls Continue() from the last</span></td>
      </tr>
      <tr>
        <td id="L14531" data-line-number="14531"></td>
        <td id="LC14531">    <span><span>//</span> managed event but before the handler has actually returned.</span></td>
      </tr>
      <tr>
        <td id="L14532" data-line-number="14532"></td>
        <td id="LC14532">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14533" data-line-number="14533"></td>
        <td id="LC14533">    <span><span>//</span> Also, To get through this lock means that either:</span></td>
      </tr>
      <tr>
        <td id="L14534" data-line-number="14534"></td>
        <td id="LC14534">    <span><span>//</span> 1. FlushQueuedEvents is not currently executing and no one will call FQE.</span></td>
      </tr>
      <tr>
        <td id="L14535" data-line-number="14535"></td>
        <td id="LC14535">    <span><span>//</span> 2. FQE is exiting but is in the middle of a callback (so AreDispatchingEvent = true)</span></td>
      </tr>
      <tr>
        <td id="L14536" data-line-number="14536"></td>
        <td id="LC14536">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14537" data-line-number="14537"></td>
        <td id="LC14537">    m_pProcess-&gt;<span>Lock</span>();</td>
      </tr>
      <tr>
        <td id="L14538" data-line-number="14538"></td>
        <td id="LC14538">
</td>
      </tr>
      <tr>
        <td id="L14539" data-line-number="14539"></td>
        <td id="LC14539">    m_pProcess-&gt;<span>m_exiting</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L14540" data-line-number="14540"></td>
        <td id="LC14540">
</td>
      </tr>
      <tr>
        <td id="L14541" data-line-number="14541"></td>
        <td id="LC14541">    <span>if</span> (<span>fDetach</span>)</td>
      </tr>
      <tr>
        <td id="L14542" data-line-number="14542"></td>
        <td id="LC14542">    {</td>
      </tr>
      <tr>
        <td id="L14543" data-line-number="14543"></td>
        <td id="LC14543">        m_pProcess-&gt;<span>SetSynchronized</span>(<span>false</span>);</td>
      </tr>
      <tr>
        <td id="L14544" data-line-number="14544"></td>
        <td id="LC14544">    }</td>
      </tr>
      <tr>
        <td id="L14545" data-line-number="14545"></td>
        <td id="LC14545">
</td>
      </tr>
      <tr>
        <td id="L14546" data-line-number="14546"></td>
        <td id="LC14546">    <span><span>//</span> If we are exiting, we *must* dispatch the ExitProcess callback, but we will delete all the events</span></td>
      </tr>
      <tr>
        <td id="L14547" data-line-number="14547"></td>
        <td id="LC14547">    <span><span>//</span> in the queue and not bother dispatching anything else. If (and only if) we are currently dispatching</span></td>
      </tr>
      <tr>
        <td id="L14548" data-line-number="14548"></td>
        <td id="LC14548">    <span><span>//</span> an event, then we will wait while that event is finished before invoking ExitProcess.</span></td>
      </tr>
      <tr>
        <td id="L14549" data-line-number="14549"></td>
        <td id="LC14549">    <span><span>//</span> (Note that a dispatched event has already been removed from the queue)</span></td>
      </tr>
      <tr>
        <td id="L14550" data-line-number="14550"></td>
        <td id="LC14550">
</td>
      </tr>
      <tr>
        <td id="L14551" data-line-number="14551"></td>
        <td id="LC14551">    <span><span>//</span> Remove the process from the global list of processes.</span></td>
      </tr>
      <tr>
        <td id="L14552" data-line-number="14552"></td>
        <td id="LC14552">    m_cordb-&gt;<span>RemoveProcess</span>(m_pProcess);</td>
      </tr>
      <tr>
        <td id="L14553" data-line-number="14553"></td>
        <td id="LC14553">
</td>
      </tr>
      <tr>
        <td id="L14554" data-line-number="14554"></td>
        <td id="LC14554">    <span>if</span> (<span>fDetach</span>)</td>
      </tr>
      <tr>
        <td id="L14555" data-line-number="14555"></td>
        <td id="LC14555">    {</td>
      </tr>
      <tr>
        <td id="L14556" data-line-number="14556"></td>
        <td id="LC14556">        <span><span>//</span> Signal the hr to the caller.</span></td>
      </tr>
      <tr>
        <td id="L14557" data-line-number="14557"></td>
        <td id="LC14557">        <span>LOG</span>((LF_CORDB, LL_INFO1000,<span><span>"</span>W32ET::EP: Detach: send result back!<span>\n</span><span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14558" data-line-number="14558"></td>
        <td id="LC14558">
</td>
      </tr>
      <tr>
        <td id="L14559" data-line-number="14559"></td>
        <td id="LC14559">        m_actionResult = S_OK;</td>
      </tr>
      <tr>
        <td id="L14560" data-line-number="14560"></td>
        <td id="LC14560">        <span>SetEvent</span>(m_actionTakenEvent);</td>
      </tr>
      <tr>
        <td id="L14561" data-line-number="14561"></td>
        <td id="LC14561">    }</td>
      </tr>
      <tr>
        <td id="L14562" data-line-number="14562"></td>
        <td id="LC14562">
</td>
      </tr>
      <tr>
        <td id="L14563" data-line-number="14563"></td>
        <td id="LC14563">    m_pProcess-&gt;<span>Unlock</span>();</td>
      </tr>
      <tr>
        <td id="L14564" data-line-number="14564"></td>
        <td id="LC14564">
</td>
      </tr>
      <tr>
        <td id="L14565" data-line-number="14565"></td>
        <td id="LC14565">    <span><span>//</span> Delete all queued events</span></td>
      </tr>
      <tr>
        <td id="L14566" data-line-number="14566"></td>
        <td id="LC14566">    m_pProcess-&gt;<span>DeleteQueuedEvents</span>();</td>
      </tr>
      <tr>
        <td id="L14567" data-line-number="14567"></td>
        <td id="LC14567">
</td>
      </tr>
      <tr>
        <td id="L14568" data-line-number="14568"></td>
        <td id="LC14568">
</td>
      </tr>
      <tr>
        <td id="L14569" data-line-number="14569"></td>
        <td id="LC14569">    <span><span>//</span> If we're detaching, then the Detach already neutered everybody, so nothing here.</span></td>
      </tr>
      <tr>
        <td id="L14570" data-line-number="14570"></td>
        <td id="LC14570">    <span><span>//</span> If we're exiting, then we still need to neuter things, but we can't do that on this thread,</span></td>
      </tr>
      <tr>
        <td id="L14571" data-line-number="14571"></td>
        <td id="LC14571">    <span><span>//</span> so we queue it. We also need to dispatch an exit process callback. We'll queue that onto the RCET</span></td>
      </tr>
      <tr>
        <td id="L14572" data-line-number="14572"></td>
        <td id="LC14572">    <span><span>//</span> and dispatch it inband w/the other callbacks.</span></td>
      </tr>
      <tr>
        <td id="L14573" data-line-number="14573"></td>
        <td id="LC14573">    <span>if</span> (!<span>fDetach</span>)</td>
      </tr>
      <tr>
        <td id="L14574" data-line-number="14574"></td>
        <td id="LC14574">    {</td>
      </tr>
      <tr>
        <td id="L14575" data-line-number="14575"></td>
        <td id="LC14575">#<span>ifdef</span> FEATURE_PAL</td>
      </tr>
      <tr>
        <td id="L14576" data-line-number="14576"></td>
        <td id="LC14576">        <span><span>//</span> Cleanup the transport pipe and semaphore files that might be left by the target (LS) process.</span></td>
      </tr>
      <tr>
        <td id="L14577" data-line-number="14577"></td>
        <td id="LC14577">        m_pNativePipeline-&gt;<span>CleanupTargetProcess</span>();</td>
      </tr>
      <tr>
        <td id="L14578" data-line-number="14578"></td>
        <td id="LC14578">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L14579" data-line-number="14579"></td>
        <td id="LC14579">        ExitProcessWorkItem * pItem = <span>new</span> (nothrow) <span>ExitProcessWorkItem</span>(m_pProcess);</td>
      </tr>
      <tr>
        <td id="L14580" data-line-number="14580"></td>
        <td id="LC14580">        <span>if</span> (pItem != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14581" data-line-number="14581"></td>
        <td id="LC14581">        {</td>
      </tr>
      <tr>
        <td id="L14582" data-line-number="14582"></td>
        <td id="LC14582">            m_cordb-&gt;<span>m_rcEventThread</span>-&gt;<span>QueueAsyncWorkItem</span>(pItem);</td>
      </tr>
      <tr>
        <td id="L14583" data-line-number="14583"></td>
        <td id="LC14583">        }</td>
      </tr>
      <tr>
        <td id="L14584" data-line-number="14584"></td>
        <td id="LC14584">    }</td>
      </tr>
      <tr>
        <td id="L14585" data-line-number="14585"></td>
        <td id="LC14585">
</td>
      </tr>
      <tr>
        <td id="L14586" data-line-number="14586"></td>
        <td id="LC14586">    <span><span>//</span> This will remove the process from our wait lists (so that we don't send multiple ExitProcess events).</span></td>
      </tr>
      <tr>
        <td id="L14587" data-line-number="14587"></td>
        <td id="LC14587">    m_pProcess.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L14588" data-line-number="14588"></td>
        <td id="LC14588">}</td>
      </tr>
      <tr>
        <td id="L14589" data-line-number="14589"></td>
        <td id="LC14589">
</td>
      </tr>
      <tr>
        <td id="L14590" data-line-number="14590"></td>
        <td id="LC14590">
</td>
      </tr>
      <tr>
        <td id="L14591" data-line-number="14591"></td>
        <td id="LC14591"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14592" data-line-number="14592"></td>
        <td id="LC14592"><span><span>//</span> Start actually creates and starts the thread.</span></td>
      </tr>
      <tr>
        <td id="L14593" data-line-number="14593"></td>
        <td id="LC14593"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14594" data-line-number="14594"></td>
        <td id="LC14594">HRESULT <span>CordbWin32EventThread::Start</span>()</td>
      </tr>
      <tr>
        <td id="L14595" data-line-number="14595"></td>
        <td id="LC14595">{</td>
      </tr>
      <tr>
        <td id="L14596" data-line-number="14596"></td>
        <td id="LC14596">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L14597" data-line-number="14597"></td>
        <td id="LC14597">    <span>if</span> (m_threadControlEvent == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14598" data-line-number="14598"></td>
        <td id="LC14598">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L14599" data-line-number="14599"></td>
        <td id="LC14599">
</td>
      </tr>
      <tr>
        <td id="L14600" data-line-number="14600"></td>
        <td id="LC14600">    <span><span>//</span> Create the thread suspended to make sure that m_threadId is set</span></td>
      </tr>
      <tr>
        <td id="L14601" data-line-number="14601"></td>
        <td id="LC14601">    <span><span>//</span> before CordbWin32EventThread::ThreadProc runs</span></td>
      </tr>
      <tr>
        <td id="L14602" data-line-number="14602"></td>
        <td id="LC14602">    <span><span>//</span> Stack size = 0x80000 = 512KB</span></td>
      </tr>
      <tr>
        <td id="L14603" data-line-number="14603"></td>
        <td id="LC14603">    m_thread = <span>CreateThread</span>(<span>NULL</span>, <span>0x80000</span>, &amp;CordbWin32EventThread::ThreadProc,</td>
      </tr>
      <tr>
        <td id="L14604" data-line-number="14604"></td>
        <td id="LC14604">                            (LPVOID) <span>this</span>, CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION, &amp;m_threadId);</td>
      </tr>
      <tr>
        <td id="L14605" data-line-number="14605"></td>
        <td id="LC14605">
</td>
      </tr>
      <tr>
        <td id="L14606" data-line-number="14606"></td>
        <td id="LC14606">    <span>if</span> (m_thread == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14607" data-line-number="14607"></td>
        <td id="LC14607">        <span>return</span> <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L14608" data-line-number="14608"></td>
        <td id="LC14608">
</td>
      </tr>
      <tr>
        <td id="L14609" data-line-number="14609"></td>
        <td id="LC14609">    DWORD succ = <span>ResumeThread</span>(m_thread);</td>
      </tr>
      <tr>
        <td id="L14610" data-line-number="14610"></td>
        <td id="LC14610">    <span>if</span> (succ == (DWORD)-<span>1</span>)</td>
      </tr>
      <tr>
        <td id="L14611" data-line-number="14611"></td>
        <td id="LC14611">        <span>return</span> <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L14612" data-line-number="14612"></td>
        <td id="LC14612">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L14613" data-line-number="14613"></td>
        <td id="LC14613">}</td>
      </tr>
      <tr>
        <td id="L14614" data-line-number="14614"></td>
        <td id="LC14614">
</td>
      </tr>
      <tr>
        <td id="L14615" data-line-number="14615"></td>
        <td id="LC14615">
</td>
      </tr>
      <tr>
        <td id="L14616" data-line-number="14616"></td>
        <td id="LC14616"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14617" data-line-number="14617"></td>
        <td id="LC14617"><span><span>//</span> Stop causes the thread to stop receiving events and exit. It</span></td>
      </tr>
      <tr>
        <td id="L14618" data-line-number="14618"></td>
        <td id="LC14618"><span><span>//</span> waits for it to exit before returning.</span></td>
      </tr>
      <tr>
        <td id="L14619" data-line-number="14619"></td>
        <td id="LC14619"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14620" data-line-number="14620"></td>
        <td id="LC14620">HRESULT <span>CordbWin32EventThread::Stop</span>()</td>
      </tr>
      <tr>
        <td id="L14621" data-line-number="14621"></td>
        <td id="LC14621">{</td>
      </tr>
      <tr>
        <td id="L14622" data-line-number="14622"></td>
        <td id="LC14622">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L14623" data-line-number="14623"></td>
        <td id="LC14623">
</td>
      </tr>
      <tr>
        <td id="L14624" data-line-number="14624"></td>
        <td id="LC14624">    <span><span>//</span> m_pProcess may be NULL from CordbWin32EventThread::ExitProcess</span></td>
      </tr>
      <tr>
        <td id="L14625" data-line-number="14625"></td>
        <td id="LC14625">
</td>
      </tr>
      <tr>
        <td id="L14626" data-line-number="14626"></td>
        <td id="LC14626">    <span><span>//</span> Can't block on W32ET while holding the process-lock since the W32ET may need that to exit.</span></td>
      </tr>
      <tr>
        <td id="L14627" data-line-number="14627"></td>
        <td id="LC14627">    <span><span>//</span> But since m_pProcess may be null, we can't enforce that.</span></td>
      </tr>
      <tr>
        <td id="L14628" data-line-number="14628"></td>
        <td id="LC14628">
</td>
      </tr>
      <tr>
        <td id="L14629" data-line-number="14629"></td>
        <td id="LC14629">    <span>if</span> (m_thread != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14630" data-line-number="14630"></td>
        <td id="LC14630">    {</td>
      </tr>
      <tr>
        <td id="L14631" data-line-number="14631"></td>
        <td id="LC14631">        <span>LockSendToWin32EventThreadMutex</span>();</td>
      </tr>
      <tr>
        <td id="L14632" data-line-number="14632"></td>
        <td id="LC14632">        m_action = W32ETA_NONE;</td>
      </tr>
      <tr>
        <td id="L14633" data-line-number="14633"></td>
        <td id="LC14633">        m_run = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L14634" data-line-number="14634"></td>
        <td id="LC14634">
</td>
      </tr>
      <tr>
        <td id="L14635" data-line-number="14635"></td>
        <td id="LC14635">        <span>SetEvent</span>(m_threadControlEvent);</td>
      </tr>
      <tr>
        <td id="L14636" data-line-number="14636"></td>
        <td id="LC14636">        <span>UnlockSendToWin32EventThreadMutex</span>();</td>
      </tr>
      <tr>
        <td id="L14637" data-line-number="14637"></td>
        <td id="LC14637">
</td>
      </tr>
      <tr>
        <td id="L14638" data-line-number="14638"></td>
        <td id="LC14638">        DWORD ret = <span>WaitForSingleObject</span>(m_thread, INFINITE);</td>
      </tr>
      <tr>
        <td id="L14639" data-line-number="14639"></td>
        <td id="LC14639">
</td>
      </tr>
      <tr>
        <td id="L14640" data-line-number="14640"></td>
        <td id="LC14640">        <span>if</span> (ret != WAIT_OBJECT_0)</td>
      </tr>
      <tr>
        <td id="L14641" data-line-number="14641"></td>
        <td id="LC14641">            hr = <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L14642" data-line-number="14642"></td>
        <td id="LC14642">    }</td>
      </tr>
      <tr>
        <td id="L14643" data-line-number="14643"></td>
        <td id="LC14643">
</td>
      </tr>
      <tr>
        <td id="L14644" data-line-number="14644"></td>
        <td id="LC14644">    m_pProcess.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L14645" data-line-number="14645"></td>
        <td id="LC14645">    m_cordb.<span>Clear</span>();</td>
      </tr>
      <tr>
        <td id="L14646" data-line-number="14646"></td>
        <td id="LC14646">
</td>
      </tr>
      <tr>
        <td id="L14647" data-line-number="14647"></td>
        <td id="LC14647">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L14648" data-line-number="14648"></td>
        <td id="LC14648">}</td>
      </tr>
      <tr>
        <td id="L14649" data-line-number="14649"></td>
        <td id="LC14649">
</td>
      </tr>
      <tr>
        <td id="L14650" data-line-number="14650"></td>
        <td id="LC14650">
</td>
      </tr>
      <tr>
        <td id="L14651" data-line-number="14651"></td>
        <td id="LC14651">
</td>
      </tr>
      <tr>
        <td id="L14652" data-line-number="14652"></td>
        <td id="LC14652">
</td>
      </tr>
      <tr>
        <td id="L14653" data-line-number="14653"></td>
        <td id="LC14653">
</td>
      </tr>
      <tr>
        <td id="L14654" data-line-number="14654"></td>
        <td id="LC14654">
</td>
      </tr>
      <tr>
        <td id="L14655" data-line-number="14655"></td>
        <td id="LC14655">
</td>
      </tr>
      <tr>
        <td id="L14656" data-line-number="14656"></td>
        <td id="LC14656">
</td>
      </tr>
      <tr>
        <td id="L14657" data-line-number="14657"></td>
        <td id="LC14657"><span><span>//</span> Allocate a buffer of cbBuffer bytes in the target.</span></td>
      </tr>
      <tr>
        <td id="L14658" data-line-number="14658"></td>
        <td id="LC14658"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14659" data-line-number="14659"></td>
        <td id="LC14659"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L14660" data-line-number="14660"></td>
        <td id="LC14660"><span><span>//</span>     cbBuffer - count of bytes for the buffer.</span></td>
      </tr>
      <tr>
        <td id="L14661" data-line-number="14661"></td>
        <td id="LC14661"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14662" data-line-number="14662"></td>
        <td id="LC14662"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L14663" data-line-number="14663"></td>
        <td id="LC14663"><span><span>//</span>     a TargetBuffer describing the new memory region in the target.</span></td>
      </tr>
      <tr>
        <td id="L14664" data-line-number="14664"></td>
        <td id="LC14664"><span><span>//</span>     Throws on error.</span></td>
      </tr>
      <tr>
        <td id="L14665" data-line-number="14665"></td>
        <td id="LC14665">TargetBuffer <span>CordbProcess::GetRemoteBuffer</span>(ULONG cbBuffer)</td>
      </tr>
      <tr>
        <td id="L14666" data-line-number="14666"></td>
        <td id="LC14666">{</td>
      </tr>
      <tr>
        <td id="L14667" data-line-number="14667"></td>
        <td id="LC14667">    <span>INTERNAL_SYNC_API_ENTRY</span>(<span>this</span>); <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14668" data-line-number="14668"></td>
        <td id="LC14668">
</td>
      </tr>
      <tr>
        <td id="L14669" data-line-number="14669"></td>
        <td id="LC14669">    <span><span>//</span> Create and initialize the event as synchronous</span></td>
      </tr>
      <tr>
        <td id="L14670" data-line-number="14670"></td>
        <td id="LC14670">    DebuggerIPCEvent event;</td>
      </tr>
      <tr>
        <td id="L14671" data-line-number="14671"></td>
        <td id="LC14671">    <span>InitIPCEvent</span>(&amp;event,</td>
      </tr>
      <tr>
        <td id="L14672" data-line-number="14672"></td>
        <td id="LC14672">                 DB_IPCE_GET_BUFFER,</td>
      </tr>
      <tr>
        <td id="L14673" data-line-number="14673"></td>
        <td id="LC14673">                 <span>true</span>,</td>
      </tr>
      <tr>
        <td id="L14674" data-line-number="14674"></td>
        <td id="LC14674">                 <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L14675" data-line-number="14675"></td>
        <td id="LC14675">
</td>
      </tr>
      <tr>
        <td id="L14676" data-line-number="14676"></td>
        <td id="LC14676">    <span><span>//</span> Indicate the buffer size wanted</span></td>
      </tr>
      <tr>
        <td id="L14677" data-line-number="14677"></td>
        <td id="LC14677">    event.<span>GetBuffer</span>.<span>bufSize</span> = cbBuffer;</td>
      </tr>
      <tr>
        <td id="L14678" data-line-number="14678"></td>
        <td id="LC14678">
</td>
      </tr>
      <tr>
        <td id="L14679" data-line-number="14679"></td>
        <td id="LC14679">    <span><span>//</span> Make the request, which is synchronous</span></td>
      </tr>
      <tr>
        <td id="L14680" data-line-number="14680"></td>
        <td id="LC14680">    HRESULT hr = <span>SendIPCEvent</span>(&amp;event, <span>sizeof</span>(event));</td>
      </tr>
      <tr>
        <td id="L14681" data-line-number="14681"></td>
        <td id="LC14681">    <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L14682" data-line-number="14682"></td>
        <td id="LC14682">    <span>_ASSERTE</span>(event.<span>type</span> == DB_IPCE_GET_BUFFER_RESULT);</td>
      </tr>
      <tr>
        <td id="L14683" data-line-number="14683"></td>
        <td id="LC14683">
</td>
      </tr>
      <tr>
        <td id="L14684" data-line-number="14684"></td>
        <td id="LC14684">    <span>IfFailThrow</span>(event.<span>GetBufferResult</span>.<span>hr</span>);</td>
      </tr>
      <tr>
        <td id="L14685" data-line-number="14685"></td>
        <td id="LC14685">
</td>
      </tr>
      <tr>
        <td id="L14686" data-line-number="14686"></td>
        <td id="LC14686">    <span><span>//</span> The request succeeded. Return the newly allocated range.</span></td>
      </tr>
      <tr>
        <td id="L14687" data-line-number="14687"></td>
        <td id="LC14687">    <span>return</span> <span>TargetBuffer</span>(event.<span>GetBufferResult</span>.<span>pBuffer</span>, cbBuffer);</td>
      </tr>
      <tr>
        <td id="L14688" data-line-number="14688"></td>
        <td id="LC14688">}</td>
      </tr>
      <tr>
        <td id="L14689" data-line-number="14689"></td>
        <td id="LC14689">
</td>
      </tr>
      <tr>
        <td id="L14690" data-line-number="14690"></td>
        <td id="LC14690"><span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L14691" data-line-number="14691"></td>
        <td id="LC14691"><span> * This will release a previously allocated left side buffer.</span></td>
      </tr>
      <tr>
        <td id="L14692" data-line-number="14692"></td>
        <td id="LC14692"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L14693" data-line-number="14693"></td>
        <td id="LC14693">HRESULT <span>CordbProcess::ReleaseRemoteBuffer</span>(<span>void</span> **ppBuffer)</td>
      </tr>
      <tr>
        <td id="L14694" data-line-number="14694"></td>
        <td id="LC14694">{</td>
      </tr>
      <tr>
        <td id="L14695" data-line-number="14695"></td>
        <td id="LC14695">    <span>INTERNAL_SYNC_API_ENTRY</span>(<span>this</span>); <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14696" data-line-number="14696"></td>
        <td id="LC14696">
</td>
      </tr>
      <tr>
        <td id="L14697" data-line-number="14697"></td>
        <td id="LC14697">    <span>_ASSERTE</span>(m_pShim != <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L14698" data-line-number="14698"></td>
        <td id="LC14698">
</td>
      </tr>
      <tr>
        <td id="L14699" data-line-number="14699"></td>
        <td id="LC14699">    <span><span>//</span> Create and initialize the event as synchronous</span></td>
      </tr>
      <tr>
        <td id="L14700" data-line-number="14700"></td>
        <td id="LC14700">    DebuggerIPCEvent event;</td>
      </tr>
      <tr>
        <td id="L14701" data-line-number="14701"></td>
        <td id="LC14701">    <span>InitIPCEvent</span>(&amp;event,</td>
      </tr>
      <tr>
        <td id="L14702" data-line-number="14702"></td>
        <td id="LC14702">                 DB_IPCE_RELEASE_BUFFER,</td>
      </tr>
      <tr>
        <td id="L14703" data-line-number="14703"></td>
        <td id="LC14703">                 <span>true</span>,</td>
      </tr>
      <tr>
        <td id="L14704" data-line-number="14704"></td>
        <td id="LC14704">                 <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L14705" data-line-number="14705"></td>
        <td id="LC14705">
</td>
      </tr>
      <tr>
        <td id="L14706" data-line-number="14706"></td>
        <td id="LC14706">    <span><span>//</span> Indicate the buffer to release</span></td>
      </tr>
      <tr>
        <td id="L14707" data-line-number="14707"></td>
        <td id="LC14707">    event.<span>ReleaseBuffer</span>.<span>pBuffer</span> = (*ppBuffer);</td>
      </tr>
      <tr>
        <td id="L14708" data-line-number="14708"></td>
        <td id="LC14708">
</td>
      </tr>
      <tr>
        <td id="L14709" data-line-number="14709"></td>
        <td id="LC14709">    <span><span>//</span> Make the request, which is synchronous</span></td>
      </tr>
      <tr>
        <td id="L14710" data-line-number="14710"></td>
        <td id="LC14710">    HRESULT hr = <span>SendIPCEvent</span>(&amp;event, <span>sizeof</span>(event));</td>
      </tr>
      <tr>
        <td id="L14711" data-line-number="14711"></td>
        <td id="LC14711">    <span>TESTANDRETURNHR</span>(hr);</td>
      </tr>
      <tr>
        <td id="L14712" data-line-number="14712"></td>
        <td id="LC14712">
</td>
      </tr>
      <tr>
        <td id="L14713" data-line-number="14713"></td>
        <td id="LC14713">    (*ppBuffer) = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L14714" data-line-number="14714"></td>
        <td id="LC14714">
</td>
      </tr>
      <tr>
        <td id="L14715" data-line-number="14715"></td>
        <td id="LC14715">    <span><span>//</span> Indicate success</span></td>
      </tr>
      <tr>
        <td id="L14716" data-line-number="14716"></td>
        <td id="LC14716">    <span>return</span> event.<span>ReleaseBufferResult</span>.<span>hr</span>;</td>
      </tr>
      <tr>
        <td id="L14717" data-line-number="14717"></td>
        <td id="LC14717">}</td>
      </tr>
      <tr>
        <td id="L14718" data-line-number="14718"></td>
        <td id="LC14718">
</td>
      </tr>
      <tr>
        <td id="L14719" data-line-number="14719"></td>
        <td id="LC14719">HRESULT <span>CordbProcess::SetDesiredNGENCompilerFlags</span>(DWORD dwFlags)</td>
      </tr>
      <tr>
        <td id="L14720" data-line-number="14720"></td>
        <td id="LC14720">{</td>
      </tr>
      <tr>
        <td id="L14721" data-line-number="14721"></td>
        <td id="LC14721">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L14722" data-line-number="14722"></td>
        <td id="LC14722">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L14723" data-line-number="14723"></td>
        <td id="LC14723">
</td>
      </tr>
      <tr>
        <td id="L14724" data-line-number="14724"></td>
        <td id="LC14724">#<span>if</span> defined(FEATURE_PREJIT)</td>
      </tr>
      <tr>
        <td id="L14725" data-line-number="14725"></td>
        <td id="LC14725">    <span>if</span> ((dwFlags != CORDEBUG_JIT_DEFAULT) &amp;&amp; (dwFlags != CORDEBUG_JIT_DISABLE_OPTIMIZATION))</td>
      </tr>
      <tr>
        <td id="L14726" data-line-number="14726"></td>
        <td id="LC14726">    {</td>
      </tr>
      <tr>
        <td id="L14727" data-line-number="14727"></td>
        <td id="LC14727">        <span>return</span> E_INVALIDARG;</td>
      </tr>
      <tr>
        <td id="L14728" data-line-number="14728"></td>
        <td id="LC14728">    }</td>
      </tr>
      <tr>
        <td id="L14729" data-line-number="14729"></td>
        <td id="LC14729">
</td>
      </tr>
      <tr>
        <td id="L14730" data-line-number="14730"></td>
        <td id="LC14730">    CordbProcess *pProcess = <span>GetProcess</span>();</td>
      </tr>
      <tr>
        <td id="L14731" data-line-number="14731"></td>
        <td id="LC14731">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L14732" data-line-number="14732"></td>
        <td id="LC14732">    HRESULT  hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L14733" data-line-number="14733"></td>
        <td id="LC14733">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L14734" data-line-number="14734"></td>
        <td id="LC14734">    {</td>
      </tr>
      <tr>
        <td id="L14735" data-line-number="14735"></td>
        <td id="LC14735">        <span><span>//</span> Left-side checks that this is a valid time to set the Ngen flags.</span></td>
      </tr>
      <tr>
        <td id="L14736" data-line-number="14736"></td>
        <td id="LC14736">        hr = pProcess-&gt;<span>GetDAC</span>()-&gt;<span>SetNGENCompilerFlags</span>(dwFlags);</td>
      </tr>
      <tr>
        <td id="L14737" data-line-number="14737"></td>
        <td id="LC14737">        <span>if</span> (!<span>SUCCEEDED</span>(hr) &amp;&amp; <span>GetShim</span>() != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14738" data-line-number="14738"></td>
        <td id="LC14738">        {</td>
      </tr>
      <tr>
        <td id="L14739" data-line-number="14739"></td>
        <td id="LC14739">            <span><span>//</span> Emulate V2 error semantics.</span></td>
      </tr>
      <tr>
        <td id="L14740" data-line-number="14740"></td>
        <td id="LC14740">            hr = <span>GetShim</span>()-&gt;<span>FilterSetNgenHresult</span>(hr);</td>
      </tr>
      <tr>
        <td id="L14741" data-line-number="14741"></td>
        <td id="LC14741">        }</td>
      </tr>
      <tr>
        <td id="L14742" data-line-number="14742"></td>
        <td id="LC14742">    }</td>
      </tr>
      <tr>
        <td id="L14743" data-line-number="14743"></td>
        <td id="LC14743">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L14744" data-line-number="14744"></td>
        <td id="LC14744">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L14745" data-line-number="14745"></td>
        <td id="LC14745">
</td>
      </tr>
      <tr>
        <td id="L14746" data-line-number="14746"></td>
        <td id="LC14746">#<span>else</span>  <span><span>//</span> !FEATURE_PREJIT</span></td>
      </tr>
      <tr>
        <td id="L14747" data-line-number="14747"></td>
        <td id="LC14747">    <span>return</span> CORDBG_E_NGEN_NOT_SUPPORTED;</td>
      </tr>
      <tr>
        <td id="L14748" data-line-number="14748"></td>
        <td id="LC14748">
</td>
      </tr>
      <tr>
        <td id="L14749" data-line-number="14749"></td>
        <td id="LC14749">#<span>endif</span> <span><span>//</span> FEATURE_PREJIT</span></td>
      </tr>
      <tr>
        <td id="L14750" data-line-number="14750"></td>
        <td id="LC14750">}</td>
      </tr>
      <tr>
        <td id="L14751" data-line-number="14751"></td>
        <td id="LC14751">
</td>
      </tr>
      <tr>
        <td id="L14752" data-line-number="14752"></td>
        <td id="LC14752">HRESULT <span>CordbProcess::GetDesiredNGENCompilerFlags</span>(DWORD *pdwFlags )</td>
      </tr>
      <tr>
        <td id="L14753" data-line-number="14753"></td>
        <td id="LC14753">{</td>
      </tr>
      <tr>
        <td id="L14754" data-line-number="14754"></td>
        <td id="LC14754">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L14755" data-line-number="14755"></td>
        <td id="LC14755">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L14756" data-line-number="14756"></td>
        <td id="LC14756">    <span>VALIDATE_POINTER_TO_OBJECT</span>(pdwFlags, DWORD*);</td>
      </tr>
      <tr>
        <td id="L14757" data-line-number="14757"></td>
        <td id="LC14757">    *pdwFlags = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L14758" data-line-number="14758"></td>
        <td id="LC14758">
</td>
      </tr>
      <tr>
        <td id="L14759" data-line-number="14759"></td>
        <td id="LC14759">    CordbProcess *pProcess = <span>GetProcess</span>();</td>
      </tr>
      <tr>
        <td id="L14760" data-line-number="14760"></td>
        <td id="LC14760">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(pProcess);</td>
      </tr>
      <tr>
        <td id="L14761" data-line-number="14761"></td>
        <td id="LC14761">    HRESULT  hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L14762" data-line-number="14762"></td>
        <td id="LC14762">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L14763" data-line-number="14763"></td>
        <td id="LC14763">    {</td>
      </tr>
      <tr>
        <td id="L14764" data-line-number="14764"></td>
        <td id="LC14764">        hr = pProcess-&gt;<span>GetDAC</span>()-&gt;<span>GetNGENCompilerFlags</span>(pdwFlags);</td>
      </tr>
      <tr>
        <td id="L14765" data-line-number="14765"></td>
        <td id="LC14765">    }</td>
      </tr>
      <tr>
        <td id="L14766" data-line-number="14766"></td>
        <td id="LC14766">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L14767" data-line-number="14767"></td>
        <td id="LC14767">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L14768" data-line-number="14768"></td>
        <td id="LC14768">}</td>
      </tr>
      <tr>
        <td id="L14769" data-line-number="14769"></td>
        <td id="LC14769">
</td>
      </tr>
      <tr>
        <td id="L14770" data-line-number="14770"></td>
        <td id="LC14770"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L14771" data-line-number="14771"></td>
        <td id="LC14771"><span><span>//</span> Get an ICorDebugReference Value for the GC handle.</span></td>
      </tr>
      <tr>
        <td id="L14772" data-line-number="14772"></td>
        <td id="LC14772"><span><span>//</span> handle - raw bits for the GC handle.</span></td>
      </tr>
      <tr>
        <td id="L14773" data-line-number="14773"></td>
        <td id="LC14773"><span><span>//</span> pOutHandle</span></td>
      </tr>
      <tr>
        <td id="L14774" data-line-number="14774"></td>
        <td id="LC14774"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L14775" data-line-number="14775"></td>
        <td id="LC14775">HRESULT <span>CordbProcess::GetReferenceValueFromGCHandle</span>(</td>
      </tr>
      <tr>
        <td id="L14776" data-line-number="14776"></td>
        <td id="LC14776">    UINT_PTR gcHandle,</td>
      </tr>
      <tr>
        <td id="L14777" data-line-number="14777"></td>
        <td id="LC14777">    ICorDebugReferenceValue **pOutValue)</td>
      </tr>
      <tr>
        <td id="L14778" data-line-number="14778"></td>
        <td id="LC14778">{</td>
      </tr>
      <tr>
        <td id="L14779" data-line-number="14779"></td>
        <td id="LC14779">    <span>PUBLIC_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L14780" data-line-number="14780"></td>
        <td id="LC14780">    <span>FAIL_IF_NEUTERED</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L14781" data-line-number="14781"></td>
        <td id="LC14781">    <span>ATT_REQUIRE_STOPPED_MAY_FAIL</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L14782" data-line-number="14782"></td>
        <td id="LC14782">    <span>VALIDATE_POINTER_TO_OBJECT</span>(pOutValue, ICorDebugReferenceValue*);</td>
      </tr>
      <tr>
        <td id="L14783" data-line-number="14783"></td>
        <td id="LC14783">
</td>
      </tr>
      <tr>
        <td id="L14784" data-line-number="14784"></td>
        <td id="LC14784">    *pOutValue = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L14785" data-line-number="14785"></td>
        <td id="LC14785">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L14786" data-line-number="14786"></td>
        <td id="LC14786">
</td>
      </tr>
      <tr>
        <td id="L14787" data-line-number="14787"></td>
        <td id="LC14787">    EX_TRY</td>
      </tr>
      <tr>
        <td id="L14788" data-line-number="14788"></td>
        <td id="LC14788">    {</td>
      </tr>
      <tr>
        <td id="L14789" data-line-number="14789"></td>
        <td id="LC14789">        <span>if</span> (gcHandle == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14790" data-line-number="14790"></td>
        <td id="LC14790">        {</td>
      </tr>
      <tr>
        <td id="L14791" data-line-number="14791"></td>
        <td id="LC14791">            <span>ThrowHR</span>(CORDBG_E_BAD_REFERENCE_VALUE);</td>
      </tr>
      <tr>
        <td id="L14792" data-line-number="14792"></td>
        <td id="LC14792">        }</td>
      </tr>
      <tr>
        <td id="L14793" data-line-number="14793"></td>
        <td id="LC14793">
</td>
      </tr>
      <tr>
        <td id="L14794" data-line-number="14794"></td>
        <td id="LC14794">        IDacDbiInterface* pDAC = <span>GetProcess</span>()-&gt;<span>GetDAC</span>();</td>
      </tr>
      <tr>
        <td id="L14795" data-line-number="14795"></td>
        <td id="LC14795">        VMPTR_OBJECTHANDLE vmObjHandle = pDAC-&gt;<span>GetVmObjectHandle</span>(gcHandle);</td>
      </tr>
      <tr>
        <td id="L14796" data-line-number="14796"></td>
        <td id="LC14796">        <span>if</span>(!pDAC-&gt;<span>IsVmObjectHandleValid</span>(vmObjHandle))</td>
      </tr>
      <tr>
        <td id="L14797" data-line-number="14797"></td>
        <td id="LC14797">        {</td>
      </tr>
      <tr>
        <td id="L14798" data-line-number="14798"></td>
        <td id="LC14798">            <span>ThrowHR</span>(CORDBG_E_BAD_REFERENCE_VALUE);</td>
      </tr>
      <tr>
        <td id="L14799" data-line-number="14799"></td>
        <td id="LC14799">        }</td>
      </tr>
      <tr>
        <td id="L14800" data-line-number="14800"></td>
        <td id="LC14800">        ULONG appDomainId = pDAC-&gt;<span>GetAppDomainIdFromVmObjectHandle</span>(vmObjHandle);</td>
      </tr>
      <tr>
        <td id="L14801" data-line-number="14801"></td>
        <td id="LC14801">        VMPTR_AppDomain vmAppDomain = pDAC-&gt;<span>GetAppDomainFromId</span>(appDomainId);</td>
      </tr>
      <tr>
        <td id="L14802" data-line-number="14802"></td>
        <td id="LC14802">
</td>
      </tr>
      <tr>
        <td id="L14803" data-line-number="14803"></td>
        <td id="LC14803">        RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L14804" data-line-number="14804"></td>
        <td id="LC14804">        CordbAppDomain * pAppDomain = <span>LookupOrCreateAppDomain</span>(vmAppDomain);</td>
      </tr>
      <tr>
        <td id="L14805" data-line-number="14805"></td>
        <td id="LC14805">        lockHolder.<span>Release</span>();</td>
      </tr>
      <tr>
        <td id="L14806" data-line-number="14806"></td>
        <td id="LC14806">
</td>
      </tr>
      <tr>
        <td id="L14807" data-line-number="14807"></td>
        <td id="LC14807">        <span><span>//</span> Now that we finally have the AppDomain, we can go ahead and get a ReferenceValue</span></td>
      </tr>
      <tr>
        <td id="L14808" data-line-number="14808"></td>
        <td id="LC14808">        <span><span>//</span> from the ObjectHandle.</span></td>
      </tr>
      <tr>
        <td id="L14809" data-line-number="14809"></td>
        <td id="LC14809">        hr = <span>CordbReferenceValue::BuildFromGCHandle</span>(pAppDomain, vmObjHandle, pOutValue);</td>
      </tr>
      <tr>
        <td id="L14810" data-line-number="14810"></td>
        <td id="LC14810">        <span>_ASSERTE</span>(<span>SUCCEEDED</span>(hr) == (*pOutValue != <span>NULL</span>));</td>
      </tr>
      <tr>
        <td id="L14811" data-line-number="14811"></td>
        <td id="LC14811">        <span>IfFailThrow</span>(hr);</td>
      </tr>
      <tr>
        <td id="L14812" data-line-number="14812"></td>
        <td id="LC14812">    }</td>
      </tr>
      <tr>
        <td id="L14813" data-line-number="14813"></td>
        <td id="LC14813">    <span>EX_CATCH_HRESULT</span>(hr);</td>
      </tr>
      <tr>
        <td id="L14814" data-line-number="14814"></td>
        <td id="LC14814">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L14815" data-line-number="14815"></td>
        <td id="LC14815">}</td>
      </tr>
      <tr>
        <td id="L14816" data-line-number="14816"></td>
        <td id="LC14816">
</td>
      </tr>
      <tr>
        <td id="L14817" data-line-number="14817"></td>
        <td id="LC14817"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L14818" data-line-number="14818"></td>
        <td id="LC14818"><span><span>//</span> Return count of outstanding GC handles held by CordbHandleValue objects</span></td>
      </tr>
      <tr>
        <td id="L14819" data-line-number="14819"></td>
        <td id="LC14819">LONG <span>CordbProcess::OutstandingHandles</span>()</td>
      </tr>
      <tr>
        <td id="L14820" data-line-number="14820"></td>
        <td id="LC14820">{</td>
      </tr>
      <tr>
        <td id="L14821" data-line-number="14821"></td>
        <td id="LC14821">    <span>return</span> m_cOutstandingHandles;</td>
      </tr>
      <tr>
        <td id="L14822" data-line-number="14822"></td>
        <td id="LC14822">}</td>
      </tr>
      <tr>
        <td id="L14823" data-line-number="14823"></td>
        <td id="LC14823">
</td>
      </tr>
      <tr>
        <td id="L14824" data-line-number="14824"></td>
        <td id="LC14824"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L14825" data-line-number="14825"></td>
        <td id="LC14825"><span><span>//</span> Increment the outstanding handle count for code:CordbProces::OutstandingHandles</span></td>
      </tr>
      <tr>
        <td id="L14826" data-line-number="14826"></td>
        <td id="LC14826"><span><span>//</span> This is the inverse of code:CordbProces::DecrementOutstandingHandles</span></td>
      </tr>
      <tr>
        <td id="L14827" data-line-number="14827"></td>
        <td id="LC14827"><span>void</span> <span>CordbProcess::IncrementOutstandingHandles</span>()</td>
      </tr>
      <tr>
        <td id="L14828" data-line-number="14828"></td>
        <td id="LC14828">{</td>
      </tr>
      <tr>
        <td id="L14829" data-line-number="14829"></td>
        <td id="LC14829">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L14830" data-line-number="14830"></td>
        <td id="LC14830">    m_cOutstandingHandles++;</td>
      </tr>
      <tr>
        <td id="L14831" data-line-number="14831"></td>
        <td id="LC14831">}</td>
      </tr>
      <tr>
        <td id="L14832" data-line-number="14832"></td>
        <td id="LC14832">
</td>
      </tr>
      <tr>
        <td id="L14833" data-line-number="14833"></td>
        <td id="LC14833"><span><span>//</span>-----------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L14834" data-line-number="14834"></td>
        <td id="LC14834"><span><span>//</span> Decrement the outstanding handle count for code:CordbProces::OutstandingHandles</span></td>
      </tr>
      <tr>
        <td id="L14835" data-line-number="14835"></td>
        <td id="LC14835"><span><span>//</span> This is the inverse of code:CordbProces::IncrementOutstandingHandles</span></td>
      </tr>
      <tr>
        <td id="L14836" data-line-number="14836"></td>
        <td id="LC14836"><span>void</span> <span>CordbProcess::DecrementOutstandingHandles</span>()</td>
      </tr>
      <tr>
        <td id="L14837" data-line-number="14837"></td>
        <td id="LC14837">{</td>
      </tr>
      <tr>
        <td id="L14838" data-line-number="14838"></td>
        <td id="LC14838">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L14839" data-line-number="14839"></td>
        <td id="LC14839">    m_cOutstandingHandles--;</td>
      </tr>
      <tr>
        <td id="L14840" data-line-number="14840"></td>
        <td id="LC14840">}</td>
      </tr>
      <tr>
        <td id="L14841" data-line-number="14841"></td>
        <td id="LC14841">
</td>
      </tr>
      <tr>
        <td id="L14842" data-line-number="14842"></td>
        <td id="LC14842">
</td>
      </tr>
      <tr>
        <td id="L14843" data-line-number="14843"></td>
        <td id="LC14843"><span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L14844" data-line-number="14844"></td>
        <td id="LC14844"><span> * IsReadyForDetach</span></td>
      </tr>
      <tr>
        <td id="L14845" data-line-number="14845"></td>
        <td id="LC14845"><span> *</span></td>
      </tr>
      <tr>
        <td id="L14846" data-line-number="14846"></td>
        <td id="LC14846"><span> * This method encapsulates all logic for deciding if it is ok for a debugger to</span></td>
      </tr>
      <tr>
        <td id="L14847" data-line-number="14847"></td>
        <td id="LC14847"><span> * detach from the process at this time.</span></td>
      </tr>
      <tr>
        <td id="L14848" data-line-number="14848"></td>
        <td id="LC14848"><span> *</span></td>
      </tr>
      <tr>
        <td id="L14849" data-line-number="14849"></td>
        <td id="LC14849"><span> * Parameters: None.</span></td>
      </tr>
      <tr>
        <td id="L14850" data-line-number="14850"></td>
        <td id="LC14850"><span> *</span></td>
      </tr>
      <tr>
        <td id="L14851" data-line-number="14851"></td>
        <td id="LC14851"><span> * Returns: S_OK if it is ok to detach, else a specific HRESULT describing why it</span></td>
      </tr>
      <tr>
        <td id="L14852" data-line-number="14852"></td>
        <td id="LC14852"><span> *   is not ok to detach.</span></td>
      </tr>
      <tr>
        <td id="L14853" data-line-number="14853"></td>
        <td id="LC14853"><span> *</span></td>
      </tr>
      <tr>
        <td id="L14854" data-line-number="14854"></td>
        <td id="LC14854"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L14855" data-line-number="14855"></td>
        <td id="LC14855">HRESULT <span>CordbProcess::IsReadyForDetach</span>()</td>
      </tr>
      <tr>
        <td id="L14856" data-line-number="14856"></td>
        <td id="LC14856">{</td>
      </tr>
      <tr>
        <td id="L14857" data-line-number="14857"></td>
        <td id="LC14857">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L14858" data-line-number="14858"></td>
        <td id="LC14858">
</td>
      </tr>
      <tr>
        <td id="L14859" data-line-number="14859"></td>
        <td id="LC14859">    <span><span>//</span> Always safe to detach in V3 case.</span></td>
      </tr>
      <tr>
        <td id="L14860" data-line-number="14860"></td>
        <td id="LC14860">    <span>if</span> (m_pShim == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14861" data-line-number="14861"></td>
        <td id="LC14861">    {</td>
      </tr>
      <tr>
        <td id="L14862" data-line-number="14862"></td>
        <td id="LC14862">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L14863" data-line-number="14863"></td>
        <td id="LC14863">    }</td>
      </tr>
      <tr>
        <td id="L14864" data-line-number="14864"></td>
        <td id="LC14864">
</td>
      </tr>
      <tr>
        <td id="L14865" data-line-number="14865"></td>
        <td id="LC14865">    <span><span>//</span> If not initialized yet, then there are no detach liabilities.</span></td>
      </tr>
      <tr>
        <td id="L14866" data-line-number="14866"></td>
        <td id="LC14866">    <span>if</span> (!m_initialized)</td>
      </tr>
      <tr>
        <td id="L14867" data-line-number="14867"></td>
        <td id="LC14867">    {</td>
      </tr>
      <tr>
        <td id="L14868" data-line-number="14868"></td>
        <td id="LC14868">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L14869" data-line-number="14869"></td>
        <td id="LC14869">    }</td>
      </tr>
      <tr>
        <td id="L14870" data-line-number="14870"></td>
        <td id="LC14870">
</td>
      </tr>
      <tr>
        <td id="L14871" data-line-number="14871"></td>
        <td id="LC14871">    RSLockHolder <span>lockHolder</span>(&amp;<span>this</span>-&gt;<span>m_processMutex</span>);</td>
      </tr>
      <tr>
        <td id="L14872" data-line-number="14872"></td>
        <td id="LC14872">
</td>
      </tr>
      <tr>
        <td id="L14873" data-line-number="14873"></td>
        <td id="LC14873">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14874" data-line-number="14874"></td>
        <td id="LC14874">    <span><span>//</span> If there are any outstanding func-evals then fail the detach.</span></td>
      </tr>
      <tr>
        <td id="L14875" data-line-number="14875"></td>
        <td id="LC14875">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14876" data-line-number="14876"></td>
        <td id="LC14876">    <span>if</span> (<span>OutstandingEvalCount</span>() != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L14877" data-line-number="14877"></td>
        <td id="LC14877">    {</td>
      </tr>
      <tr>
        <td id="L14878" data-line-number="14878"></td>
        <td id="LC14878">        <span>return</span> CORDBG_E_DETACH_FAILED_OUTSTANDING_EVALS;</td>
      </tr>
      <tr>
        <td id="L14879" data-line-number="14879"></td>
        <td id="LC14879">    }</td>
      </tr>
      <tr>
        <td id="L14880" data-line-number="14880"></td>
        <td id="LC14880">
</td>
      </tr>
      <tr>
        <td id="L14881" data-line-number="14881"></td>
        <td id="LC14881">    <span><span>//</span> V2 didn't check outstanding handles (code:CordbProcess::OutstandingHandles)</span></td>
      </tr>
      <tr>
        <td id="L14882" data-line-number="14882"></td>
        <td id="LC14882">    <span><span>//</span> because it could automatically clean those up on detach.</span></td>
      </tr>
      <tr>
        <td id="L14883" data-line-number="14883"></td>
        <td id="LC14883">
</td>
      </tr>
      <tr>
        <td id="L14884" data-line-number="14884"></td>
        <td id="LC14884">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14885" data-line-number="14885"></td>
        <td id="LC14885">    <span><span>//</span> If there are any outstanding steppers then fail the detach.</span></td>
      </tr>
      <tr>
        <td id="L14886" data-line-number="14886"></td>
        <td id="LC14886">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14887" data-line-number="14887"></td>
        <td id="LC14887">    <span>if</span> (m_steppers.<span>IsInitialized</span>() &amp;&amp; (m_steppers.<span>GetCount</span>() &gt; <span>0</span>))</td>
      </tr>
      <tr>
        <td id="L14888" data-line-number="14888"></td>
        <td id="LC14888">    {</td>
      </tr>
      <tr>
        <td id="L14889" data-line-number="14889"></td>
        <td id="LC14889">        <span>return</span> CORDBG_E_DETACH_FAILED_OUTSTANDING_STEPPERS;</td>
      </tr>
      <tr>
        <td id="L14890" data-line-number="14890"></td>
        <td id="LC14890">    }</td>
      </tr>
      <tr>
        <td id="L14891" data-line-number="14891"></td>
        <td id="LC14891">
</td>
      </tr>
      <tr>
        <td id="L14892" data-line-number="14892"></td>
        <td id="LC14892">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14893" data-line-number="14893"></td>
        <td id="LC14893">    <span><span>//</span> If there are any outstanding breakpoints then fail the detach.</span></td>
      </tr>
      <tr>
        <td id="L14894" data-line-number="14894"></td>
        <td id="LC14894">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L14895" data-line-number="14895"></td>
        <td id="LC14895">    HASHFIND foundAppDomain;</td>
      </tr>
      <tr>
        <td id="L14896" data-line-number="14896"></td>
        <td id="LC14896">    CordbAppDomain *pAppDomain = m_appDomains.<span>FindFirst</span>(&amp;foundAppDomain);</td>
      </tr>
      <tr>
        <td id="L14897" data-line-number="14897"></td>
        <td id="LC14897">
</td>
      </tr>
      <tr>
        <td id="L14898" data-line-number="14898"></td>
        <td id="LC14898">    <span>while</span> (pAppDomain != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14899" data-line-number="14899"></td>
        <td id="LC14899">    {</td>
      </tr>
      <tr>
        <td id="L14900" data-line-number="14900"></td>
        <td id="LC14900">        <span>if</span> (pAppDomain-&gt;<span>m_breakpoints</span>.<span>IsInitialized</span>() &amp;&amp; (pAppDomain-&gt;<span>m_breakpoints</span>.<span>GetCount</span>() &gt; <span>0</span>))</td>
      </tr>
      <tr>
        <td id="L14901" data-line-number="14901"></td>
        <td id="LC14901">        {</td>
      </tr>
      <tr>
        <td id="L14902" data-line-number="14902"></td>
        <td id="LC14902">            <span>return</span> CORDBG_E_DETACH_FAILED_OUTSTANDING_BREAKPOINTS;</td>
      </tr>
      <tr>
        <td id="L14903" data-line-number="14903"></td>
        <td id="LC14903">        }</td>
      </tr>
      <tr>
        <td id="L14904" data-line-number="14904"></td>
        <td id="LC14904">
</td>
      </tr>
      <tr>
        <td id="L14905" data-line-number="14905"></td>
        <td id="LC14905">        <span><span>//</span> Check for any outstanding EnC modules.</span></td>
      </tr>
      <tr>
        <td id="L14906" data-line-number="14906"></td>
        <td id="LC14906">        HASHFIND foundModule;</td>
      </tr>
      <tr>
        <td id="L14907" data-line-number="14907"></td>
        <td id="LC14907">        CordbModule * pModule = pAppDomain-&gt;<span>m_modules</span>.<span>FindFirst</span>(&amp;foundModule);</td>
      </tr>
      <tr>
        <td id="L14908" data-line-number="14908"></td>
        <td id="LC14908">        <span>while</span> (pModule != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14909" data-line-number="14909"></td>
        <td id="LC14909">        {</td>
      </tr>
      <tr>
        <td id="L14910" data-line-number="14910"></td>
        <td id="LC14910">            <span>if</span> (pModule-&gt;<span>m_EnCCount</span> &gt; <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L14911" data-line-number="14911"></td>
        <td id="LC14911">            {</td>
      </tr>
      <tr>
        <td id="L14912" data-line-number="14912"></td>
        <td id="LC14912">                <span>return</span> CORDBG_E_DETACH_FAILED_ON_ENC;</td>
      </tr>
      <tr>
        <td id="L14913" data-line-number="14913"></td>
        <td id="LC14913">            }</td>
      </tr>
      <tr>
        <td id="L14914" data-line-number="14914"></td>
        <td id="LC14914">            pModule = pAppDomain-&gt;<span>m_modules</span>.<span>FindNext</span>(&amp;foundModule);</td>
      </tr>
      <tr>
        <td id="L14915" data-line-number="14915"></td>
        <td id="LC14915">        }</td>
      </tr>
      <tr>
        <td id="L14916" data-line-number="14916"></td>
        <td id="LC14916">
</td>
      </tr>
      <tr>
        <td id="L14917" data-line-number="14917"></td>
        <td id="LC14917">
</td>
      </tr>
      <tr>
        <td id="L14918" data-line-number="14918"></td>
        <td id="LC14918">        pAppDomain = m_appDomains.<span>FindNext</span>(&amp;foundAppDomain);</td>
      </tr>
      <tr>
        <td id="L14919" data-line-number="14919"></td>
        <td id="LC14919">    }</td>
      </tr>
      <tr>
        <td id="L14920" data-line-number="14920"></td>
        <td id="LC14920">
</td>
      </tr>
      <tr>
        <td id="L14921" data-line-number="14921"></td>
        <td id="LC14921">    <span><span>//</span> If we're using the shim, give a chance to early-out if the OS doesn't support detach</span></td>
      </tr>
      <tr>
        <td id="L14922" data-line-number="14922"></td>
        <td id="LC14922">    <span><span>//</span> so that the user can continue to debug in that case.</span></td>
      </tr>
      <tr>
        <td id="L14923" data-line-number="14923"></td>
        <td id="LC14923">    <span><span>//</span> Ideally we'd just rely on the failure from DebugActiveProcessStop, but by then it's too late</span></td>
      </tr>
      <tr>
        <td id="L14924" data-line-number="14924"></td>
        <td id="LC14924">    <span><span>//</span> to recover.  This function is our only chance to distinguish between graceful detach failures</span></td>
      </tr>
      <tr>
        <td id="L14925" data-line-number="14925"></td>
        <td id="LC14925">    <span><span>//</span> and hard detach failures (after which the process object is neutered).</span></td>
      </tr>
      <tr>
        <td id="L14926" data-line-number="14926"></td>
        <td id="LC14926">    <span>if</span> (m_pShim != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14927" data-line-number="14927"></td>
        <td id="LC14927">    {</td>
      </tr>
      <tr>
        <td id="L14928" data-line-number="14928"></td>
        <td id="LC14928">#<span>if</span> !defined(FEATURE_CORESYSTEM) <span><span>//</span> CORESYSTEM TODO</span></td>
      </tr>
      <tr>
        <td id="L14929" data-line-number="14929"></td>
        <td id="LC14929">        HModuleHolder hKernel32;</td>
      </tr>
      <tr>
        <td id="L14930" data-line-number="14930"></td>
        <td id="LC14930">        hKernel32 = <span>WszLoadLibrary</span>(<span>W</span>(<span><span>"</span>kernel32<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14931" data-line-number="14931"></td>
        <td id="LC14931">        <span>if</span> (hKernel32 == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14932" data-line-number="14932"></td>
        <td id="LC14932">            <span>return</span> <span>HRESULT_FROM_GetLastError</span>();</td>
      </tr>
      <tr>
        <td id="L14933" data-line-number="14933"></td>
        <td id="LC14933">        <span>typedef</span> <span>BOOL</span> (*DebugActiveProcessStopSig) (DWORD);</td>
      </tr>
      <tr>
        <td id="L14934" data-line-number="14934"></td>
        <td id="LC14934">        DebugActiveProcessStopSig pDebugActiveProcessStop =</td>
      </tr>
      <tr>
        <td id="L14935" data-line-number="14935"></td>
        <td id="LC14935">            <span>reinterpret_cast</span>&lt;DebugActiveProcessStopSig&gt;(<span>GetProcAddress</span>(hKernel32, <span><span>"</span>DebugActiveProcessStop<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L14936" data-line-number="14936"></td>
        <td id="LC14936">        <span>if</span> (pDebugActiveProcessStop == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14937" data-line-number="14937"></td>
        <td id="LC14937">            <span>return</span> COR_E_PLATFORMNOTSUPPORTED;</td>
      </tr>
      <tr>
        <td id="L14938" data-line-number="14938"></td>
        <td id="LC14938">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L14939" data-line-number="14939"></td>
        <td id="LC14939">    }</td>
      </tr>
      <tr>
        <td id="L14940" data-line-number="14940"></td>
        <td id="LC14940">
</td>
      </tr>
      <tr>
        <td id="L14941" data-line-number="14941"></td>
        <td id="LC14941">    <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L14942" data-line-number="14942"></td>
        <td id="LC14942">}</td>
      </tr>
      <tr>
        <td id="L14943" data-line-number="14943"></td>
        <td id="LC14943">
</td>
      </tr>
      <tr>
        <td id="L14944" data-line-number="14944"></td>
        <td id="LC14944">
</td>
      </tr>
      <tr>
        <td id="L14945" data-line-number="14945"></td>
        <td id="LC14945"><span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L14946" data-line-number="14946"></td>
        <td id="LC14946"><span> * Look for any thread which was last seen in the specified AppDomain.</span></td>
      </tr>
      <tr>
        <td id="L14947" data-line-number="14947"></td>
        <td id="LC14947"><span> * The CordbAppDomain object is about to be neutered due to an AD Unload</span></td>
      </tr>
      <tr>
        <td id="L14948" data-line-number="14948"></td>
        <td id="LC14948"><span> * So the thread must no longer be considered to be in that domain.</span></td>
      </tr>
      <tr>
        <td id="L14949" data-line-number="14949"></td>
        <td id="LC14949"><span> * Note that this is a workaround due to the existance of the (possibly incorrect)</span></td>
      </tr>
      <tr>
        <td id="L14950" data-line-number="14950"></td>
        <td id="LC14950"><span> * cached AppDomain value.  Ideally we would remove the cached value entirely</span></td>
      </tr>
      <tr>
        <td id="L14951" data-line-number="14951"></td>
        <td id="LC14951"><span> * and there would be no need for this.</span></td>
      </tr>
      <tr>
        <td id="L14952" data-line-number="14952"></td>
        <td id="LC14952"><span> *</span></td>
      </tr>
      <tr>
        <td id="L14953" data-line-number="14953"></td>
        <td id="LC14953"><span> * @dbgtodo: , appdomain: We should remove CordbThread::m_pAppDomain in the V3 architecture.</span></td>
      </tr>
      <tr>
        <td id="L14954" data-line-number="14954"></td>
        <td id="LC14954"><span> * If we need the thread's current domain, we should get it accurately with DAC.</span></td>
      </tr>
      <tr>
        <td id="L14955" data-line-number="14955"></td>
        <td id="LC14955"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L14956" data-line-number="14956"></td>
        <td id="LC14956"><span>void</span> <span>CordbProcess::UpdateThreadsForAdUnload</span>(CordbAppDomain * pAppDomain)</td>
      </tr>
      <tr>
        <td id="L14957" data-line-number="14957"></td>
        <td id="LC14957">{</td>
      </tr>
      <tr>
        <td id="L14958" data-line-number="14958"></td>
        <td id="LC14958">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L14959" data-line-number="14959"></td>
        <td id="LC14959">
</td>
      </tr>
      <tr>
        <td id="L14960" data-line-number="14960"></td>
        <td id="LC14960">    <span><span>//</span> If we're doing an AD unload then we should have already seen the ATTACH</span></td>
      </tr>
      <tr>
        <td id="L14961" data-line-number="14961"></td>
        <td id="LC14961">    <span><span>//</span> notification for the default domain.</span></td>
      </tr>
      <tr>
        <td id="L14962" data-line-number="14962"></td>
        <td id="LC14962">    <span><span>//</span>_ASSERTE( m_pDefaultAppDomain != NULL );</span></td>
      </tr>
      <tr>
        <td id="L14963" data-line-number="14963"></td>
        <td id="LC14963">    <span><span>//</span> @dbgtodo appdomain: fix Default domain invariants with DAC-izing Appdomain work.</span></td>
      </tr>
      <tr>
        <td id="L14964" data-line-number="14964"></td>
        <td id="LC14964">
</td>
      </tr>
      <tr>
        <td id="L14965" data-line-number="14965"></td>
        <td id="LC14965">    RSLockHolder <span>lockHolder</span>(<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L14966" data-line-number="14966"></td>
        <td id="LC14966">
</td>
      </tr>
      <tr>
        <td id="L14967" data-line-number="14967"></td>
        <td id="LC14967">    CordbThread* t;</td>
      </tr>
      <tr>
        <td id="L14968" data-line-number="14968"></td>
        <td id="LC14968">    HASHFIND find;</td>
      </tr>
      <tr>
        <td id="L14969" data-line-number="14969"></td>
        <td id="LC14969">
</td>
      </tr>
      <tr>
        <td id="L14970" data-line-number="14970"></td>
        <td id="LC14970">    <span><span>//</span> We don't need to prepopulate here (to collect LS state) because we're just updating RS state.</span></td>
      </tr>
      <tr>
        <td id="L14971" data-line-number="14971"></td>
        <td id="LC14971">    <span>for</span> (t =  m_userThreads.<span>FindFirst</span>(&amp;find);</td>
      </tr>
      <tr>
        <td id="L14972" data-line-number="14972"></td>
        <td id="LC14972">         t != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L14973" data-line-number="14973"></td>
        <td id="LC14973">         t =  m_userThreads.<span>FindNext</span>(&amp;find))</td>
      </tr>
      <tr>
        <td id="L14974" data-line-number="14974"></td>
        <td id="LC14974">    {</td>
      </tr>
      <tr>
        <td id="L14975" data-line-number="14975"></td>
        <td id="LC14975">        <span>if</span>( t-&gt;<span>GetAppDomain</span>() == pAppDomain )</td>
      </tr>
      <tr>
        <td id="L14976" data-line-number="14976"></td>
        <td id="LC14976">        {</td>
      </tr>
      <tr>
        <td id="L14977" data-line-number="14977"></td>
        <td id="LC14977">            <span><span>//</span> This thread cannot actually be in this AppDomain anymore (since it's being</span></td>
      </tr>
      <tr>
        <td id="L14978" data-line-number="14978"></td>
        <td id="LC14978">            <span><span>//</span> unloaded).  Reset it to point to the default AppDomain</span></td>
      </tr>
      <tr>
        <td id="L14979" data-line-number="14979"></td>
        <td id="LC14979">            t-&gt;<span>m_pAppDomain</span> = m_pDefaultAppDomain;</td>
      </tr>
      <tr>
        <td id="L14980" data-line-number="14980"></td>
        <td id="LC14980">        }</td>
      </tr>
      <tr>
        <td id="L14981" data-line-number="14981"></td>
        <td id="LC14981">    }</td>
      </tr>
      <tr>
        <td id="L14982" data-line-number="14982"></td>
        <td id="LC14982">}</td>
      </tr>
      <tr>
        <td id="L14983" data-line-number="14983"></td>
        <td id="LC14983">
</td>
      </tr>
      <tr>
        <td id="L14984" data-line-number="14984"></td>
        <td id="LC14984"><span><span>//</span> CordbProcess::LookupClass</span></td>
      </tr>
      <tr>
        <td id="L14985" data-line-number="14985"></td>
        <td id="LC14985"><span><span>//</span> Looks up a previously constructed CordbClass instance without creating. May return NULL if the</span></td>
      </tr>
      <tr>
        <td id="L14986" data-line-number="14986"></td>
        <td id="LC14986"><span><span>//</span> CordbClass instance doesn't exist.</span></td>
      </tr>
      <tr>
        <td id="L14987" data-line-number="14987"></td>
        <td id="LC14987"><span><span>//</span> Argument: (in) vmDomainFile - pointer to the domainfile for the module</span></td>
      </tr>
      <tr>
        <td id="L14988" data-line-number="14988"></td>
        <td id="LC14988"><span><span>//</span>           (in) mdTypeDef    - metadata token for the class</span></td>
      </tr>
      <tr>
        <td id="L14989" data-line-number="14989"></td>
        <td id="LC14989"><span><span>//</span> Return value: pointer to a previously created CordbClass instance or NULL in none exists</span></td>
      </tr>
      <tr>
        <td id="L14990" data-line-number="14990"></td>
        <td id="LC14990">CordbClass * <span>CordbProcess::LookupClass</span>(ICorDebugAppDomain * pAppDomain, VMPTR_DomainFile vmDomainFile, mdTypeDef classToken)</td>
      </tr>
      <tr>
        <td id="L14991" data-line-number="14991"></td>
        <td id="LC14991">{</td>
      </tr>
      <tr>
        <td id="L14992" data-line-number="14992"></td>
        <td id="LC14992">    <span>_ASSERTE</span>(<span>ThreadHoldsProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L14993" data-line-number="14993"></td>
        <td id="LC14993">
</td>
      </tr>
      <tr>
        <td id="L14994" data-line-number="14994"></td>
        <td id="LC14994">    <span>if</span> (pAppDomain != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14995" data-line-number="14995"></td>
        <td id="LC14995">    {</td>
      </tr>
      <tr>
        <td id="L14996" data-line-number="14996"></td>
        <td id="LC14996">        CordbModule * pModule = ((CordbAppDomain *)pAppDomain)-&gt;<span>m_modules</span>.<span>GetBase</span>(<span>VmPtrToCookie</span>(vmDomainFile));</td>
      </tr>
      <tr>
        <td id="L14997" data-line-number="14997"></td>
        <td id="LC14997">        <span>if</span> (pModule != <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L14998" data-line-number="14998"></td>
        <td id="LC14998">        {</td>
      </tr>
      <tr>
        <td id="L14999" data-line-number="14999"></td>
        <td id="LC14999">            <span>return</span> pModule-&gt;<span>LookupClass</span>(classToken);</td>
      </tr>
      <tr>
        <td id="L15000" data-line-number="15000"></td>
        <td id="LC15000">        }</td>
      </tr>
      <tr>
        <td id="L15001" data-line-number="15001"></td>
        <td id="LC15001">    }</td>
      </tr>
      <tr>
        <td id="L15002" data-line-number="15002"></td>
        <td id="LC15002">    <span>return</span> <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L15003" data-line-number="15003"></td>
        <td id="LC15003">} <span><span>//</span> CordbProcess::LookupClass</span></td>
      </tr>
      <tr>
        <td id="L15004" data-line-number="15004"></td>
        <td id="LC15004">
</td>
      </tr>
      <tr>
        <td id="L15005" data-line-number="15005"></td>
        <td id="LC15005"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L15006" data-line-number="15006"></td>
        <td id="LC15006"><span><span>//</span> Look for a specific module in the process.</span></td>
      </tr>
      <tr>
        <td id="L15007" data-line-number="15007"></td>
        <td id="LC15007"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15008" data-line-number="15008"></td>
        <td id="LC15008"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L15009" data-line-number="15009"></td>
        <td id="LC15009"><span><span>//</span>    vmDomainFile - non-null module to lookup</span></td>
      </tr>
      <tr>
        <td id="L15010" data-line-number="15010"></td>
        <td id="LC15010"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15011" data-line-number="15011"></td>
        <td id="LC15011"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L15012" data-line-number="15012"></td>
        <td id="LC15012"><span><span>//</span>    a CordbModule object for the given cookie. Object may be from the cache, or created</span></td>
      </tr>
      <tr>
        <td id="L15013" data-line-number="15013"></td>
        <td id="LC15013"><span><span>//</span>    lazily.</span></td>
      </tr>
      <tr>
        <td id="L15014" data-line-number="15014"></td>
        <td id="LC15014"><span><span>//</span>    Never returns null.  Throws on error.</span></td>
      </tr>
      <tr>
        <td id="L15015" data-line-number="15015"></td>
        <td id="LC15015"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15016" data-line-number="15016"></td>
        <td id="LC15016"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L15017" data-line-number="15017"></td>
        <td id="LC15017"><span><span>//</span>    A VMPTR_DomainFile has appdomain affinity, but is ultimately scoped to a process.</span></td>
      </tr>
      <tr>
        <td id="L15018" data-line-number="15018"></td>
        <td id="LC15018"><span><span>//</span>    So if we get a raw VMPTR_DomainFile (eg, from the stackwalker or from some other</span></td>
      </tr>
      <tr>
        <td id="L15019" data-line-number="15019"></td>
        <td id="LC15019"><span><span>//</span>    lookup function), then we need to do a process wide lookup since we don't know which</span></td>
      </tr>
      <tr>
        <td id="L15020" data-line-number="15020"></td>
        <td id="LC15020"><span><span>//</span>    appdomain it's in. If you know the appdomain, you can use code:CordbAppDomain::LookupOrCreateModule.</span></td>
      </tr>
      <tr>
        <td id="L15021" data-line-number="15021"></td>
        <td id="LC15021"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15022" data-line-number="15022"></td>
        <td id="LC15022">CordbModule * <span>CordbProcess::LookupOrCreateModule</span>(VMPTR_DomainFile vmDomainFile)</td>
      </tr>
      <tr>
        <td id="L15023" data-line-number="15023"></td>
        <td id="LC15023">{</td>
      </tr>
      <tr>
        <td id="L15024" data-line-number="15024"></td>
        <td id="LC15024">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L15025" data-line-number="15025"></td>
        <td id="LC15025">
</td>
      </tr>
      <tr>
        <td id="L15026" data-line-number="15026"></td>
        <td id="LC15026">    RSLockHolder <span>lockHolder</span>(<span>GetProcess</span>()-&gt;<span>GetProcessLock</span>());</td>
      </tr>
      <tr>
        <td id="L15027" data-line-number="15027"></td>
        <td id="LC15027">    <span>_ASSERTE</span>(!vmDomainFile.<span>IsNull</span>());</td>
      </tr>
      <tr>
        <td id="L15028" data-line-number="15028"></td>
        <td id="LC15028">
</td>
      </tr>
      <tr>
        <td id="L15029" data-line-number="15029"></td>
        <td id="LC15029">    DomainFileInfo data;</td>
      </tr>
      <tr>
        <td id="L15030" data-line-number="15030"></td>
        <td id="LC15030">    <span>GetDAC</span>()-&gt;<span>GetDomainFileData</span>(vmDomainFile, &amp;data); <span><span>//</span> throws</span></td>
      </tr>
      <tr>
        <td id="L15031" data-line-number="15031"></td>
        <td id="LC15031">
</td>
      </tr>
      <tr>
        <td id="L15032" data-line-number="15032"></td>
        <td id="LC15032">    CordbAppDomain * pAppDomain = <span>LookupOrCreateAppDomain</span>(data.<span>vmAppDomain</span>);</td>
      </tr>
      <tr>
        <td id="L15033" data-line-number="15033"></td>
        <td id="LC15033">    <span>return</span> pAppDomain-&gt;<span>LookupOrCreateModule</span>(vmDomainFile);</td>
      </tr>
      <tr>
        <td id="L15034" data-line-number="15034"></td>
        <td id="LC15034">}</td>
      </tr>
      <tr>
        <td id="L15035" data-line-number="15035"></td>
        <td id="LC15035">
</td>
      </tr>
      <tr>
        <td id="L15036" data-line-number="15036"></td>
        <td id="LC15036"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L15037" data-line-number="15037"></td>
        <td id="LC15037"><span><span>//</span> Determine if the process has any in-band queued events which have not been dispatched</span></td>
      </tr>
      <tr>
        <td id="L15038" data-line-number="15038"></td>
        <td id="LC15038"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15039" data-line-number="15039"></td>
        <td id="LC15039"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L15040" data-line-number="15040"></td>
        <td id="LC15040"><span><span>//</span>    TRUE iff there are undispatched IB events</span></td>
      </tr>
      <tr>
        <td id="L15041" data-line-number="15041"></td>
        <td id="LC15041"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15042" data-line-number="15042"></td>
        <td id="LC15042">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L15043" data-line-number="15043"></td>
        <td id="LC15043">BOOL <span>CordbProcess::HasUndispatchedNativeEvents</span>()</td>
      </tr>
      <tr>
        <td id="L15044" data-line-number="15044"></td>
        <td id="LC15044">{</td>
      </tr>
      <tr>
        <td id="L15045" data-line-number="15045"></td>
        <td id="LC15045">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L15046" data-line-number="15046"></td>
        <td id="LC15046">
</td>
      </tr>
      <tr>
        <td id="L15047" data-line-number="15047"></td>
        <td id="LC15047">    CordbUnmanagedEvent* pEvent = m_unmanagedEventQueue;</td>
      </tr>
      <tr>
        <td id="L15048" data-line-number="15048"></td>
        <td id="LC15048">    <span>while</span>(pEvent != <span>NULL</span> &amp;&amp; pEvent-&gt;<span>IsDispatched</span>())</td>
      </tr>
      <tr>
        <td id="L15049" data-line-number="15049"></td>
        <td id="LC15049">    {</td>
      </tr>
      <tr>
        <td id="L15050" data-line-number="15050"></td>
        <td id="LC15050">        pEvent = pEvent-&gt;<span>m_next</span>;</td>
      </tr>
      <tr>
        <td id="L15051" data-line-number="15051"></td>
        <td id="LC15051">    }</td>
      </tr>
      <tr>
        <td id="L15052" data-line-number="15052"></td>
        <td id="LC15052">
</td>
      </tr>
      <tr>
        <td id="L15053" data-line-number="15053"></td>
        <td id="LC15053">    <span>return</span> pEvent != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L15054" data-line-number="15054"></td>
        <td id="LC15054">}</td>
      </tr>
      <tr>
        <td id="L15055" data-line-number="15055"></td>
        <td id="LC15055">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L15056" data-line-number="15056"></td>
        <td id="LC15056">
</td>
      </tr>
      <tr>
        <td id="L15057" data-line-number="15057"></td>
        <td id="LC15057"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L15058" data-line-number="15058"></td>
        <td id="LC15058"><span><span>//</span> Determine if the process has any in-band queued events which have not been user continued</span></td>
      </tr>
      <tr>
        <td id="L15059" data-line-number="15059"></td>
        <td id="LC15059"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15060" data-line-number="15060"></td>
        <td id="LC15060"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L15061" data-line-number="15061"></td>
        <td id="LC15061"><span><span>//</span>    TRUE iff there are user uncontinued IB events</span></td>
      </tr>
      <tr>
        <td id="L15062" data-line-number="15062"></td>
        <td id="LC15062"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15063" data-line-number="15063"></td>
        <td id="LC15063">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L15064" data-line-number="15064"></td>
        <td id="LC15064">BOOL <span>CordbProcess::HasUserUncontinuedNativeEvents</span>()</td>
      </tr>
      <tr>
        <td id="L15065" data-line-number="15065"></td>
        <td id="LC15065">{</td>
      </tr>
      <tr>
        <td id="L15066" data-line-number="15066"></td>
        <td id="LC15066">    <span>INTERNAL_API_ENTRY</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L15067" data-line-number="15067"></td>
        <td id="LC15067">
</td>
      </tr>
      <tr>
        <td id="L15068" data-line-number="15068"></td>
        <td id="LC15068">    CordbUnmanagedEvent* pEvent = m_unmanagedEventQueue;</td>
      </tr>
      <tr>
        <td id="L15069" data-line-number="15069"></td>
        <td id="LC15069">    <span>while</span>(pEvent != <span>NULL</span> &amp;&amp; pEvent-&gt;<span>IsEventUserContinued</span>())</td>
      </tr>
      <tr>
        <td id="L15070" data-line-number="15070"></td>
        <td id="LC15070">    {</td>
      </tr>
      <tr>
        <td id="L15071" data-line-number="15071"></td>
        <td id="LC15071">        pEvent = pEvent-&gt;<span>m_next</span>;</td>
      </tr>
      <tr>
        <td id="L15072" data-line-number="15072"></td>
        <td id="LC15072">    }</td>
      </tr>
      <tr>
        <td id="L15073" data-line-number="15073"></td>
        <td id="LC15073">
</td>
      </tr>
      <tr>
        <td id="L15074" data-line-number="15074"></td>
        <td id="LC15074">    <span>return</span> pEvent != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L15075" data-line-number="15075"></td>
        <td id="LC15075">}</td>
      </tr>
      <tr>
        <td id="L15076" data-line-number="15076"></td>
        <td id="LC15076">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L15077" data-line-number="15077"></td>
        <td id="LC15077">
</td>
      </tr>
      <tr>
        <td id="L15078" data-line-number="15078"></td>
        <td id="LC15078"><span><span>//</span>---------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L15079" data-line-number="15079"></td>
        <td id="LC15079"><span><span>//</span> Hijack the thread which had this event. If the thread is already hijacked this method</span></td>
      </tr>
      <tr>
        <td id="L15080" data-line-number="15080"></td>
        <td id="LC15080"><span><span>//</span> has no effect.</span></td>
      </tr>
      <tr>
        <td id="L15081" data-line-number="15081"></td>
        <td id="LC15081"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15082" data-line-number="15082"></td>
        <td id="LC15082"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L15083" data-line-number="15083"></td>
        <td id="LC15083"><span><span>//</span>    pUnmanagedEvent - the debug event which requires us to hijack</span></td>
      </tr>
      <tr>
        <td id="L15084" data-line-number="15084"></td>
        <td id="LC15084"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15085" data-line-number="15085"></td>
        <td id="LC15085"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L15086" data-line-number="15086"></td>
        <td id="LC15086"><span><span>//</span>    S_OK on success, failing HRESULT if the hijack could not be set up</span></td>
      </tr>
      <tr>
        <td id="L15087" data-line-number="15087"></td>
        <td id="LC15087"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15088" data-line-number="15088"></td>
        <td id="LC15088">#<span>ifdef</span> FEATURE_INTEROP_DEBUGGING</td>
      </tr>
      <tr>
        <td id="L15089" data-line-number="15089"></td>
        <td id="LC15089">HRESULT <span>CordbProcess::HijackIBEvent</span>(CordbUnmanagedEvent * pUnmanagedEvent)</td>
      </tr>
      <tr>
        <td id="L15090" data-line-number="15090"></td>
        <td id="LC15090">{</td>
      </tr>
      <tr>
        <td id="L15091" data-line-number="15091"></td>
        <td id="LC15091">    <span><span>//</span> Can't hijack after the event has already been continued hijacked</span></td>
      </tr>
      <tr>
        <td id="L15092" data-line-number="15092"></td>
        <td id="LC15092">    <span>_ASSERTE</span>(!pUnmanagedEvent-&gt;<span>IsEventContinuedHijacked</span>());</td>
      </tr>
      <tr>
        <td id="L15093" data-line-number="15093"></td>
        <td id="LC15093">    <span><span>//</span> Can only hijack IB events</span></td>
      </tr>
      <tr>
        <td id="L15094" data-line-number="15094"></td>
        <td id="LC15094">    <span>_ASSERTE</span>(pUnmanagedEvent-&gt;<span>IsIBEvent</span>());</td>
      </tr>
      <tr>
        <td id="L15095" data-line-number="15095"></td>
        <td id="LC15095">
</td>
      </tr>
      <tr>
        <td id="L15096" data-line-number="15096"></td>
        <td id="LC15096">    <span><span>//</span> If we already hijacked the event then there is nothing left to do</span></td>
      </tr>
      <tr>
        <td id="L15097" data-line-number="15097"></td>
        <td id="LC15097">    <span>if</span>(pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>IsFirstChanceHijacked</span>() ||</td>
      </tr>
      <tr>
        <td id="L15098" data-line-number="15098"></td>
        <td id="LC15098">        pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>IsGenericHijacked</span>())</td>
      </tr>
      <tr>
        <td id="L15099" data-line-number="15099"></td>
        <td id="LC15099">    {</td>
      </tr>
      <tr>
        <td id="L15100" data-line-number="15100"></td>
        <td id="LC15100">        <span>return</span> S_OK;</td>
      </tr>
      <tr>
        <td id="L15101" data-line-number="15101"></td>
        <td id="LC15101">    }</td>
      </tr>
      <tr>
        <td id="L15102" data-line-number="15102"></td>
        <td id="LC15102">
</td>
      </tr>
      <tr>
        <td id="L15103" data-line-number="15103"></td>
        <td id="LC15103">    <span>ResetEvent</span>(<span>this</span>-&gt;<span>m_leftSideUnmanagedWaitEvent</span>);</td>
      </tr>
      <tr>
        <td id="L15104" data-line-number="15104"></td>
        <td id="LC15104">    <span>if</span> (pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>u</span>.<span>Exception</span>.<span>dwFirstChance</span>)</td>
      </tr>
      <tr>
        <td id="L15105" data-line-number="15105"></td>
        <td id="LC15105">    {</td>
      </tr>
      <tr>
        <td id="L15106" data-line-number="15106"></td>
        <td id="LC15106">        HRESULT hr = pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>SetupFirstChanceHijackForSync</span>();</td>
      </tr>
      <tr>
        <td id="L15107" data-line-number="15107"></td>
        <td id="LC15107">        <span>SIMPLIFYING_ASSUMPTION</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L15108" data-line-number="15108"></td>
        <td id="LC15108">        <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L15109" data-line-number="15109"></td>
        <td id="LC15109">    }</td>
      </tr>
      <tr>
        <td id="L15110" data-line-number="15110"></td>
        <td id="LC15110">    <span>else</span> <span><span>//</span> Second chance exceptions must be generic hijacked.</span></td>
      </tr>
      <tr>
        <td id="L15111" data-line-number="15111"></td>
        <td id="LC15111">    {</td>
      </tr>
      <tr>
        <td id="L15112" data-line-number="15112"></td>
        <td id="LC15112">        HRESULT hr = pUnmanagedEvent-&gt;<span>m_owner</span>-&gt;<span>SetupGenericHijack</span>(pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>dwDebugEventCode</span>, &amp;pUnmanagedEvent-&gt;<span>m_currentDebugEvent</span>.<span>u</span>.<span>Exception</span>.<span>ExceptionRecord</span>);</td>
      </tr>
      <tr>
        <td id="L15113" data-line-number="15113"></td>
        <td id="LC15113">        <span>SIMPLIFYING_ASSUMPTION</span>(<span>SUCCEEDED</span>(hr));</td>
      </tr>
      <tr>
        <td id="L15114" data-line-number="15114"></td>
        <td id="LC15114">        <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L15115" data-line-number="15115"></td>
        <td id="LC15115">    }</td>
      </tr>
      <tr>
        <td id="L15116" data-line-number="15116"></td>
        <td id="LC15116">}</td>
      </tr>
      <tr>
        <td id="L15117" data-line-number="15117"></td>
        <td id="LC15117">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L15118" data-line-number="15118"></td>
        <td id="LC15118">
</td>
      </tr>
      <tr>
        <td id="L15119" data-line-number="15119"></td>
        <td id="LC15119"><span><span>//</span> Sets a bitfield reflecting the managed debugging state at the time of</span></td>
      </tr>
      <tr>
        <td id="L15120" data-line-number="15120"></td>
        <td id="LC15120"><span><span>//</span> the jit attach.</span></td>
      </tr>
      <tr>
        <td id="L15121" data-line-number="15121"></td>
        <td id="LC15121">HRESULT <span>CordbProcess::GetAttachStateFlags</span>(CLR_DEBUGGING_PROCESS_FLAGS *pFlags)</td>
      </tr>
      <tr>
        <td id="L15122" data-line-number="15122"></td>
        <td id="LC15122">{</td>
      </tr>
      <tr>
        <td id="L15123" data-line-number="15123"></td>
        <td id="LC15123">    HRESULT hr = S_OK;</td>
      </tr>
      <tr>
        <td id="L15124" data-line-number="15124"></td>
        <td id="LC15124">    <span>PUBLIC_REENTRANT_API_BEGIN</span>(<span>this</span>)</td>
      </tr>
      <tr>
        <td id="L15125" data-line-number="15125"></td>
        <td id="LC15125">    {</td>
      </tr>
      <tr>
        <td id="L15126" data-line-number="15126"></td>
        <td id="LC15126">        <span>if</span>(pFlags == <span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L15127" data-line-number="15127"></td>
        <td id="LC15127">            hr = E_POINTER;</td>
      </tr>
      <tr>
        <td id="L15128" data-line-number="15128"></td>
        <td id="LC15128">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L15129" data-line-number="15129"></td>
        <td id="LC15129">            *pFlags = <span>GetDAC</span>()-&gt;<span>GetAttachStateFlags</span>();</td>
      </tr>
      <tr>
        <td id="L15130" data-line-number="15130"></td>
        <td id="LC15130">    }</td>
      </tr>
      <tr>
        <td id="L15131" data-line-number="15131"></td>
        <td id="LC15131">    <span>PUBLIC_API_END</span>(hr);</td>
      </tr>
      <tr>
        <td id="L15132" data-line-number="15132"></td>
        <td id="LC15132">
</td>
      </tr>
      <tr>
        <td id="L15133" data-line-number="15133"></td>
        <td id="LC15133">    <span>return</span> hr;</td>
      </tr>
      <tr>
        <td id="L15134" data-line-number="15134"></td>
        <td id="LC15134">}</td>
      </tr>
      <tr>
        <td id="L15135" data-line-number="15135"></td>
        <td id="LC15135">
</td>
      </tr>
      <tr>
        <td id="L15136" data-line-number="15136"></td>
        <td id="LC15136"><span><span>//</span> Determine if this version of ICorDebug is compatibile with the ICorDebug in the specified major CLR version</span></td>
      </tr>
      <tr>
        <td id="L15137" data-line-number="15137"></td>
        <td id="LC15137"><span>bool</span> <span>CordbProcess::IsCompatibleWith</span>(DWORD clrMajorVersion)</td>
      </tr>
      <tr>
        <td id="L15138" data-line-number="15138"></td>
        <td id="LC15138">{</td>
      </tr>
      <tr>
        <td id="L15139" data-line-number="15139"></td>
        <td id="LC15139">    <span><span>//</span> The debugger versioning policy is that debuggers generally need to opt-in to supporting major new</span></td>
      </tr>
      <tr>
        <td id="L15140" data-line-number="15140"></td>
        <td id="LC15140">    <span><span>//</span> versions of the CLR.  Often new versions of the CLR violate some invariant that previous debuggers assume</span></td>
      </tr>
      <tr>
        <td id="L15141" data-line-number="15141"></td>
        <td id="LC15141">    <span><span>//</span> (eg. hot/cold splitting in Whidbey, multiple CLRs in a process in CLR v4), and neither VS or the CLR</span></td>
      </tr>
      <tr>
        <td id="L15142" data-line-number="15142"></td>
        <td id="LC15142">    <span><span>//</span> teams generally want the support burden of forward compatibility.</span></td>
      </tr>
      <tr>
        <td id="L15143" data-line-number="15143"></td>
        <td id="LC15143">
</td>
      </tr>
      <tr>
        <td id="L15144" data-line-number="15144"></td>
        <td id="LC15144">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15145" data-line-number="15145"></td>
        <td id="LC15145">    <span><span>//</span> If this assert is firing for you, its probably because the major version</span></td>
      </tr>
      <tr>
        <td id="L15146" data-line-number="15146"></td>
        <td id="LC15146">    <span><span>//</span> number of the clr.dll has changed. This assert is here to remind you to do a bit of other</span></td>
      </tr>
      <tr>
        <td id="L15147" data-line-number="15147"></td>
        <td id="LC15147">    <span><span>//</span> work you may not have realized you needed to do so that our versioning works smoothly</span></td>
      </tr>
      <tr>
        <td id="L15148" data-line-number="15148"></td>
        <td id="LC15148">    <span><span>//</span> for debugging. You probably want to contact the CLR DST team if you are a</span></td>
      </tr>
      <tr>
        <td id="L15149" data-line-number="15149"></td>
        <td id="LC15149">    <span><span>//</span> non-debugger person hitting this. DON'T JUST DELETE THIS ASSERT!!!</span></td>
      </tr>
      <tr>
        <td id="L15150" data-line-number="15150"></td>
        <td id="LC15150">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L15151" data-line-number="15151"></td>
        <td id="LC15151">    <span><span>//</span> 1) You should ensure new versions of all ICorDebug users in DevDiv (VS Debugger, MDbg, etc.)</span></td>
      </tr>
      <tr>
        <td id="L15152" data-line-number="15152"></td>
        <td id="LC15152">    <span><span>//</span>    are using a creation path that explicitly specifies that they support this new major</span></td>
      </tr>
      <tr>
        <td id="L15153" data-line-number="15153"></td>
        <td id="LC15153">    <span><span>//</span>    version of the CLR.</span></td>
      </tr>
      <tr>
        <td id="L15154" data-line-number="15154"></td>
        <td id="LC15154">    <span><span>//</span> 2) You should file an issue to track blocking earlier debuggers from targetting this</span></td>
      </tr>
      <tr>
        <td id="L15155" data-line-number="15155"></td>
        <td id="LC15155">    <span><span>//</span>    version of the CLR (i.e. update requiredVersion to the new CLR major</span></td>
      </tr>
      <tr>
        <td id="L15156" data-line-number="15156"></td>
        <td id="LC15156">    <span><span>//</span>    version).  To enable a smooth internal transition, this often isn't done until absolutely</span></td>
      </tr>
      <tr>
        <td id="L15157" data-line-number="15157"></td>
        <td id="LC15157">    <span><span>//</span>    necessary (sometimes as late as Beta2).</span></td>
      </tr>
      <tr>
        <td id="L15158" data-line-number="15158"></td>
        <td id="LC15158">    <span><span>//</span> 3) You can consider updating the CLR_ID guid used by the shim to recognize a CLR, but only</span></td>
      </tr>
      <tr>
        <td id="L15159" data-line-number="15159"></td>
        <td id="LC15159">    <span><span>//</span>    if it's important to completely hide newer CLRs from the shim.  The expectation now</span></td>
      </tr>
      <tr>
        <td id="L15160" data-line-number="15160"></td>
        <td id="LC15160">    <span><span>//</span>    is that we won't need to do this (i.e. we'd like VS to give a nice error message about</span></td>
      </tr>
      <tr>
        <td id="L15161" data-line-number="15161"></td>
        <td id="LC15161">    <span><span>//</span>    needed a newer version of the debugger, rather than just acting as if a process has no CLR).</span></td>
      </tr>
      <tr>
        <td id="L15162" data-line-number="15162"></td>
        <td id="LC15162">    <span><span>//</span> 4) Update this assert so that it no longer fires for your new CLR version or any of</span></td>
      </tr>
      <tr>
        <td id="L15163" data-line-number="15163"></td>
        <td id="LC15163">    <span><span>//</span>    the previous versions, but don't delete the assert...</span></td>
      </tr>
      <tr>
        <td id="L15164" data-line-number="15164"></td>
        <td id="LC15164">    <span><span>//</span>    the next CLR version after yours will probably need the same reminder</span></td>
      </tr>
      <tr>
        <td id="L15165" data-line-number="15165"></td>
        <td id="LC15165">
</td>
      </tr>
      <tr>
        <td id="L15166" data-line-number="15166"></td>
        <td id="LC15166">    <span>_ASSERTE_MSG</span>(clrMajorVersion &lt;= <span>4</span>,</td>
      </tr>
      <tr>
        <td id="L15167" data-line-number="15167"></td>
        <td id="LC15167">        <span><span>"</span>Found major CLR version greater than 4 in mscordbi.dll from CLRv4 - contact CLRDST<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L15168" data-line-number="15168"></td>
        <td id="LC15168">
</td>
      </tr>
      <tr>
        <td id="L15169" data-line-number="15169"></td>
        <td id="LC15169">    <span><span>//</span> This knob lets us enable forward compatibility for internal scenarios, and also simulate new</span></td>
      </tr>
      <tr>
        <td id="L15170" data-line-number="15170"></td>
        <td id="LC15170">    <span><span>//</span> versions of the runtime for testing the failure user-experience in a version of the debugger</span></td>
      </tr>
      <tr>
        <td id="L15171" data-line-number="15171"></td>
        <td id="LC15171">    <span><span>//</span> before it is shipped.</span></td>
      </tr>
      <tr>
        <td id="L15172" data-line-number="15172"></td>
        <td id="LC15172">    <span><span>//</span> We don't want to risk customers getting this, so for RTM builds this must be CHK-only.</span></td>
      </tr>
      <tr>
        <td id="L15173" data-line-number="15173"></td>
        <td id="LC15173">    <span><span>//</span> To aid in internal transition, we may temporarily enable this in RET builds, but when</span></td>
      </tr>
      <tr>
        <td id="L15174" data-line-number="15174"></td>
        <td id="LC15174">    <span><span>//</span> doing so must file a bug to track making it CHK only again before RTM.</span></td>
      </tr>
      <tr>
        <td id="L15175" data-line-number="15175"></td>
        <td id="LC15175">    <span><span>//</span> For example, Dev10 Beta2 shipped with this knob, but it was made CHK-only at the start of RC.</span></td>
      </tr>
      <tr>
        <td id="L15176" data-line-number="15176"></td>
        <td id="LC15176">    <span><span>//</span> In theory we might have a point release someday where we break debugger compat, but</span></td>
      </tr>
      <tr>
        <td id="L15177" data-line-number="15177"></td>
        <td id="LC15177">    <span><span>//</span> it seems unlikely and since this knob is unsupported anyway we can always extend it</span></td>
      </tr>
      <tr>
        <td id="L15178" data-line-number="15178"></td>
        <td id="LC15178">    <span><span>//</span> then (support reading a string value, etc.).  So for now we just map the number</span></td>
      </tr>
      <tr>
        <td id="L15179" data-line-number="15179"></td>
        <td id="LC15179">    <span><span>//</span> to the major CLR version number.</span></td>
      </tr>
      <tr>
        <td id="L15180" data-line-number="15180"></td>
        <td id="LC15180">    DWORD requiredVersion = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L15181" data-line-number="15181"></td>
        <td id="LC15181">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L15182" data-line-number="15182"></td>
        <td id="LC15182">    requiredVersion = <span>CLRConfig::GetConfigValue</span>(CLRConfig::UNSUPPORTED_Debugging_RequiredVersion);</td>
      </tr>
      <tr>
        <td id="L15183" data-line-number="15183"></td>
        <td id="LC15183">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L15184" data-line-number="15184"></td>
        <td id="LC15184">
</td>
      </tr>
      <tr>
        <td id="L15185" data-line-number="15185"></td>
        <td id="LC15185">    <span><span>//</span> If unset (the only supported configuration), then we require a debugger designed for CLRv4</span></td>
      </tr>
      <tr>
        <td id="L15186" data-line-number="15186"></td>
        <td id="LC15186">    <span><span>//</span>  for desktop, where we do not allow forward compat.</span></td>
      </tr>
      <tr>
        <td id="L15187" data-line-number="15187"></td>
        <td id="LC15187">    <span><span>//</span> For SL, we allow forward compat.  Right now, that means SLv2+ debugger requests can be</span></td>
      </tr>
      <tr>
        <td id="L15188" data-line-number="15188"></td>
        <td id="LC15188">    <span><span>//</span>  honored for SLv4.</span></td>
      </tr>
      <tr>
        <td id="L15189" data-line-number="15189"></td>
        <td id="LC15189">    <span>if</span> (requiredVersion &lt;= <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L15190" data-line-number="15190"></td>
        <td id="LC15190">    {</td>
      </tr>
      <tr>
        <td id="L15191" data-line-number="15191"></td>
        <td id="LC15191">        requiredVersion = <span>2</span>;</td>
      </tr>
      <tr>
        <td id="L15192" data-line-number="15192"></td>
        <td id="LC15192">    }</td>
      </tr>
      <tr>
        <td id="L15193" data-line-number="15193"></td>
        <td id="LC15193">
</td>
      </tr>
      <tr>
        <td id="L15194" data-line-number="15194"></td>
        <td id="LC15194">    <span><span>//</span> Compare the version we were created for against the minimum required</span></td>
      </tr>
      <tr>
        <td id="L15195" data-line-number="15195"></td>
        <td id="LC15195">    <span>return</span> (clrMajorVersion &gt;= requiredVersion);</td>
      </tr>
      <tr>
        <td id="L15196" data-line-number="15196"></td>
        <td id="LC15196">}</td>
      </tr>
      <tr>
        <td id="L15197" data-line-number="15197"></td>
        <td id="LC15197">
</td>
      </tr>
      <tr>
        <td id="L15198" data-line-number="15198"></td>
        <td id="LC15198"><span>bool</span> <span>CordbProcess::IsThreadSuspendedOrHijacked</span>(ICorDebugThread * pICorDebugThread)</td>
      </tr>
      <tr>
        <td id="L15199" data-line-number="15199"></td>
        <td id="LC15199">{</td>
      </tr>
      <tr>
        <td id="L15200" data-line-number="15200"></td>
        <td id="LC15200">    <span><span>//</span> An RS lock can be held while this is called. Specifically,</span></td>
      </tr>
      <tr>
        <td id="L15201" data-line-number="15201"></td>
        <td id="LC15201">    <span><span>//</span> CordbThread::EnumerateChains may be on the stack, and it uses</span></td>
      </tr>
      <tr>
        <td id="L15202" data-line-number="15202"></td>
        <td id="LC15202">    <span><span>//</span> ATT_REQUIRE_STOPPED_MAY_FAIL, which holds the CordbProcess::m_StopGoLock lock for</span></td>
      </tr>
      <tr>
        <td id="L15203" data-line-number="15203"></td>
        <td id="LC15203">    <span><span>//</span> its entire duration. As a result, this needs to be considered a reentrant API. See</span></td>
      </tr>
      <tr>
        <td id="L15204" data-line-number="15204"></td>
        <td id="LC15204">    <span><span>//</span> comments above code:PrivateShimCallbackHolder for more info.</span></td>
      </tr>
      <tr>
        <td id="L15205" data-line-number="15205"></td>
        <td id="LC15205">    <span>PUBLIC_REENTRANT_API_ENTRY_FOR_SHIM</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L15206" data-line-number="15206"></td>
        <td id="LC15206">
</td>
      </tr>
      <tr>
        <td id="L15207" data-line-number="15207"></td>
        <td id="LC15207">    CordbThread * pCordbThread = <span>static_cast</span>&lt;CordbThread *&gt; (pICorDebugThread);</td>
      </tr>
      <tr>
        <td id="L15208" data-line-number="15208"></td>
        <td id="LC15208">    <span>return</span> <span>GetDAC</span>()-&gt;<span>IsThreadSuspendedOrHijacked</span>(pCordbThread-&gt;<span>m_vmThreadToken</span>);</td>
      </tr>
      <tr>
        <td id="L15209" data-line-number="15209"></td>
        <td id="LC15209">}</td>
      </tr>
      <tr>
        <td id="L15210" data-line-number="15210"></td>
        <td id="LC15210">
</td>
      </tr>
      <tr>
        <td id="L15211" data-line-number="15211"></td>
        <td id="LC15211"><span>void</span> <span>CordbProcess::HandleControlCTrapResult</span>(HRESULT result)</td>
      </tr>
      <tr>
        <td id="L15212" data-line-number="15212"></td>
        <td id="LC15212">{</td>
      </tr>
      <tr>
        <td id="L15213" data-line-number="15213"></td>
        <td id="LC15213">    RSLockHolder <span>ch</span>(<span>GetStopGoLock</span>());</td>
      </tr>
      <tr>
        <td id="L15214" data-line-number="15214"></td>
        <td id="LC15214">
</td>
      </tr>
      <tr>
        <td id="L15215" data-line-number="15215"></td>
        <td id="LC15215">    DebuggerIPCEvent eventControlCResult;</td>
      </tr>
      <tr>
        <td id="L15216" data-line-number="15216"></td>
        <td id="LC15216">
</td>
      </tr>
      <tr>
        <td id="L15217" data-line-number="15217"></td>
        <td id="LC15217">    <span>InitIPCEvent</span>(&amp;eventControlCResult,</td>
      </tr>
      <tr>
        <td id="L15218" data-line-number="15218"></td>
        <td id="LC15218">        DB_IPCE_CONTROL_C_EVENT_RESULT,</td>
      </tr>
      <tr>
        <td id="L15219" data-line-number="15219"></td>
        <td id="LC15219">        <span>false</span>,</td>
      </tr>
      <tr>
        <td id="L15220" data-line-number="15220"></td>
        <td id="LC15220">        <span>VMPTR_AppDomain::NullPtr</span>());</td>
      </tr>
      <tr>
        <td id="L15221" data-line-number="15221"></td>
        <td id="LC15221">
</td>
      </tr>
      <tr>
        <td id="L15222" data-line-number="15222"></td>
        <td id="LC15222">    <span><span>//</span> Indicate whether the debugger has handled the event.</span></td>
      </tr>
      <tr>
        <td id="L15223" data-line-number="15223"></td>
        <td id="LC15223">    eventControlCResult.<span>hr</span> = result;</td>
      </tr>
      <tr>
        <td id="L15224" data-line-number="15224"></td>
        <td id="LC15224">
</td>
      </tr>
      <tr>
        <td id="L15225" data-line-number="15225"></td>
        <td id="LC15225">    <span><span>//</span> Send the reply to the LS.</span></td>
      </tr>
      <tr>
        <td id="L15226" data-line-number="15226"></td>
        <td id="LC15226">    <span>SendIPCEvent</span>(&amp;eventControlCResult, <span>sizeof</span>(eventControlCResult));</td>
      </tr>
      <tr>
        <td id="L15227" data-line-number="15227"></td>
        <td id="LC15227">}</td>
      </tr>
</tbody></table>

  

  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>