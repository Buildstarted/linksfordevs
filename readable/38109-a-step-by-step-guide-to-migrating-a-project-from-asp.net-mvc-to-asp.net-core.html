<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A Step-by-Step Guide to Migrating a Project from ASP.NET MVC to ASP.NET Core -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>A Step-by-Step Guide to Migrating a Project from ASP.NET MVC to ASP.NET Core</h1>
    <div class="content"> <img src="https://hackernoon.com/drafts/q21md31as.png"> <div class="paragraph">Here is a practical guide on migrating a project from ASP.NET MVC framework to ASP.NET Core. Step-by-step instruction written by the team of <a href="https://www.nopcommerce.com/">nopCommerce open-source project</a> can be easily applied to any ASP.NET MVC project. </div><p class="paragraph">It also describes why you might need to upgrade, and why projects that do not yet keep up with pace should consider it.</p><p class="paragraph">Before proceeding to the steps of porting from ASP.NET MVC to ASP.NET Core (using nopCommerce as an example), let&apos;s take the quick overview of this framework advantages.</p><p class="paragraph">ASP.NET Core is already a fairly well-known and developed framework with several major updates making it quite stable, technologically advanced and resistant to XSRF/CSRF attacks.</p><div class="image-container"><img src="https://hackernoon.com/photos/W6QKXkwb0ih7ukcCrbvQWbD8NyT2-4g231fq" alt></div><p class="paragraph">Cross-platform is one of the distinguishing features making it more and more popular. From now on, your web application can run both in Windows and Unix environment.&#xA0;</p><p class="paragraph">Modular architecture - ASP.NET Core comes fully in the form of NuGet packages, it allows optimizing the application, including the selected required packages. This improves solution performance and reduces the time it takes to upgrade separate parts. </p><blockquote>This is the second important characteristic that allows developers to integrate new features into their solution more flexible.</blockquote><p class="paragraph">Performance is another step towards building a high-performance application. ASP.NET Core handles 2.300% more requests per second than ASP.NET 4.6, and 800% more requests per second than node.js. </p><div class="paragraph">You can check the detailed performance tests yourself <a href="https://github.com/aspnet/benchmarks">here</a> or<a href="https://www.techempower.com/benchmarks/#section=test&amp;runid=8ca46892-e46c-4088-9443-05722ad6f7fb&amp;hw=ph&amp;test=plaintext"> here</a>.</div><div class="image-container"><img src="https://hackernoon.com/photos/W6QKXkwb0ih7ukcCrbvQWbD8NyT2-zhen31jg" alt></div><p class="paragraph">This approach gives the developer full control over the HTTP pipeline and contributes to the development of simple modules for the application, which is important for a growing open-source project.</p><p class="paragraph">Also, ASP.NET Core MVC provides features that simplify web development. nopCommerce already used some of them, such as the Model-View-Controller template, Razor syntax, model binding, and validation. Among the new features are:</p><ul><li>Tag Helpers. Server-part code for participation in creating and rendering HTML elements in Razor files.</li><li>View components. A new tool, similar to partial views, but of much higher performance. nopCommerce uses view components when reusing rendering logic is required and the task is too complex for partial view.</li><li>DI in views. Although most of the data displayed in views comes from the controller, nopCommerce also has views where dependency injection is more convenient.</li></ul><p class="paragraph">Of course, ASP.NET Core has much more features, we viewed the most interesting ones only.</p><p class="paragraph">Now let&apos;s consider the points to keep in mind when porting your app to a new framework.&#xA0;</p><p class="paragraph">The following descriptions contains large amount of links to the official ASP.NET Core documentation to give more detailed information about the topic and guide developers who face such a task the first time.</p><p class="paragraph"><strong>Step 1. Preparing a toolkit</strong></p><p class="paragraph">The first thing you need is to upgrade Visual Studio 2017 to version 15.3 or later and install the latest version of .NET Core SDK.</p><div class="paragraph">Before porting, we advise to use <a href="https://docs.microsoft.com/en-us/dotnet/standard/analyzers/portability-analyzer">.Net Portability Analyzer</a>. This can be a good starting point to understand how labor-intensive porting from one platform to another will be. Nevertheless, this tool does not cover all the issues, this process has many pitfalls to be solved as they emerge. </div><p class="paragraph">Below we will describe the main steps and the solutions used in nopCommerce project.</p><p class="paragraph"><em>The first and the easiest thing to do is to update links to the libraries used in the project so to they support .NET Standard.</em></p><p class="paragraph"><strong>Step 2. NuGet package compatibility analysis to support .Net standard&#xA0;</strong></p><div class="paragraph">If you use NuGet packages in your project, check whether they are compatible with .NET Core. One way to do this is to use the<a href="https://github.com/NuGetPackageExplorer/NuGetPackageExplorer"> NuGetPackageExplorer</a> tool.&#xA0;</div><p class="paragraph"><strong>Step 3. The new format of csproj file in .NET Core &#xA0;</strong></p><p class="paragraph">A new approach for adding references to third-party packages was introduced in .NET Core. When adding a new class library, you need to open the main project file and replace its contents as follows:</p><div class="code-container"><pre><code><span>&lt;<span>Project</span> <span class="hljs-attr">Sdk</span>=<span>&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span> <span>&lt;<span>PropertyGroup</span>&gt;</span> <span>&lt;<span>TargetFramework</span>&gt;</span>netcoreapp2.2<span>&lt;/<span>TargetFramework</span>&gt;</span> <span>&lt;/<span>PropertyGroup</span>&gt;</span> <span>&lt;<span>ItemGroup</span>&gt;</span> <span>&lt;<span>PackageReference</span> <span class="hljs-attr">Include</span>=<span>&quot;Microsoft.AspNetCore.App&quot;</span> <span class="hljs-attr">Version</span>=<span>&quot;2.2.6&quot;</span> /&gt;</span> ... <span>&lt;/<span>ItemGroup</span>&gt;</span> ...
<span>&lt;/<span>Project</span>&gt;</span></code></pre></div><p class="paragraph">References to the connected libraries will be loaded automatically. </p><div class="paragraph"><em>For more information on comparing the project.json and CSPROJ properties, read the official documentation </em><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/project-json-to-csproj"><em>here</em></a><em> and </em><a href="https://docs.microsoft.com/en-us/dotnet/core/tools/csproj"><em>here.</em></a><em></em></div><p class="paragraph"><strong>Step 4. Namespace update</strong></p><p class="paragraph">Delete all uses of System.Web and replace them with Microsoft.AspNetCore.</p><p class="paragraph"><strong>Step 5. Configure the Startup.cs file instead of using global.asax</strong>&#xA0;</p><div class="paragraph">ASP.NET Core has a new way of loading the app. The app entry point is <pre><code>Startup</code></pre>, and there is no dependency on the Global.asax file. <pre><code>Startup</code></pre> registers the middlewares in the app. <pre><code>Startup</code></pre> must include the <pre><code>Configure</code></pre> method. The required middleware should be added to the pipeline in <pre><code>Configure</code></pre>.</div><p class="paragraph"><strong>Issues to solve in Startup.cs:</strong></p><ol><li>Configuring middleware for MVC and WebAPI requests</li><li>Configuring for:&#xA0;</li></ol><ul><li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-2.2">Exception handling</a>. You will inevitably face various collisions during porting, thus be ready and set up exception handling in the development <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/environments?view=aspnetcore-2.2">environment</a>. With<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.builder.developerexceptionpageextensions.usedeveloperexceptionpage"> UseDeveloperExceptionPage</a>, we add middleware to catch exceptions.</li><li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-2.2">MVC routing</a>. <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-2.2">Registration of new routes</a> has also been changed. IRouteBuilder is now used instead of RouteCollection, as a new way<a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-2.2#understanding-iactionconstraint"> to register restrictions</a> &#xA0;(IActionConstraint)</li><li><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-2.2">MVC/WebAPI filters.</a> The filters should be updated in accordance with <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">the new implementation of ASP.NET Core</a>.&#xA0;</li><li>MVC/<a href="https://docs.microsoft.com/en-us/aspnet/core/web-api/advanced/custom-formatters?view=aspnetcore-2.2">WebAPI Formatters</a></li><li><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-2.2">Binding models</a></li><div class="code-container"><pre><code><span>//add basic MVC feature</span>
<span>var</span> mvcBuilder = services.AddMvc(); <span>//add custom model binder provider (to the top of the provider list)</span>
mvcBuilder.AddMvcOptions(options =&gt; options.ModelBinderProviders.Insert(<span>0</span>, <span>new</span> NopModelBinderProvider()));</code></pre></div><div class="code-container"><pre><code>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span><span class="hljs-doctag">///</span> Represents model binder provider for the creating NopModelBinder</span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span>public</span> <span>class</span> <span>NopModelBinderProvider</span> : <span>IModelBinderProvider</span>
{ <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span> <span><span class="hljs-doctag">///</span> Creates a nop model binder based on passed context</span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;context&quot;&gt;</span>Model binder provider context<span class="hljs-doctag">&lt;/param&gt;</span></span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Model binder<span class="hljs-doctag">&lt;/returns&gt;</span></span> <span class="hljs-function"><span>public</span> IModelBinder <span>GetBinder</span>(<span>ModelBinderProviderContext context</span>)</span> { <span>if</span> (context == <span>null</span>) <span>throw</span> <span>new</span> ArgumentNullException(<span>nameof</span>(context)); <span>var</span> modelType = context.Metadata.ModelType; <span>if</span> (!<span>typeof</span>(BaseNopModel).IsAssignableFrom(modelType)) <span>return</span> <span>null</span>; <span>//use NopModelBinder as a ComplexTypeModelBinder for BaseNopModel</span> <span>if</span> (context.Metadata.IsComplexType &amp;&amp; !context.Metadata.IsCollectionType) { <span>//create binders for all model properties</span> <span>var</span> propertyBinders = context.Metadata.Properties .ToDictionary(modelProperty =&gt; modelProperty, modelProperty =&gt; context.CreateBinder(modelProperty)); <span>return</span> <span>new</span> NopModelBinder(propertyBinders, EngineContext.Current.Resolve&lt;ILoggerFactory&gt;()); } <span>//or return null to further search for a suitable binder</span> <span>return</span> <span>null</span>;
    }
}
</code></pre></div></ul><ul><li><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/areas?view=aspnetcore-2.2">Areas</a>. To include Area in an ASP.NET Core app, add a regular route to the Startup.cs file. For example, this way it will look for configuring Admin/ area </li><div class="code-container"><pre><code>app.UseMvc(routes =&gt; { routes.MapRoute(<span>&quot;areaRoute&quot;</span>, <span>&quot;{area:exists}/{controller=Admin}/{action=Index}/{id?}&quot;</span>); routes.MapRoute( name: <span>&quot;default&quot;</span>, template: <span>&quot;{controller=Home}/{action=Index}/{id?}&quot;</span>); });</code></pre></div><div class="paragraph">When doing it, the folder with the name Area with the Admin folder inside, should be in the app root. Now the attribute <pre><code>[Area(&quot;Admin&quot;)] [Route(&quot;admin&quot;)].</code></pre> will be used to connect the controller with this area.</div><p class="paragraph">It remains only to create views for all the actions described in the controller.</p><div class="image-container"><img src="https://hackernoon.com/photos/W6QKXkwb0ih7ukcCrbvQWbD8NyT2-dl631w7" alt></div><div class="code-container"><pre><code>[<span>Area()</span>]
[<span>Route()</span>]
<span>public</span> <span>class</span> <span>AdminController</span> : <span>Controller</span>
{ <span class="hljs-function"><span>public</span> IActionResult <span>Index</span>(<span></span>)</span> { <span>return</span> View();
    }    
}</code></pre></div><p class="paragraph"><strong>Validation</strong></p><p class="paragraph">IFormCollection should not be passed to the controllers since in this case, asp.net server validation is disabled - MVC is suppressing further validation if the IFormCollection is found to be not null. To solve the problem, this property might be added to the model, this will prevent us from passing directly to the controller method. </p><blockquote>This rule works only if a model is available, if there is no model, there will be no validation.</blockquote><p class="paragraph">Child properties are no longer automatically validated and should be specified manually.</p><p class="paragraph"><strong>Step 6. Migrate HTTP handlers and HttpModules to Middleware</strong></p><div class="paragraph">HTTP handlers and HTTP modules are in fact very similar to the concept of<a href="https://docs.microsoft.com/en-us/aspnet/core/migration/http-modules?view=aspnetcore-2.2"> Middleware in ASP.NET Core</a>, but unlike modules, the middleware order is based on the order in which they are inserted into the request pipeline. The order of modules is mainly based on the events of<a href="https://msdn.microsoft.com/library/ms227673.aspx"> application life cycle.</a> The order of middleware for responses is opposite to the order for requests, while the order of modules for requests and responses is the same. Knowing this, you can proceed with the update.</div><p class="paragraph">What should be updated:</p><ul><li>Migration of modules for Middleware (AuthenticationMiddleware, CultureMiddleware, etc.)</li><li><a href="https://docs.microsoft.com/en-us/aspnet/core/migration/http-modules?view=aspnetcore-2.2#migrating-handler-code-to-middleware">Handlers</a> to Middleware</li><li>Use of new middleware</li></ul><p class="paragraph">Authentication in nopCommerce does not use a built-in authentication system; for this purpose, AuthenticationMiddleware developed in accordance with the new ASP.NET Core structure is used.</p><div class="code-container"><pre><code>
<span>public</span> <span>class</span> <span>AuthenticationMiddleware</span>
{ <span>private</span> <span>readonly</span> RequestDelegate _next; <span class="hljs-function"><span>public</span> <span>AuthenticationMiddleware</span>(<span>IAuthenticationSchemeProvider schemes, RequestDelegate next</span>)</span> { Schemes = schemes ?? <span>throw</span> <span>new</span> ArgumentNullException(<span>nameof</span>(schemes)); _next = next ?? <span>throw</span> <span>new</span> ArgumentNullException(<span>nameof</span>(next)); } <span>public</span> IAuthenticationSchemeProvider Schemes { <span>get</span>; <span>set</span>; } <span class="hljs-function"><span>public</span> <span>async</span> Task <span>Invoke</span>(<span>HttpContext context</span>)</span> { context.Features.Set&lt;IAuthenticationFeature&gt;(<span>new</span> AuthenticationFeature { OriginalPath = context.Request.Path, OriginalPathBase = context.Request.PathBase }); <span>var</span> handlers = context.RequestServices.GetRequiredService&lt;IAuthenticationHandlerProvider&gt;(); <span>foreach</span> (<span>var</span> scheme <span>in</span> <span>await</span> Schemes.GetRequestHandlerSchemesAsync()) { <span>try</span> { <span>if</span> (<span>await</span> handlers.GetHandlerAsync(context, scheme.Name) <span>is</span> IAuthenticationRequestHandler handler &amp;&amp; <span>await</span> handler.HandleRequestAsync()) <span>return</span>; } <span>catch</span> { <span>// ignored</span> } } <span>var</span> defaultAuthenticate = <span>await</span> Schemes.GetDefaultAuthenticateSchemeAsync(); <span>if</span> (defaultAuthenticate != <span>null</span>) { <span>var</span> result = <span>await</span> context.AuthenticateAsync(defaultAuthenticate.Name); <span>if</span> (result?.Principal != <span>null</span>) { context.User = result.Principal; } } <span>await</span> _next(context);
   }
}
</code></pre></div><div class="paragraph">ASP.NET provides a lot of built-in middleware that you can use in your application, but the developer can also <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write?view=aspnetcore-2.2">create his own middleware</a> and add it to HTTP request pipeline. </div><p class="paragraph">To simplify this process, we added a special interface to nopCommerce, and now it&#x2019;s enough to just create a class that implements it.</p><div class="code-container"><pre><code>
<span>public</span> <span>interface</span> <span>INopStartup</span>
{ <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span> <span><span class="hljs-doctag">///</span> Add and configure any of the middleware</span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;services&quot;&gt;</span>Collection of service descriptors<span class="hljs-doctag">&lt;/param&gt;</span></span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;configuration&quot;&gt;</span>Configuration of the application<span class="hljs-doctag">&lt;/param&gt;</span></span> <span class="hljs-function"><span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection services, IConfiguration configuration</span>)</span>; <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span> <span><span class="hljs-doctag">///</span> Configure the using of added middleware</span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;application&quot;&gt;</span>Builder for configuring an application&apos;s request pipeline<span class="hljs-doctag">&lt;/param&gt;</span></span> <span class="hljs-function"><span>void</span> <span>Configure</span>(<span>IApplicationBuilder application</span>)</span>; <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span> <span><span class="hljs-doctag">///</span> Gets order of this startup configuration implementation</span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span> <span>int</span> Order { <span>get</span>; }
}
</code></pre></div><p class="paragraph">Here you can add and configure your middleware:</p><div class="code-container"><pre><code>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span><span class="hljs-doctag">///</span> Represents object for the configuring authentication middleware on application startup</span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span>public</span> <span>class</span> <span>AuthenticationStartup</span> : <span>INopStartup</span>
{ <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span> <span><span class="hljs-doctag">///</span> Add and configure any of the middleware</span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;services&quot;&gt;</span>Collection of service descriptors<span class="hljs-doctag">&lt;/param&gt;</span></span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;configuration&quot;&gt;</span>Configuration of the application<span class="hljs-doctag">&lt;/param&gt;</span></span> <span class="hljs-function"><span>public</span> <span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection services, IConfiguration configuration</span>)</span> { <span>//add data protection</span> services.AddNopDataProtection(); <span>//add authentication</span> services.AddNopAuthentication(); } <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span> <span><span class="hljs-doctag">///</span> Configure the using of added middleware</span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;application&quot;&gt;</span>Builder for configuring an application&apos;s request pipeline<span class="hljs-doctag">&lt;/param&gt;</span></span> <span class="hljs-function"><span>public</span> <span>void</span> <span>Configure</span>(<span>IApplicationBuilder application</span>)</span> { <span>//configure authentication</span> application.UseNopAuthentication(); } <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span> <span><span class="hljs-doctag">///</span> Gets order of this startup configuration implementation</span> <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span> <span>public</span> <span>int</span> Order =&gt; <span>500</span>; <span>//authentication should be loaded before MVC</span>
}
</code></pre></div><p class="paragraph"><strong>Step 7. Using built-in DI</strong></p><div class="paragraph"><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2">Dependency</a> injection is one of the key features when designing an app in ASP.NET Core. You can develop loosely coupled applications that are more testable, modular and as a result more maintainable. This was made possible by following the principle of dependency inversion. </div><p class="paragraph">To inject dependencies, we used IoC (Inversion of Control) containers. In ASP.NET Core, such a container is represented by the IServiceProvider interface. Services are installed in the app in the Startup.ConfigureServices() method.</p><p class="paragraph">Any registered service can be configured with three scopes:</p><div class="code-container"><pre><code>
services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
options.UseSqlServer(Configuration.GetConnectionString(<span>&quot;DefaultConnection&quot;</span>)));
services.AddSingleton&lt;Isingleton,MySingleton&gt;();
</code></pre></div><p class="paragraph"><strong>Step 8. Using WebAPI project compatibility shells (Shim)</strong></p><ul><li>Adding ApiController type;</li><li>Enabling web API style model binding;</li><li>Extending model binding so that controller actions can accept HttpRequestMessage type parameters;</li><li>Adding message formatters enabling actions to return results of HttpResponseMessage type.</li></ul><div class="code-container"><pre><code>
services.AddMvc().AddWebApiConventions(); routes.MapWebApiRoute(name: <span>&quot;DefaultApi&quot;</span>, template: <span>&quot;api/{controller}/{id?}&quot;</span>
);
</code></pre></div><p class="paragraph"><strong>Step 9. Porting Application Configuration</strong></p><div class="paragraph">Some settings were previously saved in the web.config file. Now we use <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/index?tabs=basicconfiguration&amp;view=aspnetcore-2.2">a new approach</a> based on the key-value pairs set by <em>configuration providers</em>. This is the recommended method in ASP.NET Core, and we use the appsettings.json file.</div><div class="paragraph">You can also use the NuGet package <pre><code>System.Configuration.ConfigurationManager</code></pre> if for some reason you want to continue using *.config. In this case, the app cannot run on Unix platforms, but on IIS only.</div><p class="paragraph"><strong>Step 10. Porting static content to wwwroot</strong></p><div class="paragraph">To serve <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/static-files?view=aspnetcore-2.2">static content</a>, specify to web host the content root of the current directory. The default is wwwroot. You can configure your folder for storing static files by setting up middleware.</div><div class="image-container"><img src="https://hackernoon.com/photos/W6QKXkwb0ih7ukcCrbvQWbD8NyT2-ix1tc31fz" alt></div><p class="paragraph"><strong>Step 11. Porting EntityFramework to EF Core</strong></p><div class="paragraph">If the project uses some specific<a href="https://docs.microsoft.com/en-us/ef/efcore-and-ef6/"> features of Entity Framework 6</a>, that are <a href="https://docs.microsoft.com/en-us/ef/efcore-and-ef6/">not supported</a> in EF Core, it makes sense to run the application on the NET Framework. Though in this case, we will have to reject the multi-platform feature, and the application will run on Windows and IIS only.&#xA0;</div><p class="paragraph">Below are the main changes to be considered:</p><ul><li>System.Data.Entity namespace is replaced by Microsoft.EntityFrameworkCore;</li><li>The signature of the DbContext constructor has been changed. Now you should inject DbContextOptions;</li><li>HasDatabaseGeneratedOption(DatabaseGeneratedOption.None) method is replaced by ValueGeneratedNever();</li><li>WillCascadeOnDelete(false) method is replaced by OnDelete (DeleteBehavior.Restrict);</li><li>OnModelCreating(DbModelBuilder modelBuilder) method is replaced by OnModelCreating(ModelBuilder modelBuilder);</li><li>HasOptional method is no longer available;</li><li>Object configuration is changed, now OnModelCreating is using since EntityTypeConfiguration is no longer available;</li><li>ComplexType attribute is no longer available;</li><li>IDbSet interface is replaced by DbSet;</li><li>ComplexType - complex type support appeared in EF Core 2 with the <a href="https://docs.microsoft.com/en-us/ef/core/modeling/owned-entities">Owned Entity</a> type, and tables without Primary Key with <a href="https://docs.microsoft.com/en-us/ef/core/modeling/query-types">QueryType</a> in EF Core 2.1;</li><li>External keys in EF Core generate <a href="https://docs.microsoft.com/en-us/ef/core/modeling/shadow-properties">shadow properties</a> using the [Entity]Id template, unlike EF6, that uses the [Entity]_Id template. Therefore, add external keys as a regular property to the entity first;</li><li>To support DI for DbContext, configure your DbContex in ConfigureServices.</li></ul><div class="code-container"><pre><code>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span><span class="hljs-doctag">///</span> Register base object context</span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;services&quot;&gt;</span>Collection of service descriptors<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-function"><span>public</span> <span>static</span> <span>void</span> <span>AddNopObjectContext</span>(<span><span>this</span> IServiceCollection services</span>)</span>
{ services.AddDbContextPool&lt;NopObjectContext&gt;(optionsBuilder =&gt; { optionsBuilder.UseSqlServerWithLazyLoading(services); });
} <span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span><span class="hljs-doctag">///</span> SQL Server specific extension method for Microsoft.EntityFrameworkCore.DbContextOptionsBuilder</span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;optionsBuilder&quot;&gt;</span>Database context options builder<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;services&quot;&gt;</span>Collection of service descriptors<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-function"><span>public</span> <span>static</span> <span>void</span> <span>UseSqlServerWithLazyLoading</span>(<span><span>this</span> DbContextOptionsBuilder optionsBuilder, IServiceCollection services</span>)</span>
{ <span>var</span> nopConfig = services.BuildServiceProvider().GetRequiredService&lt;NopConfig&gt;(); <span>var</span> dataSettings = DataSettingsManager.LoadSettings(); <span>if</span> (!dataSettings?.IsValid ?? <span>true</span>) <span>return</span>; <span>var</span> dbContextOptionsBuilder = optionsBuilder.UseLazyLoadingProxies(); <span>if</span> (nopConfig.UseRowNumberForPaging) dbContextOptionsBuilder.UseSqlServer(dataSettings.DataConnectionString, option =&gt; option.UseRowNumberForPaging()); <span>else</span>
        dbContextOptionsBuilder.UseSqlServer(dataSettings.DataConnectionString);
}
</code></pre></div><div class="paragraph">To verify that EF Core generates a similar database structure as Entity Framework when <a href="https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/">migrating</a>, use the<a href="http://www.red-gate.com/products/sql-development/sql-compare/"> &#xA0;SQL Compare</a> tool.</div><p class="paragraph"><br><strong>Step 12. Removing all HttpContext references and replacing obsolete classes and changing the namespace</strong></p><p class="paragraph">During the project migration, you will find that a sufficiently large number of classes have been renamed or moved, and now you should comply with the new requirements. Here is a list of the main changes you may encounter:</p><ul><li>HttpPostedFileBase &#x1F86A; FormFile</li><li>Access HttpContext can now be accessed via IHttpContextAccessor</li><li>HtmlHelper &#x1F86A; HtmlHelper</li><li>ActionResult &#x1F86A; ActionResult</li><li>HttpUtility &#x1F86A; WebUtility</li><li>ISession instead of HttpSessionStateBase accessible from HttpContext.Session. from Microsoft.AspNetCore.Http</li><li>Request.Cookies returns IRequestCookieCollection: IEnumerable &lt;KeyValuePair&lt;string, string&gt; &gt;, then instead of HttpCookie we use KeyValuePair &lt;string, string&gt; from Microsoft.AspNetCore.Http</li></ul><p class="paragraph">Namespace replacement:</p><ul><li>SelectList &#x1F86A; Microsoft.AspNetCore.Mvc.Rendering</li><li>UrlHelper &#x1F86A; WebUtitlity</li><li>MimeMapping &#x1F86A; FileExtensionContentTypeProvider</li><li>MvcHtmlString &#x1F86A; IHtmlString and HtmlString</li><li>ModelState, ModelStateDictionary, ModelError &#x1F86A; Microsoft.AspNetCore.Mvc.ModelBinding</li><li>FormCollection &#x1F86A; IFormCollection</li><li>Request.Url.Scheme &#x1F86A; this.Url.ActionContext.HttpContext.Request.Scheme</li></ul><p class="paragraph">Other:</p><ul><li>MvcHtmlString.IsNullOrEmpty(IHtmlString) &#x1F86A; String.IsNullOrEmpty(variable.ToHtmlString())</li><li>[ValidateInput (false)] - does not exist anymore and is no longer needed</li><li>HttpUnauthorizedResult &#x1F86A; UnauthorizedResult</li><li>[AllowHtml] - directive does not exist anymore and is no longer needed</li><li>TagBuilder.SetInnerText method is replaced by InnerHtml.AppendHtml</li><li>JsonRequestBehavior.AllowGet when returning Json is no longer needed</li><li>HttpUtility.JavaScriptStringEncode. JavaScriptEncoder.Default.Encode</li><li>Request.RawUrl. Request.Path + Request.QueryString should be separately connected</li><li>AllowHtmlAttribute - class no longer exists</li><li>XmlDownloadResult - now you can use just return File(Encoding.UTF8.GetBytes (xml), &quot;application / xml&quot;, &quot;filename.xml&quot;);</li><li>&#xA0;[ValidateInput(false)] - directive does not exist anymore and is no longer needed</li></ul><p class="paragraph"><strong>Step 13. Authentication and authorization update</strong></p><p class="paragraph">As was already mentioned above, nopCommerce project does not involve the built-in authentication system, it is implemented in a separate middleware layer. </p><div class="paragraph"><em>However, ASP.NET Core has its own system for credentials providing. You can view the</em><a href="https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-2.2#authentication-vs-authorization"><em> documentation</em></a><em> to know about them in details.</em></div><div class="paragraph">As for data protection, we no longer use <a href="https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/compatibility/replacing-machinekey?view=aspnetcore-2.2">MachineKey</a>. Instead, we use the built-in data protection feature. By default, keys are generated when the application starts. As the data storage can be:</div><ul><li>File system - file system-based keystore</li><li>Azure Storage - data protection keys in Azure BLOB object storage</li><li>Redis - data protection keys in the Redis cache</li><li>Registry - used if the application does not have access to the file system</li><li>EF Core - keys are stored in the database</li></ul><div class="paragraph">If the built-in providers are not suitable, you can specify your own key storage provider by making a custom<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.dataprotection.repositories.ixmlrepository"> IXmlRepository</a>.</div><p class="paragraph"><strong>Step 14. JS/CSS update</strong></p><p class="paragraph">The way of using static resources has changed, now they should all be stored in the root folder of the project <em>wwwroot</em>, unless other settings are made.</p><p class="paragraph">When using javascript built-in blocks, we recommend moving them to the end of the page. Just use the asp-location = &quot;Footer&quot; attribute for your &lt;script&gt; tags. The same rule applies to js files.</p><div class="paragraph">Use the<a href="https://github.com/madskristensen/BundlerMinifier"> BundlerMinifier</a> extension as a replacement for System.Web.Optimization - this will enable bundling and minification. JavaScript and CSS while building the project (<a href="https://docs.microsoft.com/en-us/aspnet/core/client-side/bundling-and-minification">view the documentation</a>).</div><p class="paragraph"><strong>Step 15. Porting views</strong></p><div class="paragraph">First of all, Child Actions are no longer used, instead, ASP.NET Core suggests using a new high-performance tool - <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/view-components?view=aspnetcore-2.2">ViewComponents</a> called asynchronously.</div><p class="paragraph">How to get a string from ViewComponent:</p><div class="code-container"><pre><code>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span><span class="hljs-doctag">///</span> Render component to string</span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;componentName&quot;&gt;</span>Component name<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;arguments&quot;&gt;</span>Arguments<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Result<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-function"><span>protected</span> <span>virtual</span> <span>string</span> <span>RenderViewComponentToString</span>(<span><span>string</span> componentName, <span>object</span> arguments = <span>null</span></span>)</span>
{ <span>if</span> (<span>string</span>.IsNullOrEmpty(componentName)) <span>throw</span> <span>new</span> ArgumentNullException(<span>nameof</span>(componentName)); <span>var</span> actionContextAccessor = HttpContext.RequestServices.GetService(<span>typeof</span>(IActionContextAccessor)) <span>as</span> IActionContextAccessor; <span>if</span> (actionContextAccessor == <span>null</span>) <span>throw</span> <span>new</span> Exception(<span>&quot;IActionContextAccessor cannot be resolved&quot;</span>); <span>var</span> context = actionContextAccessor.ActionContext; <span>var</span> viewComponentResult = ViewComponent(componentName, arguments); <span>var</span> viewData = ViewData; <span>if</span> (viewData == <span>null</span>) { <span>throw</span> <span>new</span> NotImplementedException(); } <span>var</span> tempData = TempData; <span>if</span> (tempData == <span>null</span>) { <span>throw</span> <span>new</span> NotImplementedException(); } <span>using</span> (<span>var</span> writer = <span>new</span> StringWriter()) { <span>var</span> viewContext = <span>new</span> ViewContext( context, NullView.Instance, viewData, tempData, writer, <span>new</span> HtmlHelperOptions()); <span>// IViewComponentHelper is stateful, we want to make sure to retrieve it every time we need it.</span> <span>var</span> viewComponentHelper = context.HttpContext.RequestServices.GetRequiredService&lt;IViewComponentHelper&gt;(); (viewComponentHelper <span>as</span> IViewContextAware)?.Contextualize(viewContext); <span>var</span> result = viewComponentResult.ViewComponentType == <span>null</span> ? viewComponentHelper.InvokeAsync(viewComponentResult.ViewComponentName, viewComponentResult.Arguments): viewComponentHelper.InvokeAsync(viewComponentResult.ViewComponentType, viewComponentResult.Arguments); result.Result.WriteTo(writer, HtmlEncoder.Default); <span>return</span> writer.ToString();
    }
}
</code></pre></div><div class="paragraph">Note that there is no need to use HtmlHelper anymore, ASP.NET Core includes many auxiliary built-in <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/intro?view=aspnetcore-2.2#built-in-aspnet-core-tag-helpers">Tag Helpers</a>. When the application is running, the Razor engine handles them on the server and ultimately converts to standard html elements. </div><blockquote>This makes application development a whole lot easier. And of course, you can implement your own tag helpers.</blockquote><p class="paragraph">We started using dependency injection in views instead of enabling settings and services using EngineContext.</p><p class="paragraph">So, the main points on porting views are as follows:</p><ul><li>Convert Views/web.config to Views/_ViewImports.cshtml - to import namespaces and inject dependencies. This file does not support other Razor features, such as function and section definitions</li><li>Convert namespaces.add to @using</li><li>Porting any settings to the main application configuration</li><li>Scripts.Render and Styles.Render do not exist. Replace with links to output data of libman or BundlerMinifier</li></ul><p class="paragraph">The process of migrating a large web application is a very time-consuming task which, as a rule, cannot be carried out without the pitfalls. We planned to migrate to a new framework as soon as its first stable version was released but were not able to make it right away, as there were some critical features that had not been transferred to .NET Core, in particular, those related to EntityFramework. </p><p class="paragraph">Therefore, we had first to make our release using a mixed approach - the .NET Core architecture with the .NET Framework dependencies, which in itself is a unique solution. </p><blockquote>Being first is not easy, but we are sure we&#x2019;ve made the right choice, and our huge community supported us in this.</blockquote><p class="paragraph">We were able to fully adapt our project after the release of .NET Core 2.1, having by that time a stable solution already working on the new architecture. It remained only to replace some packages and rewrite the work with EF Core. </p><p class="paragraph">Thus, it took us several months and two released versions to completely migrate to the new framework.&#xA0;</p><div class="paragraph">We can say with confidence that we are the <a href="https://www.nopcommerce.com/">first large project</a> <a href="https://www.nopcommerce.com/"></a>to carry out such a migration. In this guide, we tried to put together the entire migration process in a structured form and describe various bottlenecks so that other developers could rely on this material and follow the roadmap when solving the same task.</div></ul> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>