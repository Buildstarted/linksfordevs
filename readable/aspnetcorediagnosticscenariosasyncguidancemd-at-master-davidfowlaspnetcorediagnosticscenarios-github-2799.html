<!DOCTYPE html>
<html lang="en">
<head>
    <title>
davidfowl/AspNetCoreDiagnosticScenarios - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="davidfowl/AspNetCoreDiagnosticScenarios - linksfor.dev(s)"/>
    <meta property="og:description" content="This repository has examples of broken patterns in ASP.NET Core applications - davidfowl/AspNetCoreDiagnosticScenarios"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - davidfowl/AspNetCoreDiagnosticScenarios</title>
<div class="readable">
        <h1>davidfowl/AspNetCoreDiagnosticScenarios</h1>
            <div>Reading time: 28-35 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md">https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    <article itemprop="text">
<ul>
<li><a href="#asynchronous-programming">Asynchronous Programming</a>
<ul>
<li><a href="#asynchrony-is-viral">Asynchrony is viral</a></li>
<li><a href="#async-void">Async void</a></li>
<li><a href="#prefer-taskfromresult-over-taskrun-for-pre-computed-or-trivially-computed-data">Prefer Task.FromResult over Task.Run for pre-computed or trivially computed data</a></li>
<li><a href="#avoid-using-taskrun-for-long-running-work-that-blocks-the-thread">Avoid using Task.Run for long running work that blocks the thread</a></li>
<li><a href="#avoid-using-taskresult-and-taskwait">Avoid using Task.Result and Task.Wait</a></li>
<li><a href="#prefer-await-over-continuewith">Prefer await over ContinueWith</a></li>
<li><a href="#always-create-taskcompletionsourcet-with-taskcreationoptionsruncontinuationsasynchronously">Always create TaskCompletionSource&lt;T&gt; with TaskCreationOptions.RunContinuationsAsynchronously</a></li>
<li><a href="#always-dispose-cancellationtokensources-used-for-timeouts">Always dispose CancellationTokenSource(s) used for timeouts</a></li>
<li><a href="#always-flow-cancellationtokens-to-apis-that-take-a-cancellationtoken">Always flow CancellationToken(s) to APIs that take a CancellationToken</a></li>
<li><a href="#cancelling-uncancellable-operations">Cancelling uncancellable operations</a></li>
<li><a href="#always-call-flushasync-on-streamwriters-or-streams-before-calling-dispose">Always call FlushAsync on StreamWriter(s) or Stream(s) before calling Dispose</a></li>
<li><a href="#prefer-asyncawait-over-directly-returning-task">Prefer async/await over directly returning Task</a></li>
<li><a href="#configureawait">ConfigureAwait</a></li>
</ul>
</li>
<li><a href="#scenarios">Scenarios</a>
<ul>
<li><a href="#timer-callbacks">Timer callbacks</a></li>
<li><a href="#implicit-async-void-delegates">Implicit async void delegates</a></li>
<li><a href="#concurrentdictionarygetoradd">ConcurrentDictionary.GetOrAdd</a></li>
<li><a href="#constructors">Constructors</a></li>
<li><a href="#windowsidentityrunimpersonated">WindowsIdentity.RunImpersonated</a></li>
</ul>
</li>
</ul>

<p>Asynchronous programming has been around for several years on the .NET platform but has historically been very difficult to do well. Since the introduction of async/await
in C# 5 asynchronous programming has become mainstream. Modern frameworks (like ASP.NET Core) are fully asynchronous and it's very hard to avoid the async keyword when writing
web services. As a result, there's been lots of confusion on the best practices for async and how to use it properly. This section will try to lay out some guidance with examples of bad and good patterns of how to write asynchronous code.</p>
<h2>Asynchrony is viral</h2>
<p>Once you go async, all of your callers <strong>SHOULD</strong> be async, since efforts to be async amount to nothing unless the entire callstack is async. In many cases, being partially async can be worse than being entirely synchronous. Therefore it is best to go all in, and make everything async at once.</p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example uses the <code>Task.Result</code> and as a result blocks the current thread to wait for the result. This is an example of <a href="#avoid-using-taskresult-and-taskwait">sync over async</a>.</p>
<div><pre><span>public</span> <span>int</span> <span>DoSomethingAsync</span>()
{
    <span>var</span> <span>result</span> <span>=</span> <span>CallDependencyAsync</span>().<span>Result</span>;
    <span>return</span> <span>result</span> <span>+</span> <span>1</span>;
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example uses the await keyword to get the result from <code>CallDependencyAsync</code>.</p>
<div><pre><span>public</span> <span>async</span> <span>Task</span>&lt;<span>int</span>&gt; <span>DoSomethingAsync</span>()
{
    <span>var</span> <span>result</span> <span>=</span> <span>await</span> <span>CallDependencyAsync</span>();
    <span>return</span> <span>result</span> <span>+</span> <span>1</span>;
}</pre></div>
<h2>Async void</h2>
<p>Use of async void in ASP.NET Core applications is <strong>ALWAYS</strong> bad. Avoid it, never do it. Typically, it's used when developers are trying to implement fire and forget patterns triggered by a controller action. Async void methods will crash the process if an exception is thrown. We'll look at more of the patterns that cause developers to do this in ASP.NET Core applications but here's a simple example:</p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> Async void methods can't be tracked and therefore unhandled exceptions can result in application crashes.</p>
<div><pre><span>public</span> <span>class</span> <span>MyController</span> : <span>Controller</span>
{
    [<span>HttpPost</span>(<span><span>"</span>/start<span>"</span></span>)]
    <span>public</span> <span>IActionResult</span> <span>Post</span>()
    {
        <span>BackgroundOperationAsync</span>();
        <span>return</span> <span>Accepted</span>();
    }
    
    <span>public</span> <span>async</span> <span>void</span> <span>BackgroundOperationAsync</span>()
    {
        <span>var</span> <span>result</span> <span>=</span> <span>await</span> <span>CallDependencyAsync</span>();
        <span>DoSomething</span>(<span>result</span>);
    }
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> <code>Task</code>-returning methods are better since unhandled exceptions trigger the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler.unobservedtaskexception?view=netframework-4.7.2" rel="nofollow"><code>TaskScheduler.UnobservedTaskException</code></a>.</p>
<div><pre><span>public</span> <span>class</span> <span>MyController</span> : <span>Controller</span>
{
    [<span>HttpPost</span>(<span><span>"</span>/start<span>"</span></span>)]
    <span>public</span> <span>IActionResult</span> <span>Post</span>()
    {
        <span>Task</span>.<span>Run</span>(<span>BackgroundOperationAsync</span>);
        <span>return</span> <span>Accepted</span>();
    }
    
    <span>public</span> <span>async</span> <span>Task</span> <span>BackgroundOperationAsync</span>()
    {
        <span>var</span> <span>result</span> <span>=</span> <span>await</span> <span>CallDependencyAsync</span>();
        <span>DoSomething</span>(<span>result</span>);
    }
}</pre></div>
<h2>Prefer <code>Task.FromResult</code> over <code>Task.Run</code> for pre-computed or trivially computed data</h2>
<p>For pre-computed results, there's no need to call <code>Task.Run</code>, that will end up queuing a work item to the thread pool that will immediately complete with the pre-computed value. Instead, use <code>Task.FromResult</code>, to create a task wrapping already computed data.</p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example wastes a thread-pool thread to return a trivially computed value.</p>
<div><pre><span>public</span> <span>class</span> <span>MyLibrary</span>
{
   <span>public</span> <span>Task</span>&lt;<span>int</span>&gt; <span>AddAsync</span>(<span>int</span> <span>a</span>, <span>int</span> <span>b</span>)
   {
       <span>return</span> <span>Task</span>.<span>Run</span>(() <span>=&gt;</span> <span>a</span> <span>+</span> <span>b</span>);
   }
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example uses <code>Task.FromResult</code> to return the trivially computed value. It does not use any extra threads as a result.</p>
<div><pre><span>public</span> <span>class</span> <span>MyLibrary</span>
{
   <span>public</span> <span>Task</span>&lt;<span>int</span>&gt; <span>AddAsync</span>(<span>int</span> <span>a</span>, <span>int</span> <span>b</span>)
   {
       <span>return</span> <span>Task</span>.<span>FromResult</span>(<span>a</span> <span>+</span> <span>b</span>);
   }
}</pre></div>
<p><g-emoji alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">üí°</g-emoji><strong>NOTE: Using <code>Task.FromResult</code> will result in a <code>Task</code> allocation. Using <code>ValueTask&lt;T&gt;</code> can completely remove that allocation.</strong></p>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example uses a <code>ValueTask&lt;int&gt;</code> to return the trivially computed value. It does not use any extra threads as a result. It also does not allocate an object on the managed heap.</p>
<div><pre><span>public</span> <span>class</span> <span>MyLibrary</span>
{
   <span>public</span> <span>ValueTask</span>&lt;<span>int</span>&gt; <span>AddAsync</span>(<span>int</span> <span>a</span>, <span>int</span> <span>b</span>)
   {
       <span>return</span> <span>new</span> <span>ValueTask</span>&lt;<span>int</span>&gt;(<span>a</span> <span>+</span> <span>b</span>);
   }
}</pre></div>
<h2>Avoid using Task.Run for long running work that blocks the thread</h2>
<p>Long running work in this context refers to a thread that's running for the lifetime of the application doing background work (like processing queue items, or sleeping and waking up to process some data). <code>Task.Run</code> will queue a work item to the thread pool. The assumption is that that work will finish quickly (or quickly enough to allow reusing that thread within some reasonable timeframe). Stealing a thread-pool thread for long-running work is bad since it takes that thread away from other work that could be done (timer callbacks, task continuations etc). Instead, spawn a new thread manually to do long running blocking work.</p>
<p><g-emoji alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">üí°</g-emoji> <strong>NOTE: The thread pool grows if you block threads but it's bad practice to do so.</strong></p>
<p><g-emoji alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">üí°</g-emoji> <strong>NOTE:<code>Task.Factory.StartNew</code> has an option <code>TaskCreationOptions.LongRunning</code> that under the covers creates a new thread and returns a Task that represents the execution. Using this properly requires several non-obvious parameters to be passed in to get the right behavior on all platforms.</strong></p>
<p><g-emoji alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">üí°</g-emoji> <strong>NOTE: Don't use <code>TaskCreationOptions.LongRunning</code> with async code as this will create a new thread which will be destroyed after first <code>await</code>.</strong></p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example steals a thread-pool thread forever, to execute queued work on a <code>BlockingCollection&lt;T&gt;</code>.</p>
<div><pre><span>public</span> <span>class</span> <span>QueueProcessor</span>
{
    <span>private</span> <span>readonly</span> <span>BlockingCollection</span>&lt;<span>Message</span>&gt; <span>_messageQueue</span> <span>=</span> <span>new</span> <span>BlockingCollection</span>&lt;<span>Message</span>&gt;();
    
    <span>public</span> <span>void</span> <span>StartProcessing</span>()
    {
        <span>Task</span>.<span>Run</span>(<span>ProcessQueue</span>);
    }
    
    <span>public</span> <span>void</span> <span>Enqueue</span>(<span>Message</span> <span>message</span>)
    {
        <span>_messageQueue</span>.<span>Add</span>(<span>message</span>);
    }
    
    <span>private</span> <span>void</span> <span>ProcessQueue</span>()
    {
        <span>foreach</span> (<span>var</span> <span>item</span> <span>in</span> <span>_messageQueue</span>.<span>GetConsumingEnumerable</span>())
        {
             <span>ProcessItem</span>(<span>item</span>);
        }
    }
    
    <span>private</span> <span>void</span> <span>ProcessItem</span>(<span>Message</span> <span>message</span>) { }
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example uses a dedicated thread to process the message queue instead of a thread-pool thread.</p>
<div><pre><span>public</span> <span>class</span> <span>QueueProcessor</span>
{
    <span>private</span> <span>readonly</span> <span>BlockingCollection</span>&lt;<span>Message</span>&gt; <span>_messageQueue</span> <span>=</span> <span>new</span> <span>BlockingCollection</span>&lt;<span>Message</span>&gt;();
    
    <span>public</span> <span>void</span> <span>StartProcessing</span>()
    {
        <span>var</span> <span>thread</span> <span>=</span> <span>new</span> <span>Thread</span>(<span>ProcessQueue</span>) 
        {
            <span><span>//</span> This is important as it allows the process to exit while this thread is running</span>
            <span>IsBackground</span> <span>=</span> <span>true</span>
        };
        <span>thread</span>.<span>Start</span>();
    }
    
    <span>public</span> <span>void</span> <span>Enqueue</span>(<span>Message</span> <span>message</span>)
    {
        <span>_messageQueue</span>.<span>Add</span>(<span>message</span>);
    }
    
    <span>private</span> <span>void</span> <span>ProcessQueue</span>()
    {
        <span>foreach</span> (<span>var</span> <span>item</span> <span>in</span> <span>_messageQueue</span>.<span>GetConsumingEnumerable</span>())
        {
             <span>ProcessItem</span>(<span>item</span>);
        }
    }
    
    <span>private</span> <span>void</span> <span>ProcessItem</span>(<span>Message</span> <span>message</span>) { }
}</pre></div>
<h2>Avoid using <code>Task.Result</code> and <code>Task.Wait</code></h2>
<p>There are very few ways to use <code>Task.Result</code> and <code>Task.Wait</code> correctly so the general advice is to completely avoid using them in your code.</p>
<h3><g-emoji alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">‚ö†Ô∏è</g-emoji> Sync over <code>async</code></h3>
<p>Using <code>Task.Result</code> or <code>Task.Wait</code> to block wait on an asynchronous operation to complete is <em>MUCH</em> worse than calling a truly synchronous API to block. This phenomenon is dubbed "Sync over async". Here is what happens at a very high level:</p>
<ul>
<li>An asynchronous operation is kicked off.</li>
<li>The calling thread is blocked waiting for that operation to complete.</li>
<li>When the asynchronous operation completes, it unblocks the code waiting on that operation. This takes place on another thread.</li>
</ul>
<p>The result is that we need to use 2 threads instead of 1 to complete synchronous operations. This usually leads to <a href="https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/" rel="nofollow">thread-pool starvation</a> and results in service outages.</p>
<h3><g-emoji alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">‚ö†Ô∏è</g-emoji> Deadlocks</h3>
<p>The <code>SynchronizationContext</code> is an abstraction that gives application models a chance to control where asynchronous continuations run. ASP.NET (non-core), WPF and Windows Forms each have an implementation that will result in a deadlock if Task.Wait or Task.Result is used on the main thread. This behavior has led to a bunch of "clever" code snippets that show the "right" way to block waiting for a Task. The truth is, there's no good way to block waiting for a Task to complete.</p>
<p><g-emoji alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">üí°</g-emoji><strong>NOTE: ASP.NET Core does not have a <code>SynchronizationContext</code> and is not prone to the deadlock problem.</strong></p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> The below are all examples that are, in one way or another, trying to avoid the deadlock situation but still succumb to "sync over async" problems.</p>
<div><pre><span>public</span> <span>string</span> <span>DoOperationBlocking</span>()
{
    <span><span>//</span> Bad - Blocking the thread that enters.</span>
    <span><span>//</span> DoAsyncOperation will be scheduled on the default task scheduler, and remove the risk of deadlocking.</span>
    <span><span>//</span> In the case of an exception, this method will throw an AggregateException wrapping the original exception.</span>
    <span>return</span> <span>Task</span>.<span>Run</span>(() <span>=&gt;</span> <span>DoAsyncOperation</span>()).<span>Result</span>;
}

<span>public</span> <span>string</span> <span>DoOperationBlocking2</span>()
{
    <span><span>//</span> Bad - Blocking the thread that enters.</span>
    <span><span>//</span> DoAsyncOperation will be scheduled on the default task scheduler, and remove the risk of deadlocking.</span>
    <span>return</span> <span>Task</span>.<span>Run</span>(() <span>=&gt;</span> <span>DoAsyncOperation</span>()).<span>GetAwaiter</span>().<span>GetResult</span>();
}

<span>public</span> <span>string</span> <span>DoOperationBlocking3</span>()
{
    <span><span>//</span> Bad - Blocking the thread that enters, and blocking the theadpool thread inside.</span>
    <span><span>//</span> In the case of an exception, this method will throw an AggregateException containing another AggregateException, containing the original exception.</span>
    <span>return</span> <span>Task</span>.<span>Run</span>(() <span>=&gt;</span> <span>DoAsyncOperation</span>().<span>Result</span>).<span>Result</span>;
}

<span>public</span> <span>string</span> <span>DoOperationBlocking4</span>()
{
    <span><span>//</span> Bad - Blocking the thread that enters, and blocking the theadpool thread inside.</span>
    <span>return</span> <span>Task</span>.<span>Run</span>(() <span>=&gt;</span> <span>DoAsyncOperation</span>().<span>GetAwaiter</span>().<span>GetResult</span>()).<span>GetAwaiter</span>().<span>GetResult</span>();
}

<span>public</span> <span>string</span> <span>DoOperationBlocking5</span>()
{
    <span><span>//</span> Bad - Blocking the thread that enters.</span>
    <span><span>//</span> Bad - No effort has been made to prevent a present SynchonizationContext from becoming deadlocked.</span>
    <span><span>//</span> In the case of an exception, this method will throw an AggregateException wrapping the original exception.</span>
    <span>return</span> <span>DoAsyncOperation</span>().<span>Result</span>;
}

<span>public</span> <span>string</span> <span>DoOperationBlocking6</span>()
{
    <span><span>//</span> Bad - Blocking the thread that enters.</span>
    <span><span>//</span> Bad - No effort has been made to prevent a present SynchonizationContext from becoming deadlocked.</span>
    <span>return</span> <span>DoAsyncOperation</span>().<span>GetAwaiter</span>().<span>GetResult</span>();
}

<span>public</span> <span>string</span> <span>DoOperationBlocking7</span>()
{
    <span><span>//</span> Bad - Blocking the thread that enters.</span>
    <span><span>//</span> Bad - No effort has been made to prevent a present SynchonizationContext from becoming deadlocked.</span>
    <span>var</span> <span>task</span> <span>=</span> <span>DoAsyncOperation</span>();
    <span>task</span>.<span>Wait</span>();
    <span>return</span> <span>task</span>.<span>GetAwaiter</span>().<span>GetResult</span>();
}</pre></div>
<h2>Prefer <code>await</code> over <code>ContinueWith</code></h2>
<p><code>Task</code> existed before the async/await keywords were introduced and as such provided ways to execute continuations without relying on the language. Although these methods are still valid to use, we generally recommend that you prefer <code>async</code>/<code>await</code> to using <code>ContinueWith</code>. <code>ContinueWith</code> also does not capture the <code>SynchronizationContext</code> and as a result is actually semantically different to <code>async</code>/<code>await</code>.</p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> The example uses <code>ContinueWith</code> instead of <code>async</code></p>
<div><pre><span>public</span> <span>Task</span>&lt;<span>int</span>&gt; <span>DoSomethingAsync</span>()
{
    <span>return</span> <span>CallDependencyAsync</span>().<span>ContinueWith</span>(<span>task</span> <span>=&gt;</span>
    {
        <span>return</span> <span>task</span>.<span>Result</span> <span>+</span> <span>1</span>;
    });
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example uses the <code>await</code> keyword to get the result from <code>CallDependencyAsync</code>.</p>
<div><pre><span>public</span> <span>async</span> <span>Task</span>&lt;<span>int</span>&gt; <span>DoSomethingAsync</span>()
{
    <span>var</span> <span>result</span> <span>=</span> <span>await</span> <span>CallDependencyAsync</span>();
    <span>return</span> <span>result</span> <span>+</span> <span>1</span>;
}</pre></div>
<h2>Always create <code>TaskCompletionSource&lt;T&gt;</code> with <code>TaskCreationOptions.RunContinuationsAsynchronously</code></h2>
<p><code>TaskCompletionSource&lt;T&gt;</code> is an important building block for libraries trying to adapt things that are not inherently awaitable to be awaitable via a <code>Task</code>. It is also commonly used to build higher-level operations (such as batching and other combinators) on top of existing asynchronous APIs. By default, <code>Task</code> continuations will run <em>inline</em> on the same thread that calls Try/Set(Result/Exception/Canceled). As a library author, this means having to understand that calling code can resume directly on your thread. This is extremely dangerous and can result in deadlocks, thread-pool starvation, corruption of state (if code runs unexpectedly) and more.</p>
<p>Always use <code>TaskCreationOptions.RunContinuationsAsynchronously</code> when creating the <code>TaskCompletionSource&lt;T&gt;</code>. This will dispatch the continuation onto the thread pool instead of executing it inline.</p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example does not use <code>TaskCreationOptions.RunContinuationsAsynchronously</code> when creating the <code>TaskCompletionSource&lt;T&gt;</code>.</p>
<div><pre><span>public</span> <span>Task</span>&lt;<span>int</span>&gt; <span>DoSomethingAsync</span>()
{
    <span>var</span> <span>tcs</span> <span>=</span> <span>new</span> <span>TaskCompletionSource</span>&lt;<span>int</span>&gt;();
    
    <span>var</span> <span>operation</span> <span>=</span> <span>new</span> <span>LegacyAsyncOperation</span>();
    <span>operation</span>.<span>Completed</span> <span>+=</span> <span>result</span> <span>=&gt;</span>
    {
        <span><span>//</span> Code awaiting on this task will resume on this thread!</span>
        <span>tcs</span>.<span>SetResult</span>(<span>result</span>);
    };
    
    <span>return</span> <span>tcs</span>.<span>Task</span>;
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example uses <code>TaskCreationOptions.RunContinuationsAsynchronously</code> when creating the <code>TaskCompletionSource&lt;T&gt;</code>.</p>
<div><pre><span>public</span> <span>Task</span>&lt;<span>int</span>&gt; <span>DoSomethingAsync</span>()
{
    <span>var</span> <span>tcs</span> <span>=</span> <span>new</span> <span>TaskCompletionSource</span>&lt;<span>int</span>&gt;(<span>TaskCreationOptions</span>.<span>RunContinuationsAsynchronously</span>);
    
    <span>var</span> <span>operation</span> <span>=</span> <span>new</span> <span>LegacyAsyncOperation</span>();
    <span>operation</span>.<span>Completed</span> <span>+=</span> <span>result</span> <span>=&gt;</span>
    {
        <span><span>//</span> Code awaiting on this task will resume on a different thread-pool thread</span>
        <span>tcs</span>.<span>SetResult</span>(<span>result</span>);
    };
    
    <span>return</span> <span>tcs</span>.<span>Task</span>;
}</pre></div>
<p><g-emoji alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">üí°</g-emoji><strong>NOTE: There are 2 enums that look alike. <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcreationoptions?view=netcore-2.0#System_Threading_Tasks_TaskCreationOptions_RunContinuationsAsynchronously" rel="nofollow"><code>TaskCreationOptions.RunContinuationsAsynchronously</code></a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=netcore-2.0" rel="nofollow"><code>TaskContinuationOptions.RunContinuationsAsynchronously</code></a>. Be careful not to confuse their usage.</strong></p>
<h2>Always dispose <code>CancellationTokenSource</code>(s) used for timeouts</h2>
<p><code>CancellationTokenSource</code> objects that are used for timeouts (are created with timers or uses the <code>CancelAfter</code> method), can put pressure on the timer queue if not disposed.</p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example does not dispose the <code>CancellationTokenSource</code> and as a result the timer stays in the queue for 10 seconds after each request is made.</p>
<div><pre><span>public</span> <span>async</span> <span>Task</span>&lt;<span>Stream</span>&gt; <span>HttpClientAsyncWithCancellationBad</span>()
{
    <span>var</span> <span>cts</span> <span>=</span> <span>new</span> <span>CancellationTokenSource</span>(<span>TimeSpan</span>.<span>FromSeconds</span>(<span>10</span>));

    <span>using</span> (<span>var</span> <span>client</span> <span>=</span> <span>_httpClientFactory</span>.<span>CreateClient</span>())
    {
        <span>var</span> <span>response</span> <span>=</span> <span>await</span> <span>client</span>.<span>GetAsync</span>(<span><span>"</span>http://backend/api/1<span>"</span></span>, <span>cts</span>.<span>Token</span>);
        <span>return</span> <span>await</span> <span>response</span>.<span>Content</span>.<span>ReadAsStreamAsync</span>();
    }
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example disposes the <code>CancellationTokenSource</code> and properly removes the timer from the queue.</p>
<div><pre><span>public</span> <span>async</span> <span>Task</span>&lt;<span>Stream</span>&gt; <span>HttpClientAsyncWithCancellationGood</span>()
{
    <span>using</span> (<span>var</span> <span>cts</span> <span>=</span> <span>new</span> <span>CancellationTokenSource</span>(<span>TimeSpan</span>.<span>FromSeconds</span>(<span>10</span>)))
    {
        <span>using</span> (<span>var</span> <span>client</span> <span>=</span> <span>_httpClientFactory</span>.<span>CreateClient</span>())
        {
            <span>var</span> <span>response</span> <span>=</span> <span>await</span> <span>client</span>.<span>GetAsync</span>(<span><span>"</span>http://backend/api/1<span>"</span></span>, <span>cts</span>.<span>Token</span>);
            <span>return</span> <span>await</span> <span>response</span>.<span>Content</span>.<span>ReadAsStreamAsync</span>();
        }
    }
}</pre></div>
<h2>Always flow <code>CancellationToken</code>(s) to APIs that take a <code>CancellationToken</code></h2>
<p>Cancellation is cooperative in .NET. Everything in the call-chain has to be explicitly passed the <code>CancellationToken</code> in order for it to work well. This means you need to explicitly pass the token into other APIs that take a token if you want cancellation to be most effective.</p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example neglects to pass the <code>CancellationToken</code> to <code>Stream.ReadAsync</code> making the operation effectively not cancellable.</p>
<div><pre><span>public</span> <span>async</span> <span>Task</span>&lt;<span>string</span>&gt; <span>DoAsyncThing</span>(<span>CancellationToken</span> <span>cancellationToken</span> <span>=</span> <span>default</span>)
{
   <span>byte</span>[] <span>buffer</span> <span>=</span> <span>new</span> <span>byte</span>[<span>1024</span>];
   <span><span>//</span> We forgot to pass flow cancellationToken to ReadAsync</span>
   <span>int</span> <span>read</span> <span>=</span> <span>await</span> <span>_stream</span>.<span>ReadAsync</span>(<span>buffer</span>, <span>0</span>, <span>buffer</span>.<span>Length</span>);
   <span>return</span> <span>Encoding</span>.<span>UTF8</span>.<span>GetString</span>(<span>buffer</span>, <span>0</span>, <span>read</span>);
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example passes the <code>CancellationToken</code> into <code>Stream.ReadAsync</code>.</p>
<div><pre><span>public</span> <span>async</span> <span>Task</span>&lt;<span>string</span>&gt; <span>DoAsyncThing</span>(<span>CancellationToken</span> <span>cancellationToken</span> <span>=</span> <span>default</span>)
{
   <span>byte</span>[] <span>buffer</span> <span>=</span> <span>new</span> <span>byte</span>[<span>1024</span>];
   <span><span>//</span> This properly flows cancellationToken to ReadAsync</span>
   <span>int</span> <span>read</span> <span>=</span> <span>await</span> <span>_stream</span>.<span>ReadAsync</span>(<span>buffer</span>, <span>0</span>, <span>buffer</span>.<span>Length</span>, <span>cancellationToken</span>);
   <span>return</span> <span>Encoding</span>.<span>UTF8</span>.<span>GetString</span>(<span>buffer</span>, <span>0</span>, <span>read</span>);
}</pre></div>
<h2>Cancelling uncancellable operations</h2>
<p>One of the coding patterns that appears when doing asynchronous programming is cancelling an uncancellable operation. This usually means creating another task that completes when a timeout or <code>CancellationToken</code> fires, and then using <code>Task.WhenAny</code> to detect a complete or cancelled operation.</p>
<h3>Using CancellationTokens</h3>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example uses <code>Task.Delay(-1, token)</code> to create a <code>Task</code> that completes when the <code>CancellationToken</code> fires, but if it doesn't fire, there's no way to dispose the <code>CancellationTokenRegistration</code>. This can lead to a memory leak.</p>
<div><pre><span>public</span> <span>static</span> <span>async</span> <span>Task</span>&lt;<span>T</span>&gt; <span>WithCancellation</span>&lt;<span>T</span>&gt;(<span>this</span> <span>Task</span>&lt;<span>T</span>&gt; <span>task</span>, <span>CancellationToken</span> <span>cancellationToken</span>)
{
    <span><span>//</span> There's no way to dispose the registration</span>
    <span>var</span> <span>delayTask</span> <span>=</span> <span>Task</span>.<span>Delay</span>(<span>-</span><span>1</span>, <span>cancellationToken</span>);

    <span>var</span> <span>resultTask</span> <span>=</span> <span>await</span> <span>Task</span>.<span>WhenAny</span>(<span>task</span>, <span>delayTask</span>);
    <span>if</span> (<span>resultTask</span> <span>==</span> <span>delayTask</span>)
    {
        <span><span>//</span> Operation cancelled</span>
        <span>throw</span> <span>new</span> <span>OperationCanceledException</span>();
    }

    <span>return</span> <span>await</span> <span>task</span>;
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example disposes the <code>CancellationTokenRegistration</code> when one of the <code>Task(s)</code> complete.</p>
<div><pre><span>public</span> <span>static</span> <span>async</span> <span>Task</span>&lt;<span>T</span>&gt; <span>WithCancellation</span>&lt;<span>T</span>&gt;(<span>this</span> <span>Task</span>&lt;<span>T</span>&gt; <span>task</span>, <span>CancellationToken</span> <span>cancellationToken</span>)
{
    <span>var</span> <span>tcs</span> <span>=</span> <span>new</span> <span>TaskCompletionSource</span>&lt;<span>object</span>&gt;(<span>TaskCreationOptions</span>.<span>RunContinuationsAsynchronously</span>);

    <span><span>//</span> This disposes the registration as soon as one of the tasks trigger</span>
    <span>using</span> (<span>cancellationToken</span>.<span>Register</span>(<span>state</span> <span>=&gt;</span>
    {
        ((<span>TaskCompletionSource</span>&lt;<span>object</span>&gt;)<span>state</span>).<span>TrySetResult</span>(<span>null</span>);
    },
    <span>tcs</span>))
    {
        <span>var</span> <span>resultTask</span> <span>=</span> <span>await</span> <span>Task</span>.<span>WhenAny</span>(<span>task</span>, <span>tcs</span>.<span>Task</span>);
        <span>if</span> (<span>resultTask</span> <span>==</span> <span>tcs</span>.<span>Task</span>)
        {
            <span><span>//</span> Operation cancelled</span>
            <span>throw</span> <span>new</span> <span>OperationCanceledException</span>(<span>cancellationToken</span>);
        }

        <span>return</span> <span>await</span> <span>task</span>;
    }
}</pre></div>
<h3>Using a timeout</h3>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example does not cancel the timer even if the operation successfuly completes. This means you could end up with lots of timers, which can flood the timer queue.</p>
<div><pre><span>public</span> <span>static</span> <span>async</span> <span>Task</span>&lt;<span>T</span>&gt; <span>TimeoutAfter</span>&lt;<span>T</span>&gt;(<span>this</span> <span>Task</span>&lt;<span>T</span>&gt; <span>task</span>, <span>TimeSpan</span> <span>timeout</span>)
{
    <span>var</span> <span>delayTask</span> <span>=</span> <span>Task</span>.<span>Delay</span>(<span>timeout</span>);

    <span>var</span> <span>resultTask</span> <span>=</span> <span>await</span> <span>Task</span>.<span>WhenAny</span>(<span>task</span>, <span>delayTask</span>);
    <span>if</span> (<span>resultTask</span> <span>==</span> <span>delayTask</span>)
    {
        <span><span>//</span> Operation cancelled</span>
        <span>throw</span> <span>new</span> <span>OperationCanceledException</span>();
    }

    <span>return</span> <span>await</span> <span>task</span>;
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example cancels the timer if the operation succesfully completes.</p>
<div><pre><span>public</span> <span>static</span> <span>async</span> <span>Task</span>&lt;<span>T</span>&gt; <span>TimeoutAfter</span>&lt;<span>T</span>&gt;(<span>this</span> <span>Task</span>&lt;<span>T</span>&gt; <span>task</span>, <span>TimeSpan</span> <span>timeout</span>)
{
    <span>using</span> (<span>var</span> <span>cts</span> <span>=</span> <span>new</span> <span>CancellationTokenSource</span>())
    {
        <span>var</span> <span>delayTask</span> <span>=</span> <span>Task</span>.<span>Delay</span>(<span>timeout</span>, <span>cts</span>.<span>Token</span>);

        <span>var</span> <span>resultTask</span> <span>=</span> <span>await</span> <span>Task</span>.<span>WhenAny</span>(<span>task</span>, <span>delayTask</span>);
        <span>if</span> (<span>resultTask</span> <span>==</span> <span>delayTask</span>)
        {
            <span><span>//</span> Operation cancelled</span>
            <span>throw</span> <span>new</span> <span>OperationCanceledException</span>();
        }
        <span>else</span>
        {
            <span><span>//</span> Cancel the timer task so that it does not fire</span>
            <span>cts</span>.<span>Cancel</span>();
        }

        <span>return</span> <span>await</span> <span>task</span>;
    }
}</pre></div>
<h2>Always call <code>FlushAsync</code> on <code>StreamWriter</code>(s) or <code>Stream</code>(s) before calling <code>Dispose</code></h2>
<p>When writing to a <code>Stream</code> or <code>StreamWriter</code>, even if the asynchronous overloads are used for writing, the underlying data might be buffered. When data is buffered, disposing the <code>Stream</code> or <code>StreamWriter</code> via the <code>Dispose</code> method will synchronously write/flush, which results in blocking the thread and could lead to thread-pool starvation. Either use the asynchronous <code>DisposeAsync</code> method (for example via <code>await using</code>) or call <code>FlushAsync</code> before calling <code>Dispose</code>.</p>
<p><g-emoji alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">üí°</g-emoji><strong>NOTE: This is only problematic if the underlying subsystem does IO.</strong></p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example ends up blocking the request by writing synchronously to the HTTP-response body.</p>
<div><pre><span>app</span>.<span>Run</span>(<span>async</span> <span>context</span> <span>=&gt;</span>
{
    <span><span>//</span> The implicit Dispose call will synchronously write to the response body</span>
    <span>using</span> (<span>var</span> <span>streamWriter</span> <span>=</span> <span>new</span> <span>StreamWriter</span>(<span>context</span>.<span>Response</span>.<span>Body</span>))
    {
        <span>await</span> <span>streamWriter</span>.<span>WriteAsync</span>(<span><span>"</span>Hello World<span>"</span></span>);
    }
});</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example asynchronously flushes any buffered data while disposing the <code>StreamWriter</code>.</p>
<div><pre><span>app</span>.<span>Run</span>(<span>async</span> <span>context</span> <span>=&gt;</span>
{
    <span><span>//</span> The implicit AsyncDispose call will flush asynchronously</span>
    <span>await</span> <span>using</span> (<span>var</span> <span>streamWriter</span> <span>=</span> <span>new</span> <span>StreamWriter</span>(<span>context</span>.<span>Response</span>.<span>Body</span>))
    {
        <span>await</span> <span>streamWriter</span>.<span>WriteAsync</span>(<span><span>"</span>Hello World<span>"</span></span>);
    }
});</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example asynchronously flushes any buffered data before disposing the <code>StreamWriter</code>.</p>
<div><pre><span>app</span>.<span>Run</span>(<span>async</span> <span>context</span> <span>=&gt;</span>
{
    <span>using</span> (<span>var</span> <span>streamWriter</span> <span>=</span> <span>new</span> <span>StreamWriter</span>(<span>context</span>.<span>Response</span>.<span>Body</span>))
    {
        <span>await</span> <span>streamWriter</span>.<span>WriteAsync</span>(<span><span>"</span>Hello World<span>"</span></span>);

        <span><span>//</span> Force an asynchronous flush</span>
        <span>await</span> <span>streamWriter</span>.<span>FlushAsync</span>();
    }
});</pre></div>
<h2>Prefer <code>async</code>/<code>await</code> over directly returning <code>Task</code></h2>
<p>There are benefits to using the <code>async</code>/<code>await</code> keyword instead of directly returning the <code>Task</code>:</p>
<ul>
<li>Asynchronous and synchronous exceptions are normalized to always be asynchronous.</li>
<li>The code is easier to modify (consider adding a <code>using</code>, for example).</li>
<li>Diagnostics of asynchronous methods are easier (debugging hangs etc).</li>
<li>Exceptions thrown will be automatically wrapped in the returned <code>Task</code> instead of surprising the caller with an actual exception.</li>
</ul>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example directly returns the <code>Task</code> to the caller.</p>
<div><pre><span>public</span> <span>Task</span>&lt;<span>int</span>&gt; <span>DoSomethingAsync</span>()
{
    <span>return</span> <span>CallDependencyAsync</span>();
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This examples uses async/await instead of directly returning the Task.</p>
<div><pre><span>public</span> <span>async</span> <span>Task</span>&lt;<span>int</span>&gt; <span>DoSomethingAsync</span>()
{
    <span>return</span> <span>await</span> <span>CallDependencyAsync</span>();
}</pre></div>
<p><g-emoji alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">üí°</g-emoji><strong>NOTE: There are performance considerations when using an async state machine over directly returning the <code>Task</code>. It's always faster to directly return the <code>Task</code> since it does less work but you end up changing the behavior and potentially losing some of the benefits of the async state machine.</strong></p>
<h2>ConfigureAwait</h2>
<p>TBD</p>

<p>The above tries to distill general guidance, but doesn't do justice to the kinds of real-world situations that cause code like this to be written in the first place (bad code). This section tries to take concrete examples from real applications and turn them into something simple to help you relate these problems to existing codebases.</p>
<h2><code>Timer</code> callbacks</h2>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> The <code>Timer</code> callback is <code>void</code>-returning and we have asynchronous work to execute. This example uses <code>async void</code> to accomplish it and as a result can crash the process if an exception occurs.</p>
<div><pre><span>public</span> <span>class</span> <span>Pinger</span>
{
    <span>private</span> <span>readonly</span> <span>Timer</span> <span>_timer</span>;
    <span>private</span> <span>readonly</span> <span>HttpClient</span> <span>_client</span>;
    
    <span>public</span> <span>Pinger</span>(<span>HttpClient</span> <span>client</span>)
    {
        <span>_client</span> <span>=</span> <span>client</span>;
        <span>_timer</span> <span>=</span> <span>new</span> <span>Timer</span>(<span>Heartbeat</span>, <span>null</span>, <span>1000</span>, <span>1000</span>);
    }

    <span>public</span> <span>async</span> <span>void</span> <span>Heartbeat</span>(<span>object</span> <span>state</span>)
    {
        <span>await</span> <span>_client</span>.<span>GetAsync</span>(<span><span>"</span>http://mybackend/api/ping<span>"</span></span>);
    }
}</pre></div>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This attempts to block in the <code>Timer</code> callback. This may result in thread-pool starvation and is an example of <a href="#warning-sync-over-async">sync over async</a></p>
<div><pre><span>public</span> <span>class</span> <span>Pinger</span>
{
    <span>private</span> <span>readonly</span> <span>Timer</span> <span>_timer</span>;
    <span>private</span> <span>readonly</span> <span>HttpClient</span> <span>_client</span>;
    
    <span>public</span> <span>Pinger</span>(<span>HttpClient</span> <span>client</span>)
    {
        <span>_client</span> <span>=</span> <span>client</span>;
        <span>_timer</span> <span>=</span> <span>new</span> <span>Timer</span>(<span>Heartbeat</span>, <span>null</span>, <span>1000</span>, <span>1000</span>);
    }

    <span>public</span> <span>void</span> <span>Heartbeat</span>(<span>object</span> <span>state</span>)
    {
        <span>_client</span>.<span>GetAsync</span>(<span><span>"</span>http://mybackend/api/ping<span>"</span></span>).<span>GetAwaiter</span>().<span>GetResult</span>();
    }
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This example uses an <code>async Task</code>-based method and discards the <code>Task</code> in the <code>Timer</code> callback. If this method fails, it will not crash the process. Instead, it will fire the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler.unobservedtaskexception?view=netframework-4.7.2" rel="nofollow"><code>TaskScheduler.UnobservedTaskException</code></a> event.</p>
<div><pre><span>public</span> <span>class</span> <span>Pinger</span>
{
    <span>private</span> <span>readonly</span> <span>Timer</span> <span>_timer</span>;
    <span>private</span> <span>readonly</span> <span>HttpClient</span> <span>_client</span>;
    
    <span>public</span> <span>Pinger</span>(<span>HttpClient</span> <span>client</span>)
    {
        <span>_client</span> <span>=</span> <span>client</span>;
        <span>_timer</span> <span>=</span> <span>new</span> <span>Timer</span>(<span>Heartbeat</span>, <span>null</span>, <span>1000</span>, <span>1000</span>);
    }

    <span>public</span> <span>void</span> <span>Heartbeat</span>(<span>object</span> <span>state</span>)
    {
        <span><span>//</span> Discard the result</span>
        <span>_</span> <span>=</span> <span>DoAsyncPing</span>();
    }

    <span>private</span> <span>async</span> <span>Task</span> <span>DoAsyncPing</span>()
    {
        <span>await</span> <span>_client</span>.<span>GetAsync</span>(<span><span>"</span>http://mybackend/api/ping<span>"</span></span>);
    }
}</pre></div>
<h2>Implicit <code>async void</code> delegates</h2>
<p>Imagine a <code>BackgroundQueue</code> with a <code>FireAndForget</code> that takes a callback. This method will execute the callback at some time in the future.</p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This will force callers to either block in the callback or use an <code>async void</code> delegate.</p>
<div><pre><span>public</span> <span>class</span> <span>BackgroundQueue</span>
{
    <span>public</span> <span>static</span> <span>void</span> <span>FireAndForget</span>(<span>Action</span> <span>action</span>) { }
}</pre></div>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This calling code is creating an <code>async void</code> method implicitly. The compiler fully supports this today.</p>
<div><pre><span>public</span> <span>class</span> <span>Program</span>
{
    <span>public</span> <span>void</span> <span>Main</span>(<span>string</span>[] <span>args</span>)
    {
        <span>var</span> <span>httpClient</span> <span>=</span> <span>new</span> <span>HttpClient</span>();
        <span>BackgroundQueue</span>.<span>FireAndForget</span>(<span>async</span> () <span>=&gt;</span>
        {
            <span>await</span> <span>httpClient</span>.<span>GetAsync</span>(<span><span>"</span>http://pinger/api/1<span>"</span></span>);
        });
        
        <span>Console</span>.<span>ReadLine</span>();
    }
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This BackgroundQueue implementation offers both sync and <code>async</code> callback overloads.</p>
<div><pre><span>public</span> <span>class</span> <span>BackgroundQueue</span>
{
    <span>public</span> <span>static</span> <span>void</span> <span>FireAndForget</span>(<span>Action</span> <span>action</span>) { }
    <span>public</span> <span>static</span> <span>void</span> <span>FireAndForget</span>(<span>Func</span>&lt;<span>Task</span>&gt; <span>action</span>) { }
}</pre></div>
<h2><code>ConcurrentDictionary.GetOrAdd</code></h2>
<p>It's pretty common to cache the result of an asynchronous operation and <code>ConcurrentDictionary</code> is a good data structure for doing that. <code>GetOrAdd</code> is a convenience API for trying to get an item if it's already there or adding it if it isn't. The callback is synchronous so it's tempting to write code that uses <code>Task.Result</code> to produce the value of an asynchronous process but that can lead to thread-pool starvation.</p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This may result in thread-pool starvation since we're blocking the request thread if the person data is not cached.</p>
<div><pre><span>public</span> <span>class</span> <span>PersonController</span> : <span>Controller</span>
{
   <span>private</span> <span>AppDbContext</span> <span>_db</span>;
   
   <span><span>//</span> This cache needs expiration</span>
   <span>private</span> <span>static</span> <span>ConcurrentDictionary</span>&lt;<span>int</span>, <span>Person</span>&gt; <span>_cache</span> <span>=</span> <span>new</span> <span>ConcurrentDictionary</span>&lt;<span>int</span>, <span>Person</span>&gt;();
   
   <span>public</span> <span>PersonController</span>(<span>AppDbContext</span> <span>db</span>)
   {
      <span>_db</span> <span>=</span> <span>db</span>;
   }
   
   <span>public</span> <span>IActionResult</span> <span>Get</span>(<span>int</span> <span>id</span>)
   {
       <span>var</span> <span>person</span> <span>=</span> <span>_cache</span>.<span>GetOrAdd</span>(<span>id</span>, (<span>key</span>) <span>=&gt;</span> <span>_db</span>.<span>People</span>.<span>FindAsync</span>(<span>key</span>).<span>Result</span>);
       <span>return</span> <span>Ok</span>(<span>person</span>);
   }
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This implementation won't result in thread-pool starvation since we're storing a task instead of the result itself.</p>
<p><g-emoji alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">‚ö†Ô∏è</g-emoji> <code>ConcurrentDictionary.GetOrAdd</code> will potentially run the cache callback multiple times in parallel. This can result in kicking off expensive computations multiple times.</p>
<div><pre><span>public</span> <span>class</span> <span>PersonController</span> : <span>Controller</span>
{
   <span>private</span> <span>AppDbContext</span> <span>_db</span>;
   
   <span><span>//</span> This cache needs expiration</span>
   <span>private</span> <span>static</span> <span>ConcurrentDictionary</span>&lt;<span>int</span>, <span>Task</span>&lt;<span>Person</span>&gt;&gt; <span>_cache</span> <span>=</span> <span>new</span> <span>ConcurrentDictionary</span>&lt;<span>int</span>, <span>Task</span>&lt;<span>Person</span>&gt;&gt;();
   
   <span>public</span> <span>PersonController</span>(<span>AppDbContext</span> <span>db</span>)
   {
      <span>_db</span> <span>=</span> <span>db</span>;
   }
   
   <span>public</span> <span>async</span> <span>Task</span>&lt;<span>IActionResult</span>&gt; <span>Get</span>(<span>int</span> <span>id</span>)
   {
       <span>var</span> <span>person</span> <span>=</span> <span>await</span> <span>_cache</span>.<span>GetOrAdd</span>(<span>id</span>, (<span>key</span>) <span>=&gt;</span> <span>_db</span>.<span>People</span>.<span>FindAsync</span>(<span>key</span>));
       <span>return</span> <span>Ok</span>(<span>person</span>);
   }
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This implementation fixes the multiple-executing callback issue by using the <code>async</code> lazy pattern.</p>
<div><pre><span>public</span> <span>class</span> <span>PersonController</span> : <span>Controller</span>
{
   <span>private</span> <span>AppDbContext</span> <span>_db</span>;
   
   <span><span>//</span> This cache needs expiration</span>
   <span>private</span> <span>static</span> <span>ConcurrentDictionary</span>&lt;<span>int</span>, <span>AsyncLazy</span>&lt;<span>Person</span>&gt;&gt; <span>_cache</span> <span>=</span> <span>new</span> <span>ConcurrentDictionary</span>&lt;<span>int</span>, <span>AsyncLazy</span>&lt;<span>Person</span>&gt;&gt;();
   
   <span>public</span> <span>PersonController</span>(<span>AppDbContext</span> <span>db</span>)
   {
      <span>_db</span> <span>=</span> <span>db</span>;
   }
   
   <span>public</span> <span>async</span> <span>Task</span>&lt;<span>IActionResult</span>&gt; <span>Get</span>(<span>int</span> <span>id</span>)
   {
       <span>var</span> <span>person</span> <span>=</span> <span>await</span> <span>_cache</span>.<span>GetOrAdd</span>(<span>id</span>, (<span>key</span>) <span>=&gt;</span> <span>new</span> <span>AsyncLazy</span>&lt;<span>Person</span>&gt;(() <span>=&gt;</span> <span>_db</span>.<span>People</span>.<span>FindAsync</span>(<span>key</span>))).<span>Value</span>;
       <span>return</span> <span>Ok</span>(<span>person</span>);
   }
   
   <span>private</span> <span>class</span> <span>AsyncLazy</span>&lt;<span>T</span>&gt; : <span>Lazy</span>&lt;<span>Task</span>&lt;<span>T</span>&gt;&gt;
   {
      <span>public</span> <span>AsyncLazy</span>(<span>Func</span>&lt;<span>Task</span>&lt;<span>T</span>&gt;&gt; <span>valueFactory</span>) : <span>base</span>(<span>valueFactory</span>)
      {
      }
   }
}</pre></div>
<h2>Constructors</h2>
<p>Constructors are synchronous. If you need to initialize some logic that may be asynchronous, there are a couple of patterns for dealing with this.</p>
<p>Here's an example of using a client API that needs to connect asynchronously before use.</p>
<div><pre><span>public</span> <span>interface</span> <span>IRemoteConnectionFactory</span>
{
   <span>Task</span>&lt;<span>IRemoteConnection</span>&gt; <span>ConnectAsync</span>();
}

<span>public</span> <span>interface</span> <span>IRemoteConnection</span>
{
    <span>Task</span> <span>PublishAsync</span>(<span>string</span> <span>channel</span>, <span>string</span> <span>message</span>);
    <span>Task</span> <span>DisposeAsync</span>();
}</pre></div>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example uses <code>Task.Result</code> to get the connection in the constructor. This could lead to thread-pool starvation and deadlocks.</p>
<div><pre><span>public</span> <span>class</span> <span>Service</span> : <span>IService</span>
{
    <span>private</span> <span>readonly</span> <span>IRemoteConnection</span> <span>_connection</span>;
    
    <span>public</span> <span>Service</span>(<span>IRemoteConnectionFactory</span> <span>connectionFactory</span>)
    {
        <span>_connection</span> <span>=</span> <span>connectionFactory</span>.<span>ConnectAsync</span>().<span>Result</span>;
    }
}</pre></div>
<p><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">‚úÖ</g-emoji> <strong>GOOD</strong> This implementation uses a static factory pattern in order to allow asynchronous construction:</p>
<div><pre><span>public</span> <span>class</span> <span>Service</span> : <span>IService</span>
{
    <span>private</span> <span>readonly</span> <span>IRemoteConnection</span> <span>_connection</span>;

    <span>private</span> <span>Service</span>(<span>IRemoteConnection</span> <span>connection</span>)
    {
        <span>_connection</span> <span>=</span> <span>connection</span>;
    }

    <span>public</span> <span>static</span> <span>async</span> <span>Task</span>&lt;<span>Service</span>&gt; <span>CreateAsync</span>(<span>IRemoteConnectionFactory</span> <span>connectionFactory</span>)
    {
        <span>return</span> <span>new</span> <span>Service</span>(<span>await</span> <span>connectionFactory</span>.<span>ConnectAsync</span>());
    }
}</pre></div>
<h2>WindowsIdentity.RunImpersonated</h2>
<p>This API runs the specified action as the impersonated Windows identity. Unfortunately there's no asynchronous version of the callback.</p>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example tries to execute the query asynchronously, and then wait for it outside of the call to <code>RunImpersonated</code>. This will throw because the query might be executing outside of the impersonation context.</p>
<div><pre><span>public</span> <span>async</span> <span>Task</span>&lt;<span>IEnumerable</span>&lt;<span>Product</span>&gt;&gt; <span>GetDataImpersonatedAsync</span>(<span>SafeAccessTokenHandle</span> <span>safeAccessTokenHandle</span>)
{
    <span>Task</span>&lt;<span>IEnumerable</span>&lt;<span>Product</span>&gt;&gt; <span>products</span> <span>=</span> <span>null</span>;
    <span>WindowsIdentity</span>.<span>RunImpersonated</span>(
        <span>safeAccessTokenHandle</span>,
        <span>context</span> <span>=&gt;</span>
        {
            <span>products</span> <span>=</span> <span>_db</span>.<span>QueryAsync</span>(<span><span>"</span>SELECT Name from Products<span>"</span></span>);
        }};
    <span>return</span> <span>await</span> <span>products</span>;
}</pre></div>
<p><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">‚ùå</g-emoji> <strong>BAD</strong> This example uses <code>Task.Result</code> to get the connection in the constructor. This could lead to thread-pool starvation and deadlocks.</p>
<div><pre><span>public</span> <span>IEnumerable</span>&lt;<span>Product</span>&gt; <span>GetDataImpersonatedAsync</span>(<span>SafeAccessTokenHandle</span> <span>safeAccessTokenHandle</span>)
{
    <span>return</span> <span>WindowsIdentity</span>.<span>RunImpersonated</span>(
        <span>safeAccessTokenHandle</span>,
        <span>context</span> <span>=&gt;</span> <span>_db</span>.<span>QueryAsync</span>(<span><span>"</span>SELECT Name from Products<span>"</span></span>).<span>Result</span>);
}</pre></div>
<p><g-emoji alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">üí°</g-emoji><strong>NOTE There's no good alternative here. This API shouldn't be used with an asynchronous callback. See <a href="https://github.com/dotnet/corefx/issues/24977">https://github.com/dotnet/corefx/issues/24977</a></strong></p>
</article>
  </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>