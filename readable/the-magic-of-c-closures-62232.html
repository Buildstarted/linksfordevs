<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The magic of C# closures - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The magic of C# closures - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@iliasshaikh"/>
    <meta property="og:description" content="A brief look at how closures work in C#"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/swlh/the-magic-of-c-closures-9c6e3fff6ff9"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The magic of C# closures</title>
<div class="readable">
        <h1>The magic of C# closures</h1>
            <div>by https://medium.com/@iliasshaikh</div>
            <div>Reading time: 7-9 minutes</div>
        <div>Posted here: 29 May 2020</div>
        <p><a href="https://medium.com/swlh/the-magic-of-c-closures-9c6e3fff6ff9">https://medium.com/swlh/the-magic-of-c-closures-9c6e3fff6ff9</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><div><a rel="noopener" href="https://medium.com/@iliasshaikh?source=post_page-----9c6e3fff6ff9----------------------"><div><p><img alt="ilias shaikh" src="https://miro.medium.com/fit/c/96/96/2*YpW8qr9IVkx7AeF6AQwfMQ.png" width="48" height="48"></p></div></a></div></div></div></div></div><p id="39ff" data-selectable-paragraph="">Closures originated from the world of functional programming, but as programming languages have evolved recently they have been liberally borrowing ideas from other languages and paradigms. In this post, we will look at closures through the lens of C#.</p><p id="34e7" data-selectable-paragraph="">Closures are like those optical illusions that seem normal when you first look at them, however, their magic unfolds on closer inspection.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*hjLD5wwyaTR6TDHiHuq3AA.jpeg?q=20" width="5073" height="3382" role="presentation"></p><p><img width="5073" height="3382" srcset="https://miro.medium.com/max/552/1*hjLD5wwyaTR6TDHiHuq3AA.jpeg 276w, https://miro.medium.com/max/1104/1*hjLD5wwyaTR6TDHiHuq3AA.jpeg 552w, https://miro.medium.com/max/1280/1*hjLD5wwyaTR6TDHiHuq3AA.jpeg 640w, https://miro.medium.com/max/1400/1*hjLD5wwyaTR6TDHiHuq3AA.jpeg 700w" sizes="700px" role="presentation" src="https://miro.medium.com/max/5073/1*hjLD5wwyaTR6TDHiHuq3AA.jpeg"></p></div></div></div></div><figcaption data-selectable-paragraph="">Photo by <a href="https://unsplash.com/@randvmb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener nofollow">Randy Jacob</a> on <a href="https://unsplash.com/s/photos/illusion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener nofollow">Unsplash</a></figcaption></figure><p id="6b05" data-selectable-paragraph="">Consider this c# code snippet,</p><pre><span id="232a" data-selectable-paragraph=""><strong>void</strong> <strong>Main</strong>()<br>{<br>  <strong>var</strong> a = <strong>foo</strong>();<br>  <strong>bar</strong>(a);<br>}</span><span id="62b4" data-selectable-paragraph=""><strong>public</strong> Action <strong>foo</strong>()<br>{<br>  <strong>int</strong> i = 100;<br>  Action a = () =&gt; Console.<strong>Write</strong>($"{i} ");<br>  <strong>return</strong> a;<br>}</span><span id="eb7f" data-selectable-paragraph=""><strong>public</strong> <strong>void</strong> <strong>bar</strong>(Action a)<br>{<br>  <strong>a</strong>();<br>}</span></pre><p id="8ef8" data-selectable-paragraph="">On running this piece of code in a console application you see -</p><pre><span id="f5d8" data-selectable-paragraph="">100</span></pre><p id="aea6" data-selectable-paragraph="">On first glance this is fairly intuitive and the output we would expect, but hang on, how can function ‘<strong><em>bar()</em></strong>’ have access to the local ‘i’ variable of <strong><em>foo()</em></strong>, after <strong><em>foo()</em></strong> has finished and in theory popped its variables off the stack.</p><p id="2a98" data-selectable-paragraph="">We have just seen a ‘closure’ in action.</p><p id="f7f6" data-selectable-paragraph="">It is, as you might imagine, a piece of compiler trickery that makes this possible, but more on that later.</p><p id="d604" data-selectable-paragraph=""><strong>So, what exactly is a ‘closure’?</strong></p><p id="52f2" data-selectable-paragraph="">According to Wikipedia -</p><blockquote><p id="c4ba" data-selectable-paragraph="">In programming languages, closures (also lexical closures or function closures) are a technique for implementing lexically scoped name binding in languages with first-class functions. Operationally, a closure is a record storing a function together with an environment : a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was bound when the closure was created. A closure — unlike a plain function — allows the function to access those captured variables through the closure’s reference to them, even when the function is invoked outside their scope.</p></blockquote><p id="181d" data-selectable-paragraph="">Wow, that’s a mouthful! It’s not however completely inscrutable, before we try and dissect this statement, let me define some of the terms used, bear with me if these are self-evident, but I will expand on them anyways.</p><ul><li id="93d0" data-selectable-paragraph="">lexical scope — this is a region of statements in your code where a variable is visible. A variable is visible in a statement if it can be referenced from the statement.</li><li id="d6a0" data-selectable-paragraph="">name binding — associating a symbol with an entity such as a variable to its value or address, or a symbol to an operation. Consider the following</li></ul><pre><span id="12f7" data-selectable-paragraph=""><em>// variable 'i' is bound to 100<br></em><strong>int</strong> i = 100; <p>      <em>// considering AA to be a reference type, <br>// variable 'a' is bound to the start address of the location on the // heap where the bytes for the instance of 'AA' are stored</em></p></span><span id="27f1" data-selectable-paragraph="">AA a = <strong>new</strong> <strong>AA</strong>(); <p>        <em>// variable 'act' is bound to the anonymous function <br></em>Action act = ()=&gt; { Console.<strong>WriteLine</strong> ("hello")};</p></span></pre><ul><li id="e484" data-selectable-paragraph="">first-class functions — a programming language is said to have first-class functions when functions can be treated as any other data. In C# first-class functions are supported using anonymous methods and lambdas.</li><li id="5acd" data-selectable-paragraph="">free variable — a free variable, in simple terms, is a variable that is not bound to a value, i.e. it is not a function parameter and it is not defined in the same function.</li></ul><p id="84c7" data-selectable-paragraph="">Now that we have set some background, let us try and understand the definition of closure in the context of our original code.</p><p id="4914" data-selectable-paragraph="">Consider the lambda</p><pre><span id="84f0" data-selectable-paragraph="">() =&gt; Console.Write($"{i}");</span></pre><p id="0481" data-selectable-paragraph="">here the variable ‘i’ is free, since it’s not a parameter to the lambda or defined internally. Instead, it gets its value from the environment when the lambda was defined. A closure is hence, a record that stores a function and all the variables/ data that it requires from the environment. In the C#/ .NET world, we have a handy way of enclosing functions and variables — called a <strong>class</strong>. And indeed, that’s how closures are implemented. So, the code in <a href="http://www.trycatchthat.com/csharp/fundamentals/2015/12/27/csharp-closure-thebasics.html#listing1" target="_blank" rel="noopener nofollow">snippet #1</a> translates into something like this — <em>please note that actual code generated probably looks a lot different.</em></p><pre><span id="f67c" data-selectable-paragraph=""><strong>class</strong> <strong>@AnonymousClass001</strong><br>{<br>  <strong>internal</strong> <strong>int</strong> i;<br>  <strong>internal</strong> <strong>void</strong> <strong>@AnonymousMethod001</strong>()<br>  {<br>    Console.<strong>Write</strong>($"{i}");<br>  }<br>}</span><span id="86d5" data-selectable-paragraph=""><strong>void</strong> <strong>Main</strong>()<br>{<br>  <strong>var</strong> a = <strong>foo</strong>();<br>  <strong>bar</strong>(a);<br>}</span><span id="b25e" data-selectable-paragraph=""><strong>public</strong> <strong>Action</strong> <strong>foo</strong>()<br>{<br>  <strong>int</strong> i = 100;<br>  <strong>var</strong> r = <strong>new</strong> <strong>@AnonymousClass001</strong>();<br>  r.i = i;<br>  Action a = r.AnonymousMethod001;<br>  <strong>return a</strong>;<br>}</span><span id="7963" data-selectable-paragraph=""><strong>public</strong> <strong>void</strong> <strong>bar</strong>(Action a)<br>{<br>  <strong>a</strong>();<br>}</span></pre><p id="6f2e" data-selectable-paragraph="">If you think about it, this is possibly the way you would have implemented closures if you’d been asked to.</p><p id="bac4" data-selectable-paragraph="">Another thing to note from the implementation is that closures capture the <strong><em>‘variable’ </em></strong>and not the <strong><em>‘value’</em></strong>. Let’s update our original code slightly to see what the implication of this is. In the following code, we increment the value of I <strong><em>after</em></strong> the lambda has been defined.</p><pre><span id="ebc6" data-selectable-paragraph=""><strong>public</strong> <strong>void</strong> <strong>foo</strong>()<br>{<br>  <strong>int</strong> i = 100;<br>  Action a = () =&gt; Console.<strong>Write</strong>($"{i} ");<br>  i++; <em>// increment i after the lambda has been defined<br></em>  <strong>bar</strong>(a);<br>}</span><span id="8955" data-selectable-paragraph=""><strong>public</strong> <strong>void</strong> <strong>bar</strong>(Action a)<br>{<br>  <strong>a</strong>();<br>}</span></pre><p id="41fe" data-selectable-paragraph="">Since, the closure captures the variable ‘i’, rather than the value ‘100’, this outputs</p><pre><span id="0e6e" data-selectable-paragraph="">101</span></pre><p id="a560" data-selectable-paragraph="">As we have seen, closures capture variables and not values. This has at least one counter-intuitive effect on loops.</p><p id="1bff" data-selectable-paragraph="">Consider the following code</p><pre><span id="e50f" data-selectable-paragraph=""><strong>void</strong> <strong>foo</strong>()<br>{<br>  Action[] acts = <strong>new</strong> Action[10];<br>  <strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10; i++)<br>  {<br>    acts[i] = ()=&gt; Console.<strong>Write</strong>(i + " ");<br>  }<p>    <strong>foreach</strong> (<strong>var</strong> a <strong>in</strong> acts)<br>  {<br>    <strong>a</strong>();<br>  }<br>}</p></span></pre><p id="796a" data-selectable-paragraph="">On running this the output is</p><pre><span id="d3f9" data-selectable-paragraph="">10 10 10 10 10 10 10 10 10 10</span></pre><p id="99ab" data-selectable-paragraph="">That does not feel right, does it?</p><p id="7622" data-selectable-paragraph="">To see what’s happening here we can again try and decompose this snippet to what the compiler would do. The code below will not compile because of the use of the non-existent keyword <strong><em>‘ref’</em></strong> in @AnoymousClass001. This is to illustrate the fact that it is the reference that is being used and not the value. <em>Otherwise, ‘int’, being a value type it would not have been possible to illustrate my point</em></p><pre><span id="c566" data-selectable-paragraph=""><strong>class</strong> <strong>@AnonymousClass001</strong><br>{<br>  <strong>internal</strong> <strong>ref</strong> <strong>int</strong> i; <em>// the ref keyword does not exist in c# and is used only for illustrative purposes</em></span><span id="89e4" data-selectable-paragraph=""><strong>  internal</strong> <strong>void</strong> <strong>@AnonymousMethod001</strong>()<br>  {<br>    Console.<strong>WriteLine</strong>(i + " ");<br>  }<br>}</span><span id="63dc" data-selectable-paragraph=""><strong>void</strong> <strong>foo</strong>()<br>{<br>  Action[] acts = <strong>new</strong> Action[10];<br>  <strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10; i++)<br>  {<br>    <strong>var</strong> r = <strong>new</strong> <strong>AnonymousClass001</strong>();<br>    r.i = <strong>ref</strong> i;<br>    acts[i] = r.AnonymousMethod001;<br>  }<p>    <strong>foreach</strong> (<strong>var</strong> a <strong>in</strong> acts)<br>  {<br>    <strong>a</strong>();<br>  }<br>}</p></span></pre><p id="b946" data-selectable-paragraph="">Hopefully, that explains why we get all 10s instead of numbers in sequence as we really wanted. To get the code to do as we want, we can change our loop block to declare a variable inside the loop block, like so -</p><pre><span id="2ee9" data-selectable-paragraph=""><strong>void</strong> <strong>foo</strong>()<br>{<br>  Action[] acts = <strong>new</strong> Action[10];<br>  <strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10; i++)<br>  {<br>    <strong>int</strong> j = i; <em>// introduce a local variable inside the loop block<br></em>    acts[i] = ()=&gt;Console.<strong>Write</strong>(j + " ");<br>  }<p>    <strong>foreach</strong> (<strong>var</strong> a <strong>in</strong> acts)<br>  {<br>    <strong>a</strong>();<br>  }<br>}</p></span></pre><p id="b9a9" data-selectable-paragraph="">This gives us the output as -</p><pre><span id="3b59" data-selectable-paragraph="">0 1 2 3 4 5 6 7 8 9</span></pre><p id="bafc" data-selectable-paragraph="">Hopefully, the reason why this works is fairly intuitive by now. The loop variable <strong><em>‘i’</em></strong> is shared across all the runs of the loop, while an instance of the variable <strong><em>‘j’</em></strong> is created every time the loop block is run.</p><pre><span id="8d0c" data-selectable-paragraph=""><strong>class</strong> <strong>@AnonymousClass001</strong><br>{<br>  <strong>internal</strong> <strong>ref</strong> <strong>int</strong> j; <em>// the ref keyword does not exist in c# and is used only for illustrative purposes</em></span><span id="4d6a" data-selectable-paragraph=""><strong>  internal</strong> <strong>void</strong> <strong>@AnonymousMethod001</strong>()<br>  {<br>    Console.<strong>WriteLine</strong>(j + " ");<br>  }<br>}</span><span id="d629" data-selectable-paragraph=""><strong>void</strong> <strong>foo</strong>()<br>{<br>  Action[] acts = <strong>new</strong> Action[10];<br>  <strong>for</strong> (<strong>int</strong> i = 0; i &lt; 10; i++)<br>  {<br>    <strong>var</strong> r = <strong>new</strong> <strong>AnonymousClass001</strong>();<br>    int j = i;<br>    r.j = <strong>ref</strong> j; <em>// this is a new variable for each iteration of the loop and not the loop variable</em><br>    acts[i] = r.AnonymousMethod001;<br>  }<p>    <strong>foreach</strong> (<strong>var</strong> a <strong>in</strong> acts)<br>  {<br>    <strong>a</strong>();<br>  }<br>}</p></span></pre><p id="b28f" data-selectable-paragraph="">So, hopefully, that sheds some light on closures in C#. I love them because of how deceptively simple they are and how their interplay with anonymous lambda functions makes the usage and behaviour of anonymous functions intuitive. The thing to watch out for is when you use the loop variable is captured in a lambda, things can get weird.</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>