<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A high-speed network driver written in C, Rust, Go, C#, Java | Hacker News - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="A high-speed network driver written in C, Rust, Go, C#, Java | Hacker News - linksfor.dev(s)"/>
    <meta property="og:description" content="You can perfectly do in same in C# just like they did with Go.We do it all the time in Windows low level coding within .NET, the reason why they didn&#x27;t beats me, most likely not knowledgeable enough of .NET capabilities.As for Java, hopefully with projects Valhala, Panama and Metropolis Java will finally have the performance language features that should have been part of Java 1.0."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://news.ycombinator.com/item?id=20945819"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A high-speed network driver written in C, Rust, Go, C#, Java | Hacker News</title>
<div class="readable">
        <h1>A high-speed network driver written in C, Rust, Go, C#, Java | Hacker News</h1>
            <div>Reading time: 49-62 minutes</div>
        <div>Posted here: 12 Sep 2019</div>
        <p><a href="https://news.ycombinator.com/item?id=20945819">https://news.ycombinator.com/item?id=20945819</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
            <tbody><tr id="20948177"><td>
            </td></tr>
        <tr id="20948598"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948598" href="https://news.ycombinator.com/vote?id=20948598&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>You can perfectly do in same in C# just like they did with Go.<p>We do it all the time in Windows low level coding within .NET, the reason why they didn't beats me, most likely not knowledgeable enough of .NET capabilities.</p><p>As for Java, hopefully with projects Valhala, Panama and Metropolis Java will finally have the performance language features that should have been part of Java 1.0.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20948909"><td>
            </td></tr>
        <tr id="20948938"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20948938" href="https://news.ycombinator.com/vote?id=20948938&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>The document has 14 pages and the only information I see is the mlock description, nothing about how they were unable to use System.Runtime.InteropServices, unsafe and DllImport to make use of it.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20948969"><td>
            </td></tr>
        <tr id="20949275"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_20949275" href="https://news.ycombinator.com/vote?id=20949275&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Odd that they couldn't call mlock using PInvoke; it sounds like the PInvoke export metadata wasn't there rather than C actually being required.<p>On Windows even for really obscure FNs you can almost always PInvoke if you know the offsets, and if you really want to be evil you can traverse the PEB. There isn't much in low level terms that is beyond the reach of C# since you can manipulate memory directly.  I've also accessed hidden COM interfaces by traversing V-Tables using similar direct memory techniques as you would in C.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20952567"><td>
            </td></tr>
    <tr id="20949314"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_20949314" href="https://news.ycombinator.com/vote?id=20949314&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>So something like<pre><code>    [DllImport(..., EntryPoint = "mlock")]
    extern int MLock(UIntPtr addr, uint len);
</code></pre>
And then getting the pointer either from <i>MemoryMappedViewAccessor</i> or <i>AllocHGlobal</i>?</span></p></div></td></tr>
      </tbody></table></td></tr>
            <tr id="20949551"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20949551" href="https://news.ycombinator.com/vote?id=20949551&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Neither C# nor Java have C in the hot path; C# uses unsafe mode, Java sun.misc.Unsafe. JNI/C# native calls are either in the initialization or for an alternate implementation to compare them.</span></p></div></td></tr>
      </tbody></table></td></tr>
    <tr id="20950850"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20950850" href="https://news.ycombinator.com/vote?id=20950850&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I can't really believe the Swift implementation needs to be that slow. Objective-C used to be 100% C compatible and Swift more or less has complete bridging to C because of the need to use these API's.<p>Objective-C was often called slow because iteration NSArray was much slower than doing it in C. Well, if you needed to do it fast in Objective-C you wouldn't do it using the user friendly and safe (for 1984) higher level objects.</p><p>I think only Rust really allows you to write really safe and still really fast code though.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20950910"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20950910" href="https://news.ycombinator.com/vote?id=20950910&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Yes, we could write most of the critical part in C and it would probably be faster. But then it wouldn't be a Swift driver.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20951170"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20951170" href="https://news.ycombinator.com/vote?id=20951170&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Are these benchmarks single-threaded?  I took a brief look at the Swift codebase, and I noticed that you are using semaphores, but there doesn't seem to be any parallel execution anywhere in the project.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20952156"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_20952156" href="https://news.ycombinator.com/vote?id=20952156&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>The Semaphore is only used during initialization, never in the critical path, see profiling results in the main repo</span></p></div></td></tr>
      </tbody></table></td></tr>
      <tr id="20951993"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20951993" href="https://news.ycombinator.com/vote?id=20951993&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I don't think you need to write the critical part of the driver in C to speed up the swift implementation.<p>I clicked through to a performance analysis showing ARC taking about 3/4 the time (in the release build).</p><p>You don't really need to be doing a lot of ARC in the inner loops if you don't want to.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20952037"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_20952037" href="https://news.ycombinator.com/vote?id=20952037&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Yes, we do if we want to have an idiomatic interface for the application on top of the driver.<p>Pull requests proving otherwise are welcome
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20953250"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_20953250" href="https://news.ycombinator.com/vote?id=20953250&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>I don’t think it’s idiomatic to do a bunch of unnecessary memory management in inner loops, right?</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20954684"><td>
            </td></tr>
        <tr id="20955583"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="280"></td><td><center><a id="up_20955583" href="https://news.ycombinator.com/vote?id=20955583&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>ARC is implemented at the language level but it's not required. You can use it when and where you like.<p>One fundamental aspect of swift is the distinction between reference types -- which are reference counted -- and value types -- which are not. Generally in Swift you'd use a value type over a reference type unless you have reasons not to. E.g.: <a href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes" rel="nofollow">https://developer.apple.com/documentation/swift/choosing_bet...</a></p><p>I mean, I don't know what the right approach for this library is. The authors are going to have to fix their own code. IMO, coming up with a demonstrably poor solution and trying to defend it as "idiomatic" is pretty weak.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
            <tr id="20954506"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20954506" href="https://news.ycombinator.com/vote?id=20954506&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Well if the C# and Java implementations use C they're definitely not C# and Java drivers. But you don't need to use C directly, just use the C features that are supported by Swift itself.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20954703"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_20954703" href="https://news.ycombinator.com/vote?id=20954703&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>C isn't in the critical path of either of those two implementations. GP is saying that it would be in a Swift version. Whether or not that's accurate I have no idea.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20951929"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20951929" href="https://news.ycombinator.com/vote?id=20951929&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; I think only Rust really allows you to write really safe and still really fast code though.<p>Snabb (<a href="https://github.com/snabbco/snabb/" rel="nofollow">https://github.com/snabbco/snabb/</a>) 
is written in LuaJIT . I assume an equivalent project in Rust would be a lot more expensive in implementation time and also lines of code.</p><p>There is also Common Lisp and SBCL in particular, which can produce extremely fast code without compromising on safety.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
      <tr id="20951432"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20951432" href="https://news.ycombinator.com/vote?id=20951432&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>The Techempower Benchmarks covering a more professional state on that. When coded right, the frameworks typically are on-par in performance in the Plaintext area (where only processing matters). In the end, these drivers were mostly thesis documents.</span></p></div></td></tr>
      </tbody></table></td></tr>
    <tr id="20948620"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948620" href="https://news.ycombinator.com/vote?id=20948620&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>It would be good to have them measure aspects other than performance, like how long it took to build each, was there a learning curve because it's an unfamiliar language, how secure the resulting code is, etc.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20949295"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20949295" href="https://news.ycombinator.com/vote?id=20949295&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>I'm pretty sure that an exhaustive answer to your last question is "the history will tell" with additional assumption  that all those drivers would be deployed in many production environments.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20950224"><td>
            </td></tr>
      <tr id="20949279"><td>
            </td></tr>
        <tr id="20950218"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20950218" href="https://news.ycombinator.com/vote?id=20950218&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>To measure how long it took to build it, track how many days it took to implement in each language.<p>To measure how secure the resulting code is, have a test suite of malformed packets or other input and see how many of them the code in each language handles.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20962376"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_20962376" href="https://news.ycombinator.com/vote?id=20962376&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I'm not qualified to judge the latter. But I can about the former.<p>That measures how well a particular developer takes, with some noise induced by the working environment (say there's construction noise during python week, not during java week, or more meetings one week than another, or the developer's has relationship troubles at home). Randomness happens.</p><p>Deducing a number that's more generally valid requires having n workers doing the same work and then doing statistical analysis. Happily that also takes care of the single-worker problem. Still, the cost of the experiment easily rises by a factor of twenty or a hundred, depending on how well the noise can be controlled and how much accuracy is needed.</p><p>Asking for improvements that would increase the cost of an experiment by many thousand per cent is a %$#@!%#@! $%#@!%@#$ thing to do. IMO.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="21015894"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_21015894" href="https://news.ycombinator.com/vote?id=21015894&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>The perfect is the enemy of the good. I'll take a rough estimate over no data at all. If the Python guy took 10 days and the Java guy took 20, then the conclusion is that Python is more productive than Java. Is it more productive exactly by 100%? No, maybe 60%, or maybe 120%. But whether the benefit is 60% or 120%, I know which tool I'll choose next time.</span></p></div></td></tr>
      </tbody></table></td></tr>
                        <tr id="20948665"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_20948665" href="https://news.ycombinator.com/vote?id=20948665&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>If you can't see or interpret the graphs (mobile browser, etc.) here's a quick description of the relative performance in terms that might be useful even without the graphs.<p>Bidirectional forwarding, Packets per second:
Here, the batch size matters; small batches have a lower packet rate across the board. Each language has increasing throughput with increasing batch size up to some point, and then the chart goes flat.
Python is by far the slowest, not even diverging from the zero line. 
C is consistently the fastest, but flattens out at 16-packet batch at 27Mpps.
Rust is consistently about 10% slower than C until C flattens out, then Rust catches up at the 32-packet batch size, and both are flat at 27Mpps. 
Go is every so slightly faster than C# until the 16-packet batch size where they cross (at 19Mpps), then C# is consistently about 2Mpps faster than Go. At the 256-packet batch size, C# reaches 27Mpps, and Go 25Mpps. 
Java is faster than C# and Go at very low batch sizes, but at 4 packets per batch Java slows down (10Mpps), and quickly reaches its peak of 11 to 12 Mpps.
OCaml and Haskell follow a similar curve, with Haskell consistently about 15% slower than Java, and Ocaml somewhere between the two.
Finally, Swift and Javascript are indistinguishable from each other, both about half the speed of Haskell across the board.</p><p>Latency, at 90, 99, 99.9, 99.99.. etc., percentile. 1Mpps:
All have zero-ish latency at the 90 percentile point, then Javascript latency quickly jumps to 150us, then again at 99.99%ile jumps again to 300us.
C# is the next to increase: at the 99%ile mark there's a steady increase till it hits 40us at 99.99%ile. Then a steady increase to about 60us.
Haskell keeps it at about 10us until 99.99%ile, then a steady increase to about 60us, and a sudden spike at the end to 250us.
Java latency remains low until 99.95%ile, then it quickly spikes up reaching a max of 325us.
Next OCaml spikes at around 99.99%ile, reaching a max of about 170us. 
Next comes Swift, with a maximum of about 70us.
Finally, C, Rust, and Go have the lowest latency. Rust and C are indistinguishable, and Go latency diverges to about 20% higher than the other two at the 99.999%ile mark, where it sways, eventually hitting around 25us while C and rust hit about 22us.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20951054"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20951054" href="https://news.ycombinator.com/vote?id=20951054&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>The Rust page also compares the performance of the Rust implementation using prefetching, which slightly outperforms C for some batch sizes. <a href="https://github.com/ixy-languages/ixy.rs#performance" rel="nofollow">https://github.com/ixy-languages/ixy.rs#performance</a><p>It would be a bit of a cheat, as it isn't portable, but it would be nice to see prefetching in the C implementation for the sake of comparison.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
                <tr id="20947297"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_20947297" href="https://news.ycombinator.com/vote?id=20947297&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Cross-language comparisons are always interesting to look at; if I had the time, I'd really like to write one in Asm and see how it compares.<p>I've written NIC drivers for some older chipsets, and IMHO it's not something that's particularly "algorithmic" in computation or could necessarily show off/exercise a programming language well; what's really measured here is probably an approximation to how fast these languages can copy memory, because that's ultimately what a NIC driver mostly does (besides waiting.) To send, you put the data in a buffer and tell the NIC to send it. To receive, the NIC tells you when it has received something, and you copy the data out. Nonetheless, the astonishingly bad performance of the Python version is surprising.</p><p>Although I haven't looked at the source in any detail, I know that newer NICs do a lot more of the processing (e.g. checksums) that would've been done in the host software, so that would be another way in which the performance of the host software wouldn't be evident.</p><p>One other thing I'd like to see is a chart of the binary sizes too (with and without all the runtime dependencies).
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20949576"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20949576" href="https://news.ycombinator.com/vote?id=20949576&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Real NIC drivers spend most of their time fiddling with bit fields. It's mostly about translating a hardware-agnostic version of a packet descriptor (mbuf, sk_buffs, ...) into a hardware-specific DMA descriptor.<p>If your driver copies memory you are doing something wrong.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20948337"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948337" href="https://news.ycombinator.com/vote?id=20948337&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; Nonetheless, the astonishingly bad performance of the Python version is surprising.<p>In the paper, they point out that the Python version is the only one they didn't bother to optimize.</p><p>However, my takeaway is that practically everybody can handle north of 1 Gigabits per second (2 Million packets per second x 64 bytes per packet) even on a 1.6GHz core.  I find <i>THAT</i> quite a bit more astonishing actually.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20948792"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20948792" href="https://news.ycombinator.com/vote?id=20948792&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>I don't see why it's that surprising. We've been stuck on 1Gbps for the better part of 20 years. What's surprising to me is that wired networking was sorta left behind the tech wave, sure 10Gbps exists but it's still not that affordable or widespread.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20949041"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20949041" href="https://news.ycombinator.com/vote?id=20949041&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I wouldn't say it was exactly left behind, because the average consumer will not really benefit from anything over 1Gbit. 1Gbit is already enough to saturate most consumer harddrives.<p>I run 10gbit inside my home and it didn't even cost me that much (if you go with 10Gbit fiber instead of copper) with the sole reasons of getting quicker transfers between my PC and NAS. My NAS has 4 SFP+ ports and functions as a switch. I bought second hand PCIe SFP+ NICs for $40 each and matching transceivers for $15 each. 10M of fiber costs less than $10.</p><p>There's no point in going higher, because 10Gbit is already way past the sequential writing speed of the drive array in my NAS, and it's pretty much saturating the NVMe cache drive in the NAS or the NVMe storage in my PC.</p><p>That's not to say you can't go faster, because 100, 200 and 400Gbit are very much possible and in use in datacenters and the like.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20950749"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_20950749" href="https://news.ycombinator.com/vote?id=20950749&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; I wouldn't say it was exactly left behind, because the average consumer will not really benefit from anything over 1Gbit. 1Gbit is already enough to saturate most consumer harddrives.<p>That hasn't been true for a long time. Even one single spinning rust hard drive made in the last decade can do sequential reads at ~120-150MiB/sec, which is easily enough to saturate a 1 Gbit/s link.</p><p>SSDs have way, way higher throughput for sequential read and write. Good SSDs will also beat that number handily for random read/writes.</p><p>And of course, any machine with more than 1 hard drive can easily saturate a 1Gbit/s network.</p><p>I also find it surprising that wired networking has been 'stuck' on 1Gbit/s for decades.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
      <tr id="20949004"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20949004" href="https://news.ycombinator.com/vote?id=20949004&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; What's surprising to me is that wired networking was sorta left behind the tech wave<p>Lack of necessity.</p><p>Since the telcos are a gigantic bottleneck to everything in the cloud, and now that <i>everything</i> is in the cloud, there is no need for &gt;1Gbps home networking.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20948920"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20948920" href="https://news.ycombinator.com/vote?id=20948920&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Because &gt;1Gbps on 1.6GHz means &lt;1.6 cycles per transmitted/received bit, or &lt;8 cycles/byte if you prefer to count bytes.<p>That's not shabby for a language like python.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20947783"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20947783" href="https://news.ycombinator.com/vote?id=20947783&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Yeah, for real life applications as well, I shy away from Python for anything where performance might one day be an issue. Most languages can at least get within an order of magnitude of state of the art (at which point ergonomic considerations can matter more), but Python is just incredibly slow in practice.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20949454"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20949454" href="https://news.ycombinator.com/vote?id=20949454&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>&gt;I shy away from Python for anything where performance might one day be an issue
if there are only a few bottlenecks that have a significant impact on the performance you could rewrite only those parts to C/Rust. This might be a good aproach especially in a situation where performance is not an issue right now but might be in future. When it actually becomes an issue only the part that actually affects the performance could then be rewritten to C. Of course this approach doesn't always make much sense, but quite often there is a small part of the code that impacts the performance the most and only that part would need to be rewritten, while the rest of the code could still enjoy a language more productive to write in. Similarly a microservice(ish) architecture comes handy with this</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20956123"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20956123" href="https://news.ycombinator.com/vote?id=20956123&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>In a language as slow as Python where even basic memory copying is slow, you don't really just have a few bottlenecks. You can optimize the most important 10% of the code and the rest of the code will still be slowing everything down. It's also a lot of work to have to rewrite parts in C/Rust and interface with Python code.</span></p></div></td></tr>
      </tbody></table></td></tr>
                    <tr id="20948207"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_20948207" href="https://news.ycombinator.com/vote?id=20948207&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>That JavaScript and Swift have essentially the same performance here is extremely telling: there are essentially four performance regimes (five if you count Python, but clearly from the graphs you should not ;P), and what would really be interesting--and which this page isn't bothering to even examine?! :(--is what is causing each of these four regimes. I want to know what is so similar about C# and Go that is causing them to have about the same performance, and yet much more performance (at higher batch sizes) than the regime of Java/OCaml/Haskell (a group which can't be explained by their garbage collectors as one of the garbage collectors tested for Java was "don't collect garbage" and it had the same performance). It frankly makes me expect there to be some algorithmic difference between those two regimes that is causing the difference, and it has nothing to do with language/runtime/fundamental performance.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20949588"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20949588" href="https://news.ycombinator.com/vote?id=20949588&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Swift spends 76% of the time incrementing/decrementing reference counts; ARC is just very bad at pushing tens of millions of objects through it every second.<p>There's some more evlauation for Swift here: <a href="https://github.com/ixy-languages/ixy.swift/tree/master/performance" rel="nofollow">https://github.com/ixy-languages/ixy.swift/tree/master/perfo...</a></p><p>It's just a coincidence that JavaScript and Swift end up with almost the same performance; there is nothing similar between these two runtimes and implementations.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20949680"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20949680" href="https://news.ycombinator.com/vote?id=20949680&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>This is also a clear optimization target.  It is very possible to write Swift code which requires very little reference-counting overhead.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20950863"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20950863" href="https://news.ycombinator.com/vote?id=20950863&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>The problem is that 99% of all Swift developers use the language to create front-ends for powerful devices and you never need to squeeze the last drop of performance out of them.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20948603"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948603" href="https://news.ycombinator.com/vote?id=20948603&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; I want to know what is so similar about C# and Go that is causing them to have about the same performance, and yet much more performance (at higher batch sizes) than the regime of Java/OCaml/Haskell […] and it has nothing to do with language/runtime/fundamental performance.<p>The authors specifically call out the issue of avoiding heap allocations when asked about Java v C# (as they're pretty similar languages), noting that they couldn't get under ~20 bytes allocated per forwarded packet in Java. C# (and Go) would have much better facilities to work entirely out of the stack, avoid memory copies and reuse allocations in the main loop.</p><p>I expect Haskell and OCaml have similar issues.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20948390"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948390" href="https://news.ycombinator.com/vote?id=20948390&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; want to know what is so similar about C# and Go that is causing them to have about the same performance.<p>I looked at the C# thesis. I think with care the programmer was able to reduce the amount of heap allocations and memory copying enough that it's similar to the mix in the go driver. I think also the modern processors ability to execute multiple instructions/code paths in parallel tend to negate the advantage efficiently compiled languages like C and go. So cache misses, heap allocation, and garbage collection tend to dominate over raw numbers of instructions executed.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20949673"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20949673" href="https://news.ycombinator.com/vote?id=20949673&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; JavaScript and Swift have essentially the same performance here<p>One thing that I notice about the Swift version is that he's making heavy use of classes, and in the performance section it mentions that there is quite a lot of time spent on retain-release.  There's probably a lot of room for performance optimization in this implementation.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20948235"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948235" href="https://news.ycombinator.com/vote?id=20948235&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>For Java it could be binary wrangling.  You have to do some weird things to unpack binary blobs in Java due to the lack of unsigned types.  So, for performance you have to wrangle things through native ByteBuffers correctly or you will get killed.</span></p></div></td></tr>
      </tbody></table></td></tr>
    <tr id="20949572"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20949572" href="https://news.ycombinator.com/vote?id=20949572&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; JavaScript and Swift have essentially the same performance here<p>Only for throughput. The latency difference is enormous.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20950235"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20950235" href="https://news.ycombinator.com/vote?id=20950235&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>c# and go both have value typea and reference types, java only has reference types. c# also has a variety of tools for controlling how memory isbused and accessed bs java. avoiding the heap may he the first order difference.</span></p></div></td></tr>
      </tbody></table></td></tr>
                <tr id="20949591"><td>
            </td></tr>
        <tr id="20950502"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20950502" href="https://news.ycombinator.com/vote?id=20950502&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Thanks, that was interesting. If anyone is excited enough to try driving peripherals in userspace via hardware registers, I can recommend starting with a Raspberry Pi, since it has several well documented peripherals (UART, SPI, I2C, DMA, and of course lots of GPIO), and the techniques described in this talk are transferable.<p>A search for 'raspberry pi mmap' will yield a lot of good starting points.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
                <tr id="20948027"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_20948027" href="https://news.ycombinator.com/vote?id=20948027&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Cool to see C# being up there close to C and before Golang.<p>I haven't used C# much over the last year due to job change but always felt like one of the most mature languages out there. Now working in Go and it's a bit frustrating in comparison.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20948334"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948334" href="https://news.ycombinator.com/vote?id=20948334&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Go isn't designed to feel mature, it's designed to be boring and effective. It's designed to keep code complexity low even as the complexity of problems and solutions increases. It's designed to allow large teams of medium-skill programmers to consistently produce safe and effective solutions. The most precise description ive heard to date is: "Go is a <i>get shit done</i> language."</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20949017"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20949017" href="https://news.ycombinator.com/vote?id=20949017&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>C# 1.0 was also boring and effective - modern versions are still effective, and I'd say they are more powerful.<p>Golang in 15 years will likely converge and embrace many of the missing features of mature languages (its happening now already), especially if it wants to reach broader adoption.</p><p>A reference like "Go is a get shit done language." very much reflects overall immaturity of the language that I see day to day.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20951110"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20951110" href="https://news.ycombinator.com/vote?id=20951110&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt;Golang in 15 years will likely converge and embrace many of the missing features of mature languages (its happening now already), especially if it wants to reach broader adoption.<p>Go is 10 years old already and picking new features at an extremely low rate, with no hints at a pace change.</p><p>I think error management and generics should be the only major changes to expect within the next 5 years. 
C# is more complex by an order of magnitude...
And thus its evolution was and is still way faster.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
      <tr id="20948606"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20948606" href="https://news.ycombinator.com/vote?id=20948606&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Basically it is designed for writing boilerplate libraries and code generators to cover up lack of language features, which even well known projects are forced to make use of (k8s).<p>I bet a G2EE variant isn't too far away.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20952021"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20952021" href="https://news.ycombinator.com/vote?id=20952021&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>It is already there in some form as 'Go Cloud Development Kit' [1]. 
Though many claim it is not really enterprise scale until a petstore application can be created in it. And a flawless implementation of EJB 2.1 made enterprise  fall in love J2EE. I am not sure Go can deliver anything remotely powerful as that.<p>1. <a href="https://gocloud.dev/" rel="nofollow">https://gocloud.dev/</a>
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20951130"><td>
            </td></tr>
        <tr id="20951738"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_20951738" href="https://news.ycombinator.com/vote?id=20951738&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>You again.<p>What infrastructure, those riding the consulting and conference Docker and K8s 2019 wave fad?!?
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20954455"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_20954455" href="https://news.ycombinator.com/vote?id=20954455&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Right now I'm using prometheus and grafana to monitor around 8k database servers (sql server too BTW). 
We have pricing applications using influxdb. Docker. Openstack. Minio. We also have mattermost.<p>All of this in a conservative big bank. My friends in the banking sector tell the same story.</p><p>True there are lots of c# enterprisey web apps.</p><p>However given the amount of boilerplate you describe, I cannot understand how such useful and reliable tools can be delivered in Go.</p><p>A hint:just because a language is not to your liking, it does not mean that it is not useful, performant and reliable.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20965252"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="240"></td><td><center><a id="up_20965252" href="https://news.ycombinator.com/vote?id=20965252&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>"However given the amount of boilerplate you describe, I cannot understand how such useful and reliable tools can be delivered in Go."<p>I don't follow your logic. Multitudes of useful and reliable tools were built with assembly languages - is that evidence that assembly code doesn't have a lot of boilerplate (relative to modern languages)?
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20956196"><td>
            </td></tr>
        <tr id="20959461"><td>
            </td></tr>
        <tr id="20959905"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="320"></td><td><center><a id="up_20959905" href="https://news.ycombinator.com/vote?id=20959905&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>And yet I haven't seen any of that on our Fortune 500 French clients, which naturally includes banks, go figure.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20961371"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="360"></td><td><center><a id="up_20961371" href="https://news.ycombinator.com/vote?id=20961371&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Are you working in operations and infrastructure? My take is that writing enterprisey applications you are not exposed to those tools.  
I'm in ops.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20961630"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="400"></td><td><center><a id="up_20961630" href="https://news.ycombinator.com/vote?id=20961630&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Not personally, but we do have mixed teams.<p>AWS, Azure, actual hardware racks, plain old VMs, JEE containers, .NET packages, Ansible, Puppet, Chef, whatever scripting stack, but surely not one line of Go related code.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
                <tr id="20951357"><td>
            </td></tr>
        <tr id="20951765"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_20951765" href="https://news.ycombinator.com/vote?id=20951765&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Here's a list of prominent Go infrastructure projects and by no means a complete list: Kubernetes, Docker, Etcd, Consul (and the rest of Hashicorp's projects), CockroachDB, Prometheus, TiDB. Maybe I'm just blind to C# but I don't remember coming across a single similar project that's written in C#.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20953303"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="240"></td><td><center><a id="up_20953303" href="https://news.ycombinator.com/vote?id=20953303&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Azure, Orleans, ASP.NET, Windows,SQL Server, Bing, IIS, Kestrel,...<p>Yep, they aren't pure C#, still way more relevant to the world IT infrastructure than anything Go.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20955007"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="280"></td><td><center><a id="up_20955007" href="https://news.ycombinator.com/vote?id=20955007&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>None of this is relevent and or even close to be as popular as the previous tools mention in Go, just k8s and Docker crush your entire list. Another very popular one is Grafana also written in Go.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20956207"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="320"></td><td><center><a id="up_20956207" href="https://news.ycombinator.com/vote?id=20956207&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>In what?  Only if we are talking about Github stars or Silicon Valley coffee shops.<p>Fortune 500 prefer to care about actual delivered business value.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20961867"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="360"></td><td><center><a id="up_20961867" href="https://news.ycombinator.com/vote?id=20961867&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I worked in two F500 compagnies both are using k8s, Docker / grafana and Go. They also use C# but not in the cloud / operations / infra world.<p>Go talk to some SRE team in F100 and F500 and ask them what they think about C# infra side lol.</p><p>The fact that C# was running on Windows only until 2 years ago explains why.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20969701"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="400"></td><td><center><a id="up_20969701" href="https://news.ycombinator.com/vote?id=20969701&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I only work for Fortune 500s, on project scale where license costs are a tiny drop regarding overall project costs.<p>Plenty them do run production servers on Windows.</p><p>You forgot there are 498 left to check.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20958019"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="320"></td><td><center><a id="up_20958019" href="https://news.ycombinator.com/vote?id=20958019&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>That's a very distorted and interesting view of the software industry as a whole.</span></p></div></td></tr>
      </tbody></table></td></tr>
      <tr id="20954413"><td>
            </td></tr>
        <tr id="20956166"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="320"></td><td><center><a id="up_20956166" href="https://news.ycombinator.com/vote?id=20956166&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Then better learn how to use it properly, specially .NET stored procedures, OLAP engine and SSMS.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20959509"><td>
            </td></tr>
        <tr id="20959907"><td>
            </td></tr>
        <tr id="20961377"><td>
            </td></tr>
        <tr id="20961680"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="480"></td><td><center><a id="up_20961680" href="https://news.ycombinator.com/vote?id=20961680&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>In correct English one would state <i>fully</i>, <i>completely</i> written in X.<p>Modern stacks are seldom pure blood language X, thus if 5% of it is written in Y, the product is written in a mix of X and Y.</p><p>Which I also mentioned on my comment, <i>"Yep, they aren't pure C#"</i>, naturally overseen when one intends to champion its language as "Year of Desktop Linux" on IT infrastructures.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20965882"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="520"></td><td><center><a id="up_20965882" href="https://news.ycombinator.com/vote?id=20965882&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Playing games with the commonly accepted meaning of words is a known sophism.<p>The Linux kernel is 0.2% of shell scripts, yet no one would say it's written in shell. Same for windows or sql server. .Net is marginal there.</p><p>Btw I do code in Go, but I mostly use go apps and enjoys their small memory footprint and ease of deployment.</p><p>I must not be the only one as I see go apps pretty much everywhere in ops teams.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
              <tr id="20955001"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="320"></td><td><center><a id="up_20955001" href="https://news.ycombinator.com/vote?id=20955001&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Depends on what parts, entire products of the Sql server product line are in C#, like Sql Server Reporting Services for instance.<p>The core sql server rdbms engine is hosting the .net runtime for a few things - but there its maginal compared to C++.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20959524"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="360"></td><td><center><a id="up_20959524" href="https://news.ycombinator.com/vote?id=20959524&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Exact. It's marginal. Saying "written in .net" about sql server made the Microsoft PFEs laugh during our coffee break though.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20959909"><td>
            </td></tr>
                    <tr id="20968333"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20968333" href="https://news.ycombinator.com/vote?id=20968333&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; It's designed to keep code complexity low even as the complexity of problems and solutions increases.<p>Honestly I think that's pretty wrong. Go is designed to let you get coding quickly. It's not designed to make your ultimate solution well designed are easily refactorable. In a few years there's going to be a ton of Go code that becomes almost as bad as C where it becomes untouchable because people quickly threw something together and didn't think about long term design.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20948387"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20948387" href="https://news.ycombinator.com/vote?id=20948387&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>I didn’t read the thesis for each implementation, but it would have been cool to see how long it took an engineer to write each network driver. I bet the Go version, while definitely not the fastest, was one of the fastest to finish.</span></p></div></td></tr>
      </tbody></table></td></tr>
                  <tr id="20947168"><td>
            </td></tr>
        <tr id="20947307"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20947307" href="https://news.ycombinator.com/vote?id=20947307&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Except their answer is wrong, because Rust (LLVM rather) does eliminate bounds checks. They're comparing GCC vs LLVM here more than they are comparing C vs Rust. They should have compiled their C code in LLVM. Their implementation is littered with uses of "unsafe" which means its almost impossible for the compiler to eliminate the bounds checks.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20949286"><td>
            </td></tr>
        <tr id="20951242"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20951242" href="https://news.ycombinator.com/vote?id=20951242&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>So the bounds check is:<pre><code>    queue.bufs_in_use[rx_index]
</code></pre>
If so the bounds check could possibly be safely eliminated by the programmer because I think `wrap_ring` ensures that rx_index will always be in bounds?</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20951314"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_20951314" href="https://news.ycombinator.com/vote?id=20951314&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Yes. It wouldn't be too unidiomatic to use get_unchecked in those two places, perhaps with a debug_assert! in place.<p>It would be really nice if this wasn't needed, but it's a valid use of unsafe code.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20948264"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20948264" href="https://news.ycombinator.com/vote?id=20948264&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; Their implementation is littered with uses of "unsafe" which means its almost impossible for the compiler to eliminate the bounds checks.<p>Does `unsafe` actually impede optimization in this way? I thought it just disabled certain type checks and error messages but didn't affect anything on the LLVM level.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20948796"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20948796" href="https://news.ycombinator.com/vote?id=20948796&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>You're essentially right. The grandparent may be meaning that they're using a lot of raw pointers (which requires unsafe), and raw pointers means less aliasing information, and so less precise optimisations. This can affect bounds checks, because a raw pointer could potentially alias the length field of a slice or vector, and so LLVM has to be conservative around writes to them.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20952847"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_20952847" href="https://news.ycombinator.com/vote?id=20952847&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Are their uses of unsafe necessary? After briefly looking over the implementation it seems like they could just be using references in a bunch of places. Take for example:<pre><code>   let queue = &amp;mut self.rx_queues[queue_id as usize];
   rx_index = queue.rx_index;
   last_rx_index = queue.rx_index;

   for i in 0..num_packets {
       let desc = unsafe { queue.descriptors.add(rx_index) as *mut ixgbe_adv_rx_desc };
       let status =
           unsafe { ptr::read_volatile(&amp;mut (*desc).wb.upper.status_error as *mut u32) };</code></pre></span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20957896"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_20957896" href="https://news.ycombinator.com/vote?id=20957896&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>I've got no idea. One would have to understand the code fairly deeply to tell that. For instance, are the volatile reads/writes meant to be atomic ones (which could be done safely) or are they truly volatile?</span></p></div></td></tr>
      </tbody></table></td></tr>
          <tr id="20949637"><td>
            </td></tr>
    <tr id="20947811"><td>
            </td></tr>
                  <tr id="20948075"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_20948075" href="https://news.ycombinator.com/vote?id=20948075&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>So why the difference in "language" speeds?<p>You have some the results not quite following the conventional expectation. For example the Swift implementation is as slow as JavaScript. JavaScript is a lot faster than Python. Java is considerable slower than the usually very similar C#.</p><p>The implementation is fairly complex; so it is a bit hard to see what is going on. But it must be possible to pin the big performance differences implied by the two graphs to something?
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20948238"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948238" href="https://news.ycombinator.com/vote?id=20948238&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Python is interpreted bytecode. This means that for every small instruction on the bytecode there's a round trip to the Python interpreter that has to execute that instruction. This is faster than parsing and interpreting at the same time, such as shells often do, but it's still a lot slower than JIT compilers.<p>Now, a just-in-time (JIT) compiler transforms the code into machine code at runtime. Usually from bytecode. Java, C# JavaScript all use this model predominantly these days. This takes a bit of work during runtime and you cannot afford too complicated optimizations that a C or C++ compiler would do, but it comes close (and for certain reasons is even better sometimes). So that's the main reason why JavaScript is faster than Python. Theres a Python JIT compiler, PyPy, that might close the gap, though. And for Python in particular there are also other options to improve speed somewhat, one of them involves converting the Python code to C. Not too idiomatic, usually, though.</p><p>As for Java and C#, that's a point where it can sometimes show that C# has been designed to be a high-level language that can drop down to low levels if needed. C# has pointers and the ability to control memory layout of your data, if you need it. This turns off a lot of niceties and safeties  that the language usually offers (you also need the <i>unsafe</i> keyword, which has that name for a reason), but can improve speed. Newer versions of C# increasingly added other features that allow you to <i>safely</i> write code that performs predictably fast. But even value types and reified generics go a long way of making things faster by default than being required to always use classes and the heap.</p><p>Java on the other hand has few of those features where the develop is offered low-level control. It has one major advantage, though, in that its own JIT compiler is a lot more advanced and can do some crazy transformations and optimizations. One might argue that Java needs that much magic because you don't have much control at the language level to make things fast, so as far as performance goes between C# and Java  this may be pretty much the tradeoff between complicated language and complicated JIT compiler.</p><p>As for which benchmark shows Java being faster than C# depends a bit on how the code was written, but recently .NET has become a lot better as well and popular multi-language benchmarks show C# often faster than Java.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20948169"><td>
            </td></tr>
    <tr id="20948251"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948251" href="https://news.ycombinator.com/vote?id=20948251&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I'd imagine Python is so slow in this benchmark because it doesn't have any kind of optimizing compiler. All the other languages are either compiled ahead of time or just-in-time compiled into more efficient machine code.<p>I wonder how PyPy would do on this benchmark...
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20948222"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948222" href="https://news.ycombinator.com/vote?id=20948222&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>I find the performance of Java rather suspicious. It starts out fast for the smallest batch's sizes but then kind of falls flat for the rest.</span></p></div></td></tr>
      </tbody></table></td></tr>
                <tr id="20946552"><td>
            </td></tr>
        <tr id="20947457"><td>
            </td></tr>
    <tr id="20948810"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948810" href="https://news.ycombinator.com/vote?id=20948810&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Unsurprising if you've kept up with .net
The new primitive types (spans) allow direct low level manipulation of memory slices. A NIC driver, at it's core, really only copies data to and from shared buffers, so it gets a tremendous benefit from this new type.<p>C# recently getting new low level memory types definitely gave it the edge there, it does not reflect real world scenarios very accurately.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20949168"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20949168" href="https://news.ycombinator.com/vote?id=20949168&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; C# recently getting new low level memory types definitely gave it the edge there, it does not reflect real world scenarios very accurately.<p>In my experience, C# is by a large margin the most performant "managed" language vs. Java, Python.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20958514"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20958514" href="https://news.ycombinator.com/vote?id=20958514&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>If you go down to bytecode engineering you can create some seriously fast JVM code. But I agree that making .net go fast seems easier than getting the JVM to go fast (if anything because many of the standard libraries are anything but fast, and you have to go hunting for high performance ones or roll your own).</span></p></div></td></tr>
      </tbody></table></td></tr>
      <tr id="20949953"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20949953" href="https://news.ycombinator.com/vote?id=20949953&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Was going to say much the same thing.<p>I ported a C hash function to C# recently, and using the low-level feature that C# offers, performance was <i>very</i> close to the C version.</p><p>C# is really nice to work with for this kind of thing.</p><p>And - .NET Core 3.0 introduced support for hardware intrinsics, so I could probably bridge the gap if I spent some time on vectorisingthe C# code.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
      <tr id="20947015"><td>
            </td></tr>
    <tr id="20946588"><td>
            </td></tr>
        <tr id="20949604"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20949604" href="https://news.ycombinator.com/vote?id=20949604&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>The OCaml version is probably our most optimized implementation, it was scrutinized (and improved) by lots of people at the MirageOS retreat earlier this year.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20956148"><td>
            </td></tr>
        <tr id="20947194"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20947194" href="https://news.ycombinator.com/vote?id=20947194&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>For me, that was the line that surprised me the most. The .NET VM has had a reputation as being a worse variant of the JVM, but it seems that now the tables have turned.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20947258"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20947258" href="https://news.ycombinator.com/vote?id=20947258&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Really? To me it was always a runtime VM done right! The .net CLR is much more stable, leak-proof, and performant in my experience. I have .net services that run on servers for years without ever being restarted.<p>Given that C# and "Rust" are neck and neck, I'd rather have a nice GC language to work with.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20948008"><td>
            </td></tr>
    <tr id="20950182"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20950182" href="https://news.ycombinator.com/vote?id=20950182&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>C and Rust are really close, but if you look at latency C# is still lagging behind (Go performs way better in that regard).</span></p></div></td></tr>
      </tbody></table></td></tr>
      <tr id="20947402"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20947402" href="https://news.ycombinator.com/vote?id=20947402&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Where did you see that? I've never come across that reputation before, only that the JVM has more usage (in high-perf scenarios) because it was cross-platform and had a bigger community.<p>.NET always had very good performance and the new .NET Core cross-platform framework and runtime is now consistently among the fastest in various performance benchmarks for all kinds of applications.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20947905"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20947905" href="https://news.ycombinator.com/vote?id=20947905&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Oh man, yes they have. For a couple years now the CLR has surpassed the JVM in straight-line performance for many workloads. A lot of effort has been going into providing escape hatches without sharp edges for getting closer to the hardware with the likes of Span&lt;T&gt;, Vec, and the upcoming hardware intrinsics. It always started faster..</span></p></div></td></tr>
      </tbody></table></td></tr>
    <tr id="20947319"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20947319" href="https://news.ycombinator.com/vote?id=20947319&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>I’d guess (cause I’m lazy and don’t want to verify the code) that it’s because the CLR has much better unmanaged support. It’s a first class feature.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20947855"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20947855" href="https://news.ycombinator.com/vote?id=20947855&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Indeed. It was designed to interact with C APIs directly from day 1 and they've made it more powerful fairly recently with Span&lt;T&gt; and Memory&lt;T&gt; (essentially "safe pointers").<p>You can literally develop entire applications in unsafe mode, with C's level of unsafety. Nobody does, but you could.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
      <tr id="20947799"><td>
            </td></tr>
    <tr id="20947487"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20947487" href="https://news.ycombinator.com/vote?id=20947487&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; but it seems that now the tables have turned.<p>I'm not sure that's the conclusion to draw from a niche benchmark.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
      <tr id="20947567"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20947567" href="https://news.ycombinator.com/vote?id=20947567&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>As someone on Team C#, I bet my career on it after careful consideration and comparison with every other option I had on the table, I had the exact same thought. But it's Microsoft, in my opinion they know software better than anyone around. They cover a lot of ground and fail sometimes but overall I consistently have high expectations from them. I use their platform everyday. Good work, Microsoft!</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20949320"><td>
            </td></tr>
        <tr id="20952805"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20952805" href="https://news.ycombinator.com/vote?id=20952805&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I agree, but to me that's an odd phenomenon. I didn't grow up with that stigma and not sure what age/group it affects more. I started on a Commodore, which used Commodore BASIC (based on Bill Gate's Microsoft BASIC). As far as business criticism against them, I view the underlying economic system that allows and perpetuates it as the culprit. Not a single entity like MS, Amazon, Oracle etc. I'm not a cherry-picker, not productive and it's not rational. Bad actors are smacked down and it would be all of them if they thought they could get away with it. I'm in favor of changing the business model, not harping on the "new bad guy" every few  years. Today it seems to be Google.<p>I think it's mostly a lack of insightfulness and thought that leads to cherry-picking bad guys when the system is structured in a way where unscrupulous behavior is worth risking. I could be wrong, maybe Microsoft is evil incarnate but at the level I operate on, I don't see it.</p><p>But yes, no reason to not embrace the good parts from Microsoft, or anyone else. That's how I do it. I chose C# to stick with because I believe in what they're doing around it. Huge fan of Blazor, appreciate their focus on long-term support, their product integration, and their excellent tooling. The language is good, and I can get a job doing it anywhere in the country without being in a major metropolitan area. In some of these metrics, I personally don't think you can beat the C# ecosystem.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20951458"><td>
            </td></tr>
                    <tr id="20947961"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_20947961" href="https://news.ycombinator.com/vote?id=20947961&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>That's a very interesting experiment in many levels. Haven't taken the time to look at the paper yet, but I'm curious of how you got your number of pps vs Gb/s in the README :<p>"full bidirectional load at 20 Gbit/s with 64 byte packets (29.76 Mpps)". sounds like 20Gb/s should be closer to 40Mpps than to 30Mpps. Did you hit CPU limits on the packet generator, or am I missing some packet header overhead ?</p><p>Did you try bigger that 64-byte packets ? I'm curious how various runtimes would handle that.</p><p>And how long did you run the benchmarks ? I couldn't really figure it out from the github or the paper. Mostly wondering if java and other Gc'd language showed improvement or degradation over time. I could see the JITs kicking in, but I could also see the GCs causing latency spikes.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20949555"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20949555" href="https://news.ycombinator.com/vote?id=20949555&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; am I missing some packet header overhead ?<p>Yes: Ethernet adds 20 bytes: 8 byte preamble/start of frame delimiter + 12 byte interframe gap</p><p>=&gt; the "on-the-wire" size is actually 84-bytes</p><p>=&gt; 20Gbps/84-bytes = 29.76Mpps</p><p>&gt; Did you try bigger that 64-byte packets ? I'm curious how various runtimes would handle that.</p><p>In typical forwarding, packet size does not impact forwaring that much until you hit some bandwidth limit (PCIe, DDR and/or L3 cache) because you only touch the packet header (typically the 1st 64-bytes cacheline in the packet). The data transfer itself will be done by NIC DMA.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20949616"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20949616" href="https://news.ycombinator.com/vote?id=20949616&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>PCIe bandwidth also decreases with increasing packet size as there's a lot of overhead per packet. Memory isn't used, it's all handled in cache, hitting main memory is super slow.</span></p></div></td></tr>
      </tbody></table></td></tr>
      <tr id="20949569"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20949569" href="https://news.ycombinator.com/vote?id=20949569&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>You're only considering the MAC level size of 64 bytes but there is also the physical layer overhead, which pushes the effective size of a packet to 84 bytes (see [1]) with a 7 bytes preamble, a 1 byte start of frame delimiter and 12 bytes of inter-packets gap. If you use 84 bytes with 20 Gbps you get the 29.76 Mpps.<p>[1] <a href="https://en.wikipedia.org/wiki/Ethernet_frame" rel="nofollow">https://en.wikipedia.org/wiki/Ethernet_frame</a>
              </p></span></p></td></tr>
      </tbody></table></td></tr>
                <tr id="20947286"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_20947286" href="https://news.ycombinator.com/vote?id=20947286&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>The fact that Go is slower than C# really amazes me! Not long ago I switched from C# to Go on a project for performance reasons, but maybe I need to go back.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20947390"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20947390" href="https://news.ycombinator.com/vote?id=20947390&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>It’s only slower at the highest batch sizes. I’d say their performance on throughput here is comparable, except the Go version has much better latencies (don’t be confused by the first graph like I was: that green line at the top is actually javascript).</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20947813"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20947813" href="https://news.ycombinator.com/vote?id=20947813&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Thanks. I was looking at that and scratching my head as to why Go's latency was so bad here...</span></p></div></td></tr>
      </tbody></table></td></tr>
      <tr id="20947700"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20947700" href="https://news.ycombinator.com/vote?id=20947700&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>What made you come to the conclusion that golang was faster than C#? The hype and claims we see in blogs that are not backed up by anything?<p>Both C# and Java are faster than golang.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20947947"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20947947" href="https://news.ycombinator.com/vote?id=20947947&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Usually where I see C# slow down is not because of the language, but because of over engineered "enterprisey" solutions that Java has a bad rep for e.g. having things like a FactoryProviderFactory type idioms.<p>A lot of the projects I work on, for instance, heavily utilize dependency injection for no gain. There's only one implementation, theres no test mocks. Its just overengineered and obsfuscated for no reason.</p><p>Coming from a predominantly C++ background, we eschew virtual wherever possible, favoring compile time polymorphism to runtime whenever possible, because we're cognizant of the overhead of the indirect dispact and likely loss of optimized opportunities to inline trivial calls.</p><p>For sure, one can write C# or Java that can keep up, or even outperform C++ in some circumstances, but youre not going to do it with "enterprise" patterns hiding behind interfaces and factories and dependency injection.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20948155"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20948155" href="https://news.ycombinator.com/vote?id=20948155&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>That isn't how Turbo Vision, OWL, VCL, MFC, Motif++, PowerPlant, C Set++, ATL, Qt, Unreal, COM/UWP, wxWidgets, JUCE look like.<p>There are the CppCon talks, the Modern C++ advocacy, and then there is the code that everyone at most corporations actually write.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20948860"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_20948860" href="https://news.ycombinator.com/vote?id=20948860&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Virtual dispatch is particularly well suited for constructing dynamic GUIs at runtime. Doesn't mean that "everyone" is writing code like that.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20948914"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_20948914" href="https://news.ycombinator.com/vote?id=20948914&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>COM/UWP is not only for GUIs, it is the full area of modern Windows APIs.<p>Then there are ORM like the ill fated POET.</p><p>Yeah just like not everyone is writing code that "eschew virtual wherever possible, favoring compile time polymorphism to runtime whenever possible", specially on large corporations with mixed language teams.</p><p>Beyond C++ conference talks, I am yet to see stuff like SFINAE and tag dispatching in the C++ code I occasionally deal with. Grated those are libraries that get called from Java/.NET projects.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20957833"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="240"></td><td><center><a id="up_20957833" href="https://news.ycombinator.com/vote?id=20957833&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I have written a fair amount of C++ template metaprogramming and policy based libraries.  One library I wrote, in particular, was a templated generic matching engine primarily used in the self-clearing of trades. Through template policies, it could be configured to do one-to-one, on-to-many, many-to-many matching based upon template args, for example. I also did a bit of SFINAE in writing a home-grown ORM lib. I haven't really written any libs using tag dispatching, but I've certainly used my fair share (looking at you, Boost MultiIndex).<p>You don't usually see these sorts of types wrapped for Java or .Net, and if they are, you usually have some sort of proxy in between to hide the templates.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
            <tr id="20947785"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20947785" href="https://news.ycombinator.com/vote?id=20947785&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Saying "The hype and claims we see in blogs that are not backed up by anything?" followed by "Both C# and Java are faster than golang" without substantiating the claim is the pot calling the kettle black.<p>If you do have links to share, however, please do.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20952004"><td>
            </td></tr>
        <tr id="20954441"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_20954441" href="https://news.ycombinator.com/vote?id=20954441&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I know of the techempower benchmarks. You'll notice that the go results that end up scoring highly are using "atreugo", a customized low allocation implementation. That's how it gets its speed. Java and C# on the other hand are using fully fledged framework implementations (e.g. Vertx or ASP.NET).<p>You end up with a highly customized implementation not suited for wide use to get the higher performance benefits (and it still doesn't beat java on benchmarks like single/multiple queries and JSON serialization).</p><p>All these benchmarks should be taken with a large grain of salt. The golang compiler doesn't even pass function variables in registers (they're all stack allocated as far as I know), let alone do any of the advanced inlining and optimizations the JVM does.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20954938"><td>
            </td></tr>
        <tr id="20956932"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_20956932" href="https://news.ycombinator.com/vote?id=20956932&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Which is still a specialized library, and not widely used like golangs standard library. And comes with its own set of disadvantages</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20961907"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="240"></td><td><center><a id="up_20961907" href="https://news.ycombinator.com/vote?id=20961907&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Vertx is not part of the standard library either, saying that Fast HTTP is a spezialized lib is very missleading since it's widely used.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20962680"><td>
            </td></tr>
              <tr id="20948040"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20948040" href="https://news.ycombinator.com/vote?id=20948040&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; Both C# and Java are faster than golang.<p>In this case Golang outperforms (in terms of throughput) Java on batch sizes &gt; 4 and does so by nearly 2x at batch size of 256.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
      <tr id="20950783"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20950783" href="https://news.ycombinator.com/vote?id=20950783&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Not sure of this was a web project, but I imagine when you add an entire framework and web server, you may see less performance than a small binary, regardless of the respective language speed</span></p></div></td></tr>
      </tbody></table></td></tr>
                <tr id="20950659"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_20950659" href="https://news.ycombinator.com/vote?id=20950659&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Is there a compelling reason to write high level user mode drivers like this over traditional kernel drivers? I remember finding this repo a few years back and being fascinated.</span></p></div></td></tr>
      </tbody></table></td></tr>
        <tr id="20950684"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20950684" href="https://news.ycombinator.com/vote?id=20950684&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>From the paper: <a href="https://www.net.in.tum.de/fileadmin/bibtex/publications/papers/the-case-for-writing-network-drivers-in-high-level-languages.pdf" rel="nofollow">https://www.net.in.tum.de/fileadmin/bibtex/publications/pape...</a><p>&gt; Drivers are written in C or restricted subsets of C++ on all production-grade server, desktop, and mobile operating systems. They account for 66% of the code in Linux, but 39 out of 40 security bugs related to memory safety found in Linux in
2017 are located in drivers. These bugs could have been prevented by using high-level languages for drivers.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
    <tr id="20951046"><td>
            </td></tr>
        <tr id="20951174"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_20951174" href="https://news.ycombinator.com/vote?id=20951174&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>Interesting. I suppose the ability to (almost?) debug drivers like I would any other user-mode applications could be a big win.</span></p></div></td></tr>
      </tbody></table></td></tr>
                  <tr id="20956398"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_20956398" href="https://news.ycombinator.com/vote?id=20956398&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Rust has definitely earned my respect.<p>Someone add D lang to this test!  I want to know!
              </p></span></p></td></tr>
      </tbody></table></td></tr>
              <tr id="20949329"><td>
            </td></tr>
        <tr id="20951064"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20951064" href="https://news.ycombinator.com/vote?id=20951064&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><br><div>
                  <p><span>While C++ is way better than using C, it doesn't forbid "writing C with C++ compiler", does rendering useless all the safety features it offers, if one isn't allowed to tame the team via static analysis tooling.</span></p></div></td></tr>
      </tbody></table></td></tr>
                <tr id="20948313"><td>
            </td></tr>
              <tr id="20948306"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_20948306" href="https://news.ycombinator.com/vote?id=20948306&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>I am calling in question validity of this project as a benchmark.<p>The author asserts, that "it's virtually impossible to write allocation-free idiomatic Java code, so we still allocate... 20 bytes on average per forwarded packet". This sounds questionable, — does that mean, that he actually performs a JVM memory allocation for _every_ packet?! Furthermore, the specifics of memory management look murky. One implementation uses "volatile" C writes [1] (simply storing data to memory). Another implementations of the same thing uses a full CPU memory barrier [2]. Which one is right?</p><p>In my opinion, significant inconsistencies between implementations render any comparison between them invalid. And when a whole cross-language test suite is written by one person, you can be sure, that they don't really excel in many of those languages.</p><p>This is why I like Benchmark Game — all benchmarks are submitted by users, so they are a lot closer to how a real-world decent programmers can solve the problem. Still not perfect, but at least that counts as an attempt.</p><p>1: <a href="https://github.com/ixy-languages/ixy.java/blob/fcad50339e5372d7cc1cc53d7a7360bec04aaebd/ixy/src/main/java/de/tum/in/net/ixy/ixgbe/IxgbeTxQueue.java" rel="nofollow">https://github.com/ixy-languages/ixy.java/blob/fcad50339e537...</a></p><p>2: <a href="https://github.com/ixy-languages/ixy.java/blob/fcad50339e5372d7cc1cc53d7a7360bec04aaebd/ixy/src/ixy/c/ixy.c" rel="nofollow">https://github.com/ixy-languages/ixy.java/blob/fcad50339e537...</a>
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20949645"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20949645" href="https://news.ycombinator.com/vote?id=20949645&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>Java reaches 52% of C speed in the benchmark game ("fastest measurement at the largest workload" data set, geometric mean), we reach 38%. Seems like our implementation is within a reasonable range for something that's usually not done in Java.<p>A full memory barrier is not required, but some languages only offer that. For example, go had the same problem. It's not a bottleneck because it goes to MMIO PCIe space which is super slow anyways (awaits a whole PCIe roundtrip).</p><p>And no, it obviously wasn't written by only one person but a team of 10.</p><p>No, we are not saying that we allocate for every packet. We say that we allocate 20 bytes on average per packet.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
        <tr id="20953105"><td>
            </td></tr>
      <tr id="20948585"><td>
            <table>  <tbody><tr>    <td><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_20948585" href="https://news.ycombinator.com/vote?id=20948585&amp;how=up&amp;goto=item%3Fid%3D20945819"></a></center></td><td><p><span>&gt; The author asserts, that "it's virtually impossible to write allocation-free idiomatic Java code, so we still allocate... 20 bytes on average per forwarded packet". This sounds questionable<p>The code is public, I'm sure they'd be happy to have your insight and fix this issue, it doesn't seem like they were happy about it.
              </p></span></p></td></tr>
      </tbody></table></td></tr>
              </tbody></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>