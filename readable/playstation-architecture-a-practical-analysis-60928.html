<!DOCTYPE html>
<html lang="en">
<head>
    <title>
PlayStation Architecture | A Practical Analysis - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="PlayStation Architecture | A Practical Analysis - linksfor.dev(s)"/>
    <meta property="og:description" content="An in-depth analysis that explains how this console works internally"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://copetti.org/projects/consoles/playstation/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - PlayStation Architecture | A Practical Analysis</title>
<div class="readable">
        <h1>PlayStation Architecture | A Practical Analysis</h1>
            <div>Reading time: 15-19 minutes</div>
        <div>Posted here: 21 Apr 2020</div>
        <p><a href="https://copetti.org/projects/consoles/playstation/">https://copetti.org/projects/consoles/playstation/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div class="page"><nav id="navbar"></nav><hr><h2 id="a-quick-introduction">A quick introduction</h2><p>Sony knew that 3D hardware can get very messy to develop for, for this reason, their new console will keep its design <em>simple</em> and <em>practical</em>… Although this may come with a cost!</p><hr><h2 id="cpu">CPU</h2><p>The main processor is a modification of LSI’s <strong>CoreWare CW33300</strong> which, at the same time, is binary-compatible with SGI’s <strong>MIPS R3051</strong>. This chip runs at 33.87 MHz and it features:</p><ul><li>The <strong>MIPS I</strong> ISA: A 32-bit RISC instruction set, it includes multiplication and division instructions.</li><li>One ALU and one shifter.</li><li>5-stage pipeline.</li><li>4 KB instruction cache and 1 KB of data cache (the original CoreWare CW33300 contained 2 KB of data cache): The data cache is actually <strong>Scratchpad RAM</strong>, meaning that it can have other uses apart from behaving as L1 cache.</li></ul><p>Like other MIPS R3000-based CPUs, it supported configurations with up to four coprocessors, Sony customised it with two:</p><ul><li><strong>System Control Coprocessor</strong> or ‘COP0’: A MMU that provides virtual memory by using a Translation Lookaside Buffer or ‘TLB’. Not all the features that come with virtual memory are available though, for example, memory protection is disabled since games are programmed for bare-metal (without running from an OS). On the other hand, this MMU still gives interrupt support, exception handling and breakpoints, these are used for debugging.</li><li><strong>Geometry Transformation Engine</strong> or ‘GTE’: A special math processor used for vector and matrix calculations. While only containing a fixed-point unit, it still provides useful operations for 3D graphics such as lighting and polygon transformations.</li></ul><p>Additionally, there’s an extra processor found in the main CPU:</p><ul><li><strong>Motion Decoder</strong> or ‘MDEC’: Provides <strong>full motion video</strong> playback (known as ‘FMV’) and transfers the decoded frames to the GPU using DMA.</li></ul><h4 id="taking-over-the-cpu">Taking over the CPU</h4><p>Sometimes any subsystem (graphics, audio or CD) may require large chunks of data at a fast rate, however the CPU may not be able to <em>always</em> keep up with the demand.</p><p>For this reason, the CD-ROM Controller, MDEC, GPU, SPU and the Parallel port have access to an exclusive <strong>DMA controller</strong> that takes control of the main bus whenever they require it.</p><hr><h2 id="graphics">Graphics</h2><p>A large part of the graphics pipeline is carried out by the GTE. This includes perspective transformation, which projects the 3D space onto a 2D plane using the camera’s perspective. The processed data is then sent to Sony’s proprietary GPU for rendering.</p><h4 id="drawing-the-scene">Drawing the scene</h4><p>If you’ve been reading the <a href="https://copetti.org/projects/consoles/sega-saturn/">Sega Saturn article</a>, let me tell you that the design of this GPU <em>a lot</em> simpler!</p><p>Insomniac’s <em>Spyro: Year of the Dragon</em> will be used as example to show how a scene is drawn.</p><div><ul><li id="tab-1-1-models-link"><a href="#tab-1-1-models">Models</a></li><li id="tab-1-2-shaders-link"><a href="#tab-1-2-shaders">Shaders</a></li><li id="tab-1-3-textures-link"><a href="#tab-1-3-textures">Textures</a></li></ul><div><div id="tab-1-1-models"><h4>Models</h4><div><div><a href="https://copetti.org/images/consoles/ps1/spyro/wireframes.png"><picture>
<img name="image_cover" alt="Image" src="https://copetti.org/images/consoles/ps1/spyro/wireframes.png" data-src="https://copetti.org/images/consoles/ps1/spyro/wireframes.png"></picture></a><figcaption>Primitive view of the scene</figcaption></div><p>To start with, the GPU uses <strong>triangles as primitives</strong> to form 3D models. Being the only available primitive means that backgrounds and foregrounds make no difference in terms of composition (both are made of triangles). 2D games inherit the same nature: They are just flat polygons (two triangles joined to form a quadrangle). The GPU also includes routines for handling quadrangles as sprites.</p><p>The CPU sends geometry data to the GPU by filling its internal 64 byte FIFO buffer with <strong>commands</strong> (up to three). Basically, a command states how and where to draw one primitive. Once the geometry is received, <strong>clipping</strong> is applied to skip operations over unseen polygons (residing outside the camera’s viewport).</p><p>Compared to the more complex <a href="https://copetti.org/projects/consoles/sega-saturn/">Sega Saturn</a>, the GPU only requires a <strong>single frame-buffer</strong>.</p></div></div><div id="tab-1-2-shaders"><h4>Shaders</h4><div><div><a href="https://copetti.org/images/consoles/ps1/spyro/shaders.png"><picture>
<img name="image_cover" alt="Image" src="https://copetti.org/images/consoles/ps1/spyro/shaders.png" data-src="https://copetti.org/images/consoles/ps1/spyro/shaders.png"></picture></a><figcaption>Gouraud shading in action</figcaption></div><p>In order to apply lighting effects over these polygons, the system provides two algorithms:</p><ul><li><strong>Flat shading</strong>: Each primitive has a constant light level.</li><li><strong>Gouraud shading</strong>: Each primitive’s vertex has its own light level, then the brightness between each point is automatically interpolated. As you can imagine the results are more realistic. On the other hand, this algorithm is not available for sprites.</li></ul><p>The reason of having this choice comes down to the fact that Flat shading provides ~2.5 times more polygons per second than Gouraud, so it’s important to optimise which polygons need a more realistic shading than others.</p></div></div><div id="tab-1-3-textures"><h4>Textures</h4><div><div><a href="https://copetti.org/images/consoles/ps1/spyro/result.png"><picture>
<img name="image_cover" alt="Image" src="https://copetti.org/images/consoles/ps1/spyro/result.png" data-src="https://copetti.org/images/consoles/ps1/spyro/result.png"></picture></a><figcaption>Textures applied (<i>Tada!</i>)</figcaption></div><p>Finally, shaded surfaces are blended with texture maps to produce the final result.</p><p>The GPU performs a very <em>inexpensive</em> routine called <strong>Affine Texture Mapping</strong> to stamp textures on our polygons. This technique only operates using 2D coordinates (X/Y values) while discarding the third coordinate used for perspective (Z-value).</p><p>The unit also includes the following effects available to use:</p><ul><li><strong>Semi-Transparency</strong>: Simulates light passing through multiple textures.</li><li><strong>Dithering</strong>: Soften sudden changes in colour while adhering to the same colour palette.</li><li><strong>Fog</strong>: Simulates smoke in the environment.</li></ul><p>It’s worth mentioning that the PS1 happened to excel at those effects!</p></div></div></div></div><hr><h4 id="designs">Designs</h4><p>Here are some examples of game characters designed from the ground up for the 3D era, they are interactive so I encourage you to check them out!</p><h4 id="playing-with-vram">Playing with VRAM</h4><p>The system features 1 MB of VRAM that will be used to store the frame-buffer, textures and other resources the GPU will need to access almost instantly. In theory, with the available amount of VRAM one could allocate a <em>massive</em> frame-buffer of 1024×512 pixels with 16-bit colours or a <em>realistic</em> one of 960×512 pixels with 24-bit colours allowing to draw the best frames any game has ever shown… This sounds pretty impressive right? Well, it does raise a couple of issues, for instance:</p><ul><li>Those dimensions will have to be rescaled to follow a standardised definition so the video encoder can broadcast it to conventional TVs.</li><li>How is the GPU going to be able to draw anything in time if there is no space left for the rest of materials (i.e.textures, colour tables, etc)?</li><li>The PS1’s GPU can only process frame-buffers with up to 640×480 pixels.</li></ul><p>Alright, so let’s have a 16 bpp 640x480 buffer instead, which leaves 424 KB of VRAM for materials. So far so good? Again, such resolution may be fine on CRT monitors, but not really noticeable on those 90s TVs everyone had at their homes. Then, is there any way to optimise the frame-buffer? Introducing <strong>adjustable frame-buffers</strong>.</p><p>In essence, instead of wasting valuable VRAM by using ‘unappreciated’ resolutions, this console’s GPU allows to decrease the dimensions of the frame-buffer to effectively increment the space available for other resources.<br>A common setup consisted in dividing the 640x480 frame-buffer into two 320x480 ones, then using a technique called <strong>page-flipping</strong> to render multiple scenes at the same time. Page-flipping consists in switching the location of the frame for display between the two available whenever the game wants it, allowing the game to render one scene while displaying another, thus hiding any flickering effect and improving loading times (something that the player will certainly appreciate!).</p><p>Overall, our suggested layout only consumed 600 KB of VRAM. The rest (424 KB) was often used to store colour lookup-tables and textures that, combined with <strong>2 KB of texture cache available</strong>, resulted in a very convenient and efficient setup.</p><p>Finally, it is worth mentioning that VRAM could be mapped using <strong>multiple colour depths at the same time</strong>, meaning that we could allocate a 16 bpp frame-buffer with 24 bpp textures alongside it. This is another feature allowing further optimisation of space.</p><h4 id="secrets-and-limitations">Secrets and Limitations</h4><p>Whereas the PS1 had a very simple and suitable architecture, problems ended up arising anyway. Surprisingly, certain issues were tackled with very clever workarounds!</p><div><ul><li id="tab-2-1-wobbling-textures-link"><a href="#tab-2-1-wobbling-textures">Wobbling textures</a></li><li id="tab-2-2-visibility-approach-link"><a href="#tab-2-2-visibility-approach">Visibility approach</a></li><li id="tab-2-3-pre-rendered-graphics-link"><a href="#tab-2-3-pre-rendered-graphics">Pre-rendered graphics</a></li></ul><div><div id="tab-2-1-wobbling-textures"><h4>Wobbling textures</h4><div><p><video poster="https://copetti.org/images/consoles/ps1/video_posters/ffviii.jpg" preload="metadata" src="https://copetti.org/videos/consoles/ps1/ffviii.mp4" href="https://copetti.org/videos/consoles/ps1/ffviii.mp4" controls="" controllist="nodownload">
No support for video.</video><figcaption>Textures jiggle a bit while they move<br>Square Soft's Final Fantasy VIII (1999)</figcaption></p><p>The routines used for handling geometry and applying textures were known to carry some inaccuracies:</p><ul><li>GPU coordinates are <strong>limited to fixed-point units</strong>: That means no decimals (thus no precision), contributing to sudden jumps when polygons move slightly.</li><li>As you know, affine transformations have <strong>no sense of depth</strong>, which may confuse the user’s perception when the camera is close to the model and is positioned perpendicular to the viewer.</li><li>Finally, the smallest size of a polygon in this system <strong>is a pixel</strong>, making small polygons (no matter how small) to be rendered as a single pixel. Now, this means that textured polygons may lose part of their texture if their size becomes smaller than a pixel. Furthermore, complex models may suffer from edges constantly shaking.<ul><li>This effect is more apparent when using a small frame-buffer or rendering models at a distance. Modern systems tackled this by implementing sub-pixel resolution methods, which handles polygons using fractions of pixels.</li></ul></li></ul><p>These explain why users may notice instabilities while playing some games. The effect is also referred as <strong>texture warping</strong>, some games often resorted to <strong>tessellation</strong> (dividing a big polygon into smaller ones) in order to reduce these unwanted effects, others just reduced the amount of textures in favour of <strong>solid colours</strong>.</p></div></div><div id="tab-2-2-visibility-approach"><h4>Visibility approach</h4><div><div><a href="https://copetti.org/images/consoles/ps1/crash.jpg"><picture>
<img name="image_cover" alt="Image" src="https://copetti.org/images/consoles/ps1/crash.jpg" data-src="https://copetti.org/images/consoles/ps1/crash.jpg"></picture></a><figcaption>This game used pre-ordered geometry to gain performance<br>Hence its camera only moves backwards or forwards<br>Crash Bandicoot (1996)</figcaption></div><p>Just like the <a href="https://copetti.org/projects/consoles/sega-saturn/">competition</a>, the PS1 doesn’t include any hardware feature that solves the <a href="https://copetti.org/projects/consoles/sega-saturn/#an-introduction-to-the-visibility-problem">visibility problem</a>. Nonetheless, the GPU supports sorted polygons by providing an <strong>ordering table</strong>: A dedicated table where each entry is indexed using a depth value (also called ‘Z-value’) and contains the address where the GPU command resides.</p><p>The CPU needs to manually sort the polygons first, and then reference them in the correct entry of the table, which will be handled by the GPU. This process will enable the GPU to render the geometry in the correct order.</p><p>Multiple DMA functions are provided to assist the CPU/GPU with the creation and traversal of this table.</p></div></div><div id="tab-2-3-pre-rendered-graphics"><h4>Pre-rendered graphics</h4><div><div><a href="https://copetti.org/images/consoles/ps1/prerendered.png"><picture>
<img name="image_cover" alt="Image" src="https://copetti.org/images/consoles/ps1/prerendered.png" data-src="https://copetti.org/images/consoles/ps1/prerendered.png"></picture></a><figcaption>Scene with Pre-rendered background<br>The way models interact and move is essential to <i>trick</i> the user's perception<br>Square Soft's Final Fantasy VII (1997)</figcaption></div><p>If a game strived for a more realistic scenery than the GPU could provide, one available option was to stack two triangles and use the Motion Decoder to feed <strong>pre-rendered cinematic</strong> on them. FMV video could weight a lot of space, luckily the CD-ROM was prepared for this.</p><p>Some games relied on it specifically for composing backgrounds and, honestly, it was quite convincing to see them in a CRT TV, obviously modern emulators with upscaling capabilities will tell on very quickly.</p></div></div></div></div><hr><h2 id="audio">Audio</h2><p>The <strong>Sound Processing Unit</strong> or ‘SPU’ takes care of this. It supports the enormous amount of <strong>24 channels</strong> of <strong>ADPCM samples</strong> (a more efficient version of the well-known PCM sampling) with a sampling rate of 44.1 KHz (CD quality).</p><p>This chip also provides the following capabilities:</p><ul><li><strong>MIDI sequencing</strong>: Apart from playing samples, this chip will also synthesise MIDI-encoded music.</li><li><strong>Pitch modulation</strong>: As the name suggests, games can automatically alter the pitch of their samples instead of needing to store extra ones.</li><li><strong>ADSR Envelope</strong>: These are a set of properties available for sound modulation.</li><li><strong>Looping</strong>: This allows to instruct the system to play a piece of audio repeatedly.</li><li><strong>Digital reverb</strong>: Simulates the sample being played inside an specific atmosphere in order immerse the player.</li></ul><p>512 KB of buffer is used to transfer audio, this memory is accessible from the CPU and CD controller, the latter will reserve it while playing an Audio CD.</p><hr><h2 id="games">Games</h2><p>Similarly to the Saturn’s boot process, after turning this console on, it will:</p><ol><li>Execute a small OS found in the BIOS ROM.<ol><li>Initialise the hardware.</li></ol></li><li>Display the splash screen.</li><li>If there is a CD inserted, the CD-ROM controller will check if it’s genuine:<ul><li><strong>It is</strong>: The controller will allow to read its content.<ol><li>The CPU will look for ‘SYSTEM.CNF’ and continue execution from there.</li></ol></li><li><strong>It’s not</strong>: The CPU will display an error message.</li></ul></li><li>With no CD inserted, the CPU will open the memory card manager, the user is now in control.<ol><li>Inside the manager there’s an option to open the CD audio player.</li></ol></li></ol><p>Games have all the facilities that the CD medium provides: Large storage (640 MB), good audio quality and a ‘not-so-slow’ read speed thanks to the 2x drive. Additionally, there are two I/O ports (<strong>Serial</strong> and <strong>Parallel</strong>) available for add-ons, however these were removed in later revisions of the console due to lack of use and the fact that they could also be applied to crack the copy protection system.</p><p>The SDK provided C libraries which used <strong>BIOS routines</strong> to access the hardware. This is the main factor that helped to emulate the PS1 on wide range of platforms.</p><h4 id="io-design">I/O design</h4><p>The port of the controller and the Memory Card are electrically identical so the address of each one is hardcoded, Sony altered the physical shape of the ports to avoid accidents.</p><hr><h2 id="anti-piracy--region-lock">Anti-piracy / Region Lock</h2><p>Like any other optical media, in order to fetch data from a CD, a laser beam is used to read the <strong>pits</strong> (zeroes) and <strong>lands</strong> (ones) from the track of the disc.
Now, conventional discs are not 100% flat and they often have tiny fluctuations in their tracks. These <em>defects</em> are completely unnoticeable while reading the data since lasers can automatically calibrate themselves as they read.</p><p>This is what Sony based their copy protection on: The CD reader of the PS1 will only accept discs whose specific region (sector 4) is engraved using a defined frequency informally known as <strong>Wobble Groove</strong>, which is only applied during mastering and cannot be replicated through conventional burners. This sector in particular will contain one of the following set of characters (each representing a different piece of information):</p><ul><li><strong>SCEA</strong> → Sony Computer Entertainment of America.</li><li><strong>SCEE</strong> → Sony Computer Entertainment of Europe.</li><li><strong>SCEI</strong> → Sony Computer Entertainment of Japan.</li></ul><p>As you can imagine, the reader applies <strong>region-locking</strong> using this technique as well.</p><p>On the other side, this check is only executed once at the start, so manually swapping the disc just after passing the check can defeat this protection… with the risk of damaging the drive.
Alternatively, tiny boards programmed to mock the wobble signal could be soldered in the console. These boards are known as <strong>Modchips</strong> and, while legally questionable, were incredibly popular.</p><p>The use of emulators were seen as a threat for publishers as well. As a result, some games included their own checks (mostly checksums) to combat any type of unauthorised use or modification.</p><hr><h2 id="sources--keep-reading">Sources / Keep Reading</h2><h4 id="general">General</h4><ul><li><a href="https://en.wikipedia.org/wiki/PlayStation_technical_specifications"><strong>Technical Specifications (Wikipedia)</strong></a></li><li><a href="http://hitmen.c02.at/files/docs/psx/psx.pdf"><strong>Unofficial (yet very complete) development manual</strong></a></li><li><a href="https://www.youtube.com/watch?v=MPXpH2hxuNc"><strong>Video with more details about the architecture</strong></a></li><li><a href="https://en.wikipedia.org/wiki/PlayStation_models"><strong>Different revisions of the console</strong></a></li></ul><h4 id="cpu-1">CPU</h4><ul><li><a href="https://github.com/mamedev/mame/blob/master/src/devices/cpu/psx/psx.cpp"><strong>Source code of emulator</strong></a></li></ul><h4 id="graphics-1">Graphics</h4><ul><li><a href="https://retrocomputing.stackexchange.com/questions/5019/why-do-3d-models-on-the-playstation-1-wobble-so-much"><strong>Retrocomputing thread discussing the reasons 3D models jiggled</strong></a></li><li><a href="https://www.youtube.com/watch?v=nqw2HMUrNiA"><strong>More examples of unstable polygons</strong></a></li><li><a href="https://web.archive.org/web/20200216025504/https://www.models-resource.com/"><strong>The Models Resource</strong> (Archived)</a></li><li><a href="https://all-things-andy-gavin.com/2011/02/02/making-crash-bandicoot-part-1/"><strong>Making of Crash Bandicot, written by the original developers</strong></a></li></ul><h4 id="copy-protection">Copy protection</h4><ul><li><a href="https://www.youtube.com/watch?v=XUwSOfQ1D3c"><strong>‘Wobble groove’ in detail</strong></a></li><li><a href="https://github.com/kalymos/PsNee"><strong>Open source modchip using an Arduino</strong></a></li></ul><h4 id="photography">Photography</h4><ul><li>Motherboard and console: <a href="https://commons.wikimedia.org/wiki/User:Evan-Amos"><strong>Evan Amos Gallery</strong></a></li><li>Diagrams and game screenshots: <strong>Me</strong></li></ul><hr><h3 id="contributing">Contributing</h3><p id="contributing-body">This article is part of the <a href="https://copetti.org/projects/consoles/">Architecture of Consoles</a> series.
If you found it interesting please consider donating, your contribution will be used to get more tools and resources that will help to improve the quality of current articles and upcoming ones.</p><p>A list of desirable tools and latest acquisitions for this article are tracked in here:</p><div><pre><code data-lang="markdown"><span>## Interesting hardware to get (ordered by priority)
</span><span></span>
<span>-</span> First PS1 revision with a controller (£5 - £20 ?)
- Any game (£5 ?)</code></pre></div><hr><h3>Changelog</h3><p>Always nice to keep a record of changes.</p><div><pre><code data-lang="markdown"><span>## 2020-04-19
</span><span></span>
<span>-</span> Expanded anti-piracy section after finding more info

<span>## 2020-04-11
</span><span></span>
<span>-</span> Dedicated more text to the visibility approach 

<span>## 2020-02-28
</span><span></span>
<span>-</span> Expanded VRAM section

<span>## 2020-01-27
</span><span></span>
<span>-</span> Expanded 'Models' section
<span>-</span> Added more reasons textures wobble

<span>## 2019-10-29
</span><span></span>
<span>-</span> Added some 3d models to fiddle with

<span>## 2019-10-09
</span><span></span>
<span>-</span> Improved Scratchpad term

<span>## 2019-09-17
</span><span></span>
<span>-</span> Added a quick introduction

<span>## 2019-08-29
</span><span></span>
<span>-</span> Better explanations

<span>## 2019-08-09
</span><span></span>
<span>-</span> Corrected vague CPU info

<span>## 2019-08-08
</span><span></span>
<span>-</span> Ready for publication
</code></pre></div><hr></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>