<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Consuming Ethernet frames with the nom crate - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Consuming Ethernet frames with the nom crate - linksfor.dev(s)"/>
    <meta property="og:description" content="Now that we&#x27;ve found the best way to find the &#x201C;default network interface&#x201D;&#x2026; what can we do with that interface?&#xA;Well, listen for network traffic of course!&#xA;use rawsock::open_best_library; use std::time::Instant; fn main() -&gt; Result&lt;(), Error&gt; { let lib = open_best_library()?; let iface_name = format!(r#&quot;\Device\NPF_{}&quot;#, netinfo::default_nic_guid()?); let iface = lib.open_interface(&amp;iface_name)?; println!(&quot;Listening for packets...&quot;); // doing some low-cost logging over here let start = Instant::now(); iface.loop_infinite_dyn(&amp;mut |packet| { println!( &quot;{:?} | received {} bytes&quot;, start."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://fasterthanli.me/blog/2019/making-our-own-ping-9/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Consuming Ethernet frames with the nom crate</title>
<div class="readable">
        <h1>Consuming Ethernet frames with the nom crate</h1>
            <div>Reading time: 40-51 minutes</div>
        <div>Posted here: 29 Nov 2019</div>
        <p><a href="https://fasterthanli.me/blog/2019/making-our-own-ping-9/">https://fasterthanli.me/blog/2019/making-our-own-ping-9/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
          






          
    <p>Now that we've found the best way to find the “default network interface”…
what can we do with that interface?</p>
<p>Well, listen for network traffic of course!</p>
<pre><code><span>use</span> rawsock::open_best_library;
<span>use</span> std::time::Instant;

<span><span>fn</span> <span>main</span></span>() -&gt; <span>Result</span>&lt;(), Error&gt; {
    <span>let</span> lib = open_best_library()?;

    <span>let</span> iface_name = <span>format!</span>(<span>r#"\Device\NPF_{}"#</span>, netinfo::default_nic_guid()?);
    <span>let</span> iface = lib.open_interface(&amp;iface_name)?;

    <span>println!</span>(<span>"Listening for packets..."</span>);

    
    <span>let</span> start = Instant::now();
    iface.loop_infinite_dyn(&amp;<span>mut</span> |packet| {
        <span>println!</span>(
            <span>"{:?} | received {} bytes"</span>,
            start.elapsed(),
            packet.len()
        );
    })?;
    <span>Ok</span>(())
}
</code></pre>
<p>Here's a video:</p>

<p>And here's some text, for accessibility:</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
1.0005401s | received 60 bytes
1.0005401s | received 100 bytes
1.0005401s | received 85 bytes
1.0005401s | received 54 bytes
1.0005401s | received 54 bytes
1.0005401s | received 54 bytes
1.0005401s | received 54 bytes
1.0005401s | received 54 bytes
1.8324313s | received 900 bytes
1.8324313s | received 183 bytes
1.8324313s | received 1392 bytes
1.8324313s | received 1392 bytes
1.8324313s | received 1392 bytes
1.8333986s | received 1392 bytes
(cut)
</code></pre>
<p>It.. seems to work? Although it's hard to tell, because I haven't printed the
contents of each packet. And I haven't printed the contents of each packet,
because I don't want to post raw traffic from and to my own computer on the
internet, even if I can't make sense of it right now - somebody might!</p>
<h2 id="sniffing-the-dumb-way">Sniffing the dumb way</h2>
<p>I can think of a way to make sure it works.</p>
<p>Remember in <a href="https://fasterthanli.me/blog/2019/making-our-own-ping-2/">Part 2</a> when we discovered that
Windows's <code>ping.exe</code> sent lowercase letters of the alphabet?</p>
<p>If the payload for ICMP echo packets isn't compressed (and this seems unlikely),
then we should be able to find it in the packets we're sniffing. Let's give it a go.</p>
<p>So we just use <code>.find()</code> and..</p>
<pre><code>iface.loop_infinite_dyn(&amp;<span>mut</span> |packet| {
    <span>let</span> now = start.elapsed();

    <span>match</span> packet.find(<span>"abcdefghijkl"</span>) {
        <span>Some</span>(_) =&gt; <span>println!</span>(<span>"{:?} | probably an ICMP packet"</span>, now),
        <span>None</span> =&gt; <span>println!</span>(<span>"{:?} | probably *not* an ICMP packet"</span>, now),
    }
})?;
</code></pre>
<pre><code><span>$</span><span> cargo check</span>
    Checking ersatz v0.1.0 (C:\msys64\home\amos\ftl\ersatz)
error[E0599]: no method named `find` found for type `&amp;rawsock::common::packet::BorrowedPacket&lt;'_&gt;` in the current scope
<span>  --&gt;</span><span> src\main.rs:23:22</span>
   |
23 |         match packet.find("abcdefghijkl") {
   |                      ^^^^
</code></pre>
<p>Wait, frick, no, <code>&amp;[u8]</code> doesn't have <code>.find</code>. It has <code>contains</code> but that's
just for a single element (a single u8) - which is not helpful here.</p>
<p>How do we find if a slice contains another slice?</p>
<p>Well, there are certainly smart ways to do it, but for the time being we
can simply use <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.windows">windows iterators</a>.</p>
<p><code>haystack.windows(N)</code> gives us an iterator over iterators over all subslices
of length N of <code>haystack</code>. If we call it with <code>N = needle.len()</code>, we can test
all those subslices for equality with needle, and stop whenever we find one
that matches!</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/windows-iterators.png" alt=""></p>
<p>Let's make a quick function for that:</p>
<pre><code><span><span>fn</span> <span>contains</span></span>(haystack: &amp;[<span>u8</span>], needle: &amp;[<span>u8</span>]) -&gt; <span>bool</span> {
    haystack
        .windows(needle.len())
        .any(|window| window == needle)
}
</code></pre>
<p>No, you know what, let's make it generic over <em>any</em> type that can be
thought of as a sequence of bytes:</p>
<pre><code><span><span>fn</span> <span>contains</span></span>&lt;H, N&gt;(haystack: H, needle: N) -&gt; <span>bool</span>
<span>where</span>
    H: <span>AsRef</span>&lt;[<span>u8</span>]&gt;,
    N: <span>AsRef</span>&lt;[<span>u8</span>]&gt;,
{
    <span>let</span> (haystack, needle) = (haystack.as_ref(), needle.as_ref());
    haystack
        .windows(needle.len())
        .any(|window| window == needle)
}
</code></pre>
<p>And then use it:</p>
<pre><code>

iface.loop_infinite_dyn(&amp;<span>mut</span> |packet| {
    <span>let</span> now = start.elapsed();

    <span>if</span> contains(&amp;packet[..], <span>"abcdefghijkl"</span>) {
        <span>println!</span>(<span>"{:?} | probably an ICMP packet"</span>, now);
    } <span>else</span> {
        <span>println!</span>(<span>"{:?} | probably *not* an ICMP packet"</span>, now);
    }
})?;
</code></pre>
<pre><code>$ cargo run --quiet
Listening for packets...
1.0005319s | probably *not* an ICMP packet
1.0005319s | probably *not* an ICMP packet
1.0005319s | probably an ICMP packet
1.0005319s | probably an ICMP packet
1.6498447s | probably an ICMP packet
1.6498447s | probably an ICMP packet
1.6498447s | probably *not* an ICMP packet
2.6507489s | probably *not* an ICMP packet
2.6507489s | probably *not* an ICMP packet
2.6507489s | probably *not* an ICMP packet
2.6507489s | probably *not* an ICMP packet
2.6507489s | probably *not* an ICMP packet
2.6507489s | probably an ICMP packet
2.6507489s | probably an ICMP packet
</code></pre>
<p>Wonderful!</p>
<blockquote>
<p>Note: I was running <code>ping 8.8.8.8 -t</code> in the background to test this.
Otherwise, it's relatively rare to see ICMP packets pass.
Not extremely rare, just uncommon enough that it got annoying to wait.</p>
</blockquote>
<p>For convenience's sake, let's move our “process packet” function out of
main:</p>
<pre><code><span>use</span> rawsock::BorrowedPacket;
<span>use</span> std::time::{Duration, Instant};

<span><span>fn</span> <span>main</span></span>() -&gt; <span>Result</span>&lt;(), Error&gt; {
    <span>let</span> lib = open_best_library()?;

    <span>let</span> iface_name = <span>format!</span>(<span>r#"\Device\NPF_{}"#</span>, netinfo::default_nic_guid()?);
    <span>let</span> iface = lib.open_interface(&amp;iface_name)?;

    <span>println!</span>(<span>"Listening for packets..."</span>);

    <span>let</span> start = Instant::now();
    iface.loop_infinite_dyn(&amp;<span>mut</span> |packet| {
        <span>if</span> !contains(&amp;packet[..], <span>"abcdefghijkl"</span>) {
            
            <span>return</span>;
        }
        process_packet(start.elapsed(), packet);
    })?;
    <span>Ok</span>(())
}

<span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    <span>println!</span>(<span>"{:?} | probably an ICMP packet"</span>, now);
}
</code></pre>
<p>Good. Moving on.</p>
<p>So we know that <em>somewhere in there</em>, there's <em>probably</em> some ICMP packets.
But what it is exactly we're getting? Ethernet frames? IP packets? It could
be either, depending on the library
<a href="https://crates.io/crates/rawsock">rawsock</a> is using under the hood.</p>
<p>If it is an Ethernet frame, then it should have the following structure:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/ethernet-frame-structure.png" alt=""></p>
<p>And the EtherType for IPv4 is <code>0x0800</code>. So if we read a 16-bit
integer at position 12, we should be good?</p>
<p>But how do we get a u16 from a <code>&amp;[u8]</code>? Well, by now, we know an unsafe
way to do it:</p>
<pre><code><span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    <span>let</span> ether_type: <span>u16</span> = <span>unsafe</span> {
        <span>let</span> u16_ptr: *<span>const</span> <span>u16</span> = transmute(&amp;packet[<span>12</span>]);
        *u16_ptr
    };
    <span>println!</span>(<span>"{:?} | ether_type = 0x{:04x}"</span>, now, ether_type);
}
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
6.1546872s | ether_type = 0x0008
6.1547236s | ether_type = 0x0008
6.6612632s | ether_type = 0x0008
6.6613005s | ether_type = 0x0008
7.3471202s | ether_type = 0x0008
7.3471402s | ether_type = 0x0008

</code></pre>
<p>Huh. That's <code>0x0008</code>, not <code>0x0800</code>. Still, pretty close though. Looks like two bytes
were just swapped?</p>
<p>Remember in <a href="https://fasterthanli.me/blog/2019/reading-files-the-hard-way-3/">Reading files the hard way - Part 3</a>,
when we used the <a href="https://crates.io/crates/byteorder">byteorder</a> crate?</p>
<p>Well, same. It just so happens that my processor (an Intel i7) is little-endian, but
Ethernet is big-endian, so we can't <em>just</em> transmute things at will and expect it to
work.</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/be-le.png" alt=""></p>
<p>We <em>can</em> do it by hand:</p>
<pre><code><span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    <span>let</span> (a, b) = (packet[<span>12</span>], packet[<span>13</span>]);
    <span>let</span> (a, b) = (a <span>as</span> <span>u16</span>, b <span>as</span> <span>u16</span>);

    <span>let</span> ether_type = (a &lt;&lt; <span>8</span>) + b;
    <span>println!</span>(<span>"{:?} | ether_type = 0x{:04x}"</span>, now, ether_type);
}
</code></pre>
<p>And it'd work:</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
1.0068664s | ether_type = 0x0800
1.0069143s | ether_type = 0x0800
2.0119471s | ether_type = 0x0800
3.0154707s | ether_type = 0x0800
3.0154912s | ether_type = 0x0800
</code></pre>
<p>But this would only work <em>on little-endian processors</em>. On big-endian
processors, we'd be shifting bytes around unnecessarily (and incorrectly).</p>
<p>Plus, writing this by hand is kinda error-prone. I'm not ashamed to admit
that I - your humble servant - <em>frequently</em> get bit-twiddling wrong.</p>
<p>I'm also not ashamed to admit that I prefer portable, declarative(-ish) code.</p>
<p>Luckily, here we don't even have to bring the <code>byteorder</code> crate in (we're
watching our <code>Cargo.toml</code> size and compile times, remember?). The Rust
standard library contains everything we need.</p>
<p>Unluckily, it wants a fixed-size array, ie. <code>[u8; 2]</code>, not a slice, ie.
<code>&amp;[u8]</code> - which we have.</p>
<p>But look on the bright side! Unsafe no more:</p>
<pre><code><span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    <span>let</span> ether_type = {
        <span>let</span> <span>mut</span> ether_type = [<span>0u8</span>; <span>2</span>];
        ether_type.copy_from_slice(&amp;packet[<span>12</span>..<span>14</span>]);
        
        <span>u16</span>::from_be_bytes(ether_type)
    };
    <span>println!</span>(<span>"{:?} | ether_type = 0x{:04x}"</span>, now, ether_type);
}
</code></pre>
<div>
    
<p>You may be wondering - does <code>copy_from_slice</code> really need to be passed
<code>&amp;packet[12..14]</code>?</p>
<p>Would just <code>&amp;packet[12..]</code> suffice?</p>
<p>It would not. It would panic.</p>
<p>This also explains why <code>copy_from_slice</code> does not return a Result. It just
panics. Just like trying to subslice with invalid indices will also panic.</p>
</div>
<p>Does this work?</p>
<pre><code>$ cargo run --quiet
Listening for packets...
1.0005347s | ether_type = 0x0800
1.0005645s | ether_type = 0x0800
2.0012903s | ether_type = 0x0800
2.0013114s | ether_type = 0x0800
3.0014023s | ether_type = 0x0800
3.0014241s | ether_type = 0x0800
</code></pre>
<p>Yeah! Seems okay. We don't know <em>yet</em> if they're actually ICMP packets, but at least,
it looks like we're getting Ethernet frames that contain IPv4 packets. Either that, or
many coincidences are happening in a row (which is always a possibility, because computers).</p>
<h2 id="two-macs-in-a-rowboat">Two MACs in a rowboat</h2>
<p>How about we check that the MAC addresses look reasonable? We know MAC
addresses look something like <code>12:34:56:78:9A:BC</code>, so, let's make a quick struct.</p>
<p>This is not the last we've seen of Ethernet, so, let's make an <code>ethernet</code> module.</p>
<pre><code>

<span>mod</span> ethernet;
</code></pre>
<pre><code>

<span>use</span> std::fmt;

<span>#[derive(PartialEq, Eq, Clone, Copy)]</span>
<span>pub</span> <span><span>struct</span> <span>Addr</span></span>([<span>u8</span>; <span>6</span>]);

<span>impl</span> fmt::Display <span>for</span> Addr {
    <span><span>fn</span> <span>fmt</span></span>(&amp;<span>self</span>, w: &amp;<span>mut</span> fmt::Formatter) -&gt; fmt::<span>Result</span> {
        <span>let</span> [a, b, c, d, e, f] = <span>self</span>.<span>0</span>;
        <span>write!</span>(
            w,
            <span>"{:02X}-{:02X}-{:02X}-{:02X}-{:02X}-{:02X}"</span>,
            a, b, c, d, e, f
        )
    }
}

<span>impl</span> fmt::<span>Debug</span> <span>for</span> Addr {
    <span><span>fn</span> <span>fmt</span></span>(&amp;<span>self</span>, f: &amp;<span>mut</span> fmt::Formatter) -&gt; fmt::<span>Result</span> {
        fmt::Display::fmt(<span>self</span>, f)
    }
}
</code></pre>
<div>
    
<p>MAC addresses are sometimes formatted as “12:34:45:67:89:AB”, but <a href="https://standards.ieee.org/content/dam/ieee-standards/standards/web/documents/tutorials/macgrp.pdf">according
to some IEEE
document</a>,
the “12-34-45-67-89-AB” form is preferred, so that's what we'll use.</p>
<p>It's also the format used in <code>ipconfig /all</code>'s output on Windows 10 at least.</p>
<p>As a bonus, the hyphen-separated format doesn't look anything like IPv6
addresses. No confusion!</p>
</div>
<p>Let's also make a convenience method to “build” a MacAddress from a slice:</p>
<pre><code>

<span>impl</span> Addr {
    <span>pub</span> <span><span>fn</span> <span>new</span></span>(slice: &amp;[<span>u8</span>]) -&gt; <span>Self</span> {
        <span>let</span> <span>mut</span> res = <span>Self</span>([<span>0u8</span>; <span>6</span>]);
        
        res.<span>0</span>.copy_from_slice(&amp;slice[..<span>6</span>]);
        res
    }
}
</code></pre>
<p>Then, for readability, let's define a <code>read_u16</code> function, which will read
a big-endian 16-bit integer from a slice.</p>
<p>All together, we get:</p>
<pre><code><span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    <span>let</span> read_u16 = |slice: &amp;[<span>u8</span>]| {
        <span>let</span> <span>mut</span> res = [<span>0u8</span>; <span>2</span>];
        res.copy_from_slice(&amp;slice[..<span>2</span>]);
        <span>u16</span>::from_be_bytes(res)
    };

    <span>let</span> dst = ethernet::Addr::new(&amp;packet[<span>0</span>..]);
    <span>let</span> src = ethernet::Addr::new(&amp;packet[<span>6</span>..]);
    <span>let</span> ether_type = read_u16(&amp;packet[<span>12</span>..]);
    <span>println!</span>(
        <span>"{:?} | dst {} | src {} | typ 0x{:04x}"</span>,
        now, dst, src, ether_type
    );
}
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
404.8053ms | dst 14-0C-76-6A-71-BD | src F4-D1-08-0B-7E-BC | typ 0x0800
404.8525ms | dst F4-D1-08-0B-7E-BC | src 14-0C-76-6A-71-BD | typ 0x0800
1.4515468s | dst 14-0C-76-6A-71-BD | src F4-D1-08-0B-7E-BC | typ 0x0800
1.4515697s | dst F4-D1-08-0B-7E-BC | src 14-0C-76-6A-71-BD | typ 0x0800
2.8507864s | dst 14-0C-76-6A-71-BD | src F4-D1-08-0B-7E-BC | typ 0x0800
2.8508097s | dst F4-D1-08-0B-7E-BC | src 14-0C-76-6A-71-BD | typ 0x0800
3.6322431s | dst 14-0C-76-6A-71-BD | src F4-D1-08-0B-7E-BC | typ 0x0800
3.6322665s | dst F4-D1-08-0B-7E-BC | src 14-0C-76-6A-71-BD | typ 0x0800
</code></pre>
<p>This looks good!</p>
<p>We can immediately see that there's pairs of packets, from <code>F4-D1...</code>
to <code>14-0C...</code>, and back. Probably echo requests and responses!</p>
<p>Do those look legit? Remember that blocks of MAC addresses are assigned
to network hardware vendors, so we can simply look those up in <a href="https://dnschecker.org/mac-lookup.php">an online
database</a>, and we find that:</p>
<ul>
<li><code>F4-D1-08-0B-7E-BC</code> is manufactured by “Intel Corporate”</li>
<li><code>14-0C-76-6A-71-BD</code> is manufactured by “FREEBOX SAS”</li>
</ul>
<p>Which would definitely match my Wi-Fi adapter and my ISP's box.</p>
<h2 id="code-review--debugging-interlude">Code review + debugging interlude</h2>
<p>So we've parsed a little bit of Ethernet.</p>
<p>Should we be happy? Yes!</p>
<p>Should we be content! No!</p>
<p>Our parsing code right now is very imperative, and it's not immediately
obvious what's going on.</p>
<p>Here it is again with annotations:</p>
<pre><code>

<span>let</span> read_u16 = |slice: &amp;[<span>u8</span>]| {
    
    
    <span>let</span> <span>mut</span> res = [<span>0u8</span>; <span>2</span>];
    res.copy_from_slice(&amp;slice[..<span>2</span>]);
    <span>u16</span>::from_be_bytes(res)
};

<span>let</span> dst = ethernet::Addr::new(&amp;packet[<span>0</span>..]);



<span>let</span> src = ethernet::Addr::new(&amp;packet[<span>6</span>..]);


<span>let</span> ether_type = read_u16(&amp;packet[<span>12</span>..]);


</code></pre>
<p>And for that, we're going to want a few crates.</p>
<p>But first, a diversion: <em>does</em> <code>from_be_bytes</code> optimize nicely?</p>
<p>Let's build a sample program:</p>
<pre><code><span>$</span><span> mkdir wat</span>
<span>$</span><span> cargo init</span>
</code></pre>
<pre><code>

<span>#[inline(never)]</span>
<span>pub</span> <span>extern</span> <span>"C"</span> <span><span>fn</span> <span>read_u16</span></span>(slice: &amp;[<span>u8</span>]) -&gt; <span>u16</span> {
    <span>let</span> <span>mut</span> res = [<span>0u8</span>; <span>2</span>];
    res.copy_from_slice(&amp;slice[..<span>2</span>]);
    <span>u16</span>::from_be_bytes(res)
}

<span><span>fn</span> <span>main</span></span>() {
    <span>println!</span>(<span>"{}"</span>, read_u16(&amp;[<span>0x12</span>, <span>0x34</span>]));
    <span>println!</span>(<span>"{}"</span>, read_u16(&amp;[<span>0x56</span>, <span>0x78</span>]));
}
</code></pre>
<p>Let's include debug symbols, because we want a release build here:</p>
<pre><code>
<span>
[profile.release]</span>
<span>debug</span> = <span>true</span>
</code></pre>
<pre><code><span>$</span><span> cargo build --release</span>
   Compiling wat v0.1.0 (C:\msys64\home\amos\ftl\wat)
    Finished release [optimized + debuginfo] target(s) in 0.30s
</code></pre>
<p>We'll use <a href="https://x64dbg.com/">x64dbg</a> to find out. We can just open up the
<code>wat\target\release</code> directory in explorer and drag our <code>.exe</code> into the
x64dbg window.</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-initial.png" alt=""></p>
<p>To find our function, we can use the “Symbols” tab:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-find-symbol.png" alt=""></p>
<p>Double-clicking on the symbol brings us to its disassembly:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-disasm.png" alt=""></p>
<p>Yeah that's uhh pretty short.</p>
<pre><code><span>movzx</span>       <span>eax</span>, <span>word</span> <span>ptr</span> <span>ds</span>:[<span>rcx</span>]
<span>rol</span>         <span>ax</span>, <span>8</span>
<span>ret</span>
</code></pre>
<p>Let's set a breakpoint and start debugging:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-break-and-run.png" alt=""></p>
<p>Here we are at the very start of <code>read_u16</code>:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-before-movzx.png" alt=""></p>
<p>There's only one argument passed to <code>read_u16</code>, and it's a slice.
It appears the address of the slice's contents are passed through
the <code>RCX</code> register, which <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions">seems correct on Microsoft x64</a>.</p>
<pre><code><span>movzx</span>       <span>eax</span>, <span>word</span> <span>ptr</span> <span>ds</span>:[<span>rcx</span>]
</code></pre>
<p>We're reading a word (two bytes, 16 bits) from memory, starting from
the address contained in the <code>RCX</code> register. We're also zero-extending
(that's the <code>zx</code> in <code>movzx</code>), so that the rest of <code>EAX</code> contains zeroes.</p>
<p>Which, after <code>movzx</code>, it does!</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-before-rol.png" alt=""></p>
<p>All that's left is to rotate the <code>AX</code> register (16-bit wide) left 8 bits and…</p>
<pre><code><span>rol</span>         <span>ax</span>, <span>8</span>
</code></pre>
<p>wait.. just rotate left? Does it wrap around?</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-before-ret.png" alt=""></p>
<p>Yeah! Apparently it does.</p>
<p>We now have the u16 we want in <code>RAX</code>, and, what a coincidence, that's also
the register used to return integers in the Microsoft x64 calling convention.</p>
<p>So, to answer our question, <strong>yes</strong>, <code>u16::from_be_bytes</code> (and even <code>copy_from_slice</code>)
optimize <em>really well</em>.</p>
<h2 id="back-to-our-regularly-scheduled-parsing">Back to our regularly-scheduled parsing</h2>
<p>Before we took a detour through x64dbg-land, I said I wanted our parsing to be more
declarative.</p>
<p>First off, I want an <code>ethernet::Frame</code> structure.</p>
<pre><code>

<span>use</span> custom_debug_derive::*;

<span>#[derive(CustomDebug)]</span>
<span>pub</span> <span><span>struct</span> <span>Frame</span></span> {
    <span>pub</span> dst: Addr,
    <span>pub</span> src: Addr,

    <span>#[debug(format = <span>"0x{:04x}"</span>)]</span>
    <span>pub</span> ether_type: <span>u16</span>,
}
</code></pre>
<p>Second, I want it to have a <code>parse</code> method:</p>
<pre><code>

<span>impl</span> Frame {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: &amp;[<span>u8</span>]) -&gt; <span>Self</span> {
        <span>let</span> read_u16 = |slice: &amp;[<span>u8</span>]| {
            <span>let</span> <span>mut</span> res = [<span>0u8</span>; <span>2</span>];
            res.copy_from_slice(&amp;slice[..<span>2</span>]);
            <span>u16</span>::from_be_bytes(res)
        };

        <span>Self</span> {
            dst: Addr::new(&amp;i[<span>0</span>..]),
            src: Addr::new(&amp;i[<span>6</span>..]),
            ether_type: read_u16(&amp;i[<span>12</span>..]),
        }
    }
}
</code></pre>
<p>Our <code>process_packet</code> function now becomes:</p>
<pre><code>

<span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    <span>let</span> frame = ethernet::Frame::parse(packet);
    <span>println!</span>(<span>"{:?} | {:?}"</span>, now, frame);
}
</code></pre>
<p>Does it still work? Why wouldn't it!</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
1.0004896s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
1.0005298s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
2.0009547s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
2.0009996s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
</code></pre>
<p>But still our code is very imperative.</p>
<p>We're going to use one of my all-time favorite crates: <a href="https://crates.io/crates/nom">nom</a>.</p>
<div>
    
<p>The <code>nom</code> crate has changed a lot over the course of its life.</p>
<p>We'll be using version 5, which I hear is significantly better than the
previous releases.</p>
<p>In particular, nom 5 is based on <code>impl Fn</code> rather than macros, making the
code easier to read and write, and even giving a performance boost!</p>
</div>
<pre><code>$ cargo add nom
      Adding nom v5.<span>0.1</span> to dependencies
</code></pre>
<p><code>nom</code> is a <em>parser combinators</em> library, which means we'll get to.. combine..
parsers.</p>
<p>A parser is just a function that takes an input, and returns a result.</p>
<p>If we look for <code>be_u16</code> in nom's documentation we'll find two variants:
one in <code>nom::number::complete</code> and one in <code>nom::number::streaming</code>. We're
only interested in the former, as we have complete Ethernet frames available.</p>
<p>Its signature is as follows:</p>
<pre><code><span>pub</span> <span><span>fn</span> <span>be_u16</span></span>&lt;<span>'a</span>, E: ParseError&lt;&amp;<span>'a</span>[<span>u8</span>]&gt;&gt;(i: &amp;<span>'a</span>[<span>u8</span>]) -&gt; IResult&lt;&amp;<span>'a</span>[<span>u8</span>], <span>u16</span>, E&gt; {
    
}
</code></pre>
<p>We immediately notice <code>IResult</code>, which is a <code>nom</code> type. Why not just use <code>Result</code> ?</p>
<p>Because parsers consume part of the input. So in case of success, they'd
typically return a tuple: <code>(remaining_input, parsed)</code>.</p>
<p>Can we use it to replace our <code>read_u16</code> ? Let's see.</p>
<pre><code><span>use</span> nom::number::complete::be_u16;

<span>impl</span> Frame {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: &amp;[<span>u8</span>]) -&gt; <span>Self</span> {
        <span>let</span> (_, ether_type) = be_u16::&lt;()&gt;(&amp;i[<span>12</span>..]).unwrap();

        <span>Self</span> {
            dst: Addr::new(&amp;i[<span>0</span>..]),
            src: Addr::new(&amp;i[<span>6</span>..]),
            ether_type,
        }
    }
}
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
999.8623ms | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
999.8913ms | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
2.000622s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
2.0006446s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
3.0006469s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
3.0006706s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
</code></pre>
<p>Yeah! Seems to work!</p>
<p>Although we've been very naughty:</p>
<ul>
<li>We've completely ignored errors (by specifying <code>E=()</code>, and using <code>.unwrap()</code>)</li>
<li>We're.. not actually combining parsers</li>
</ul>
<p>If we want to combine parsers, we'll need to make a parser for <code>Addr</code>.</p>
<p>We can do that as an associated method:</p>
<pre><code>

<span>use</span> nom::{bytes::complete::take, combinator::map, error::ParseError, IResult};

<span>impl</span> Addr {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>&lt;<span>'a</span>, E&gt;(i: &amp;<span>'a</span> [<span>u8</span>]) -&gt; IResult&lt;&amp;<span>'a</span> [<span>u8</span>], <span>Self</span>, E&gt;
    <span>where</span>
        E: ParseError&lt;&amp;<span>'a</span> [<span>u8</span>]&gt;,
    {
        map(take(<span>6_usize</span>), Self::new)(i)
    }
}
</code></pre>
<p>Whoa, that's a lot of use directives. Get used to those!</p>
<p>Let's walk through these:</p>
<ul>
<li><code>Addr::parse</code> is a parser - it takes an input and returns an <code>IResult&lt;I, O, E&gt;</code></li>
<li><code>take(N)</code> returns a parser - that takes 6 bytes and returns them as a slice</li>
<li><code>map(P, F)</code> runs the parser <code>P</code> and, if successful, runs its output through <code>F</code> before returning
<ul>
<li>In our case, we transform a <code>&amp;[u8]</code> into an <code>ethernet::Addr</code></li>
</ul>
</li>
</ul>
<p>Here's another way to write the same thing:</p>
<pre><code>

<span>use</span> nom::{combinator::map, error::ParseError, number::complete::be_u8, sequence::tuple, IResult};




<span>impl</span> Addr {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>&lt;<span>'a</span>, E&gt;(i: &amp;<span>'a</span> [<span>u8</span>]) -&gt; IResult&lt;&amp;<span>'a</span> [<span>u8</span>], <span>Self</span>, E&gt;
    <span>where</span>
        E: ParseError&lt;&amp;<span>'a</span> [<span>u8</span>]&gt;,
    {
        

        map(
            tuple((be_u8, be_u8, be_u8, be_u8, be_u8, be_u8)),
            |(a, b, c, d, e, f)| <span>Self</span>([a, b, c, d, e, f]),
        )(i)
    }
}
</code></pre>
<p>…but I like the first version better.</p>
<p>How do we use our new parser?</p>
<p>Well, we can keep being naughty:</p>
<pre><code><span>impl</span> Frame {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: &amp;[<span>u8</span>]) -&gt; <span>Self</span> {
        <span>let</span> (_, dst) = Addr::parse::&lt;()&gt;(&amp;i[<span>0</span>..]).unwrap();
        <span>let</span> (_, src) = Addr::parse::&lt;()&gt;(&amp;i[<span>6</span>..]).unwrap();
        <span>let</span> (_, ether_type) = be_u16::&lt;()&gt;(&amp;i[<span>12</span>..]).unwrap();

        <span>Self</span> {
            dst,
            src,
            ether_type,
        }
    }
}
</code></pre>
<p>This sure still works:</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
999.5699ms | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
999.5999ms | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
1.9995319s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
1.9995561s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
2.3363625s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: 0x0800 }
2.3364035s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: 0x0800 }
</code></pre>
<p>…but, again, this completely defeats the purpose of <code>nom</code>. What we want is
to <em>combine</em> those, like that:</p>
<pre><code><span>use</span> nom::{number::complete::be_u16, sequence::tuple};

<span>impl</span> Frame {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>&lt;<span>'a</span>, E&gt;(i: &amp;<span>'a</span> [<span>u8</span>]) -&gt; IResult&lt;&amp;<span>'a</span> [<span>u8</span>], <span>Self</span>, E&gt;
    <span>where</span>
        E: ParseError&lt;&amp;<span>'a</span> [<span>u8</span>]&gt;,
    {
        map(
            tuple((Addr::parse, Addr::parse, be_u16)),
            |(dst, src, ether_type)| <span>Self</span> {
                dst,
                src,
                ether_type,
            },
        )(i)
    }
}
</code></pre>
<p>Nowwww we're getting somewhere.</p>
<p>But I'm getting tired of typing those <code>'a</code> and <code>where E: ParseError</code> by hand.</p>
<p>How about we make a <code>parse</code> module that has some types for us.</p>
<pre><code>

<span>mod</span> parse;
</code></pre>
<pre><code>

<span>pub</span> <span><span>type</span> <span>Input</span></span>&lt;<span>'a</span>&gt; = &amp;<span>'a</span> [<span>u8</span>];
<span>pub</span> <span><span>type</span> <span>Result</span></span>&lt;<span>'a</span>, T&gt; = nom::IResult&lt;Input&lt;<span>'a</span>&gt;, T, ()&gt;;
</code></pre>
<pre><code>

<span>impl</span> Addr {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        map(take(<span>6_usize</span>), Self::new)(i)
    }
}

<span>impl</span> Frame {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        map(
            tuple((Addr::parse, Addr::parse, be_u16)),
            |(dst, src, ether_type)| <span>Self</span> {
                dst,
                src,
                ether_type,
            },
        )(i)
    }
}
</code></pre>
<p>Ahhh. Much better.</p>
<p>Of course, we need to change our <code>process_packet</code> function a bit, to account
for error handling:</p>
<pre><code><span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    <span>match</span> ethernet::Frame::parse(packet) {
        <span>Ok</span>((_remaining, frame)) =&gt; {
            <span>println!</span>(<span>"{:?} | {:?}"</span>, now, frame);
        }
        <span>Err</span>(e) =&gt; {
            <span>println!</span>(<span>"{:?} | could not parse ethernet frame: {:?}"</span>, now, e);
        }
    }
}
</code></pre>
<p>And our sample program - still doing the same thing - works again.</p>
<p>But speaking of errors, what happens if we call <code>ethernet::Frame::parse</code> with
invalid input? Say, an incomplete frame?</p>
<pre><code><span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    <span>let</span> incomplete_packet = &amp;packet[..<span>2</span>];

    <span>match</span> ethernet::Frame::parse(incomplete_packet) {
        
    }
}
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
999.9702ms | could not parse ethernet frame: Error(())
999.9991ms | could not parse ethernet frame: Error(())
2.0000975s | could not parse ethernet frame: Error(())
2.0001199s | could not parse ethernet frame: Error(())
</code></pre>
<p>Oh right. We chose the empty tuple, <code>()</code>, as our error type.</p>
<p>Let's fix that.</p>
<pre><code>

<span>use</span> nom::error::ErrorKind <span>as</span> NomErrorKind;

<span>pub</span> <span><span>type</span> <span>Input</span></span>&lt;<span>'a</span>&gt; = &amp;<span>'a</span> [<span>u8</span>];
<span>pub</span> <span><span>type</span> <span>Result</span></span>&lt;<span>'a</span>, T&gt; = nom::IResult&lt;Input&lt;<span>'a</span>&gt;, T, (Input&lt;<span>'a</span>&gt;, NomErrorKind)&gt;;
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
644.1433ms | could not parse ethernet frame: Error(([20, 12], Eof))
644.1723ms | could not parse ethernet frame: Error(([244, 209], Eof))
1.6446712s | could not parse ethernet frame: Error(([20, 12], Eof))
1.6446948s | could not parse ethernet frame: Error(([244, 209], Eof))
</code></pre>
<p>It's something! <code>nom::error::ParseError</code> is implemented for <code>(I, nom::error::ErrorKind)</code>.</p>
<p>What if we want something a little more.. custom?</p>
<pre><code>

<span>use</span> nom::error::ErrorKind <span>as</span> NomErrorKind;

<span>pub</span> <span><span>type</span> <span>Input</span></span>&lt;<span>'a</span>&gt; = &amp;<span>'a</span> [<span>u8</span>];
<span>pub</span> <span><span>type</span> <span>Result</span></span>&lt;<span>'a</span>, T&gt; = nom::IResult&lt;Input&lt;<span>'a</span>&gt;, T, Error&lt;Input&lt;<span>'a</span>&gt;&gt;&gt;;

<span>#[derive(Debug)]</span>
<span>pub</span> <span><span>struct</span> <span>Error</span></span>&lt;I&gt; {
    <span>pub</span> errors: <span>Vec</span>&lt;(I, NomErrorKind)&gt;,
}
</code></pre>
<pre><code><span>$</span><span> cargo check --quiet</span>
error[E0277]: the trait bound `parse::Error&lt;&amp;[u8]&gt;: nom::error::ParseError&lt;&amp;[u8]&gt;` is not satisfied
<span>  --&gt;</span><span> src\ethernet.rs:37:9</span>
   |
37 |         map(take(6_usize), Self::new)(i)
   |         ^^^ the trait `nom::error::ParseError&lt;&amp;[u8]&gt;` is not implemented for `parse::Error&lt;&amp;[u8]&gt;`
   |
   = note: required by `nom::combinator::map`

(many more errors omitted)
</code></pre>
<p>Oh right, we need to actually implement that trait.</p>
<p>I wouldn't put you - the reader - through all of that if it wasn't going
to come in handy later. In the meantime, just consider it a leisurely walk
through some of nom's internals.</p>
<pre><code>

<span>use</span> nom::error::{ErrorKind <span>as</span> NomErrorKind, ParseError <span>as</span> NomParseError};

<span>pub</span> <span><span>type</span> <span>Input</span></span>&lt;<span>'a</span>&gt; = &amp;<span>'a</span> [<span>u8</span>];
<span>pub</span> <span><span>type</span> <span>Result</span></span>&lt;<span>'a</span>, T&gt; = nom::IResult&lt;Input&lt;<span>'a</span>&gt;, T, Error&lt;Input&lt;<span>'a</span>&gt;&gt;&gt;;

<span>#[derive(Debug)]</span>
<span>pub</span> <span><span>struct</span> <span>Error</span></span>&lt;I&gt; {
    <span>pub</span> errors: <span>Vec</span>&lt;(I, NomErrorKind)&gt;,
}

<span>impl</span>&lt;I&gt; NomParseError&lt;I&gt; <span>for</span> Error&lt;I&gt; {
    <span><span>fn</span> <span>from_error_kind</span></span>(input: I, kind: NomErrorKind) -&gt; <span>Self</span> {
        <span>let</span> errors = <span>vec!</span>[(input, kind)];
        <span>Self</span> { errors }
    }

    <span><span>fn</span> <span>append</span></span>(input: I, kind: NomErrorKind, <span>mut</span> other: <span>Self</span>) -&gt; <span>Self</span> {
        other.errors.push((input, kind));
        other
    }
}
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
999.5487ms | could not parse ethernet frame: Error(Error { errors: [([20, 12], Eof)] })
999.5803ms | could not parse ethernet frame: Error(Error { errors: [([244, 209], Eof)] })
2.0000408s | could not parse ethernet frame: Error(Error { errors: [([20, 12], Eof)] })
2.0001096s | could not parse ethernet frame: Error(Error { errors: [([244, 209], Eof)] })
</code></pre>
<p>Cool!</p>
<p>You may have noticed our <code>parse::Error</code> type actually holds a <code>Vec</code> of errors.</p>
<p>Why is this important? So we can have multiple errors of course.</p>
<p>The <code>context</code> combinator allows us to add some, well, context, to our errors.
In other words it allows us to attach to our errors information about what it is
we were trying to parse.</p>
<p>Let's use it now:</p>
<pre><code>

<span>use</span> nom::{
    bytes::complete::take, combinator::map, error::context, number::complete::be_u16,
    sequence::tuple,
};

<span>impl</span> Addr {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        context(<span>"MAC address"</span>, map(take(<span>6_usize</span>), Self::new))(i)
    }
}

<span>impl</span> Frame {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        context(
            <span>"Ethernet frame"</span>,
            map(
                tuple((Addr::parse, Addr::parse, context(<span>"EtherType"</span>, be_u16))),
                |(dst, src, ether_type)| <span>Self</span> {
                    dst,
                    src,
                    ether_type,
                },
            ),
        )(i)
    }
}
</code></pre>
<p>Huh, this doesn't change the output at all. Let's look at the implementation
of the <code>context</code> combinator:</p>
<pre><code>


<span>#[cfg(feature = <span>"alloc"</span>)]</span>
<span>pub</span> <span><span>fn</span> <span>context</span></span>&lt;I: <span>Clone</span>, E: ParseError&lt;I&gt;, F, O&gt;(context: &amp;<span>'static</span> <span>str</span>, f: F) -&gt; <span>impl</span> <span>Fn</span>(I) -&gt; IResult&lt;I, O, E&gt;
<span>where</span>
    F: <span>Fn</span>(I) -&gt; IResult&lt;I, O, E&gt; {

    <span>move</span> |i: I| {
        <span>match</span> f(i.clone()) {
            <span>Ok</span>(o) =&gt; <span>Ok</span>(o),
            <span>Err</span>(Err::Incomplete(i)) =&gt; <span>Err</span>(Err::Incomplete(i)),
            <span>Err</span>(Err::Error(e)) =&gt; <span>Err</span>(Err::Error(E::add_context(i, context, e))),
            <span>Err</span>(Err::Failure(e)) =&gt; <span>Err</span>(Err::Failure(E::add_context(i, context, e))),
        }
    }
}
</code></pre>
<p>Okay.. looks like it calls <code>add_context</code> on our <code>Error</code> type. I don't remember
implementing that, do you? Maybe there's a default implementation in the <code>ParseError</code>
trait..</p>
<pre><code><span>pub</span> <span><span>trait</span> <span>ParseError</span></span>&lt;I&gt;: <span>Sized</span> {
    

    
    
    
    <span><span>fn</span> <span>add_context</span></span>(_input: I, _ctx: &amp;<span>'static</span> <span>str</span>, other: <span>Self</span>) -&gt; <span>Self</span> {
        other
    }
}
</code></pre>
<p>Oh. It's just throwing the context away.</p>
<p>We're going to need an enum. <code>NomErrorKind</code> is already an enum, but none of the variants
take a string, they're just simple cases like so:</p>
<pre><code><span>pub</span> <span><span>enum</span> <span>ErrorKind</span></span> {
  Tag,
  MapRes,
  MapOpt,
  Alt,
  IsNot,
  
}
</code></pre>
<p>So let's make our <em>own</em> ErrorKind:</p>
<pre><code><span>#[derive(Debug)]</span>
<span>pub</span> <span><span>enum</span> <span>ErrorKind</span></span> {
    
    Nom(NomErrorKind),
    Context(&amp;<span>'static</span> <span>str</span>),
}

<span>#[derive(Debug)]</span>
<span>pub</span> <span><span>struct</span> <span>Error</span></span>&lt;I&gt; {
    
    <span>pub</span> errors: <span>Vec</span>&lt;(I, ErrorKind)&gt;,
}

<span>impl</span>&lt;I&gt; NomParseError&lt;I&gt; <span>for</span> Error&lt;I&gt; {
    <span><span>fn</span> <span>from_error_kind</span></span>(input: I, kind: NomErrorKind) -&gt; <span>Self</span> {
        
        <span>let</span> errors = <span>vec!</span>[(input, ErrorKind::Nom(kind))];
        <span>Self</span> { errors }
    }

    <span><span>fn</span> <span>append</span></span>(input: I, kind: NomErrorKind, <span>mut</span> other: <span>Self</span>) -&gt; <span>Self</span> {
        
        other.errors.push((input, ErrorKind::Nom(kind)));
        other
    }

    
    <span><span>fn</span> <span>add_context</span></span>(input: I, ctx: &amp;<span>'static</span> <span>str</span>, <span>mut</span> other: <span>Self</span>) -&gt; <span>Self</span> {
        other.errors.push((input, ErrorKind::Context(ctx)));
        other
    }
}
</code></pre>
<p>Now we can see <em>exactly</em> where parsing failed:</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
1.0001186s | Error(Error { errors: [([20, 12], Nom(Eof)), ([20, 12], Context("MAC address")), ([20, 12], Context("Ethernet frame"))] })
1.0001786s | Error(Error { errors: [([244, 209], Nom(Eof)), ([244, 209], Context("MAC address")), ([244, 209], Context("Ethernet frame"))] })
2.0002709s | Error(Error { errors: [([20, 12], Nom(Eof)), ([20, 12], Context("MAC address")), ([20, 12], Context("Ethernet frame"))] })
2.0003059s | Error(Error { errors: [([244, 209], Nom(Eof)), ([244, 209], Context("MAC address")), ([244, 209], Context("Ethernet frame"))] })
</code></pre>
<p>Although.. I'm not in love with that error format.</p>
<p>How about we prettify it a little bit?</p>
<pre><code><span>$</span><span> cargo add hex_slice</span>
WARN: Added `hex-slice` instead of `hex_slice`
      Adding hex-slice v0.1.4 to dependencies
<span>
$</span><span> <span>echo</span> <span>"thanks cargo-edit, I promise not to typo it again"</span></span>
</code></pre>
<pre><code>

<span>use</span> std::fmt;

<span>impl</span>&lt;<span>'a</span>&gt; fmt::<span>Debug</span> <span>for</span> Error&lt;&amp;<span>'a</span> [<span>u8</span>]&gt; {
    <span><span>fn</span> <span>fmt</span></span>(&amp;<span>self</span>, f: &amp;<span>mut</span> fmt::Formatter) -&gt; fmt::<span>Result</span> {
        <span>write!</span>(f, <span>"/!\\ ersatz parsing error\n"</span>)?;
        <span>for</span> (input, kind) <span>in</span> <span>self</span>.errors.iter().rev() {
            <span>let</span> prefix = <span>match</span> kind {
                ErrorKind::Context(ctx) =&gt; <span>format!</span>(<span>"...in {}"</span>, ctx),
                ErrorKind::Nom(err) =&gt; <span>format!</span>(<span>"nom error {:?}"</span>, err),
            };

            <span>let</span> maxlen = <span>40</span>;
            <span>let</span> input = <span>if</span> input.len() &gt; maxlen {
                &amp;input[input.len() - maxlen..]
            } <span>else</span> {
                input
            };

            <span>use</span> hex_slice::AsHex;
            <span>write!</span>(f, <span>"{:&lt;30} {:x}\n"</span>, prefix, input.as_hex())?;
        }
        <span>Ok</span>(())
    }
}
</code></pre>
<p>We're also going to adjust our <code>process_packet()</code> function a bit - by
matching the error more precisely.</p>
<p>As long as we never use the <code>cut</code> combinator, and never use any streaming
parsers, we should only ever get <code>nom::Err::Error</code>, never <code>nom::Err::Failure</code>
(from <code>cut</code>) or <code>nom::Err::Incomplete</code> (from streaming parsers).</p>
<p>This will make the output even cleaner:</p>
<pre><code><span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    <span>let</span> incomplete_packet = &amp;packet[..<span>2</span>];

    <span>match</span> ethernet::Frame::parse(incomplete_packet) {
        <span>Ok</span>((_remaining, frame)) =&gt; {
            <span>println!</span>(<span>"{:?} | {:?}"</span>, now, frame);
        }
        <span>Err</span>(nom::Err::Error(e)) =&gt; {
            <span>println!</span>(<span>"{:?} | {:?}"</span>, now, e);
        }
        
        _ =&gt; <span>unreachable!</span>(),
    }
}
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
303.8231ms | /!\ ersatz parsing error
...in Ethernet frame           [14 c]
...in MAC address              [14 c]
nom error Eof                  [14 c]

303.8853ms | /!\ ersatz parsing error
...in Ethernet frame           [f4 d1]
...in MAC address              [f4 d1]
nom error Eof                  [f4 d1]

1.3050234s | /!\ ersatz parsing error
...in Ethernet frame           [14 c]
...in MAC address              [14 c]
nom error Eof                  [14 c]

1.3050716s | /!\ ersatz parsing error
...in Ethernet frame           [f4 d1]
...in MAC address              [f4 d1]
nom error Eof                  [f4 d1]
</code></pre>
<p>That already looks a lot better. I wonder if it's useful to
print the input for every line though. What if we give a slightly
longer truncated Ethernet frame, so that it fails in, say, the middle
of reading the EtherType?</p>
<pre><code>

<span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    
    <span>let</span> incomplete_packet = &amp;packet[..<span>13</span>];

    
}
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
1.0010714s | /!\ ersatz parsing error
...in Ethernet frame           [f4 d1 8 b 7e bc 14 c 76 6a 71 bd 8]
...in EtherType                [8]
nom error Eof                  [8]

1.0011471s | /!\ ersatz parsing error
...in Ethernet frame           [14 c 76 6a 71 bd f4 d1 8 b 7e bc 8]
...in EtherType                [8]
nom error Eof                  [8]
</code></pre>
<p>Yeah! It is useful!</p>
<p>Although.. I'm not fond of the way <code>hex-slice</code> shows hex values. I'd like them
to be two-character wide no matter what.</p>
<p>Also, <code>[8]</code> is not extremely useful as far as context goes. Is it the first 8?
Or the second one?</p>
<pre><code>...in Ethernet frame           [f4 d1 8 b 7e bc 14 c 76 6a 71 bd 8]
                                      ^                          ^
                                   this one ?              or this one ?
</code></pre>
<pre><code><span>$</span><span> cargo rm hex-slice</span>
    Removing hex-slice from dependencies
</code></pre>
<p>We can do better than this.</p>
<pre><code><span>use</span> std::fmt;

<span>impl</span>&lt;<span>'a</span>&gt; fmt::<span>Debug</span> <span>for</span> Error&lt;&amp;<span>'a</span> [<span>u8</span>]&gt; {
    <span><span>fn</span> <span>fmt</span></span>(&amp;<span>self</span>, f: &amp;<span>mut</span> fmt::Formatter) -&gt; fmt::<span>Result</span> {
        <span>write!</span>(f, <span>"/!\\ ersatz parsing error\n"</span>)?;

        <span>let</span> <span>mut</span> shown_input = <span>None</span>;
        <span>let</span> margin_left = <span>4</span>;
        <span>let</span> margin_str = <span>" "</span>.repeat(margin_left);

        
        <span>let</span> maxlen = <span>60</span>;

        
        
        
        <span>let</span> print_slice =
            |f: &amp;<span>mut</span> fmt::Formatter, s: &amp;[<span>u8</span>], offset: <span>usize</span>, len: <span>usize</span>| -&gt; fmt::<span>Result</span> {
                
                <span>let</span> (s, offset, len) = {
                    
                    

                    <span>let</span> avail_after = s.len() - offset;
                    <span>let</span> after = std::cmp::min(avail_after, maxlen / <span>2</span>);

                    <span>let</span> avail_before = offset;
                    <span>let</span> before = std::cmp::min(avail_before, maxlen / <span>2</span>);

                    <span>let</span> new_start = offset - before;
                    <span>let</span> new_end = offset + after;
                    <span>let</span> new_offset = before;
                    <span>let</span> new_len = std::cmp::min(new_end - new_start, len);

                    (&amp;s[new_start..new_end], new_offset, new_len)
                };

                <span>write!</span>(f, <span>"{}"</span>, margin_str)?;
                <span>for</span> b <span>in</span> s {
                    <span>write!</span>(f, <span>"{:02X} "</span>, b)?;
                }
                <span>write!</span>(f, <span>"\n"</span>)?;

                <span>write!</span>(f, <span>"{}"</span>, margin_str)?;
                <span>for</span> i <span>in</span> <span>0</span>..s.len() {
                    
                    <span>if</span> i == offset + len - <span>1</span> {
                        
                        <span>write!</span>(f, <span>"~~"</span>)?;
                    } <span>else</span> <span>if</span> (offset..offset + len).contains(&amp;i) {
                        <span>write!</span>(f, <span>"~~~"</span>)?;
                    } <span>else</span> {
                        <span>write!</span>(f, <span>"   "</span>)?;
                    };
                }
                <span>write!</span>(f, <span>"\n"</span>)?;

                <span>Ok</span>(())
            };

        <span>for</span> (input, kind) <span>in</span> <span>self</span>.errors.iter().rev() {
            <span>let</span> prefix = <span>match</span> kind {
                ErrorKind::Context(ctx) =&gt; <span>format!</span>(<span>"...in {}"</span>, ctx),
                ErrorKind::Nom(err) =&gt; <span>format!</span>(<span>"nom error {:?}"</span>, err),
            };

            <span>write!</span>(f, <span>"{}\n"</span>, prefix)?;
            <span>match</span> shown_input {
                <span>None</span> =&gt; {
                    shown_input.replace(input);
                    print_slice(f, input, <span>0</span>, input.len())?;
                }
                <span>Some</span>(parent_input) =&gt; {
                    
                    
                    
                    <span>use</span> nom::Offset;
                    <span>let</span> offset = parent_input.offset(input);
                    print_slice(f, parent_input, offset, input.len())?;
                }
            };
        }
        <span>Ok</span>(())
    }
}
</code></pre>
<p>Here's the diagram I drew to help me write this code:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/highlight-math.png" alt=""></p>
<p>I'm fairly happy with the result:</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
1.0008906s | /!\ ersatz parsing error
...in Ethernet frame
    14 0C 76 6A 71 BD F4 D1 08 0B 7E BC 08
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
...in EtherType
    14 0C 76 6A 71 BD F4 D1 08 0B 7E BC 08
                                        ~~
nom error Eof
    14 0C 76 6A 71 BD F4 D1 08 0B 7E BC 08
                                        ~~
</code></pre>
<h2 id="real-world-errors">Real-world errors</h2>
<p>We've only seen synthetic errors for now, so how about a real one?</p>
<p>There's only a handful of <code>EtherType</code> values we care about, so let's make
it an enum:</p>
<pre><code><span>$</span><span> cargo add derive-try-from-primitive</span>
      Adding derive-try-from-primitive v0.1.0 to dependencies
</code></pre>
<pre><code>

<span>use</span> derive_try_from_primitive::*;

<span>#[derive(Debug, TryFromPrimitive)]</span>
<span>#[repr(u16)]</span>
<span>pub</span> <span><span>enum</span> <span>EtherType</span></span> {
    IPv4 = <span>0x0800</span>,
}
</code></pre>
<p>Make a parser for it:</p>
<pre><code><span>impl</span> EtherType {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        context(
            <span>"EtherType"</span>,
            map(be_u16, |x| EtherType::try_from(x).unwrap()),
        )(i)
    }
}
</code></pre>
<p>Use it in <code>Frame</code>:</p>
<pre><code><span>#[derive(Debug)]</span>
<span>pub</span> <span><span>struct</span> <span>Frame</span></span> {
    <span>pub</span> dst: Addr,
    <span>pub</span> src: Addr,
    <span>pub</span> ether_type: EtherType,
}
</code></pre>
<p>Use it in <code>Frame</code>'s parser:</p>
<pre><code><span>impl</span> Frame {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        context(
            <span>"Ethernet frame"</span>,
            map(
                tuple((Addr::parse, Addr::parse, EtherType::parse)),
                |(dst, src, ether_type)| <span>Self</span> {
                    dst,
                    src,
                    ether_type,
                },
            ),
        )(i)
    }
}
</code></pre>
<p>And take it for a spin:</p>
<pre><code>
<span><span>fn</span> <span>process_packet</span></span>(now: Duration, packet: &amp;BorrowedPacket) {
    
    <span>match</span> ethernet::Frame::parse(packet) {

    
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
999.8431ms | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: IPv4 }
999.889ms | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: IPv4 }
1.7093166s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: IPv4 }
1.7093598s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: IPv4 }
2.7247371s | Frame { dst: 14-0C-76-6A-71-BD, src: F4-D1-08-0B-7E-BC, ether_type: IPv4 }
2.7247634s | Frame { dst: F4-D1-08-0B-7E-BC, src: 14-0C-76-6A-71-BD, ether_type: IPv4 }
</code></pre>
<p>So far so good.</p>
<p>Remember that we're still pinging <code>8.8.8.8</code> in the background.</p>
<p>What happens if we start pinging <code>google.com</code> instead? A the moment, it
resolves to <code>[2a00:1450:4007:817::200e]</code> for me and that.. doesn't look like
IPv4.</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src\libcore\option.rs:378:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Well. Something certainly happened. But it brought down our entire packet sniffer with it.</p>
<p>Which isn't great.</p>
<p>What happened?</p>
<p>Well, we've used the
<a href="https://crates.io/crates/derive-try-from-primitive">derive-try-from-primitive</a>
crate to get <code>EtherType::try_from</code>.</p>
<p>It performs mappings from <code>u16</code> values to <code>EtherType</code> variants:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/value-mapping.png" alt=""></p>
<p>..and then we call <code>.unwrap()</code> on it:</p>
<pre><code><span>impl</span> EtherType {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        context(
            <span>"EtherType"</span>,
            map(be_u16, |x| EtherType::try_from(x).unwrap()),
        )(i)
    }
}
</code></pre>
<p>…which panics on <code>None</code>. So everything is expected. I just kind of glossed it
over so we had an opportunity to fix it later.</p>
<p>How <em>do</em> we fix it though?</p>
<p>We can add.. a custom error type!</p>
<pre><code>

<span>#[derive(Debug)]</span>
<span>pub</span> <span><span>enum</span> <span>ErrorKind</span></span> {
    Nom(NomErrorKind),
    Context(&amp;<span>'static</span> <span>str</span>),
    
    Custom(<span>String</span>),
}


<span>impl</span>&lt;I&gt; Error&lt;I&gt; {
    <span>pub</span> <span><span>fn</span> <span>custom</span></span>(input: I, msg: <span>String</span>) -&gt; <span>Self</span> {
        <span>Self</span> {
            errors: <span>vec!</span>[(input, ErrorKind::Custom(msg))],
        }
    }
}


</code></pre>
<p>Then, instead of having <code>EtherType::parse</code> be a pure parser combinator, we
can “stop” after calling <code>be_u16</code> (if it succeeded), and check that it's a
unknown EtherType value.</p>
<pre><code><span>impl</span> EtherType {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        <span>let</span> original_i = i;
        <span>let</span> (i, x) = context(<span>"EtherType"</span>, be_u16)(i)?;
        

        <span>match</span> EtherType::try_from(x) {
            <span>Some</span>(typ) =&gt; <span>Ok</span>((i, typ)),
            <span>None</span> =&gt; {
                <span>let</span> msg = <span>format!</span>(<span>"unknown EtherType 0x{:04X}"</span>, x);
                
                <span>use</span> nom::Offset;
                <span>let</span> err_slice = &amp;original_i[..original_i.offset(i)];

                <span>Err</span>(nom::Err::Error(parse::Error::custom(err_slice, msg)))
            }
        }
    }
}
</code></pre>
<p>The result is <em>very</em> readable:</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
Listening for packets...
1.0000231s | /!\ ersatz parsing error
...in Ethernet frame
    14 0C 76 6A 71 BD F4 D1 08 0B 7E BC 86 DD 60 00 00 00 00 28
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
unknown EtherType 0x86dd
    14 0C 76 6A 71 BD F4 D1 08 0B 7E BC 86 DD 60 00 00 00 00 28 3A 80 2A 01 0E 35 2F D6 8F 60 E4 5F
                                        ~~~~~

1.0001009s | /!\ ersatz parsing error
...in Ethernet frame
    F4 D1 08 0B 7E BC 14 0C 76 6A 71 BD 86 DD 60 00 00 00 00 28
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
unknown EtherType 0x86dd
    F4 D1 08 0B 7E BC 14 0C 76 6A 71 BD 86 DD 60 00 00 00 00 28 3A 39 2A 00 14 50 40 07 08 17 00 00
                                        ~~~~~
</code></pre>
<div>
    
<p><a href="https://crates.io/crates/nom">nom</a> is a powerful parsing library, that can be used both for
text formats and binary formats.</p>
<p>With a few <code>impl</code> blocks here and there, it can easily support custom error handling.</p>
<p>Its “parser combinator” approach makes for code that's both readable <em>and</em> fast.</p>
</div>
<p>Wait, wait, cool bear, hold on, wait.</p>
<p>We haven't checked what kind of instructions our code actually generates.</p>
<p>Time to make a release build and start up x64dbg.</p>
<pre><code>$ cargo build 
   Compiling proc-macro2 v0.4.30
   Compiling semver-parser v0.7.0
   (cut: many more lines)
   Compiling ersatz v0.1.0 (C:\msys64\home\amos\ftl\ersatz)
    Finished <span>release</span> [optimized] target(s) <span>in</span> <span>29.91</span>s

$ butler sizeof ./target/<span>release</span>/ersatz.exe
Total <span>size</span> <span>of</span> ./target/<span>release</span>/ersatz.exe: <span>352.00</span> KiB
</code></pre>
<p>Honestly? 352 KiB isn't that bad.</p>
<p>Let's hope we can find our way through the executable…</p>
<p>I was able to find the symbol
<code>_ZN6ersatz8ethernet5Frame5parse17h813008bcdcb13adbE</code>, which looks promising.
I was not able to find any trace of <code>EtherType::parse</code> - I'm assuming it has
been inlined.</p>
<p>I analyzed the function and visualized it as a graph. The graph unfortunately
doesn't fit in a single screenshot. Although, the overview view does:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-frame-parse.png" alt=""></p>
<p>We can see that it calls <code>ersatz.sub_...</code> twice (although it checks the return
value first):</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-call-sub.png" alt=""></p>
<p>If everything goes well, it keeps on trucking:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-interlude.png" alt=""></p>
<p>And then… ooooh would you look at that - looks a lot like our <code>read_u16</code> from before!</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-rol.png" alt=""></p>
<p>Here's another interesting bit - our fancy Rust <code>enum</code>? Disappeared:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-ipv4-ethertype.png" alt=""></p>
<p>Alright, it seems that cool bear was right after all, this looks good.</p>
<p>Something is bothering me, though. If we look at <code>ersatz.sub_...</code>'s code:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-to-usize.png" alt=""></p>
<p>It's calling one of nom's trait methods? I wonder what it does…</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/dbg-to-usize-impl.png" alt=""></p>
<p>Oh. Uh. Seems wasteful? Let's try turning on Link-Time Optimization:</p>
<pre><code>// in `Cargo.toml`
<span>
[profile.release]</span>
<span>lto</span> = <span>true</span>
</code></pre>
<pre><code><span>$</span><span> cargo build --release</span>
   Compiling proc-macro2 v0.4.30
   (many lines cut)
   Compiling ersatz v0.1.0 (C:\msys64\home\amos\ftl\ersatz)
    Finished release [optimized] target(s) in 34.16s
</code></pre>
<p>Didn't even take that much longer.</p>
<p>Did it make a difference in the codegen?</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/lto-symbols.png" alt=""></p>
<p>Looks like it! I can't find <code>ethernet::Frame::parse</code> anymore.</p>
<p>I know there's an <code>unknown EtherType</code> error message <em>somewhere</em> though.</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/lto-stringref.png" alt=""></p>
<p>ahAH! There it is.</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/lto-unknown-ethertype.png" alt=""></p>
<p>Let's follow it in the graph:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/lto-ethertype-error.png" alt=""></p>
<p>Alright, it's definitely formatting an error message. Where can we come from though?</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/lto-rol.png" alt=""></p>
<p>Aha! Here's our <code>movzx</code> and our <code>rol</code>.</p>
<p>This is in turn accessible from this part of the graph:</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/lto-mac-calls.png" alt=""></p>
<p>And I bet you those two <code>call</code> (highlighted in cyan) are to <code>ethernet::Addr::parse</code>.</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/lto-mac-impl1.png" alt=""></p>
<p>Mhhh is it? Let's look a little further down the graph…</p>
<p><img src="https://fasterthanli.me/img/making-our-own-ping-9/lto-mac-impl2.png" alt=""></p>
<p>It is!</p>
<p>I also cannot see <em>any</em> trace of <code>ToUsize::to_usize</code> anymore, which means
rustc / LLVM / MSVC worked together to successfully perform cross-crate inlining.</p>
<h2 id="epilogue">Epilogue</h2>
<p>This has been a long article, <strong>but</strong> we've got everything we need to finish
this series. Well, except the ability to <em>send</em> traffic, but I promise you
the <code>rawsock</code> crate will also let us do that.</p>
<p>In the meantime, we'll just slowly chip away at IPv4, and ICMP.. and then rebuild
them from the ground up to come up with the ultimate, userland-networking-powered,
version of <code>sup</code>.</p>


          







          
          
<p>This article was made possible thanks to my patrons: Aurora, Chad Morrow, Geoffroy Couprie, Ignacio Vergara, Jane Lusby, Jesús
Higueras, Jérémy Gtld, Michael Alyn Miller, Nicolas Goy, o0Ignition0o,
Pascal, Raphael Gaschignard, Romain Ruetschi, Ryszard Sommefeldt, Ted
Mielczarek, Xananax, and Zaki.
</p>
          
        </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>