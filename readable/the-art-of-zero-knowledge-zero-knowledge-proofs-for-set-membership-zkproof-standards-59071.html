<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Art of Zero Knowledge: Zero-Knowledge Proofs for Set Membership | ZKProof Standards - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The Art of Zero Knowledge: Zero-Knowledge Proofs for Set Membership | ZKProof Standards - linksfor.dev(s)"/>
    <meta property="article:author" content="Dario FioreAll author posts"/>
    <meta property="og:description" content="Last year I wrote about why booking too far in advance can be dangerous for your business, and this concept of margin so eloquently captures what I had recognized had been my problem: I was so booked up with clients that I wasn&#x2019;t leaving any margin for error, growth, planning, or reflection."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://zkproof.org/2020/02/27/zkp-set-membership/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The Art of Zero Knowledge: Zero-Knowledge Proofs for Set Membership | ZKProof Standards</title>
<div class="readable">
        <h1>The Art of Zero Knowledge: Zero-Knowledge Proofs for Set Membership | ZKProof Standards</h1>
            <div>by Dario FioreAll author posts</div>
            <div>Reading time: 13-16 minutes</div>
        <div>Posted here: 28 Feb 2020</div>
        <p><a href="https://zkproof.org/2020/02/27/zkp-set-membership/">https://zkproof.org/2020/02/27/zkp-set-membership/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div data-parent="true" data-section="2"><div data-imgready="true"><div><div><div><div><div><div><div><p>With a Merkle tree one can accumulate <em>sets made of arbitrary elements</em> using a collision-resistant hash function. We refer to <a href="https://hackernoon.com/merkle-trees-181cb4bc30b4">this resource</a> or <a href="https://nakamoto.com/merkle-trees/">this one</a> for a more detailed explanation, but the basic idea is the following.</p>
<p>The public parameters simply consist of an hash function (e.g., SHA-256).<br>
In order to accumulate a set <span id="MathJax-Element-39-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi><mo>=</mo><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&amp;#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi><mo>=</mo><mo fence="false" stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>…</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo fence="false" stretchy="false">}</mo></math></span></span> (let us assume for simplicity that <span id="MathJax-Element-40-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> is a power of <span id="MathJax-Element-41-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn></math></span></span>), one builds a binary tree in which <span id="MathJax-Element-42-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&amp;#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>…</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo fence="false" stretchy="false">}</mo></math></span></span> are the leaves, and every internal node is the hash of its two children. The accumulator value <span id="MathJax-Element-43-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span> is then the value at the root of such tree.<br>
To create a proof <span id="MathJax-Element-44-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03C0;</mi><mi>j</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>π</mi><mi>j</mi></msub></math></span></span> that a certain <span id="MathJax-Element-45-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>j</mi></msub><mo>&amp;#x2208;</mo><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>j</mi></msub><mo>∈</mo><mi>S</mi></math></span></span>, one returns all the sibling nodes that are in the path from the leaf <span id="MathJax-Element-46-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>j</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>j</mi></msub></math></span></span> until the root.<br>
From the binary tree structure one then gets that these proofs consist of <span id="MathJax-Element-47-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>log</mi><mo>&amp;#x2061;</mo><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span> strings of <span id="MathJax-Element-48-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x2113;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>ℓ</mi></math></span></span> bits each (where <span id="MathJax-Element-49-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x2113;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>ℓ</mi></math></span></span> is the hash’s output bit length), and can be verified by using the siblings to recompute the nodes in the path and then check if the final result is equal to the root <span id="MathJax-Element-50-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span>.</p>
<p>Merkle trees are a very powerful construct, with countless applications and a lot of nice properties. They are actually more powerful than accumulators; they realize a so-called <a href="https://eprint.iacr.org/2011/495.pdf">vector commitment</a>, since the position of each leaf in the tree is also encoded in a binding way, in the sense that it is computationally impossible to claim two distinct values at the same position.</p>
</div><div><p>With <a href="https://link.springer.com/chapter/10.1007/3-540-48285-7_24">RSA Accumulators</a> one can accumulate <em>sets made of prime numbers</em>. The main ingredient of these constructions are <em>groups of unknown order</em>, of which RSA groups (from which the name) or <a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.7192">class groups</a> are candidate realizations. Let us show how this works in RSA groups.</p>
<p>The public parameters consist of an RSA modulus <span id="MathJax-Element-51-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mo>=</mo><mi>p</mi><mo>&amp;#x22C5;</mo><mi>q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi><mo>=</mo><mi>p</mi><mo>⋅</mo><mi>q</mi></math></span></span> product of two large prime numbers <span id="MathJax-Element-52-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi></math></span></span> and <span id="MathJax-Element-53-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>q</mi></math></span></span>, and of a random generator <span id="MathJax-Element-54-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>G</mi><mo>&amp;#x2208;</mo><msubsup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>Z</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>N</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2217;</mo></mrow></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>G</mi><mo>∈</mo><msubsup><mrow><mi mathvariant="double-struck">Z</mi></mrow><mrow><mi>N</mi></mrow><mrow><mo>∗</mo></mrow></msubsup></math></span></span>. Here, <span id="MathJax-Element-55-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>Z</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>N</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mrow><mi mathvariant="double-struck">Z</mi></mrow><mrow><mi>N</mi></mrow></msub></math></span></span> denotes the ring of non-negative integers modulo <span id="MathJax-Element-56-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math></span></span>—the set <span id="MathJax-Element-57-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mo>&amp;#x2026;</mo><mo>,</mo><mi>N</mi><mo>&amp;#x2212;</mo><mn>1</mn><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mo>…</mo><mo>,</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo fence="false" stretchy="false">}</mo></math></span></span>—while <span id="MathJax-Element-58-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>Z</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>N</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2217;</mo></mrow></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mrow><mi mathvariant="double-struck">Z</mi></mrow><mrow><mi>N</mi></mrow><mrow><mo>∗</mo></mrow></msubsup></math></span></span> is the subset of elements in <span id="MathJax-Element-59-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>Z</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>N</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mrow><mi mathvariant="double-struck">Z</mi></mrow><mrow><mi>N</mi></mrow></msub></math></span></span> that are also coprime with <span id="MathJax-Element-60-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi></math></span></span>, which form a <em>group</em> under multiplication.</p>
<p>In order to accumulate a set <span id="MathJax-Element-61-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span> of prime numbers <span id="MathJax-Element-62-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mo>&amp;#x2026;</mo><msub><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msub><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mo>…</mo><msub><mi>e</mi><mrow><mi>n</mi></mrow></msub><mo fence="false" stretchy="false">}</mo></math></span></span>, one computes
<p><span id="MathJax-Element-63-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>A</mi><mo stretchy=&quot;false&quot;>&amp;#x2190;</mo><msup><mi>G</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><munderover><mo>&amp;#x220F;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></munderover><msub><mi>e</mi><mi>i</mi></msub></mrow></msup><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>N</mi><mo>.</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>A</mi><mo stretchy="false">←</mo><msup><mi>G</mi><mrow><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></munderover><msub><mi>e</mi><mi>i</mi></msub></mrow></msup><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>N</mi><mo>.</mo></math></span></span></p><br>
To create a proof that a certain <span id="MathJax-Element-64-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>e</mi><mi>j</mi></msub><mo>&amp;#x2208;</mo><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>e</mi><mi>j</mi></msub><mo>∈</mo><mi>S</mi></math></span></span>, one computes
<p><span id="MathJax-Element-65-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msub><mi>&amp;#x03C0;</mi><mi>j</mi></msub><mo stretchy=&quot;false&quot;>&amp;#x2190;</mo><msup><mi>G</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><munderover><mo>&amp;#x220F;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo>&amp;#x2260;</mo><mi>j</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></munderover><msub><mi>e</mi><mi>i</mi></msub></mrow></msup><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>N</mi><mo>=</mo><msup><mi>A</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><msub><mi>e</mi><mi>j</mi></msub></mrow></msup><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>N</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>π</mi><mi>j</mi></msub><mo stretchy="false">←</mo><msup><mi>G</mi><mrow><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo>≠</mo><mi>j</mi></mrow><mrow><mi>n</mi></mrow></munderover><msub><mi>e</mi><mi>i</mi></msub></mrow></msup><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>N</mi><mo>=</mo><msup><mi>A</mi><mrow><mn>1</mn><mrow><mo>/</mo></mrow><msub><mi>e</mi><mi>j</mi></msub></mrow></msup><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>N</mi></math></span></span></p><br>
which can be verified by checking if
<p><span id="MathJax-Element-66-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msubsup><mi>&amp;#x03C0;</mi><mi>j</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>e</mi><mi>j</mi></msub></mrow></msubsup><mo>=</mo><mi>A</mi><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>N</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msubsup><mi>π</mi><mi>j</mi><mrow><msub><mi>e</mi><mi>j</mi></msub></mrow></msubsup><mo>=</mo><mi>A</mi><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>N</mi></math></span></span></p></p>
<p>Overall, RSA accumulators are a quite simple and elegant construction. While the basic construction above has the limitation that elements must be prime numbers, this can be solved by using appropriately constructed hash functions that map arbitrary strings into primes. Compared to Merkle trees, they have the appealing property that everything is constant-size: both <span id="MathJax-Element-67-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span> and the proof <span id="MathJax-Element-68-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03C0;</mi><mi>j</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>π</mi><mi>j</mi></msub></math></span></span> consist of one group element each, and verification requires one modular exponentiation only.<br>
On top of this, they enjoy further properties. For example, it is possible to efficiently add elements to the accumulator value (i.e. it is dynamic), to create proofs of non-membership (it is universal), and to create short proofs for membership of many elements. See for example this recent work by <a href="https://eprint.iacr.org/2018/1188.pdf">Boneh, Bunz and Fisch</a> to read about these and more properties.</p>
</div><div><p><h2><span>Verifying Set Membership, <em>Efficiently and Privately</em></span></h2></p></div><div><p>We have seen how accumulators can provide a solution to the problem of proving and verifying set membership in an efficient manner.<br>
Let us now move to the question of how to make these proofs also privacy-preserving, namely how to prove that <span id="MathJax-Element-69-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi><mo>&amp;#x2208;</mo><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>∈</mo><mi>S</mi></math></span></span> without revealing <span id="MathJax-Element-70-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span>.</p>
<p>Actually, in most applications, the privacy requirement about <span id="MathJax-Element-71-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> typically goes together with the need of proving more than just membership. One may wish to prove that a property <span id="MathJax-Element-72-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></span></span> holds for some element <span id="MathJax-Element-73-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi><mo>&amp;#x2208;</mo><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>∈</mo><mi>S</mi></math></span></span>, without revealing exactly for which element.<br>
In other (more cryptographic) words, one is interested in making a zero-knowledge proof (ZKP) for the <a href="https://cs.stanford.edu/people/trevisan/cs254-12/lecture02.pdf">NP relation</a> <span id="MathJax-Element-74-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>R</mi><mo stretchy=&quot;false&quot;>(</mo><mi>S</mi><mo>,</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>:=</mo><mi>x</mi><mo>&amp;#x2208;</mo><mi>S</mi><mo>&amp;#x2227;</mo><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi><mo stretchy="false">(</mo><mi>S</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:=</mo><mi>x</mi><mo>∈</mo><mi>S</mi><mo>∧</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></span></span>, where <span id="MathJax-Element-75-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span> is public and <span id="MathJax-Element-76-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> is secret.<br>
A ZKP for <span id="MathJax-Element-77-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>R</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi></math></span></span> however is not necessarily “efficient” in the same sense as discussed earlier since the verifier should read <span id="MathJax-Element-78-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span>, and the proof itself may not be succinct.</p>
<p>To make the proof also short and efficient to verify, a solution is to mix ZKPs with accumulators, that is to build a ZKP for the following relation
<p><span id="MathJax-Element-79-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>R</mi><mo stretchy=&quot;false&quot;>(</mo><mi>A</mi><mo>,</mo><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo>,</mo><msub><mi>&amp;#x03C0;</mi><mi>x</mi></msub><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo><mo>:=</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext mathvariant=&quot;sans-serif&quot;>Verify</mtext></mrow><mo stretchy=&quot;false&quot;>(</mo><mi>A</mi><mo>,</mo><mi>x</mi><mo>,</mo><msub><mi>&amp;#x03C0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>x</mi></mrow></msub><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2227;</mo><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>R</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><msub><mi>π</mi><mi>x</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>:=</mo><mrow><mtext mathvariant="sans-serif">Verify</mtext></mrow><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>x</mi><mo>,</mo><msub><mi>π</mi><mrow><mi>x</mi></mrow></msub><mo stretchy="false">)</mo><mo>∧</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></span></span></p><br>
that, in words, proves existence of an element <span id="MathJax-Element-80-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> for which <span id="MathJax-Element-81-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi></math></span></span> holds and for which there is a valid accumulator proof relative to <span id="MathJax-Element-82-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span>, which in turn implies membership in the set accumulated in <span id="MathJax-Element-83-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span>.</p>
<p>This blueprint can be applied to both Merkle trees and RSA accumulators.<br>
In the rest of this post, we review the main existing solutions that follow these two approaches, and then we conclude by mentioning a recent work.</p>
</div><div><p><h3><span>ZKPs for Set Membership via Merkle Trees</span></h3></p></div><p>ZKPs for set membership via Merkle trees are a straightforward application of the ZKP &amp; Accumulators mixing approach mentioned above.<br>
Notably, this idea has been implemented in the <a href="https://z.cash/">Zcash</a> protocol, which used the general-purpose power of zkSNARKs in order to prove in zero-knowledge existence of a valid Merkle path (in addition to other properties modeling the validity of a transaction). This in turn translates into proving correctness of about <span id="MathJax-Element-84-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>log</mi><mo>&amp;#x2061;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>S</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>log</mi><mo>⁡</mo><mrow><mo stretchy="false">|</mo></mrow><mi>S</mi><mrow><mo stretchy="false">|</mo></mrow></math></span></span> hash computations on secret inputs. Encoding hash computations in the zkSNARK is what makes this approach particularly expensive for the prover. Zcash’s <a href="https://github.com/zcash/zips/blob/master/protocol/protocol.pdf">Sapling</a> provided significant speedups of this approach via an ingenious choice of a pairing-friendly elliptic curve and the Pedersen hash function. Nevertheless, proving set membership is by now the most expensive part of proof generation in Zcash.</p><div><p><h3><span>ZKPs for Set Membership via RSA Accumulators</span></h3></p></div><div><p>For the case of RSA Accumulators, a notable work is that of <a href="https://cs.brown.edu/people/alysyans/papers/camlys02.pdf">Camenisch and Lysyanskaya</a> who designed a ZKP protocol for the knowledge of an integer <span id="MathJax-Element-85-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>e</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi></math></span></span> that is in the accumulator and that is committed in a group <span id="MathJax-Element-86-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>G</mi></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="double-struck">G</mi></mrow></math></span></span> of prime order <span id="MathJax-Element-87-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>q</mi></math></span></span>. More technically, given an accumulator <span id="MathJax-Element-88-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span> and a Pedersen commitment <span id="MathJax-Element-89-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msub><mo>&amp;#x2208;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>G</mi></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mrow><mi>e</mi></mrow></msub><mo>∈</mo><mrow><mi mathvariant="double-struck">G</mi></mrow></math></span></span> as public values, they show how to prove knowledge of <span id="MathJax-Element-90-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>e</mi><mo>,</mo><mi>W</mi><mo>,</mo><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>e</mi><mo>,</mo><mi>W</mi><mo>,</mo><mi>r</mi><mo stretchy="false">)</mo></math></span></span> such that
<p><span id="MathJax-Element-91-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>A</mi><mo>=</mo><msup><mi>W</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msup><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>N</mi><mo>&amp;#x2227;</mo><msub><mi>C</mi><mi>e</mi></msub><mo>=</mo><msup><mi>g</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msup><msup><mi>h</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>r</mi></mrow></msup><mo>&amp;#x2208;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>G</mi></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>A</mi><mo>=</mo><msup><mi>W</mi><mrow><mi>e</mi></mrow></msup><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>N</mi><mo>∧</mo><msub><mi>C</mi><mi>e</mi></msub><mo>=</mo><msup><mi>g</mi><mrow><mi>e</mi></mrow></msup><msup><mi>h</mi><mrow><mi>r</mi></mrow></msup><mo>∈</mo><mrow><mi mathvariant="double-struck">G</mi></mrow></math></span></span></p><br>
Having the commitment <span id="MathJax-Element-92-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mrow><mi>e</mi></mrow></msub></math></span></span> comes in handy if the final goal is to prove some property <span id="MathJax-Element-93-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi></math></span></span> about the set element <span id="MathJax-Element-94-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>e</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi></math></span></span>: one simply creates another commit-and-prove ZKP for proving knowledge of <span id="MathJax-Element-95-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>e</mi><mo>,</mo><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>e</mi><mo>,</mo><mi>r</mi><mo stretchy="false">)</mo></math></span></span> such that <span id="MathJax-Element-96-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mi>e</mi></msub><mo>=</mo><msup><mi>g</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msup><msup><mi>h</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>r</mi></mrow></msup><mo>&amp;#x2208;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>G</mi></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mi>e</mi></msub><mo>=</mo><msup><mi>g</mi><mrow><mi>e</mi></mrow></msup><msup><mi>h</mi><mrow><mi>r</mi></mrow></msup><mo>∈</mo><mrow><mi mathvariant="double-struck">G</mi></mrow></math></span></span> and <span id="MathJax-Element-97-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>e</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></math></span></span> holds.</p>
<p>The <a href="https://cs.brown.edu/people/alysyans/papers/camlys02.pdf">Camenisch-Lysyanskaya</a> protocol is potentially more efficient than the one based on Merkle trees as it does not require expensive general-purpose ZKPs that encode hash computations. Nevertheless, its use can be cumbersome due to some technical details. Most notably, the accumulated sets must be prime numbers of a specific size (which also imposes a minimum size for the prime-order group), and the hash-to-prime trick to avoid this problem cannot be used straightforwardly to mitigate this issue.</p>
</div><div><p><h2><span>ZKPs for Set Membership: Efficient, Succinct, Modular</span></h2></p></div><p>In the last part of this post, I would like to mention a <a href="https://eprint.iacr.org/2019/1255">recent work [BCFK19]</a> that investigates <em>modular</em> and <em>efficient</em> constructions of ZKPs for set membership.</p><div><p>One is often confronted with creating ZKPs for “composite statements”, e.g., statements of the form “I know a value <span id="MathJax-Element-98-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> that belongs to a set <span id="MathJax-Element-99-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span> and for which properties <span id="MathJax-Element-100-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>P</mi><mn>1</mn></msub><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></span></span> and <span id="MathJax-Element-101-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>P</mi><mn>2</mn></msub><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>P</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></span></span> hold”. In such a case, it can be convenient to create a proof by using three different proof systems, one for each subtask, e.g., <span id="MathJax-Element-102-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>e</mi><mi>m</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>m</mi><mi>e</mi><mi>m</mi></mrow></msub></math></span></span> for set membership, <span id="MathJax-Element-103-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mn>1</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mn>1</mn></msub></math></span></span> for <span id="MathJax-Element-104-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>P</mi><mn>1</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>P</mi><mn>1</mn></msub></math></span></span>, <span id="MathJax-Element-105-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mn>2</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mn>2</mn></msub></math></span></span> for <span id="MathJax-Element-106-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>P</mi><mn>2</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>P</mi><mn>2</mn></msub></math></span></span>.<br>
This modular approach can be beneficial in multiple ways: one can focus on designing efficiency-optimized ZKPs for specific tasks, the same scheme can be re-used and replaced in a plug-and-play fashion, and it is just a simple design paradigm.</p>
<p>Technically, this approach can be realized by using <em>commit-and-prove </em>ZKP systems.<br>
In a nutshell, a proof system <span id="MathJax-Element-107-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">Π</mi></math></span></span> for a property <span id="MathJax-Element-108-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi></math></span></span> is commit-and-prove if it can prove statements of the form “I know <span id="MathJax-Element-109-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> such that <span id="MathJax-Element-110-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></span></span> holds and <span id="MathJax-Element-111-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>x</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mrow><mi>x</mi></mrow></msub></math></span></span> is a commitment to <span id="MathJax-Element-112-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span>”. Since commitments are binding, generating two such proofs with respect to the same commitment immediately implies an AND composition of the two proven statement. Essentially, commitments act as a “secure glue” between different proof systems.<br>
While commit-and-prove has been known and used extensively in cryptography constructions, the recent <a href="https://eprint.iacr.org/2019/142">LegoSNARK</a> paper studied this paradigm in the context of succinct ZKPs, aka zkSNARKs.</p>
</div><div><p><h3><span>Modular in ZKP for Set-Membership</span></h3></p></div><div><p>The <a href="https://eprint.iacr.org/2019/1255">[BCFK19]</a> paper starts from the observation that <em>an accumulator value can be seen as a commitment to a set</em>, and that the whole accumulator primitive can be seen as a succinct commit-and-prove system for set membership relations. In this sense, accumulators with ZK proofs of knowledge (i.e., that can prove “I know a valid accumulator proof for an <span id="MathJax-Element-113-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> in the commitment”) can be seen as commit-and-prove zkSNARK for set membership relations involving two types of commitments, a commitment to a set—the accumulator—and a commitment to an element.</p>
<p>So, one theoretical contribution of the paper is to extend the model of commit-and-prove zkSNARKs (and their composability properties) to the setting of typed-commitments, namely commitments to messages of different types (e.g., strings and sets over strings).</p>
</div><div><p><h3><span>More Flexible and Modular ZKPs for RSA Accumulators</span></h3></p></div><div><p>On the more practical side, <a href="https://eprint.iacr.org/2019/1255">[BCFK19]</a> proposes new commit-and-prove zkSNARKs for set-membership, notably two solutions based on RSA accumulators that can be combined modularly and efficiently with other popular ZKP systems, such as <a href="https://eprint.iacr.org/2017/1066.pdf">Bulletproofs</a> or <a href="https://eprint.iacr.org/2016/260.pdf">Groth16</a>. The latter feature is useful since it allows one to prove statements of the form “I know a value <span id="MathJax-Element-114-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> that belongs to a set <span id="MathJax-Element-115-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span> and for which property <span id="MathJax-Element-116-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></span></span> holds'”, by using this specialized scheme for the set-membership part and a general-purpose one for any other property about <span id="MathJax-Element-117-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span>.</p>
<p>Going more into the detail, <a href="https://eprint.iacr.org/2019/1255">[BCFK19]</a> proposes two solutions based on RSA.<br>
Both of them provide a functionality similar to the ZKP of <a href="https://cs.brown.edu/people/alysyans/papers/camlys02.pdf">Camenisch and Lysyanskaya </a>mentioned earlier, in the sense that the element <span id="MathJax-Element-118-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> object of the membership proof is committed in a Pedersen commitment <span id="MathJax-Element-119-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mi>x</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mi>x</mi></msub></math></span></span> over a group <span id="MathJax-Element-120-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>G</mi></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="double-struck">G</mi></mrow></math></span></span> of prime order <span id="MathJax-Element-121-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>q</mi></math></span></span>.<br>
One key difference that helps efficient modularity however is that in <a href="https://eprint.iacr.org/2019/1255">[BCFK19]</a> <span id="MathJax-Element-122-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>G</mi></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="double-struck">G</mi></mrow></math></span></span> can be of standard size (e.g., 256 bits for 128 bits of security). This, we recall, means that other commit-and-prove systems that want to use <span id="MathJax-Element-123-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mi>x</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mi>x</mi></msub></math></span></span> do not need to suffer efficiency slowdowns due to inflated sizes of <span id="MathJax-Element-124-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>G</mi></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="double-struck">G</mi></mrow></math></span></span>.<br>
In terms of supported sets, both solutions in <a href="https://eprint.iacr.org/2019/1255">[BCFK19]</a> allow more flexible choices of sets than the <a href="https://cs.brown.edu/people/alysyans/papers/camlys02.pdf">Camenisch-Lysyanskaya</a> protocol: the first scheme supports the accumulation of sets whose elements are arbitrary binary strings, while in the second scheme elements are prime numbers of exactly <span id="MathJax-Element-125-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BC;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>μ</mi></math></span></span> bits (for various flexible choices of <span id="MathJax-Element-126-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BC;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>μ</mi></math></span></span>).</p>
</div><div><p><h3><span>Deep Diving into Linking Pedersen Commitments in Different Groups</span></h3></p></div><div><p>Let us go even deeper and see how <a href="https://eprint.iacr.org/2019/1255">[BCFK19]</a> achieves these improvements. In a nutshell, this is due to a new way to link a proof of membership for RSA accumulators to a Pedersen commitment in a prime order group, together with a careful analysis showing how this can be secure under parameters <em>not requiring a larger prime order group</em>.<br>
For this post we only summarize the main idea for the scheme supporting sets of primes; we refer the interested readers to the paper for further details.</p>
<p>Let us recall the setting. The statement known to the verifier consists of an accumulator <span id="MathJax-Element-127-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi><mo>=</mo><msup><mi>G</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><munderover><mo>&amp;#x220F;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></munderover><msub><mi>e</mi><mi>i</mi></msub></mrow></msup><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>N</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi><mo>=</mo><msup><mi>G</mi><mrow><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></munderover><msub><mi>e</mi><mi>i</mi></msub></mrow></msup><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>N</mi></math></span></span>, which is a commitment to a set <span id="MathJax-Element-128-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi><mo>=</mo><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mo>&amp;#x2026;</mo><mo>,</mo><msub><mi>e</mi><mi>n</mi></msub><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi><mo>=</mo><mo fence="false" stretchy="false">{</mo><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><mo>…</mo><mo>,</mo><msub><mi>e</mi><mi>n</mi></msub><mo fence="false" stretchy="false">}</mo></math></span></span>, and of a Pedersen commitment <span id="MathJax-Element-129-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mrow><mi>e</mi></mrow></msub></math></span></span> in a group <span id="MathJax-Element-130-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>G</mi></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="double-struck">G</mi></mrow></math></span></span> of prime order <span id="MathJax-Element-131-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>q</mi></math></span></span>.<br>
The goal of the prover is to argue knowledge of <span id="MathJax-Element-132-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>e</mi><mo>,</mo><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>e</mi><mo>,</mo><mi>r</mi><mo stretchy="false">)</mo></math></span></span> that open <span id="MathJax-Element-133-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mi>e</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mi>e</mi></msub></math></span></span>, i.e., <span id="MathJax-Element-134-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msub><mo>=</mo><msup><mi>g</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msup><msup><mi>h</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>r</mi></mrow></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mrow><mi>e</mi></mrow></msub><mo>=</mo><msup><mi>g</mi><mrow><mi>e</mi></mrow></msup><msup><mi>h</mi><mrow><mi>r</mi></mrow></msup></math></span></span>, and such that <span id="MathJax-Element-135-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>e</mi><mo>&amp;#x2208;</mo><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi><mo>∈</mo><mi>S</mi></math></span></span> where <span id="MathJax-Element-136-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi><mo>=</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext mathvariant=&quot;sans-serif&quot;>Acc</mtext></mrow><mo stretchy=&quot;false&quot;>(</mo><mi>S</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi><mo>=</mo><mrow><mtext mathvariant="sans-serif">Acc</mtext></mrow><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></math></span></span>. This is achieved through a combination of the following:</p>
<ul>
<li><span id="MathJax-Element-137-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>C</mi><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2217;</mo></mrow></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>C</mi><mi>e</mi><mrow><mo>∗</mo></mrow></msubsup></math></span></span>, a commitment to <span id="MathJax-Element-138-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>e</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi></math></span></span> created by the prover in the RSA group: <span id="MathJax-Element-139-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2217;</mo></mrow></msubsup><mo>=</mo><msup><mi>G</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msup><msup><mi>H</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>s</mi></mrow></msup><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>N</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>C</mi><mrow><mi>e</mi></mrow><mrow><mo>∗</mo></mrow></msubsup><mo>=</mo><msup><mi>G</mi><mrow><mi>e</mi></mrow></msup><msup><mi>H</mi><mrow><mi>s</mi></mrow></msup><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>N</mi></math></span></span>.</li>
<li><span id="MathJax-Element-140-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></math></span></span>, a ZKP of a committed root for <span id="MathJax-Element-141-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span>, i.e., a proof of knowledge of <span id="MathJax-Element-142-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>e</mi><mo>,</mo><mi>s</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi><mo>,</mo><mi>s</mi></math></span></span> and <span id="MathJax-Element-143-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math></span></span> such that
<p><span id="MathJax-Element-144-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msup><mi>W</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msup><mo>=</mo><mi>A</mi><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>N</mi><mspace width=&quot;1em&quot; /><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>and</mtext></mrow><mspace width=&quot;1em&quot; /><msubsup><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2217;</mo></mrow></msubsup><mo>=</mo><msup><mi>G</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msup><msup><mi>H</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>s</mi></mrow></msup><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>N</mi><mo>.</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>W</mi><mrow><mi>e</mi></mrow></msup><mo>=</mo><mi>A</mi><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>N</mi><mspace width="1em"></mspace><mrow><mtext>and</mtext></mrow><mspace width="1em"></mspace><msubsup><mi>C</mi><mrow><mi>e</mi></mrow><mrow><mo>∗</mo></mrow></msubsup><mo>=</mo><msup><mi>G</mi><mrow><mi>e</mi></mrow></msup><msup><mi>H</mi><mrow><mi>s</mi></mrow></msup><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>N</mi><mo>.</mo></math></span></span></p></li>
<li><span id="MathJax-Element-145-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>q</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>q</mi></mrow></msub></math></span></span>, a ZKP that <span id="MathJax-Element-146-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2217;</mo></mrow></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>C</mi><mrow><mi>e</mi></mrow><mrow><mo>∗</mo></mrow></msubsup></math></span></span> and <span id="MathJax-Element-147-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mrow><mi>e</mi></mrow></msub></math></span></span> commit to the same value modulo <span id="MathJax-Element-148-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>q</mi></math></span></span>.</li>
<li><span id="MathJax-Element-149-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub></math></span></span>, a ZKP that <span id="MathJax-Element-150-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mrow><mi>e</mi></mrow></msub></math></span></span> commits to an integer in the range <span id="MathJax-Element-151-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>&amp;#x03BC;</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msup><mo>,</mo><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>&amp;#x03BC;</mi></mrow></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>μ</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>,</mo><msup><mn>2</mn><mrow><mi>μ</mi></mrow></msup><mo stretchy="false">)</mo></math></span></span>.</li>
</ul>
<p>Intuitively, <span id="MathJax-Element-152-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></math></span></span> shows that <span id="MathJax-Element-153-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow><mo>&amp;#x2217;</mo></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>C</mi><mrow><mi>e</mi></mrow><mo>∗</mo></msubsup></math></span></span> commits to an integer that is accumulated in <span id="MathJax-Element-154-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span> (at this point, however, such integer may be a trivial root, i.e., <span id="MathJax-Element-155-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span>). The goal of <span id="MathJax-Element-156-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>q</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>q</mi></mrow></msub></math></span></span> and <span id="MathJax-Element-157-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub></math></span></span> is to rule out this corner case <span id="MathJax-Element-158-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>e</mi><mo>=</mo><mn>1</mn></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi><mo>=</mo><mn>1</mn></math></span></span> and to “securely link” the commitment <span id="MathJax-Element-159-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>C</mi><mi>e</mi><mo>&amp;#x2217;</mo></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>C</mi><mi>e</mi><mo>∗</mo></msubsup></math></span></span> in the RSA group created by the prover with the prime-order group commitment <span id="MathJax-Element-160-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mi>e</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mi>e</mi></msub></math></span></span> known to the verifier, namely to ensure that these two commitment open to the same integer <span id="MathJax-Element-161-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>e</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>e</mi></math></span></span>.<br>
This is less straightforward than expected because <span id="MathJax-Element-162-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>q</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>q</mi></mrow></msub></math></span></span> is only able to prove that the equality of the values committed in <span id="MathJax-Element-163-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>C</mi><mi>e</mi><mo>&amp;#x2217;</mo></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>C</mi><mi>e</mi><mo>∗</mo></msubsup></math></span></span> and <span id="MathJax-Element-164-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mi>e</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mi>e</mi></msub></math></span></span> holds <em>modulo </em><span id="MathJax-Element-165-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>q</mi></math></span></span><em> and not necessarily over the integers</em>. Also, from <span id="MathJax-Element-166-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></math></span></span> alone, one can only infer that <span id="MathJax-Element-167-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>C</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>e</mi></mrow><mo>&amp;#x2217;</mo></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>C</mi><mrow><mi>e</mi></mrow><mo>∗</mo></msubsup></math></span></span> commits to some integer <span id="MathJax-Element-168-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>e</mi><mo>&amp;#x2217;</mo></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi><mo>∗</mo></msup></math></span></span> that divides <span id="MathJax-Element-169-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><munderover><mo>&amp;#x220F;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></munderover><msub><mi>e</mi><mi>i</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></munderover><msub><mi>e</mi><mi>i</mi></msub></math></span></span>.</p>
<p>So, the bad case that malicious provers may trigger and that the protocol must exclude is that <span id="MathJax-Element-170-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>e</mi><mo>&amp;#x2217;</mo></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi><mo>∗</mo></msup></math></span></span> and <span id="MathJax-Element-171-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>e</mi><mo>&amp;#x2217;</mo></msup><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi><mo>∗</mo></msup><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>q</mi></math></span></span> are <em>different</em> over the integers. This can be shown with a quite detailed analysis whose basic idea is to use the fact that <span id="MathJax-Element-172-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></math></span></span> nevertheless guarantees that <span id="MathJax-Element-173-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>e</mi><mo>&amp;#x2217;</mo></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi><mo>∗</mo></msup></math></span></span> can be the product of only few primes in <span id="MathJax-Element-174-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span> (say 1, 2, depending on the difference between <span id="MathJax-Element-175-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BC;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>μ</mi></math></span></span> and <span id="MathJax-Element-176-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>q</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">|</mo></mrow><mi>q</mi><mrow><mo stretchy="false">|</mo></mrow></math></span></span>), and that <span id="MathJax-Element-177-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x03A0;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="normal">Π</mi><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi></mrow></msub></math></span></span> ensures that <span id="MathJax-Element-178-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>e</mi><mo>&amp;#x2217;</mo></msup><mo lspace=&quot;thickmathspace&quot; rspace=&quot;thickmathspace&quot;>mod</mo><mi>q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi><mo>∗</mo></msup><mo lspace="thickmathspace" rspace="thickmathspace">mod</mo><mi>q</mi></math></span></span> lies in the range <span id="MathJax-Element-179-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>&amp;#x03BC;</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msup><mo>,</mo><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>&amp;#x03BC;</mi></mrow></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><msup><mn>2</mn><mrow><mi>μ</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>,</mo><msup><mn>2</mn><mrow><mi>μ</mi></mrow></msup><mo stretchy="false">)</mo></math></span></span>.</p>
<p>To summarize, this technique enables linking the commitments in the RSA and prime-order group in an efficient way, and this enables to use this ZKP for set membership in combination with other SNARKs that are instantiated over the same prime-order group.</p>
</div><p>To conclude, in this post we went on a journey about the set membership problem. We started from seminal works (Merkle trees and RSA accumulators) that provide a solution to the scalability problem of set membership. Next, we went on to discuss solutions that allow one to maintain the privacy of the element involved in the set membership statement — a problem that is key in a number of applications from different domains, including finance, and business- or governmental-level interaction. Given the emergence of ZKP applications in the real-world, we expect that new solutions to the problem of privacy-preserving set membership will come out.</p></div></div></div></div></div></div></div></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>