<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Modern Alternatives to PGP -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Modern Alternatives to PGP</h1><div><div class="post-content"><p>Did your last Yubikey just break? Perhaps you forgot an offline backup password. Maybe you're just tired of <a href="https://gist.github.com/grugq/03167bed45e774551155">living like a spy</a> and never using smartphones. Whatever it is, you're here, and you're finally ready to <a href="https://blog.filippo.io/giving-up-on-long-term-pgp">give up on PGP</a>. That's great!</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.gtank.cc/content/images/2019/02/225357.jpg" class="kg-image"><figcaption>We're here to help!</figcaption></figure><p>No one was sending you encrypted emails anyway, so that's easy enough. But the most widespread uses of PGP are machine-oriented, for needs like package signing and local file encryption. I recently got into this again on a thread that mentioned <a href="https://github.com/golang/go/issues/30141">deprecating Go's OpenPGP package</a> and people always ask the same question: if not PGP, then what?</p><p>The thing is, there can't be a direct modern alternative to PGP. It's a do-everything design that predates modern cryptographic engineering and hasn't worked out well. The "modern alternative" is to use a much more specific and much less configurable solution to your problem.</p><p>Here are the most common uses of PGP and their modern, focused alternatives.</p><h2 id="signatures-for-os-or-package-updates">Signatures for OS or package updates</h2><p><strong>Original need:</strong><a href="https://tutorials.ubuntu.com/tutorial/tutorial-how-to-verify-ubuntu#0">Linux distributions</a> and many other software update mechanisms use PGP signatures to prevent malicious mirrors or network attackers from altering the contents of their packages.</p><p><strong>Modern alternative:</strong> a lightweight signing tool like OpenBSD's <a href="https://https.www.google.com.tedunangst.com/flak/post/signify">signify</a> or <a href="https://jedisct1.github.io/minisign/">minisign</a>, either of which you could quickly build in Go using <a href="https://godoc.org/golang.org/x/crypto/ed25519">x/crypto/ed25519</a>. I wrote one as a <a href="https://github.com/gtank/sshsign">party trick</a> last month – it's less than 200 lines of code and that includes some silly key parsing tricks.</p><p>These tools are extremely simple and robust because they only support one algorithm, lack state or any notion of a keyring, and are usually decoupled from complex messaging formats (which should be a separate concern from your signature cryptography). As a bonus they're mostly compatible with each other because the keys are all <a href="https://tools.ietf.org/html/rfc8032">EdDSA</a> keys. Need I even mention that EdDSA is much, much faster than RSA?</p><p>If you're a maintainer of self-serve packaging infrastructure or otherwise have more complex needs, you should take a look at <a href="https://theupdateframework.github.io/">TUF</a>. It's a modern toolkit meant to resist all kinds of update-related attacks that PGP signatures simply don't address. For an idea of how it works in practice, check out the designs for Python's package infrastructure (<a href="https://www.python.org/dev/peps/pep-0458/">PEP 458</a>, <a href="https://www.python.org/dev/peps/pep-0480/">PEP 480</a>). The <a href="https://github.com/theupdateframework/notary">Notary project</a> is a productionized and audited implementation.</p><h2 id="encrypting-data-blobs">Encrypting data blobs</h2><p><strong>Original need: </strong>You want to store individual pieces of data without making their contents accessible to anyone else on your system. For some reason this isn't built into operating systems yet, so programs like <a href="https://www.passwordstore.org">pass</a> use PGP.</p><p><strong>Modern alternative: </strong><a href="https://godoc.org/golang.org/x/crypto/nacl/box">nacl/box</a> and <a href="https://godoc.org/golang.org/x/crypto/nacl/secretbox">nacl/secretbox</a>. These are general-purpose replacements for encrypting any kind of data. They support public-key and secret-key encryption, respectively, and both use secure modern modes and ciphers.</p><p><a href="https://keybase.io">Keybase</a> made a very solid attempt to specify nacl in a storable message format with <a href="https://saltpack.org">saltpack</a>, which has a good Go implementation using the above x/crypto package. It works as a nearly drop-in replacement anywhere you were using ASCII-armored PGP data.</p><h2 id="sending-files-securely">Sending files securely</h2><p><strong>Original need: </strong>You have files that you want to send to another person, but you don't want the data to be visible in transit or stored in the cloud. For this, folks often attach an encrypted ZIP file to an email.</p><p><strong>Modern alternative: </strong><a href="https://magic-wormhole.readthedocs.io/en/latest/welcome.html">magic-wormhole</a>. If you need to send files to another person securely, use this. It's based on a modern cryptographic technique called <a href="https://blog.cryptographyengineering.com/2018/10/19/lets-talk-about-pake/">PAKE</a>, which basically means it keeps your data safe in transit while giving an attacker no chance to crack the password. It generates those passwords for you, and they're short, one-time-use combinations of three English words – all your recipient needs to do is enter the words. There's nothing to remember long-term and no account information to lose in a data breach. Wormhole also works through firewalls and optionally supports Tor.</p><p>We live in the future. There are better options than emailing encrypted files around.</p><h2 id="something-else">Something else?</h2><p>What's your lingering use case for PGP? Hit me up <a href="https://twitter.com/gtank__">on Twitter</a> or send me <a href="mailto:blog@gtank.cc?subject=I'm still using PGP">an email</a> and let's talk about getting you off PGP for good.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>