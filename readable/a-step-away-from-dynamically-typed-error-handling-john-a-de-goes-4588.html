<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Bifunctor IO: A Step Away from Dynamically-Typed Error Handling - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Bifunctor IO: A Step Away from Dynamically-Typed Error Handling - linksfor.dev(s)"/>
    <meta property="article:author" content="Twitter"/>
    <meta property="og:description" content="Too long has sloppy, imprecise error handling been the norm in effect systems. Time for precision&#x2014;time for bifunctor IO!"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://degoes.net/articles/bifunctor-io"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Bifunctor IO: A Step Away from Dynamically-Typed Error Handling</title>
<div class="readable">
        <h1>Bifunctor IO: A Step Away from Dynamically-Typed Error Handling</h1>
        <p>
by Twitter <br/>Reading time: 32-40 minutes        </p>
        <p><a href="http://degoes.net/articles/bifunctor-io">http://degoes.net/articles/bifunctor-io</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div itemprop="text">
      <p><em>Bifunctor IO</em>.</p>

<p>The subject is currently one of the hottest topics in the Scala functional programming community, inspiring both fear and awe in equal measure, as well as a proliferation of tickets, pull requests, and blog posts.</p>

<p>The occasion? Scalaz 8 IO has a new bifunctor design that challenges our assumptions about error handling in effect types, and functional programmers all over Scala‚Äôs community are trying to decide if and how this design helps us write better software.</p>

<p>Scalaz 8‚Äôs greenfield design presents a unique opportunity to re-examine every assumption about functional programming in Scala. The bifunctor design joins other innovations in the effect system (such as fine-grained interruption, resource safety, and fiber concurrency), as well as a <a href="https://www.slideshare.net/jdegoes/scalaz-8-a-whole-new-game">growing number of novel features</a> intended to radically improve FP in Scala.</p>

<p>Fibers and interruption were hotly debated when I first introduced them at Scala IO and <a href="https://www.youtube.com/watch?v=wi_vLNULh9Y">Scale by the Bay</a>, but now <a href="http://github.com/typelevel/cats-effect">even competitive libraries</a> have moved in the direction of Scalaz 8 IO.</p>

<p>What of bifunctor IO? Is this design going to change the way we manage errors in Scala effect types? Or will it be an interesting footnote in the history of functional programming in Scala?</p>

<p>As a contributor, I‚Äôm certainly biased, but I do believe bifunctor IO, which introduces typed errors, is here to stay, and that it‚Äôs going to greatly improve our ability to reason about our software. Bifunctor IO helps us describe the properties of our code through the type system, which is what drove many of us to statically-typed FP.</p>

<p>In this post, I‚Äôm going to give you an overview of the design and debunk some common myths. You can then decide for yourself if the increased precision is useful.</p>

<h2 id="what-is-io">What is IO?</h2>

<p>In many libraries, including Scalaz 7.2 and prior, <code>IO[A]</code> (or <code>Task[A]</code>) is an immutable data type that models an effectful program that runs forever, fails with a <code>Throwable</code>, or computes an <code>A</code>.</p>

<p>Like everything else in purely functional programming, <code>IO</code> is referentially-transparent‚Äîand all of its methods, excepting <code>unsafePerformIO</code> or its equivalent, are total, deterministic, and free of side effects.</p>

<p>You can use <code>IO</code> values to build other <code>IO</code> values, in the same way you can use <code>String</code> values to build other <code>String</code> values. It‚Äôs very similar to programming with immutable lists, maps, and other data structures common in functional programming, except instead of modeling data structures, the type models IO operations (so-called <em>effects</em>).</p>

<p>Inside your application‚Äôs main function, you convert <code>IO</code> into the effects that it models by <em>performing</em> those operations. In Scala, this execution function ships with every effect system, so you can run effects as easily as <code>unsafePerformIO(myProgram)</code>.</p>

<p>While ‚Äúrunning‚Äù an effect is not purely functional, for impure languages like Scala, it‚Äôs a necessary evil‚Äîat least (and ideally, at most) one place in your application.</p>

<p>I mentioned earlier that <code>IO[A]</code> can fail with a <code>Throwable</code> or produce an <code>A</code>. This bifurcation should remind you of <code>Either[E, A]</code>, and indeed, <code>IO</code> data types are effectful versions of <code>Either[E, A]</code>, where the <code>E</code> type is either untyped or loosely typed.</p>

<p>Effect types do not throw exceptions, of course. Their notion of failure is exactly like the notion of ‚Äúfailure‚Äù with <code>Either[E, A]</code>. Failure is a value and merely short-circuits the remainder of the computation unless the failure is handled. This behaves similar to an exception in all the ways that matter, but it‚Äôs just an ordinary value (semantically, anyway, if not always in the implementation).</p>

<p>All effect types ship with equivalents of the following two error management functions:</p>

<figure><pre><code data-lang="scala"><span>object</span> <span>IO</span> <span>{</span>
  <span>// A function defined on the `IO` companion object:
</span>  <span>def</span> <span>fail</span><span>[</span><span>A</span><span>](</span><span>t</span><span>:</span> <span>Throwable</span><span>)</span><span>:</span> <span>IO</span><span>[</span><span>A</span><span>]</span> <span>=</span> <span>???</span>
<span>}</span>
<span>trait</span> <span>IO</span><span>[</span><span>A</span><span>]</span> <span>{</span>
  <span>...</span>
  <span>// A method defined on the `IO` data type:
</span>  <span>def</span> <span>attempt</span><span>:</span> <span>IO</span><span>[</span><span>Throwable</span> <span>\/</span> <span>A</span><span>]</span> <span>=</span> <span>???</span>
  <span>...</span>
<span>}</span></code></pre></figure>

<p>where <code>type \/[A, B] = Either[A, B]</code>.</p>

<p>These two functions allow you to produce a value that describes a failed computation (<code>IO.fail</code>), as well as handle a value that describes a failed computation (<code>io.attempt</code>). They satisfy the obvious properties (e.g. <code>IO.fail(t).attempt === IO.point(\/.left(t))</code>, where <code>IO.point</code> lifts a pure <code>A</code> into <code>IO[A]</code>).</p>

<p>General-purpose effect types like <code>IO</code> are how we usually model effects in purely functional programs. Because <code>IO</code> can represent any type of effect and has reasonably high performance, it tends to be the foundation that functional programs are built on. While FP programs may use other effect types, those types usually end up translated into <code>IO</code>.</p>

<p>Lots of programming languages have <code>IO</code>-like types, including of course Haskell (from which the Scala effect types are inspired!), PureScript, TypeScript, Kotlin, and many other languages.</p>

<p>Interestingly, every <code>IO[A]</code> data type in all of these languages has a bifurcated model of computation: either the effect fails with some (dynamically-typed) error, or it succeeds with some value of type <code>A</code>.</p>

<h2 id="whats-bifunctor-io">What‚Äôs Bifunctor IO?</h2>

<p>I came up with a bifunctor design for IO in late 2017, and recently upgraded Scalaz 8 IO to support the new design. In this design, <code>IO[E, A]</code> is an immutable data type that models an effectful program that runs forever, fails with an <code>E</code>, or computes an <code>A</code>.</p>

<p><code>IO[E, A]</code> is a ‚Äúbifunctor‚Äù because you can define an instance of the type class <code>Bifunctor</code> (defined <a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Bifunctor.scala">here</a>), which lets you map over not just the value (<code>A =&gt; A2</code>), but also over the error (<code>E =&gt; E2</code>).</p>

<p>This bifunctor capability of the data type is essential, as it allows you to ‚Äúlift‚Äù programs that produce one class of errors into programs that produce another (typically larger) class of errors.</p>

<p>In bifunctor IO, the two core error management functions are nearly unchanged, but become significantly more general:</p>

<figure><pre><code data-lang="scala"><span>object</span> <span>IO</span> <span>{</span>
  <span>def</span> <span>fail</span><span>[</span><span>E</span>, <span>A</span><span>](</span><span>e</span><span>:</span> <span>E</span><span>)</span><span>:</span> <span>IO</span><span>[</span><span>E</span>, <span>A</span><span>]</span> <span>=</span> <span>???</span>
<span>}</span>
<span>trait</span> <span>IO</span><span>[</span><span>E</span>, <span>A</span><span>]</span> <span>{</span>
  <span>...</span>
  <span>def</span> <span>attempt</span><span>[</span><span>E2</span><span>]</span><span>:</span> <span>IO</span><span>[</span><span>E2</span>, <span>E</span> <span>\/</span> <span>A</span><span>]</span> <span>=</span> <span>???</span>
  <span>...</span>
<span>}</span></code></pre></figure>

<p>Instead of being forced to fail an <code>IO</code> with a poorly typed <code>Throwable</code>, you can create <code>IO</code> values that model failure <em>for any error type at all</em>, including strings, numbers, ADTs, or even type-level sets, all of which make sense in different circumstances.</p>

<p>Most functional programs will mix and match many different types of errors at different levels of the application, varying them in response to the local needs of each part of the application.</p>

<p>The <code>attempt</code> function becomes polymorphic in the new error type, allowing you to choose any type of error. This represents a compile-time guarantee that the attempted <code>IO</code> cannot fail, because there is no way it can summon a value of an arbitrary type <code>E2</code> into existence. You can easily choose the error type of an attempted effect to be <code>Nothing</code> or equivalent (<code>Void</code> in Scalaz, Haskell, PureScript, and others), thus proving that failure is impossible.</p>

<p>The power of this approach can be demonstrated in the following snippet:</p>

<figure><pre><code data-lang="scala"><span>def</span> <span>right</span><span>[</span><span>A</span><span>](</span><span>v</span><span>:</span> <span>Void</span> <span>\/</span> <span>A</span><span>)</span><span>:</span> <span>A</span> <span>=</span>
  <span>v</span><span>.</span><span>fold</span><span>(</span><span>_</span><span>.</span><span>absurd</span><span>[</span><span>A</span><span>])(</span><span>identity</span><span>)</span>

<span>val</span> <span>io</span><span>:</span> <span>IO</span><span>[</span><span>E</span>, <span>A</span><span>]</span> <span>=</span> <span>???</span>

<span>val</span> <span>attempt1</span><span>:</span> <span>IO</span><span>[</span><span>Void</span>, <span>E</span> <span>\/</span> <span>A</span><span>]</span> <span>=</span> <span>io</span><span>.</span><span>attempt</span><span>[</span><span>Void</span><span>]</span>
<span>val</span> <span>attempt2</span><span>:</span> <span>IO</span><span>[</span><span>Void</span>, <span>Void</span> <span>\/</span> <span>(</span><span>E</span> <span>\/</span> <span>A</span><span>)]</span> <span>=</span> <span>attempt1</span><span>.</span><span>attempt</span><span>[</span><span>Void</span><span>]</span>

<span>val</span> <span>attempt3</span><span>:</span> <span>IO</span><span>[</span><span>Void</span>, <span>E</span> <span>\/</span> <span>A</span><span>]</span> <span>=</span> <span>attempt2</span><span>.</span><span>map</span><span>(</span><span>right</span><span>)</span></code></pre></figure>

<p>This snippet proves the intuitive fact that repeated attempts cannot fail. The fact that you can express this guarantee at compile-time, using types that communicate rich information to developers, is quite remarkable and powerful.</p>

<p>While error management changes only in minor ways, the resulting ramifications to the error model are profound. Before I explore them, however, we must talk about the different types of errors.</p>

<h2 id="types-of-errors">Types of Errors</h2>

<p>There are two classes of errors in applications:</p>

<ol>
  <li><strong>Recoverable Errors</strong>. Recoverable errors refer to the errors we expect to happen occasionally. For example, when we perform an HTTP request, we expect that sometimes, it will not succeed because the server is down or there are network issues. Because we expect these errors to happen, we want to build our code in a way that acknowledges the failure scenarios. We want graceful fallbacks at some level of the application (perhaps not locally, but at the edges).</li>
  <li><strong>Non-Recoverable Errors</strong>. Non-recoverable errors refer to the errors we do not expect to happen. For example, if a user has configured the JRE with 10k of memory for the stack, then a lot of ordinary (non-recursive) code will stack overflow, producing a <code>StackOverflowError</code>. This is not a normal error we expect to happen, nor is there a sane way to recover from it.</li>
</ol>

<p>In Java, the convention is to use <code>Exception</code> for recoverable errors, and <code>Error</code> for non-recoverable errors. Both of these are subclasses of <code>Throwable</code>, which is the only error type supported by the JVM.</p>

<p>In languages like Erlang and C, recoverable errors are modeled with ordinary values, and non-recoverable errors do not have an explicit representation and resolve outside application logic (with a crash in Erlang, and with undefined behavior in C).</p>

<p>The distinction between failure scenarios that we expect to happen and failure scenarios that we do not expect to happen is <em>extremely important</em>:</p>

<ul>
  <li>Failure scenarios that we expect to happen can be recovered from in application code. In statically-typed functional programming, we have the ability to guarantee at compile-time that expected failures are handled, or at least tracked, so we know the consequences of interacting with such code.</li>
  <li>Failure scenarios that we do <em>not</em> expect to happen cannot be sanely recovered from, and the reason is precisely this: we did <em>not</em> expect these errors, so we do not know <em>where</em> they will occur, <em>what</em> these errors will be, or whether it makes sense to continue, and if so, what remedial actions permit a well-defined recovery.</li>
</ul>

<p>Attempting to recover from an unexpected error puts your program into an undefined state: it is undefined precisely because you do not know where the error occurred, which means you don‚Äôt know the state of the application or its external environment; and you do not know what the error is, which means you don‚Äôt know if and how to recover.</p>

<p>Non-recoverable errors are almost always defects, but sometimes they occur for catastrophic reasons outside the direct control of the programmer (such as running out of memory). A C program may overwrite an arbitrary piece of memory (defect), a Java program may try to allocate more memory than reserved for the heap (catastrophic), or an Erlang actor may make a false assumption about data (defect).</p>

<p>The distinction between recoverable and non-recoverable errors fully informs the design of the Scalaz 8 IO error model. In the next section, I‚Äôll introduce this error model and talk about its implications.</p>

<h2 id="a-principled-error-model">A Principled Error Model</h2>

<p><img src="http://degoes.net/images/scalaz-8-error-model.png" alt="Scalaz 8 Error Model"></p>

<p>In the Scalaz 8 IO error model, the distinction between recoverable and non-recoverable errors is explicit. This distinction forms the foundation of the error model.</p>

<p>Recoverable errors are statically-typed, and modeled by the <code>E</code> type parameter in <code>IO[E, A]</code>.</p>

<p>Effects of type <code>IO[E, A]</code> can fail for any <code>E</code>, and can be recovered from to yield <code>IO[E2, E \/ A]</code>, for any type <code>E2</code>, including uninhabited types like <code>Nothing</code> or Scalaz‚Äôs <code>Void</code> type. The type system tells you <em>if</em> and <em>how</em> an effect can fail.</p>

<p>Non-recoverable errors are <em>weakly typed</em>, and include the full range of runtime errors on the JVM, which is any type that extends <code>Throwable</code>. Execution of any <code>IO[E, A]</code> may fail due to some non-recoverable error‚Äîprobably a defect, but possibly a catastrophic error outside the control of the program.</p>

<p>Non-recoverable errors are, as their name suggests, not recoverable, which is the case in languages like C and Erlang. If one of these errors occurs, the fiber running the effect will be terminated.</p>

<p>This error model implies that, aside from non-termination, there are exactly three possible outcomes from running an effect <code>IO[E, A]</code>:</p>

<ul>
  <li>The effect fails due to an unhandled <code>E</code> created with <code>IO.fail</code>.</li>
  <li>The effect is terminated due to a non-recoverable <code>Throwable</code>.</li>
  <li>The effect computes an <code>A</code>.</li>
</ul>

<p>In the sections that follow, I‚Äôll dive into specifics of the error model by covering some of the practical benefits to developers.</p>

<h3 id="benefit-1-no-dynamically-typed-errors">Benefit 1: No Dynamically-Typed Errors</h3>

<p>The most distinguishing feature of the error model is that it allows us to move away from dynamically-typed errors.</p>

<p>Programming with <code>IO[A]</code> provides no compile-time guarantees about failure. From the type alone, you must assume that all effects may fail for any reason at any time, even if you‚Äôve already handled them or they can only fail in specific ways.</p>

<p>With <code>IO[E, A]</code>, you know all possible (recoverable) failure scenarios:</p>

<ul>
  <li>If you handle some failure scenarios but not others, you can express this in the type by choosing a suitable sum type for <code>E</code>.</li>
  <li>If the effect cannot fail, you can express this with <code>IO[Void, A]</code> or equivalent.</li>
  <li>If the effect may truly fail for any reason, then you can express this with <code>IO[Throwable, E]</code> (or even, heaven forbid, <code>IO[AnyRef, E]</code>).</li>
</ul>

<p>For one practical application among many, suppose that you want your REST API to return errors in the JSON format. In this case, you can simply express the requirement in the type:</p>

<figure><pre><code data-lang="scala"><span>def</span> <span>serve</span><span>(</span><span>handler</span><span>:</span> <span>HTTPRequest</span> <span>=&gt;</span> <span>IO</span><span>[</span><span>Void</span>, <span>JSON</span><span>])</span></code></pre></figure>

<p>The type here demands that the handler you pass to the <code>serve</code> function handle all its own errors and encode them into JSON. Now you don‚Äôt have to worry about code forgetting to handle some error and then not knowing how to transcribe the error into the required JSON format.</p>

<p>As another example, suppose we have an evaluator in a spreadsheet application for some domain-specific scripting language. In this case, we want to know precisely how evaluation may fail, because failure is expected and we must handle different failures in different ways.</p>

<p>In this case, we can model the evaluator as follows:</p>

<figure><pre><code data-lang="scala"><span>sealed</span> <span>trait</span> <span>EvaluationError</span>
<span>case</span> <span>class</span> <span>ParseError</span><span>(</span><span>line</span><span>:</span> <span>Int</span><span>,</span> <span>expected</span><span>:</span> <span>List</span><span>[</span><span>Symbol</span><span>])</span> <span>extends</span> <span>EvaluationError</span>
<span>case</span> <span>class</span> <span>TypeError</span><span>(</span><span>expected</span><span>:</span> <span>Type</span><span>,</span> <span>actual</span><span>:</span> <span>Type</span><span>)</span> <span>extends</span> <span>EvaluationError</span>
<span>case</span> <span>class</span> <span>RuntimeError</span><span>(</span><span>function</span><span>:</span> <span>String</span><span>)</span> <span>extends</span> <span>EvaluationError</span>

<span>def</span> <span>evaluate</span><span>(</span><span>script</span><span>:</span> <span>String</span><span>)</span><span>:</span> <span>IO</span><span>[</span><span>EvaluationError</span>, <span>Unit</span><span>]</span> <span>=</span> <span>???</span></code></pre></figure>

<p>Both statically-typed values <em>and</em> statically-typed errors let us use the compiler to prove properties of our programs. In the case of statically-typed errors, we can prove that effects only fail in specific ways, or that they don‚Äôt fail at all.</p>

<p>Further, we can vary our propositions in different parts of our program, because we have the flexibility to vary the type of error.</p>

<h3 id="feature-2-no-lost-errors">Feature 2: No Lost Errors</h3>

<p>Most programming languages have lossy error models. By lossy, I mean it is possible for exceptions to be swallowed.</p>

<p>In the following snippet, two errors will be swallowed:</p>

<figure><pre><code data-lang="scala"><span>try</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>try</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>"e1"</span><span>)</span>
    <span>finally</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>"e2"</span><span>)</span>
  <span>}</span> <span>finally</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>"e3"</span><span>)</span>
<span>}</span> <span>catch</span> <span>{</span>
  <span>case</span> <span>e</span> <span>:</span> <span>Error</span> <span>=&gt;</span> <span>println</span><span>(</span><span>e</span><span>)</span>
<span>}</span></code></pre></figure>

<p>Most Scala (or Java) developers don‚Äôt know which error will be caught and reported in the outermost <code>catch</code> block, but one fact is clear from the structure: at most one exception will be reported. The other two will be lost forever.</p>

<p>Scalaz 8 IO dramatically improves on this broken error model by <em>guaranteeing</em> that no errors are lost, whether they are recoverable errors modeled with <code>E</code>, or non-recoverable errors that result from defects or catastrophic runtime errors.</p>

<p>This guarantee is provided with a <em>hierarchy of supervisors</em>. A <em>supervisor</em> is just a function <code>Throwable =&gt; IO[Void, Unit]</code>, which will receive all unhandled errors from a fiber.</p>

<p>The root fiber, which runs the application <code>main</code> function, has a default supervisor, which can be overridden. The default supervisor prints the stack trace of the error to the console.</p>

<p>Other supervisors are specified by the application when forking an effect. For example, if you want to run some work in a separate fiber, you call <code>fork0</code> and specify the supervisor for the fiber:</p>

<figure><pre><code data-lang="scala"><span>for</span> <span>{</span>
  <span>fiber</span> <span>&lt;-</span> <span>work</span><span>.</span><span>fork0</span><span>(</span><span>t</span> <span>=&gt;</span> <span>logError</span><span>(</span><span>t</span><span>))</span>
  <span>...</span>
<span>}</span> <span>yield</span> <span>()</span></code></pre></figure>

<p>In this example, the supervisor merely logs the error to a file, to ensure if there is a defect in our program, we know that it happened. Other sensible choices include logging to a remote server, restarting a fiber, or returning diagnostic information in an API.</p>

<p>Supervisors are hierarchical. If you don‚Äôt specify a supervisor when forking an effect, then it will inherit the supervisor of the fiber that performed the forking.</p>

<p>The supervisor hierarchy provides a modular way of dealing with unhandled errors. Lower levels of an application can decide how to supervise their children, or simply delegate to the parent.</p>

<h3 id="benefit-3-no-resource-leaks">Benefit 3: No Resource Leaks</h3>

<p>Scalaz 8 IO has a built-in primitive called <code>bracket</code>, which is a more structured version of <code>try</code> / <code>finally</code>.</p>

<p>The <code>bracket</code> primitive allows you to acquire a resource in one effect, use the resource in another effect, and finally, close the resource in a different effect.</p>

<p>Using this primitive is quite simple:</p>

<figure><pre><code data-lang="scala"><span>openFile</span><span>(</span><span>"data.csv"</span><span>).</span><span>bracket</span><span>(</span><span>closeFile</span><span>(</span><span>_</span><span>))</span> <span>{</span> <span>handle</span> <span>=&gt;</span>
  <span>// Use resource in here...
</span><span>}</span></code></pre></figure>

<p>Resources acquired with <code>bracket</code> will <em>always</em> be released, even if the body fails due to an unhandled <code>E</code>, a defect in the code, fiber interruption, or a catastrophic external error.</p>

<p>Resource safety lets you build bullet-proof, long-lived applications that are resilient to failures, whether expected or unexpected.</p>

<h3 id="benefit-4-no-changes-needed">Benefit 4: No Changes Needed</h3>

<p>A remarkable property of the Scalaz 8 <code>IO</code> bifunctor design is that it generalizes over both the <em>existing</em> dynamically-typed error effect types and so-called <em>non-exceptional</em> effect types.</p>

<p>Existing effect types may fail at any time, for any reason. To model this type of effect type, we can use the following type alias:</p>

<figure><pre><code data-lang="scala"><span>type</span> <span>Task</span><span>[</span><span>A</span><span>]</span> <span>=</span> <span>IO</span><span>[</span><span>Throwable</span>, <span>A</span><span>]</span></code></pre></figure>

<p>With one notable exception, there is <em>no difference</em> between this definition of <code>Task</code> and other dynamically-typed error effects. This is the preferred migration option if you are moving to Scalaz 8 from Scalaz 7.2 <code>IO</code> or <code>Task</code>, Monix <code>Task</code>, or cats-effect <code>IO</code>.</p>

<p>The only difference relates to how <em>defects</em> are handled. Older error models conflate recoverable errors with non-recoverable errors, which ‚Äúworks‚Äù because they fix the error type to <code>Throwable</code>. These types encourage users to write code like <code>IO.point(42).map(_ =&gt; throw Error("Surprise!")).attempt</code>.</p>

<p>In Scalaz 8 IO, defects in your code cannot be ‚Äúcaught‚Äù, similar to Erlang, C, and many other real-world programming languages. Since we use values to represent failure in functional programming (in the case of <code>IO</code>, values constructed with <code>IO.fail</code>), throwing exceptions from pure code is considered a defect, and the fiber running the effect will be terminated.</p>

<p>The cause for the termination will, of course, be passed to the fiber‚Äôs supervisor, so it can be logged or otherwise made visible. Or, depending on the context, you might decide to restart a fiber that fails due to a defect, similar to supervision in actor systems.</p>

<p>Aside from this one difference, users who prefer only using <code>Throwable</code>, or who wish to introduce typed errors selectively, can simply use <code>IO[Throwable, A]</code> as their default effect type.</p>

<p>No changes to error handling are necessary, because the bifunctor design completely subsumes older designs.</p>

<h3 id="benefit-5-no-errors">Benefit 5: No Errors</h3>

<p>As discussed previously, <code>IO</code> can also model effects that cannot fail. The following snippet creates a type synonym to do just this:</p>

<figure><pre><code data-lang="scala"><span>type</span> <span>Unexceptional</span><span>[</span><span>A</span><span>]</span> <span>=</span> <span>IO</span><span>[</span><span>Void</span>, <span>A</span><span>]</span></code></pre></figure>

<p>Effects of type <code>Unexceptional[A]</code> cannot (recoverably) fail, meaning if they fail, it‚Äôs because of a non-recoverable defect in your code or because of a catastrophic error like <code>OutOfMemoryError</code>.</p>

<p>As you can see, <code>IO[E, A]</code> generalizes over both non-exceptional effect types and dynamically-typed effect types. In other words, the bifunctor design of Scalaz 8 IO is <em>strictly more expressive</em> than all other effect types. Other effect types fall out elegantly as special cases.</p>

<p>Developers who complain about the bifunctor design are really complaining because they have <em>gained</em> the ability to be more precise, not because they are <em>required</em> to be more precise. This is rather like complaining about optional type annotations‚Äîif you don‚Äôt like them, don‚Äôt use them!</p>

<p>The alternative to the bifunctor design is to introduce special-case types for non-exceptional or strongly-typed effect types. For example, cats-effect will probably get <code>UIO</code>, which is a non-exceptional effect type, and may at some point get a bifunctor <code>BIO</code>. Such proliferation of effect types (with massive redundancy in the implementations!) is unnecessary with the bifunctor design, because a single generalized type <code>IO[E, A]</code> is capable of modeling everything.</p>

<h2 id="debunking-myths-of-bifunctor-io">Debunking Myths of Bifunctor IO</h2>

<p>The bifunctor design for the Scalaz 8 IO effect type is so new, there‚Äôs not much documentation on the subject. Up until recently, the main source of documentation has been the code itself! As a result, the design has been subject to a lot of speculation.</p>

<p>In the next sections, I want to debunk what I perceive to be common myths around the bifunctor design. Arguably, some of these myths are instead <em>strong biases</em> toward dynamically-typed error handling, but most of you who read this blog probably prefer static types, and will share my own bias in this regard.</p>

<h3 id="myth-1-composition-destroys-specific-error-types">Myth 1: Composition Destroys Specific Error Types</h3>

<p>This myth states that composing two effects <code>IO[E1, A]</code> and <code>IO[E2, B]</code> will result in an error type that erases the distinction between <code>E1</code> and <code>E2</code>. Stated simply, <em>composing effects leads to a loss of precise error types</em>.</p>

<p>This myth is false because users themselves define how error types compose, and they are not required to use <em>common supertype</em> composition. For example, I can easily combine two effects <code>IO[E1, A]</code> and <code>IO[E2, B]</code> with different errors in a lossless way using a disjunction type, such as <code>E1 \/ E2</code>.</p>

<p>This technique is demonstrated in the following snippet:</p>

<figure><pre><code data-lang="scala"><span>val</span> <span>io</span><span>:</span> <span>IO</span><span>[</span><span>E1</span> <span>\/</span> <span>E2</span>, <span>(</span><span>A</span>, <span>B</span><span>))</span> <span>=</span>
  <span>for</span> <span>{</span>
    <span>a</span> <span>&lt;-</span> <span>op1</span><span>.</span><span>leftMap</span><span>(\/.</span><span>left</span><span>)</span>
    <span>b</span> <span>&lt;-</span> <span>op2</span><span>.</span><span>leftMap</span><span>(\/.</span><span>right</span><span>)</span>
  <span>}</span> <span>yield</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span></code></pre></figure>

<p>In general, error types always compose in a completely lossless way using sum types.</p>

<p>In some cases, you may want a built-in sum type like <code>\/</code> (<code>Either</code>), as shown in the above snippet. In other cases, it is more convenient to define a custom sum type, such as the previously introduced <code>EvaluationError</code>:</p>

<figure><pre><code data-lang="scala"><span>sealed</span> <span>trait</span> <span>EvaluationError</span>
<span>case</span> <span>class</span> <span>ParseError</span><span>(</span><span>line</span><span>:</span> <span>Int</span><span>,</span> <span>expected</span><span>:</span> <span>List</span><span>[</span><span>Symbol</span><span>])</span> <span>extends</span> <span>EvaluationError</span>
<span>case</span> <span>class</span> <span>TypeError</span><span>(</span><span>expected</span><span>:</span> <span>Type</span><span>,</span> <span>actual</span><span>:</span> <span>Type</span><span>)</span> <span>extends</span> <span>EvaluationError</span>
<span>case</span> <span>class</span> <span>RuntimeError</span><span>(</span><span>function</span><span>:</span> <span>String</span><span>)</span> <span>extends</span> <span>EvaluationError</span></code></pre></figure>

<p>Others still may prefer to use type-level sets to represent errors, because this makes it very easy to add and subtract errors, while still providing the ability to handle some or all errors.</p>

<p>The <a href="https://twitter.com/propensive/status/993422307388424192">Mitigation library</a> by <a href="http://twitter.com/propensive">Jon Pretty</a>, based on Totalitarian, provides a convenient and powerful solution for managing sets of errors. Look for <code>scalaz-mitigation</code> in the near future! (Bug Jon and me about it until we do something!)</p>

<h3 id="myth-2-you-dont-recover-from-errors-often">Myth 2: You Don‚Äôt Recover From Errors Often</h3>

<p>This myth states that typed errors are not useful because most code doesn‚Äôt recover from most types of errors.</p>

<p>This is only true when recoverable errors are conflated with non-recoverable errors. If an error is not expected, and therefore cannot be recovered from, then it will neither appear in any type signature, nor affect the development experience.</p>

<p>For example, take the following snippet of code:</p>

<figure><pre><code data-lang="scala"><span>for</span> <span>{</span>
  <span>r1</span> <span>&lt;-</span> <span>op1</span>
  <span>r2</span> <span>&lt;-</span> <span>op2</span>
  <span>r3</span> <span>&lt;-</span> <span>op3</span>
<span>}</span> <span>yield</span> <span>r1</span> <span>+</span> <span>r2</span> <span>+</span> <span>r3</span></code></pre></figure>

<p>If <code>op1</code>, <code>op2</code>, and <code>op3</code> do not fail in recoverable ways, then they will have type <code>IO[Void, A]</code> (for some type <code>A</code>), which means they compose with effects of any other error type, and we know from looking at the type signature that these operations do not fail.</p>

<p>Only recoverable errors, which we expect to happen, and which we need to deal with in our programs, are reflected in the error type.</p>

<h3 id="myth-3-the-error-type-is-an-encapsulation-leak">Myth 3: The Error Type is an Encapsulation Leak</h3>

<p>This myth states that having statically-typed errors leaks implementation details. This is not true at all‚Äîin fact, it is poor API design that leaks implementation details.</p>

<p>Let‚Äôs take the following API:</p>

<figure><pre><code data-lang="scala"><span>def</span> <span>read</span><span>(</span><span>id</span><span>:</span> <span>String</span><span>)</span><span>:</span> <span>IO</span><span>[</span><span>FileNotFoundException</span>, <span>ByteVector</span><span>]</span></code></pre></figure>

<p>This API states that <code>read</code> can fail with <code>FileNotFoundException</code>. However, we may want to abstract over different ways of reading a resource (in-memory versus over HTTP, for example). If we want to abstract over reading, then <code>FileNotFoundException</code> is a poor way to represent failure. Instead, we should design the API as follows:</p>

<figure><pre><code data-lang="scala"><span>def</span> <span>read</span><span>(</span><span>id</span><span>:</span> <span>String</span><span>)</span><span>:</span> <span>IO</span><span>[</span><span>ResourceNotFound</span>, <span>ByteVector</span><span>]</span></code></pre></figure>

<p>Or possibly even more simply:</p>

<figure><pre><code data-lang="scala"><span>def</span> <span>read</span><span>(</span><span>id</span><span>:</span> <span>String</span><span>)</span><span>:</span> <span>IO</span><span>[</span><span>Void</span>, <span>Option</span><span>[</span><span>ByteVector</span><span>]]</span></code></pre></figure>

<p>Whether or not an effect may fail in a recoverable way is part of an API‚Äôs public contract, and should be reflected clearly in the types.</p>

<p>API design requires skill, and types alone cannot stop us from making bad design choices. Even without typed errors, we are free to design APIs that leak implementation details.</p>

<p>For example, consider the following API:</p>

<figure><pre><code data-lang="scala"><span>def</span> <span>resolve</span><span>(</span><span>path</span><span>:</span> <span>String</span><span>)</span><span>:</span> <span>Task</span><span>[</span><span>File</span><span>]</span></code></pre></figure>

<p>This API resolves a <code>path</code> to a <code>File</code> resource (<code>java.util.File</code>). However, <code>File</code> only represents local files, and could easily be generalized to <code>URI</code> or something similar. If we must abstract over different resource locations, then <code>File</code> is a poor choice.</p>

<p>No one would suggest that because it is possible to return <code>File</code>, and that <code>File</code> leaks implementation details, we should therefore use <code>AnyRef</code> for all return values so we can let implementations vary.</p>

<p>In the same way, just because it is possible to leak implementation details in the type of an error channel, doesn‚Äôt mean we should use dynamically-typed errors.</p>

<p>There is no connection whatsoever between typed errors and the leaking of implementation details. They are completely orthogonal.</p>

<h3 id="myth-4-it-pushes-complexity-to-the-user">Myth 4: It Pushes Complexity to the User</h3>

<p>This myth states that using typed errors pushes ‚Äúcomplexity‚Äù to the user. The myth conflates <em>inherent complexity</em> with <em>incidental complexity</em>.</p>

<p><em>Inherent complexity</em> is complexity that is inherent to the task of properly modeling a domain. For example, if we wish to precisely model the domain of JSON values, then we <em>must</em> have a sum type that supports boolean, null, numbers, arrays, and objects. Further, our number type must support arbitrary precision.</p>

<figure><pre><code data-lang="scala"><span>sealed</span> <span>trait</span> <span>JSON</span>
<span>case</span> <span>object</span> <span>JNull</span> <span>extends</span> <span>JSON</span>
<span>case</span> <span>class</span> <span>JBool</span><span>(</span><span>value</span><span>:</span> <span>Boolean</span><span>)</span> <span>extends</span> <span>JSON</span>
<span>case</span> <span>class</span> <span>JNum</span><span>(</span><span>value</span><span>:</span> <span>BigDecimal</span><span>)</span> <span>extends</span> <span>JSON</span>
<span>case</span> <span>class</span> <span>JArr</span><span>(</span><span>value</span><span>:</span> <span>List</span><span>[</span><span>JSON</span><span>])</span> <span>extends</span> <span>JSON</span>
<span>case</span> <span>class</span> <span>JObj</span><span>(</span><span>value</span><span>:</span> <span>Map</span><span>[</span><span>String</span>, <span>JSON</span><span>])</span> <span>extends</span> <span>JSON</span></code></pre></figure>

<p>This is complexity, but it is inherent complexity because it is intrinsic to the problem of precisely modeling JSON values.</p>

<p><em>Incidental complexity</em> is complexity that arises not because of the problem domain, but because of implementation decisions that could have been otherwise without sacrificing correctness. For example, dependency injection frameworks have much <em>incidental complexity</em>‚Äîthey are a very complex way of passing arguments to functions.</p>

<p>Precisely modeling data types always comes with some cost due to <em>inherent complexity</em>. Stated differently, making illegal states unrepresentable requires work. If we want to precisely describe <em>if</em> and <em>how</em> our effects may fail, then this, too, will require work, but this complexity is inherent to precise error handling.</p>

<p>A design like Scalaz 8 <code>IO</code> lets you choose how precise you want to be. It has the flexibility to describe infallible effects or effects that fail in only pre-defined ways, but you only need to use this flexibility when you decide the precision adds sufficient value.</p>

<p>Legacy designs remove the choice from you, forcing you into a dynamically-typed error model that offers no ability to make illegal (error) states unrepresentable. They are antithetical to the goals that drive us to statically-typed functional programming.</p>

<h3 id="myth-5-the-bifunctor-io-doesnt-reflect-the-runtime">Myth 5: The Bifunctor IO Doesn‚Äôt Reflect the Runtime</h3>

<p>This myth states that any effect type should ‚Äúreflect the runtime‚Äù, which is vague enough to warrant <a href="https://twitter.com/djspiewak/status/983805298526699520">sourcing the claim</a>:</p>

<blockquote>
  <p>‚ÄúIO needs to reflect and describe the capabilities of the runtime, for good or for bad. All it takes is an ‚Äòinnocent‚Äô throw to turn it all into a lie, and you can‚Äôt prevent that.‚Äù</p>
</blockquote>

<p>This is an argument to catch defects, such as exceptions thrown from pure code, so users can attempt recovery. It‚Äôs also an argument to fix the failure type to <code>Throwable</code>, because this is what the JVM does.</p>

<p>The argument is incoherent, as can be seen by examining the implications of consistently ‚Äúreflecting the runtime‚Äù.</p>

<p>The JVM does not support parametric polymorphism, which means the <code>A</code> in <code>IO[A]</code> is erased at runtime (equivalent to <code>IO[AnyRef]</code>). Because of this type erasure and the lack of type safety in Scala, this means having a value of type <code>IO[A]</code> is no guarantee the <code>IO</code> value will actually compute an <code>A</code>.</p>

<p>To ‚Äúreflect the runtime‚Äù in the <code>IO</code> data type, it would be necessary to avoid using parametric polymorphism entirely, because this feature is not supported by the JVM, and it‚Äôs impossible to enforce that <code>IO[A]</code> actually produces anything of type <code>A</code>. After all, <em>reflecting the runtime</em> would argue, it just takes one innocent, accidental coercion to turn <code>IO[A]</code> into a lie, and you can‚Äôt prevent that!</p>

<p>Additionally, the JVM uses <code>null</code> for optionality, not <code>Option</code> or <code>Maybe</code>. <em>Reflecting the runtime</em> would argue for embracing <code>null</code> for optionality, and expecting <code>null</code> everywhere in the interface to <code>IO</code>.</p>

<p>Doing functional programming, <a href="http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.pdf">even in languages like Haskell</a>, requires a set of assumptions. In Scala, these assumptions include no runtime reflection, no coercion, no exceptions, no side effects, no null, and so forth.</p>

<p>Without these assumptions (often called the <a href="http://www.lihaoyi.com/post/StrategicScalaStylePracticalTypeSafety.html#scalazzi-scala">Scalazzi subset</a> of Scala, after Scalaz), you would program fearfully, constantly checking the runtime class of every value, testing to make sure no values are null, obsessively try/catching, and fearing that a function like <code>def identity[A](a: A): A</code> may generate a novel <code>A</code> through runtime reflection.</p>

<p>Principled development requires sane assumptions, and pragmatic development requires we know when these assumptions go wrong. The Scalaz 8 error model provides both in a single package, because even though the design assumes you work in Scalazzi, if you don‚Äôt, your defects will be captured and reported to supervisors.</p>

<h3 id="myth-6-bifunctor-io-doesnt-let-you-use-impure-code">Myth 6: Bifunctor IO Doesn‚Äôt Let You Use Impure Code</h3>

<p>This myth states that because the bifunctor design doesn‚Äôt automatically catch defects, you can‚Äôt use the effect type with Java code or impure Scala code.</p>

<p>This is not true at all. All code, including exception throwing, impure code, can be trivially imported into <code>IO</code>. In fact, there are three utility functions in Scalaz 8 that do just this:</p>

<ul>
  <li><code>def syncThrowable[A](eff: =&gt; A): IO[Throwable, A]</code> ‚Äî This function imports code that may throw <code>Throwable</code> values, properly translating them into <code>IO.fail</code> values.</li>
  <li><code>def syncException[A](eff: =&gt; A): IO[Exception, A]</code> ‚Äî This function imports code that may throw <code>Exception</code> values, properly translating them into <code>IO.fail</code> values.</li>
  <li><code>def syncCatch[E, A](eff: =&gt; A)(pf: PartialFunction[Throwable, E]): IO[E, A]</code> ‚Äî This function imports code that may throw a user-defined range of errors, properly translating them into <code>IO.fail</code> values.</li>
</ul>

<p>These functions let you safely interact with dysfunctional code, which performs side-effects and throws exceptions. You can import this code into pure values, which can interface with your functional code.</p>

<p>Wrapping unsafe code with <code>Try</code>, to safely convert exceptions into values, is something that many Scala developers are already doing. With Scalaz 8, the method you use changes, but not much else.</p>

<h3 id="myth-7-bifunctor-io-is-just-eithert">Myth 7: Bifunctor IO Is Just EitherT</h3>

<p>This myth states that bifunctor IO is unnecessary, since we can already achieve the same benefits by stacking the <code>EitherT</code> monad transformer on top of ordinary <code>IO</code>.</p>

<p>There are two flaws in this argument:</p>

<ol>
  <li>For older effect types <code>F[_]</code> (such as Monix <code>Task</code>, cats-effect <code>IO</code>, and Scalaz 7.2 <code>IO</code> / <code>Task</code>), <code>EitherT[IO, E, ?]</code> has two error channels, overlapping instances for <code>MonadError</code> (one having an error type fixed to <code>Throwable</code>), two conflicting ways of failing, and two conflicting ways of recovering from failures. Contrast this to <code>IO[E, A]</code>, which has a single error channel.</li>
  <li>Scalaz 8 bifunctor IO is functionally equivalent to <code>EitherT[UIO, E, A]</code> for some infallible effect type <code>UIO</code>. Although Scalaz 8 IO could be redesigned to be infallible, this would mean as much as a <em>5x performance penalty</em> for recapturing error handling using an <code>EitherT</code> monad transformer. As discussed in my <a href="http://degoes.net/articles/effects-without-transformers">last blog post</a>, monad transformers are not practical in Scala.</li>
</ol>

<p>Scalaz 8 IO brings something genuinely new to the table over <code>EitherT</code>: a clean, typed, single error channel, and high-performance, wrapped in a package that generalizes over all existing effect types.</p>

<h2 id="final-words">Final Words</h2>

<p>Like other changes in Scalaz 8, including the fiber concurrency model, fine-grained interruption, and resource safety, the bifunctor design of <code>IO</code> requires rethinking assumptions.</p>

<p>This new model doesn‚Äôt <em>require</em> you to be more precise, since you‚Äôre free to stick with <code>Throwable</code> for all your errors. But it does <em>empower</em> you to describe failure scenarios precisely, and vary <em>if</em> and <em>how</em> effects fail at different levels of your application.</p>

<p>Benefits of the error model are many, and include being able to model infallible effects (non-exceptional <code>IO</code>), use effects the way you‚Äôre familiar with (using <code>Throwable</code> everywhere) so you can gradually incorporate typed errors wherever useful, guarantee no resource leaks (even in the event of non-recoverable errors), never lose any errors (unlike other error models), and have strong, compile-time guarantees about <em>if</em> and <em>how</em> your effects can fail.</p>

<p>While there are myths out there about the new bifunctor design, this is expected since there is a scarcity of documentation. Without good documentation, there will always be questions about how a new design works or what the tradeoffs are. Hopefully this blog post succeeds in making the bifunctor design more accessible.</p>

<p>If I‚Äôve convinced you the bifunctor design has value, vote with your feet: support projects like Scalaz 8 IO, encourage contributions like Luka Jacobowitz‚Äôs <a href="https://github.com/LukaJCB/cats-bio">bifunctor IO</a>, and contribute issues and pull requests to your favorite effect type.</p>

<p>Scalaz 8 IO may be the first one to adopt this design, but from the looks of things, it‚Äôs not the last. I greatly look forward to seeing others adopt and improve upon the design, to the benefit of the entire Scala functional programming community.</p>

      <hr>
      
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>