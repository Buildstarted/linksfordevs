<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using HTTP Request Routes, Request Body, and Query string parameters for Authorization in ASP.NET Core -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Using HTTP Request Routes, Request Body, and Query string parameters for Authorization in ASP.NET Core</h1><div><div class="entry-content"><p>This post shows how HTTP route parameters, a HTTP request body or HTTP request query string parameters can be used for authorization in ASP.NET Core. </p><p><strong>Code:</strong><a href="https://github.com/damienbod/AspNetCoreWindowsAuth" rel="nofollow">https://github.com/damienbod/AspNetCoreWindowsAuth</a></p><p><strong>Authorization using ASP.NET Core Route parameters</strong></p><p>An AuthorizationHandler can be used to implement authorization logic in ASP.NET Core. The handler can authorize HTTP requests using a route parameter from where the policy for the requirement used in the handler is defined. The IHttpContextAccessor is used to access the route parameters. The RouteValues property in the request of the HttpContext contains these values. If you know the name of the route value, the value can be retrieved using this key. In this demo, a static text is used to validate the route parameter value. In a real world AuthorizationHandler, the value would be validated against a claim from the token, or queried from a database, or an authorization service. To validate this correctly, something must be used which cannot be manipulated. If using a claim from the access token, then the access token must be validated fully and correctly. The AuthorizationHandler implements the ValuesRouteRequirement which is used in the policy definition.</p><pre class="brush: csharp; title: ; notranslate" title="">using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using System.Threading.Tasks;

namespace AppAuthorizationService
{
    public class ValuesCheckRouteParameterHandler : AuthorizationHandler&lt;ValuesRouteRequirement&gt;
    {
        private readonly IHttpContextAccessor _httpContextAccessor;

        public ValuesCheckRouteParameterHandler(IHttpContextAccessor httpContextAccessor)
        {
            _httpContextAccessor = httpContextAccessor;
        }

        protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, ValuesRouteRequirement requirement)
        {
            var routeValues = _httpContextAccessor.HttpContext.Request.RouteValues;

            object user;
            routeValues.TryGetValue("user", out user);
            if ( user.ToString() == "phil")
            {
                context.Succeed(requirement);
            }

            return Task.CompletedTask;
        }
    }
}
</pre><p>In the Startup class using the ConfigureServices method, the IAuthorizationHandler services are registered and also the IHttpContextAccessor using the AddHttpContextAccessor method. The policies are defined for the authorization requirements. The demo is an API project example, which uses swagger so the AddControllers extension method is used, with AddNewtonsoftJson.</p><pre class="brush: csharp; title: ; notranslate" title="">public void ConfigureServices(IServiceCollection services)
{
	// ...

	services.AddHttpContextAccessor();

	services.AddSingleton&lt;IAuthorizationHandler, ValuesCheckQueryParameterHandler&gt;();
	services.AddSingleton&lt;IAuthorizationHandler, ValuesCheckRequestBodyHandler&gt;();
	services.AddSingleton&lt;IAuthorizationHandler, ValuesCheckRouteParameterHandler&gt;();

	services.AddAuthorization(options =&gt;
	{
		options.AddPolicy("protectedScope", policy =&gt;
		{
			policy.RequireClaim("scope", "native_api");
		});
		options.AddPolicy("ValuesRoutePolicy", valuesRoutePolicy =&gt;
		{
			valuesRoutePolicy.Requirements.Add(new ValuesRouteRequirement());
		});
		options.AddPolicy("ValuesQueryPolicy", valuesQueryPolicy =&gt;
		{
			valuesQueryPolicy.Requirements.Add(new ValuesCheckQueryParamRequirement());
		});
		options.AddPolicy("ValuesRequestBodyCheckPolicy", valuesRequestBodyCheckPolicy =&gt;
		{
			valuesRequestBodyCheckPolicy.Requirements.Add(new ValuesRequestBodyRequirement());
		});
	});


	services.AddControllers()
		.AddNewtonsoftJson();
}
</pre><p>The policy is then used in the controller in the authorize attribute. In this demo, if the user has the value ‘phil’, the data will be returned, otherwise a 403 is returned, or 401 if no bearer access token is sent in the header of the HTTP request.</p><pre class="brush: csharp; title: ; notranslate" title="">[Authorize("ValuesRoutePolicy")]
[ProducesResponseType(StatusCodes.Status200OK)]
[HttpGet]
[Route("{user}", Name = nameof(GetWithRouteParam))]
public IActionResult GetWithRouteParam([FromRoute]string user)
{
	return Ok($"get this data [{user}] using the route");
}
</pre><p>A HttpClient implementation can then make a HTTP request with the route set and the access token added to the headers.</p><pre class="brush: csharp; title: ; notranslate" title="">private static async Task CallApiwithRouteValue(string currentAccessToken, string user)
{
	_apiClient.SetBearerToken(currentAccessToken);
	var response = await _apiClient.GetAsync($"/api/values/{user}");

	if (response.IsSuccessStatusCode)
	{
		var result = await response.Content.ReadAsStringAsync();
		Console.WriteLine($"\n{result}");
	}
	else
	{
		Console.WriteLine($"Error: {response.ReasonPhrase}");
	}
}
</pre><p><strong>Authorization using HTTP Query string parameters</strong></p><p>ASP.NET Core query parameters can also be used inside an AuthorizationHandler in almost the same way as the route parameter. The IHttpContextAccessor is used to get the HttpContext. Then the Query request property can be used to access the parameters. In this demo, the query parameter is named fruit which can be used to retrieve the value. If it equals oranges, the requirement will succeed using this handler.</p><pre class="brush: csharp; title: ; notranslate" title="">using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using System.Threading.Tasks;

namespace AppAuthorizationService
{
    public class ValuesCheckQueryParameterHandler : AuthorizationHandler&lt;ValuesCheckQueryParamRequirement&gt;
    {
        private readonly IHttpContextAccessor _httpContextAccessor;

        public ValuesCheckQueryParameterHandler(IHttpContextAccessor httpContextAccessor)
        {
            _httpContextAccessor = httpContextAccessor;
        }

        protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, ValuesCheckQueryParamRequirement requirement)
        {
            var queryString = _httpContextAccessor.HttpContext.Request.Query;
            var fruit = queryString["fruit"];

            if (fruit.ToString() == "orange")
            {
                context.Succeed(requirement);
            }

            return Task.CompletedTask;
        }
    }
}
</pre><p>The controller class can then be authorized with the Authorize attribute using the ValuesQueryPolicy which checks for the requirement, which was used in the ValuesCheckQueryParameterHandler. </p><pre class="brush: csharp; title: ; notranslate" title="">[Authorize("ValuesQueryPolicy")]
[ProducesResponseType(StatusCodes.Status200OK)]
[HttpGet]
[Route("q/{user}", Name = nameof(GetWithQueryParam))]
public IActionResult GetWithQueryParam([FromRoute]string user, [FromQuery]string fruit)
{
	return Ok($"get this data [{fruit}] using the query parameter");
}
</pre><p>A HttpClient can then be used to send the HTTP request with the query string parameter.</p><pre class="brush: csharp; title: ; notranslate" title="">private static async Task CallApiwithQueryStringParam(string currentAccessToken, string fruit)
{
	_apiClient.SetBearerToken(currentAccessToken);
	var response = await _apiClient.GetAsync($"/api/values/q?fruit={fruit}");

	if (response.IsSuccessStatusCode)
	{
		var result = await response.Content.ReadAsStringAsync();
		Console.WriteLine( $"\n{result}");
	}
	else
	{
		Console.WriteLine($"Error: {response.ReasonPhrase}");
	}
}
</pre><p><strong>Authorization using the HTTP Request Body</strong></p><p>The body of a HTTP POST request can also be used to do authorization. This works slightly different to the previous two examples. The ValuesCheckRequestBodyHandler implements the AuthorizationHandler with the ValuesRequestBodyRequirement requirement and also the BodyData resource. This resource is used to do the authorization checks as required. </p><pre class="brush: csharp; title: ; notranslate" title="">using Microsoft.AspNetCore.Authorization;
using System.Threading.Tasks;

namespace AppAuthorizationService
{
    public class ValuesCheckRequestBodyHandler : AuthorizationHandler&lt;ValuesRequestBodyRequirement, BodyData&gt;
    {
        protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, 
              ValuesRequestBodyRequirement requirement, BodyData bodyData)
        {
            if(bodyData.User == "mike")
            {
                context.Succeed(requirement);
            }

            return Task.CompletedTask;
        }
    }

    public class BodyData
    {
        public string User { get; set; }
    }
}
</pre><p>In the Controller, the Authorize attribute is not used. This is because we do not want to deserialize the body a second time. Once inside the controller method, the body data, which has already been serialized is passed as a parameter to the authorization check. This has the disadvantage that the authorization is executed later in the pipeline. The authorization is then used in the method and a Forbidden 403 is returned, if the body data sent has unauthorized values.</p><pre class="brush: csharp; title: ; notranslate" title="">[Authorize]
[ProducesResponseType(StatusCodes.Status200OK)]
[Produces(typeof(BodyData))]
[HttpPost]
[Route("", Name = nameof(Post))]
public async Task&lt;IActionResult&gt; Post([FromBody]BodyData user)
{
	var requirement = new ValuesRequestBodyRequirement();
	var resource = user;

	var authorizationResult =
		await _authorizationService.AuthorizeAsync(
			User, resource, requirement);

	if (authorizationResult.Succeeded)
	{
		return Ok($"posted this data [{user.User}] using the body");
	}
	else
	{
		return new ForbidResult();
	}
}
</pre><p>It is really easy to use the different parts of the HTTP request, to do the specific authorization as required. </p><p><strong>Links:</strong></p><p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies</a></p><p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-3.0" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-3.0</a></p><p><a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/razor-pages</a></p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><h3 class="jp-relatedposts-headline"><em>Related</em></h3></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>