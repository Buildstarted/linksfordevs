<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Top 10 Things You Can Do With GraalVM - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Top 10 Things You Can Do With GraalVM - linksfor.dev(s)"/>
    <meta property="article:author" content="Chris Seaton"/>
    <meta property="og:description" content="There are a lot of different parts to GraalVM, so if you&#x2019;ve heard the name before, or even seen some of our talks, there are for sure things that it can do that you don&#x2019;t know about yet. In this&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/graalvm/graalvm-ten-things-12d9111f307d"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">ðŸŽ‰</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Top 10 Things You Can Do With GraalVM</title>
<div class="readable">
        <h1>Top 10 Things You Can Do With GraalVM</h1>
        <p>
by Chris Seaton <br/>Reading time: 28-35 minutes        </p>
        <p><a href="https://medium.com/graalvm/graalvm-ten-things-12d9111f307d">https://medium.com/graalvm/graalvm-ten-things-12d9111f307d</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*XhpaxLHIJRDd4t0KPPuvlA.png?q=20" width="655" height="294" role="presentation"></p><p><img width="655" height="294" role="presentation" src="https://miro.medium.com/max/655/1*XhpaxLHIJRDd4t0KPPuvlA.png"></p></div></div></div></figure><div><div><div><div><p><a rel="noopener" href="https://medium.com/@chrisgseaton?source=post_page-----12d9111f307d----------------------"><img alt="Chris Seaton" src="https://miro.medium.com/fit/c/96/96/1*Y2qT8VR3UNZI8pJmQ5Poag@2x.jpeg" width="48" height="48"></a></p></div></div></div></div><p id="a074" data-selectable-paragraph=""><em>This post has been updated to GraalVM 19.3.0</em></p><p id="0d6f" data-selectable-paragraph="">There are a lot of different parts to <a href="https://www.graalvm.org/" target="_blank" rel="noopener nofollow">GraalVM</a>, so if youâ€™ve heard the name before, or even seen some of our talks, there are for sure things that it can do that you donâ€™t know about yet. In this article weâ€™ll list some of the diverse features of GraalVM and show you what they can do for you.</p><ul><li id="45cc" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/p/12d9111f307d">1. High-performance modern Java</a></li><li id="c55b" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/p/12d9111f307d">2. Low-footprint, fast-startup Java</a></li><li id="ae63" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/p/12d9111f307d">3. Combine JavaScript, Java, Ruby, and R</a></li><li id="b6fb" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/p/12d9111f307d">4. Run native languages on the JVM</a></li><li id="e5cc" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/p/12d9111f307d">5. Tools that work across all languages</a></li><li id="eeee" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/p/12d9111f307d">6. Extend a JVM-based application</a></li><li id="1d0b" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/p/12d9111f307d">7. Extend a native application</a></li><li id="7496" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/p/12d9111f307d">8. Java code as a native library</a></li><li id="5e0f" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/p/12d9111f307d">9. Polyglot in the database</a></li><li id="9ad8" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/p/12d9111f307d">10. Create your own language</a></li></ul><p id="f948" data-selectable-paragraph="">You can reproduce everything that Iâ€™m showing in this article with GraalVM 19.3.0, which is available from <a href="https://www.graalvm.org/downloads" target="_blank" rel="noopener nofollow">graalvm.org/downloads</a>. Iâ€™m using the Enterprise Edition on macOS, which is free to evaluate as weâ€™re doing here, but the instructions will also work on Linux. Most of them will also work with the Community Edition.</p><p id="c711" data-selectable-paragraph="">Follow along and run these programs while youâ€™re reading! The code Iâ€™m running on GraalVM can be cloned from <a href="http://github.com/chrisseaton/graalvm-ten-things/" target="_blank" rel="noopener nofollow">github.com/chrisseaton/graalvm-ten-things/</a>.</p><p id="bcb2" data-selectable-paragraph="">Iâ€™ve downloaded GraalVM Enterprise Edition based on JDK8 for macOS from <a href="https://www.oracle.com/downloads/graalvm-downloads.html" target="_blank" rel="noopener nofollow">https://www.oracle.com/downloads/graalvm-downloads.html</a>, and put the programs from it onto my <code>$PATH</code>. This gives me the Java and JavaScript languages by default.</p><pre><span id="c480" data-selectable-paragraph="">$ git clone <a href="https://github.com/chrisseaton/graalvm-ten-things.git" target="_blank" rel="noopener nofollow">https://github.com/chrisseaton/graalvm-ten-things.git</a><br>$ cd foo<br>$ tar -zxf graalvm-ee-java8-darwin-amd64-19.3.0.tar.gz<br>    # or graalvm-ee-java8-linux-amd64-19.3.0.tar.gz on Linux<br>$ export PATH=graalvm-ee-java8-19.3.0/Contents/Home/bin:$PATH<br>    # or PATH=graalvm-ee-java8-19.3.0/bin:$PATH on Linux</span></pre><p id="a89f" data-selectable-paragraph="">GraalVM comes with JavaScript included and has a package manager called <code>gu</code> that lets you install additional languages. Iâ€™ve installed the Ruby, Python and R languages. Iâ€™ve also installed the <code>native-image</code>tool. These all get downloaded from GitHub.</p><pre><span id="61c3" data-selectable-paragraph="">$ gu install native-image<br>$ gu install ruby<br>$ gu install python<br>$ gu install R</span></pre><p id="1222" data-selectable-paragraph="">Now when you run <code>java</code> or <code>js</code> you'll get the GraalVM versions of those runtimes.</p><pre><span id="48ed" data-selectable-paragraph="">$ java -version<br>java version "1.8.0_231"<br>Java(TM) SE Runtime Environment (build 1.8.0_231-b11)<br>Java HotSpot(TM) 64-Bit GraalVM EE 19.3.0 (build 25.231-b11-jvmci-19.3-b05, mixed mode)</span><span id="bac6" data-selectable-paragraph="">$ js --version<br>GraalVM JavaScript (GraalVM EE Native 19.3.0)</span></pre><p id="b872" data-selectable-paragraph="">The <em>Graal</em> name in the GraalVM comes from the GraalVM compiler. GraalVM is <a href="http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf" target="_blank" rel="noopener nofollow">one compiler to rule them all</a>, meaning that itâ€™s a single implementation of a compiler written as a library which can be used for many different things. For example we use the GraalVM compiler to compile both <em>ahead-of-time</em> and <em>just-in-time</em>, to compile multiple programming languages, and to multiple architectures.</p><p id="037d" data-selectable-paragraph="">One simple way to use GraalVM is to use it as your Java JIT compiler.</p><p id="2999" data-selectable-paragraph="">Weâ€™ll use this example program, which gives you the top-ten words in a document. It uses modern Java language features like streams and collectors.</p><figure><div></div></figure><p id="c17f" data-selectable-paragraph="">GraalVM includes a <code>javac</code> compiler, but it isn't any different from the standard one for the purposes of this demo, so you could use your system <code>javac</code> instead if you wanted to.</p><pre><span id="7dcd" data-selectable-paragraph="">$ javac TopTen.java</span></pre><p id="4174" data-selectable-paragraph="">If we run the <code>java</code> command included in GraalVM we'll be automatically using the Graal JIT compiler - no extra configuration is needed. I'll use the <code>time</code> command to get the real, wall-clock elapsed time it takes to run the entire program from start to finish, rather than setting up a complicated micro-benchmark, and I'll use a large input so that we aren't quibbling about a few seconds here or there. The <code>large.txt</code> file is 150 MB.</p><pre><span id="5c83" data-selectable-paragraph="">$ make large.txt<br>$ time java TopTen large.txt<br>sed = 502701<br>ut = 392657<br>in = 377651<br>et = 352641<br>id = 317627<br>eu = 317627<br>eget = 302621<br>vel = 300120<br>a = 287615<br>sit = 282613</span><span id="7a8a" data-selectable-paragraph="">real  0m12.950s<br>user  0m17.827s<br>sys 0m0.622s</span></pre><p id="a531" data-selectable-paragraph="">GraalVM is written in Java, rather than C++ like most other JIT compilers for Java. We think this allows us to improve it more quickly than existing compilers, with powerful new optimisations such as partial escape analysis that arenâ€™t available in the standard JIT compilers for HotSpot. This can make your Java programs run significantly faster.</p><p id="bfaa" data-selectable-paragraph="">To run without the GraalVM JIT compiler to compare, I can use the flag <code>-XX:-UseJVMCICompiler</code>. JVMCI is the interface between GraalVM and the JVM. You could also compare against your standard JVM as well.</p><pre><span id="2871" data-selectable-paragraph="">$ time java -XX:-UseJVMCICompiler TopTen large.txt<br>sed = 502701<br>ut = 392657<br>in = 377651<br>et = 352641<br>id = 317627<br>eu = 317627<br>eget = 302621<br>vel = 300120<br>a = 287615<br>sit = 282613</span><span id="5b96" data-selectable-paragraph="">real  0m19.602s<br>user  0m20.357s<br>sys 0m0.498s</span></pre><p id="8f8d" data-selectable-paragraph="">This shows GraalVM running our Java program in around two-thirds of the wall-clock time it takes to run it with a standard HotSpot compiler. In an area where we are used to treating single-digit percentage increases in performance as significant, this is a big-deal.</p><p id="e280" data-selectable-paragraph="">Youâ€™ll still get a result better than HotSpot if you use the Community Edition, but it wonâ€™t be quite as a good as the Enterprise Edition.</p><p id="22b0" data-selectable-paragraph="">Twitter are one company <a href="https://www.youtube.com/watch?v=OSyvidFXL7M" target="_blank" rel="noopener nofollow">using GraalVM in production today</a>, and they say that for them it is paying off in terms of real money saved. Twitter are using GraalVM to run Scala applications â€” GraalVM works at the level of JVM bytecode so it works for any JVM language.</p><p id="b6b1" data-selectable-paragraph="">This is the first way you can use GraalVM â€” simply as a drop-in better JIT compiler for your existing Java applications.</p><p id="412b" data-selectable-paragraph="">The Java platform is particularly strong for long-running processes and peak performance, but short-running processes can suffer from longer startup time and relatively high memory usage.</p><p id="7624" data-selectable-paragraph="">For example, if we run the same application with a much smaller input â€” around 1 KB instead of 150 MB, then it seems to take an unreasonably long time, and quite a lot of memory at 70 MB, to run for such a small file. We use <code>-l</code> to print the memory used as well as time used.</p><pre><span id="2f24" data-selectable-paragraph="">$ make small.txt<br>$ /usr/bin/time -l java TopTen small.txt<br>      # -v on Linux instead of -l<br>sed = 6<br>sit = 6<br>amet = 6<br>mauris = 3<br>volutpat = 3<br>vitae = 3<br>dolor = 3<br>libero = 3<br>tempor = 2<br>suscipit = 2<br>        0.17 real         0.28 user         0.04 sys<br>  70737920  maximum resident set size<br>...</span></pre><p id="9511" data-selectable-paragraph="">GraalVM gives us a tool that solves this problem. We said that GraalVM is like a compiler library and it can be used in many different ways. One of those is to compile <em>ahead-of-time</em>, to a native executable image, instead of compiling <em>just-in-time</em> at runtime. This is similar to how a conventional compiler like <code>gcc</code> works.</p><pre><span id="31f1" data-selectable-paragraph="">$ native-image --no-server --no-fallback TopTen<br>[topten:37970]    classlist:   1,801.57 ms<br>[topten:37970]        (cap):   1,289.45 ms<br>[topten:37970]        setup:   3,087.67 ms<br>[topten:37970]   (typeflow):   6,704.85 ms<br>[topten:37970]    (objects):   6,448.88 ms<br>[topten:37970]   (features):     820.90 ms<br>[topten:37970]     analysis:  14,271.88 ms<br>[topten:37970]     (clinit):     257.25 ms<br>[topten:37970]     universe:     766.11 ms<br>[topten:37970]      (parse):   1,365.29 ms<br>[topten:37970]     (inline):   3,829.55 ms<br>[topten:37970]    (compile):  34,674.51 ms<br>[topten:37970]      compile:  41,412.71 ms<br>[topten:37970]        image:   2,741.41 ms<br>[topten:37970]        write:     619.13 ms<br>[topten:37970]      [total]:  64,891.52 ms</span></pre><p id="fd05" data-selectable-paragraph="">This command produces a native executable called <code>topten</code>. This executable isnâ€™t a launcher for the JVM, it doesnâ€™t link to the JVM, and it doesnâ€™t bundle the JVM in any way. <code>native-image</code> really does compile your Java code, and any Java libraries you use, all the way down to simple machine code. For runtime components like the garbage collector we are running our own new VM called the <mark>SubstrateVM</mark>, which like GraalVM is also written in Java.</p><p id="9b75" data-selectable-paragraph="">If we look at the libraries which <code>topten</code> uses you can see they are only standard system libraries. We could also move just this one file to a system which has never had a JVM installed and run it there to verify it doesnâ€™t use a JVM or any other files. Itâ€™s also pretty small - this executable is less than 8 MB.</p><pre><span id="8770" data-selectable-paragraph="">$ otool -L topten    # ldd topten on Linux<br>topten:<br>  libSystem.B.dylib (current version 1252.250.1)<br>  CoreFoundation (current version 1575.12.0)<br>  /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)<br>$ du -h topten <br>7.5M  topten</span></pre><p id="cfb8" data-selectable-paragraph="">If we run the executable we can see that it starts around an order of magnitude faster, and uses around an order of magnitude less memory, than running the same program on the JVM does. Itâ€™s so fast that you donâ€™t notice the time taken when using it at the command line â€” you donâ€™t feel that pause you always get when running a short-running command with the JVM.</p><pre><span id="0b78" data-selectable-paragraph="">$ /usr/bin/time -l ./topten small.txt<br>sed = 6<br>sit = 6<br>amet = 6<br>mauris = 3<br>volutpat = 3<br>vitae = 3<br>dolor = 3<br>libero = 3<br>tempor = 2<br>suscipit = 2<br>        0.02 real         0.00 user         0.00 sys<br>   3158016  maximum resident set size<br>...</span></pre><p id="e54f" data-selectable-paragraph="">The <code>native-image </code>tool has some <a href="https://github.com/oracle/graal/blob/master/substratevm/LIMITATIONS.md" target="_blank" rel="noopener nofollow">restrictions</a> such as all classes having to be available during compilation, and some limitations around reflection. It has some additional advantages over basic compilation as well in that static initializers are run during compilation, so you can reduce the work done each time an application loads.</p><p id="69dc" data-selectable-paragraph="">This is a second way that you can use GraalVM â€” a way to distribute and run your existing Java programs with a low-footprint and fast-startup. It also frees you from configuration issues such as finding the right jar files at runtime, and allows you to have smaller Docker images.</p><p id="ac57" data-selectable-paragraph="">As well as Java, GraalVM includes new implementations of JavaScript, Ruby, R and Python. These are written using a new language implementation framework called <em>Truffle</em> that makes it possible to implement language interpreters that are both simple and high performance. When you write a language interpreter using Truffle, Truffle will automatically use GraalVM on your behalf to give you a JIT compiler for your language. So GraalVM is not only a JIT compiler and ahead-of-time native compiler for Java, it can also be a JIT compiler for JavaScript, Ruby, R and Python.</p><p id="6413" data-selectable-paragraph="">The languages in GraalVM aim to be drop-in replacements for your existing languages. For example we can install a Node.js module:</p><pre><span id="4d62" data-selectable-paragraph="">$ npm install color<br>...<br>+ color@3.1.1<br>added 6 packages from 6 contributors and audited 7 packages in 6.931s</span></pre><p id="cad6" data-selectable-paragraph="">We can write a little program <em>color.js</em> using this module to convert an RGB HTML color to HSL:</p><pre><span id="a75c" data-selectable-paragraph="">var Color = require('color');</span><span id="6796" data-selectable-paragraph="">process.argv.slice(2).forEach(function (val) {<br>  console.log(Color(val).hsl().string());<br>});</span></pre><p id="de12" data-selectable-paragraph="">Then we can run that in the usual way:</p><pre><span id="84c4" data-selectable-paragraph="">$ node color.js '#42aaf4'<br>hsl(204.89999999999998, 89%, 60.8%)</span></pre><p id="725e" data-selectable-paragraph="">The languages in GraalVM work together â€” thereâ€™s an API which lets you run code from one language in another. This lets you write polyglot programs â€” programs written in more than one language.</p><p id="aee0" data-selectable-paragraph="">You might want to do this because you want to write the majority of your application in one language, but thereâ€™s a library in another languageâ€™s ecosystem that youâ€™d like to use. For example, say weâ€™d like to write our application for converting a CSS color name to hexadecimal in Node.js, but we want to use a Ruby color library instead to do the conversion.</p><figure><div></div></figure><p id="06d7" data-selectable-paragraph="">We specify some Ruby code to run as a string, but notice that we donâ€™t do much in it â€” we just require the libraries, and then return a Ruby object. The way to use this object from Ruby is normally to say <code>Color::RGB.by_name(name).html</code>. If you look at how <code>color_rgb</code> is used further down by JavaScript, you can see that actually we're calling these methods from JavaScript, even though they are Ruby objects and methods, and we pass them a JavaScript string, and we concatenate the result, which is a Ruby string, with other JavaScript strings.</p><p id="a7ea" data-selectable-paragraph="">Weâ€™ll install both our Ruby and JavaScript dependencies.</p><pre><span id="80b6" data-selectable-paragraph="">$ gem install color<br>Fetching: color-1.8.gem (100%)<br>Successfully installed color-1.8<br>1 gem installed</span><span id="825d" data-selectable-paragraph="">$ npm install express<br>+ express@4.17.0<br>added 50 packages from 37 contributors and audited 143 packages in 22.431s</span></pre><p id="61ff" data-selectable-paragraph="">We then need to run <code>node</code> with a couple of options: <code>--polyglot</code> to say we want access to other languages, and <code>--jvm</code> because the <code>node</code> native image by default doesn't include more than JavaScript.</p><pre><span id="19ec" data-selectable-paragraph="">$ node --polyglot --jvm color-server.js<br>serving at <a href="http://localhost:8080/" target="_blank" rel="noopener nofollow">http://localhost:8080</a></span></pre><p id="592e" data-selectable-paragraph="">Then open <a href="http://localhost:8080/css/aquamarine" target="_blank" rel="noopener nofollow">http://localhost:8080/css/aquamarine</a>, or some other colour name, as normal in your browser.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*FFrMNcdEuhIgiHz7gp54Ig.png?q=20" width="1632" height="1192" role="presentation"></p><p><img width="1632" height="1192" role="presentation"></p></div></div></div></div></figure><p id="121c" data-selectable-paragraph="">Letâ€™s try a larger example using more languages and modules.</p><p id="f57f" data-selectable-paragraph="">JavaScript doesnâ€™t have a great solution for arbitrarily-large integers. I found several modules like <code>big-integer</code> but these are all inefficient as they store components of the number as JavaScript floating point numbers. Java's <code>BigInteger</code> class is more efficient so let's use that instead to do some arbitrarily-large integer arithmetic.</p><p id="2b2c" data-selectable-paragraph="">JavaScript also doesnâ€™t include any built-in support for drawing graphs, where R does include excellent support for this. Letâ€™s use Râ€™s <code>svg</code> module to draw a 3D scatter plot of a trigonometric function.</p><p id="46de" data-selectable-paragraph="">In both cases we can use GraalVMâ€™s polyglot API, and we can just compose the results from these other languages into JavaScript.</p><figure><div></div></figure><p id="38aa" data-selectable-paragraph="">Open <a href="http://localhost:3000/" target="_blank" rel="noopener nofollow">http://localhost:3000/</a> in your browser to see the result.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*NPuHZJZouIOMaVSjey9xUg.png?q=20" width="1632" height="1440" role="presentation"></p><p><img width="1632" height="1440" role="presentation"></p></div></div></div></div></figure><p id="1fe3" data-selectable-paragraph="">Thatâ€™s the third thing we can do with GraalVM â€” run programs written in multiple languages and use modules from those languages together. We think of this as a kind of commoditisation of languages and modules â€” you can use whichever language you think is best for your problem at hand, and whichever library you want, no matter which language it came from.</p><p id="da89" data-selectable-paragraph="">Another language that GraalVM supports is C. GraalVM can run C code in the same way that it runs languages like JavaScript and Ruby.</p><p id="a39e" data-selectable-paragraph="">What GraalVM actually supports is running the output of the LLVM toolchain â€” LLVM bitcode â€” rather than directly supporting C. This means you can use your existing tooling with C, and also other languages that can output LLVM, such as C++, Fortran, and potentially other languages in the future. To make things simple for a demo Iâ€™m running a special <a href="http://people.csail.mit.edu/smcc/projects/single-file-programs/" target="_blank" rel="noopener nofollow">single-file version</a> of gzip, maintained by <a href="http://people.csail.mit.edu/smcc/" target="_blank" rel="noopener nofollow">Stephen McCamant</a>. Itâ€™s just the <code>gzip</code> source code and the <code>autoconf</code> configuration concatenated into one file for simplicity. I've also had to patch a couple of things to make it work on macOS and with clang, but not to get it working on GraalVM.</p><p id="ccfb" data-selectable-paragraph="">Then we can compile using standard <code>clang</code> (the LLVM C compiler), and we want it to compile to LLVM bitcode, not native assembly, because that's what GraalVM can run. I'm using <code>clang</code> 4.0.1.</p><pre><span id="6721" data-selectable-paragraph="">$ clang -c -emit-llvm gzip.c</span></pre><p id="c14a" data-selectable-paragraph="">And then we run this directly using GraalVM using the <code>lli</code> command (LLVM bitcode interpreter). Let's try compressing a file using my system <code>gzip</code>, and then decompress using <code>gzip</code> running on GraalVM.</p><pre><span id="512c" data-selectable-paragraph="">$ cat small.txt<br>Lorem ipsum dolor sit amet...<br>$ gzip small.txt<br>$ lli gzip.bc -d small.txt.gz<br>$ cat small.txt<br>Lorem ipsum dolor sit amet...</span></pre><p id="9f4a" data-selectable-paragraph="">Alternatively, C/C++ code can be compiled to LLVM bitcode using the <code>clang</code> shipped with GraalVM. For that you should enable a pre-built LLVM toolchain support and point the <code>LLVM_TOOLCHAIN</code> environment variable to the directory containing a set of build tools, such as a C compiler and a linker, that enables compiling a native project to bitcode.</p><pre><span id="8e57" data-selectable-paragraph="">$ gu install llvm-toolchain<br>$ export LLVM_TOOLCHAIN=$(lli --print-toolchain-path)</span></pre><p id="9cd9" data-selectable-paragraph="">Then you can compile <code>gzip.c</code> source code to an executable with embedded LLVM bitcode and run it as follows:</p><pre><span id="5efb" data-selectable-paragraph="">$ $<!-- -->LLVM_TOOLCHAIN/clang gzip.c -o gzip<br>$ gzip small.txt<br>$ lli gzip -d small.txt.gz<br>$ cat small.txt<br>Lorem ipsum dolor sit amet...</span></pre><p id="e710" data-selectable-paragraph="">The implementations of Ruby and Python in GraalVM use this technique to run C extensions for these languages. This means that you can run C extensions inside the VM, and it allows us to maintain high performance even while supporting these legacy native extension interfaces.</p><p id="5019" data-selectable-paragraph="">This is a fourth thing you can do with the GraalVM â€” run programs written in native languages like C and C++, and also run C extensions to languages like Python and Ruby, which existing JVM implementations like JRuby are not able to do.</p><p id="ffce" data-selectable-paragraph="">If you program in Java youâ€™re probably used to very high quality tools like IDEs, debuggers and profilers. Not all languages have these kind of tools, but you get them if you use a language in GraalVM.</p><p id="cc9d" data-selectable-paragraph="">All the GraalVM languages (except for Java at the moment) are implemented using the common Truffle framework. This allows us to implement functionality like debuggers once and have it available to all languages.</p><p id="2b3d" data-selectable-paragraph="">To try this weâ€™ll write a basic <em>FizzBuzz</em> program, because it prints things to the screen and it has clear branches that are only taken on some iterations, so we can set some breakpoints more easily. Weâ€™ll start with a JavaScript implementation.</p><figure><div></div></figure><p id="f3f5" data-selectable-paragraph="">We can run this JavaScript program as normal using GraalVM, using the <code>js</code> executable.</p><pre><span id="40ce" data-selectable-paragraph="">$ js fizzbuzz.js<br>1<br>2<br>Fizz<br>4<br>Buzz<br>Fizz<br>...</span></pre><p id="5ad3" data-selectable-paragraph="">We can also run the program with the flag <code>--inspect</code>. This will give us a link to open in Chrome and will pause the program in the debugger.</p><pre><span id="5228" data-selectable-paragraph="">$ js --inspect fizzbuzz.js<br>Debugger listening on port 9229.<br>To start debugging, open the following URL in Chrome:<br>    chrome-devtools://devtools/bundled/inspector.html?ws=127.0.0.1:9229/6c478d4e-1350b196b409<br>...</span></pre><p id="51f8" data-selectable-paragraph="">We can then set a breakpoint on the <em>FizzBuzz</em> line and then continue execution. When it breaks weâ€™ll see the value of <code>n</code>, and can continue again, or explore the rest of the debugging interface.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*kQoJRkHNZtZ-XiEer4HLwg.png?q=20" width="1632" height="1440" role="presentation"></p><p><img width="1632" height="1440" role="presentation"></p></div></div></div></div></figure><p id="ed24" data-selectable-paragraph="">The Chrome debugger is usually used with JavaScript, but thereâ€™s nothing special about JavaScript in GraalVM. This flag is also available and working in our implementations of Python, Ruby and R. I wonâ€™t show you the source of each program, but you run them in exactly the same way, and get the same Chrome debugger interface to each.</p><pre><span id="0c02" data-selectable-paragraph="">$ graalpython --inspect fizzbuzz.py</span></pre><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*F072cZoIA3oaoBA1OzCOEQ.png?q=20" width="1632" height="1440" role="presentation"></p><p><img width="1632" height="1440" role="presentation"></p></div></div></div></div></figure><pre><span id="5852" data-selectable-paragraph="">$ ruby --inspect fizzbuzz.rb</span></pre><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*c2oldXo8fZCMVDZJXu56DQ.png?q=20" width="1632" height="1440" role="presentation"></p><p><img width="1632" height="1440" role="presentation"></p></div></div></div></div></figure><pre><span id="bb1b" data-selectable-paragraph="">$ Rscript --inspect fizzbuzz.r</span></pre><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*nb6YQ7Yoa-ZfeZIIMKpT8Q.png?q=20" width="1632" height="1440" role="presentation"></p><p><img width="1632" height="1440" role="presentation"></p></div></div></div></div></figure><p id="d775" data-selectable-paragraph="">Another tool that you may be familiar with using already from Java is VisualVM. It gives you a user interface which you can connect to a running JVM on your machine or somewhere over a network to inspect various aspects such as how it is using memory and threads.</p><p id="f094" data-selectable-paragraph="">GraalVM includes VisualVM with the standard <code>jvisualvm</code> command.</p><pre><span id="8cf1" data-selectable-paragraph="">$ jvisualvm &amp;&gt; /dev/null &amp;</span></pre><p id="b490" data-selectable-paragraph="">If we run it while we run our Java <code>TopTen</code> application from before, we can watch the memory use over time, or we can do something like take a heap dump and inspect what kind of objects we have using memory in our heap.</p><pre><span id="84f0" data-selectable-paragraph="">$ java TopTen large.txt</span></pre><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*C8eLLZkW1zjVLBMRpm-p5A.png?q=20" width="2062" height="1442" role="presentation"></p><p><img width="2062" height="1442" role="presentation"></p></div></div></div></div></figure><p id="5b04" data-selectable-paragraph="">Iâ€™ve written this Ruby program to generate some garbage over time.</p><figure><div></div></figure><p id="bfd9" data-selectable-paragraph="">If you run a standard JVM language, like JRuby, with VisualVM youâ€™ll be disappointed in that youâ€™ll see the underlying Java objects, rather than any information about your languageâ€™s objects.</p><p id="c532" data-selectable-paragraph="">If we use the GraalVM version of Ruby instead, VisualVM will recognise the Ruby objects themselves. We need to use the <code>--jvm</code> command to use VisualVM, as it doesn't support the native version of Ruby.</p><pre><span id="1b03" data-selectable-paragraph="">$ ruby --jvm render.rb</span></pre><p id="4935" data-selectable-paragraph="">We can see the same heap view dump of underlying Java objects if we want to, or under <em>Summary</em> we can select <em>Ruby Heap</em> and see proper Ruby objects instead.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*rT5WBKykZHoLp1ziMCkmCQ.png?q=20" width="2062" height="1442" role="presentation"></p><p><img width="2062" height="1442" role="presentation"></p></div></div></div></div></figure><p id="5f89" data-selectable-paragraph="">The Truffle framework is a <a href="http://programming-journal.org/2018/2/14/" target="_blank" rel="noopener nofollow">kind of nexus for languages and tools</a>. If you program your languages using Truffle, and you program your tools like this debugger against Truffleâ€™s tool API, then each tool works with each language, and you only have to write the tool once.</p><p id="20eb" data-selectable-paragraph="">So the fifth way that you can use GraalVM is as a platform to get high quality tooling for languages which donâ€™t always have the support behind them to build bespoke tools like the Chrome Debugger or VisualVM.</p><p id="afb6" data-selectable-paragraph="">As well as being usable as standalone language implementations, and together in a polyglot use case, these languages and tools can also be embedded in your Java application. A new <code>org.graalvm.polyglot</code> API lets you load and run code in other languages and to use values from them.</p><figure><div></div></figure><p id="19be" data-selectable-paragraph="">If you use the <code>javac</code> and <code>java</code> commands from GraalVM, the imports <code>org.graalvm...</code> will already be on your classpath, so you can compile and run this without any extra flags.</p><pre><span id="3b08" data-selectable-paragraph="">$ javac ExtendJava.java<br>$ java ExtendJava '14 + 2'<br>16<br>$ java ExtendJava -js 'Math.sqrt(14)'<br>3.7416573867739413<br>$ java ExtendJava -python '[2**n for n in range(0, 8)]'<br>[1, 2, 4, 8, 16, 32, 64, 128]<br>$ java ExtendJava -ruby '[4, 2, 3].sort'<br>[2, 3, 4]</span></pre><p id="c6c6" data-selectable-paragraph="">These versions of the languages are the same high-performance polyglot versions that you get from using the commands like <code>node</code> and <code>ruby</code> as the GraalVM executables.</p><p id="55b2" data-selectable-paragraph="">This is a sixth way you can use GraalVM â€” as a single interface to embed many different languages in your Java application. The polyglot API allows you to take guest language objects and use them as Java interfaces and other sophisticated interoperability.</p><p id="4031" data-selectable-paragraph="">GraalVM already includes one native library built like this â€” itâ€™s a library that lets you run code written in any GraalVM language from native applications. JavaScript runtimes like V8, and Python interpreters like CPython, are often embeddable meaning that they can be linked as a library into another application. GraalVM lets you use any language in an embedded context, by linking to this one polyglot embedding library.</p><p id="191b" data-selectable-paragraph="">The library is already built when you get GraalVM, but by default it only includes the builtin language JavaScript. You can rebuild the polyglot library to include other languages using the command below, but youâ€™ll need to download Oracle GraalVM Enterprise Edition Native Image Early Adopter based on JDK8 for MacOS (19.3.0) from <a href="https://www.oracle.com/downloads/graalvm-downloads.html" target="_blank" rel="noopener nofollow">OTN</a>. Rebuilding does take a few minutes, so you may want to just experiment with JavaScript if youâ€™re following along â€” you donâ€™t need to rebuild if you just want JavaScript.</p><pre><span id="b7cb" data-selectable-paragraph="">$ gu install --force --file native-image-installable-svm-svmee-java8-darwin-amd64-19.3.0.jar<br>$ gu rebuild-images libpolyglot</span></pre><p id="b4e5" data-selectable-paragraph="">We can write a simple C program that runs commands in any GraalVM language passed on the command line. Weâ€™re going to be doing the equivalent of our <code>ExtendJava</code> example from above, but with C as the host language.</p><figure><div></div></figure><p id="9e8b" data-selectable-paragraph="">We can then compile and run that using our system C compiler and link to the native polyglot library in GraalVM. Again, it doesnâ€™t need a JVM.</p><pre><span id="90f0" data-selectable-paragraph="">$ clang -L$GRAALVM_HOME/jre/lib/polyglot -I${GRAALVM_HOME}/jre/lib/polyglot -lpolyglot -o extendc -O1 extendc.c -rpath $GRAALVM_HOME<br>$ otool -L extendc<br>extendc:<br>  @rpath/jre/lib/polyglot/libpolyglot.dylib (compatibility version       0.0.0, current version 0.0.0)<br>  /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.250.1)</span></pre></div></div></section><section><div><div><pre><span id="39c2" data-selectable-paragraph="">$ ./extendc '14 + 2'<br>16<br>$ ./extendc -js 'Math.sqrt(14)'<br>3.7416573867739413<br>$ ./extendc -python '[2**n for n in range(0, 8)]'<br>[1, 2, 4, 8, 16, 32, 64, 128]<br>$ ./extendc -ruby '(0...8).map { |n| 2 ** n }'<br>[1, 2, 4, 8, 16, 32, 64, 128]</span></pre><p id="5941" data-selectable-paragraph="">This a seventh thing you can do with the GraalVM â€” use a single library in your native application to embed any GraalVM language.</p><p id="9fde" data-selectable-paragraph="">Java has a great ecosystem of many very high quality libraries, which often arenâ€™t available in other ecosystems, including native applications as well as other managed languages. If you wanted to use a Java library from a native application you could embed the JVM but this gets very large and complicated very quickly.</p><p id="3245" data-selectable-paragraph="">GraalVM lets you take Java library, either off-the-shelf or one youâ€™ve written yourself, and compile it to a standalone native library for use from other native languages. As with our native compilation before, they donâ€™t require a JVM to run.</p><p id="2533" data-selectable-paragraph="">I wrote an application that uses the excellent Apache SIS geospatial library to calculate the great-circle distance between two points on Earth. I used SIS 0.8 which I downloaded separately from <a href="http://sis.apache.org/" target="_blank" rel="noopener nofollow">http://sis.apache.org/</a> and extracted the jar from.</p><figure><div></div></figure><p id="ca42" data-selectable-paragraph="">We can compile this as normal, and then use it to work out the distance between London (latitude 51.507222, longitude -0.1275) and New York (40.7127, -74.0059).</p><pre><span id="7104" data-selectable-paragraph="">$ javac -cp sis.jar -parameters Distance.java<br>$ java -cp sis.jar:. Distance 51.507222 -0.1275 40.7127 -74.0059<br>5570.25 km</span></pre><p id="aa2c" data-selectable-paragraph="">We can compile that to a native executable, as we did with our <code>topten</code> program.</p><pre><span id="23ae" data-selectable-paragraph="">$ native-image --no-server --no-fallback -cp sis.jar:. Distance<br>...<br>$ ./distance 51.507222 -0.1275 40.7127 -74.0059<br>5570.25 km</span></pre><p id="4a57" data-selectable-paragraph="">We can also build this as a native shared library, instead of an executable. To do that we declare one or more methods as <code>@CEntryPoint</code>.</p><figure><div></div></figure><p id="309f" data-selectable-paragraph="">We donâ€™t need to change our <code>javac</code> command line because GraalVM automatically puts these new APIs onto the classpath. We can then compile to a shared library, and an automatically generated header file.</p><pre><span id="80c0" data-selectable-paragraph="">$ native-image --no-server -cp sis.jar:. --shared -H:Name=libdistance<br>$ otool -L libdistance.dylib   # .so on Linux<br>libdistance.dylib:<br>  .../graalvm-ten-things/libdistance.dylib (compatibility version 0.0.0, current version 0.0.0)<br>/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.250.1)<br>CoreFoundation (compatibility version 150.0.0, current version 1575.17.0)<br>/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)<br>$ du -h libdistance.dylib<br>1.8M  libdistance.dylib</span></pre><p id="528a" data-selectable-paragraph="">We can then write a little C program to use the library. The interface to our native library does have a little ceremony â€” because the VM needs to manage a heap, threads, a garbage collector and other services, we need to create an instance of the system, and tell it about our main thread.</p><figure><div></div></figure><p id="c531" data-selectable-paragraph="">We compile this with our standard system tools and can run our executable (set <code>LD_LIBRARY_PATH=.</code> on Linux).</p><pre><span id="6052" data-selectable-paragraph="">$ clang -I. -L. -ldistance distance.c -o distance<br>$ otool -L distance<br>distance:<br>.../graalvm-blog-post/libdistance.dylib (compatibility version 0.0.0, current version 0.0.0)<br>libSystem.B.dylib (compatibility version 1.0.0, current version 1252.250.1)<br>$ ./distance 51.507222 -0.1275 40.7127 -74.0059<br>5570.25 km</span></pre><p id="eebd" data-selectable-paragraph="">This is an eighth thing we can do with GraalVM â€” compile Java code to a native library that we can then use in native applications without using a full JVM.</p><p id="7415" data-selectable-paragraph="">One application of the polyglot library for embedding languages is in the Oracle Database. Weâ€™ve used it to create the Oracle Database Multilingual Engine (MLE) which includes support for using GraalVM languages and modules from SQL.</p><p id="6f89" data-selectable-paragraph="">For example, say that we have a frontend already written in JavaScript, and weâ€™re doing some validation of email addresses using the JavaScript module <code>validator</code>. If we have some logic for the same application in the database written in SQL or PLSQL we'd like to be able to use exactly the same validator so that the results are the same.</p><p id="bf3c" data-selectable-paragraph="">You can download the MLE as Docker image from <a href="https://oracle.github.io/oracle-db-mle/releases/0.2.7/docker/" target="_blank" rel="noopener nofollow">https://oracle.github.io/oracle-db-mle/releases/0.2.7/docker/</a>. Then load it into Docker.</p><pre><span id="1fd4" data-selectable-paragraph="">$ docker load --input mle-docker-0.2.7.tar.gz</span></pre><p id="2cbd" data-selectable-paragraph="">We want to run the image, and then when itâ€™s finished loading, which can take a few minutes, execute a Bash terminal in it.</p><pre><span id="0f33" data-selectable-paragraph="">$ docker run mle-docker-0.2.7<br>$ docker ps<br>$ docker exec -ti &lt;container_id&gt; bash -li</span></pre><p id="8aae" data-selectable-paragraph="">If we can run the interactive SQL tool, <code>sqlplus</code>, in this Bash terminal to connect to the database then it's up and running.</p><pre><span id="5462" data-selectable-paragraph="">$ sqlplus scott/tiger@localhost:1521/ORCLCDB</span></pre><p id="6046" data-selectable-paragraph="">Now, still in the Bash terminal running in Docker, we install that <code>validator</code> module and then we run a command <code>dbjs</code> to deploy it into the database. Then we run <code>sqlplus</code> again.</p><pre><span id="70ca" data-selectable-paragraph="">$ npm install validator<br>$ npm install @types/validator<br>$ dbjs deploy -u scott -p tiger -c localhost:1521/ORCLCDB validator<br>$ sqlplus scott/tiger@localhost:1521/ORCLCDB</span></pre><p id="a7f9" data-selectable-paragraph="">We can now use the <code>validator</code> module as part of an SQL expression.</p><pre><span id="7699" data-selectable-paragraph="">SQL&gt; select validator.isEmail('hello.world@oracle.com') from dual;</span><span id="04c0" data-selectable-paragraph="">VALIDATOR.ISEMAIL('HELLO.WORLD@ORACLE.COM')<br>-------------------------------------------<br>                                          1</span><span id="8eb4" data-selectable-paragraph="">SQL&gt; select validator.isEmail('hello.world') from dual;</span><span id="0a31" data-selectable-paragraph="">VALIDATOR.ISEMAIL('HELLO.WORLD')<br>--------------------------------<br>                               0</span></pre><p id="af7a" data-selectable-paragraph="">This is our ninth thing that you can do with GraalVM â€” run GraalVM languages inside the Oracle Database so that you can use the same logic from your frontends or backends inside your Database logic, instead of always having to pull it out of the database to an application server.</p><p id="92ea" data-selectable-paragraph="">Oracle Labs and our academic collaborators have been able to make new high-performance implementations of JavaScript, R, Ruby, Python and C with a relatively small team because we have developed the Truffle framework to make this easy.</p><p id="c469" data-selectable-paragraph="">Truffle is a Java library that helps you to write an <em>abstract syntax tree</em> (AST) interpreter for a language. An AST interpreter is probably the simplest way to implement a language, because it works directly on the output of the parser and doesnâ€™t involve any bytecode or conventional compiler techniques, but it is often slow. We have therefore combined it with a technique called <em>partial evaluation</em>, which allows Truffle to use the GraalVM compiler to automatically provide a just-in-time compilation for your language, just based on your AST interpreter.</p><p id="b68a" data-selectable-paragraph="">You can use Truffle to implement your own new programming language, to create a high-performance implementation of an existing programming language, or to implement a domain specific language. We talk a lot about the details of Truffle and Graal in our project, but we often forget to mention that Truffle is the <em>easy</em> way to implement a language. And you get features like the debugger automatically. Anyone whoâ€™s done just an undergraduate course in programming language implementation should have the basic skills needed. Oracle Labs implemented a basic version of Ruby faster than any previous efforts with just one intern over a few months.</p><p id="0157" data-selectable-paragraph="">We donâ€™t have space here to show a complete language, even a tiny one, but <a href="https://github.com/graalvm/simplelanguage" target="_blank" rel="noopener nofollow">SimpleLanguage</a> is an executable tutorial of how to create your own language using Truffle, based around a simplified JavaScript-style language. For example <a href="https://github.com/graalvm/simplelanguage/blob/master/language/src/main/java/com/oracle/truffle/sl/nodes/controlflow/SLIfNode.java" target="_blank" rel="noopener nofollow">see the implementation</a> of the <code>if</code> statement.</p><p id="ea3d" data-selectable-paragraph="">Other languages written using Truffle by people outside of Oracle Labs includes a <a href="https://github.com/SOM-st/TruffleSOM" target="_blank" rel="noopener nofollow">Smalltalk variant</a>, a <a href="https://github.com/smarr/SOMns" target="_blank" rel="noopener nofollow">Newspeak variant</a>, and a <a href="https://github.com/cesquivias/mumbler" target="_blank" rel="noopener nofollow">Lisp variant</a>. The Lisp example has a <a href="http://cesquivias.github.io/" target="_blank" rel="noopener nofollow">tutorial</a> you can follow.</p><p id="fadb" data-selectable-paragraph="">GraalVM enables a very diverse set of new functionality â€” itâ€™s a platform on which you can build more powerful languages and tools and put them into more environments. It lets you pick the language and modules you want no matter where the program is running or which languages youâ€™re using already.</p><p id="e1ea" data-selectable-paragraph="">To try GraalVM go to <a href="https://www.graalvm.org/" target="_blank" rel="noopener nofollow">https://www.graalvm.org/</a>. There are links to downloads and documentation there, and more examples like weâ€™ve shown in this blog post.</p><p id="9d5c" data-selectable-paragraph="">Try following along with the instructions here, and try adapting them to see what else you can do. Let us know how youâ€™re experimenting with GraalVM in your application and send us any feedback <a href="https://twitter.com/ChrisGSeaton" target="_blank" rel="noopener nofollow">@ChrisGSeaton</a> or <a href="https://twitter.com/shelajev" target="_blank" rel="noopener nofollow">@shelajev</a>.</p></div></div></section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>