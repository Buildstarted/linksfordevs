<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The problem with being second -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook" xmlns=""><div id="readInner" class="margin-medium size-medium"><h1>The problem with being second</h1><div><div class="postview" xmlns="http://www.w3.org/1999/xhtml"><p>First, hats off to the <a href="https://web.archive.org/web/20080214220258/http://www.mono-project.com/about/index.html">Mono team</a>.&nbsp; I think they've done a great job at writing some great software, but also at proving that evil MS really does know how to produce a truly common language runtime that can be properly standardized and ported to other platforms and&nbsp;languages.</p><p>Now for the meat of my blog.&nbsp; Working on the AMD64 JIT for the runtime is really fun, but it has a few downsides.&nbsp; You we are the 'second' JIT that MS has written.&nbsp; As such the knee-jerk reaction of testers is not to consult the spec and see if what we're doing is different, but acceptable.&nbsp; Instead they blindly compare it to the first JIT (the x86 JIT) and if it's different and it breaks their test, it must be wrong.&nbsp; As we all know, 2 different implementations of the same spec are going to behave differently.</p><p>The biggest difference I see is that the AMD64 JIT has borrowed a lot of code and optimizations from the native AMD64 compiler.&nbsp; Because of this, we perform some optimizations that are 100% legal according to the CLR spec, but that are certainly unexpected by those who have been using the x86 JIT for a while.&nbsp; Almost all of these examples stem from end users not writing proper thread safe code.</p><p>Here's a real example from System.Collections.Hashtable:</p><p><code>private bucket[] buckets;</code></p><p><code>public virtual bool ContainsKey(Object key) {<br>if (key == null) {<br>throw new ArgumentNullException("key", Environment.GetResourceString("ArgumentNull_Key"));<br>}</code></p><p>&nbsp;&nbsp;&nbsp; uint seed;<br>uint incr;<br><strong><span>&nbsp;&nbsp;&nbsp; // Take a snapshot of buckets, in case another thread resizes table<br></span>&nbsp;&nbsp;&nbsp; bucket[] lbuckets = buckets;<br></strong>&nbsp;&nbsp;&nbsp; uint hashcode = InitHash(key, <strong>lbuckets.Length</strong>, out seed, out incr);<br>int&nbsp; ntry = 0;<br>bucket b;<br>int bucketNumber = (int) (seed % (uint)<strong>lbuckets.Length</strong>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>do {<br>b = <strong>lbuckets</strong>[bucketNumber];<br>if (b.key == null) {<br>return false;<br>}<br>if (((b.hash_coll &amp;&nbsp; 0x7FFFFFFF) == hashcode) &amp;&amp;&nbsp;<br>KeyEquals (b.key, key))<br>return true;<br>bucketNumber = (int) (((long)bucketNumber + incr)% (uint)<strong>lbuckets.Length</strong>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>} while (b.hash_coll &lt; 0 &amp;&amp; ++ntry &lt; lbuckets.Length);<br>return false;<br>}<br></p><p>I added the emphasis.&nbsp; Notice the comment that indicates the code is assuming that <code>this.buckets</code> will change on another thread. With the x86 JIT, simply copying the member into a local was enough.&nbsp; However, the AMD64 JIT applied some simple copy-propagation to this code and realized that since the this pointer was already enregistered, it was easy to access <code>this.buckets</code> as a simple indirection. So the AMD64 JIT completely ignores the local copy.&nbsp;At this point some of you might be thinking that was an illegal optimization.&nbsp; It's not.&nbsp; Go read the specs and study your compiler theory.</p><p>There is exactly one thing needed to correct this method.&nbsp; Its the volatile keyword.&nbsp; By simply marking the buckets member as being volatile, then the JIT <strong>cannot</strong> add or remove reads or writes to it, thus it cannot copy-prop.</p><p>As a side note, I believe this code really is fine even if the buckets array does get bigger on another thread.&nbsp; It would only have a problem it buckets got smaller after bucketNumber was calculated, but before it was used to index into the array.&nbsp; Don't quote me on this, but&nbsp;I vaguely remember that Hashtable never does resize smaller, so this really is a total non-issue, but still a good example.</p><p>--Grant</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>