<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using Bing Maps in Blazor with JSInterop and TypeScript -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Using Bing Maps in Blazor with JSInterop and TypeScript</h1><div><div class="ac ae af ag ah ec aj ak"><p id="c86f" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">In this article we are going to work with the Bing Maps web control in a client side Blazor application. As there is not a Blazor native Bing Maps control we will be using TypeScript to access the Bing Maps API. In order to communicate with TypeScript from C# we will be making use of <code class="he hf hg hh hi b">JSRuntime</code> calls in Blazor.</p><figure class="hk hl hm hn ho hp do dp paragraph-image"><h1 id="27ce" class="if ig ef at as ih eh ii ej ij ik il im in io ip iq">Getting started</h1><p id="9d99" class="gq gr ef at gs b gt ir gv is gx it gz iu hb iv hd dx">All the work in this article is being done with Visual Studio 2019 Community Edition 16.1 Preview 3. Everything will work with .Net Core 3 Preview 4 or Preview 5. Start a new project using the Blazor (ASP.Net Core Hosted) template.</p><p id="af8e" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">To use this you will also need your own Bing Maps API key. You can sign up for your own free key at <a href="https://www.bingmapsportal.com/" class="dc by iw ix iy iz" target="_blank" rel="noopener">https://www.bingmapsportal.com/</a> .</p><p id="14d1" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">I am doing all of my client side Blazor development using MVVM. That is not part of this article, but if you are wondering why I’m creating folders in my project named Views and Models that is the reason. If you are interested in reading my Blazor MVVM articles the first article is linked below.</p><h1 id="1401" class="if ig ef at as ih eh ii ej ij ik il im in io ip iq">Setting up the Bing Maps API</h1><p id="f8d2" class="gq gr ef at gs b gt ir gv is gx it gz iu hb iv hd dx">The Bing Maps 8 Web API is a Microsoft Javascript API. To make it accessible to the TypeScript we will be writing we are going to add a <code class="he hf hg hh hi b">&lt;script&gt;</code> tag to the <code class="he hf hg hh hi b">index.html</code> in our <code class="he hf hg hh hi b">wwwroot</code> folder of our client project. Edit <code class="he hf hg hh hi b">index.html</code> and add this line right before <code class="he hf hg hh hi b">&lt;/body&gt;</code>:</p><pre class="hk hl hm hn ho jx jy cm"><span id="3060" class="jz ig ef at hi b fi ka kb r kc">&lt;script type='text/javascript' src='https://www.bing.com/api/maps/mapcontrol?key=MyBingKey' &gt;&lt;/script&gt;</span></pre><p id="857d" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">Make sure you edit the above line to replace MyBingKey with your actual key you received when you registered. With that in place the Bing Maps API will now be available to your code.</p><h1 id="60c2" class="if ig ef at as ih eh ii ej ij ik il im in io ip iq">Setting up our Blazor component</h1><p id="edda" class="gq gr ef at gs b gt ir gv is gx it gz iu hb iv hd dx">Bing Maps requires the name of a <code class="he hf hg hh hi b">&lt;div&gt;</code> to initialize itself. To make this available to Bing we are going to add a new component to the Blazor sample template and put the needed &lt;div&gt; in it. For my project I made a new folder and named it Views and inside of that folder I added a new Razor View and named it <code class="he hf hg hh hi b">SiteMapper.razor</code>. You can use whatever naming you are comfortable with, mine is specific to a mapping project that I am working on. Inside of your new component enter the following code:</p><figure class="hk hl hm hn ho hp"><p id="558f" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">For some reason setting height to 100% doesn’t work but using the viewport height relative length does. We now have a <code class="he hf hg hh hi b">&lt;div&gt;</code> with the id myMap which Bing Maps can use.</p><p id="ef2a" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">After our component is created we need to go add it to <code class="he hf hg hh hi b">NavMenu.razor</code> in the <code class="he hf hg hh hi b">Pages</code> folder to make it appear when we launch our application. We will also need to make a copy of <code class="he hf hg hh hi b">_Imports.razor</code> and place it into our Views folder.</p><h1 id="4ded" class="if ig ef at as ih eh ii ej ij ik il im in io ip iq">Setting up TypeScript</h1><p id="eada" class="gq gr ef at gs b gt ir gv is gx it gz iu hb iv hd dx">Blazor will already compile TypeScript that is added to the built in client project out of the box; we only need to set up our folder structure. We are also going to add the Bing Map 8 TypeScript definition files to our project to give us Intellisense for Bing Maps when we are editing our TypeScript. Underneath our <code class="he hf hg hh hi b">wwwroot</code> folder add a new folder and name it ts. To get our definitions for Intellisense go here and down load the definition files:</p><p id="2b37" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">Make a new folder under your <code class="he hf hg hh hi b">ts</code> folder and name it <code class="he hf hg hh hi b">types</code>. Copy everything from below the <code class="he hf hg hh hi b">types</code> folder in the definitions you just downloaded into that folder. Also make an <code class="he hf hg hh hi b">interfaces</code> folder below your <code class="he hf hg hh hi b">ts</code> folder which we will use a little bit later. Your folder structure under TS will look like this:</p><figure class="hk hl hm hn ho hp do dp paragraph-image"><p id="b013" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">With our folders set up and our definitions in place we can add our first TypeScript file. In the <code class="he hf hg hh hi b">ts</code> folder add a new TypeScript file and name it <code class="he hf hg hh hi b">BingTsInterop.ts</code>. Inside of that TypeScript file add the following content:</p><figure class="hk hl hm hn ho hp"><p id="b636" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">The first line is a reference which is similar to a using statement in C#. It is telling our TypeScript about the definition files we have available and providing us with IntelliSense. Line 3 is declaring a single instance of our BingMap class which is defined in lines 5 though 15. The class contains an instance of a <code class="he hf hg hh hi b">Map</code> and a constructor which creates a new map which will be placed in the <code class="he hf hg hh hi b">myMap</code> div. The constructor also specifies some <code class="he hf hg hh hi b">MapLoadOptions</code>, in this case the center of the map, the map type and the zoom level.</p><p id="db78" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">The <code class="he hf hg hh hi b">loadMap()</code>function on line 17 through 19 assigns a new instance of our <code class="he hf hg hh hi b">BingMap</code> class to <code class="he hf hg hh hi b">bingMap</code>. This is the function we want to call from JSInterop.</p><h1 id="5c30" class="if ig ef at as ih eh ii ej ij ik il im in io ip iq">Calling <code class="he hf hg hh hi b">loadMap()</code> from Blazor</h1><p id="78ca" class="gq gr ef at gs b gt ir gv is gx it gz iu hb iv hd dx">If we do a build now we will see that <code class="he hf hg hh hi b">BingTSInterop.ts</code> has been compiled to create <code class="he hf hg hh hi b">BingTSInterop.js</code>. Now that we have our output go back into <code class="he hf hg hh hi b">index.html</code> and make it available to our application with this tag:</p><pre class="hk hl hm hn ho jx jy cm"><span id="d13d" class="jz ig ef at hi b fi ka kb r kc">&lt;script src="./ts/BingTsInterop.js"&gt;&lt;/script&gt;</span></pre><p id="1852" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">To add the needed C# to our component lets add a code behind file. In the Views folder add a new C# class and name it <code class="he hf hg hh hi b">SiteMapper.razor.cs</code>. Change the class’ name to <code class="he hf hg hh hi b">SiteMapperBase</code> and have it inherit from <code class="he hf hg hh hi b">ComponentBase</code>. To make a call to TypeScript we will need to also add <code class="he hf hg hh hi b">using MicrosoftJSInterop;</code> to our using statements. Our class will look like this:</p><figure class="hk hl hm hn ho hp"><p id="a2c3" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">The class is pretty simple so far. We have one property, <code class="he hf hg hh hi b">JSRuntime</code> which has been injected to our class and we have are overriding <code class="he hf hg hh hi b">OnAfterRenderAsync()</code> to make our call to <code class="he hf hg hh hi b">loadMap</code>. Because there is no return value from <code class="he hf hg hh hi b">loadMap</code> we are using <code class="he hf hg hh hi b">InvokeAsync&lt;Task&gt;.</code> If there had been a return value we would need an appropriate type specified.</p><p id="f247" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">With our code behind set up we can go back into <code class="he hf hg hh hi b">SiteMapper.razor</code> and add the following line just below the <code class="he hf hg hh hi b">@page</code> directive.</p><pre class="hk hl hm hn ho jx jy cm"><span id="d18c" class="jz ig ef at hi b fi ka kb r kc">@inherits SiteMapperBase</span></pre><p id="09e6" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">With that in place our code behind will now be part our View without needing to keep everything in a single file. At this point we can launch our application.</p><figure class="hk hl hm hn ho hp do dp paragraph-image"><p id="1918" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">As soon as our component finishes rendering we now call our TypeScript <code class="he hf hg hh hi b">loadMap</code> function. We can change the view or settings of the map then navigate to a different control and come back and <code class="he hf hg hh hi b">loadMap</code> will be called again and set it back to the default values.</p><h1 id="f566" class="if ig ef at as ih eh ii ej ij ik il im in io ip iq">Adding a marker</h1><p id="f603" class="gq gr ef at gs b gt ir gv is gx it gz iu hb iv hd dx">Now that we have a map let’s do something with it. A pretty common task with maps is to place a pushpin on it. There is a very large repository of Bing Maps samples at <a href="https://bingmapsv8samples.azurewebsites.net/" class="dc by iw ix iy iz" target="_blank" rel="noopener">https://bingmapsv8samples.azurewebsites.net/</a> . I’m a fan of the SVG Template Pushpin (it looks clean and the color is easy to set) so let’s look at that code:</p><figure class="hk hl hm hn ho hp"><p id="f59d" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">There’s a bit of code but most of it is static code to making the pin. The main points of interest to us are the call to <code class="he hf hg hh hi b">map.getCenter()</code> on the first line which determines the location of the pin in that code sample and then on line 10 where the color gets set to blue. If we can pass in the location and color we will have a reusable pushpin. Our goal is to wire up all of ourTypeScript in a way that we can forget that it is there and focus on doing the real work in Blazor. In order to do that we need a reliable way to pass data in to TypeScript.</p><p id="674c" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">We can see by looking at the code that <code class="he hf hg hh hi b">color</code> is a string but what is <code class="he hf hg hh hi b">map.getCenter()</code>? If we type that function into our TypeScript file we can mouse hover over it and see that it returns a <code class="he hf hg hh hi b">Microsoft.Maps.Location</code>. We’re already using that type in the <code class="he hf hg hh hi b">BingMap</code> constructor. If we mouse hover over that type we can see <code class="he hf hg hh hi b">constructor Microsoft.Maps.Location(latitude:any, longitude:any)</code> so it looks like we need to pass a color, latitude and longitude into TypeScript to generate a custom pushpin. How do we send all 3 values over using JSInterop? We could send them as 3 objects using <code class="he hf hg hh hi b">args[]</code> but I have a feeling that will make our code harder to read. It would be better if they were all members of one object.</p><h1 id="3265" class="if ig ef at as ih eh ii ej ij ik il im in io ip iq">TypeScript Interfaces</h1><p id="c452" class="gq gr ef at gs b gt ir gv is gx it gz iu hb iv hd dx">TypeScript, just like C#, allows us to write interfaces to use as contracts in our code. We are going to create a Typescript interface for our input and then create the same data structure in C# and pass it in from Blazor. If everything works as expected we’ll be able to create our own object in Blazor and pass it directly to TypeScript.</p><p id="33c3" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">Go to the <code class="he hf hg hh hi b">wwwroot/ts/interfaces</code> folder we created earlier and create a new TypeScript file in it and name it <code class="he hf hg hh hi b">BingMapsInterfaces.ts</code>. We decided we wanted a string and a location earlier so put this code into the file:</p><figure class="hk hl hm hn ho hp"><p id="e161" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">This is the syntax for a TypeScript interface. We first declare an interface and name it and then declare the members. Except for the typing syntax it is really close to C#. In order to make this interface available to our code we will add a new reference to <code class="he hf hg hh hi b">BingTsInterop.ts</code>.</p><pre class="hk hl hm hn ho jx jy cm"><span id="5d17" class="jz ig ef at hi b fi ka kb r kc">/// &lt;reference path="interfaces/BingMapsInterfaces.ts" /&gt;</span></pre><p id="ec90" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">That statement makes anything we create in <code class="he hf hg hh hi b">BingMapsInterfaces.ts</code> available to our code. Next we will go back to our Blazor code and create what we hope will be a matching class.</p><p id="e568" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">Make a <code class="he hf hg hh hi b">Models</code> folder in the client project and then create a new C# class and name it <code class="he hf hg hh hi b">BingMapObjects.cs</code>. First we will create our <code class="he hf hg hh hi b">Location</code> class. In Typescript we had <code class="he hf hg hh hi b">number</code> for latitude and longitude, here we will use <code class="he hf hg hh hi b">double</code>. We will also add a constructor to make our code cleaner when we are assigning values.</p><figure class="hk hl hm hn ho hp"><p id="d998" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">With the <code class="he hf hg hh hi b">Location</code> defined we can now make a <code class="he hf hg hh hi b">Pushpin</code> class. This will simply be the color and the location.</p><figure class="hk hl hm hn ho hp"><p id="706c" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">If we wired up everything correctly we will be able to add a pushpin to our map from Blazor now. Go back into <code class="he hf hg hh hi b">SiteMapper.razor.cs</code> and add this code to our <code class="he hf hg hh hi b">OnAfterRenderAsync</code> method:</p><figure class="hk hl hm hn ho hp"><p id="8052" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">Now create the <code class="he hf hg hh hi b">AddPushpin</code> function in BingTsInterop.ts:</p><figure class="hk hl hm hn ho hp"><p id="822e" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">We have created a TypeScript function which accepts a <code class="he hf hg hh hi b">BingPin</code> and has no return value. We can see that we are passing in the location as well as the color from <code class="he hf hg hh hi b">sitePin</code> which we have passed in from our C# code. The second statement of the function simply places the pushpin we created onto the map. If we launch our application again we should now see a green pushpin.</p><figure class="hk hl hm hn ho hp do dp paragraph-image"><h1 id="3746" class="if ig ef at as ih eh ii ej ij ik il im in io ip iq">Adding a Polygon</h1><p id="f460" class="gq gr ef at gs b gt ir gv is gx it gz iu hb iv hd dx">Adding a polygon to the map is another common task. If we look at the code sample for a basic polygon on the github repository it doesn’t look too complicated:</p><figure class="hk hl hm hn ho hp"><p id="2092" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">The code gets the center of the map the uses two additional points to define a triangle. These points are put into <code class="he hf hg hh hi b">exteriorRing</code>. Each polygon is made up of one or more rings. The first ring is the exterior ring which defines the polygon and it’s fill area. Each ring after the first one is an interior ring which defines areas inside of the polygon which become holes in the polygon.</p><p id="5328" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">The actual constructor comes next and it doesn’t look to bad. First is the exterior ring, then a string for the fill color, a string for the stroke color and a number for the stroke thickness. It shouldn’t be too difficult to define the interface and class to pass this information in to Typescript.</p><p id="5cbd" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">Temporarily adding a polygon constructor to our typescript code and mouse hovering over it shows something interesting.</p><pre class="hk hl hm hn ho jx jy cm"><span id="6375" class="jz ig ef at hi b fi ka kb r kc">constructor Microsoft.Maps.Polygon(rings: Microsoft.Maps.Location[] | Microsoft.Maps.Location[][], options?: Microsoft.Maps.IPolygonOptions)</span></pre><p id="984d" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">It looks like the first argument can either be a single ring or an array of rings (a ring is a Location[]). Also the options parameter is not required but we will supply it because we want to make use of it. If we are going to define a single interface which will allow one or multiple rings we will have to define it to be <code class="he hf hg hh hi b">Microsoft.Maps.Location[][]</code> even if we are only passing a single ring. Go back into <code class="he hf hg hh hi b">BingMapsInterfaces.ts</code> and add this code to define an interface for our options:</p><figure class="hk hl hm hn ho hp"><p id="1926" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">That was just a straight list of the three options we want to provide. Next we can define the actual polygon object we want to pass in from Blazor:</p><figure class="hk hl hm hn ho hp"><p id="a86d" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">As discussed earlier we are always going to use the syntax for multiple rings even if we are only passing a single ring.</p><p id="01b9" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">With the interfaces defined this way the function to add our polygon to the map becomes pretty short. Go back into BingTsInterop.ts and add this function:</p><figure class="hk hl hm hn ho hp"><p id="4c44" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">We just call the constructor and push it to the map and we are done.</p><h1 id="246a" class="if ig ef at as ih eh ii ej ij ik il im in io ip iq">Making a circle</h1><p id="a22b" class="gq gr ef at gs b gt ir gv is gx it gz iu hb iv hd dx">Some business requirements necessitated coming up with code that could create a circle roughly 10 miles in diameter centered on a specified point. Instead of picking points by hand we are going to use that code in this article. Create a new class <code class="he hf hg hh hi b">MapCircle.cs</code> in the <code class="he hf hg hh hi b">Models</code> folder and paste in this code:</p><figure class="hk hl hm hn ho hp"><p id="bfc5" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">That code uses math to make a circle out of points around a center point. The loop near the bottom uses 3 as the interval so that a circle is only made of 120 points instead of 360 points. That number can be raised or lowered as needed for resolution or performance.</p><p id="0689" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">We now have to go back to BingMapsObjects.cs and add the classes in there to match our TypeScript interfaces. Looking at the Typescript our C# classes wind up looking like this:</p><figure class="hk hl hm hn ho hp"><p id="488a" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">It’s a 1 for 1 mapping and should work when we make the JSInterop call. All that’s left now is to add the code to create our Polygon to <code class="he hf hg hh hi b">SiteMapper.razor.cs</code>. Here is all of the needed code:</p><figure class="hk hl hm hn ho hp"><p id="c7af" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">This code first declares a new <code class="he hf hg hh hi b">Polygon</code> then declares a <code class="he hf hg hh hi b">List&lt;Location[]&gt;</code> for the rings. <code class="he hf hg hh hi b">List&lt;T&gt;</code> is easier to work with and has the handy <code class="he hf hg hh hi b">.ToArray()</code> method. In line 3 we call <code class="he hf hg hh hi b">DrawMapCircle</code> and add the circle as our first (the exterior) ring. In lines 4 through 6 we draw a smaller circle and reverse its direction then add it as the second ring. If the interior ring does not go in the opposite direction of the exterior ring it will not render properly. Line 7 turns our <code class="he hf hg hh hi b">List</code> of rings into an <code class="he hf hg hh hi b">Array</code>. The rest of the code instantiates the <code class="he hf hg hh hi b">PolygonOptions</code> and sets the values we want to pass in. Finally line 13 calls the <code class="he hf hg hh hi b">AddPolygon</code> method we created in TypeScript. If we run our application now we should see a donut sort of shape on our map.</p><figure class="hk hl hm hn ho hp do dp paragraph-image"><h1 id="01c6" class="if ig ef at as ih eh ii ej ij ik il im in io ip iq">Wrapping Up</h1><p id="7e43" class="gq gr ef at gs b gt ir gv is gx it gz iu hb iv hd dx">In this article we took our first look at using the Bing Maps 8 web control in a client side Blazor application. We started off with getting an API key and making the API available to our code. We followed that up by setting up our TypeScript folders and adding the Bing Map type definitions to give us Intellisense for Bing in Typescript. Finally we went through how to initialized the map and add pushpins and polygons to it. In that process we also covered using TypeScript interfaces to cleanly pass data from C# to Typescript.</p><p id="ff10" class="gq gr ef at gs b gt gu gv gw gx gy gz ha hb hc hd dx">There is a lot more to the Bing Maps 8 API and we have just scratched the surface. Next time we may cover addtional functions of the API or we may dive into the Bing Maps REST API. If you have questions or comments you can leave them here or reach out to me @LouisHendricks on Twitter.</p></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>