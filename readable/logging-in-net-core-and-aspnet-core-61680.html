<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Logging in .NET Core and ASP.NET Core - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Logging in .NET Core and ASP.NET Core - linksfor.dev(s)"/>
    <meta property="article:author" content="Rick-Anderson"/>
    <meta property="og:description" content="Learn how to use the logging framework provided by the Microsoft.Extensions.Logging NuGet package."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0#create-a-custom-logger"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Logging in .NET Core and ASP.NET Core</title>
<div class="readable">
        <h1>Logging in .NET Core and ASP.NET Core</h1>
            <div>by Rick-Anderson</div>
            <div>Reading time: 85-108 minutes</div>
        <div>Posted here: 14 May 2020</div>
        <p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0#create-a-custom-logger">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0#create-a-custom-logger</a></p>
        <hr/>
<div id="readability-page-1" class="page">


	<div data-bi-name="body">

		<div>

			

			<section>
				<div>


				<div id="main-column">

					<main id="main" role="main" data-bi-name="content" lang="en-us" dir="ltr">



						

						<ul data-bi-name="page info" lang="en-us" dir="ltr">
							<li>
								<time data-article-date="" aria-label="Article review date" datetime="2020-05-09T00:00:00.000Z" data-article-date-source="ms.date">05/09/2020</time>
							</li>
								<li>55 minutes to read</li>
								<li>
									<a href="https://github.com/dotnet/AspNetCore.Docs/blob/master/aspnetcore/fundamentals/logging/index.md" title="23 Contributors" aria-label="23 Contributors">
										
									</a>
								</li>
						</ul>

						<nav id="center-doc-outline" data-bi-name="intopic toc" role="navigation" aria-label="Article Outline">
							<h3>In this article</h3>
						<ol><li><a href="#logging-providers">Logging providers</a></li><li><a href="#create-logs">Create logs</a></li><li><a href="#configure-logging">Configure logging</a></li><li><a href="#set-log-level-by-command-line-environment-variables-and-other-configuration">Set log level by command line, environment variables, and other configuration</a></li><li><a href="#how-filtering-rules-are-applied">How filtering rules are applied</a></li><li><a href="#logging-output-from-dotnet-run-and-visual-studio">Logging output from dotnet run and Visual Studio</a></li><li><a href="#log-category">Log category</a></li><li><a href="#log-level">Log level</a></li><li><a href="#log-event-id">Log event ID</a></li><li><a href="#log-message-template">Log message template</a></li><li><a href="#log-exceptions">Log exceptions</a></li><li><a href="#aspnet-core-and-ef-core-categories">ASP.NET Core and EF Core categories</a></li><li><a href="#log-scopes">Log scopes</a></li><li><a href="#built-in-logging-providers">Built-in logging providers</a></li><li><a href="#third-party-logging-providers">Third-party logging providers</a></li><li><a href="#non-host-console-app">Non-host console app</a></li><li><a href="#log-during-host-construction">Log during host construction</a></li><li><a href="#configure-a-service-that-depends-on-ilogger">Configure a service that depends on ILogger</a></li><li><a href="#create-logs-in-main">Create logs in Main</a></li><li><a href="#change-log-levels-in-a-running-app">Change log levels in a running app</a></li><li><a href="#ilogger-and-iloggerfactory">ILogger and ILoggerFactory</a></li><li><a href="#apply-log-filter-rules-in-code">Apply log filter rules in code</a></li><li><a href="#create-a-custom-logger">Create a custom logger</a></li><li><a href="#additional-resources">Additional resources</a></li></ol></nav>

						<!-- <content> -->
							
<div data-moniker="aspnetcore-3.0 aspnetcore-3.1 aspnetcore-5.0">
<p>By <a href="https://twitter.com/serpent5" data-linktype="external">Kirk Larkin</a>, <a href="https://github.com/JuergenGutsch" data-linktype="external">Juergen Gutsch</a> and <a href="https://twitter.com/RickAndMSFT" data-linktype="external">Rick Anderson</a></p>
<p>.NET Core supports a logging API that works with a variety of built-in and third-party logging providers. This article shows how to use the logging API with built-in providers.</p>
<p>Most of the code examples shown in this article are from ASP.NET Core apps. The logging-specific parts of these code snippets apply to any .NET Core app that uses the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.0" data-linktype="relative-path">Generic Host</a>. The ASP.NET Core web app templates use the Generic Host.</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/logging/index/samples/3.x" data-linktype="external">View or download sample code</a> (<a href="https://docs.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.0#how-to-download-a-sample" data-linktype="relative-path">how to download</a>)</p>

<h2 id="logging-providers">Logging providers<a href="#logging-providers" aria-labelledby="logging-providers"></a></h2>
<p>Logging providers store logs, except for the <code>Console</code> provider which displays logs. For example, the Azure Application Insights provider stores logs in Azure Application Insights. Multiple providers can be enabled.</p>
<p>The default ASP.NET Core web app templates:</p>
<ul>
<li>Use the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.0" data-linktype="relative-path">Generic Host</a>.</li>
<li>Call <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.host.createdefaultbuilder" data-linktype="absolute-path">CreateDefaultBuilder</a>, which adds the following logging providers:
<ul>
<li><a href="#console-provider" data-linktype="self-bookmark">Console</a></li>
<li><a href="#debug-provider" data-linktype="self-bookmark">Debug</a></li>
<li><a href="#event-source-provider" data-linktype="self-bookmark">EventSource</a></li>
<li><a href="#welog" data-linktype="self-bookmark">EventLog</a> : Windows only</li>
</ul>
</li>
</ul>
<pre tabindex="0"><code highlight-lines="9" data-author-content="public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
"><span><span>public</span> <span>class</span> <span>Program</span>
{
    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        CreateHostBuilder(args).Build().Run();
    }

    <span><span>public</span> <span>static</span> IHostBuilder <span>CreateHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;</span>
<mark>        Host.CreateDefaultBuilder(args)</mark>
<span>            .ConfigureWebHostDefaults(webBuilder =&gt;
            {
                webBuilder.UseStartup&lt;Startup&gt;();
            });
}
</span></code></pre>
<p>The preceding code shows the <code>Program</code> class created with the ASP.NET Core web app templates. The next several sections provide samples based on the ASP.NET Core web app templates, which use the Generic Host. <a href="#nhca" data-linktype="self-bookmark">Non-host console apps</a> are discussed later in this document.</p>
<p>To override the default set of logging providers added by <code>Host.CreateDefaultBuilder</code>, call <code>ClearProviders</code> and add the required logging providers. For example, the following code:</p>
<ul>
<li>Calls <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggingbuilderextensions.clearproviders" data-linktype="absolute-path">ClearProviders</a> to remove all the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggerprovider" data-linktype="absolute-path">ILoggerProvider</a> instances from the builder.</li>
<li>Adds the <a href="#console-provider" data-linktype="self-bookmark">Console</a> logging provider.</li>
</ul>
<pre tabindex="0"><code highlight-lines="5-6" data-author-content="public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureLogging(logging =>
        {
            logging.ClearProviders();
            logging.AddConsole();
        })
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseStartup<Startup>();
        });
"><span><span><span>public</span> <span>static</span> IHostBuilder <span>CreateHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureLogging(logging =&gt;
        {</span>
<mark>            logging.ClearProviders();
            logging.AddConsole();</mark>
<span>        })
        .ConfigureWebHostDefaults(webBuilder =&gt;
        {
            webBuilder.UseStartup&lt;Startup&gt;();
        });
</span></code></pre>
<p>For additional providers, see:</p>
<ul>
<li><a href="#bilp" data-linktype="self-bookmark">Built-in logging providers</a></li>
<li><a href="#third-party-logging-providers" data-linktype="self-bookmark">Third-party logging providers</a>.</li>
</ul>
<h2 id="create-logs">Create logs<a href="#create-logs" aria-labelledby="create-logs"></a></h2>
<p>To create logs, use an <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger-1" data-linktype="absolute-path">ILogger&lt;TCategoryName&gt;</a> object from <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.0" data-linktype="relative-path">dependency injection</a> (DI).</p>
<p>The following example:</p>
<ul>
<li>Creates a logger, <code>ILogger&lt;AboutModel&gt;</code>, which uses a log <em>category</em> of the fully qualified name of the type <code>AboutModel</code>. The log category is a string that is associated with each log.</li>
<li>Calls <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.loginformation" data-linktype="absolute-path">LogInformation</a> to log at the <code>Information</code> level. The Log <em>level</em> indicates the severity of the logged event.</li>
</ul>
<pre tabindex="0"><code highlight-lines="5,14" data-author-content="public class AboutModel : PageModel
{
    private readonly ILogger _logger;

    public AboutModel(ILogger<AboutModel> logger)
    {
        _logger = logger;
    }
    public string Message { get; set; }

    public void OnGet()
    {
        Message = $&quot;About page visited at {DateTime.UtcNow.ToLongTimeString()}&quot;;
        _logger.LogInformation(Message);
    }
}
"><span><span>public</span> <span>class</span> <span>AboutModel</span> : <span>PageModel</span>
{
    <span>private</span> <span>readonly</span> ILogger _logger;
</span>
<mark>    <span><span>public</span> <span>AboutModel</span>(<span>ILogger&lt;AboutModel&gt; logger</span>)</span></mark>
<span><span></span>    {
        _logger = logger;
    }
    <span>public</span> <span>string</span> Message { <span>get</span>; <span>set</span>; }

    <span><span>public</span> <span>void</span> <span>OnGet</span>(<span></span>)</span>
    {
        Message = <span>$"About page visited at <span>{DateTime.UtcNow.ToLongTimeString()}</span>"</span>;</span>
<mark>        _logger.LogInformation(Message);</mark>
<span>    }
}
</span></code></pre>
<p><a href="#log-level" data-linktype="self-bookmark">Levels</a> and <a href="#log-category" data-linktype="self-bookmark">categories</a> are explained in more detail later in this document.</p>
<p>For information on Blazor, see <a href="#clib" data-linktype="self-bookmark">Create logs in Blazor and Blazor WebAssembly</a> in this document.</p>
<p><a href="#clms" data-linktype="self-bookmark">Create logs in Main and Startup</a> shows how to create logs in <code>Main</code> and <code>Startup</code>.</p>
<h2 id="configure-logging">Configure logging<a href="#configure-logging" aria-labelledby="configure-logging"></a></h2>
<p>Logging configuration is commonly provided by the <code>Logging</code> section of <em>appsettings</em>.<code>{Environment}</code><em>.json</em> files. The following <em>appsettings.Development.json</em> file is generated by the ASP.NET Core web app templates:</p>
<pre tabindex="0"><code data-author-content="{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Warning&quot;,
      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
    }
  }
}
"><span>{
  <span>"Logging"</span>: {
    <span>"LogLevel"</span>: {
      <span>"Default"</span>: <span>"Information"</span>,
      <span>"Microsoft"</span>: <span>"Warning"</span>,
      <span>"Microsoft.Hosting.Lifetime"</span>: <span>"Information"</span>
    }
  }
}
</span></code></pre>
<p>In the preceding JSON:</p>
<ul>
<li>The <code>"Default"</code>, <code>"Microsoft"</code>, and <code>"Microsoft.Hosting.Lifetime"</code> categories are specified.</li>
<li>The <code>"Microsoft"</code> category applies to all categories that start with <code>"Microsoft"</code>. For example, this setting applies to the <code>"Microsoft.AspNetCore.Routing.EndpointMiddleware"</code> category.</li>
<li>The <code>"Microsoft"</code> category logs at log level <code>Warning</code> and higher.</li>
<li>The <code>"Microsoft.Hosting.Lifetime"</code> category is more specific than the <code>"Microsoft"</code> category, so the <code>"Microsoft.Hosting.Lifetime"</code> category logs at log level "Information" and higher.</li>
<li>A specific log provider is not specified, so <code>LogLevel</code> applies to all the enabled logging providers except for the <a href="#welog" data-linktype="self-bookmark">Windows EventLog</a>.</li>
</ul>
<p>The <code>Logging</code> property can have <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel" data-linktype="absolute-path">LogLevel</a> and log provider properties. The <code>LogLevel</code> specifies the minimum <a href="#log-level" data-linktype="self-bookmark">level</a> to log for selected categories. In the preceding JSON, <code>Information</code> and <code>Warning</code> log levels are specified. <code>LogLevel</code> indicates the severity of the log and ranges from 0 to 6:</p>
<p><code>Trace</code> = 0, <code>Debug</code> = 1, <code>Information</code> = 2, <code>Warning</code> = 3, <code>Error</code> = 4, <code>Critical</code> = 5, and <code>None</code> = 6.</p>
<p>When a <code>LogLevel</code> is specified, logging is enabled for messages at the specified level and higher. In the preceding JSON, the <code>Default</code> category is logged for <code>Information</code> and higher. For example, <code>Information</code>, <code>Warning</code>, <code>Error</code>, and <code>Critical</code> messages are logged. If no <code>LogLevel</code> is specified, logging defaults to the <code>Information</code> level. For more information, see <a href="#llvl" data-linktype="self-bookmark">Log levels</a>.</p>
<p>A provider property can specify a <code>LogLevel</code> property. <code>LogLevel</code> under a provider specifies levels to log for that provider, and overrides the non-provider log settings. Consider the following <em>appsettings.json</em> file:</p>
<pre tabindex="0"><code data-author-content="{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: { // All providers, LogLevel applies to all the enabled providers.
      &quot;Default&quot;: &quot;Error&quot;, // Default logging, Error and higher.
      &quot;Microsoft&quot;: &quot;Warning&quot; // All Microsoft* categories, Warning and higher.
    },
    &quot;Debug&quot;: { // Debug provider.
      &quot;LogLevel&quot;: {
        &quot;Default&quot;: &quot;Information&quot;, // Overrides preceding LogLevel:Default setting.
        &quot;Microsoft.Hosting&quot;: &quot;Trace &quot; // Debug:Microsoft.Hosting category.
      },
      &quot;EventSource&quot;: { // EventSource provider
        &quot;LogLevel&quot;: {
          &quot;Default&quot;: &quot;Warning&quot; // All categories of EventSource provider.
        }
      }
    }
  }
}
"><span>{
  <span>"Logging"</span>: {
    <span>"LogLevel"</span>: { // All providers, LogLevel applies to all the enabled providers.
      <span>"Default"</span>: <span>"Error"</span>, // Default logging, Error and higher.
      <span>"Microsoft"</span>: <span>"Warning"</span> // All Microsoft* categories, Warning and higher.
    },
    <span>"Debug"</span>: { // Debug provider.
      <span>"LogLevel"</span>: {
        <span>"Default"</span>: <span>"Information"</span>, // Overrides preceding LogLevel:Default setting.
        <span>"Microsoft.Hosting"</span>: <span>"Trace "</span> // Debug:Microsoft.Hosting category.
      },
      <span>"EventSource"</span>: { // EventSource provider
        <span>"LogLevel"</span>: {
          <span>"Default"</span>: <span>"Warning"</span> // All categories of EventSource provider.
        }
      }
    }
  }
}
</span></code></pre>
<p>Settings in <code>Logging.{providername}.LogLevel</code> override settings in <code>Logging.LogLevel</code>. In the preceding JSON, the <code>Debug</code> provider's default log level is set to <code>Information</code>:</p>
<p><code>Logging:Debug:LogLevel:Default:Information</code></p>
<p>The preceding setting specifies the <code>Information</code> log level for every <code>Logging:Debug:</code> category except <code>Microsoft.Hosting</code>. When a specific category is listed, the specific category overrides the default category. In the preceding JSON, the <code>Logging:Debug:LogLevel</code> categories <code>"Microsoft.Hosting"</code> and <code>"Default"</code> override the settings in <code>Logging:LogLevel</code></p>
<p>The minimum log level can be specified for any of:</p>
<ul>
<li>Specific providers:  For example, <code>Logging:EventSource:LogLevel:Default:Information</code></li>
<li>Specific categories: For example, <code>Logging:LogLevel:Microsoft:Warning</code></li>
<li>All providers and all categories: <code>Logging:LogLevel:Default:Warning</code></li>
</ul>
<p>Any logs below the minimum level are <em><strong>not</strong></em>:</p>
<ul>
<li>Passed to the provider.</li>
<li>Logged or displayed.</li>
</ul>
<p>To suppress all logs, specify <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel" data-linktype="absolute-path">LogLevel.None</a>. <code>LogLevel.None</code> has a value of 6, which is higher than <code>LogLevel.Critical</code> (5).</p>
<p>If a provider supports <a href="#logscopes" data-linktype="self-bookmark">log scopes</a>, <code>IncludeScopes</code> indicates whether they're enabled. For more information, see <a href="#logscopes" data-linktype="self-bookmark">log scopes</a></p>
<p>The following <em>appsettings.json</em> file contains all the providers enabled by default:</p>
<pre tabindex="0"><code data-author-content="{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: { // No provider, LogLevel applies to all the enabled providers.
      &quot;Default&quot;: &quot;Error&quot;,
      &quot;Microsoft&quot;: &quot;Warning&quot;,
      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Warning&quot;
    },
    &quot;Debug&quot;: { // Debug provider.
      &quot;LogLevel&quot;: {
        &quot;Default&quot;: &quot;Information&quot; // Overrides preceding LogLevel:Default setting.
      }
    },
    &quot;Console&quot;: {
      &quot;IncludeScopes&quot;: true,
      &quot;LogLevel&quot;: {
        &quot;Microsoft.AspNetCore.Mvc.Razor.Internal&quot;: &quot;Warning&quot;,
        &quot;Microsoft.AspNetCore.Mvc.Razor.Razor&quot;: &quot;Debug&quot;,
        &quot;Microsoft.AspNetCore.Mvc.Razor&quot;: &quot;Error&quot;,
        &quot;Default&quot;: &quot;Information&quot;
      }
    },
    &quot;EventSource&quot;: {
      &quot;LogLevel&quot;: {
        &quot;Microsoft&quot;: &quot;Information&quot;
      }
    },
    &quot;EventLog&quot;: {
      &quot;LogLevel&quot;: {
        &quot;Microsoft&quot;: &quot;Information&quot;
      }
    },
    &quot;AzureAppServicesFile&quot;: {
      &quot;IncludeScopes&quot;: true,
      &quot;LogLevel&quot;: {
        &quot;Default&quot;: &quot;Warning&quot;
      }
    },
    &quot;AzureAppServicesBlob&quot;: {
      &quot;IncludeScopes&quot;: true,
      &quot;LogLevel&quot;: {
        &quot;Microsoft&quot;: &quot;Information&quot;
      }
    },
    &quot;ApplicationInsights&quot;: {
      &quot;LogLevel&quot;: {
        &quot;Default&quot;: &quot;Information&quot;
      }
    }
  }
}
"><span>{
  <span>"Logging"</span>: {
    <span>"LogLevel"</span>: { // No provider, LogLevel applies to all the enabled providers.
      <span>"Default"</span>: <span>"Error"</span>,
      <span>"Microsoft"</span>: <span>"Warning"</span>,
      <span>"Microsoft.Hosting.Lifetime"</span>: <span>"Warning"</span>
    },
    <span>"Debug"</span>: { // Debug provider.
      <span>"LogLevel"</span>: {
        <span>"Default"</span>: <span>"Information"</span> // Overrides preceding LogLevel:Default setting.
      }
    },
    <span>"Console"</span>: {
      <span>"IncludeScopes"</span>: <span>true</span>,
      <span>"LogLevel"</span>: {
        <span>"Microsoft.AspNetCore.Mvc.Razor.Internal"</span>: <span>"Warning"</span>,
        <span>"Microsoft.AspNetCore.Mvc.Razor.Razor"</span>: <span>"Debug"</span>,
        <span>"Microsoft.AspNetCore.Mvc.Razor"</span>: <span>"Error"</span>,
        <span>"Default"</span>: <span>"Information"</span>
      }
    },
    <span>"EventSource"</span>: {
      <span>"LogLevel"</span>: {
        <span>"Microsoft"</span>: <span>"Information"</span>
      }
    },
    <span>"EventLog"</span>: {
      <span>"LogLevel"</span>: {
        <span>"Microsoft"</span>: <span>"Information"</span>
      }
    },
    <span>"AzureAppServicesFile"</span>: {
      <span>"IncludeScopes"</span>: <span>true</span>,
      <span>"LogLevel"</span>: {
        <span>"Default"</span>: <span>"Warning"</span>
      }
    },
    <span>"AzureAppServicesBlob"</span>: {
      <span>"IncludeScopes"</span>: <span>true</span>,
      <span>"LogLevel"</span>: {
        <span>"Microsoft"</span>: <span>"Information"</span>
      }
    },
    <span>"ApplicationInsights"</span>: {
      <span>"LogLevel"</span>: {
        <span>"Default"</span>: <span>"Information"</span>
      }
    }
  }
}
</span></code></pre>
<p>In the preceding sample:</p>
<ul>
<li>The categories and levels are not suggested values. The sample is provided to show all the default providers.</li>
<li>Settings in <code>Logging.{providername}.LogLevel</code> override settings in <code>Logging.LogLevel</code>. For example, the level in <code>Debug.LogLevel.Default</code> overrides the level in <code>LogLevel.Default</code>.</li>
<li>Each default provider <em>alias</em> is used. Each provider defines an <em>alias</em> that can be used in configuration in place of the fully qualified type name. The built-in providers aliases are:
<ul>
<li>Console</li>
<li>Debug</li>
<li>EventSource</li>
<li>EventLog</li>
<li>AzureAppServicesFile</li>
<li>AzureAppServicesBlob</li>
<li>ApplicationInsights</li>
</ul>
</li>
</ul>
<h2 id="set-log-level-by-command-line-environment-variables-and-other-configuration">Set log level by command line, environment variables, and other configuration<a href="#set-log-level-by-command-line-environment-variables-and-other-configuration" aria-labelledby="set-log-level-by-command-line-environment-variables-and-other-configuration"></a></h2>
<p>Log level can be set by any of the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.0" data-linktype="relative-path">configuration providers</a>. For information on configuring the logging providers using the command line, environment variables, other file formats, and more, see <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.0" data-linktype="relative-path">Configuration in ASP.NET Core</a>.</p>
<h2 id="how-filtering-rules-are-applied">How filtering rules are applied<a href="#how-filtering-rules-are-applied" aria-labelledby="how-filtering-rules-are-applied"></a></h2>
<p>When an <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger-1" data-linktype="absolute-path">ILogger&lt;TCategoryName&gt;</a> object is created, the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggerfactory" data-linktype="absolute-path">ILoggerFactory</a> object selects a single rule per provider to apply to that logger. All messages written by an <code>ILogger</code> instance are filtered based on the selected rules. The most specific rule for each provider and category pair is selected from the available rules.</p>
<p>The following algorithm is used for each provider when an <code>ILogger</code> is created for a given category:</p>
<ul>
<li>Select all rules that match the provider or its alias. If no match is found, select all rules with an empty provider.</li>
<li>From the result of the preceding step, select rules with longest matching category prefix. If no match is found, select all rules that don't specify a category.</li>
<li>If multiple rules are selected, take the <strong>last</strong> one.</li>
<li>If no rules are selected, use <code>MinimumLevel</code>.</li>
</ul>

<h2 id="logging-output-from-dotnet-run-and-visual-studio">Logging output from dotnet run and Visual Studio<a href="#logging-output-from-dotnet-run-and-visual-studio" aria-labelledby="logging-output-from-dotnet-run-and-visual-studio"></a></h2>
<p>Logs created with the <a href="#lp" data-linktype="self-bookmark">default logging providers</a> are displayed:</p>
<ul>
<li>In Visual Studio
<ul>
<li>In the Debug output window when debugging.</li>
<li>In the ASP.NET Core Web Server window.</li>
</ul>
</li>
<li>In the console window when the app is run with <code>dotnet run</code>.</li>
</ul>
<p>Logs that begin with "Microsoft" categories are from ASP.NET Core framework code. ASP.NET Core and application code use the same logging API and providers.</p>

<h2 id="log-category">Log category<a href="#log-category" aria-labelledby="log-category"></a></h2>
<p>When an <code>ILogger</code> object is created, a <em>category</em> is specified. That category is included with each log message created by that instance of <code>ILogger</code>. The category string is arbitrary, but the convention is to use the class name. For example, in a controller the name might be <code>"TodoApi.Controllers.TodoController"</code>. The ASP.NET Core web apps use <code>ILogger&lt;T&gt;</code> to automatically get an <code>ILogger</code> instance that uses the fully qualified type name of <code>T</code> as the category:</p>
<pre tabindex="0"><code data-author-content="public class PrivacyModel : PageModel
{
    private readonly ILogger<PrivacyModel> _logger;

    public PrivacyModel(ILogger<PrivacyModel> logger)
    {
        _logger = logger;
    }

    public void OnGet()
    {
        _logger.LogInformation(&quot;GET Pages.PrivacyModel called.&quot;);
    }
}
"><span><span>public</span> <span>class</span> <span>PrivacyModel</span> : <span>PageModel</span>
{
    <span>private</span> <span>readonly</span> ILogger&lt;PrivacyModel&gt; _logger;

    <span><span>public</span> <span>PrivacyModel</span>(<span>ILogger&lt;PrivacyModel&gt; logger</span>)</span>
    {
        _logger = logger;
    }

    <span><span>public</span> <span>void</span> <span>OnGet</span>(<span></span>)</span>
    {
        _logger.LogInformation(<span>"GET Pages.PrivacyModel called."</span>);
    }
}
</span></code></pre>
<p>To explicitly specify the category, call <code>ILoggerFactory.CreateLogger</code>:</p>
<pre tabindex="0"><code data-author-content="public class ContactModel : PageModel
{
    private readonly ILogger _logger;

    public ContactModel(ILoggerFactory logger)
    {
        _logger = logger.CreateLogger(&quot;TodoApi.Pages.ContactModel&quot;);
    }

    public void OnGet()
    {
        _logger.LogInformation(&quot;GET Pages.ContactModel called.&quot;);
    }
"><span><span>public</span> <span>class</span> <span>ContactModel</span> : <span>PageModel</span>
{
    <span>private</span> <span>readonly</span> ILogger _logger;

    <span><span>public</span> <span>ContactModel</span>(<span>ILoggerFactory logger</span>)</span>
    {
        _logger = logger.CreateLogger(<span>"TodoApi.Pages.ContactModel"</span>);
    }

    <span><span>public</span> <span>void</span> <span>OnGet</span>(<span></span>)</span>
    {
        _logger.LogInformation(<span>"GET Pages.ContactModel called."</span>);
    }
</span></code></pre>
<p><code>ILogger&lt;T&gt;</code> is equivalent to calling <code>CreateLogger</code> with the fully qualified type name of <code>T</code>.</p>

<h2 id="log-level">Log level<a href="#log-level" aria-labelledby="log-level"></a></h2>
<p>The following table lists the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel" data-linktype="absolute-path">LogLevel</a> values, the convenience <code>Log{LogLevel}</code> extension method, and the suggested usage:</p>

<p>In the previous table, the <code>LogLevel</code> is listed from lowest to highest severity.</p>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions" data-linktype="absolute-path">Log</a> method's first parameter, <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel" data-linktype="absolute-path">LogLevel</a>, indicates the severity of the log. Rather than calling <code>Log(LogLevel, ...)</code>, most developers call the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions" data-linktype="absolute-path">Log{LogLevel}</a> extension methods. The <code>Log{LogLevel}</code> extension methods <a href="https://github.com/dotnet/extensions/blob/release/3.1/src/Logging/Logging.Abstractions/src/LoggerExtensions.cs" data-linktype="external">call the Log method and specify the LogLevel</a>. For example, the following two logging calls are functionally equivalent and produce the same log:</p>
<pre tabindex="0"><code highlight-lines="6-7" data-author-content="[HttpGet]
public IActionResult Test1(int id)
{
    var routeInfo = ControllerContext.ToCtxString(id);

    _logger.Log(LogLevel.Information, MyLogEvents.TestItem, routeInfo);
    _logger.LogInformation(MyLogEvents.TestItem, routeInfo);

    return ControllerContext.MyDisplayRouteInfo();
}
"><span>[<span>HttpGet</span>]
<span><span>public</span> IActionResult <span>Test1</span>(<span><span>int</span> id</span>)</span>
{
    <span>var</span> routeInfo = ControllerContext.ToCtxString(id);
</span>
<mark>    _logger.Log(LogLevel.Information, MyLogEvents.TestItem, routeInfo);
    _logger.LogInformation(MyLogEvents.TestItem, routeInfo);</mark>
<span>
    <span>return</span> ControllerContext.MyDisplayRouteInfo();
}
</span></code></pre>
<p><code>MyLogEvents.TestItem</code> is the event ID. <code>MyLogEvents</code> is part of the sample app and is displayed in the <a href="#leid" data-linktype="self-bookmark">Log event ID</a> section.</p>
<p><a href="https://github.com/Rick-Anderson/RouteInfo/blob/master/Microsoft.Docs.Samples.RouteInfo/ControllerContextExtensions.cs" data-linktype="external">MyDisplayRouteInfo and ToCtxString</a> are provided by the <a href="https://www.nuget.org/packages/Rick.Docs.Samples.RouteInfo" data-linktype="external">Rick.Docs.Samples.RouteInfo</a> NuGet package. The methods display <code>Controller</code> route information.</p>

<p>The following code creates <code>Information</code> and <code>Warning</code> logs:</p>
<pre tabindex="0"><code highlight-lines="4,10" data-author-content="[HttpGet(&quot;{id}&quot;)]
public async Task<ActionResult<TodoItemDTO>> GetTodoItem(long id)
{
    _logger.LogInformation(MyLogEvents.GetItem, &quot;Getting item {Id}&quot;, id);

    var todoItem = await _context.TodoItems.FindAsync(id);

    if (todoItem == null)
    {
        _logger.LogWarning(MyLogEvents.GetItemNotFound, &quot;Get({Id}) NOT FOUND&quot;, id);
        return NotFound();
    }

    return ItemToDTO(todoItem);
}
"><span>[<span>HttpGet(<span>"{id}"</span>)</span>]
<span>public</span> <span>async</span> Task&lt;ActionResult&lt;TodoItemDTO&gt;&gt; GetTodoItem(<span>long</span> id)
{</span>
<mark>    _logger.LogInformation(MyLogEvents.GetItem, <span>"Getting item {Id}"</span>, id);</mark>
<span>
    <span>var</span> todoItem = <span>await</span> _context.TodoItems.FindAsync(id);

    <span>if</span> (todoItem == <span>null</span>)
    {</span>
<mark>        _logger.LogWarning(MyLogEvents.GetItemNotFound, <span>"Get({Id}) NOT FOUND"</span>, id);</mark>
<span>        <span>return</span> NotFound();
    }

    <span>return</span> ItemToDTO(todoItem);
}
</span></code></pre>
<p>In the preceding code, the first <code>Log{LogLevel}</code> parameter,<code>MyLogEvents.GetItem</code>, is the <a href="#leid" data-linktype="self-bookmark">Log event ID</a>. The second parameter is a message template with placeholders for argument values provided by the remaining method parameters. The method parameters are explained in the <a href="#lmt" data-linktype="self-bookmark">message template</a> section later in this document.</p>
<p>Call the appropriate <code>Log{LogLevel}</code> method to control how much log output is written to a particular storage medium. For example:</p>
<ul>
<li>In production:
<ul>
<li>Logging at the <code>Trace</code> or <code>Information</code> levels produces a high-volume of detailed log messages. To control costs and not exceed data storage limits, log <code>Trace</code> and <code>Information</code> level messages to a high-volume, low-cost data store. Consider limiting <code>Trace</code> and <code>Information</code> to specific categories.</li>
<li>Logging at <code>Warning</code> through <code>Critical</code> levels should produce few log messages.
<ul>
<li>Costs and storage limits usually aren't a concern.</li>
<li>Few logs allow more flexibility in data store choices.</li>
</ul>
</li>
</ul>
</li>
<li>In development:
<ul>
<li>Set to <code>Warning</code>.</li>
<li>Add <code>Trace</code> or <code>Information</code> messages when troubleshooting. To limit output, set <code>Trace</code> or <code>Information</code> only for the categories under investigation.</li>
</ul>
</li>
</ul>
<p>ASP.NET Core writes logs for framework events. For example, consider the log output for:</p>
<ul>
<li>A Razor Pages app created with the ASP.NET Core templates.</li>
<li>Logging set to <code>Logging:Console:LogLevel:Microsoft:Information</code></li>
<li>Navigation to the Privacy page:</li>
</ul>
<pre tabindex="0"><code data-author-content="info: Microsoft.AspNetCore.Hosting.Diagnostics[1]
      Request starting HTTP/2 GET https://localhost:5001/Privacy
info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]
      Executing endpoint '/Privacy'
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[3]
      Route matched with {page = &quot;/Privacy&quot;}. Executing page /Privacy
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[101]
      Executing handler method DefaultRP.Pages.PrivacyModel.OnGet - ModelState is Valid
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[102]
      Executed handler method OnGet, returned result .
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[103]
      Executing an implicit handler method - ModelState is Valid
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[104]
      Executed an implicit handler method, returned result Microsoft.AspNetCore.Mvc.RazorPages.PageResult.
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[4]
      Executed page /Privacy in 74.5188ms
info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]
      Executed endpoint '/Privacy'
info: Microsoft.AspNetCore.Hosting.Diagnostics[2]
      Request finished in 149.3023ms 200 text/html; charset=utf-8
"><span>info: Microsoft.AspNetCore.Hosting.Diagnostics[1]
      Request starting HTTP/2 GET https://localhost:5001/Privacy
info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]
      Executing endpoint '/Privacy'
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[3]
      Route matched with {page = "/Privacy"}. Executing page /Privacy
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[101]
      Executing handler method DefaultRP.Pages.PrivacyModel.OnGet - ModelState is Valid
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[102]
      Executed handler method OnGet, returned result .
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[103]
      Executing an implicit handler method - ModelState is Valid
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[104]
      Executed an implicit handler method, returned result Microsoft.AspNetCore.Mvc.RazorPages.PageResult.
info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[4]
      Executed page /Privacy in 74.5188ms
info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]
      Executed endpoint '/Privacy'
info: Microsoft.AspNetCore.Hosting.Diagnostics[2]
      Request finished in 149.3023ms 200 text/html; charset=utf-8
</span></code></pre>
<p>The following JSON sets <code>Logging:Console:LogLevel:Microsoft:Information</code>:</p>
<pre tabindex="0"><code data-author-content="{
  &quot;Logging&quot;: {      // Default, all providers.
    &quot;LogLevel&quot;: {
      &quot;Microsoft&quot;: &quot;Warning&quot;
    },
    &quot;Console&quot;: { // Console provider.
      &quot;LogLevel&quot;: {
        &quot;Microsoft&quot;: &quot;Information&quot;
      }
    }
  }
}
"><span>{
  <span>"Logging"</span>: {      // Default, all providers.
    <span>"LogLevel"</span>: {
      <span>"Microsoft"</span>: <span>"Warning"</span>
    },
    <span>"Console"</span>: { // Console provider.
      <span>"LogLevel"</span>: {
        <span>"Microsoft"</span>: <span>"Information"</span>
      }
    }
  }
}
</span></code></pre>

<h2 id="log-event-id">Log event ID<a href="#log-event-id" aria-labelledby="log-event-id"></a></h2>
<p>Each log can specify an <em>event ID</em>. The sample app uses the <code>MyLogEvents</code> class to define event IDs:</p>
<!-- Review: to bad there is no way to use an enum for event ID's -->
<pre tabindex="0"><code data-author-content="public class MyLogEvents
{
    public const int GenerateItems = 1000;
    public const int ListItems     = 1001;
    public const int GetItem       = 1002;
    public const int InsertItem    = 1003;
    public const int UpdateItem    = 1004;
    public const int DeleteItem    = 1005;

    public const int TestItem      = 3000;

    public const int GetItemNotFound    = 4000;
    public const int UpdateItemNotFound = 4001;
}
"><span><span>public</span> <span>class</span> <span>MyLogEvents</span>
{
    <span>public</span> <span>const</span> <span>int</span> GenerateItems = <span>1000</span>;
    <span>public</span> <span>const</span> <span>int</span> ListItems     = <span>1001</span>;
    <span>public</span> <span>const</span> <span>int</span> GetItem       = <span>1002</span>;
    <span>public</span> <span>const</span> <span>int</span> InsertItem    = <span>1003</span>;
    <span>public</span> <span>const</span> <span>int</span> UpdateItem    = <span>1004</span>;
    <span>public</span> <span>const</span> <span>int</span> DeleteItem    = <span>1005</span>;

    <span>public</span> <span>const</span> <span>int</span> TestItem      = <span>3000</span>;

    <span>public</span> <span>const</span> <span>int</span> GetItemNotFound    = <span>4000</span>;
    <span>public</span> <span>const</span> <span>int</span> UpdateItemNotFound = <span>4001</span>;
}
</span></code></pre><pre tabindex="0"><code highlight-lines="4,10" data-author-content="[HttpGet(&quot;{id}&quot;)]
public async Task<ActionResult<TodoItemDTO>> GetTodoItem(long id)
{
    _logger.LogInformation(MyLogEvents.GetItem, &quot;Getting item {Id}&quot;, id);

    var todoItem = await _context.TodoItems.FindAsync(id);

    if (todoItem == null)
    {
        _logger.LogWarning(MyLogEvents.GetItemNotFound, &quot;Get({Id}) NOT FOUND&quot;, id);
        return NotFound();
    }

    return ItemToDTO(todoItem);
}
"><span>[<span>HttpGet(<span>"{id}"</span>)</span>]
<span>public</span> <span>async</span> Task&lt;ActionResult&lt;TodoItemDTO&gt;&gt; GetTodoItem(<span>long</span> id)
{</span>
<mark>    _logger.LogInformation(MyLogEvents.GetItem, <span>"Getting item {Id}"</span>, id);</mark>
<span>
    <span>var</span> todoItem = <span>await</span> _context.TodoItems.FindAsync(id);

    <span>if</span> (todoItem == <span>null</span>)
    {</span>
<mark>        _logger.LogWarning(MyLogEvents.GetItemNotFound, <span>"Get({Id}) NOT FOUND"</span>, id);</mark>
<span>        <span>return</span> NotFound();
    }

    <span>return</span> ItemToDTO(todoItem);
}
</span></code></pre>
<p>An event ID associates a set of events. For example, all logs related to displaying a list of items on a page might be 1001.</p>
<p>The logging provider may store the event ID in an ID field, in the logging message, or not at all. The Debug provider doesn't show event IDs. The console provider shows event IDs in brackets after the category:</p>
<pre tabindex="0"><code data-author-content="info: TodoApi.Controllers.TodoItemsController[1002]
      Getting item 1
warn: TodoApi.Controllers.TodoItemsController[4000]
      Get(1) NOT FOUND
"><span>info: TodoApi.Controllers.TodoItemsController[1002]
      Getting item 1
warn: TodoApi.Controllers.TodoItemsController[4000]
      Get(1) NOT FOUND
</span></code></pre>
<p>Some logging providers store the event ID in a field, which allows for filtering on the ID.</p>

<h2 id="log-message-template">Log message template<a href="#log-message-template" aria-labelledby="log-message-template"></a></h2>
<!-- Review, Each log API uses a message template. -->
<p>Each log API uses a message template. The message template can contain placeholders for which arguments are provided. Use names for the placeholders, not numbers.</p>
<pre tabindex="0"><code highlight-lines="4,10" data-author-content="[HttpGet(&quot;{id}&quot;)]
public async Task<ActionResult<TodoItemDTO>> GetTodoItem(long id)
{
    _logger.LogInformation(MyLogEvents.GetItem, &quot;Getting item {Id}&quot;, id);

    var todoItem = await _context.TodoItems.FindAsync(id);

    if (todoItem == null)
    {
        _logger.LogWarning(MyLogEvents.GetItemNotFound, &quot;Get({Id}) NOT FOUND&quot;, id);
        return NotFound();
    }

    return ItemToDTO(todoItem);
}
"><span>[<span>HttpGet(<span>"{id}"</span>)</span>]
<span>public</span> <span>async</span> Task&lt;ActionResult&lt;TodoItemDTO&gt;&gt; GetTodoItem(<span>long</span> id)
{</span>
<mark>    _logger.LogInformation(MyLogEvents.GetItem, <span>"Getting item {Id}"</span>, id);</mark>
<span>
    <span>var</span> todoItem = <span>await</span> _context.TodoItems.FindAsync(id);

    <span>if</span> (todoItem == <span>null</span>)
    {</span>
<mark>        _logger.LogWarning(MyLogEvents.GetItemNotFound, <span>"Get({Id}) NOT FOUND"</span>, id);</mark>
<span>        <span>return</span> NotFound();
    }

    <span>return</span> ItemToDTO(todoItem);
}
</span></code></pre>
<p>The order of placeholders, not their names, determines which parameters are used to provide their values. In the following code, the parameter names are out of sequence in the message template:</p>
<pre tabindex="0"><code data-author-content="string p1 = &quot;param1&quot;;
string p2 = &quot;param2&quot;;
_logger.LogInformation(&quot;Parameter values: {p2}, {p1}&quot;, p1, p2);
"><span><span>string</span> p1 = <span>"param1"</span>;
<span>string</span> p2 = <span>"param2"</span>;
_logger.LogInformation(<span>"Parameter values: {p2}, {p1}"</span>, p1, p2);
</span></code></pre>
<p>The preceding code creates a log message with the parameter values in sequence:</p>
<pre tabindex="0"><code data-author-content="Parameter values: param1, param2
">Parameter values: param1, param2
</code></pre>
<p>This approach allows logging providers to implement <a href="https://github.com/NLog/NLog/wiki/How-to-use-structured-logging" data-linktype="external">semantic or structured logging</a>. The arguments themselves are passed to the logging system, not just the formatted message template. This enables logging providers to store the parameter values as fields. For example, consider the following logger method:</p>
<pre tabindex="0"><code data-author-content="_logger.LogInformation(&quot;Getting item {Id} at {RequestTime}&quot;, id, DateTime.Now);
"><span>_logger.LogInformation(<span>"Getting item {Id} at {RequestTime}"</span>, id, DateTime.Now);
</span></code></pre>
<p>For example, when logging to Azure Table Storage:</p>
<ul>
<li>Each Azure Table entity can have <code>ID</code> and <code>RequestTime</code> properties.</li>
<li>Tables with properties simplify queries on logged data. For example, a query can find all logs within a particular <code>RequestTime</code> range without having to parse the time out of the text message.</li>
</ul>
<h2 id="log-exceptions">Log exceptions<a href="#log-exceptions" aria-labelledby="log-exceptions"></a></h2>
<p>The logger methods have overloads that take an exception parameter:</p>
<pre tabindex="0"><code data-author-content="[HttpGet(&quot;{id}&quot;)]
public IActionResult TestExp(int id)
{
    var routeInfo = ControllerContext.ToCtxString(id);
    _logger.LogInformation(MyLogEvents.TestItem, routeInfo);

    try
    {
        if (id == 3)
        {
            throw new Exception(&quot;Test expception&quot;);
        }
    }
    catch (Exception ex)
    {
        _logger.LogWarning(MyLogEvents.GetItemNotFound, ex, &quot;TestExp({Id})&quot;, id);
        return NotFound();
    }

    return ControllerContext.MyDisplayRouteInfo();
}
"><span>[<span>HttpGet(<span>"{id}"</span>)</span>]
<span><span>public</span> IActionResult <span>TestExp</span>(<span><span>int</span> id</span>)</span>
{
    <span>var</span> routeInfo = ControllerContext.ToCtxString(id);
    _logger.LogInformation(MyLogEvents.TestItem, routeInfo);

    <span>try</span>
    {
        <span>if</span> (id == <span>3</span>)
        {
            <span>throw</span> <span>new</span> Exception(<span>"Test expception"</span>);
        }
    }
    <span>catch</span> (Exception ex)
    {
        _logger.LogWarning(MyLogEvents.GetItemNotFound, ex, <span>"TestExp({Id})"</span>, id);
        <span>return</span> NotFound();
    }

    <span>return</span> ControllerContext.MyDisplayRouteInfo();
}
</span></code></pre><p><a href="https://github.com/Rick-Anderson/RouteInfo/blob/master/Microsoft.Docs.Samples.RouteInfo/ControllerContextExtensions.cs" data-linktype="external">MyDisplayRouteInfo and ToCtxString</a> are provided by the <a href="https://www.nuget.org/packages/Rick.Docs.Samples.RouteInfo" data-linktype="external">Rick.Docs.Samples.RouteInfo</a> NuGet package. The methods display <code>Controller</code> route information.</p>

<p>Exception logging is provider-specific.</p>
<h3 id="default-log-level">Default log level<a href="#default-log-level" aria-labelledby="default-log-level"></a></h3>
<p>If the default log level is not set, the default log level value is <code>Information</code>.</p>
<p>For example, consider the following web app:</p>
<ul>
<li>Created with the ASP.NET web app templates.</li>
<li><em>appsettings.json</em> and <em>appsettings.Development.json</em> deleted or renamed.</li>
</ul>
<p>With the preceding setup, navigating to the privacy or home page produces many <code>Trace</code>, <code>Debug</code>, and <code>Information</code>  messages with <code>Microsoft</code> in the category name.</p>
<p>The following code sets the default log level when the default log level is not set in configuration:</p>
<pre tabindex="0"><code highlight-lines="10" data-author-content="public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging => logging.SetMinimumLevel(LogLevel.Warning))
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
"><span><span>public</span> <span>class</span> <span>Program</span>
{
    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        CreateHostBuilder(args).Build().Run();
    }

    <span><span>public</span> <span>static</span> IHostBuilder <span>CreateHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;
        Host.CreateDefaultBuilder(args)</span>
<mark>            .ConfigureLogging(logging =&gt; logging.SetMinimumLevel(LogLevel.Warning))</mark>
<span>            .ConfigureWebHostDefaults(webBuilder =&gt;
            {
                webBuilder.UseStartup&lt;Startup&gt;();
            });
}
</span></code></pre><!-- review required: I say this a couple times -->
<p>Generally, log levels should be specified in configuration and not code.</p>
<h3 id="filter-function">Filter function<a href="#filter-function" aria-labelledby="filter-function"></a></h3>
<p>A filter function is invoked for all providers and categories that don't have rules assigned to them by configuration or code:</p>
<pre tabindex="0"><code data-author-content="public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =>
            {
                logging.AddFilter((provider, category, logLevel) =>
                {
                    if (provider.Contains(&quot;ConsoleLoggerProvider&quot;)
                        &amp;&amp; category.Contains(&quot;Controller&quot;)
                        &amp;&amp; logLevel >= LogLevel.Information)
                    {
                        return true;
                    }
                    else if (provider.Contains(&quot;ConsoleLoggerProvider&quot;)
                        &amp;&amp; category.Contains(&quot;Microsoft&quot;)
                        &amp;&amp; logLevel >= LogLevel.Information)
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                });
            })
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
"><span><span>public</span> <span>class</span> <span>Program</span>
{
    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        CreateHostBuilder(args).Build().Run();
    }

    <span><span>public</span> <span>static</span> IHostBuilder <span>CreateHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =&gt;
            {
                logging.AddFilter((provider, category, logLevel) =&gt;
                {
                    <span>if</span> (provider.Contains(<span>"ConsoleLoggerProvider"</span>)
                        &amp;&amp; category.Contains(<span>"Controller"</span>)
                        &amp;&amp; logLevel &gt;= LogLevel.Information)
                    {
                        <span>return</span> <span>true</span>;
                    }
                    <span>else</span> <span>if</span> (provider.Contains(<span>"ConsoleLoggerProvider"</span>)
                        &amp;&amp; category.Contains(<span>"Microsoft"</span>)
                        &amp;&amp; logLevel &gt;= LogLevel.Information)
                    {
                        <span>return</span> <span>true</span>;
                    }
                    <span>else</span>
                    {
                        <span>return</span> <span>false</span>;
                    }
                });
            })
            .ConfigureWebHostDefaults(webBuilder =&gt;
            {
                webBuilder.UseStartup&lt;Startup&gt;();
            });
}
</span></code></pre>
<p>The preceding code displays console logs when the category contains <code>Controller</code> or <code>Microsoft</code> and the log level is <code>Information</code> or higher.</p>
<p>Generally, log levels should be specified in configuration and not code.</p>
<h2 id="aspnet-core-and-ef-core-categories">ASP.NET Core and EF Core categories<a href="#aspnet-core-and-ef-core-categories" aria-labelledby="aspnet-core-and-ef-core-categories"></a></h2>
<p>The following table contains some categories used by ASP.NET Core and Entity Framework Core, with notes about the logs:</p>

<p>To view more categories in the console window, set <strong>appsettings.Development.json</strong> to the following:</p>
<pre tabindex="0"><code data-author-content="{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Trace&quot;,
      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
    }
  }
}
"><span>{
  <span>"Logging"</span>: {
    <span>"LogLevel"</span>: {
      <span>"Default"</span>: <span>"Information"</span>,
      <span>"Microsoft"</span>: <span>"Trace"</span>,
      <span>"Microsoft.Hosting.Lifetime"</span>: <span>"Information"</span>
    }
  }
}
</span></code></pre><!-- Review: What other providers support scopes? Console is not generally used in staging/production  -->

<h2 id="log-scopes">Log scopes<a href="#log-scopes" aria-labelledby="log-scopes"></a></h2>
<p>A <em>scope</em> can group a set of logical operations. This grouping can be used to attach the same data to each log that's created as part of a set. For example, every log created as part of processing a transaction can include the transaction ID.</p>
<p>A scope:</p>
<ul>
<li>Is an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.idisposable" data-linktype="absolute-path">IDisposable</a> type that's returned by the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger.beginscope" data-linktype="absolute-path">BeginScope</a> method.</li>
<li>Lasts until it's disposed.</li>
</ul>
<p>The following providers support scopes:</p>
<ul>
<li><code>Console</code></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.azureappservices.batchingloggeroptions.includescopes#Microsoft_Extensions_Logging_AzureAppServices_BatchingLoggerOptions_IncludeScopes" data-linktype="absolute-path">AzureAppServicesFile and AzureAppServicesBlob</a></li>
</ul>
<p>Use a scope by wrapping logger calls in a <code>using</code> block:</p>
<pre tabindex="0"><code data-author-content="[HttpGet(&quot;{id}&quot;)]
public async Task<ActionResult<TodoItemDTO>> GetTodoItem(long id)
{
    TodoItem todoItem;

    using (_logger.BeginScope(&quot;using block message&quot;))
    {
        _logger.LogInformation(MyLogEvents.GetItem, &quot;Getting item {Id}&quot;, id);

        todoItem = await _context.TodoItems.FindAsync(id);

        if (todoItem == null)
        {
            _logger.LogWarning(MyLogEvents.GetItemNotFound, 
                &quot;Get({Id}) NOT FOUND&quot;, id);
            return NotFound();
        }
    }

    return ItemToDTO(todoItem);
}
"><span>[<span>HttpGet(<span>"{id}"</span>)</span>]
<span>public</span> <span>async</span> Task&lt;ActionResult&lt;TodoItemDTO&gt;&gt; GetTodoItem(<span>long</span> id)
{
    TodoItem todoItem;

    <span>using</span> (_logger.BeginScope(<span>"using block message"</span>))
    {
        _logger.LogInformation(MyLogEvents.GetItem, <span>"Getting item {Id}"</span>, id);

        todoItem = <span>await</span> _context.TodoItems.FindAsync(id);

        <span>if</span> (todoItem == <span>null</span>)
        {
            _logger.LogWarning(MyLogEvents.GetItemNotFound, 
                <span>"Get({Id}) NOT FOUND"</span>, id);
            <span>return</span> NotFound();
        }
    }

    <span>return</span> ItemToDTO(todoItem);
}
</span></code></pre>
<p>The following JSON enables scopes for the console provider:</p>
<pre tabindex="0"><code data-author-content="{
  &quot;Logging&quot;: {
    &quot;Debug&quot;: {
      &quot;LogLevel&quot;: {
        &quot;Default&quot;: &quot;Information&quot;
      }
    },
    &quot;Console&quot;: {
      &quot;IncludeScopes&quot;: true, // Required to use Scopes.
      &quot;LogLevel&quot;: {
        &quot;Microsoft&quot;: &quot;Warning&quot;,
        &quot;Default&quot;: &quot;Information&quot;
      }
    },
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Debug&quot;
    }
  }
}
"><span>{
  <span>"Logging"</span>: {
    <span>"Debug"</span>: {
      <span>"LogLevel"</span>: {
        <span>"Default"</span>: <span>"Information"</span>
      }
    },
    <span>"Console"</span>: {
      <span>"IncludeScopes"</span>: <span>true</span>, // Required to use Scopes.
      <span>"LogLevel"</span>: {
        <span>"Microsoft"</span>: <span>"Warning"</span>,
        <span>"Default"</span>: <span>"Information"</span>
      }
    },
    <span>"LogLevel"</span>: {
      <span>"Default"</span>: <span>"Debug"</span>
    }
  }
}
</span></code></pre>
<p>The following code enables scopes for the console provider:</p>
<pre tabindex="0"><code data-author-content="public class Scopes
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureLogging((hostingContext, logging) =>
            {
                logging.ClearProviders();
                logging.AddConsole(options => options.IncludeScopes = true);
                logging.AddDebug();
            })
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
"><span><span>public</span> <span>class</span> <span>Scopes</span>
{
    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        CreateHostBuilder(args).Build().Run();
    }

    <span><span>public</span> <span>static</span> IHostBuilder <span>CreateHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureLogging((hostingContext, logging) =&gt;
            {
                logging.ClearProviders();
                logging.AddConsole(options =&gt; options.IncludeScopes = <span>true</span>);
                logging.AddDebug();
            })
            .ConfigureWebHostDefaults(webBuilder =&gt;
            {
                webBuilder.UseStartup&lt;Startup&gt;();
            });
}
</span></code></pre>
<p>Generally, logging should be specified in configuration and not code.</p>

<h2 id="built-in-logging-providers">Built-in logging providers<a href="#built-in-logging-providers" aria-labelledby="built-in-logging-providers"></a></h2>
<p>ASP.NET Core includes the following logging providers:</p>
<ul>
<li><a href="#console-provider" data-linktype="self-bookmark">Console</a></li>
<li><a href="#debug-provider" data-linktype="self-bookmark">Debug</a></li>
<li><a href="#event-source-provider" data-linktype="self-bookmark">EventSource</a></li>
<li><a href="#welog" data-linktype="self-bookmark">EventLog</a></li>
<li><a href="#azure-app-service" data-linktype="self-bookmark">AzureAppServicesFile and AzureAppServicesBlob</a></li>
<li><a href="#azure-application-insights" data-linktype="self-bookmark">ApplicationInsights</a></li>
</ul>
<p>For information on <code>stdout</code> and debug logging with the ASP.NET Core Module, see <a href="https://docs.microsoft.com/en-us/aspnet/core/test/troubleshoot-azure-iis?view=aspnetcore-3.0" data-linktype="relative-path">Troubleshoot ASP.NET Core on Azure App Service and IIS</a> and <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/aspnet-core-module?view=aspnetcore-3.0#log-creation-and-redirection" data-linktype="relative-path">ASP.NET Core Module</a>.</p>
<h3 id="console">Console<a href="#console" aria-labelledby="console"></a></h3>
<p>The <code>Console</code> provider logs output to the console. For more information on viewing <code>Console</code> logs in development, see <a href="#dnrvs" data-linktype="self-bookmark">Logging output from dotnet run and Visual Studio</a>.</p>
<h3 id="debug">Debug<a href="#debug" aria-labelledby="debug"></a></h3>
<p>The <code>Debug</code> provider writes log output by using the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debug" data-linktype="absolute-path">System.Diagnostics.Debug</a> class. Calls to <code>System.Diagnostics.Debug.WriteLine</code> write to the <code>Debug</code> provider.</p>
<p>On Linux, the <code>Debug</code> provider log location is distribution-dependent and may be one of the following:</p>
<ul>
<li><em>/var/log/message</em></li>
<li><em>/var/log/syslog</em></li>
</ul>
<h3 id="event-source">Event Source<a href="#event-source" aria-labelledby="event-source"></a></h3>
<p>The <code>EventSource</code> provider writes to a cross-platform event source with the name <code>Microsoft-Extensions-Logging</code>. On Windows, the provider uses <a href="https://msdn.microsoft.com/library/windows/desktop/bb968803" data-linktype="external">ETW</a>.</p>
<h4 id="dotnet-trace-tooling">dotnet trace tooling<a href="#dotnet-trace-tooling" aria-labelledby="dotnet-trace-tooling"></a></h4>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-trace" data-linktype="absolute-path">dotnet-trace</a> tool is a cross-platform CLI global tool that enables the collection of .NET Core traces of a running process. The tool collects <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.eventsource" data-linktype="absolute-path">Microsoft.Extensions.Logging.EventSource</a> provider data using a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.eventsource.loggingeventsource" data-linktype="absolute-path">LoggingEventSource</a>.</p>
<p>See <a href="https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-trace" data-linktype="absolute-path">dotnet-trace</a> for installation instructions.</p>
<p>Use the dotnet trace tooling to collect a trace from an app:</p>
<ol>
<li><p>Run the app with the <code>dotnet run</code> command.</p>
</li>
<li><p>Determine the process identifier (PID) of the .NET Core app:</p>
<ul>
<li>On Windows, use one of the following approaches:
<ul>
<li>Task Manager (Ctrl+Alt+Del)</li>
<li><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist" data-linktype="absolute-path">tasklist command</a></li>
<li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-process" data-linktype="absolute-path">Get-Process Powershell command</a></li>
</ul>
</li>
<li>On Linux, use the <a href="https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/pidof.html" data-linktype="external">pidof command</a>.</li>
</ul>
<p>Find the PID for the process that has the same name as the app's assembly.</p>
</li>
<li><p>Execute the <code>dotnet trace</code> command.</p>
<p>General command syntax:</p>
<pre tabindex="0"><code data-author-content="dotnet trace collect -p {PID} 
    --providers Microsoft-Extensions-Logging:{Keyword}:{Event Level}
        :FilterSpecs=\&quot;
            {Logger Category 1}:{Event Level 1};
            {Logger Category 2}:{Event Level 2};
            ...
            {Logger Category N}:{Event Level N}\&quot;
"><span><span>dotnet</span> trace collect<span> -p</span> {PID} 
   <span> --providers</span> Microsoft-Extensions-Logging:{Keyword}:{Event Level}
        :FilterSpecs=\<span>"
            {Logger Category 1}:{Event Level 1};
            {Logger Category 2}:{Event Level 2};
            ...
            {Logger Category N}:{Event Level N}\"
</span></span></code></pre>
<p>When using a PowerShell command shell, enclose the <code>--providers</code> value in single quotes (<code>'</code>):</p>
<pre tabindex="0"><code data-author-content="dotnet trace collect -p {PID} 
    --providers 'Microsoft-Extensions-Logging:{Keyword}:{Event Level}
        :FilterSpecs=\&quot;
            {Logger Category 1}:{Event Level 1};
            {Logger Category 2}:{Event Level 2};
            ...
            {Logger Category N}:{Event Level N}\&quot;'
"><span><span>dotnet</span> trace collect<span> -p</span> {PID} 
   <span> --providers</span> <span>'Microsoft-Extensions-Logging:{Keyword}:{Event Level}
        :FilterSpecs=\"
            {Logger Category 1}:{Event Level 1};
            {Logger Category 2}:{Event Level 2};
            ...
            {Logger Category N}:{Event Level N}\"'</span>
</span></code></pre>
<p>On non-Windows platforms, add the <code>-f speedscope</code> option to change the format of the output trace file to <code>speedscope</code>.</p>


<p><code>FilterSpecs</code> entries for <code>{Logger Category}</code> and <code>{Event Level}</code> represent additional log filtering conditions. Separate <code>FilterSpecs</code> entries with a semicolon (<code>;</code>).</p>
<p>Example using a Windows command shell (<strong>no</strong> single quotes around the <code>--providers</code> value):</p>
<pre tabindex="0"><code data-author-content="dotnet trace collect -p {PID} --providers Microsoft-Extensions-Logging:4:2:FilterSpecs=\&quot;Microsoft.AspNetCore.Hosting*:4\&quot;
"><span><span>dotnet</span> trace collect<span> -p</span> {PID}<span> --providers</span> Microsoft-Extensions-Logging:<span>4</span>:<span>2</span>:FilterSpecs=\<span>"Microsoft.AspNetCore.Hosting*:4\"
</span></span></code></pre>
<p>The preceding command activates:</p>
<ul>
<li>The Event Source logger to produce formatted strings (<code>4</code>) for errors (<code>2</code>).</li>
<li><code>Microsoft.AspNetCore.Hosting</code> logging at the <code>Informational</code> logging level (<code>4</code>).</li>
</ul>
</li>
<li><p>Stop the dotnet trace tooling by pressing the Enter key or Ctrl+C.</p>
<p>The trace is saved with the name <em>trace.nettrace</em> in the folder where the <code>dotnet trace</code> command is executed.</p>
</li>
<li><p>Open the trace with <a href="#perfview" data-linktype="self-bookmark">Perfview</a>. Open the <em>trace.nettrace</em> file and explore the trace events.</p>
</li>
</ol>
<p>If the app doesn't build the host with <code>CreateDefaultBuilder</code>, add the <a href="#event-source-provider" data-linktype="self-bookmark">Event Source provider</a> to the app's logging configuration.</p>
<p>For more information, see:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-trace" data-linktype="absolute-path">Trace for performance analysis utility (dotnet-trace)</a> (.NET Core documentation)</li>
<li><a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md" data-linktype="external">Trace for performance analysis utility (dotnet-trace)</a> (dotnet/diagnostics GitHub repository documentation)</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.eventsource.loggingeventsource" data-linktype="absolute-path">LoggingEventSource Class</a> (.NET API Browser)</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventlevel" data-linktype="absolute-path">EventLevel</a></li>
<li><a href="https://github.com/dotnet/extensions/blob/release/3.0/src/Logging/Logging.EventSource/src/LoggingEventSource.cs" data-linktype="external">LoggingEventSource reference source (3.0)</a> – To obtain reference source for a different version, change the branch to <code>release/{Version}</code>, where <code>{Version}</code> is the version of ASP.NET Core desired.</li>
<li><a href="#perfview" data-linktype="self-bookmark">Perfview</a> – Useful for viewing Event Source traces.</li>
</ul>
<h4 id="perfview">Perfview<a href="#perfview" aria-labelledby="perfview"></a></h4>
<p>Use the <a href="https://github.com/Microsoft/perfview" data-linktype="external">PerfView utility</a> to collect and view logs. There are other tools for viewing ETW logs, but PerfView provides the best experience for working with the ETW events emitted by ASP.NET Core.</p>
<p>To configure PerfView for collecting events logged by this provider, add the string <code>*Microsoft-Extensions-Logging</code> to the <strong>Additional Providers</strong> list. Don't miss the <code>*</code> at the start of the string.</p>

<h3 id="windows-eventlog">Windows EventLog<a href="#windows-eventlog" aria-labelledby="windows-eventlog"></a></h3>
<p>The <code>EventLog</code> provider sends log output to the Windows Event Log. Unlike the other providers, the <code>EventLog</code> provider does <em><strong>not</strong></em> inherit the default non-provider settings. If <code>EventLog</code> log settings are specified, they <a href="https://github.com/dotnet/extensions/blob/release/3.1/src/Hosting/Hosting/src/Host.cs#L99-L103" data-linktype="external">default to LogLevel.Warning</a>.</p>
<p>To log events lower than <code>Warning</code>, explicitly set the log level. For example, add the following to the <em>appsettings.json</em> file:</p>
<pre tabindex="0"><code data-author-content="&quot;EventLog&quot;: {
  &quot;LogLevel&quot;: {
    &quot;Default&quot;: &quot;Information&quot;
  }
}
"><span><span>"EventLog"</span>: {
  <span>"LogLevel"</span>: {
    <span>"Default"</span>: <span>"Information"</span>
  }
}
</span></code></pre>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.eventloggerfactoryextensions" data-linktype="absolute-path">AddEventLog overloads</a> can pass in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.eventlog.eventlogsettings" data-linktype="absolute-path">EventLogSettings</a>. If <code>null</code> or not specified, the following default settings are used:</p>
<ul>
<li><code>LogName : "Application"</code></li>
<li><code>SourceName : ".NET Runtime"</code></li>
<li><code>MachineName</code> : local machine</li>
</ul>
<p>The following code changes the <code>SourceName</code> from the default value of <code>".NET Runtime"</code> to <code>MyLogs</code>:</p>
<pre tabindex="0"><code data-author-content="public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =>
            {
                logging.AddEventLog(eventLogSettings =>
                {
                    eventLogSettings.SourceName = &quot;MyLogs&quot;; 
                });
            })
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
"><span><span>public</span> <span>class</span> <span>Program</span>
{
    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        CreateHostBuilder(args).Build().Run();
    }

    <span><span>public</span> <span>static</span> IHostBuilder <span>CreateHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =&gt;
            {
                logging.AddEventLog(eventLogSettings =&gt;
                {
                    eventLogSettings.SourceName = <span>"MyLogs"</span>; 
                });
            })
            .ConfigureWebHostDefaults(webBuilder =&gt;
            {
                webBuilder.UseStartup&lt;Startup&gt;();
            });
}
</span></code></pre><h3 id="azure-app-service">Azure App Service<a href="#azure-app-service" aria-labelledby="azure-app-service"></a></h3>
<p>The <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.AzureAppServices" data-linktype="external">Microsoft.Extensions.Logging.AzureAppServices</a> provider package writes logs to text files in an Azure App Service app's file system and to <a href="https://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-blobs/#what-is-blob-storage" data-linktype="external">blob storage</a> in an Azure Storage account.</p>
<p>The provider package isn't included in the shared framework. To use the provider, add the provider package to the project.</p>
<p>To configure provider settings, use <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.azureappservices.azurefileloggeroptions" data-linktype="absolute-path">AzureFileLoggerOptions</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.azureappservices.azureblobloggeroptions" data-linktype="absolute-path">AzureBlobLoggerOptions</a>, as shown in the following example:</p>
<pre tabindex="0"><code data-author-content="public class Scopes
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureLogging(logging => logging.AddAzureWebAppDiagnostics())
                .ConfigureServices(serviceCollection => serviceCollection
                    .Configure<AzureFileLoggerOptions>(options =>
                    {
                        options.FileName = &quot;azure-diagnostics-&quot;;
                        options.FileSizeLimit = 50 * 1024;
                        options.RetainedFileCountLimit = 5;
                    })
                    .Configure<AzureBlobLoggerOptions>(options =>
                    {
                        options.BlobName = &quot;log.txt&quot;;
                    }))
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                });
    }
}
"><span><span>public</span> <span>class</span> <span>Scopes</span>
{
    <span>public</span> <span>class</span> <span>Program</span>
    {
        <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
        {
            CreateHostBuilder(args).Build().Run();
        }

        <span><span>public</span> <span>static</span> IHostBuilder <span>CreateHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureLogging(logging =&gt; logging.AddAzureWebAppDiagnostics())
                .ConfigureServices(serviceCollection =&gt; serviceCollection
                    .Configure&lt;AzureFileLoggerOptions&gt;(options =&gt;
                    {
                        options.FileName = <span>"azure-diagnostics-"</span>;
                        options.FileSizeLimit = <span>50</span> * <span>1024</span>;
                        options.RetainedFileCountLimit = <span>5</span>;
                    })
                    .Configure&lt;AzureBlobLoggerOptions&gt;(options =&gt;
                    {
                        options.BlobName = <span>"log.txt"</span>;
                    }))
                .ConfigureWebHostDefaults(webBuilder =&gt;
                {
                    webBuilder.UseStartup&lt;Startup&gt;();
                });
    }
}
</span></code></pre>
<p>When deployed to Azure App Service, the app uses the settings in the <a href="https://docs.microsoft.com/en-us/azure/app-service/web-sites-enable-diagnostic-log/#enable-application-logging-windows" data-linktype="absolute-path">App Service logs</a> section of the <strong>App Service</strong> page of the Azure portal. When the following settings are updated, the changes take effect immediately without requiring a restart or redeployment of the app.</p>
<ul>
<li><strong>Application Logging (Filesystem)</strong></li>
<li><strong>Application Logging (Blob)</strong></li>
</ul>
<p>The default location for log files is in the <em>D:\home\LogFiles\Application</em> folder, and the default file name is <em>diagnostics-yyyymmdd.txt</em>. The default file size limit is 10 MB, and the default maximum number of files retained is 2. The default blob name is <em>{app-name}{timestamp}/yyyy/mm/dd/hh/{guid}-applicationLog.txt</em>.</p>
<p>This provider only logs when the project runs in the Azure environment.</p>
<h4 id="azure-log-streaming">Azure log streaming<a href="#azure-log-streaming" aria-labelledby="azure-log-streaming"></a></h4>
<p>Azure log streaming supports viewing log activity in real time from:</p>
<ul>
<li>The app server</li>
<li>The web server</li>
<li>Failed request tracing</li>
</ul>
<p>To configure Azure log streaming:</p>
<ul>
<li>Navigate to the <strong>App Service logs</strong> page from the app's portal page.</li>
<li>Set <strong>Application Logging (Filesystem)</strong> to <strong>On</strong>.</li>
<li>Choose the log <strong>Level</strong>. This setting only applies to Azure log streaming.</li>
</ul>
<p>Navigate to the <strong>Log Stream</strong> page to view logs. The logged messages are logged with the <code>ILogger</code> interface.</p>
<h3 id="azure-application-insights">Azure Application Insights<a href="#azure-application-insights" aria-labelledby="azure-application-insights"></a></h3>
<p>The <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.ApplicationInsights" data-linktype="external">Microsoft.Extensions.Logging.ApplicationInsights</a> provider package writes logs to <a href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/cloudservices" data-linktype="absolute-path">Azure Application Insights</a>. Application Insights is a service that monitors a web app and provides tools for querying and analyzing the telemetry data. If you use this provider, you can query and analyze your logs by using the Application Insights tools.</p>
<p>The logging provider is included as a dependency of <a href="https://www.nuget.org/packages/Microsoft.ApplicationInsights.AspNetCore" data-linktype="external">Microsoft.ApplicationInsights.AspNetCore</a>, which is the package that provides all available telemetry for ASP.NET Core. If you use this package, you don't have to install the provider package.</p>
<p>The <a href="https://www.nuget.org/packages/Microsoft.ApplicationInsights.Web" data-linktype="external">Microsoft.ApplicationInsights.Web</a> package is for ASP.NET 4.x, not ASP.NET Core.</p>
<p>For more information, see the following resources:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/application-insights/app-insights-overview" data-linktype="absolute-path">Application Insights overview</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core" data-linktype="absolute-path">Application Insights for ASP.NET Core applications</a> - Start here if you want to implement the full range of Application Insights telemetry along with logging.</li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/ilogger" data-linktype="absolute-path">ApplicationInsightsLoggerProvider for .NET Core ILogger logs</a> - Start here if you want to implement the logging provider without the rest of Application Insights telemetry.</li>
<li><a href="https://docs.microsoft.com/azure/azure-monitor/app/asp-net-trace-logs" data-linktype="external">Application Insights logging adapters</a>.</li>
<li><a href="https://docs.microsoft.com/en-us/learn/modules/instrument-web-app-code-with-application-insights" data-linktype="absolute-path">Install, configure, and initialize the Application Insights SDK</a> - Interactive tutorial on the Microsoft Learn site.</li>
</ul>
<h2 id="third-party-logging-providers">Third-party logging providers<a href="#third-party-logging-providers" aria-labelledby="third-party-logging-providers"></a></h2>
<p>Third-party logging frameworks that work with ASP.NET Core:</p>
<ul>
<li><a href="https://elmah.io/" data-linktype="external">elmah.io</a> (<a href="https://github.com/elmahio/Elmah.Io.Extensions.Logging" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://docs.graylog.org/en/2.3/pages/gelf.html" data-linktype="external">Gelf</a> (<a href="https://github.com/mattwcole/gelf-extensions-logging" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://jsnlog.com/" data-linktype="external">JSNLog</a> (<a href="https://github.com/mperdeck/jsnlog" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://kisslog.net/" data-linktype="external">KissLog.net</a> (<a href="https://github.com/catalingavan/KissLog-net" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://logging.apache.org/log4net/" data-linktype="external">Log4Net</a> (<a href="https://github.com/huorswords/Microsoft.Extensions.Logging.Log4Net.AspNetCore" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://loggr.net/" data-linktype="external">Loggr</a> (<a href="https://github.com/imobile3/Loggr.Extensions.Logging" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://nlog-project.org/" data-linktype="external">NLog</a> (<a href="https://github.com/NLog/NLog.Extensions.Logging" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://www.nuget.org/packages/InvertedSoftware.PLogger.Core/" data-linktype="external">PLogger</a> (<a href="https://github.com/invertedsoftware/InvertedSoftware.PLogger.Core" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://sentry.io/welcome/" data-linktype="external">Sentry</a> (<a href="https://github.com/getsentry/sentry-dotnet" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://serilog.net/" data-linktype="external">Serilog</a> (<a href="https://github.com/serilog/serilog-aspnetcore" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://cloud.google.com/dotnet/docs/stackdriver#logging" data-linktype="external">Stackdriver</a> (<a href="https://github.com/googleapis/google-cloud-dotnet" data-linktype="external">Github repo</a>)</li>
</ul>
<p>Some third-party frameworks can perform <a href="https://softwareengineering.stackexchange.com/questions/312197/benefits-of-structured-logging-vs-basic-logging" data-linktype="external">semantic logging, also known as structured logging</a>.</p>
<p>Using a third-party framework is similar to using one of the built-in providers:</p>
<ol>
<li>Add a NuGet package to your project.</li>
<li>Call an <code>ILoggerFactory</code> extension method provided by the logging framework.</li>
</ol>
<p>For more information, see each provider's documentation. Third-party logging providers aren't supported by Microsoft.</p>

<h2 id="non-host-console-app">Non-host console app<a href="#non-host-console-app" aria-labelledby="non-host-console-app"></a></h2>
<p>For an example of how to use the Generic Host in a non-web console app, see the <em>Program.cs</em> file of the <a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/host/hosted-services/samples" data-linktype="external">Background Tasks sample app</a> (<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.0" data-linktype="relative-path">Background tasks with hosted services in ASP.NET Core</a>).</p>
<p>Logging code for apps without Generic Host differs in the way <a href="#add-providers" data-linktype="self-bookmark">providers are added</a> and <a href="#create-logs" data-linktype="self-bookmark">loggers are created</a>.</p>
<h3 id="logging-providers-1">Logging providers<a href="#logging-providers-1" aria-labelledby="logging-providers-1"></a></h3>
<p>In a non-host console app, call the provider's <code>Add{provider name}</code> extension method while creating a <code>LoggerFactory</code>:</p>
<pre tabindex="0"><code highlight-lines="11-12" data-author-content="class Program
{
    static void Main(string[] args)
    {
        var loggerFactory = LoggerFactory.Create(builder =>
        {
            builder
                .AddFilter(&quot;Microsoft&quot;, LogLevel.Warning)
                .AddFilter(&quot;System&quot;, LogLevel.Warning)
                .AddFilter(&quot;LoggingConsoleApp.Program&quot;, LogLevel.Debug)
                .AddConsole()
                .AddEventLog();
        });
        ILogger logger = loggerFactory.CreateLogger<Program>();
        logger.LogInformation(&quot;Example log message&quot;);
    }
}
"><span><span>class</span> <span>Program</span>
{
    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        <span>var</span> loggerFactory = LoggerFactory.Create(builder =&gt;
        {
            builder
                .AddFilter(<span>"Microsoft"</span>, LogLevel.Warning)
                .AddFilter(<span>"System"</span>, LogLevel.Warning)
                .AddFilter(<span>"LoggingConsoleApp.Program"</span>, LogLevel.Debug)</span>
<mark>                .AddConsole()
                .AddEventLog();</mark>
<span>        });
        ILogger logger = loggerFactory.CreateLogger&lt;Program&gt;();
        logger.LogInformation(<span>"Example log message"</span>);
    }
}
</span></code></pre><h3 id="create-logs-1">Create logs<a href="#create-logs-1" aria-labelledby="create-logs-1"></a></h3>
<p>To create logs, use an <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger-1" data-linktype="absolute-path">ILogger&lt;TCategoryName&gt;</a> object. Use the <code>LoggerFactory</code> to create an <code>ILogger</code>.</p>
<p>The following example creates a logger with <code>LoggingConsoleApp.Program</code> as the category.</p>
<pre tabindex="0"><code highlight-lines="14" data-author-content="class Program
{
    static void Main(string[] args)
    {
        var loggerFactory = LoggerFactory.Create(builder =>
        {
            builder
                .AddFilter(&quot;Microsoft&quot;, LogLevel.Warning)
                .AddFilter(&quot;System&quot;, LogLevel.Warning)
                .AddFilter(&quot;LoggingConsoleApp.Program&quot;, LogLevel.Debug)
                .AddConsole()
                .AddEventLog();
        });
        ILogger logger = loggerFactory.CreateLogger<Program>();
        logger.LogInformation(&quot;Example log message&quot;);
    }
}
"><span><span>class</span> <span>Program</span>
{
    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        <span>var</span> loggerFactory = LoggerFactory.Create(builder =&gt;
        {
            builder
                .AddFilter(<span>"Microsoft"</span>, LogLevel.Warning)
                .AddFilter(<span>"System"</span>, LogLevel.Warning)
                .AddFilter(<span>"LoggingConsoleApp.Program"</span>, LogLevel.Debug)
                .AddConsole()
                .AddEventLog();
        });</span>
<mark>        ILogger logger = loggerFactory.CreateLogger&lt;Program&gt;();</mark>
<span>        logger.LogInformation(<span>"Example log message"</span>);
    }
}
</span></code></pre>
<p>In the following ASP.NET CORE examples, the logger is used to create logs with <code>Information</code> as the level. The Log <em>level</em> indicates the severity of the logged event.</p>
<pre tabindex="0"><code highlight-lines="15" data-author-content="class Program
{
    static void Main(string[] args)
    {
        var loggerFactory = LoggerFactory.Create(builder =>
        {
            builder
                .AddFilter(&quot;Microsoft&quot;, LogLevel.Warning)
                .AddFilter(&quot;System&quot;, LogLevel.Warning)
                .AddFilter(&quot;LoggingConsoleApp.Program&quot;, LogLevel.Debug)
                .AddConsole()
                .AddEventLog();
        });
        ILogger logger = loggerFactory.CreateLogger<Program>();
        logger.LogInformation(&quot;Example log message&quot;);
    }
}
"><span><span>class</span> <span>Program</span>
{
    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        <span>var</span> loggerFactory = LoggerFactory.Create(builder =&gt;
        {
            builder
                .AddFilter(<span>"Microsoft"</span>, LogLevel.Warning)
                .AddFilter(<span>"System"</span>, LogLevel.Warning)
                .AddFilter(<span>"LoggingConsoleApp.Program"</span>, LogLevel.Debug)
                .AddConsole()
                .AddEventLog();
        });
        ILogger logger = loggerFactory.CreateLogger&lt;Program&gt;();</span>
<mark>        logger.LogInformation(<span>"Example log message"</span>);</mark>
<span>    }
}
</span></code></pre>
<p><a href="#log-level" data-linktype="self-bookmark">Levels</a> and <a href="#log-category" data-linktype="self-bookmark">categories</a> are explained in more detail in this document.</p>

<h2 id="log-during-host-construction">Log during host construction<a href="#log-during-host-construction" aria-labelledby="log-during-host-construction"></a></h2>
<p>Logging during host construction isn't directly supported. However, a separate logger can be used. In the following example, a <a href="https://serilog.net/" data-linktype="external">Serilog</a> logger is used to log in <code>CreateHostBuilder</code>. <code>AddSerilog</code> uses the static configuration specified in <code>Log.Logger</code>:</p>
<pre tabindex="0"><code data-author-content="using System;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args)
    {
        var builtConfig = new ConfigurationBuilder()
            .AddJsonFile(&quot;appsettings.json&quot;)
            .AddCommandLine(args)
            .Build();

        Log.Logger = new LoggerConfiguration()
            .WriteTo.Console()
            .WriteTo.File(builtConfig[&quot;Logging:FilePath&quot;])
            .CreateLogger();

        try
        {
            return Host.CreateDefaultBuilder(args)
                .ConfigureServices((context, services) =>
                {
                    services.AddRazorPages();
                })
                .ConfigureAppConfiguration((hostingContext, config) =>
                {
                    config.AddConfiguration(builtConfig);
                })
                .ConfigureLogging(logging =>
                {   
                    logging.AddSerilog();
                })
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                });
        }
        catch (Exception ex)
        {
            Log.Fatal(ex, &quot;Host builder error&quot;);

            throw;
        }
        finally
        {
            Log.CloseAndFlush();
        }
    }
}
"><span><span>using</span> System;
<span>using</span> Microsoft.AspNetCore.Hosting;
<span>using</span> Microsoft.Extensions.DependencyInjection;
<span>using</span> Microsoft.Extensions.Configuration;
<span>using</span> Microsoft.Extensions.Hosting;
<span>using</span> Microsoft.Extensions.Logging;

<span>public</span> <span>class</span> <span>Program</span>
{
    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        CreateHostBuilder(args).Build().Run();
    }

    <span><span>public</span> <span>static</span> IHostBuilder <span>CreateHostBuilder</span>(<span><span>string</span>[] args</span>)</span>
    {
        <span>var</span> builtConfig = <span>new</span> ConfigurationBuilder()
            .AddJsonFile(<span>"appsettings.json"</span>)
            .AddCommandLine(args)
            .Build();

        Log.Logger = <span>new</span> LoggerConfiguration()
            .WriteTo.Console()
            .WriteTo.File(builtConfig[<span>"Logging:FilePath"</span>])
            .CreateLogger();

        <span>try</span>
        {
            <span>return</span> Host.CreateDefaultBuilder(args)
                .ConfigureServices((context, services) =&gt;
                {
                    services.AddRazorPages();
                })
                .ConfigureAppConfiguration((hostingContext, config) =&gt;
                {
                    config.AddConfiguration(builtConfig);
                })
                .ConfigureLogging(logging =&gt;
                {   
                    logging.AddSerilog();
                })
                .ConfigureWebHostDefaults(webBuilder =&gt;
                {
                    webBuilder.UseStartup&lt;Startup&gt;();
                });
        }
        <span>catch</span> (Exception ex)
        {
            Log.Fatal(ex, <span>"Host builder error"</span>);

            <span>throw</span>;
        }
        <span>finally</span>
        {
            Log.CloseAndFlush();
        }
    }
}
</span></code></pre>

<h2 id="configure-a-service-that-depends-on-ilogger">Configure a service that depends on ILogger<a href="#configure-a-service-that-depends-on-ilogger" aria-labelledby="configure-a-service-that-depends-on-ilogger"></a></h2>
<p>Constructor injection of a logger into <code>Startup</code> works in earlier versions of ASP.NET Core because a separate DI container is created for the Web Host. For information about why only one container is created for the Generic Host, see the <a href="https://github.com/aspnet/Announcements/issues/353" data-linktype="external">breaking change announcement</a>.</p>
<p>To configure a service that depends on <code>ILogger&lt;T&gt;</code>, use constructor injection or provide a factory method. The factory method approach is recommended only if there is no other option. For example, consider a service that needs an <code>ILogger&lt;T&gt;</code> instance provided by DI:</p>
<pre tabindex="0"><code highlight-lines="6-10" data-author-content="public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();

    services.AddSingleton<IMyService>((container) =>
    {
        var logger = container.GetRequiredService<ILogger<MyService>>();
        return new MyService() { Logger = logger };
    });
}
"><span><span><span>public</span> <span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection services</span>)</span>
{
    services.AddControllers();
    services.AddRazorPages();
</span>
<mark>    services.AddSingleton&lt;IMyService&gt;((container) =&gt;
    {
        <span>var</span> logger = container.GetRequiredService&lt;ILogger&lt;MyService&gt;&gt;();
        <span>return</span> <span>new</span> MyService() { Logger = logger };
    });</mark>
<span>}
</span></code></pre>
<p>The preceding highlighted code is a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.func-2" data-linktype="absolute-path">Func</a> that runs the first time the DI container needs to construct an instance of <code>MyService</code>. You can access any of the registered services in this way.</p>

<h2 id="create-logs-in-main">Create logs in Main<a href="#create-logs-in-main" aria-labelledby="create-logs-in-main"></a></h2>
<p>The following code logs in <code>Main</code> by getting an <code>ILogger</code> instance from DI after building the host:</p>
<pre tabindex="0"><code data-author-content="public static void Main(string[] args)
{
    var host = CreateHostBuilder(args).Build();

    var logger = host.Services.GetRequiredService<ILogger<Program>>();
    logger.LogInformation(&quot;Host created.&quot;);

    host.Run();
}

public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseStartup<Startup>();
        });
"><span><span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
{
    <span>var</span> host = CreateHostBuilder(args).Build();

    <span>var</span> logger = host.Services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
    logger.LogInformation(<span>"Host created."</span>);

    host.Run();
}

<span><span>public</span> <span>static</span> IHostBuilder <span>CreateHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =&gt;
        {
            webBuilder.UseStartup&lt;Startup&gt;();
        });
</span></code></pre><h3 id="create-logs-in-startup">Create logs in Startup<a href="#create-logs-in-startup" aria-labelledby="create-logs-in-startup"></a></h3>
<p>The following code writes logs in <code>Startup.Configure</code>:</p>
<pre tabindex="0"><code data-author-content="public void Configure(IApplicationBuilder app, IWebHostEnvironment env,
                      ILogger<Startup> logger)
{
    if (env.IsDevelopment())
    {
        logger.LogInformation(&quot;In Development.&quot;);
        app.UseDeveloperExceptionPage();
    }
    else
    {
        logger.LogInformation(&quot;Not Development.&quot;);
        app.UseExceptionHandler(&quot;/Error&quot;);
        app.UseHsts();
    }

    app.UseHttpsRedirection();
    app.UseStaticFiles();

    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapRazorPages();
    });
}
"><span><span><span>public</span> <span>void</span> <span>Configure</span>(<span>IApplicationBuilder app, IWebHostEnvironment env,
                      ILogger&lt;Startup&gt; logger</span>)</span>
{
    <span>if</span> (env.IsDevelopment())
    {
        logger.LogInformation(<span>"In Development."</span>);
        app.UseDeveloperExceptionPage();
    }
    <span>else</span>
    {
        logger.LogInformation(<span>"Not Development."</span>);
        app.UseExceptionHandler(<span>"/Error"</span>);
        app.UseHsts();
    }

    app.UseHttpsRedirection();
    app.UseStaticFiles();

    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapControllers();
        endpoints.MapRazorPages();
    });
}
</span></code></pre>
<p>Writing logs before completion of the DI container setup in the <code>Startup.ConfigureServices</code> method is not supported:</p>
<ul>
<li>Logger injection into the <code>Startup</code> constructor is not supported.</li>
<li>Logger injection into the <code>Startup.ConfigureServices</code> method signature is not supported</li>
</ul>
<p>The reason for this restriction is that logging depends on DI and on configuration, which in turns depends on DI. The DI container isn't set up until <code>ConfigureServices</code> finishes.</p>
<p>For information on configuring a service that depends on <code>ILogger&lt;T&gt;</code> or why constructor injection of a logger into <code>Startup</code> worked in earlier versions, see <a href="#csdi" data-linktype="self-bookmark">Configure a service that depends on ILogger</a></p>
<h3 id="no-asynchronous-logger-methods">No asynchronous logger methods<a href="#no-asynchronous-logger-methods" aria-labelledby="no-asynchronous-logger-methods"></a></h3>
<p>Logging should be so fast that it isn't worth the performance cost of asynchronous code. If a logging data store is slow, don't write to it directly. Consider writing the log messages to a fast store initially, then moving them to the slow store later. For example, when logging to SQL Server, don't do so directly in a <code>Log</code> method, since the <code>Log</code> methods are synchronous. Instead, synchronously add log messages to an in-memory queue and have a background worker pull the messages out of the queue to do the asynchronous work of pushing data to SQL Server. For more information, see <a href="https://github.com/dotnet/AspNetCore.Docs/issues/11801" data-linktype="external">this</a> GitHub issue.</p>

<h3 id="create-logs-in-blazor">Create logs in Blazor<a href="#create-logs-in-blazor" aria-labelledby="create-logs-in-blazor"></a></h3>
<h4 id="blazor-webassembly">Blazor WebAssembly<a href="#blazor-webassembly" aria-labelledby="blazor-webassembly"></a></h4>
<p>Configure logging in Blazor WebAssembly apps with the <code>WebAssemblyHostBuilder.Logging</code> property in <code>Program.Main</code>:</p>
<pre tabindex="0"><code data-author-content="using Microsoft.AspNetCore.Components.WebAssembly.Hosting;

...

var builder = WebAssemblyHostBuilder.CreateDefault(args);

builder.Logging.SetMinimumLevel(LogLevel.Debug);
builder.Logging.AddProvider(new CustomLoggingProvider());
"><span><span>using</span> Microsoft.AspNetCore.Components.WebAssembly.Hosting;

...

<span>var</span> builder = WebAssemblyHostBuilder.CreateDefault(args);

builder.Logging.SetMinimumLevel(LogLevel.Debug);
builder.Logging.AddProvider(<span>new</span> CustomLoggingProvider());
</span></code></pre>
<p>The <code>Logging</code> property is of type <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggingbuilder" data-linktype="absolute-path">ILoggingBuilder</a>, so all of the extension methods available on <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggingbuilder" data-linktype="absolute-path">ILoggingBuilder</a> are also available on <code>Logging</code>.</p>
<h4 id="log-in-razor-components">Log in Razor components<a href="#log-in-razor-components" aria-labelledby="log-in-razor-components"></a></h4>
<p>Loggers respect app startup configuration.</p>
<p>The <code>using</code> directive for <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging" data-linktype="absolute-path">Microsoft.Extensions.Logging</a> is required to support Intellisense completions for APIs, such as <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.logwarning" data-linktype="absolute-path">LogWarning</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.logerror" data-linktype="absolute-path">LogError</a>.</p>
<p>The following example demonstrates logging with an <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger" data-linktype="absolute-path">ILogger</a> in Razor components:</p>
<pre tabindex="0"><code data-author-content="@page &quot;/counter&quot;
@using Microsoft.Extensions.Logging;
@inject ILogger<Counter> logger;

<h1>Counter</h1>

<p>Current count: @currentCount</p>

<button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;>Click me</button>

@code {
    private int currentCount = 0;

    private void IncrementCount()
    {
        logger.LogWarning(&quot;Someone has clicked me!&quot;);

        currentCount++;
    }
}
"><span><span></span><span></span><span>@</span><span>page</span><span> "/counter"
</span><span><span>@using</span><span> Microsoft.Extensions.Logging;</span></span><span>
</span><span><span>@inject</span><span> ILogger&lt;Counter&gt; logger;</span></span><span>

<span>&lt;<span>h1</span>&gt;</span>Counter<span>&lt;/<span>h1</span>&gt;</span>

<span>&lt;<span>p</span>&gt;</span>Current count: </span><span></span><span>@</span><span>currentCount</span><span><span>&lt;/<span>p</span>&gt;</span>

<span>&lt;<span>button</span> <span>class</span>=<span>"btn btn-primary"</span> </span></span><span></span><span>@</span><span>onclick=<span>"IncrementCount"</span>&gt;Click</span><span><span> <span>me</span>&lt;/<span>button</span>&gt;</span>

</span><span></span><span>@</span><span>code</span><span> {
    private int currentCount = 0;

    private void IncrementCount()
    {
        logger.LogWarning("Someone has clicked me!");

        currentCount++;
    }
}
</span></span></code></pre>
<p>The following example demonstrates logging with an <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggerfactory" data-linktype="absolute-path">ILoggerFactory</a> in Razor components:</p>
<pre tabindex="0"><code data-author-content="@page &quot;/counter&quot;
@using Microsoft.Extensions.Logging;
@inject ILoggerFactory LoggerFactory

<h1>Counter</h1>

<p>Current count: @currentCount</p>

<button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;>Click me</button>

@code {
    private int currentCount = 0;

    private void IncrementCount()
    {
        var logger = LoggerFactory.CreateLogger<Counter>();
        logger.LogWarning(&quot;Someone has clicked me!&quot;);

        currentCount++;
    }
}
"><span><span></span><span></span><span>@</span><span>page</span><span> "/counter"
</span><span><span>@using</span><span> Microsoft.Extensions.Logging;</span></span><span>
</span><span><span>@inject</span><span> ILoggerFactory LoggerFactory</span></span><span>

<span>&lt;<span>h1</span>&gt;</span>Counter<span>&lt;/<span>h1</span>&gt;</span>

<span>&lt;<span>p</span>&gt;</span>Current count: </span><span></span><span>@</span><span>currentCount</span><span><span>&lt;/<span>p</span>&gt;</span>

<span>&lt;<span>button</span> <span>class</span>=<span>"btn btn-primary"</span> </span></span><span></span><span>@</span><span>onclick=<span>"IncrementCount"</span>&gt;Click</span><span><span> <span>me</span>&lt;/<span>button</span>&gt;</span>

</span><span></span><span>@</span><span>code</span><span> {
    private int currentCount = 0;

    private void IncrementCount()
    {
        var logger = LoggerFactory.CreateLogger<span>&lt;<span>Counter</span>&gt;</span>();
        logger.LogWarning("Someone has clicked me!");

        currentCount++;
    }
}
</span></span></code></pre>
<h2 id="change-log-levels-in-a-running-app">Change log levels in a running app<a href="#change-log-levels-in-a-running-app" aria-labelledby="change-log-levels-in-a-running-app"></a></h2>
<p>The Logging API doesn't include a scenario to change log levels while an app is running. However, some configuration providers are capable of reloading configuration, which takes immediate effect on logging configuration. For example, the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.0#file-configuration-provider" data-linktype="relative-path">File Configuration Provider</a>, reloads logging configuration by default. If configuration is changed in code while an app is running, the app can call <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfigurationroot.reload" data-linktype="absolute-path">IConfigurationRoot.Reload</a> to update the app's logging configuration.</p>
<h2 id="ilogger-and-iloggerfactory">ILogger and ILoggerFactory<a href="#ilogger-and-iloggerfactory" aria-labelledby="ilogger-and-iloggerfactory"></a></h2>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger-1" data-linktype="absolute-path">ILogger&lt;TCategoryName&gt;</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggerfactory" data-linktype="absolute-path">ILoggerFactory</a> interfaces and implementations are included in the .NET Core SDK. They are also available in the following NuGet packages:</p>
<ul>
<li>The interfaces are in <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.Abstractions/" data-linktype="external">Microsoft.Extensions.Logging.Abstractions</a>.</li>
<li>The default implementations are in <a href="https://www.nuget.org/packages/microsoft.extensions.logging/" data-linktype="external">Microsoft.Extensions.Logging</a>.</li>
</ul>
<!-- review. Why would you want to hard code filtering rules in code? -->

<h2 id="apply-log-filter-rules-in-code">Apply log filter rules in code<a href="#apply-log-filter-rules-in-code" aria-labelledby="apply-log-filter-rules-in-code"></a></h2>
<p>The preferred approach for setting log filter rules is by using <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.0" data-linktype="relative-path">Configuration</a>.</p>
<p>The following example shows how to register filter rules in code:</p>
<pre tabindex="0"><code data-author-content="public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =>
               logging.AddFilter(&quot;System&quot;, LogLevel.Debug)
                  .AddFilter<DebugLoggerProvider>(&quot;Microsoft&quot;, LogLevel.Information)
                  .AddFilter<ConsoleLoggerProvider>(&quot;Microsoft&quot;, LogLevel.Trace))
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}
"><span><span>public</span> <span>class</span> <span>Program</span>
{
    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        CreateHostBuilder(args).Build().Run();
    }

    <span><span>public</span> <span>static</span> IHostBuilder <span>CreateHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =&gt;
               logging.AddFilter(<span>"System"</span>, LogLevel.Debug)
                  .AddFilter&lt;DebugLoggerProvider&gt;(<span>"Microsoft"</span>, LogLevel.Information)
                  .AddFilter&lt;ConsoleLoggerProvider&gt;(<span>"Microsoft"</span>, LogLevel.Trace))
            .ConfigureWebHostDefaults(webBuilder =&gt;
            {
                webBuilder.UseStartup&lt;Startup&gt;();
            });
}
</span></code></pre>
<p><code>logging.AddFilter("System", LogLevel.Debug)</code> specifies the <code>System</code> category and log level <code>Debug</code>. The filter is applied to all providers because a specific provider was not configured.</p>
<p><code>AddFilter&lt;DebugLoggerProvider&gt;("Microsoft", LogLevel.Information)</code> specifies:</p>
<ul>
<li>The <code>Debug</code> logging provider.</li>
<li>Log level <code>Information</code> and higher.</li>
<li>All categories starting with <code>"Microsoft"</code>.</li>
</ul>
<h2 id="create-a-custom-logger">Create a custom logger<a href="#create-a-custom-logger" aria-labelledby="create-a-custom-logger"></a></h2>
<p>To add a custom logger, add an <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggerprovider" data-linktype="absolute-path">ILoggerProvider</a> with <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggerfactory" data-linktype="absolute-path">ILoggerFactory</a>:</p>
<pre tabindex="0"><code data-author-content="public void Configure(
    IApplicationBuilder app,
    IWebHostEnvironment env,
    ILoggerFactory loggerFactory)
{
    loggerFactory.AddProvider(new CustomLoggerProvider(new CustomLoggerConfiguration()));
"><span><span><span>public</span> <span>void</span> <span>Configure</span>(<span>
    IApplicationBuilder app,
    IWebHostEnvironment env,
    ILoggerFactory loggerFactory</span>)</span>
{
    loggerFactory.AddProvider(<span>new</span> CustomLoggerProvider(<span>new</span> CustomLoggerConfiguration()));
</span></code></pre>
<p>The <code>ILoggerProvider</code> creates one or more <code>ILogger</code> instances. The <code>ILogger</code> instances are used by the framework to log the information.</p>
<h3 id="sample-custom-logger-configuration">Sample custom logger configuration<a href="#sample-custom-logger-configuration" aria-labelledby="sample-custom-logger-configuration"></a></h3>
<p>The sample:</p>
<ul>
<li>Is designed to be a very basic sample that sets the color of the log console by event ID and log level. Loggers generally don't change by event ID and are not specific to log level.</li>
<li>Creates different colored console entries per log level and event ID using the following configuration type:</li>
</ul>
<pre tabindex="0"><code data-author-content="public class ColoredConsoleLoggerConfiguration
{
    public LogLevel LogLevel { get; set; } = LogLevel.Warning;
    public int EventId { get; set; } = 0;
    public ConsoleColor Color { get; set; } = ConsoleColor.Yellow;
}
"><span><span>public</span> <span>class</span> <span>ColoredConsoleLoggerConfiguration</span>
{
    <span>public</span> LogLevel LogLevel { <span>get</span>; <span>set</span>; } = LogLevel.Warning;
    <span>public</span> <span>int</span> EventId { <span>get</span>; <span>set</span>; } = <span>0</span>;
    <span>public</span> ConsoleColor Color { <span>get</span>; <span>set</span>; } = ConsoleColor.Yellow;
}
</span></code></pre>
<p>The preceding code sets the default level to <code>Warning</code> and the color to <code>Yellow</code>. If the <code>EventId</code> is set to 0, we will log all events.</p>
<h3 id="create-the-custom-logger">Create the custom logger<a href="#create-the-custom-logger" aria-labelledby="create-the-custom-logger"></a></h3>
<p>The <code>ILogger</code> implementation category name is typically the logging source. For example, the type where the logger is created:</p>
<pre tabindex="0"><code data-author-content="public class ColoredConsoleLogger : ILogger
{
    private readonly string _name;
    private readonly ColoredConsoleLoggerConfiguration _config;

    public ColoredConsoleLogger(string name, ColoredConsoleLoggerConfiguration config)
    {
        _name = name;
        _config = config;
    }

    public IDisposable BeginScope<TState>(TState state)
    {
        return null;
    }

    public bool IsEnabled(LogLevel logLevel)
    {
        return logLevel == _config.LogLevel;
    }

    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, 
                        Exception exception, Func<TState, Exception, string> formatter)
    {
        if (!IsEnabled(logLevel))
        {
            return;
        }

        if (_config.EventId == 0 || _config.EventId == eventId.Id)
        {
            var color = Console.ForegroundColor;
            Console.ForegroundColor = _config.Color;
            Console.WriteLine($&quot;{logLevel} - {eventId.Id} &quot; +
                              $&quot;- {_name} - {formatter(state, exception)}&quot;);
            Console.ForegroundColor = color;
        }
    }
}
"><span><span>public</span> <span>class</span> <span>ColoredConsoleLogger</span> : <span>ILogger</span>
{
    <span>private</span> <span>readonly</span> <span>string</span> _name;
    <span>private</span> <span>readonly</span> ColoredConsoleLoggerConfiguration _config;

    <span><span>public</span> <span>ColoredConsoleLogger</span>(<span><span>string</span> name, ColoredConsoleLoggerConfiguration config</span>)</span>
    {
        _name = name;
        _config = config;
    }

    <span>public</span> IDisposable BeginScope&lt;TState&gt;(TState state)
    {
        <span>return</span> <span>null</span>;
    }

    <span><span>public</span> <span>bool</span> <span>IsEnabled</span>(<span>LogLevel logLevel</span>)</span>
    {
        <span>return</span> logLevel == _config.LogLevel;
    }

    <span>public</span> <span>void</span> Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, 
                        Exception exception, Func&lt;TState, Exception, <span>string</span>&gt; formatter)
    {
        <span>if</span> (!IsEnabled(logLevel))
        {
            <span>return</span>;
        }

        <span>if</span> (_config.EventId == <span>0</span> || _config.EventId == eventId.Id)
        {
            <span>var</span> color = Console.ForegroundColor;
            Console.ForegroundColor = _config.Color;
            Console.WriteLine(<span>$"<span>{logLevel}</span> - <span>{eventId.Id}</span> "</span> +
                              <span>$"- <span>{_name}</span> - <span>{formatter(state, exception)}</span>"</span>);
            Console.ForegroundColor = color;
        }
    }
}
</span></code></pre>
<p>The preceding code:</p>
<ul>
<li>Creates a logger instance per category name.</li>
<li>Checks <code>logLevel == _config.LogLevel</code> in <code>IsEnabled</code>, so each <code>logLevel</code> has a unique logger. Generally, loggers should also be enabled for all higher log levels:</li>
</ul>
<pre tabindex="0"><code data-author-content="public bool IsEnabled(LogLevel logLevel)
{
    return logLevel >= _config.LogLevel;
}
"><span><span><span>public</span> <span>bool</span> <span>IsEnabled</span>(<span>LogLevel logLevel</span>)</span>
{
    <span>return</span> logLevel &gt;= _config.LogLevel;
}
</span></code></pre>
<h3 id="create-the-custom-loggerprovider">Create the custom LoggerProvider<a href="#create-the-custom-loggerprovider" aria-labelledby="create-the-custom-loggerprovider"></a></h3>
<p>The <code>LoggerProvider</code> is the class that creates the logger instances. Maybe it is not needed to create a logger instance per category, but this makes sense for some Loggers, like NLog or log4net. Doing this you are also able to choose different logging output targets per category if needed:</p>
<pre tabindex="0"><code data-author-content="public class ColoredConsoleLoggerProvider : ILoggerProvider
{
    private readonly ColoredConsoleLoggerConfiguration _config;
    private readonly ConcurrentDictionary<string, ColoredConsoleLogger> _loggers = new ConcurrentDictionary<string, ColoredConsoleLogger>();

    public ColoredConsoleLoggerProvider(ColoredConsoleLoggerConfiguration config)
    {
        _config = config;
    }

    public ILogger CreateLogger(string categoryName)
    {
        return _loggers.GetOrAdd(categoryName, name => new ColoredConsoleLogger(name, _config));
    }

    public void Dispose()
    {
        _loggers.Clear();
    }
}
"><span><span>public</span> <span>class</span> <span>ColoredConsoleLoggerProvider</span> : <span>ILoggerProvider</span>
{
    <span>private</span> <span>readonly</span> ColoredConsoleLoggerConfiguration _config;
    <span>private</span> <span>readonly</span> ConcurrentDictionary&lt;<span>string</span>, ColoredConsoleLogger&gt; _loggers = <span>new</span> ConcurrentDictionary&lt;<span>string</span>, ColoredConsoleLogger&gt;();

    <span><span>public</span> <span>ColoredConsoleLoggerProvider</span>(<span>ColoredConsoleLoggerConfiguration config</span>)</span>
    {
        _config = config;
    }

    <span><span>public</span> ILogger <span>CreateLogger</span>(<span><span>string</span> categoryName</span>)</span>
    {
        <span>return</span> _loggers.GetOrAdd(categoryName, name =&gt; <span>new</span> ColoredConsoleLogger(name, _config));
    }

    <span><span>public</span> <span>void</span> <span>Dispose</span>(<span></span>)</span>
    {
        _loggers.Clear();
    }
}
</span></code></pre>
<p>In the preceding code, <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.build.logging.loggerdescription.createlogger" data-linktype="absolute-path">CreateLogger</a> creates a single instance of the <code>ColoredConsoleLogger</code> per category name and stores it in the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentdictionary-2" data-linktype="absolute-path"><code>ConcurrentDictionary&lt;TKey,TValue&gt;</code></a>;</p>
<h3 id="usage-and-registration-of-the-custom-logger">Usage and registration of the custom logger<a href="#usage-and-registration-of-the-custom-logger" aria-labelledby="usage-and-registration-of-the-custom-logger"></a></h3>
<p>Register the logger in the <code>Startup.Configure</code>:</p>
<pre tabindex="0"><code data-author-content="public void Configure(IApplicationBuilder app, IWebHostEnvironment env, 
                      ILoggerFactory loggerFactory)
{
    // Default registration.
    loggerFactory.AddProvider(new ColoredConsoleLoggerProvider(
                              new ColoredConsoleLoggerConfiguration
    {
        LogLevel = LogLevel.Error,
        Color = ConsoleColor.Red
    }));

    // Custom registration with default values.
    loggerFactory.AddColoredConsoleLogger();

    // Custom registration with a new configuration instance.
    loggerFactory.AddColoredConsoleLogger(new ColoredConsoleLoggerConfiguration
    {
        LogLevel = LogLevel.Debug,
        Color = ConsoleColor.Gray
    });

    // Custom registration with a configuration object.
    loggerFactory.AddColoredConsoleLogger(c =>
    {
        c.LogLevel = LogLevel.Information;
        c.Color = ConsoleColor.Blue;
    });

    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        app.UseExceptionHandler(&quot;/Home/Error&quot;);
        app.UseHsts();
    }
    app.UseHttpsRedirection();
    app.UseStaticFiles();

    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(
            name: &quot;default&quot;,
            pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
}
"><span><span><span>public</span> <span>void</span> <span>Configure</span>(<span>IApplicationBuilder app, IWebHostEnvironment env, 
                      ILoggerFactory loggerFactory</span>)</span>
{
    <span>// Default registration.</span>
    loggerFactory.AddProvider(<span>new</span> ColoredConsoleLoggerProvider(
                              <span>new</span> ColoredConsoleLoggerConfiguration
    {
        LogLevel = LogLevel.Error,
        Color = ConsoleColor.Red
    }));

    <span>// Custom registration with default values.</span>
    loggerFactory.AddColoredConsoleLogger();

    <span>// Custom registration with a new configuration instance.</span>
    loggerFactory.AddColoredConsoleLogger(<span>new</span> ColoredConsoleLoggerConfiguration
    {
        LogLevel = LogLevel.Debug,
        Color = ConsoleColor.Gray
    });

    <span>// Custom registration with a configuration object.</span>
    loggerFactory.AddColoredConsoleLogger(c =&gt;
    {
        c.LogLevel = LogLevel.Information;
        c.Color = ConsoleColor.Blue;
    });

    <span>if</span> (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    <span>else</span>
    {
        app.UseExceptionHandler(<span>"/Home/Error"</span>);
        app.UseHsts();
    }
    app.UseHttpsRedirection();
    app.UseStaticFiles();

    app.UseRouting();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapControllerRoute(
            name: <span>"default"</span>,
            pattern: <span>"{controller=Home}/{action=Index}/{id?}"</span>);
    });
}
</span></code></pre>
<p>For the preceding code, provide at least one extension method for the <code>ILoggerFactory</code>:</p>
<pre tabindex="0"><code data-author-content="public static class ColoredConsoleLoggerExtensions
{
    public static ILoggerFactory AddColoredConsoleLogger(
                                      this ILoggerFactory loggerFactory, 
                                      ColoredConsoleLoggerConfiguration config)
    {
        loggerFactory.AddProvider(new ColoredConsoleLoggerProvider(config));
        return loggerFactory;
    }
    public static ILoggerFactory AddColoredConsoleLogger(
                                      this ILoggerFactory loggerFactory)
    {
        var config = new ColoredConsoleLoggerConfiguration();
        return loggerFactory.AddColoredConsoleLogger(config);
    }
    public static ILoggerFactory AddColoredConsoleLogger(
                                    this ILoggerFactory loggerFactory, 
                                    Action<ColoredConsoleLoggerConfiguration> configure)
    {
        var config = new ColoredConsoleLoggerConfiguration();
        configure(config);
        return loggerFactory.AddColoredConsoleLogger(config);
    }
}
"><span><span>public</span> <span>static</span> <span>class</span> <span>ColoredConsoleLoggerExtensions</span>
{
    <span><span>public</span> <span>static</span> ILoggerFactory <span>AddColoredConsoleLogger</span>(<span>
                                      <span>this</span> ILoggerFactory loggerFactory, 
                                      ColoredConsoleLoggerConfiguration config</span>)</span>
    {
        loggerFactory.AddProvider(<span>new</span> ColoredConsoleLoggerProvider(config));
        <span>return</span> loggerFactory;
    }
    <span><span>public</span> <span>static</span> ILoggerFactory <span>AddColoredConsoleLogger</span>(<span>
                                      <span>this</span> ILoggerFactory loggerFactory</span>)</span>
    {
        <span>var</span> config = <span>new</span> ColoredConsoleLoggerConfiguration();
        <span>return</span> loggerFactory.AddColoredConsoleLogger(config);
    }
    <span><span>public</span> <span>static</span> ILoggerFactory <span>AddColoredConsoleLogger</span>(<span>
                                    <span>this</span> ILoggerFactory loggerFactory, 
                                    Action&lt;ColoredConsoleLoggerConfiguration&gt; configure</span>)</span>
    {
        <span>var</span> config = <span>new</span> ColoredConsoleLoggerConfiguration();
        configure(config);
        <span>return</span> loggerFactory.AddColoredConsoleLogger(config);
    }
}
</span></code></pre><h2 id="additional-resources">Additional resources<a href="#additional-resources" aria-labelledby="additional-resources"></a></h2>
<ul>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/loggermessage?view=aspnetcore-3.0" data-linktype="relative-path">High-performance logging with LoggerMessage in ASP.NET Core</a></li>
<li>Logging bugs should be created in the <a href="https://github.com/dotnet/runtime/issues" data-linktype="external">github.com/dotnet/runtime/</a> repo.</li>
<li><a href="https://asp.net-hacker.rocks/2017/05/05/add-custom-logging-in-aspnetcore.html" data-linktype="external">How to add custom logging in ASP.NET Core</a></li>
</ul>
</div>
<div data-moniker="aspnetcore-1.0 aspnetcore-1.1 aspnetcore-2.0 aspnetcore-2.1 aspnetcore-2.2">
<p>By <a href="https://github.com/tdykstra" data-linktype="external">Tom Dykstra</a> and <a href="https://ardalis.com/" data-linktype="external">Steve Smith</a></p>
<p>.NET Core supports a logging API that works with a variety of built-in and third-party logging providers. This article shows how to use the logging API with built-in providers.</p>
<p><a href="https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/logging/index/samples" data-linktype="external">View or download sample code</a> (<a href="https://docs.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.0#how-to-download-a-sample" data-linktype="relative-path">how to download</a>)</p>
<h2 data-id="add-providers">Add providers<a href="#add-providers" aria-labelledby="add-providers"></a></h2>
<p>A logging provider displays or stores logs. For example, the Console provider displays logs on the console, and the Azure Application Insights provider stores them in Azure Application Insights. Logs can be sent to multiple destinations by adding multiple providers.</p>
<p>To add a provider, call the provider's <code>Add{provider name}</code> extension method in <em>Program.cs</em>:</p>
<pre tabindex="0"><code highlight-lines="18-20" data-author-content="public static void Main(string[] args)
{
    var webHost = new WebHostBuilder()
        .UseKestrel()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureAppConfiguration((hostingContext, config) =>
        {
            var env = hostingContext.HostingEnvironment;
            config.AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
                  .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;, 
                      optional: true, reloadOnChange: true);
            config.AddEnvironmentVariables();
        })
        .ConfigureLogging((hostingContext, logging) =>
        {
            // Requires `using Microsoft.Extensions.Logging;`
            logging.AddConfiguration(hostingContext.Configuration.GetSection(&quot;Logging&quot;));
            logging.AddConsole();
            logging.AddDebug();
            logging.AddEventSourceLogger();
        })
        .UseStartup<Startup>()
        .Build();

    webHost.Run();
}
"><span><span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
{
    <span>var</span> webHost = <span>new</span> WebHostBuilder()
        .UseKestrel()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureAppConfiguration((hostingContext, config) =&gt;
        {
            <span>var</span> env = hostingContext.HostingEnvironment;
            config.AddJsonFile(<span>"appsettings.json"</span>, optional: <span>true</span>, reloadOnChange: <span>true</span>)
                  .AddJsonFile(<span>$"appsettings.<span>{env.EnvironmentName}</span>.json"</span>, 
                      optional: <span>true</span>, reloadOnChange: <span>true</span>);
            config.AddEnvironmentVariables();
        })
        .ConfigureLogging((hostingContext, logging) =&gt;
        {
            <span>// Requires `using Microsoft.Extensions.Logging;`</span>
            logging.AddConfiguration(hostingContext.Configuration.GetSection(<span>"Logging"</span>));</span>
<mark>            logging.AddConsole();
            logging.AddDebug();
            logging.AddEventSourceLogger();</mark>
<span>        })
        .UseStartup&lt;Startup&gt;()
        .Build();

    webHost.Run();
}
</span></code></pre>
<p>The preceding code requires references to <code>Microsoft.Extensions.Logging</code> and <code>Microsoft.Extensions.Configuration</code>.</p>
<p>The default project template calls <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.webhost.createdefaultbuilder" data-linktype="absolute-path">CreateDefaultBuilder</a>, which adds the following logging providers:</p>
<ul>
<li>Console</li>
<li>Debug</li>
<li>EventSource (starting in ASP.NET Core 2.2)</li>
</ul>
<pre tabindex="0"><code highlight-lines="7" data-author-content="public static void Main(string[] args)
{
    CreateWebHostBuilder(args).Build().Run();
}

public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>
    WebHost.CreateDefaultBuilder(args)
        .UseStartup<Startup>();
"><span><span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
{
    CreateWebHostBuilder(args).Build().Run();
}

<span><span>public</span> <span>static</span> IWebHostBuilder <span>CreateWebHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;</span>
<mark>    WebHost.CreateDefaultBuilder(args)</mark>
<span>        .UseStartup&lt;Startup&gt;();
</span></code></pre>
<p>If you use <code>CreateDefaultBuilder</code>, you can replace the default providers with your own choices. Call <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggingbuilderextensions.clearproviders" data-linktype="absolute-path">ClearProviders</a>, and add the providers you want.</p>
<pre tabindex="0"><code highlight-lines="18-22" data-author-content="public static void Main(string[] args)
{
    var host = CreateWebHostBuilder(args).Build();

    var todoRepository = host.Services.GetRequiredService<ITodoRepository>();
    todoRepository.Add(new Core.Model.TodoItem() { Name = &quot;Feed the dog&quot; });
    todoRepository.Add(new Core.Model.TodoItem() { Name = &quot;Walk the dog&quot; });

    var logger = host.Services.GetRequiredService<ILogger<Program>>();
    logger.LogInformation(&quot;Seeded the database.&quot;);

    host.Run();
}

public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>
    WebHost.CreateDefaultBuilder(args)
        .UseStartup<Startup>()
        .ConfigureLogging(logging =>
        {
            logging.ClearProviders();
            logging.AddConsole();
        });
"><span><span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
{
    <span>var</span> host = CreateWebHostBuilder(args).Build();

    <span>var</span> todoRepository = host.Services.GetRequiredService&lt;ITodoRepository&gt;();
    todoRepository.Add(<span>new</span> Core.Model.TodoItem() { Name = <span>"Feed the dog"</span> });
    todoRepository.Add(<span>new</span> Core.Model.TodoItem() { Name = <span>"Walk the dog"</span> });

    <span>var</span> logger = host.Services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
    logger.LogInformation(<span>"Seeded the database."</span>);

    host.Run();
}

<span><span>public</span> <span>static</span> IWebHostBuilder <span>CreateWebHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;
    WebHost.CreateDefaultBuilder(args)
        .UseStartup&lt;Startup&gt;()</span>
<mark>        .ConfigureLogging(logging =&gt;
        {
            logging.ClearProviders();
            logging.AddConsole();
        });</mark>
<span></span></code></pre>
<p>Learn more about <a href="#built-in-logging-providers" data-linktype="self-bookmark">built-in logging providers</a> and <a href="#third-party-logging-providers" data-linktype="self-bookmark">third-party logging providers</a> later in the article.</p>
<h2 data-id="create-logs-2">Create logs<a href="#create-logs-2" aria-labelledby="create-logs-2"></a></h2>
<p>To create logs, use an <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger-1" data-linktype="absolute-path">ILogger&lt;TCategoryName&gt;</a> object. In a web app or hosted service, get an <code>ILogger</code> from dependency injection (DI). In non-host console apps, use the <code>LoggerFactory</code> to create an <code>ILogger</code>.</p>
<p>The following ASP.NET Core example creates a logger with <code>TodoApiSample.Pages.AboutModel</code> as the category. The log <em>category</em> is a string that is associated with each log. The <code>ILogger&lt;T&gt;</code> instance provided by DI creates logs that have the fully qualified name of type <code>T</code> as the category.</p>
<pre tabindex="0"><code highlight-lines="3,5,7" data-author-content="public class AboutModel : PageModel
{
    private readonly ILogger _logger;

    public AboutModel(ILogger<AboutModel> logger)
    {
        _logger = logger;
    }
"><span><span>public</span> <span>class</span> <span>AboutModel</span> : <span>PageModel</span>
{</span>
<mark>    <span>private</span> <span>readonly</span> ILogger _logger;</mark>
<span></span>
<mark>    <span><span>public</span> <span>AboutModel</span>(<span>ILogger&lt;AboutModel&gt; logger</span>)</span></mark>
<span><span></span>    {</span>
<mark>        _logger = logger;</mark>
<span>    }
</span></code></pre>
<p>In the following ASP.NET Core and console app examples, the logger is used to create logs with <code>Information</code> as the level. The Log <em>level</em> indicates the severity of the logged event.</p>
<pre tabindex="0"><code highlight-lines="4" data-author-content="public void OnGet()
{
    Message = $&quot;About page visited at {DateTime.UtcNow.ToLongTimeString()}&quot;;
    _logger.LogInformation(&quot;Message displayed: {Message}&quot;, Message);
}
"><span><span><span>public</span> <span>void</span> <span>OnGet</span>(<span></span>)</span>
{
    Message = <span>$"About page visited at <span>{DateTime.UtcNow.ToLongTimeString()}</span>"</span>;</span>
<mark>    _logger.LogInformation(<span>"Message displayed: {Message}"</span>, Message);</mark>
<span>}
</span></code></pre>
<p><a href="#log-level" data-linktype="self-bookmark">Levels</a> and <a href="#log-category" data-linktype="self-bookmark">categories</a> are explained in more detail later in this article.</p>
<h3 data-id="create-logs-in-startup-1">Create logs in Startup<a href="#create-logs-in-startup-1" aria-labelledby="create-logs-in-startup-1"></a></h3>
<p>To write logs in the <code>Startup</code> class, include an <code>ILogger</code> parameter in the constructor signature:</p>
<pre tabindex="0"><code highlight-lines="3,5,8,20,27" data-author-content="public class Startup
{
    private readonly ILogger _logger;

    public Startup(IConfiguration configuration, ILogger<Startup> logger)
    {
        Configuration = configuration;
        _logger = logger;
    }

    public IConfiguration Configuration { get; }

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc()
            .SetCompatibilityVersion(CompatibilityVersion.Version_2_2);

        // Add our repository type
        services.AddSingleton<ITodoRepository, TodoRepository>();
        _logger.LogInformation(&quot;Added TodoRepository to services&quot;);
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        if (env.IsDevelopment())
        {
            _logger.LogInformation(&quot;In Development environment&quot;);
            app.UseDeveloperExceptionPage();
        }
        else
        {
            app.UseExceptionHandler(&quot;/Error&quot;);
            app.UseHsts();
        }

        app.UseHttpsRedirection();
        app.UseStaticFiles();
        app.UseCookiePolicy();

        app.UseMvc();
    }
}
"><span><span>public</span> <span>class</span> <span>Startup</span>
{</span>
<mark>    <span>private</span> <span>readonly</span> ILogger _logger;</mark>
<span></span>
<mark>    <span><span>public</span> <span>Startup</span>(<span>IConfiguration configuration, ILogger&lt;Startup&gt; logger</span>)</span></mark>
<span><span></span>    {
        Configuration = configuration;</span>
<mark>        _logger = logger;</mark>
<span>    }

    <span>public</span> IConfiguration Configuration { <span>get</span>; }

    <span><span>public</span> <span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection services</span>)</span>
    {
        services.AddMvc()
            .SetCompatibilityVersion(CompatibilityVersion.Version_2_2);

        <span>// Add our repository type</span>
        services.AddSingleton&lt;ITodoRepository, TodoRepository&gt;();</span>
<mark>        _logger.LogInformation(<span>"Added TodoRepository to services"</span>);</mark>
<span>    }

    <span><span>public</span> <span>void</span> <span>Configure</span>(<span>IApplicationBuilder app, IHostingEnvironment env</span>)</span>
    {
        <span>if</span> (env.IsDevelopment())
        {</span>
<mark>            _logger.LogInformation(<span>"In Development environment"</span>);</mark>
<span>            app.UseDeveloperExceptionPage();
        }
        <span>else</span>
        {
            app.UseExceptionHandler(<span>"/Error"</span>);
            app.UseHsts();
        }

        app.UseHttpsRedirection();
        app.UseStaticFiles();
        app.UseCookiePolicy();

        app.UseMvc();
    }
}
</span></code></pre><h3 data-id="create-logs-in-the-program-class">Create logs in the Program class<a href="#create-logs-in-the-program-class" aria-labelledby="create-logs-in-the-program-class"></a></h3>
<p>To write logs in the <code>Program</code> class, get an <code>ILogger</code> instance from DI:</p>
<pre tabindex="0"><code highlight-lines="9,10" data-author-content="public static void Main(string[] args)
{
    var host = CreateWebHostBuilder(args).Build();

    var todoRepository = host.Services.GetRequiredService<ITodoRepository>();
    todoRepository.Add(new Core.Model.TodoItem() { Name = &quot;Feed the dog&quot; });
    todoRepository.Add(new Core.Model.TodoItem() { Name = &quot;Walk the dog&quot; });

    var logger = host.Services.GetRequiredService<ILogger<Program>>();
    logger.LogInformation(&quot;Seeded the database.&quot;);

    host.Run();
}

public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>
    WebHost.CreateDefaultBuilder(args)
        .UseStartup<Startup>()
        .ConfigureLogging(logging =>
        {
            logging.ClearProviders();
            logging.AddConsole();
        });
"><span><span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
{
    <span>var</span> host = CreateWebHostBuilder(args).Build();

    <span>var</span> todoRepository = host.Services.GetRequiredService&lt;ITodoRepository&gt;();
    todoRepository.Add(<span>new</span> Core.Model.TodoItem() { Name = <span>"Feed the dog"</span> });
    todoRepository.Add(<span>new</span> Core.Model.TodoItem() { Name = <span>"Walk the dog"</span> });
</span>
<mark>    <span>var</span> logger = host.Services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();</mark>
<mark>    logger.LogInformation(<span>"Seeded the database."</span>);</mark>
<span>
    host.Run();
}

<span><span>public</span> <span>static</span> IWebHostBuilder <span>CreateWebHostBuilder</span>(<span><span>string</span>[] args</span>)</span> =&gt;
    WebHost.CreateDefaultBuilder(args)
        .UseStartup&lt;Startup&gt;()
        .ConfigureLogging(logging =&gt;
        {
            logging.ClearProviders();
            logging.AddConsole();
        });
</span></code></pre>
<p>Logging during host construction isn't directly supported. However, a separate logger can be used. In the following example, a <a href="https://serilog.net/" data-linktype="external">Serilog</a> logger is used to log in <code>CreateWebHostBuilder</code>. <code>AddSerilog</code> uses the static configuration specified in <code>Log.Logger</code>:</p>
<pre tabindex="0"><code data-author-content="using System;
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

public class Program
{
    public static void Main(string[] args)
    {
        CreateWebHostBuilder(args).Build().Run();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args)
    {
        var builtConfig = new ConfigurationBuilder()
            .AddJsonFile(&quot;appsettings.json&quot;)
            .AddCommandLine(args)
            .Build();

        Log.Logger = new LoggerConfiguration()
            .WriteTo.Console()
            .WriteTo.File(builtConfig[&quot;Logging:FilePath&quot;])
            .CreateLogger();

        try
        {
            return WebHost.CreateDefaultBuilder(args)
                .ConfigureServices((context, services) =>
                {
                    services.AddMvc();
                })
                .ConfigureAppConfiguration((hostingContext, config) =>
                {
                    config.AddConfiguration(builtConfig);
                })
                .ConfigureLogging(logging =>
                {
                    logging.AddSerilog();
                })
                .UseStartup<Startup>();
        }
        catch (Exception ex)
        {
            Log.Fatal(ex, &quot;Host builder error&quot;);

            throw;
        }
        finally
        {
            Log.CloseAndFlush();
        }
    }
}
"><span><span>using</span> System;
<span>using</span> Microsoft.AspNetCore;
<span>using</span> Microsoft.AspNetCore.Hosting;
<span>using</span> Microsoft.Extensions.DependencyInjection;
<span>using</span> Microsoft.Extensions.Configuration;
<span>using</span> Microsoft.Extensions.Logging;

<span>public</span> <span>class</span> <span>Program</span>
{
    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
    {
        CreateWebHostBuilder(args).Build().Run();
    }

    <span><span>public</span> <span>static</span> IWebHostBuilder <span>CreateWebHostBuilder</span>(<span><span>string</span>[] args</span>)</span>
    {
        <span>var</span> builtConfig = <span>new</span> ConfigurationBuilder()
            .AddJsonFile(<span>"appsettings.json"</span>)
            .AddCommandLine(args)
            .Build();

        Log.Logger = <span>new</span> LoggerConfiguration()
            .WriteTo.Console()
            .WriteTo.File(builtConfig[<span>"Logging:FilePath"</span>])
            .CreateLogger();

        <span>try</span>
        {
            <span>return</span> WebHost.CreateDefaultBuilder(args)
                .ConfigureServices((context, services) =&gt;
                {
                    services.AddMvc();
                })
                .ConfigureAppConfiguration((hostingContext, config) =&gt;
                {
                    config.AddConfiguration(builtConfig);
                })
                .ConfigureLogging(logging =&gt;
                {
                    logging.AddSerilog();
                })
                .UseStartup&lt;Startup&gt;();
        }
        <span>catch</span> (Exception ex)
        {
            Log.Fatal(ex, <span>"Host builder error"</span>);

            <span>throw</span>;
        }
        <span>finally</span>
        {
            Log.CloseAndFlush();
        }
    }
}
</span></code></pre>
<h3 data-id="no-asynchronous-logger-methods-1">No asynchronous logger methods<a href="#no-asynchronous-logger-methods-1" aria-labelledby="no-asynchronous-logger-methods-1"></a></h3>
<p>Logging should be so fast that it isn't worth the performance cost of asynchronous code. If your logging data store is slow, don't write to it directly. Consider writing the log messages to a fast store initially, then move them to the slow store later. For example, if you're logging to SQL Server, you don't want to do that directly in a <code>Log</code> method, since the <code>Log</code> methods are synchronous. Instead, synchronously add log messages to an in-memory queue and have a background worker pull the messages out of the queue to do the asynchronous work of pushing data to SQL Server. For more information, see <a href="https://github.com/dotnet/AspNetCore.Docs/issues/11801" data-linktype="external">this</a> GitHub issue.</p>
<h2 data-id="configuration">Configuration<a href="#configuration" aria-labelledby="configuration"></a></h2>
<p>Logging provider configuration is provided by one or more configuration providers:</p>
<ul>
<li>File formats (INI, JSON, and XML).</li>
<li>Command-line arguments.</li>
<li>Environment variables.</li>
<li>In-memory .NET objects.</li>
<li>The unencrypted <a href="https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-3.0" data-linktype="relative-path">Secret Manager</a> storage.</li>
<li>An encrypted user store, such as <a href="https://docs.microsoft.com/en-us/aspnet/core/security/key-vault-configuration?view=aspnetcore-3.0" data-linktype="relative-path">Azure Key Vault</a>.</li>
<li>Custom providers (installed or created).</li>
</ul>
<p>For example, logging configuration is commonly provided by the <code>Logging</code> section of app settings files. The following example shows the contents of a typical <em>appsettings.Development.json</em> file:</p>
<pre tabindex="0"><code data-author-content="{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Debug&quot;,
      &quot;System&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Information&quot;
    },
    &quot;Console&quot;:
    {
      &quot;IncludeScopes&quot;: true
    }
  }
}
"><span>{
  <span>"Logging"</span>: {
    <span>"LogLevel"</span>: {
      <span>"Default"</span>: <span>"Debug"</span>,
      <span>"System"</span>: <span>"Information"</span>,
      <span>"Microsoft"</span>: <span>"Information"</span>
    },
    <span>"Console"</span>:
    {
      <span>"IncludeScopes"</span>: <span>true</span>
    }
  }
}
</span></code></pre>
<p>The <code>Logging</code> property can have <code>LogLevel</code> and log provider properties (Console is shown).</p>
<p>The <code>LogLevel</code> property under <code>Logging</code> specifies the minimum <a href="#log-level" data-linktype="self-bookmark">level</a> to log for selected categories. In the example, <code>System</code> and <code>Microsoft</code> categories log at <code>Information</code> level, and all others log at <code>Debug</code> level.</p>
<p>Other properties under <code>Logging</code> specify logging providers. The example is for the Console provider. If a provider supports <a href="#log-scopes" data-linktype="self-bookmark">log scopes</a>, <code>IncludeScopes</code> indicates whether they're enabled. A provider property (such as <code>Console</code> in the example) may also specify a <code>LogLevel</code> property. <code>LogLevel</code> under a provider specifies levels to log for that provider.</p>
<p>If levels are specified in <code>Logging.{providername}.LogLevel</code>, they override anything set in <code>Logging.LogLevel</code>. For example, consider the following JSON:</p>
<pre tabindex="0"><code data-author-content="{
  &quot;Logging&quot;: {      // Default, all providers.
    &quot;LogLevel&quot;: {
      &quot;Microsoft&quot;: &quot;Warning&quot;
    },
    &quot;Console&quot;: { // Console provider.
      &quot;LogLevel&quot;: {
        &quot;Microsoft&quot;: &quot;Information&quot;
      }
    }
  }
}
"><span>{
  <span>"Logging"</span>: {      // Default, all providers.
    <span>"LogLevel"</span>: {
      <span>"Microsoft"</span>: <span>"Warning"</span>
    },
    <span>"Console"</span>: { // Console provider.
      <span>"LogLevel"</span>: {
        <span>"Microsoft"</span>: <span>"Information"</span>
      }
    }
  }
}
</span></code></pre>
<p>In the preceding JSON, the <code>Console</code> provider settings overrides the preceding (default) log level.</p>
<p>The Logging API doesn't include a scenario to change log levels while an app is running. However, some configuration providers are capable of reloading configuration, which takes immediate effect on logging configuration. For example, the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.0#file-configuration-provider" data-linktype="relative-path">File Configuration Provider</a>, which is added by <code>CreateDefaultBuilder</code> to read settings files, reloads logging configuration by default. If configuration is changed in code while an app is running, the app can call <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfigurationroot.reload" data-linktype="absolute-path">IConfigurationRoot.Reload</a> to update the app's logging configuration.</p>
<p>For information on implementing configuration providers, see <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.0" data-linktype="relative-path">Configuration in ASP.NET Core</a>.</p>
<h2 data-id="sample-logging-output">Sample logging output<a href="#sample-logging-output" aria-labelledby="sample-logging-output"></a></h2>
<p>With the sample code shown in the preceding section, logs appear in the console when the app is run from the command line. Here's an example of console output:</p>
<pre tabindex="0"><code data-author-content="info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]
      Request starting HTTP/1.1 GET http://localhost:5000/api/todo/0
info: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[1]
      Executing action method TodoApi.Controllers.TodoController.GetById (TodoApi) with arguments (0) - ModelState is Valid
info: TodoApi.Controllers.TodoController[1002]
      Getting item 0
warn: TodoApi.Controllers.TodoController[4000]
      GetById(0) NOT FOUND
info: Microsoft.AspNetCore.Mvc.StatusCodeResult[1]
      Executing HttpStatusCodeResult, setting HTTP status code 404
info: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[2]
      Executed action TodoApi.Controllers.TodoController.GetById (TodoApi) in 42.9286ms
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]
      Request finished in 148.889ms 404
"><span>info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]
      Request starting HTTP/1.1 GET http://localhost:5000/api/todo/0
info: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[1]
      Executing action method TodoApi.Controllers.TodoController.GetById (TodoApi) with arguments (0) - ModelState is Valid
info: TodoApi.Controllers.TodoController[1002]
      Getting item 0
warn: TodoApi.Controllers.TodoController[4000]
      GetById(0) NOT FOUND
info: Microsoft.AspNetCore.Mvc.StatusCodeResult[1]
      Executing HttpStatusCodeResult, setting HTTP status code 404
info: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[2]
      Executed action TodoApi.Controllers.TodoController.GetById (TodoApi) in 42.9286ms
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]
      Request finished in 148.889ms 404
</span></code></pre>
<p>The preceding logs were generated by making an HTTP Get request to the sample app at <code>http://localhost:5000/api/todo/0</code>.</p>
<p>Here's an example of the same logs as they appear in the Debug window when you run the sample app in Visual Studio:</p>
<pre tabindex="0"><code data-author-content="Microsoft.AspNetCore.Hosting.Internal.WebHost:Information: Request starting HTTP/1.1 GET http://localhost:53104/api/todo/0  
Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker:Information: Executing action method TodoApi.Controllers.TodoController.GetById (TodoApi) with arguments (0) - ModelState is Valid
TodoApi.Controllers.TodoController:Information: Getting item 0
TodoApi.Controllers.TodoController:Warning: GetById(0) NOT FOUND
Microsoft.AspNetCore.Mvc.StatusCodeResult:Information: Executing HttpStatusCodeResult, setting HTTP status code 404
Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker:Information: Executed action TodoApi.Controllers.TodoController.GetById (TodoApi) in 152.5657ms
Microsoft.AspNetCore.Hosting.Internal.WebHost:Information: Request finished in 316.3195ms 404
"><span>Microsoft.AspNetCore.Hosting.Internal.WebHost:Information: Request starting HTTP/1.1 GET http://localhost:53104/api/todo/0  
Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker:Information: Executing action method TodoApi.Controllers.TodoController.GetById (TodoApi) with arguments (0) - ModelState is Valid
TodoApi.Controllers.TodoController:Information: Getting item 0
TodoApi.Controllers.TodoController:Warning: GetById(0) NOT FOUND
Microsoft.AspNetCore.Mvc.StatusCodeResult:Information: Executing HttpStatusCodeResult, setting HTTP status code 404
Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker:Information: Executed action TodoApi.Controllers.TodoController.GetById (TodoApi) in 152.5657ms
Microsoft.AspNetCore.Hosting.Internal.WebHost:Information: Request finished in 316.3195ms 404
</span></code></pre>
<p>The logs that are created by the <code>ILogger</code> calls shown in the preceding section begin with "TodoApi". The logs that begin with "Microsoft" categories are from ASP.NET Core framework code. ASP.NET Core and application code are using the same logging API and providers.</p>
<p>The remainder of this article explains some details and options for logging.</p>
<h2 data-id="nuget-packages">NuGet packages<a href="#nuget-packages" aria-labelledby="nuget-packages"></a></h2>
<p>The <code>ILogger</code> and <code>ILoggerFactory</code> interfaces are in <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.Abstractions/" data-linktype="external">Microsoft.Extensions.Logging.Abstractions</a>, and default implementations for them are in <a href="https://www.nuget.org/packages/microsoft.extensions.logging/" data-linktype="external">Microsoft.Extensions.Logging</a>.</p>
<h2 data-id="log-category-1">Log category<a href="#log-category-1" aria-labelledby="log-category-1"></a></h2>
<p>When an <code>ILogger</code> object is created, a <em>category</em> is specified for it. That category is included with each log message created by that instance of <code>ILogger</code>. The category may be any string, but the convention is to use the class name, such as "TodoApi.Controllers.TodoController".</p>
<p>Use <code>ILogger&lt;T&gt;</code> to get an <code>ILogger</code> instance that uses the fully qualified type name of <code>T</code> as the category:</p>
<pre tabindex="0"><code highlight-lines="7" data-author-content="public class TodoController : Controller
{
    private readonly ITodoRepository _todoRepository;
    private readonly ILogger _logger;

    public TodoController(ITodoRepository todoRepository,
        ILogger<TodoController> logger)
    {
        _todoRepository = todoRepository;
        _logger = logger;
    }
"><span><span>public</span> <span>class</span> <span>TodoController</span> : <span>Controller</span>
{
    <span>private</span> <span>readonly</span> ITodoRepository _todoRepository;
    <span>private</span> <span>readonly</span> ILogger _logger;

    <span><span>public</span> <span>TodoController</span>(<span>ITodoRepository todoRepository,</span></span></span>
<mark><span><span>        ILogger&lt;TodoController&gt; logger</span>)</span></mark>
<span><span></span>    {
        _todoRepository = todoRepository;
        _logger = logger;
    }
</span></code></pre>
<p>To explicitly specify the category, call <code>ILoggerFactory.CreateLogger</code>:</p>
<pre tabindex="0"><code highlight-lines="7,10" data-author-content="public class TodoController : Controller
{
    private readonly ITodoRepository _todoRepository;
    private readonly ILogger _logger;

    public TodoController(ITodoRepository todoRepository,
        ILoggerFactory logger)
    {
        _todoRepository = todoRepository;
        _logger = logger.CreateLogger(&quot;TodoApiSample.Controllers.TodoController&quot;);
    }
"><span><span>public</span> <span>class</span> <span>TodoController</span> : <span>Controller</span>
{
    <span>private</span> <span>readonly</span> ITodoRepository _todoRepository;
    <span>private</span> <span>readonly</span> ILogger _logger;

    <span><span>public</span> <span>TodoController</span>(<span>ITodoRepository todoRepository,</span></span></span>
<mark><span><span>        ILoggerFactory logger</span>)</span></mark>
<span><span></span>    {
        _todoRepository = todoRepository;</span>
<mark>        _logger = logger.CreateLogger(<span>"TodoApiSample.Controllers.TodoController"</span>);</mark>
<span>    }
</span></code></pre>
<p><code>ILogger&lt;T&gt;</code> is equivalent to calling <code>CreateLogger</code> with the fully qualified type name of <code>T</code>.</p>
<h2 data-id="log-level-1">Log level<a href="#log-level-1" aria-labelledby="log-level-1"></a></h2>
<p>Every log specifies a <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel" data-linktype="absolute-path">LogLevel</a> value. The log level indicates the severity or importance. For example, you might write an <code>Information</code> log when a method ends normally and a <code>Warning</code> log when a method returns a <em>404 Not Found</em> status code.</p>
<p>The following code creates <code>Information</code> and <code>Warning</code> logs:</p>
<pre tabindex="0"><code highlight-lines="3,7" data-author-content="public IActionResult GetById(string id)
{
    _logger.LogInformation(LoggingEvents.GetItem, &quot;Getting item {Id}&quot;, id);
    var item = _todoRepository.Find(id);
    if (item == null)
    {
        _logger.LogWarning(LoggingEvents.GetItemNotFound, &quot;GetById({Id}) NOT FOUND&quot;, id);
        return NotFound();
    }
    return new ObjectResult(item);
}
"><span><span><span>public</span> IActionResult <span>GetById</span>(<span><span>string</span> id</span>)</span>
{</span>
<mark>    _logger.LogInformation(LoggingEvents.GetItem, <span>"Getting item {Id}"</span>, id);</mark>
<span>    <span>var</span> item = _todoRepository.Find(id);
    <span>if</span> (item == <span>null</span>)
    {</span>
<mark>        _logger.LogWarning(LoggingEvents.GetItemNotFound, <span>"GetById({Id}) NOT FOUND"</span>, id);</mark>
<span>        <span>return</span> NotFound();
    }
    <span>return</span> <span>new</span> ObjectResult(item);
}
</span></code></pre>
<p>In the preceding code, the <code>MyLogEvents.GetItem</code> and <code>MyLogEvents.GetItemNotFound</code> parameters are the <a href="#log-event-id" data-linktype="self-bookmark">Log event ID</a>. The second parameter is a message template with placeholders for argument values provided by the remaining method parameters. The method parameters are explained in the <a href="#lmt" data-linktype="self-bookmark">Log message template section</a> in this article.</p>
<p>Log methods that include the level in the method name (for example, <code>LogInformation</code> and <code>LogWarning</code>) are <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions" data-linktype="absolute-path">extension methods for ILogger</a>. These methods call a <code>Log</code> method that takes a <code>LogLevel</code> parameter. You can call the <code>Log</code> method directly rather than one of these extension methods, but the syntax is relatively complicated. For more information, see <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger" data-linktype="absolute-path">ILogger</a> and the <a href="https://github.com/dotnet/extensions/blob/release/2.2/src/Logging/Logging.Abstractions/src/LoggerExtensions.cs" data-linktype="external">logger extensions source code</a>.</p>
<p>ASP.NET Core defines the following log levels, ordered here from lowest to highest severity.</p>
<ul>
<li><p>Trace = 0</p>
<p>For information that's typically valuable only for debugging. These messages may contain sensitive application data and so shouldn't be enabled in a production environment. <em>Disabled by default.</em></p>
</li>
<li><p>Debug = 1</p>
<p>For information that may be useful in development and debugging. Example: <code>Entering method Configure with flag set to true.</code> Enable <code>Debug</code> level logs in production only when troubleshooting, due to the high volume of logs.</p>
</li>
<li><p>Information = 2</p>
<p>For tracking the general flow of the app. These logs typically have some long-term value. Example: <code>Request received for path /api/todo</code></p>
</li>
<li><p>Warning = 3</p>
<p>For abnormal or unexpected events in the app flow. These may include errors or other conditions that don't cause the app to stop but might need to be investigated. Handled exceptions are a common place to use the <code>Warning</code> log level. Example: <code>FileNotFoundException for file quotes.txt.</code></p>
</li>
<li><p>Error = 4</p>
<p>For errors and exceptions that cannot be handled. These messages indicate a failure in the current activity or operation (such as the current HTTP request), not an app-wide failure. Example log message: <code>Cannot insert record due to duplicate key violation.</code></p>
</li>
<li><p>Critical = 5</p>
<p>For failures that require immediate attention. Examples: data loss scenarios, out of disk space.</p>
</li>
</ul>
<p>Use the log level to control how much log output is written to a particular storage medium or display window. For example:</p>
<ul>
<li>In production:
<ul>
<li>Logging at the <code>Trace</code> through <code>Information</code> levels produces a high-volume of detailed log messages. To control costs and not exceed data storage limits, log <code>Trace</code> through <code>Information</code> level messages to a high-volume, low-cost data store.</li>
<li>Logging at <code>Warning</code> through <code>Critical</code> levels typically produces fewer, smaller log messages. Therefore, costs and storage limits usually aren't a concern, which results in greater flexibility of data store choice.</li>
</ul>
</li>
<li>During development:
<ul>
<li>Log <code>Warning</code> through <code>Critical</code> messages to the console.</li>
<li>Add <code>Trace</code> through <code>Information</code> messages when troubleshooting.</li>
</ul>
</li>
</ul>
<p>The <a href="#log-filtering" data-linktype="self-bookmark">Log filtering</a> section later in this article explains how to control which log levels a provider handles.</p>
<p>ASP.NET Core writes logs for framework events. The log examples earlier in this article excluded logs below <code>Information</code> level, so no <code>Debug</code> or <code>Trace</code> level logs were created. Here's an example of console logs produced by running the sample app configured to show <code>Debug</code> logs:</p>
<pre tabindex="0"><code data-author-content="info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]
      Request starting HTTP/1.1 GET http://localhost:62555/api/todo/0
dbug: Microsoft.AspNetCore.Routing.Tree.TreeRouter[1]
      Request successfully matched the route with name 'GetTodo' and template 'api/Todo/{id}'.
dbug: Microsoft.AspNetCore.Mvc.Internal.ActionSelector[2]
      Action 'TodoApi.Controllers.TodoController.Update (TodoApi)' with id '089d59b6-92ec-472d-b552-cc613dfd625d' did not match the constraint 'Microsoft.AspNetCore.Mvc.Internal.HttpMethodActionConstraint'
dbug: Microsoft.AspNetCore.Mvc.Internal.ActionSelector[2]
      Action 'TodoApi.Controllers.TodoController.Delete (TodoApi)' with id 'f3476abe-4bd9-4ad3-9261-3ead09607366' did not match the constraint 'Microsoft.AspNetCore.Mvc.Internal.HttpMethodActionConstraint'
dbug: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[1]
      Executing action TodoApi.Controllers.TodoController.GetById (TodoApi)
info: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[1]
      Executing action method TodoApi.Controllers.TodoController.GetById (TodoApi) with arguments (0) - ModelState is Valid
info: TodoApi.Controllers.TodoController[1002]
      Getting item 0
warn: TodoApi.Controllers.TodoController[4000]
      GetById(0) NOT FOUND
dbug: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[2]
      Executed action method TodoApi.Controllers.TodoController.GetById (TodoApi), returned result Microsoft.AspNetCore.Mvc.NotFoundResult.
info: Microsoft.AspNetCore.Mvc.StatusCodeResult[1]
      Executing HttpStatusCodeResult, setting HTTP status code 404
info: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[2]
      Executed action TodoApi.Controllers.TodoController.GetById (TodoApi) in 0.8788ms
dbug: Microsoft.AspNetCore.Server.Kestrel[9]
      Connection id &quot;0HL6L7NEFF2QD&quot; completed keep alive response.
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]
      Request finished in 2.7286ms 404
"><span>info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]
      Request starting HTTP/1.1 GET http://localhost:62555/api/todo/0
dbug: Microsoft.AspNetCore.Routing.Tree.TreeRouter[1]
      Request successfully matched the route with name 'GetTodo' and template 'api/Todo/{id}'.
dbug: Microsoft.AspNetCore.Mvc.Internal.ActionSelector[2]
      Action 'TodoApi.Controllers.TodoController.Update (TodoApi)' with id '089d59b6-92ec-472d-b552-cc613dfd625d' did not match the constraint 'Microsoft.AspNetCore.Mvc.Internal.HttpMethodActionConstraint'
dbug: Microsoft.AspNetCore.Mvc.Internal.ActionSelector[2]
      Action 'TodoApi.Controllers.TodoController.Delete (TodoApi)' with id 'f3476abe-4bd9-4ad3-9261-3ead09607366' did not match the constraint 'Microsoft.AspNetCore.Mvc.Internal.HttpMethodActionConstraint'
dbug: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[1]
      Executing action TodoApi.Controllers.TodoController.GetById (TodoApi)
info: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[1]
      Executing action method TodoApi.Controllers.TodoController.GetById (TodoApi) with arguments (0) - ModelState is Valid
info: TodoApi.Controllers.TodoController[1002]
      Getting item 0
warn: TodoApi.Controllers.TodoController[4000]
      GetById(0) NOT FOUND
dbug: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[2]
      Executed action method TodoApi.Controllers.TodoController.GetById (TodoApi), returned result Microsoft.AspNetCore.Mvc.NotFoundResult.
info: Microsoft.AspNetCore.Mvc.StatusCodeResult[1]
      Executing HttpStatusCodeResult, setting HTTP status code 404
info: Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker[2]
      Executed action TodoApi.Controllers.TodoController.GetById (TodoApi) in 0.8788ms
dbug: Microsoft.AspNetCore.Server.Kestrel[9]
      Connection id "0HL6L7NEFF2QD" completed keep alive response.
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]
      Request finished in 2.7286ms 404
</span></code></pre>
<h2 data-id="log-event-id-1">Log event ID<a href="#log-event-id-1" aria-labelledby="log-event-id-1"></a></h2>
<p>Each log can specify an <em>event ID</em>. The sample app does this by using a locally defined <code>LoggingEvents</code> class:</p>
<pre tabindex="0"><code highlight-lines="3,7" data-author-content="public IActionResult GetById(string id)
{
    _logger.LogInformation(LoggingEvents.GetItem, &quot;Getting item {Id}&quot;, id);
    var item = _todoRepository.Find(id);
    if (item == null)
    {
        _logger.LogWarning(LoggingEvents.GetItemNotFound, &quot;GetById({Id}) NOT FOUND&quot;, id);
        return NotFound();
    }
    return new ObjectResult(item);
}
"><span><span><span>public</span> IActionResult <span>GetById</span>(<span><span>string</span> id</span>)</span>
{</span>
<mark>    _logger.LogInformation(LoggingEvents.GetItem, <span>"Getting item {Id}"</span>, id);</mark>
<span>    <span>var</span> item = _todoRepository.Find(id);
    <span>if</span> (item == <span>null</span>)
    {</span>
<mark>        _logger.LogWarning(LoggingEvents.GetItemNotFound, <span>"GetById({Id}) NOT FOUND"</span>, id);</mark>
<span>        <span>return</span> NotFound();
    }
    <span>return</span> <span>new</span> ObjectResult(item);
}
</span></code></pre><pre tabindex="0"><code data-author-content="public class LoggingEvents
{
    public const int GenerateItems = 1000;
    public const int ListItems = 1001;
    public const int GetItem = 1002;
    public const int InsertItem = 1003;
    public const int UpdateItem = 1004;
    public const int DeleteItem = 1005;

    public const int GetItemNotFound = 4000;
    public const int UpdateItemNotFound = 4001;
}
"><span><span>public</span> <span>class</span> <span>LoggingEvents</span>
{
    <span>public</span> <span>const</span> <span>int</span> GenerateItems = <span>1000</span>;
    <span>public</span> <span>const</span> <span>int</span> ListItems = <span>1001</span>;
    <span>public</span> <span>const</span> <span>int</span> GetItem = <span>1002</span>;
    <span>public</span> <span>const</span> <span>int</span> InsertItem = <span>1003</span>;
    <span>public</span> <span>const</span> <span>int</span> UpdateItem = <span>1004</span>;
    <span>public</span> <span>const</span> <span>int</span> DeleteItem = <span>1005</span>;

    <span>public</span> <span>const</span> <span>int</span> GetItemNotFound = <span>4000</span>;
    <span>public</span> <span>const</span> <span>int</span> UpdateItemNotFound = <span>4001</span>;
}
</span></code></pre>
<p>An event ID associates a set of events. For example, all logs related to displaying a list of items on a page might be 1001.</p>
<p>The logging provider may store the event ID in an ID field, in the logging message, or not at all. The Debug provider doesn't show event IDs. The console provider shows event IDs in brackets after the category:</p>
<pre tabindex="0"><code data-author-content="info: TodoApi.Controllers.TodoController[1002]
      Getting item invalidid
warn: TodoApi.Controllers.TodoController[4000]
      GetById(invalidid) NOT FOUND
"><span>info: TodoApi.Controllers.TodoController[1002]
      Getting item invalidid
warn: TodoApi.Controllers.TodoController[4000]
      GetById(invalidid) NOT FOUND
</span></code></pre>
<h2 data-id="log-message-template-1">Log message template<a href="#log-message-template-1" aria-labelledby="log-message-template-1"></a></h2>
<p>Each log specifies a message template. The message template can contain placeholders for which arguments are provided. Use names for the placeholders, not numbers.</p>
<pre tabindex="0"><code highlight-lines="3,7" data-author-content="public IActionResult GetById(string id)
{
    _logger.LogInformation(LoggingEvents.GetItem, &quot;Getting item {Id}&quot;, id);
    var item = _todoRepository.Find(id);
    if (item == null)
    {
        _logger.LogWarning(LoggingEvents.GetItemNotFound, &quot;GetById({Id}) NOT FOUND&quot;, id);
        return NotFound();
    }
    return new ObjectResult(item);
}
"><span><span><span>public</span> IActionResult <span>GetById</span>(<span><span>string</span> id</span>)</span>
{</span>
<mark>    _logger.LogInformation(LoggingEvents.GetItem, <span>"Getting item {Id}"</span>, id);</mark>
<span>    <span>var</span> item = _todoRepository.Find(id);
    <span>if</span> (item == <span>null</span>)
    {</span>
<mark>        _logger.LogWarning(LoggingEvents.GetItemNotFound, <span>"GetById({Id}) NOT FOUND"</span>, id);</mark>
<span>        <span>return</span> NotFound();
    }
    <span>return</span> <span>new</span> ObjectResult(item);
}
</span></code></pre>
<p>The order of placeholders, not their names, determines which parameters are used to provide their values. In the following code, notice that the parameter names are out of sequence in the message template:</p>
<pre tabindex="0"><code data-author-content="string p1 = &quot;parm1&quot;;
string p2 = &quot;parm2&quot;;
_logger.LogInformation(&quot;Parameter values: {p2}, {p1}&quot;, p1, p2);
"><span><span>string</span> p1 = <span>"parm1"</span>;
<span>string</span> p2 = <span>"parm2"</span>;
_logger.LogInformation(<span>"Parameter values: {p2}, {p1}"</span>, p1, p2);
</span></code></pre>
<p>This code creates a log message with the parameter values in sequence:</p>
<pre tabindex="0"><code data-author-content="Parameter values: parm1, parm2
">Parameter values: parm1, parm2
</code></pre>
<p>The logging framework works this way so that logging providers can implement <a href="https://softwareengineering.stackexchange.com/questions/312197/benefits-of-structured-logging-vs-basic-logging" data-linktype="external">semantic logging, also known as structured logging</a>. The arguments themselves are passed to the logging system, not just the formatted message template. This information enables logging providers to store the parameter values as fields. For example, suppose logger method calls look like this:</p>
<pre tabindex="0"><code data-author-content="_logger.LogInformation(&quot;Getting item {Id} at {RequestTime}&quot;, id, DateTime.Now);
"><span>_logger.LogInformation(<span>"Getting item {Id} at {RequestTime}"</span>, id, DateTime.Now);
</span></code></pre>
<p>If you're sending the logs to Azure Table Storage, each Azure Table entity can have <code>ID</code> and <code>RequestTime</code> properties, which simplifies queries on log data. A query can find all logs within a particular <code>RequestTime</code> range without parsing the time out of the text message.</p>
<h2 data-id="logging-exceptions">Logging exceptions<a href="#logging-exceptions" aria-labelledby="logging-exceptions"></a></h2>
<p>The logger methods have overloads that let you pass in an exception, as in the following example:</p>
<pre tabindex="0"><code highlight-lines="3" data-author-content="catch (Exception ex)
{
    _logger.LogWarning(LoggingEvents.GetItemNotFound, ex, &quot;GetById({Id}) NOT FOUND&quot;, id);
    return NotFound();
}
return new ObjectResult(item);
"><span><span>catch</span> (Exception ex)
{</span>
<mark>    _logger.LogWarning(LoggingEvents.GetItemNotFound, ex, <span>"GetById({Id}) NOT FOUND"</span>, id);</mark>
<span>    <span>return</span> NotFound();
}
<span>return</span> <span>new</span> ObjectResult(item);
</span></code></pre>
<p>Different providers handle the exception information in different ways. Here's an example of Debug provider output from the code shown above.</p>
<pre tabindex="0"><code data-author-content="TodoApiSample.Controllers.TodoController: Warning: GetById(55) NOT FOUND

System.Exception: Item not found exception.
   at TodoApiSample.Controllers.TodoController.GetById(String id) in C:\TodoApiSample\Controllers\TodoController.cs:line 226
">TodoApiSample.Controllers.TodoController: Warning: GetById(55) NOT FOUND

System.Exception: Item not found exception.
   at TodoApiSample.Controllers.TodoController.GetById(String id) in C:\TodoApiSample\Controllers\TodoController.cs:line 226
</code></pre>
<h2 data-id="log-filtering">Log filtering<a href="#log-filtering" aria-labelledby="log-filtering"></a></h2>
<p>You can specify a minimum log level for a specific provider and category or for all providers or all categories. Any logs below the minimum level aren't passed to that provider, so they don't get displayed or stored.</p>
<p>To suppress all logs, specify <code>LogLevel.None</code> as the minimum log level. The integer value of <code>LogLevel.None</code> is 6, which is higher than <code>LogLevel.Critical</code> (5).</p>
<h3 data-id="create-filter-rules-in-configuration">Create filter rules in configuration<a href="#create-filter-rules-in-configuration" aria-labelledby="create-filter-rules-in-configuration"></a></h3>
<p>The project template code calls <code>CreateDefaultBuilder</code> to set up logging for the Console, Debug, and EventSource (ASP.NET Core 2.2 or later) providers. The <code>CreateDefaultBuilder</code> method sets up logging to look for configuration in a <code>Logging</code> section, as explained <a href="#configuration" data-linktype="self-bookmark">earlier in this article</a>.</p>
<p>The configuration data specifies minimum log levels by provider and category, as in the following example:</p>
<pre tabindex="0"><code data-author-content="{
  &quot;Logging&quot;: {
    &quot;Debug&quot;: {
      &quot;LogLevel&quot;: {
        &quot;Default&quot;: &quot;Information&quot;
      }
    },
    &quot;Console&quot;: {
      &quot;IncludeScopes&quot;: false,
      &quot;LogLevel&quot;: {
        &quot;Microsoft.AspNetCore.Mvc.Razor.Internal&quot;: &quot;Warning&quot;,
        &quot;Microsoft.AspNetCore.Mvc.Razor.Razor&quot;: &quot;Debug&quot;,
        &quot;Microsoft.AspNetCore.Mvc.Razor&quot;: &quot;Error&quot;,
        &quot;Default&quot;: &quot;Information&quot;
      }
    },
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Debug&quot;
    }
  }
}
"><span>{
  <span>"Logging"</span>: {
    <span>"Debug"</span>: {
      <span>"LogLevel"</span>: {
        <span>"Default"</span>: <span>"Information"</span>
      }
    },
    <span>"Console"</span>: {
      <span>"IncludeScopes"</span>: <span>false</span>,
      <span>"LogLevel"</span>: {
        <span>"Microsoft.AspNetCore.Mvc.Razor.Internal"</span>: <span>"Warning"</span>,
        <span>"Microsoft.AspNetCore.Mvc.Razor.Razor"</span>: <span>"Debug"</span>,
        <span>"Microsoft.AspNetCore.Mvc.Razor"</span>: <span>"Error"</span>,
        <span>"Default"</span>: <span>"Information"</span>
      }
    },
    <span>"LogLevel"</span>: {
      <span>"Default"</span>: <span>"Debug"</span>
    }
  }
}
</span></code></pre>
<p>This JSON creates six filter rules: one for the Debug provider, four for the Console provider, and one for all providers. A single rule is chosen for each provider when an <code>ILogger</code> object is created.</p>
<h3 data-id="filter-rules-in-code">Filter rules in code<a href="#filter-rules-in-code" aria-labelledby="filter-rules-in-code"></a></h3>
<p>The following example shows how to register filter rules in code:</p>
<pre tabindex="0"><code highlight-lines="4-5" data-author-content="WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .ConfigureLogging(logging =>
        logging.AddFilter(&quot;System&quot;, LogLevel.Debug)
               .AddFilter<DebugLoggerProvider>(&quot;Microsoft&quot;, LogLevel.Trace));
"><span>WebHost.CreateDefaultBuilder(args)
    .UseStartup&lt;Startup&gt;()
    .ConfigureLogging(logging =&gt;</span>
<mark>        logging.AddFilter(<span>"System"</span>, LogLevel.Debug)
               .AddFilter&lt;DebugLoggerProvider&gt;(<span>"Microsoft"</span>, LogLevel.Trace));</mark>
<span></span></code></pre>
<p>The second <code>AddFilter</code> specifies the Debug provider by using its type name. The first <code>AddFilter</code> applies to all providers because it doesn't specify a provider type.</p>
<h3 data-id="how-filtering-rules-are-applied-1">How filtering rules are applied<a href="#how-filtering-rules-are-applied-1" aria-labelledby="how-filtering-rules-are-applied-1"></a></h3>
<p>The configuration data and the <code>AddFilter</code> code shown in the preceding examples create the rules shown in the following table. The first six come from the configuration example and the last two come from the code example.</p>

<p>When an <code>ILogger</code> object is created, the <code>ILoggerFactory</code> object selects a single rule per provider to apply to that logger. All messages written by an <code>ILogger</code> instance are filtered based on the selected rules. The most specific rule possible for each provider and category pair is selected from the available rules.</p>
<p>The following algorithm is used for each provider when an <code>ILogger</code> is created for a given category:</p>
<ul>
<li>Select all rules that match the provider or its alias. If no match is found, select all rules with an empty provider.</li>
<li>From the result of the preceding step, select rules with longest matching category prefix. If no match is found, select all rules that don't specify a category.</li>
<li>If multiple rules are selected, take the <strong>last</strong> one.</li>
<li>If no rules are selected, use <code>MinimumLevel</code>.</li>
</ul>
<p>With the preceding list of rules, suppose you create an <code>ILogger</code> object for category "Microsoft.AspNetCore.Mvc.Razor.RazorViewEngine":</p>
<ul>
<li>For the Debug provider, rules 1, 6, and 8 apply. Rule 8 is most specific, so that's the one selected.</li>
<li>For the Console provider, rules 3, 4, 5, and 6 apply. Rule 3 is most specific.</li>
</ul>
<p>The resulting <code>ILogger</code> instance sends logs of <code>Trace</code> level and above to the Debug provider. Logs of <code>Debug</code> level and above are sent to the Console provider.</p>
<h3 data-id="provider-aliases">Provider aliases<a href="#provider-aliases" aria-labelledby="provider-aliases"></a></h3>
<p>Each provider defines an <em>alias</em> that can be used in configuration in place of the fully qualified type name.  For the built-in providers, use the following aliases:</p>
<ul>
<li>Console</li>
<li>Debug</li>
<li>EventSource</li>
<li>EventLog</li>
<li>TraceSource</li>
<li>AzureAppServicesFile</li>
<li>AzureAppServicesBlob</li>
<li>ApplicationInsights</li>
</ul>
<h3 data-id="default-minimum-level">Default minimum level<a href="#default-minimum-level" aria-labelledby="default-minimum-level"></a></h3>
<p>There's a minimum level setting that takes effect only if no rules from configuration or code apply for a given provider and category. The following example shows how to set the minimum level:</p>
<pre tabindex="0"><code highlight-lines="3" data-author-content="WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .ConfigureLogging(logging => logging.SetMinimumLevel(LogLevel.Warning));
"><span>WebHost.CreateDefaultBuilder(args)
    .UseStartup&lt;Startup&gt;()</span>
<mark>    .ConfigureLogging(logging =&gt; logging.SetMinimumLevel(LogLevel.Warning));</mark>
<span></span></code></pre>
<p>If you don't explicitly set the minimum level, the default value is <code>Information</code>, which means that <code>Trace</code> and <code>Debug</code> logs are ignored.</p>
<h3 data-id="filter-functions">Filter functions<a href="#filter-functions" aria-labelledby="filter-functions"></a></h3>
<p>A filter function is invoked for all providers and categories that don't have rules assigned to them by configuration or code. Code in the function has access to the provider type, category, and log level. For example:</p>
<pre tabindex="0"><code highlight-lines="5-13" data-author-content="WebHost.CreateDefaultBuilder(args)
    .UseStartup<Startup>()
    .ConfigureLogging(logBuilder =>
    {
        logBuilder.AddFilter((provider, category, logLevel) =>
        {
            if (provider == &quot;Microsoft.Extensions.Logging.Console.ConsoleLoggerProvider&quot; &amp;&amp;
                category == &quot;TodoApiSample.Controllers.TodoController&quot;)
            {
                return false;
            }
            return true;
        });
    });
"><span>WebHost.CreateDefaultBuilder(args)
    .UseStartup&lt;Startup&gt;()
    .ConfigureLogging(logBuilder =&gt;
    {</span>
<mark>        logBuilder.AddFilter((provider, category, logLevel) =&gt;
        {
            <span>if</span> (provider == <span>"Microsoft.Extensions.Logging.Console.ConsoleLoggerProvider"</span> &amp;&amp;
                category == <span>"TodoApiSample.Controllers.TodoController"</span>)
            {
                <span>return</span> <span>false</span>;
            }
            <span>return</span> <span>true</span>;
        });</mark>
<span>    });
</span></code></pre><h2 data-id="system-categories-and-levels">System categories and levels<a href="#system-categories-and-levels" aria-labelledby="system-categories-and-levels"></a></h2>
<p>Here are some categories used by ASP.NET Core and Entity Framework Core, with notes about what logs to expect from them:</p>

<h2 data-id="log-scopes-1">Log scopes<a href="#log-scopes-1" aria-labelledby="log-scopes-1"></a></h2>
<p>A <em>scope</em> can group a set of logical operations. This grouping can be used to attach the same data to each log that's created as part of a set. For example, every log created as part of processing a transaction can include the transaction ID.</p>
<p>A scope is an <code>IDisposable</code> type that's returned by the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger.beginscope" data-linktype="absolute-path">BeginScope</a> method and lasts until it's disposed. Use a scope by wrapping logger calls in a <code>using</code> block:</p>
<pre tabindex="0"><code highlight-lines="4-5,13" data-author-content="public IActionResult GetById(string id)
{
    TodoItem item;
    using (_logger.BeginScope(&quot;Message attached to logs created in the using block&quot;))
    {
        _logger.LogInformation(LoggingEvents.GetItem, &quot;Getting item {Id}&quot;, id);
        item = _todoRepository.Find(id);
        if (item == null)
        {
            _logger.LogWarning(LoggingEvents.GetItemNotFound, &quot;GetById({Id}) NOT FOUND&quot;, id);
            return NotFound();
        }
    }
    return new ObjectResult(item);
}
"><span><span><span>public</span> IActionResult <span>GetById</span>(<span><span>string</span> id</span>)</span>
{
    TodoItem item;</span>
<mark>    <span>using</span> (_logger.BeginScope(<span>"Message attached to logs created in the using block"</span>))
    {</mark>
<span>        _logger.LogInformation(LoggingEvents.GetItem, <span>"Getting item {Id}"</span>, id);
        item = _todoRepository.Find(id);
        <span>if</span> (item == <span>null</span>)
        {
            _logger.LogWarning(LoggingEvents.GetItemNotFound, <span>"GetById({Id}) NOT FOUND"</span>, id);
            <span>return</span> NotFound();
        }</span>
<mark>    }</mark>
<span>    <span>return</span> <span>new</span> ObjectResult(item);
}
</span></code></pre>
<p>The following code enables scopes for the console provider:</p>
<p><em>Program.cs</em>:</p>
<pre tabindex="0"><code highlight-lines="4" data-author-content=".ConfigureLogging((hostingContext, logging) =>
{
    logging.AddConfiguration(hostingContext.Configuration.GetSection(&quot;Logging&quot;));
    logging.AddConsole(options => options.IncludeScopes = true);
    logging.AddDebug();
})
"><span>.ConfigureLogging((hostingContext, logging) =&gt;
{
    logging.AddConfiguration(hostingContext.Configuration.GetSection(<span>"Logging"</span>));</span>
<mark>    logging.AddConsole(options =&gt; options.IncludeScopes = <span>true</span>);</mark>
<span>    logging.AddDebug();
})
</span></code></pre>
<div>
<p><span aria-hidden="true"></span> Note</p>
<p>Configuring the <code>IncludeScopes</code> console logger option is required to enable scope-based logging.</p>
<p>For information on configuration, see the <a href="#configuration" data-linktype="self-bookmark">Configuration</a> section.</p>
</div>
<p>Each log message includes the scoped information:</p>
<pre tabindex="0"><code data-author-content="info: TodoApiSample.Controllers.TodoController[1002]
      => RequestId:0HKV9C49II9CK RequestPath:/api/todo/0 => TodoApiSample.Controllers.TodoController.GetById (TodoApi) => Message attached to logs created in the using block
      Getting item 0
warn: TodoApiSample.Controllers.TodoController[4000]
      => RequestId:0HKV9C49II9CK RequestPath:/api/todo/0 => TodoApiSample.Controllers.TodoController.GetById (TodoApi) => Message attached to logs created in the using block
      GetById(0) NOT FOUND
">info: TodoApiSample.Controllers.TodoController[1002]
      =&gt; RequestId:0HKV9C49II9CK RequestPath:/api/todo/0 =&gt; TodoApiSample.Controllers.TodoController.GetById (TodoApi) =&gt; Message attached to logs created in the using block
      Getting item 0
warn: TodoApiSample.Controllers.TodoController[4000]
      =&gt; RequestId:0HKV9C49II9CK RequestPath:/api/todo/0 =&gt; TodoApiSample.Controllers.TodoController.GetById (TodoApi) =&gt; Message attached to logs created in the using block
      GetById(0) NOT FOUND
</code></pre>
<h2 data-id="built-in-logging-providers-1">Built-in logging providers<a href="#built-in-logging-providers-1" aria-labelledby="built-in-logging-providers-1"></a></h2>
<p>ASP.NET Core ships the following providers:</p>
<ul>
<li><a href="#console-provider" data-linktype="self-bookmark">Console</a></li>
<li><a href="#debug-provider" data-linktype="self-bookmark">Debug</a></li>
<li><a href="#event-source-provider" data-linktype="self-bookmark">EventSource</a></li>
<li><a href="#windows-eventlog-provider" data-linktype="self-bookmark">EventLog</a></li>
<li><a href="#tracesource-provider" data-linktype="self-bookmark">TraceSource</a></li>
<li><a href="#azure-app-service-provider" data-linktype="self-bookmark">AzureAppServicesFile</a></li>
<li><a href="#azure-app-service-provider" data-linktype="self-bookmark">AzureAppServicesBlob</a></li>
<li><a href="#azure-application-insights-trace-logging" data-linktype="self-bookmark">ApplicationInsights</a></li>
</ul>
<p>For information on stdout and debug logging with the ASP.NET Core Module, see <a href="https://docs.microsoft.com/en-us/aspnet/core/test/troubleshoot-azure-iis?view=aspnetcore-3.0" data-linktype="relative-path">Troubleshoot ASP.NET Core on Azure App Service and IIS</a> and <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/aspnet-core-module?view=aspnetcore-3.0#log-creation-and-redirection" data-linktype="relative-path">ASP.NET Core Module</a>.</p>
<h3 data-id="console-provider">Console provider<a href="#console-provider" aria-labelledby="console-provider"></a></h3>
<p>The <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.Console" data-linktype="external">Microsoft.Extensions.Logging.Console</a> provider package sends log output to the console.</p>
<pre tabindex="0"><code data-author-content="logging.AddConsole();
"><span>logging.AddConsole();
</span></code></pre>
<p>To see console logging output, open a command prompt in the project folder and run the following command:</p>
<pre tabindex="0"><code data-author-content="dotnet run
"><span><span>dotnet</span> <span>run</span>
</span></code></pre>
<h3 data-id="debug-provider">Debug provider<a href="#debug-provider" aria-labelledby="debug-provider"></a></h3>
<p>The <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.Debug" data-linktype="external">Microsoft.Extensions.Logging.Debug</a> provider package writes log output by using the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debug" data-linktype="absolute-path">System.Diagnostics.Debug</a> class (<code>Debug.WriteLine</code> method calls).</p>
<p>On Linux, this provider writes logs to <em>/var/log/message</em>.</p>
<pre tabindex="0"><code data-author-content="logging.AddDebug();
"><span>logging.AddDebug();
</span></code></pre>
<h3 data-id="event-source-provider">Event Source provider<a href="#event-source-provider" aria-labelledby="event-source-provider"></a></h3>
<p>The <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.EventSource" data-linktype="external">Microsoft.Extensions.Logging.EventSource</a> provider package writes to an Event Source cross-platform with the name <code>Microsoft-Extensions-Logging</code>. On Windows, the provider uses <a href="https://msdn.microsoft.com/library/windows/desktop/bb968803" data-linktype="external">ETW</a>.</p>
<pre tabindex="0"><code data-author-content="logging.AddEventSourceLogger();
"><span>logging.AddEventSourceLogger();
</span></code></pre>
<p>The Event Source provider is added automatically when <code>CreateDefaultBuilder</code> is called to build the host.</p>
<p>Use the <a href="https://github.com/Microsoft/perfview" data-linktype="external">PerfView utility</a> to collect and view logs. There are other tools for viewing ETW logs, but PerfView provides the best experience for working with the ETW events emitted by ASP.NET Core.</p>
<p>To configure PerfView for collecting events logged by this provider, add the string <code>*Microsoft-Extensions-Logging</code> to the <strong>Additional Providers</strong> list. (Don't miss the asterisk at the start of the string.)</p>
<p><img src="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/index/_static/perfview-additional-providers.png?view=aspnetcore-3.0" alt="Perfview Additional Providers" data-linktype="relative-path"></p>
<h3 data-id="windows-eventlog-provider">Windows EventLog provider<a href="#windows-eventlog-provider" aria-labelledby="windows-eventlog-provider"></a></h3>
<p>The <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.EventLog" data-linktype="external">Microsoft.Extensions.Logging.EventLog</a> provider package sends log output to the Windows Event Log.</p>
<pre tabindex="0"><code data-author-content="logging.AddEventLog();
"><span>logging.AddEventLog();
</span></code></pre>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.eventloggerfactoryextensions" data-linktype="absolute-path">AddEventLog overloads</a> let you pass in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.eventlog.eventlogsettings" data-linktype="absolute-path">EventLogSettings</a>. If <code>null</code> or not specified, the following default settings are used:</p>
<ul>
<li><code>LogName</code> – "Application"</li>
<li><code>SourceName</code> – ".NET Runtime"</li>
<li><code>MachineName</code> – local machine</li>
</ul>
<p>Events are logged for <a href="#log-level" data-linktype="self-bookmark">Warning level and higher</a>. To log events lower than <code>Warning</code>, explicitly set the log level. For example, add the following to the <em>appsettings.json</em> file:</p>
<pre tabindex="0"><code data-author-content="&quot;EventLog&quot;: {
  &quot;LogLevel&quot;: {
    &quot;Default&quot;: &quot;Information&quot;
  }
}
"><span><span>"EventLog"</span>: {
  <span>"LogLevel"</span>: {
    <span>"Default"</span>: <span>"Information"</span>
  }
}
</span></code></pre>
<h3 data-id="tracesource-provider">TraceSource provider<a href="#tracesource-provider" aria-labelledby="tracesource-provider"></a></h3>
<p>The <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.TraceSource" data-linktype="external">Microsoft.Extensions.Logging.TraceSource</a> provider package uses the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracesource" data-linktype="absolute-path">TraceSource</a> libraries and providers.</p>
<pre tabindex="0"><code data-author-content="logging.AddTraceSource(sourceSwitchName);
"><span>logging.AddTraceSource(sourceSwitchName);
</span></code></pre>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.tracesourcefactoryextensions" data-linktype="absolute-path">AddTraceSource overloads</a> let you pass in a source switch and a trace listener.</p>
<p>To use this provider, an app has to run on the .NET Framework (rather than .NET Core). The provider can route messages to a variety of <a href="https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/trace-listeners" data-linktype="absolute-path">listeners</a>, such as the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.textwritertracelistener" data-linktype="absolute-path">TextWriterTraceListener</a> used in the sample app.</p>
<h3 data-id="azure-app-service-provider">Azure App Service provider<a href="#azure-app-service-provider" aria-labelledby="azure-app-service-provider"></a></h3>
<p>The <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.AzureAppServices" data-linktype="external">Microsoft.Extensions.Logging.AzureAppServices</a> provider package writes logs to text files in an Azure App Service app's file system and to <a href="https://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-blobs/#what-is-blob-storage" data-linktype="external">blob storage</a> in an Azure Storage account.</p>
<pre tabindex="0"><code data-author-content="logging.AddAzureWebAppDiagnostics();
"><span>logging.AddAzureWebAppDiagnostics();
</span></code></pre>
<p>The provider package isn't included in the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/metapackage-app?view=aspnetcore-3.0" data-linktype="relative-path">Microsoft.AspNetCore.App metapackage</a>. When targeting .NET Framework or referencing the <code>Microsoft.AspNetCore.App</code> metapackage, add the provider package to the project.</p>
<p>An <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.azureappservicesloggerfactoryextensions.addazurewebappdiagnostics" data-linktype="absolute-path">AddAzureWebAppDiagnostics</a> overload lets you pass in <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.azureappservices.azureappservicesdiagnosticssettings" data-linktype="absolute-path">AzureAppServicesDiagnosticsSettings</a>. The settings object can override default settings, such as the logging output template, blob name, and file size limit. (<em>Output template</em> is a message template that's applied to all logs in addition to what's provided with an <code>ILogger</code> method call.)</p>
<p>When you deploy to an App Service app, the application honors the settings in the <a href="https://docs.microsoft.com/en-us/azure/app-service/web-sites-enable-diagnostic-log/#enablediag" data-linktype="absolute-path">App Service logs</a> section of the <strong>App Service</strong> page of the Azure portal. When the following settings are updated, the changes take effect immediately without requiring a restart or redeployment of the app.</p>
<ul>
<li><strong>Application Logging (Filesystem)</strong></li>
<li><strong>Application Logging (Blob)</strong></li>
</ul>
<p>The default location for log files is in the <em>D:\home\LogFiles\Application</em> folder, and the default file name is <em>diagnostics-yyyymmdd.txt</em>. The default file size limit is 10 MB, and the default maximum number of files retained is 2. The default blob name is <em>{app-name}{timestamp}/yyyy/mm/dd/hh/{guid}-applicationLog.txt</em>.</p>
<p>The provider only works when the project runs in the Azure environment. It has no effect when the project is run locally—it doesn't write to local files or local development storage for blobs.</p>
<h4 data-id="azure-log-streaming-1">Azure log streaming<a href="#azure-log-streaming-1" aria-labelledby="azure-log-streaming-1"></a></h4>
<p>Azure log streaming lets you view log activity in real time from:</p>
<ul>
<li>The app server</li>
<li>The web server</li>
<li>Failed request tracing</li>
</ul>
<p>To configure Azure log streaming:</p>
<ul>
<li>Navigate to the <strong>App Service logs</strong> page from your app's portal page.</li>
<li>Set <strong>Application Logging (Filesystem)</strong> to <strong>On</strong>.</li>
<li>Choose the log <strong>Level</strong>. This setting only applies to Azure log streaming, not other logging providers in the app.</li>
</ul>
<p>Navigate to the <strong>Log Stream</strong> page to view app messages. They're logged by the app through the <code>ILogger</code> interface.</p>
<h3 data-id="azure-application-insights-trace-logging">Azure Application Insights trace logging<a href="#azure-application-insights-trace-logging" aria-labelledby="azure-application-insights-trace-logging"></a></h3>
<p>The <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.ApplicationInsights" data-linktype="external">Microsoft.Extensions.Logging.ApplicationInsights</a> provider package writes logs to Azure Application Insights. Application Insights is a service that monitors a web app and provides tools for querying and analyzing the telemetry data. If you use this provider, you can query and analyze your logs by using the Application Insights tools.</p>
<p>The logging provider is included as a dependency of <a href="https://www.nuget.org/packages/Microsoft.ApplicationInsights.AspNetCore" data-linktype="external">Microsoft.ApplicationInsights.AspNetCore</a>, which is the package that provides all available telemetry for ASP.NET Core. If you use this package, you don't have to install the provider package.</p>
<p>Don't use the <a href="https://www.nuget.org/packages/Microsoft.ApplicationInsights.Web" data-linktype="external">Microsoft.ApplicationInsights.Web</a> package—that's for ASP.NET 4.x.</p>
<p>For more information, see the following resources:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/application-insights/app-insights-overview" data-linktype="absolute-path">Application Insights overview</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core" data-linktype="absolute-path">Application Insights for ASP.NET Core applications</a> - Start here if you want to implement the full range of Application Insights telemetry along with logging.</li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/ilogger" data-linktype="absolute-path">ApplicationInsightsLoggerProvider for .NET Core ILogger logs</a> - Start here if you want to implement the logging provider without the rest of Application Insights telemetry.</li>
<li><a href="https://docs.microsoft.com/azure/azure-monitor/app/asp-net-trace-logs" data-linktype="external">Application Insights logging adapters</a>.</li>
<li><a href="https://docs.microsoft.com/en-us/learn/modules/instrument-web-app-code-with-application-insights" data-linktype="absolute-path">Install, configure, and initialize the Application Insights SDK</a> - Interactive tutorial on the Microsoft Learn site.</li>
</ul>
<h2 data-id="third-party-logging-providers-1">Third-party logging providers<a href="#third-party-logging-providers-1" aria-labelledby="third-party-logging-providers-1"></a></h2>
<p>Third-party logging frameworks that work with ASP.NET Core:</p>
<ul>
<li><a href="https://elmah.io/" data-linktype="external">elmah.io</a> (<a href="https://github.com/elmahio/Elmah.Io.Extensions.Logging" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://docs.graylog.org/en/2.3/pages/gelf.html" data-linktype="external">Gelf</a> (<a href="https://github.com/mattwcole/gelf-extensions-logging" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://jsnlog.com/" data-linktype="external">JSNLog</a> (<a href="https://github.com/mperdeck/jsnlog" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://kisslog.net/" data-linktype="external">KissLog.net</a> (<a href="https://github.com/catalingavan/KissLog-net" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://logging.apache.org/log4net/" data-linktype="external">Log4Net</a> (<a href="https://github.com/huorswords/Microsoft.Extensions.Logging.Log4Net.AspNetCore" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://loggr.net/" data-linktype="external">Loggr</a> (<a href="https://github.com/imobile3/Loggr.Extensions.Logging" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://nlog-project.org/" data-linktype="external">NLog</a> (<a href="https://github.com/NLog/NLog.Extensions.Logging" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://sentry.io/welcome/" data-linktype="external">Sentry</a> (<a href="https://github.com/getsentry/sentry-dotnet" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://serilog.net/" data-linktype="external">Serilog</a> (<a href="https://github.com/serilog/serilog-aspnetcore" data-linktype="external">GitHub repo</a>)</li>
<li><a href="https://cloud.google.com/dotnet/docs/stackdriver#logging" data-linktype="external">Stackdriver</a> (<a href="https://github.com/googleapis/google-cloud-dotnet" data-linktype="external">Github repo</a>)</li>
</ul>
<p>Some third-party frameworks can perform <a href="https://softwareengineering.stackexchange.com/questions/312197/benefits-of-structured-logging-vs-basic-logging" data-linktype="external">semantic logging, also known as structured logging</a>.</p>
<p>Using a third-party framework is similar to using one of the built-in providers:</p>
<ol>
<li>Add a NuGet package to your project.</li>
<li>Call an <code>ILoggerFactory</code> extension method provided by the logging framework.</li>
</ol>
<p>For more information, see each provider's documentation. Third-party logging providers aren't supported by Microsoft.</p>
<h2 data-id="additional-resources-1">Additional resources<a href="#additional-resources-1" aria-labelledby="additional-resources-1"></a></h2>
<ul>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/loggermessage?view=aspnetcore-3.0" data-linktype="relative-path">High-performance logging with LoggerMessage in ASP.NET Core</a></li>
</ul>
</div>

						<!-- </content> -->

						</main>

						<!-- recommended content page section -->

							<nav data-bi-name="recommendation-bottom" hidden="" id="recommended-content-center" aria-labelledby="recommended-content-center-title">
								<h3 id="recommended-content-center-title">Related Articles</h3>
							</nav>

						<!-- end recommended content page section -->

						<!-- page rating section -->
								
						<!-- end page rating section -->


						<!-- feedback section -->
<section data-bi-name="feedback-section">

    <h2 id="feedback">Feedback</h2>

    

    

    

    <div data-tab-group-independent="" hidden="" data-bi-name="tab-group">
        <ul role="tablist">
            <li role="presentation">
                <a aria-controls="tabpanel-issues-open" data-tab="issues-open" href="#tabpanel-issues-open" role="tab" data-bi-name="tab" aria-selected="true" tabindex="0"></a>
            </li>
            <li role="presentation">
                <a aria-controls="tabpanel-issues-closed" data-tab="issues-closed" href="#tabpanel-issues-closed" role="tab" data-bi-name="tab" aria-selected="false" tabindex="-1"></a>
            </li>
        </ul>
        <section data-tab="issues-open" id="tabpanel-issues-open" role="tabpanel">
            
            <ul aria-label="Open Issues"></ul>
        </section>
        <section data-tab="issues-closed" id="tabpanel-issues-closed" role="tabpanel" hidden="hidden" aria-hidden="true">
            <div>There are no closed issues</div>
            <ul aria-label="Closed Issues"></ul>
        </section>
    </div>
    
</section>

						<!-- end feedback section -->

						<!-- feedback report section -->
						<!-- end feedback report section -->

						
					</div>

					

					<!--end of div.columns -->
				</div>

			<!--end of .primary-holder -->
			</section>

			
		</div>

		<!--end of .mainContainer -->
	</div>

	

	

	


</div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>