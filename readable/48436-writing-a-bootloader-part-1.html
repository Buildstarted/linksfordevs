<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Writing a Bootloader Part 1 -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Writing a Bootloader Part 1</h1>
    <div class="entry"> <p>This article series explains how to write a tiny 32-bit x86 operating system kernel. We won&#x2019;t do very much other than print <code>Hello world!</code> to the screen in increasingly complicated ways! We&#x2019;ll start off in assembly and then build up to writing C++!</p>
<p>A <a href="/2017/10/13/writing-a-bootloader/writingabootloader.pdf">presentation</a> of this article series is also available.</p>
<p>To follow along you&#x2019;re going to need the NASM assembler and <a href="https://www.qemu.org/">QEMU</a> to emulate a virtual machine for us. QEMU is great because you don&#x2019;t have to worry about accidentally destroying your hardware with badly written OS code ;) You can install these on <a href="https://msdn.microsoft.com/en-gb/commandline/wsl/install_guide">Windows Subsystem for Linux</a> or Ubuntu with this command:</p>
<pre><code>sudo apt-get install nasm qemu
</code></pre><p>On a mac you can use homebrew:</p>
<pre><code>brew install nasm
</code></pre><p>On Windows 10 you&#x2019;ll also want to install <a href="https://sourceforge.net/projects/xming/">an X Server</a> which allows QEMU to open a window from the linux subsystem.</p>
<p>We&#x2019;re going to write a floppy disk bootloader because it doesn&#x2019;t require us to mess about with file systems which helps keep things simple as possible.</p>
<p><img src="/2017/10/13/writing-a-bootloader/floppy.jpg" alt="Cutting edge 1970s technology!"></p>
<p>When you press the power button the computer loads the BIOS from some flash memory stored on the motherboard. The BIOS initializes and self tests the hardware then loads the first 512 bytes into memory from the media device (i.e. the cdrom or floppy disk). If the last two bytes equal <code>0xAA55</code> then the BIOS will jump to location <code>0x7C00</code> effectively transferring control to the bootloader. </p>
<p>At this point the CPU is running in 16 bit mode, meaning only the 16 bit registers are available. Also since the BIOS only loads the first 512 bytes this means our bootloader code has to stay below that limit, otherwise we&#x2019;ll hit uninitialised memory!</p>
<p>Let&#x2019;s get hello world printing to the screen. To do this we&#x2019;re going to use the &#x2018;Write Character in TTY mode&#x2019; <a href="https://en.wikipedia.org/wiki/BIOS_interrupt_call">BIOS Interrupt Call</a> and the load string byte instruction <code>lobsb</code> which loads byte at address <code>ds:si</code> into <code>al</code>. Here goes:</p>
<pre><code>bits 16 ; tell NASM this is 16 bit code
org 0x7c00 ; tell NASM to start outputting stuff at offset 0x7c00
boot:
    mov si,hello ; point si register to hello label memory location
    mov ah,0x0e ; 0x0e means &apos;Write Character in TTY mode&apos;
.loop:
    lodsb
    or al,al ; is al == 0 ?
    jz halt  ; if (al == 0) jump to halt label
    int 0x10 ; runs BIOS interrupt 0x10 - Video Services
    jmp .loop
halt:
    cli ; clear interrupt flag
    hlt ; halt execution
hello: db &quot;Hello world!&quot;,0

times 510 - ($-$$) db 0 ; pad remaining 510 bytes with zeroes
dw 0xaa55 ; magic bootloader magic - marks this 512 byte sector bootable!
</code></pre><p>If you save this file as <code>boot1.asm</code> (or <a href="/2017/10/13/writing-a-bootloader/boot1.asm">download it here</a>) we can now use <code>nasm</code> to compile it:</p>
<pre><code>nasm -f bin boot1.asm -o boot1.bin
</code></pre><p>If we run <code>hexdump boot1.bin</code> we can see that NASM created some code, padded some zeros then set the final two bytes to the magic number.</p>
<pre><code>0000000 be 10 7c b4 0e ac 08 c0 74 04 cd 10 eb f7 fa f4
0000010 48 65 6c 6c 6f 20 77 6f 72 6c 64 21 00 00 00 00
0000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
00001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa
0000200
</code></pre><p>We can now run this thing! You can tell QEMU to boot off a floppy disk using <code>qemu-system-x86_64 -fda boot1.bin</code> on Windows 10 you might need to stick <code>DISPLAY=:0</code> in front to open the window from WSL. You should get something like this!</p>
<p><img src="/2017/10/13/writing-a-bootloader/boot1.png" alt="Our Hello World bootloader"></p>
<h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink"></a>Next Steps</h2><p>Next we can start investigating getting into Protected Mode in <a href="/2017/10/16/writing-a-bootloader2/">Part 2</a>!</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>