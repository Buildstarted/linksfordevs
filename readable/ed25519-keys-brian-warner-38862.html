<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>Ed25519 Keys | Brian Warner</h1>
        <p>
Reading time: 6-8 minutes        </p>
        <p><a href="https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/">https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
				
<p>There are several different implementations of the <a href="http://ed25519.cr.yp.to/">Ed25519</a> signature system, and they each use slightly different key formats. While writing <a href="https://github.com/warner/python-ed25519">python-ed25519</a>, I wanted to validate it against the upstream known-answer-tests, so I had to figure out how to convert those keys into a format that my code could use.</p>
<p><span id="more-124"></span><br>
The best reference is the <a href="http://ed25519.cr.yp.to/ed25519-20110926.pdf">original paper</a>, which explains everything you need to know to implement the basic algorithm. I currently know of three or four implementations (many of which are on the Ed25519 <a href="http://ed25519.cr.yp.to/software.html">software page</a>):</p>
<ul>
<li>a portable C ‚Äúreference‚Äù version</li>
<li>a 10x faster AMD64-optimized C/assembly version (in two flavors, with different speed/memory tradeoffs)</li>
<li>an educational (but unusably slow) pure-python module</li>
<li>my Python binding to the C reference version</li>
</ul>
<p>djb‚Äôs <a href="http://nacl.cr.yp.to/">NaCl</a> library (as of version 20110221) includes an <del>older copy</del> prototype of the portable C version, in nacl-20110221/crypto_sign/edwards5519sha512batch/ref/ (as far as I can tell, it doesn‚Äôt implement quite the same algorithm: it doesn‚Äôt include the pubkey in the hash when computing S. UPDATE: djb told me that nacl-20110221‚Äôs code is just a prototype, and will be replaced with the real Ed25519 in the next release). The <a href="http://bench.cr.yp.to/supercop.html">SUPERCOP</a> benchmark suite includes both the portable C and the two AMD64-specific flavors (in supercop-20110704/crypto_sign/ed25519/, under the ref, amd64-51-30k, and amd64-64-24k subdirectories). The pedagogical pure-python implementation is referenced by the <a href="http://ed25519.cr.yp.to/software.html">ed25519 web page</a>, but since it takes tens of seconds to compute each signature, it‚Äôs really only useful for validating the output of other implementations.</p>
<p>My <a href="https://github.com/warner/python-ed25519">python-ed25519</a> library provides Python bindings to the portable C version, using code taken from the SUPERCOP suite.</p>
<p>These different implementations all arrange the keys and signatures slightly differently. NaCl‚Äôs goal is to provide safe high-level box/unbox functions, so the only interface it offers will copy the entire message into the output and append a signature to it (not so convenient for building into other protocols). SUPERCOP‚Äôs goal is to measure the speed of each operation, so its interface isn‚Äôt so convenient for general use either. I‚Äôve tried to give python-ed25519 a good interface for use in other projects.</p>
<p>To remind myself about how these different implementations handle keys, here‚Äôs an overview.</p>
<p>Ed25519 keys start life as a 32-byte (256-bit) uniformly random binary seed (e.g. the output of SHA256 on some random input). The seed is then hashed using SHA512, which gets you 64 bytes (512 bits), which is then split into a ‚Äúleft half‚Äù (the first 32 bytes) and a ‚Äúright half‚Äù. The left half is massaged into a curve25519 private scalar ‚Äúa‚Äù by setting and clearing a few high/low-order bits. The pubkey is generated by multiplying this secret scalar by ‚ÄúB‚Äù (the generator), which yields a 32-byte/256-bit group element ‚ÄúA‚Äù.</p>
<p>When signatures are made, two values result: R and S (both 32-bytes, so the overall signature is 64 bytes long). R depends upon the right half of the expanded seed and on the message. (In traditional DSA, R is randomly generated, and the security of the private key depends upon the quality of that randomness, leading to some high-profile failures). S is the real meat of the signature, and is a function of everything (including the pubkey).</p>
<p>Private signing keys can be generated from just the 32-byte seed, but require additional work before you can make signatures (SHA512-based expansion, the bit setting/clearing massage step, and pubkey exponentiation). Likewise public verifying keys can be derived from either the private seed or the private exponent. (note that it‚Äôs the multiplications that take the most time: everything else is trivial by comparison).</p>
<p>If you care more about the speed of operations than storage space, you‚Äôd want to store the expanded versions. Or, you might want to store as little information as possible, and accept the performance penalty of re-deriving things when necessary. Different implementations choose different tradeoffs.</p>
<p>With that background, here‚Äôs what the different implementations do:</p>
<ul>
<li>slow pure-python ‚Äúed25519.py‚Äù implementation, with Known-Answer-Tests in sign.py and sign.input:
<ul>
<li>publickey(sk) takes the seed, returns the 32-byte pubkey</li>
<li>signature() takes the message to be signed, the seed, and the pubkey, returns the 64-byte signature</li>
<li>checkvalid() takes the signature, the message, and the 32-byte pubkey</li>
<li>each line of the test data contains four fields (joined by colons):</li>
<li>seed+pubkey (64 bytes)</li>
<li>just the pubkey (32 bytes)</li>
<li>the message (variable length)</li>
<li>the signature concatenated with the message (R+S+msg)</li>
</ul>
</li>
<li>NaCl-20110221 implementation:
<ul>
<li>keypair() returns two values. The first (signing key) is the private scalar (32 bytes) concatenated with the ‚Äúright half‚Äù (also 32 bytes). The second is the pubkey (32 bytes)</li>
<li>sign() takes the signing key and message. The NaCl version doesn‚Äôt take the pubkey, and thus diverges from the ed25519.py implementation: S=H(r+msg), not H(r+pubkey+msg). ed25519.py matches the paper, as does SUPERCOP, but NaCl does not. sign() returns R+msg+S</li>
</ul>
</li>
<li>SUPERCOP-20110704 implementation:
<ul>
<li>keypair() returns two values. The first (signing key) is the seed (32 bytes) concatenated with the generated pubkey (32 bytes). The second is the pubkey (32 bytes).</li>
<li>sign() returns R+S+msg</li>
</ul>
</li>
<li>python-ed25519 (using the SUPERCOP code but changing the output):
<ul>
<li>ed25519.create_keypair() returns a SigningKey object and a VerifyingKey object</li>
<li>SigningKeys can be serialized with to_bytes() (which returns the same 64 bytes as the SUPERCOP code that it wraps: the seed concatenated with the pubkey A), or with to_seed() (which returns just the 32-byte seed).</li>
<li>VerifyingKeys can be serialized with to_bytes(), which returns the<br>
32-byte pubkey A.</li>
<li>sk.sign() returns a 64-byte signature (the concatenation of R and S) without returning a copy of the message too. (internally, this invokes SUPERCOP‚Äôs crypto_sign() function with an output buffer large enough to hold R+S+msg, then discards the message).</li>
</ul>
</li>
</ul>
<p>This is summarized in the following diagram:</p>
<p><a href="http://ffp4g1ylyit3jdyti1hqcvtb-wpengine.netdna-ssl.com/warner/files/2011/11/key-formats.png"><img title="key-formats" src="http://ffp4g1ylyit3jdyti1hqcvtb-wpengine.netdna-ssl.com/warner/files/2011/11/key-formats-757x1024.png" alt="" width="757" height="1024" srcset="https://blog.mozilla.org/warner/files/2011/11/key-formats-757x1024.png 757w, https://blog.mozilla.org/warner/files/2011/11/key-formats-222x300.png 222w, https://blog.mozilla.org/warner/files/2011/11/key-formats.png 1039w" sizes="(max-width: 757px) 100vw, 757px"></a></p>
				

								
				<p>
					<small>
						This entry was posted on Tuesday, November 29th, 2011 at 5:24 pm						and is filed under <a href="https://blog.mozilla.org/warner/category/cryptography/" rel="category tag">Cryptography</a>.
						You can follow any comments to this entry through the <a href="https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/feed/">RSS 2.0</a> feed.

													You can <a href="#respond">leave a comment</a>, or <a href="https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/trackback/" rel="trackback">trackback</a> from your own site.

						
					</small>
				</p>

			</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>