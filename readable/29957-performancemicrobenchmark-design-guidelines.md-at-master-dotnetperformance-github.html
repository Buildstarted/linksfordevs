<!DOCTYPE html>
<html lang="en">
<head>
    <title>
performance/microbenchmark-design-guidelines.md at master &#xB7; dotnet/performance &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>performance/microbenchmark-design-guidelines.md at master · dotnet/performance · GitHub</h1><div><div id="" class="markdown-body entry-content p-3 p-md-6"><h2><a id="user-content-general-overview" class="anchor" aria-hidden="true" href="#general-overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>General Overview</h2><ul><li>Choose a good name because you won't be able to change it after the first results are uploaded to the Reporting System.</li><li>Move initialization logic to a Setup method. Don't forget to clean up the resources in a corresponding Cleanup method.</li><li>If your benchmark needs input data, it should be always exactly the same data. Use <code>ValuesGenerator</code> to generate the data.</li><li>Benchmark should have one test case per one code path of the benchmarked code. Not more.</li><li>Focus on the most common use cases, not edge cases. Performance of error cases is almost never interesting.</li><li>Make sure the benchmark has no side-effects.</li><li>Return the result from the benchmark to prevent dead code elimination.</li><li>Try to avoid adding loops to your benchmark, BenchmarkDotNet is going to invoke the benchmark many times for you instead.</li></ul><h2><a id="user-content-table-of-contents" class="anchor" aria-hidden="true" href="#table-of-contents"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Table of Contents</h2><h2><a id="user-content-mindset" class="anchor" aria-hidden="true" href="#mindset"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mindset</h2><p>Writing Benchmarks is much different than writing Unit Tests. So before you start coding, you need to change your mindset first.</p><h3><a id="user-content-benchmarks-are-not-unit-tests" class="anchor" aria-hidden="true" href="#benchmarks-are-not-unit-tests"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Benchmarks are not Unit Tests</h3><p>When writing Unit Tests, we ideally want to test all methods and properties of the given type. We also test both the happy and unhappy paths. The result of every Unit Test run is a single value: passed or failed.</p><p>Benchmarks are different. First of all, the result of a benchmark run is never a single value. It's a whole distribution, described with values like mean, standard deviation, min, max and so on. To get a meaningful distribution, the benchmark has to be executed many, many times. <strong>This takes a lot of time</strong>. With the current <a href="https://github.com/dotnet/performance/blob/51d8f8483b139bb1edde97f917fa436671693f6f/src/harness/BenchmarkDotNet.Extensions/RecommendedConfig.cs#L17-L20">recommended settings</a> used in this repository, it takes on average six seconds to run a single benchmark.
The public surface of .NET Standard 2.0 API has tens of thousands of methods. If we had 1 benchmark for every public method, it would take two and a half days to run the benchmarks. Not to speak about the time it would take to analyze the results, filter the false positives, etc..</p><p>This is only one of the reasons why writing Benchmarks is different than writing Unit Tests.</p><p>The goal of benchmarking is to test the performance of all the methods that are frequently used (hot paths) and should be performant. <strong>The focus should be on the most common use cases, not edge cases</strong>.</p><h3><a id="user-content-benchmarks-are-immutable" class="anchor" aria-hidden="true" href="#benchmarks-are-immutable"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Benchmarks are Immutable</h3><p>The results of benchmark runs are exported to an internal Reporting System. Every benchmark is identified using the following <code>xUnit</code> ID pattern:</p><pre><code>namespace.typeName.methodName(paramName: paramValue)
</code></pre><p>To be able to track the performance over time, we <strong>must NOT change the ID</strong>. It means that every change to a namespace, type name, method name, parameter name|value is considered to be a breaking change and must be avoided if possible.</p><p><a target="_blank" rel="noopener noreferrer" href="/dotnet/performance/blob/master/docs/img/benchmark_id_rename.png"><img src="/dotnet/performance/raw/master/docs/img/benchmark_id_rename.png" alt="Rename"></a></p><p>The Reporting System is used to monitor the performance changes and detect regressions. If the body of the benchmark is changed, the old name is kept and the reported time increases, it's going to be marked as regression and require a dedicated performance investigation. We want to avoid such false alarms and hence we want to reduce the number of changes in existing benchmarks to a minimum.</p><p><a target="_blank" rel="noopener noreferrer" href="/dotnet/performance/blob/master/docs/img/benchmark_id_regression.png"><img src="/dotnet/performance/raw/master/docs/img/benchmark_id_regression.png" alt="Regression"></a></p><p>If you have some good reasons for changing the implementation of the benchmark you should remove the old one and introduce a new one with a new name.</p><h2><a id="user-content-benchmarkdotnet" class="anchor" aria-hidden="true" href="#benchmarkdotnet"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BenchmarkDotNet</h2><p>BenchmarkDotNet is the benchmarking harness used in this repository. If you are new to BenchmarkDotNet, you should read <a href="/dotnet/performance/blob/master/docs/benchmarkdotnet.md">this introduction to BenchmarkDotNet</a>.</p><p>Key things that you need to remember:</p><ul><li>BenchmarkDotNet <strong>does not require the user to provide the number of iterations and invocations per iteration</strong>, it implements a smart heuristic based on standard error and runs the benchmark until the results are stable.</li><li>BenchmarkDotNet runs every benchmark in a separate process, process isolation allows avoiding side-effects. The more memory allocated by given benchmark, the bigger the difference for in-proc vs out-proc execution.</li><li>BenchmarkDotNet was designed to make accurate nano-benchmarks with repeatable results possible, to achieve that it does many things, including overhead calculation and subtraction (it benchmarks an empty method with the same signature and subtract the average value from results).</li><li>BenchmarkDotNet removes outliers by default (this repo is configured to remove only the upper outliers)</li><li>BenchmarkDotNet creates a type which derives from type with benchmarks. So the type with benchmarks must <strong>not</strong> be <strong>sealed</strong> and it can <strong>not</strong> be <strong>static</strong> and it has to be <strong>public</strong>. It also has to be a <code>class</code> (no structs support).</li></ul><p><strong>Note:</strong> If you are not sure what invocation or iteration means, please read <a href="https://benchmarkdotnet.org/articles/guides/how-it-works.html" rel="nofollow">this doc</a> that explains how BenchmarkDotNet works.</p><h2><a id="user-content-setup" class="anchor" aria-hidden="true" href="#setup"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setup</h2><p>Let's write a benchmark that measures the performance of reversing an array of 1 000 integers:</p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">Benchmark</span>]
<span class="pl-k">public</span><span class="pl-k">int</span>[] <span class="pl-en">Reverse</span>()
{
    <span class="pl-k">int</span>[] <span class="pl-smi">array</span><span class="pl-k">=</span><span class="pl-smi">Enumerable</span>.<span class="pl-en">Range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1_000</span>).<span class="pl-en">ToArray</span>();

    <span class="pl-smi">Array</span>.<span class="pl-en">Reverse</span>(<span class="pl-smi">array</span>);

    <span class="pl-k">return</span><span class="pl-smi">array</span>;
}</pre></div><p>Profile it using the <a href="/dotnet/performance/blob/master/docs/benchmarkdotnet.md#Profiling">ETW Profiler</a>:</p><div class="highlight highlight-source-batchfile"><pre>dotnet run -c Release -f netcoreapp3.0 --filter *.Reverse --profiler ETW</pre></div><p>And open the produced trace file with <a href="https://github.com/Microsoft/perfview">PerfView</a>:</p><p><a target="_blank" rel="noopener noreferrer" href="/dotnet/performance/blob/master/docs/img/setup_array_reverse_profiler.png"><img src="/dotnet/performance/raw/master/docs/img/setup_array_reverse_profiler.png" alt="Regression"></a></p><p>As you can see, reversing the array took only <code>26.6%</code> of the benchmark execution time! The rest was spent on executing the array creation logic. What does it mean? It means that the given benchmark is measuring the performance of creating and reversing the array. Not just reversing the array.</p><p>This is why <strong>the initialization logic should be always separated from the benchmark</strong>.</p><h3><a id="user-content-globalsetup" class="anchor" aria-hidden="true" href="#globalsetup"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GlobalSetup</h3><p>A public method marked with <code>[GlobalSetup]</code> attribute is going to be executed <strong>exactly once</strong>, before running the benchmark for the first time.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">private</span><span class="pl-k">int</span>[] <span class="pl-smi">_array</span>;

[<span class="pl-en">GlobalSetup</span>]
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">SetupReverse</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">_array</span><span class="pl-k">=</span><span class="pl-smi">Enumerable</span>.<span class="pl-en">Range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1000</span>).<span class="pl-en">ToArray</span>();

[<span class="pl-en">Benchmark</span>]
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Reverse</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">Array</span>.<span class="pl-en">Reverse</span>(<span class="pl-smi">_array</span>);</pre></div><p>Any method marked <code>[GlobalSetup]</code> which does not specify the <code>Target(s)</code> benchmark name(s) is executed for every benchmark declared in a given class.</p><p>In case you want to have a class with multiple benchmarks and multiple, dedicated setup methods you need to use <code>Target</code> or <code>Targets</code> properties of the setup attribute:</p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">GlobalSetup</span>(<span class="pl-en">Target</span><span class="pl-k">=</span><span class="pl-k">nameof</span>(<span class="pl-smi">Reverse</span>))]
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">SetupReverse</span>()

[GlobalSetup(Targets <span class="pl-k">=</span><span class="pl-k">new</span> [] { <span class="pl-k">nameof</span>(<span class="pl-smi">Array</span>), <span class="pl-k">nameof</span>(<span class="pl-smi">Span</span>), <span class="pl-k">nameof</span>(<span class="pl-smi">ReadOnlySpan</span>)})]
public void SetupArray()</pre></div><p><strong>Note:</strong> If you need to clean up resources after the benchmark run (an example of required cleanup would be any files created on the disk by the benchmark process), you should use the corresponding <code>[GlobalCleanup]</code> attribute. It's going to be executed only once, after all benchmark iterations.</p><h3><a id="user-content-iterationsetup" class="anchor" aria-hidden="true" href="#iterationsetup"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IterationSetup</h3><p>If your benchmark requires a clean state for every invocation, you need to use the <code>[IterationSetup]</code> attribute. Unfortunately, just using the <code>[IterationSetup]</code> attribute is not enough to get stable results. You also need to make sure that the benchmark itself performs enough of computations for a single invocation to run longer than 100ms. <strong>If you don't, your benchmark will be entirely invalid.</strong></p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">Params</span>(<span class="pl-c1">1000</span><span class="pl-k">*</span><span class="pl-c1">1000</span><span class="pl-k">*</span><span class="pl-c1">200</span>)] <span class="pl-c"><span class="pl-c">//</span> allows for stable iteration around 200ms</span><span class="pl-k">public</span><span class="pl-smi">int</span><span class="pl-smi">NumberOfBytes</span> { <span class="pl-smi">get</span>; <span class="pl-smi">set</span>; }

<span class="pl-k">private</span><span class="pl-k">byte</span>[] <span class="pl-smi">_source</span>, <span class="pl-smi">_destination</span>;

[<span class="pl-en">GlobalSetup</span>]
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Setup</span>()
{
    <span class="pl-smi">_source</span><span class="pl-k">=</span><span class="pl-smi">ValuesGenerator</span>.<span class="pl-en">Array</span>&lt;<span class="pl-k">byte</span>&gt;(<span class="pl-smi">NumberOfBytes</span>);
    <span class="pl-smi">_destination</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">byte</span>[<span class="pl-smi">Base64</span>.<span class="pl-en">GetMaxEncodedToUtf8Length</span>(<span class="pl-smi">NumberOfBytes</span>)];
}

[<span class="pl-en">IterationSetup</span>(<span class="pl-en">Target</span><span class="pl-k">=</span><span class="pl-k">nameof</span>(<span class="pl-smi">Base64EncodeInPlace</span>))]
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">SetupBase64EncodeInPlace</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">Array</span>.<span class="pl-en">Copy</span>(<span class="pl-smi">_source</span>, <span class="pl-smi">_destination</span>, <span class="pl-smi">_source</span>.<span class="pl-smi">Length</span>);

[<span class="pl-en">Benchmark</span>]
<span class="pl-k">public</span><span class="pl-en">OperationStatus</span><span class="pl-en">Base64EncodeInPlace</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">Base64</span>.<span class="pl-en">EncodeToUtf8InPlace</span>(<span class="pl-smi">_destination</span>, <span class="pl-smi">_source</span>.<span class="pl-smi">Length</span>, <span class="pl-k">out</span><span class="pl-c1">_</span>);</pre></div><p><strong>Note:</strong> If you need to clean up resources after every benchmark run, you should use the corresponding <code>[IterationCleanup]</code> attribute. It's going to be executed once after every iteration.</p><p>If you want to get a better understanding of it, you should read <a href="https://aakinshin.net/posts/stopwatch/#pitfalls" rel="nofollow">this blog post</a> about stopwatch and follow the GitHub discussions in this <a href="https://github.com/dotnet/BenchmarkDotNet/issues/730">issue</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/760">PR</a>.</p><ins><strong>If using <code>[GlobalSetup]</code> is enough, you should NOT be using <code>[IterationSetup]</code></strong></ins><h3><a id="user-content-operationsperinvoke" class="anchor" aria-hidden="true" href="#operationsperinvoke"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OperationsPerInvoke</h3><p><code>[GlobalSetup]</code> and <code>[IterationSetup]</code> might not be enough if you want to setup some nano-benchmarks.</p><p>A good example is <code>Slicing</code> a <code>Span</code>. <code>Span</code> is a stack-only type, so we can not have a <code>[GlobalSetup]</code> method which writes it to a field of a <code>class</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span><span class="pl-en">WontCompile</span>
{
    <span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">_span</span>; <span class="pl-c"><span class="pl-c">//</span> compiler error</span>

    [<span class="pl-en">GlobalSetup</span>]
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Setup</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">_span</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt;(<span class="pl-k">new</span><span class="pl-k">byte</span>[<span class="pl-c1">10</span>]);
}</pre></div><p>The current implementation of BenchmarkDotNet does not allow to run benchmarks defined in structs (including <code>ref struct</code>).</p><p>If we write a following benchmark:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">private</span><span class="pl-k">byte</span>[] <span class="pl-smi">_nonEmptyArray</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">byte</span>[<span class="pl-c1">10</span>];

[<span class="pl-en">Benchmark</span>]
<span class="pl-k">public</span><span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-en">Slice</span>()
{
    <span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt;(<span class="pl-smi">_nonEmptyArray</span>);

    <span class="pl-k">return</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-smi">span</span>.<span class="pl-smi">Length</span><span class="pl-k">/</span><span class="pl-c1">2</span>);
}</pre></div><p>The benchmark is not going to measure the performance of <code>Slice</code> operation, but similar to previous example of reversing an array it's going to measure the performance of creating a <code>Span</code> from <code>Array</code> and the <code>Slice</code> operation.</p><p>To solve this problem we can use <code>OperationsPerInvoke</code> property of the <code>[Benchmark]</code> attribute.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">private</span><span class="pl-k">byte</span>[] <span class="pl-smi">_nonEmptyArray</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">byte</span>[<span class="pl-c1">18</span>];

[<span class="pl-en">Benchmark</span>(<span class="pl-en">OperationsPerInvoke</span><span class="pl-k">=</span><span class="pl-c1">16</span>)]
<span class="pl-k">public</span><span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-en">Slice</span>()
{
    <span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt;(<span class="pl-smi">_nonEmptyArray</span>); <span class="pl-c"><span class="pl-c">//</span> create it once</span><span class="pl-c"><span class="pl-c">//</span> perform OperationsPerInvoke-many operations</span><span class="pl-c"><span class="pl-c">//</span> without introducing a loop, which would add an extra overhead</span><span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>);
    <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>);
    <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>);
    <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>); <span class="pl-smi">span</span><span class="pl-k">=</span><span class="pl-smi">span</span>.<span class="pl-en">Slice</span>(<span class="pl-c1">1</span>);

    <span class="pl-k">return</span><span class="pl-smi">span</span>;
}</pre></div><p>BenchmarkDotNet is going to scale the result by the number provided in <code>OperationsPerInvoke</code> so the cost of creating the <code>Span</code> is going to be amortized:</p><pre><code>reportedResult = 1/16*SpanCtor + 1*Slice
</code></pre><p><strong>Note:</strong><code>OperationsPerInvoke</code> should be big enough to amortize the "setup" cost.</p><h2><a id="user-content-test-cases" class="anchor" aria-hidden="true" href="#test-cases"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Test Cases</h2><h3><a id="user-content-code-paths" class="anchor" aria-hidden="true" href="#code-paths"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code Paths</h3><p>When it comes to choosing different test cases for a benchmark, we should be using the internal perspective of the system (<a href="https://en.wikipedia.org/wiki/White-box_testing" rel="nofollow">White-box testing</a>) and <strong>choose test cases that test different code paths</strong>.</p><h4><a id="user-content-arrayreverse" class="anchor" aria-hidden="true" href="#arrayreverse"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array.Reverse</h4><p>Let's consider the example of reversing an array and take a look at the <a href="https://github.com/dotnet/coreclr/blob/085398b5c6913b03180c855f56b967e2a7d6edde/src/System.Private.CoreLib/shared/System/Array.cs#L1347-L1371">current implementation</a>:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Reverse</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-en">T</span>[] <span class="pl-smi">array</span>, <span class="pl-k">int</span><span class="pl-smi">index</span>, <span class="pl-k">int</span><span class="pl-smi">length</span>)
{
    <span class="pl-k">if</span> (<span class="pl-smi">array</span><span class="pl-k">==</span><span class="pl-c1">null</span>)
        <span class="pl-smi">ThrowHelper</span>.<span class="pl-en">ThrowArgumentNullException</span>(<span class="pl-smi">ExceptionArgument</span>.<span class="pl-smi">array</span>);
    <span class="pl-k">if</span> (<span class="pl-smi">index</span><span class="pl-k">&lt;</span><span class="pl-c1">0</span>)
        <span class="pl-smi">ThrowHelper</span>.<span class="pl-en">ThrowIndexArgumentOutOfRange_NeedNonNegNumException</span>();
    <span class="pl-k">if</span> (<span class="pl-smi">length</span><span class="pl-k">&lt;</span><span class="pl-c1">0</span>)
        <span class="pl-smi">ThrowHelper</span>.<span class="pl-en">ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum</span>();
    <span class="pl-k">if</span> (<span class="pl-smi">array</span><span class="pl-k">!</span>.<span class="pl-smi">Length</span><span class="pl-k">-</span><span class="pl-smi">index</span><span class="pl-k">&lt;</span><span class="pl-smi">length</span>) <span class="pl-c"><span class="pl-c">//</span> TODO-NULLABLE: Remove ! when [DoesNotReturn] respected</span><span class="pl-smi">ThrowHelper</span>.<span class="pl-en">ThrowArgumentException</span>(<span class="pl-smi">ExceptionResource</span>.<span class="pl-smi">Argument_InvalidOffLen</span>);

    <span class="pl-k">if</span> (<span class="pl-smi">length</span><span class="pl-k">&lt;=</span><span class="pl-c1">1</span>)
        <span class="pl-k">return</span>;

    <span class="pl-k">ref</span><span class="pl-en">T</span><span class="pl-smi">first</span><span class="pl-k">=</span><span class="pl-k">ref</span><span class="pl-smi">Unsafe</span>.<span class="pl-en">Add</span>(<span class="pl-k">ref</span><span class="pl-smi">Unsafe</span>.<span class="pl-en">As</span>&lt;<span class="pl-k">byte</span>, <span class="pl-en">T</span>&gt;(<span class="pl-k">ref</span><span class="pl-smi">array</span>.<span class="pl-en">GetRawSzArrayData</span>()), <span class="pl-smi">index</span>);
    <span class="pl-k">ref</span><span class="pl-en">T</span><span class="pl-smi">last</span><span class="pl-k">=</span><span class="pl-k">ref</span><span class="pl-smi">Unsafe</span>.<span class="pl-en">Add</span>(<span class="pl-k">ref</span><span class="pl-smi">Unsafe</span>.<span class="pl-en">Add</span>(<span class="pl-k">ref</span><span class="pl-smi">first</span>, <span class="pl-smi">length</span>), <span class="pl-k">-</span><span class="pl-c1">1</span>);
    <span class="pl-k">do</span>
    {
        <span class="pl-en">T</span><span class="pl-smi">temp</span><span class="pl-k">=</span><span class="pl-smi">first</span>;
        <span class="pl-smi">first</span><span class="pl-k">=</span><span class="pl-smi">last</span>;
        <span class="pl-smi">last</span><span class="pl-k">=</span><span class="pl-smi">temp</span>;
        <span class="pl-smi">first</span><span class="pl-k">=</span><span class="pl-smi">ref</span><span class="pl-smi">Unsafe</span>.<span class="pl-en">Add</span>(<span class="pl-k">ref</span><span class="pl-smi">first</span>, <span class="pl-c1">1</span>);
        <span class="pl-smi">last</span><span class="pl-k">=</span><span class="pl-smi">ref</span><span class="pl-smi">Unsafe</span>.<span class="pl-en">Add</span>(<span class="pl-k">ref</span><span class="pl-smi">last</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>);
    } <span class="pl-k">while</span> (<span class="pl-smi">Unsafe</span>.<span class="pl-en">IsAddressLessThan</span>(<span class="pl-k">ref</span><span class="pl-smi">first</span>, <span class="pl-k">ref</span><span class="pl-smi">last</span>));
}</pre></div><p>Does it make sense to test the code paths that throw?</p><p>Should we test the code path for an array with one or zero elements?</p><ul><li>No, because it does not perform any actual work. We would be benchmarking a branch and return from the method. If <code>Reverse</code> is inlinable, such a benchmark would be measuring the performance of <code>if (length &lt;= 1)</code> and the throw checks.</li><li>No, because it's not a common case. Moreover, it's very unlikely that removing this check from the code would pass the <a href="https://github.com/dotnet/runtime">dotnet/runtime</a> repository code review and regress the performance in the future.</li></ul><p>So what is left? A loop that does the actual work. Does it make sense to test it for arrays of different sizes?</p><ul><li>No, because the loop has <code>O(n)</code> complexity and testing different sizes is just going to produce the results that confirm the linear time. It won't add any value but instead, prolong the time it takes to run the benchmarks.</li></ul><h4><a id="user-content-buffercopymemory" class="anchor" aria-hidden="true" href="#buffercopymemory"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Buffer.CopyMemory</h4><p>Let's consider another example: copying blocks of memory. Part of the <a href="https://github.com/dotnet/coreclr/blob/085398b5c6913b03180c855f56b967e2a7d6edde/src/System.Private.CoreLib/shared/System/Buffer.cs#L143-L155">current implementation</a>:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">internal</span><span class="pl-k">static</span><span class="pl-k">unsafe</span><span class="pl-k">void</span><span class="pl-en">Memmove</span>(byte* dest, byte* src, <span class="pl-en">nuint</span><span class="pl-smi">len</span>)
{
    <span class="pl-c"><span class="pl-c">//</span> P/Invoke into the native version when the buffers are overlapping.</span><span class="pl-k">if</span> (((<span class="pl-en">nuint</span>)<span class="pl-smi">dest</span><span class="pl-k">-</span> (<span class="pl-en">nuint</span>)<span class="pl-smi">src</span><span class="pl-k">&lt;</span><span class="pl-smi">len</span>) <span class="pl-k">||</span> ((<span class="pl-en">nuint</span>)<span class="pl-smi">src</span><span class="pl-k">-</span> (<span class="pl-en">nuint</span>)<span class="pl-smi">dest</span><span class="pl-k">&lt;</span><span class="pl-smi">len</span>))
    {
        <span class="pl-k">goto</span><span class="pl-en">PInvoke</span>;
    }

    <span class="pl-smi">byte</span><span class="pl-k">*</span><span class="pl-smi">srcEnd</span><span class="pl-k">=</span><span class="pl-smi">src</span><span class="pl-k">+</span><span class="pl-smi">len</span>;
    <span class="pl-smi">byte</span><span class="pl-k">*</span><span class="pl-smi">destEnd</span><span class="pl-k">=</span><span class="pl-smi">dest</span><span class="pl-k">+</span><span class="pl-smi">len</span>;

    <span class="pl-k">if</span> (<span class="pl-smi">len</span><span class="pl-k">&lt;=</span><span class="pl-c1">16</span>) <span class="pl-k">goto</span><span class="pl-en">MCPY02</span>;
    <span class="pl-k">if</span> (<span class="pl-smi">len</span><span class="pl-k">&gt;</span><span class="pl-c1">64</span>) <span class="pl-k">goto</span><span class="pl-en">MCPY05</span>;

    <span class="pl-en">MCPY00</span>:
    <span class="pl-c"><span class="pl-c">//</span> omitted for brevity</span><span class="pl-en">MCPY01</span>:
    <span class="pl-c"><span class="pl-c">//</span> omitted for brevity</span><span class="pl-en">MCPY02</span>:
    <span class="pl-c"><span class="pl-c">//</span> omitted for brevity</span><span class="pl-en">MCPY03</span>:
    <span class="pl-c"><span class="pl-c">//</span> omitted for brevity</span><span class="pl-en">MCPY04</span>:
    <span class="pl-c"><span class="pl-c">//</span> omitted for brevity</span><span class="pl-en">MCPY05</span>:
    <span class="pl-c"><span class="pl-c">//</span> PInvoke to the native version when the copy length exceeds the threshold.</span><span class="pl-k">if</span> (<span class="pl-smi">len</span><span class="pl-k">&gt;</span><span class="pl-smi">MemmoveNativeThreshold</span>)
        <span class="pl-k">goto</span><span class="pl-en">PInvoke</span>;

    <span class="pl-en">MCPY06</span>:</pre></div><p>Should we test the performance of copying overlapping buffers?</p><ul><li>No, because it's an edge case.</li><li>No, because the same code path is executed for big buffers (<code>len &gt; 64 &amp;&amp; len &gt; MemmoveNativeThreshold</code>)</li></ul><p>What should we test? This method is commonly used, so we should test all four code paths:</p><ul><li>small buffers (<code>len &lt;= 16</code>)</li><li>medium size buffers (<code>len &gt; 16 &amp;&amp; len &lt;= 64</code>)</li><li>big buffers (<code>len &gt; 64 &amp;&amp; len &lt; MemmoveNativeThreshold</code>)</li><li>very big buffers (<code>len &gt; 64 &amp;&amp; len &gt; MemmoveNativeThreshold</code>)</li></ul><p>One important thing is to leave a comment in the source code and explain our decision. So nobody removes an important test case in the future and we don't forget why we added it ourselves. An example:</p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">Params</span>(
    <span class="pl-c1">128</span>, <span class="pl-c"><span class="pl-c">//</span> stackalloc path</span><span class="pl-c1">1024</span><span class="pl-k">*</span><span class="pl-c1">256</span>)] <span class="pl-c"><span class="pl-c">//</span> ArrayPool.Shared.Rent without allocation </span><span class="pl-k">public</span><span class="pl-smi">int</span><span class="pl-smi">Count</span> { <span class="pl-smi">get</span>; <span class="pl-smi">set</span>; }</pre></div><h3><a id="user-content-always-the-same-input-data" class="anchor" aria-hidden="true" href="#always-the-same-input-data"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Always the same input data</h3><p>To allow for apples to apples comparison over time, the input data should be always the same.</p><p><code>ValuesGenerator</code> class from <code>BenchmarkDotNet.Extensions</code> library exposes following methods that guarantee to always produce the same data:</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">T</span><span class="pl-en">GetNonDefaultValue</span>&lt;<span class="pl-en">T</span>&gt;();
<span class="pl-en">T</span>[] <span class="pl-en">ArrayOfUniqueValues</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-k">int</span><span class="pl-smi">count</span>);
<span class="pl-en">T</span>[] <span class="pl-en">Array</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-k">int</span><span class="pl-smi">count</span>);
<span class="pl-en">Dictionary</span>&lt;<span class="pl-en">TKey</span>, <span class="pl-en">TValue</span>&gt; <span class="pl-en">Dictionary</span>&lt;<span class="pl-en">TKey</span>, <span class="pl-en">TValue</span>&gt;(<span class="pl-k">int</span><span class="pl-smi">count</span>)</pre></div><p>As of today, the <code>T</code> can be: <code>byte</code>, <code>char</code>, <code>int</code>, <code>double</code>, <code>bool</code> and <code>string</code>. Extending <code>T</code> to more types is very welcomed!</p><p><strong>Note:</strong><code>ValuesGenerator</code> is simply always creating a new instance of <code>Random</code> with a constant seed. It's a crucial component and its correctness is verified using  <a href="https://github.com/dotnet/performance/blob/master/src/tests/harness/BenchmarkDotNet.Extensions.Tests/UniqueValuesGeneratorTests.cs">Unit Tests</a>.</p><p><strong>Note:</strong> Please don't use <code>Random</code> directly in the benchmarks, do use <code>ValuesGenerator</code> and extend it with missing features when needed.</p><h3><a id="user-content-benchmarkdotnet-1" class="anchor" aria-hidden="true" href="#benchmarkdotnet-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BenchmarkDotNet</h3><h4><a id="user-content-arguments" class="anchor" aria-hidden="true" href="#arguments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments</h4><p><code>[Arguments]</code> is xUnit's <code>[InlineData]</code> counterpart.</p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">Benchmark</span>]
[<span class="pl-en">Arguments</span>(<span class="pl-c1">100</span>)]
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Method</span>(<span class="pl-k">int</span><span class="pl-smi">length</span>)</pre></div><p><strong>Note:</strong> BenchmarkDotNet supports passing arguments by <code>ref</code> to the benchmarked method.</p><h4><a id="user-content-params" class="anchor" aria-hidden="true" href="#params"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Params</h4><p>If you need to use the argument in the setup method, then instead of using <code>Arguments</code> you should use <code>Params</code>. A <code>[Params]</code> field|property can be accessed during the setup/cleanup (<a href="https://benchmarkdotnet.org/Advanced/Params.htm" rel="nofollow">docs</a>). Example:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">int</span>[] <span class="pl-smi">_array</span>;

[<span class="pl-en">Params</span>(
    <span class="pl-c1">100</span>, <span class="pl-c"><span class="pl-c">//</span> comment explaining why it's needed to have this test case</span><span class="pl-c1">1_000</span>, <span class="pl-c"><span class="pl-c">//</span> comment explaining why it's needed to have this test case</span><span class="pl-c1">10_000</span>)] <span class="pl-c"><span class="pl-c">//</span> comment explaining why it's needed to have this test case</span><span class="pl-k">public</span><span class="pl-smi">int</span><span class="pl-smi">Size</span> { <span class="pl-smi">get</span>; <span class="pl-smi">set</span>; }

[<span class="pl-en">GlobalSetup</span>]
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">PrepareArray</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">_array</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">int</span>[<span class="pl-smi">Size</span>];</pre></div><p>However, <strong><code>[Params]</code> are applied to all the benchmarks in given class</strong>. So if few benchmarks require different <code>[Params]</code> values they have to be split into separate types (current BenchmarkDotNet implementation limitation).</p><h4><a id="user-content-argumentssource" class="anchor" aria-hidden="true" href="#argumentssource"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ArgumentsSource</h4><p><code>[ArgumentsSource]</code> is xUnit's <code>[MemberData]</code> counterpart.</p><div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> for single argument it's an IEnumerable of objects (object), not IEnumerable of arrays of objects (object[])</span><span class="pl-k">public</span><span class="pl-en">IEnumerable</span>&lt;<span class="pl-k">object</span>&gt; <span class="pl-en">Cultures</span>()
{
    <span class="pl-k">yield</span><span class="pl-k">return</span><span class="pl-k">new</span><span class="pl-en">CultureInfo</span>(<span class="pl-s"><span class="pl-pds">"</span>fr<span class="pl-pds">"</span></span>);
    <span class="pl-k">yield</span><span class="pl-k">return</span><span class="pl-k">new</span><span class="pl-en">CultureInfo</span>(<span class="pl-s"><span class="pl-pds">"</span>da<span class="pl-pds">"</span></span>);
    <span class="pl-k">yield</span><span class="pl-k">return</span><span class="pl-k">new</span><span class="pl-en">CultureInfo</span>(<span class="pl-s"><span class="pl-pds">"</span>ja<span class="pl-pds">"</span></span>);
    <span class="pl-k">yield</span><span class="pl-k">return</span><span class="pl-k">new</span><span class="pl-en">CultureInfo</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>);
}

[<span class="pl-en">Benchmark</span>]
[<span class="pl-en">ArgumentsSource</span>(<span class="pl-k">nameof</span>(<span class="pl-smi">Cultures</span>))]
<span class="pl-k">public</span><span class="pl-en">DateTime</span><span class="pl-en">Parse</span>(<span class="pl-en">CultureInfo</span><span class="pl-smi">cultureInfo</span>)
    <span class="pl-k">=&gt;</span><span class="pl-smi">DateTime</span>.<span class="pl-en">Parse</span>(<span class="pl-s"><span class="pl-pds">"</span>10/10/2010 12:00:00 AM<span class="pl-pds">"</span></span>, <span class="pl-smi">cultureInfo</span>);</pre></div><p><strong>Note:</strong> If you need to use the argument in the setup method, then instead of using <code>ArgumentsSource</code> you should use <code>ParamsSource</code>.</p><p><strong>Note:</strong><code>[ArgumentsSource]</code> methods are only called once per execution of the benchmark, and the cached results are used per invocation.</p><p><strong>Note:</strong> the time spent for initializing an argument is not included in the time reported by the harness. It means that you can have a custom complex type with initialization logic in it's ctor and setup the benchmark in that way:</p><p>An example from <a href="https://github.com/dotnet/performance/blob/d13b517422b40c2c4e0c78934a5e1c4b54420372/src/benchmarks/micro/corefx/System.Drawing/Perf_Image_Load.cs#L71-L85">System.Drawing.Perf_Image_Load</a></p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">Benchmark</span>]
[<span class="pl-en">ArgumentsSource</span>(<span class="pl-k">nameof</span>(<span class="pl-smi">ImageFormats</span>))]
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Bitmap_FromStream</span>(<span class="pl-en">ImageTestData</span><span class="pl-smi">format</span>)
{
    <span class="pl-k">using</span> (<span class="pl-k">new</span><span class="pl-en">Bitmap</span>(<span class="pl-smi">format</span>.<span class="pl-smi">Stream</span>))
    {
    }
}

<span class="pl-k">public</span><span class="pl-en">IEnumerable</span>&lt;<span class="pl-k">object</span>&gt; <span class="pl-en">ImageFormats</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">return</span><span class="pl-k">new</span> [] 
{
    <span class="pl-k">new</span><span class="pl-en">ImageTestData</span>(<span class="pl-smi">ImageFormat</span>.<span class="pl-smi">Bmp</span>),
    <span class="pl-k">new</span><span class="pl-en">ImageTestData</span>(<span class="pl-smi">ImageFormat</span>.<span class="pl-smi">Jpeg</span>),
    <span class="pl-k">new</span><span class="pl-en">ImageTestData</span>(<span class="pl-smi">ImageFormat</span>.<span class="pl-smi">Png</span>),
    <span class="pl-k">new</span><span class="pl-en">ImageTestData</span>(<span class="pl-smi">ImageFormat</span>.<span class="pl-smi">Gif</span>)
};

<span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">ImageTestData</span>
{
    <span class="pl-k">public</span><span class="pl-en">Stream</span><span class="pl-smi">Stream</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">private</span><span class="pl-k">string</span><span class="pl-smi">FormatName</span> { <span class="pl-k">get</span>; }

    <span class="pl-k">public</span><span class="pl-en">ImageTestData</span>(<span class="pl-en">ImageFormat</span><span class="pl-smi">format</span>)
    {
        <span class="pl-smi">Stream</span><span class="pl-k">=</span><span class="pl-en">CreateTestImage</span>(<span class="pl-smi">format</span>); <span class="pl-c"><span class="pl-c">//</span> another way to setup your benchmark(s)</span><span class="pl-smi">FormatName</span><span class="pl-k">=</span><span class="pl-smi">format</span>.<span class="pl-en">ToString</span>();
    }

    <span class="pl-c"><span class="pl-c">//</span> the value returned by ToString is used in the text representation of Benchmark ID in our reporting system</span><span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">string</span><span class="pl-en">ToString</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">FormatName</span>;

    <span class="pl-k">private</span><span class="pl-k">static</span><span class="pl-en">Stream</span><span class="pl-en">CreateTestImage</span>(<span class="pl-en">ImageFormat</span><span class="pl-smi">format</span>)
    <span class="pl-c"><span class="pl-c">//</span> omitted for brevity</span>
}</pre></div><h4><a id="user-content-generic-benchmarks" class="anchor" aria-hidden="true" href="#generic-benchmarks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generic benchmarks</h4><p>BenchmarkDotNet supports generic classes. It allows for having a dedicated test case for Value and Reference Types.</p><p>An example from <a href="https://github.com/dotnet/performance/blob/dabac287ff09d06c756ee316e4dfe28c78698635/src/benchmarks/micro/coreclr/System.Reflection/Activator.cs">Activator</a> benchmarks:</p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">GenericTypeArguments</span>(<span class="pl-k">typeof</span>(<span class="pl-en">EmptyStruct</span>))] <span class="pl-c"><span class="pl-c">//</span> value type</span>
[<span class="pl-en">GenericTypeArguments</span>(<span class="pl-k">typeof</span>(<span class="pl-en">EmptyClass</span>))] <span class="pl-c"><span class="pl-c">//</span> reference type</span><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">Activator</span>&lt;<span class="pl-en">T</span>&gt;
{
    [<span class="pl-en">Benchmark</span>]
    <span class="pl-k">public</span><span class="pl-en">T</span><span class="pl-en">CreateInstanceGeneric</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">System</span>.<span class="pl-smi">Activator</span>.<span class="pl-en">CreateInstance</span>&lt;<span class="pl-en">T</span>&gt;();

    [<span class="pl-en">Benchmark</span>]
    <span class="pl-k">public</span><span class="pl-k">object</span><span class="pl-en">CreateInstanceType</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">System</span>.<span class="pl-smi">Activator</span>.<span class="pl-en">CreateInstance</span>(<span class="pl-k">typeof</span>(<span class="pl-en">T</span>));
}

<span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">EmptyClass</span> { }
<span class="pl-k">public</span><span class="pl-k">struct</span><span class="pl-en">EmptyStruct</span> { }</pre></div><h2><a id="user-content-best-practices" class="anchor" aria-hidden="true" href="#best-practices"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Best Practices</h2><h3><a id="user-content-single-responsibility-principle" class="anchor" aria-hidden="true" href="#single-responsibility-principle"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Single Responsibility Principle</h3><p>The benchmarks should follow the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="nofollow">Single Responsibility Principle</a> as other methods do. It means that a single benchmark should do a single thing.</p><p>An example of a benchmark that violates the rule:</p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">Benchmark</span>]
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">CompressDecompress</span>(<span class="pl-k">bool</span><span class="pl-smi">compress</span>, <span class="pl-en">Stream</span><span class="pl-smi">compressionStream</span>, <span class="pl-k">byte</span>[] <span class="pl-smi">uncompressedData</span>)
{
    <span class="pl-k">if</span> (<span class="pl-smi">compress</span>)
    {
        <span class="pl-smi">compressionStream</span>.<span class="pl-en">Write</span>(<span class="pl-smi">uncompressedData</span>, <span class="pl-c1">0</span>, <span class="pl-smi">uncompressedData</span>.<span class="pl-smi">Length</span>);
    }
    <span class="pl-k">else</span>
    {
        <span class="pl-smi">compressionStream</span>.<span class="pl-en">Read</span>(<span class="pl-smi">uncompressedData</span>, <span class="pl-c1">0</span>, <span class="pl-smi">uncompressedData</span>.<span class="pl-smi">Length</span>);
    }
}</pre></div><p>In this case, there should be one benchmark for compression and another for the decompression.</p><h3><a id="user-content-no-side-effects" class="anchor" aria-hidden="true" href="#no-side-effects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>No Side-Effects</h3><p>Let's consider following benchmark:</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">List</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-smi">_numbers</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">List</span>&lt;<span class="pl-k">int</span>&gt;();

[<span class="pl-en">Benchmark</span>]
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Add</span>() <span class="pl-k">=&gt;</span><span class="pl-smi">_numbers</span>.<span class="pl-en">Add</span>(<span class="pl-c1">12345</span>);</pre></div><p>In this particular benchmark, the list is growing with every benchmark invocation. <code>List&lt;T&gt;</code> is internally using an <code>Array</code> to store all the elements. When the array is not big enough to store one more element, a two times bigger array is allocated and all elements are copied from the old array to the new one. It means that every next <code>Add</code> operation takes more time. We might also get <code>OutOfMemoryException</code> at some point in time.</p><p><strong>Benchmarks should not have any side effects</strong>.</p><h3><a id="user-content-dead-code-elimination" class="anchor" aria-hidden="true" href="#dead-code-elimination"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dead Code Elimination</h3><p>To prevent from <a href="https://en.wikipedia.org/wiki/Dead_code_elimination" rel="nofollow">dead code elimination</a> BenchmarkDotNet consumes the result returned from a benchmark and writes it to a <code>volatile</code> field (<a href="https://github.com/dotnet/BenchmarkDotNet/blob/94863ab4d024eca04d061423e5aad498feff386b/src/BenchmarkDotNet/Engines/Consumer.cs">code</a>).</p><p>The only thing that you need to remember is to <strong>return the result from the benchmark</strong>. This is required practice even if you know that the JIT will not eliminate code in a particular case.</p><h3><a id="user-content-loops" class="anchor" aria-hidden="true" href="#loops"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Loops</h3><p>BenchmarkDotNet does not require the user to provide the number of <strong>invocations per iteration</strong>. This value is determined by BenchmarkDotNet during the Pilot Experiment Stage, based on the <code>IterationTime</code> setting.</p><p>It means, that you don't have to write a loop inside the benchmark and repeat the operation many times. The harness is going to do this for you.</p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">Benchmark</span>]
[<span class="pl-en">Arguments</span>(<span class="pl-s"><span class="pl-pds">"</span>12345<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">ParseOk</span>(<span class="pl-k">string</span><span class="pl-smi">value</span>) <span class="pl-k">=&gt;</span><span class="pl-smi">int</span>.<span class="pl-en">Parse</span>(<span class="pl-smi">value</span>);

[<span class="pl-en">Benchmark</span>]
[<span class="pl-en">Arguments</span>(<span class="pl-s"><span class="pl-pds">"</span>12345<span class="pl-pds">"</span></span>)]
<span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">ParseNotOk</span>(<span class="pl-k">string</span><span class="pl-smi">value</span>)
{
    <span class="pl-k">int</span><span class="pl-smi">result</span><span class="pl-k">=</span><span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>; <span class="pl-smi">i</span><span class="pl-k">&lt;</span><span class="pl-c1">1000</span>; <span class="pl-smi">i</span><span class="pl-k">++</span>)
    {
        <span class="pl-smi">result</span><span class="pl-k">+=</span><span class="pl-smi">int</span>.<span class="pl-en">Parse</span>(<span class="pl-smi">value</span>);
    }
    <span class="pl-k">return</span><span class="pl-smi">result</span>;
}</pre></div><p>By relying on the BDN mechanism you are going to avoid loop alignment issues. BenchmarkDotNet handles that on its own side when your benchmark does not have a loop.</p><h3><a id="user-content-method-inlining" class="anchor" aria-hidden="true" href="#method-inlining"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Method Inlining</h3><p>BenchmarkDotNet prevents from inlining the benchmarked method by wrapping it into a delegate (delegates can not be inlined as of today). The cost of delegate invocation is excluded by a separate run for Overhead calculation.</p><p>The benchmark methods don't need to have <code>[MethodImpl(MethodImplOptions.NoInlining)]</code> attribute applied.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>