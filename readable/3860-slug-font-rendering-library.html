<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Slug Font Rendering Library -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook" xmlns=""><div id="readInner" class="margin-medium size-medium"><h1>Slug Font Rendering Library</h1><div><div><p xmlns="http://www.w3.org/1999/xhtml">
	Dynamic GPU Font Rendering and Advanced Text Layout
</p><div class="content" xmlns="http://www.w3.org/1999/xhtml"><p><b>Slug</b> is a professional software library for rendering high-quality, resolution-independent text and vector graphics
	in 3D applications on the GPU. It can be used for drawing graphical user interfaces, rendering heads-up displays,
	showing debugging information, and placing text inside a 3D world or virtual environment.</p><p>Slug renders shapes on the GPU directly from outline data composed of quadratic Bézier curves to produce
	crisp text at any scale or from any perspective. There are no precomputed texture images or signed distance fields. Slug uses a
	<a href="http://jcgt.org/published/0006/02/02/">breakthrough mathematical algorithm</a> that we invented to achieve perfect robustness
	with high performance, and it is the <i>only</i> existing GPU method that renders properly antialiased glyphs with no
	artifacts under both magnification and minification.</p><p>Slug also provides text layout services that calculate the positions of the glyphs that would be drawn for a given
	string of Unicode characters. In addition to basic bounding box and advance width calculations, it can perform kerning,
	ligature replacement, combining diacritical mark placement, character composition, and alternate substitution.
	More high-level information is available on the <a href="slug.pdf">Slug fact sheet</a>.</p><p>Although Slug was originally designed only to render text, it can now draw arbitrary vector graphics using the same
	technology. Complex diagrams and vector drawings can be rendered at blazingly fast speeds directly on the GPU with
	total resolution independence.</p><p>The full set of features provided by Slug is described in the <a href="SlugManual.pdf">Slug User Manual</a>.</p></div><div class="section" xmlns="http://www.w3.org/1999/xhtml"><div class="content"><h2>Demo</h2><p>A demo of the Slug library for Windows is available here:</p><p><b><a href="SlugDemo.zip">Download Slug Demo</a></b><br><span>(Updated 5-Feb-2020)</span></p><p>The demo contains several pages of text and vector graphics that highlight rendering capabilities and typographic features.
		On most pages, left-clicking and dragging will scroll the scene, right-clicking and dragging will rotate the scene,
		and moving the mouse wheel will zoom in and out.</p><p>The text on the fifth page of the demo can be changed by placing a file named <code>story.txt</code> in the same folder
		as the demo application. This text file should be encoded as UTF-8, and up to 64 lines of it will be rendered in the demo.
		The font used for this text is <code>story.slug</code> in the <code>Fonts</code> folder. By default, this is just a copy
		of the Arial font, but you can change it by using the <code>slugfont</code> tool to import another TTF file. To do so,
		copy the TTF file into the <code>Fonts</code> folder, and execute the following command line with the actual font name:</p><p><code>slugfont &lt;fontname&gt;.ttf -o story.slug</code></p></div></div><div class="content" xmlns="http://www.w3.org/1999/xhtml"><h2>Glyph Rendering</h2><img src="glyph.png"><p>Each glyph is rendered by drawing a quad that covers its bounding box. (Because it’s only a box, it can be clipped or subdivided
	to match another surface inside a 3D environment.) A specialized shader efficiently determines how much each pixel inside the box
	is covered by the glyph using the original Bézier curve data stored in the font. Because no precomputed images or distance fields
	are involved, the result is a sharp outline at all resolutions with no faceting or blurring. Slug has the ability to apply a couple
	speed optimizations at large font sizes, one of which is rendering a tight bounding polygon instead of a plain box. The image to
	the right was rendered by Slug using Times New Roman at a 500-pixel font size.</p><img src="emoji.png"><p>In addition to boring old letters and numbers, Slug can render full-color emoji and pictographs with the same
	resolution independence that gives every contour a clean, crisp appearance at any scale. Slug supports the complete set of color
	characters defined by Unicode, and it can handle skin tone modifiers as well as zero-width joiner sequences.</p><p>The image to the left was rendered by Slug using the Segoe UI Emoji font at a 40-pixel size. This font ships with Windows and
	contains color layer data that elegantly provides the ability to scale multicolor emoji and pictographs with the same versatility
	as conventional black-and-white glyphs.</p><br></div><div class="section" xmlns="http://www.w3.org/1999/xhtml"><div class="content"><h2>Text Layout</h2><p>Given a string of Unicode characters, Slug can lay out a line of text and produce the vertex data needed to render all of the corresponding glyphs.
		In the process, Slug can optionally apply kerning, ligature replacement, combining diacritical mark placement, and character composition.
		Slug also supports a number of OpenType features that include stylistic alternates, small caps, oldstyle figures, subscripts, superscripts,
		case-sensitive punctuation, and fractions.</p><table><tbody><tr><td class="left"><i>Kerning</i> is a subtle process by which spacing between characters is adjusted to create a cleaner, more consistent appearance.
				In the image to the right, the top line is drawn without kerning, and the bottom line is drawn with kerning. Notice how
				the o and a are moved slightly to the left to fill in the empty space under the T and the W. Also, the period and closing
				quotation mark are moved in because there is space to do so.
			</td><td class="right"><img src="kern.png"></td></tr><tr><td class="left">
				Ligature replacement is the process by which a special glyph called a <i>ligature</i> is drawn in place of a specific sequence of
				two or more ordinary glyphs. This is often done for pairs of characters that frequently appear next to each other and tend to
				touch or overlap slightly. In the image to the right, ligatures for Th, fi, and ffl are provided by the font, and they
				are rendered as a total of three glyphs in the bottom line, whereas seven separate glyphs are rendered in the top line.
			</td><td class="right"><img src="liga.png"></td></tr><tr><td class="left">
				Unicode defines many different <i>combining marks</i> that are intended to be attached to the closest preceding base glyph.
				Combining marks can be attached to multiple points on a base glyph or even to other combining marks at specific locations defined
				by the font. This allows accents and other types of symbols to be drawn with characters that may not have a precomposed equivalent
				in Unicode. The image to the right shows several combining marks that are automatically placed in the right position and stacked
				on top of each other.
			</td><td class="right"><img src="mark.png"></td></tr><tr><td class="left">
				Some fonts, especially those that contain emoji, define <i>character composition</i> sequences that allow specific groups of
				glyphs to be replaced by new glyphs that represent the meanings of those sequences. Unicode defines a set of skin tone modifiers
				and zero-width joiner sequences that rely on this feature. In the image to the right, the top line shows the individual glyphs
				before composition, and the bottom line shows the composed glyphs that replace those sequences.
			</td><td class="right"><img src="join.png"></td></tr></tbody></table></div></div><div class="content" xmlns="http://www.w3.org/1999/xhtml"><h2>The Product</h2><p>Slug is distributed as a static library that has a basic C++ interface, and full source is included with every license. Slug is platform agnostic
	and runs on Windows, Mac, Linux, iOS, Android, and game consoles. It can be used with Direct3D 10/11/12, OpenGL 3.0+, Vulkan, Metal, and WebGL2.
	The API is fully documented in the <a href="SlugManual.pdf">Slug User Manual</a>.</p><p>The primary function of Slug is to take a Unicode string (encoded as UTF-8), lay out the corresponding glyphs, and generate a vertex buffer
	containing the data needed to draw them. When text is rendered, your application binds the vertex buffer, one of our glyph shaders, and two texture
	maps associated with the font. One texture holds all of the Bézier curve data, and the other texture holds spatial data structures that Slug uses
	for efficient rendering.</p><p>Slug renders each glyph as a single quad. (There is also an optimization that uses a tighter polygon having up to eight vertices that can
	be enabled to increase speed at larger sizes.) This has the advantage that it’s easy to clip to an irregular shape or project onto a
	curved surface in a 3D environment. It also means that vertex buffer storage requirements do not depend on the complexity of the glyphs.</p><p>Slug comes with a standalone tool that reads both the TrueType and PostScript flavors of the OpenType format (having <code>.ttf</code> and <code>.otf</code>
	file extensions, respectively) and generates a new file with the <code>.slug</code> extension containing all of the information necessary to render the font
	on the GPU. The <code>.slug</code> file includes the original glyph outline data, optimization data used by the glyph shader, kerning data, join sequence data,
	mark attachment data, and color layer data. A <code>.slug</code> file may contain a subset of the original font so that unneeded characters do not take up
	any space. The data used for kerning, join sequences, mark attachments, and color layers is all optional.</p><p>The technical details about how the Slug algorithm works and how the data is organized in <code>.slug</code> files are
	discussed in a paper by Eric Lengyel in the <a href="http://jcgt.org/published/0006/02/02/">Journal of Computer Graphics Techniques</a>.
	There is also a detailed <a href="http://terathon.com/i3d2018_lengyel.pdf">slide presentation</a> about the Slug algorithm.</p></div><div class="section" xmlns="http://www.w3.org/1999/xhtml"><div class="content"><h2>Licensing</h2><p>We have many flexible licensing options available for a wide range of applications and budgets. Slug can be licensed on a per-title basis, or it can
		be licensed once for every product you make until the end of time. Our support options range from questions over email to a two-day on-site visit from the
		guy who actually built the thing. We’re open to negotiating any other reasonable terms as well. We recognize that many situations are unique, and we
		are prepared to tailor a license specifically to your company’s needs. Please <a href="mailto:lengyel@terathon.com">contact us</a> to get the ball
		rolling. (At this time, we are licensing only to companies.)</p></div></div><div class="content" xmlns="http://www.w3.org/1999/xhtml"><h2>Why the name “Slug”?</h2><p>A slug is what they used to call a full line of text cast as one piece of hot lead by a <a href="https://en.wikipedia.org/wiki/Linotype_machine">Linotype machine</a>.
	The primary function of our software is to lay out and render lines of text.</p></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>