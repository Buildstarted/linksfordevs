<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Stable Filtering &#x2014; Part 1 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Stable Filtering &nbsp;—&nbsp; Part 1</h1><div><div class="s"><p class="readability-styled" style="display: inline;">Since I just finished shipping the web infrastructure for our new web comic </p><a class="B" href="https://meowtheinfinite.com/">Meow the Infinite</a><p class="readability-styled" style="display: inline;">, I thought it might be a good time to take a break and write up some long-overdue tech articles.  This one is about a filter I designed several years ago, but which does something I’ve never seen discussed in the video compression field, even though it seems like it really should have been.
</p><p class="readability-styled" style="display: inline;">Way back in 2011, I designed a “half-pel filter”.  This is a special kind of filter that’s supposed to take an input image and create, as convincingly as possible, what that image would look like if it were shifted </p><i>exactly half a pixel over</i><p class="readability-styled" style="display: inline;">.
</p><p class="readability-styled" style="display: inline;">You are probably wondering why anyone would need such a filter.  Well, it turns out they are actually quite common in modern video codecs.  Video codecs use filters like this to grab pieces of previous frames and use them in later frames.  Older codecs used to move frame data only by whole pixels at a time, but newer codecs get fancier and allow half-pixel and quarter-pixel shifting to better handle subtle motions.
</p><p class="readability-styled" style="display: inline;">While analyzing the behavior of motion compensation algorithms using traditional half-pel filter designs, </p><a class="B" href="https://mollyrocket.com/news_0007">Jeff Roberts</a><p class="readability-styled" style="display: inline;"> found they degraded quickly when applied repeatedly to successive frames, forcing the other parts of the video compressor to use more data than necessary to correct the artifacts.  If he turned off these corrections, and just looked at the raw half-pel filter results, it would take an image like this:
</p></div><div class="s"><p class="readability-styled" style="display: inline;">after only a single second of video.  It slid to the side like it should, since each frame moved the image a half pixel over.  But instead of looking like a displaced version of the original image, the result appeared severely mangled.
</p><p class="readability-styled" style="display: inline;">Now, a “single second of video” is actually a lot of filter applications &nbsp;—&nbsp; 60 of them, actually, if it’s at 60 frames per second.  But ideally we’d have filters that stand up to this kind of abuse.  If we did, smoothly-scrolling videos wouldn’t have to be encoded with as many artifact corrections, so they’d be smaller, or higher quality, or both.
</p><p class="readability-styled" style="display: inline;">If you’re familiar with video compression, you might rightfully be wondering why you need to apply a half-pel filter more than once anyway.  After all, if you do two half-pel filter applications, you’ve moved by one whole pixel, so why not just use the data from </p><i>two</i><p class="readability-styled" style="display: inline;"> frames ago and grab </p><i>that</i><p class="readability-styled" style="display: inline;">?
</p><p class="readability-styled" style="display: inline;">Well, the answer is two-fold.  First, the more data you need to encode for the fetch, the less compression you get.  So if you start having to encode lots of “which frame to grab from” data unnecessarily, you won’t compress as well.
</p><p class="readability-styled" style="display: inline;">But that’s not that big a deal.  The real issue is that if you need to grab from prior frames, </p><i>you have to store them</i><p class="readability-styled" style="display: inline;">.  Storing 2 prior frames instead of 1 uses, as you might guess, twice as much memory.  This isn’t a big deal on a modern CPU that has tons of memory and just wouldn’t care.  But it </p><i>is</i><p class="readability-styled" style="display: inline;"> a big deal if you’re trying to be a fast, portable, widely applicable video format that wants to run on devices where memory is tight (cell phones, embedded hardware, etc.)
</p><p class="readability-styled" style="display: inline;">For our purposes, we really didn’t want to have to store multiple frames for motion compensation just to work around the half-pel filter.  So I was tasked to find out exactly what was going on here, and see if I could design a filter that wouldn’t have these problems.
</p><p class="readability-styled" style="display: inline;">I had never looked at filters before at all &nbsp;—&nbsp; literally.  I had no idea how people typically designed them.  Strangely enough, this turned out to be a good thing, because it meant I looked at the problem without a lot of preconceived notions.
</p></div><div class="s"><p class="readability-styled" style="display: inline;">What you’ll learn very quickly if you look into half-pel filter design is that the common ones all take the same form: somewhere between 2 and 8 pixels of the input image are sampled and blended together at specific ratios to produce each pixel in the output image.  They differ only by how many input pixels they use (often called “taps” in filter slang) and the ratios at which those pixels are blended.  These ratios are often called the “filter kernel”, and it’s all you need to completely define the filter.
</p><p class="readability-styled" style="display: inline;">If you’re familiar with any kind of image sampling or resampling (like image scaling), then this should sound familiar to you.  The filters are basically the same.  Since video compression is a broad field with lots of research in it, there are obviously many </p><i>other</i><p class="readability-styled" style="display: inline;"> ways people do motion compensation that has nothing to do with simple filtering.  But the codecs in common use tend to have motion compensation routines that include half-pel filters that are basically the same as image scaling filters: you just take your input pixels, multiply them by some weights, add them together, and you’ve got your output pixels.
</p></div><div class="s"><p class="readability-styled" style="display: inline;">OK, so you need to shift an image by a half a pixel.  If you’re a graphics programmer, but you’re not particularly familiar with filtering, you might be thinking, “big deal, just bilinearly filter it”.  That’s a standard thing we do in graphics when we need to produce in-between values from two inputs, like we’re doing here.
</p><p class="readability-styled" style="display: inline;">A bilinear filter for an exact half-pixel movement is easy to describe as a filter kernel &nbsp;—&nbsp; it’s just this:
</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>