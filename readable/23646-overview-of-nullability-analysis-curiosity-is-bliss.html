<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Overview of nullability analysis &#xB7; Curiosity is bliss -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Overview of nullability analysis · Curiosity is bliss</h1><div><div id="" class="post"><time datetime="2019-05-14T00:00:00-07:00" class="post-date">14 May 2019</time>&nbsp; 
  <p>A regular Roslyn contributor, <a href="https://github.com/YairHalberstadt">Yair</a>, asked for some pointers about C# 8.0’s nullability analysis on the <a href="https://gitter.im/dotnet/roslyn">gitter</a> channel. I thought I’d expand on my reply and share it more broadly.</p><p>This post assumes familiarity with the “nullable reference types” feature, including the concepts of nullability <a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/nullable-reference-types-specification.md#nullability-of-types">annotations</a> (annotated, not-annotated, oblivious) and <a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/nullable-reference-types-specification.md#null-state-and-null-tracking">states</a> (not-null, maybe-null).</p><h2 id="bound-trees">Bound trees</h2><p>The backbone of the compiler consists of four main stages:</p><ul><li><em>parsing</em> source code into syntax trees,</li><li>building symbols from declarations and <em>binding</em> the syntax of each method body into an initial bound tree,</li><li><em>lowering</em> the bound tree into a set of simpler bound nodes,</li><li><em>emitting</em> IL from the lowered bound nodes, along with some metadata.</li></ul><p>Nullability analysis rests on the initial bound tree. This tree has a structure similar to the syntax tree, but instead of referencing un-interpreted identifiers (like <code class="language-plaintext highlighter-rouge">x</code> or <code class="language-plaintext highlighter-rouge">Method</code>) it references symbols. Symbols are an object model for entities declared by a program or loaded from metadata. 
For example, symbols allow differentiating different uses of a given identifier in code. You could have a parameter <code class="language-plaintext highlighter-rouge">x</code>, a local <code class="language-plaintext highlighter-rouge">x</code>, a type <code class="language-plaintext highlighter-rouge">x</code> or even a method <code class="language-plaintext highlighter-rouge">x</code>. For each kind of symbol you can ask different questions, such as the type of the parameter or local, or the return and parameter types of a method.</p><p>When types are explicit in source (for example, <code class="language-plaintext highlighter-rouge">string nonNullLocal = "";</code>, <code class="language-plaintext highlighter-rouge">string? maybeNullLocal = "";</code> or <code class="language-plaintext highlighter-rouge">MakeArray&lt;string?&gt;(item)</code>), the bound nodes and symbols capture an explicit/declared nullability: <code class="language-plaintext highlighter-rouge">TypeWithAnnotations</code> with <code class="language-plaintext highlighter-rouge">Annotated</code> or <code class="language-plaintext highlighter-rouge">NotAnnotated</code> annotations in a <a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/nullable-reference-types-specification.md#nullable-contexts">context</a> with nullability annotations enabled, or <code class="language-plaintext highlighter-rouge">Oblivious</code> in a disabled context.</p><p>When types are inferred (for example, in <code class="language-plaintext highlighter-rouge">var local = "";</code> or <code class="language-plaintext highlighter-rouge">MakeArray(item)</code>), the bound node just uses an <code class="language-plaintext highlighter-rouge">Oblivious</code> annotation, which the nullability analysis will later revise.</p><h2 id="nullablewalker">NullableWalker</h2><p><a href="https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/FlowAnalysis/NullableWalker.cs"><code class="language-plaintext highlighter-rouge">NullableWalker</code></a> is responsible for most of the analysis. It is a visitor for the initial bound tree, which:</p><ol><li>computes the nullability state of expressions (and save those to answer queries from the IDE),</li><li>keeps track of knowledge for different variables (more on that below), and</li><li>produces warnings.</li></ol><h2 id="state-tracking">State tracking</h2><p>As the analysis progresses through a method body, <code class="language-plaintext highlighter-rouge">NullableWalker</code> tracks some knowledge for each variable (or more generally, storage location). At a certain point in the analysis, the state for a given variable is either <code class="language-plaintext highlighter-rouge">MaybeNull</code> or <code class="language-plaintext highlighter-rouge">NotNull</code>.
For all the tracked variables, this is represented as a state array, in which each variable gets an index/position/slot.</p><p>For instance, each parameter and local in a method gets a slot, which holds either a <code class="language-plaintext highlighter-rouge">NotNull</code> or <code class="language-plaintext highlighter-rouge">MaybeNull</code> state. Consider a parameter <code class="language-plaintext highlighter-rouge">string? p1</code>: we give it a slot/index and we’ll initialize its state to maybe-null (ie. <code class="language-plaintext highlighter-rouge">State[slot] = MaybeNull</code>, because its declared type is <code class="language-plaintext highlighter-rouge">Annotated</code>), then when we visit <code class="language-plaintext highlighter-rouge">p1 = "";</code> we can just override that state, and when we visit <code class="language-plaintext highlighter-rouge">p1.ToString()</code> we consult that state to decide whether to warn for possible null dereference.</p><p><code class="language-plaintext highlighter-rouge">NullableWalker</code> not only tracks variables, it also tracks fields, so it assigns slots for those too. That way, it can warn on <code class="language-plaintext highlighter-rouge">localStruct.field1.ToString()</code>, but not <code class="language-plaintext highlighter-rouge">localStruct.field2.ToString()</code> independently.
Such nested slots are known to have a containing slot. With that information, we can look at an assignment like <code class="language-plaintext highlighter-rouge">local2 = local1;</code> and we can not only copy the slot for <code class="language-plaintext highlighter-rouge">local1</code> to set the state of <code class="language-plaintext highlighter-rouge">local2</code>, but we can copy the nested slots thereby transfering all of our knowledge of <code class="language-plaintext highlighter-rouge">local1</code> to <code class="language-plaintext highlighter-rouge">local2</code>.</p><p>The state is generally just a simple array, but it can also be two arrays in some cases. That’s called “conditional state”. It is used for analyzing expressions like <code class="language-plaintext highlighter-rouge">x == null</code>. We keep track of the states “if the expression were true” and “if the expression were false” separately. Slots are still used to index into those arrays as normal.</p><p>Cloning states is another common operation. When analyzing <code class="language-plaintext highlighter-rouge">if (b) ... else ...</code>, we clone the state so that we can analyze each branch separately. We can merge those states when the branches rejoin (<code class="language-plaintext highlighter-rouge">Meet</code> takes the worst case values). That gives us the state following the <code class="language-plaintext highlighter-rouge">if</code> statement.</p><p>In code that isn’t reachable, as in <code class="language-plaintext highlighter-rouge">if (false) { ... unreachable ...}</code>, every value you read is <code class="language-plaintext highlighter-rouge">NotNull</code> regardless of tracked state to minimize warnings.</p><h2 id="simple-example">Simple example</h2><p>Let’s wrap up this overview by looking at an assignment, <code class="language-plaintext highlighter-rouge">x = y</code>. To analyze this expression, we’re going to:</p><ol><li>visit the right-hand-side expression and get a <code class="language-plaintext highlighter-rouge">TypeWithState</code> back which tells us the null-state of <code class="language-plaintext highlighter-rouge">y</code> at this point in the program,</li><li>visit the left-hand-side expression as an L-value (i.e., for assigning to) and get a <code class="language-plaintext highlighter-rouge">TypeWithAnnotations</code> back which tells us the declared type of <code class="language-plaintext highlighter-rouge">x</code> (not its state),</li><li>we check if the assignment from the state of <code class="language-plaintext highlighter-rouge">y</code> to the declared type of <code class="language-plaintext highlighter-rouge">x</code> poses problems, both in terms of top-level nullability (for instance, are we assigning a <code class="language-plaintext highlighter-rouge">null</code> value to a un-annotated <code class="language-plaintext highlighter-rouge">string</code> variable?), or nested nullability (for example, are we assigning a <code class="language-plaintext highlighter-rouge">List&lt;string&gt;</code> value to a <code class="language-plaintext highlighter-rouge">List&lt;string?&gt;</code> variable?),</li><li>we update the state of <code class="language-plaintext highlighter-rouge">x</code> based on the state of <code class="language-plaintext highlighter-rouge">y</code>,</li><li>return the state of <code class="language-plaintext highlighter-rouge">x</code> as the state of the assignment expression, in case it is a nested expression like <code class="language-plaintext highlighter-rouge">(x = y).ToString()</code>.</li></ol><p>In that example, <code class="language-plaintext highlighter-rouge">y</code> might not be a simple bound node for accessing <code class="language-plaintext highlighter-rouge">y</code>, but it could also involve implicit conversions. In that case, visiting <code class="language-plaintext highlighter-rouge">y</code> at the step (1) will visit a bound conversion which holds <code class="language-plaintext highlighter-rouge">y</code> as its operand. As long as the visit operation for each kind of bound node does its part (i.e., produce a <code class="language-plaintext highlighter-rouge">TypeWithState</code> for the expression, produce proper side effects on state and diagnostics) then this process composes well.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>