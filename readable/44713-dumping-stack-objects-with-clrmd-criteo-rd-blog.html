<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Dumping stack objects with ClrMD - Criteo R&amp;D Blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Dumping stack objects with ClrMD - Criteo R&amp;D Blog</h1><div><div class="ac ae af ag ah ea aj ak"><p id="7ed3" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The SOS extension for WinDbg defines a command, !DumpStackObjects (or !dso), that allows to list all the references on the stack for a given thread. It’s convenient to retrieve the value of arguments or local variables of methods in the callstack. Recently, for an investigation, I ran across the need to dump those values for a few thousand threads. Obviously this is not something you’d want to do by hand, so I checked what was possible to do with ClrMD.</p><p id="534b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">ClrMD defines an <code class="hc hd he hf hg b">EnumerateStackObjects</code> method on the <code class="hc hd he hf hg b">ClrThread</code> object, which seems to do exactly what’s needed. To make sure, we can write this small program and compare the output with the !DumpStackObjects command:</p><figure class="hh hi hj hk hl hm"><p id="fa6b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Let’s see what’s going on here. <code class="hc hd he hf hg b">EnumerateStackObjects</code> returns a list of <code class="hc hd he hf hg b">ClrRoot</code> instances. Those instances represent references. The <code class="hc hd he hf hg b">Address</code> field contains the address of the reference <strong class="gq hr">on the stack</strong>, whereas the <code class="hc hd he hf hg b">Object</code> field contains the address of the object the reference is pointing to (the value you’re likely interested in). If we compare the output of our program with WinDbg, it seems indeed to match:</p><figure class="hh hi hj hk hl hm dm dn paragraph-image"><figcaption class="ax fg if ig ih do dm dn ii ij as cv">ClrMD on the left, WinDbg/SOS on the right</figcaption></figure><p id="c724" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">That is… on Windows. For my investigation, I needed to do the same thing with a Linux coredump. ClrMD is compatible with Linux, so it shouldn’t be a problem, or so I thought. But when I ran the same code on Linux, no stack objects were found.</p><figure class="hh hi hj hk hl hm dm dn paragraph-image"><figcaption class="ax fg if ig ih do dm dn ii ij as cv">LLDB/SOS on the left, ClrMD on the right</figcaption></figure><p id="b943" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Digging into the <code class="hc hd he hf hg b">EnumerateStackObjects</code> implementation, it seems that it gets the address range of the stack by inspecting <code class="hc hd he hf hg b">ClrThread.StackBase</code> and <code class="hc hd he hf hg b">ClrThread.StackLimit</code>, then checks every value in that range to find references. In my case, <code class="hc hd he hf hg b">StackBase</code> and <code class="hc hd he hf hg b">StackLimit</code> both returned 0, so it makes sense that the algorithm would then fail to find anything. So how are <code class="hc hd he hf hg b">StackBase</code> and <code class="hc hd he hf hg b">StackLimit</code> implemented?</p><p id="4c00" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">In ClrMD, <code class="hc hd he hf hg b">StackBase</code> and <code class="hc hd he hf hg b">StackLimit</code> are read from the <a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block" class="da by im in io ip" target="_blank" rel="noopener nofollow">thread environment block (TEB)</a>. The contents of the TEB are retrieved directly from the DAC using the <code class="hc hd he hf hg b">GetThreadData</code> method. If we look at <a href="https://github.com/dotnet/coreclr/blob/d2a8b55d4c944438df1599c9a78262bc48f07266/src/debug/daccess/request.cpp#L752" class="da by im in io ip" target="_blank" rel="noopener nofollow">the implementation of that function in the CoreCLR repository</a>, the problem becomes quite obvious:</p><figure class="hh hi hj hk hl hm"><p id="f474" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv"><code class="hc hd he hf hg b">FEATURE_PAL</code> is defined on all other platforms than Windows. It means that when running .net core on Linux, the TEB information of the thread will be empty. It actually makes sense since TEB is a Windows concept, but then how is the SOS DumpStackObjects function working on Linux?</p><p id="61af" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This time, the answer lies <a href="https://github.com/dotnet/diagnostics/blob/367aa5cd433e5e5a9e128aee5acb8196231ac769/src/SOS/Strike/strike.cpp#L616" class="da by im in io ip" target="_blank" rel="noopener nofollow">in the dotnet/diagnostics repository</a>. Here is a stripped down version with only the interesting bits:</p><figure class="hh hi hj hk hl hm"><p id="7238" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The code starts by getting the current stack pointer from the registers by calling the <code class="hc hd he hf hg b">GetStackOffset</code> method, and assigns it to <code class="hc hd he hf hg b">StackTop</code>. Then, <strong class="gq hr">only on Windows</strong>, it reads the TEB to get the address of the beginning the stack. For other platforms, there’s a fallback code where <code class="hc hd he hf hg b">StackBottom</code> is initialized to <code class="hc hd he hf hg b">StackTop + 0xFFFF</code> if no value has been assigned. This hack puzzles me quite a bit. 0xFFFF (64KB) is much smaller than the default size of the stack, and at the same time I don’t think it offers any guarantee that we won’t read memory outside of the stack (I searched for a while but couldn’t find any evidence that a guard page is allocated above the stack).</p><p id="0dca" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">However surprising it may look, our goal is just to mimic the DumpStackObject output, so can we implement the same logic in ClrMD?</p><p id="d525" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">For that, we need a way to retrieve the value of the RSP register, to get the stack offset. This is done by calling the <code class="hc hd he hf hg b">GetThreadContext</code> method with the id of the thread. It takes as parameter a byte array (or an <code class="hc hd he hf hg b">IntPtr</code>), in which is serialized the contents of a structure representing the registers. That structure is <code class="hc hd he hf hg b">AMD64Context</code>, <code class="hc hd he hf hg b">ArmContext</code>, or <code class="hc hd he hf hg b">Arm64Context</code> depending on the target architecture. In our case, we only care about AMD64:</p><figure class="hh hi hj hk hl hm"><p id="7c43" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Once we have this information, we can start browsing the stack and search for references (the code is shamelessly copied <a href="https://github.com/microsoft/dotnet-samples/blob/master/Microsoft.Diagnostics.Runtime/CLRMD/ClrStack/Program.cs#L81" class="da by im in io ip" target="_blank" rel="noopener nofollow">from the ClrMD samples</a>):</p><figure class="hh hi hj hk hl hm"><p id="bb49" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">We start by trying to dereference any value we find in the stack, then we call <code class="hc hd he hf hg b">ClrHeap.GetObjectType</code> to find if it points to a valid object. If so, we display the result to the console.</p><p id="4bed" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">I tried running this code and it worked fine for a few hundred threads, then it crashed with a segmentation fault. I managed to track it down to a call to <code class="hc hd he hf hg b">ClrHeap.GetObjectType</code> with a specific address. It’s likely that we found a pointer to a value outside of the managed heap, which is causing some unpredictable behavior. How is SOS coping with this? Looking back at <a href="https://github.com/dotnet/diagnostics/blob/master/src/SOS/Strike/util.cpp#L1988" class="da by im in io ip" target="_blank" rel="noopener nofollow">the implementation</a>, it looks like we forgot a sanity check:</p><figure class="hh hi hj hk hl hm"><p id="2aa3" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">With ClrMD, we can achieve the same result by enumerating the GC segments and making sure our address is inside one of those:</p><figure class="hh hi hj hk hl hm"><p id="a08e" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Now we have everything we need to finish our implementation of DumpStackObjects for Linux:</p><figure class="hh hi hj hk hl hm"><p id="062c" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">And this time, we get the same output as the !DumpStackObjects command, as expected:</p><figure class="hh hi hj hk hl hm dm dn paragraph-image"></figure></figure></figure></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>