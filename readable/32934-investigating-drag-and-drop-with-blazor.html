<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Investigating Drag and Drop with Blazor -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Investigating Drag and Drop with Blazor</h1>
    <div class="post-content"> <p>Drag and drop has become a popular interface solution in modern applications. It&apos;s common to find it in productivity tools, great examples of this are Trello, JIRA and Notion. As well as being an intuitive interface for the user, it can definitely add a bit of &quot;eye-candy&quot; to an application.</p><p>We&apos;ve been thinking about incorporating drag and drop into some screens of the product my team are building at work. This has given me a great opportunity to see how drag and drop can be accomplished with Blazor.</p><p>This post is going to cover what I&apos;ve found while I&apos;ve been experimenting and a walk through of a simple prototype app I built to test things out. Below is a sneak peak of the finished prototype.</p><blockquote>The code for this post is <a href="https://github.com/chrissainty/SimpleDragAndDropWithBlazor">available on GitHub</a>.</blockquote><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/08/SimpleDragAndDropWithBlazor.gif" class="kg-image"></figure><h2 id="the-drag-and-drop-api-a-brief-introduction">The drag and drop API - A brief introduction</h2><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API">drag and drop API is part of the HTML5 spec</a> and has been around for a long time now. The API defines a set of events and interfaces which can be used to build a drag and drop interface.</p><h3 id="events">Events</h3><ul><li><code>drag</code><br>Fires when a <em>dragged item</em> (element or text selection) is dragged.</li><li><code>dragend</code><br>Fires when a drag operation ends, such as releasing a mouse button or hitting the Esc key.</li><li><code>dragenter</code><br>Fires when a dragged item enters a valid drop target.</li><li><code>dragexit</code><br>Fires when an element is no longer the drag operation&apos;s immediate selection target.</li><li><code>dragleave</code><br>Fires when a dragged item leaves a valid drop target.</li><li><code>dragover</code><br>Fires when a dragged item is being dragged over a valid drop target, every few hundred milliseconds.</li><li><code>dragstart</code><br>Fires when the user starts dragging an item.</li><li><code>drop</code><br>Fires when an item is dropped on a valid drop target.</li></ul><p>Certain events will only fire once during a drag-and-drop interaction such as <code>dragstart</code> and <code>dragend</code>. However, others will fire repeatedly such as <code>drag</code> and <code>dragover</code>. </p><h3 id="interfaces">Interfaces</h3><p>There are a few interfaces for drag and drop interactions but the key ones are the <code>DragEvent</code> interface and the <code>DataTransfer</code> interface. </p><p>The <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/DragEvent">DragEvent</a></code> interface is a DOM event which represents a drag and drop interaction. It contains a single property, <code>dataTransfer</code>, which is a <code>DataTransfer</code> object.</p><p>The <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer">DataTransfer</a></code> interface has several properties and methods available. It contains information about the data being transferred by the interaction as well as methods to add or remove data from it.</p><p><strong>Properties</strong></p><ul><li><code>dropEffect</code><br>Gets the type of drag-and-drop operation currently selected or sets the operation to a new type. The value must be <code>none</code>, <code>copy</code>, <code>link</code> or <code>move</code>.</li><li><code>effectAllowed</code><br>Provides all of the types of operations that are possible. Must be one of <code>none</code>, <code>copy</code>, <code>copyLink</code>, <code>copyMove</code>, <code>link</code>, <code>linkMove</code>, <code>move</code>, <code>all</code> or <code>uninitialized</code>.</li><li><code>files</code><br>Contains a list of all the local files available on the data transfer. If the drag operation doesn&apos;t involve dragging files, this property is an empty list.</li><li><code>items</code><br>Gives a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransferItemList"><code>DataTransferItemList</code></a> object which is a list of all of the drag data.</li><li><code>types</code><br>An array of <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMString"><code>strings</code></a> giving the formats that were set in the <code>dragstart</code> event.</li></ul><p><strong>Methods</strong></p><ul><li><code>DataTransfer.clearData()</code><br>Remove the data associated with a given type. The type argument is optional. If the type is empty or not specified, the data associated with all types is removed. If data for the specified type does not exist, or the data transfer contains no data, this method will have no effect.</li><li><code>DataTransfer.getData()</code><br>Retrieves the data for a given type, or an empty string if data for that type does not exist or the data transfer contains no data.</li><li><code>DataTransfer.setData()</code><br>Set the data for a given type. If data for the type does not exist, it is added at the end, such that the last item in the types list will be the new format. If data for the type already exists, the existing data is replaced in the same position.</li><li><code>DataTransfer.setDragImage()</code><br>Set the image to be used for dragging if a custom one is desired.</li></ul><h2 id="drag-and-drop-api-in-blazor">Drag and drop API in Blazor</h2><p>As with most UI events, Blazor has C# representations for the drag and drop API. Below is the <code>UIDragEventArgs</code> and <code>DataTransfer</code> classes which represents the <code>DragEvent</code> and <code>DataTransfer</code> interfaces I mentioned earlier. </p><pre><code class="language-csharp">/// &lt;summary&gt;
/// Supplies information about an drag event that is being raised.
/// &lt;/summary&gt;
public class UIDragEventArgs : UIMouseEventArgs
{
    /// &lt;summary&gt;
    /// The data that underlies a drag-and-drop operation, known as the drag data store.
    /// See &lt;see cref=&quot;DataTransfer&quot;/&gt;.
    /// &lt;/summary&gt;
    public DataTransfer DataTransfer { get; set; }
}
</code></pre>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// The &lt;see cref=&quot;DataTransfer&quot;/&gt; object is used to hold the data that is being dragged during a drag and drop operation.
/// It may hold one or more &lt;see cref=&quot;UIDataTransferItem&quot;/&gt;, each of one or more data types.
/// For more information about drag and drop, see HTML Drag and Drop API.
/// &lt;/summary&gt;
public class DataTransfer
{
    /// &lt;summary&gt;
    /// Gets the type of drag-and-drop operation currently selected or sets the operation to a new type.
    /// The value must be none, copy, link or move.
    /// &lt;/summary&gt;
    public string DropEffect { get; set; }

    /// &lt;summary&gt;
    /// Provides all of the types of operations that are possible.
    /// Must be one of none, copy, copyLink, copyMove, link, linkMove, move, all or uninitialized.
    /// &lt;/summary&gt;
    public string EffectAllowed { get; set; }

    /// &lt;summary&gt;
    /// Contains a list of all the local files available on the data transfer.
    /// If the drag operation doesn&apos;t involve dragging files, this property is an empty list.
    /// &lt;/summary&gt;
    public string[] Files { get; set; }

    /// &lt;summary&gt;
    /// Gives a &lt;see cref=&quot;UIDataTransferItem&quot;/&gt; array which is a list of all of the drag data.
    /// &lt;/summary&gt;
    public UIDataTransferItem[] Items { get; set; }

    /// &lt;summary&gt;
    /// An array of &lt;see cref=&quot;string&quot;/&gt; giving the formats that were set in the dragstart event.
    /// &lt;/summary&gt;
    public string[] Types { get; set; }
}
</code></pre>
<p>This was a great start to my investigation, however, it was short lived. After a quick bit of experimenting, it seems at this point in time there isn&apos;t a way to populate these values and pass data around using them. At least from C#, which is my goal at the moment. What is available though are the various events of the drag and drop API, I just needed to come up with a way of tracking the data as it moved about. </p><h2 id="building-the-prototype-a-todo-list">Building the prototype - A todo list</h2><p>As you have seen from the gif at the start of this post, the prototype is a highly original todo list. I set myself some goals I wanted to achieve from the exercise, they were:</p><ul><li>Be able to track an item being dragged</li><li>Control where items could be dropped</li><li>Give a visual indicator to the user where items could be dropped or not dropped</li><li>Update an item on drop</li><li>Feedback when an item has been updated</li></ul><h3 id="overview">Overview</h3><p>My solution ended up with three components, <code>JobsContainer</code>, <code>JobList</code> and <code>Job</code> which are used to manipulate a list of <code>JobModel</code>s.</p><pre><code class="language-csharp">public class JobModel
{
    public int Id { get; set; }
    public JobStatuses Status { get; set; }
    public string Description { get; set; }
    public DateTime LastUpdated { get; set; }
}

public enum JobStatuses
{
    Todo,
    Started,
    Completed
}
</code></pre>
<p>The <code>JobsContainer</code> is responsible for overall list of jobs, keeping track of the job being dragged and raising an event whenever a job is updated. </p><p>The <code>JobsList</code> component represents a single job status, it creates a <em>drop-zone</em> where jobs can be dropped and renders any jobs which have its status.</p><p>The <code>Job</code> component renders a <code>JobModel</code> instance. If the instance is dragged then it lets the <code>JobsContainer</code> know so it can be tracked.</p><h3 id="jobscontainer-component">JobsContainer Component</h3><pre><code class="language-html">&lt;div class=&quot;jobs-container&quot;&gt;
    &lt;CascadingValue Value=&quot;this&quot;&gt;
        @ChildContent
    &lt;/CascadingValue&gt;
&lt;/div&gt;

@code {
    [Parameter] public List&lt;JobModel&gt; Jobs { get; set; }
    [Parameter] RenderFragment ChildContent { get; set; }
    [Parameter] EventCallback&lt;JobModel&gt; OnStatusUpdated { get; set; }

    public JobModel Payload { get; set; }

    public async Task UpdateJobAsync(JobStatuses newStatus)
    {
        var task = Jobs.SingleOrDefault(x =&gt; x.Id == Payload.Id);

        if (task != null)
        {
            task.Status = newStatus;
            task.LastUpdated = DateTime.Now;
            await OnStatusUpdated.InvokeAsync(Payload);
        }
    }
}

</code></pre>
<p>Its main job (<em>no pun intended!</em>) is to coordinate updates to jobs as they are moved about the various statuses. It takes a list of <code>JobModel</code> as a parameter as well as exposing an event which consuming components can handle to know when a job gets updated. </p><p>It passes itself as a <code>CascadingValue</code> to the various <code>JobsList</code> components, which are child components. This allows them access to the list of jobs as well as the <code>UpdateJobAsync</code> method, which is called when a job is dropped onto a new status.</p><h3 id="jobslist-component">JobsList Component</h3><pre><code class="language-html">&lt;div class=&quot;job-status&quot;&gt;
    &lt;h3&gt;@ListStatus (@Jobs.Count())&lt;/h3&gt;

    &lt;ul class=&quot;dropzone @dropClass&quot; ondragover=&quot;event.preventDefault();&quot;
        @ondrop=&quot;HandleDrop&quot;
        @ondragenter=&quot;HandleDragEnter&quot;
        @ondragleave=&quot;HandleDragLeave&quot;&gt;

        @foreach (var job in Jobs)
        {
            &lt;Job JobModel=&quot;job&quot; /&gt;
        }

    &lt;/ul&gt;
&lt;/div&gt;

@code {

    [CascadingParameter] JobsContainer Container { get; set; }
    [Parameter] JobStatuses ListStatus { get; set; }
    [Parameter] JobStatuses[] AllowedStatuses { get; set; }

    List&lt;JobModel&gt; Jobs = new List&lt;JobModel&gt;();
    string dropClass = &quot;&quot;;

    protected override void OnParametersSet()
    {
        Jobs.Clear();
        Jobs.AddRange(Container.Jobs.Where(x =&gt; x.Status == ListStatus));
    }

    private void HandleDragEnter()
    {
        if (ListStatus == Container.Payload.Status) return;

        if (AllowedStatuses != null &amp;&amp; !AllowedStatuses.Contains(Container.Payload.Status))
        {
            dropClass = &quot;no-drop&quot;;
        }
        else
        {
            dropClass = &quot;can-drop&quot;;
        }
    }

    private void HandleDragLeave()
    {
        dropClass = &quot;&quot;;
    }

    private async Task HandleDrop()
    {
        dropClass = &quot;&quot;;

        if (AllowedStatuses != null &amp;&amp; !AllowedStatuses.Contains(Container.Payload.Status)) return;

        await Container.UpdateJobAsync(ListStatus);
    }
}
</code></pre>
<p>There is quite a bit of code so let&apos;s break it down.</p><pre><code class="language-csharp">[Parameter] JobStatuses ListStatus { get; set; }
[Parameter] JobStatuses[] AllowedStatuses { get; set; }
</code></pre>
<p>The component takes a <code>ListStatus</code> and array of <code>AllowedStatuses</code>. The <code>AllowedStatuses</code> are used by the <code>HandleDrop</code> method to decide if a job can be dropped or not.</p><p>The <code>ListStatus</code> is the job status that the component instance is responsible for. It&apos;s used to fetch the jobs from the <code>JobsContainer</code> component which match that status so the component can render them in its list.</p><p>This is performed using the <code>OnParametersSet</code> lifecycle method, making sure to clear out the list each time to avoid duplicates.</p><pre><code class="language-csharp">protected override void OnParametersSet()
{
    Jobs.Clear();
    Jobs.AddRange(Container.Jobs.Where(x =&gt; x.Status == ListStatus));
}
</code></pre>
<p>I&apos;m using an unordered list to display the jobs. The list is also a <em>drop-zone</em> for jobs, meaning you can drop other elements onto it. This is achieved by defining the <code>ondragover</code> event, but note there&apos;s no <code>@</code> symbol in-front of it. This isn&apos;t a typo. </p><pre><code class="language-html">&lt;ul class=&quot;dropzone @dropClass&quot; ondragover=&quot;event.preventDefault();&quot;
    @ondrop=&quot;HandleDrop&quot;
    @ondragenter=&quot;HandleDragEnter&quot;
    @ondragleave=&quot;HandleDragLeave&quot;&gt;

    @foreach (var job in Jobs)
    {
        &lt;Job JobModel=&quot;job&quot; /&gt;
    }

&lt;/ul&gt;
</code></pre>
<p>The event is just a normal JavaScript event, not a Blazor version, calling <code>preventDefault</code>. The reason for this is that by default you can&apos;t drop elements onto each other. By calling <code>preventDefault</code> it stops this default behaviour from occurring.</p><p>The rest of the events are all Blazor versions. <code>OnDragEnter</code> and <code>OnDragLeave</code> are both used to set the CSS of for the <em>drop-zone.</em></p><pre><code class="language-csharp">private void HandleDragEnter()
{
    if (ListStatus == Container.Payload.Status) return;

    if (AllowedStatuses != null &amp;&amp; !AllowedStatuses.Contains(Container.Payload.Status))
    {
        dropClass = &quot;no-drop&quot;;
    }
    else
    {
        dropClass = &quot;can-drop&quot;;
    }
}

private void HandleDragLeave()
{
    dropClass = &quot;&quot;;
}
</code></pre>
<p><code>HandleDragEnter</code> manages the border of the <em>drop-zone</em> to give the user visual feedback if a job can be dropped. </p><p>If the job being dragged has the same status as the <em>drop-zone</em> it&apos;s over then nothing happens. If a job is dragged over the <em>drop-zone,</em> and it&apos;s a valid target, then a green border is added via the <code>can-drop</code> CSS class. If it&apos;s not a valid target then a red border is added via the <code>no-drop</code> CSS class.</p><p>The <code>HandleDragLeave</code> method just resets the class once the job has been dragged away.</p><pre><code class="language-csharp">private async Task HandleDrop()
{
    dropClass = &quot;&quot;;

    if (AllowedStatuses != null &amp;&amp; !AllowedStatuses.Contains(Container.Payload.Status)) return;

    await Container.UpdateJobAsync(ListStatus);
}
</code></pre>
<p>Finally, <code>HandleDrop</code> is responsible for making sure a job is allowed to be dropped, and if so, updating its status via the <code>JobsContainer</code>.</p><h3 id="job-component">Job Component</h3><pre><code class="language-html">&lt;li class=&quot;draggable&quot; draggable=&quot;true&quot; title=&quot;@JobModel.Description&quot; @ondragstart=&quot;@(() =&gt; HandleDragStart(JobModel))&quot;&gt;
    &lt;p class=&quot;description&quot;&gt;@JobModel.Description&lt;/p&gt;
    &lt;p class=&quot;last-updated&quot;&gt;&lt;small&gt;Last Updated&lt;/small&gt; @JobModel.LastUpdated.ToString(&quot;HH:mm.ss tt&quot;)&lt;/p&gt;
&lt;/li&gt;

@code {
    [CascadingParameter] JobsContainer Container { get; set; }
    [Parameter] JobModel JobModel { get; set; }

    private void HandleDragStart(JobModel selectedJob)
    {
        Container.Payload = selectedJob;
    }
}
</code></pre>
<p>It&apos;s responsible for displaying a <code>JobModel</code> and for making it draggable. Elements are made draggable by adding the <code>draggable=&quot;true&quot;</code> attribute. The component is also responsible for handling the <code>ondragstart</code> event. </p><p>When <code>ondragstart</code> fires the component assigns the job to the <code>JobsContainer</code>s <code>Payload</code> property. This keeps track of the job being dragged which is used when handling drop events, as we saw in the <code>JobsList</code> component.</p><h3 id="usage">Usage</h3><p>Now we&apos;ve gone through each component let&apos;s see what it looks like all together.</p><pre><code class="language-html">&lt;JobsContainer Jobs=&quot;Jobs&quot; OnStatusUpdated=&quot;HandleStatusUpdated&quot;&gt;
    &lt;JobList ListStatus=&quot;JobStatuses.Todo&quot; AllowedStatuses=&quot;@(new JobStatuses[] { JobStatuses.Started})&quot; /&gt;
    &lt;JobList ListStatus=&quot;JobStatuses.Started&quot; AllowedStatuses=&quot;@(new JobStatuses[] { JobStatuses.Todo})&quot; /&gt;
    &lt;JobList ListStatus=&quot;JobStatuses.Completed&quot; AllowedStatuses=&quot;@(new JobStatuses[] { JobStatuses.Started })&quot; /&gt;
&lt;/JobsContainer&gt;

@code {
    List&lt;JobModel&gt; Jobs = new List&lt;JobModel&gt;();

    protected override void OnInit()
    {
        Jobs.Add(new JobModel { Id = 1, Description = &quot;Mow the lawn&quot;, Status = JobStatuses.Todo, LastUpdated = DateTime.Now });
        Jobs.Add(new JobModel { Id = 2, Description = &quot;Go to the gym&quot;, Status = JobStatuses.Todo, LastUpdated = DateTime.Now });
        Jobs.Add(new JobModel { Id = 3, Description = &quot;Call Ollie&quot;, Status = JobStatuses.Todo, LastUpdated = DateTime.Now });
        Jobs.Add(new JobModel { Id = 4, Description = &quot;Fix bike tyre&quot;, Status = JobStatuses.Todo, LastUpdated = DateTime.Now });
        Jobs.Add(new JobModel { Id = 5, Description = &quot;Finish blog post&quot;, Status = JobStatuses.Todo, LastUpdated = DateTime.Now });
    }

    void HandleStatusUpdated(JobModel updatedJob)
    {
        Console.WriteLine(updatedJob.Description);
    }
}
</code></pre>
<p>Looking back at the goals I set for this exercise:</p><ul><li>Be able to track an item being dragged</li><li>Control where items could be dropped</li><li>Give a visual indicator to the user where items could be dropped or not dropped</li><li>Update an item on drop</li><li>Feedback when an item has been updated</li></ul><p>I&apos;m feel pretty happy that each one of those has been achieved with the above solution. Please keep in mind this was just a fact finding exercise and the code above is just a prototype. There are probably quite a few bits which could use a tweak or a re-factor before actually using it. </p><p>One thing which I thought about after I started was the ability to re-order using dragging and dropping. But that isn&apos;t something I could make work in a way I would&apos;ve been happy with. In traditional JavaScript applications, this is achieved by manipulating the DOM directly. This is something which isn&apos;t possible right now with Blazor. I have a few ideas about ways to achieve this using C# but I&apos;m leaving them for another time.</p><p>I had a lot of fun experimenting with drag and drop with Blazor. As usual, I found that getting something up and working was pretty quick and easy. I would definitely want to iterate on this code a bit before I started using it in a real app but I hope it will give people a good starting point.</p><p>In this post, I&apos;ve given an overview of the HTML drag and drop API as well as showing what parts are available to us in Blazor. I then walked through a prototype for a drag and drop interface using a todo list as the example.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>