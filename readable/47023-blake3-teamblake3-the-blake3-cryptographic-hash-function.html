<!DOCTYPE html>
<html lang="en">
<head>
    <title>
BLAKE3-team/BLAKE3: The BLAKE3 cryptographic hash function -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>BLAKE3-team/BLAKE3: The BLAKE3 cryptographic hash function</h1><div><div id="" class="markdown-body entry-content p-5"><p>BLAKE3 is a cryptographic hash function that is:</p><ul><li><strong>Much faster</strong> than MD5, SHA-1, SHA-2, SHA-3, and BLAKE2.</li><li><strong>Secure</strong>, unlike MD5 and SHA-1. And secure against length extension,
unlike SHA-2.</li><li><strong>Highly parallelizable</strong> across any number of threads and SIMD lanes,
because it's a Merkle tree on the inside.</li><li>Capable of <strong>verified streaming</strong> and <strong>incremental updates</strong>, again
because it's a Merkle tree.</li><li>A <strong>PRF</strong>, <strong>MAC</strong>, <strong>KDF</strong>, and <strong>XOF</strong>, as well as a regular hash.</li><li><strong>One algorithm with no variants</strong>, which is fast on x86-64 and also
on smaller architectures.</li></ul><p>The <a href="https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/benchmarks/bar_chart.py">chart below</a>
shows BLAKE3's performance on modern server hardware, an Intel Cascade
Lake-SP 8275CL processor:</p><p align="center"><a target="_blank" rel="noopener noreferrer" href="/BLAKE3-team/BLAKE3/blob/master/media/speed.svg"><img src="/BLAKE3-team/BLAKE3/raw/master/media/speed.svg?sanitize=true" alt="performance graph"></a></p><p>BLAKE3 is based on an optimized instance of the established hash
function <a href="https://blake2.net" rel="nofollow">BLAKE2</a> and on the <a href="https://github.com/oconnor663/bao/blob/master/docs/spec_0.9.1.md">original Bao tree
mode</a>.
The specifications and design rationale are available in the <a href="https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf">BLAKE3
paper</a>.
The default output size is 256 bits. The current version of
<a href="https://github.com/oconnor663/bao">Bao</a> implements verified streaming
with BLAKE3.</p><p>This repository is the official implementation of BLAKE3. It includes:</p><ul><li><p>The <a href="https://crates.io/crates/blake3" rel="nofollow"><code>blake3</code></a> Rust crate, which
includes optimized SIMD implementations, with dynamic CPU feature
detection on x86. SSE4.1 and AVX2 support are implemented in Rust,
while AVX-512 and ARM NEON support are imported from the C
implementation and controlled by the <code>c_avx512</code> and <code>c_neon</code> features.
Multi-threading is implemented with
<a href="https://github.com/rayon-rs/rayon">Rayon</a> and controlled by the
<code>rayon</code> feature.</p></li><li><p>The <a href="https://crates.io/crates/b3sum" rel="nofollow"><code>b3sum</code></a> Rust crate, which
provides a command line interface. You can install it from
<a href="https://crates.io/crates/b3sum" rel="nofollow">crates.io</a> with <code>cargo install b3sum</code>. It enables the multi-threading and AVX-512 features of the
<code>blake3</code> crate by default.</p></li><li><p>The <a href="/BLAKE3-team/BLAKE3/blob/master/c">C implementation</a>, which like the Rust implementation includes
SIMD code and dynamic CPU feature detection on x86. Unlike the Rust
implementation, it's not currently multi-threaded. The
<a href="/BLAKE3-team/BLAKE3/blob/master/c/README.md">README</a> provides build examples.</p></li><li><p>The <a href="/BLAKE3-team/BLAKE3/blob/master/reference_impl/reference_impl.rs">reference implementation</a>,
which is discussed in Section 5.1 of the <a href="https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf">BLAKE3
paper</a>.
This implementation is much smaller and simpler than the optimized
ones above. If you want to see how BLAKE3 works, or you're writing a
port that doesn't need multi-threading or SIMD optimizations, start
here.</p></li><li><p><a href="https://github.com/BLAKE3-team/BLAKE3/actions"><img src="https://github.com/BLAKE3-team/BLAKE3/workflows/tests/badge.svg" alt="Actions Status"></a></p></li></ul><p>BLAKE3 was designed by:</p><p>The development of BLAKE3 was sponsored by
<a href="https://teserakt.io" rel="nofollow">Teserakt</a> and <a href="https://electriccoin.co" rel="nofollow">Electric Coin Company</a>.</p><p><em>NOTE: BLAKE3 is not a password hashing algorithm, because it's
designed to be fast, whereas password hashing should not be fast. If you
hash passwords to store the hashes or if you derive keys from passwords,
we recommend <a href="https://github.com/P-H-C/phc-winner-argon2">Argon2</a>.</em></p><h2><a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2><p>This repository provides the <code>b3sum</code> command line utility and the
<code>blake3</code> Rust crate.</p><h3><a id="user-content-the-b3sum-utility" class="anchor" aria-hidden="true" href="#the-b3sum-utility"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>b3sum</code> utility</h3><p>The <code>b3sum</code> utility allows you to process files and data from standard
input using BLAKE3 in any of its three modes.
To use <code>b3sum</code> on the command line, <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html" rel="nofollow">install Rust and
Cargo</a>,
and then run:</p><p>If <code>rustup</code> didn't configure your <code>PATH</code> for you, you might need to go
looking for the installed binary in e.g. <code>~/.cargo/bin</code>. You can test
out how fast BLAKE3 is on your machine by creating a big file and
hashing it, for example as follows:</p><div class="highlight highlight-source-shell"><pre><span class="pl-c"><span class="pl-c">#</span> Create a 1 GB file.</span>
head -c 1000000000 /dev/zero <span class="pl-k">&gt;</span> /tmp/bigfile
<span class="pl-c"><span class="pl-c">#</span> Hash it with SHA-256.</span><span class="pl-k">time</span> openssl sha256 /tmp/bigfile
<span class="pl-c"><span class="pl-c">#</span> Hash it with BLAKE3.</span><span class="pl-k">time</span> b3sum /tmp/bigfile</pre></div><h3><a id="user-content-the-blake3-crate" class="anchor" aria-hidden="true" href="#the-blake3-crate"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>blake3</code> crate</h3><p>To use BLAKE3 from Rust code, add a dependency on the <code>blake3</code> crate to
your <code>Cargo.toml</code>. Here's an example of hashing some input bytes:</p><div class="highlight highlight-source-rust"><pre><span class="pl-c">// Hash an input all at once.</span><span class="pl-k">let</span> hash1 <span class="pl-k">=</span> blake3<span class="pl-k">::</span><span class="pl-en">hash</span>(<span class="pl-s">b"foobarbaz"</span>);

<span class="pl-c">// Hash an input incrementally.</span><span class="pl-k">let</span><span class="pl-k">mut</span> hasher <span class="pl-k">=</span> blake3<span class="pl-k">::</span>Hasher<span class="pl-k">::</span><span class="pl-en">new</span>();
hasher.<span class="pl-en">update</span>(<span class="pl-s">b"foo"</span>);
hasher.<span class="pl-en">update</span>(<span class="pl-s">b"bar"</span>);
hasher.<span class="pl-en">update</span>(<span class="pl-s">b"baz"</span>);
<span class="pl-k">let</span> hash2 <span class="pl-k">=</span> hasher.<span class="pl-en">finalize</span>();
<span class="pl-c1">assert_eq!</span>(hash1, hash2);

<span class="pl-c">// Extended output. OutputReader also implements Read and Seek.</span><span class="pl-k">let</span><span class="pl-k">mut</span> output <span class="pl-k">=</span> [<span class="pl-c1">0</span>; <span class="pl-c1">1000</span>];
<span class="pl-k">let</span><span class="pl-k">mut</span> output_reader <span class="pl-k">=</span> hasher.<span class="pl-en">finalize_xof</span>();
output_reader.<span class="pl-en">fill</span>(<span class="pl-k">&amp;</span><span class="pl-k">mut</span> output);
<span class="pl-c1">assert_eq!</span>(<span class="pl-k">&amp;</span>output[..<span class="pl-c1">32</span>], hash1.<span class="pl-en">as_bytes</span>());</pre></div><p>Besides <code>hash</code>, BLAKE3 provides two other modes, <code>keyed_hash</code> and
<code>derive_key</code>. The <code>keyed_hash</code> mode takes a 256-bit key:</p><div class="highlight highlight-source-rust"><pre><span class="pl-c">// MAC an input all at once.</span><span class="pl-k">let</span> example_key <span class="pl-k">=</span> [<span class="pl-c1">42u8</span>; <span class="pl-c1">32</span>];
<span class="pl-k">let</span> mac1 <span class="pl-k">=</span> blake3<span class="pl-k">::</span><span class="pl-en">keyed_hash</span>(<span class="pl-k">&amp;</span>example_key, <span class="pl-s">b"example input"</span>);

<span class="pl-c">// MAC incrementally.</span><span class="pl-k">let</span><span class="pl-k">mut</span> hasher <span class="pl-k">=</span> blake3<span class="pl-k">::</span>Hasher<span class="pl-k">::</span><span class="pl-en">new_keyed</span>(<span class="pl-k">&amp;</span>example_key);
hasher.<span class="pl-en">update</span>(<span class="pl-s">b"example input"</span>);
<span class="pl-k">let</span> mac2 <span class="pl-k">=</span> hasher.<span class="pl-en">finalize</span>();
<span class="pl-c1">assert_eq!</span>(mac1, mac2);</pre></div><p>The <code>derive_key</code> mode takes a context string of any length and key
material of any length, and it outputs a derived key of any length. The
context string should be hardcoded, globally unique, and
application-specific. A good default format for the context string is
<code>"[application] [commit timestamp] [purpose]"</code>:</p><div class="highlight highlight-source-rust"><pre><span class="pl-c">// Derive a couple of subkeys for different purposes.</span><span class="pl-k">const</span> EMAIL_CONTEXT: <span class="pl-k">&amp;</span><span class="pl-k">str</span><span class="pl-k">=</span><span class="pl-s">"BLAKE3 example 2020-01-07 17:10:44 email key"</span>;
<span class="pl-k">const</span> API_CONTEXT: <span class="pl-k">&amp;</span><span class="pl-k">str</span><span class="pl-k">=</span><span class="pl-s">"BLAKE3 example 2020-01-07 17:11:21 API key"</span>;
<span class="pl-k">let</span> input_key <span class="pl-k">=</span><span class="pl-s">b"some very secret key material (&gt;'-')&gt; &lt;('-'&lt;) ^('-')^"</span>;
<span class="pl-k">let</span><span class="pl-k">mut</span> email_key <span class="pl-k">=</span> [<span class="pl-c1">0</span>; <span class="pl-c1">32</span>];
blake3<span class="pl-k">::</span><span class="pl-en">derive_key</span>(EMAIL_CONTEXT, input_key, <span class="pl-k">&amp;</span><span class="pl-k">mut</span> email_key);
<span class="pl-k">let</span><span class="pl-k">mut</span> api_key <span class="pl-k">=</span> [<span class="pl-c1">0</span>; <span class="pl-c1">32</span>];
blake3<span class="pl-k">::</span><span class="pl-en">derive_key</span>(API_CONTEXT, input_key, <span class="pl-k">&amp;</span><span class="pl-k">mut</span> api_key);
<span class="pl-c1">assert!</span>(email_key <span class="pl-k">!=</span> api_key);</pre></div><h2><a id="user-content-contributing" class="anchor" aria-hidden="true" href="#contributing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Contributing</h2><p>Please see <a href="/BLAKE3-team/BLAKE3/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>.</p><h2><a id="user-content-intellectual-property" class="anchor" aria-hidden="true" href="#intellectual-property"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Intellectual property</h2><p>The Rust code is copyright Jack O'Connor, 2019-2020.
The C code is copyright Samuel Neves and Jack O'Connor, 2019-2020.</p><p>This work is released into the public domain with CC0 1.0.
Alternatively, it is licensed under the Apache License 2.0.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>