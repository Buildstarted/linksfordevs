<!DOCTYPE html>
<html lang="en">
<head>
    <title>
IdentityServer4: Building a Simple Token Server and Protecting Your ASP.NET Core APIs with JWT - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="IdentityServer4: Building a Simple Token Server and Protecting Your ASP.NET Core APIs with JWT - linksfor.dev(s)"/>
    <meta property="og:description" content="Introduction I got many questions how the ASP.NET Core ApiBoilerplate protects the API endpoints and which URL validates the token. If you are new to ASP.NET Core and are using the template to get started, chances are you..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://vmsdurano.com/apiboilerplate-and-identityserver4-access-control-for-apis/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - IdentityServer4: Building a Simple Token Server and Protecting Your ASP.NET Core APIs with JWT</title>
<div class="readable">
        <h1>IdentityServer4: Building a Simple Token Server and Protecting Your ASP.NET Core APIs with JWT</h1>
            <div>Reading time: 34-43 minutes</div>
        <div>Posted here: 19 Feb 2020</div>
        <p><a href="http://vmsdurano.com/apiboilerplate-and-identityserver4-access-control-for-apis/">http://vmsdurano.com/apiboilerplate-and-identityserver4-access-control-for-apis/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section>
            

<p>I got many questions how the ASP.NET Core <a href="https://github.com/proudmonkey/ApiBoilerPlate">ApiBoilerplate</a> protects the <code>API</code> endpoints and which URL validates the token. If you are new to ASP.NET Core and are using the template to get started, chances are you might ask the same question to yourself. I hope this post clears some confusion about it.</p>

<p>I'll try to make this post as generic as possible so that you can still apply the same concept even if you are not using the <code>ApiBoilerplate</code> template.</p>



<p>In ASP.NET Core or even in traditional Web APIs, we would normally decorate our <code>Controllers</code> or <code>Actions</code> with the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.authorizeattribute?view=aspnetcore-3.1">[Authorize]</a> attribute to secure our Api endpoints from anonymous, unauthorized or unauthenticated users:</p>

<p><strong>Controller Level Restriction</strong></p>

<pre><code><span>[</span><span>Authorize</span><span>]</span>
<span>public</span> <span>class</span> <span>PersonController</span><span>:</span> <span>ControllerBase</span>  
<span>{</span>
   
<span>}</span>
</code></pre>

<p><strong>Action Level Restriction</strong></p>

<pre><code><span>[</span><span>HttpGet</span><span>]</span>
<span>[</span><span>Authorize</span><span>]</span>
<span>public</span> <span>async</span> Task<span>&lt;</span>IEnumerable<span>&lt;</span>PersonResponse<span>&gt;&gt;</span> <span>Get</span><span>(</span><span>)</span>  
<span>{</span>
   
<span>}</span>
</code></pre>

<p>The <code>[Authorize]</code> attribute provides filters for users and roles and it’s fairly easy to implement it if you are using membership/identity provider. You can even customize it's behavior by extending the <code>[AuthorizeAttribute]</code> class based on your custom needs. There are two ways in which we can implement authorization in ASP.NET Core. These include role-based authorization and policy-based authorization. From the example above, it doesn't specify any arguments for the <code>[Authorize]</code> attribute, which means that it only checks if the user is authenticated. This is sufficient enough for the purpose of this demo.</p>

<p>There are many possible options that we can use to secure our <code>APIs</code>, a few of the most popular are using <code>OAuth 2.0 Access Tokens</code>, <code>Api Keys</code> or <code>JSON Web Tokens(JWT)</code>. Here's an article explaining their differences: <a href="https://zapier.com/engineering/apikey-oauth-jwt/">API Keys vs OAuth Tokens vs JSON Web Tokens</a></p>

<p>In this demo we are going to use <code>JWT</code> as access token which contains a JSON data payload that is signed and serialized. </p>



<p>Because it's simple and a great technology for authenticating APIs and server-to-server authorization. I'm not going to cover the details about <code>JWT</code> as there are already tons of guides about this, and I personally recommend this one: <a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a></p>

<p>Please keep in mind that a <code>JWT</code> guarantees data ownership but not encryption; the <code>JSON</code> data you store into a <code>JWT</code> can be seen by anyone that intercepts the token, as it’s just serialized, not encrypted. In other words, using <code>JWT</code> doesn't make our <code>API</code> invulnerable. For this reason, an extra layer of protection that always goes hand in hand with <code>JWT</code> is to secure all our network traffic with an <code>HTTPS</code> connection.</p>



<p><a href="https://readthedocs.org/projects/identityserver4/downloads/pdf/latest/">IdentityServer4</a> an <code>OpenID Connect</code> and <code>OAuth 2.0</code> framework that provides a set of services and middleware for ASP.NET Core apps. I won't be covering all features in this post, and I would recommend you to head over to the <a href="https://identityserver4.readthedocs.io/en/latest/">official documentation</a> page to see what features it provides.</p>

<p>IdentityServer4 supports multiple protocol flows or grant types such as <code>Authorization Code</code>, <code>Client Credentials</code>, <code>Refresh Token</code>, <code>Implicit</code> and etc. In this post we are going to take a look at the <code>Client Credentials</code> flow.</p>



<p><code>Client Credentials Flow</code> is a process in which client apps use <code>client_id</code>, <code>client_secret</code> and sometimes a <code>scope</code> in exchange for an <code>access_token</code> to access a protected resource.</p>

<p>This flow is the recommended way to secure APIs easily without a particular user connected, mostly this approach is better in server-to-server scenarios, when interconnected internal applications within a system need to authenticate without Login UI to present username and password.</p>

<p>For more information about IdentityServer 4 supported grant types, see: <a href="http://docs.identityserver.io/en/latest/topics/grant_types.html">Grant Types</a></p>



<p>Many folks that I know virtually in the forums and in person were asking about the distinctions between the two terms: <code>OAuth</code> and <code>OpenID</code>. I thought I'd give a brief overview about them in this post to help you better understand each terms.</p>

<p>In general, <code>OpenID</code> is about authentication (proving who you are (a.k.a identity)). <code>Authentication</code> is a process in which a user provides credentials, typically in a form of username and password that are then compared to those stored in an database, application or resource. <code>OAuth</code> on the other hand is about authorization (to grant access to files/resource/data without having to deal with the original authentication). <code>Authorization</code> refers to the process that determines what a user is allowed to do <strong>after</strong> they have been authenticated. The other thing called <code>OpenID Connect</code> does both.</p>

<p>We will use <code>.NETCore 3.1</code> and <code>IdentityServer4</code> framework to provide most of the security features that an application requires based <code>OAuth 2.0</code> and <code>OIDC</code> protocol implementation. This enables a third-party app to obtain a limited access to an <code>HTTP</code> service and APIs within your server premise. Instead of using resource owner's credentials to directly access a protected resource from our APIs, the client obtains an access token. In <code>OAuth 2.0</code>, access tokens are normally a string denoting a specific scope, lifetime and other access attributes. </p>

<p>Always remember that:</p>

<ul>
<li><code>OAuth 2.0</code> is an authorization protocol that specifies how tokens are transferred.There is no defined structure for the token required by the <a href="https://tools.ietf.org/html/rfc6750">spec</a>, which means you can generate a string and implement tokens however you want. </li>
<li><code>JWT</code> defines a token format.</li>
<li><code>OAuth 2.0</code> can use <code>JWT</code> as a token format. This is why we will use <code>JWT</code> in concert with <code>OAuth</code> to obtain an access token.</li>
</ul>

<p>Just to give you a quick overview, here's a glossary of <code>OAuth</code> terms:</p>

<ul>
<li><code>Resource Owner</code> (a.k.a the User) - An entity capable of granting access to a protected resource.</li>
<li><code>Resource Server</code> (a.k.a your ASP.NET Core APIs) - The server hosting the protected resource, capable of accepting and responding to protected resource requests using access tokens.</li>
<li><code>Client</code> - An application (desktop, web, service or mobile app) making protected resource requests on behalf of the resource owner and with its authorization.</li>
<li><code>Token Server</code> - The service issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.</li>
</ul>

<p>We're not going to cover <code>Resource Owner</code> in this example as we won't be doing with user authentication that allow users to input their account credentials. Instead, we will focus on API to API authentication and authorization using client credentials grant type.</p>

<p>To make it clearer, here's a simple diagram describing the high-level flow on how each component interact with each other.</p>

<p><img src="https://proudmonkeystorage.blob.core.windows.net/cdn/2020Feb17/oauth_flow.PNG" alt=""></p>



<p>Let's build a simple <code>Token Server</code> using <code>IdentityServer4</code> that authorizes internal/external client apps for accessing a certain <code>Resource Server</code>. You can think of it as a system that generates a simple data structure containing <code>Authorization</code> and/or <code>Authentication</code> information. In this post, we'll only cover the <code>OAuth</code> aspect of <code>IdentityServer4</code> to generate an <code>access_token</code> in a form of <code>JWT</code> for authorizing access. This would be the "keys to the house", so to speak, letting you through the doorway and into the residence of a protected resource, usually an ASP.NET Core Web APIs. A good practice is to host this server as a separate service and not implement it within your web application specific apps.</p>

<p>For this particular demo, I'm going to use the following tools and frameworks:</p>

<ul>
<li>Visual Studio 2019</li>
<li>.NET Core 3.1</li>
<li>ASP.NET Core 3.1</li>
<li>IdentityServer4</li>
<li>IdentityServer4.AccessTokenValidation </li>
<li>ApiBoilerPlate.AspNetCore</li>
</ul>

<p>To begin, let's go ahead and fire up Visual Studio 2019. Create a new <strong>ASP.NET Core Web Application</strong> project with an <strong>Empty</strong> project template and make sure <strong>Authentication</strong> option is unchecked.</p>

<p>Install the <a href="https://www.nuget.org/packages/IdentityServer4">latest version</a> of <code>IdentityServer4</code> Nuget Package:</p>

<pre><code>PM&gt; Install-Package IdentityServer4 -Version 3.1.1  
</code></pre>

<blockquote>
  <p>Note: The latest version as of this time of writing is 3.1.1.</p>
</blockquote>

<p>For the sole purpose of this demo, we'll just use an In-Memory data store to keep the list of clients and resources. In real/production applications, you should store these data in a persistent data store such as a database. IndentityServer4 has <a href="https://github.com/IdentityServer/IdentityServer4.EntityFramework">persistent layer</a> support baked for Entity Framework Core and you can use it to generate the schema needed for storing clients, scopes and grants.</p>

<p>Now, let's a create a couple of static internal classes that house some test data for <code>clients</code> and <code>resources</code>.</p>

<h4 id="configuringapiresources">Configuring API Resources</h4>

<p>Here's the code for our test API resources:</p>

<pre><code><span>using</span> IdentityServer4<span>.</span>Models<span>;</span>  
<span>using</span> System<span>.</span>Collections<span>.</span>Generic<span>;</span>

<span>namespace</span> IdentityServer4Demo<span>.</span>TokenServer<span>.</span>Data  
<span>{</span>
    <span>internal</span> <span>static</span> <span>class</span> <span>ResourceManager</span>
    <span>{</span>
        <span>public</span> <span>static</span> IEnumerable<span>&lt;</span>ApiResource<span>&gt;</span> Apis <span>=&gt;</span>
            <span>new</span> <span>List</span><span>&lt;</span>ApiResource<span>&gt;</span>
            <span>{</span>
                <span>new</span> <span>ApiResource</span> <span>{</span>
                    Name <span>=</span> <span>"app.api.whatever"</span><span>,</span>
                    DisplayName <span>=</span> <span>"Whatever Apis"</span><span>,</span>
                    ApiSecrets <span>=</span> <span>{</span> <span>new</span> <span>Secret</span><span>(</span><span>"a75a559d-1dab-4c65-9bc0-f8e590cb388d"</span><span>.</span><span>Sha256</span><span>(</span><span>)</span><span>)</span> <span>}</span><span>,</span>
                    Scopes <span>=</span> <span>new</span> <span>List</span><span>&lt;</span>Scope<span>&gt;</span> <span>{</span>
                        <span>new</span> <span>Scope</span><span>(</span><span>"app.api.whatever.read"</span><span>)</span><span>,</span>
                        <span>new</span> <span>Scope</span><span>(</span><span>"app.api.whatever.write"</span><span>)</span><span>,</span>
                        <span>new</span> <span>Scope</span><span>(</span><span>"app.api.whatever.full"</span><span>)</span>
                    <span>}</span>
                <span>}</span><span>,</span>
                <span>new</span> <span>ApiResource</span><span>(</span><span>"app.api.weather"</span><span>,</span><span>"Weather Apis"</span><span>)</span>
            <span>}</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>

<p>The <code>ApiResource</code> object is a class that lives within <code>IdentityServer4.Models</code> namespace and is built-in to IdentityServer4. This enable us to mock API Resources (a.k.a ASP.NET Core / Web APIs) that we wish to protect. From the code example above, we are modelling two APIs that we want to protect: The <code>app.api.whatever</code> and <code>app.api.weather</code>.</p>

<p>Notice that each <code>ApiResource</code> object are defined differently. The first item uses the default constructor with no parameters. You would use this approach if you wanted to configure multiple scopes per <code>API</code>. In this example, we've defined three scopes: <code>app.api.whatever.read</code>, <code>app.api.whatever.write</code> and <code>app.api.whatever.full</code>. </p>

<p>The second item uses the constructor parameter for convenience. You would typically use this for simpler scenarios where you only require one scope per <code>API</code>. In this case, the <code>app.api.weather</code> name will automatically become a <code>scope</code> for the resource.</p>

<blockquote>
  <p>Note: A couple of things to keep in mind here is that each scopes should be unique, and that is why it's recommended to define your scopes based on each <code>API</code> unique name. You can also define the <code>ApiResource</code> in <code>JSON</code> configuration file (<code>appsettings.json</code>) and then pass the configuration section to the <code>AddInMemoryApiResource</code> method.</p>
</blockquote>

<p>The next thing that we need to do is to setup some test clients that we want to authorize access to our configured <code>ApiResources</code>.</p>

<h4 id="configuringclients">Configuring Clients</h4>

<p>Here's the code for our test clients:</p>

<pre><code><span>using</span> IdentityServer4<span>.</span>Models<span>;</span>  
<span>using</span> System<span>.</span>Collections<span>.</span>Generic<span>;</span>

<span>namespace</span> IdentityServer4Demo<span>.</span>TokenServer<span>.</span>Data  
<span>{</span>
    <span>internal</span> <span>static</span> <span>class</span> <span>ClientManager</span>
    <span>{</span>
        <span>public</span> <span>static</span> IEnumerable<span>&lt;</span>Client<span>&gt;</span> Clients <span>=&gt;</span>
            <span>new</span> <span>List</span><span>&lt;</span>Client<span>&gt;</span>
            <span>{</span>
                    <span>new</span> <span>Client</span>
                    <span>{</span>
                         ClientName <span>=</span> <span>"Client Application1"</span><span>,</span>
                         ClientId <span>=</span> <span>"t8agr5xKt4$3"</span><span>,</span>
                         AllowedGrantTypes <span>=</span> GrantTypes<span>.</span>ClientCredentials<span>,</span>
                         ClientSecrets <span>=</span> <span>{</span> <span>new</span> <span>Secret</span><span>(</span><span>"eb300de4-add9-42f4-a3ac-abd3c60f1919"</span><span>.</span><span>Sha256</span><span>(</span><span>)</span><span>)</span> <span>}</span><span>,</span>
                         AllowedScopes <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>string</span><span>&gt;</span> <span>{</span> <span>"app.api.whatever.read"</span><span>,</span> <span>"app.api.whatever.write"</span> <span>}</span>
                    <span>}</span><span>,</span>
                    <span>new</span> <span>Client</span>
                    <span>{</span>
                         ClientName <span>=</span> <span>"Client Application2"</span><span>,</span>
                         ClientId <span>=</span> <span>"3X=nNv?Sgu$S"</span><span>,</span>
                         AllowedGrantTypes <span>=</span> GrantTypes<span>.</span>ClientCredentials<span>,</span>
                         ClientSecrets <span>=</span> <span>{</span> <span>new</span> <span>Secret</span><span>(</span><span>"1554db43-3015-47a8-a748-55bd76b6af48"</span><span>.</span><span>Sha256</span><span>(</span><span>)</span><span>)</span> <span>}</span><span>,</span>
                         AllowedScopes <span>=</span> <span>{</span> <span>"app.api.weather"</span> <span>}</span>
                    <span>}</span>
            <span>}</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>

<p>The code above is nothing but a simple static method that returns a <code>List</code> of test clients. Each client has a unique <code>ClientName</code>, <code>ClientId</code>, <code>ClientSecrets</code> and <code>AllowedScopes</code>, but all have the same <code>AllowedGrantTypes</code> set to <code>GrantTypes.ClientCredentials</code>.</p>

<p>A few things to keep in mind:</p>

<ul>
<li>The <code>OAuth Client Credentials</code> grant type requires <code>ClientId</code> and <code>ClientSecrets</code> to authorize access.</li>
<li>The <code>ClientId</code> in this example uses a random string that is hashed using the <code>Sha256()</code> extension method built-in to IdentityServer4. You are free to use whatever format for secrets based on your requirements.</li>
<li>The <code>ClientSecrets</code> in this example uses a <code>UUID</code> that is also hashed using the <code>Sha256()</code> extension method. Again, you are free to use whatever format for secrets based on your requirements.</li>
<li>Client applications will use the <code>ClientId</code> and <code>ClientSecrets</code> to request a <code>Token</code> from <code>IdentityServer4</code>.</li>
<li>The <code>AllowedScopes</code> attribute defines the scopes that a certain client is allowed to access. In this case our configured API resources. Scopes can be used to restrict access to a resource based on read/write permissions.</li>
<li>In <code>IdentityServer4</code> scopes are modelled as resources, which come in two flavors: <code>Identity</code> and <code>API</code>. An <code>Identity resource</code> allows you to model a scope that will return a certain set of claims, while an <code>API resource</code> scope allows you to model access to a protected resource/API. We won't be covering identity resource in this post.</li>
<li>The values we've set are just examples, you would want to change those values to whatever to you want. </li>
</ul>

<h4 id="configuringidentityserver4">Configuring IdentityServer4</h4>

<p>Now that we have in-memory test clients and <code>API</code> resources configured, next is to enable <code>IdentityServer4</code>. The good thing about <code>IdentityServer4</code> is it provides various <a href="http://docs.identityserver.io/en/latest/topics/startup.html">in-memory configurations</a> for us to easily configure <code>IdentityServer</code> from our configured in-memory objects. </p>

<p>Add the following code at <code>ConfigureServices</code> method of <code>Startup.cs</code> file:</p>

<pre><code><span>public</span> <span>void</span> <span>ConfigureServices</span><span>(</span><span>IServiceCollection</span> services<span>)</span>  
<span>{</span>
    services<span>.</span><span>AddIdentityServer</span><span>(</span><span>)</span>
            <span>.</span><span>AddDeveloperSigningCredential</span><span>(</span><span>)</span>
            <span>.</span><span>AddInMemoryApiResources</span><span>(</span>Data<span>.</span>ResourceManager<span>.</span>Apis<span>)</span>
            <span>.</span><span>AddInMemoryClients</span><span>(</span>Data<span>.</span>ClientManager<span>.</span>Clients<span>)</span><span>;</span>

<span>}</span>
</code></pre>

<p>The code above registers <code>IdentityServer</code> and it's dependencies in <code>DI Container</code>. </p>

<p>Since a signing certificate is required for signing and validating tokens, we've used the <code>AddDeveloperSigningCredential()</code> provided by <code>IdentityServer4</code> to automatically generate a signing credential for us to test <code>OAuth</code> functionality during development and prototyping. In real applications, you should consider using <code>AddSigningCredential()</code> instead and provide an <a href="http://docs.identityserver.io/en/latest/topics/crypto.html">asymmetric key</a> pair and signing algorithm to sign and validate tokens. </p>

<p>The <code>AddInMemoryApiResources()</code>and <code>AddInMemoryClients()</code> middlewares register our in-memory stores for our configured clients and  API resources example.</p>

<p>Finally, add the following code at <code>Configure</code> method of <code>Startup.cs</code> file:</p>

<pre><code><span>public</span> <span>void</span> <span>Configure</span><span>(</span><span>IApplicationBuilder</span> app<span>)</span>  
<span>{</span>
    app<span>.</span><span>UseIdentityServer</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>

<p>That simple! We now have a simple <code>Token Server</code> for generating <code>JWTs</code>.</p>

<h4 id="requestingatoken">Requesting a Token</h4>

<p><code>IdentityServer4</code> provides an <code>OIDC</code> discovery endpoint, which can be used to retrieve metadata about the authorization server including the <code>Token Endpoint</code>. The discovery endpoint is available via <code>/.well-known/openid-configuration</code> relative to the base address of your <code>Token Server</code>. For example, if we run the application locally and perform a <code>GET</code> request to the following endpoint:</p>

<pre><code>//localhost:44354/.well-known/openid-configuration  
</code></pre>

<p>We will then be presented with the following <code>JSON</code> schema below:</p>

<pre><code><span>{</span>
    <span>"issuer"</span><span>:</span> <span>"<a href="https://localhost:44354/" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span></a>"</span><span>,</span>
    <span>"jwks_uri"</span><span>:</span> <span>"<a href="https://localhost:44354/.well-known/openid-configuration/jwks" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span><span>/.</span><span>well</span><span>-</span><span>known</span><span>/</span><span>openid</span><span>-</span><span>configuration</span><span>/</span><span>jwks</span></a>"</span><span>,</span>
    <span>"authorization_endpoint"</span><span>:</span> <span>"<a href="https://localhost:44354/connect/authorize" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span><span>/</span><span>connect</span><span>/</span><span>authorize</span></a>"</span><span>,</span>
    <span>"token_endpoint"</span><span>:</span> <span>"<a href="https://localhost:44354/connect/token" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span><span>/</span><span>connect</span><span>/</span><span>token</span></a>"</span><span>,</span>
    <span>"userinfo_endpoint"</span><span>:</span> <span>"<a href="https://localhost:44354/connect/userinfo" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span><span>/</span><span>connect</span><span>/</span><span>userinfo</span></a>"</span><span>,</span>
    <span>"end_session_endpoint"</span><span>:</span> <span>"<a href="https://localhost:44354/connect/endsession" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span><span>/</span><span>connect</span><span>/</span><span>endsession</span></a>"</span><span>,</span>
    <span>"check_session_iframe"</span><span>:</span> <span>"<a href="https://localhost:44354/connect/checksession" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span><span>/</span><span>connect</span><span>/</span><span>checksession</span></a>"</span><span>,</span>
    <span>"revocation_endpoint"</span><span>:</span> <span>"<a href="https://localhost:44354/connect/revocation" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span><span>/</span><span>connect</span><span>/</span><span>revocation</span></a>"</span><span>,</span>
    <span>"introspection_endpoint"</span><span>:</span> <span>"<a href="https://localhost:44354/connect/introspect" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span><span>/</span><span>connect</span><span>/</span><span>introspect</span></a>"</span><span>,</span>
    <span>"device_authorization_endpoint"</span><span>:</span> <span>"<a href="https://localhost:44354/connect/deviceauthorization" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span><span>/</span><span>connect</span><span>/</span><span>deviceauthorization</span></a>"</span><span>,</span>
    <span>"frontchannel_logout_supported"</span><span>:</span> <span>true</span><span>,</span>
    <span>"frontchannel_logout_session_supported"</span><span>:</span> <span>true</span><span>,</span>
    <span>"backchannel_logout_supported"</span><span>:</span> <span>true</span><span>,</span>
    <span>"backchannel_logout_session_supported"</span><span>:</span> <span>true</span><span>,</span>
    <span>"scopes_supported"</span><span>:</span> <span>[</span>
        <span>"app.api.whatever.read"</span><span>,</span>
        <span>"app.api.whatever.write"</span><span>,</span>
        <span>"app.api.whatever.full"</span><span>,</span>
        <span>"app.api.weather"</span><span>,</span>
        <span>"offline_access"</span>
    <span>]</span><span>,</span>
    <span>"claims_supported"</span><span>:</span> <span>[</span><span>]</span><span>,</span>
    <span>"grant_types_supported"</span><span>:</span> <span>[</span>
        <span>"authorization_code"</span><span>,</span>
        <span>"client_credentials"</span><span>,</span>
        <span>"refresh_token"</span><span>,</span>
        <span>"implicit"</span><span>,</span>
        <span>"urn:ietf:params:oauth:grant-type:device_code"</span>
    <span>]</span><span>,</span>
    <span>"response_types_supported"</span><span>:</span> <span>[</span>
        <span>"code"</span><span>,</span>
        <span>"token"</span><span>,</span>
        <span>"id_token"</span><span>,</span>
        <span>"id_token token"</span><span>,</span>
        <span>"code id_token"</span><span>,</span>
        <span>"code token"</span><span>,</span>
        <span>"code id_token token"</span>
    <span>]</span><span>,</span>
    <span>"response_modes_supported"</span><span>:</span> <span>[</span>
        <span>"form_post"</span><span>,</span>
        <span>"query"</span><span>,</span>
        <span>"fragment"</span>
    <span>]</span><span>,</span>
    <span>"token_endpoint_auth_methods_supported"</span><span>:</span> <span>[</span>
        <span>"client_secret_basic"</span><span>,</span>
        <span>"client_secret_post"</span>
    <span>]</span><span>,</span>
    <span>"id_token_signing_alg_values_supported"</span><span>:</span> <span>[</span>
        <span>"RS256"</span>
    <span>]</span><span>,</span>
    <span>"subject_types_supported"</span><span>:</span> <span>[</span>
        <span>"public"</span>
    <span>]</span><span>,</span>
    <span>"code_challenge_methods_supported"</span><span>:</span> <span>[</span>
        <span>"plain"</span><span>,</span>
        <span>"S256"</span>
    <span>]</span><span>,</span>
    <span>"request_parameter_supported"</span><span>:</span> <span>true</span>
<span>}</span>
</code></pre>

<p>We can see that the <code>Token Endpoint</code> can be accessed at: <code>https://&lt;YOUR-TOKENSERVER-DOMAIN&gt;/connect/token</code> endpoint. Also notice the <code>app.api.whatever.read</code>, <code>app.api.whatever.write</code>, <code>app.api.whatever.full</code> and <code>app.api.weather</code> scopes that we have configured earlier are added under the <code>scopes_supported</code> attribute.</p>

<p>Now, let's do a quick test for requesting a <code>JWT</code> using the <code>Clients</code> we've configured by issuing a <code>POST</code> <code>Http</code> request in <a href="https://www.postman.com/">POSTMAN</a>:</p>

<pre><code><span><span>POST</span> /connect/token HTTP/1.1</span>  
 localhost:44354  
 application/x-www-form-urlencoded  
client_id=t8agr5xKt4$3&amp;  
client_secret=eb300de4-add9-42f4-a3ac-abd3c60f1919&amp;  
grant_type=client_credentials&amp;  
scope=app.api.whatever.read app.api.whatever.write  
</code></pre>

<p>We should be presented with the following <code>Http</code> response in <code>JSON</code> format:</p>

<pre><code><span>{</span>
    <span>"access_token"</span><span>:</span> <span>"eyJhbGciOiJSUzI1NiIsImtpZCI6IlJMUGVHQVhlQkluZFdsdVFwclBBdEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE1ODE5MjM5MzQsImV4cCI6MTU4MTkyNzUzNCwiaXNzIjoiaHR0cHM6Ly9sb2NhbGhvc3Q6NDQzNTQiLCJhdWQiOiJhcHAuYXBpLndoYXRldmVyIiwiY2xpZW50X2lkIjoidDhhZ3I1eEt0NCQzIiwic2NvcGUiOlsiYXBwLmFwaS53aGF0ZXZlci5yZWFkIiwiYXBwLmFwaS53aGF0ZXZlci53cml0ZSJdfQ.lWQflS4xUe8hPcPHPjaTenOu7XkSWtsLHY4IGqLxu4AUtM0Ki8XSS2vEaLBfp5rIxgvjSMKbwv2SMJJCOPeB8Ck0L62ohldmAvs2fhiYYNNg4_Oz3ljVfbQz6zdP8xAVc6LKXXVM3Ed8GO_yRAgFDOOCfpiimj81h4QPd8yCrpWvHDihxsvwtCVGBQVQRMEv85fYhWoJ8qeX4sj2sW-dcuLzj-DFsPfqcX-BggXw5O4JVpmQ8QEUNCX1NCkLe8wYhu4GCAwTLK-umhirCSNzBhmAuIV3sXoPWa6VsYK4qJn8OVEOG0vDr8Jd394uauc6NYyxcZsf1qgxPa8-LRm_xA"</span><span>,</span>
    <span>"expires_in"</span><span>:</span> <span>3600</span><span>,</span>
    <span>"token_type"</span><span>:</span> <span>"Bearer"</span><span>,</span>
    <span>"scope"</span><span>:</span> <span>"app.api.whatever.read app.api.whatever.write"</span>
<span>}</span>
</code></pre>

<p>The value in <code>access_token</code> attribute is the <code>JWT</code>. To verify the content and signature inside <code>JWT</code>, we can use an online tool called <a href="https://jwt.io/">jwt.io</a> to decode the value. Here's the decoded metadata:</p>

<p>HEADER:ALGORITHM &amp; TOKEN TYPE  </p>

<pre><code><span>{</span>
  <span>"alg"</span><span>:</span> <span>"RS256"</span><span>,</span>
  <span>"kid"</span><span>:</span> <span>"RLPeGAXeBIndWluQprPAtA"</span><span>,</span>
  <span>"typ"</span><span>:</span> <span>"at+jwt"</span>
<span>}</span>
</code></pre>

<p>The result above contains a public key Id (<code>kid</code>) and other attributes that will be used by client applications to verify the <code>JWT</code> signature. These attributes are accessible to client applications via the <code>.well-known/openid-configuration/jwks</code> endpoint in the <code>OpenID Connect</code> discovery document:</p>

<pre><code>{
    "keys": [
        {
            "kty": "RSA",
            "use": "sig",
            "kid": "RLPeGAXeBIndWluQprPAtA",
            "e": "AQAB",
            "n": "vkz4dwnAFRZ0KmoI4OXFgd53217md67N-egnTKlJQIF4buNjdpLuGzmivTS7_bkaJa4EnRk9O4LA2E59b_q-hDKV34XPpl5FEnr8SOmeNU2BhFDwKxVodqbw4ovkUH3pH5UOcCOIH-_jYBLxwFK2tsJitn_rfDx1bd_W0OnaFqrrgghYMZqf7EYRxCvqrWl6TURtY_zdvWJOWIWiwI7b8D39AxELGbWPpj9oP7sBFmeImqiPnJsnP3626aiB5FMBJeFKF0lwP86x9ZCSFDVMMQcJsrs-Fr6grWzGq-wR7FChfFhZulQ0vH610x323A491yEpYvyZRXjhEqgtOQRthQ",
            "alg": "RS256"
        }
    ]
}
</code></pre>

<p>The claims above are part of the signing credentials generated by <code>AddDeveloperSigningCredential()</code> call. The generated developer signing credentials will be persisted in a file called <code>tempkey.rsa</code>. By default, the file is created at the root directory of our application. The <code>tempkey.rsa</code> stores the required keys used to sign tokens, allowing for client applications to verify that the contents of the token have not been altered in transit. This involves a private key used to sign the token and a public key to verify the signature.</p>

<blockquote>
  <p>Note: You don't have to check-in the <code>tempkey.rsa</code> file into your source control / git repository, it will be re-created if it is not present.</p>
</blockquote>

<p>PAYLOAD:DATA  </p>

<pre><code><span>{</span>
  <span>"nbf"</span><span>:</span> <span>1581923934</span><span>,</span>
  <span>"exp"</span><span>:</span> <span>1581927534</span><span>,</span>
  <span>"iss"</span><span>:</span> <span>"<a href="https://localhost:44354/" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span></a>"</span><span>,</span>
  <span>"aud"</span><span>:</span> <span>"app.api.whatever"</span><span>,</span>
  <span>"client_id"</span><span>:</span> <span>"t8agr5xKt4$3"</span><span>,</span>
  <span>"scope"</span><span>:</span> <span>[</span>
    <span>"app.api.whatever.read"</span><span>,</span>
    <span>"app.api.whatever.write"</span>
  <span>]</span>
<span>}</span>
</code></pre>

<p>The claims above are the basic metadata for a <code>JWT</code>. </p>

<ul>
<li><code>nbf</code> stands for not before.</li>
<li><code>exp</code> stands for expiry.</li>
<li><code>iss</code> stands for issuer.</li>
<li><code>aud</code> stands for audience. The resource name in which a client is needed to access.</li>
<li><code>client_id</code> the client id of the client application requesting the token.</li>
<li><code>scope</code> the scope in which a client is allowed to access.</li>
</ul>

<h4 id="validatingatoken">Validating a Token</h4>

<p>Since we don't have an ASP.NET Core API application that we can use to test yet, we can take advantage of the token introspection endpoint of IdentityServer4 to validate the token. This simulates as if we were an <code>OAuth</code> resource receiving it from an external client. </p>

<p>The token introspection is available at <code><a href="https://localhost:5001/connect/introspect" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>5001</span><span>/</span><span>connect</span><span>/</span><span>introspect</span></a></code> endpoint. In POSTMAN, we can use <code>Basic Auth</code> and set the <code>ApiResource</code> name as the username and <code>ApiSecret</code> as the password. These values will then be encoded to <code>Base64</code> string. Finally, we can set the <code>JWT</code> as the token parameter.  Here's an example <code>POST</code> <code>Http</code> request:</p>

<pre><code><span><span>POST</span> /connect/introspect HTTP/1.1</span>  
 localhost:5001  
 application/x-www-form-urlencoded  
 Basic YXBwLmFwaS53aGF0ZXZlcjphNzVhNTU5ZC0xZGFiLTRjNjUtOWJjMC1mOGU1OTBjYjM4OGQ=  
token=eyJhbGciOiJSUzI1NiIsImtpZCI6IlJMUGVHQVhlQkluZFdsdVFwclBBdEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE1ODE5MjQ5MTMsImV4cCI6MTU4MTkyODUxMywiaXNzIjoiaHR0cHM6Ly9sb2NhbGhvc3Q6NTAwMSIsImF1ZCI6ImFwcC5hcGkud2hhdGV2ZXIiLCJjbGllbnRfaWQiOiJ0OGFncjV4S3Q0JDMiLCJzY29wZSI6WyJhcHAuYXBpLndoYXRldmVyLnJlYWQiLCJhcHAuYXBpLndoYXRldmVyLndyaXRlIl19.TPhU1v8xeOf7WEu1ApS4Vc5Is_s5ciEYXOrRxk7fEl-5CwAh00psuMtmZ57R6avOmg1kLrcHZQUSNS7UbbIisTcJm6GAdtpuKWvbCV4svagaWKfqntmCJenfYXCJ1ETrTvFYLIW5uSX2sSU8Ve2W8LQOmwlNREvf3QUXFiyODK9S-NO1q2hdVB_cVtVC5EdxSDYbvwJHq-qoz01vL_jdAJl-XBBOqSOGr2htwqsukv6IpvrhPaJzZ6s8oWZ5VOUos1LLc6AeFHmdaTkHqjM34jdmVV2kZ4SycfbM4I6crxTzkK0ou1BCG9e79fsliDrf3OrLmb6rEKSuNZk14s4X_Q  
</code></pre>

<p>If successful, we’ll receive the following claims in a given token echoed back to us:</p>

<pre><code><span>{</span>
    <span>"nbf"</span><span>:</span> <span>1581924913</span><span>,</span>
    <span>"exp"</span><span>:</span> <span>1581928513</span><span>,</span>
    <span>"iss"</span><span>:</span> <span>"<a href="https://localhost:5001/" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>5001</span></a>"</span><span>,</span>
    <span>"aud"</span><span>:</span> <span>"app.api.whatever"</span><span>,</span>
    <span>"client_id"</span><span>:</span> <span>"t8agr5xKt4$3"</span><span>,</span>
    <span>"active"</span><span>:</span> <span>true</span><span>,</span>
    <span>"scope"</span><span>:</span> <span>"app.api.whatever.read app.api.whatever.write"</span>
<span>}</span>
</code></pre>

<h2 id="creatingasimpleapiresource">Creating A Simple API Resource</h2>

<p>Let's create an ASP.NET Core API that will act as an audience for our Token Server. Add a new project to our exiting solution. Create a new <strong>ASP.NET Core Web Application</strong> project and select <strong>API</strong> project template.</p>

<p>Visual Studio scaffolds all the necessary files and dependencies to help you get started building RESTful APIs in ASP.NET Core. The generated template includes a <code>WeatherForecastController</code> to simulate a simple <code>GET</code> <code>Http</code> request using a static data as shown in the code below:</p>

<pre><code><span>namespace</span> IdentityServer4Demo<span>.</span>WeatherApi<span>.</span>Controllers  
<span>{</span>
    <span>[</span><span>ApiController</span><span>]</span>
    <span>[</span><span>Route</span><span>(</span><span>"[controller]"</span><span>)</span><span>]</span>
    <span>public</span> <span>class</span> <span>WeatherForecastController</span> <span>:</span> <span>ControllerBase</span>
    <span>{</span>
        <span>private</span> <span>static</span> <span>readonly</span> <span>string</span><span>[</span><span>]</span> Summaries <span>=</span> <span>new</span><span>[</span><span>]</span>
        <span>{</span>
            <span>"Freezing"</span><span>,</span> <span>"Bracing"</span><span>,</span> <span>"Chilly"</span><span>,</span> 
            <span>"Cool"</span><span>,</span> <span>"Mild"</span><span>,</span> <span>"Warm"</span><span>,</span> <span>"Balmy"</span><span>,</span> 
            <span>"Hot"</span><span>,</span> <span>"Sweltering"</span><span>,</span> <span>"Scorching"</span>
        <span>}</span><span>;</span>

        <span>private</span> <span>readonly</span> ILogger<span>&lt;</span>WeatherForecastController<span>&gt;</span> _logger<span>;</span>

        <span>public</span> <span>WeatherForecastController</span><span>(</span>ILogger<span>&lt;</span>WeatherForecastController<span>&gt;</span> logger<span>)</span>
        <span>{</span>
            _logger <span>=</span> logger<span>;</span>
        <span>}</span>

        <span>[</span><span>HttpGet</span><span>]</span>
        <span>public</span> IEnumerable<span>&lt;</span>WeatherForecast<span>&gt;</span> <span>Get</span><span>(</span><span>)</span>
        <span>{</span>
            <span>var</span> rng <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>
            <span>return</span> Enumerable<span>.</span><span>Range</span><span>(</span><span>1</span><span>,</span> <span>5</span><span>)</span><span>.</span><span>Select</span><span>(</span>index <span>=&gt;</span> <span>new</span> <span>WeatherForecast</span>
            <span>{</span>
                Date <span>=</span> DateTime<span>.</span>Now<span>.</span><span>AddDays</span><span>(</span>index<span>)</span><span>,</span>
                TemperatureC <span>=</span> rng<span>.</span><span>Next</span><span>(</span><span>-</span><span>20</span><span>,</span> <span>55</span><span>)</span><span>,</span>
                Summary <span>=</span> Summaries<span>[</span>rng<span>.</span><span>Next</span><span>(</span>Summaries<span>.</span>Length<span>)</span><span>]</span>
            <span>}</span><span>)</span>
            <span>.</span><span>ToArray</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>

<p>Notice that the <code>Controller</code> and <code>Action</code> method isn't protected by default. This means that we should be able to access the <code>/WeatherForecast</code> endpoint by invoking a <code>GET</code> <code>Http</code> request:</p>

<p>Let's run the application to ensure that our <code>API</code> is working as we expected. You should be presented with the following output in <code>JSON</code> format:</p>

<pre><code><span>[</span>
    <span>{</span>
        <span>"date"</span><span>:</span> <span>"2020-02-18T10:23:51.0316366-06:00"</span><span>,</span>
        <span>"temperatureC"</span><span>:</span> <span>31</span><span>,</span>
        <span>"temperatureF"</span><span>:</span> <span>87</span><span>,</span>
        <span>"summary"</span><span>:</span> <span>"Mild"</span>
    <span>}</span><span>,</span>
    <span>{</span>
        <span>"date"</span><span>:</span> <span>"2020-02-19T10:23:51.0316788-06:00"</span><span>,</span>
        <span>"temperatureC"</span><span>:</span> <span>36</span><span>,</span>
        <span>"temperatureF"</span><span>:</span> <span>96</span><span>,</span>
        <span>"summary"</span><span>:</span> <span>"Warm"</span>
    <span>}</span><span>,</span>
    <span>{</span>
        <span>"date"</span><span>:</span> <span>"2020-02-20T10:23:51.0316796-06:00"</span><span>,</span>
        <span>"temperatureC"</span><span>:</span> <span>22</span><span>,</span>
        <span>"temperatureF"</span><span>:</span> <span>71</span><span>,</span>
        <span>"summary"</span><span>:</span> <span>"Cool"</span>
    <span>}</span><span>,</span>
    <span>{</span>
        <span>"date"</span><span>:</span> <span>"2020-02-21T10:23:51.0316802-06:00"</span><span>,</span>
        <span>"temperatureC"</span><span>:</span> <span>-5</span><span>,</span>
        <span>"temperatureF"</span><span>:</span> <span>24</span><span>,</span>
        <span>"summary"</span><span>:</span> <span>"Cool"</span>
    <span>}</span><span>,</span>
    <span>{</span>
        <span>"date"</span><span>:</span> <span>"2020-02-22T10:23:51.0316805-06:00"</span><span>,</span>
        <span>"temperatureC"</span><span>:</span> <span>-18</span><span>,</span>
        <span>"temperatureF"</span><span>:</span> <span>0</span><span>,</span>
        <span>"summary"</span><span>:</span> <span>"Bracing"</span>
    <span>}</span>
<span>]</span>
</code></pre>

<p>Great! </p>

<h4 id="protectingtheapiwithjwt">Protecting the API with JWT</h4>

<p>Now let's secure the <code>WeatherForecast</code> endpoints. First, install <code>IdentityServer4.AccessTokenValidation</code>:</p>

<pre><code>PM&gt; Install-Package IdentityServer4.AccessTokenValidation -Version 3.0.1  
</code></pre>

<p><code>IdentityServer4.AccessTokenValidation</code> is an ASP.NET Core authentication handler to validate <code>JWT</code> and reference tokens from IdentityServer4. Now, let's setup <code>JWT</code> Authentication Handler with IdentityServer4 by adding the following code at <code>ConfigureServices</code> method of <code>Startup.cs</code> file:</p>

<pre><code><span>public</span> <span>void</span> <span>ConfigureServices</span><span>(</span><span>IServiceCollection</span> services<span>)</span>  
<span>{</span>
    services<span>.</span><span>AddAuthentication</span><span>(</span>IdentityServerAuthenticationDefaults<span>.</span>AuthenticationScheme<span>)</span>
            <span>.</span><span>AddIdentityServerAuthentication</span><span>(</span>options <span>=&gt;</span>
            <span>{</span>
                options<span>.</span>Authority <span>=</span> <span>"<a href="https://localhost:44354/" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span></a>"</span><span>;</span>
                options<span>.</span>ApiName <span>=</span> <span>"app.api.weather"</span><span>;</span>
            <span>}</span><span>)</span><span>;</span>

    services<span>.</span><span>AddControllers</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>

<p>The code above adds Authentication support using "Bearer" as the default scheme. It then configures IdentityServer Authentication handler. The <code>Authority</code> is the base Url to where your IdentityServer is hosted, in this example our Token Server sits at <code><a href="https://localhost:44354/" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>44354</span></a></code>. The <code>ApiName</code> should be registered in your IdentityServer as an <code>Audience</code>. The <code>RequireHttpsMetadata</code> property is turned off by default and you should turn it on when you deploy the app in production.</p>

<p>When our APIs are decorated with the <code>[Authorize]</code> attribute, then the requesting clients should provide the access token generated from IdentityServer and pass it as a <code>Bearer Authorization Header</code> before they can be granted access to our <code>API</code> endpoints.</p>

<p>Now let's go back the <code>WeatherForecast Controller</code> and then decorate it with the <code>[Authorize]</code> attribute:</p>

<pre><code><span>[</span><span>ApiController</span><span>]</span>
<span>[</span><span>Authorize</span><span>]</span>
<span>[</span><span>Route</span><span>(</span><span>"[controller]"</span><span>)</span><span>]</span>
<span>public</span> <span>class</span> <span>WeatherForecastController</span> <span>:</span> <span>ControllerBase</span>  
<span>{</span>
    
<span>}</span>
</code></pre>

<p>Finally, add the <code>UseAuthentication()</code> middleware to the pipeline between <code>UseRouting()</code> and <code>UseAuthorization()</code> calls:</p>

<pre><code><span>public</span> <span>void</span> <span>Configure</span><span>(</span><span>IApplicationBuilder</span> app<span>,</span> <span>IWebHostEnvironment</span> env<span>)</span>  
<span>{</span>
    

    app<span>.</span><span>UseRouting</span><span>(</span><span>)</span><span>;</span>
    app<span>.</span><span>UseAuthentication</span><span>(</span><span>)</span><span>;</span>
    app<span>.</span><span>UseAuthorization</span><span>(</span><span>)</span><span>;</span>

    
<span>}</span>
</code></pre>

<p>That simple! We now have a simple <code>API Resource</code> that is protected by <code>JWT Bearer Authentication</code> scheme.</p>

<h4 id="testingtheapiendpoint">Testing the API Endpoint</h4>

<p>Since this demo is composed of two projects and our ASP.NET Core API application relies on our <code>Token Server</code> application, we need to make the <code>Token Server</code> accessible when testing the <code>API Resource</code>. Typically, we will host or deploy both projects in a web server to be able to connect between them. Luckily, one of the cool features since Visual Studio 2017 is to enable multiple start-up projects. This means that we could run both applications simultaneously within Visual Studio. All you need to do is:</p>

<ol>
<li>Right click on the Solution  </li>
<li>Select <code>Set Startup Projects...</code>  </li>
<li>Select <code>Multiple Startup Projects</code> radio button  </li>
<li>Select <code>Start</code> as the action for both ASP.NET Core Api and Token Server project  </li>
<li>Click <code>Apply</code> and then <code>OK</code>  </li>
<li>Now build and run the application. </li>
</ol>

<p>You will see that our <code>/WeatherForecast</code> <code>GET</code> endpoint is now returning an <code>Http</code> <code>401</code> Error, and means we are now <code>Unauthorize</code> to access that endpoint:</p>

<p><img src="https://proudmonkeystorage.blob.core.windows.net/cdn/2020Feb17/weather_response_401.PNG" alt=""></p>

<p>In order for us to be authorized, we need a <code>JWT</code> bearer from our <code>Token Server</code>. Let's use POSTMAN once again to request a <code>JWT</code>, and this time we will use the <code>Client Application2</code> credential since our <code>WeatherForecast</code> application use the <code>app.api.weather</code> as the <code>ApiName</code> which we already have configured in our <code>Token Server</code> earlier. Here's the sample <code>POST</code> <code>Http</code> request for getting a <code>JWT</code>: </p>

<pre><code><span><span>POST</span> /connect/token HTTP/1.1</span>  
 localhost:44354  
 application/x-www-form-urlencoded  
client_id=3X=nNv?Sgu$S&amp;  
client_secret=1554db43-3015-47a8-a748-55bd76b6af48&amp;  
grant_type=client_credentials&amp;  
scope=app.api.weather  
</code></pre>

<p>The response should give us the <code>JWT</code> contained in <code>access_token</code> attribute:</p>

<pre><code><span>{</span>
    <span>"access_token"</span><span>:</span> <span>"eyJhbGciOiJSUzI1NiIsImtpZCI6IlJMUGVHQVhlQkluZFdsdVFwclBBdEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE1ODE5NjE1ODgsImV4cCI6MTU4MTk2NTE4OCwiaXNzIjoiaHR0cHM6Ly9sb2NhbGhvc3Q6NDQzNTQiLCJhdWQiOiJhcHAuYXBpLndlYXRoZXIiLCJjbGllbnRfaWQiOiIzWD1uTnY_U2d1JFMiLCJzY29wZSI6WyJhcHAuYXBpLndlYXRoZXIiXX0.tlL_-h8cXxogjOgqvU6tnQwGo9hjAHZS36MIi-M80Q4EqdGSobx1UJM0erd14YolYjtFpAHOr6HajUEzZBePnnkUhWt3zE1Jom6NKMmMB0wWOX8fiEoDtSetrbJNtQ24gOTRRA4mAJobNQtqERYmq0CUCwwcCQ3x7w0igiynZbYTAZPGz_yBDy0XK8Q_SIikD7x9M6OWizvOzcYEobzeVa5Sdt7nE5T4-0vpEllf2-yrF63rxthiZ4WYuT8qFXcFHV1MbzB2skmr66uGyX4Uqs-QZeIt-h0rSQSY6FMprlQf6xwXAk0L8H7SIIWiYFf6u2SHe8CUb1NJsFjZTbed2w"</span><span>,</span>
    <span>"expires_in"</span><span>:</span> <span>3600</span><span>,</span>
    <span>"token_type"</span><span>:</span> <span>"Bearer"</span><span>,</span>
    <span>"scope"</span><span>:</span> <span>"app.api.weather"</span>
<span>}</span>
</code></pre>

<p>Copy the value of <code>access_token</code> and then create a new tab in POSTMAN to test out our <code>/WeatherForecast</code> endpoint. Here's the sample <code>GET</code> <code>Http</code> request with the <code>Bearer Authorization</code> header:</p>

<pre><code><span><span>GET</span> /weatherforecast HTTP/1.1</span>  
 localhost:44380  
 application/json  
 Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlJMUGVHQVhlQkluZFdsdVFwclBBdEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE1ODE5NjE1ODgsImV4cCI6MTU4MTk2NTE4OCwiaXNzIjoiaHR0cHM6Ly9sb2NhbGhvc3Q6NDQzNTQiLCJhdWQiOiJhcHAuYXBpLndlYXRoZXIiLCJjbGllbnRfaWQiOiIzWD1uTnY_U2d1JFMiLCJzY29wZSI6WyJhcHAuYXBpLndlYXRoZXIiXX0.tlL_-h8cXxogjOgqvU6tnQwGo9hjAHZS36MIi-M80Q4EqdGSobx1UJM0erd14YolYjtFpAHOr6HajUEzZBePnnkUhWt3zE1Jom6NKMmMB0wWOX8fiEoDtSetrbJNtQ24gOTRRA4mAJobNQtqERYmq0CUCwwcCQ3x7w0igiynZbYTAZPGz_yBDy0XK8Q_SIikD7x9M6OWizvOzcYEobzeVa5Sdt7nE5T4-0vpEllf2-yrF63rxthiZ4WYuT8qFXcFHV1MbzB2skmr66uGyX4Uqs-QZeIt-h0rSQSY6FMprlQf6xwXAk0L8H7SIIWiYFf6u2SHe8CUb1NJsFjZTbed2w  
</code></pre>

<p>Now we should be able to see a <code>Http</code> Status <code>200</code> back with the response from <code>/weatherforecast</code> <code>GET</code> call:</p>

<p><img src="https://proudmonkeystorage.blob.core.windows.net/cdn/2020Feb17/weather_response.PNG" alt=""></p>



<p>If you are reading this post and haven't tried using <code>ApiBoilerPlate</code> for building your ASP.NET Core APIs, then head over to the official repository here: <a href="https://github.com/proudmonkey/ApiBoilerPlate">https://github.com/proudmonkey/ApiBoilerPlate</a>.</p>

<p>The template uses <code>IdentityServer4</code> <code>AccessTokenValidation</code> as well to authenticate and validate access tokens. You can find the code that configures IdentityServer Authentication under <code>Installers/RegisterIdentityServerAuthentication.cs</code> file. Here’s the code snippet:</p>

<pre><code>services<span>.</span><span>AddAuthentication</span><span>(</span>IdentityServerAuthenticationDefaults<span>.</span>AuthenticationScheme<span>)</span>  
    <span>.</span><span>AddIdentityServerAuthentication</span><span>(</span>options <span>=&gt;</span>
    <span>{</span>
        options<span>.</span>Authority <span>=</span> config<span>[</span><span>"ApiResourceBaseUrls:AuthServer"</span><span>]</span><span>;</span>
        options<span>.</span>RequireHttpsMetadata <span>=</span> <span>false</span><span>;</span>
        options<span>.</span>ApiName <span>=</span> <span>"api.boilerplate.core"</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>

<p>The template automatically handles requesting a token for you. At line 61 of <a href="https://github.com/proudmonkey/ApiBoilerPlate/blob/master/ApiBoilerPlate/Infrastructure/Installers/RegisterApiResources.cs">Infrastructure/Installers/RegisterApiResources.cs</a> class, you can find that the <code>OIDC Discover Endpoint</code> is injected as a <code>Singleton</code>:</p>

<pre><code>services<span>.</span><span><span>AddSingleton</span><span>&lt;</span><span>IDiscoveryCache</span><span>&gt;</span></span><span>(</span>r <span>=&gt;</span>  
<span>{</span>
    <span>var</span> factory <span>=</span> r<span>.</span><span><span>GetRequiredService</span><span>&lt;</span><span>IHttpClientFactory</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>new</span> <span>DiscoveryCache</span><span>(</span>config<span>[</span><span>"ApiResourceBaseUrls:AuthServer"</span><span>]</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> factory<span>.</span><span>CreateClient</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>

<p>This means that everytime you instantiate the <code>HttpClient</code> object, the discovery endpoint is binded automatically, allowing you to call the token endpoint directly without configuring them all over again. The <code>DiscoveryCache</code> object pulls the base Url of the Token Server configured in appsettings.json:</p>

<pre><code><span>"ApiResourceBaseUrls"</span><span>:</span> <span>{</span>
    <span>"AuthServer"</span><span>:</span> <span>"<a href="https://localhost:5000/" rel="nofollow"><span>https</span><span>://</span><span>localhost</span><span>:</span><span>5000</span></a>"</span>
<span>}</span>
</code></pre>

<p>Keep in mind that you need to change the value of <code>AuthServer</code> attribute to where your Token Server is hosted. </p>

<h4 id="requestingclientcredentialstoken">Requesting Client Credentials Token</h4>

<p>You can see how a token request is being configured at <a href="https://github.com/proudmonkey/ApiBoilerPlate/blob/master/ApiBoilerPlate/Services/AuthServerConnect.cs">Services/AuthServerConnect.cs</a> class:</p>

<pre><code><span>namespace</span> ApiBoilerPlate<span>.</span>Services  
<span>{</span>
    <span>public</span> <span>class</span> <span>AuthServerConnect</span> <span>:</span> <span>IAuthServerConnect</span>
    <span>{</span>
        <span>private</span> <span>readonly</span> <span>HttpClient</span> _httpClient<span>;</span>
        <span>private</span> <span>readonly</span> <span>IDiscoveryCache</span> _discoveryCache<span>;</span>
        <span>private</span> <span>readonly</span> ILogger<span>&lt;</span>AuthServerConnect<span>&gt;</span> _logger<span>;</span>
        <span>private</span> <span>readonly</span> <span>IConfiguration</span> _config<span>;</span>

        <span>public</span> <span>AuthServerConnect</span><span>(</span><span>HttpClient</span> httpClient<span>,</span> <span>IConfiguration</span> config<span>,</span> <span>IDiscoveryCache</span> discoveryCache<span>,</span> ILogger<span>&lt;</span>AuthServerConnect<span>&gt;</span> logger<span>)</span>
        <span>{</span>
            _httpClient <span>=</span> httpClient<span>;</span>
            _config <span>=</span> config<span>;</span>
            _discoveryCache <span>=</span> discoveryCache<span>;</span>
            _logger <span>=</span> logger<span>;</span>
        <span>}</span>
        <span>public</span> <span>async</span> Task<span>&lt;</span><span>string</span><span>&gt;</span> <span>RequestClientCredentialsTokenAsync</span><span>(</span><span>)</span>
        <span>{</span>

            <span>var</span> endPointDiscovery <span>=</span> <span>await</span> _discoveryCache<span>.</span><span>GetAsync</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>endPointDiscovery<span>.</span>IsError<span>)</span>
            <span>{</span>
                _logger<span>.</span><span>Log</span><span>(</span>LogLevel<span>.</span>Error<span>,</span> $<span>"ErrorType: {endPointDiscovery.ErrorType} Error: {endPointDiscovery.Error}"</span><span>)</span><span>;</span>
                <span>throw</span> <span>new</span> <span>HttpRequestException</span><span>(</span><span>"Something went wrong while connecting to the AuthServer Token Endpoint."</span><span>)</span><span>;</span>
            <span>}</span>

            <span>var</span> tokenResponse <span>=</span> <span>await</span> _httpClient<span>.</span><span>RequestClientCredentialsTokenAsync</span><span>(</span><span>new</span> <span>ClientCredentialsTokenRequest</span>
            <span>{</span>
                Address <span>=</span> endPointDiscovery<span>.</span>TokenEndpoint<span>,</span>
                ClientId <span>=</span> _config<span>[</span><span>"Self:Id"</span><span>]</span><span>,</span>
                ClientSecret <span>=</span> _config<span>[</span><span>"Self:Secret"</span><span>]</span><span>,</span>
                Scope <span>=</span> <span>"SampleApiResource"</span>
            <span>}</span><span>)</span><span>;</span>

            <span>if</span> <span>(</span>tokenResponse<span>.</span>IsError<span>)</span>
            <span>{</span>
                _logger<span>.</span><span>Log</span><span>(</span>LogLevel<span>.</span>Error<span>,</span> $<span>"ErrorType: {tokenResponse.ErrorType} Error: {tokenResponse.Error}"</span><span>)</span><span>;</span>
                <span>throw</span> <span>new</span> <span>HttpRequestException</span><span>(</span><span>"Something went wrong while requesting Token to the AuthServer."</span><span>)</span><span>;</span>
            <span>}</span>

            <span>return</span> tokenResponse<span>.</span>AccessToken<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>

<p>The code snippet above request an access token from IndentityServer Token endpoint via the <code>DiscoveryCache</code> by passing the registered <code>ClientId</code>, <code>ClientSecret</code> and <code>Scope</code> in your Token Server. The <code>ClientId</code> and <code>ClientSecret</code> are also contained appsettings.json file:</p>

<pre><code><span>"Self"</span><span>:</span> <span>{</span>
    <span>"Id"</span><span>:</span> <span>"api.boilerplate.core"</span><span>,</span>
    <span>"Secret"</span><span>:</span> <span>"0a2e472b-f263-43fd-8372-3b13f5acf222"</span>
<span>}</span>
</code></pre>

<blockquote>
  <p>Tip: In production or real application, you should consider storing the secrets and keys in a more secured location like database or cloud vault.</p>
</blockquote>

<p>The <code>RequestClientCredentialsTokenAsync()</code> method will then be called each time you issue an <code>Http</code> requests via <code>HttpClient</code>. This process is encapsulated in a custom bearer token <code>DelegatingHandler</code> class called <a href="https://github.com/proudmonkey/ApiBoilerPlate/blob/master/ApiBoilerPlate/Infrastructure/Handlers/ProtectedApiBearerTokenHandler.cs">ProtectedApiBearerTokenHandler</a>. Here’s the code snippet:</p>

<pre><code><span>namespace</span> ApiBoilerPlate<span>.</span>Infrastructure<span>.</span>Handlers  
<span>{</span>
    <span>public</span> <span>class</span> <span>ProtectedApiBearerTokenHandler</span> <span>:</span> <span>DelegatingHandler</span>
    <span>{</span>
        <span>private</span> <span>readonly</span> <span>IAuthServerConnect</span> _authServerConnect<span>;</span>

        <span>public</span> <span>ProtectedApiBearerTokenHandler</span><span>(</span><span>IAuthServerConnect</span> authServerConnect<span>)</span>
        <span>{</span>
            _authServerConnect <span>=</span> authServerConnect<span>;</span>
        <span>}</span>

        <span>protected</span> <span>override</span> <span>async</span> Task<span>&lt;</span>HttpResponseMessage<span>&gt;</span> <span>SendAsync</span><span>(</span><span>HttpRequestMessage</span> request<span>,</span> <span>CancellationToken</span> cancellationToken<span>)</span>
        <span>{</span>
            
            <span>var</span> accessToken <span>=</span> <span>await</span> _authServerConnect<span>.</span><span>RequestClientCredentialsTokenAsync</span><span>(</span><span>)</span><span>;</span>

            
            request<span>.</span><span>SetBearerToken</span><span>(</span>accessToken<span>)</span><span>;</span>

            
            <span>return</span> <span>await</span> <span>base</span><span>.</span><span>SendAsync</span><span>(</span>request<span>,</span> cancellationToken<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>

<p>We can then register the <code>ProtectedApiBearerTokenHandler</code> as a <code>Transient</code> service in <code>ConfigureServices</code> method in <code>Startup.cs</code>:</p>

<pre><code>services<span>.</span><span><span>AddTransient</span><span>&lt;</span><span>ProtectedApiBearerTokenHandler</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>  
</code></pre>

<p>That's it! I hope you'll find this post helpful!</p>



<p>The source code for this demo is available in my GitHub repository here: <a href="https://github.com/proudmonkey/IdentityServer4Demo">https://github.com/proudmonkey/IdentityServer4Demo</a></p>



<ul>
<li><a href="https://blog.logrocket.com/jwt-authentication-best-practices/">JWT Authentication Best Practices</a></li>
<li><a href="https://blog.logrocket.com/how-to-secure-a-rest-api-using-jwt-7efd83e71432/">How to Secure a REST Api using JWT</a></li>
<li><a href="https://zapier.com/engineering/apikey-oauth-jwt/">ApiKey vs OAuth vs JWT</a></li>
<li><a href="https://www.scottbrady91.com/Identity-Server/Getting-Started-with-IdentityServer-4">Getting Started with IdentityServer4</a></li>
<li><a href="http://docs.identityserver.io/en/latest/topics/apis.html">Protecting APIs with IdentityServer4</a></li>
<li><a href="http://vmsdurano.com/apiboilerplate-new-features-and-improvements-for-building-asp-net-core-3-apis/">ApiBoilerPlate: New Features and Improvements for Building ASP.NET Core 3 APIs</a></li>
</ul>
        <a href="https://www.buymeacoffee.com/ImP9gONBW" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/yellow_img.png" alt="Buy Me A Coffee"></a>
		
		
		
        </section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>