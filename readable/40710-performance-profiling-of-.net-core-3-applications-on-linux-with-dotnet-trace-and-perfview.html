<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Performance Profiling of .NET Core 3 applications on Linux with dotnet-trace and PerfView -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Performance Profiling of .NET Core 3 applications on Linux with dotnet-trace and PerfView</h1>
    <div class="post-content entry-content"> <p>Performance issues never seem to disappear from the world, no matter how fast new computers become. To deal with those issues we need proper tools. In the world of .NET development, we can consider ourselves lucky in this regard. We have some of the best tools available, at least on Windows. On .NET Core with Linux, things are not so great. But they&#x2019;re getting better.</p>
<p>With .NET Core 3, Microsoft <a href="https://devblogs.microsoft.com/dotnet/introducing-diagnostics-improvements-in-net-core-3-0/">introduced</a> a bunch of new much-needed diagnostic tools:</p> <p>In this article, we&#x2019;re going to do some performance analysis with <strong>dotnet-trace</strong> and <strong>PerfView</strong>. But before that, let&#x2019;s talk a bit about how we did things up to now, in Windows. And why we can&#x2019;t do that with .NET Core in Linux.</p>
<h2>Performance Profiling in Windows</h2>
<p>I already said we have some great tools on Windows. Let&#x2019;s go over them:</p>
<h3>1. Classic Performance profilers</h3>
<p>There are 3 major performance profilers in the .NET market:</p> <p>A profiler allows you to record a runtime snapshot and analyze it for performance issues. You&#x2019;ll be able to break execution time into methods and find out how much time each method took. You&#x2019;ll see time of network requests, I/O requests, system code vs user code and a myriad of other metrics to help you figure out the problem.</p>
<p>Unfortunately, these profilers don&#x2019;t run on Linux (although they do support .NET Core apps on Windows).</p>
<h6><strong>Update:</strong> dotTrace early access 2019.3 command line tools <a href="https://blog.jetbrains.com/dotnet/2019/10/25/resharper-ultimate-2019-3-eap/">now support</a> profiling .NET Core apps on Linux. Rider early access 2019.3 <a href="https://blog.jetbrains.com/dotnet/2019/10/25/rider-2019-3-eap/">can now profile</a> on a Linux machine with a dotTrace extension. Thanks to @falconandy for the update.</h6>
<h3>2. Performance Counters</h3>
<p><a href="https://michaelscodingspot.com/performance-counters/">Performance counters</a> show a bunch of metrics to get an overall sense of your app&#x2019;s performance. Those include:</p>
<ul>
<li><strong>% Processor Time</strong> (Total or per process)</li>
<li><strong>Private Bytes</strong> &#x2013; Shows process memory (both managed and native). </li>
<li><strong>Gen X Collections</strong> &#x2013; Number of garbage collector collections in the generation.</li>
<li><strong>IO Data Bytes/sec</strong> &#x2013; Bytes written or read to file/network or another resource.</li>
<li><strong># of Exceptions thrown / sec</strong> &#x2013; A large number of (first-chance) exceptions thrown in a second can significantly hurt performance.</li> </ul>
<p>And hundreds more.</p>
<p>Just looking at performance counters can indicate if you have a CPU problem, an I/O problem, a contention problem or a problem with too many exceptions.</p>
<p>Linux has a sort of equivalent tool called <a href="http://www.brendangregg.com/perf.html">Perf</a> but we don&#x2019;t have an easy way to consume these counters like with <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/perfmon">PerfMon</a> on Windows. The new <strong>dotnet-counters</strong> solves this problem and allows to easily consume performance counters from .NET Core on Linux.</p>
<h3>3. ETW Events and CPU Stacks Profiling with PerfView</h3>
<p>Another way to profile performance problems is with <a href="https://github.com/microsoft/perfview">PerfView</a>&#x2018;s CPU Stack sampling. PerfView is a great tool to analyze ETW events, GC and CPU usage. It&#x2019;s less intuitive than the commercial performance profilers but in some ways more powerful.</p>
<p>Here&#x2019;s the general idea of how we do performance profiling with PerfView: First, collect system-wide CPU Stack samples every millisecond (or every X milliseconds). When done collecting, we filter down to a single process and analyze the data much like in a classic performance profiler. You&#x2019;ll be able to see which methods took the most execution time, method call trees, thread times, and even method call distribution histogram (more on that later).</p>
<p>Analyzing with PerfView adds less performance overhead than attaching a classic performance profiler, which allows you to use it in production environments. It&#x2019;s also free.</p>
<p>Up to now, you could have used <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/linux-performance-tracing.md">PerfCollect</a> to collect performance trace on Linux (.NET Core 2.1+) and analyze in <strong>PerfView</strong>. Now you can do it with <strong>dotnet-trace</strong> as well (.NET Core 3+). There are many differences between <strong>dotnet-trace</strong> and <strong>PerfCollect</strong> which are described <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/linux-performance-tracing.md">here</a>. I think dotnet-trace is easier to use and to analyze the data. It also uses a cross-platform mechanism called <strong>EventPipe</strong> that&#x2019;s built into .NET Core 3.0. This means your analysis is going to be similar on all platforms. In this article, we&#x2019;re going to use the newer <strong>dotnet-trace</strong>.</p>
<h2>Performance Profiling .NET Core on Linux &#x2013; Getting Started</h2>
<p>Here are the steps I followed to collect a performance trace on Linux:</p>
<ol>
<li><strong>Linux machine</strong> &#x2013; For this article, I used Oracle&#x2019;s <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox VM</a> and Ubuntu 18 <a href="https://ubuntu.com/download/desktop">Desktop ISO</a>. After setting up the VM, I installed the .NET Core 3 runtime and SDK as shown in <a href="https://dotnet.microsoft.com/download/linux-package-manager/ubuntu18-04/sdk-current">this guide</a>. I installed the <strong>dotnet-trace</strong> tool with the command: <code>dotnet tool install --global dotnet-trace</code>.</li>
<li><strong>Project to profile</strong> &#x2013; I created a small Console .NET Core 3.0 C# project (available on <a href="https://github.com/michaelscodingspot/PracticalDebugging/tree/master/SortingStrategies">GitHub</a>) that we&#x2019;re going to profile on Linux. The project is taking a number of integers as input and then sorts them in different ways &#x2013; Bubble sort, Quick Sort, and Merge sort.
To publish for .NET Core, I ran the following command:</li> </ol> <div id="crayon-5dc0e5b8198f1984952828" class="crayon-syntax crayon-theme-github crayon-font-consolas crayon-os-pc print-yes notranslate"> <div class="crayon-main"> <table class="crayon-table"> <tr class="crayon-row"> <td class="crayon-nums "> </td> <td class="crayon-code"><div class="crayon-pre"><p class="crayon-line" id="crayon-5dc0e5b8198f1984952828-1"><span class="crayon-e">dotnet </span><span class="crayon-v">publish</span><span class="crayon-h"> </span><span class="crayon-o">--</span><span class="crayon-e">configuration </span><span class="crayon-i">Release</span></p></div></td> </tr> </table> </div> </div> <p>	This created the folder <code>bin\Release\netcoreapp3.0\publish</code>.</p>
<ol>
<li><strong>Execute on Linux</strong> &#x2013; Once installed, I copied the <code>publish</code> folder to the Linux machine and ran it with the <code>dotnet</code> command:</li> </ol>
<p><img src="/wp-content/uploads/2019/11/dotnet-run.png" alt="run with dotnet"></p>
<ol>
<li><strong>Collect a trace</strong> &#x2013; To attach to the process, dotnet-trace allows to list .NET Core processes with the <code>list-processes</code> command:</li> </ol>
<p><img src="/wp-content/uploads/2019/11/dotnet-trace-list-processes.png" alt="dotnet trace list processes"></p>
<p>For some reason, there are always two different processes listed when running the application (2871 &amp; 2955). In any case, the first one is the one relevant.</p>
<p>Unfortunately, dotnet-trace can only attach to a running process, not start it (at least not yet). So profiling issues at startup is still impossible. </p>
<p>Next, I ran this command to do the actual trace collection: <code>dotnet trace collect -p 2871</code>. While the collection was recorded, I completed the Console app scenario.</p>
<p><img src="/wp-content/uploads/2019/11/finished-console-app.png"></p>
<p>Once the process exited, the <strong>dotnet-trace</strong> tool finished as well, creating a <code>trace.nettrace</code> file.</p>
<p><img src="/wp-content/uploads/2019/11/dotnet-trace-collect.png" alt="dotnet trace collect"></p>
<ol>
<li>I copied the <code>trace.nettrace</code> output file to Windows</li> </ol>
<h2>Analyze trace with PerfView</h2>
<p>Now that the collection part is over, it&#x2019;s time to analyze the results. Let&#x2019;s open <code>trace.nettrace</code> file in <a href="https://www.microsoft.com/en-us/download/details.aspx?id=28567">PerfView</a>. We get the following options:</p>
<p><img src="/wp-content/uploads/2019/11/perfview-open-nettrace.png" alt="PerfView open nettrace file"></p> <p>We&#x2019;re interested in <strong>Thread Time</strong> here, which will give CPU Stacks samples of all threads. </p>
<p>Once opened, you can go straight to <strong>CallTree tab</strong> to get the following:</p>
<p><img src="/wp-content/uploads/2019/11/perfview-calltree.png" alt="PerfView call tree"></p>
<p>So that&#x2019;s a whole bunch of information in one screen, but the <strong>Name column</strong> is pretty straightforward. It shows the calling hierarchy in the process. The thread called the method <code>Main</code> which then called <code>Sorter.Start</code> which called <code>ReadLine()</code>, <code>Bubble.Sort()</code>, <code>QuickSort.Sort()</code>, <code>MergeSort.Sort()</code>, and <code>GetRandomNumbers()</code>. </p>
<p>We can look at the column <strong>Inc %</strong> that shows the execution percentage this method took <strong>including</strong> the time taken by the methods it called (callees). You can see that the Bubble sort function took 30.9% of all execution time, Quicksort function took 3% and Merge sort took just 0.1%. Bubble sort took the longest, which makes sense. But if you know a thing or two about sorting algorithms, then you might suspect there&#x2019;s a problem here. Merge sort and Quicksort are both O(n*log(n)) (well, Quicksort is that on average) and it doesn&#x2019;t make sense that merge sort is so much quicker. We&#x2019;ll analyze that a bit later on.</p>
<p>Let&#x2019;s talk more about what we see in this window, starting from the columns</p>
<ul>
<li><strong>Name</strong> &#x2013; name of the method. It also can be a group of functions according to the <strong>GroupPats</strong> strategy.</li>
<li><strong>Inc %</strong> &#x2013; Execution time percentage out of entire collected sample, including methods called by this one (callees)</li>
<li><strong>Inc</strong> &#x2013; Same as Inc % except that the metric is in the number of samples. So if we&#x2019;re taking a sample once a millisecond (default) then it roughly represents the number of milliseconds spent in this method.</li>
<li><strong>Exc %</strong> &#x2013; Execution time percentage out of entire collected sample taken by this method only (Own time), excluding callees.</li>
<li><strong>Exc</strong> &#x2013; Same as Exc % except that the metric is in the number of samples.</li>
<li><strong>Fold</strong> &#x2013; How many were folded into this method.</li>
<li><strong>When</strong> &#x2013; Represents the method calls distribution over time. Starting from left (start of the trace) to right (end of trace). For example, in the above collection, you can see that Bubble Sort was executed from about 60% into the collection to pretty much the very end.</li>
<li><strong>First</strong> &#x2013; Time of the first sample (milliseconds from the start of the trace).</li>
<li><strong>Last</strong> &#x2013; Time of the last sample (milliseconds from the start of the trace).</li> </ul>
<h6>If you look at the <strong>GroupPats</strong> input (top-right corner), you&#x2019;ll see it&#x2019;s set to <strong>[no grouping]</strong>. Unlike in Windows traces, the default of a dotnet-trace is <strong>[group module entries]</strong> which groups all methods from a single module into one line until another module is called. Without going into too many details on grouping and folding, the <strong>[no grouping]</strong> option that I used, expands all lines. A better tactic would be to start from module grouping, find the <strong>SortingStrategies</strong> module of this application and ungroup it. An even better one is the default setting on Windows called <strong>[Just my app]</strong> which ungroups your own application&#x2019;s methods and groups everything else. Unfortunately, this option is still missing when importing from Linux. For more detail on grouping and folding watch <a href="https://channel9.msdn.com/Series/PerfView-Tutorial/PerfVIew-Tutorial-4-Grouping-And-Folding">this tutorial</a> by Vance Morrison.</h6>
<h3>By Name Tab</h3>
<p>Let&#x2019;s investigate the strange difference between Quick Sort and Merge sort. Specifically, I&#x2019;d like to analyze Quicksort and see why it&#x2019;s so slow.</p>
<p>Expanding <code>QuickSort.Sort()</code> simply shows a lot of recursive calls that don&#x2019;t help much.</p>
<p><img src="/wp-content/uploads/2019/11/quicksort-recursive.png"></p>
<p>To help the investigation, we can minimize the analysis to include just Quick Sort time with the <strong>Drill Into</strong> functionality. This will remove all other CPU stacks.</p>
<p><img src="/wp-content/uploads/2019/11/drillInto.png" alt="PerfView drill into"></p>
<p>Now, let&#x2019;s move to the <strong>By Name</strong> tab, which shows just a flat list of methods:</p>
<p><img src="/wp-content/uploads/2019/11/byname-flatlist-perfview.png" alt="By name tab in PerfView"></p>
<p>I usually sort this table by <strong>Inc %</strong> which includes <strong>callees</strong> for each method (includes the time of the methods it called). You can see that <code>Trace.WriteLine</code> took 90.7% of the entire execution time. So for some reason, the <code>QuickSort.Sort()</code> method calls <code>Trace.WriteLine()</code> which destroys its performance. With this new information, it&#x2019;s going to be easy to find the problem. Check out the <a href="https://github.com/michaelscodingspot/PracticalDebugging/blob/master/SortingStrategies/QuickSort.cs">source code</a> of QuickSort and try to find it yourself.</p>
<h2>Summary and Resources</h2>
<p>In this post, we saw how to do performance profiling on a .NET Core 3 process on Linux. This involved installing the dotnet SDK, then installing the <strong>dotnet-trace</strong> tool, collecting a trace of your .NET Core process, copying the trace file to a Windows machine and analyzing with PerfView.</p>
<p>This is probably the best way to do performance analysis today on Linux. Having said that, you can also analyze with <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/linux-performance-tracing.md">PerfCollect</a> and other tools as shown in this very interesting talk by Sasha Goldstein: <a href="https://www.youtube.com/watch?v=O4kTJW91Ri4">Debugging and Profiling .NET Core Apps on Linux</a>. </p>
<p>I&#x2019;d love to see my favorite tools (<a href="https://www.jetbrains.com/profiler/">dotTrace</a>, <a href="https://www.jetbrains.com/dotmemory/">dotMemory</a>, <a href="https://www.red-gate.com/products/dotnet-development/ants-performance-profiler/">ANTS profilers</a>) run on Linux. I don&#x2019;t think there&#x2019;s any hope for ANTS profiler to support it, but there&#x2019;s some hope with JetBrains. They seem to support dotTrace for the Mono runtime, but not .NET Core. This is nice for their <a href="https://www.jetbrains.com/rider/">Rider</a> customers that use Mono runtime with Unity 3D on Mac, but doesn&#x2019;t help us mainstream .NET developers. Fingers crossed.</p>
<h3>More Resources</h3>
<p>Here&#x2019;s the official blog post by Microsoft announcing the new diagnostic tools in .NET Core 3 (dotnet-trace, dotnet-dump, and dotnet-counters): <a href="https://devblogs.microsoft.com/dotnet/introducing-diagnostics-improvements-in-net-core-3-0/">Introducing diagnostics improvements in .NET Core 3.0</a>. Interesting read.</p>
<p>To learn more on PerfView, I really recommend the <a href="https://channel9.msdn.com/Series/PerfView-Tutorial">video tutorials</a> by Vance Morrison on Channel 9.</p> <div class="optin-endofpost optin-endofpost_desktop"> <div> <div> <img src="https://i2.wp.com/michaelscodingspot.com/wp-content/uploads/2017/06/black-small-optimized-flipped.gif?w=1080&amp;ssl=1"> </div> <div> <div> <span>Subscribe to get post updates and:</span> <img src="https://i2.wp.com/michaelscodingspot.com/wp-content/uploads/2019/04/pdf-icon.png?w=1080&amp;ssl=1"> <span> Performance Optimizations in C# .NET: 10 Best Practices</span> </div> </div> </div> </div> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>