<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Building C# 8.0 | .NET Blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Building C# 8.0 | .NET Blog</h1><div><div class="entry-content col-12 sharepostcontent"><h1 class="entry-title">Building C# 8.0</h1><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/02/MadsTorgersen.jpeg" width="58" height="58" alt="Mads Torgersen - MSFT" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 alignnone photo"><p>Mads</p></div></div></div><p>November 12th, 2018</p><h1>Building C# 8.0</h1><p>The next major version of C# is C# 8.0. It’s been in the works for quite some time, even as we built and shipped the minor releases C# 7.1, 7.2 and 7.3, and I’m quite excited about the new capabilities it will bring.</p><p>The current plan is that C# 8.0 will ship at the same time as .NET Core 3.0. However, the features will start to come alive with the previews of Visual Studio 2019 that we are working on. As those come out and you can start trying them out in earnest, we will provide a whole lot more detail about the individual features. The aim of this post is to give you an overview of what to expect, and a heads-up on where to expect it.</p><h1>New features in C# 8.0</h1><p>Here’s an overview of the most significant features slated for C# 8.0. There are a number of smaller improvements in the works as well, which will trickle out over the coming months.</p><h2>Nullable reference types</h2><p>The purpose of this feature is to help prevent the ubiquitous null reference exceptions that have riddled object-oriented programming for half a century now.</p><p>It stops you from putting <code>null</code> into ordinary reference types such as <code>string</code> – it makes those types non-nullable! It does so gently, with warnings, not errors. But on existing code there will be new warnings, so you have to opt in to using the feature (which you can do at the project, file or even source line level).</p><pre class="lang:c# decode:true">string s = null; // Warning: Assignment of null to non-nullable reference type
</pre><p>What if you <em>do</em> want null? Then you can use a <em>nullable reference type</em>, such as <code>string?</code>:</p><pre class="lang:c# decode:true">string? s = null; // Ok
</pre><p>When you try to use a nullable reference, you need to check it for null first. The compiler analyzes the flow of your code to see if a null value could make it to where you use it:</p><pre class="lang:c# decode:true">void M(string? s)
{
    Console.WriteLine(s.Length); // Warning: Possible null reference exception
    if (s != null)
    {
        Console.WriteLine(s.Length); // Ok: You won't get here if s is null
    }
}
</pre><p>The upshot is that C# lets you express your “nullable intent”, and warns you when you don’t abide by it.</p><h2>Async streams</h2><p>The async/await feature of C# 5.0 lets you consume (and produce) asynchronous results in straightforward code, without callbacks:</p><pre class="lang:c# decode:true">async Task&lt;int&gt; GetBigResultAsync()
{
    var result = await GetResultAsync();
    if (result &gt; 20) return result; 
    else return -1;
}
</pre><p>It is not so helpful if you want to consume (or produce) continuous streams of results, such as you might get from an IoT device or a cloud service. Async streams are there for that.</p><p>We introduce <code>IAsyncEnumerable&lt;T&gt;</code>, which is exactly what you’d expect; an asynchronous version of <code>IEnumerable&lt;T&gt;</code>. The language lets you <code>await foreach</code> over these to consume their elements, and <code>yield return</code> to them to produce elements.</p><pre class="lang:c# decode:true">async IAsyncEnumerable&lt;int&gt; GetBigResultsAsync()
{
    await foreach (var result in GetResultsAsync())
    {
        if (result &gt; 20) yield return result; 
    }
}
</pre><h2>Ranges and indices</h2><p>We’re adding a type <code>Index</code>, which can be used for indexing. You can create one from an <code>int</code> that counts from the beginning, or with a prefix <code>^</code> operator that counts from the end:</p><pre class="lang:c# decode:true">Index i1 = 3;  // number 3 from beginning
Index i2 = ^4; // number 4 from end
int[] a = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
Console.WriteLine($"{a[i1]}, {a[i2]}"); // "3, 6"
</pre><p>We’re also introducing a <code>Range</code> type, which consists of two <code>Index</code>es, one for the start and one for the end, and can be written with a <code>x..y</code><em>range expression</em>. You can then index with a <code>Range</code> in order to produce a slice:</p><pre class="lang:c# decode:true">var slice = a[i1..i2]; // { 3, 4, 5 }
</pre><h2>Default implementations of interface members</h2><p>Today, once you publish an interface it’s game over: you can’t add members to it without breaking all the existing implementers of it.</p><p>In C# 8.0 we let you provide a body for an interface member. Thus, if somebody doesn’t implement that member (perhaps because it wasn’t there yet when they wrote the code), they will just get the default implementation instead.</p><pre class="lang:c# decode:true">interface ILogger
{
    void Log(LogLevel level, string message);
    void Log(Exception ex) =&gt; Log(LogLevel.Error, ex.ToString()); // New overload
}

class ConsoleLogger : ILogger
{
    public void Log(LogLevel level, string message) { ... }
    // Log(Exception) gets default implementation
}
</pre><p>The <code>ConsoleLogger</code> class doesn’t have to implement the <code>Log(Exception)</code> overload of <code>ILogger</code>, because it is declared with a default implementation. Now you can add new members to existing public interfaces as long as you provide a default implementation for existing implementors to use.</p><h2>Recursive patterns</h2><p>We’re allowing patterns to contain other patterns:</p><pre class="lang:c# decode:true">IEnumerable&lt;string&gt; GetEnrollees()
{
    foreach (var p in People)
    {
        if (p is Student { Graduated: false, Name: string name }) yield return name;
    }
}
</pre><p>The pattern <code>Student { Graduated: false, Name: string name }</code> checks that the <code>Person</code> is a <code>Student</code>, then applies the constant pattern <code>false</code> to their <code>Graduated</code> property to see if they’re still enrolled, and the pattern <code>string name</code> to their <code>Name</code> property to get their name (if non-null). Thus, if <code>p</code> is a <code>Student</code>, has not graduated and has a non-null name, we <code>yield return</code> that name.</p><h2>Switch expressions</h2><p>Switch statements with patterns are quite powerful in C# 7.0, but can be cumbersome to write. Switch expressions are a “lightweight” version, where all the cases are expressions:</p><pre class="lang:c# decode:true">var area = figure switch 
{
    Line _      =&gt; 0,
    Rectangle r =&gt; r.Width * r.Height,
    Circle c    =&gt; Math.PI * c.Radius * c.Radius,
    _           =&gt; throw new UnknownFigureException(figure)
};
</pre><h2>Target-typed new-expressions</h2><p>In many cases, when you’re creating a new object, the type is already given from context. In those situations we’ll let you omit the type:</p><pre class="lang:c# decode:true">Point[] ps = { new (1, 4), new (3,-2), new (9, 5) }; // all Points
</pre><p><span>The implementation of this feature was <a href="https://github.com/dotnet/roslyn/pull/25196">contributed</a> by a member of the community, <a href="https://github.com/alrz">Alireza Habibi</a>. Thank you!</span></p><h1>Platform dependencies</h1><p>Many of the C# 8.0 language features have platform dependencies. Async streams, indexers and ranges all rely on new framework types that will be part of .NET Standard 2.1. As Immo describes in his post <a href="https://blogs.msdn.microsoft.com/dotnet/">Announcing .NET Standard 2.1</a>, .NET Core 3.0 as well as Xamarin, Unity and Mono will all implement .NET Standard 2.1, but .NET Framework 4.8 will not. This means that the types required to use these features won’t be available on .NET Framework 4.8. Likewise, default interface member implementations rely on new runtime enhancements, and we will not make those in the .NET Runtime 4.8 either.</p><p>For this reason, using C# 8.0 is only supported on platforms that implement .NET Standard 2.1. The need to keep the runtime stable has prevented us from implementing new language features in it for more than a decade. With the side-by-side and open-source nature of the modern runtimes, we feel that we can responsibly evolve them again, and do language design with that in mind. Scott explained in his <a href="https://blogs.msdn.microsoft.com/dotnet/2018/10/04/update-on-net-core-3-0-and-net-framework-4-8/">Update on .NET Core 3.0 and .NET Framework 4.8</a> that .NET Framework is going to see less innovation in the future, instead focusing on stability and reliability. Given that, we think it is better for it to miss out on some language features than for nobody to get them.</p><h1>How can I learn more?</h1><p>The C# language design process is open source, and takes place in the <a href="https://github.com/dotnet/csharplang">github.com/dotnet/csharplang)</a> repo. It can be a bit overwhelming and chaotic if you don’t follow along regularly. The heartbeat of language design is the language design meetings, which are captured in the <a href="https://github.com/dotnet/csharplang/blob/master/meetings/2018/README.md">C# Language Design Notes</a>.</p><p>About a year ago I wrote a post <a href="https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/">Introducing Nullable Reference Types in C#</a>. It should still be an informative read.</p><p>You can also watch videos such as <a href="https://channel9.msdn.com/events/Build/2018/BRK2155">The future of C#</a> from Microsoft Build 2018, or <a href="https://channel9.msdn.com/events/dotnetConf/2018/S103">What’s Coming to C#?</a> from .NET Conf 2018, which showcase several of the features.</p><p>Kathleen has a great post laying out the plans for <a href="https://blogs.msdn.microsoft.com/vbteam/2018/11/12/visual-basic-in-net-core-3-0/">Visual Basic in .NET Core 3.0</a>.</p><p>As we start releasing the features as part of Visual Studio 2019 previews, we will also publish much more detail about the individual features.</p><p>Personally I can’t wait to get them into the hands of all of you!</p><p>Happy hacking,</p><p>Mads Torgersen, Design Lead for C#</p><div class="authorinfoarea"></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>