<!DOCTYPE html>
<html lang="en">
<head>
    <title>
`zig cc`: a Powerful Drop-In Replacement for GCC/Clang - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="`zig cc`: a Powerful Drop-In Replacement for GCC/Clang - linksfor.dev(s)"/>
    <meta property="og:description" content="If you have heard of Zig before, you may know it as&#xA;a promising new programming language which is ambitiously trying to overthrow C as the&#xA;de-facto systems language. But did you know that it also can straight up compile C code?"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - `zig cc`: a Powerful Drop-In Replacement for GCC/Clang</title>
<div class="readable">
        <h1>`zig cc`: a Powerful Drop-In Replacement for GCC/Clang</h1>
            <div>Reading time: 33-42 minutes</div>
        <div>Posted here: 25 Mar 2020</div>
        <p><a href="https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html">https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
        



<p>
If you have heard of <a href="https://ziglang.org/">Zig</a> before, you may know it as
a promising new programming language which is ambitiously trying to overthrow C as the
de-facto systems language. But did you know that it also can straight up compile C code?
</p>
<p>
This has been possible for a while, and you can see some
<a href="https://ziglang.org/#Zig-is-also-a-C-compiler">examples of this on the home page</a>.
What's new is that the <code>zig cc</code> sub-command is available, and it supports
the same options as <a href="https://clang.llvm.org/">Clang</a>, which, in turn, supports
the same options as <a href="https://gcc.gnu.org/">GCC</a>.
</p>
<p>
Now, I'm sure you're feeling pretty skeptical right about now, so let me hook you real
quick before I get into the juicy details.
</p>
<h2>Clang and GCC cannot do this:</h2>
<pre><strong>andy@ark ~/tmp&gt; cat hello.c</strong>
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    fprintf(stderr, "Hello, World!
");
    return 0;
}
<strong>andy@ark ~/tmp&gt; clang -o hello.exe hello.c -target x86_64-windows-gnu</strong>
clang-7: warning: argument unused during compilation: '--gcc-toolchain=/nix/store/ificps9si1nvz85f9xa7gjd9h6r5lzg6-gcc-9.2.0' [-Wunused-command-line-argument]
/nix/store/7bhi29ainf5rjrk7k7wyhndyskzyhsxh-binutils-2.31.1/bin/ld: unrecognised emulation mode: i386pep
Supported emulations: elf_x86_64 elf32_x86_64 elf_i386 elf_iamcu elf_l1om elf_k1om
clang-7: <span>error</span>: linker command failed with exit code 1 (use -v to see invocation)
<strong>andy@ark ~/tmp&gt; clang -o hello hello.c -target mipsel-linux-musl</strong>
In file included from hello.c:1:
In file included from /nix/store/8pp3i3hcp7bv0f8jllzqq7gcp9dbzvp9-glibc-2.27-dev/include/stdio.h:27:
In file included from /nix/store/8pp3i3hcp7bv0f8jllzqq7gcp9dbzvp9-glibc-2.27-dev/include/bits/libc-header-start.h:33:
In file included from /nix/store/8pp3i3hcp7bv0f8jllzqq7gcp9dbzvp9-glibc-2.27-dev/include/features.h:452:
/nix/store/8pp3i3hcp7bv0f8jllzqq7gcp9dbzvp9-glibc-2.27-dev/include/gnu/stubs.h:7:11: <span>fatal error</span>: 
      'gnu/stubs-32.h' file not found
# include &lt;gnu/stubs-32.h&gt;
          ^~~~~~~~~~~~~~~~
1 error generated.
<strong>andy@ark ~/tmp&gt; clang -o hello hello.c -target aarch64-linux-gnu</strong>
In file included from hello.c:1:
In file included from /nix/store/8pp3i3hcp7bv0f8jllzqq7gcp9dbzvp9-glibc-2.27-dev/include/stdio.h:27:
In file included from /nix/store/8pp3i3hcp7bv0f8jllzqq7gcp9dbzvp9-glibc-2.27-dev/include/bits/libc-header-start.h:33:
In file included from /nix/store/8pp3i3hcp7bv0f8jllzqq7gcp9dbzvp9-glibc-2.27-dev/include/features.h:452:
/nix/store/8pp3i3hcp7bv0f8jllzqq7gcp9dbzvp9-glibc-2.27-dev/include/gnu/stubs.h:7:11: <span>fatal error</span>: 
      'gnu/stubs-32.h' file not found
# include &lt;gnu/stubs-32.h&gt;
          ^~~~~~~~~~~~~~~~
1 error generated.
</pre>

<h2>`zig cc` can:</h2>
<pre><strong>andy@ark ~/tmp&gt; zig cc -o hello.exe hello.c -target x86_64-windows-gnu</strong>
<strong>andy@ark ~/tmp&gt; wine64 hello.exe</strong>
Hello, World!
<strong>andy@ark ~/tmp&gt; zig cc -o hello hello.c -target mipsel-linux-musl</strong>
<strong>andy@ark ~/tmp&gt; qemu-mipsel ./hello</strong>
Hello, World!
<strong>andy@ark ~/tmp&gt; zig cc -o hello hello.c -target aarch64-linux-gnu</strong>
<strong>andy@ark ~/tmp&gt; qemu-aarch64 -L ~/Downloads/glibc/multi-2.31/install/glibcs/aarch64-linux-gnu ./hello</strong>
Hello, World!
</pre>
<h2>Features of `zig cc`</h2>
<p>
<code>zig cc</code> is <em>not the main purpose of the Zig project</em>. It merely
exposes the already-existing capabilities of the Zig compiler via a small frontend layer
that parses C compiler options.
</p>
<h3>Install simply by unzipping a tarball</h3>
<p>
Zig is an open source project, and of course can be
<a href="https://github.com/ziglang/zig/#building-from-source">built and installed from source the usual way</a>. However, the Zig project also has tarballs available on
<a href="https://ziglang.org/download/">the download page</a>.
You can download a 45 MiB tarball, unpack it, and you're done.
You can even have multiple versions at the same time, no problem.
</p>
<p>
Here, rather than downloading the x86_64-linux version, which matches the computer I am
currently using, I'll download the Windows version and run it in
<a href="https://www.winehq.org/">Wine</a> to show how simple installation is:
</p>
<pre><strong>andy@ark ~/tmp&gt; wget --quiet https://ziglang.org/builds/zig-windows-x86_64-0.5.0+13d04f996.zip</strong>
<strong>andy@ark ~/tmp&gt; unzip -q zig-windows-x86_64-0.5.0+13d04f996.zip </strong>
<strong>andy@ark ~/tmp&gt; wine64 ./zig-windows-x86_64-0.5.0+13d04f996/zig.exe cc -o hello hello.c -target x86_64-linux</strong>
<strong>andy@ark ~/tmp&gt; ./hello</strong>
Hello, World!
</pre>
<p>
Take a moment to appreciate what just happened here - I downloaded a Windows build of Zig,
ran it in Wine, using it to cross compile for Linux, and then ran the binary natively.
Computers are fun!
</p>
<p>
Compare this to
<a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-9.0.1">downloading Clang</a>,
which has 380 MiB Linux-distribution-specific tarballs. Zig's Linux tarballs are fully statically
linked, and therefore work correctly on all Linux distributions. The size difference here
comes because the Clang tarball ships with more utilities than a C compiler, as well as
pre-compiled static libraries for both LLVM and Clang. Zig does not ship with any pre-compiled
libraries; instead it ships with source code, and builds what it needs on-the-fly.
</p>
<h3 id="caching-system">Caching System</h3>
<p>
The Zig compiler uses a sophisticated caching system to avoid needlessly rebuilding
artifacts. I carefully designed this caching system to
make optimal use of the file system while maintaining correct semantics - which is
<a href="https://apenwarr.ca/log/20181113">trickier than you might think</a>!
</p>
<p>
The caching system uses a combination of hashing inputs and checking the fstat values
of file paths, while being mindful of mtime granularity. This makes it avoid
needlessly hashing files, while at the same time detecting when a modified file has
the same contents. It always has correct behavior, whether the file system has nanosecond
mtime granularity, second granularity, always sets mtime to zero, or anything in between.
</p>
<p>
You can find a
<a href="https://ziglang.org/download/0.4.0/release-notes.html#Build-Artifact-Caching">detailed description of the caching system in the 0.4.0 release notes</a>.
</p>
<p>
<code>zig cc</code> makes this caching system available when compiling C code. For simple
enough projects, this obviates the need for a Makefile or other build system.
</p>
<pre><strong>andy@ark ~/tmp&gt; cat foo.c</strong>
#include &lt;stdio.h&gt;

#include "another_file.c"

int main(int argc, char **argv) {
#include "printf_many_times.c"
}
<strong>andy@ark ~/tmp&gt; cat another_file.c </strong>
void another(void) {}
<strong>andy@ark ~/tmp&gt; time zig cc -c foo.c</strong>
0.12
<strong>andy@ark ~/tmp&gt; time zig cc -c foo.c</strong>
0.01
<strong>andy@ark ~/tmp&gt; touch another_file.c </strong>
<strong>andy@ark ~/tmp&gt; time zig cc -c foo.c</strong>
0.01
<strong>andy@ark ~/tmp&gt; echo "/* add a comment */" &gt;&gt;another_file.c</strong>
<strong>andy@ark ~/tmp&gt; time zig cc -c foo.c</strong>
0.12
<strong>andy@ark ~/tmp&gt; time zig cc -c foo.c</strong>
0.01
</pre>
<p>
Here you can see the caching system is smart enough to find dependencies that are
included with the preprocessor, and smart enough to avoid a full rebuild when the
mtime of another_file.c was updated.
</p>
<p>
One last thing before I move on. I want to point out that this caching system is not
some fluffy bloated feature - rather it is an absolutely critical component to making
cross-compiling work in a usable manner. As we'll see below, other compilers ship with 
pre-compiled, target-specific binaries, while Zig ships with <em>source code only</em>
and cross-compiles on-the-fly, caching the result.
</p>

<h3>Cross Compiling</h3>
<p>I have carefully designed Zig since the very beginning to treat cross compilation
as a first class use case. Now that the <code>zig cc</code> frontend is available,
it brings these capabilities to C code.
</p>
<p>
I showed you above cross-compiling some simple "Hello, World!" programs. But now let's
try a real-world C project.
</p>
<p>
Let's try <a href="https://luajit.org/">LuaJIT</a>!
</p>
<pre>[~/Downloads]$ <strong>git clone https://github.com/LuaJIT/LuaJIT</strong>
[~/Downloads]$ <strong>cd LuaJIT</strong>
[~/Downloads/LuaJIT]$ <strong>ls</strong>
COPYRIGHT  doc  dynasm  etc  Makefile  README  src
</pre>
<p>
OK so it uses standard Makefiles. Here we go, first let's make sure it works natively
with <code>zig cc</code>.
</p>
<pre>[~/Downloads/LuaJIT]$ <strong>export CC="zig cc"</strong>
[~/Downloads/LuaJIT]$ <strong>make CC="$CC"</strong>
==== Building LuaJIT 2.1.0-beta3 ====
make -C src
make[1]: Entering directory '/home/andy/Downloads/LuaJIT/src'
HOSTCC    host/minilua.o
HOSTLINK  host/minilua
DYNASM    host/buildvm_arch.h
HOSTCC    host/buildvm.o
HOSTCC    host/buildvm_asm.o
HOSTCC    host/buildvm_peobj.o
HOSTCC    host/buildvm_lib.o
HOSTCC    host/buildvm_fold.o
HOSTLINK  host/buildvm
BUILDVM   lj_vm.S
ASM       lj_vm.o
CC        lj_gc.o
BUILDVM   lj_ffdef.h
CC        lj_err.o
CC        lj_char.o
BUILDVM   lj_bcdef.h
CC        lj_bc.o
CC        lj_obj.o
CC        lj_buf.o
CC        lj_str.o
CC        lj_tab.o
CC        lj_func.o
CC        lj_udata.o
CC        lj_meta.o
CC        lj_debug.o
CC        lj_state.o
CC        lj_dispatch.o
CC        lj_vmevent.o
CC        lj_vmmath.o
CC        lj_strscan.o
CC        lj_strfmt.o
CC        lj_strfmt_num.o
CC        lj_api.o
CC        lj_profile.o
CC        lj_lex.o
CC        lj_parse.o
CC        lj_bcread.o
CC        lj_bcwrite.o
CC        lj_load.o
CC        lj_ir.o
CC        lj_opt_mem.o
BUILDVM   lj_folddef.h
CC        lj_opt_fold.o
CC        lj_opt_narrow.o
CC        lj_opt_dce.o
CC        lj_opt_loop.o
CC        lj_opt_split.o
CC        lj_opt_sink.o
CC        lj_mcode.o
CC        lj_snap.o
CC        lj_record.o
CC        lj_crecord.o
BUILDVM   lj_recdef.h
CC        lj_ffrecord.o
CC        lj_asm.o
CC        lj_trace.o
CC        lj_gdbjit.o
CC        lj_ctype.o
CC        lj_cdata.o
CC        lj_cconv.o
CC        lj_ccall.o
CC        lj_ccallback.o
CC        lj_carith.o
CC        lj_clib.o
CC        lj_cparse.o
CC        lj_lib.o
CC        lj_alloc.o
CC        lib_aux.o
BUILDVM   lj_libdef.h
CC        lib_base.o
CC        lib_math.o
CC        lib_bit.o
CC        lib_string.o
CC        lib_table.o
CC        lib_io.o
CC        lib_os.o
CC        lib_package.o
CC        lib_debug.o
CC        lib_jit.o
CC        lib_ffi.o
CC        lib_init.o
AR        libluajit.a
CC        luajit.o
BUILDVM   jit/vmdef.lua
DYNLINK   libluajit.so
LINK      luajit
warning: unsupported linker arg: -E
OK        Successfully built LuaJIT
make[1]: Leaving directory '/home/andy/Downloads/LuaJIT/src'
==== Successfully built LuaJIT 2.1.0-beta3 ====

[~/Downloads/LuaJIT]$ <strong>ls</strong>
COPYRIGHT  doc  dynasm  etc  Makefile  README  src

[~/Downloads/LuaJIT]$ <strong>./src/</strong>
host/         jit/          libluajit.so  luajit        zig-cache/    

[~/Downloads/LuaJIT]$ <strong>./src/luajit </strong>
LuaJIT 2.1.0-beta3 -- Copyright (C) 2005-2020 Mike Pall. http://luajit.org/
JIT: ON SSE2 SSE3 SSE4.1 BMI2 fold cse dce fwd dse narrow loop abc sink fuse
&gt; <strong>print(3 + 4)</strong>
7
&gt; 
</pre>
<p>
OK so that worked. Now for the real test - can we make it cross compile?
</p>
<pre>[~/Downloads/LuaJIT]$ <strong>git clean -xfdq</strong>
[~/Downloads/LuaJIT]$ <strong>export CC="zig cc -target aarch64-linux-gnu"</strong>
[~/Downloads/LuaJIT]$ <strong>export HOST_CC="zig cc"</strong>
[~/Downloads/LuaJIT]$ <strong>make CC="$CC" HOST_CC="$HOST_CC" TARGET_STRIP="echo"</strong>
==== Building LuaJIT 2.1.0-beta3 ====
make -C src
make[1]: Entering directory '/home/andy/Downloads/LuaJIT/src'
HOSTCC    host/minilua.o
HOSTLINK  host/minilua
DYNASM    host/buildvm_arch.h
HOSTCC    host/buildvm.o
HOSTCC    host/buildvm_asm.o
HOSTCC    host/buildvm_peobj.o
HOSTCC    host/buildvm_lib.o
HOSTCC    host/buildvm_fold.o
HOSTLINK  host/buildvm
BUILDVM   lj_vm.S
ASM       lj_vm.o
CC        lj_gc.o
BUILDVM   lj_ffdef.h
CC        lj_err.o
CC        lj_char.o
BUILDVM   lj_bcdef.h
CC        lj_bc.o
CC        lj_obj.o
CC        lj_buf.o
CC        lj_str.o
CC        lj_tab.o
CC        lj_func.o
CC        lj_udata.o
CC        lj_meta.o
CC        lj_debug.o
CC        lj_state.o
CC        lj_dispatch.o
CC        lj_vmevent.o
CC        lj_vmmath.o
CC        lj_strscan.o
CC        lj_strfmt.o
CC        lj_strfmt_num.o
CC        lj_api.o
CC        lj_profile.o
CC        lj_lex.o
CC        lj_parse.o
CC        lj_bcread.o
CC        lj_bcwrite.o
CC        lj_load.o
CC        lj_ir.o
CC        lj_opt_mem.o
BUILDVM   lj_folddef.h
CC        lj_opt_fold.o
CC        lj_opt_narrow.o
CC        lj_opt_dce.o
CC        lj_opt_loop.o
CC        lj_opt_split.o
CC        lj_opt_sink.o
CC        lj_mcode.o
CC        lj_snap.o
CC        lj_record.o
CC        lj_crecord.o
BUILDVM   lj_recdef.h
CC        lj_ffrecord.o
CC        lj_asm.o
CC        lj_trace.o
CC        lj_gdbjit.o
CC        lj_ctype.o
CC        lj_cdata.o
CC        lj_cconv.o
CC        lj_ccall.o
CC        lj_ccallback.o
CC        lj_carith.o
CC        lj_clib.o
CC        lj_cparse.o
CC        lj_lib.o
CC        lj_alloc.o
CC        lib_aux.o
BUILDVM   lj_libdef.h
CC        lib_base.o
CC        lib_math.o
CC        lib_bit.o
CC        lib_string.o
CC        lib_table.o
CC        lib_io.o
CC        lib_os.o
CC        lib_package.o
CC        lib_debug.o
CC        lib_jit.o
CC        lib_ffi.o
CC        lib_init.o
AR        libluajit.a
CC        luajit.o
BUILDVM   jit/vmdef.lua
DYNLINK   libluajit.so
libluajit.so
LINK      luajit
warning: unsupported linker arg: -E
luajit
OK        Successfully built LuaJIT
make[1]: Leaving directory '/home/andy/Downloads/LuaJIT/src'
==== Successfully built LuaJIT 2.1.0-beta3 ====

[~/Downloads/LuaJIT]$ <strong>file ./src/luajit </strong>
./src/luajit: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 2.0.0, with debug_info, not stripped
</pre>
<p>
It worked! Will it run in <a href="https://www.qemu.org/">QEMU</a> though?
</p>
<pre>[~/Downloads/LuaJIT]$ <strong>qemu-aarch64 -L ~/Downloads/glibc/multi-2.31/install/glibcs/aarch64-linux-gnu ./src/luajit</strong>
LuaJIT 2.1.0-beta3 -- Copyright (C) 2005-2020 Mike Pall. http://luajit.org/
JIT: ON fold cse dce fwd dse narrow loop abc sink fuse
&gt; <strong>print(4 + 3)</strong>
7
&gt; 
</pre>
<p>
Amazing. QEMU never fails to impress me.
</p>
<p>
Before we move on, I want to show one more thing. You can see above, in order to run the
foreign-architecture binary, I had to pass
<code>-L ~/Downloads/glibc/multi-2.31/install/glibcs/aarch64-linux-gnu</code>. This is
due to the binary being dynamically linked. You can confirm this with the output from
<code>file</code> above where it says: <code>dynamically linked, interpreter /lib/ld-linux-aarch64.so.1</code>
</p>
<p>
Often, when cross-compiling, it is useful to make a <em>static</em> binary.
In the case of Linux, for example, this will make the resulting binary able to run on
any Linux distribution, rather than only ones with a hard-coded glibc dynamic linker path
of <code>/lib/ld-linux-aarch64.so.1</code>.
</p>
<p>
We can accomplish this by targeting musl rather than glibc:
</p>
<pre>[~/Downloads/LuaJIT]$ git clean -qxfd
[~/Downloads/LuaJIT]$ export CC="zig cc -target aarch64-linux-musl"
[~/Downloads/LuaJIT]$ make CC="$CC" CXX="$CXX" HOST_CC="$HOST_CC" TARGET_STRIP="echo"
==== Building LuaJIT 2.1.0-beta3 ====
(same output)
==== Successfully built LuaJIT 2.1.0-beta3 ====
[~/Downloads/LuaJIT]$ file src/luajit
src/luajit: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, not stripped
[~/Downloads/LuaJIT]$ qemu-aarch64 ./src/luajit
LuaJIT 2.1.0-beta3 -- Copyright (C) 2005-2020 Mike Pall. http://luajit.org/
JIT: ON fold cse dce fwd dse narrow loop abc sink fuse
&gt; print(11 + 22)
33
</pre>
<p>
Here you can see the <code>file</code> command reported <em>statically linked</em>,
and in the qemu command, the <code>-L</code> parameter was not needed.
</p>

<h2>Use Cases of `zig cc`</h2>
<p>
Alright, so I've given you a taste of what <code>zig cc</code> can do, but now I will
list explicitly what I consider to be the use cases:
</p>
<h3>Experimentation</h3>
<p>
Sometimes you just want a tool that you can use to try out different things. It can quickly
answer questions such as "What assembly does this code generate on MIPS vs ARM?". The widely
popular <a href="https://godbolt.org/">Compiler Explorer</a> serves this purpose.
</p>
<p>
<code>zig cc</code> provides a lightweight tool which can also answer questions such as,
"What happens if I swap out glibc for <a href="https://musl.libc.org/">musl</a>?" and
"How big is this executable when cross-compiled for Windows?".
<a href="https://twitter.com/andy_kelley/status/1242183564512366595">Here's me using Zig to
quickly find out what the maximum UDP packet size is on Linux</a>.
</p>
<p>
Since Zig is so easy to install - and it actually works everywhere without patches,
even Linux distributions such as <a href="https://nixos.org/">NixOS</a> -
it can often be a more convenient tool for running quick C test programs on your computer.
</p>
<p>
At the time of this writing, LLVM 10 was just released two hours ago.
It will take days or weeks for it to become available in various system package managers.
But you can already
<a href="https://ziglang.org/download/">download a master branch build of Zig</a>
and play with the new features of Clang/LLVM 10. For example, improved RISC-V support!
</p>
<pre>andy@ark ~/tmp&gt; <strong>zig cc -o hello hello.c -target riscv64-linux-musl</strong>
andy@ark ~/tmp&gt; <strong>qemu-riscv64 ./hello</strong>
Hello, World!
</pre>

<h3>Bundling a C compiler as part of a larger project</h3>
<p>
With Zig tarballs weighing in at under 45 MiB, zero system dependencies, no configuration,
and MIT license, it makes for an ideal candidate when you need to bundle a C compiler along
with another project.
</p>
<p>
For example, maybe you have
<a href="https://nim-lang.org/">a programming language that compiles to C</a>.
Zig is an obvious choice for what C compiler to ship with your language.
</p>
<p>
Or maybe you want to make a batteries-included
<a href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDE</a>
that ships with a compiler.
</p>

<h3>Lightweight alternative to a cross compilation environment</h3>
<p>
If you're trying to build something with a large dependency tree, you'll probably want to
use a full cross compilation environment, such as <a href="https://mxe.cc/">mxe.cc</a>
or <a href="http://musl.cc/">musl.cc</a>.
</p>
<p>
But if you don't need such a sledgehammer, <code>zig cc</code> could be a useful alternative,
especially if your goal is to compile for N different targets. Consider that musl.cc lists different
tarballs for each architecture, each weighing in at roughly 85 MiB. Meanwhile Zig weighs in at 45 MiB
and it supports all those architectures, plus glibc and Windows.
</p>

<h3>An alternative to installing MSVC on Windows</h3>
<p>
You could spend days - literally! - waiting for Microsoft Visual Studio to install,
or you could install Zig and
<a href="https://code.visualstudio.com/">VS Code</a> in a matter of minutes.
</p>

<h2>Under the Hood</h2>
<p>If <code>zig cc</code> is built on top of Clang, why doesn't Clang just do this?
What exactly is Zig doing on top of Clang to make this work?</p>
<p>
The answer is, <em>a lot</em>, actually. I'll go over how it works here.
</p>
<h3>compiler-rt</h3>
<p>
compiler-rt is a library that provides "polyfill" implementations of language-supported features
when the target does not have machine code instructions for it. For example, compiler-rt has
the function <code>__muldi3</code> to perform signed 64-bit integer multiplication on architectures
that do not have a 64-bit wide integer multiplication instruction.
</p>
<p>
In the GNU world, compiler-rt is named <strong>libgcc</strong>.
</p>
<p>
Most C compilers ship with this library pre-built for the target.
For example, on an Ubuntu (Bionic) system, with the <code>build-essential</code> package installed,
you can find this at <code>/lib/x86_64-linux-gnu/libgcc_s.so.1</code>.
</p>
<p>
If you download <a href="https://github.com/llvm/llvm-project/releases/download/llvmorg-9.0.1/clang+llvm-9.0.1-x86_64-linux-gnu-ubuntu-16.04.tar.xz">clang+llvm-9.0.1-x86_64-linux-gnu-ubuntu-16.04.tar.xz</a> and take a look
around, clang actually does not even ship with compiler-rt. Instead, it relies on the system libgcc
noted above. This is one reason that this tarball is Ubuntu-specific and does not work on other
Linux distributions, 
<a href="https://www.leidinger.net/blog/2010/09/28/the-freebsd-linuxulator-explained-for-users/">FreeBSD's Linuxulator</a>,
or <a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">WSL</a>,
which have system files in different locations.
</p>
<p>
Zig's strategy with compiler-rt is that we have
<a href="https://github.com/ziglang/zig/blob/0.5.0/lib/std/special/compiler_rt.zig">our own implementation of this library</a>,
written in Zig. Most of it is ported from
<a href="https://github.com/llvm/llvm-project/tree/llvmorg-10.0.0-rc6/compiler-rt">LLVM's compiler-rt project</a>,
but we also have some of our own improvements on top of this.
</p>
<p>
Anyway, rather than depending on system compiler-rt being installed, or shipping a pre-compiled
library, Zig ships its compiler-rt <em>in source form</em>, and lazily builds compiler-rt 
for the compilation target, and then caches the result using
<a href="#caching-system">the caching system discussed above</a>.
</p>
<p>
Zig's compiler-rt is <a href="https://github.com/ziglang/zig/issues/1290">not yet complete</a>.
However, completing it is a prerequisite for releasing Zig version 1.0.0.
</p>

<h3>libc</h3>
<p>
When C code calls <code>printf</code>, <code>printf</code> has to be implemented <em>somewhere</em>,
and that somewhere is libc.
</p>
<p>
Some operating systems, such as <a href="https://www.freebsd.org/">FreeBSD</a> and macOS, have an
designated system libc, and it is the kernel syscall interface. On others, such as
Windows and Linux, libc is optional, and therefore there are multiple options of which
libc to use, if any.
</p>
<p>
As of the time of this writing, Zig can provide libcs for the following targets:
</p>
<pre>andy@ark ~&gt; zig targets | jq .libc
[
  "aarch64_be-linux-gnu",
  "aarch64_be-linux-musl",
  "aarch64_be-windows-gnu",
  "aarch64-linux-gnu",
  "aarch64-linux-musl",
  "aarch64-windows-gnu",
  "armeb-linux-gnueabi",
  "armeb-linux-gnueabihf",
  "armeb-linux-musleabi",
  "armeb-linux-musleabihf",
  "armeb-windows-gnu",
  "arm-linux-gnueabi",
  "arm-linux-gnueabihf",
  "arm-linux-musleabi",
  "arm-linux-musleabihf",
  "arm-windows-gnu",
  "i386-linux-gnu",
  "i386-linux-musl",
  "i386-windows-gnu",
  "mips64el-linux-gnuabi64",
  "mips64el-linux-gnuabin32",
  "mips64el-linux-musl",
  "mips64-linux-gnuabi64",
  "mips64-linux-gnuabin32",
  "mips64-linux-musl",
  "mipsel-linux-gnu",
  "mipsel-linux-musl",
  "mips-linux-gnu",
  "mips-linux-musl",
  "powerpc64le-linux-gnu",
  "powerpc64le-linux-musl",
  "powerpc64-linux-gnu",
  "powerpc64-linux-musl",
  "powerpc-linux-gnu",
  "powerpc-linux-musl",
  "riscv64-linux-gnu",
  "riscv64-linux-musl",
  "s390x-linux-gnu",
  "s390x-linux-musl",
  "sparc-linux-gnu",
  "sparcv9-linux-gnu",
  "wasm32-freestanding-musl",
  "x86_64-linux-gnu",
  "x86_64-linux-gnux32",
  "x86_64-linux-musl",
  "x86_64-windows-gnu"
]
</pre>
<p>
In order to provide libc on these targets, Zig ships with a subset of the source files
for these projects:
</p>
<ul>
  <li>musl v1.2.0</li>
  <li><a href="https://mingw-w64.org/">mingw-w64</a> v7.0.0</li>
  <li>glibc 2.31</li>
</ul>
<p>
For each libc, there is a
<a href="https://github.com/ziglang/zig/wiki/Updating-libc">process for upgrading to a new release</a>.
This process is a sort of pre-processing step. We still end up with source files, but we
de-duplicate non-multi-arch source files into multi-arch source files.
</p>

<h4>glibc</h4>
<p>
glibc is the most involved. The first step is building glibc for every target that it supports,
which takes upwards of 24 hours and 74 GiB of disk space.
</p>
<p>
From here, the
<a href="https://github.com/ziglang/zig/blob/dc44fe053c609f389e375f6857f96b6bb3794897/tools/process_headers.zig">process_headers tool</a>
inspects all the header files from all the targets, and identifies which files are the same across
all targets, and which header files are target-specific. They are then sorted into the
corresponding directories in Zig's source tree, in:
</p>
<ul>
  <li>lib/libc/include/generic-glibc/</li>
  <li>lib/libc/include/$ARCH-linux-$ABI/ (there are multiple of these directories)</li>
</ul>
<p>
Additionally, Linux header files are not included in glibc, and so the same process is applied to
Linux header files, with the directories:
</p>
<ul>
  <li>lib/libc/include/any-linux-any/</li>
  <li>lib/libc/include/$ARCH-linux-any/</li>
</ul>
<p>
That takes care of the header files, but now we have the problem of dynamic linking against
glibc, without touching any system files.
</p>
<p>
For this, we have the
<a href="https://github.com/ziglang/zig/blob/dc44fe053c609f389e375f6857f96b6bb3794897/tools/update_glibc.zig">update_glibc tool</a>.
Given the path to the glibc source directory, it finds all the <code>.abilist</code> text files
and uses them to produce 3 simple but crucial files:
</p>
<ul>
  <li><a href="https://github.com/ziglang/zig/blob/master/lib/libc/glibc/vers.txt">vers.txt</a>
    - the list of all glibc versions.
  </li>
  <li><a href="https://github.com/ziglang/zig/blob/master/lib/libc/glibc/fns.txt">fns.txt</a>
    - the list of all symbols that glibc provides, followed by the library it appears in
    (for example libm, libpthread, libc, librt).
  </li>
  <li><a href="https://github.com/ziglang/zig/blob/master/lib/libc/glibc/abi.txt">abi.txt</a>
    - for each target, for each function, tells which versions of glibc, if any, it appears in.
  </li>
</ul>
<p>
Together, these files amount to only 192 KB (27 KB gzipped), and they allow Zig to target any
version of glibc.
</p>
<p>
Yes, I did not make a typo there. Zig can target any of the 42 versions of glibc for any of the
architectures listed above. I'll show you:
</p>
<pre>andy@ark ~/tmp&gt; <strong>cat rand.zig </strong>
const std = @import("std");

pub fn main() anyerror!void {
    var buf: [10]u8 = undefined;
    _ = std.c.getrandom(&amp;buf, buf.len, 0);
    std.debug.warn("random bytes: {x}
", .{buf});
}
andy@ark ~/tmp&gt; <strong>zig build-exe rand.zig -lc -target native-native-gnu.2.25</strong>
andy@ark ~/tmp&gt; <strong>./rand</strong>
random bytes: e2059382afb599ea6d29
andy@ark ~/tmp&gt; <strong>zig build-exe rand.zig -lc -target native-native-gnu.2.24</strong>
lld: error: undefined symbol: getrandom
&gt;&gt;&gt; referenced by rand.zig:5 (/home/andy/tmp/rand.zig:5)
&gt;&gt;&gt;               ./rand.o:(main.0)
</pre>
<p>
Sure enough, if you look at the
<a href="http://man7.org/linux/man-pages/man2/getrandom.2.html">man page for getrandom</a>,
it says:
</p>
<blockquote>
Support was added to glibc in version 2.25.
</blockquote>
<p>
When no explicit glibc version is requested, and the target OS is the native (host) OS,
Zig detects the native glibc version by inspecting the Zig executable's own dynamically
linked libraries, looking for glibc, and checking the version. It turns out you can look for
<code>libc.so.6</code> and then <code>readlink</code> on that, and it will look something
like <code>libc-2.27.so</code>. When this strategy does not work, Zig looks at
<code>/usr/bin/env</code>, looking for the same thing. Since this file path is hard-coded
into countless shebang lines, it's a pretty safe bet to find out the dynamic linker path and
glibc version (if any) of the native system!
</p>
<p>
<code>zig cc</code> currently does not provide a way to choose a specific glibc version
(because C compilers do not provide a way), and so Zig chooses the native version for
compiling natively, and the default (2.17) for cross-compiling.
However, I'm sure this problem can be solved, even when using <code>zig cc</code>. For example,
maybe it could support an environment variable, or simply introduce an extra command line
option that does not conflict with any Clang options.
</p>
<p>
When you request a certain version of glibc, Zig uses those text files noted above to
create dummy <code>.so</code> files to link against, which contain exactly the correct
set of symbols (with appropriate name mangling) based on the requested version.
The symbols will be resolved at runtime, by the dynamic linker on the target platform.
</p>
<p>
In this way, most of libc in the glibc case resides on the target file system. But not all of it!
There are still the "C runtime start files":
</p>
<ul>
  <li>Scrt1.o</li>
  <li>crti.o</li>
  <li>crtn.o</li>
</ul>
<p>
These are statically compiled into every binary that dynamically links glibc, and their
<a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> is therefore
Very Very Stable.
</p>
<p>
And so, Zig bundles a small subset of glibc's source files needed to build these object
files from source for every target. The total size of this comes out to 1.4 MiB (252 KB gzipped).
I do think there is some room for improvement here, but I digress.
</p>
<p>
There are a couple of patches to this small subset of glibc source files, which simplify them
to avoid including too many .h files, since the end result that we need is some bare bones object
files, and not all of glibc.
</p>
<p>
And finally, we certainly do not ship the build system of glibc with Zig! I manually inspected,
audited, and analyzed glibc's build system, and then by hand wrote code in the Zig
compiler which hooks into Zig's <a href="#caching-system">caching system</a> and performs a minimal
build of only these start files, as needed.
</p>

<h4>musl</h4>
<p>
The process for preparing musl to ship with Zig is much simpler by comparison.
</p>
<p>
It still involves building musl for every target architecture that it supports,
but in this case only the <code>install-headers</code> target has to be run,
and it takes less than a minute, even to do it for all targets.
</p>
<p>
The same
<a href="https://github.com/ziglang/zig/blob/dc44fe053c609f389e375f6857f96b6bb3794897/tools/process_headers.zig">process_headers tool</a>
tool used for glibc headers is used on the musl headers:
</p>
<ul>
  <li>lib/libc/include/generic-musl/</li>
  <li>lib/libc/include/$ARCH-linux-$ABI/ (there are multiple of these directories)</li>
</ul>
<p>
Unlike glibc, musl supports building statically. Zig currently assumes a static libc
when musl is chosen, and does not support dynamically linking against musl, although
that could potentially be added in the future.
</p>
<p>
And so for musl, zig actually bundles most - but still not all - of musl's source files.
Everything in <code>arch</code>, <code>crt</code>, <code>compat</code>, <code>src</code>, and <code>include</code> gets copied in.
</p>
<p>
Again much like glibc, I carefully studied musl's build system, and then hand-coded logic
in the Zig compiler to build these source files. In musl's case it is simpler - just a bit
of logic having to do with the file extension, and whether to override files with an
architecture-specific file. The only file that needs to be patched (by hand) is
<code>version.h</code>, which is normally generated during the configure phase in musl's build
system.
</p>
<p>
I really appreciate Rich Felker's efforts to make musl simple to utilize in this way,
and he has been incredibly helpful in the <code>#musl</code> IRC channel when I ask
questions.
<a href="https://andrewkelley.me/post/why-donating-to-musl-libc-project.html">I proudly sponsor Rich Felker for $150/month</a>.
</p>

<h4>mingw-w64</h4>
<p>
mingw-w64 was an absolute joy to support in Zig. The beautiful thing about this project is that
they have already been transitioning into having one set of header files that applies to all
architectures (using <code>#ifdefs</code> only where needed). One set of header files
is sufficient to support all four architectures: arm, aarch64, x86, and x86_64. 
</p>
<p>
So for updating headers, all we have to do is build mingw-w64, then:
</p>
<pre>mv $INSTALLPREFIX/include $ZIGSRC/lib/libc/include/any-windows-any
</pre>
<p>
After doing this for all 3 libcs, the libc/include directory looks like this:
</p>
<pre>aarch64_be-linux-any   i386-linux-musl           powerpc-linux-any
aarch64_be-linux-gnu   mips64el-linux-any        powerpc-linux-gnu
aarch64-linux-any      mips64el-linux-gnuabi64   powerpc-linux-musl
aarch64-linux-gnu      mips64el-linux-gnuabin32  riscv32-linux-any
aarch64-linux-musl     mips64-linux-any          riscv64-linux-any
any-linux-any          mips64-linux-gnuabi64     riscv64-linux-gnu
any-windows-any        mips64-linux-gnuabin32    riscv64-linux-musl
armeb-linux-any        mips64-linux-musl         s390x-linux-any
armeb-linux-gnueabi    mipsel-linux-any          s390x-linux-gnu
armeb-linux-gnueabihf  mipsel-linux-gnu          s390x-linux-musl
arm-linux-any          mips-linux-any            sparc-linux-gnu
arm-linux-gnueabi      mips-linux-gnu            sparcv9-linux-gnu
arm-linux-gnueabihf    mips-linux-musl           x86_64-linux-any
arm-linux-musl         powerpc64le-linux-any     x86_64-linux-gnu
generic-glibc          powerpc64le-linux-gnu     x86_64-linux-gnux32
generic-musl           powerpc64-linux-any       x86_64-linux-musl
i386-linux-any         powerpc64-linux-gnu
i386-linux-gnu         powerpc64-linux-musl
</pre>
<p>
When Zig generates a C command line to send to clang, it puts the appropriate
include paths using <code>-I</code> depending on the target. For example, if the
target is <code>aarch64-linux-musl</code>, then the following command line parameters
are appended:
</p>
<ul>
  <li><code>-I$LIB/libc/include/aarch64-linux-musl</code></li>
  <li><code>-I$LIB/libc/include/aarch64-linux-any</code></li>
  <li><code>-I$LIB/libc/include/generic-musl</code></li>
</ul>
<p>
Anyway back to mingw-w64.
</p>
<p>
Again, Zig includes a subset of source files from mingw-w64 with a few patches applied
to make things compile successfully.
</p>
<p>
The Zig compiler code that builds mingw-w64 from source files emulates only the parts of
the build system that are needed for this subset. This includes preprocessing <code>.def.in</code>
files to get <code>.def</code> files, and then in-turn using LLD to generate <code>.lib</code> files
from the <code>.def</code> files, which allows Zig to provide <code>.lib</code> files for
any Windows DLL, such as kernel32.dll or even opengl32.dll.
</p>

<h3>Invoking Clang Without a System Dependency</h3>
<p>
Since Zig already links against Clang libraries for the
<a href="https://ziglang.org/#Integration-with-C-libraries-without-FFIbindings">translate-c feature</a>,
it was not much more cost to expose the <code>main()</code> entry point from Zig.
So that's exactly what we do:
</p>
<ul>
  <li><code>llvm-project/clang/tools/driver/driver.cpp</code> is copied to <code>$ZIGGIT/src/zig_clang_driver.cpp</code></li>
  <li><code>llvm-project/clang/tools/driver/cc1_main.cpp</code> is copied to <code>$ZIGGIT/src/zig_clang_cc1_main.cpp</code></li>
  <li><code>llvm-project/clang/tools/driver/cc1as_main.cpp</code> is copied to <code>$ZIGGIT/src/zig_clang_cc1as_main.cpp</code></li>
</ul>
<p>
The following patch is applied:
</p>
<pre>--- a/src/zig_clang_driver.cpp
+++ b/src/zig_clang_driver.cpp
@@ -206,8 +205,6 @@
                     void *MainAddr);
 extern int cc1as_main(ArrayRef&lt;const char *&gt; Argv, const char *Argv0,
                       void *MainAddr);
<span>-extern int cc1gen_reproducer_main(ArrayRef&lt;const char *&gt; Argv,</span>
<span>-                                  const char *Argv0, void *MainAddr);</span>
 
 static void insertTargetAndModeArgs(const ParsedClangName &amp;NameParts,
                                     SmallVectorImpl&lt;const char *&gt; &amp;ArgVector,
@@ -330,19 +327,18 @@
   if (Tool == "-cc1as")
     return cc1as_main(makeArrayRef(ArgV).slice(2), ArgV[0],
                       GetExecutablePathVP);
<span>-  if (Tool == "-cc1gen-reproducer")</span>
<span>-    return cc1gen_reproducer_main(makeArrayRef(ArgV).slice(2), ArgV[0],</span>
<span>-                                  GetExecutablePathVP);</span>
   // Reject unknown tools.
   llvm::errs() &lt;&lt; "error: unknown integrated tool '" &lt;&lt; Tool &lt;&lt; "'. "
                &lt;&lt; "Valid tools include '-cc1' and '-cc1as'.
";
   return 1;
 }
 
<span>-int main(int argc_, const char **argv_) {</span>
<span>+extern "C" int ZigClang_main(int argc_, const char **argv_);</span>
<span>+int ZigClang_main(int argc_, const char **argv_) {</span>
   noteBottomOfStack();
   llvm::InitLLVM X(argc_, argv_);
<span>-  SmallVector&lt;const char *, 256&gt; argv(argv_, argv_ + argc_);</span>
<span>+  size_t argv_offset = (strcmp(argv_[1], "-cc1") == 0 || strcmp(argv_[1], "-cc1as") == 0) ? 0 : 1;</span>
<span>+  SmallVector&lt;const char *, 256&gt; argv(argv_ + argv_offset, argv_ + argc_);</span>
 
   if (llvm::sys::Process::FixupStandardFileDescriptors())
     return 1;
</pre>
<p>
This disables some cruft, and then renames <code>main</code> to <code>ZigClang_main</code> so that
it can be called like any other function. Next, in Zig's actual <code>main</code>, it looks
for <code>clang</code> as the first parameter, and calls it.
</p>
<p>
So, <code>zig clang</code> is low-level undocumented API that Zig exposes for directly invoking Clang.
But <code>zig cc</code> is much higher level than that. When Zig needs to compile C code,
it invokes itself as a child process, taking advantage of <code>zig clang</code>. <code>zig cc</code>
on the other hand, has a more difficult job: it must parse Clang's command line options and
map those to the Zig compiler's settings, so that ultimately <code>zig clang</code> can be invoked
as a child process.
</p>

<h3>Parsing Clang Command Line Options</h3>
<p>
When using <code>zig cc</code>, Zig acts as a proxy between the user and Clang. It does not need
to understand all the parameters, but it does need to understand some of them, such as
the target. This means that Zig must understand when a C command line parameter expects
to "consume" the next parameter on the command line.
</p>
<p>
For example, <code>-z -target</code> would mean to pass <code>-target</code> to the linker,
whereas <code>-E -target</code> would mean that the next parameter specifies the target.
</p>
<p>Clang has a
<a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">long list of command line options</a> and so it would be foolish to try to hard-code all of them.
</p>
<p>
Fortunately, LLVM has a file "options.td" which describes all of its command line parameter options
in some obscure format. But fortunately again, LLVM comes with the <code>llvm-tblgen</code> tool
that can dump it as JSON format.
</p>
<p>
Zig has an
<a href="https://github.com/ziglang/zig/blob/dc44fe053c609f389e375f6857f96b6bb3794897/tools/update_clang_options.zig">update_clang_options tool</a>
which processes this JSON dump and produces a
<a href="https://github.com/ziglang/zig/blob/dc44fe053c609f389e375f6857f96b6bb3794897/src-self-hosted/clang_options_data.zig">big sorted list of Clang's command line options</a>.
</p>
<p>
Combined with a list of "known options" which correspond to Zig compiler options,
this is used to make an iterator API that <code>zig cc</code> uses to parse command line
parameters and instantiate a Zig compiler instance. Any Clang options that Zig is not
aware of are forwarded to Clang directly. Some parameters are handled specially.
</p>

<h3>Linking</h3>
<p>
This part is pretty straightforward. Zig depends on LLD for linking rather than
shelling out to the system linker, like GCC and Clang do.
</p>
<p>
When you use <code>-o</code> with <code>zig cc</code>, Clang is not actually acting as
a linker driver here. Zig is still the linker driver.
</p>

<h2>Everybody Wins</h2>
<p>
Now that I've spent this entire blog article comparing Zig and Clang as if they are
competitors, let me make it absolutely clear that both of these are harmonious,
mutually beneficial open-source projects. It's pretty obvious how Clang and the entire
LLVM project are massively beneficial to the Zig project, since Zig builds on top of them.
</p>
<p>
But it works the other way, too.
</p>
<p>
With Zig's focus on cross-compiling, its test suite has been expanding rapidly to cover
a large number of architectures and operating systems, leading to
<a href="https://github.com/ziglang/zig/issues?q=is%3Aissue+label%3Aupstream+is%3Aclosed">dozens of bugs reported upstream and patches sent</a>, including, for example:
</p>
<ul>
  <li><a href="https://bugs.llvm.org/show_bug.cgi?id=43268">Regression discovered in LLVM 9 release candidate</a></li>
  <li><a href="https://bugs.winehq.org/show_bug.cgi?id=47979">Bug fixed in Wine's NtDll</a></li>
  <li><a href="https://github.com/ziglang/zig/issues/3338#issuecomment-536771508">Directly working with RISC-V target developers</a></li>
  <li><a href="https://bugs.llvm.org/show_bug.cgi?id=43768#c3">Bug fixes in LLVM's MIPS code generation</a></li>
</ul>
<p>Everybody wins.</p>

<h2>This is still experimental!</h2>
<p>
I have only recently landed <code>zig cc</code> support last week, and it is still experimental.
Please do not expect it to be production quality yet.
</p>
<p>
Zig's 0.6.0 release is right around the corner, scheduled for April 13th. I will be sure to provide
an update on the release notes on how stable and robust you can expect <code>zig cc</code> to be
in the 0.6.0 release.
</p>
<p>
There are some follow-up issues related to <code>zig cc</code> which are still open:
</p>
<ul>
  <li><a href="https://github.com/ziglang/zig/issues/4784">improve zig cc flag integration</a></li>
  <li><a href="https://github.com/ziglang/zig/issues/4785">using zig as a drop in replacement for msvc</a></li>
  <li><a href="https://github.com/ziglang/zig/issues/4786">support compiling and linking c++ code</a></li>
  <li><a href="https://github.com/ziglang/zig/issues/4787">use case: directly symlink zig binary to /usr/bin/cc</a></li>
</ul><p>
As always, <a href="https://github.com/ziglang/zig/blob/master/CONTRIBUTING.md">Contributions are most welcome</a>.

</p><h2>ðŸ’– Sponsor Zig ðŸ’–</h2>
<p><a href="https://github.com/sponsors/andrewrk">Sponsor Andrew Kelley on GitHub</a></p>
<p>
If you're reading this and you already sponsor me, thank you so much! I wake up every day
absolutely thrilled that I get to do this for my full time job.
</p>
<p>
As Zig has been gaining popularity, demands for my time have been growing faster than
funds to hire another full-time programmer. Every recurring donation helps, and if the funds keep
growing then soon enough the Zig project will have two full-time programmers.
</p>
<p>
That's all folks. I hope you and your loved ones are well.
</p>



      </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>