<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Chris Brumme - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Chris Brumme - linksfor.dev(s)"/>
    <meta property="og:description" content="When I learned in 2018 that Chris had passed away, I was very sad."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.frijters.net/cbrumme/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Chris Brumme</title>
<div class="readable">
        <h1>Chris Brumme</h1>
            <div>Reading time: 114-144 minutes</div>
        <div>Posted here: 07 Jan 2020</div>
        <p><a href="https://www.frijters.net/cbrumme/">https://www.frijters.net/cbrumme/</a></p>
        <hr/>
<div id="readability-page-1" class="page">

<p>When I <a href="https://twitter.com/h0x0d/status/1012922086870773760">learned</a> in 2018 that Chris had passed away, I was very sad.</p>
<p>I first met Chris in the fall of 2003. <a href="https://twitter.com/headinthebox">Erik Meijer</a> had asked me to attend a
devlab in Redmond for <a href="https://en.wikipedia.org/wiki/C%CF%89">Xen</a> and since I needed the trip to get to KLM Flying Dutchman Platinum
status I decided to go.</p>
<p>The Xen devlab was canceled,
but I did go to spend a lovely week driving and hiking around beautiful Washington state and met up with Chris in his office. We talked
about the intricacies of running Java on the CLR (both technical and legal).</p>
<p>We started e-mailing earlier in 2003. Below is the archive of these mails. I made a couple of redactions to remove names, two phone numbers
and some personal details. I updated some links and added clarifying titles to some terms.</p>
<p>In memory of a brilliant, but above all very kind and generous person.</p>
    
    <div><p>
Jeroen,</p><p>I’m not sure I fully understand your scenario.</p>
<p>I think you want to have a method on a class which satisfies an interface contract.  Today, this means the method must be virtual.</p>
<p>You want to be sure that the subtype can replace your stubbed method body with something reasonable.  So long as the subtype mentions the Interface on its ‘implements’ list again, we will trigger a new layout of this interface on that subtype.</p>
<p>You want to be able to use any old name for the class method.  This implies you are using a MethodImpl to match the method to the interface contract.  Any name will work, so long as it is unique on this class.  So you could come up with a mangling scheme, using characters that are illegal in the source language but legal in the metadata.  It sounds like you want to use ‘privatescope’ to avoid the uniqueness requirement.  (Is this the only reason you need privatescope?)</p>
<p>You want the class method to be unavailable to external callers, because it is an implementation detail.  Any of private, privatescope, or internal would achieve this.  Private is the most restrictive, and arguably the most suitable here.  This is what C# does, as you know.</p>
<p>Are those your requirements?  If so, I would personally use a ‘private virtual newslot final’ method, just like C#.  And I would come up with a name-mangling scheme for the name.  Unlike C#, I might pick a mangling scheme that includes ‘$’ or some other bizarre character other than ‘.’.  But I would have to check the list of legal characters.</p>
<p>IKVM looks very interesting.  If you get really stuck on something, feel free to ask.  I may be able to help.  However, I want to avoid getting deep into Java / JVM issues.  I can only help you with issues targeting the CLR.</p>
<p>Chris.</p>
<p><a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a></p>

    </div>    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            &gt; I’m not sure I fully understand your scenario.<o:p></o:p></p>
        
        <p>
            I dug up my original notes and I'll explain what I was trying to do (note that I'm not looking for a solution, when I found out that privatescope methods aren't allowed to be virtual, I chose to use another way of doing of it).<o:p></o:p></p>
        
        <p>
            This is a somewhat bizarre scenario, but since I want my JVM to be as compatible as possible I did think it was important to support. Here is the Java code (won't compile, but the equivalent .class files will run).<o:p></o:p></p>
        
        <p>
            class Base {<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>protected void Foo() {}<o:p></o:p></p>
        <p>
            }<o:p></o:p></p>
        <p>
            interface IFoo {<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>public void Foo();<o:p></o:p></p>
        <p>
            }<o:p></o:p></p>
        <p>
            class Derived implements IFoo {<o:p></o:p></p>
        <p>
            }<o:p></o:p></p>
        <p>
            class MoreDerived extends Derived {<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>protected void Foo() {}<o:p></o:p></p>
        <p>
            }<o:p></o:p></p>
        
        <p>
            Note that Derived is not abstract, but it does *not* implement IFoo.Foo, because Base.Foo is protected it doesn't qualify as an implementation of IFoo.Foo. If you instantiate Derived on a JVM (this is allowed!) and then call IFoo.Foo, it throws an IllegalAccessError.<o:p></o:p></p>
        
        <p>
            Now when I compiled this to MSIL, I inserted a privatescope Foo method in Derived that implements IFoo.Foo and made that method throw an IllegalAccessError. To my surprise I found that MoreDerived.Foo actually overrides the Derived.Foo privatescope method. I hadn't expected this because I (incorrectly) assumed that the CLR wouldn't ever take the name of a privatescope method into account (basically, I though of privatescope as equivalent to "this has no name").<o:p></o:p></p>
        
        <p>
            The solution was, of course, trivial. Mangle the name of the Derived.Foo method and make it private instead of privatescope (because I had since learned from Serge Lidin that privatescope virtual wasn't a legal combination anyway). Everyone happy, except for the fact that I felt some disappointment at the fact that privatescope wasn't as nice a construct as I had originally thought when I was reading the ECMA spec for the first time. I had hoped it would do away with the need for name mangling, but in this case I still had to use it.<o:p></o:p></p>
        
        <p>
            &gt; It sounds like <o:p></o:p>
        </p>
        <p>
            &gt; you want to use ‘privatescope’ to avoid the uniqueness <o:p></o:p>
        </p>
        <p>
            &gt; requirement.<span>&nbsp; </span>(Is this the only reason you need privatescope?)<o:p></o:p></p>
        
        <p>
            Exactly. I thought it was the most elegant way of mapping the (broken) Java classes onto CLR types.<o:p></o:p></p>
        
        <p>
            &gt; You want the class method to be unavailable to external <o:p></o:p>
        </p>
        <p>
            &gt; callers, because it is an implementation detail.<span>&nbsp; </span>Any of <o:p></o:p>
        </p>
        <p>
            &gt; private, privatescope, or internal would achieve this.<span>&nbsp; </span><o:p></o:p>
        </p>
        <p>
            &gt; Private is the most restrictive, and arguably the most <o:p></o:p>
        </p>
        <p>
            &gt; suitable here.<span>&nbsp; </span>This is what C# does, as you know.<o:p></o:p></p>
        
        <p>
            An additional property of privatescope that I liked, was the fact that it wasn't private. When the Java application would use reflection to look at the methods in the type, it would be really easy for me to filter out the privatescope methods (which weren't supposed to be there, from the Java point of view). In the new situation I had to use a custom attribute to mark the stub method as an implementation detail that shouldn't be visible.<o:p></o:p></p>
        
        <p>
            &gt; Are those your requirements?<span>&nbsp; </span>If so, I would personally use a <o:p></o:p>
        </p>
        <p>
            &gt; ‘private virtual newslot final’ method, just like C#.<span>&nbsp; </span>And I <o:p></o:p>
        </p>
        <p>
            &gt; would come up with a name-mangling scheme for the name.<o:p></o:p></p>
        
        <p>
            This is exactly what I ended up with.<o:p></o:p></p>
        
        <p>
            &gt; IKVM looks very interesting.<span>&nbsp; </span>If you get really stuck on <o:p></o:p>
        </p>
        <p>
            &gt; something, feel free to ask.<span>&nbsp; </span>I may be able to help.<span>&nbsp; </span><o:p></o:p>
        </p>
        <p>
            &gt; However, I want to avoid getting deep into Java / JVM issues. <o:p></o:p>
        </p>
        <p>
            &gt;<span>&nbsp; </span>I can only help you with issues targeting the CLR.<o:p></o:p></p>
        
        <p>
            Thanks. Let me explain a little of what prompted my original comment. I think I have a pretty deep understanding of both the JVM and CLR and I must say that I *love* the CLR. In fact, I like the CLR so much, that every time I find a tiny blemish, I'm disappointed ;-) I'd like the CLR (and the specification) to be all it can be, so I occasionally try to challenge you (and others at MS) in the hope that either it will be explained to me why something was designed in such a way (in other words, prove me wrong) or that the design (or implementation) might be improved (in the long run. I don't really care about the small service pack style bugs that can easily be worked around).<o:p></o:p></p>
        
        <p>
            BTW, thanks for your blog, it is really good to read about the design decisions and trade offs that were/are considered. Are you attending the <abbr title="Microsoft Professional Developers Conference">PDC</abbr>? I'd love to chat with you over a couple of beers :-)<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
    </div>
        
    <div>
        <p>
            Thanks, that all makes perfect sense.<o:p></o:p></p>
        
        <p>
            I'll try to chase down the discrepancies between ECMA and our implementation with respect to privatescope.<o:p></o:p></p>
        
        <p>
            I'm not sure if I'll be going to the PDC.<span>&nbsp; </span>I've consistently missed every PDC for the last 6 years (and every company meeting, too).<span>&nbsp; </span>But I'm seriously thinking of going to this one.<span>&nbsp; </span>If I go, a beer sounds great.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a><o:p></o:p></p>
        
&nbsp;</div>
        
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            I've got a question that might be appropriate for your blog. I would like to know why the CLR has finalizers and what your take on them is. To give some context: IMHO, finalizers should only be used as a last resort for freeing unmanaged resources and nothing else, because of this, I would have put an InheritanceDemand on Finalize for the UnmanagedCode permission. At the moment, untrusted code can run at a higher priority by high-jacking the finalizer thread (In Java, untrusted code can change the thread priority, I'm not sure that .NET even tries to prevent this). More important, I believe that untrusted code can prevent an AppDomain from being unloaded -- again -- by running in the finalizer thread.<o:p></o:p></p>
        
        <p>
            Second question: Will you be at the <abbr title="Codename for what later became .NET Framework 2.0">Whidbey</abbr> <abbr title="Software Design Review">SDR</abbr> on the 25/26 of June?<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
    </div>
        
    <div>
        <p>
            For your second question, I shall be on Maui from 6/11 thru 7/4.<o:p></o:p></p>
        <p>
            However, I have broadband and wireless out by the pool.<span>&nbsp; </span>So -- if my wife permits -- I shall still blog a little.<o:p></o:p></p>
        
        <p>
            I'm thinking of going to the PDC in L.A. in late October this year.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        
        <p>
            &gt; For your second question, I shall be on Maui from 6/11 thru 7/4.<o:p></o:p></p>
        <p>
            &gt; However, I have broadband and wireless out by the pool.<span>&nbsp; </span>So -- if my <o:p></o:p>
        </p>
        <p>
            &gt; wife permits -- I shall still blog a little.<o:p></o:p></p>
        
        <p>
            That's fun too ;-)<o:p></o:p></p>
        
        <p>
            &gt; I'm thinking of going to the PDC in L.A. in late October this year.<o:p></o:p></p>
        
        <p>
            I know, I already asked you. I may have even promised to buy you a beer ;-)<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            I think you said "a couple of beers", which could be interpreted as up to 3.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a><o:p></o:p></p>
    </div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            I hope you had a good vacation!<o:p></o:p></p>
        
        <p>
            The Whidbey SDR was fun and the alpha bits are very nice.<o:p></o:p></p>
        
        <p>
            I have a few questions, possibly for your blog or you can just ignore them and I'll get the answers at the PDC, while you're under the influence of large amounts of alcohol ;-)<o:p></o:p></p>
        
        <p>
            - Why no return type co-variance (and argument type contra-variance)?<o:p></o:p></p>
        <p>
            - Why no delegate structural equivalence?<o:p></o:p></p>
        <p>
            - What is the output of this code:<o:p></o:p></p>
        
        <p>
            class Test {<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>public static void Main() {<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>int i = int.MinValue;<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>System.Console.WriteLine(-i);<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>System.Console.WriteLine(i * -1);<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>System.Console.WriteLine(i / -1);<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>}<o:p></o:p></p>
        <p>
            }<o:p></o:p></p>
        
        <p>
            Why?<o:p></o:p></p>
        
        <p>
            - Why don't arrays implement IList&lt;T&gt;, ICollection&lt;T&gt; and IEnumerable&lt;T&gt;? (I think I understand why, but it might make a good blog entry to explain). Would it be a good idea to add a static helper to System.Array to wrap arrays into a generic class that does implement these interfaces?<o:p></o:p></p>
        <p>
            - What does ildasm mean when it says ".assembly *legacy* library mscorlib" on Whidbey assemblies?<o:p></o:p></p>
        
        <p>
            That's enough for now ;-). Feel free to ignore me if you're busy.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
    </div>
    
    <div>
        <p>
            Some of these are easy.<o:p></o:p></p>
        
        <p>
            No co/contravariance -- we haven't had time to do it yet.<span>&nbsp; </span>It's not a controversial feature.<span>&nbsp; </span>You might see some limited places show up in the next release.<span>&nbsp; </span>But not where you are expecting it (i.e. not with normal virtual methods).<o:p></o:p></p>
        
        <p>
            No delegate structural equivalence -- we haven't had time to do it yet.<o:p></o:p></p>
        <p>
            This one is even more desirable.<span>&nbsp; </span>You might see us make it easier for you to form a single delegate type over multiple related signatures, before you see us actually treat structurally equivalent delegates as type-substitutable.<o:p></o:p></p>
        
        <p>
            For the math output, presumably you are asking about the exception.<span>&nbsp; </span>The code is:<o:p></o:p></p>
        
        <p>
            Mov eax, 80000000<o:p></o:p></p>
        <p>
            Mov ecx, ffffffff<o:p></o:p></p>
        <p>
            Cdq<o:p></o:p></p>
        <p>
            Idiv ecx<o:p></o:p></p>
        
        <p>
            This generates an integer overflow exception.<span>&nbsp; </span>From the ECMA spec on<o:p></o:p></p>
        <p>
            'div':<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Integral operations throw ArithmeticException if the result<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>cannot be represented in the result type. This can happen<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if value1 is the smallest representable integer value, and<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>value2 is -1.<o:p></o:p></p>
        
        <p>
            I haven't been following the generics effort as closely as I should.<span>&nbsp; </span>My initial answer, without thinking about it, is that variant arrays (MyType[] substitutes for Object[]) would be something of a lie.<span>&nbsp; </span>But the lie is no worse than the substitution, so this may not be the reason.<span>&nbsp; </span>I'll check into this.<o:p></o:p></p>
        
        <p>
            Part of the Whidbey versioning story is that assemblies can be tagged to indicate something about how they version.<span>&nbsp; </span>Based on what ILDASM is saying, it sounds like the tag isn't present in mscorlib yet.<span>&nbsp; </span>Therefore ILDASM is categorizing it as the default.<span>&nbsp; </span>The 'legacy' part indicates that the assembly isn't participating properly in the new plan yet.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
    </div>
    
    <div>
        <p>
            Chris, thanks for your answers. <o:p></o:p>
        </p>
        
        <p>
            &gt; For the math output, presumably you are asking about the exception.<span>&nbsp; </span><o:p></o:p>
        </p>
        <p>
            &gt; The code is:<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; Mov eax, 80000000<o:p></o:p></p>
        <p>
            &gt; Mov ecx, ffffffff<o:p></o:p></p>
        <p>
            &gt; Cdq<o:p></o:p></p>
        <p>
            &gt; Idiv ecx<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; This generates an integer overflow exception.<span>&nbsp; </span>From the ECMA spec on<o:p></o:p></p>
        <p>
            &gt; 'div':<o:p></o:p></p>
        
        <p>
            Right, but this is an x86-ism. The CLR could handle the exception and pretend the result of the idiv is -1. This is what Java does and I think that makes for a more consistent story, especially since the CLR has the .ovf versions (but the div.ovf is conspicously absent).<o:p></o:p></p>
        
        <p>
            So what I would have done is: div.ovf = current behavior and div = catch the overflow exception and resume on the next instruction (leaving the -1 in eax).<o:p></o:p></p>
        
        <p>
            &gt; I haven't been following the generics effort as closely as I should.<span>&nbsp; </span><o:p></o:p>
        </p>
        <p>
            &gt; My initial answer, without thinking about it, is that variant arrays <o:p></o:p>
        </p>
        <p>
            &gt; (MyType[] substitutes for Object[]) would be something of a lie.<span>&nbsp; </span>But <o:p></o:p>
        </p>
        <p>
            &gt; the lie is no worse than the substitution, so this may not be the <o:p></o:p>
        </p>
        <p>
            &gt; reason.<span>&nbsp; </span>I'll check into this.<o:p></o:p></p>
        
        <p>
            I thought it had to do with the type information sharing that arrays do, but after thinking about it a bit more I don't think there is any reason why it wouldn't work. Performance for value types would probably not be ideal (unless specialised code for each array type is generated, but that would be wasteful), but it would be a powerful feature.<o:p></o:p></p>
        
        <p>
            This reminds me, I noticed the private FastArray&lt;T&gt; class in mscorlib and I assume it is there to get around the cost of array covariance, but it looks to be more complicated than it needs to be. Someone else (I can't take credit unfortunately) came up with this pattern:<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public sealed class FastArray&lt;T&gt;<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>struct ValueContainer&lt;Ti&gt;<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>internal Ti t;<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ValueContainer&lt;T&gt;[] array;<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public FastArray(int count)<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>array = new ValueContainer&lt;T&gt;[count];<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public int Length<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>get { return array.Length; }<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public T this[int index]<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>get { return array[index].t; }<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>set { array[index].t = value; }<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
    </div>
    
    <div>
        <p>
            The ECMA rules for division are that the sign of the result is positive if both operands have the same sign, and it's negative if both operands have different signs.<span>&nbsp; </span>This makes sense to me.<o:p></o:p></p>
        
        <p>
            Since you are dividing two negative operands, the result must be positive.<span>&nbsp; </span>Returning -1 seems like the wrong thing to do here.<span>&nbsp; </span>The actual result cannot be represented in a signed integer of this size.<o:p></o:p></p>
        
        <p>
            I'll dig into the array / generics issues and get back to you later.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        
        <p>
            &gt; The ECMA rules for division are that the sign of the result is <o:p></o:p>
        </p>
        <p>
            &gt; positive if both operands have the same sign, and it's negative if <o:p></o:p>
        </p>
        <p>
            &gt; both operands have different signs.<o:p></o:p></p>
        <p>
            &gt; This makes sense to me.<o:p></o:p></p>
        
        <p>
            OK, but why not apply the same rule to multiplication then?<o:p></o:p></p>
        
        <p>
            -2147483648 * -1 = -2147483648<o:p></o:p></p>
        
        <p>
            <span>&nbsp;</span>is just as nonsensical as<o:p></o:p></p>
        
        <p>
            -2147483648 / -1 = -2147483648<o:p></o:p></p>
        
        <p>
            but only the latter one throws an exception.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
    </div>
    
    <div>
        <p>
            Working on the execution engine rather than the JIT, I don't' spend much time looking at IL.<span>&nbsp; </span>I have to admit that I never noticed the asymmetry.<o:p></o:p></p>
        <p>
            I'll look into this, too.<span>&nbsp; </span>I'm curious if there was a rationale.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
    </div>
    
    <div>
        <p>
            <span>Sorry, I've been gone for a while on some fire drills.</span><o:p></o:p></p>
        <p>
            <span>Your FastArray is certainly convenient to express.</span>&nbsp;<span> But it creates new structs and new arrays of structs for each expansion of a different reference type T.&nbsp; Today, we share code very aggressively for reference types, but we do a poor job of sharing code for different structs.&nbsp; Therefore, your approach will generate many distinct method bodies and stubs.</span>&nbsp;<span> In the future, we could do a better job here.</span><o:p></o:p></p>
        <p>
            <span>And here's the internal story for the div/mul thing from a dev involved with the decisions.&nbsp; I doubt that this is our official story, so I don't think I would publicize it:</span><o:p></o:p></p>
        <p>
            <span>As you say, div really should be called div.ovf, and thus there is symmetry there with mul.ovf, that part is perfectly reasonable.</span><o:p></o:p></p>
        <p>
            <span>Really the only issue is why we don’t have a div without overflow.&nbsp;&nbsp;&nbsp; The simple answer here is that it did not add a whole lot of value (where would you use div non-overflow?)</span><o:p></o:p></p>
        <p>
            <span>Of course historically this is not how it happened.&nbsp; In reality div and mul came first before the overflow variants, and the goal of the IL was simply to find an abstraction for many hardware platforms.&nbsp; Hardware DID support overflow for division but not multiplication.&nbsp;&nbsp;&nbsp; Later we added mul.ovf.&nbsp;&nbsp; Why go back at that point and go to some trouble to create a ‘broken’ version of div (since it really does have to return the wrong value for at least on case), just for the sake of symmetry?</span><o:p></o:p></p>
        
        <p>
            <a name=""><span>Chris.</span></a><o:p></o:p></p>
        <p><span><a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a></span></p></div>
    
    <div>
        <p>
            Hi Chris, <o:p></o:p>
        </p>
        
        <p>
            &gt; Your FastArray is certainly convenient to express.<span>&nbsp; </span>But it creates new <o:p></o:p>
        </p>
        <p>
            &gt; structs and new arrays of structs for each expansion of a different <o:p></o:p>
        </p>
        <p>
            &gt; reference type T.<span>&nbsp; </span>Today, we share code very aggressively for <o:p></o:p>
        </p>
        <p>
            &gt; reference types, but we do a poor job of sharing code for different <o:p></o:p>
        </p>
        <p>
            &gt; structs.<span>&nbsp; </span>Therefore, your approach will generate many distinct method <o:p></o:p>
        </p>
        <p>
            &gt; bodies and stubs.<o:p></o:p></p>
        <p>
            &gt;<span>&nbsp; </span>In the future, we could do a better job here.<o:p></o:p></p>
        
        <p>
            I also noticed that when I change FastArray to a value type, it becomes a lot slower. I assume this is due to the extra type information that needs to be passed in each method call.<o:p></o:p></p>
        
        <p>
            Another thing I've been thinking about (and this is really far out there) is running managed code in kernel mode. Do you think that in the future (and I'm talking about far into the future, past Longhorn/<abbr title="Codename for .NET Framework version after Whidbey">Orcas</abbr>) it will ever become possible to run (verifiable) managed applications in kernel mode? It would obviously require a lot of work (esp. duplicating all the APIs on the kernel side), but the performance and scalability gains could be significant. I don't know if you're familiar with the IBM AS400, but its architecture inspired me to think about managed code in kernel mode.<o:p></o:p></p>
        
        <p>
            Obviously this requires a 64 bit architecture, because currently kernel memory space is already cramped, but I think that this might be an interesting future path.<o:p></o:p></p>
        
        <p>
            Thanks.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
    </div>
    
    <div>
        <p>
            Long term, we would all like to see managed execution in the kernel.<o:p></o:p></p>
        <p>
            Suspension for GC has to be done differently.<span>&nbsp; </span>NGEN rather than JIT becomes more important.<o:p></o:p></p>
        
        <p>
            But we all see the benefits of having type safety and bounds checking inside device drivers.<span>&nbsp; </span>They will need to step outside of type-safety in some places, but those places can be clearly marked for audit (like C# 'unsafe' blocks).<o:p></o:p></p>
        
        <p>
            Eventually, I'm confident that this will happen.<span>&nbsp; </span>Whether it's the CLR we built, or whether the OS folks build their own... who knows.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            I just read your most recent blog entry. Awesome! Thanks for taking the time (and having the courage) to write this stuff up.<o:p></o:p></p>
        
        <p>
            At the end you write: "This means aggressively chasing the weaknesses of our present system, like the fact that locally installed assemblies by default run with FullTrust throughout their execution."<o:p></o:p></p>
        
        <p>
            This (FullTrust for local code) was my biggest disappointment with .NET when I first encountered it, it's good to see that it is on the agenda. Another thing that annoyed me recently was a 3rd party application that decided (during its installation) that it would be a good idea to modify the .NET framework security policy (without telling me). I hope that for Longhorn, application sandboxing will become the norm rather than the exception, but I realise that this is a difficult task (and probably not related to what you are doing).<o:p></o:p></p>
        
        <p>
            I know you probably can't talk about this (hopefully at the PDC), but I'm wondering about the combination of Palladium (eh, NGSCB) and managed code. I hope that *only* managed code will be allowed to run as a Palladium agent. That way running encrypted code can be prevented (which I believe is critical to the success of Palladium, imagine a worm that uses Palladium to encrypt itself securely).<o:p></o:p></p>
        
        <p>
            About the kernel mode code, do you think it will ever become viable to run application code in kernel space? Below you said: "NGEN rather than JIT becomes more important". Is this because of bootstrapping issues, or because you don't want something with the complexity of the JIT running in kernel space? Maybe one day the JIT will be written in managed code as well ;-)<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            More personal opinions:<o:p></o:p></p>
        
        <p>
            By the time LH rolls around, I think we'll have a much more rational and restricted security world for applications to live in.<span>&nbsp; </span>And a reasonable way for apps to escape that restricted world.<o:p></o:p></p>
        
        <p>
            NGSCB is necessarily a lot less than Win32.<span>&nbsp; </span>Therefore the CLR cannot run in NGSCB without a significant port.<span>&nbsp; </span>I think everyone agrees that this is a long-term sensible way to execute ultra-secure application code.<span>&nbsp; </span>However, it's not clear whether either the CLR or NGSCB are mature enough for us to invest in that marriage today.<span>&nbsp; </span>And as always we are very pressed for resources.<o:p></o:p></p>
        
        <p>
            I'm not sure why we would want to run application code in kernel space.<o:p></o:p></p>
        <p>
            Device drivers make sense to me.<o:p></o:p></p>
        
        <p>
            I think existing kernel developers would be more comfortable with NGEN than the JIT for kernel-side managed execution (should this ever occur).<o:p></o:p></p>
        <p>
            The notion of generating code on the fly -- inside the kernel -- and then executing whatever you ended up with, is horrifying to them.<span>&nbsp; </span>They really want to know what they are going to be executing and they really don't want any randomization based on the sequence in which JITting occurs, or based on which .cctors win a race condition, etc.<span>&nbsp; </span>They want absolute predictability and I cannot blame them.<o:p></o:p></p>
        
        <p>
            It's perfectly reasonable for JITs to be written in managed code.<span>&nbsp; </span>There are bootstrapping issues, but they are addressed with NGEN or interpretation or with a special bootstrapping unmanaged JIT.<span>&nbsp; </span>I think you will see managed JITs at some point.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p><span><a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a></span>
    </p></div>
    
    <div>
        <p>
            Could you explain the use of the ‘volatile’ prefix before any non-dependent ldfld or stfld?<span>&nbsp; </span>We will order stores for you.<span>&nbsp; </span>It’s true that loads might be hoisted.<span>&nbsp; </span>Does Java have a stronger memory model than X86, which forces your compiler to emit these prefixes?<o:p></o:p></p>
        
        <p>
            Although Java may allow transfers in or out of finally blocks, your example doesn’t seem to take advantage of this.<span>&nbsp; </span>So it seems like you could compile your current example more simply than you do.<span>&nbsp; </span>Can’t this example be handled by emitting try/catch/finally clauses exactly as they appear in the source?<o:p></o:p></p>
        
        <p>
            And (you’ll have to excuse my extreme ignorance of Java) you say that try/finally is compiled in Java to try/catch.<span>&nbsp; </span>Presumably the Java compiler branches from the catch to some common code that’s shared with the non-exceptional finally pathway.<span>&nbsp; </span>Then at the end it either returns or throws depending on whether the finally was reached exceptionally or not.<span>&nbsp; </span>You also say that Java supports branching in and out of catch &amp; finally and that a return from a finally is legal.<span>&nbsp; </span>Do you have a simple example that uses these freedoms?<span>&nbsp; </span>I would like to think about it for a while.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        
        <p>
            <a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris, <o:p></o:p>
        </p>
        
        <p>
            &gt; Could you explain the use of the ‘volatile’ prefix before any <o:p></o:p>
        </p>
        <p>
            &gt; non-dependent ldfld or stfld?<span>&nbsp; </span>We will order stores for you.<o:p></o:p></p>
        
        <p>
            The example is from Java (source) code that might also run on other VMs that do require volatile. I wrote the code, but I didn't have the CLR memory model in mind at the time, the Java model is weaker.<o:p></o:p></p>
        
        <p>
            &gt; It’s true that loads might be hoisted.<span>&nbsp; </span>Does Java have a stronger <o:p></o:p>
        </p>
        <p>
            &gt; memory model than X86, which forces your compiler to emit these <o:p></o:p>
        </p>
        <p>
            &gt; prefixes?<o:p></o:p></p>
        
        <p>
            Rather it's the other way around ;-) Java has a weaker memory model, so the source contains the a volatile modifier on the "running" field. When I compile the Java bytecode to CIL, I have to respect the fact that the field is volatile.<o:p></o:p></p>
        
        <p>
            This code is not a very good example of the memory model issues, because it is broken on several counts (by design, there is no safe way to write the thread startup/teardown in Java, it really should be done in native code).<o:p></o:p></p>
        
        <p>
            &gt; Although Java may allow transfers in or out of finally blocks, your <o:p></o:p>
        </p>
        <p>
            &gt; example doesn’t seem to take advantage of this.<o:p></o:p></p>
        
        <p>
            Not on the surface, but I don't actually compile the source, I compile the .class file. A try finally is compiled as follows (pseudo code):<o:p></o:p></p>
        
        <p>
            try {<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>...<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>jsr finally_block;<o:p></o:p></p>
        <p>
            } catch(Throwable t) {<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>jsr finally_block;<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>throw t;<o:p></o:p></p>
        <p>
            }<o:p></o:p></p>
        
        <p>
            finally_block:<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp; </span>....<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp; </span>ret<o:p></o:p></p>
        
        <p>
            So here you have branches out of both the try and catch blocks. I compile jsr by pushing an integer representing the call site and then branching to the address and ret is compiled as a bunch of beq instructions (jumping the return address corresponding to the call site).<o:p></o:p></p>
        
        <p>
            &gt; So it seems like you could compile your current example more simply <o:p></o:p>
        </p>
        <p>
            &gt; than you do.<span>&nbsp; </span>Can’t this example be handled by emitting <o:p></o:p>
        </p>
        <p>
            &gt; try/catch/finally clauses exactly as they appear in the source?<o:p></o:p></p>
        
        <p>
            If I were compiling source that would be the obvious solution, but now I don't know. For typical code I could figure out what constitutes a finally block (for known compilers anyway), but that would fail for unknown compilers or handwritten bytecode and that would cause the semantics to be different based on whether my CIL compiler was able to parse the bytecode correctly. This seems undesirable.<o:p></o:p></p>
        
        <p>
            &gt; And (you’ll have to excuse my extreme ignorance of Java) you say that <o:p></o:p>
        </p>
        <p>
            &gt; try/finally is compiled in Java to try/catch.<o:p></o:p></p>
        <p>
            &gt; Presumably the Java compiler branches from the catch to some common <o:p></o:p>
        </p>
        <p>
            &gt; code that’s shared with the non-exceptional finally pathway.<span>&nbsp; </span>Then at <o:p></o:p>
        </p>
        <p>
            &gt; the end it either returns or throws depending on whether the finally <o:p></o:p>
        </p>
        <p>
            &gt; was reached exceptionally or not.<o:p></o:p></p>
        
        <p>
            As you saw above, it's worse than that. They have a very evil jsr/ret construct (which makes their verifier very complicated).<o:p></o:p></p>
        
        <p>
            &gt; You also say that Java supports branching in and out of catch &amp; <o:p></o:p>
        </p>
        <p>
            &gt; finally and that a return from a finally is legal.<o:p></o:p></p>
        <p>
            &gt; Do you have a simple example that uses these freedoms?<span>&nbsp; </span>I would like <o:p></o:p>
        </p>
        <p>
            &gt; to think about it for a while.<o:p></o:p></p>
        
        <p>
            I hope the above made it clear. I don't have any good examples of returning from a finally block (which is obviously an evil thing to do). I'm vacationing in WA next week, wanna have a cup of coffee?<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            I need to think about the exceptions more.<span>&nbsp; </span>I don't drink coffee, but would certainly enjoy meeting with you while you are out here.<o:p></o:p></p>
        
        <p>
            You have my work email.<span>&nbsp; </span>The phone number here is <span>[Redacted]</span>.<o:p></o:p></p>
        
        <p>
            Of course, I still have a beer or two coming my way at the PDC.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        
        <p>
            &gt; I need to think about the exceptions more.<span>&nbsp; </span>I don't drink coffee, but <o:p></o:p>
        </p>
        <p>
            &gt; would certainly enjoy meeting with you while you are out here.<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; You have my work email.<span>&nbsp; </span>The phone number here is <span>[Redacted]</span>.<o:p></o:p></p>
        
        <p>
            OK. I'll give you a call when I'm in the neighborhood. I'm not taking my laptop with me, so I don't if I'll be able to check my e-mail.<o:p></o:p></p>
        
        <p>
            &gt; Of course, I still have a beer or two coming my way at the PDC.<o:p></o:p></p>
        
        <p>
            Absolutely!<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            If you can't reach me at my desk with the number below, you can also try my cell phone <span>[Redacted]</span>.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            <span>Here’s an example of a program which</span> <span>– I think</span> <span>– would fail a Java conformance test.</span><o:p></o:p></p>
        <p>
            <span>class A&nbsp; {</span><o:p></o:p></p>
        <p>
            <span>static {</span><o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.testF();</span><o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><o:p></o:p></p>
        <p>
            <span>}</span><o:p></o:p></p>
        <p>
            <span>class B extends A&nbsp; {</span><o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static Object f = new Object();</span><o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void testF() {</span><o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.toString();</span><o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><o:p></o:p></p>
        <p>
            <span>}</span><o:p></o:p></p>
        <p>
            <span>class C&nbsp; {</span><o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void main(String[] args)&nbsp; {</span><o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new B();</span><o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><o:p></o:p></p>
        <p>
            <span>}</span><o:p></o:p></p>
        <p>
            <span>On a conforming implementation, I suspect that A’s .cctor executes before B’s.&nbsp; So the call from A’s .cctor to B.testF can trigger B’s .cctor.</span><o:p></o:p></p>
        <p>
            <span>On the CLR, B’s .cctor will start executing first.&nbsp; If B’s .cctor chains to A’s .cctor, then we will consider this to be a cycle.&nbsp; We will allow the thread to see uninitialized state in B (the alternative now being a deadlock).&nbsp; This will cause an AV since</span> <span>B.f is still null.</span><o:p></o:p></p>
        <p>
            <a name=""><span>Chris.</span></a><o:p></o:p></p>
        <p>
            <u><span><a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a></span></u><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            I'm safely back home again. I enjoyed meeting you, thanks.<o:p></o:p></p>
        
        <p>
            You wrote:<o:p></o:p></p>
        <p>
            &gt; Here’s an example of a program which – I think – would fail a Java <o:p></o:p>
        </p>
        <p>
            &gt; conformance test.<o:p></o:p></p>
        
        <p>
            It doesn't. It throws an ExceptionInInitializerError (caused by NullPointerException) on Sun's JRE 1.4.1 (and on IKVM). I just reread the JVM specification section on class initialization and it explicitly states that the base class initializer runs *after* starting the initialization of the current class.<o:p></o:p></p>
        
        <p>
            When talking to you I felt kind of stupid for not having noticed a problem with class initialization (other than the deadlock vs seeing uninitialized state issue), but now I'm a little more confident again that I didn't miss anything.<o:p></o:p></p>
        
        <p>
            At the PDC I'm having dinner with Lee <span>[Redacted]</span> and some of the J# developers (and Miguel <span>[Redacted]</span>), I'll ask if they can explain the issue they are running into. BTW, if you'd like to join us that would be cool (but maybe you'd need to invite a lawyer too ;-)). I don't know what night it'll be, but it will be after the "alternate programming languages" BOF.<o:p></o:p></p>
        
        <p>
            &gt; On a conforming implementation, I suspect that A’s .cctor executes <o:p></o:p>
        </p>
        <p>
            &gt; before B’s.<span>&nbsp; </span>So the call from A’s .cctor to B.testF can trigger B’s <o:p></o:p>
        </p>
        <p>
            &gt; .cctor.<o:p></o:p></p>
        
        <p>
            Fortunately (for me) this turns out not to be the case and the JVM algorithm is implementable on the CLR. I'm trying to think of a reason why you'd want the behavior you're describing (vs the specified JVM behavior), but it's early and I've only had one cup of coffee ;-)<o:p></o:p></p>
        
        <p>
            &gt; On the CLR, B’s .cctor will start executing first.<span>&nbsp; </span>If B’s .cctor <o:p></o:p>
        </p>
        <p>
            &gt; chains to A’s .cctor, then we will consider this to be a cycle.<span>&nbsp; </span>We <o:p></o:p>
        </p>
        <p>
            &gt; will allow the thread to see uninitialized state in B (the alternative <o:p></o:p>
        </p>
        <p>
            &gt; now being a deadlock).<o:p></o:p></p>
        
        <p>
            Java does the same thing if the access is on the same thread, but in multithreaded scenarios it is possible to deadlock (whereas on the CLR you'd still see the unitialized state).<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            So those guys complained that we weren't conforming, without checking their facts?<span>&nbsp; </span>I'm glad I told them we wouldn't fix this one for them.<o:p></o:p></p>
        
        <p>
            I'm not sure about a dinner with the J# folks.<span>&nbsp; </span>Let me know when you pick an evening.<span>&nbsp; </span>But I think I need to check before I can accept.<span>&nbsp; </span>Definitely let's get together one evening during the PDC.<span>&nbsp; </span>I think Monday is the only night I'm currently committed.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Chris,<o:p></o:p></p>
        
        <p>
            I'm not sure what we're doing for dinner, but I'm going to be at the Ask the Experts "Java and .NET: Migration and Interop" tonight at 7pm (to chat with the J# people). I understand Miguel is also going to be there, so maybe we'll do dinner afterwards, but I'm not sure.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            I finally got around to implementing weak reference support in IKVM and I thought you might be interested in what I found.<o:p></o:p></p>
        
        <p>
            First a little bit of introduction. Java has three types of weak references:<o:p></o:p></p>
        <p>
            - SoftReference: Only cleared when GC is about to run out of memory<o:p></o:p></p>
        <p>
            - WeakReference: Like a short .NET System.WeakReference<o:p></o:p></p>
        <p>
            - PhantomReference: A long weak reference, but the referent is not retrievable (!)<o:p></o:p></p>
        
        <p>
            In addition to typical weak reference functionality, these classes also support a ReferenceQueue notion. When a reference gets cleared by the GC, it can optionally post the reference into a ReferenceQueue. PhantomReference is only useful in combination with a ReferenceQueue. The PhantomReference object gets added to the queue after the referent is finalized, the other two get added when they are cleared.<o:p></o:p></p>
        
        <p>
            (BTW, all three classes derived from java.lang.ref.Reference)<o:p></o:p></p>
        
        <p>
            Here are my implementation experiences:<o:p></o:p></p>
        <p>
            I couldn't find a way to implement SoftReference, so at the moment I treat them the same as a WeakReference. The reference part of WeakReference and PhantomReference was easy.<o:p></o:p></p>
        
        <p>
            The trickiest was to find a way to detect that a reference is cleared so that it can be enqueued.<o:p></o:p></p>
        
        <p>
            I came up with the following implementation of java.lang.ref.Reference (pseudo code):<o:p></o:p></p>
        
        <p>
            abstract class Reference {<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>private cli.System.WeakReference referent;<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>private ReferenceQueue queue;<o:p></o:p></p>
        
        <p>
            <span>&nbsp; </span>Reference(object o, ReferenceQueue queue) {<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>referent = new cli.System.WeakReference(o, this instanceof PhantomReference);<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>this.queue = queue;<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>if(queue != null) new QueueWatcher();<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>}<o:p></o:p></p>
        
        <p>
            <span>&nbsp; </span>private class QueueWatcher {<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>protected void finalize() {<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if(referent.IsAlive) {<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if(!cli.System.Environment.HasShutdownStarted) {<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>new QueueWatcher();<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>} else {<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>enqueue();<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>}<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>}<o:p></o:p></p>
        
        <p>
            <span>&nbsp; </span>public void enqueue() {<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>queue.add(this);<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>}<o:p></o:p></p>
        
        <p>
            <span>&nbsp; </span>public object get() {<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>return referent.Target;<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>}<o:p></o:p></p>
        
        <p>
            <span>&nbsp; </span>public void clear() {<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>referent.Target = null;<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>}<o:p></o:p></p>
        <p>
            }<o:p></o:p></p>
        
        <p>
            (In case your Java is a bit rusty, the QueueWatcher inner classes has an implicit reference to the instance of the outer class that constructed it.)<o:p></o:p></p>
        
        <p>
            This works, but there are some obvious problems with the QueueWatcher hack:<o:p></o:p></p>
        <p>
            - It's a hack<o:p></o:p></p>
        <p>
            - It's inefficient<o:p></o:p></p>
        <p>
            - A future JIT could decide to compile "new QueueWatcher()" as "(new QueueWatcher()).finalize()"<o:p></o:p></p>
        
        <p>
            However, overall, I'm pretty happy with it.<o:p></o:p></p>
        
        <p>
            I've thought about what functionality the CLR could provide to make this easier, but I haven't been able to come up with anything that isn't just a rip off of the Java model.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            I found a bug in System.WeakReference. The class is not sealed and neither is its finalizer, so any untrusted code can create an unbounded number of GCHandles that will never get cleaned up (by creating a subclass of WeakReference that overrides Finalize and not calls the base class Finalize).<o:p></o:p></p>
        
        <p>
            See attached code for a reproduction.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Thanks.<span>&nbsp; </span>I'll file the bug.<span>&nbsp; </span>Unfortunately, sealing the class now would be a breaking change.<span>&nbsp; </span>And Denial of Service isn't considered a strong security threat -- particularly since defense against denial of service attacks remains so difficult.<o:p></o:p></p>
        
        <p>
            It won't surprise me if this bug is indefinitely punted.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            It is kind of nasty that the leak stays around even after the AppDomain is unloaded.<o:p></o:p></p>
        
        <p>
            It would be fixable by making the Finalize method final. Unfortunately, C# doesn't allow this (big design flaw, IMHO), but I guess that would also be a breaking change. How about a full trust inheritance demand on the Finalize method? That way untrusted code can't leak and it's hard to come up with a useful scenario where partially trusted code needs a Finalize anyway.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            The leak shouldn't stay around after the AppDomain is unloaded.<span>&nbsp; </span>We bulk unmap the entire handle table for the doomed AppDomain.<span>&nbsp; </span>(Each AppDomain gets its own handle table, though we have to be clever with handles to objects that are agile with respect to AppDomain boundaries).<span>&nbsp; </span>If this were not the case, we would crash on the first GC after the unload since you can be sure that the MethodTables of the instances have been unmanpped.<o:p></o:p></p>
        
        <p>
            I think that SQL Server may have a pre-verification pass to reject "safe" code that defines Finalize methods.<span>&nbsp; </span>If so, Finalize would remain available to some partially trust assemblies -- but not to the assemblies with the lowest possible trust.<o:p></o:p></p>
        
        <p>
            It would be interesting to formalize this, so that a process host could decide whether it wants to make itself immune to this sort of denial of service.<span>&nbsp; </span>There is a tension here, because the host can no longer run arbitrary code that was written for some other environment.<o:p></o:p></p>
        
        <p>
            I'll add some of your thoughts to the bug report.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="https://devblogs.microsoft.com/cbrumme/">http://blogs.gotdotnet.com/cbrumme/</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            &gt; The leak shouldn't stay around after the AppDomain is unloaded.<span>&nbsp; </span>We <o:p></o:p>
        </p>
        <p>
            &gt; bulk unmap the entire handle table for the doomed AppDomain.<o:p></o:p></p>
        <p>
            &gt; (Each AppDomain gets its own handle table, though we have to be clever <o:p></o:p>
        </p>
        <p>
            &gt; with handles to objects that are agile with respect to AppDomain <o:p></o:p>
        </p>
        <p>
            &gt; boundaries).<span>&nbsp; </span>If this were not the case, we would crash on the first <o:p></o:p>
        </p>
        <p>
            &gt; GC after the<span>&nbsp; </span>unload since you can be sure that the MethodTables of <o:p></o:p>
        </p>
        <p>
            &gt; the instances have been unmanpped.<o:p></o:p></p>
        
        <p>
            Aha. My test case used an empty string object (ldstr "") to put in the WeakReference, so that probably explains why they stayed around (I checked with perfmon).<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            I'm glad to see you're blogging againg. The reason I'm e-mailing is that I've found a new finalization issue. The attached (verifiable) code creates a subclass of System.Reflection.Assembly (an unsealed type, but the constructor is inaccessible), and proceeds to create an instance of this subclass. This is obviously not a good thing :-)<o:p></o:p></p>
        
        <p>
            This one is easy to fix (the verifier should treat types without an accessible constructor as sealed), but when the constructor is accessible you can still create instances without calling it and I think this is much harder to solve.<o:p></o:p></p>
        
        <p>
            I would like to take this opportunity once again to plead for restricting Finalize to fully trusted code. I know it is a breaking change, but for Whidbey you might be able to get away with it, with every release it will become harder.<o:p></o:p></p>
        
        <p>
            BTW, I think Peter <span>[Redacted]</span> (<span>[Redacted]</span>@microsoft.com) already filed a bug for this (I discovered this while having a private e-mail discussion with him).<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Thanks.<span>&nbsp; </span>I changed your test slightly to avoid the race with the<o:p></o:p></p>
        <p>
            finalizer:<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>IL_000b:<span>&nbsp; </span>call<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>void [mscorlib]System.GC::Collect()<o:p></o:p></p>
        <p>
            Add&gt;&gt;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>call<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>void<o:p></o:p></p>
        <p>
            [mscorlib]System.GC::WaitForPendingFinalizers()<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>IL_0010:<span>&nbsp; </span>ldsfld<span>&nbsp;&nbsp;&nbsp;&nbsp; </span>class ExtendHack ExtendHack::cheat<o:p></o:p></p>
        
        <p>
            I'm guessing that the finalizer was getting scheduled for you ahead of the app's main thread, but for me it wasn't running.<o:p></o:p></p>
        
        <p>
            Clearly we need to fix this bug.<span>&nbsp; </span>But we will also be talking about the larger issue of whether finalization should be revoked from partial trust, and the behavior of partially constructed objects.<o:p></o:p></p>
        
        <p>
            I'll get back to you with the decision.<span>&nbsp; </span>And I really appreciate the heads up here.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            &gt; Thanks.<span>&nbsp; </span>I changed your test slightly to avoid the race with the<o:p></o:p></p>
        <p>
            &gt; finalizer:<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt;<span>&nbsp;&nbsp;&nbsp;&nbsp; </span>IL_000b:<span>&nbsp; </span>call<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>void [mscorlib]System.GC::Collect()<o:p></o:p></p>
        <p>
            &gt; Add&gt;&gt;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>call<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>void<o:p></o:p></p>
        <p>
            &gt; [mscorlib]System.GC::WaitForPendingFinalizers()<o:p></o:p></p>
        <p>
            &gt;<span>&nbsp;&nbsp;&nbsp;&nbsp; </span>IL_0010:<span>&nbsp; </span>ldsfld<span>&nbsp;&nbsp;&nbsp;&nbsp; </span>class ExtendHack ExtendHack::cheat<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; I'm guessing that the finalizer was getting scheduled for you ahead of <o:p></o:p>
        </p>
        <p>
            &gt; the app's main thread, but for me it wasn't running.<o:p></o:p></p>
        
        <p>
            Yeah, I knew I should've put that in. I thought of it as I was editing the IL, but my mind has been made weak by Visual Studio .NET intellisense, and I was too lazy to look up the exact method name ;-)<o:p></o:p></p>
        
        <p>
            &gt; Clearly we need to fix this bug.<span>&nbsp; </span>But we will also be talking about <o:p></o:p>
        </p>
        <p>
            &gt; the larger issue of whether finalization should be revoked from <o:p></o:p>
        </p>
        <p>
            &gt; partial trust, and the behavior of partially constructed objects.<o:p></o:p></p>
        
        <p>
            I think it would also be a good idea to restrict GC.SupressFinalize/ReRegisterForFinalize to fully trusted code.<o:p></o:p></p>
        
        <p>
            Something completely different, but I notice that the GC class has ClearCache event for the Reflection cache, it would be really nice if similar functionality would be available in the public API.<o:p></o:p></p>
        
        <p>
            &gt; I'll get back to you with the decision.<span>&nbsp; </span>And I really appreciate the <o:p></o:p>
        </p>
        <p>
            &gt; heads up here.<o:p></o:p></p>
        
        <p>
            Thanks!<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            Thanks for the blog about finalization. As you probably would have expected, I disagree with you on the need for partially trusted code to have finalizers. I just don't see a compelling scenario. If you really want to enable pooling in this way (IMHO a bad design pattern), add notification to weak references (like Java has). This works much better (although I must admit that I don't see a way to implement this without making GCHandles less efficient).<o:p></o:p></p>
        
        <p>
            Another issue wrt finalization that bothers me is the fact that objects that override Finalize are automatically added to the RegisteredForFinalization queue. For some programming languages/environments it might make sense to make this decision on an instance by instance basis, instead of class based. It would be nice if there was an attribute to mark your type "DontRegisterForFinalize". That way you could call ReRegisterForFinalize only when needed. Of course, this really should have been the default, but its too late for that now ;-) That also would have prevented the JIT bug where it registers an object for finalization that shouldn't have been created yet.<o:p></o:p></p>
        
        
        <p>
            &gt;&gt;However, many other denial of service attacks are possible from partial trust, so this is uninteresting.&lt;&lt;<o:p></o:p></p>
        
        <p>
            While I can appreciate the pragmatism behind this, it still saddens me to read this ;-)<o:p></o:p></p>
        
        <p>
            BTW, any chance I can get a look at the Whidbey changes (I'm on the alpha and under NDA), or will the (rumored soon) next alpha drop contain the new functionality already?<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Yes, I knew you wouldn't be happy about the "finalization from partial trust".<span>&nbsp; </span>But ultimately we should be able to fix the denial of service issues here.<span>&nbsp; </span>In fact, the work was on our Whidbey schedule.<span>&nbsp; </span>Of course, it was eventually punted to a future release.<o:p></o:p></p>
        
        <p>
            Delegates use an internal finalization mechanism that is instance-based.<o:p></o:p></p>
        <p>
            When we marshal a delegate to unmanaged code, we create a thunk for the eventual unmanaged-&gt;managed callbacks.<span>&nbsp; </span>We share these thunks pretty aggressively, and we drop refcounts on them as the marshaled delegates are collected.<span>&nbsp; </span>The vast majority of delegates are never marshaled out in this fashion, so they don't need cleanup side effects.<o:p></o:p></p>
        
        <p>
            I hadn't realized this was a common pattern.<span>&nbsp; </span>What kind of places do you run into this?<span>&nbsp; </span>Suppress/ReRegisterForFinalization gives you some instance-level control.<span>&nbsp; </span>But it clearly expects the common case to be that all instances of a type require finalization.<o:p></o:p></p>
        
        <p>
            As for requiring the program to explicitly ask for finalization during construction, I suspect we would quickly get customer requests for a type-level marker.<span>&nbsp; </span>With all the rules about multiple calls to a finalize method, possibly concurrently with other method calls, any Finalize method must be written in an extremely careful way.<span>&nbsp; </span>If the Finalize method isn't robust in the face of partially constructed or partially destructed objects, it's broken.<span>&nbsp; </span>(Yes, I bet that many of our FX Finalize methods would not pass this test).<span>&nbsp; </span>Personally, I like the guarantee that if the object was even allocated, it will Finalize.<o:p></o:p></p>
        
        <p>
            I would love to send you the missing pieces from the finalization and hosting blogs.<span>&nbsp; </span>Who did you deal with on the NDA?<span>&nbsp; </span>Are you on any of our advisory councils?<span>&nbsp; </span>If you give me a name, I'll follow up over here.<o:p></o:p></p>
        
        <p>
            To be honest, I haven't been paying any attention to the schedule.<span>&nbsp; </span>So although I think we are making an interim build publicly available, I haven't looked to see when it is happening.<span>&nbsp; </span>I should follow up.<span>&nbsp; </span>If it contains the code I was writing about, I won't have to wait for Beta before I can post the missing pieces.<o:p></o:p></p>
        
        <p>
            It's really too bad that you don't want to come work on the CLR.<o:p></o:p></p>
        
        <p>
            Chris<o:p></o:p></p>
        <p>
            <a href="http://blogs.gotdotnet.com/cbrumme">http://blogs.gotdotnet.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi,<o:p></o:p></p>
        
        <p>
            &gt; Yes, I knew you wouldn't be happy about the "finalization from partial <o:p></o:p>
        </p>
        <p>
            &gt; trust".<span>&nbsp; </span>But ultimately we should be able to fix the denial of service <o:p></o:p>
        </p>
        <p>
            &gt; issues here.<span>&nbsp; </span>In fact, the work was on our Whidbey schedule.<o:p></o:p></p>
        <p>
            &gt; Of course, it was eventually punted to a future release.<o:p></o:p></p>
        
        <p>
            I don't mind actually, as long as it gets done for Orcas ;-) I think that DoS prevention willo be much more important for Longhorn.<o:p></o:p></p>
        
        <p>
            &gt; Delegates use an internal finalization mechanism that is <o:p></o:p>
        </p>
        <p>
            &gt; instance-based.<o:p></o:p></p>
        <p>
            [...]<o:p></o:p></p>
        <p>
            &gt; I hadn't realized this was a common pattern.<span>&nbsp; </span>What kind of places do <o:p></o:p>
        </p>
        <p>
            &gt; you run into this?<o:p></o:p></p>
        
        <p>
            It is something that one of the Eiffel developers asked about and I ran into it yesterday when I was working on my object model mapping stuff for IKVM. I rename some methods (Equals -&gt; equals, GetHashCode -&gt; hashCode), this is done based on some XML mapping file, so obviously the code also emitted a Finalize -&gt; finalize rename (i.e. a method named finalize that overrides Finalize and doesn't do anything except call the base class method). Obviously not a good idea (the workaround is, of course, trivial). This sort-of coincided with my previous thinking on finalization (and the bug I mentioned) to form the idea that finalization should be more flexible. So, it's one of those "nice to have" features, but as far as I'm concerned it has no priority whatsoever. I'm sure you get lots of these "it would be really cool if..." requests.<o:p></o:p></p>
        
        <p>
            &gt; Suppress/ReRegisterForFinalization gives you some instance-level <o:p></o:p>
        </p>
        <p>
            &gt; control.<span>&nbsp; </span>But it clearly expects the common case to be that all <o:p></o:p>
        </p>
        <p>
            &gt; instances of a type require finalization.<o:p></o:p></p>
        
        <p>
            Yes, the Eiffel guys tried calling SuppressFinalization in their constructor, but performance was still pretty bad.<o:p></o:p></p>
        
        <p>
            &gt; As for requiring the program to explicitly ask for finalization during <o:p></o:p>
        </p>
        <p>
            &gt; construction, I suspect we would quickly get customer requests for a <o:p></o:p>
        </p>
        <p>
            &gt; type-level marker.<o:p></o:p></p>
        
        <p>
            Yeah, I thought it would be solvable in the compiler, but now I realise that because object allocation/constructor invocation is a single instruction you cannot do that.<o:p></o:p></p>
        
        <p>
            &gt; If the Finalize method isn't robust in the face of partially <o:p></o:p>
        </p>
        <p>
            &gt; constructed or partially destructed objects, it's broken.<o:p></o:p></p>
        
        <p>
            I agree and that certainly wasn't my motivation for the feature.<o:p></o:p></p>
        
        <p>
            &gt; Personally, I like the<o:p></o:p></p>
        <p>
            &gt; guarantee that if the object was even allocated, it will Finalize.<o:p></o:p></p>
        
        <p>
            Well, there is the downside that it makes the whole base constructor invocation verification (almost) useless. This is also where the instance based finalization would be helpful, you could override Finalize with an empty method and make it final to prevent subclasses from obtaining uninitialized instances.<o:p></o:p></p>
        
        <p>
            &gt; I would love to send you the missing pieces from the finalization and <o:p></o:p>
        </p>
        <p>
            &gt; hosting blogs.<span>&nbsp; </span>Who did you deal with on the NDA?<o:p></o:p></p>
        
        <p>
            Barbara <span>[Redacted]</span> handled the NDA. BTW, I haven't read the hosting blog yet, I hope to do that tonight.<o:p></o:p></p>
        
        <p>
            &gt; Are you on any of our advisory councils?<o:p></o:p></p>
        
        <p>
            No, never been asked.<o:p></o:p></p>
        
        <p>
            &gt; To be honest, I haven't been paying any attention to the schedule.<span>&nbsp; </span>So <o:p></o:p>
        </p>
        <p>
            &gt; although I think we are making an interim build publicly available, I <o:p></o:p>
        </p>
        <p>
            &gt; haven't looked to see when it is happening.<span>&nbsp; </span>I should follow up.<span>&nbsp; </span>If <o:p></o:p>
        </p>
        <p>
            &gt; it contains the code I was writing about, I won't have to wait for <o:p></o:p>
        </p>
        <p>
            &gt; Beta before I can post the missing pieces.<o:p></o:p></p>
        
        <p>
            I don't know, but it might be that the next alpha (if there is one) will not be made public. We got the current version in July and weren't allowed to talk about them until the PDC.<o:p></o:p></p>
        
        <p>
            &gt; It's really too bad that you don't want to come work on the CLR.<o:p></o:p></p>
        
        <p>
            If you get clearance to send me the design documents, I'd love to give my feedback.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi,<o:p></o:p></p>
        
        <p>
            I just realized that my reference to the JIT bug in my last mail probably didn't make any sense to you. The bug I was talking about was not the verifier bug I reported earlier, but a bug in the JIT I discovered a while ago: <a href="http://weblog.ikvm.net/CommentView.aspx?guid=b199682c-6546-46fd-bead-bc355c4fc21f">http://weblog.ikvm.net/CommentView.aspx?guid=b199682c-6546-46fd-bead-bc355c4fc21f</a><o:p></o:p></p>
        
        <p>
            Summary: When you do new "Foo(GetConstructorArgs())", the JIT allocates the object before calling GetConstructorArgs and that has the side effect of running finalization on an object that shouldn't have been allocated yet (if GetConstructorArgs throws an exception).<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
        <p>
            P.S. Any news on the NDA?<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Thanks.<span>&nbsp; </span>I hadn't seen this case.<span>&nbsp; </span>I see Peter already logged the bug.<o:p></o:p></p>
        
        <p>
            I hadn't heard back from Barbara yet, so I just pinged her in email again.<span>&nbsp; </span>I'll try phoning her later today if I don't get a reply in email.<o:p></o:p></p>
        
        <p>
            Chris<o:p></o:p></p>
        <p>
            <a href="http://blogs.gotdotnet.com/cbrumme">http://blogs.gotdotnet.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            I've added a bunch of legalese to remind you of your NDA.<span>&nbsp; </span>Hopefully I did it correctly.<span>&nbsp; </span>Obviously you shouldn't show these docs to anyone.<o:p></o:p></p>
        <p>
            And when I post the updated blogs upon disclosure, I would recommend throwing away these attached copies.<o:p></o:p></p>
        
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi,<o:p></o:p></p>
        
        <p>
            &gt; I've added a bunch of legalese to remind you of your NDA.<span>&nbsp; </span>Hopefully I <o:p></o:p>
        </p>
        <p>
            &gt; did it correctly.<span>&nbsp; </span>Obviously you shouldn't show these docs to anyone.<o:p></o:p></p>
        <p>
            &gt; And when I post the updated blogs upon disclosure, I would recommend <o:p></o:p>
        </p>
        <p>
            &gt; throwing away these attached copies.<o:p></o:p></p>
        
        <p>
            Thanks, I won't and I will, respectively.<o:p></o:p></p>
        
        <p>
            BTW, some of this stuff is already public (although somewhat vague):<o:p></o:p></p>
        <p>
            <a href="http://longhorn.msdn.microsoft.com/lhsdk/ref/ns/system.runtime.interopservices/c/safehandle/safehandle.aspx">http://longhorn.msdn.microsoft.com/lhsdk/ref/ns/system.runtime.interopservices/c/safehandle/safehandle.aspx</a><o:p></o:p></p>
        
        <p>
            After reading it through (but not letting it sink in yet), my first thought is that I like it. Of course, I also have a few (contradictory) questions:<o:p></o:p></p>
        <p>
            1) Why was <abbr title="CriticalFinalizer">CF</abbr> generalized? Why is SafeHandle not enough?<o:p></o:p></p>
        <p>
            2) Why is <abbr title="CriticalFinalizerObject">CFO</abbr> a base class and not an attribute?<o:p></o:p></p>
        <p>
            3) Wouldn't it be a good idea to require CFO derived classes to be sealed?<o:p></o:p></p>
        
        <p>
            &gt;&gt;This means that a buffer flush can precede the close of the underlying <o:p></o:p>
        </p>
        <p>
            &gt;&gt;handle.&lt;&lt;<o:p></o:p></p>
        
        <p>
            IHMO promoting this idea is bad. Depending on finalizers to flush buffers will still cause hard to find bugs. Sure the typical case is solved with CF, but what about layered streams (e.g. a block encryption stream on top of a buffering stream). Or user defined finalizers?<o:p></o:p></p>
        <p>
            This reminds me of another use for instance finalizers, when you put assertions in your finalizers (e.g. assert that the buffer is empty, instead of flushing it automatically), it would be nice if that was something that could be enabled with a switch (somewhat like a customer debug probe).<o:p></o:p></p>
        
        <p>
            &gt;&gt;This would be an intolerable situation for a Security feature, but <o:p></o:p>
        </p>
        <p>
            &gt;&gt;it’s perfectly acceptable when we’re just trying to increase the <o:p></o:p>
        </p>
        <p>
            &gt;&gt;scalability and reliability of naively written database <o:p></o:p>
        </p>
        <p>
            &gt;&gt;applications.&lt;&lt;<o:p></o:p></p>
        
        <p>
            I'm a bit worried that someone, somewhere will at some point in the future rely <abbr title="Host Protection Attribute">HPA</abbr> for security.<o:p></o:p></p>
        
        <p>
            &gt;&gt;In Whidbey, it is possible to avoid inducing asynchronous Aborts onto <o:p></o:p>
        </p>
        <p>
            &gt;&gt;threads that are performing backout (i.e. filter, finally, catch or <o:p></o:p>
        </p>
        <p>
            &gt;&gt;fault blocks) or that hold locks.&lt;&lt;<o:p></o:p></p>
        
        <p>
            I assume you mean that on Whidbey the runtime will never introduce asynchronous Aborts into threads that are performing backout or holding locks, but the quoted text isn't entirely clear to me.<o:p></o:p></p>
        
        <p>
            I'll probably have more to say when I've thought about it a bit more.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            &gt;&gt; Why was CF generalized? Why is SafeHandle not enough?<o:p></o:p></p>
        
        <p>
            The System.Data folks have lighter-weight resources that aren’t handle-based, like buffers with offsets.<span>&nbsp; </span>For these resources, they still want guaranteed cleanup, reduced graph promotion, GC.KeepAlive behavior and enforcement of the above based on the type system.<span>&nbsp; </span>But they don’t need the cost of preventing handle recycling, because they don’t expose these handles out directly to the app.<span>&nbsp; </span>Since the app cannot control their lifetime directly, there are no risks so it isn’t worth paying the price of interlocking on each call.<o:p></o:p></p>
        
        <p>
            &gt;&gt; Why is CFO a base class and not an attribute?<o:p></o:p></p>
        
        <p>
            If it was an attribute, you would add it to some existing class.<span>&nbsp; </span>Then we won’t get the benefits of reduced graph promotion.<o:p></o:p></p>
        
        <p>
            &gt;&gt; Wouldn't it be a good idea to require CFO derived classes to be<o:p></o:p></p>
        
        <p>
            &gt;&gt; sealed?<o:p></o:p></p>
        
        <p>
            Each subtype needs to judge this for itself.<span>&nbsp; </span>But yes, in general that makes sense.<span>&nbsp; </span>Note that you must be trusted to subtype one of these types (transitively) so some of the usual concerns about unsealed types don’t apply here.<o:p></o:p></p>
        
        <p>
            &gt;&gt; IHMO promoting this idea is bad. Depending on finalizers to<o:p></o:p></p>
        
        <p>
            &gt;&gt; flush buffers will still cause hard to find bugs.<o:p></o:p></p>
        
        <p>
            I think everyone agrees with you.<span>&nbsp; </span>The issue was that our critical finalizer code actually made the problem worse than it used to be.<span>&nbsp; </span>We don’t want you creating references between the file and the stream instances and we don’t want the finalizable objects pointing at anything, because of graph promotion.<span>&nbsp; </span>So we added this tweak just so we wouldn’t cause regressions.<o:p></o:p></p>
        
        <p>
            &gt;&gt; I'm a bit worried that someone, somewhere will at some point in<o:p></o:p></p>
        
        <p>
            &gt;&gt; the future rely HPA for security.<o:p></o:p></p>
        
        <p>
            This is a big concern.<span>&nbsp; </span>Even within the company we’ve had a lot of confusion on this point.<o:p></o:p></p>
        
        <p>
            &gt;&gt; I assume you mean that on Whidbey the runtime will never<o:p></o:p></p>
        
        <p>
            &gt;&gt; introduce asynchronous Aborts into threads that are performing<o:p></o:p></p>
        
        <p>
            &gt;&gt; backout or holding locks, but the quoted text isn't entirely<o:p></o:p></p>
        
        <p>
            &gt;&gt; clear to me.<o:p></o:p></p>
        
        <p>
            I wish I had said that.<span>&nbsp; </span>It would be a reasonable position for us to take, but it would be a breaking change.<span>&nbsp; </span>Instead, we give you ways to abort nicely.<span>&nbsp; </span>And we may add a Customer Debug Probe for the legacy case, so the dev understands the risk of what he is doing.<o:p></o:p></p>
        
        <p>
            This is one of those nasty places where we are trading off long term correctness of the platform against the short term costs of breaking application compatibility.<span>&nbsp; </span>It’s still being debated.<o:p></o:p></p>
        
        
        <p>
            Chris.<o:p></o:p></p>
        
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi,<o:p></o:p></p>
        
        <p>
            Thanks for the explanations!<o:p></o:p></p>
        
        <p>
            &gt; &gt;&gt; Why was CF generalized? Why is SafeHandle not enough?<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; The System.Data folks have lighter-weight resources that aren’t <o:p></o:p>
        </p>
        <p>
            &gt; handle-based, like buffers with offsets.<o:p></o:p></p>
        
        <p>
            Ah I see. i had forgotten about those (not the System.Data specific ones, I didn't know about them, but the general idea of unmanaged memory buffers). I actually spent quite a bit of time thinking about this (in relation to memory mapped files, a tricky problem in a managed environment), so I should have remembered that.<o:p></o:p></p>
        
        <p>
            &gt; &gt;&gt; Why is CFO a base class and not an attribute?<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; If it was an attribute, you would add it to some existing class.<span>&nbsp; </span>Then <o:p></o:p>
        </p>
        <p>
            &gt; we won’t get the benefits of reduced graph promotion.<o:p></o:p></p>
        
        <p>
            You can apply the same reasoning to subclassing. Arguably, a subclasser is more likely not to notice the parentage of its parent than someone deliberatly applying the attribute. How about the following ideas? If an attribute is used, all subclasses should also have the attribute (not as a security precaution, but to make sure the developer of the subclass is aware of the issues). Or, in the CFO base class scheme, you could only allow subclassing in the same assembly (or "friend" assemblies).<o:p></o:p></p>
        
        <p>
            I know that you shouldn't have outward facing CF classes, but I'm sure there'll be third party libraries doing the wrong thing and it would be good to try to minimize the opportunity for that.<o:p></o:p></p>
        
        <p>
            &gt; &gt;&gt; Wouldn't it be a good idea to require CFO derived classes to be <o:p></o:p>
        </p>
        <p>
            &gt; &gt;&gt; sealed?<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; Each subtype needs to judge this for itself.<span>&nbsp; </span>But yes, in general that <o:p></o:p>
        </p>
        <p>
            &gt; makes sense.<span>&nbsp; </span>Note that you must be trusted to subtype one of these <o:p></o:p>
        </p>
        <p>
            &gt; types (transitively) so some of the usual concerns about unsealed <o:p></o:p>
        </p>
        <p>
            &gt; types don’t apply here.<o:p></o:p></p>
        
        <p>
            I fear that most people will still be developing full-trust-only code in the Whidbey "timeframe" (to use MS speak ;-)), so while not a security issue, it'll be good to guide people in the right direction.<o:p></o:p></p>
        
        <p>
            &gt; &gt;&gt; IHMO promoting this idea is bad. Depending on finalizers to flush <o:p></o:p>
        </p>
        <p>
            &gt; &gt;&gt; buffers will still cause hard to find bugs.<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; I think everyone agrees with you.<span>&nbsp; </span>The issue was that our critical <o:p></o:p>
        </p>
        <p>
            &gt; finalizer code actually made the problem worse than it used to be.<span>&nbsp; </span>We <o:p></o:p>
        </p>
        <p>
            &gt; don’t want you creating references between the file and the stream <o:p></o:p>
        </p>
        <p>
            &gt; instances and we don’t want the finalizable objects pointing at <o:p></o:p>
        </p>
        <p>
            &gt; anything, because of graph promotion.<span>&nbsp; </span>So we added this tweak just so <o:p></o:p>
        </p>
        <p>
            &gt; we wouldn’t cause regressions.<o:p></o:p></p>
        
        <p>
            OK, I see what you're saying now. Basically you are just giving an example of a potential regression that would have been created if you didn't have the ordering rule (which makes *perfect* sense BTW). If I may make a suggestion, it would be great if you added a little clarification to the text that explains why it is still a bad idea to depend on this.<o:p></o:p></p>
        
        <p>
            &gt; &gt;&gt; I'm a bit worried that someone, somewhere will at some point in the <o:p></o:p>
        </p>
        <p>
            &gt; &gt;&gt; future rely HPA for security.<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; This is a big concern.<span>&nbsp; </span>Even within the company we’ve had a lot of <o:p></o:p>
        </p>
        <p>
            &gt; confusion on this point.<o:p></o:p></p>
        
        <p>
            The name of the attribute and the fact that it is a CAS attribute doesn't help. It's probably too late, but have you considered renaming it to something like HostScalabilityAdviceAttribute (or whatever)?<o:p></o:p></p>
        
        <p>
            &gt; &gt;&gt; I assume you mean that on Whidbey the runtime will never introduce <o:p></o:p>
        </p>
        <p>
            &gt; &gt;&gt; asynchronous Aborts into threads that are performing backout or <o:p></o:p>
        </p>
        <p>
            &gt; &gt;&gt; holding locks, but the quoted text isn't entirely clear to me.<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; I wish I had said that.<span>&nbsp; </span>It would be a reasonable position for us to <o:p></o:p>
        </p>
        <p>
            &gt; take, but it would be a breaking change.<span>&nbsp; </span>Instead, we give you ways to <o:p></o:p>
        </p>
        <p>
            &gt; abort nicely.<o:p></o:p></p>
        
        <p>
            I see. So presumably there'll be a new method Thread.SafeAbort().<o:p></o:p></p>
        
        <p>
            &gt; This is one of those nasty places where we are trading off long term <o:p></o:p>
        </p>
        <p>
            &gt; correctness of the platform against the short term costs of breaking <o:p></o:p>
        </p>
        <p>
            &gt; application compatibility.<span>&nbsp; </span>It’s still being debated.<o:p></o:p></p>
        
        <p>
            I know it's not a democracy, but I'll cast my vote anyway ;-) I'd like to see the existing Abort method fixed (funnily enough, in both senses of the word, "corrected" and like having your dog fixed).<o:p></o:p></p>
        
        <p>
            As an aside, I got a notice today on the subclassing by finalization bug, saying that it didn't work in partial trust (verification exception), so I'm glad to see it has been fixed :-)<o:p></o:p></p>
        
        <p>
            As another aside, I know it is not your area, but there are two unnecessary restrictions in the spec that I'd like to see fixed. I'd ask <span>[Redacted]</span> but at the PDC I got the impression he doesn't like me very much (no idea why, maybe it's just in my head). Anyway, the CLI spec says that all interfaces members must be public, this is a bogus rule for static members, in particular for .cctor. A second point is that the spec disallows nested types in interfaces, this restriction also doesn't make much sense (and, in fact, the CLR doesn't enforce it).<o:p></o:p></p>
        <p>
            The relevant references are:<o:p></o:p></p>
        
        <p>
            Partition I, Working Draft 2.2, June 2003, section 8.5.3.2:<o:p></o:p></p>
        <p>
            "1. Members defined by an interface shall be public."<o:p></o:p></p>
        
        <p>
            Partition II, Working Draft 2.2, June 2003, section 9.6:<o:p></o:p></p>
        <p>
            "Interfaces may be nested inside of classes and value types, but classes and value types shall not be nested inside of interfaces." <o:p></o:p>
        </p>
        
        <p>
            If you agree that these restrictions are pointless, maybe you could forward it to the appropriate person. However, as usual, feel free to ignore me. I won't hold it against you.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi,<o:p></o:p></p>
        
        <p>
            I ran across an interesting bug (I think). When the main thread ends, I think its thread local storage stays alive. I assume this is because the main thread actually stays around to manage the CLR life cycle. See the attached repro.<o:p></o:p></p>
        
        <p>
            I ran into this when I was trying to hack my own thread death event, by using finalization of a TLS object as the event trigger. Really lame, but I couldn't think of anything better.<o:p></o:p></p>
        
        <p>
            BTW, the Longhorn command line shell preview released a new Whidbey build (2.0.31113) that includes the CriticalFinalizerObject. I installed it, but haven't played with it much, but I intend to.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Your ECMA suggestions are now on our internal list.<span>&nbsp; </span>Obviously I cannot speak to whether the external ECMA committee will accept them, since it is made up of representatives from many companies.<span>&nbsp; </span>However, they seem non-controversial and I would guess that they will pass.<o:p></o:p></p>
        
        <p>
            As for feeling that <span>[Redacted]</span> didn't like you, I would not read anything into that.<span>&nbsp; </span>I'm sure you just caught him at a bad time.<span>&nbsp; </span>Many of us on the team have been through similar circumstances with him, when we caught him at a bad time.<o:p></o:p></p>
        
        <p>
            If it's not obvious, there are a bunch of people on the CLR team who know who you are, what you do, and hope that one day you might consider joining the team.<span>&nbsp; </span>(I realize that this isn't in the cards right now, but we're all in this for the long term).<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi,<o:p></o:p></p>
        
        <p>
            &gt; Your ECMA suggestions are now on our internal list.<span>&nbsp; </span><o:p></o:p>
        </p>
        
        <p>
            Thanks!<o:p></o:p></p>
        
        <p>
            &gt; If it's not obvious, there are a bunch of people on the CLR team who <o:p></o:p>
        </p>
        <p>
            &gt; know who you are, what you do, and hope that one day you might <o:p></o:p>
        </p>
        <p>
            &gt; consider joining the team.<span>&nbsp; </span>(I realize that this isn't in the cards <o:p></o:p>
        </p>
        <p>
            &gt; right now, but we're all in this for the long term).<o:p></o:p></p>
        
        <p>
            Thanks. If I ever go looking for another job, the CLR team would definitely be at the top of my list :-)<o:p></o:p></p>
        
        <p>
            BTW, The "Visual Studio 2005 Community Technology Preview" was given out at VSLive, so I think you can update your blog entries now.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            I finally posted the updates.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hello Chris,<o:p></o:p></p>
        
        <p>
            I just noticed that in beta 1 the verifier complains about interchanging references from a System.Byte[] with a System.SByte[]. According to the 1.0 CLI spec this was allowed and I use this feature in IKVM to make interoperating with Java's signed byte arrays easier with the CLS unsigned byte arrays.<o:p></o:p></p>
        
        <p>
            Is this an intentional change and is the CLI spec going to be updated?<o:p></o:p></p>
        
        <p>
            I actually think this is a good change, when I originally discovered that the verifier allowed mixing the two I complained about it (but then I also started using it ;-)).<o:p></o:p></p>
        
        <p>
            BTW, what's the deal with the co-/contravariant generic type parameters? Yesterday I found out that it is already working (<a href="http://weblog.ikvm.net/CommentView.aspx?guid=21f9ed86-827e-4666-9553-5d4a8d735b7e">http://weblog.ikvm.net/</a>), but there appears to be absolutely no documentation. Has it not yet been decided whether that feature will make it into the final release?<o:p></o:p></p>
        
        <p>
            Thanks.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            I'll check into the Byte[]/SByte[] change and get back to you.<span>&nbsp; </span>I will be surprised if the change was intentional.<o:p></o:p></p>
        
        <p>
            The co-/contravariant generic type parameters are definitely going to be in the final release.<span>&nbsp; </span>However, none of the MS languages except ILASM have any support for them.<span>&nbsp; </span>So you aren't going to see them used in WinFX either.<o:p></o:p></p>
        
        <p>
            I assume that Eiffel uses them, but haven't checked.<o:p></o:p></p>
        
        <p>
            I'm personally nervous whenever we have a feature for which we have no internal consumers.<span>&nbsp; </span>In the past, we've discovered security or functionality holes when we've done this.<o:p></o:p></p>
        
        <p>
            It doesn't look like you need documentation for this feature... you've already figured out exactly how it works.<span>&nbsp; </span>I'm told that it was documented for the ECMA submission on generics.<span>&nbsp; </span>But I'll also mention it as a doc hole to UE.<o:p></o:p></p>
        
        <p>
            I saw further down your blog that we don't properly inject assemblies into all the AppDomains that use them, when the assemblies are being shared.<span>&nbsp; </span>A lot of work went into fixing that one for Whidbey.<span>&nbsp; </span>But, as far as I know, you are the only person who actually noticed the old broken behavior.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Oops.<span>&nbsp; </span>I forgot to say something friendly like:<o:p></o:p></p>
        
        <p>
            I hope everything is going well for you and that you are enjoying the summer.<span>&nbsp; </span>It's great to see Whidbey now on a solid path to shipping.<o:p></o:p></p>
        <p>
            Obviously we are still some distance from saying the same thing about Orcas.<span>&nbsp; </span>I'll be interested in hearing your views on Whidbey generally.<o:p></o:p></p>
        <p>
            From over here, it feels like we put a ton of effort and features into it.<span>&nbsp; </span>But the customer is always right and so I'm curious to know if we left out some important stuff that's going to cause pain out there.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        
        <p>
            &gt; I'll check into the Byte[]/SByte[] change and get back to you.<span>&nbsp; </span>I will <o:p></o:p>
        </p>
        <p>
            &gt; be surprised if the change was intentional.<o:p></o:p></p>
        
        <p>
            Thanks.<o:p></o:p></p>
        
        <p>
            &gt; The co-/contravariant generic type parameters are definitely going to <o:p></o:p>
        </p>
        <p>
            &gt; be in the final release.<span>&nbsp; </span>However, none of the MS languages except <o:p></o:p>
        </p>
        <p>
            &gt; ILASM have any support for them.<span>&nbsp; </span>So you aren't going to see them used <o:p></o:p>
        </p>
        <p>
            &gt; in WinFX either.<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; I assume that Eiffel uses them, but haven't checked.<o:p></o:p></p>
        
        <p>
            That's what I assumed too. I only discoverd them through the System.GenericParameterAttributes enum. I then had to twiddle with the bits of an assembly and use ILDASM to figure out the syntax ;-)<o:p></o:p></p>
        
        <p>
            &gt; I'm personally nervous whenever we have a feature for which we have no <o:p></o:p>
        </p>
        <p>
            &gt; internal consumers.<span>&nbsp; </span>In the past, we've discovered security or <o:p></o:p>
        </p>
        <p>
            &gt; functionality holes when we've done this.<o:p></o:p></p>
        
        <p>
            I know exactly what you mean. This seems like a relatively straight forward feature though.<o:p></o:p></p>
        
        <p>
            &gt; It doesn't look like you need documentation for this feature... you've <o:p></o:p>
        </p>
        <p>
            &gt; already figured out exactly how it works.<span>&nbsp; </span>I'm told that it was <o:p></o:p>
        </p>
        <p>
            &gt; documented for the ECMA submission on generics.<span>&nbsp; </span>But I'll also mention <o:p></o:p>
        </p>
        <p>
            &gt; it as a doc hole to UE.<o:p></o:p></p>
        
        <p>
            I don't think the ECMA submissions are public yet. I'd love to be proven wrong though.<o:p></o:p></p>
        
        <p>
            &gt; I saw further down your blog that we don't properly inject assemblies <o:p></o:p>
        </p>
        <p>
            &gt; into all the AppDomains that use them, when the assemblies are being <o:p></o:p>
        </p>
        <p>
            &gt; shared.<span>&nbsp; </span>A lot of work went into fixing that one for Whidbey.<span>&nbsp; </span>But, as <o:p></o:p>
        </p>
        <p>
            &gt; far as I know, you are the only person who actually noticed the old <o:p></o:p>
        </p>
        <p>
            &gt; broken behavior.<o:p></o:p></p>
        
        <p>
            Yeah, that was a very strange and tricky bug to find (I didn't actually discover it, a user of IKVM discovered it and I had to repro it based on a vague description of the problem).<o:p></o:p></p>
        
        <p>
            &gt; Oops.<span>&nbsp; </span>I forgot to say something friendly like:<o:p></o:p></p>
        
        <p>
            :-)<o:p></o:p></p>
        
        <p>
            &gt; I hope everything is going well for you and that you are enjoying the <o:p></o:p>
        </p>
        <p>
            &gt; summer.<o:p></o:p></p>
        
        <p>
            We just had a heat wave (5 days above 25 degrees C, three of which above 30 deg C). That wasn't very pleasant, fortunately it is a bit cooler now. We don't generally have AC here (except in cars). I hope you're having nice summer like last year when I was there for the Whidbey SDR.<o:p></o:p></p>
        
        <p>
            &gt; It's great to see Whidbey now on a solid path to shipping.<o:p></o:p></p>
        
        <p>
            Definitely. Beta 1 looks very good.<o:p></o:p></p>
        
        <p>
            &gt; Obviously we are still some distance from saying the same thing about <o:p></o:p>
        </p>
        <p>
            &gt; Orcas.<o:p></o:p></p>
        
        <p>
            If there is going to be a SDR (or even something earlier than that), I'd definitely be interested.<o:p></o:p></p>
        
        <p>
            &gt; I'll be interested in hearing your views on Whidbey generally.<o:p></o:p></p>
        <p>
            &gt; From over here, it feels like we put a ton of effort and features into <o:p></o:p>
        </p>
        <p>
            &gt; it.<span>&nbsp; </span>But the customer is always right and so I'm curious to know if we <o:p></o:p>
        </p>
        <p>
            &gt; left out some important stuff that's going to cause pain out there.<o:p></o:p></p>
        
        <p>
            In general I'm very happy. For IKVM I would have liked to have seen some more improvements to Reflection (and Reflection.Emit).<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi,<o:p></o:p></p>
        
        <p>
            &gt; I'll check into the Byte[]/SByte[] change and get back to you.<span>&nbsp; </span>I will <o:p></o:p>
        </p>
        <p>
            &gt; be surprised if the change was intentional.<o:p></o:p></p>
        
        <p>
            Any news?<o:p></o:p></p>
        
        <p>
            Also, I ran across a Whidbey regression relating to type names with double backslashes in them in Reflection.Emit scenarios. I haven't been able to build a concise repro, but beforing spending a lot of time on it I wanted to check with you if it might be a known issue already.<o:p></o:p></p>
        
        <p>
            So far I see two, probably related, issues:<o:p></o:p></p>
        
        <p>
            AssemblyName name = new AssemblyName();<o:p></o:p></p>
        <p>
            name.Name = "test";<o:p></o:p></p>
        <p>
            AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run); ModuleBuilder mod = ab.DefineDynamicModule("test"); TypeBuilder tb = mod.DefineType(@"foo\\1"); Console.WriteLine(tb.FullName); Console.WriteLine(tb.CreateType().FullName);<o:p></o:p></p>
        
        <p>
            The above code prints out:<o:p></o:p></p>
        <p>
            foo\\1<o:p></o:p></p>
        <p>
            foo\\\\1<o:p></o:p></p>
        
        <p>
            The other problem is that in a larger program I get a System.Runtime.InteropServices.COMException: Exception from HRESULT: 0x80131130. This is also caused by blackslashes in the type name (I use blackslashes to mangle names that would otherwise clash), because the problem goes away if I use a forward slash in the name mangling. I tried to build a small repro, but so far I couldn't get that to fail.<o:p></o:p></p>
        
        <p>
            Thanks.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            I hadn't heard any resolution from the verifier dev yet, so I just ping'ed him again.<span>&nbsp; </span>Given the ECMA rules, I think we'll have no choice but to fix this.<o:p></o:p></p>
        
        <p>
            Thanks for the repro on the emit problem.<span>&nbsp; </span>I'll send this to the reflection emit dev.<span>&nbsp; </span>Given that we have a customer app that has been broken, this is likely something we want to / have to fix, also.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            For the Byte[]/SByte[] problem, I see where the code got broken when we tightened up the rules for generics.<span>&nbsp; </span>I filed a bug and we'll get it fixed.<o:p></o:p></p>
        
        <p>
            For the \\ change, the dev cleaned up the grammar for type names and inadvertently broke this.<span>&nbsp; </span>Given that we broke a customer's app, he is now trying to achieve his cleanup in a non-breaking way.<span>&nbsp; </span>So we're going to try to fix this one, but I could imagine he might get stuck.<span>&nbsp; </span>If that happens, I'll get back to you.<span>&nbsp; </span>Otherwise you should assume that we will fix it.<o:p></o:p></p>
        
        <p>
            Thanks for pointing out these bugs.<o:p></o:p></p>
        
        <p>
            Chris<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi,<o:p></o:p></p>
        
        <p>
            Since the e-mail exchange with Chris <span>[Redacted]</span> wasn't very productive, I spent a little time to repro the COMException I was getting.<o:p></o:p></p>
        
        <p>
            The attached program works on <abbr title="Codename for .NET Framework 1.1">Everett</abbr>, but throws on Whidbey.<o:p></o:p></p>
        
        <p>
            This is clearly related to the backslash in the type name (if you remove that, it works on both Everett and Whidbey).<o:p></o:p></p>
        
        <p>
            BTW, was it my lack of clarity in my mails to Chris <span>[Redacted]</span>, or did you understand my proposed solution, or did I totally miss the point?<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            I apologize for taking so long to respond.<span>&nbsp; </span>Something came up on this end.<o:p></o:p></p>
        
        <p>
            I gave your program to Chris <span>[Redacted]</span>, without any of your below email.<o:p></o:p></p>
        
        <p>
            It was not your lack of clarity.<span>&nbsp; </span>There are two people on reflection, and one of them recently <span><span>[personal information removed].</span>&nbsp; </span>He hasn't been back in the office yet.<o:p></o:p></p>
        
        <p>
            I'm sure the bug will get resolved properly when he's back in the office, if Chris doesn't get to it before then.<o:p></o:p></p>
        
        <p>
            Chris<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi, <o:p></o:p>
        </p>
        
        <p>
            &gt; I apologize for taking so long to respond.<span>&nbsp; </span>Something came up on this <o:p></o:p>
        </p>
        <p>
            &gt; end.<o:p></o:p></p>
        
        <p>
            No problem.<o:p></o:p></p>
        
        <p>
            &gt; It was not your lack of clarity.<span>&nbsp; </span>There are two people on reflection, <o:p></o:p>
        </p>
        <p>
            &gt; and one of them recently <span>[personal information removed]</span><o:p></o:p>
        </p>
        <p>
            &gt; He hasn't been back in the office yet.<o:p></o:p></p>
        
        <p>
            Do you mean <span>[Redacted]</span>? I hope he's doing alright.<o:p></o:p></p>
        
        <p>
            &gt; I'm sure the bug will get resolved properly when he's back in the <o:p></o:p>
        </p>
        <p>
            &gt; office, if Chris doesn't get to it before then.<o:p></o:p></p>
        
        <p>
            Thanks.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            <span>[Personal information removed]</span></p>
        
        <p>
            He sent some email saying he would be in the office later this week.<o:p></o:p></p>
        <p>
            We'll see.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            Sorry to bother you with this, but this is something that worries me:<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/grantri/archive/2004/09/07/226355.aspx">http://blogs.msdn.com/grantri/archive/2004/09/07/226355.aspx</a><o:p></o:p></p>
        
        <p>
            Either [my understanding of] the CLI spec is seriously broken or I'm not going to be running any mission critical code on my AMD64 machine...<o:p></o:p></p>
        
        <p>
            Thanks.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            You are certainly not bothering me.<o:p></o:p></p>
        
        <p>
            I was unaware of the blog, but I'm quite aware of the issue.<span>&nbsp; </span>I had several meetings on this particular bug and I recently found a much more compelling and wide-spread example where this optimization can bite us (thread-safe event firing, where we deliberately use a local to avoid issues with asynchronous RemoveOn callers).<o:p></o:p></p>
        
        <p>
            My current plan is to get some DCRs approved in time for Beta2 (officially I'm already too late), which would condition these JIT64 optimizations on the presence of a CompilationRelaxationsAttribute.<span>&nbsp; </span>I'm hoping that we can get the .NET frameworks cleaned up enough to safely add this attribute to our own assemblies, but your code would have to opt-in to this aggressive optimization.<span>&nbsp; </span>So user assemblies will run correctly between X86 &amp; AMD64, by default.<o:p></o:p></p>
        
        <p>
            I should stress that this is my plan, rather than the plan of record -- especially given the usual resource constraints.<span>&nbsp; </span>But I talked to several people about it over the last week and there seems to be enough support for it.<o:p></o:p></p>
        
        <p>
            Public blogs are definitely a two-edged sword.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            &gt; You are certainly not bothering me.<o:p></o:p></p>
        
        <p>
            Well if I am, don't hesitate to say so.<o:p></o:p></p>
        
        <p>
            &gt; I was unaware of the blog, but I'm quite aware of the issue.<span>&nbsp; </span>I had <o:p></o:p>
        </p>
        <p>
            &gt; several meetings on this particular bug and I recently found a much <o:p></o:p>
        </p>
        <p>
            &gt; more compelling and wide-spread example where this optimization can <o:p></o:p>
        </p>
        <p>
            &gt; bite us (thread-safe event firing, where we deliberately use a local <o:p></o:p>
        </p>
        <p>
            &gt; to avoid issues with asynchronous RemoveOn callers).<o:p></o:p></p>
        
        <p>
            So the optimization is indeed allowed per the spec? That surprises me quite a bit. Programming is looking more and more like quantum physics :-) A local variable can contain a superposition of multiple values...<o:p></o:p></p>
        
        <p>
            &gt; My current plan is to get some DCRs approved in time for Beta2 <o:p></o:p>
        </p>
        <p>
            &gt; (officially I'm already too late), which would condition these JIT64 <o:p></o:p>
        </p>
        <p>
            &gt; optimizations on the presence of a CompilationRelaxationsAttribute.<span>&nbsp; </span><o:p></o:p>
        </p>
        <p>
            &gt; I'm hoping that we can get the .NET frameworks cleaned up enough to <o:p></o:p>
        </p>
        <p>
            &gt; safely add this attribute to our own assemblies, but your code would <o:p></o:p>
        </p>
        <p>
            &gt; have to opt-in to this aggressive optimization.<span>&nbsp; </span>So user assemblies <o:p></o:p>
        </p>
        <p>
            &gt; will run correctly between X86 &amp; AMD64, by default.<o:p></o:p></p>
        
        <p>
            Is this optimization really that significant that it is worth all this trouble? I honestly don't see anyone adding this attribute to their code (and of the people that would add it, some (most?) probably don't understand the consequences).<o:p></o:p></p>
        
        <p>
            In any case, the CLI spec should definitely be clarified that this type of optimization is allowed. I'm still trying to find language in the spec that prohibits this optimization :-)<o:p></o:p></p>
        
        <p>
            How about this:<o:p></o:p></p>
        <p>
            "Values are stored in locations. A location can hold only one value at a time. All locations are typed. The type of the location embodies the requirements that shall be met by values that are stored in the location. Examples of locations are local variables and parameters. "<o:p></o:p></p>
        
        <p>
            Interesting thought: A "secure" method must do a volatile read before doing any parameter validation, otherwise the value of the parameter might change after the validation (if the method is inlined and this optimization happens).<o:p></o:p></p>
        
        <p>
            &gt; Public blogs are definitely a two-edged sword.<o:p></o:p></p>
        
        <p>
            :-) I hope you get time to post to your blog soon.<o:p></o:p></p>
        
        <p>
            Another thing that I recently ran into: What's with the System.Runtime.CompilerServices.IsBoxed modifier? Wouldn't it be better to finally implemented boxed references, instead of this hack? I know that would mean that these C++/CLI methods wouldn't be callable by other languages, but as it stand the language interop story isn't that great either (with the ValueType parameter types).<o:p></o:p></p>
        
        <p>
            Thanks.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; So the optimization is indeed allowed per the spec?<o:p></o:p></p>
        
        <p>
            It depends on your definition of "side effect".<span>&nbsp; </span>Historically C++ has used this same language to allow exactly this sort of thing, so that would be the typical reading of the spec.<o:p></o:p></p>
        
        <p>
            Note that the CLI spec also specifies an extremely weak memory model that is heavily influenced by IA64.<span>&nbsp; </span>Over here, we generally believe that the spec is too lenient and that our customers deserve a stronger memory model.<span>&nbsp; </span>We would use the same custom attribute to allow the system assemblies to opt-in to a weaker memory model on IA64 without forcing all our customers to deal with the high test burden and complicated programming model that it implies.<o:p></o:p></p>
        
        
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; Is this optimization really that significant that it is worth<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; all this trouble?<o:p></o:p></p>
        
        <p>
            For line-of-business and web apps, the optimizations are not worth the trouble.<span>&nbsp; </span>For high end ISV apps (like perhaps one day AutoCAD) or for the OS Shell, these optimizations are critical.<o:p></o:p></p>
        
        
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; I honestly don't see anyone adding this attribute to their<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; code (and of the people that would add it, some (most?)<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; probably don't understand the consequences).<o:p></o:p></p>
        
        <p>
            Agreed.<span>&nbsp; </span>It's there for people who need the performance of traditional unmanaged code and are willing to pay all the costs of achieving it.<o:p></o:p></p>
        <p>
            This means that our customers generally will ignore this capability, though they will certainly enjoy the performance benefits of having most of the frameworks built this way.<span>&nbsp; </span>We just need to be sure that we don't create races and other subtle bugs in the frameworks by chasing this extra perf.<span>&nbsp; </span>On IA64 the risk is higher than with AMD64.<span>&nbsp; </span>For X86 we are assuming no new risk in Whidbey.<o:p></o:p></p>
        
        
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; A "secure" method must do a volatile read before doing any<o:p></o:p></p>
        <p>
            <span>&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; parameter validation, otherwise the value of the parameter<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; might change after the validation (if the method is inlined<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; and this optimization happens).<o:p></o:p></p>
        
        <p>
            Thank-you.<span>&nbsp; </span>I have raised this issue more broadly.<span>&nbsp; </span>You really should be working here.<o:p></o:p></p>
        
        
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; Wouldn't it be better to finally implemented boxed references,<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&gt;&gt; instead of this hack?<o:p></o:p></p>
        
        <p>
            Eventually, we still intend to implement boxed references.<span>&nbsp; </span>Of course, we've been saying that for about 5 years so it's hard to know whether to take us seriously.<span>&nbsp; </span>You shouldn't read too much into the fact that this class is now defined in mscorlib.<span>&nbsp; </span>We basically took a bunch of markers from the C++ team (as we had already done with some other language<o:p></o:p></p>
        <p>
            teams) and dumped them into mscorlib.<span>&nbsp; </span>The CLR still has nothing to do with the C++ illusion of boxed references.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            &gt; <span>&nbsp;&nbsp;&nbsp; </span>&gt;&gt; So the optimization is indeed allowed per the spec?<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; It depends on your definition of "side effect".<span>&nbsp; </span>Historically C++ has <o:p></o:p>
        </p>
        <p>
            &gt; used this same language to allow exactly this sort of thing, so that <o:p></o:p>
        </p>
        <p>
            &gt; would be the typical reading of the spec.<o:p></o:p></p>
        
        <p>
            I sort of figured that that's where it came from. I, however, see source code as a much more abstract representation than IL (which is much more like a CPU instruction set), so they can get away with this much easier. Also, in C++ you mark a variable as volatile, but in the CLR (and in the CPU) it's the individual instructions that have the acquire/release semantics. To me the fact that a local variable can change its value feels like a CPU register that changes its value (that reminds of the old days under DOS, where the high 16 bits of the 32 bit registers where sometimes randomly destroyed by broken memory extenders).<o:p></o:p></p>
        
        <p>
            &gt; <span>&nbsp;&nbsp;&nbsp; </span>&gt;&gt; Is this optimization really that significant that it is worth<o:p></o:p></p>
        <p>
            &gt; <span>&nbsp;&nbsp;&nbsp; </span>&gt;&gt; all this trouble?<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; For line-of-business and web apps, the optimizations are not worth the <o:p></o:p>
        </p>
        <p>
            &gt; trouble.<span>&nbsp; </span>For high end ISV apps (like perhaps one day AutoCAD) or for <o:p></o:p>
        </p>
        <p>
            &gt; the OS Shell, these optimizations are critical.<o:p></o:p></p>
        
        <p>
            I can imagine reordering loads and stores are important, but I have a hard time believing that the particular one that Grant's blog referred to makes a difference. After all, loading the value from the stack (an indirection through the stack pointer) versus loading it from the object (an indirection through the this pointer) doesn't make much difference.<o:p></o:p></p>
        
        <p>
            &gt; We just need to be sure that we don't create races and other subtle <o:p></o:p>
        </p>
        <p>
            &gt; bugs in the frameworks by chasing this extra perf.<o:p></o:p></p>
        
        <p>
            It seems like a difficult trade-off to me. The time spent to audit the code could also be used to improve perf in another way. Or is it possible to have static analysis tools detect these issues reliably?<o:p></o:p></p>
        
        <p>
            &gt; <span>&nbsp;&nbsp;&nbsp; </span>&gt;&gt; Wouldn't it be better to finally implemented boxed references,<o:p></o:p></p>
        <p>
            &gt; <span>&nbsp;&nbsp;&nbsp; </span>&gt;&gt; instead of this hack?<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; Eventually, we still intend to implement boxed references.<span>&nbsp; </span>Of course, <o:p></o:p>
        </p>
        <p>
            &gt; we've been saying that for about 5 years so it's hard to know whether <o:p></o:p>
        </p>
        <p>
            &gt; to take us seriously.<o:p></o:p></p>
        
        <p>
            &lt;g&gt; It seems like a trivial feature (of course, almost everything looks trivial from the outside), I'm surprised the C++ guys haven't been able to convince the CLR team to do it. The thing I worry about is that once C++/CLI "popularizes" the current hack, there will be even less incentive to fix the CLR, because it will introduce another, incompatible, way of expressing the same thing. You probably can't answer this, but with the new Longhorn/WinFX story does that mean that Longhorn will ship with Whidbey instead of Orcas? If so, Whidbey is really going to have to be the CLR version that gets everything right.<o:p></o:p></p>
        
        <p>
            BTW, did you see how they encode the type? I think it's rather ugly:<o:p></o:p></p>
        
        <p>
            class ValueType modopt(Int32) modopt(IsBoxed) i<o:p></o:p></p>
        
        <p>
            I would've preferred something like this:<o:p></o:p></p>
        
        <p>
            class ValueType modopt(IsBoxed`1&lt;Int32&gt;) i<o:p></o:p></p>
        
        <p>
            but I vaguely seem to remember that modifiers don't allow generics.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            I thought a lot about the optimization and I'm now somewhat more willing to believe that it is worthwhile and I have to reluctantly agree that adding a bit to CRA is the best thing to do. I really don't like CRA though, e.g. does link understand it (and refuse to link together modules with different flags)? How does it interact with Reflection.Emit or DynamicMethods? Global switches like that add conceptual weight to the platform.<o:p></o:p></p>
        
        <p>
            I feel kinda funny, because in the Java world I'm always arguing that they are too conservative adding features to the VM.<o:p></o:p></p>
        
        <p>
            Aside from the optimization, if the current CLI spec really allows this optimization, then I'm having a hard time figuring out how to (efficiently) compile Java bytecode to IL. Java doesn't allow this optimization (I had to re-read chapter 17 of the JLS to be sure [compared to the CLI spec they have a really detailed and formal description of their memory model [even if it is a little flawed]]), so how would I do a field load? I could always use a volatile.l[s]fld, but that has far too strong guarantees and disallows many optimizations. The only other option I could come up with was to do a virtual method call after each field load, that would also preclude the JIT from doing the optimization (as long as there is no way for it to prove where the virtual call ends up).<o:p></o:p></p>
        
        <p>
            Finally, I can't be sure, but I think my suggestion to solve the "method arguments" problem (do a volatile load) doesn't work. As I understand it now, even a volatile load doesn't preclude the copy propagation of the non-volatile load. So you'd have to have a full memory barrier or do a virtual call at the top of your method (or modify the JIT to disallow copy propagation on arguments).<o:p></o:p></p>
        
        <p>
            In summary, I think where we should end up is: CLI spec disallows this optimization, but when the CRA attribute is present (and has the correct flag set) the JIT is allowed to do optimizations that aren't spec compliant.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Linking already ignores a large number of assembly-level concepts.<span>&nbsp; </span>I think their current goal is for linking to mechanically succeed, and any semantic issues are for the developer to resolve.<span>&nbsp; </span>Eventually I could imagine this being better productized.<o:p></o:p></p>
        
        <p>
            The V1 ECMA spec is way too lax about the memory model.<span>&nbsp; </span>With a weak<o:p></o:p></p>
        <p>
            (IA64-style) memory model, there's little point in discouraging codegen optimizations... the chip is going to screw up the developer's assumptions anyway.<span>&nbsp; </span>I personally would like to see the ECMA spec updated to a stronger memory model.<span>&nbsp; </span>This will give developers a rational world to code in.<o:p></o:p></p>
        
        <p>
            Regardless of whether the ECMA spec moves to a strong memory model, the CLR will guarantee a strong model by default.<span>&nbsp; </span>(It's still not clear which technique we will use on IA64 to achieve this). So as a practical matter you can convert byte codes to IL for the CLR without any volatile operations.<span>&nbsp; </span>However, I realize that changing the ECMA spec is far more desirable for you.<o:p></o:p></p>
        
        <p>
            I'm writing up a DCR today anyway.<span>&nbsp; </span>I'll include the proposal to ECMA as part of that work.<span>&nbsp; </span>However, I already know that some of the non-Microsoft ECMA attendees will be very opposed to these changes.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hello Chris,<o:p></o:p></p>
        
        <p>
            I ran into something interesting again. I was writing a test case for IKVM to test static initialization dependencies, and to do this I iterate thru all types in my class library and fire up an AppDomain to initialize that type and then I unload the AppDomain again and move on to the next type.<o:p></o:p></p>
        
        <p>
            I noticed that for types that fire up the AWT thread (basically the Windows event loop) the AppDomain couldn't be unloaded. This turned out to be because the thread is blocking inside a Win32 API waiting for a message (and since there aren't any windows, the message loop is unlikely to receive any messages).<o:p></o:p></p>
        
        <p>
            It's not terribly important, but it might be a good idea to have special support in Thread.Abort for Windows message loop threads, that seems like a simple thing, but it probably is more complicated (isn't it always ;-)).<o:p></o:p></p>
        
        <p>
            I could be wrong about my diagnosis, it's consistent with what I see on Everett, but on Whidbey (beta 1) the unload often succeeds for some reason.<o:p></o:p></p>
        
        <p>
            I added a simple workaround to my code (I set up a WinForms timer that fires every 100ms).<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi.<o:p></o:p></p>
        
        <p>
            I apologize for the delay...<span>&nbsp; </span>I was at an offsite for the last week.<o:p></o:p></p>
        <p>
            They kept us busy from 7:00 AM until 10:00 PM, so I had very little time left over for email in the evenings and mornings.<o:p></o:p></p>
        
        <p>
            It's true that any unmanaged blocking will defeat the CLR's ability to take control of the thread.<span>&nbsp; </span>That's one reason why we wrap [Msg]WaitForMultipleObjects[Ex] with WaitHandle.WaitAny/All, for example.<o:p></o:p></p>
        
        <p>
            I had thought that WinForms used PeekMessage or MsgWait* or other tricks to either poll or efficiently block when there are no messages for the GUI thread to process.<span>&nbsp; </span>But I looked at the WinForms code to confirm this and it looks like they will call WaitMessage is nothing is happening.<span>&nbsp; </span>This looks like it will be a problem.<o:p></o:p></p>
        
        <p>
            At some point I need to go look at what Avalon is doing here, too.<span>&nbsp; </span>I have some general questions about how they do add-ins and whether they can cleanly support AppDomain.Unload of those add-ins.<o:p></o:p></p>
        
        <p>
            All of this will shake out naturally when we get our act together with a strong add-in model and implementation.<span>&nbsp; </span>But we are way behind on this effort and it obviously is now post-Whidbey.<o:p></o:p></p>
        
        <p>
            How are things going generally?<span>&nbsp; </span>Sometimes I get mail on Mono's progress, and I see that IKVM is the way to execute Java code on their runtime.<o:p></o:p></p>
        
        <p>
            And is the Applications business healthy in Europe?<span>&nbsp; </span>Microsoft certainly seems to be screwing up its business opportunities there.<span>&nbsp; </span>Of all our businesses, Applications seems to be the one where we are struggling the most and all of those problems seem to be self-inflicted.<span>&nbsp; </span>I still feel that over time this will be a huge business for us.<span>&nbsp; </span>But it looks like it will take a lot more time than I had hoped.<o:p></o:p></p>
        
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
    </div>
    
    <div>
        <p>
            Hi,<o:p></o:p></p>
        
        <p>
            &gt; I apologize for the delay...<span>&nbsp; </span>I was at an offsite for the last week.<o:p></o:p></p>
        <p>
            &gt; They kept us busy from 7:00 AM until 10:00 PM, so I had very little <o:p></o:p>
        </p>
        <p>
            &gt; time left over for email in the evenings and mornings.<o:p></o:p></p>
        
        <p>
            Ugh. Was that some internal Microsoft event?<o:p></o:p></p>
        
        <p>
            &gt; I had thought that WinForms used PeekMessage or MsgWait* or other <o:p></o:p>
        </p>
        <p>
            &gt; tricks to either poll or efficiently block when there are no messages <o:p></o:p>
        </p>
        <p>
            &gt; for the GUI thread to process.<span>&nbsp; </span>But I looked at the WinForms code to <o:p></o:p>
        </p>
        <p>
            &gt; confirm this and it looks like they will call WaitMessage is nothing <o:p></o:p>
        </p>
        <p>
            &gt; is happening.<span>&nbsp; </span>This looks like it will be a problem.<o:p></o:p></p>
        
        <p>
            It's a tricky problem. Who owns these things? It's tempting to say that the individual libraries should prevent this, but at the end of the day the owner of Thread.Abort/AppDomain.Unload is probably more aware of the issues (to put it nicely ;-))<o:p></o:p></p>
        
        <p>
            &gt; At some point I need to go look at what Avalon is doing here, too.<span>&nbsp; </span>I <o:p></o:p>
        </p>
        <p>
            &gt; have some general questions about how they do add-ins and whether they <o:p></o:p>
        </p>
        <p>
            &gt; can cleanly support AppDomain.Unload of those add-ins.<o:p></o:p></p>
        
        <p>
            I need to look at Avalon too. I've installed the CTP, but so far I haven't really played with it.<o:p></o:p></p>
        
        <p>
            &gt; How are things going generally?<span>&nbsp; </span>Sometimes I get mail on Mono's <o:p></o:p>
        </p>
        <p>
            &gt; progress, and I see that IKVM is the way to execute Java code on their <o:p></o:p>
        </p>
        <p>
            &gt; runtime.<o:p></o:p></p>
        
        <p>
            Yeah, that's going great. IKVM is really starting to pick up users, but unfortunately I'm still the only developer.<o:p></o:p></p>
        
        <p>
            &gt; And is the Applications business healthy in Europe? <o:p></o:p>
        </p>
        
        <p>
            I don't know in general, but we're doing good (but we're small). The company whose product we're piggybacking on continues to blunder along and so far seems unaffected by Microsoft's move into the space.<o:p></o:p></p>
        
        <p>
            Something else, when is Orcas planning really going to get going? I've considered writing up my wishlist (in detail), would that be helpful?<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            It was indeed a Microsoft event, though it had zero technical content.<o:p></o:p></p>
        <p>
            But it gave me a chance to meet with a lot of people here who I normally wouldn't interact with (lawyers, business folks and a few architects), so I did get some value out of it.<o:p></o:p></p>
        
        <p>
            Generally the CLR pushes the frameworks to be friendly to an Unload.<span>&nbsp; </span>We have guidelines for this which we have reviewed with all the teams.<o:p></o:p></p>
        <p>
            It's part of the hardening effort that's required to get onto SQL Server's white list so you can be used inside the database.<span>&nbsp; </span>But ultimately we rely on different teams having scenarios that involve Unload and testing it themselves.<span>&nbsp; </span>When we get our add-in story going properly, I think this issue will resolve itself.<span>&nbsp; </span>Both WinForms &amp; Avalon would test add-ins aggressively for the client and we already have ASP.NET and SQL Server testing Unload aggressively on the server.<o:p></o:p></p>
        
        <p>
            As for Orcas planning, we've actually had some high level planning already.<span>&nbsp; </span>This has included presentations to various VPs, so it's somewhat baked.<span>&nbsp; </span>However, a lot is going to change between now and when we can move lots of bodies from Whidbey over to Orcas.<span>&nbsp; </span>(I think a few people are working on Orcas deliverables, but it's at the noise level).<o:p></o:p></p>
        <p>
            I personally am not yet happy with some of the broad directions of the current Orcas plan.<span>&nbsp; </span>Realistically I think it will be early spring before we have a plan we can believe in and we are really executing on.<o:p></o:p></p>
        
        <p>
            Any time between now and February is probably a good time for input on the plan.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hello Chris,<o:p></o:p></p>
        
        <p>
            A while ago I asked you if the changed verifier behavior towards signed/unsigned arrays was intentional and you said it probably wasn't. I just installed the December CTP on my x64 system and peverify still complains about this method:<o:p></o:p></p>
        
        <p>
            .method public static int8[] cast(unsigned int8[] A_0) cil managed {<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>.maxstack<span>&nbsp; </span>1<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>IL_0000:<span>&nbsp; </span>ldarg.0<o:p></o:p></p>
        <p>
            <span>&nbsp; </span>IL_0001:<span>&nbsp; </span>ret<o:p></o:p></p>
        <p>
            }<o:p></o:p></p>
        
        <p>
            As I said back then, I don't really mind, it's just a reminder to me that I need to change my code to represent Java byte arrays as unsigned byte arrays (not because of this, but to be CLS compliant).<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            There was a lot of email chatter about fixing this and a bunch of related regressions, though I didn't review those fixes myself.<o:p></o:p></p>
        
        <p>
            I just tried the attached program with a 12/24 private build.<span>&nbsp; </span>It executes off a network share and it satisfies peverify.exe.<o:p></o:p></p>
        
        <p>
            Then I used ILDASM / ILASM to paste in the method you show below.<o:p></o:p></p>
        <p>
            Peverify still likes it.<o:p></o:p></p>
        
        <p>
            So I think we must have fixed it, but it didn't make the CTP.<o:p></o:p></p>
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            &gt; I just tried the attached program with a 12/24 private build.<span>&nbsp; </span>It <o:p></o:p>
        </p>
        <p>
            &gt; executes off a network share and it satisfies peverify.exe.<o:p></o:p></p>
        
        <p>
            Interesting that casting now works consistently with the verifier. In Everett you couldn't do that.<o:p></o:p></p>
        
        <p>
            &gt; So I think we must have fixed it, but it didn't make the CTP.<o:p></o:p></p>
        
        <p>
            It turns out that the December CTP includes a pretty old version of the CLR (build 41115) it's main focus is the Team System stuff. I only installed it because the November CTP DVD didn't have a working x64 installer (the setup file contained all zeroes, how on earth did that happen :-0).<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            &gt; &gt; I just tried the attached program with a 12/24 private build.<span>&nbsp; </span>It <o:p></o:p>
        </p>
        <p>
            &gt; &gt; executes off a network share and it satisfies peverify.exe.<o:p></o:p></p>
        <p>
            &gt; <o:p></o:p>
        </p>
        <p>
            &gt; Interesting that casting now works consistently with the verifier. In <o:p></o:p>
        </p>
        <p>
            &gt; Everett you couldn't do that.<o:p></o:p></p>
        
        <p>
            Upon reflection I think that this is bad idea. It's a breaking change (assuming that isinst behaves consistently with castclass) and offers not much benefit.<o:p></o:p></p>
        
        <p>
            I'm not sure if it's worth losing any sleep over, but I've attached a contrived example that is perfectly safe on Everett, but would have security hole on Whidbey.<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Chris,<o:p></o:p></p>
        
        <p>
            I have no idea what made me think of this, but attached is a program that uses WeakReference to get access to a GCHandle it shouldn't have access to.<o:p></o:p></p>
        
        <p>
            BTW, who on earth is responsible for making the Whidbey version of ILDASM unusable in interactive mode, by making the tree list the full type names at every level?<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Argh!<o:p></o:p></p>
        
        <p>
            I'll forward your feedback on the ILDASM to the owner.<span>&nbsp; </span>(Do you know Serge?<span>&nbsp; </span>He's the dev who wrote the ".NET IL Assembler" book).<o:p></o:p></p>
        
        <p>
            And I'll follow up on the security problem with GcHandle immediately.<o:p></o:p></p>
        <p>
            Thank-you for finding this.<o:p></o:p></p>
        
        <p>
            -- I haven't forgotten about the byte[]/sbyte[] security threat you sent me.<span>&nbsp; </span>It's just that on my first casual read of it, I didn't understand what it was doing.<span>&nbsp; </span>So I need a quiet 30 minutes, which is hard to come by.<o:p></o:p></p>
        
        <p>
            Chris<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Serge had this to say:<o:p></o:p></p>
        
        <p>
            "...full class name display in graphic mode can be disabled by unchecking menu choice View/FullClassNames."<o:p></o:p></p>
        
        <p>
            I don't know if this satisfies you, given that it's not a persistent setting.<span>&nbsp; </span>It's not clear whether Serge can add persistence before Whidbey locks down, though I know he would like to.<o:p></o:p></p>
        
        
        <p>
            Chris.<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <p>
            Thanks. I had looked for an option on the view menu (it's not in beta 1, or I must be really blind ;-)), but that's sufficient for me. I don't really mind if it doesn't persist.<o:p></o:p></p>
    
    <div>
        <p>
            Hi,<o:p></o:p></p>
        
        <p>
            &gt; I'll forward your feedback on the ILDASM to the owner.<span>&nbsp; </span>(Do you know <o:p></o:p>
        </p>
        <p>
            &gt; Serge?<span>&nbsp; </span>He's the dev who wrote the ".NET IL Assembler" book).<o:p></o:p></p>
        
        <p>
            I never met him, but we've e-mailed. I didn't know he was still the one responsible for ILDASM or I would have flamed him directly ;-)<o:p></o:p></p>
        
        <p>
            &gt; And I'll follow up on the security problem with GcHandle immediately.<o:p></o:p></p>
        <p>
            &gt; Thank-you for finding this.<o:p></o:p></p>
        
        <p>
            You're welcome. I'm curious what fix they'll come up with.<o:p></o:p></p>
        
        <p>
            &gt; -- I haven't forgotten about the byte[]/sbyte[] security threat you <o:p></o:p>
        </p>
        <p>
            &gt; sent me.<span>&nbsp; </span>It's just that on my first casual read of it, I didn't <o:p></o:p>
        </p>
        <p>
            &gt; understand what it was doing.<span>&nbsp; </span>So I need a quiet 30 minutes, which is <o:p></o:p>
        </p>
        <p>
            &gt; hard to come by.<o:p></o:p></p>
        
        <p>
            It's very contrived so the code doesn't make all that much sense, but the general principle is that the CLR should avoid trying to do too many surprising things (programmers generally study a programming language and not the underlying abstraction [unfortunately]). This especially applies to changing the existing functionality, of course.<o:p></o:p></p>
        
        <p>
            &lt;noise&gt;<o:p></o:p></p>
        <p>
            Yesterday I thought I had found a JIT bug. I wanted to fix an outstanding issue in IKVM's handling of JNI (Java Native Interface) where it didn't support calling methods that return a value type. When I wrote a test case for this behavior and ran it, it failed in a very strange way. Here is a (much) distilled version of the code I generated:<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>.maxstack<span>&nbsp; </span>9<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>.locals init (valuetype [IKVM.Runtime]IKVM.Runtime.JNI/Frame V_0,<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>native int V_1,<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>valuetype [IKVM.GNU.Classpath]java.lang.CharSequence V_2)<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>ldloca.s<span>&nbsp;&nbsp; </span>V_0<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>initobj<span>&nbsp;&nbsp;&nbsp; </span>[IKVM.Runtime]IKVM.Runtime.JNI/Frame<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>ldloca.s<span>&nbsp;&nbsp; </span>V_0<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>ldloc.1<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>ldloca.s<span>&nbsp;&nbsp; </span>V_0<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>ldsfld<span>&nbsp;&nbsp;&nbsp;&nbsp; </span>object class0::'__&lt;classObject&gt;'<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>brtrue.s<span>&nbsp;&nbsp; </span>IL_0052<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>ldtoken<span>&nbsp;&nbsp;&nbsp; </span>class0<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>call<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>object [IKVM.Runtime]IKVM.Runtime.ByteCodeHelper::GetClassFromTypeHandle(valuetype [mscorlib]System.RuntimeTypeHandle)<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>stsfld<span>&nbsp;&nbsp;&nbsp;&nbsp; </span>object class0::'__&lt;classObject&gt;'<o:p></o:p></p>
        <p>
            IL_0052:<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>ldsfld<span>&nbsp;&nbsp;&nbsp;&nbsp; </span>object class0::'__&lt;classObject&gt;'<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>call<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>instance native int [IKVM.Runtime]IKVM.Runtime.JNI/Frame::MakeLocalRef(object)<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>ldftn<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>native int class0::NativeFunc(native int, native int)<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>calli<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>native int(native int,native int)<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>dup<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>call<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>void [mscorlib]System.Console::WriteLine(int32)<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>call<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>instance object [IKVM.Runtime]IKVM.Runtime.JNI/Frame::UnwrapLocalRef(native int)<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>stloc.2<o:p></o:p></p>
        
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>ldloc.2<o:p></o:p></p>
        <p>
            <span>&nbsp;&nbsp;&nbsp; </span>ret<o:p></o:p></p>
        
        <p>
            The crucial bit is that V_2 is a value type and that UnwrapLocalRef returns object. The stloc.2 caused the JIT to "optimize" the call the UnwrapLocalRef by passing in the address of V_2 (because it assumed that the method would return a value type, since I was [incorrectly] treating the return value as a value type).<o:p></o:p></p>
        
        <p>
            Before I had figured out what was wrong I worked around it by moving the "ldloca.s V_0" to after the "calli" (and I had previously run the code on Whidbey, where the problem also didn't show), so I was "conviced" it was a JIT bug. Only this morning when I was trying to build a concise repro I figured out what was going on and I realized that it wasn't a JIT bug after all.<o:p></o:p></p>
        <p>
            &lt;/noise&gt;<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi again,<o:p></o:p></p>
        
        <p>
            I just did a little more IKVM testing on x64 and I ran into a problem relating to how MethodImpls are handled. On Everett when you override a method that has a MethodImpl, you end up overriding the original method (in other words, the MethodImpl method occupies the same vtable slot as the original method), in Whidbey (build 41115) this no longer works. See the attached example.<o:p></o:p></p>
        
        <p>
            Was this change intentional?<o:p></o:p></p>
        
        <p>
            Regards,<o:p></o:p></p>
        <p>
            Jeroen<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            I see "I'm Derived" for this test case on a recent Whidbey build, just like Everett.<o:p></o:p></p>
        
        <p>
            I believe this was an accidental regression during Whidbey that was noticed by the C# team and that has been corrected.<span>&nbsp; </span>Simon can confirm this.<o:p></o:p></p>
        
        <p>
            Thanks for the heads up.<o:p></o:p></p>
        
        <p>
            Chris<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            Hi Jeroen,<o:p></o:p></p>
        
        <p>
            Actually, the change was not accidental; it was an attempt to move closer to what methodImpls were originally intended to be. We originally wanted methodImpls to be a one-time, one-slot method body substitution rather than a form of virtual slot unification. However, the C# team pointed out that they were relying on the previous behaviour and that probably others were as well, so we changed it back. Assuming that you're working with Beta 1, you'll see the behaviour reverted in Beta 2 when it is released.<o:p></o:p></p>
        
        <p>
            Thanks,<o:p></o:p></p>
        <p>
            Simon<o:p></o:p></p>
&nbsp;</div>
    
    <div>
        <p>
            We're still talking about the generalization of your example (like some cases involving dispatch on boxed enums).<span>&nbsp; </span>There's no question that it's interesting and a potential problem.<span>&nbsp; </span>So far, the examples are all contrived and it looks like we have more threatening problems for this release.<span>&nbsp; </span>But it's too early to be sure.<o:p></o:p></p>
        
        <p>
            Regardless of where we end up, thank-you very much for bringing it to our attention.<o:p></o:p></p>
        
        <p>
            Chris<o:p></o:p></p>
        <p>
            <a href="http://blogs.msdn.com/cbrumme">http://blogs.msdn.com/cbrumme</a><o:p></o:p></p>
&nbsp;</div>


</div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>