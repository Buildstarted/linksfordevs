<!DOCTYPE html>
<html lang="en">
<head>
    <title>
r/math - A monad is a monoid in the category of endofunctors, what&#x27;s the problem? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="r/math - A monad is a monoid in the category of endofunctors, what&#x27;s the problem? - linksfor.dev(s)"/>
    <meta property="og:description" content="353 votes and 78 comments so far on Reddit"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.reddit.com/r/math/comments/ap25mr/a_monad_is_a_monoid_in_the_category_of/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - r/math - A monad is a monoid in the category of endofunctors, what&#x27;s the problem?</title>
<div class="readable">
        <h1>r/math - A monad is a monoid in the category of endofunctors, what&#x27;s the problem?</h1>
            <div>Reading time: 17-22 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://www.reddit.com/r/math/comments/ap25mr/a_monad_is_a_monoid_in_the_category_of/">https://www.reddit.com/r/math/comments/ap25mr/a_monad_is_a_monoid_in_the_category_of/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div data-click-id="text"><div theme="[object Object]"><p>This phrase appears in the hilarious <a href="http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html" rel="noopener noreferrer nofollow ugc" target="_blank"><em>A Brief, Incomplete, and Mostly Wrong History of Programming Languages</em></a>, making fun of the obscure mathematical concepts in the functional programming language Haskell.</p><p>I've studied some category theory and I've programmed in Haskell, and I've seen this statement many times before. But I've never actually taken the time to break it down and see why it's true. I just spent a couple of hours refreshing my rusty category theory knowledge and figuring it out. I wanted to write it down to make sure I actually understood it well. So... here goes.</p><p>What's a category?</p><p>A [category](<a href="https://en.wikipedia.org/wiki/Category_(mathematics)" rel="noopener noreferrer nofollow ugc" target="_blank">https://en.wikipedia.org/wiki/Category_(mathematics)</a>) is simply a collection of 'objects' (or 'points') with 'morphisms' (or 'arrows') between them, satisfying two very simple rules:</p><ul><li><p>You can compose an arrow <code>f: A -&gt; B</code> with an arrow <code>g: B -&gt; C</code> to get a new arrow <code>g . f: A -&gt; C</code>, and this composition is associative (i.e. <code>h . (g . f) = (h . g) . f</code>).</p></li><li><p>For every object <code>A</code> there exists an <em>identity arrow</em> <code>id_A: A -&gt; A</code>, such that for every arrow <code>f: A -&gt; B</code> we have <code>id_B . f = f . id_A = f</code>.</p></li></ul><p>The classical example in mathematics is the category <code>Set</code>, whose objects are sets, and whose arrows are functions between these sets. In the world of Haskell, we have the category <a href="https://wiki.haskell.org/Hask" rel="noopener noreferrer nofollow ugc" target="_blank"><code>Hask</code></a>, whose objects are Haskell types and whose arrows are functions between these types. So, for example, <code>Float</code> and <code>Int</code> are objects, and <code>round:: Float -&gt; Int</code> is an arrow.</p><p>What's a functor?</p><p>In category theory a <a href="https://en.wikipedia.org/wiki/Functor" rel="noopener noreferrer nofollow ugc" target="_blank">functor</a> is a map between two categories. So if <code>C</code> and <code>D</code> are categories, then a functor <code>F: C -&gt; D</code> will map objects in <code>C</code> to objects in <code>D</code>, and arrows in <code>C</code> to arrows in <code>D</code>. It does this in a 'nice' way. That is:</p><ul><li><p>The starts and ends of arrows are mapped nicely: if <code>f</code> is an arrow in <code>C</code> from object <code>A</code> to <code>B</code>, then <code>F(f)</code> is an arrow in <code>D</code> from <code>F(A)</code> to <code>F(B)</code>.</p></li><li><p>Identities are preserved: <code>F(id_A) = id_F(A)</code>.</p></li><li><p>Composition is preserved: <code>F(g . f) = F(g) . F(f)</code>.</p></li></ul><p>Note that this concept is a bit more general than the concept of functors in Haskell (see below).</p><p>What's an endofunctor?</p><p>An endofunctor is simply a functor from a category to itself. So in the above, assume that <code>C = D</code>. Note, that doesn't mean that the endofunctor <code>F</code> doesn't <em>do</em> anything. Just like a function from the real numbers to the real numbers might still <em>change</em> the numbers, the functor <code>F</code> might still change the objects and arrows that are fed through it in some way.</p><p>What's a Haskell Functor?</p><p>What is known as a <code>Functor</code> in Haskell is actually an endofunctor on the category <code>Hask</code>. Recall that <code>Hask</code> has types as its objects and functions between these types as its arrows. So an endofunctor on <code>Hask</code> will map a type to some other type, and will also map functions to functions in some nice way.</p><p>This is the <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#Functor" rel="noopener noreferrer nofollow ugc" target="_blank">definition of <code>Functor</code> in Haskell</a>:</p><pre><code>{- | The 'Functor' class is used for types that can be mapped over.
Instances of 'Functor' should satisfy the following laws:

&gt; fmap id  ==  id
&gt; fmap (f . g)  ==  fmap f . fmap g

The instances of 'Functor' for lists, 'Data.Maybe.Maybe' and 'System.IO.IO'
satisfy these laws.
-}

class  Functor f  where
    fmap        :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre><p>See the symmetry with the mathematical definition of functors above? The type constructor <code>f</code> fulfills the role of the functor's action on types (objects), while <code>fmap</code> fulfills the role of the functor's action on functions (arrows).</p><p>The two classical examples of <code>Functor</code>s in Haskell are lists (<code>[]</code>) and <code>Maybe</code>.</p><p>List is a Functor</p><p>List is a type constructor that, given some type <code>a</code> will give you a new type <code>[a]</code>, namely lists consisting of values of type <code>a</code>. This is the type (object) mapping part. The function mapping part is <code>fmap</code> (also known simply as <code>map</code>). Given some function <code>f:: a -&gt; b</code> it will give you a function <code>fmap f:: [a] -&gt; [b]</code>, namely the function that applies <code>f</code> to every element of a list of values of type <code>a</code>. You can see that <code>fmap id</code> is indeed the identity: doing nothing to every element of a list is the same as doing nothing to the list. The other law, <code>fmap (f . g) = fmap f . fmap g</code>, is also easy to see: doing <code>g</code> and then <code>f</code> to every element of a list, is the same as first doing <code>g</code> to every element of a list and then doing <code>f</code> to every element of the resulting list.</p><p>Maybe is a Functor</p><p><code>Maybe</code> is a type constructor that given some type <code>a</code> will give you a new type <code>Maybe a</code>. The values of this type are <code>Just x</code> for any <code>x</code> of type <code>a</code>, and <code>Nothing</code>. The function mapping part <code>fmap</code> will take some function <code>f:: a -&gt; b</code> and give you a new function <code>fmap f:: Maybe a -&gt; Maybe b</code>. It will take <code>Just x</code> to <code>Just (f x)</code>, and <code>Nothing</code> to <code>Nothing</code>. Can you prove the laws?</p><p>What's the category of endofunctors?</p><p>Ok, now things are going to get a bit more tricky. First we need to talk about natural transformations, which are basically arrows between functors. Then we'll use this to build a category of endofunctors, and finally we'll look at examples in Haskell.</p><p>What are natural transformations?</p><p>It turns out that if you have categories <code>C</code> and <code>D</code> and functors <code>F, G: C -&gt; D</code> between them, you can sometimes find so called '<a href="https://en.wikipedia.org/wiki/Natural_transformation" rel="noopener noreferrer nofollow ugc" target="_blank">natural transformations</a>' between the functors <code>F</code> and <code>G</code>. A natural transformation <code>t: F =&gt; G</code> is a family of arrows in <code>D</code> that satisfies two requirements:</p><ul><li><p>The arrows <code>t</code> go from the results of <code>F</code> to the results of <code>G</code>. More precisly, for every object <code>A</code> in <code>C</code> we have an arrow <code>t_A: F(A) -&gt; G(A)</code> in <code>D</code>. This is the 'component' of <code>t</code> at <code>A</code>.</p></li><li><p>For every arrow <code>f</code> in <code>C</code>, applying <code>F(f)</code> first and then <code>t</code> is the same as applying <code>t</code> first and then <code>G(f)</code>. This is the 'natural' part of a 'natural transformation'. More precisely, for every <code>f: X -&gt; Y</code> in <code>C</code> we have <code>t_Y . F(f) = G(f) . t_X</code>. Graphically, it means that going around <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f2/Natural_transformation.svg/1267px-Natural_transformation.svg.png" rel="noopener noreferrer nofollow ugc" target="_blank">this diagram</a> in either direction does the same thing ('the diagram commutes').</p></li></ul><p>Of course there's a special case where <code>F</code> and <code>G</code> are endofunctors (so <code>C = D</code>). There's also nothing stopping us from setting <code>F = G</code>, so then we're looking for natural transformations from a functor to itself. Just as with endofunctors these natural transformations may still <em>do something</em>.</p><p>The category of endofunctors</p><p>Now, for some category <code>C</code> we have a bunch of endofunctors on <code>C</code> and we have natural transformations between these endofunctors. We can make this into a category! So let's introduce <code>Endo(C)</code>, the category whose objects are endofunctors on <code>C</code>, and whose arrows are natural transformations between these endofunctors. You can check that composition of natural transformations is indeed associative, and that there is an identity natural transformation from every endofunctor to itself. But that's not super relevant here.</p><p>The category of endofunctors in Haskell</p><p>Lost? Let's think about what this would look like in the world of Haskell: what does <code>Endo(Hask)</code> look like? Well, its objects are endofunctors on <code>Hask</code>, which are simply <code>Functor</code>s. Its arrows are 'transformations' from one <code>Functor</code> to another. So if <code>f</code> and <code>g</code> are functors, then we're looking for some set of functions <code>t</code>, such that for every type <code>a</code> we have a function <code>t:: f a -&gt; g a</code>.</p><p>Let's pick <code>f = Maybe</code> and <code>g = []</code>. So we're looking for a set of functions <code>t:: Maybe a -&gt; [a]</code>. Well here's one example:</p><pre><code>maybeToList            :: Maybe a -&gt; [a]
maybeToList  Nothing   = []
maybeToList  (Just x)  = [x]
</code></pre><p>Ok, so <code>maybeToList</code> is a transformation from the endofunctor <code>Maybe</code> to the endofunctor <code>[]</code>. But is it natural? Well, let's take some arbitrary function <code>f: a-&gt; b</code>. If <code>maybeToList</code> is natural, it must satisfy <code>maybeToList . fmap f = map f . maybeToList</code> (note that I've filled in <code>map</code> for the list's <code>fmap</code> to avoid confusion). Well this is pretty easy to check:</p><pre><code>(maybeToList . fmap f) Just x = maybeToList (Just (f x)) = [f x]
(map f . maybeToList ) Just x = map f [x]                = [f x]

(maybeToList . fmap f) Nothing = maybeToList Nothing = []
(map f . maybeToList ) Nothing = map f []            = []
</code></pre><p>So yes, they're the same! So <code>maybeToList</code> is a natural transformation from the endofunctor <code>Maybe</code> to the endofunctor <code>[]</code>.</p><p>Another interesting natural transformation is <code>concat:: [[a]] -&gt; [a]</code>. It is a natural transformation from <code>[[]]</code> (i.e. applying the endofunctor <code>[]</code> twice), to <code>[]</code>. The naturality condition is <code>concat . map (map f) = map f . concat</code>.</p><p>What's a monoid?</p><p>Ok, this one is gonna be tricky again. There's a few different layers to this:</p><ul><li><p>First we'll look at the classical concept of a monoid in set theory. We'll also look at an example of such a monoid in Haskell.</p></li><li><p>Then we'll try to generalize the concept of monoids from set theory to category theory. We'll realize that we're missing a category-theoretic ingredient. Confusingly, this ingredient is called a 'monoidal category'.</p></li><li><p>Armed with monoidal categories, we can understand a monoid in a category.</p></li></ul><p>Monoids in set theory</p><p>In classical set theory, a <a href="https://en.wikipedia.org/wiki/Monoid" rel="noopener noreferrer nofollow ugc" target="_blank">monoid</a> is a set <code>M</code> with some binary operation <code>•: M × M -&gt; M</code> satisfying the following properties:</p><ul><li><p>Associativity: for all <code>a, b, c</code> in <code>M</code>, we have <code>(a • b) • c = a • (b • c)</code>. Informally: "it doesn't matter where you put the brackets."</p></li><li><p>Identity element: there is some <code>e</code> in <code>M</code> such that for every <code>a</code> in <code>M</code> we have <code>e • a = a • e = a</code>.</p></li></ul><p>An example of a monoid is the set of all finite strings over some alphabet with string concatenation as the monoid operation. It's easy to check that associativity holds and that the empty string acts as an identity element.</p><p>This also gives us our example in Haskell: for every type <code>a</code> the type <code>[a]</code> is a monoid with <code>++</code> (concatenation) as the monoid operation and the empty list as identity element. (Small note: technically the type <code>[a]</code> also includes infinite lists, for which concatenation isn't well defined. Because of this, lists in Haskell technically aren't monoids, nor are they monads. We will ignore this technicality in what follows.)</p><p>Monoids in category theory</p><p>Category theorists are alergic to sets. If they see a definition of a mathematical object that includes the word 'set', they'll immediately start thinking about how they can rewrite this definition without using the word 'set'. Or, more respectfully, they'll try to generalize the definition such that it holds in categories other than <code>Set</code> too.</p><p>It's obvious how to begin: the set <code>M</code> should be replaced by an arbitrary object <code>M</code> in some category <code>C</code>. The binary operation <code>•</code> should be replaced by some arrow <code>μ</code> in the category. Similarly, since we can't 'crack open' an object in a category (we'd have to say what it is, and category theorists hate that), we have to replace the identity element with some arrow <code>η</code> going into <code>M</code>.</p><p>The arrow <code>μ</code> should clearly end at <code>M</code>, but where should it start? We need some way to construct a 'product object', similar to the cartesian product for sets. Turns out there's a few different ways you can do that, but the one that's useful for monoids is the concept of a 'tensor product' in a 'monoidal category'.</p><p>Monoidal categories</p><p>The aim here is to define some operation <code>⊗</code> that will allow us to combine two objects <code>A, B</code> in some category <code>C</code> into a new object <code>A ⊗ B</code> in that same category. The natural way to map objects in categories is through functors. But in this case we would have to map two objects into one object. We need a functor that can take two arguments.</p><p>The typical way of solving this is by instead introducing a product space that encodes both arguments as one. So we need to have an object <code>(A, B)</code> in some product category <code>C × C</code>. At this point you may think I'm going crazy: in order to define monoids in categories we need to define products of objects, but to do that we need to define monoidal categories, but in order to that we need to define products of whole categories?!</p><p>That's right. Luckily, it's really quite simple. For categories <code>C</code> and <code>D</code> the product category <code>C × D</code> is simply the category whose objects are pairs <code>(A, B)</code> of objects <code>A</code> in <code>C</code> and <code>B</code> in <code>D</code>, and whose arrows are pairs <code>f, g: (A, B) -&gt; (X, Y)</code> of arrows <code>f: A -&gt; X</code> and <code>g: B -&gt; Y</code> in <code>C</code> and <code>D</code>, respectively. Composition works straight-forwardly: <code>(f, g) . (k, l) = (f . k, g . l)</code>, with associativity easy to check. For any object <code>(A, B)</code> the identity arrow is simply given by <code>(id_A, id_B)</code>.</p><p>Ok, so now that we defined product categories, the machinery of functors is available to us again, and we can start thinking about a functor <code>⊗: C × C -&gt; C</code> that combines objects (and arrows). What properties would we want this functor to posses? Well, we would certainly want it to be associative in some way: we want <code>A ⊗ (B ⊗ C)</code> to be 'similar' to <code>(A ⊗ B) ⊗ C</code>. This can be made precise by saying that there is a natural transformation whose components are isomorphisms <code>α: A ⊗ (B ⊗ C) -&gt; (A ⊗ B) ⊗ C</code>. Similarly, we'd like there to be some identity element for <code>⊗</code>, let's call it <code>I</code>: we want <code>I ⊗ A</code> and <code>A ⊗ I</code> to be 'similar' to <code>A</code>. This can again be made precise by saying that there are natural transformations whose components are isomorphisms <code>λ: I ⊗ A -&gt; A</code> and <code>ρ: A ⊗ I -&gt; A</code>. There's some additional conditions about these natural transformations playing nice with each other (the 'coherence conditions'), but we'll skip over that here.</p><p>If you compare this section to the one about monoids in set theory, you can probably spot some similarities. Instead of elements of a set, we have objects in a category; instead of a binary operation <code>•</code> we have the functor <code>⊗</code>; instead of an identity element we have a unit object; and instead of equations involving elements of a set, we have natural transformations between functors built using <code>⊗</code>. This correspondence is why the term 'monoid' is reused, and why this concept is called a <a href="https://en.wikipedia.org/wiki/Monoidal_category" rel="noopener noreferrer nofollow ugc" target="_blank">monoidal category</a>.</p><p>If we want to make the monoidal structure of a category <code>C</code> explicit, we will refer to it as the monoidal category <code>(C, ⊗, I)</code></p><p>Monoids in a monoidal category</p><p>Above we defined a concept analogous to monoids. However, it's not quite what we're looking for; a monoidal category is a category with some additional properties. What we're looking for is an <em>object in a category</em> satisfing certain properties. Namely, a [monoid in a monoidal category](<a href="https://en.wikipedia.org/wiki/Monoid_(category_theory)" rel="noopener noreferrer nofollow ugc" target="_blank">https://en.wikipedia.org/wiki/Monoid_(category_theory)</a>).</p><p>We start with the definition of a monoid, and then swap out set-theoretic concepts for category-theoretic ones. This is what we get:</p><p>A monoid in a monoidal category <code>(C, ⊗, I)</code> is an object <code>M</code> with an arrow <code>μ: M ⊗ M -&gt; M</code> ('multiplication') and an arrow <code>η: I -&gt; M</code> ('unit') satisfying the two monoid axioms:</p><ul><li><p>Associativity: if you have an object <code>M ⊗ (M ⊗ M) ≅ (M ⊗ M) ⊗</code>, it doesn't matter if you first multiply the left side or first multiply the right side. This is made exact with a commutative diagram involving <code>μ</code> and the natural isomorphism <code>α</code> (the associator).</p></li><li><p>Unit is an identity with multiplication: if you have an object <code>I ⊗ M ≅ M</code>, then 'forgetting' the <code>I</code> using the left unitor <code>λ</code> is the same as first mapping to <code>M ⊗ M</code> using <code>η</code> and then to <code>M</code> using <code>μ</code>. A symmetric equation must hold for <code>M ⊗ I</code> using the right unitor <code>ρ</code>.</p></li></ul><p>So how about a monoid in the category of endofunctors?</p><p>Ok, now that we know what a monoid in a (monoidal) category is, we can start thinking about a monoid in the category of endofunctors.</p><p>As we found out above, we first need to find a monoidal structure in the category of endofunctors. Turns out that's pretty easy: composition of endofunctors satisfies all the properties of a tensor product! The tensor product identity <code>I</code> is simply the identity functor <code>id</code>. It takes a little bit of work to show that the natural transformations behave the right way, but we'll skip over that here.</p><p>So then a monoid in the category of endofunctors is some endofunctor <code>M</code>, a natural transformation <code>μ: M . M -&gt; M</code> ('multiplication'), and a natural transformation <code>η: id -&gt; M</code> ('unit'), that satisfy the monoid axioms.</p><p>How can we make sense of this definition? Well, here's one way that will carry over quite nicely to Haskell: we can think of our endofunctors as introducing some additional structure on the objects they're applied to. The action of the endofunctors on arrows is to 'lift' the arrow into the structure. The endofunctor <code>M</code> then, is simply some chosen structure. The transformation <code>μ</code> ('multiplication') can be seen as 'flattening' the duplicate structure <code>M . M</code> down to just the structure <code>M</code>. The transformation <code>η</code> can be thought of as injecting unstructured data into the structure <code>M</code>.</p><p>What about the monoid axioms?</p><p>Associativity</p><p>If you have a triplicate structure <code>M . M . M</code>, it doesn't matter if you flatten it down to <code>M</code> as <code>(M . M) . M -&gt; M . M -&gt; M</code> or as <code>M . (M . M) -&gt; M . M -&gt; M</code>. This can be symbolically stated as for every <code>X</code>, <code>μ_X . M(μ_X) = μ_X . μ_M(X)</code>. Or intuitively: there's a unique way to flatten layered structure.</p><p>Unit is identity with multiplication</p><ul><li><p>If you have strucured data (<code>M</code>), and then use <code>η</code> to inject this into <code>M</code> again, you obtain data in <code>M . M</code>. You can then use <code>μ</code> to flatten this back down to <code>M</code>. This is the same as doing nothing. Symbolically, for every <code>X</code>, <code>μ_X . η_M(X) = id_M(X)</code></p></li><li><p>If you have structured data (<code>M</code>), and then use <code>M(η)</code> give structure to the 'contents' of your structure, you again obtain data in <code>M . M</code>. You can again use <code>μ</code> to flatten this back down to <code>M</code>. This is, again, the same as doing nothing. Symbolically, for every <code>X</code>, <code>μ_X . M(η_X) = id_M(X)</code>.</p></li></ul><p>Intuitively: injecting structure and flattening it cancel each other out.</p><p>A monoid in Endo(Hask)</p><p>Let's move to the world of Haskell again. As before, we look at <code>Endo(Hask)</code>, with its familiar endofunctors of <code>[]</code> and <code>Maybe</code> and others. Let's choose <code>M = []</code>. What should we pick for <code>μ</code>? It should be a natural transformation <code>μ:: [[a]] -&gt; [a]</code>. We've seen one before: <code>concat</code> (also known as <code>join</code>)! How about <code>η</code>? It should be a natural transformation <code>η:: id(a) -&gt; [a]</code>, which is simply <code>η:: a -&gt; [a]</code>. Well it's pretty simple to come up with one:</p><pre><code>inject   :: a -&gt; [a]
inject x = [x]
</code></pre><p>This function is also known as <code>pure</code> or <code>return</code> in Haskell.</p><p>What about the monoid axioms?</p><p>Well, for associativity we have to check that if we have some 3d list, that flattening the outer dimensions first will give the same result as flattening the inner dimensions. So: <code>concat . concat = concat . (map concat)</code>. It shouldn't be too hard to convince yourself that this is true.</p><p>But does our choice of unit play nice with the multiplication? We need to check:</p><ul><li><p>Injecting a list into a list and then concatenating is the same as doing nothing to that list: <code>concat . inject = id :: [a] -&gt; [a]</code>. That sounds pretty reasonable.</p></li><li><p>Injecting every element of a list into a list and then concatenating is the same as doing nothing to that list: <code>concat . map inject = id :: [a] -&gt; [a]</code>. Again, that seems clear.</p></li></ul><p>So <code>[]</code> is a monoid in the <code>Endo(Hask)</code>. Or equivalently, <code>[]</code> is a monad in <code>Hask</code>. Hooray!</p></div></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>