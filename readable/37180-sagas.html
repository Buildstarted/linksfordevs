<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Sagas -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Sagas</h1>
    <section class="page__content"> <p>Today has been a lively day in some parts of the Twitterverse debating the Saga pattern. As it stands, there are a few frameworks for .NET out there that use the term &quot;Saga&quot; for&#xA0;some framework implementation of a state machine or workflow. Trouble is, that&apos;s not what a Saga is. A Saga is a failure management pattern. </p>
<p>Sagas come out of the realization that particularly long-lived transactions (originally even just inside databases), but also far distributed transactions across location and/or trust boundaries can&apos;t eaily be handled using the classic ACID model with 2-Phase commit and holding locks for the duration of the work. Instead, a Saga splits work into individual transactions whose effects can be, somehow, reversed after work has been performed and commited.</p>
<p><a href="http://vasters.com/binary/Windows-Live-Writer/Sagas_1273E/image_4.png"><img alt="image" src="http://vasters.com/binary/Windows-Live-Writer/Sagas_1273E/image_thumb_1.png" width="672"></a></p>
<p>The picture shows a simple Saga. If you book a travel itinerary, you want a car and a hotel and a flight. If you can&apos;t get all of them, it&apos;s probably not worth going. It&apos;s also very certain that you can&apos;t enlist all of these providers into a distributed ACID transaction. Instead, you&apos;ll have an activity for booking rental cars that knows both how to perform a reservation and also how to cancel it - and one for a hotel and one for flights. </p>
<p>The activities are grouped in a composite job (routing slip) that&apos;s handed along the activity chain. If you want, you can sign/encrypt the routing slip items so that they can only be understood and manipulated by the intended receiver. When an activity completes, it adds a record of the completion to the routing slip along with information on where its compensating operation can be reached (e.g. via a Queue). When an activity fails, it cleans up locally and then sends the routing slip backwards to the last completed activity&apos;s compensation address to unwind the transaction outcome.</p>
<p>If you&apos;re a bit familiar with travel, you&apos;ll also notice that I&apos;ve organized the steps by risk. Reserving a rental car almost always succeeds if you book in advance, because the rental car company can move more cars on-site of there is high demand. Reserving a hotel is slightly more risky, but you can commonly back out of a reservation without penalty until 24h before the stay. Airfare often comes with a refund restriction, so you&apos;ll want to do that last.</p>
<p>I created a <a href="https://gist.github.com/3562597">Gist on Github that you can run as a console application</a>. It illustrates this model in code. Mind that it is a mockup and not a framework. I wrote this in less than 90 minutes, so don&apos;t expect to reuse this.</p>
<p>The main program sets up an examplary routing slip (all the classes are in the one file) and creates three completely independent &quot;processes&quot; (activity hosts) that are each responsible for handling a particular kind of work. The &quot;processes&quot; are linked by a &quot;network&quot; and each kind of activity has an address for forward progress work and one of compensation work. The network resolution is simulated by &apos;Send&quot;.</p> <div class="csharpcode"><pre><span class="lnum"> 1: </span><span class="kwrd">static</span> ActivityHost[] processes;</pre><pre><span class="lnum"> 2: </span>&#xA0;</pre><pre><span class="lnum"> 3: </span><span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)</pre><pre><span class="lnum"> 4: </span>{</pre><pre><span class="lnum"> 5: </span> var routingSlip = <span class="kwrd">new</span> RoutingSlip(<span class="kwrd">new</span> WorkItem[]</pre><pre><span class="lnum"> 6: </span>        {</pre><pre><span class="lnum"> 7: </span> <span class="kwrd">new</span> WorkItem&lt;ReserveCarActivity&gt;(<span class="kwrd">new</span> WorkItemArguments),</pre><pre><span class="lnum"> 8: </span> <span class="kwrd">new</span> WorkItem&lt;ReserveHotelActivity&gt;(<span class="kwrd">new</span> WorkItemArguments),</pre><pre><span class="lnum"> 9: </span> <span class="kwrd">new</span> WorkItem&lt;ReserveFlightActivity&gt;(<span class="kwrd">new</span> WorkItemArguments)</pre><pre><span class="lnum"> 10: </span>        });</pre><pre><span class="lnum"> 11: </span>&#xA0;</pre><pre><span class="lnum"> 12: </span>&#xA0;</pre><pre><span class="lnum"> 13: </span> <span class="rem">// imagine these being completely separate processes with queues between them</span></pre><pre><span class="lnum"> 14: </span> processes = <span class="kwrd">new</span> ActivityHost[]</pre><pre><span class="lnum"> 15: </span>                        {</pre><pre><span class="lnum"> 16: </span> <span class="kwrd">new</span> ActivityHost&lt;ReserveCarActivity&gt;(Send),</pre><pre><span class="lnum"> 17: </span> <span class="kwrd">new</span> ActivityHost&lt;ReserveHotelActivity&gt;(Send),</pre><pre><span class="lnum"> 18: </span> <span class="kwrd">new</span> ActivityHost&lt;ReserveFlightActivity&gt;(Send)</pre><pre><span class="lnum"> 19: </span>                        };</pre><pre><span class="lnum"> 20: </span>&#xA0;</pre><pre><span class="lnum"> 21: </span> <span class="rem">// hand off to the first address</span></pre><pre><span class="lnum"> 22: </span>    Send(routingSlip.ProgressUri, routingSlip);</pre><pre><span class="lnum"> 23: </span>}</pre><pre><span class="lnum"> 24: </span>&#xA0;</pre><pre><span class="lnum"> 25: </span><span class="kwrd">static</span> <span class="kwrd">void</span> Send(Uri uri, RoutingSlip routingSlip)</pre><pre><span class="lnum"> 26: </span>{</pre><pre><span class="lnum"> 27: </span> <span class="rem">// this is effectively the network dispatch</span></pre><pre><span class="lnum"> 28: </span> <span class="kwrd">foreach</span> (var process <span class="kwrd">in</span> processes)</pre><pre><span class="lnum"> 29: </span>    {</pre><pre><span class="lnum"> 30: </span> <span class="kwrd">if</span> (process.AcceptMessage(uri, routingSlip))</pre><pre><span class="lnum"> 31: </span>        {</pre><pre><span class="lnum"> 32: </span> <span class="kwrd">break</span>;</pre><pre><span class="lnum"> 33: </span>        }</pre><pre><span class="lnum"> 34: </span>    }</pre><pre><span class="lnum"> 35: </span>}</pre></div> <p>The activities each implement a reservation step and an undo step. Here&apos;s the one for cars:</p>
<div class="csharpcode"><pre><span class="lnum"> 1: </span><span class="kwrd">class</span> ReserveCarActivity : Activity</pre><pre><span class="lnum"> 2: </span>{</pre><pre><span class="lnum"> 3: </span> <span class="kwrd">static</span> Random rnd = <span class="kwrd">new</span> Random(2);</pre><pre><span class="lnum"> 4: </span>&#xA0;</pre><pre><span class="lnum"> 5: </span> <span class="kwrd">public</span> <span class="kwrd">override</span> WorkLog DoWork(WorkItem workItem)</pre><pre><span class="lnum"> 6: </span>    {</pre><pre><span class="lnum"> 7: </span> Console.WriteLine(<span class="str">&quot;Reserving car&quot;</span>);</pre><pre><span class="lnum"> 8: </span> var car = workItem.Arguments[<span class="str">&quot;vehicleType&quot;</span>];</pre><pre><span class="lnum"> 9: </span>        var reservationId = rnd.Next(100000);</pre><pre><span class="lnum"> 10: </span> Console.WriteLine(<span class="str">&quot;Reserved car {0}&quot;</span>, reservationId);</pre><pre><span class="lnum"> 11: </span> <span class="kwrd">return</span> <span class="kwrd">new</span> WorkLog(<span class="kwrd">this</span>, <span class="kwrd">new</span> WorkResult { { <span class="str">&quot;reservationId&quot;</span>, reservationId } });</pre><pre><span class="lnum"> 12: </span>    }</pre><pre><span class="lnum"> 13: </span>&#xA0;</pre><pre><span class="lnum"> 14: </span> <span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">bool</span> Compensate(WorkLog item, RoutingSlip routingSlip)</pre><pre><span class="lnum"> 15: </span>    {</pre><pre><span class="lnum"> 16: </span> var reservationId = item.Result[<span class="str">&quot;reservationId&quot;</span>];</pre><pre><span class="lnum"> 17: </span> Console.WriteLine(<span class="str">&quot;Cancelled car {0}&quot;</span>, reservationId);</pre><pre><span class="lnum"> 18: </span> <span class="kwrd">return</span> <span class="kwrd">true</span>;</pre><pre><span class="lnum"> 19: </span>    }</pre><pre><span class="lnum"> 20: </span>&#xA0;</pre><pre><span class="lnum"> 21: </span> <span class="kwrd">public</span> <span class="kwrd">override</span> Uri WorkItemQueueAddress</pre><pre><span class="lnum"> 22: </span>    {</pre><pre><span class="lnum"> 23: </span> get { <span class="kwrd">return</span> <span class="kwrd">new</span> Uri(<span class="str">&quot;sb://./carReservations&quot;</span>); }</pre><pre><span class="lnum"> 24: </span>    }</pre><pre><span class="lnum"> 25: </span>&#xA0;</pre><pre><span class="lnum"> 26: </span> <span class="kwrd">public</span> <span class="kwrd">override</span> Uri CompensationQueueAddress</pre><pre><span class="lnum"> 27: </span>    {</pre><pre><span class="lnum"> 28: </span> get { <span class="kwrd">return</span> <span class="kwrd">new</span> Uri(<span class="str">&quot;sb://./carCancellactions&quot;</span>); }</pre><pre><span class="lnum"> 29: </span>    }</pre><pre><span class="lnum"> 30: </span>}</pre></div> <p>The chaining happens solely through the routing slip. The routing slip is &quot;serializable&quot; (it&apos;s not, pretend that it is) and it&apos;s the only piece of information that flows between the collaborating activities. There is no central coordination. All work is local on the nodes and once a node is done, it either hands the routing slip forward (on success) or backward (on failure). For forward progress data, the routing slip has a queue and for backwards items it maintains a stack. The routing slip also handles resolving and invoking whatever the &quot;next&quot; thing to call is on the way forward and backward.</p>
<div class="csharpcode"><pre><span class="lnum"> 1: </span><span class="kwrd">class</span> RoutingSlip</pre><pre><span class="lnum"> 2: </span>{</pre><pre><span class="lnum"> 3: </span> <span class="kwrd">readonly</span> Stack&lt;WorkLog&gt; completedWorkLogs = <span class="kwrd">new</span> Stack&lt;WorkLog&gt;();</pre><pre><span class="lnum"> 4: </span> <span class="kwrd">readonly</span> Queue&lt;WorkItem&gt; nextWorkItem = <span class="kwrd">new</span> Queue&lt;WorkItem&gt;();</pre><pre><span class="lnum"> 5: </span>&#xA0;</pre><pre><span class="lnum"> 6: </span> <span class="kwrd">public</span> RoutingSlip()</pre><pre><span class="lnum"> 7: </span>    {</pre><pre><span class="lnum"> 8: </span>    }</pre><pre><span class="lnum"> 9: </span>&#xA0;</pre><pre><span class="lnum"> 10: </span> <span class="kwrd">public</span> RoutingSlip(IEnumerable&lt;WorkItem&gt; workItems)</pre><pre><span class="lnum"> 11: </span>    {</pre><pre><span class="lnum"> 12: </span> <span class="kwrd">foreach</span> (var workItem <span class="kwrd">in</span> workItems)</pre><pre><span class="lnum"> 13: </span>        {</pre><pre><span class="lnum"> 14: </span> <span class="kwrd">this</span>.nextWorkItem.Enqueue(workItem);</pre><pre><span class="lnum"> 15: </span>        }</pre><pre><span class="lnum"> 16: </span>    }</pre><pre><span class="lnum"> 17: </span>&#xA0;</pre><pre><span class="lnum"> 18: </span> <span class="kwrd">public</span> <span class="kwrd">bool</span> IsCompleted</pre><pre><span class="lnum"> 19: </span>    {</pre><pre><span class="lnum"> 20: </span> get { <span class="kwrd">return</span> <span class="kwrd">this</span>.nextWorkItem.Count == 0; }</pre><pre><span class="lnum"> 21: </span>    }</pre><pre><span class="lnum"> 22: </span>&#xA0;</pre><pre><span class="lnum"> 23: </span> <span class="kwrd">public</span> <span class="kwrd">bool</span> IsInProgress</pre><pre><span class="lnum"> 24: </span>    {</pre><pre><span class="lnum"> 25: </span> get { <span class="kwrd">return</span> <span class="kwrd">this</span>.completedWorkLogs.Count &gt; 0; }</pre><pre><span class="lnum"> 26: </span>    }</pre><pre><span class="lnum"> 27: </span>&#xA0;</pre><pre><span class="lnum"> 28: </span> <span class="kwrd">public</span> <span class="kwrd">bool</span> ProcessNext()</pre><pre><span class="lnum"> 29: </span>    {</pre><pre><span class="lnum"> 30: </span> <span class="kwrd">if</span> (<span class="kwrd">this</span>.IsCompleted)</pre><pre><span class="lnum"> 31: </span>        {</pre><pre><span class="lnum"> 32: </span> <span class="kwrd">throw</span> <span class="kwrd">new</span> InvalidOperationException();</pre><pre><span class="lnum"> 33: </span>        }</pre><pre><span class="lnum"> 34: </span>&#xA0;</pre><pre><span class="lnum"> 35: </span> var currentItem = <span class="kwrd">this</span>.nextWorkItem.Dequeue();</pre><pre><span class="lnum"> 36: </span>        var activity = (Activity)Activator.CreateInstance(currentItem.ActivityType);</pre><pre><span class="lnum"> 37: </span> <span class="kwrd">try</span></pre><pre><span class="lnum"> 38: </span>        {</pre><pre><span class="lnum"> 39: </span>            var result = activity.DoWork(currentItem);</pre><pre><span class="lnum"> 40: </span> <span class="kwrd">if</span> (result != <span class="kwrd">null</span>)</pre><pre><span class="lnum"> 41: </span>            {</pre><pre><span class="lnum"> 42: </span> <span class="kwrd">this</span>.completedWorkLogs.Push(result);</pre><pre><span class="lnum"> 43: </span> <span class="kwrd">return</span> <span class="kwrd">true</span>;</pre><pre><span class="lnum"> 44: </span>            }</pre><pre><span class="lnum"> 45: </span>        }</pre><pre><span class="lnum"> 46: </span> <span class="kwrd">catch</span> (Exception e)</pre><pre><span class="lnum"> 47: </span>        {</pre><pre><span class="lnum"> 48: </span> Console.WriteLine(<span class="str">&quot;Exception {0}&quot;</span>, e.Message);</pre><pre><span class="lnum"> 49: </span>        }</pre><pre><span class="lnum"> 50: </span> <span class="kwrd">return</span> <span class="kwrd">false</span>;</pre><pre><span class="lnum"> 51: </span>    }</pre><pre><span class="lnum"> 52: </span>&#xA0;</pre><pre><span class="lnum"> 53: </span> <span class="kwrd">public</span> Uri ProgressUri</pre><pre><span class="lnum"> 54: </span>    {</pre><pre><span class="lnum"> 55: </span>        get</pre><pre><span class="lnum"> 56: </span>        {</pre><pre><span class="lnum"> 57: </span> <span class="kwrd">if</span> (IsCompleted)</pre><pre><span class="lnum"> 58: </span>            {</pre><pre><span class="lnum"> 59: </span> <span class="kwrd">return</span> <span class="kwrd">null</span>;</pre><pre><span class="lnum"> 60: </span>            }</pre><pre><span class="lnum"> 61: </span> <span class="kwrd">else</span></pre><pre><span class="lnum"> 62: </span>            {</pre><pre><span class="lnum"> 63: </span> <span class="kwrd">return</span></pre><pre><span class="lnum"> 64: </span> ((Activity)Activator.CreateInstance(<span class="kwrd">this</span>.nextWorkItem.Peek().ActivityType)).</pre><pre><span class="lnum"> 65: </span>                        WorkItemQueueAddress;</pre><pre><span class="lnum"> 66: </span>            }</pre><pre><span class="lnum"> 67: </span>        }</pre><pre><span class="lnum"> 68: </span>    }</pre><pre><span class="lnum"> 69: </span>&#xA0;</pre><pre><span class="lnum"> 70: </span> <span class="kwrd">public</span> Uri CompensationUri</pre><pre><span class="lnum"> 71: </span>    {</pre><pre><span class="lnum"> 72: </span>        get</pre><pre><span class="lnum"> 73: </span>        {</pre><pre><span class="lnum"> 74: </span> <span class="kwrd">if</span> (!IsInProgress)</pre><pre><span class="lnum"> 75: </span>            {</pre><pre><span class="lnum"> 76: </span> <span class="kwrd">return</span> <span class="kwrd">null</span>;</pre><pre><span class="lnum"> 77: </span>            }</pre><pre><span class="lnum"> 78: </span> <span class="kwrd">else</span></pre><pre><span class="lnum"> 79: </span>            {</pre><pre><span class="lnum"> 80: </span> <span class="kwrd">return</span></pre><pre><span class="lnum"> 81: </span> ((Activity)Activator.CreateInstance(<span class="kwrd">this</span>.completedWorkLogs.Peek().ActivityType)).</pre><pre><span class="lnum"> 82: </span>                        CompensationQueueAddress;</pre><pre><span class="lnum"> 83: </span>            }</pre><pre><span class="lnum"> 84: </span>        }</pre><pre><span class="lnum"> 85: </span>    }</pre><pre><span class="lnum"> 86: </span>&#xA0;</pre><pre><span class="lnum"> 87: </span> <span class="kwrd">public</span> <span class="kwrd">bool</span> UndoLast()</pre><pre><span class="lnum"> 88: </span>    {</pre><pre><span class="lnum"> 89: </span> <span class="kwrd">if</span> (!<span class="kwrd">this</span>.IsInProgress)</pre><pre><span class="lnum"> 90: </span>        {</pre><pre><span class="lnum"> 91: </span> <span class="kwrd">throw</span> <span class="kwrd">new</span> InvalidOperationException();</pre><pre><span class="lnum"> 92: </span>        }</pre><pre><span class="lnum"> 93: </span>&#xA0;</pre><pre><span class="lnum"> 94: </span> var currentItem = <span class="kwrd">this</span>.completedWorkLogs.Pop();</pre><pre><span class="lnum"> 95: </span>        var activity = (Activity)Activator.CreateInstance(currentItem.ActivityType);</pre><pre><span class="lnum"> 96: </span> <span class="kwrd">try</span></pre><pre><span class="lnum"> 97: </span>        {</pre><pre><span class="lnum"> 98: </span> <span class="kwrd">return</span> activity.Compensate(currentItem, <span class="kwrd">this</span>);</pre><pre><span class="lnum"> 99: </span>        }</pre><pre><span class="lnum"> 100: </span> <span class="kwrd">catch</span> (Exception e)</pre><pre><span class="lnum"> 101: </span>        {</pre><pre><span class="lnum"> 102: </span> Console.WriteLine(<span class="str">&quot;Exception {0}&quot;</span>, e.Message);</pre><pre><span class="lnum"> 103: </span> <span class="kwrd">throw</span>;</pre><pre><span class="lnum"> 104: </span>        }</pre><pre><span class="lnum"> 105: </span>&#xA0;</pre><pre><span class="lnum"> 106: </span>    }</pre><pre><span class="lnum"> 107: </span>}</pre></div> <p>The local work&#xA0; and making the decisions is encapsulated in the ActivityHost, which calls ProcessNext() on the routing slip to resolve the next activity and call its DoWork() function on the way forward or will resolve the last executed activity on the way back and invoke its Compensate() function. Again, there&apos;s nothing centralized here; all that work hinges on the routing slip and the three activities and their execution is completely disjoint.</p>
<div class="csharpcode"><pre><span class="lnum"> 1: </span><span class="kwrd">abstract</span> <span class="kwrd">class</span> ActivityHost</pre><pre><span class="lnum"> 2: </span>{</pre><pre><span class="lnum"> 3: </span>    Action&lt;Uri, RoutingSlip&gt; send;</pre><pre><span class="lnum"> 4: </span>&#xA0;</pre><pre><span class="lnum"> 5: </span> <span class="kwrd">public</span> ActivityHost(Action&lt;Uri, RoutingSlip&gt; send)</pre><pre><span class="lnum"> 6: </span>    {</pre><pre><span class="lnum"> 7: </span> <span class="kwrd">this</span>.send = send;</pre><pre><span class="lnum"> 8: </span>    }</pre><pre><span class="lnum"> 9: </span>&#xA0;</pre><pre><span class="lnum"> 10: </span> <span class="kwrd">public</span> <span class="kwrd">void</span> ProcessForwardMessage(RoutingSlip routingSlip)</pre><pre><span class="lnum"> 11: </span>    {</pre><pre><span class="lnum"> 12: </span> <span class="kwrd">if</span> (!routingSlip.IsCompleted)</pre><pre><span class="lnum"> 13: </span>        {</pre><pre><span class="lnum"> 14: </span> <span class="rem">// if the current step is successful, proceed</span></pre><pre><span class="lnum"> 15: </span> <span class="rem">// otherwise go to the Unwind path</span></pre><pre><span class="lnum"> 16: </span> <span class="kwrd">if</span> (routingSlip.ProcessNext())</pre><pre><span class="lnum"> 17: </span>            {</pre><pre><span class="lnum"> 18: </span> <span class="rem">// recursion stands for passing context via message</span></pre><pre><span class="lnum"> 19: </span> <span class="rem">// the routing slip can be fully serialized and passed</span></pre><pre><span class="lnum"> 20: </span> <span class="rem">// between systems. </span></pre><pre><span class="lnum"> 21: </span> <span class="kwrd">this</span>.send(routingSlip.ProgressUri, routingSlip);</pre><pre><span class="lnum"> 22: </span>            }</pre><pre><span class="lnum"> 23: </span> <span class="kwrd">else</span></pre><pre><span class="lnum"> 24: </span>            {</pre><pre><span class="lnum"> 25: </span> <span class="rem">// pass message to unwind message route</span></pre><pre><span class="lnum"> 26: </span> <span class="kwrd">this</span>.send(routingSlip.CompensationUri, routingSlip);</pre><pre><span class="lnum"> 27: </span>            }</pre><pre><span class="lnum"> 28: </span>        }</pre><pre><span class="lnum"> 29: </span>    }</pre><pre><span class="lnum"> 30: </span>&#xA0;</pre><pre><span class="lnum"> 31: </span> <span class="kwrd">public</span> <span class="kwrd">void</span> ProcessBackwardMessage(RoutingSlip routingSlip)</pre><pre><span class="lnum"> 32: </span>    {</pre><pre><span class="lnum"> 33: </span> <span class="kwrd">if</span> (routingSlip.IsInProgress)</pre><pre><span class="lnum"> 34: </span>        {</pre><pre><span class="lnum"> 35: </span> <span class="rem">// UndoLast can put new work on the routing slip</span></pre><pre><span class="lnum"> 36: </span> <span class="rem">// and return false to go back on the forward </span></pre><pre><span class="lnum"> 37: </span> <span class="rem">// path</span></pre><pre><span class="lnum"> 38: </span> <span class="kwrd">if</span> (routingSlip.UndoLast())</pre><pre><span class="lnum"> 39: </span>            {</pre><pre><span class="lnum"> 40: </span> <span class="rem">// recursion stands for passing context via message</span></pre><pre><span class="lnum"> 41: </span> <span class="rem">// the routing slip can be fully serialized and passed</span></pre><pre><span class="lnum"> 42: </span> <span class="rem">// between systems </span></pre><pre><span class="lnum"> 43: </span> <span class="kwrd">this</span>.send(routingSlip.CompensationUri, routingSlip);</pre><pre><span class="lnum"> 44: </span>            }</pre><pre><span class="lnum"> 45: </span> <span class="kwrd">else</span></pre><pre><span class="lnum"> 46: </span>            {</pre><pre><span class="lnum"> 47: </span> <span class="kwrd">this</span>.send(routingSlip.ProgressUri, routingSlip);</pre><pre><span class="lnum"> 48: </span>            }</pre><pre><span class="lnum"> 49: </span>        }</pre><pre><span class="lnum"> 50: </span>    }</pre><pre><span class="lnum"> 51: </span>&#xA0;</pre><pre><span class="lnum"> 52: </span> <span class="kwrd">public</span> <span class="kwrd">abstract</span> <span class="kwrd">bool</span> AcceptMessage(Uri uri, RoutingSlip routingSlip);</pre><pre><span class="lnum"> 53: </span>}</pre></div> <p>That&apos;s a Saga.</p> </section>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>