<!DOCTYPE html>
<html lang="en">
<head>
    <title>
What&#x27;s behind the hype about Blazor? - Stack Overflow Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="What&#x27;s behind the hype about Blazor? - Stack Overflow Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Chris Sainty"/>
    <meta property="og:description" content="Blazor is a new client-side UI framework from the ASP.NET team. Its big selling point is the ability to write rich web UI experiences using HTML, CSS, and C# instead of JavaScript&#x2014;something a lot of developers have been dreaming of."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://stackoverflow.blog/2020/02/26/whats-behind-the-hype-about-blazor/?hss_channel=tw-4083531"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - What&#x27;s behind the hype about Blazor? - Stack Overflow Blog</title>
<div class="readable">
        <h1>What&#x27;s behind the hype about Blazor? - Stack Overflow Blog</h1>
            <div>by Chris Sainty</div>
            <div>Reading time: 12-15 minutes</div>
        <div>Posted here: 13 Mar 2020</div>
        <p><a href="https://stackoverflow.blog/2020/02/26/whats-behind-the-hype-about-blazor/?hss_channel=tw-4083531">https://stackoverflow.blog/2020/02/26/whats-behind-the-hype-about-blazor/?hss_channel=tw-4083531</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
    
<p>If you’ve been keeping up with the latest developments in the .NET world over the past year or two, you’ve probably heard the word Blazor mentioned once or twice. Blazor is a new client-side UI framework from the<a href="http://asp.net/"> </a>ASP.NET team. Its big selling point is the ability to write rich web UI experiences using HTML, CSS, and C# instead of JavaScript—something a lot of developers have been dreaming of.</p>



<p>While JavaScript has been the defacto standard for front-end web development since its inception, we’ve never really seemed to be happy with it. I mean, how many superset or transpile to JavaScript languages have sprung up over the years to help improve JavaScript and make it more maintainable? CoffeeScript, Dart, Elm and Scala—to name but a few.&nbsp;</p>



<p>Looking at the <a href="https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted">most loved</a> languages, TypeScript, a language designed by the legendary <a href="https://en.wikipedia.org/wiki/Anders_Hejlsberg">Anders Hejlsberg</a>, tops the list. The same man who designed C#, no less. It adds features such as interfaces, classes, compile time type-checking, even generics. However, all those features and more already exist in C#, and have done for years. C# is a powerful, flexible, feature rich language that is easy to learn.</p>



<p>But Blazor has already started to show it has potential as a highly efficient and productive programming model outside of its original design—as a direct competitor to JavaScript single page application (SPA) frameworks.</p>



<p>Microsoft already has multiple experiments going on with Blazor, trialling it with desktop applications using <a href="https://www.electronjs.org/">Electron</a> and <a href="https://www.nuget.org/packages/WebWindow">WebWindow</a> (an experimental lightweight alternative to Electron). But most recently, for native mobile app development where the Blazor programming model is mixed with native <a href="https://dotnet.microsoft.com/apps/xamarin">Xamarin</a> forms controls.</p>



<p>Could we be seeing the start of a single unified UI framework for building any type of application with .NET, be it web, desktop, or mobile? I don’t know about you, but I certainly find that an exciting prospect.</p>



<h2><strong>What makes Blazor so flexible?</strong></h2>



<p>To answer this question, we need to understand how Blazor has been architected.</p>



<p>Essentially, Blazor has a separation between how it calculates UI changes (app/component model) and how those changes are applied (renderer). This sets Blazor apart from other UI frameworks such as Angular or ReactJS/React Native that can only create web technology based UIs. By using different renderers Blazor is able to create not only web based UIs, but also native mobile UIs as well.</p>



<p>This does require components to be authored differently, so components written for web renderers can’t be used with native mobile renderers. However, the programming model is the same. Meaning once developers are familiar with it, they can create UIs using any renderer.</p>



<figure><img src="https://lh5.googleusercontent.com/7qSVTvfd6ZYFSsdvRwk_33JmqzlfZlFdF1VVncQYcbR3qSYrrJLd5NkjKD-hnOTcJT103JVlYQT_1dmgnO9TONczizPWqYXs2622cNz2CAiQVBEXlmt4jK8Of0FpFo5rHSHn14Lb" alt=""></figure>



<h3><strong>Render/Hosting Model</strong></h3>



<p>At its core, Blazor’s app/component model is responsible for calculating UI changes, but you can use different renderers to control how the UI is actually displayed and updated. These renderers are more commonly referred to as hosting models. At the time of writing, there are four hosting models for Blazor in various stages of development.<br></p>



<p><strong>Blazor Server </strong>(Remote Renderer)</p>



<ul><li>Platform: <strong>Web</strong></li><li>Status – <strong>GA/Production Supported</strong></li></ul>



<p><strong>Blazor WebAssembly </strong>(WebAssembly Renderer)</p>



<ul><li>Platform: <strong>Web</strong></li><li>Status: <strong>Preview (Committed Product)</strong></li></ul>



<p><strong>Blazor Electron </strong>(Electron Renderer)</p>



<ul><li>Platform: <strong>Desktop (Windows, Mac, and Linux)</strong></li><li>Status: <strong>Experimental (Not Committed)</strong></li></ul>



<p><strong>Mobile Blazor Bindings</strong> (MobileBlazorBindings Renderer)</p>



<ul><li>Platform: <strong>Mobile (iOS and Android)</strong></li><li>Status: <strong>Experimental (Not Committed)</strong></li></ul>



<p>Blazor Server is the only production supported model at the time of writing. Blazor WebAssembly is due for release around May 2020—I would expect this could be the big announcement at <a href="https://www.microsoft.com/en-us/build">Build</a>. Blazor Electron and Mobile Blazor Bindings are both marked as experimental and Microsoft hasn’t yet committed to shipping these.</p>



<h3><strong>App/Component Model</strong></h3>



<p>This is the engine room of the framework. Here we can find all the non-UI specific elements which make Blazor work. The programming model, routing and navigation, and the render tree, which is Blazor’s mechanism for calculating UI changes.</p>



<p>The part I want to focus on though is the programming model. Out of the four hosting models I talked about above, the first three have one thing in common, they all understand web standards. Components authored to target these hosting models will be using HTML and CSS. But the fourth model, Mobile Blazor bindings, doesn’t understand web standards at all. Applications built for this hosting model will need to have their components written using native mobile controls.</p>



<p>To give a more visual example, let’s look at the same component written for Blazor WebAssembly, which uses a web standards compliant renderer, vs Mobile Blazor Bindings, which uses the non-web standards-based renderer.</p>



<pre><span> </span><span>// WebAssembly Renderer</span><span>

</span><span>&lt;div&gt;</span><span>
 </span><span>&lt;p&gt;</span><span>Current</span><span> count</span><span>:</span><span> </span><span>@currentCount</span><span>&lt;/</span><span>p</span><span>&gt;</span><span>
 </span><span>&lt;</span><span>button </span><span>class</span><span>=</span><span>"btn btn-primary"</span><span> </span><span>@onclick</span><span>=</span><span>"IncrementCount"</span><span>&gt;</span><span>Click</span><span> me</span><span>&lt;/</span><span>button</span><span>&gt;</span><span>
</span><span>&lt;/</span><span>div</span><span>&gt;</span><span>

</span><span>@code</span><span> </span><span>{</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>int</span><span> currentCount </span><span>=</span><span> </span><span>0</span><span>;</span><span>

&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>void</span><span> </span><span>IncrementCount</span><span>()</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span>{</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentCount</span><span>++;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span>}</span><span>
</span><span>}</span><span>

</span><span>// MobileBlazorBindings Renderer</span><span>

</span><span>&lt;</span><span>StackLayout</span><span>&gt;</span><span>
 </span><span>&lt;</span><span>Label</span><span> </span><span>FontSize</span><span>=</span><span>"30"</span><span> </span><span>Text</span><span>=</span><span>"@($"</span><span>Current</span><span> count</span><span>:</span><span> </span><span>{</span><span>currentCount</span><span>}</span><span>")"</span><span> </span><span>/&gt;</span><span>
 </span><span>&lt;</span><span>Button</span><span> </span><span>Text</span><span>=</span><span>"Click me"</span><span> </span><span>OnClick</span><span>=</span><span>"@IncrementCount"</span><span> </span><span>/&gt;</span><span>
</span><span>&lt;/</span><span>StackLayout</span><span>&gt;</span><span>

</span><span>@code</span><span> </span><span>{</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>int</span><span> currentCount </span><span>=</span><span> </span><span>0</span><span>;</span><span>

&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>void</span><span> </span><span>IncrementCount</span><span>()</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span>{</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentCount</span><span>++;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span>}</span><span>
</span><span>}</span><span>
</span></pre>



<p>It’s easy to see the differences between the two code samples, but what I want you to focus on the similarities.</p>



<p>Both samples have a markup section and a code block. In fact, the code blocks are identical between the samples. They each have an `OnClick` event with a specified handler and both use expressions to output the value of the current count field.</p>



<p>The point I’m making here is the programming model is the same. And this is the power of Blazor, learn the programming model and, save a few tweaks here and there, you’re going to be able to produce UI for any type of app, on any platform—that’s something we’ve not been able to do before with .NET.</p>



<p>Now we have a bit more of an understanding about how Blazor is put together, I want to talk a bit about the two main hosting models, Blazor Server and Blazor WebAssembly.</p>



<h2><strong>Blazor Server</strong></h2>



<p>The Blazor Server hosting model is currently the only production supported option for Blazor development right now. It was released back in September 2019 with .NET Core 3, during .NET Conf.</p>



<figure><img src="https://lh4.googleusercontent.com/jWAcExuurXUSaF6s4P7JgHvJHSoRpZecXTK9OcryYo3EXXH1L4GGt-zB2Lro4dTytVNL-pw7-PpEX1JUAR939hHnIHe3AJWVSKGQnINVCqSdS_Rm_XX5hTLkipo3GbAlrwFVLUlw" alt=""></figure>



<p>In this model, the Blazor application runs on the server on top of the full .NET Core runtime. When the user loads the application a small JavaScript file is downloaded which establishes a real-time, two-way <a href="https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-3.1">SignalR</a> connection with the server. Any interaction that the user has with the app is then transmitted back to the server over the SignalR connection for the server to process. After the server is done, any UI updates are transmitted back to the client and applied to the DOM.</p>



<p>Now, I know what you’re thinking. There is no way that that can be performant, all of those interactions and UI updates being constantly sent back and forth. But I think you’ll actually be surprised.</p>



<p>The team did some load testing on Blazor Server to establish what it could and couldn’t deal with and this is what they found.</p>



<p><strong>Test 1 – Standard D1 v2 instance on Azure (1vCPU &amp; 3.5GB memory)</strong></p>



<p>The application could handle <strong>over 5000 concurrent active users</strong> without any visible degradation in performance.</p>



<p><strong>Test 2 – Standard D3 v2 instance on Azure (4vCPU &amp; 14GB memory)</strong></p>



<p>The application could handle <strong>over 20,000 concurrent active users</strong> without any visible degradation in performance.</p>



<p>These are pretty impressive figures, I think you’ll agree. The major findings which came out of these experiments were that memory and latency are the main bottlenecks of Blazor Server applications. If latency got above 200ms then performance took a hit and scale was limited by the available memory on the box.</p>



<h3><strong>Benefits</strong></h3>



<ul><li>Runs on the full .NET Core runtime</li><li>Fast development cycle</li><li>Small download size</li><li>Code is kept on the server and not downloaded to the client</li></ul>



<h3><strong>Drawbacks</strong></h3>



<ul><li>Doesn’t work well in high latency environments</li><li>No offline support—requires a constant connection to the server</li><li>Heavy resource demand on the server</li></ul>



<h3><strong>Ideal use case</strong></h3>



<p>I honestly think Blazor Server can be used for lots of scenarios, but its niche will be in intranet applications or low demand public-facing apps. The speed of development with this hosting model is obscenely quick, and I mean fast, due to everything being on the server. There is no need for separate API projects, for example, you can just consume application services directly in your components. I was sceptical of Blazor Server at first, but I have to say, I have been really surprised with what it can do.</p>



<h2><strong>Blazor WebAssembly</strong></h2>



<p>This is the big one, the hosting model that usually gets most interest, and for good reason. This model offers a direct competitor to JavaScript SPAs such as Angular, VueJS, and React.</p>



<p>By using WebAssembly, we are able to write our UI logic using C# and not JavaScript. It’s currently in preview and due for release around May 2020.</p>



<figure><img src="https://lh3.googleusercontent.com/mOlbeBLFNYCEl6CdctXBoadoKK3JRV2wONEStZmheeb0vJXwMPC8FEjDjjmvbH9Hoq_x2G8I03xX8hKlKdXi8azoWX5YXqAfPBLM1aHTWqjj_chj4l7FUjsQMDyT8rvOe55giwRK" alt=""></figure>



<p>A version of the <a href="https://www.mono-project.com/">Mono .NET runtime</a>, compiled to WebAssembly, is downloaded to the client’s browser along with the application DLLs and any dependencies. Once everything is in the browser, the Mono runtime is bootstrapped, and it, in turn, loads and executes the application DLLs.</p>



<p>I’m going to address the first question that usually arises from hearing the above explanation, what is the download size? Well, the current preview weighs in at around 2.4mb, that’s pretty impressive considering there’s a .NET runtime involved. But I appreciate that this isn’t amazing when compared to some JavaScript frameworks. By the time the WebAssembly hosting model is released in May, the team hopes to cut that size significantly. The first prototype of Blazor used a very compact .NET runtime, which compiled to just 60k of WebAssembly code. I believe major size improvements are just a matter of time.</p>



<p>Currently, Blazor WebAssembly uses interpreted mode to load and run your application. In this mode, the Mono IL interpreter executes your applications .NET DLLs inside the browser. The only part of the process that is compiled to WebAssembly is the Mono runtime. In the future, the team are looking to allow developers to choose if their apps, or more likely parts of their apps, will be compiled to WebAssembly as well—This is known as AOT or Ahead Of Time compilation. The benefit of this mode is performance, the trade-off is a larger download size.</p>



<h3><strong>Benefits</strong></h3>



<ul><li>Compiles to static files, meaning there is no need for a .NET runtime on the server</li><li>Work is offloaded from the server to the client</li><li>Apps can be run in an offline state</li><li>Codesharing, C# objects can be shared between client and server easily</li></ul>



<h3><strong>Drawbacks</strong></h3>



<ul><li>Payload. Right now if you create a fresh new Blazor project, it weighs in at around 2.4mb. The team hopes to cut this down significantly come May.</li><li>Load time. Due to download size, devices on poor connections can experience longer initial load times.</li><li>Restricted runtime. Apps have to operate in the browser’s sandbox and are subject to the same security restrictions as any JavaScript application.</li></ul>



<h3><strong>Ideal use case</strong></h3>



<p>Blazor WebAssembly is built to be a direct competitor to modern JavaScript frameworks. Therefore, anywhere you would be looking to use one of those frameworks, you could consider Blazor. It’s also trivial to make Blazor WebAssembly apps into PWAs (Progressive Web Application). In fact, there will be an out of the box template for this coming in May.</p>



<p>It’s also important to point out that using Blazor WebAssembly doesn’t require you to use .NET on the server. Meaning if you have a backend written in Node, PHP, or Rails you can happily use Blazor as the frontend without any issues as Blazor WebAssembly compiles to static files.</p>



<h2><strong>What’s the future of Blazor?</strong></h2>



<p>With one hosting model in production already and another on the way shortly, let’s finish by turning our attention to the future.</p>



<p>Where do I see Blazor going? Coming back to my earlier thought around Blazor becoming a single UI framework for any .NET application. I think this is where Blazor is heading, in my opinion. If all of the current hosting models for Blazor move into production, and right now I can’t see why they wouldn’t, developers will have the option to learn a single programming model which they can use to create UIs anywhere. This is a big deal.</p>



<p>At a time where there are lots of discussions around the barrier for entry to .NET, with so many choices new developers to the platform have to face, Blazor could offer clarity when it comes to UI, a single programming model, learnt once and applied anywhere. For me, that’s the hype with Blazor.<br></p><p>
    Tags: <a href="https://stackoverflow.blog/tag/blazor/" rel="tag">blazor</a>, <a href="https://stackoverflow.blog/tag/bulletin/" rel="tag">bulletin</a>, <a href="https://stackoverflow.blog/tag/c-sharp/" rel="tag">c sharp</a>, <a href="https://stackoverflow.blog/tag/dot-net/" rel="tag">dot net</a>, <a href="https://stackoverflow.blog/tag/stackoverflow/" rel="tag">stackoverflow</a>, <a href="https://stackoverflow.blog/tag/web-dev/" rel="tag">web dev</a>  </p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>