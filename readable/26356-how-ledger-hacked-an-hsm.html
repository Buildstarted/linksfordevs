<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How Ledger Hacked an HSM -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>How Ledger Hacked an HSM</h1><div><div class="twelve columns"><p>The announcement yesterday of <a href="https://www.blackhat.com/us-19/briefings/schedule/?hootPostID=db681a52c6a321681e1f9281b5124457#everybody-be-cool-this-is-a-robbery-16233">this talk about HSM hacking</a> on the BlackHat 2019 program has caused a stir, and for good reason: the authors claim to have discovered remote unauthenticated attacks giving full control of an HSM and complete access to keys and secrets stored on it.</p><p>At the moment very few details are available in English about how this attack by researchers from Ledger was carried out, but fortunately for Francophones, this work was presented in detail earlier this week at the annual French security conference <a href="https://www.sstic.org/2019/news/">SSTIC</a>. French speakers can watch the <a href="https://www.sstic.org/2019/presentation/hsm/">video</a> or <a href="https://www.sstic.org/media/SSTIC2019/SSTIC-actes/hsm/SSTIC2019-Article-hsm-campana_bedrune_neNSDyL.pdf">read the paper</a> in the proceedings.</p><h3>A brief summary</h3><p>For the not-so-Francophone, the bilingual team at Cryptosense have translated a brief summary of what the Ledger researchers Gabriel Campana and Jean-Baptiste B√©drune did. There were plenty of technical challenges to solve along the way, in what was clearly a thorough and professional piece of vulnerability research:</p><ol><li>They started by using legitimate SDK access to their test HSM to upload a firmware module that would give them a shell inside the HSM. Note that this SDK access was used to discover the attacks, but is not necessary to exploit them.</li><li>They then used the shell to run a fuzzer on the internal implementation of PKCS#11 commands to find reliable, exploitable buffer overflows.</li><li>They checked they could exploit these buffer overflows from outside the HSM, i.e. by just calling the PKCS#11 driver from the host machine</li><li>They then wrote a payload that would override access control and, via another issue in the HSM, allow them to upload arbitrary (unsigned) firmware. It‚Äôs important to note that this backdoor is persistent ‚Äì a subsequent update will not fix it.</li><li>They then wrote a module that would dump all the HSM secrets, and uploaded it to the HSM.</li></ol><p>The article in the SSTIC proceedings gives plenty more information (and a recommendation to read the <a href="https://cryptosense.com/whitepapers/hsm-whitepaper/">Cryptosense HSM security whitepaper</a> ‚Äì thanks üôÇ ). It includes cryptographic attacks (flaws in PKCS#1v1.5 signature verification) and other goodies. It‚Äôll be well worth attending the talk at Blackhat in August.</p><h3>What next?</h3><p>The vulnerabilities have now been patched. The manufacturer is not named in the presentation, but it may be possible to work it out by, for example, looking at the <a href="https://safenet.gemalto.com/technical-support/security-updates/?LangType=1049">recent security announcements of large HSM manufacturers</a>. <i>Update: on June 10th Gemalto added an update to confirm that the affected HSM is the Safenet Protect Server PSI-E2/PSE2</i>.</p><h3>Could the vulnerability have been exploited?</h3><p>Certainly well-funded vulnerability research teams at state-level intelligence agencies could have carried out similar work and discovered this attack. The disruption caused to a target country‚Äôs financial system by revealing certain secret keys would be pretty interesting to those looking to carry out cyber warfare. Perhaps the most concerning part of the attack is that the firmware update backdoor is persistent. There could be live HSMs deployed in critical infrastructure now containing similar backdoors.</p><h3>What about other HSMs?</h3><p>As an easy first step, HSM users can check for buffer overflows that can be exploited from outside the HSM (step 3 of the ‚Äúkill chain‚Äù above) using our <a href="https://cryptosense.com/analyzer/pkcs11-security/">PKCS#11 fuzzer</a>.</p><p>In order to detect internal memory corruption, we recently added an option to stop the fuzzing when the API gives a result inconsistent with a previous one ‚Äì this was a result of direct requests from our users who were encountering such issues with multiple manufacturers‚Äô products. While this is only one step in the chain, it is the only one amenable to repeatable, automated testing without access to HSM internals.</p><p>Perhaps one day NIST certifications will require HSMs to resist the kind of attack described here, but today you have to either do the vulnerability research yourself (maybe with the help of our tools), or just keep your fingers crossed.</p><p>Read more about HSM attacks in our <a href="https://cryptosense.com/whitepapers">Whitepaper</a>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>