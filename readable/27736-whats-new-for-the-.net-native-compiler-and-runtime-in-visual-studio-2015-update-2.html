<!DOCTYPE html>
<html lang="en">
<head>
    <title>
What&#x2019;s new for the .NET Native Compiler and Runtime in Visual Studio 2015 Update 2 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>What’s new for the .NET Native Compiler and Runtime in Visual Studio 2015 Update 2</h1><div><div class="entry-content col-12 sharepostcontent"><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://secure.gravatar.com/avatar/af95447e1440ce4953514b3399e21b32?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 photo avatar-default"></div></div></div><p>April 18th, 2016</p><p>Last week&nbsp;we released an update to the <a href="https://blogs.msdn.microsoft.com/visualstudio/2016/04/11/whats-new-in-vs-2015-update-2-for-universal-windows-developers/" target="_blank">Visual Studio 2015 Tools for Universal Windows Apps (UWA)</a>. The release includes improvements across the libraries, runtime, and compiler. This means that development is faster and applications will be more responsive and easier to maintain. Applications such as <a href="https://www.microsoft.com/en-us/store/apps/ncaa-march-madness-live/9wzdncrfjcmh" target="_blank">NCAA March Madness Live</a> and <a href="https://www.microsoft.com/en-us/store/apps/tunein-radio/9wzdncrfj3sf" target="_blank">TuneIn Radio</a> are already available in the Store built using our new .NET Native tools!</p><p>The latest version for Visual Studio 2015 Tools for Universal Windows Apps has been released as an update for Visual Studio 2015 Update 2. It can be obtained by installing <a href="http://go.microsoft.com/fwlink/?LinkId=691129" target="_blank">Visual Studio 2015 Update 2</a> or modifying Visual Studio 2015 Update 2 if it is already installed. When prompted with the list of features to install, validate that <strong>Tools (1.3.1) and Windows 10 SDK (10.0.10586)</strong> has been checked, which is located under the <strong>Universal Windows App Development Tools</strong> section. Once the Visual Studio 2015 Tools for UWA update has been installed, existing projects will use the latest compiler and runtime after they have been recompiled.</p><h3>Modify Visual Studio 2015 Update 2</h3><p>The following steps can be taken to modify Visual Studio 2015 Update 2 and install the latest UWA tools:</p><ul><li>Select Next and validate the Selected Features are correct.</li><li>Select Update.</li></ul><h3>Update .NET Core Libraries</h3><p>The .NET Core libraries are distributed as NuGet packages at NuGet.org. Here’s how you can get the latest .NET Core packages:</p><ul><li>Navigate to the NuGet Package Manager which can be found by going to ToolsNuGet Package ManagerManage NuGet Packages for Solution.</li><li>Select the Updates tab.</li><li>Select the Microsoft.NETCore.UniversalWindowsPlatform NuGet package (the UWP metapackage for .NET Core) on the left and check the projects that are being upgraded.</li><li>Ensure that the Version is listed as Latest Stable 5.1.0.</li><li>Select Install.</li></ul><p><a href="http://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2016/04/UWP_NetCore_NuGet_Update.png"></a><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2016/04/UWP_NetCore_NuGet_Update.png"><img class="alignnone size-full wp-image-5635" src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2016/04/UWP_NetCore_NuGet_Update.png" alt="uwp_netcore_nuget_update" width="1138" height="311" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2016/04/UWP_NetCore_NuGet_Update.png 1138w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2016/04/UWP_NetCore_NuGet_Update-300x82.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2016/04/UWP_NetCore_NuGet_Update-768x210.png 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2016/04/UWP_NetCore_NuGet_Update-1024x280.png 1024w" sizes="(max-width: 1138px) 100vw, 1138px"></a></p><h2 id="what-s-new-in-the-net-native-compiler-and-runtime">What’s New in the .NET Native Compiler and Runtime</h2><h3 id="better-reflection-support-universal-shared-generics">Better Reflection Support – Universal Shared Generics</h3><p>.NET apps use reflection a lot, either directly or as part of a library that they use. Reflection will now work “out of the box” for many more apps. We love reflection as much as you do and want you to enjoy using it with .NET Native!</p><p>Reflection enables you to inspect or instantiate types in a late-bound fashion (e.g. not using new). That’s very useful for loosely coupled architectures or for dynamic scenarios. Dynamism is a challenge when compiling to native code, since all of the code must be known and compiled at compile-time. One dynamic scenario is making new generic types at runtime.</p><p>We call List&lt;T&gt; an&nbsp;open type&nbsp;since it needs the T defined. We call List&lt;MyValueType&gt; a&nbsp;closed type since T has been defined. Within a program, we call these closed types&nbsp;generic instantiations. List&lt;MyValueType&gt; can be thought of as a third type, neither List&lt;T&gt; or MyValueType, but the&nbsp;generic instantiation&nbsp;of that combination.</p><p>Generic types are a combination of shape (members) and behavior (method bodies). The shape and behavior is compiled to native code. The native code for List&lt;MyValueType&gt; and List&lt;MyReferenceType&gt; are not the same. That means that the .NET Native compiler must find all generic instantiations so that there is code to execute for each generic at runtime. The wonderful expressiveness of the reflection APIs makes finding all of the generic instantiations via static analysis quite difficult. In particular, code using Type.MakeGenericType and MethodInfo.MakeGenericMethod can be arbitrarily complex.</p><p>This challenge led us to adopt a new path for native compiling generics. We came to the conclusion that we needed a more general purpose way to compose generics at runtime. We call this new feature Universal Shared Generics (USG). Most generics will still have highly optimized code that is specific to their composition. However, in the case where type specific code has not been generated, a USG version will be available.</p><h3 id="better-stack-traces-with-hockeyapp">Better Stack Traces with HockeyApp</h3><p>With this release and <a href="http://hockeyapp.net/features/" target="_blank">HockeyApp</a>, you can now get high fidelity, actionable stack traces from their applications in production. We’ve done work to ensure client side collection is more robust and that the HockeyApp backend can properly generate human readable stacks. This functionality was announced at <a href="https://channel9.msdn.com/Events/Build/2016/P463" target="_blank">//build</a> and is now available. It’s fast and easy to get started with <a href="http://support.hockeyapp.net/kb/client-integration-windows-and-windows-phone/crash-reporting-for-uwp" target="_blank">HockeyApp for UWP</a>.</p><h3 id="faster-winrt-interop">Faster WinRT Interop</h3><p>We’ve made WinRT interop faster and have seen speedups as high as 8x in our lab compared to the UWP 1.2 tools. This will be particularly useful for applications that have pages with a high number of XAML elements as well as IoT stream processing scenarios.</p><h3 id="faster-native-code">Faster Native Code</h3><p>A number of incremental and feature-level improvements to code quality are included in this release. Targeted improvements include, but aren’t limited to:</p><ul><li>Improved <a href="https://blogs.msdn.microsoft.com/nativeconcurrency/2012/04/12/what-is-vectorization/" target="_blank">auto-vectorization</a></li><li>Reduced overhead of enumeration of <code>IEnumerable&lt;T&gt;</code> collections</li><li>Whole program inlining analysis</li><li><a href="https://msdn.microsoft.com/en-us/library/e7k32f4k.aspx" target="_blank">Profile Guided Optimization</a> (PGO) of the <a href="https://blogs.msdn.microsoft.com/dotnet/2015/09/28/whats-new-for-net-and-uwp-in-win10-tools-1-1/" target="_blank">SharedFramework</a> Together, these features lead to reduced working set, smaller code size, and better generated code quality for .NET UWP applications.</li></ul><p>Previous releases of the .NET Native compiler utilized the same inlining optimizer as the CLR JIT compiler. Because the JIT compiler is tuned to generate code quickly, it makes local decisions about which methods to inline. Ahead-of-time compilation allows the .NET Native compiler to evaluate inlining decisions while considering the full scope of your application. With 1.3.1 this is now done using the same whole program inlining engine used for high performance C++ applications, enabling significant improvement for many scenarios.</p><p><a href="https://msdn.microsoft.com/en-us/library/e7k32f4k.aspx" target="_blank">Profile-Guided Optimizations</a> allows the compiler make better code generation decisions by giving it information about what happens in an application at runtime. We have applied PGO optimizations to the SharedLibrary component using data we’ve collected from a variety of UWP applications. We’re excited to enable this class of optimizations for general usage in a future version of the UWP tools.</p><p>Sharing the same optimizing backend as the C++ compiler allows .NET Native to use the advanced optimizing technologies that have been developed for high performance C++ code. We will continue to light up features that this integration allows.</p><h3 id="development-time-compiler-improvements">Development Time Compiler Improvements</h3><p>Many of the internal data structures and algorithms of the .NET Native compiler are now much more efficient. Most apps will see a reduction in the memory used by the compiler and a small reduction in compile time. For a subset of applications and libraries, these improvements are the difference between compiling successfully and taking <a href="https://github.com/mathnet/mathnet-numerics/issues/361" target="_blank">hours and hours to build</a>. We’ll continue to make optimizations and improvements to accommodate the wide variety and scale of code in the growing UWP ecosystem.</p><h2 id="provide-feedback">Provide Feedback</h2><p>We want to thank you for your feedback as it has been instrumental in guiding our work! Please continue to send questions and suggestions to <a href="mailto:dotnetnative@microsoft.com" target="_blank">dotnetnative@microsoft.com</a>. We look forward to hearing from you and seeing what great things you will build.</p><p><em>This post was written by Matthew Whilden, Software Engineer and Stacey Haffner, Program Manager on the .NET team.</em></p><div class="authorinfoarea"></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>