<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Announcing .NET Core 3.1 | .NET Blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Announcing .NET Core 3.1 | .NET Blog</h1><div><div class="entry-content col-12 sharepostcontent"><h1 class="entry-title">Announcing .NET Core 3.1</h1><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://secure.gravatar.com/avatar/37f91ebe219df737566a4dc7cdd53b68?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 photo avatar-default"><p>Richard</p></div></div></div><p>December 3rd, 2019</p><h1>Announcing .NET Core 3.1</h1><p>We’re excited to announce the release of .NET Core 3.1. It’s really just a small set of fixes and refinements over <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/">.NET Core 3.0</a>, which we released just over two months ago. The most important feature is that .NET Core 3.1 is an <a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core">long-term supported (LTS) release</a> and will be supported for three years. As we’ve done in the past, we wanted to take our time before releasing the next LTS release. The extra two months (after .NET Core 3.0) allowed us to select and implement the right set of improvements over what was already a very stable base. .NET Core 3.1 is now ready to be used wherever your imagination or business need takes it.</p><p>You can <a href="https://dotnet.microsoft.com/download/dotnet-core/3.1">download .NET Core 3.1</a>, for Windows, macOS, and Linux:</p><p><a href="https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-core-3-1/">ASP.NET Core</a> and <a href="https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-3-1-and-entity-framework-6-4/">EF Core</a> are also being released today.</p><p><a href="https://devblogs.microsoft.com/visualstudio/tis-the-season-visual-studio-2019/">Visual Studio 2019 16.4</a> was also released today and includes .NET Core 3.1. It is a required update to use .NET Core 3.1 with Visual Studio. For Visual Studio 2019 users, we recommend simply updating Visual Studio to 16.4 and instead of separately downloading .NET Core 3.1.</p><p>Visual Studio for Mac also supports and includes .NET Core 3.1, in the Visual Studio for Mac 8.4 Preview channel. You will need to opt into the Preview channel to use .NET Core 3.1.</p><p>Release notes:</p><p>The changes in .NET Core 3.1 were primarily focussed on <a href="https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-core-3-1/">Blazor</a> and <a href="https://devblogs.microsoft.com/dotnet/net-core-3-for-windows-desktop/">Windows Desktop</a>, the two new and large additions in .NET Core 3.0. This includes support for C++/CLI, which has been a regular request for developers targeting Windows.</p><p>Before we take a look at what’s new in .NET Core 3.1, let’s take a quick look at the key improvements in <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/">.NET Core 3.0</a>, which is the bulk of what’s important to consider for .NET Core 3.1.</p><h2>Recap of .NET Core 3.0 Improvements</h2><p>The following key improvements were delivered in .NET Core 3.0. We’ve already heard from <a href="https://twitter.com/Nick_Craver/status/1190217625017696256">developers of big sites</a> that it is working super well for them.</p><ul><li><strong>.NET Core 3.0 is already battle-tested</strong> by being hosted for months at <a href="https://dotnet.microsoft.com/">dot.net</a> and on <a href="https://www.bing.com/version">Bing.com</a>. Many other Microsoft teams will soon be deploying large workloads on .NET Core 3.1 in production.</li><li><strong>Performance is greatly improved</strong> across many components and is described in detail at <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/">Performance Improvements in .NET Core 3.0</a> and <a href="https://devblogs.microsoft.com/dotnet/hardware-intrinsics-in-net-core/">Hardware Intrinsics in .NET Core</a>.</li><li><strong>C# 8</strong> add async streams, range/index, <a href="https://devblogs.microsoft.com/dotnet/do-more-with-patterns-in-c-8-0/">more patterns</a>, and <a href="https://devblogs.microsoft.com/dotnet/embracing-nullable-reference-types/">nullable reference types</a>. Nullable enables you to directly target the flaws in code that lead to <code>NullReferenceException</code>. The lowest layer of the framework libraries has been annotated, so that you know when to expect <code>null</code>.</li><li><strong>F# 4.7</strong> focuses on making some thing easier with implicit <code>yield</code> expressions and some syntax relaxations. It also includes support for <code>LangVersion</code>, and ships with <code>nameof</code> and opening of static classes in preview. The F# Core Library now also targets .NET Standard 2.0. You can read more at <a href="https://devblogs.microsoft.com/dotnet/announcing-f-4-7/">Announcing F# 4.7</a>.</li><li><strong>.NET Standard 2.1</strong> increases the set of types you can use in code that can be used woth both .NET Core and Xamarin. <a href="https://devblogs.microsoft.com/dotnet/announcing-net-standard-2-1/">.NET Standard 2.1</a> includes types since .NET Core 2.1.</li><li><strong>Windows Desktop</strong> apps are now supported with .NET Core, for both <a href="https://github.com/dotnet/winforms">Windows Forms</a> and <a href="https://github.com/dotnet/wpf">WPF</a> (and <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/">open source</a>). The WPF designer is part of Visual Studio 2019. The <a href="https://devblogs.microsoft.com/dotnet/updates-to-net-core-windows-forms-designer-in-visual-studio-16-5-preview-1/">Windows Forms designer</a> is in preview and available as a download.</li><li><strong>.NET Core apps now have executables</strong> by default. In past releases, apps needed to be launched via the <code>dotnet</code> command, like <code>dotnet myapp.dll</code>. Apps can now be launched with an app-specific executable, like <code>myapp</code> or <code>./myapp</code>, depending on the operating system.</li><li><strong>High performance JSON APIs</strong> have been added, for reader/writer, object model and serialization scenarios. These APIs were built from scratch on top of <code>Span&lt;T&gt;</code> and use UTF8 under the covers instead of UTF16 (like <code>string</code>). These APIs minimize allocations, resulting in faster performance, and much less work for the garbage collector. See <a href="https://devblogs.microsoft.com/dotnet/try-the-new-system-text-json-apis/">Try the new System.Text.Json APIs</a>.</li><li><strong>The garbage collector uses less memory</strong> by default, often a lot less. This improvement is very beneficial for scenarios where many applications are hosted on the same server. The garbage collector has also been updated to make better use of large numbers of cores, on machines with &gt;64 cores. See <a href="https://devblogs.microsoft.com/dotnet/making-cpu-configuration-better-for-gc-on-machines-with-64-cpus/">Making CPU configuration better for GC on machines with &gt; 64 CPUs</a>.</li><li><strong>.NET Core has been hardened for Docker</strong> to enable .NET applications to work predictably and efficiently in containers. The garbage collector and thread pool have been updated to work much better when a container has been configured for limited memory or CPU. .NET Core docker images are smaller, particularly the SDK image. See: <a href="https://devblogs.microsoft.com/dotnet/running-with-server-gc-in-a-small-container-scenario-part-0/">Running with Server GC in a Small Container Scenario Part 0</a>, <a href="https://devblogs.microsoft.com/dotnet/running-with-server-gc-in-a-small-container-scenario-part-1-hard-limit-for-the-gc-heap/">Running with Server GC in a Small Container Scenario Part 1 – Hard Limit for the GC Heap</a> and <a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/">Using .NET and Docker Together – DockerCon 2019 Update</a>.</li><li><strong>Raspberry Pi and ARM chips</strong> are now supported to enable IoT development, including with the remote Visual Studio debugger. You can deploy apps that listen to sensors, and print messages or images on a display, all using the new GPIO APIs. ASP.NET can be used to expose data as an API or as a site that enables configuring an IoT device.</li></ul><h2>Platform support</h2><p>.NET Core 3.1 is supported on the following operating systems:</p><ul><li>Alpine: 3.10+</li><li>Debian: 9+</li><li>Ubuntu: 16.04+</li><li>Fedora: 29+</li><li>centOS: 7+</li><li>RHEL: 6+</li><li>openSUSE: 15+</li><li>SUSE Enterprise Linux (SLES): 12 SP2+</li><li>macOS: 10.13+</li><li>Windows Client: 7, 8.1, 10 (1607+)</li><li>Windows Server: 2012 R2+</li></ul><p>Note: Windows Forms and WPF apps are only functional and supported on Windows.</p><p>Chip support follows:</p><ul><li>x64 on Windows, macOS, and Linux</li><li>x86 on Windows</li><li>ARM32 on Windows and Linux</li><li>ARM64 on Linux (kernel 4.14+)</li></ul><p>Note: Please ensure that .NET Core 3.1 ARM64 deployments use Linux kernel 4.14 version or later. For example, Ubuntu 18.04 satisfies this requirement, but 16.04 does not.</p><h2>Windows Forms Controls Removal</h2><p>The following Windows Forms controls have been removed from .NET Core 3.1:</p><ul><li>DataGrid</li><li>ToolBar</li><li>ContextMenu</li><li>Menu</li><li>MainMenu</li><li>MenuItem</li></ul><p>These controls were replaced with more powerful controls in .NET Framework 2.0, back in 2005. They have not been available by default in the Visual Studio Designer Toolbox for many years. As a result, we decided to remove these controls and focus only on the new ones.</p><p>The following replacements are recommended:</p><table border="1"><thead><tr><th><b>Old Control (API)</b></th><th><b>Recommended Replacement</b></th><th><b>Other associated APIs removed</b></th></tr></thead><tbody><tr><td> DataGrid</td><td> DataGridView</td><td> DataGridCell, DataGridRow, DataGridTableCollection, DataGridColumnCollection, DataGridTableStyle, DataGridColumnStyle, DataGridLineStyle, DataGridParentRowsLabel, DataGridParentRowsLabelStyle, DataGridBoolColumn, DataGridTextBox, GridColumnStylesCollection, GridTableStylesCollection, HitTestType</td></tr><tr><td> ToolBar</td><td> ToolStrip</td><td> ToolBarAppearance</td></tr><tr><td> ToolBarButton</td><td> ToolStripButton</td><td> ToolBarButtonClickEventArgs, ToolBarButtonClickEventHandler, ToolBarButtonStyle, ToolBarTextAlign</td></tr><tr><td> ContextMenu</td><td> ContextMenuStrip</td><td></td></tr><tr><td> Menu</td><td> ToolStripDropDown, ToolstripDropDownMenu</td><td> MenuItemCollection</td></tr><tr><td> MainMenu</td><td> MenuStrip</td><td></td></tr><tr><td> MenuItem</td><td> ToolstripMenuItem</td><td></td></tr></tbody></table><p>Yes, this is an unfortunate breaking change. You will see build breaks if you are using the controls we removed in your applications. Also, if you open .NET Core 3.0 applications in the latest versions of the .NET Core Windows Forms designer, you will see errors if you are using these controls.</p><p>We recommend you update your applications to .NET Core 3.1 and move to the alternative controls. Replacing the controls is a straight-forward process, essentially “find and replace”.</p><p>First, we should have made these changes before we released .NET Core 3.0, and we appologize for that. We try to avoid late changes, and even more for breaking changes, and it pains us to make this one.</p><p>As we got further into the Windows Forms designer project, we realized that these controls were not aligned with creating modern applications and should never have been part of the .NET Core port of Windows Forms. We also saw that they would require more time from us to support than made sense.</p><p>Our goal is to continue to improve Windows Forms for high DPI, accessibility, and reliability, and this late change was required to enable us to focus on delivering that.</p><h2>C++/CLI</h2><p>We added support for creating C++/CLI (AKA “managed C++”) components that can be used with .NET Core 3.0+, in Visual Studio 2019 16.4. You need to install the “Desktop development with C++” workload and the “C++/CLI support” component in order to use C++/CLI.</p><p>This component adds a couple templates that you can use:</p><ul><li>CLR Class Library (.NET Core)</li><li>CLR Empty Project (.NET Core)</li></ul><p>If you cannot find them, just search for them in the New Project dialog.</p><p>C++/CLI is only enabled on Windows. You cannot use C++/CLI components targeted for .NET Framework with .NET Core or vice versa.</p><h2>Closing</h2><p>We recommend moving to .NET Core 3.1 as soon as you can. It is a great release (largely due to 3.0) that brings improvements to so many aspects of .NET Core. It is also a <a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core">long term support (LTS) release</a>, and will be supported for three years.</p><p>Life cycle update:</p><ul><li>.NET Core 3.0 will reach end-of-life three months from today, on March 3, 2020.</li><li>.NET Core 2.2 will each end of life on December 23rd.</li><li>.NET Core 2.1 will be supported until August 2021 (it is also an LTS release).</li></ul><p>The following .NET Core posts are recommended reading to learn more about what you get with .NET Core 3.1 and other projects we’ve been working on.</p><p><strong>Fundamentals</strong></p><p><strong>Desktop</strong></p><p><strong>ASP.NET</strong></p><p><strong>General</strong></p><div class="authorinfoarea"><div><p>Program Manager,&nbsp;.NET Team</p><p><strong>Follow Richard</strong>&nbsp;&nbsp;&nbsp;<a class="no-underline stayinformed" aria-label="Richard Lander LinkedIn profile" target="_blank" href="https://www.linkedin.com/in/richardlander/"><i class="fa fa-linkedin"></i></a><a class="no-underline stayinformed" aria-label="Richard Lander GitHub profile" target="_blank" href="https://github.com/richlander"><i class="fa fa-github"></i></a><a class="no-underline stayinformed hvr-pop" aria-label="Richard Lander RSS Feed" target="_blank" href="https://devblogs.microsoft.com/dotnet/author/richlander-ca/feed/"></a></p></div></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>