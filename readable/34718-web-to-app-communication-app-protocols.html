<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Web-to-App Communication: App&#xA0;Protocols -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Web-to-App Communication: App&#xA0;Protocols</h1>
    <div class="entry-content"> <p>Just over eight years ago, I wrote my last blog post about <a href="https://blogs.msdn.microsoft.com/ieinternals/2011/07/13/understanding-protocols/">App Protocols</a>, the type of URL scheme that (typically) opens another program on your computer instead of returning data to the web browser.&#xA0;</p>
<p>App Protocols<sup>1</sup> are both simple and powerful, allowing client app developers to easily enable the invocation of their applications from a website. For instance, <span>ms-screenclip</span> is a simple app protocol built into Windows 10 that kicks off the process of taking a screenshot:</p>
<pre>    ms-screenclip:?delayInSeconds=2</pre>
<p>When the user invokes this url, the handler waits two seconds, then launches its UI to collect a screenshot. Notably, App Protocols are <strong>fire-and-forget</strong><em>,&#xA0;</em>meaning that the handler has no direct way to return data back to the browser that invoked the protocol.</p>
<p>The power and simplicity of App Protocols comes at a cost. They are the easiest route out of browser sandboxes and are thus <strong>terrifying</strong>, especially because this exploit vector is stable and available in every browser from legacy IE to the very latest versions of Chrome/Firefox/Edge/Safari.</p>
<h3>What&#x2019;s the Security Risk?</h3>
<p>There are a number of issues that make App Protocols a particular security risk.</p>
<h4>Careless Implementation</h4>
<p>The primary security problem is that most App Protocols were designed to address a particular scenario (e.g.<em> a videoconferencing client designed to launch from the &#x201C;Meet Now&#x201D; page on the videoconferencing vendor&#x2019;s website</em>) and not designed with the expectation that the app could be exposed to potentially dangerous data from the web at large.</p>
<p>We&#x2019;ve seen apps where the app will silently reconfigure itself (e.g. sending your email to a different server) based on parameters in the URL it receives. We&#x2019;ve seen apps where the app will immediately create or delete files without first confirming the irreversible operation with the user. We&#x2019;ve seen apps that assumed they&#x2019;d never get more than 255 characters in their URLs and had buffer-overflows leading to Remote Code Execution when that limit was exceeded. The list goes on and on.</p>
<h4>Poor API Contract</h4>
<p>App Protocols are implemented as a simple mapping between the protocol scheme (e.g. &#x201C;alert&#x201D;) and a shell command, e.g.&#xA0;</p>
<p><img class="alignnone size-full wp-image-2183" src="https://textplain.files.wordpress.com/2019/08/alertprotocol.png?w=502" alt="AlertProtocol" srcset="https://textplain.files.wordpress.com/2019/08/alertprotocol.png 502w, https://textplain.files.wordpress.com/2019/08/alertprotocol.png?w=150 150w, https://textplain.files.wordpress.com/2019/08/alertprotocol.png?w=300 300w" sizes="(max-width: 502px) 100vw, 502px"></p>
<p>When the protocol is invoked by the browser, it simply bundles up the URL and passes it on the command line to the target application. The application doesn&#x2019;t get any information about the caller (e.g. &#x201C;What browser or app invoked this?&#x201D;, &#x201C;What origin invoked this?&#x201D;, etc) and thus it must make any decisions solely on the basis of the URL.</p>
<p>Until recently, there was an even bigger problem here, related to the encoding of the URL. Browsers, including Chrome, Edge, and IE, were willing to include bare spaces and quotation marks in the URL argument, meaning that an application could get a command line like:</p>
<pre><strong>alert.exe &quot;<span>alert:This-is-an-Evil-URL&quot; --DoSomethingDangerous --Ignore=This</span>&quot;</strong></pre>
<p>The app&#x2019;s code saw the <span>&#x2013;DoSomethingDangerous</span> argument, failed to recognize it as a part of the URL, and invoked dangerous functionality. This attack led to remote code execution bugs in App Protocol handlers <em>many&#xA0;</em>times over the years.&#xA0;</p>
<p>Chrome began %-escaping spaces and quotation marks back <a href="https://chromium.googlesource.com/chromium/src/+/2401e58572884b3561e4348d64f11ac74667ef02">in Chrome 64</a>, and Edge 18 followed suit in Windows 10 RS5.</p>
<p>You can see how your browser behaves using the links on this <a href="https://webdbg.com/test/protocol/">test page</a>.</p>
<p><span><strong>Future Opportunity: </strong>A richer API contract that allows an App Protocol handler to determine how specifically it was invoked would allow it to better protect itself from unexpected sites. Moving the App Protocol URL data from the command line to somewhere else (e.g. stdin) might help reduce the possibility of parsing errors.</span></p>
<h4>Sandbox</h4>
<p>The application that handles the protocol typically runs outside of the browser&#x2019;s sandbox. This means that a security vulnerability in the app can be exploited to steal or corrupt any data the user can access, install malware, etc. If the browser is running Elevated (at Administrator), any App Protocol handlers it invokes are launched Elevated.</p>
<p>Because most app handlers are written in native code, the result is that they usually end up in the <strong>DOOM!</strong> portion of this diagram:</p>
<p><img class="size-full wp-image-2185 aligncenter" src="https://textplain.files.wordpress.com/2019/08/ruleoftwo-1.png?w=520" alt="RuleOfTwo" srcset="https://textplain.files.wordpress.com/2019/08/ruleoftwo-1.png 520w, https://textplain.files.wordpress.com/2019/08/ruleoftwo-1.png?w=150 150w, https://textplain.files.wordpress.com/2019/08/ruleoftwo-1.png?w=300 300w" sizes="(max-width: 520px) 100vw, 520px"></p>
<h3>Prompting</h3>
<p>In most cases, the only<sup>2</sup> thing&#xA0;standing between the user and disaster is a permission prompt.</p>
<p>In Internet Explorer, the prompt looked like this:</p>
<p><img class="size-full wp-image-2171 aligncenter" src="https://textplain.files.wordpress.com/2019/08/iepermission.png?w=407" alt="IEPermission" srcset="https://textplain.files.wordpress.com/2019/08/iepermission.png 407w, https://textplain.files.wordpress.com/2019/08/iepermission.png?w=150 150w, https://textplain.files.wordpress.com/2019/08/iepermission.png?w=300 300w" sizes="(max-width: 407px) 100vw, 407px"><br>As you can see, the dialog provides a bunch of context about what&#x2019;s happening, including the raw URL, the name of the handler, and a remark that allowing the launch may harm the computer.</p>
<p>Such information is lacking in more modern browsers, including Firefox:</p>
<p><img class="alignnone size-full wp-image-2172 aligncenter" src="https://textplain.files.wordpress.com/2019/08/firefoxpermission.png?w=314" alt="FirefoxPermission" srcset="https://textplain.files.wordpress.com/2019/08/firefoxpermission.png 314w, https://textplain.files.wordpress.com/2019/08/firefoxpermission.png?w=137 137w, https://textplain.files.wordpress.com/2019/08/firefoxpermission.png?w=274 274w" sizes="(max-width: 314px) 100vw, 314px"></p>
<p>&#x2026;and Edge/Chrome:</p>
<p><img class="size-full wp-image-2174 aligncenter" src="https://textplain.files.wordpress.com/2019/08/chromepermission.png?w=450" alt="ChromePermission" srcset="https://textplain.files.wordpress.com/2019/08/chromepermission.png 450w, https://textplain.files.wordpress.com/2019/08/chromepermission.png?w=150 150w, https://textplain.files.wordpress.com/2019/08/chromepermission.png?w=300 300w" sizes="(max-width: 450px) 100vw, 450px"></p>
<p>Browser UI designers (reasonably) argue that the vast majority of users are poorly equipped to make trust decisions, even with the information in the IE prompt, and so modern UI has been greatly simplified<sup>3</sup>.&#xA0;</p>
<p>Unfortunately, lost to evolution is the crucial indication to the user that they&#x2019;re even <strong>making a trust decision </strong>at all.</p>
<h3>Eliminating Prompts</h3>
<p>Making matters more dangerous, <em>everyone</em> hates security prompts that interrupt non-malicious scenarios. A common user request can be summarized as &#x201C;<em>Prompt me </em>only <em>when something bad is going to happen. In fact, in those cases, don&#x2019;t even prompt me, just protect me.</em>&#x201C;</p>
<p>Unfortunately, the browser cannot know whether a given App Protocol invocation is good or evil, so it delegates control of prompting in two ways:</p>
<p>In Internet Explorer and Edge (version&lt;=18), the browser respects a per-protocol <strong>WarnOnOpen</strong> boolean in the registry, such that the App itself may tell the browser: &#x201C;<em>No worries, let anyone launch me, no prompt needed.</em>&#x201C;</p>
<p>In Firefox, Chrome, and Edge (version &gt;= 76), the browser instead allows the user to suppress further prompts with a &#x201C;Remember my choice&#x201D; checkbox. If the user selects this option, the protocol will silently launch in the future without the browser first asking permission.</p>
<p>Notably Edge/Chrome version 77.0.3864 removed the &#x201C;Always open these types of links in the associated app&#x201D; checkbox. The stated reason is found in Chrome issue #<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=982341#c11">982341</a>:</p>
<pre>No obvious way to undo &quot;Always open these types of links&quot; decision for External Protocols. <a href="https://chromium.googlesource.com/chromium/src.git/+/4e0e7e532b04eef14f05077872629a2ccb763530">4e0e7e532b04eef14f05077872629a2ccb763530</a></pre>
<p>A user who had ticked the &#x201C;Always open&#x201D; box has no way to later view that decision<sup>4</sup>, and no obvious way to reverse it. Almost no one figured out that using the &#x201C;Clear Browsing Data &gt; Cookies and other site data&#x201D; dialog box option <a href="https://cs.chromium.org/chromium/src/chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.cc?l=1155&amp;rcl=2e290878bbcc563bc9c506be23d9901edf3425d0">directs Chrome</a> to delete all previous &#x201C;Always open&#x201D; decisions for the user&#x2019;s profile.&#xA0;</p>
<p>Particularly confusing is that the &#x201C;Always open&#x201D; decision wasn&#x2019;t made on a per-site basis&#x2013; it applies to every site visited by the user in that browser profile.</p>
<p><span><strong>Future Opportunity: </strong>Much of the risk inherent in open-without-prompting behavior comes from the site that any random site (<a href="http://evil.example.com">http://evil.example.com</a>) can abuse it to launch the protocol handler. If we changed the option to &#x201C;Always allow this site to open this protocol&#x201D;, the risk would be significantly reduced, and a user could reasonably safely allow, e.g. <a href="https://teams.microsoft.com">https://teams.microsoft.com</a> to open the msteams protocol without a prompt. Alternatively, perhaps the Registry-based registration of a protocol handler should explicitly list the sites allowed to launch the protocol, akin to the SiteLock feature in legacy ActiveX controls.</span></p>
<p>Some security folks have argued that browsers should not provide <em>any&#xA0;</em>mechanism for skipping the permission prompt. Unfortunately, there&#x2019;s evidence to suggest that such a firm stance might result in vendors avoiding the prompt by choosing <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=982341#c9">even riskier architectures</a> for Web-to-App communication.&#xA0;</p>
<h3>Zero-Day Defense</h3>
<p>Even when an active zero day against an App Protocol handler is getting exploited in the wild (e.g. <a href="https://www.nccgroup.trust/uk/our-research/technical-advisory-citrix-workspace-receiver-remote-code-execution-vulnerability/?research=Technical+advisories">this one</a>), browsers have few defenses available to protect users.&#xA0;</p>
<p>Unlike, say, file downloads, where the browser multiple mechanisms that can protect users against newly-discovered threats (<a href="https://textslashplain.com/2019/07/16/updating-browsers-quickly-flags-respins-and-components/">file type policies</a> and SmartScreen/SafeBrowsing), browsers do not presently have rapid update mechanisms that can block access to known vulnerable App Protocol handlers.</p>
<p><span><strong>Future Opportunity:&#xA0;</strong>Use SafeBrowsing/SmartScreen or a file-type-policies style Component Update to supply the client with a list of known-vulnerable protocol handlers. If a page attempts to invoke such a protocol, either block it entirely or strongly caution the user. </span></p>
<p><span>To improve the experience even further, the blocklist could contain version information such that blocking/additional warnings would only be shown if the version of the handler app is earlier than the version number of the app containing the fix.</span><span>&#xA0;</span></p>
<p>Antivirus programs typically do monitor all calls to ShellExecute and could <em>conceivably</em> protect against malicious invocation of app protocol handlers, but I am not aware of any having ever done so.</p>
<h3>Privacy Concerns Prevent Protocol Detection</h3>
<p>One of the most common challenges for developers who want to use App Protocols for Web-to-App communication is that the web platform does not expose the list of available protocol handlers to JavaScript. This is primarily a privacy consideration: exposing the list of protocol handlers to the web would expose a significant amount of <a href="https://dev.chromium.org/Home/chromium-security/client-identification-mechanisms">fingerprintable entropy</a> and might even reveal things about the user&#x2019;s interests and beliefs (e.g. a ConservativeNews App or a LGBTQ App might implement a protocol handler for app-to-app communication).</p>
<p>Internet Explorer and Edge &lt;= 18 used to expose a non-standard JavaScript function <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/msLaunchUri">msLaunchUri</a> that would allow a web page to detect that a user didn&#x2019;t have a protocol handler installed, but this function is not available in other browsers.</p>
<h5>UX When a Protocol Isn&#x2019;t Installed?</h5>
<p>Browser behavior varies if the user attempts to invoke a link with a scheme for which no protocol handler is registered.</p>
<p>Firefox shows an error page: <img class="alignnone size-full wp-image-2177" src="https://textplain.files.wordpress.com/2019/08/firefoxnotinstalled.png?w=551" alt="FirefoxNotInstalled" srcset="https://textplain.files.wordpress.com/2019/08/firefoxnotinstalled.png 551w, https://textplain.files.wordpress.com/2019/08/firefoxnotinstalled.png?w=150 150w, https://textplain.files.wordpress.com/2019/08/firefoxnotinstalled.png?w=300 300w" sizes="(max-width: 551px) 100vw, 551px"></p>
<p>On Windows 8 and later, IE and Edge&lt;=18 show a prompt that offers to take the user to the Microsoft store to search for a protocol handler for the target scheme.</p>
<p><img class="size-full wp-image-2176 aligncenter" src="https://textplain.files.wordpress.com/2019/08/win10notinstalled.png?w=392" alt="Win10NotInstalled" srcset="https://textplain.files.wordpress.com/2019/08/win10notinstalled.png 392w, https://textplain.files.wordpress.com/2019/08/win10notinstalled.png?w=150 150w, https://textplain.files.wordpress.com/2019/08/win10notinstalled.png?w=300 300w" sizes="(max-width: 392px) 100vw, 392px"></p>
<p>Unfortunately, this search is rarely fruitful because most apps are not available in the Microsoft Store.</p>
<p>Interestingly, Chrome and Edge76+ show nothing at all when attempting to invoke a link for which no protocol handler is installed. Surprisingly, there&#x2019;s no notice even in the Developer Tools console; a particularly thorough debugger will only see a &#x201C;(canceled)&#x201D; request in the DevTool&#x2019;s Network tab.</p> <p>In future posts, I&#x2019;ll explore some other alternatives for Web-to-App communication.</p>
<p>-Eric</p>
<p><span>Notes</span></p>
<p><sup>1</sup> Within Chromium, App Protocols are called &#x201C;External Protocols.&#x201D;</p>
<p><sup>2</sup> As an anti-abuse mechanism, the browser may require a <strong>user-gesture</strong> (e.g. a mouse click) before attempting to launch an App Protocol, and may <strong>throttle&#xA0;</strong>invocations to avoid spamming the user with an infinite stream of prompts.</p>
<p><sup>3</sup>&#xA0;Chrome&#x2019;s prompt <a href="https://blogs.msdn.microsoft.com/ieinternals/2011/07/13/understanding-protocols/">used to</a> look much like IE&#x2019;s.</p>
<p><sup>4</sup>&#xA0; Short of opening the Preferences for the profile in Notepad or another text editor. E.g. after choosing &#x201C;Always open&#x201D; for Microsoft Teams and Skype for Business, the JSON file %localappdata%\Microsoft\Edge SxS\user Data\default\preferences contains</p>
<pre>&quot;protocol_handler&quot;:{&quot;excluded_schemes&quot;:{&quot;msteams&quot;:false, &quot;ms-sfb&quot;: false}}</pre> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>