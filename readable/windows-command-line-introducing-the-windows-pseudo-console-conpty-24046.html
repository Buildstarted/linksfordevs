<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Windows Command-Line: Introducing the Windows Pseudo Console (ConPTY) | Windows Command Line - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Windows Command-Line: Introducing the Windows Pseudo Console (ConPTY) | Windows Command Line - linksfor.dev(s)"/>
    <meta property="article:author" content="Rich TurnerSr. Program Manager,&#xA0;Windows Console &amp; Command-LineFollow Rich"/>
    <meta property="og:description" content="In this, the fourth post in the Windows Command-Line series, we&#x27;ll discuss the new Windows Pseudo Console (ConPTY) infrastructure and API - why we built it, what it&#x27;s for, how it works, how to use it, and more."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Windows Command-Line: Introducing the Windows Pseudo Console (ConPTY) | Windows Command Line</title>
<div class="readable">
        <h1>Windows Command-Line: Introducing the Windows Pseudo Console (ConPTY) | Windows Command Line</h1>
            <div>by Rich TurnerSr. Program Manager,&#xA0;Windows Console &amp; Command-LineFollow Rich</div>
            <div>Reading time: 26-34 minutes</div>
        <div>Posted here: 17 May 2019</div>
        <p><a href="https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/">https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/17323e64ced8eaf243bf348f751f6e21?s=58&amp;d=identicon&amp;r=g" width="58" height="58" alt="Avatar"></p><p>Rich</p></div></div></div><p>August 2nd, 2018</p><p>In this, the fourth post in the Windows Command-Line series, we‚Äôll discuss the new Windows Pseudo Console (ConPTY) infrastructure and API ‚Äì why we built it, what it‚Äôs for, how it works, how to use it, and more.</p><h2 id="posts-in-this-windows-command-line-series">Posts in the ‚ÄúWindows Command-Line‚Äù series<a href="#posts-in-this-windows-command-line-series"></a></h2><blockquote><p>Note: This chapter list will be updated as more posts are published:</p></blockquote><ol><li><a href="http://devblogs.microsoft.com/commandline/windows-command-line-backgrounder/">Backgrounder</a></li><li><a href="https://devblogs.microsoft.com/commandline/windows-command-line-the-evolution-of-the-windows-command-line/">The Evolution of the Windows Command-Line</a></li><li><a href="https://devblogs.microsoft.com/commandline/windows-command-line-inside-the-windows-console/">Inside the Windows Console</a></li><li><strong>Introducing the Windows Pseudo Console (ConPTY)</strong> [This Post]</li><li><a href="https://devblogs.microsoft.com/commandline/windows-command-line-unicode-and-utf-8-output-text-buffer/">Unicode and UTF-8 Output Text Buffer</a></li></ol><hr><p>In <a target="_blank" href="https://blogs.msdn.microsoft.com/commandline/2018/07/20/windows-command-line-inside-the-windows-console/" rel="noopener noreferrer">the previous post</a> in this series, we started to explore the internals of the Windows Console and Windows‚Äô Command-Line infrastructure. We also discussed many of Console‚Äôs strengths and outlined its key weaknesses.</p><p>One of those weaknesses is that Windows tries to be ‚Äúhelpful‚Äù but gets in the way of alternative and 3rd party Console developers, service developers, etc. When building a Console or service, developers need to be able to access/supply the communication pipes through which their Terminal/service communicates with command-line applications. In the *NIX world, this isn‚Äôt a problem because *NIX provides a <a target="_blank" href="https://en.wikipedia.org/wiki/Pseudoterminal" rel="noopener noreferrer">‚ÄúPseudo Terminal‚Äù (PTY)</a> infrastructure which makes it easy to build the communication plumbing for a Console or service, but Windows does not ‚Ä¶</p><p><strong><em>‚Ä¶ until now!</em></strong></p><p>Before we dig into what we‚Äôve done, let‚Äôs briefly revisit how Terminals evolved:</p><h2 id="in-the-beginning-was-the-tty">In the beginning was the TTY<a href="#in-the-beginning-was-the-tty"></a></h2><p>As discussed in <a target="_blank" href="https://blogs.msdn.microsoft.com/commandline/2018/06/20/windows-command-line-backgrounder/" rel="noopener noreferrer">the first ‚Äòbackgrounder‚Äô post in this series</a>, in the early days of computing, users operated computers via electromechanical Teletype (TTY) devices connected to a computer via some form of serial communications link (typically a <a target="_blank" href="https://en.wikipedia.org/wiki/Digital_current_loop_interface" rel="noopener noreferrer">20mA current loop</a>).</p><figure><img src="https://devblogs.microsoft.com/wp-content/uploads/sites/33/2019/02/command-line-thompson-richie-teletype.jpg" alt="Ken Thompson and Dennis Richie (standing) working on a DEC PDP-11 via teletype (notice no electronic display)"></figure><figcaption>Ken Thompson and Dennis Richie (standing) working on a DEC PDP-11 via teletype (notice no electronic display)</figcaption><h3 id="rise-of-the-terminals">Rise of the Terminals</h3><p>Teletype devices were replaced by computerized Terminals with electronic display devices (usually CRT screens). Terminals were generally very simple devices (hence the term ‚Äúdumb terminal‚Äù) containing only the electronics and compute-power required to:</p><ol><li>Accept text input via the keyboard</li><li>Buffer input text one line at a time (enabling local editing before sending)</li><li>Send/receive text via serial communications (usually via the once ubiquitous <a target="_blank" href="https://en.wikipedia.org/wiki/RS-232" rel="noopener noreferrer">RS-232</a> interface)</li><li>Display received text on the Terminal‚Äôs display</li></ol><p>Despite their simplicity (or perhaps because of it), Terminals rapidly became the primary devices used to operate mini, mainframe, and server computers: Most data entry clerks, computer operators, system administrators, scientists, researchers, software developers, and industry luminaries earned their digital-stripes by pounding away on Terminals from DEC, IBM, Wyse, and many others.</p><figure><img src="https://devblogs.microsoft.com/wp-content/uploads/sites/33/2019/02/command-line-grace-hopper-terminal.jpg" alt="Admiral Grace Hopper in her office with a DEC VT220 Terminal on her desk"></figure><figcaption>Admiral Grace Hopper in her office with a DEC VT220 Terminal on her desk</figcaption><h3 id="the-rise-and-rise-of-software-terminals">The Rise and Rise of Software Terminals</h3><p>Starting in the mid 1980‚Äôs, dedicated Terminal devices gradually started to be replaced by general purpose computers that were rapidly becoming more affordable, popular, and powerful. Many early PCs and other computers of the ‚Äô80s had Terminal applications that could open a connection to the PC‚Äôs RS-232 serial port and exchange data with whatever was listening on the other end of the connection.</p><p>As general-purpose computers grew in sophistication, the Graphical User Interface (GUI) arrived and introduced a whole new world of simultaneously running applications, including Terminal applications.</p><p>But a problem arose: How would a Terminal application speak to another Command-Line application running on the same machine? And how would you attach a physical serial cable between the two apps running on the same computer?</p><h2 id="enter-the-pseudo-terminal-pty">Enter, the Pseudo Terminal (PTY)<a href="#enter-the-pseudo-terminal-pty"></a></h2><p>In the *NIX world, this problem was solved by the introduction of the <a target="_blank" href="https://en.wikipedia.org/wiki/Pseudoterminal" rel="noopener noreferrer">Pseudo Terminal (PTY)</a>.</p><p>The PTY virtualizes a computer‚Äôs serial communications hardware, exposing ‚Äúmaster‚Äù and ‚Äúslave‚Äù pseudo-devices: Terminal apps connect to a master pseudo-device; Command-Line applications (e.g. shells like Cmd, PowerShell, and bash) connect to a slave pseudo-device. When the Terminal client sends text and/or control commands (encoded as text) to the master, the text is relayed along to the associated ‚Äúslave‚Äù. Text emitted by the application is sent to the slave and is then routed back to the master and thus to the Terminal. Data is always sent/received asynchronously.</p><figure><img src="https://devblogs.microsoft.com/wp-content/uploads/sites/33/2019/02/terminal-pty-shell-e1532552020635.png" alt="Terminal to/from PTY to/from App/Shell"></figure><figcaption>Terminal PTY App/Shell</figcaption><p>Importantly, the ‚Äúslave‚Äù pseudo-device emulates the behavior of a physical Terminal device and converts command characters into <a target="_blank" rel="noopener noreferrer">POSIX signals</a>. For example, if a user types <a target="_blank" href="https://en.wikipedia.org/wiki/Control-C" rel="noopener noreferrer">CTRL+C</a> into the Terminal, the ASCII value of CTRL+C (0x03) is sent via the master. When received by the slave, the 0x03 value is removed from the input stream and a <a target="_blank" href="https://en.wikipedia.org/wiki/Signal_(IPC)#SIGINT" rel="noopener noreferrer">SIGINT signal</a> is generated.</p><p>This PTY infrastructure is used extensively by *NIX Terminal applications, text pane managers (like screen, tmux), etc. Such apps call <a target="_blank" rel="noopener noreferrer">openpty()</a> which returns a pair of file descriptors (fd) for the PTY‚Äôs master and slave. The app can then fork/exec the child Command-Line application (e.g. bash), which uses its slave fds to listen and return text to the attached Terminal.</p><p>This mechanism allows Terminal applications to ‚Äútalk‚Äù directly to Command-Line applications running locally in the same way as the Terminal would talk with a remote Computer via a serial/network connection.</p><h2 id="what-no-windows-pseudo-console">What, no Windows Pseudo Console?<a href="#what-no-windows-pseudo-console"></a></h2><p>So, as we discussed in the previous post in this series ‚Äì <a target="_blank" href="https://blogs.msdn.microsoft.com/commandline/2018/07/20/windows-command-line-inside-the-windows-console/" rel="noopener noreferrer">Inside the Windows Console</a> ‚Äì while the Windows Console is conceptually similar to the traditional *NIX Terminal, it differs in several key ways, especially at its lowest-levels which can cause problems for developers of Windows Command-Line apps, 3rd-party Terminals/Consoles, and server apps:</p><ol><li><strong>Windows lacks a PTY infrastructure</strong>: When the user launches a Command-Line app (e.g. Cmd, PowerShell, wsl, ipconfig, etc.), Windows itself ‚Äúhooks up‚Äù a new or existing Console instance to the app</li><li><strong>Windows obstructs 3rd party Consoles and Server Apps</strong>: Windows (currently) does not provide Terminals a way to supply the communication pipes via which it wants to communicate with a Command-Line app. 3rd party Terminals are forced to create an off-screen Console, and to send it user-input and scrape its output, redrawing the output on the 3rd party Console‚Äôs own display!</li><li><strong>Only Windows has a Console API</strong>: Windows Command-Line apps rely on the Win32 Console API which reduces code portability because every other platform ‚Äúspeaks text/VT‚Äù rather than calling APIs</li><li><strong>Windows Command-Line Remoting is substandard</strong>: Windows‚Äô Command-Line apps‚Äô dependence on Console API significantly impedes interop &amp; remoting scenarios</li></ol><h2 id="what-to-do">What to do?<a href="#what-to-do"></a></h2><p>We‚Äôve heard from many, <strong><em>many</em></strong> developers, who‚Äôve frequently requested a PTY-like mechanism in Windows ‚Äì especially those who created and/or work on ConEmu/Cmder, Console2/ConsoleZ, Hyper, VSCode, Visual Studio, WSL, Docker, and OpenSSH.</p><p>Well, we finally did it: <strong>We created a Pseudo Console for Windows</strong>:</p><p>Since taking ownership of the Console ~4 years ago, the Console Team has been busy overhauling the Windows Console &amp; Command-Line internals. While doing so, we regularly and carefully considered the issues described above and many other related asks and issues. But the internals weren‚Äôt in the right shape to make a Pseudo Console feasible ‚Ä¶ until now!</p><p>Windows‚Äô new Pseudo Console (ConPTY) infrastructure, API, and several other supporting changes will remedy/facilitate an entire class of issues ‚Ä¶ <strong><em>without breaking or damaging backward compatibility for existing command-line applications</em></strong>!</p><blockquote><p>The new Win32 ConPTY API (formal docs to follow soon) is now available in recent Windows 10 Insider builds and corresponding <a target="_blank" href="https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewSDK" rel="noopener noreferrer">Windows 10 Insider Preview SDK</a>, and will ship in the next major release of Windows 10 (due sometime in fall/winter 2018).</p></blockquote><h2 id="consoleconhosts-architecture">Console/ConHost‚Äôs Architecture<a href="#consoleconhosts-architecture"></a></h2><p>To understand ConPTY, we have to revisit the architecture of Windows Console ‚Ä¶ or more accurately ‚Ä¶ ConHost!</p><p>It‚Äôs important to understand that while ConHost implements what you see and know as the Windows Console application itself, ConHost also contains and implements most of Windows‚Äô Command-Line infrastructure! From now on, however, <strong>ConHost also becomes a true ‚ÄúConsole Host‚Äù</strong>, supporting all Command-Line applications and/or GUI applications that communicate with Command-Line applications!</p><p><strong><em>How? Why? What?</em></strong> Let‚Äôs dig in some more:</p><p>Here‚Äôs a high-level view of the internal architecture of Console/ConHost:</p><p><img src="https://devblogs.microsoft.com/wp-content/uploads/sites/33/2019/02/command-line-conpty-architecture.png" alt="Console Architecture including the ConPTY"></p><p>Compared to the architecture we outlined in <a target="_blank" href="https://blogs.msdn.microsoft.com/commandline/2018/07/20/windows-command-line-inside-the-windows-console/" rel="noopener noreferrer">the previous ‚ÄúConsole Internals‚Äù post in this series</a>, ConHost now contains a few additional modules for handling VT and a new ConPTY module that implements the public API:</p><ul><li><strong>ConPTY API</strong>: The new Win32 ConPTY API provides a mechanism that is similar to the POSIX PTY model, but in a Windows-relevant manner</li><li><strong>VT Interactivity</strong>: Receives incoming UTF-8 encoded text, converts each displayable text character into the corresponding <a href="https://docs.microsoft.com/en-us/windows/console/input-record-str" target="_blank"><code>INPUT_RECORD</code></a>, and stores them in the Input Buffer. It also handles control sequences such as 0x03 (CTRL+C) converting them into <a href="https://docs.microsoft.com/en-us/windows/console/key-event-record-str" target="_blank"><code>KEY_EVENT_RECORDS</code></a> that will effect the corresponding control action</li><li><strong>VT Renderer</strong>: Generates the VT sequences necessary to move the cursor and render the text and styling in regions of the Output Buffer that have changed since the previous frame</li></ul><p>Okay, but what does this actually mean?</p><h2 id="how-do-windows-command-line-applications-work">How Do Windows Command-Line Applications Work?<a href="#how-do-windows-command-line-applications-work"></a></h2><p>To better understand the impact of the new ConPTY infrastructure, let‚Äôs consider for a moment how Windows Console and Command-Line applications have worked up until now.</p><p>Whenever a user launches a Command-Line application like Cmd, PowerShell, or ssh, Windows creates a new Win32 process into which it loads the app‚Äôs executable binary file, and any dependencies (resources or libraries).</p><p>The newly created process usually inherits the stdin and stdout handles from its parent. If the parent was a Windows GUI process, there are no stdin and stdout handles and so Windows will spin up and attach the new app to a new Console instance. Communications between Command-Line apps and their Console are transported via ConDrv.</p><p>For example, if launched from a non-elevated PowerShell instance, the new app process will inherit its parent‚Äôs stdin/stdout handles and will therefore receive input from and emit output to the same Console as the parent.</p><blockquote><p>There is a little ‚Äúhand-waving‚Äù going on here as there are cases where Command-Line apps are launched attached to a <em>new</em> Console instance, especially for security reasons, but the cases described above are generally true. Ultimately, when a Command-Line app/shell is launched, Windows connects it to a Console (ConHost.exe) instance via ConDrv:</p></blockquote><p><img src="https://devblogs.microsoft.com/wp-content/uploads/sites/33/2019/02/command-line-conpty-1803-console-architecture.png" alt="Console architecture in Win10 1803"></p><h2 id="how-does-conhost-work">How does ConHost work?<a href="#how-does-conhost-work"></a></h2><p>Whenever a Command-Line application is executed, Windows will connect the app to a new or existing ConHost instance. The app and its Console instance are connected via the kernel-mode Console Driver (ConDrv) which sends/receives IOCTL messages containing serialized API call requests and/or text data.</p><p>Historically, as outlined in prior posts, ConHost‚Äôs job today is a relatively simple one:</p><ul><li>The user generates input via keyboard/mouse/pen/touch which is converted into <a href="https://docs.microsoft.com/en-us/windows/console/key-event-record-str" target="_blank"><code>KEY_EVENT_RECORD</code></a> or <a href="https://docs.microsoft.com/en-us/windows/console/mouse-event-record-str" target="_blank"><code>MOUSE_EVENT_RECORD</code></a> and stored in the Input Buffer</li><li>The Input Buffer is drained one record at a time and performs the requested input action like draw text on screen, move cursor, copy/paste text, etc. Many of these actions result in the Output Buffer‚Äôs contents being changed. These changed regions are recorded by ConHost‚Äôs state engine</li><li>Each frame, the Console renders the OutputBuffer‚Äôs changed regions to the display</li></ul><p>When a Command-Line app calls Windows Console APIs, the API calls are serialized into IOCTL messages and sent via the ConDrv driver. ConDrv then delivers the IOCTL messages to the attached Console, which decodes and executes the requested API call. Return/output values are serialized back into an IOCTL message and sent back to the app via ConDrv.</p><h2 id="conhost---investing-in-yesterday-for-tomorrow">ConHost ‚Äì Investing in yesterday for tomorrow<a href="#conhost---investing-in-yesterday-for-tomorrow"></a></h2><p>Microsoft tries, wherever possible, to maintain backward compatibility with existing apps/tools. This is especially true in the Command-Line world. In fact, 32-bit editions of Windows 10 can still run many/most ‚ÄúWin16‚Äù 16-bit Windows apps and executables!</p><p>As mentioned above, one of ConHost‚Äôs key roles is to provide services to Command-Line apps that it hosts, especially legacy apps that call and rely on the Win32 Console API. ConHost now offers some new services:</p><ul><li>Seamlessly provide PTY-like infrastructure for communication with modern Consoles and Terminals</li><li>Modernizes legacy/traditional Command-Line Apps<ul><li>Receives &amp; converts UTF-8 encoded text/VT into input records (as if typed by user)</li><li>Executes Console API calls for the app it‚Äôs hosting, updating its ‚ÄúOutput Buffer‚Äù accordingly</li><li>Renders changed regions of the output buffer as UTF-8 encoded text/VT</li></ul></li></ul><p>Below is an example of a modern Console app talking via a ConPTY ConHost to a Command-Line app</p><p><img src="https://devblogs.microsoft.com/wp-content/uploads/sites/33/2019/02/command-line-conpty-bridging.png" alt="ConPty bridging Traditional and Modern Command-Line apps"></p><p>In this new model:</p><ol><li>Console:<ol><li>Creates its own communication pipes</li><li>Calls the ConPTY API to create a ConPTY causing Windows to spin up a ConHost instance connected to the other end of the pipes</li><li>Creates an instance of the Command-Line app (e.g. PowerShell) attached to ConHost as usual</li></ol></li><li>ConHost:<ol><li>Reads UTF-8 encoded text/VT input and converts into <a href="https://docs.microsoft.com/en-us/windows/console/input-record-str" target="_blank"><code>INPUT_RECORD</code></a> that are sent to the Command-Line app</li><li>Executes API calls from the Command-Line app which may modify the contents of the Output Buffer</li><li>Renders changes in its Output Buffer as UTF-8 encoded text/VT and sends the resulting text to its Console</li></ol></li><li>Command-Line app:<ol><li>Runs as usual, reading input and calling Console APIs without any knowledge that its ConPTY ConHost is translating its input/output from/to UTF-8 encoded text/VT!</li></ol></li></ol><p>The latter point is important! When a legacy Command-Line app uses a Console API like <a target="_blank" href="https://docs.microsoft.com/en-us/windows/console/writeconsoleoutput" rel="noopener noreferrer"><code>WriteConsoleOutput(...)</code></a>, the specified text is written to the attached ConHost‚Äôs Output Buffer. Periodically, ConHost renders changed areas of the Output Buffer as text/VT which is sent via stdout back to the Console.</p><p>Ultimately, this means that even traditional Command-Line apps ‚Äúspeak text/VT‚Äù externally, <strong><em>without requiring any changes</em></strong>!</p><p>Using the new ConPTY infrastructure, 3rd party Consoles can now communicate directly with modern and traditional Command-Line applications, and speak text/VT with all of them.</p><h2 id="remoting-windows-command-line-applications">Remoting Windows Command-Line Applications<a href="#remoting-windows-command-line-applications"></a></h2><p>The mechanism above works great on a single machine, but also helps when you interact with, for example, a PowerShell instance running on a remote Windows machine or in a container</p><p>To run Command-Line applications remotely (i.e. on remote machines, servers, or in containers), there is a challenge: Command-Line apps running on remote machines communicate with a local ConHost instance because IOCTL messages are not designed for use over a network connection. So how does input from a Console running on your client machine get to the remote machine, and how does output from the app running on the remote machine get back to your client Console? Further, what if you‚Äôre running a Linux or Mac machine that has Terminals, but not Windows-compatible Consoles, and don‚Äôt understand how Windows Console works?</p><p>So, to remotely operate a Windows machine we need a communications broker of some kind ‚Äì one that can transparently serialize data across some form of network connection and manage app instance lifetime, etc.</p><p>Something like <a target="_blank" href="https://en.wikipedia.org/wiki/Secure_Shell" rel="noopener noreferrer">ssh</a>, perhaps?</p><p>Thankfully, <a target="_blank" href="https://www.openssh.com/" rel="noopener noreferrer">OpenSSH</a> was recently <a target="_blank" href="https://github.com/PowerShell/Win32-OpenSSH" rel="noopener noreferrer">ported to Windows</a> and <a target="_blank" href="https://blogs.msdn.microsoft.com/commandline/2018/01/22/openssh-in-windows-10/" rel="noopener noreferrer">added as a Windows 10 optional feature</a>. PowerShell Core has also adopted ssh as one of its supported <a target="_blank" href="https://docs.microsoft.com/en-us/powershell/scripting/core-powershell/running-remote-commands" rel="noopener noreferrer">PowerShell Core Remoting</a> protocols. And for those who‚Äôve invested in Windows PowerShell, <a target="_blank" href="https://docs.microsoft.com/en-us/powershell/scripting/core-powershell/running-remote-commands?view=powershell-6#windows-powershell-remoting" rel="noopener noreferrer">Windows PowerShell Remoting</a> is still a viable option.</p><p>Let‚Äôs consider how <a target="_blank" href="https://github.com/PowerShell/Win32-OpenSSH" rel="noopener noreferrer">OpenSSH for Windows</a> allows us to remotely operate Windows Command-Line shells and apps today:</p><p><img src="https://devblogs.microsoft.com/wp-content/uploads/sites/33/2019/02/command-line-conpty-remoting-before-pty.png" alt="Command-Line Remoting Before ConPTY"></p><p>Currently, OpenSSH involves some unwanted convolutions:</p><ol><li>The user:<ol><li>Runs the ssh client and Windows attaches a Console instance as usual</li><li>Types into the Console which sends keystrokes to the ssh clent</li></ol></li><li>The ssh client:<ol><li>Reads input as bytes of text data</li><li>Sends the text data via the network to the listening sshd service</li></ol></li><li>The sshd service has to jump through several hoops:<ol><li>Launches the default shell (i.e. Cmd) which causes Windows to spawn &amp; connect a new Console instance</li><li>Finds &amp; attaches itself to the Cmd instance‚Äôs Console</li><li>Moves Console off-screen (and/or hides it)</li><li>Sends input data received from ssh client to the off-screen Console as input</li></ol></li><li>The cmd instance operates as it always has:<ol><li>Gathers input delivered by the sshd service</li><li>Does work</li><li>Calls Console APIs to emit/style text, move the cursor, etc.</li></ol></li><li>The attached [off-screen] Console:<ol><li>Executes the API calls, updating its output buffer</li></ol></li><li>The sshd service:<ol><li>Scrapes the off-screen Console‚Äôs output buffer, finds differences, encodes them into text/VT and sends them back to ‚Ä¶</li></ol></li><li>The ssh client which sends the text back to ‚Ä¶</li><li>The Console, which draws the text on the screen</li></ol><p><strong><em>Fun, right? No, it‚Äôs not!</em></strong> There‚Äôs a lot that can and does go wrong, especially in the process of simulating and sending user-input and scraping the output buffer to/from the off-screen Console. This results in instability, crashes, data corruption, excessive power consumption, etc. Further, not all apps do the work to scrape text properties as well as text itself, which results in text formatting being lost, and remoted applications‚Äô text being ‚Äúmonochromatized‚Äù!</p><h3 id="remoting-using-modern-conhost-and-conpty">Remoting Using Modern ConHost and ConPTY</h3><p><strong><em>Surely we can do better than this?</em></strong> Yes, yes we can ‚Äì let‚Äôs make a few architectural changes and use our new ConPTY:</p><p><img src="https://devblogs.microsoft.com/wp-content/uploads/sites/33/2019/02/command-line-conpty-remoting-with-pty.png" alt="Command-Line Remoting With ConPTY"></p><p>In the diagram above, we can see:</p><ol><li>The user:<ol><li>Runs the ssh client and Windows attaches a Console instance as usual</li><li>Types into the Console which sends keystrokes to the ssh clent</li></ol></li><li>The ssh client:<ol><li>Reads input as bytes of text data</li><li>Sends the text data via the network to the listening sshd service</li></ol></li><li>The sshd service:<ol><li>Creates stdin/stdout pipes</li><li>Calls the ConPTY API to create a ConPTY</li><li>Launches instance of Cmd attached to the other end of the ConPTY. Windows spins-up and attaches a new ConHost instance</li></ol></li><li>The cmd instance operates as it always has:<ol><li>Gathers input</li><li>Does work</li><li>Calls Console APIs to emit/style text, move the cursor, etc.</li></ol></li><li>The ConPTY ConHost instance:<ol><li>Executes the API calls, updating its output buffer</li><li>Renders changed regions of the output buffer as UTF-8 encoded text/VT which is sent back to the Console/Terminal via ssh</li></ol></li></ol><p>The ConPTY-enabled approach above is clearly much cleaner and simpler for the sshd service. The only Windows Console API calls are being executed entirely within a Command-Line app‚Äôs ConHost instance which converts any visible changes into text/VT: Nothing ConHost is connected to need know that the app its hosting calls Console APIs rather than generating text/VT itself!</p><p>We think you‚Äôll agree that this new ConPTY remoting mechanism results in an elegant, consistent, simpler architecture. Combined with the powerful features built into ConHost, supporting legacy apps, and rendering changes caused by apps calling Console APIs into text/VT, the new ConHost and ConPTY infrastructure helps us carry the past into the future.</p><blockquote><p>The ConPTY API is available in the current <a target="_blank" href="https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewSDK" rel="noopener noreferrer">Windows 10 Insider Preview SDK</a>. By now, I am sure you‚Äôre itching to see some code üòâ</p></blockquote><p>Let‚Äôs take a look at the API declarations:</p><pre><code><span>// Creates a "Pseudo Console" (ConPTY).</span><span>
HRESULT WINAPI </span><span>CreatePseudoConsole</span><span>(</span><span>
                                </span><span>_In_</span><span> COORD size</span><span>,</span><span>        </span><span>// ConPty Dimensions</span><span>
                                </span><span>_In_</span><span> HANDLE hInput</span><span>,</span><span>     </span><span>// ConPty Input</span><span>
                                </span><span>_In_</span><span> HANDLE hOutput</span><span>,</span><span>    </span><span>// ConPty Output</span><span>
                                </span><span>_In_</span><span> DWORD dwFlags</span><span>,</span><span>     </span><span>// ConPty Flags</span><span>
                                </span><span>_Out_</span><span> HPCON</span><span>*</span><span> phPC</span><span>);</span><span>     </span><span>// ConPty Reference</span><span>

</span><span>// Resizes the given ConPTY to the specified size, in characters.</span><span>
HRESULT WINAPI </span><span>ResizePseudoConsole</span><span>(</span><span>_In_</span><span> HPCON hPC</span><span>,</span><span> </span><span>_In_</span><span> COORD size</span><span>);</span><span>

</span><span>// Closes the ConPTY and all associated handles. Client applications attached </span><span>
</span><span>// to the ConPTY will also terminated. </span><span>
VOID WINAPI </span><span>ClosePseudoConsole</span><span>(</span><span>_In_</span><span> HPCON hPC</span><span>);</span></code></pre><p>The ConPTY API above essentially exposes three new functions:</p><ul><li><strong><code>CreatePseudoConsole(size, hInput, hOutput, dwFlags, phPC)</code></strong><ul><li>Creates a pty with dimensions of <code>w</code> columns and <code>h</code> rows of characters using pipes created by the caller:<ul><li><code>size</code>: Width and Height (in chars) of the ConPTY buffer</li><li><code>hInput</code>: For writing input to the PTY, encoded as UTF-8, text/VT sequences</li><li><code>hOutput</code>: For reading the output from the PTY, encoded as UTF-8, text/VT sequences</li><li><code>dwFlags</code>: Possible values:<ul><li><code>PSEUDOCONSOLE_INHERIT_CURSOR</code>: The created ConPTY will attempt to inherit the cursor position of the parent Terminal application</li></ul></li><li><code>phPC</code>: handle to a Console reference for the cerated ConPty</li></ul></li><li><strong>Returns</strong>: Success/failure. On success, <code>phPC</code> contains handle to the new ConPty</li></ul></li><li><strong><code>ResizePseudoConsole(hPC, size)</code></strong><ul><li>Resizes the given ConPTY‚Äôs internal buffer to represent a display of the specified character width and height</li></ul></li><li><strong><code>ClosePseudoConsole(hPC)</code></strong><ul><li>Closes the ConPTY and all associated handles. Client applications attached to the ConPTY will also terminated, as if they were running in a console window that was closed</li></ul></li></ul><h2 id="using-the-conpty-api">Using the ConPTY API<a href="#using-the-conpty-api"></a></h2><p>Below is a small code example of how to call the ConPTY API to create a Pseudo Console and attach a Command-Line application to the created ConPTY.</p><blockquote><p>Note: A simple sample illustrating how to use the Pseudo Console API is available <a target="_blank" href="https://github.com/Microsoft/console/tree/master/samples/ConPTY/EchoCon" rel="noopener noreferrer">here</a>.</p></blockquote><pre><code><span>    
    </span><span>// Note: Most error checking removed for brevity.  </span><span>
    </span><span>// ...</span><span>
    
    </span><span>// Initializes the specified startup info struct with the required properties and</span><span>
    </span><span>// updates its thread attribute list with the specified ConPTY handle</span><span>
    HRESULT </span><span>InitializeStartupInfoAttachedToConPTY</span><span>(</span><span>STARTUPINFOEX</span><span>*</span><span> siEx</span><span>,</span><span> HPCON hPC</span><span>)</span><span>
    </span><span>{</span><span>
        HRESULT hr </span><span>=</span><span> E_UNEXPECTED</span><span>;</span><span>
        </span><span>size_t</span><span> size</span><span>;</span><span>

        siEx</span><span>-&gt;</span><span>StartupInfo</span><span>.</span><span>cb </span><span>=</span><span> </span><span>sizeof</span><span>(</span><span>STARTUPINFOEX</span><span>);</span><span>
        
        </span><span>// Create the appropriately sized thread attribute list</span><span>
        </span><span>InitializeProcThreadAttributeList</span><span>(</span><span>NULL</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>&amp;</span><span>size</span><span>);</span><span>
        std</span><span>::</span><span>unique_ptr</span><span>&lt;</span><span>BYTE</span><span>[]&gt;</span><span> attrList </span><span>=</span><span> std</span><span>::</span><span>make_unique</span><span>&lt;</span><span>BYTE</span><span>[]&gt;(</span><span>size</span><span>);</span><span>
        
        </span><span>// Set startup info's attribute list &amp; initialize it</span><span>
        siEx</span><span>-&gt;</span><span>lpAttributeList </span><span>=</span><span> </span><span>reinterpret_cast</span><span>&lt;</span><span>PPROC_THREAD_ATTRIBUTE_LIST</span><span>&gt;(</span><span>
            attrList</span><span>.</span><span>get</span><span>());</span><span>
        </span><span>bool</span><span> fSuccess </span><span>=</span><span> </span><span>InitializeProcThreadAttributeList</span><span>(</span><span>
            siEx</span><span>-&gt;</span><span>lpAttributeList</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>(</span><span>PSIZE_T</span><span>)&amp;</span><span>size</span><span>);</span><span>
            
        </span><span>if</span><span> </span><span>(</span><span>fSuccess</span><span>)</span><span>
        </span><span>{</span><span>
            </span><span>// Set thread attribute list's Pseudo Console to the specified ConPTY</span><span>
            fSuccess </span><span>=</span><span> </span><span>UpdateProcThreadAttribute</span><span>(</span><span>
                            lpAttributeList</span><span>,</span><span>
                            </span><span>0</span><span>,</span><span>
                            PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE</span><span>,</span><span>
                            hPC</span><span>,</span><span>
                            </span><span>sizeof</span><span>(</span><span>HPCON</span><span>),</span><span>
                            NULL</span><span>,</span><span>
                            NULL</span><span>);</span><span>
            </span><span>return</span><span> fSuccess </span><span>?</span><span> S_OK </span><span>:</span><span> HRESULT_FROM_WIN32</span><span>(</span><span>GetLastError</span><span>());</span><span>
        </span><span>}</span><span>
        </span><span>else</span><span>
        </span><span>{</span><span>
            hr </span><span>=</span><span> HRESULT_FROM_WIN32</span><span>(</span><span>GetLastError</span><span>());</span><span>
        </span><span>}</span><span>
        </span><span>return</span><span> hr</span><span>;</span><span>
    </span><span>}</span><span>
    
    </span><span>// ...</span><span>
    
    HANDLE hOut</span><span>,</span><span> hIn</span><span>;</span><span>
    HANDLE outPipeOurSide</span><span>,</span><span> inPipeOurSide</span><span>;</span><span>
    HANDLE outPipePseudoConsoleSide</span><span>,</span><span> inPipePseudoConsoleSide</span><span>;</span><span>
    HPCON hPC </span><span>=</span><span> </span><span>0</span><span>;</span><span>

    </span><span>// Create the in/out pipes:</span><span>
    </span><span>CreatePipe</span><span>(&amp;</span><span>inPipePseudoConsoleSide</span><span>,</span><span> </span><span>&amp;</span><span>inPipeOurSide</span><span>,</span><span> NULL</span><span>,</span><span> </span><span>0</span><span>);</span><span>
    </span><span>CreatePipe</span><span>(&amp;</span><span>outPipeOurSide</span><span>,</span><span> </span><span>&amp;</span><span>outPipePseudoConsoleSide</span><span>,</span><span> NULL</span><span>,</span><span> </span><span>0</span><span>);</span><span>

    </span><span>// Create the Pseudo Console, using the pipes</span><span>
    </span><span>CreatePseudoConsole</span><span>(</span><span>
        </span><span>{</span><span>80</span><span>,</span><span> </span><span>32</span><span>},</span><span> 
        inPipePseudoConsoleSide</span><span>,</span><span> 
        outPipePseudoConsoleSide</span><span>,</span><span> 
        </span><span>0</span><span>,</span><span> 
        </span><span>&amp;</span><span>hPC</span><span>);</span><span>

    </span><span>// Prepare the StartupInfoEx structure attached to the ConPTY.</span><span>
    STARTUPINFOEX siEx</span><span>{};</span><span>
    </span><span>InitializeStartupInfoAttachedToConPTY</span><span>(&amp;</span><span>siEx</span><span>,</span><span> hPC</span><span>);</span><span>

    </span><span>// Create the client application, using startup info containing ConPTY info</span><span>
    </span><span>wchar_t</span><span>*</span><span> commandline </span><span>=</span><span> L</span><span>"c:\\windows\\system32\\cmd.exe"</span><span>;</span><span>
    PROCESS_INFORMATION piClient</span><span>{};</span><span>
    fSuccess </span><span>=</span><span> </span><span>CreateProcessW</span><span>(</span><span>
                    </span><span>nullptr</span><span>,</span><span>
                    commandline</span><span>,</span><span>
                    </span><span>nullptr</span><span>,</span><span>
                    </span><span>nullptr</span><span>,</span><span>
                    TRUE</span><span>,</span><span>
                    EXTENDED_STARTUPINFO_PRESENT</span><span>,</span><span>
                    </span><span>nullptr</span><span>,</span><span>
                    </span><span>nullptr</span><span>,</span><span>
                    </span><span>&amp;</span><span>siEx</span><span>-&gt;</span><span>StartupInfo</span><span>,</span><span>
                    </span><span>&amp;</span><span>piClient</span><span>);</span><span>

    </span><span>// ...</span></code></pre><p>At this point, cmd.exe is running connected to the ConPTY created by <code>CreatePseudoConsole()</code>. The caller uses the ConPTY‚Äôs handles that it created to write and read to/from the Cmd instance. The Pseudo Console can be resized by calling <code>ResizePseudoConsole()</code>, and can be closed by calling <code>ClosePseudoConsole()</code>:</p><h3 id="writing-to-pseudo-console">Writing to Pseudo Console</h3><p>Writing input to the ConPTY is simple:</p><pre><code><span>// Input "echo Hello, World!", press enter to have cmd process the command,</span><span>
</span><span>//  input an up arrow (to get the previous command), and enter again to execute.</span><span>
std</span><span>::</span><span>string helloWorld </span><span>=</span><span> </span><span>"echo Hello, World!\n\x1b[A\n"</span><span>;</span><span>
DWORD dwWritten</span><span>;</span><span>
</span><span>WriteFile</span><span>(</span><span>hIn</span><span>,</span><span> helloWorld</span><span>.</span><span>c_str</span><span>(),</span><span> </span><span>(</span><span>DWORD</span><span>)</span><span>helloWorld</span><span>.</span><span>length</span><span>(),</span><span> </span><span>&amp;</span><span>dwWritten</span><span>,</span><span> </span><span>nullptr</span><span>);</span></code></pre><h3 id="resizing-the-pseudo-console">Resizing the Pseudo Console</h3><p>This scenario shows how to resize the ConPTY:</p><pre><code><span>// Suppose some other async callback triggered us to resize.</span><span>
</span><span>//      This call will update the Terminal with the size we received.</span><span>
HRESULT hr </span><span>=</span><span> </span><span>ResizePseudoConsole</span><span>(</span><span>hPC</span><span>,</span><span> </span><span>{</span><span>120</span><span>,</span><span> </span><span>30</span><span>});</span></code></pre><h3 id="closing-the-pseudo-console">Closing the Pseudo Console</h3><p>Closing the ConPTY couldn‚Äôt be simpler:</p><pre><code><span>ClosePseudoConsole</span><span>(</span><span>hPC</span><span>);</span></code></pre><p>Note: Closing the ConPTY will terminate the associated ConHost and any attached clients.</p><p>The introduction of the ConPTY API is perhaps one of the most fundamental, and liberating, changes that‚Äôs happened to the Windows Command-Line in several years ‚Ä¶ if not <em>decades</em>!</p><p>We, the Console team, have already ported some of Microsoft‚Äôs tools to use the ConPTY API. We‚Äôre also working with several teams inside Microsoft (Windows Subsystem for Linux (WSL), Windows Containers, VSCode, Visual Studio, etc.), and with several external parties including <a target="_blank" href="https://twitter.com/ConEmuMaximus5" rel="noopener noreferrer">@ConEmuMaximus5</a> ‚Äì creator of the awesome <a target="_blank" href="https://conemu.github.io/" rel="noopener noreferrer">ConEmu</a> 3rd party Console for Windows.</p><p><strong><em>But we need your help</em></strong> to raise awareness of, and to start adopting the new ConPTY API:</p><h2 id="command-line-application-developers">Command-Line Application Developers<a href="#command-line-application-developers"></a></h2><p>If you own and/or maintain an existing traditional Windows Command-Line application, you‚Äôre largely off the hook and don‚Äôt have much to do: ConHost will do all the work for you ‚Äì you can continue to depend upon and call the Console API‚Äôs as you always have, and your app will work just as it always has, while also benefitting from improved, higher-fidelity experience if operated remotely üòÉ</p><p>But if you‚Äôd like to, you can also introduce new VT support gradually or in new feature areas if you wish ‚Äì the decision is yours.</p><p>If, on the other hand you‚Äôre currently or are planning on writing <strong><em>new</em></strong> Windows Command-Line applications, we strongly encourage you to consider simply emitting UTF-8 encoded text/VT instead of calling the Windows Console API: ‚ÄúSpeaking VT‚Äù will give you access to many features that will not be available via the Windows Console API (e.g. <a target="_blank" href="https://blogs.msdn.microsoft.com/commandline/2016/09/22/24-bit-color-in-the-windows-console/" rel="noopener noreferrer">16M RGB True Color support</a>)</p><h2 id="3rd-party-consoleservice-developers">3rd Party Console/Service Developers<a href="#3rd-party-consoleservice-developers"></a></h2><p>If you‚Äôre a developer working on a stand-alone Console/Terminal app, or are integrating a Console inside of an application, then we strongly encourage you to explore and adopt the new ConPTY API at your earliest convenience: Adopting the ConPTY API (rather than the older off-screen Console mechanism) is likely to eliminate several classes of bugs, while increasing stability, reliability, and performance.</p><blockquote><p>As an example, the VSCode team currently maintains an issue (<a target="_blank" href="https://github.com/Microsoft/vscode/issues/45693" rel="noopener noreferrer">GitHub #45693</a>) that tracks several issues caused by Windows‚Äô current lack of a Pseudo Console.</p></blockquote><h2 id="detecting-the-conpty-api">Detecting the ConPTY API<a href="#detecting-the-conpty-api"></a></h2><p>The new ConPTY API will be available for the first time in the Autumn/Fall 2018 release of Windows 10.</p><p>If you need to support earlier versions of Windows, then you‚Äôll likely need to test at runtime whether the currently running version of Windows supports ConPTY. As with most Win32 API‚Äôs an effective way to test if an API is present is to use <a target="_blank" rel="noopener noreferrer">Runtime Dynamic Linking</a> approach of calling <a target="_blank" rel="noopener noreferrer"><code>LoadLibrary()</code></a> &amp; <a target="_blank" rel="noopener noreferrer"><code>GetProcAddress()</code></a>.</p><p>If the currently running version of Windows supports ConPTY, your app can find and call the new ConPTY APIs. If not, you‚Äôll have to revert to the convoluted mechanisms used until now, as outlined above.</p><p>Another long post ‚Ä¶ this is getting to be a habit! Once again, if you‚Äôve read and followed the post this far, <strong>THANK YOU</strong>! üòÉ</p><p>There‚Äôs a lot to unpack from the information above, but we feel it is important to understand <em>why</em> we make changes and improvements such as introducing a Pseudo Console API, as well as <em>what</em> we built. Our goals here are to eradicate an entire class of issues and limitations for developers of Console and server apps, and to make developing code for the Windows Command Line infrastructure more powerful, consistent, and fun.</p><p>We look forward to hearing from you via <a href="https://insider.windows.com/en-us/how-to-feedback/" target="_blank">Feedback Hub</a>. For more complex problems, please file issues on our <a target="_blank" href="https://github.com/microsoft/console" rel="noopener noreferrer">Windows Console GitHub Repo</a>. And if you have questions, please <a target="_blank" href="https://twitter.com/richturn_ms" rel="noopener noreferrer">ping me on Twitter</a>.</p><p>We can‚Äôt wait to hear about what you build atop the new Pseudo Console API.</p><p>Rich &amp; the Windows Console Team: <img src="https://devblogs.microsoft.com/wp-content/uploads/sites/33/2019/02/Team-Console.png" alt="Team Console"></p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>