<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The ReaderT Design Pattern -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>The ReaderT Design Pattern</h1><div><div id="hs_cos_wrapper_post_body" class="hs_cos_wrapper hs_cos_wrapper_meta_field hs_cos_wrapper_type_rich_text"><p>Often times I'll receive or read questions online about "design patterns" in Haskell. A common response is that Haskell doesn't have them. What many languages address via patterns, in Haskell we address via language features (like built-in immutability, lambdas, laziness, etc). However, I believe there is still room for some high-level guidance on structuring programs, which I'll loosely refer to as a Haskell design pattern.</p><p>The pattern I'm going to describe today is what I've been referring to as the "ReaderT pattern" for a few years now, at least in informal discussions. I use it as the basis for the design of Yesod's <code>Handler</code> type, it describes the majority of the Stack code base, and I've recommended it to friends, colleagues, and customers regularly.</p><p>That said, this pattern is not universally held in the Haskell world, and plenty of people design their code differently. So remember that, like <a href="/blog/2016/11/exceptions-best-practices-haskell">other articles I've written</a>, this is highly opinionated, but represents my personal and FP Complete's best practices recommendations.</p><p>Let's summarize the pattern, and then get into details and exceptions:</p><ul><li>Your application should define a core data type (call it <code>Env</code> if you want).</li><li>This data type will contain all runtime configuration and global functions that may be mockable (like logging functions or database access).</li><li>If you must have some mutable state, put it in <code>Env</code> as a mutable reference (<code>IORef</code>, <code>TVar</code>, etc).</li><li>Your application code will, in general, live in <code>ReaderT Env
IO</code>. Define it as <code>type App = ReaderT Env IO</code> if you wish, or use a newtype wrapper instead of <code>ReaderT</code> directly.</li><li>You can use additional monad transformers on occassion, but only for small subsets of your application, and it's best if those subsets are pure code.</li><li>Optional: instead of directly using the <code>App</code> datatype, write your functions in terms of mtl-style typeclasses like <code>MonadReader</code> and <code>MonadIO</code>, which will allow you to recover some of the purity you think I just told you to throw away with <code>IO</code> and mutable references.</li></ul><p>That's a lot to absorb all at once, some of it (like the mtl typeclasses) may be unclear, and other parts (especially that mutable reference bit) probably seems completely wrong. Let me motivate these statements and explain the nuances.</p><h2 id="better-globals">Better globals</h2><p>Let's knock out the easy parts of this. Global variables are bad, and mutable globals are far worse. Let's say you have an application which wants to configure its logging level (e.g., should we print or swallow DEBUG level messages?). There are three common ways you might do this in Haskell:</p><ol><li>Use a compile-time flag to control which logging code gets included in your executable</li><li>Define a global value which reads a config file (or environment variables) with <code>unsafePerformIO</code></li><li>Read the config file in your <code>main</code> function and then pass the value (explicitly, or implicitly via <code>ReaderT</code>) to the rest of your code</li></ol><p>(1) is tempting, but experience tells me it's a terrible solution. Every time you have conditional compilation in your codebase, you're adding in a fractal of possible build failures. If you have 5 conditionals, you now have 32 (2^5) possible build configurations. Are you sure you have the right set of import statements for all of those 32 configurations? It's just a pain to deal with. Moreover, do you really want to decide at <i>compile time</i> that you're not going to need debug information? I'd much rather be able to flip a <code>false</code> to <code>true</code> in a config file and restart my app to get more information while debugging.</p><p>(By the way, even better than this is the ability to signal the process <i>while it's running</i> to change debug levels, but we'll leave that out for now. The <code>ReaderT</code>+mutable variable pattern is one of the best ways to achieve this.)</p><p>OK, so you've agreed with me that you shouldn't conditionally compile. Now that you've written your whole application, however, you're probably hesitant to have to rewrite it to thread through some configuration value everywhere. I get that, it's a pain. So you decide you'll just use <code>unsafePerformIO</code>, since the file will be read once, it's a pure-ish value for the entire runtime, and everything seems mostly safe. However:</p><ul><li>You now have a slight level of non-determinism of where exceptions will occur. If you have a missing or invalid config file, where will the exception get thrown from? I'd much rather that occur immediately on app initialization.</li><li>Suppose you want to run one small part of the application with louder debug information (because you know it's more likely to fail thant the rest of your code). You basically can't do this at all.</li><li>Just wait until you use STM inside your config file parsing for some reason, and then your config value first gets evaluated inside a <i>different</i> STM block. (And <a href="https://github.com/snoyberg/yaml/issues/86">there's no way that could ever happen</a>.)</li><li>Every time you use <code>unsafePerformIO</code>, a kitten dies.</li></ul><p>It's time to just bite the bullet, define some <code>Env</code> data type, put the config file values in it, and thread it through your application. If you design your application from the beginning like this: great, no harm done. Doing it later in application development is certainly a pain, but the pain can be mitigated by some of what I'll say below. And it is <i>absolutely</i> better to suck up a little pain with mechanical code rewriting than be faced with race conditions around <code>unsafePerformIO</code>. Remember, this is Haskell: we'd rather face compile time rather than runtime pain.</p><p>Once you've accepted your fate and gone all-in on (3), you're on easy street:</p><ul><li>Have some new config value to pass around? Easy, just augment the <code>Env</code> type.</li><li>Want to temporarily bump the log level? Use <code>local</code> and you're golden</li></ul><p>You're now far less likely to resort to ugly hacks like CPP code (1) or global variables (2), because you've eliminated the potential pain from doing it the Right Way.</p><h3 id="initializing-resources">Initializing resources</h3><p>The case of reading a config value is nice, but even nicer is initializing some resources. Suppose you want to initialize a random number generator, open up a <code>Handle</code> for sending log messages to, set up a database pool, or create a temporary directory to store files in. These are all far more logical to do inside <code>main</code> than from some global position.</p><p>One advantage of the global variable approach for these kinds of initializations is that it can be defered until the first time the value is used, which is nice if you think some resources may not always be needed. But if that's what you want, you can use an approach like <a href="https://github.com/commercialhaskell/stack/blob/master/src/Data/IORef/RunOnce.hs"><code>runOnce</code></a>.</p><h2 id="avoiding-writert-and-statet">Avoiding WriterT and StateT</h2><p>Why in the world would I ever recommend mutable references as anything but a last resort? We all know that purity in Haskell is paramount, and mutability is the devil. And besides, we have these wonderful things called <code>WriterT</code> and <code>StateT</code> if we have some values that need to change over time in our application, so why not use them?</p><p>In fact, early versions of Yesod did just that: they used a <code>StateT</code> kind of approach within <code>Handler</code> to allow you to modify the user session values and set response headers. However, I switched over to mutable references quite a while ago, and here's why:</p><p><strong>Exception-survival</strong> If you have a runtime exception, you will <i>lose your state</i> in <code>WriterT</code> and <code>StateT</code>. Not so with a mutable reference: you can read the last available state before the runtime exception was thrown. We use this to great benefit in Yesod, to be able to set response headers even if the response fails with something like a <code>notFound</code>.</p><p><strong>False purity</strong> We say <code>WriterT</code> and <code>StateT</code> are pure, and technically they are. But let's be honest: if you have an application which is entirely living within a <code>StateT</code>, you're not getting the benefits of restrained mutation that you want from pure code. May as well call a spade a spade, and accept that you have a mutable variable.</p><p><strong>Concurrency</strong> What's the result of <code>put 4 &gt;&gt; concurrently (modify (+
1)) (modify (+ 2)) &gt;&gt; get</code>? You may <i>want</i> to say that it will be <code>7</code>, but it definitely won't be. Your options, depending on how <code>concurrently</code> is implemented with regards to the state provided by <code>StateT</code>, are <code>4</code>, <code>5</code>, or <code>6</code>. Don't believe me? Play around with:</p><pre><span class="hs-cpp">#!/</span><span class="hs-varid">usr</span><span class="hs-varop">/</span><span class="hs-varid">bin</span><span class="hs-varop">/</span><span class="hs-varid">env</span><span class="hs-varid">stack</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">Async</span><span class="hs-varop">.</span><span class="hs-conid">Lifted</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Monad</span><span class="hs-varop">.</span><span class="hs-conid">State</span><span class="hs-varop">.</span><span class="hs-conid">Strict</span><span class="hs-definition">main</span><span class="hs-keyglyph">::</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-definition">main</span><span class="hs-keyglyph">=</span><span class="hs-varid">execStateT</span><span class="hs-layout">(</span><span class="hs-varid">concurrently</span><span class="hs-layout">(</span><span class="hs-varid">modify</span><span class="hs-layout">(</span><span class="hs-varop">+</span><span class="hs-num">1</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">(</span><span class="hs-varid">modify</span><span class="hs-layout">(</span><span class="hs-varop">+</span><span class="hs-num">2</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-num">4</span><span class="hs-varop">&gt;&gt;=</span><span class="hs-varid">print</span></pre><p>The issue is that we need to clone the state from the parent thread into both child threads, and then <i>arbitrarily pick</i> which child state will survive. Or, if we want to, we can just throw both child states away and continue with the original parent state. (By the way, if you think the fact that this code compiles is a bad thing, I agree, and suggest you use <code>Control.Concurrent.Async.Lifted.Safe</code>.)</p><p>Dealing with mutable state between different threads is a hard problem, but <code>StateT</code> doesn't <i>fix</i> the problem, it <i>hides</i> it. If you use a mutable variable, you'll be forced to think about this. What semantics do we want? Should we use an <code>IORef</code>, and stick to <code>atomicModifyIORef</code>? Should we use a <code>TVar</code>? These are fair questions, and ones we'll be forced to examine. For a <code>TVar</code>-like approach:</p><pre><span class="hs-cpp">#!/</span><span class="hs-varid">usr</span><span class="hs-varop">/</span><span class="hs-varid">bin</span><span class="hs-varop">/</span><span class="hs-varid">env</span><span class="hs-varid">stack</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">Async</span><span class="hs-varop">.</span><span class="hs-conid">Lifted</span><span class="hs-varop">.</span><span class="hs-conid">Safe</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Monad</span><span class="hs-varop">.</span><span class="hs-conid">Reader</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">STM</span><span class="hs-definition">modify</span><span class="hs-keyglyph">::</span><span class="hs-layout">(</span><span class="hs-conid">MonadReader</span><span class="hs-layout">(</span><span class="hs-conid">TVar</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-varid">m</span><span class="hs-layout">,</span><span class="hs-conid">MonadIO</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyglyph">=&gt;</span><span class="hs-layout">(</span><span class="hs-conid">Int</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">m</span><span class="hs-conid">()</span><span class="hs-definition">modify</span><span class="hs-varid">f</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">ref</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">ask</span><span class="hs-varid">liftIO</span><span class="hs-varop">$</span><span class="hs-varid">atomically</span><span class="hs-varop">$</span><span class="hs-varid">modifyTVar'</span><span class="hs-varid">ref</span><span class="hs-varid">f</span><span class="hs-definition">main</span><span class="hs-keyglyph">::</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-definition">main</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">ref</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">newTVarIO</span><span class="hs-num">4</span><span class="hs-varid">runReaderT</span><span class="hs-layout">(</span><span class="hs-varid">concurrently</span><span class="hs-layout">(</span><span class="hs-varid">modify</span><span class="hs-layout">(</span><span class="hs-varop">+</span><span class="hs-num">1</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">(</span><span class="hs-varid">modify</span><span class="hs-layout">(</span><span class="hs-varop">+</span><span class="hs-num">2</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-varid">ref</span><span class="hs-varid">readTVarIO</span><span class="hs-varid">ref</span><span class="hs-varop">&gt;&gt;=</span><span class="hs-varid">print</span></pre><p>And you can even get a little fancier with <a href="https://www.stackage.org/package/monad-unlift-ref">prebaked transformers</a>.</p><p><strong>WriterT is broken</strong> Don't forget that, as Gabriel Gonzalez has demonstrated, <a href="https://mail.haskell.org/pipermail/libraries/2012-October/018599.html">even the strict <code>WriterT</code> has a space leak</a>.</p><p><strong>Caveats</strong> I still do use <code>StateT</code> and <code>WriterT</code> sometimes. One prime example is Yesod's <code>WidgetT</code>, which is essentially a <code>WriterT</code> sitting on top of <code>HandlerT</code>. It makes sense in that context because:</p><ul><li>The mutable state is expected to be modified for a small subset of the application</li><li>Although we can perform side-effects while building up the widget, the widget construction itself is a morally pure activity</li><li>We don't need to let state survive an exception: if something goes wrong, we'll send back an error page instead</li><li>There's no good reason to use concurrency when constructing a widget.</li><li>Despite my space leak concerns, I thoroughly benchmarked <code>WriterT</code> against alternatives, and found it to be the fastest for this use case. (Numbers beat reasoning.)</li></ul><p>The other great exception to this rule is pure code. If you have some subset of your application which can perform no <code>IO</code> but needs some kind of mutable state, absolutely, 100%, please use <code>StateT</code>.</p><h2 id="avoiding-exceptt">Avoiding ExceptT</h2><p>I'm already <a href="/blog/2016/11/exceptions-best-practices-haskell">strongly on record</a> as saying that <code>ExceptT</code> over <code>IO</code> is a bad idea. To briefly repeat myself: the contract of <code>IO</code> is that any exception can be thrown at any time, so <code>ExceptT</code> doesn't actually document possible exceptions, it misleads. You can see that blog post for more details.</p><p>I'm rehashing this here because some of the downsides of <code>StateT</code> and <code>WriterT</code> apply to <code>ExceptT</code> as well. For example, how do you handle concurrency in an <code>ExceptT</code>? With runtime exceptions, the behavior is clear: when using <code>concurrently</code>, if any child thread throws an exception, the other thread is killed and the exception rethrown in the parent. What behavior do you want with <code>ExceptT</code>?</p><p>Again, you can use <code>ExceptT</code> from pure code where a runtime exception is not part of the contract, just like you should use <code>StateT</code> in pure code. But once we've eliminated <code>StateT</code>, <code>WriterT</code>, and <code>ExceptT</code> from our main application transformers, we're left with...</p><h2 id="just-readert">Just ReaderT</h2><p>And now you know why I call this "the ReaderT design pattern." <code>ReaderT</code> has a huge advantage over the other three transformers listed: <i>it has no mutable state</i>. It's simply a convenient manner of passing an extra parameter to all functions. And even if that parameter contains mutable references, that parameter itself is fully immutable. Given that:</p><ul><li>We get to ignore all of the state-overwriting issues I mentioned with concurrency. Notice how we were able to use the <code>.Safe</code> module in the example above. That's because it is <i>actually safe</i> to do concurrency with a <code>ReaderT</code>.</li><li>Similarly, you can use the <a href="https://www.stackage.org/package/monad-unlift"><code>monad-unlift</code> library</a> package</li><li>Deep monad transformer stacks are confusing. Knocking it all down to just one transformer reduces complexity, significantly.</li><li>It's not just simpler for you. It's simpler for GHC too, which tends to have a much better time optimizing one-layer <code>ReaderT</code> code versus 5-transformer-deep code.</li></ul><p>By the way, once you've bought into <code>ReaderT</code>, you can just throw it away entirely, and manually pass your <code>Env</code> around. Most of us don't do that, because it feels masochistic (imagine having to tell <i>every call to <code>logDebug</code></i> where to get the logging function). But if you're trying to write a simpler codebase that doesn't require understanding of transformers, it's now within your grasp.</p><h2 id="has-typeclass-approach">Has typeclass approach</h2><p>Let's say we're going to expand our mutable variable example above to include a logging function. It may look something like this:</p><pre><span class="hs-cpp">#!/</span><span class="hs-varid">usr</span><span class="hs-varop">/</span><span class="hs-varid">bin</span><span class="hs-varop">/</span><span class="hs-varid">env</span><span class="hs-varid">stack</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">Async</span><span class="hs-varop">.</span><span class="hs-conid">Lifted</span><span class="hs-varop">.</span><span class="hs-conid">Safe</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Monad</span><span class="hs-varop">.</span><span class="hs-conid">Reader</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">STM</span><span class="hs-keyword">import</span><span class="hs-conid">Say</span><span class="hs-keyword">data</span><span class="hs-conid">Env</span><span class="hs-keyglyph">=</span><span class="hs-conid">Env</span><span class="hs-layout">{</span><span class="hs-varid">envLog</span><span class="hs-keyglyph">::</span><span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-layout">)</span><span class="hs-layout">,</span><span class="hs-varid">envBalance</span><span class="hs-keyglyph">::</span><span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-conid">TVar</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-layout">}</span><span class="hs-definition">modify</span><span class="hs-keyglyph">::</span><span class="hs-layout">(</span><span class="hs-conid">MonadReader</span><span class="hs-conid">Env</span><span class="hs-varid">m</span><span class="hs-layout">,</span><span class="hs-conid">MonadIO</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyglyph">=&gt;</span><span class="hs-layout">(</span><span class="hs-conid">Int</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">m</span><span class="hs-conid">()</span><span class="hs-definition">modify</span><span class="hs-varid">f</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">env</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">ask</span><span class="hs-varid">liftIO</span><span class="hs-varop">$</span><span class="hs-varid">atomically</span><span class="hs-varop">$</span><span class="hs-varid">modifyTVar'</span><span class="hs-layout">(</span><span class="hs-varid">envBalance</span><span class="hs-varid">env</span><span class="hs-layout">)</span><span class="hs-varid">f</span><span class="hs-definition">logSomething</span><span class="hs-keyglyph">::</span><span class="hs-layout">(</span><span class="hs-conid">MonadReader</span><span class="hs-conid">Env</span><span class="hs-varid">m</span><span class="hs-layout">,</span><span class="hs-conid">MonadIO</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyglyph">=&gt;</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">m</span><span class="hs-conid">()</span><span class="hs-definition">logSomething</span><span class="hs-varid">msg</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">env</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">ask</span><span class="hs-varid">liftIO</span><span class="hs-varop">$</span><span class="hs-varid">envLog</span><span class="hs-varid">env</span><span class="hs-varid">msg</span><span class="hs-definition">main</span><span class="hs-keyglyph">::</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-definition">main</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">ref</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">newTVarIO</span><span class="hs-num">4</span><span class="hs-keyword">let</span><span class="hs-varid">env</span><span class="hs-keyglyph">=</span><span class="hs-conid">Env</span><span class="hs-layout">{</span><span class="hs-varid">envLog</span><span class="hs-keyglyph">=</span><span class="hs-varid">sayString</span><span class="hs-layout">,</span><span class="hs-varid">envBalance</span><span class="hs-keyglyph">=</span><span class="hs-varid">ref</span><span class="hs-layout">}</span><span class="hs-varid">runReaderT</span><span class="hs-layout">(</span><span class="hs-varid">concurrently</span><span class="hs-layout">(</span><span class="hs-varid">modify</span><span class="hs-layout">(</span><span class="hs-varop">+</span><span class="hs-num">1</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">(</span><span class="hs-varid">logSomething</span><span class="hs-str">"Increasing account balance"</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-varid">env</span><span class="hs-varid">balance</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">readTVarIO</span><span class="hs-varid">ref</span><span class="hs-varid">sayString</span><span class="hs-varop">$</span><span class="hs-str">"Final balance: "</span><span class="hs-varop">++</span><span class="hs-varid">show</span><span class="hs-varid">balance</span></pre><p>Your first reaction to this is probably that defining this <code>Env</code> data type for your application looks like overhead and boilerplate. You're right, it is. Like I said above though, it's better to just suck up some of the pain initially to make a better long-term application development practice. Now let me double down on that...</p><p>There's a bigger problem with this code: it's <i>too coupled</i>. Our <code>modify</code> function takes in an entire <code>Env</code> value, even though it never uses the logging function. And similarly, <code>logSomething</code> never uses the mutable variable it's provided. Exposing too much state to a function is bad:</p><ul><li>We can't, from the type signature, get any idea about what the code is doing</li><li>It's more difficult to test. In order to see if <code>modify</code> is doing the right thing, we need to provide it some garbage logging function.</li></ul><p>So let's double down on that boilerplate, and use the <code>Has</code> typeclass trick. This composes well with <code>MonadReader</code> and other mtl classes like <code>MonadThrow</code> and <code>MonadIO</code> to allow us to state <i>exactly</i> what our function needs, at the cost of having to define a lot of typeclasses upfront. Let's see how this looks:</p><pre><span class="hs-cpp">#!/</span><span class="hs-varid">usr</span><span class="hs-varop">/</span><span class="hs-varid">bin</span><span class="hs-varop">/</span><span class="hs-varid">env</span><span class="hs-varid">stack</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">Async</span><span class="hs-varop">.</span><span class="hs-conid">Lifted</span><span class="hs-varop">.</span><span class="hs-conid">Safe</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Monad</span><span class="hs-varop">.</span><span class="hs-conid">Reader</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">STM</span><span class="hs-keyword">import</span><span class="hs-conid">Say</span><span class="hs-keyword">data</span><span class="hs-conid">Env</span><span class="hs-keyglyph">=</span><span class="hs-conid">Env</span><span class="hs-layout">{</span><span class="hs-varid">envLog</span><span class="hs-keyglyph">::</span><span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-layout">)</span><span class="hs-layout">,</span><span class="hs-varid">envBalance</span><span class="hs-keyglyph">::</span><span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-conid">TVar</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-layout">}</span><span class="hs-keyword">class</span><span class="hs-conid">HasLog</span><span class="hs-varid">a</span><span class="hs-keyword">where</span><span class="hs-varid">getLog</span><span class="hs-keyglyph">::</span><span class="hs-varid">a</span><span class="hs-keyglyph">-&gt;</span><span class="hs-layout">(</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-layout">)</span><span class="hs-keyword">instance</span><span class="hs-conid">HasLog</span><span class="hs-layout">(</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-layout">)</span><span class="hs-keyword">where</span><span class="hs-varid">getLog</span><span class="hs-keyglyph">=</span><span class="hs-varid">id</span><span class="hs-keyword">instance</span><span class="hs-conid">HasLog</span><span class="hs-conid">Env</span><span class="hs-keyword">where</span><span class="hs-varid">getLog</span><span class="hs-keyglyph">=</span><span class="hs-varid">envLog</span><span class="hs-keyword">class</span><span class="hs-conid">HasBalance</span><span class="hs-varid">a</span><span class="hs-keyword">where</span><span class="hs-varid">getBalance</span><span class="hs-keyglyph">::</span><span class="hs-varid">a</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">TVar</span><span class="hs-conid">Int</span><span class="hs-keyword">instance</span><span class="hs-conid">HasBalance</span><span class="hs-layout">(</span><span class="hs-conid">TVar</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-keyword">where</span><span class="hs-varid">getBalance</span><span class="hs-keyglyph">=</span><span class="hs-varid">id</span><span class="hs-keyword">instance</span><span class="hs-conid">HasBalance</span><span class="hs-conid">Env</span><span class="hs-keyword">where</span><span class="hs-varid">getBalance</span><span class="hs-keyglyph">=</span><span class="hs-varid">envBalance</span><span class="hs-definition">modify</span><span class="hs-keyglyph">::</span><span class="hs-layout">(</span><span class="hs-conid">MonadReader</span><span class="hs-varid">env</span><span class="hs-varid">m</span><span class="hs-layout">,</span><span class="hs-conid">HasBalance</span><span class="hs-varid">env</span><span class="hs-layout">,</span><span class="hs-conid">MonadIO</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyglyph">=&gt;</span><span class="hs-layout">(</span><span class="hs-conid">Int</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">m</span><span class="hs-conid">()</span><span class="hs-definition">modify</span><span class="hs-varid">f</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">env</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">ask</span><span class="hs-varid">liftIO</span><span class="hs-varop">$</span><span class="hs-varid">atomically</span><span class="hs-varop">$</span><span class="hs-varid">modifyTVar'</span><span class="hs-layout">(</span><span class="hs-varid">getBalance</span><span class="hs-varid">env</span><span class="hs-layout">)</span><span class="hs-varid">f</span><span class="hs-definition">logSomething</span><span class="hs-keyglyph">::</span><span class="hs-layout">(</span><span class="hs-conid">MonadReader</span><span class="hs-varid">env</span><span class="hs-varid">m</span><span class="hs-layout">,</span><span class="hs-conid">HasLog</span><span class="hs-varid">env</span><span class="hs-layout">,</span><span class="hs-conid">MonadIO</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyglyph">=&gt;</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">m</span><span class="hs-conid">()</span><span class="hs-definition">logSomething</span><span class="hs-varid">msg</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">env</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">ask</span><span class="hs-varid">liftIO</span><span class="hs-varop">$</span><span class="hs-varid">getLog</span><span class="hs-varid">env</span><span class="hs-varid">msg</span><span class="hs-definition">main</span><span class="hs-keyglyph">::</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-definition">main</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">ref</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">newTVarIO</span><span class="hs-num">4</span><span class="hs-keyword">let</span><span class="hs-varid">env</span><span class="hs-keyglyph">=</span><span class="hs-conid">Env</span><span class="hs-layout">{</span><span class="hs-varid">envLog</span><span class="hs-keyglyph">=</span><span class="hs-varid">sayString</span><span class="hs-layout">,</span><span class="hs-varid">envBalance</span><span class="hs-keyglyph">=</span><span class="hs-varid">ref</span><span class="hs-layout">}</span><span class="hs-varid">runReaderT</span><span class="hs-layout">(</span><span class="hs-varid">concurrently</span><span class="hs-layout">(</span><span class="hs-varid">modify</span><span class="hs-layout">(</span><span class="hs-varop">+</span><span class="hs-num">1</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">(</span><span class="hs-varid">logSomething</span><span class="hs-str">"Increasing account balance"</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-varid">env</span><span class="hs-varid">balance</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">readTVarIO</span><span class="hs-varid">ref</span><span class="hs-varid">sayString</span><span class="hs-varop">$</span><span class="hs-str">"Final balance: "</span><span class="hs-varop">++</span><span class="hs-varid">show</span><span class="hs-varid">balance</span></pre><p>Holy creeping boilerplate batman! Yes, type signatures get longer, rote instances get written. But our type signatures are now deeply informative, and we can test our functions with ease, e.g.:</p><pre><span class="hs-definition">main</span><span class="hs-keyglyph">::</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-definition">main</span><span class="hs-keyglyph">=</span><span class="hs-varid">hspec</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-varid">describe</span><span class="hs-str">"modify"</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-varid">it</span><span class="hs-str">"works"</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-varid">var</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">newTVarIO</span><span class="hs-layout">(</span><span class="hs-num">1</span><span class="hs-keyglyph">::</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-varid">runReaderT</span><span class="hs-layout">(</span><span class="hs-varid">modify</span><span class="hs-layout">(</span><span class="hs-varop">+</span><span class="hs-num">2</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-varid">var</span><span class="hs-varid">res</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">readTVarIO</span><span class="hs-varid">var</span><span class="hs-varid">res</span><span class="hs-varop">`shouldBe`</span><span class="hs-num">3</span><span class="hs-varid">describe</span><span class="hs-str">"logSomething"</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-varid">it</span><span class="hs-str">"works"</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-varid">var</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">newTVarIO</span><span class="hs-str">""</span><span class="hs-keyword">let</span><span class="hs-varid">logFunc</span><span class="hs-varid">msg</span><span class="hs-keyglyph">=</span><span class="hs-varid">atomically</span><span class="hs-varop">$</span><span class="hs-varid">modifyTVar</span><span class="hs-varid">var</span><span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-varid">msg</span><span class="hs-layout">)</span><span class="hs-varid">msg1</span><span class="hs-keyglyph">=</span><span class="hs-str">"Hello "</span><span class="hs-varid">msg2</span><span class="hs-keyglyph">=</span><span class="hs-str">"World\n"</span><span class="hs-varid">runReaderT</span><span class="hs-layout">(</span><span class="hs-varid">logSomething</span><span class="hs-varid">msg1</span><span class="hs-varop">&gt;&gt;</span><span class="hs-varid">logSomething</span><span class="hs-varid">msg2</span><span class="hs-layout">)</span><span class="hs-varid">logFunc</span><span class="hs-varid">res</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">readTVarIO</span><span class="hs-varid">var</span><span class="hs-varid">res</span><span class="hs-varop">`shouldBe`</span><span class="hs-layout">(</span><span class="hs-varid">msg1</span><span class="hs-varop">++</span><span class="hs-varid">msg2</span><span class="hs-layout">)</span></pre><p>And if defining all of these classes manually bothers you, or you're just a big fan of the library, you're free to use lens:</p><pre><span class="hs-cpp">#!/</span><span class="hs-varid">usr</span><span class="hs-varop">/</span><span class="hs-varid">bin</span><span class="hs-varop">/</span><span class="hs-varid">env</span><span class="hs-varid">stack</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">Async</span><span class="hs-varop">.</span><span class="hs-conid">Lifted</span><span class="hs-varop">.</span><span class="hs-conid">Safe</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Monad</span><span class="hs-varop">.</span><span class="hs-conid">Reader</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">STM</span><span class="hs-keyword">import</span><span class="hs-conid">Say</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Lens</span><span class="hs-keyword">import</span><span class="hs-conid">Prelude</span><span class="hs-varid">hiding</span><span class="hs-layout">(</span><span class="hs-varid">log</span><span class="hs-layout">)</span><span class="hs-keyword">data</span><span class="hs-conid">Env</span><span class="hs-keyglyph">=</span><span class="hs-conid">Env</span><span class="hs-layout">{</span><span class="hs-varid">envLog</span><span class="hs-keyglyph">::</span><span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-layout">)</span><span class="hs-layout">,</span><span class="hs-varid">envBalance</span><span class="hs-keyglyph">::</span><span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-conid">TVar</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-layout">}</span><span class="hs-definition">makeLensesWith</span><span class="hs-varid">camelCaseFields</span><span class="hs-chr">'</span><span class="hs-chr">'</span><span class="hs-conid">Env</span><span class="hs-definition">modify</span><span class="hs-keyglyph">::</span><span class="hs-layout">(</span><span class="hs-conid">MonadReader</span><span class="hs-varid">env</span><span class="hs-varid">m</span><span class="hs-layout">,</span><span class="hs-conid">HasBalance</span><span class="hs-varid">env</span><span class="hs-layout">(</span><span class="hs-conid">TVar</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-layout">,</span><span class="hs-conid">MonadIO</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyglyph">=&gt;</span><span class="hs-layout">(</span><span class="hs-conid">Int</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">m</span><span class="hs-conid">()</span><span class="hs-definition">modify</span><span class="hs-varid">f</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">env</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">ask</span><span class="hs-varid">liftIO</span><span class="hs-varop">$</span><span class="hs-varid">atomically</span><span class="hs-varop">$</span><span class="hs-varid">modifyTVar'</span><span class="hs-layout">(</span><span class="hs-varid">env</span><span class="hs-varop">^.</span><span class="hs-varid">balance</span><span class="hs-layout">)</span><span class="hs-varid">f</span><span class="hs-definition">logSomething</span><span class="hs-keyglyph">::</span><span class="hs-layout">(</span><span class="hs-conid">MonadReader</span><span class="hs-varid">env</span><span class="hs-varid">m</span><span class="hs-layout">,</span><span class="hs-conid">HasLog</span><span class="hs-varid">env</span><span class="hs-layout">(</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-layout">)</span><span class="hs-layout">,</span><span class="hs-conid">MonadIO</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyglyph">=&gt;</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">m</span><span class="hs-conid">()</span><span class="hs-definition">logSomething</span><span class="hs-varid">msg</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">env</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">ask</span><span class="hs-varid">liftIO</span><span class="hs-varop">$</span><span class="hs-layout">(</span><span class="hs-varid">env</span><span class="hs-varop">^.</span><span class="hs-varid">log</span><span class="hs-layout">)</span><span class="hs-varid">msg</span><span class="hs-definition">main</span><span class="hs-keyglyph">::</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-definition">main</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">ref</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">newTVarIO</span><span class="hs-num">4</span><span class="hs-keyword">let</span><span class="hs-varid">env</span><span class="hs-keyglyph">=</span><span class="hs-conid">Env</span><span class="hs-layout">{</span><span class="hs-varid">envLog</span><span class="hs-keyglyph">=</span><span class="hs-varid">sayString</span><span class="hs-layout">,</span><span class="hs-varid">envBalance</span><span class="hs-keyglyph">=</span><span class="hs-varid">ref</span><span class="hs-layout">}</span><span class="hs-varid">runReaderT</span><span class="hs-layout">(</span><span class="hs-varid">concurrently</span><span class="hs-layout">(</span><span class="hs-varid">modify</span><span class="hs-layout">(</span><span class="hs-varop">+</span><span class="hs-num">1</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">(</span><span class="hs-varid">logSomething</span><span class="hs-str">"Increasing account balance"</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-varid">env</span><span class="hs-varid">balance</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">readTVarIO</span><span class="hs-varid">ref</span><span class="hs-varid">sayString</span><span class="hs-varop">$</span><span class="hs-str">"Final balance: "</span><span class="hs-varop">++</span><span class="hs-varid">show</span><span class="hs-varid">balance</span></pre><p>In our case, where <code>Env</code> doesn't have any immutable config-style data in it, the advantages of the lens approach aren't as apparent. But if you have some deeply nested config value, and especially want to play around with using <code>local</code> to tweak some values in it throughout your application, the lens approach can pay off.</p><p>So to summarize: this approach really is about biting the bullet and absorbing some initial pain and boilerplate. I argue that the myriad benefits you get from it during app development are well worth it. Remember: you'll pay that upfront cost <i>once</i>, you'll reap its rewards daily.</p><h2 id="regain-purity">Regain purity</h2><p>It's unfortunate that our <code>modify</code> function has a <code>MonadIO</code> constraint on it. Even though our real implementation requires <code>IO</code> to perform side-effects (specifically, to read and write a <code>TVar</code>), we've now infected all callers of the function by saying "we have the right to perform <i>any</i> side-effects, including launching the missiles, or worse, throwing a runtime exception." Can we regain some level of purity? The answer is yes, it just requires a bit more boilerplate:</p><pre><span class="hs-cpp">#!/</span><span class="hs-varid">usr</span><span class="hs-varop">/</span><span class="hs-varid">bin</span><span class="hs-varop">/</span><span class="hs-varid">env</span><span class="hs-varid">stack</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">Async</span><span class="hs-varop">.</span><span class="hs-conid">Lifted</span><span class="hs-varop">.</span><span class="hs-conid">Safe</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Monad</span><span class="hs-varop">.</span><span class="hs-conid">Reader</span><span class="hs-keyword">import</span><span class="hs-keyword">qualified</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Monad</span><span class="hs-varop">.</span><span class="hs-conid">State</span><span class="hs-varop">.</span><span class="hs-conid">Strict</span><span class="hs-keyword">as</span><span class="hs-conid">State</span><span class="hs-keyword">import</span><span class="hs-conid">Control</span><span class="hs-varop">.</span><span class="hs-conid">Concurrent</span><span class="hs-varop">.</span><span class="hs-conid">STM</span><span class="hs-keyword">import</span><span class="hs-conid">Say</span><span class="hs-keyword">import</span><span class="hs-conid">Test</span><span class="hs-varop">.</span><span class="hs-conid">Hspec</span><span class="hs-keyword">data</span><span class="hs-conid">Env</span><span class="hs-keyglyph">=</span><span class="hs-conid">Env</span><span class="hs-layout">{</span><span class="hs-varid">envLog</span><span class="hs-keyglyph">::</span><span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-layout">)</span><span class="hs-layout">,</span><span class="hs-varid">envBalance</span><span class="hs-keyglyph">::</span><span class="hs-varop">!</span><span class="hs-layout">(</span><span class="hs-conid">TVar</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-layout">}</span><span class="hs-keyword">class</span><span class="hs-conid">HasLog</span><span class="hs-varid">a</span><span class="hs-keyword">where</span><span class="hs-varid">getLog</span><span class="hs-keyglyph">::</span><span class="hs-varid">a</span><span class="hs-keyglyph">-&gt;</span><span class="hs-layout">(</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-layout">)</span><span class="hs-keyword">instance</span><span class="hs-conid">HasLog</span><span class="hs-layout">(</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-layout">)</span><span class="hs-keyword">where</span><span class="hs-varid">getLog</span><span class="hs-keyglyph">=</span><span class="hs-varid">id</span><span class="hs-keyword">instance</span><span class="hs-conid">HasLog</span><span class="hs-conid">Env</span><span class="hs-keyword">where</span><span class="hs-varid">getLog</span><span class="hs-keyglyph">=</span><span class="hs-varid">envLog</span><span class="hs-keyword">class</span><span class="hs-conid">HasBalance</span><span class="hs-varid">a</span><span class="hs-keyword">where</span><span class="hs-varid">getBalance</span><span class="hs-keyglyph">::</span><span class="hs-varid">a</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">TVar</span><span class="hs-conid">Int</span><span class="hs-keyword">instance</span><span class="hs-conid">HasBalance</span><span class="hs-layout">(</span><span class="hs-conid">TVar</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-keyword">where</span><span class="hs-varid">getBalance</span><span class="hs-keyglyph">=</span><span class="hs-varid">id</span><span class="hs-keyword">instance</span><span class="hs-conid">HasBalance</span><span class="hs-conid">Env</span><span class="hs-keyword">where</span><span class="hs-varid">getBalance</span><span class="hs-keyglyph">=</span><span class="hs-varid">envBalance</span><span class="hs-keyword">class</span><span class="hs-conid">Monad</span><span class="hs-varid">m</span><span class="hs-keyglyph">=&gt;</span><span class="hs-conid">MonadBalance</span><span class="hs-varid">m</span><span class="hs-keyword">where</span><span class="hs-varid">modifyBalance</span><span class="hs-keyglyph">::</span><span class="hs-layout">(</span><span class="hs-conid">Int</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">m</span><span class="hs-conid">()</span><span class="hs-keyword">instance</span><span class="hs-layout">(</span><span class="hs-conid">HasBalance</span><span class="hs-varid">env</span><span class="hs-layout">,</span><span class="hs-conid">MonadIO</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyglyph">=&gt;</span><span class="hs-conid">MonadBalance</span><span class="hs-layout">(</span><span class="hs-conid">ReaderT</span><span class="hs-varid">env</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyword">where</span><span class="hs-varid">modifyBalance</span><span class="hs-varid">f</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">env</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">ask</span><span class="hs-varid">liftIO</span><span class="hs-varop">$</span><span class="hs-varid">atomically</span><span class="hs-varop">$</span><span class="hs-varid">modifyTVar'</span><span class="hs-layout">(</span><span class="hs-varid">getBalance</span><span class="hs-varid">env</span><span class="hs-layout">)</span><span class="hs-varid">f</span><span class="hs-keyword">instance</span><span class="hs-conid">Monad</span><span class="hs-varid">m</span><span class="hs-keyglyph">=&gt;</span><span class="hs-conid">MonadBalance</span><span class="hs-layout">(</span><span class="hs-conid">State</span><span class="hs-varop">.</span><span class="hs-conid">StateT</span><span class="hs-conid">Int</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyword">where</span><span class="hs-varid">modifyBalance</span><span class="hs-keyglyph">=</span><span class="hs-conid">State</span><span class="hs-varop">.</span><span class="hs-varid">modify</span><span class="hs-definition">modify</span><span class="hs-keyglyph">::</span><span class="hs-conid">MonadBalance</span><span class="hs-varid">m</span><span class="hs-keyglyph">=&gt;</span><span class="hs-layout">(</span><span class="hs-conid">Int</span><span class="hs-keyglyph">-&gt;</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">m</span><span class="hs-conid">()</span><span class="hs-definition">modify</span><span class="hs-varid">f</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">modifyBalance</span><span class="hs-varid">f</span><span class="hs-definition">logSomething</span><span class="hs-keyglyph">::</span><span class="hs-layout">(</span><span class="hs-conid">MonadReader</span><span class="hs-varid">env</span><span class="hs-varid">m</span><span class="hs-layout">,</span><span class="hs-conid">HasLog</span><span class="hs-varid">env</span><span class="hs-layout">,</span><span class="hs-conid">MonadIO</span><span class="hs-varid">m</span><span class="hs-layout">)</span><span class="hs-keyglyph">=&gt;</span><span class="hs-conid">String</span><span class="hs-keyglyph">-&gt;</span><span class="hs-varid">m</span><span class="hs-conid">()</span><span class="hs-definition">logSomething</span><span class="hs-varid">msg</span><span class="hs-keyglyph">=</span><span class="hs-keyword">do</span><span class="hs-varid">env</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">ask</span><span class="hs-varid">liftIO</span><span class="hs-varop">$</span><span class="hs-varid">getLog</span><span class="hs-varid">env</span><span class="hs-varid">msg</span><span class="hs-definition">main</span><span class="hs-keyglyph">::</span><span class="hs-conid">IO</span><span class="hs-conid">()</span><span class="hs-definition">main</span><span class="hs-keyglyph">=</span><span class="hs-varid">hspec</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-varid">describe</span><span class="hs-str">"modify"</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-varid">it</span><span class="hs-str">"works, IO"</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-varid">var</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">newTVarIO</span><span class="hs-layout">(</span><span class="hs-num">1</span><span class="hs-keyglyph">::</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-varid">runReaderT</span><span class="hs-layout">(</span><span class="hs-varid">modify</span><span class="hs-layout">(</span><span class="hs-varop">+</span><span class="hs-num">2</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-varid">var</span><span class="hs-varid">res</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">readTVarIO</span><span class="hs-varid">var</span><span class="hs-varid">res</span><span class="hs-varop">`shouldBe`</span><span class="hs-num">3</span><span class="hs-varid">it</span><span class="hs-str">"works, pure"</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-keyword">let</span><span class="hs-varid">res</span><span class="hs-keyglyph">=</span><span class="hs-conid">State</span><span class="hs-varop">.</span><span class="hs-varid">execState</span><span class="hs-layout">(</span><span class="hs-varid">modify</span><span class="hs-layout">(</span><span class="hs-varop">+</span><span class="hs-num">2</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">(</span><span class="hs-num">1</span><span class="hs-keyglyph">::</span><span class="hs-conid">Int</span><span class="hs-layout">)</span><span class="hs-varid">res</span><span class="hs-varop">`shouldBe`</span><span class="hs-num">3</span><span class="hs-varid">describe</span><span class="hs-str">"logSomething"</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-varid">it</span><span class="hs-str">"works"</span><span class="hs-varop">$</span><span class="hs-keyword">do</span><span class="hs-varid">var</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">newTVarIO</span><span class="hs-str">""</span><span class="hs-keyword">let</span><span class="hs-varid">logFunc</span><span class="hs-varid">msg</span><span class="hs-keyglyph">=</span><span class="hs-varid">atomically</span><span class="hs-varop">$</span><span class="hs-varid">modifyTVar</span><span class="hs-varid">var</span><span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-varid">msg</span><span class="hs-layout">)</span><span class="hs-varid">msg1</span><span class="hs-keyglyph">=</span><span class="hs-str">"Hello "</span><span class="hs-varid">msg2</span><span class="hs-keyglyph">=</span><span class="hs-str">"World\n"</span><span class="hs-varid">runReaderT</span><span class="hs-layout">(</span><span class="hs-varid">logSomething</span><span class="hs-varid">msg1</span><span class="hs-varop">&gt;&gt;</span><span class="hs-varid">logSomething</span><span class="hs-varid">msg2</span><span class="hs-layout">)</span><span class="hs-varid">logFunc</span><span class="hs-varid">res</span><span class="hs-keyglyph">&lt;-</span><span class="hs-varid">readTVarIO</span><span class="hs-varid">var</span><span class="hs-varid">res</span><span class="hs-varop">`shouldBe`</span><span class="hs-layout">(</span><span class="hs-varid">msg1</span><span class="hs-varop">++</span><span class="hs-varid">msg2</span><span class="hs-layout">)</span></pre><p>It's silly in an example this short, since the entirety of the <code>modify</code> function is now in a typeclass. But with larger examples, you can see how we'd be able to specify that entire portions of our logic perform no arbitrary side-effects, while still using the <code>ReaderT</code> pattern to its fullest.</p><p>To put this another way: the function <code>foo :: Monad m =&gt; Int -&gt; m
Double</code> may appear to be impure, because it lives in a <code>Monad</code>. But this isn't true: by giving it a constraint of "any arbitrary instance of <code>Monad</code>", we're stating "this has no real side-effects." After all, the type above unifies with <code>Identity</code>, which of course is pure.</p><p>This example may seem a bit funny, but what about <code>parseInt ::
MonadThrow m =&gt; Text -&gt; m Int</code>? You may think "that's impure, it throws a runtime exception." But the type unifies with <code>parseInt ::
Text -&gt; Maybe Int</code>, which of course is pure. We've gained a lot of knowledge about our function and can feel safe calling it.</p><p>So the take-away here is: if you can generalize your functions to mtl-style <code>Monad</code> constraints, do it, you'll regain a lot of the benfits you'd have with purity.</p><h2 id="analysis">Analysis</h2><p>While the technique here is certainly a bit heavy-handed, for any large-scale application or library development that cost will be amortized. I've found the benefits of working in this style to far outweigh the costs in many real world projects.</p><p>There are other problems it causes, like more confusing error messages and more cognitive overhead for someone joining the project. But in my experience, once someone is onboarded to the approach, it works out well.</p><p>In addition to the concrete benefits I listed above, using this approach automatically navigates you around many common monad transformer stack pain points that you'll see people experiencing in the real world. I encourage others to share their real-world examples of them. I personally haven't hit those problems in a long while, since I've stuck to this approach.</p><h2 id="post-publish-updates">Post-publish updates</h2><p><strong>June 15, 2017</strong> The comment below from Ashley about ImplicitParams spawned a <a href="https://www.reddit.com/r/haskell/comments/6gz4w5/whats_wrong_with_implicitparams/">Reddit discussion about the problems with that extension</a>. Please do read the discussion yourself, but the takeaway for me is that <code>MonadReader</code> is a better choice.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>