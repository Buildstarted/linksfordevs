<!DOCTYPE html>
<html lang="en">
<head>
    <title>
mgravell/PooledAwait: Low allocation async/await for C#/.NET -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>mgravell/PooledAwait: Low allocation async/await for C#/.NET</h1><div><div id="" class="markdown-body entry-content p-5"><p><a href="https://mgravell.github.io/PooledAwait/" rel="nofollow">Documentation</a></p><h1><a id="user-content-what-is-this" class="anchor" aria-hidden="true" href="#what-is-this"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is this?</h1><p>You know how <code>async</code> methods that <code>await</code> something <strong>incomplete</strong> end up creating a few objects, right? There's
the boxed state machine, an <code>Action</code> that moves it forward, a <code>Task[&lt;T&gt;]</code>, etc - right?</p><p>Well... what about if there just <strong>wasn't</strong>?</p><p>And what if all you had to do was change your <code>async ValueTask&lt;int&gt;</code> method to <code>async PooledValueTask&lt;int&gt;</code>?</p><p>And I hear you; you're saying "but I can't change the public API!". But what if a <code>PooledValueTask&lt;int&gt;</code> really <em>was</em>
a <code>ValueTask&lt;int&gt;</code>? So you can just cheat:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-en">ValueTask</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">DoTheThing</span>() <span class="pl-c"><span class="pl-c">//</span> the outer method is not async</span>
{
	<span class="pl-k">return</span><span class="pl-en">ReallyDoTheThing</span>(<span class="pl-k">this</span>);
	<span class="pl-smi">static</span><span class="pl-smi">async</span><span class="pl-smi">PooledValueTask</span><span class="pl-k">&lt;</span><span class="pl-smi">int</span><span class="pl-k">&gt;</span><span class="pl-en">ReallyDoTheThing</span>(<span class="pl-en">SomeType</span><span class="pl-smi">obj</span>)
	{
		... <span class="pl-smi">await</span> ...
		<span class="pl-c"><span class="pl-c">//</span> (use obj.* instead of this.*)</span>
		... <span class="pl-smi">return</span> ...
	}
}</pre></div><p>(the use of a <code>static</code> local function here avoids a <code>&lt;&gt;c__DisplayClass</code> wrapper from how the local-function capture context is implemented by the compiler)</p><p>And how about if maybe just maybe in the future it could be (<a href="https://github.com/dotnet/csharplang/issues/1407">if this happens</a>) just:</p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">SomeKindOfAttribute</span>] <span class="pl-c"><span class="pl-c">//</span> &lt;=== this is the only change</span><span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">ValueTask</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">DoTheThing</span>()
{
	<span class="pl-c"><span class="pl-c">//</span> no changes here at all</span>
}</pre></div><p>(although note that in some cases it can work <em>better</em> with the <code>static</code> trick, as above)</p><p>Would that be awesome? Because that's what this is!</p><h1><a id="user-content-how-does-that-work" class="anchor" aria-hidden="true" href="#how-does-that-work"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How does that work?</h1><p>The <code>PooledValueTask[&lt;T&gt;]</code> etc exist mostly to define a custom <strong>builder</strong>. The builder in this library uses aggressive pooling of classes
that replace the <em>boxed</em> approach used by default; we recycle them when the state machine completes.</p><p>It also makes use of the <code>IValueTaskSource[&lt;T&gt;]</code> API to allow incomplete operations to be represented without a <code>Task[&lt;T&gt;]</code>, but with a custom backer.
And we pool that too, recycling it when the task is <em>awaited</em>. The only downside: you can't <code>await</code> the same result <em>twice</em> now, because
once you've awaited it the first time, <strong>it has gone</strong>. A cycling token is used to make sure you can't accidentally read the incorrect
values after the result has been awaited.</p><p>We can <em>even</em> do this for <code>Task[&lt;T&gt;]</code>, except here we can only avoid the boxed state machine; hence <code>PooledTask[&lt;T&gt;]</code> exists too. No custom backing in this case, though, since a <code>Task[&lt;T&gt;]</code> will
need to be allocated (except for <code>Task.CompletedTask</code>, which we special-case).</p><h1><a id="user-content-test-results" class="anchor" aria-hidden="true" href="#test-results"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Test results</h1><p>Based on an operation that uses <code>Task.Yield()</code> to ensure that the operations are incomplete; ".NET" means the inbuilt out-of-the box implementation; "Pooled" means the implementation from this library.</p><p>In particular, notice:</p><ul><li>zero allocations for <code>PooledValueTask[&lt;T&gt;]</code> vs <code>ValueTask[&lt;T&gt;]</code> (on .NET Core; <em>significantly reduced</em> on .NET Framework)</li><li><em>reduced</em> allocations for <code>PooledTask[&lt;T&gt;]</code> vs <code>Task[&lt;T&gt;]</code></li><li>no performance degredation; just lower allocations</li></ul><pre lang="txt"><code>| Method |  Job | Runtime |   Categories |     Mean |     Error |    StdDev |  Gen 0 |  Gen 1 |  Gen 2 | Allocated |
|------- |----- |-------- |------------- |---------:|----------:|----------:|-------:|-------:|-------:|----------:|
|   .NET |  Clr |     Clr |      Task&lt;T&gt; | 2.159 us | 0.0427 us | 0.0474 us | 0.0508 | 0.0039 |      - |     344 B |
| Pooled |  Clr |     Clr |      Task&lt;T&gt; | 2.037 us | 0.0246 us | 0.0230 us | 0.0273 | 0.0039 |      - |     182 B |
|   .NET | Core |    Core |      Task&lt;T&gt; | 1.397 us | 0.0024 us | 0.0022 us | 0.0176 |      - |      - |     120 B |
| Pooled | Core |    Core |      Task&lt;T&gt; | 1.349 us | 0.0058 us | 0.0054 us | 0.0098 |      - |      - |      72 B |
|        |      |         |              |          |           |           |        |        |        |           |
|   .NET |  Clr |     Clr |         Task | 2.065 us | 0.0200 us | 0.0167 us | 0.0508 | 0.0039 |      - |     336 B |
| Pooled |  Clr |     Clr |         Task | 1.979 us | 0.0179 us | 0.0167 us | 0.0273 | 0.0039 |      - |     182 B |
|   .NET | Core |    Core |         Task | 1.390 us | 0.0159 us | 0.0149 us | 0.0176 |      - |      - |     112 B |
| Pooled | Core |    Core |         Task | 1.361 us | 0.0055 us | 0.0051 us | 0.0098 |      - |      - |      72 B |
|        |      |         |              |          |           |           |        |        |        |           |
|   .NET |  Clr |     Clr | ValueTask&lt;T&gt; | 2.087 us | 0.0403 us | 0.0431 us | 0.0547 | 0.0078 | 0.0039 |     352 B |
| Pooled |  Clr |     Clr | ValueTask&lt;T&gt; | 1.924 us | 0.0248 us | 0.0220 us | 0.0137 | 0.0020 |      - |     100 B |
|   .NET | Core |    Core | ValueTask&lt;T&gt; | 1.405 us | 0.0078 us | 0.0073 us | 0.0195 |      - |      - |     128 B |
| Pooled | Core |    Core | ValueTask&lt;T&gt; | 1.374 us | 0.0116 us | 0.0109 us |      - |      - |      - |         - |
|        |      |         |              |          |           |           |        |        |        |           |
|   .NET |  Clr |     Clr |    ValueTask | 2.056 us | 0.0206 us | 0.0183 us | 0.0508 | 0.0039 |      - |     344 B |
| Pooled |  Clr |     Clr |    ValueTask | 1.948 us | 0.0388 us | 0.0416 us | 0.0137 | 0.0020 |      - |     100 B |
|   .NET | Core |    Core |    ValueTask | 1.408 us | 0.0140 us | 0.0117 us | 0.0176 |      - |      - |     120 B |
| Pooled | Core |    Core |    ValueTask | 1.366 us | 0.0039 us | 0.0034 us |      - |      - |      - |         - |
</code></pre><p>Note that <em>most</em> of the remaining allocations are actually the work-queue internals of <code>Task.Yield()</code> (i.e. how
<code>ThreadPool.QueueUserWorkItem</code> works) - we've removed virtually all of the unnecessary overheads that came from the
<code>async</code> machinery. Most real-world scenarios aren't using <code>Task.Yield()</code> - they are waiting on external data, etc - so
they won't see these. Plus they are effectively zero on .NET Core 3.</p><p>The tests do the exact same thing; the only thing that changes is the return type, i.e. whether it is
<code>async Task&lt;int&gt;</code>, <code>async ValueTask&lt;int&gt;</code>, <code>async PooledTask&lt;int&gt;</code> or <code>async PooledValueTask&lt;int&gt;</code>.
All of them have the same threading/execution-context/sync-context semantics; there's no cheating going on.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>