<!DOCTYPE html>
<html lang="en">
<head>
    <title>
3K, 60fps, 130ms: achieving it with Rust | tonari blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="3K, 60fps, 130ms: achieving it with Rust | tonari blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Jake McGintyJune 14, 2020"/>
    <meta property="og:description" content="How we chose the Rust programming language to advance the state-of-the-art in real-time communication"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.tonari.no/why-we-love-rust"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - 3K, 60fps, 130ms: achieving it with Rust | tonari blog</title>
<div class="readable">
        <h1>3K, 60fps, 130ms: achieving it with Rust | tonari blog</h1>
            <div>by Jake McGintyJune 14, 2020</div>
            <div>Reading time: 20-25 minutes</div>
        <div>Posted here: 16 Jun 2020</div>
        <p><a href="https://blog.tonari.no/why-we-love-rust">https://blog.tonari.no/why-we-love-rust</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>How we chose the Rust programming language to advance the state-of-the-art in real-time communication</p><div><p><i>T</i><m><i>his post was written collectively with Ryo Kawaguchi, </i></m><m><m><i>Andrea Law, Brian Schwind</i></m></m><m><i>.</i></m></p><p><m>Our goal for tonari is to build a virtual doorway to another space that allows for truly natural human interactions. Nearly two years in development, tonari is, to the best of our knowledge, the lowest-latency high resolution production-ready "teleconferencing" (we are truly not fond of that word) product available. </m></p><ul><li><b>130ms</b> glass-to-glass latency (the time from light hitting the camera to when it appears on-screen on the other side)</li><li><b>3K, 60fps</b> video transmission</li><li>High-bitrate 48kHz stereo audio</li></ul><p>Compare this to the typical <b>315-500ms</b> latency for Zoom and <m>WebRTC</m>, as measured between two laptops (X1 Carbon and MacBook Pro) on the same network at our office. It's a huge difference. It's the difference between constantly interrupting each other versus having a natural flow of conversation. It's the difference between a blurry face from a camera seemingly pointed up someone's nose versus a wide-view high fidelity image that smoothly transfers all the subtle body language of an in-person conversation.</p><div><picture><source srcset="images/ea56c74d-a55d-4183-9a7b-d697954c5159-tonari-frontier-2.png.optimized.webp" type="image/webp"><source srcset="images/ea56c74d-a55d-4183-9a7b-d697954c5159-tonari-frontier-2.png.optimized.jpg"><img src="https://blog.tonari.no/images/ea56c74d-a55d-4183-9a7b-d697954c5159-tonari-frontier-2.png.optimized.jpg"></picture></div><p>Since launching <a href="https://blog.tonari.no/changing-communication-and-culture-in-an-organization" rel="noopener" target="_blank">our first pilot</a> in February, we've experienced no software-related downtime (tripping over ethernet cables is a different story). A<m>nd as much as we would love to think we're infallible engineers, we truly don't believe we could have achieved these numbers with this level of stability without Rust.</m></p><a href="#in-the-beginning-(or-why-we're-not-webrtc)" id="in-the-beginning-(or-why-we're-not-webrtc)"><h2>In the beginning (or: why we're not WebRTC)</h2></a><p>The <m>very</m> first tonari proof-of-concept used a basic projector, bluetooth speakers, and a website running on top of vanilla WebRTC (JavaScript). We've come a long way since those days.</p><p>While that prototype (and our opinionated vision of the future) got us grant funding, we knew that tonari would be dead on arrival unless we could<m> achieve </m><i>significantly</i> lower latency and higher fidelity than <m>WebRTC</m>—two things that aren't currently associated with video chat in 2020.</p><p>We figured, “Okay<i>, so we can just </i><m><i>modify</i></m><i> WebRTC directly and wrap it up with a slick UI in C++ and launch it in no time</i>.”</p><p>A week of struggling with WebRTC’s nearly 750,000 LoC <i>behemoth</i> of a codebase revealed just how painful a single small change could be — how hard it was to test, and feel truly <i>safe,</i> with the code you were dealing with.</p><a href="#let-there-be-light...weight-code" id="let-there-be-light...weight-code"><h3>Let there be light...weight code</h3></a><p>So in a furious (read: calm and thoroughly-discussed) rage quit we decided it was easier to re-implement the whole stack from scratch. We wanted to <i>know and understand every line of code</i> being run on our hardware, and it should be designed for the <i>exact</i> hardware we wanted.</p><p>Thus began our journey to the depths beyond high-level interfaces like a browser or existing RTC project, and into the world of low-level systems and hardware interaction from scratch.</p><p>We needed it to <m>be inherently </m><b><m><i>secure</i></m></b><m> to </m>protect the privacy of those who use tonari.  We needed it to be <b><i>performant</i></b> to make it feel as human and real-time as possible.  And we needed it to be <b><i>maintainable</i></b> as the code becomes more mature, as new brains show up and have to learn our work and expand on it.</p><p><m>We discussed and ruled out a handful of alternative approaches:</m></p><ul><li><b><i>Security: </i></b>C and C++ are memory- and concurrency-unsafe, and their disparate and seemingly infinite build systems make it hard to have a consistent and simple development experience.</li><li><i><b>Performance: </b></i>Java, <m>C#, and Go'</m>s memory management is opaque and can be difficult to work with in latency-sensitive applications where you want full control over your memory.</li><li><i><b>Maintainability: </b></i>Haskell, Nim, D, and a handful of other more bespoke languages tend to be more limited in tooling, community, and hire-ability.</li></ul><p>Rust is really the only production-ready language that we found confidently satisfies these needs.</p><a href="#finding-beauty-in-rust" id="finding-beauty-in-rust"><h2>Finding beauty in Rust</h2></a><p>Rust's beauty lies in the countless decisions made by the development community that constantly make you feel like you have can ten cakes and eat all of them too.</p><ul><li>Its build system is opinionated, and cleanly designed. It is itself a complete ecosystem that makes introducing new engineers to your project and setting up dev environments remarkably simple.</li><li>The memory and concurrency safety guarantees cannot be over-appreciated. We're confident that we wouldn't have done our first deployment yet if we had continued this in C++ - we'd still probably be stuck on subtle snags.</li><li>Our ability to interact at the lowest level with hardware via APIs like CUDA, oftentimes through existing <a href="https://crates.io/" rel="noopener" target="_blank"><m>crates</m></a> (Rust's term for a code library), has allowed us to have higher standards about the latency we want from our first production release.</li></ul><p>As tonari is getting more advanced, we're now choosing embedded microcontrollers whose firmware can be written in Rust so we don't have to leave our idyllic utopia into the old world of unsafe system programming.</p><a href="#crates-we-rely-on" id="crates-we-rely-on"><h2>Crates we rely on</h2></a><p>We're not going to <code>cat Cargo.toml</code> here, instead focusing on some select crates that have earned the prestigious award of a lifetime invitation to each of our birthday parties forever.</p><a href="#&quot;better-than-std&quot;-crates" id="&quot;better-than-std&quot;-crates"><h3>"Better-than-std" crates</h3></a><ul><li><a href="https://github.com/crossbeam-rs/crossbeam" rel="noopener" target="_blank"><code>crossbeam</code></a> is better for inter-thread communication than <code>std::sync::mpsc</code> in almost every way, and may be merged into <code>std</code> eventually.</li><li><a href="https://github.com/Amanieu/parking_lot" rel="noopener" target="_blank"><code>parking_lot</code></a> has a mutex implementation better than <code>std::sync::Mutex</code> in almost every way, and may be merged into the standard library (one day). It also provides many other useful synchronization primitives.</li><li><a href="https://github.com/tokio-rs/bytes" rel="noopener" target="_blank"><code>bytes</code></a> is a more robust, and often more performant, way to play with bytes compared to <code>Vec&lt;u8&gt;</code>.</li><li><a href="https://github.com/alexcrichton/socket2-rs" rel="noopener" target="_blank"><code>socket2</code></a> is what you will end up at if you are ever doing lower-level networking optimizations.</li></ul><a href="#beauty-supply" id="beauty-supply"><h3>Beauty supply</h3></a><ul><li><a href="https://github.com/daboross/fern" rel="noopener" target="_blank"><code>fern</code></a> is a dead-simple way to customize and prettify your logging output. We use it to keep our logs readable and internally standardized.</li><li><a href="https://github.com/TeXitoi/structopt" rel="noopener" target="_blank"><code>structopt</code></a> is how you always dreamed CLI arguments would be handled. There's no reason not to use it unless you're going for bare-minimum dependencies.</li></ul><a href="#cargo-cult-classics" id="cargo-cult-classics"><h3>Cargo cult classics</h3></a><ul><li><a href="https://github.com/sunng87/cargo-release" rel="noopener" target="_blank"><code>cargo-release</code></a> allows us to cut internal releases painlessly.</li><li><a href="https://github.com/est31/cargo-udeps" rel="noopener" target="_blank"><code>cargo-udeps</code></a> identifies unused dependencies and allows us to keep our build times minimal.</li><li><code>cargo tree</code> (recently integrated in cargo) shows a dependency tree that's useful in many ways, but namely in identifying ways to minimize dependencies.</li><li><a href="https://github.com/rust-secure-code/cargo-geiger" rel="noopener" target="_blank"><code>cargo-geiger</code></a> helps us quickly evaluate external dependencies for possible security (or correctness) concerns.</li><li><a href="https://github.com/flamegraph-rs/flamegraph" rel="noopener" target="_blank"><code>cargo-flamegraph</code></a> helps us enormously when tracking down performance hot-spots in our code.</li></ul><a href="#project-structure" id="project-structure"><h2>Project structure</h2></a><p>The tonari codebase is a monorepo. At its root we have a Cargo workspace with a <code>binaries</code> crate, and a number of supporting library crates.</p><p>Having our crates in one repo makes them easy to reference in our <code>binaries</code> crate without needing to publish to <a href="https://crates.io/" rel="noopener" target="_blank">crates.io</a> or get too fancy with specifying git dependencies in our <code>Cargo.toml</code>. When the time comes to publish these libraries as open source, it's trivial to break it out into its own repo.</p><a href="#library,-binary,-why-not-both" id="library,-binary,-why-not-both"><h3>Library, binary, why not both?</h3></a><p>We have one main library crate that contains a unified API for talking to hardware, media codecs, network protocols, etc. Outside of that private API, we also have standalone crates in our workspace that we consider candidates for open-sourcing. For example, we’ve written our own actor framework fit for long-running high-throughput actors, as well as our own network protocol for reliable, high-bandwidth, low-latency media streaming.

We use separate binaries for different parts of the tonari system and each of these lives in <code>binaries</code>, a combination library/binary crate. Its library modules contains a set of reusable actors that combine our private API with our actor system, and then a collection of individual binaries that consume these actors and define the plumbing between them.</p><a href="#flags-as-far-as-the-eye-can-see" id="flags-as-far-as-the-eye-can-see"><h3>Flags as far as the eye can see</h3></a><p>We make extensive use of feature flags to allow development of our project on different OSes (like Brian's 1970s-era MacBook Pro) or different hardware configurations. This allows us to easily swap out camera hardware without extra runtime checks or using awful <code>sed</code> hacks.

For example, Linux uses <code>v4l2</code> (Video For Linux...2) to access most webcams, but other webcams might have their own SDK.  To compile for platforms that don't use <code>v4l2</code> or when an SDK isn't available for a particular OS, we can put those SDKs behind feature flags and export a common interface.

As a (simplified) concrete example, let's say we have a common camera interface defined as a trait:</p><pre><code><span>pub</span> <span>trait</span> Capture <span>{</span>
    
    <span>fn</span> <span>capture</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> Vec<span>&lt;</span>u8<span>&gt;</span><span>;</span>
<span>}</span></code></pre><p>Let's also say we have three different camera interfaces - <code>v4l2</code>, <code>corevideo</code>, and <code>polaroid.</code> We can make our binaries work exclusively with this trait to be flexible, and we can swap in different implementations of <code>Capture</code> with feature flags.</p><pre><code><span>#[cfg(feature = "v4l2")]</span>
<span>mod</span> v4l2 <span>{</span>
    <span>pub</span> <span>struct</span> V4l2Capture <span>{</span>
        <span>...</span>
    <span>}</span>

    <span>impl</span> Capture <span>for</span> V4l2Capture <span>{</span>
        <span>fn</span> <span>capture</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> Vec<span>&lt;</span>u8<span>&gt;</span> <span>{</span>
            <span>...</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>#[cfg(feature = "corevideo")]</span>
<span>mod</span> corevideo <span>{</span>
    <span>pub</span> <span>struct</span> CoreVideoCapture <span>{</span>
        <span>...</span>
    <span>}</span>

    <span>impl</span> Capture <span>for</span> CoreVideoCapture <span>{</span>
        <span>fn</span> <span>capture</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> Vec<span>&lt;</span>u8<span>&gt;</span> <span>{</span>
            <span>...</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>#[cfg(feature = "polaroid")]</span>
<span>mod</span> polaroid <span>{</span>
    <span>pub</span> <span>struct</span> PolaroidCapture <span>{</span>
        <span>...</span>
    <span>}</span>

    <span>impl</span> Capture <span>for</span> PolaroidCapture <span>{</span>
        <span>fn</span> <span>capture</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> Vec<span>&lt;</span>u8<span>&gt;</span> <span>{</span>
            <span>...</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>#[cfg(feature = "v4l2")]</span>
<span>pub</span> <span>type</span> VideoCapture <span>=</span> v4l2<span>::</span>V4l2Capture<span>;</span>

<span>#[cfg(feature = "corevideo")]</span>
<span>pub</span> <span>type</span> VideoCapture <span>=</span> corevideo<span>::</span>CoreVideoCapture<span>;</span>

<span>#[cfg(feature = "polaroid")]</span>
<span>pub</span> <span>type</span> VideoCapture <span>=</span> polaroid<span>::</span>PolaroidCapture<span>;</span></code></pre><p>If we make our code work with things which implement the <code>Capture</code> trait instead of concrete types, we can now compile on and target various platforms by simply toggling feature flags. For example, we can have a struct which has a field - <code>video_capture: Box&lt;dyn Capture&gt;</code> which will let us store any type which can <code>Capture</code> from a camera.

An example <code>Cargo.toml</code> file to support the capture implementations we wrote above might look something like this:</p><pre><code><span>[</span><span>package</span><span>]</span>
name <span>=</span> <span>"tonari"</span>
version <span>=</span> <span>"1.0.0"</span>
edition <span>=</span> <span>"2018"</span>

<span>[</span>features<span>]</span>
<span>default</span> <span>=</span> <span>[</span><span>"v4l2"</span><span>]</span>
macos <span>=</span> <span>[</span><span>"corevideo"</span><span>]</span>
classic <span>=</span> <span>[</span><span>"polaroid"</span><span>]</span>
v4l2 <span>=</span> <span>[</span><span>"rscam"</span><span>]</span>

<span>[</span>dependencies<span>]</span>
rscam <span>=</span> <span>{</span> version <span>=</span> <span>"0.5"</span><span>,</span> optional <span>=</span> <span>true</span> <span>}</span>     # v4l2 linux camera library
corevideo <span>=</span> <span>{</span> version <span>=</span> <span>"0.1"</span><span>,</span> optional <span>=</span> <span>true</span> <span>}</span> # MacOS camera library
polaroid <span>=</span> <span>{</span> version <span>=</span> <span>"0.1"</span><span>,</span> optional <span>=</span> <span>true</span> <span>}</span>  # Polaroid camera <span>library</span> <span>(</span>very slow <span>FPS</span><span>)</span></code></pre><p>This way we can avoid building and linking to platform-specific libraries like <code>v4l2</code> which aren't available everywhere.</p><a href="#learning-rust-on-the-job" id="learning-rust-on-the-job"><h2>Learning Rust on the job</h2></a><p>A year after switching over to Rust, we onboarded our fourth engineer to the team, who didn't have much prior experience in either Rust or systems engineering. While the learning curve is undeniable (<a href="https://rufflewind.com/2017-02-15/rust-move-copy-borrow" rel="noopener" target="_blank"><m><m><i>borrow checker</i></m></m></a><a href="https://rufflewind.com/2017-02-15/rust-move-copy-borrow" rel="noopener" target="_blank"><m><i>, my old friend</i></m></a>), we've found that Rust is incredibly empowering for those new to lower-level programming.</p><p>As mentioned, memory and concurrency safety built into the language means that an <m>entire class of problems not only fail to compile,</m><m><m> but </m></m><m>the compiler itself</m> is often the only teacher you need since its warnings are so descriptive. Much has already been written about Rust's <a href="https://twitter.com/b0rk/status/954366146505052160?lang=en" rel="noopener" target="_blank">great compiler messages</a>, as well as <a href="https://doc.rust-lang.org/stable/book/" rel="noopener" target="_blank">excellent docs</a> (for example, take a look at this <a href="https://doc.rust-lang.org/book/ch08-02-strings.html" rel="noopener" target="_blank">lengthy discussion on strings</a>), and in our case as well these have been incredibly helpful resources.</p><p>There is usually one obvious "right way" to do a thing in Rust, unlike many other languages. Code that isn't written the "right way" tends to stand out, and is easy to pick out in reviews, often times automatically by <code>cargo clippy</code>.</p><p>In practice, this has meant that new engineers can quickly start contributing production-ready code. Code reviews can remain focused on the implementation, as opposed to expending energy doing manual correctness checks.</p><a href="#the-day-to-day" id="the-day-to-day"><h2>The day-to-day</h2></a><a href="#an-ide-census" id="an-ide-census"><h3>An IDE census</h3></a><p>In the IDE department, Rust still shows its relative immaturity compared to some of its predecessors. This year especially, though, there have been huge strides, and each of us has found a pretty comfortable development environment at this point.

 • 1 of us use macOS, and 3 of us use Linux (Arch, Ubuntu, and Pop!_OS, revealing our respective levels of masochism)
 • 2 of us use VS Code with the <code>rust-analyzer</code> plugin, and 2 of us use Sublime Text with <code>RustEnhanced</code>.

We’re often sharing setups and trying each other’s out (except Brian, who is stuck in his ways at the ripe old age of 29), and we’re constantly keeping an eye on new development tools that can help us work better together.</p><a href="#code-style-guidelines-are-dead,-long-live-rustfmt" id="code-style-guidelines-are-dead,-long-live-rustfmt"><h3>Code style guidelines are dead, long live <code>rustfmt</code></h3></a><p>You know what's <i>wild</i>? We don't have a code style guideline document that you have to read before submitting code. We don't need one. We just enforce <code>rustfmt</code>. <i>Let me tell you:</i> it really takes the edge off of code reviews.</p><a href="#how-we-review-code" id="how-we-review-code"><h3>How we review code</h3></a><p>Our code reviews are straightforward since there's only four of us so far, and we are lucky to have a lot of trust amongst us. Our main goal is to have <b><i>at least two pairs of eyes</i></b> on every line of code, and to not block each other so we can maintain momentum.</p><a href="#continuous-testing" id="continuous-testing"><h2>Continuous testing</h2></a><p>We use Google’s Cloud Builder for running our CI build, as our infrastructure stack is mostly built on GCP and it allows for easy-ish tweaking of build machine specs and custom build images. It's triggered for every commit and runs <code>cargo clippy</code> and <code>cargo build</code>. We pass <code>-D warnings</code> to the compiler to promote warnings into errors to ensure our changes don’t make our poor fellow coworker’s <code>rustc</code> <m>rain w</m>arnings on them the next time they pull changes.

To improve the CI build time, we cache the <code>target</code> and <code>.cargo</code> directories in Cloud Storage, so it can be download next time for incremental build.</p><pre><code><span>for</span> <span>crate</span> <span>in</span> <span><span>$(</span><span>ls</span> */Cargo.toml <span>|</span> <span>xargs</span> <span>dirname</span><span>)</span></span><span>;</span> <span>do</span>
  <span>pushd</span> <span>$crate</span>

  
  cargo +<span>$NIGHTLY_TOOLCHAIN</span> clippy --no-default-features -- -D warnings

  
  <span>time</span> <span>RUSTFLAGS</span><span>=</span><span>"-D warnings"</span> cargo build --no-default-features

  
  <span>time</span> cargo <span>test</span> --no-default-features

  <span>popd</span>
<span>done</span></code></pre><p>We've also heard good things about <code><a href="https://github.com/mozilla/sccache" rel="noopener" target="_blank">sccache</a></code> and will evaluate it soon!</p><a href="#integrating-with-existing-c/c++-libraries" id="integrating-with-existing-c/c++-libraries"><h2>Integrating with existing C/C++ libraries</h2></a><p>The Rust ecosystem is great, but there are huge existing projects out there which just aren't feasible to port to Rust yet without a huge time investment. <code>webrtc-audio-processing</code> is a good example. The benefits it provides (clear audio with no vocal echoes or feedback) are huge and porting it to Rust in the near-term is not likely (it's around 80k lines of C and C++ code).</p><p>Thankfully, Rust makes it quite easy to use existing C and C++ libraries. <m>The </m><m><a href="https://crates.io/crates/bindgen" rel="noopener" target="_blank">bindgen</a></m><m> crate does most of the heavy-lifting. Give it a header file in C or C++ and it will automatically generate (unsafe) Rust code which can call the functions defined in the header.</m> At that point, it's up to you to create a higher level Rust crate which exposes a safe API.</p><p>A lot of this process is fairly automatic for libraries with straightforward or commonly-used build processes. Creating the higher level safe API is important though - the Rust API that bindgen provides is not very fun to use directly as it's unsafe and typically not very idiomatic. Fortunately, once you have a higher level API you can eventually swap the C library out with your own Rust version and consumers of the crate are none the wiser.</p><p>These features let us work with APIs and hardware which would either never have a native Rust API or take months or years to re-implement. Low-level OS libraries, large codebases such as <code>webrtc-audio-processing</code>, and manufacturer-supplied camera SDKs all become available for use in our Rust codebase without having to move our entire application language over to C++, while still performing as if we had.</p><a href="#c++-specific-quirks" id="c++-specific-quirks"><h3>C++-specific quirks</h3></a><p>Some C++ libraries are difficult to interface with directly from Rust. You have to whitelist types because <code>bindgen</code> can't handle all the <code>std::*</code> types that get pulled in, it doesn't play well with templated functions and copy/move constructors, and a whole host of other issues documented <a href="https://rust-lang.github.io/rust-bindgen/cpp.html" rel="noopener" target="_blank">here</a>.</p><p>To get around these issues, we'll typically create a simplified C++ header and source wrapper which exports <code>bindgen</code>-friendly functions. It's a bit more work, but far less work than porting the entire library to Rust. You can see an example of this wrapper creation <a href="https://github.com/tonarino/webrtc-audio-processing/tree/2a973929c3afbc24beea75aa235f3341a7be275a/webrtc-audio-processing-sys/src" rel="noopener" target="_blank">here</a>.</p><p>With all of Rust's ecosystem, and C/C++ projects being only a <code>bindgen</code> invocation away, we have easy access to some of the highest quality software packages in existence, all without having to sacrifice execution speed.</p><a href="#pain-points-of-rust" id="pain-points-of-rust"><h2>Pain points of Rust</h2></a><p>Rust is not problem-free. It's a relatively new language that is constantly evolving, and there are shortcomings that you should consider when evaluating a move to Rust. <m>Here</m> is our non-exhaustive list:</p><ul><li><b>Long compile times</b>; <a href="https://xkcd.com/303/" rel="noopener" target="_blank">the popular xkcd comic</a>, the coffee break while waiting for Rust code to compile is very real. Our codebase for example takes about 8 mins to compile non-incrementally on a moderately beefy laptop, but it can be a lot <a href="https://pingcap.com/blog/rust-compilation-model-calamity/" rel="noopener" target="_blank">worse</a>.
The Rust compiler has a lot of work to do enforcing strong language guarantees, and it must compile your entire dependency tree from source. Incremental builds are better, but some crates come with build scripts that pull and compile non-Rust dependency code, and the build cache may need to be cleared when upgrading their versions and switching branches.</li><li><b>Library coverage</b>; The library ecosystem is quite mature but the coverage is limited compared to C / C++. We ended up implementing our own jitter buffer, and we also wrap several C / C++ libraries with Rust's <a href="https://github.com/rust-lang/rust-bindgen" rel="noopener" target="_blank">bindgen</a>, which means we have <code>unsafe</code> regions in our Rust code. Non-trivial projects tend to have some minimal amount of <code>unsafe</code> coding, which adds to the learning curve and chance of memory bugs.</li><li>Rust demands you to write <b>correct and explicit code up-front</b>. If you get it wrong, the compiler won't let it slide. If you care less about concurrency and memory guarantees, development can feel needlessly slow. Rust developers are constantly working on improving the error messages, though. They are friendly and actionable, often with an included fix suggestion. A good foundational model on memory &amp; concurrency also helps getting over the initial hump quicker, so we suggest taking time to truly understand the language and its guarantees.</li><li><b>Rust's type inferencer</b> is so strong it makes you feel sometimes like you're using a dynamically-typed language. That said, there comes the moment where it does not quite work the way you want, especially when generics and <a href="https://doc.rust-lang.org/book/ch15-02-deref.html" rel="noopener" target="_blank">deref coercion</a> are involved, and you end up having to fumble around to make the inferencer happy. It can come with frustration, and it's really helpful to have someone in the team who already has gone through that stage of learning. With enough patience, that frustration often turns into a wow moment, with a deeper understanding of the language design and why it's done that way, as well as a possible bug that you would have otherwise introduced.</li><li><b>Language evolution</b>; The Rust language is constantly evolving. Some of the language constructs like <code>async</code> are still volatile, and you may find it's best to stick with threads and the standard library when you can.</li></ul><a href="#consequences-of-selecting-rust-so-far" id="consequences-of-selecting-rust-so-far"><h2><m>Consequences of selecting Rust so far</m></h2></a><p>Experiencing no software-related downtime so far is both a pleasant surprise, and a testament to the safety provided by Rust's guarantees. Rust has also made it easy to write performant code with efficient resource usage - both our CPU and memory usage has been predictable and consistent. Without a garbage collector, we can guarantee consistent latency and frame rates.</p><p>Our experience maintaining a Rust codebase has also been great. We've been able to introduce significant improvements to our latency through sizable changes to our codebase with confidence. A clean compile doesn't always imply everything will work, but honestly, that's been the case more often than not.</p><p>The end result is a reliable product which hasn't been a nightmare to maintain (strong words, we know), and performs quickly at the high specs we demand for frame rate, latency, and resource efficiency. Again, it's hard to imagine where we might be without Rust!</p><a href="#open-source" id="open-source"><h2><m>Open</m> source</h2></a><p><m>We've open sourced one </m><a href="https://doc.rust-lang.org/nomicon/ffi.html" rel="noopener" target="_blank"><m>FFI</m></a><m> crate so far, </m><code><a href="https://github.com/tonarino/webrtc-audio-processing" rel="noopener" target="_blank">webrtc-audio-processing</a></code>. This is one of the crates that used to live in the top level of our repo, and there are many more like it on their way to open-source.</p><p>There will be more on this subject later as we release more code, but one thing feels true: even before open-sourcing our crates, it’s felt very healthy to our code's clarity to <i>assume</i> each crate we crate privately <i>will</i> be open-sourced. This philosophy keeps our boundaries between crates more clean, and encourages us to make quicker decisions about opening up parts of our codebase with minimal fuss.</p><a href="#thanks" id="thanks"><h2>Thanks</h2></a><p>Thanks for making it this far, we hope this brain-dump might have offered a useful thought or two for those getting into Rust, or those with advanced knowledge of Rust but using it in different environments. Please feel free to say hi at <a href="mailto:hey@tonari.no" rel="noopener" target="_blank">hey@tonari.no</a> or find us on <a href="https://twitter.com/heytonari" rel="noopener" target="_blank">Twitter</a> with any feedback.</p><div><picture><source srcset="images/cc0e4c37-b0a6-4072-8f41-d74c3d23bdee-Untitled.png.optimized.webp" type="image/webp"><source srcset="images/cc0e4c37-b0a6-4072-8f41-d74c3d23bdee-Untitled.png.optimized.jpg"><img src="https://blog.tonari.no/images/cc0e4c37-b0a6-4072-8f41-d74c3d23bdee-Untitled.png.optimized.jpg"></picture></div><p><b>Note: </b>In an earlier version of this post, we called our audio "audiophile-quality" which is a phrase that, at this point, could mean anything. We've updated the post with more details.</p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>