<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity - linksfor.dev(s)"/>
    <meta property="og:description" content="In this post, I show how you can build a client-side Blazor app with authentication using WebAPI and ASP.NET Core Identity."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://chrissainty.com/securing-your-blazor-apps-authentication-with-clientside-blazor-using-webapi-aspnet-core-identity/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity</title>
<div class="readable">
        <h1>Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity</h1>
            <div>Reading time: 27-35 minutes</div>
        <div>Posted here: 10 Jul 2019</div>
        <p><a href="https://chrissainty.com/securing-your-blazor-apps-authentication-with-clientside-blazor-using-webapi-aspnet-core-identity/">https://chrissainty.com/securing-your-blazor-apps-authentication-with-clientside-blazor-using-webapi-aspnet-core-identity/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
                        <!--kg-card-begin: html--><h2>Securing Your Blazor Apps (Part 2)</h2><!--kg-card-end: html--><hr><p>This is the second post in the series: Securing Your Blazor Apps. </p><p><strong>Part 1</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-introduction-to-authentication-with-blazor/">Introduction to Authentication with server-side Blazor</a><br><strong>Part 2</strong> - Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity (this post)<br><strong>Part 3</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-configuring-role-based-authorization-with-client-side-blazor/">Configuring Role-based Authorization with client-side Blazor</a><br><strong>Part 4</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-configuring-policy-based-authorization-with-blazor/">Configuring Policy-based Authorization with Blazor</a></p><hr><p>In <a href="https://chrissainty.com/securing-your-blazor-apps-introduction-to-authentication-with-blazor/">part 1</a> of this series, I showed how to create a server-side Blazor application with authentication enabled. </p><p>In this post, I'm going to show how to setup authentication with client-side Blazor using WebAPI and ASP.NET Core Identity.</p><blockquote>All the code for this post is available on <a href="https://github.com/chrissainty/AuthenticationWithClientSideBlazor">GitHub</a>.</blockquote><p>If you are not familiar with ASP.NET Core Identity then you can checkout the <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-2.2&amp;tabs=visual-studio">Microsoft Docs site</a> for full and in-depth information.</p><h2 id="getting-setup-creating-the-solution">Getting Setup: Creating the solution</h2><figure><img src="https://chrissainty.com/content/images/2019/08/Screenshot-2019-08-14-at-15.04.37.png"></figure><p>Start by creating a new Blazor WebAssembly App (remember to tick the ASP.NET Core hosted checkbox), this template will create a Blazor application which runs in the clients browser on WebAssembly hosted by a ASP.NET Core WebAPI. Once the solution has been created we're going to start making some changes to the server project.</p><h2 id="configuring-webapi">Configuring WebAPI</h2><p>We're going to configure the API first, but before we begin let's get some NuGet packages installed.</p><!--kg-card-begin: markdown--><pre><code>    <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"Microsoft.AspNetCore.Blazor.Server"</span> <span>Version</span>=<span>"3.1.0-preview3.19555.2"</span> /&gt;</span>
    <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"Microsoft.AspNetCore.Mvc.NewtonsoftJson"</span> <span>Version</span>=<span>"3.1.0-preview3.19555.2"</span> /&gt;</span>

    <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"Microsoft.AspNetCore.Authentication.JwtBearer"</span> <span>Version</span>=<span>"3.1.0-preview3.19555.2"</span> /&gt;</span>
    <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"Microsoft.AspNetCore.Identity.UI"</span> <span>Version</span>=<span>"3.1.0-preview3.19555.2"</span> /&gt;</span>
    <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore"</span> <span>Version</span>=<span>"3.1.0-preview3.19555.2"</span> /&gt;</span>
    <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"Microsoft.AspNetCore.Identity.EntityFrameworkCore"</span> <span>Version</span>=<span>"3.1.0-preview3.19555.2"</span> /&gt;</span>
    <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"Microsoft.EntityFrameworkCore.SqlServer"</span> <span>Version</span>=<span>"3.1.0-preview3.19554.8"</span> /&gt;</span>
    <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"Microsoft.EntityFrameworkCore.Tools"</span> <span>Version</span>=<span>"3.1.0-preview3.19554.8"</span>&gt;</span>
      <span>&lt;<span>PrivateAssets</span>&gt;</span>all<span>&lt;/<span>PrivateAssets</span>&gt;</span>
      <span>&lt;<span>IncludeAssets</span>&gt;</span>runtime; build; native; contentfiles; analyzers; buildtransitive<span>&lt;/<span>IncludeAssets</span>&gt;</span>
    <span>&lt;/<span>PackageReference</span>&gt;</span>
    <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"Microsoft.Extensions.Logging.Debug"</span> <span>Version</span>=<span>"3.1.0-preview3.19553.2"</span> /&gt;</span>
    <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>"Microsoft.VisualStudio.Web.CodeGeneration.Design"</span> <span>Version</span>=<span>"3.1.0-preview3.19558.8"</span> /&gt;</span>
</code></pre>
<!--kg-card-end: markdown--><p>You can either add the above packages to your server projects .csproj file - or you can install them via the command line or NuGet package manager.</p><h3 id="setting-up-the-identity-database-connection-string">Setting up the Identity database: Connection string</h3><p>Before we can set anything up, database wise we need a connection string. This is usually kept in the <code>appsettings.json</code> file, but the Blazor hosted template doesn't supply one - so we are going to have to add it.</p><p>Right click on the server project and select <code>Add</code> &gt; <code>New Item</code>. Then select <code>App Settings File</code> from the list.</p><!--kg-card-begin: markdown--><pre><code>{
  <span>"ConnectionStrings"</span>: {
    <span>"DefaultConnection"</span>: <span>"Server=(localdb)\\MSSQLLocalDB;Database=AuthenticationWithClientSideBlazor;Trusted_Connection=True;MultipleActiveResultSets=true"</span>
  }
}
</code></pre>
<!--kg-card-end: markdown--><p>The file comes with a connection string already in place, feel free to point this where ever you need to. I'm just going to add a database name and leave the rest as default.</p><h3 id="setting-up-the-identity-database-dbcontext">Setting up the Identity database: DbContext</h3><p>In the root of the server project create a folder called <code>Data</code> then add a new class called <code>ApplicationDbContext</code> with the following code.</p><!--kg-card-begin: markdown--><pre><code><span>public</span> <span>class</span> <span>ApplicationDbContext</span> : <span>IdentityDbContext</span>
{
    <span><span>public</span> <span>ApplicationDbContext</span>(<span>DbContextOptions options</span>) : <span>base</span>(<span>options</span>)</span>
    {
    }
}
</code></pre>
<!--kg-card-end: markdown--><p>Because we are using Identity which needs to store information in a database we're not inheriting from <code>DbContext</code> but instead from <code>IdentityDbContext</code>. &nbsp;The <code>IdentityDbContext</code> base class contains all the configuration EF needs to manage the Identity database tables.</p><h3 id="setting-up-the-identity-database-registering-services">Setting up the Identity database: Registering services</h3><p>In the <code>Startup</code> class we need to add a constructor which takes an <code>IConfiguration</code> and a property to store it. <code>IConfiguration</code> allows us to access the settings in the <code>appsettings.json</code> file, such as the connection string.</p><!--kg-card-begin: markdown--><pre><code><span>public</span> IConfiguration Configuration { <span>get</span>; }

<span><span>public</span> <span>Startup</span>(<span>IConfiguration configuration</span>)</span>
{
    Configuration = configuration;
}
</code></pre>
<!--kg-card-end: markdown--><p>Now we need to add the following lines to the top of the <code>ConfigureServices</code> method.</p><!--kg-card-begin: markdown--><pre><code><span><span>public</span> <span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection services</span>)</span>
{
    services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
                    options.UseSqlServer(Configuration.GetConnectionString(<span>"DefaultConnection"</span>)));

    services.AddDefaultIdentity&lt;IdentityUser&gt;()
        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();

    

}
</code></pre>
<!--kg-card-end: markdown--><p>Essentially, these two lines are adding the <code>ApplicationDbContext</code> to the services collection. Then registering the various services for ASP.NET Core Identity and telling it to use Entity Framework as a backing store via the <code>ApplicationDbContext</code>.</p><h3 id="setting-up-the-identity-database-creating-the-database">Setting up the Identity database: Creating the database</h3><p>We're now in a position to create the initial migration for the database. In the package manager console run the following command.</p><!--kg-card-begin: markdown--><pre><code>Add-Migration CreateIdentitySchema -o <span>Data</span>/Migrations
</code></pre>
<!--kg-card-end: markdown--><p>Once the command has run you should see the migrations file in <code>Data</code> &gt; <code>Migrations</code>. Run <code>Update-Database</code> in the console to apply the migration to your database.</p><p>If you have any issues with running the migration command, make sure that the server project is selected as the default project in the package manager console.</p><h3 id="enabling-authentication-registering-services">Enabling Authentication: Registering services</h3><p>The next step is to enable authentication in the API. Again, in <code>ConfigureServices</code> add the following code after the code we added in the previous section.</p><!--kg-card-begin: markdown--><pre><code><span><span>public</span> <span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection services</span>)</span>
{

    
    
    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
        .AddJwtBearer(options =&gt;
        {
            options.TokenValidationParameters = <span>new</span> TokenValidationParameters
            {
                ValidateIssuer = <span>true</span>,
                ValidateAudience = <span>true</span>,
                ValidateLifetime = <span>true</span>,
                ValidateIssuerSigningKey = <span>true</span>,
                ValidIssuer = Configuration[<span>"JwtIssuer"</span>],
                ValidAudience = Configuration[<span>"JwtAudience"</span>],
                IssuerSigningKey = <span>new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration[<span>"JwtSecurityKey"</span>]))
            };
        });
        
     

}
</code></pre>
<!--kg-card-end: markdown--><p>The code above is adding and setting up some services required for authentication to the service container. Then adding a handler for JSON Web Tokens (JWT) and configuring how received JWTs should be validated. Feel free to tweak these settings to your requirements.</p><h3 id="enabling-authentication-app-settings">Enabling Authentication: App settings</h3><p>There are a few settings which are being loaded from the <code>appsettings.json</code> file.</p><ul><li><code>Configuration["JwtIssuer"]</code></li><li><code>Configuration["JwtAudience"]</code></li><li><code>Configuration["JwtSecurityKey"]</code></li></ul><p>We haven' actually added them to the <code>appsettings</code> file yet, so let do that now. While we're there we'll also add a setting to control how long the tokens last, which we'll use in a bit.</p><!--kg-card-begin: markdown--><pre><code><span>"JwtSecurityKey"</span>: <span>"RANDOM_KEY_MUST_NOT_BE_SHARED"</span>,
<span>"JwtIssuer"</span>: <span>"https://localhost"</span>,
<span>"JwtAudience"</span>: <span>"https://localhost"</span>,
<span>"JwtExpiryInDays"</span>: <span>1</span>,
</code></pre>
<!--kg-card-end: markdown--><p>It's really important that the <code>JwtSecurityKey</code> is kept secret as this is what is used to sign the tokens produced by the API. If this is compromised then your app would no longer be secure.</p><p>As I'm running everything locally I have my <em>Issuer</em> and <em>Audienc</em>e set to localhost. But if you're using this in a real app then you would set the <em>Issuer</em> to the domain the API is running on and the <em>Audience</em> to the domain the client app is running on.</p><h3 id="enabling-authentication-adding-middleware">Enabling Authentication: Adding middleware</h3><p>Finally, in the <code>Configure</code> method we need to add the necessary middleware to the pipeline. This will enable the authentication and authorization features in our API. Add them just above the <code>app.UseEndpoints</code> middleware.</p><!--kg-card-begin: markdown--><pre><code>app.UseAuthentication();
app.UseAuthorization();
</code></pre>
<!--kg-card-end: markdown--><p>That should be everything we need to do the <code>Startup</code> class. Authentication is now enabled for the API.</p><p>You can test everything is working by adding an <code>[Authorize]</code> attribute to the <code>WeatherForecasts</code> action on the <code>SampleDataController</code>. Then startup the app and navigate to the <em>Fetch Data</em> page, no data should load and you should see a 401 error in the console.</p><h3 id="adding-the-account-controller">Adding the account controller</h3><p>In order for people to login to our app they need to be able to signup. We're going to add an account controller which will be responsible for creating new accounts. </p><!--kg-card-begin: markdown--><pre><code>[<span>Route(<span>"api/[controller]"</span>)</span>]
[<span>ApiController</span>]
<span>public</span> <span>class</span> <span>AccountsController</span> : <span>ControllerBase</span>
{
    <span>private</span> <span>static</span> UserModel LoggedOutUser = <span>new</span> UserModel { IsAuthenticated = <span>false</span> };

    <span>private</span> <span>readonly</span> UserManager&lt;IdentityUser&gt; _userManager;

    <span><span>public</span> <span>AccountsController</span>(<span>UserManager&lt;IdentityUser&gt; userManager</span>)</span>
    {
        _userManager = userManager;
    }

    [<span>HttpPost</span>]
    <span><span>public</span> <span>async</span> Task&lt;IActionResult&gt; <span>Post</span>(<span>[FromBody]RegisterModel model</span>)</span>
    {
        <span>var</span> newUser = <span>new</span> IdentityUser { UserName = model.Email, Email = model.Email };

        <span>var</span> result = <span>await</span> _userManager.CreateAsync(newUser, model.Password);

        <span>if</span> (!result.Succeeded)
        {
            <span>var</span> errors = result.Errors.Select(x =&gt; x.Description);

            <span>return</span> Ok(<span>new</span> RegisterResult { Successful = <span>false</span>, Errors = errors });

        }

        <span>return</span> Ok(<span>new</span> RegisterResult { Successful = <span>true</span> });
    }
}
</code></pre>
<!--kg-card-end: markdown--><p>The <code>Post</code> action uses the ASP.NET Core Identity <code>UserManager</code> to create a new user in the system from a <code>RegisterModel</code>. </p><p>We haven't added the register model yet so we can do that now, put this in the shared project as this will be used by our Blazor app in a bit.</p><!--kg-card-begin: markdown--><pre><code><span>public</span> <span>class</span> <span>RegisterModel</span>
{
    [<span>Required</span>]
    [<span>EmailAddress</span>]
    [<span>Display(Name = <span>"Email"</span>)</span>]
    <span>public</span> <span>string</span> Email { <span>get</span>; <span>set</span>; }

    [<span>Required</span>]
    [<span>StringLength(100, ErrorMessage = <span>"The {0} must be at least {2} and at max {1} characters long."</span>, MinimumLength = 6)</span>]
    [<span>DataType(DataType.Password)</span>]
    [<span>Display(Name = <span>"Password"</span>)</span>]
    <span>public</span> <span>string</span> Password { <span>get</span>; <span>set</span>; }

    [<span>DataType(DataType.Password)</span>]
    [<span>Display(Name = <span>"Confirm password"</span>)</span>]
    [<span>Compare(<span>"Password"</span>, ErrorMessage = <span>"The password and confirmation password do not match."</span>)</span>]
    <span>public</span> <span>string</span> ConfirmPassword { <span>get</span>; <span>set</span>; }
}
</code></pre>
<!--kg-card-end: markdown--><p>If all goes well then a successful <code>RegisterResult</code> is returned, otherwise a failed <code>RegisterResult</code> is returned. Again, we need to create the <code>RegisterResult</code> and again it needs to go in the shared project.</p><!--kg-card-begin: markdown--><pre><code><span>public</span> <span>class</span> <span>RegisterResult</span>
{
    <span>public</span> <span>bool</span> Successful { <span>get</span>; <span>set</span>; }
    <span>public</span> IEnumerable&lt;<span>string</span>&gt; Errors { <span>get</span>; <span>set</span>; }
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="adding-the-login-controller">Adding the login controller</h3><p>Now we have a way for users to signup we now need a way for them to login.</p><!--kg-card-begin: markdown--><pre><code>[<span>Route(<span>"api/[controller]"</span>)</span>]
[<span>ApiController</span>]
<span>public</span> <span>class</span> <span>LoginController</span> : <span>ControllerBase</span>
{
    <span>private</span> <span>readonly</span> IConfiguration _configuration;
    <span>private</span> <span>readonly</span> SignInManager&lt;IdentityUser&gt; _signInManager;

    <span><span>public</span> <span>LoginController</span>(<span>IConfiguration configuration,
                           SignInManager&lt;IdentityUser&gt; signInManager</span>)</span>
    {
        _configuration = configuration;
        _signInManager = signInManager;
    }

    [<span>HttpPost</span>]
    <span><span>public</span> <span>async</span> Task&lt;IActionResult&gt; <span>Login</span>(<span>[FromBody] LoginModel login</span>)</span>
    {
        <span>var</span> result = <span>await</span> _signInManager.PasswordSignInAsync(login.Email, login.Password, <span>false</span>, <span>false</span>);

        <span>if</span> (!result.Succeeded) <span>return</span> BadRequest(<span>new</span> LoginResult { Successful = <span>false</span>, Error = <span>"Username and password are invalid."</span> });

        <span>var</span> claims = <span>new</span>[]
        {
            <span>new</span> Claim(ClaimTypes.Name, login.Email)
        };

        <span>var</span> key = <span>new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration[<span>"JwtSecurityKey"</span>]));
        <span>var</span> creds = <span>new</span> SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        <span>var</span> expiry = DateTime.Now.AddDays(Convert.ToInt32(_configuration[<span>"JwtExpiryInDays"</span>]));

        <span>var</span> token = <span>new</span> JwtSecurityToken(
            _configuration[<span>"JwtIssuer"</span>],
            _configuration[<span>"JwtAudience"</span>],
            claims,
            expires: expiry,
            signingCredentials: creds
        );

        <span>return</span> Ok(<span>new</span> LoginResult { Successful = <span>true</span>, Token = <span>new</span> JwtSecurityTokenHandler().WriteToken(token) });
    }
}
</code></pre>
<!--kg-card-end: markdown--><p>The sole job of the login controller is to verify the username and password in the <code>LoginModel</code> using the ASP.NET Core Identity <code>SignInManger</code>. If they're correct then a new JSON web token is generated and passed back to the client in a <code>LoginResult</code>.</p><p>Just like before we need to add the <code>LoginModel</code> and <code>LoginResult</code> to the shared project.</p><!--kg-card-begin: markdown--><pre><code><span>public</span> <span>class</span> <span>LoginModel</span>
{
    [<span>Required</span>]
    <span>public</span> <span>string</span> Email { <span>get</span>; <span>set</span>; }

    [<span>Required</span>]
    <span>public</span> <span>string</span> Password { <span>get</span>; <span>set</span>; }

    <span>public</span> <span>bool</span> RememberMe { <span>get</span>; <span>set</span>; }
}
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code><span>public</span> <span>class</span> <span>LoginResult</span>
{
    <span>public</span> <span>bool</span> Successful { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Error { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Token { <span>get</span>; <span>set</span>; }
}
</code></pre>
<!--kg-card-end: markdown--><p>That's everything we need on our API. We have now configured it to use authentication via JSON web tokens. As well as setup the controllers we need for our Blazor client-side app to register new users and to login.</p><h2 id="configuring-client-side-blazor">Configuring client-side Blazor</h2><p>Let's turn our attention to Blazor. The first thing we're going to do is install <a href="https://www.nuget.org/packages/Blazored.LocalStorage/">Blazored.LocalStorage</a>, we will need this later to persist the auth token from the API when we login.</p><p>We also need to update the <code>App</code> component to use the <code>AuthorizeRouteView</code> component instead of the <code>RouteView</code> component.</p><!--kg-card-begin: markdown--><pre><code><span>&lt;<span>Router</span> <span>AppAssembly</span>=<span>"@typeof(Program).Assembly"</span>&gt;</span>
    <span>&lt;<span>Found</span> <span>Context</span>=<span>"routeData"</span>&gt;</span>
        <span>&lt;<span>AuthorizeRouteView</span> <span>RouteData</span>=<span>"@routeData"</span> <span>DefaultLayout</span>=<span>"@typeof(MainLayout)"</span> /&gt;</span>
    <span>&lt;/<span>Found</span>&gt;</span>
    <span>&lt;<span>NotFound</span>&gt;</span>
        <span>&lt;<span>CascadingAuthenticationState</span>&gt;</span>
            <span>&lt;<span>LayoutView</span> <span>Layout</span>=<span>"@typeof(MainLayout)"</span>&gt;</span>
                <span>&lt;<span>p</span>&gt;</span>Sorry, there's nothing at this address.<span>&lt;/<span>p</span>&gt;</span>
            <span>&lt;/<span>LayoutView</span>&gt;</span>
        <span>&lt;/<span>CascadingAuthenticationState</span>&gt;</span>
    <span>&lt;/<span>NotFound</span>&gt;</span>
<span>&lt;/<span>Router</span>&gt;</span>
</code></pre>
<!--kg-card-end: markdown--><p>This component provides a cascading parameter of type <code>Task&lt;AuthenticationState&gt;</code>. This is used by the <code>AuthorizeView</code> component to determine the current users authentication state. </p><p>But any component can request the parameter and use it to do procedural logic, for example.</p><!--kg-card-begin: markdown--><pre><code>@code {
    [CascadingParameter] private Task<span>&lt;<span>AuthenticationState</span>&gt;</span> authenticationStateTask { get; set; }

    private async Task LogUserAuthenticationState()
    {
        var authState = await authenticationStateTask;
        var user = authState.User;

        if (user.Identity.IsAuthenticated)
        {
            Console.WriteLine($"User {user.Identity.Name} is authenticated.");
        }
        else
        {
            Console.WriteLine("User is NOT authenticated.");
        }
    }
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="creating-a-custom-authenticationstateprovider">Creating a Custom AuthenticationStateProvider</h3><p>As we are using client-side Blazor we need to provide our own implementation for the <code>AuthenticationStateProvider</code> class. Because there are so many options when it comes to client-side apps there is no way to design a default class that would work for everyone. </p><p>We need to override the <code>GetAuthenticationStateAsync</code> method. In this method we need to determine if the current user is authenticated or not. We're also going to add a couple of helper methods which we will use to update the authentication state when the user logs in or out.</p><!--kg-card-begin: markdown--><pre><code><span>public</span> <span>class</span> <span>ApiAuthenticationStateProvider</span> : <span>AuthenticationStateProvider</span>
{
    <span>private</span> <span>readonly</span> HttpClient _httpClient;
    <span>private</span> <span>readonly</span> ILocalStorageService _localStorage;

    <span><span>public</span> <span>ApiAuthenticationStateProvider</span>(<span>HttpClient httpClient, ILocalStorageService localStorage</span>)</span>
    {
        _httpClient = httpClient;
        _localStorage = localStorage;
    }
    <span><span>public</span> <span>override</span> <span>async</span> Task&lt;AuthenticationState&gt; <span>GetAuthenticationStateAsync</span>(<span></span>)</span>
    {
        <span>var</span> savedToken = <span>await</span> _localStorage.GetItemAsync&lt;<span>string</span>&gt;(<span>"authToken"</span>);

        <span>if</span> (<span>string</span>.IsNullOrWhiteSpace(savedToken))
        {
            <span>return</span> <span>new</span> AuthenticationState(<span>new</span> ClaimsPrincipal(<span>new</span> ClaimsIdentity()));
        }

        _httpClient.DefaultRequestHeaders.Authorization = <span>new</span> AuthenticationHeaderValue(<span>"bearer"</span>, savedToken);

        <span>return</span> <span>new</span> AuthenticationState(<span>new</span> ClaimsPrincipal(<span>new</span> ClaimsIdentity(ParseClaimsFromJwt(savedToken), <span>"jwt"</span>)));
    }

    <span><span>public</span> <span>void</span> <span>MarkUserAsAuthenticated</span>(<span><span>string</span> email</span>)</span>
    {
        <span>var</span> authenticatedUser = <span>new</span> ClaimsPrincipal(<span>new</span> ClaimsIdentity(<span>new</span>[] { <span>new</span> Claim(ClaimTypes.Name, email) }, <span>"apiauth"</span>));
        <span>var</span> authState = Task.FromResult(<span>new</span> AuthenticationState(authenticatedUser));
        NotifyAuthenticationStateChanged(authState);
    }

    <span><span>public</span> <span>void</span> <span>MarkUserAsLoggedOut</span>(<span></span>)</span>
    {
        <span>var</span> anonymousUser = <span>new</span> ClaimsPrincipal(<span>new</span> ClaimsIdentity());
        <span>var</span> authState = Task.FromResult(<span>new</span> AuthenticationState(anonymousUser));
        NotifyAuthenticationStateChanged(authState);
    }

    <span><span>private</span> IEnumerable&lt;Claim&gt; <span>ParseClaimsFromJwt</span>(<span><span>string</span> jwt</span>)</span>
    {
        <span>var</span> claims = <span>new</span> List&lt;Claim&gt;();
        <span>var</span> payload = jwt.Split(<span>'.'</span>)[<span>1</span>];
        <span>var</span> jsonBytes = ParseBase64WithoutPadding(payload);
        <span>var</span> keyValuePairs = JsonSerializer.Deserialize&lt;Dictionary&lt;<span>string</span>, <span>object</span>&gt;&gt;(jsonBytes);

        keyValuePairs.TryGetValue(ClaimTypes.Role, <span>out</span> <span>object</span> roles);

        <span>if</span> (roles != <span>null</span>)
        {
            <span>if</span> (roles.ToString().Trim().StartsWith(<span>"["</span>))
            {
                <span>var</span> parsedRoles = JsonSerializer.Deserialize&lt;<span>string</span>[]&gt;(roles.ToString());

                <span>foreach</span> (<span>var</span> parsedRole <span>in</span> parsedRoles)
                {
                    claims.Add(<span>new</span> Claim(ClaimTypes.Role, parsedRole));
                }
            }
            <span>else</span>
            {
                claims.Add(<span>new</span> Claim(ClaimTypes.Role, roles.ToString()));
            }

            keyValuePairs.Remove(ClaimTypes.Role);
        }

        claims.AddRange(keyValuePairs.Select(kvp =&gt; <span>new</span> Claim(kvp.Key, kvp.Value.ToString())));

        <span>return</span> claims;
    }

    <span><span>private</span> <span>byte</span>[] <span>ParseBase64WithoutPadding</span>(<span><span>string</span> base64</span>)</span>
    {
        <span>switch</span> (base64.Length % <span>4</span>)
        {
            <span>case</span> <span>2</span>: base64 += <span>"=="</span>; <span>break</span>;
            <span>case</span> <span>3</span>: base64 += <span>"="</span>; <span>break</span>;
        }
        <span>return</span> Convert.FromBase64String(base64);
    }
}
</code></pre>
<!--kg-card-end: markdown--><p>There is a lot of code here so let's break it down step by step.</p><p>The <code>GetAuthenticationStateAsync</code> method is called by the <code>CascadingAuthenticationState</code> component to determine if the current user is authenticated or not. </p><p>In the code above, we check to see if there is an auth token in local storage. If there is no token in local storage, then we return a new <code>AuthenticationState</code> with a blank claims principal. This is the equivalent of saying the current user is not authenticated.</p><p>If there is a token, we retrieve it and set the default authorization header for the <code>HttpClient</code>. We then return a new <code>AuthenticationState</code> with a new claims principal containing the claims from the token. The claims are extracted from the token by the <code>ParseClaimsFromJwt</code> method. This method decodes the token and returns the claims contained within it.</p><p><em>Full disclosure - the <code>ParseClaimsFromJwt</code> method is borrowed from <a href="https://github.com/SteveSandersonMS/presentation-2019-06-NDCOslo/tree/master/demos/MissionControl">Steve Sandersons Mission Control</a> demo app, which he showed at <a href="https://www.youtube.com/watch?v=uW-Kk7Qpv5U">NDC Oslo 2019</a>. </em></p><p>The <code>MarkUserAsAuthenticated</code> is a helper method that's used to when a user logs in. Its sole purpose is to invoke the <code>NotifyAuthenticationStateChanged</code> method which fires an event called <code>AuthenticationStateChanged</code>. This cascades the new authentication state, via the <code>CascadingAuthenticationState</code> component.</p><p>As you may expect, <code>MarkUserAsLoggedOut</code> does almost exactly the same as the previous method but when a user logs out.</p><h3 id="auth-service">Auth Service</h3><p>The auth service is going to be the what we use in our components to register users and log them in and out of the application. It's going to be a nice abstraction for all of the stuff going on in the background. </p><!--kg-card-begin: markdown--><pre><code><span>public</span> <span>class</span> <span>AuthService</span> : <span>IAuthService</span>
{
    <span>private</span> <span>readonly</span> HttpClient _httpClient;
    <span>private</span> <span>readonly</span> AuthenticationStateProvider _authenticationStateProvider;
    <span>private</span> <span>readonly</span> ILocalStorageService _localStorage;

    <span><span>public</span> <span>AuthService</span>(<span>HttpClient httpClient,
                       AuthenticationStateProvider authenticationStateProvider,
                       ILocalStorageService localStorage</span>)</span>
    {
        _httpClient = httpClient;
        _authenticationStateProvider = authenticationStateProvider;
        _localStorage = localStorage;
    }

    <span><span>public</span> <span>async</span> Task&lt;RegisterResult&gt; <span>Register</span>(<span>RegisterModel registerModel</span>)</span>
    {
        <span>var</span> result = <span>await</span> _httpClient.PostJsonAsync&lt;RegisterResult&gt;(<span>"api/accounts"</span>, registerModel);

        <span>return</span> result;
    }

    <span><span>public</span> <span>async</span> Task&lt;LoginResult&gt; <span>Login</span>(<span>LoginModel loginModel</span>)</span>
    {
        <span>var</span> loginAsJson = JsonSerializer.Serialize(loginModel);
        <span>var</span> response = <span>await</span> _httpClient.PostAsync(<span>"api/Login"</span>, <span>new</span> StringContent(loginAsJson, Encoding.UTF8, <span>"application/json"</span>));
        <span>var</span> loginResult = JsonSerializer.Deserialize&lt;LoginResult&gt;(<span>await</span> response.Content.ReadAsStringAsync(), <span>new</span> JsonSerializerOptions { PropertyNameCaseInsensitive = <span>true</span> });

        <span>if</span> (!response.IsSuccessStatusCode)
        {
            <span>return</span> loginResult;
        }

        <span>await</span> _localStorage.SetItemAsync(<span>"authToken"</span>, loginResult.Token);
        ((ApiAuthenticationStateProvider)_authenticationStateProvider).MarkUserAsAuthenticated(loginModel.Email);
        _httpClient.DefaultRequestHeaders.Authorization = <span>new</span> AuthenticationHeaderValue(<span>"bearer"</span>, loginResult.Token);

        <span>return</span> loginResult;
    }

    <span><span>public</span> <span>async</span> Task <span>Logout</span>(<span></span>)</span>
    {
        <span>await</span> _localStorage.RemoveItemAsync(<span>"authToken"</span>);
        ((ApiAuthenticationStateProvider)_authenticationStateProvider).MarkUserAsLoggedOut();
        _httpClient.DefaultRequestHeaders.Authorization = <span>null</span>;
    }
}
</code></pre>
<!--kg-card-end: markdown--><p>The <code>Register</code> method posts the <code>registerModel</code> to the accounts controller and then returns the <code>RegisterResult</code> to the caller.</p><p>The <code>Login</code> method is similar to the <code>Register</code> method, it posts the <code>LoginModel</code> to the login controller. But when a successful result is returned it strips out the auth token and persists it to local storage. </p><p>It then calls the <code>MarkUserAsAuthenticated</code> method we just looked at on the <code>ApiAuthenticationStateProvider</code>. Finally, it sets the default authorization header on the <code>HttpClient</code>.</p><p>The <code>Logout</code> method is just doing the reverse of the <code>Login</code> method.</p><h3 id="register-component">Register Component</h3><p>We're on the home stretch now. We can now turn our attention to the UI and creating a component which will allow people to register with the site.</p><!--kg-card-begin: markdown--><pre><code>@page "/register"
@inject IAuthService AuthService
@inject NavigationManager NavigationManager

<span>&lt;<span>h1</span>&gt;</span>Register<span>&lt;/<span>h1</span>&gt;</span>

@if (ShowErrors)
{
    <span>&lt;<span>div</span> <span>class</span>=<span>"alert alert-danger"</span> <span>role</span>=<span>"alert"</span>&gt;</span>
        @foreach (var error in Errors)
        {
            <span>&lt;<span>p</span>&gt;</span>@error<span>&lt;/<span>p</span>&gt;</span>
        }
    <span>&lt;/<span>div</span>&gt;</span>
}

<span>&lt;<span>div</span> <span>class</span>=<span>"card"</span>&gt;</span>
    <span>&lt;<span>div</span> <span>class</span>=<span>"card-body"</span>&gt;</span>
        <span>&lt;<span>h5</span> <span>class</span>=<span>"card-title"</span>&gt;</span>Please enter your details<span>&lt;/<span>h5</span>&gt;</span>
        <span>&lt;<span>EditForm</span> <span>Model</span>=<span>"RegisterModel"</span> <span>OnValidSubmit</span>=<span>"HandleRegistration"</span>&gt;</span>
            <span>&lt;<span>DataAnnotationsValidator</span> /&gt;</span>
            <span>&lt;<span>ValidationSummary</span> /&gt;</span>

            <span>&lt;<span>div</span> <span>class</span>=<span>"form-group"</span>&gt;</span>
                <span>&lt;<span>label</span> <span>for</span>=<span>"email"</span>&gt;</span>Email address<span>&lt;/<span>label</span>&gt;</span>
                <span>&lt;<span>InputText</span> <span>Id</span>=<span>"email"</span> <span>class</span>=<span>"form-control"</span> @<span>bind-Value</span>=<span>"RegisterModel.Email"</span> /&gt;</span>
                <span>&lt;<span>ValidationMessage</span> <span>For</span>=<span>"@(() =&gt; RegisterModel.Email)"</span> /&gt;</span>
            <span>&lt;/<span>div</span>&gt;</span>
            <span>&lt;<span>div</span> <span>class</span>=<span>"form-group"</span>&gt;</span>
                <span>&lt;<span>label</span> <span>for</span>=<span>"password"</span>&gt;</span>Password<span>&lt;/<span>label</span>&gt;</span>
                <span>&lt;<span>InputText</span> <span>Id</span>=<span>"password"</span> <span>type</span>=<span>"password"</span> <span>class</span>=<span>"form-control"</span> @<span>bind-Value</span>=<span>"RegisterModel.Password"</span> /&gt;</span>
                <span>&lt;<span>ValidationMessage</span> <span>For</span>=<span>"@(() =&gt; RegisterModel.Password)"</span> /&gt;</span>
            <span>&lt;/<span>div</span>&gt;</span>
            <span>&lt;<span>div</span> <span>class</span>=<span>"form-group"</span>&gt;</span>
                <span>&lt;<span>label</span> <span>for</span>=<span>"password"</span>&gt;</span>Confirm Password<span>&lt;/<span>label</span>&gt;</span>
                <span>&lt;<span>InputText</span> <span>Id</span>=<span>"password"</span> <span>type</span>=<span>"password"</span> <span>class</span>=<span>"form-control"</span> @<span>bind-Value</span>=<span>"RegisterModel.ConfirmPassword"</span> /&gt;</span>
                <span>&lt;<span>ValidationMessage</span> <span>For</span>=<span>"@(() =&gt; RegisterModel.ConfirmPassword)"</span> /&gt;</span>
            <span>&lt;/<span>div</span>&gt;</span>
            <span>&lt;<span>button</span> <span>type</span>=<span>"submit"</span> <span>class</span>=<span>"btn btn-primary"</span>&gt;</span>Submit<span>&lt;/<span>button</span>&gt;</span>
        <span>&lt;/<span>EditForm</span>&gt;</span>
    <span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>

@code {

    private RegisterModel RegisterModel = new RegisterModel();
    private bool ShowErrors;
    private IEnumerable<span>&lt;<span>string</span>&gt;</span> Errors;

    private async Task HandleRegistration()
    {
        ShowErrors = false;

        var result = await AuthService.Register(RegisterModel);

        if (result.Successful)
        {
            NavigationManager.NavigateTo("/login");
        }
        else
        {
            Errors = result.Errors;
            ShowErrors = true;
        }
    }

}
</code></pre>
<!--kg-card-end: markdown--><p>The register component contains a form which allows the user to enter their email address and desired password. When the form is submitted the <code>Register</code> method on the <code>AuthService</code> is called passing in the <code>RegisterModel</code>. If the result of the registration is a success then the user is navigated to the login page. Otherwise any errors are displayed to the user.</p><h3 id="login-component">Login Component</h3><p>Now we can register a new account, we need to be able to login. The login component is going to be responsible for that.</p><!--kg-card-begin: markdown--><pre><code>@page "/login"
@inject IAuthService AuthService
@inject NavigationManager NavigationManager

<span>&lt;<span>h1</span>&gt;</span>Login<span>&lt;/<span>h1</span>&gt;</span>

@if (ShowErrors)
{
    <span>&lt;<span>div</span> <span>class</span>=<span>"alert alert-danger"</span> <span>role</span>=<span>"alert"</span>&gt;</span>
        <span>&lt;<span>p</span>&gt;</span>@Error<span>&lt;/<span>p</span>&gt;</span>
    <span>&lt;/<span>div</span>&gt;</span>
}

<span>&lt;<span>div</span> <span>class</span>=<span>"card"</span>&gt;</span>
    <span>&lt;<span>div</span> <span>class</span>=<span>"card-body"</span>&gt;</span>
        <span>&lt;<span>h5</span> <span>class</span>=<span>"card-title"</span>&gt;</span>Please enter your details<span>&lt;/<span>h5</span>&gt;</span>
        <span>&lt;<span>EditForm</span> <span>Model</span>=<span>"loginModel"</span> <span>OnValidSubmit</span>=<span>"HandleLogin"</span>&gt;</span>
            <span>&lt;<span>DataAnnotationsValidator</span> /&gt;</span>
            <span>&lt;<span>ValidationSummary</span> /&gt;</span>

            <span>&lt;<span>div</span> <span>class</span>=<span>"form-group"</span>&gt;</span>
                <span>&lt;<span>label</span> <span>for</span>=<span>"email"</span>&gt;</span>Email address<span>&lt;/<span>label</span>&gt;</span>
                <span>&lt;<span>InputText</span> <span>Id</span>=<span>"email"</span> <span>Class</span>=<span>"form-control"</span> @<span>bind-Value</span>=<span>"loginModel.Email"</span> /&gt;</span>
                <span>&lt;<span>ValidationMessage</span> <span>For</span>=<span>"@(() =&gt; loginModel.Email)"</span> /&gt;</span>
            <span>&lt;/<span>div</span>&gt;</span>
            <span>&lt;<span>div</span> <span>class</span>=<span>"form-group"</span>&gt;</span>
                <span>&lt;<span>label</span> <span>for</span>=<span>"password"</span>&gt;</span>Password<span>&lt;/<span>label</span>&gt;</span>
                <span>&lt;<span>InputText</span> <span>Id</span>=<span>"password"</span> <span>type</span>=<span>"password"</span> <span>Class</span>=<span>"form-control"</span> @<span>bind-Value</span>=<span>"loginModel.Password"</span> /&gt;</span>
                <span>&lt;<span>ValidationMessage</span> <span>For</span>=<span>"@(() =&gt; loginModel.Password)"</span> /&gt;</span>
            <span>&lt;/<span>div</span>&gt;</span>
            <span>&lt;<span>button</span> <span>type</span>=<span>"submit"</span> <span>class</span>=<span>"btn btn-primary"</span>&gt;</span>Submit<span>&lt;/<span>button</span>&gt;</span>
        <span>&lt;/<span>EditForm</span>&gt;</span>
    <span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>

@code {

    private LoginModel loginModel = new LoginModel();
    private bool ShowErrors;
    private string Error = "";

    private async Task HandleLogin()
    {
        ShowErrors = false;

        var result = await AuthService.Login(loginModel);

        if (result.Successful)
        {
            NavigationManager.NavigateTo("/");
        }
        else
        {
            Error = result.Error;
            ShowErrors = true;
        }
    }

}
</code></pre>
<!--kg-card-end: markdown--><p>Following a similar design to the register component. There is a form for the user to input their email address and password.</p><p>When the form is submitted the <code>AuthService</code> is called and the result is returned. If the login was successful then the user is redirected to the home page, otherwise they are shown the error message.</p><h3 id="logout-component">Logout Component</h3><p>We can now register and login but we also need the ability to logout. I've gone with a page component to do this but you could also implement this on a button click somewhere.</p><!--kg-card-begin: markdown--><pre><code>@page "/logout"
@inject IAuthService AuthService
@inject NavigationManager NavigationManager

@code {

    protected override async Task OnInitializedAsync()
    {
        await AuthService.Logout();
        NavigationManager.NavigateTo("/");
    }

}

</code></pre>
<!--kg-card-end: markdown--><p>The component doesn't have any UI, when the user navigates to it the <code>Logout</code> method on the <code>AuthService</code> is called and then the user is redirected back to the home page. </p><h3 id="adding-a-logindisplay-and-updating-the-mainlayout">Adding a LoginDisplay and updating the MainLayout</h3><p>The final task is to add a <code>LoginDisplay</code> component and then update the <code>MainLayout</code> component to use it. </p><p>The <code>LoginDisplay</code> component is the same one used in the server-side Blazor template. If unauthenticated, it shows the R<em>egister</em> and <em>Log in</em> links - if unauthenticated, it shows the users email and the <em>Log out</em> link. </p><!--kg-card-begin: markdown--><pre><code><span>&lt;<span>AuthorizeView</span>&gt;</span>
    <span>&lt;<span>Authorized</span>&gt;</span>
        Hello, @context.User.Identity.Name!
        <span>&lt;<span>a</span> <span>href</span>=<span>"LogOut"</span>&gt;</span>Log out<span>&lt;/<span>a</span>&gt;</span>
    <span>&lt;/<span>Authorized</span>&gt;</span>
    <span>&lt;<span>NotAuthorized</span>&gt;</span>
        <span>&lt;<span>a</span> <span>href</span>=<span>"Register"</span>&gt;</span>Register<span>&lt;/<span>a</span>&gt;</span>
        <span>&lt;<span>a</span> <span>href</span>=<span>"Login"</span>&gt;</span>Log in<span>&lt;/<span>a</span>&gt;</span>
    <span>&lt;/<span>NotAuthorized</span>&gt;</span>
<span>&lt;/<span>AuthorizeView</span>&gt;</span>
</code></pre>
<!--kg-card-end: markdown--><p>We just need to update the <code>MainLayout</code> component now.</p><!--kg-card-begin: markdown--><pre><code>@inherits LayoutComponentBase

<span>&lt;<span>div</span> <span>class</span>=<span>"sidebar"</span>&gt;</span>
    <span>&lt;<span>NavMenu</span> /&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>

<span>&lt;<span>div</span> <span>class</span>=<span>"main"</span>&gt;</span>
    <span>&lt;<span>div</span> <span>class</span>=<span>"top-row px-4"</span>&gt;</span>
        <span>&lt;<span>LoginDisplay</span> /&gt;</span>
        <span>&lt;<span>a</span> <span>href</span>=<span>"http://blazor.net"</span> <span>target</span>=<span>"_blank"</span> <span>class</span>=<span>"ml-md-auto"</span>&gt;</span>About<span>&lt;/<span>a</span>&gt;</span>
    <span>&lt;/<span>div</span>&gt;</span>

    <span>&lt;<span>div</span> <span>class</span>=<span>"content px-4"</span>&gt;</span>
        @Body
    <span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre>
<!--kg-card-end: markdown--><h3 id="registering-services">Registering Services</h3><p>The last thing that's needed is to register the various services we've been building in the <code>Startup</code> class.</p><!--kg-card-begin: markdown--><pre><code><span><span>public</span> <span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection services</span>)</span>
{
    services.AddBlazoredLocalStorage();
    services.AddAuthorizationCore();
    services.AddScoped&lt;AuthenticationStateProvider, ApiAuthenticationStateProvider&gt;();
    services.AddScoped&lt;IAuthService, AuthService&gt;();
}
</code></pre>
<!--kg-card-end: markdown--><p>If everything has gone to plan then you should have something that looks like this.</p><figure><img src="https://chrissainty.com/content/images/2019/07/AuthenticationWithClientSideBlazor.gif"></figure><h2 id="summary">Summary</h2><p>In this post I showed how to create a new Blazor client-side application with authentication using WebAPI and ASP.NET Core Identity. </p><p>I showed how to configure the API to process and issue JSON web tokens. As well as how to setup the various controller actions to service the client application.I then showed how to configure Blazor to use the API and the tokens it issued to set the apps authentication state.</p><p>As I mentioned at the start of this post, all the code is available on <a href="https://github.com/chrissainty/AuthenticationWithClientSideBlazor">GitHub</a>.</p>
                        <hr>
                        
                        <hr>
                        
                    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>