<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How to build a plugin system on the web and also sleep well at night -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>How to build a plugin system on the web and also sleep well at night</h1><div><div class="css-1aecauc"><h3 id="problem-2-copying-the-scene-is-expensive" class="css-15l5y06">Problem #2: copying the scene is expensive</h3><p>The second problem with the <code class="css-16uouur">&lt;iframe&gt;</code> approach is that it requires serializing large parts of the document before sending them to the plugin.</p><p>It turns out that people can create very, very large documents in Figma to the point of hitting memory limits. For example, on Microsoft’s design systems file (which we spent a month optimizing last year), it took 14 seconds just to serialize the document and send it to the plugin, <em>before the plugin could even run</em>. Given that most plugins are going to involve quick actions like “swap two items in my selection”, this would make plugins unusable.</p><p><em>Loading the data incrementally or lazily also isn’t really an option, because: </em></p><ol start="1" class="css-oqx1ti"><li>It would involve months of re-architecting the core product.</li><li>Any API that may need to wait on a piece of data that hasn’t arrived yet will now be asynchronous.</li></ol><p>In summary, because Figma documents can have really large amount of data with a lot of interdependencies, the <code class="css-16uouur">&lt;iframe&gt;</code> wasn’t going to work for us.</p><p>With the <code class="css-16uouur">&lt;iframe&gt;</code> approach having been ruled out, we had to backtrack in our research.</p><p>We went back to the drawing board and spent two long weeks discussing a variety of approaches. As the simple solution didn’t work out, we had to give serious consideration to more exotic ideas. There were many — too many to fill the margins of this blog post. </p><p><em>But most approaches had one or more major disqualifying flaws:</em></p><ul class="css-oqx1ti"><li>Have an API that would be too difficult to use (e.g. accessing the document using a REST API or GraphQL like method)</li><li>Depends on browser features that browser vendors have removed or are trying to (e.g. synchronous xhr + service worker, shared buffers)</li><li>Requires significant research work or re-architecting of our application that could take months before we can even validate that it can work (e.g. load a copy of Figma in an iframe + sync via CRDTs, hack green threads into JavaScript with generators by cross-compiling)</li></ul><p>At the end of the day, we concluded that we had to find a way to create a model where plugins can directly manipulate the document. Writing a plugin should feel like a designer automating their actions. So we knew we’d have to allow plugins to run on the main thread.</p><h3 id="implications-of-running-on-the-main-thread" class="css-15l5y06">Implications of running on the main thread</h3><p>Before we dive into Attempt #2, we need to take a step back and re-examine what it means to allow plugins to run on the main thread. After all, we didn’t consider it at first because we knew that it could be dangerous. Running on the main thread sounds an awful lot like <code class="css-16uouur">eval(UNSAFE_CODE)</code>.</p><p><em>The benefits of running on the main thread are that plugins can:</em></p><ol start="1" class="css-oqx1ti"><li>Directly edit the document rather than a copy of it, eliminating loading time issues.</li><li>Run our complex component updating and constraints logic without needing to have two copies of that code.</li><li>Make synchronous API calls in situations where you’d expect a synchronous API. There would be no confusion with loading or flushing updates.</li><li>Be written in a more intuitive way: plugins are just automating actions that the user would otherwise do manually using our UI.</li></ol><p><em>However, now we have these problems:</em></p><ol start="1" class="css-oqx1ti"><li>Plugins can hang, and there is no way to interrupt a plugin.</li><li>Plugins can make network requests as figma.com.</li><li>Plugins can access and modify global state. This includes modifying our UI, creating dependencies on internal application state outside the API, or doing downright malicious things like changing the value of <code class="css-16uouur">({}).__proto__</code>  which poisons every new and existing JavaScript object.</li></ol><p>We decided that we could drop the requirement for (1). When plugins freeze, it affects the perceived stability of Figma. However, our plugin model works such that they are only ever run on explicit user action. By changing the UI when a plugin runs, freezes would always be attributed to the plugin. It also means that it is not possible for a plugin to “break” a document.</p><h3 id="what-does-it-mean-for-eval-to-be-dangerous" class="css-15l5y06">What does it mean for <code class="css-16uouur">eval</code> to be dangerous?</h3><p>To deal with the issue of plugins being able to make network requests and access global state, we must first understand exactly what it means that “eval arbitrary JavaScript code is dangerous”.</p><p>If a variant of JavaScript, let’s call it SimpleScript, had only the ability to do arithmetic such  <code class="css-16uouur">7 * 24 * 60 * 60</code>, it would be quite safe to <code class="css-16uouur">eval</code>.</p><p>You can add some features to SimpleScript like variable assignment and if statements to make it more like a programming language, and it would still be very safe. At the end of the day, it still essentially boils down to doing arithmetic. Add function evaluation, and now you have lambda calculus and Turing completeness.</p><p>In other words, JavaScript doesn’t <em>have</em> to be dangerous. In its most reductionist form, it’s merely an extended way of doing arithmetics. What <em>is</em> dangerous is when it has access to input &amp; output. This includes network access, DOM access, etc. It’s <strong>Browser APIs</strong> that are dangerous.</p><p>And APIs are all global variables. So hide the global variables!</p><h3 id="hiding-the-global-variables" class="css-15l5y06">Hiding the global variables</h3><p>Now, hiding the global variables sounds good in theory, but it’s difficult to create secure implementations by merely “hiding” them. You might consider, for example, removing all properties on the <code class="css-16uouur">window</code> object, or setting them to <code class="css-16uouur">null</code>, but the code could still get access to global values such as <code class="css-16uouur">({}).constructor</code>. It would be very challenging to find all the possible ways in which some global value might leak.</p><p>Rather, we need some stronger form of sandboxing where those global values never existed in the first place.</p><div class="css-1gmtsx3"><blockquote class="css-1m2040m"><p>In other words, JavaScript doesn’t have to be dangerous. </p></blockquote></div><p>Consider the previous example of a hypothetical SimpleScript that only supports arithmetic. It’s a straightforward CS 101 exercise to write an arithmetic evaluation program. In any reasonable implementation of this program, SimpleScript would simply be unable to do anything other than arithmetic.</p><p>Now, expand SimpleScript to support more language features until it becomes JavaScript, and this program is called an <strong>interpreter</strong>, which is how JavaScript, a dynamic interpreted language, is run.</p><p>Implementing JavaScript is too much work for a small startup like ours. Instead, to validate this approach, we took <a href="https://github.com/svaarala/duktape">Duktape</a>, a lightweight JavaScript interpreter written in C++ and compiled it to WebAssembly.</p><p>To confirm that it works, we ran <a href="https://github.com/tc39/test262/tree/es5-tests">test262</a> on it, the standard JavaScript test suite. It passes all ES5 tests except for a few unimportant test failures. To run plugin code with Duktape, we would call the <code class="css-16uouur">eval</code> function of <em>the compiled interpreter</em>.</p><p><em>What are the properties of this approach?</em></p><ul class="css-oqx1ti"><li>This interpreter runs in the main thread, which means we can create a main-thread based API.</li><li>It’s secure in a way that’s easy to reason about. Duktape does not support any browser APIs — and that’s a feature! Furthermore, it runs as WebAssembly which itself is a sandboxed environment that has no access to browser APIs. In other words, plugin code can communicate with the outside world only through explicit whitelisted APIs by default.</li><li>It’s slower than regular JavaScript since this interpreter is not a JIT, but that’s ok.</li><li>It requires the browser to compile a medium-size WASM binary, which has some cost.</li><li>Browser debugging tools don’t work by default, but we spent a day implementing a console for the interpreter to validate that it’d be at least possible to debug plugins.</li><li>Duktape only supports ES5, but it’s already common practice in the web community to cross-compile newer JavaScript versions using tools such as <a href="https://babeljs.io/">Babel</a>.</li></ul><p>(Aside: a few months later, Fabrice Bellard released <a href="https://bellard.org/quickjs/">QuickJS</a> which supports ES6 natively.)</p><p>Now, compiling a JavaScript interpreter! Depending on your inclinations or aesthetics as a programmer, you might either think:</p><p>THIS IS AWESOME! 🤩 </p><p>or</p><p>…really? A JavaScript engine in a browser that <em>already has a JavaScript engine?</em> 🤨. What next, an operating system in a browser?</p><p>And some amount of suspicion is healthy! It is best to avoid re-implementing the browser unless we absolutely have to. We already spent a lot of effort <a href="/blog/building-a-professional-design-tool-on-the-web/">implementing an entire rendering system</a>. It was necessary for performance and cross-browser support and are glad we did it, but we still try to not re-invent the wheel.</p><p><strong>This is not the approach we ended up going with.</strong> There’s an even better approach. However, it was important to cover as a step towards understanding our final sandboxing model which is more complicated.</p><p>While we had a promising approach compiling a JS interpreter, there was one more tool to look at. We found a technology called the <a href="https://github.com/tc39/proposal-realms">Realms shim</a> created by the folks at <a href="https://agoric.com">Agoric</a>.</p><p>This technology describes creating a sandbox and supporting plugins as a potential use case. A promising description! The Realms API looks roughly like this:</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>