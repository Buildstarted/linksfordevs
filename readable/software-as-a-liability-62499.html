<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Software as a Liability - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Software as a Liability - linksfor.dev(s)"/>
    <meta property="og:description" content="On many teams I&#x2019;ve advised or been a part of, code is generally viewed as an asset. Only some code, the &#x201C;bad code&#x201D;, is considered technical debt. The highest-performing teams, however, viewed thing&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://somehowmanage.com/2020/06/07/software-as-a-liability/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Software as a Liability</title>
<div class="readable">
        <h1>Software as a Liability</h1>
            <div>Reading time: 9-11 minutes</div>
        <div>Posted here: 07 Jun 2020</div>
        <p><a href="https://somehowmanage.com/2020/06/07/software-as-a-liability/">https://somehowmanage.com/2020/06/07/software-as-a-liability/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="content">

	<section id="primary">
		<main id="main">

			
<article id="post-33">

	

	
	<div>
		
<p>On many teams I’ve advised or been a part of, code is generally viewed as an asset. Only some code, the “bad code”, is considered technical debt. The highest-performing teams, however, viewed things differently. For them,&nbsp;<em>all&nbsp;</em>code is technical debt on some level.</p>



<h5 id="bd54">Programming vs. Software Engineering</h5>



<p>Software requires two broad classes of effort. There is the immediate effort to write the software, and then future effort to maintain it. (Titus Winters of Google would call the former simply “programming”, and the sum total of both as “software engineering”).</p>



<blockquote><p>Software engineering is programming integrated over time. Engineering is what happens when things need to live for longer and the influence of time starts creeping in.</p><cite>—&nbsp;<a rel="noreferrer noopener" href="https://www.youtube.com/watch?v=tISy7EJQPzI&amp;t=8m17s" target="_blank">Titus Winters</a></cite></blockquote>



<p>It turns out that both the initial effort (programming) and the eventual effort (software engineering) are hard to estimate. If you’ve been in the software world long enough, the notion of a project’s initial implementation being delivered on time is so rare, it’s almost a joke. And of course, as you get to the “future effort” part, things become even harder to estimate and predict.</p>



<h5 id="76d8">A Taxonomy of Technical Debt</h5>



<p>Once you’ve built something, you (or someone else) become probably responsible for maintaining it. This cost is usually referred to as “<a href="https://martinfowler.com/bliki/TechnicalDebt.html" target="_blank" rel="noreferrer noopener">technical debt</a>”. We can break the cost of this future work into two broad classes:</p>



<ul><li><strong>Interrupts:&nbsp;</strong>Interrupts are when existing systems are taxing your time through reactive work like fixing bugs, fire-fighting, etc. Writing code now that creates interrupts in the future means you (or someone else) will be able to spend less time on making progress on other work later. Both the quantity and severity of interrupts matter. Interrupts are particularly hazardous to engineering teams because they are hard to plan for and usually result in forced context switching.</li><li><strong>Inertia:&nbsp;</strong>Inertia means that a system is hard to make new changes to (because it is hard to understand or reason about, because it’s brittle, not modular and hence hard to change, and so on). This makes forward work difficult for you (ie even when you can spend time doing forward work, it’s really slow) or for others (e.g. because the system is hard to understand, it is a tax on the time of people who need to learn more about it, as well as on people who need to explain to others how it works).</li></ul>



<p>It’s worth noting that if you had two systems that were identical in quality, you’d find that the costs of interrupts increased with system usage—how many people use your product, how often they use it, and how diverse their usage patterns are. In fact,&nbsp;<a href="https://www.hyrumslaw.com/" target="_blank" rel="noreferrer noopener">Hyrum’s law</a>&nbsp;tells us that the more people use your product, the more diverse their usages will be. But with the pressure of increased and different usage, your system finds new and different ways to fail, and the cost of failure (since your system is highly-used and depended upon) increases, too.</p>



<p>On the other hand, the cost of&nbsp;<em>inertia</em>&nbsp;increases with the quantity/scope of future changes you need to make to your product. And, of course, for poorly-designed systems, inertia and interrupts create vicious feedback loops. High inertia means you create bugs as you change your code, resulting in interrupts. And when interrupts happen and you need to fix them, it will be really costly because your system has inertia.</p>



<p>The point here is that&nbsp;<em>all&nbsp;</em>software is costly. Poorly written software is obviously more costly, but all software requires effort both now and in the future. Hence, it all creates technical debt—you will be paying interest on it, and occasionally you (or someone else) may need to pay down the principal with some refactoring or re-architecture. In other words, you are creating a liability.</p>



<p>A lot of people think of liability from a financial (debt) or legal perspective, but literally, a liability is simply “the state of being responsible for something”. And when you write software, you or someone else will be responsible for it.</p>



<h5 id="d762">Why Write Code?</h5>



<p>But if all code is technical debt, why write any software at all? Well, the&nbsp;<em>functionality&nbsp;</em>that software enables is an asset. At some level, any valuable piece of software is solving&nbsp;<a href="https://lanraccoon.com/2020/youre-not-writing-code-youre-solving-problems/" target="_blank" rel="noreferrer noopener">some problem</a>. And that’s the important distinction here. Software is the means, not the end.</p>



<p>Another way to frame this comes from “Uncle Bob” Martin (author of the seminal book Clean Code—though this framing is covered in another of his books, Clean Architecture). He views software as having two dimensions: behavior and structure.</p>



<blockquote><p>Every software system provides two different values to the stakeholders: behavior and structure. Software developers are responsible for ensuring that both those values remain high.</p><cite>— Bob Martin</cite></blockquote>



<p>Uncle Bob goes on to argue that structure (the ability to modify a piece of software) is more important than behavior (its current functionality). His argument is compelling: a perfectly functional but inflexible system will be impossible to change when change is required, but a poorly functioning system that is extremely flexible can easily be fixed.</p>



<p>I think that statement is mostly true. I use the word “mostly” because you could argue that there are some systems where existing functionality matters more than future flexibility. There are some critical contexts in which being absolutely certain that software is operating correctly outweighs any increased costs in flexibility (e.g. a car, an airplane, medical equipment). And there are some contexts in which not having some functionality really quickly will mean that it doesn’t matter how flexible that software is in the future, because it will have no future (e.g. an early-stage startup). But I don’t want to go too deep on this topic, since it’s tangential to the point I’d like to get to (and we’re getting there, I promise!).</p>



<h5 id="6f7b">Future Scope and Likelihood</h5>



<p>So, putting this all together,&nbsp;<strong>software makes sense to build if and only if the value it creates now (through its functionality), and the value it enables in the future (through its ability to change its functionality), outweigh the costs it takes to build it now and maintain it in the future.&nbsp;</strong>But that “future” part is hard to predict.</p>



<p>I’ve always been amazed at how financial analysts can put together a spreadsheet to value an asset or investment. They’ll confidently forecast out a series of cash-flows, often in perpetuity. When they can’t forecast perpetuity with a straight face, they’ll slap a&nbsp;<a href="https://en.wikipedia.org/wiki/Terminal_value_(finance)" target="_blank" rel="noreferrer noopener">terminal value</a>&nbsp;on it instead.</p>



<p>In software, it’s not that easy to predict (or pretend to predict) the future. So it’s easy to just, like Bob Martin, say that flexible software is better than inflexible software. But that’s a truism and it doesn’t really solve the problem of how, exactly, to think about building your software.</p>



<p>Software purists will make the case that “good software is good software”. Practice good&nbsp;<a href="https://springframework.guru/gang-of-four-design-patterns/" target="_blank" rel="noreferrer noopener">design patterns</a>, use the&nbsp;<a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noreferrer noopener">SOLID principles</a>, remove (or encapsulate) complexity, etc. And you should. There are things that are almost universally good or bad architectural decisions in software, and we’ve got some great literature to help guide us.</p>



<p>But remember, writing good software is the means, not the end. Your goal is to build software in a way where current and future functionality outweigh current and future costs. And to get that right,&nbsp;<strong>we</strong>&nbsp;<strong>have to understand the scope and likelihood of future changes</strong>. Without that, we’re flying blind.</p>



<h5 id="120d">Domains, Users, and Problems</h5>



<p>I’m a big fan of&nbsp;<a href="https://dddcommunity.org/learning-ddd/" target="_blank" rel="noreferrer noopener">Domain-Driven Design</a>&nbsp;because it shifts focus off of the code into the domain you’re trying to model.</p>



<blockquote><p>The most significant complexity of many applications is not technical. It is in the domain itself, the activity or business of the user. When this domain complexity is not dealt with in the design, it won’t matter that the infrastructural technology is well-conceived.</p><cite>— Domain Driven Design</cite></blockquote>



<p>The promise is simple: model the underlying domain correctly, and not only should the code and architecture fall into place now—they should be able to adapt and evolve as your requirements change.</p>



<p>Deeply understanding the domain you’re working with is a great start, but focusing too much on domain modeling can be misguided. Your users don’t care about how the domain is modeled—they care about whether your software solves their problems. So you actually need to understand three things:</p>



<ol><li>The domain.</li><li>Your users.</li><li>Your users’ problems.</li></ol>



<p>How to actually do that probably requires a separate article(s), but it basically comes down to spending time thinking about, discussing, and analyzing those three aspects.</p>



<h5 id="e49b">Don’t Gatekeep</h5>



<p>As a final thought, there’s a risk of taking “software as a liability” to an extreme.</p>



<p>You’ve probably worked with one of these developers before: the type that gatekeeps software. Asked to implement something by a Product Manager or a colleague, their go-to response is “no, that’s too complicated”. Then they walk off feeling good that they have just prevented adding a bunch of complexity into the code base, and the future stream of liabilities that would create.</p>



<p>Any principle can be abused with the wrong attitude. So yes, all software is a liability, and it all has costs, but by truly understanding the domain you’re building in, the users you’re building for, and the problems you’re solving, you can help manage the trade-off between the cost of software and the benefits it provides.</p>




	</div><!-- .entry-content -->

	<!-- .entry-footer -->

				
</article><!-- #post-${ID} -->

<!-- #comments -->

		</main><!-- #main -->
	</section><!-- #primary -->


	</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>