<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Getting Started with gRPC Client Factory -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Getting Started with gRPC Client Factory</h1><div><div id="pryc-wp-acctp-original-content"><p>Regular visitors of my blog will know that I’ve written a lot of posts about the HttpClientFactory feature, available in the Microsoft.Extensions.Http package which simplifies the consumption and proper lifetime usage of HttpClient instances.</p><p>Recently, I’ve begun digging into gRPC and I’m pleased to see a similar pattern is available for gRPC-based communication.</p><p>In this post, I want to show a quick example of how to get started with the gRPC Client Factory. I’m going to focus on adding this to an ASP.NET Core 3.0 web project, which will act as a client of an external gRPC service. This post assumes a little knowledge about gRPC. You can read my <a href="https://www.stevejgordon.co.uk/early-look-at-grpc-using-aspnet-core-3">earlier blog post</a> (slightly outdated now) which covers some extra ground.</p><p>The first step is to install the <a href="https://www.nuget.org/packages/Grpc.Net.ClientFactory" target="_blank" rel="noopener noreferrer">Grpc.Net.ClientFactory NuGet package</a> into your project, along with the other libraries required to establish a gRPC client.</p><p>Note that these features are still in preview so I’m using the currently available pre-release versions from NuGet.</p><p>I also need to reference a proto file which contains the service contract for the service I will be consuming.</p><p>I’ll add a Protobuf file and tell the tooling to generate the client stubs for it.</p><h2>Registering a gRPC Client</h2><p>Registering a gRPC client is very similar to registering a HttpClient.</p><p>In ConfigureServices, on the IServiceCollection, we can call AddGrpcClient which access a generic argument to the client stub generated by the gRPC tooling.</p><p>Here I pass in the code-generated WeatherForecastsClient which exists thanks to the build tooling that generated it for me from the proto file.</p><p>I can pass the base address which is the HTTPS URL to the gRPC server which is hosting the service.</p><p>Finally, I can now inject instances of the client wherever I need them via constructor injection. As with HttpClientFactory, the clients are registered as transient services, with the underlying connection (channels) being managed for us.</p><h2>Summary</h2><p>That’s it for the basic use of the gRPC client factory. It’s all pretty simple to get started with. There are some other things we can do when registering the client which I’ll focus on in some future blog posts.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>