<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">🎉</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>I/O pipelines - .NET</h1>
        <p>
by Rick-Anderson <br/>Reading time: 29-37 minutes        </p>
        <p><a href="https://docs.microsoft.com/en-us/dotnet/standard/io/pipelines">https://docs.microsoft.com/en-us/dotnet/standard/io/pipelines</a></p>
        <hr/>
<div id="readability-page-1" class="page">


	<div data-bi-name="body">

		<div>

			

			<section>
				<div>


				<div id="main-column">

					<main id="main" role="main" data-bi-name="content" lang="en-us" dir="ltr">



						

						<ul data-bi-name="page info" lang="en-us" dir="ltr">
							<li>
								<time role="presentation" datetime="2019-10-01T00:00:00.000Z" data-article-date-source="ms.date">10/01/2019</time>
							</li>
								<li>19 minutes to read</li>
							<li>
								<a href="https://github.com/dotnet/docs/blob/master/docs/standard/io/pipelines.md" title="4 Contributors" aria-label="4 Contributors">
									
								</a>
							</li>

						</ul>

						<nav id="center-doc-outline" data-bi-name="intopic toc" role="navigation" aria-label="Article Outline">
							<h3>In this article</h3>
						<ol><li><a href="#what-problem-does-systemiopipelines-solve">What problem does System.IO.Pipelines solve</a></li><li><a href="#pipe">Pipe</a></li><li><a href="#pipereader">PipeReader</a></li><li><a href="#pipewriter">PipeWriter</a></li><li><a href="#iduplexpipe">IDuplexPipe</a></li><li><a href="#streams">Streams</a></li></ol></nav>


						<!-- <content> -->
							
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines" data-linktype="absolute-path">System.IO.Pipelines</a> is a new library that is designed to make it easier to do high-performance I/O in .NET. It’s a library targeting .NET Standard that works on all .NET implementations.</p>

<h2 id="what-problem-does-systemiopipelines-solve">What problem does System.IO.Pipelines solve<a href="#what-problem-does-systemiopipelines-solve" aria-labelledby="what-problem-does-systemiopipelines-solve"></a></h2>
<!-- corner case doesn't MT (machine translate)   -->
<p>Apps that parse streaming data are composed of boilerplate code having many specialized and unusual code flows. The boilerplate and special case code is complex and difficult to maintain.</p>
<p><code>System.IO.Pipelines</code> was architected to:</p>
<ul>
<li>Have high performance parsing streaming data.</li>
<li>Reduce code complexity.</li>
</ul>
<p>The following code is typical for a TCP server that receives line-delimited messages (delimited by <code>'\n'</code>) from a client:</p>
<pre tabindex="0"><code data-author-content="async Task ProcessLinesAsync(NetworkStream stream)
{
    var buffer = new byte[1024];
    await stream.ReadAsync(buffer, 0, buffer.Length);

    // Process a single line from the buffer
    ProcessLine(buffer);
}
"><span><span><span>async</span> Task <span>ProcessLinesAsync</span>(<span>NetworkStream stream</span>)</span>
{
    <span>var</span> buffer = <span>new</span> <span>byte</span>[<span>1024</span>];
    <span>await</span> stream.ReadAsync(buffer, <span>0</span>, buffer.Length);

    <span>// Process a single line from the buffer</span>
    ProcessLine(buffer);
}
</span></code></pre>
<p>The preceding code has several problems:</p>
<ul>
<li>The entire message (end of line) might not be received in a single call to <code>ReadAsync</code>.</li>
<li>It's ignoring the result of <code>stream.ReadAsync</code>. <code>stream.ReadAsync</code> returns how much data was read.</li>
<li>It doesn't handle the case where multiple lines are read in a single <code>ReadAsync</code> call.</li>
<li>It allocates a <code>byte</code> array with each read.</li>
</ul>
<p>To fix the preceding problems, the following changes are required:</p>
<ul>
<li><p>Buffer the incoming data until a new line is found.</p>
</li>
<li><p>Parse all the lines returned in the buffer.</p>
</li>
<li><p>It's possible that the line is bigger than 1 KB (1024 bytes). The code needs to resize the input buffer until the delimiter is found in order to fit the complete line inside the buffer.</p>
<ul>
<li>If the buffer is resized, more buffer copies are made as longer lines appear in the input.</li>
<li>To reduce wasted space, compact the buffer used for reading lines.</li>
</ul>
</li>
<li><p>Consider using buffer pooling to avoid allocating memory repeatedly.</p>
</li>
<li><p>The following code addresses some of these problems:</p>
</li>
</ul>
<pre tabindex="0"><code data-author-content="async Task ProcessLinesAsync(NetworkStream stream)
{
    byte[] buffer = ArrayPool<byte>.Shared.Rent(1024);
    var bytesBuffered = 0;
    var bytesConsumed = 0;

    while (true)
    {
        // Calculate the amount of bytes remaining in the buffer.
        var bytesRemaining = buffer.Length - bytesBuffered;

        if (bytesRemaining == 0)
        {
            // Double the buffer size and copy the previously buffered data into the new buffer.
            var newBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length * 2);
            Buffer.BlockCopy(buffer, 0, newBuffer, 0, buffer.Length);
            // Return the old buffer to the pool.
            ArrayPool<byte>.Shared.Return(buffer);
            buffer = newBuffer;
            bytesRemaining = buffer.Length - bytesBuffered;
        }

        var bytesRead = await stream.ReadAsync(buffer, bytesBuffered, bytesRemaining);
        if (bytesRead == 0)
        {
            // EOF
            break;
        }

        // Keep track of the amount of buffered bytes.
        bytesBuffered += bytesRead;
        var linePosition = -1;

        do
        {
            // Look for a EOL in the buffered data.
            linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed,
                                         bytesBuffered - bytesConsumed);

            if (linePosition >= 0)
            {
                // Calculate the length of the line based on the offset.
                var lineLength = linePosition - bytesConsumed;

                // Process the line.
                ProcessLine(buffer, bytesConsumed, lineLength);

                // Move the bytesConsumed to skip past the line consumed (including \n).
                bytesConsumed += lineLength + 1;
            }
        }
        while (linePosition >= 0);
    }
}
"><span><span><span>async</span> Task <span>ProcessLinesAsync</span>(<span>NetworkStream stream</span>)</span>
{
    <span>byte</span>[] buffer = ArrayPool&lt;<span>byte</span>&gt;.Shared.Rent(<span>1024</span>);
    <span>var</span> bytesBuffered = <span>0</span>;
    <span>var</span> bytesConsumed = <span>0</span>;

    <span>while</span> (<span>true</span>)
    {
        <span>// Calculate the amount of bytes remaining in the buffer.</span>
        <span>var</span> bytesRemaining = buffer.Length - bytesBuffered;

        <span>if</span> (bytesRemaining == <span>0</span>)
        {
            <span>// Double the buffer size and copy the previously buffered data into the new buffer.</span>
            <span>var</span> newBuffer = ArrayPool&lt;<span>byte</span>&gt;.Shared.Rent(buffer.Length * <span>2</span>);
            Buffer.BlockCopy(buffer, <span>0</span>, newBuffer, <span>0</span>, buffer.Length);
            <span>// Return the old buffer to the pool.</span>
            ArrayPool&lt;<span>byte</span>&gt;.Shared.Return(buffer);
            buffer = newBuffer;
            bytesRemaining = buffer.Length - bytesBuffered;
        }

        <span>var</span> bytesRead = <span>await</span> stream.ReadAsync(buffer, bytesBuffered, bytesRemaining);
        <span>if</span> (bytesRead == <span>0</span>)
        {
            <span>// EOF</span>
            <span>break</span>;
        }

        <span>// Keep track of the amount of buffered bytes.</span>
        bytesBuffered += bytesRead;
        <span>var</span> linePosition = <span>-1</span>;

        <span>do</span>
        {
            <span>// Look for a EOL in the buffered data.</span>
            linePosition = Array.IndexOf(buffer, (<span>byte</span>)<span>'\n'</span>, bytesConsumed,
                                         bytesBuffered - bytesConsumed);

            <span>if</span> (linePosition &gt;= <span>0</span>)
            {
                <span>// Calculate the length of the line based on the offset.</span>
                <span>var</span> lineLength = linePosition - bytesConsumed;

                <span>// Process the line.</span>
                ProcessLine(buffer, bytesConsumed, lineLength);

                <span>// Move the bytesConsumed to skip past the line consumed (including \n).</span>
                bytesConsumed += lineLength + <span>1</span>;
            }
        }
        <span>while</span> (linePosition &gt;= <span>0</span>);
    }
}
</span></code></pre>
<p>The previous code is complex and doesn't address all the problems identified. High-performance networking usually means writing very complex code to maximize performance. <code>System.IO.Pipelines</code> was designed to make writing this type of code easier.</p>
<h2 id="pipe">Pipe<a href="#pipe" aria-labelledby="pipe"></a></h2>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipe" data-linktype="absolute-path">Pipe</a> class can be used to create a <code>PipeWriter/PipeReader</code> pair. All data written into the <code>PipeWriter</code> is available in the <code>PipeReader</code>:</p>
<pre tabindex="0"><code data-author-content="var pipe = new Pipe();
PipeReader reader = pipe.Reader;
PipeWriter writer = pipe.Writer;
"><span><span>var</span> pipe = <span>new</span> Pipe();
PipeReader reader = pipe.Reader;
PipeWriter writer = pipe.Writer;
</span></code></pre>

<h3 id="pipe-basic-usage">Pipe basic usage<a href="#pipe-basic-usage" aria-labelledby="pipe-basic-usage"></a></h3>
<pre tabindex="0"><code data-author-content="async Task ProcessLinesAsync(Socket socket)
{
    var pipe = new Pipe();
    Task writing = FillPipeAsync(socket, pipe.Writer);
    Task reading = ReadPipeAsync(pipe.Reader);

    await Task.WhenAll(reading, writing);
}

async Task FillPipeAsync(Socket socket, PipeWriter writer)
{
    const int minimumBufferSize = 512;

    while (true)
    {
        // Allocate at least 512 bytes from the PipeWriter.
        Memory<byte> memory = writer.GetMemory(minimumBufferSize);
        try
        {
            int bytesRead = await socket.ReceiveAsync(memory, SocketFlags.None);
            if (bytesRead == 0)
            {
                break;
            }
            // Tell the PipeWriter how much was read from the Socket.
            writer.Advance(bytesRead);
        }
        catch (Exception ex)
        {
            LogError(ex);
            break;
        }

        // Make the data available to the PipeReader.
        FlushResult result = await writer.FlushAsync();

        if (result.IsCompleted)
        {
            break;
        }
    }

     // By completing PipeWriter, tell the PipeReader that there's no more data coming.
    await writer.CompleteAsync();
}

async Task ReadPipeAsync(PipeReader reader)
{
    while (true)
    {
        ReadResult result = await reader.ReadAsync();
        ReadOnlySequence<byte> buffer = result.Buffer;

        while (TryReadLine(ref buffer, out ReadOnlySequence<byte> line))
        {
            // Process the line.
            ProcessLine(line);
        }

        // Tell the PipeReader how much of the buffer has been consumed.
        reader.AdvanceTo(buffer.Start, buffer.End);

        // Stop reading if there's no more data coming.
        if (result.IsCompleted)
        {
            break;
        }
    }

    // Mark the PipeReader as complete.
    await reader.CompleteAsync();
}

bool TryReadLine(ref ReadOnlySequence<byte> buffer, out ReadOnlySequence<byte> line)
{
    // Look for a EOL in the buffer.
    SequencePosition? position = buffer.PositionOf((byte)'\n');

    if (position == null)
    {
        line = default;
        return false;
    }

    // Skip the line + the \n.
    line = buffer.Slice(0, position.Value);
    buffer = buffer.Slice(buffer.GetPosition(1, position.Value));
    return true;
}
"><span><span><span>async</span> Task <span>ProcessLinesAsync</span>(<span>Socket socket</span>)</span>
{
    <span>var</span> pipe = <span>new</span> Pipe();
    Task writing = FillPipeAsync(socket, pipe.Writer);
    Task reading = ReadPipeAsync(pipe.Reader);

    <span>await</span> Task.WhenAll(reading, writing);
}

<span><span>async</span> Task <span>FillPipeAsync</span>(<span>Socket socket, PipeWriter writer</span>)</span>
{
    <span>const</span> <span>int</span> minimumBufferSize = <span>512</span>;

    <span>while</span> (<span>true</span>)
    {
        <span>// Allocate at least 512 bytes from the PipeWriter.</span>
        Memory&lt;<span>byte</span>&gt; memory = writer.GetMemory(minimumBufferSize);
        <span>try</span>
        {
            <span>int</span> bytesRead = <span>await</span> socket.ReceiveAsync(memory, SocketFlags.None);
            <span>if</span> (bytesRead == <span>0</span>)
            {
                <span>break</span>;
            }
            <span>// Tell the PipeWriter how much was read from the Socket.</span>
            writer.Advance(bytesRead);
        }
        <span>catch</span> (Exception ex)
        {
            LogError(ex);
            <span>break</span>;
        }

        <span>// Make the data available to the PipeReader.</span>
        FlushResult result = <span>await</span> writer.FlushAsync();

        <span>if</span> (result.IsCompleted)
        {
            <span>break</span>;
        }
    }

     <span>// By completing PipeWriter, tell the PipeReader that there's no more data coming.</span>
    <span>await</span> writer.CompleteAsync();
}

<span><span>async</span> Task <span>ReadPipeAsync</span>(<span>PipeReader reader</span>)</span>
{
    <span>while</span> (<span>true</span>)
    {
        ReadResult result = <span>await</span> reader.ReadAsync();
        ReadOnlySequence&lt;<span>byte</span>&gt; buffer = result.Buffer;

        <span>while</span> (TryReadLine(<span>ref</span> buffer, <span>out</span> ReadOnlySequence&lt;<span>byte</span>&gt; line))
        {
            <span>// Process the line.</span>
            ProcessLine(line);
        }

        <span>// Tell the PipeReader how much of the buffer has been consumed.</span>
        reader.AdvanceTo(buffer.Start, buffer.End);

        <span>// Stop reading if there's no more data coming.</span>
        <span>if</span> (result.IsCompleted)
        {
            <span>break</span>;
        }
    }

    <span>// Mark the PipeReader as complete.</span>
    <span>await</span> reader.CompleteAsync();
}

<span><span>bool</span> <span>TryReadLine</span>(<span><span>ref</span> ReadOnlySequence&lt;<span>byte</span>&gt; buffer, <span>out</span> ReadOnlySequence&lt;<span>byte</span>&gt; line</span>)</span>
{
    <span>// Look for a EOL in the buffer.</span>
    SequencePosition? position = buffer.PositionOf((<span>byte</span>)<span>'\n'</span>);

    <span>if</span> (position == <span>null</span>)
    {
        line = <span>default</span>;
        <span>return</span> <span>false</span>;
    }

    <span>// Skip the line + the \n.</span>
    line = buffer.Slice(<span>0</span>, position.Value);
    buffer = buffer.Slice(buffer.GetPosition(<span>1</span>, position.Value));
    <span>return</span> <span>true</span>;
}
</span></code></pre>
<p>There are two loops:</p>
<ul>
<li><code>FillPipeAsync</code> reads from the <code>Socket</code> and writes to the <code>PipeWriter</code>.</li>
<li><code>ReadPipeAsync</code> reads from the <code>PipeReader</code> and parses incoming lines.</li>
</ul>
<p>There are no explicit buffers allocated. All buffer management is delegated to the <code>PipeReader</code> and <code>PipeWriter</code> implementations. Delegating buffer management makes it easier for consuming code to focus solely on the business logic.</p>
<p>In the first loop:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.getmemory#System_IO_Pipelines_PipeWriter_GetMemory_System_Int32_" data-linktype="absolute-path">PipeWriter.GetMemory(Int32)</a> is called to get memory from the underlying writer.</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.advance#System_IO_Pipelines_PipeWriter_Advance_System_Int32_" data-linktype="absolute-path">PipeWriter.Advance(Int32)</a>
is called to tell the <code>PipeWriter</code> how much data was written to the buffer.</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.flushasync" data-linktype="absolute-path">PipeWriter.FlushAsync</a> is called to make the data available to the <code>PipeReader</code>.</li>
</ul>
<p>In the second loop, the <code>PipeReader</code> consumes the buffers written by <code>PipeWriter</code>. The buffers come from the socket. The call to <code>PipeReader.ReadAsync</code>:</p>
<ul>
<li><p>Returns a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.readresult" data-linktype="absolute-path">ReadResult</a> that contains two important pieces of information:</p>
<ul>
<li>The data that was read in the form of <code>ReadOnlySequence&lt;byte&gt;</code>.</li>
<li>A boolean <code>IsCompleted</code> that indicates if the end of data (EOF) has been reached.</li>
</ul>
</li>
</ul>
<p>After finding the end of line (EOL) delimiter and parsing the line:</p>
<ul>
<li>The logic processes the buffer to skip what's already processed.</li>
<li><code>PipeReader.AdvanceTo</code> is called to tell the <code>PipeReader</code> how much data has been consumed and examined.</li>
</ul>
<p>The reader and writer loops end by calling <code>Complete</code>. <code>Complete</code> lets the underlying Pipe release the memory it allocated.</p>
<h3 id="backpressure-and-flow-control">Backpressure and flow control<a href="#backpressure-and-flow-control" aria-labelledby="backpressure-and-flow-control"></a></h3>
<p>Ideally, reading and parsing work together:</p>
<ul>
<li>The writing thread consumes data from the network and puts it in buffers.</li>
<li>The parsing thread is responsible for constructing the appropriate data structures.</li>
</ul>
<p>Typically, parsing takes more time than just copying blocks of data from the network:</p>
<ul>
<li>The reading thread gets ahead of the parsing thread.</li>
<li>The reading thread has to either slow down or allocate more memory to store the data for the parsing thread.</li>
</ul>
<p>For optimal performance, there's a balance between frequent pauses and allocating more memory.</p>
<p>To solve the preceding problem, the <code>Pipe</code> has two settings to control the flow of data:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipeoptions.pausewriterthreshold#System_IO_Pipelines_PipeOptions_PauseWriterThreshold" data-linktype="absolute-path">PauseWriterThreshold</a>: Determines how much data should be buffered before calls to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.flushasync" data-linktype="absolute-path">FlushAsync</a> pause.</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipeoptions.resumewriterthreshold#System_IO_Pipelines_PipeOptions_ResumeWriterThreshold" data-linktype="absolute-path">ResumeWriterThreshold</a>: Determines how much data the reader has to observe before calls to <code>PipeWriter.FlushAsync</code> resume.</li>
</ul>
<p><img src="https://docs.microsoft.com/en-us/dotnet/standard/io/media/pipelines/resume-pause.png" alt="Diagram with ResumeWriterThreshold and PauseWriterThreshold" data-linktype="relative-path"></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.flushasync" data-linktype="absolute-path">PipeWriter.FlushAsync</a>:</p>
<ul>
<li>Returns an incomplete <code>ValueTask&lt;FlushResult&gt;</code> when the amount of data in the <code>Pipe</code> crosses <code>PauseWriterThreshold</code>.</li>
<li>Completes <code>ValueTask&lt;FlushResult&gt;</code> when it becomes lower than <code>ResumeWriterThreshold</code>.</li>
</ul>
<p>Two values are used to prevent rapid cycling, which can occur if one value is used.</p>
<h3 id="examples">Examples<a href="#examples" aria-labelledby="examples"></a></h3>
<pre tabindex="0"><code data-author-content="// The Pipe will start returning incomplete tasks from FlushAsync until
// the reader examines at least 5 bytes.
var options = new PipeOptions(pauseWriterThreshold: 10, resumeWriterThreshold: 5);
var pipe = new Pipe(options);
"><span><span>// The Pipe will start returning incomplete tasks from FlushAsync until</span>
<span>// the reader examines at least 5 bytes.</span>
<span>var</span> options = <span>new</span> PipeOptions(pauseWriterThreshold: <span>10</span>, resumeWriterThreshold: <span>5</span>);
<span>var</span> pipe = <span>new</span> Pipe(options);
</span></code></pre>
<h3 id="pipescheduler">PipeScheduler<a href="#pipescheduler" aria-labelledby="pipescheduler"></a></h3>
<p>Typically when using <code>async</code> and <code>await</code>, asynchronous code resumes on either on a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler" data-linktype="absolute-path">TaskScheduler</a> or on the current  <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext" data-linktype="absolute-path">SynchronizationContext</a>.</p>
<p>When doing I/O, it's important to have fine-grained control over where the I/O is performed. This control allows taking advantage of CPU caches effectively. Efficient caching is critical for high-performance apps like web servers. <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipescheduler" data-linktype="absolute-path">PipeScheduler</a> provides control over where asynchronous callbacks run. By default:</p>
<ul>
<li>The current <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext" data-linktype="absolute-path">SynchronizationContext</a> is used.</li>
<li>If there's no <code>SynchronizationContext</code>, it uses the thread pool to run callbacks.</li>
</ul>
<pre tabindex="0"><code data-author-content="public static void Main(string[] args)
{
    var writeScheduler = new SingleThreadPipeScheduler();
    var readScheduler = new SingleThreadPipeScheduler();

    // Tell the Pipe what schedulers to use and disable the SynchronizationContext.
    var options = new PipeOptions(readerScheduler: readScheduler,
                                  writerScheduler: writeScheduler,
                                  useSynchronizationContext: false);
    var pipe = new Pipe(options);
}

// This is a sample scheduler that async callbacks on a single dedicated thread.
public class SingleThreadPipeScheduler : PipeScheduler
{
    private readonly BlockingCollection<(Action<object> Action, object State)> _queue =
     new BlockingCollection<(Action<object> Action, object State)>();
    private readonly Thread _thread;

    public SingleThreadPipeScheduler()
    {
        _thread = new Thread(DoWork);
        _thread.Start();
    }

    private void DoWork()
    {
        foreach (var item in _queue.GetConsumingEnumerable())
        {
            item.Action(item.State);
        }
    }

    public override void Schedule(Action<object> action, object state)
    {
        _queue.Add((action, state));
    }
}
"><span><span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
{
    <span>var</span> writeScheduler = <span>new</span> SingleThreadPipeScheduler();
    <span>var</span> readScheduler = <span>new</span> SingleThreadPipeScheduler();

    <span>// Tell the Pipe what schedulers to use and disable the SynchronizationContext.</span>
    <span>var</span> options = <span>new</span> PipeOptions(readerScheduler: readScheduler,
                                  writerScheduler: writeScheduler,
                                  useSynchronizationContext: <span>false</span>);
    <span>var</span> pipe = <span>new</span> Pipe(options);
}

<span>// This is a sample scheduler that async callbacks on a single dedicated thread.</span>
<span>public</span> <span>class</span> <span>SingleThreadPipeScheduler</span> : <span>PipeScheduler</span>
{
    <span>private</span> <span>readonly</span> BlockingCollection&lt;(Action&lt;<span>object</span>&gt; Action, <span>object</span> State)&gt; _queue =
     <span>new</span> BlockingCollection&lt;(Action&lt;<span>object</span>&gt; Action, <span>object</span> State)&gt;();
    <span>private</span> <span>readonly</span> Thread _thread;

    <span><span>public</span> <span>SingleThreadPipeScheduler</span>(<span></span>)</span>
    {
        _thread = <span>new</span> Thread(DoWork);
        _thread.Start();
    }

    <span><span>private</span> <span>void</span> <span>DoWork</span>(<span></span>)</span>
    {
        <span>foreach</span> (<span>var</span> item <span>in</span> _queue.GetConsumingEnumerable())
        {
            item.Action(item.State);
        }
    }

    <span><span>public</span> <span>override</span> <span>void</span> <span>Schedule</span>(<span>Action&lt;<span>object</span>&gt; action, <span>object</span> state</span>)</span>
    {
        _queue.Add((action, state));
    }
}
</span></code></pre>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipescheduler.threadpool#System_IO_Pipelines_PipeScheduler_ThreadPool" data-linktype="absolute-path">PipeScheduler.ThreadPool</a> is the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipescheduler" data-linktype="absolute-path">PipeScheduler</a> implementation that queues callbacks to the thread pool. <code>PipeScheduler.ThreadPool</code> is the default and generally the best choice. <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipescheduler.inline#System_IO_Pipelines_PipeScheduler_Inline" data-linktype="absolute-path">PipeScheduler.Inline</a> can cause unintended consequences such as deadlocks.</p>
<h3 id="pipe-reset">Pipe reset<a href="#pipe-reset" aria-labelledby="pipe-reset"></a></h3>
<p>It's frequently efficient to reuse the <code>Pipe</code> object. To reset the pipe, call <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipereader" data-linktype="absolute-path">PipeReader</a> <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipe.reset" data-linktype="absolute-path">Reset</a> when both the <code>PipeReader</code> and <code>PipeWriter</code> are complete.</p>
<h2 id="pipereader">PipeReader<a href="#pipereader" aria-labelledby="pipereader"></a></h2>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipereader" data-linktype="absolute-path">PipeReader</a> manages memory on the caller's behalf. <strong>Always</strong> call <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipereader.advanceto" data-linktype="absolute-path">PipeReader.AdvanceTo</a> after calling <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipereader.readasync" data-linktype="absolute-path">PipeReader.ReadAsync</a>. This lets the <code>PipeReader</code> know when the caller is done with the memory so that it can be tracked. The <code>ReadOnlySequence&lt;byte&gt;</code> returned from <code>PipeReader.ReadAsync</code> is only valid until the call the <code>PipeReader.AdvanceTo</code>. It's illegal to use <code>ReadOnlySequence&lt;byte&gt;</code> after calling <code>PipeReader.AdvanceTo</code>.</p>
<p><code>PipeReader.AdvanceTo</code> takes two <a href="https://docs.microsoft.com/en-us/dotnet/api/system.sequenceposition" data-linktype="absolute-path">SequencePosition</a> arguments:</p>
<ul>
<li>The first argument determines how much memory was consumed.</li>
<li>The second argument determines how much of the buffer was observed.</li>
</ul>
<p>Marking data as consumed means that the pipe can return the memory to the underlying buffer pool. Marking data as observed controls what the next call to <code>PipeReader.ReadAsync</code> does. Marking everything as observed means that the next call to <code>PipeReader.ReadAsync</code> won't return until there's more data written to the pipe. Any other value will make the next call to <code>PipeReader.ReadAsync</code> return immediately with the observed <em>and</em> unobserved data, but data that has already been consumed.</p>
<h3 id="read-streaming-data-scenarios">Read streaming data scenarios<a href="#read-streaming-data-scenarios" aria-labelledby="read-streaming-data-scenarios"></a></h3>
<p>There are a couple of typical patterns that emerge when trying to read streaming data:</p>
<ul>
<li>Given a stream of data, parse a single message.</li>
<li>Given a stream of data, parse all available messages.</li>
</ul>
<p>The following examples use the <code>TryParseMessage</code> method for parsing messages from a <code>ReadOnlySequence&lt;byte&gt;</code>. <code>TryParseMessage</code> parses a single message and update the input buffer to trim the parsed message from the buffer. <code>TryParseMessage</code> is not part of .NET, it's a user written method used in the following sections.</p>
<pre tabindex="0"><code data-author-content="bool TryParseMessage(ref ReadOnlySequence<byte> buffer, out Message message);
"><span><span><span>bool</span> <span>TryParseMessage</span>(<span><span>ref</span> ReadOnlySequence&lt;<span>byte</span>&gt; buffer, <span>out</span> Message message</span>)</span>;
</span></code></pre>
<h3 id="read-a-single-message">Read a single message<a href="#read-a-single-message" aria-labelledby="read-a-single-message"></a></h3>
<p>The following code reads a single message from a <code>PipeReader</code> and returns it to the caller.</p>
<pre tabindex="0"><code name="ReadSingleMsg" data-author-content="async ValueTask<Message> ReadSingleMessageAsync(PipeReader reader,
 CancellationToken cancellationToken = default)
{
    while (true)
    {
        ReadResult result = await reader.ReadAsync(cancellationToken);
        ReadOnlySequence<byte> buffer = result.Buffer;

        // In the event that no message is parsed successfully, mark consumed 
        // as nothing and examined as the entire buffer.
        SequencePosition consumed = buffer.Start;
        SequencePosition examined = buffer.End;

        try
        {
            if (TryParseMessage(ref buffer, out Message message))
            {
                // A single message was successfully parsed so mark the start as the 
                // parsed buffer as consumed. TryParseMessage trims the buffer to 
                // point to the data after the message was parsed.
                consumed = buffer.Start;

                // Examined is marked the same as consumed here, so the next call 
                // to ReadSingleMessageAsync will process the next message if there's 
                // one.
                examined = consumed;

                return message;
            }

            // There's no more data to be processed.
            if (result.IsCompleted)
            {
                if (buffer.Length > 0)
                {
                    // The message is incomplete and there's no more data to process.
                    throw new InvalidDataException(&quot;Incomplete message.&quot;);
                }

                break;
            }
        }
        finally
        {
            reader.AdvanceTo(consumed, examined);
        }
    }

    return null;
}
"><span><span><span>async</span> ValueTask&lt;Message&gt; <span>ReadSingleMessageAsync</span>(<span>PipeReader reader,
 CancellationToken cancellationToken = <span>default</span></span>)</span>
{
    <span>while</span> (<span>true</span>)
    {
        ReadResult result = <span>await</span> reader.ReadAsync(cancellationToken);
        ReadOnlySequence&lt;<span>byte</span>&gt; buffer = result.Buffer;

        <span>// In the event that no message is parsed successfully, mark consumed </span>
        <span>// as nothing and examined as the entire buffer.</span>
        SequencePosition consumed = buffer.Start;
        SequencePosition examined = buffer.End;

        <span>try</span>
        {
            <span>if</span> (TryParseMessage(<span>ref</span> buffer, <span>out</span> Message message))
            {
                <span>// A single message was successfully parsed so mark the start as the </span>
                <span>// parsed buffer as consumed. TryParseMessage trims the buffer to </span>
                <span>// point to the data after the message was parsed.</span>
                consumed = buffer.Start;

                <span>// Examined is marked the same as consumed here, so the next call </span>
                <span>// to ReadSingleMessageAsync will process the next message if there's </span>
                <span>// one.</span>
                examined = consumed;

                <span>return</span> message;
            }

            <span>// There's no more data to be processed.</span>
            <span>if</span> (result.IsCompleted)
            {
                <span>if</span> (buffer.Length &gt; <span>0</span>)
                {
                    <span>// The message is incomplete and there's no more data to process.</span>
                    <span>throw</span> <span>new</span> InvalidDataException(<span>"Incomplete message."</span>);
                }

                <span>break</span>;
            }
        }
        <span>finally</span>
        {
            reader.AdvanceTo(consumed, examined);
        }
    }

    <span>return</span> <span>null</span>;
}
</span></code></pre>
<p>The preceding code:</p>
<ul>
<li>Parses a single message.</li>
<li>Updates the consumed <code>SequencePosition</code> and examined <code>SequencePosition</code> to point to the start of the trimmed input buffer.</li>
</ul>
<p>The two <code>SequencePosition</code> arguments are updated because <code>TryParseMessage</code> removes the parsed message from the input buffer. Generally, when parsing a single message from the buffer, the examined position should be one of the following:</p>
<ul>
<li>The end of the message.</li>
<li>The end of the received buffer if no message was found.</li>
</ul>
<p>The single message case has the most potential for errors. Passing the wrong values to <em>examined</em> can result in an out of memory exception or an infinite loop. For more information, see the <a href="#gotchas" data-linktype="self-bookmark">PipeReader common problems</a> section in this article.</p>
<h3 id="reading-multiple-messages">Reading multiple messages<a href="#reading-multiple-messages" aria-labelledby="reading-multiple-messages"></a></h3>
<p>The following code reads all messages from a <code>PipeReader</code> and calls <code>ProcessMessageAsync</code> on each.</p>
<pre tabindex="0"><code name="MyConnection1" data-author-content="async Task ProcessMessagesAsync(PipeReader reader, CancellationToken cancellationToken = default)
{
    try
    {
        while (true)
        {
            ReadResult result = await reader.ReadAsync(cancellationToken);
            ReadOnlySequence<byte> buffer = result.Buffer;

            try
            {
                // Process all messages from the buffer, modifying the input buffer on each 
                // iteration.
                while (TryParseMessage(ref buffer, out Message message))
                {
                    await ProcessMessageAsync(message);
                }

                // There's no more data to be processed.
                if (result.IsCompleted)
                {
                    if (buffer.Length > 0)
                    {
                        // The message is incomplete and there's no more data to process.
                        throw new InvalidDataException(&quot;Incomplete message.&quot;);
                    }
                    break;
                }
            }
            finally
            {
                // Since all messages in the buffer are being processed, you can use the 
                // remaining buffer's Start and End position to determine consumed and examined.
                reader.AdvanceTo(buffer.Start, buffer.End);
            }
        }
    }
    finally
    {
        await reader.CompleteAsync();
    }
}
"><span><span><span>async</span> Task <span>ProcessMessagesAsync</span>(<span>PipeReader reader, CancellationToken cancellationToken = <span>default</span></span>)</span>
{
    <span>try</span>
    {
        <span>while</span> (<span>true</span>)
        {
            ReadResult result = <span>await</span> reader.ReadAsync(cancellationToken);
            ReadOnlySequence&lt;<span>byte</span>&gt; buffer = result.Buffer;

            <span>try</span>
            {
                <span>// Process all messages from the buffer, modifying the input buffer on each </span>
                <span>// iteration.</span>
                <span>while</span> (TryParseMessage(<span>ref</span> buffer, <span>out</span> Message message))
                {
                    <span>await</span> ProcessMessageAsync(message);
                }

                <span>// There's no more data to be processed.</span>
                <span>if</span> (result.IsCompleted)
                {
                    <span>if</span> (buffer.Length &gt; <span>0</span>)
                    {
                        <span>// The message is incomplete and there's no more data to process.</span>
                        <span>throw</span> <span>new</span> InvalidDataException(<span>"Incomplete message."</span>);
                    }
                    <span>break</span>;
                }
            }
            <span>finally</span>
            {
                <span>// Since all messages in the buffer are being processed, you can use the </span>
                <span>// remaining buffer's Start and End position to determine consumed and examined.</span>
                reader.AdvanceTo(buffer.Start, buffer.End);
            }
        }
    }
    <span>finally</span>
    {
        <span>await</span> reader.CompleteAsync();
    }
}
</span></code></pre><h3 id="cancellation">Cancellation<a href="#cancellation" aria-labelledby="cancellation"></a></h3>
<p><code>PipeReader.ReadAsync</code>:</p>
<ul>
<li>Supports passing a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken" data-linktype="absolute-path">CancellationToken</a>.</li>
<li>Throws an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.operationcanceledexception" data-linktype="absolute-path">OperationCanceledException</a> if the <code>CancellationToken</code> is canceled while there's a read pending.</li>
<li>Supports a way to cancel the current read operation via <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipereader.cancelpendingread" data-linktype="absolute-path">PipeReader.CancelPendingRead</a>, which avoids raising an exception. Calling <code>PipeReader.CancelPendingRead</code> causes the current or next call to <code>PipeReader.ReadAsync</code> to return a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.readresult" data-linktype="absolute-path">ReadResult</a> with <code>IsCanceled</code> set to <code>true</code>. This can be useful for halting the existing read loop in a non-destructive and non-exceptional way.</li>
</ul>
<pre tabindex="0"><code name="MyConnection" data-author-content="private PipeReader reader;

public MyConnection(PipeReader reader)
{
    this.reader = reader;
}

public void Abort()
{
    // Cancel the pending read so the process loop ends without an exception.
    reader.CancelPendingRead();
}

public async Task ProcessMessagesAsync()
{
    try
    {
        while (true)
        {
            ReadResult result = await reader.ReadAsync();
            ReadOnlySequence<byte> buffer = result.Buffer;

            try
            {
                if (result.IsCanceled)
                {
                    // The read was canceled. You can quit without reading the existing data.
                    break;
                }

                // Process all messages from the buffer, modifying the input buffer on each 
                // iteration.
                while (TryParseMessage(ref buffer, out Message message))
                {
                    await ProcessMessageAsync(message);
                }

                // There's no more data to be processed.
                if (result.IsCompleted)
                {
                    break;
                }
            }
            finally
            {
                // Since all messages in the buffer are being processed, you can use the 
                // remaining buffer's Start and End position to determine consumed and examined.
                reader.AdvanceTo(buffer.Start, buffer.End);
            }
        }
    }
    finally
    {
        await reader.CompleteAsync();
    }
}
"><span><span>private</span> PipeReader reader;

<span><span>public</span> <span>MyConnection</span>(<span>PipeReader reader</span>)</span>
{
    <span>this</span>.reader = reader;
}

<span><span>public</span> <span>void</span> <span>Abort</span>(<span></span>)</span>
{
    <span>// Cancel the pending read so the process loop ends without an exception.</span>
    reader.CancelPendingRead();
}

<span><span>public</span> <span>async</span> Task <span>ProcessMessagesAsync</span>(<span></span>)</span>
{
    <span>try</span>
    {
        <span>while</span> (<span>true</span>)
        {
            ReadResult result = <span>await</span> reader.ReadAsync();
            ReadOnlySequence&lt;<span>byte</span>&gt; buffer = result.Buffer;

            <span>try</span>
            {
                <span>if</span> (result.IsCanceled)
                {
                    <span>// The read was canceled. You can quit without reading the existing data.</span>
                    <span>break</span>;
                }

                <span>// Process all messages from the buffer, modifying the input buffer on each </span>
                <span>// iteration.</span>
                <span>while</span> (TryParseMessage(<span>ref</span> buffer, <span>out</span> Message message))
                {
                    <span>await</span> ProcessMessageAsync(message);
                }

                <span>// There's no more data to be processed.</span>
                <span>if</span> (result.IsCompleted)
                {
                    <span>break</span>;
                }
            }
            <span>finally</span>
            {
                <span>// Since all messages in the buffer are being processed, you can use the </span>
                <span>// remaining buffer's Start and End position to determine consumed and examined.</span>
                reader.AdvanceTo(buffer.Start, buffer.End);
            }
        }
    }
    <span>finally</span>
    {
        <span>await</span> reader.CompleteAsync();
    }
}
</span></code></pre>

<h3 id="pipereader-common-problems">PipeReader common problems<a href="#pipereader-common-problems" aria-labelledby="pipereader-common-problems"></a></h3>
<ul>
<li><p>Passing the wrong values to <code>consumed</code> or <code>examined</code> may result in reading already read data.</p>
</li>
<li><p>Passing <code>buffer.End</code> as examined may result in:</p>
<ul>
<li>Stalled data</li>
<li>Possibly an eventual Out of Memory (OOM) exception if data isn't consumed. For example, <code>PipeReader.AdvanceTo(position, buffer.End)</code> when processing a single message at a time from the buffer.</li>
</ul>
</li>
<li><p>Passing the wrong values to <code>consumed</code> or <code>examined</code> may result in an infinite loop. For example, <code>PipeReader.AdvanceTo(buffer.Start)</code> if <code>buffer.Start</code> hasn't changed will cause the next call to <code>PipeReader.ReadAsync</code> to return immediately before new data arrives.</p>
</li>
<li><p>Passing the wrong values to <code>consumed</code> or <code>examined</code> may result in infinite buffering (eventual OOM).</p>
</li>
<li><p>Using the <code>ReadOnlySequence&lt;byte&gt;</code> after calling <code>PipeReader.AdvanceTo</code> may result in memory corruption (use after free).</p>
</li>
<li><p>Failing to call <code>PipeReader.Complete/CompleteAsync</code> may result in a memory leak.</p>
</li>
<li><p>Checking <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.readresult.iscompleted#System_IO_Pipelines_ReadResult_IsCompleted" data-linktype="absolute-path">ReadResult.IsCompleted</a> and exiting the reading logic before processing the buffer results in data loss. The loop exit condition should be based on <code>ReadResult.Buffer.IsEmpty</code> and <code>ReadResult.IsCompleted</code>. Doing this incorrectly could result in an infinite loop.</p>
</li>
</ul>
<h4 id="problematic-code">Problematic code<a href="#problematic-code" aria-labelledby="problematic-code"></a></h4>
<p>❌ <strong>Data loss</strong></p>
<p>The <code>ReadResult</code> can return the final segment of data when <code>IsCompleted</code> is set to <code>true</code>. Not reading that data before exiting the read loop will result in data loss.</p>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>
<pre tabindex="0"><code name="DoNotUse#1" data-author-content="Environment.FailFast(&quot;This code is terrible, don't use it!&quot;);
while (true)
{
    ReadResult result = await reader.ReadAsync(cancellationToken);
    ReadOnlySequence<byte> dataLossBuffer = result.Buffer;

    if (result.IsCompleted)
    {
        break;
    }

    Process(ref dataLossBuffer, out Message message);

    reader.AdvanceTo(dataLossBuffer.Start, dataLossBuffer.End);
}
"><span>Environment.FailFast(<span>"This code is terrible, don't use it!"</span>);
<span>while</span> (<span>true</span>)
{
    ReadResult result = <span>await</span> reader.ReadAsync(cancellationToken);
    ReadOnlySequence&lt;<span>byte</span>&gt; dataLossBuffer = result.Buffer;

    <span>if</span> (result.IsCompleted)
    {
        <span>break</span>;
    }

    Process(<span>ref</span> dataLossBuffer, <span>out</span> Message message);

    reader.AdvanceTo(dataLossBuffer.Start, dataLossBuffer.End);
}
</span></code></pre><div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>

<p>❌ <strong>Infinite loop</strong></p>
<p>The following logic may result in an infinite loop if the <code>Result.IsCompleted</code> is <code>true</code> but there's never a complete message in the buffer.</p>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>
<pre tabindex="0"><code name="DoNotUse#2" data-author-content="Environment.FailFast(&quot;This code is terrible, don't use it!&quot;);
while (true)
{
    ReadResult result = await reader.ReadAsync(cancellationToken);
    ReadOnlySequence<byte> infiniteLoopBuffer = result.Buffer;
    if (result.IsCompleted &amp;&amp; infiniteLoopBuffer.IsEmpty)
    {
        break;
    }

    Process(ref infiniteLoopBuffer, out Message message);

    reader.AdvanceTo(infiniteLoopBuffer.Start, infiniteLoopBuffer.End);
}
"><span>Environment.FailFast(<span>"This code is terrible, don't use it!"</span>);
<span>while</span> (<span>true</span>)
{
    ReadResult result = <span>await</span> reader.ReadAsync(cancellationToken);
    ReadOnlySequence&lt;<span>byte</span>&gt; infiniteLoopBuffer = result.Buffer;
    <span>if</span> (result.IsCompleted &amp;&amp; infiniteLoopBuffer.IsEmpty)
    {
        <span>break</span>;
    }

    Process(<span>ref</span> infiniteLoopBuffer, <span>out</span> Message message);

    reader.AdvanceTo(infiniteLoopBuffer.Start, infiniteLoopBuffer.End);
}
</span></code></pre><div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>

<p>Here's another piece of code with the same problem. It's checking for a non-empty buffer before checking <code>ReadResult.IsCompleted</code>. Because it's in an <code>else if</code>, it will loop forever if there's never a complete message in the buffer.</p>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>
<pre tabindex="0"><code name="DoNotUse#3" data-author-content="Environment.FailFast(&quot;This code is terrible, don't use it!&quot;);
while (true)
{
    ReadResult result = await reader.ReadAsync(cancellationToken);
    ReadOnlySequence<byte> infiniteLoopBuffer = result.Buffer;

    if (!infiniteLoopBuffer.IsEmpty)
    {
        Process(ref infiniteLoopBuffer, out Message message);
    }
    else if (result.IsCompleted)
    {
        break;
    }

    reader.AdvanceTo(infiniteLoopBuffer.Start, infiniteLoopBuffer.End);
}
"><span>Environment.FailFast(<span>"This code is terrible, don't use it!"</span>);
<span>while</span> (<span>true</span>)
{
    ReadResult result = <span>await</span> reader.ReadAsync(cancellationToken);
    ReadOnlySequence&lt;<span>byte</span>&gt; infiniteLoopBuffer = result.Buffer;

    <span>if</span> (!infiniteLoopBuffer.IsEmpty)
    {
        Process(<span>ref</span> infiniteLoopBuffer, <span>out</span> Message message);
    }
    <span>else</span> <span>if</span> (result.IsCompleted)
    {
        <span>break</span>;
    }

    reader.AdvanceTo(infiniteLoopBuffer.Start, infiniteLoopBuffer.End);
}
</span></code></pre><div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>

<p>❌ <strong>Unexpected Hang</strong></p>
<p>Unconditionally calling <code>PipeReader.AdvanceTo</code> with <code>buffer.End</code> in the <code>examined</code> position may result in hangs when parsing a single message. The next call to <code>PipeReader.AdvanceTo</code> won't return until:</p>
<ul>
<li>There's more data written to the pipe.</li>
<li>And the new data wasn't previously examined.</li>
</ul>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>
<pre tabindex="0"><code name="DoNotUse#4" data-author-content="Environment.FailFast(&quot;This code is terrible, don't use it!&quot;);
while (true)
{
    ReadResult result = await reader.ReadAsync(cancellationToken);
    ReadOnlySequence<byte> hangBuffer = result.Buffer;

    Process(ref hangBuffer, out Message message);

    if (result.IsCompleted)
    {
        break;
    }

    reader.AdvanceTo(hangBuffer.Start, hangBuffer.End);

    if (message != null)
    {
        return message;
    }
}
"><span>Environment.FailFast(<span>"This code is terrible, don't use it!"</span>);
<span>while</span> (<span>true</span>)
{
    ReadResult result = <span>await</span> reader.ReadAsync(cancellationToken);
    ReadOnlySequence&lt;<span>byte</span>&gt; hangBuffer = result.Buffer;

    Process(<span>ref</span> hangBuffer, <span>out</span> Message message);

    <span>if</span> (result.IsCompleted)
    {
        <span>break</span>;
    }

    reader.AdvanceTo(hangBuffer.Start, hangBuffer.End);

    <span>if</span> (message != <span>null</span>)
    {
        <span>return</span> message;
    }
}
</span></code></pre><div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>

<p>❌ <strong>Out of Memory (OOM)</strong></p>
<p>With the following conditions, the following code keeps buffering until an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.outofmemoryexception" data-linktype="absolute-path">OutOfMemoryException</a> occurs:</p>
<ul>
<li>There's no maximum message size.</li>
<li>The data returned from the <code>PipeReader</code> doesn't make a complete message. For example, it doesn't make a complete message because the other side is writing a large message (For example, a 4-GB message).</li>
</ul>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>
<pre tabindex="0"><code name="DoNotUse#5" data-author-content="Environment.FailFast(&quot;This code is terrible, don't use it!&quot;);
while (true)
{
    ReadResult result = await reader.ReadAsync(cancellationToken);
    ReadOnlySequence<byte> thisCouldOutOfMemory = result.Buffer;

    Process(ref thisCouldOutOfMemory, out Message message);

    if (result.IsCompleted)
    {
        break;
    }

    reader.AdvanceTo(thisCouldOutOfMemory.Start, thisCouldOutOfMemory.End);

    if (message != null)
    {
        return message;
    }
}
"><span>Environment.FailFast(<span>"This code is terrible, don't use it!"</span>);
<span>while</span> (<span>true</span>)
{
    ReadResult result = <span>await</span> reader.ReadAsync(cancellationToken);
    ReadOnlySequence&lt;<span>byte</span>&gt; thisCouldOutOfMemory = result.Buffer;

    Process(<span>ref</span> thisCouldOutOfMemory, <span>out</span> Message message);

    <span>if</span> (result.IsCompleted)
    {
        <span>break</span>;
    }

    reader.AdvanceTo(thisCouldOutOfMemory.Start, thisCouldOutOfMemory.End);

    <span>if</span> (message != <span>null</span>)
    {
        <span>return</span> message;
    }
}
</span></code></pre><div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>

<p>❌ <strong>Memory Corruption</strong></p>
<p>When writing helpers that read the buffer, any returned payload should be copied before calling <code>Advance</code>. The following example will return memory that the <code>Pipe</code> has discarded and may reuse it for the next operation (read/write).</p>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the following code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The following sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>
<pre tabindex="0"><code name="DoNotUse#Message" data-author-content="public class Message
{
    public ReadOnlySequence<byte> CorruptedPayload { get; set; }
}
"><span><span>public</span> <span>class</span> <span>Message</span>
{
    <span>public</span> ReadOnlySequence&lt;<span>byte</span>&gt; CorruptedPayload { <span>get</span>; <span>set</span>; }
}
</span></code></pre><pre tabindex="0"><code name="DoNotUse#6" data-author-content="    Environment.FailFast(&quot;This code is terrible, don't use it!&quot;);
    Message message = null;

    while (true)
    {
        ReadResult result = await reader.ReadAsync(cancellationToken);
        ReadOnlySequence<byte> buffer = result.Buffer;

        ReadHeader(ref buffer, out int length);

        if (length <= buffer.Length)
        {
            message = new Message
            {
                // Slice the payload from the existing buffer
                CorruptedPayload = buffer.Slice(0, length)
            };

            buffer = buffer.Slice(length);
        }

        if (result.IsCompleted)
        {
            break;
        }

        reader.AdvanceTo(buffer.Start, buffer.End);

        if (message != null)
        {
            // This code is broken since reader.AdvanceTo() was called with a position *after* the buffer 
            // was captured.
            break;
        }
    }

    return message;
}
"><span>    Environment.FailFast(<span>"This code is terrible, don't use it!"</span>);
    Message message = <span>null</span>;

    <span>while</span> (<span>true</span>)
    {
        ReadResult result = <span>await</span> reader.ReadAsync(cancellationToken);
        ReadOnlySequence&lt;<span>byte</span>&gt; buffer = result.Buffer;

        ReadHeader(<span>ref</span> buffer, <span>out</span> <span>int</span> length);

        <span>if</span> (length &lt;= buffer.Length)
        {
            message = <span>new</span> Message
            {
                <span>// Slice the payload from the existing buffer</span>
                CorruptedPayload = buffer.Slice(<span>0</span>, length)
            };

            buffer = buffer.Slice(length);
        }

        <span>if</span> (result.IsCompleted)
        {
            <span>break</span>;
        }

        reader.AdvanceTo(buffer.Start, buffer.End);

        <span>if</span> (message != <span>null</span>)
        {
            <span>// This code is broken since reader.AdvanceTo() was called with a position *after* the buffer </span>
            <span>// was captured.</span>
            <span>break</span>;
        }
    }

    <span>return</span> message;
}
</span></code></pre><div>
<p><span aria-hidden="true"></span> Warning</p>
<p>Do <strong>NOT</strong> use the preceding code. Using this sample will result in data loss, hangs, security issues and should <strong>NOT</strong> be copied. The preceding sample is provided to explain <a href="#gotchas" data-linktype="self-bookmark">PipeReader Common problems</a>.</p>
</div>
<h2 id="pipewriter">PipeWriter<a href="#pipewriter" aria-labelledby="pipewriter"></a></h2>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter" data-linktype="absolute-path">PipeWriter</a> manages buffers for writing on the caller's behalf. <code>PipeWriter</code> implements <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.ibufferwriter-1" data-linktype="absolute-path"><code>IBufferWriter&lt;byte&gt;</code></a>. <code>IBufferWriter&lt;byte&gt;</code> makes it possible to get access to buffers to perform writes without additional buffer copies.</p>
<pre tabindex="0"><code name="MyPipeWriter" data-author-content="async Task WriteHelloAsync(PipeWriter writer, CancellationToken cancellationToken = default)
{
    // Request at least 5 bytes from the PipeWriter.
    Memory<byte> memory = writer.GetMemory(5);

    // Write directly into the buffer.
    int written = Encoding.ASCII.GetBytes(&quot;Hello&quot;.AsSpan(), memory.Span);

    // Tell the writer how many bytes were written.
    writer.Advance(written);

    await writer.FlushAsync(cancellationToken);
}
"><span><span><span>async</span> Task <span>WriteHelloAsync</span>(<span>PipeWriter writer, CancellationToken cancellationToken = <span>default</span></span>)</span>
{
    <span>// Request at least 5 bytes from the PipeWriter.</span>
    Memory&lt;<span>byte</span>&gt; memory = writer.GetMemory(<span>5</span>);

    <span>// Write directly into the buffer.</span>
    <span>int</span> written = Encoding.ASCII.GetBytes(<span>"Hello"</span>.AsSpan(), memory.Span);

    <span>// Tell the writer how many bytes were written.</span>
    writer.Advance(written);

    <span>await</span> writer.FlushAsync(cancellationToken);
}
</span></code></pre>
<p>The previous code:</p>
<ul>
<li>Requests a buffer of at least 5 bytes from the <code>PipeWriter</code> using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.getmemory" data-linktype="absolute-path">GetMemory</a>.</li>
<li>Writes bytes for the ASCII string <code>"Hello"</code> to the returned <code>Memory&lt;byte&gt;</code>.</li>
<li>Calls <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.advance" data-linktype="absolute-path">Advance</a> to indicate how many bytes were written to the buffer.</li>
<li>Flushes the <code>PipeWriter</code>, which sends the bytes to the underlying device.</li>
</ul>
<p>The previous method of writing uses the buffers provided by the <code>PipeWriter</code>. Alternatively, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.writeasync" data-linktype="absolute-path">PipeWriter.WriteAsync</a>:</p>
<ul>
<li>Copies the existing buffer to the <code>PipeWriter</code>.</li>
<li>Calls <code>GetSpan</code>, <code>Advance</code> as appropriate and calls <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.flushasync" data-linktype="absolute-path">FlushAsync</a>.</li>
</ul>
<pre tabindex="0"><code name="MyPipeWriter#2" data-author-content="async Task WriteHelloAsync(PipeWriter writer, CancellationToken cancellationToken = default)
{
    byte[] helloBytes = Encoding.ASCII.GetBytes(&quot;Hello&quot;);

    // Write helloBytes to the writer, there's no need to call Advance here 
    // (Write does that).
    await writer.WriteAsync(helloBytes, cancellationToken);
}
"><span><span><span>async</span> Task <span>WriteHelloAsync</span>(<span>PipeWriter writer, CancellationToken cancellationToken = <span>default</span></span>)</span>
{
    <span>byte</span>[] helloBytes = Encoding.ASCII.GetBytes(<span>"Hello"</span>);

    <span>// Write helloBytes to the writer, there's no need to call Advance here </span>
    <span>// (Write does that).</span>
    <span>await</span> writer.WriteAsync(helloBytes, cancellationToken);
}
</span></code></pre><h3 id="cancellation-1">Cancellation<a href="#cancellation-1" aria-labelledby="cancellation-1"></a></h3>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.flushasync" data-linktype="absolute-path">FlushAsync</a> supports passing a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken" data-linktype="absolute-path">CancellationToken</a>. Passing a <code>CancellationToken</code> results in an <code>OperationCanceledException</code> if the token is canceled while there's a flush pending. <code>PipeWriter.FlushAsync</code> supports a way to cancel the current flush operation via <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.cancelpendingflush" data-linktype="absolute-path">PipeWriter.CancelPendingFlush</a> without raising an exception. Calling <code>PipeWriter.CancelPendingFlush</code> causes the current or next call to <code>PipeWriter.FlushAsync</code> or <code>PipeWriter.WriteAsync</code> to return a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.flushresult" data-linktype="absolute-path">FlushResult</a> with <code>IsCanceled</code> set to <code>true</code>. This can be useful for halting the yielding flush in a non-destructive and non-exceptional way.</p>

<h3 id="pipewriter-common-problems">PipeWriter common problems<a href="#pipewriter-common-problems" aria-labelledby="pipewriter-common-problems"></a></h3>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.getspan" data-linktype="absolute-path">GetSpan</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.getmemory" data-linktype="absolute-path">GetMemory</a> return a buffer with at least the requested amount of memory. <strong>Don't</strong> assume exact buffer sizes.</li>
<li>There's no guarantee that successive calls will return the same buffer or the same-sized buffer.</li>
<li>A new buffer must be requested after calling <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.advance" data-linktype="absolute-path">Advance</a> to continue writing more data. The previously acquired buffer can't be written to.</li>
<li>Calling <code>GetMemory</code> or <code>GetSpan</code> while there's an incomplete call to <code>FlushAsync</code> isn't safe.</li>
<li>Calling <code>Complete</code> or <code>CompleteAsync</code> while there's unflushed data can result in memory corruption.</li>
</ul>
<h2 id="iduplexpipe">IDuplexPipe<a href="#iduplexpipe" aria-labelledby="iduplexpipe"></a></h2>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.iduplexpipe" data-linktype="absolute-path">IDuplexPipe</a> is a contract for types that support both reading and writing. For example, a network connection would be represented by an <code>IDuplexPipe</code>.</p>
<p>Unlike <code>Pipe</code> which contains a <code>PipeReader</code> and a <code>PipeWriter</code>, <code>IDuplexPipe</code> represents a single side of a full duplex connection. That means what is written to the <code>PipeWriter</code> will not be read from the <code>PipeReader</code>.</p>
<h2 id="streams">Streams<a href="#streams" aria-labelledby="streams"></a></h2>
<p>When reading or writing stream data, you typically read data using a de-serializer and write data using a serializer. Most of these read and write stream APIs have a <code>Stream</code> parameter. To make it easier to integrate with these existing APIs, <code>PipeReader</code> and <code>PipeWriter</code> expose an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipereader.asstream" data-linktype="absolute-path">AsStream</a>.  <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter.asstream" data-linktype="absolute-path">AsStream</a> returns a <code>Stream</code> implementation around the <code>PipeReader</code> or <code>PipeWriter</code>.</p>

						<!-- </content> -->

						</main>

						<!-- recommended content page section -->

							<nav data-bi-name="recommendation-bottom" hidden="" id="recommended-content-center" aria-labelledby="recommended-content-center-title">
								<h3 id="recommended-content-center-title">Related Articles</h3>
							</nav>

						<!-- end recommended content page section -->

						<!-- rating mobile section -->
								
						<!-- end rating mobile section -->

						<!-- feedback section -->



<section data-bi-name="feedback-section">

	<h2 id="feedback">Feedback</h2>

	

	

	

	<div data-tab-group-independent="" hidden="" data-bi-name="tab-group">
		<ul role="tablist">
			<li role="presentation">
				<a href="#tabpanel-issues-open" role="tab" aria-controls="tabpanel-issues-open" data-tab="issues-open" data-bi-name="tab" aria-selected="true" tabindex="0"></a>
			</li>
			<li role="presentation">
				<a href="#tabpanel-issues-closed" role="tab" aria-controls="tabpanel-issues-closed" data-tab="issues-closed" data-bi-name="tab" aria-selected="false" tabindex="-1"></a>
			</li>
		</ul>
		<section id="tabpanel-issues-open" role="tabpanel" data-tab="issues-open">
			
			<ul aria-label="Open Issues"></ul>
		</section>
		<section id="tabpanel-issues-closed" role="tabpanel" data-tab="issues-closed" hidden="hidden" aria-hidden="true">
			<div>There are no closed issues</div>
			<ul aria-label="Closed Issues"></ul>
		</section>
	</div>
	
</section>

						<!-- end feedback section -->

						<!-- feedback report section -->
						<!-- end feedback report section -->

						
					</div>

					

					<!--end of div.columns -->
				</div>

			<!--end of .primary-holder -->
			</section>

			
		</div>

		<!--end of .mainContainer -->
	</div>

	

	

		
		
	


</div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>