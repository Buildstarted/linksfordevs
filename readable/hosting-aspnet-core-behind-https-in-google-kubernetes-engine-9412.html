<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Hosting ASP.NET Core behind https in Google Kubernetes Engine - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Hosting ASP.NET Core behind https in Google Kubernetes Engine - linksfor.dev(s)"/>
    <meta property="og:description" content="Side-note: this may be one of the clumsiest titles I&#x2019;ve ever written for a blog post. But it does what it says on the tin. Oh, and the space after &#x201C;ASP&#x201D; in &#x201C;ASP .NET Core&amp;#8&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://codeblog.jonskeet.uk/2019/03/17/hosting-asp-net-core-behind-https-in-google-kubernetes-engine/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Hosting ASP.NET Core behind https in Google Kubernetes Engine</title>
<div class="readable">
        <h1>Hosting ASP.NET Core behind https in Google Kubernetes Engine</h1>
            <div>Reading time: 16-20 minutes</div>
        <div>Posted here: 18 Mar 2019</div>
        <p><a href="https://codeblog.jonskeet.uk/2019/03/17/hosting-asp-net-core-behind-https-in-google-kubernetes-engine/">https://codeblog.jonskeet.uk/2019/03/17/hosting-asp-net-core-behind-https-in-google-kubernetes-engine/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><article id="post-1698">
	
	<!-- .entry-header -->

		<div>
		<p>Side-note: this may be one of the clumsiest titles I‚Äôve ever written for a blog post. But it does what it says on the tin. Oh, and the space after ‚ÄúASP‚Äù in ‚ÄúASP .NET Core‚Äù everywhere it to avoid auto-linking. While I could use a different dot or a zero-width non-breaking space to avoid it, I‚Äôm not sure I trust WordPress to do the right thing with those‚Ä¶</p>
<h2>Background</h2>
<p>Over the past few weeks, I‚Äôve moved <a href="https://nodatime.org/">nodatime.org</a>, <a href="https://csharpindepth.com/">csharpindepth.com</a> and <a href="https://jonskeet.uk/">jonskeet.uk</a> over to Google Kubernetes Engine. (They all used to be hosted on Azure.)</p>
<p>I‚Äôve done this for a few reasons:</p>
<ul>
<li>As my job is primarily making .NET developers more productive on Google Cloud Platform, it feels natural to run my own code there. I want to see where there are friction points, so I can help fix them.</li>
<li>I wanted more redundancy, particularly for nodatime.org; Kubernetes felt a simple way of managing that at a reasonable cost</li>
<li>HTTPS certificate management (via Let‚Äôs Encrypt) has been a bit painful for me on Azure; I could have automated more, but that would have taken extra time I don‚Äôt have. (It may also have improved since I last looked.)</li>
</ul>
<p>The first of these is the most important, by a long way. But the HTTPS management part ‚Äì and then the knock-on effects ‚Äì is what I‚Äôm looking at in this blog post.</p>
<h2>Basic hosting</h2>
<p>Hosting an ASP .NET Core application in <a href="https://cloud.google.com/kubernetes-engine/">Google Kubernetes Engine</a> (GKE from now on) is really simple, at least once you‚Äôve understood the Kubernetes concepts. I have:</p>
<ul>
<li>A single cluster</li>
<li>A single ingress backed by a <a href="https://cloud.google.com/load-balancing/">Google Cloud Load Balancer</a> for all my domains, with a reserved static IP address (set up in DNS)</li>
<li>A service per application (<a href="https://github.com/nodatime/nodatime/blob/master/build/nodatime.org/service.yaml">nodatime.org example</a>)</li>
<li>A deployment per application (<a href="https://github.com/nodatime/nodatime/blob/master/build/nodatime.org/deployment.yaml">nodatime.org example</a>)</li>
</ul>
<p>In each case, the ASP .NET Core application is built with a vanilla Dockerfile which would not look unusual to anyone who‚Äôs hosted ASP .NET Core in Docker anywhere else.</p>
<p>I happen to use <a href="https://cloud.google.com/cloud-build">Google Cloud Build</a> to build the Docker images, and <a href="https://cloud.google.com/container-registry/">Google Container Registry</a> to host the images, but neither of those are required. (For csharpindepth.com and jonskeet.uk there are simple triggers in Google Cloud Build to build and deploy on GitHub pushes; for nodatime.org it‚Äôs a bit more complicated as the documentation build currently has some Windows dependencies. I have a machine at home that polls GitHub every half hour, and pushes the built application to Google Cloud Build for packaging when necessary.)</p>
<p>So, that gets HTTP hosting sorted. I dare say there are some aspects I‚Äôve not configured as well as I could have done, but it was reasonably straightforward to get going.</p>
<h2>HTTPS with Google-managed certificates</h2>
<p>With HTTP working, it‚Äôs time to shoot for HTTPS. It‚Äôs important to note that the apps I‚Äôm talking about are all hobby projects, not commercial ones ‚Äì I‚Äôm already paying for hosting, so I don‚Äôt want to have to pay for SSL certificates as well. Enter Let‚Äôs Encrypt, of course.</p>
<p>A while ago I used Let‚Äôs Encrypt to set up HTTPS on Azure, and while it was free and I didn‚Äôt have to write any code, it wasn‚Äôt exactly painless. I followed two guides at the same time, because neither of them exactly matched the Azure portal I was looking at. There were lots of bits of information to grab from various different bits of the portal, and it took a couple of attempts to get right‚Ä¶ but I got there. I also set up a web job to renew the certificates, but didn‚Äôt go through the hoops required to run those web jobs periodically. (There were instructions, but it looked like they‚Äôd take a while to work through compared with just manually running the web job every couple of months or so. I decided to take the pragmatic approach, knowing that I was expecting to move to GKE anyway. If Azure had been the expected permanent home for the apps, I‚Äôd have gone through the steps and I‚Äôm sure they‚Äôd have worked fine.) I don‚Äôt know which guide I worked through at the time, but if I were starting today I‚Äôd probably try <a href="https://www.hanselman.com/blog/SecuringAnAzureAppServiceWebsiteUnderSSLInMinutesWithLetsEncrypt.aspx">Scott Hanselman‚Äôs guide</a>.</p>
<p>So, what can I do on Google Cloud Platform instead? I decided to terminate the SSL connection at the load balancer, using <a href="https://cloud.google.com/load-balancing/docs/ssl-certificates#managed-certs">Google-managed certificates</a>. To be really clear, these are currently in beta, but have worked well for me so far. Terminating the SSL connection at the load balancer means that the load balancer forwards the request to the Kubernetes service as an HTTP request, not HTTPS. The ASP .NET Core app itself <em>only</em> exposes an HTTP port, so it doesn‚Äôt need to know any details of certificates.</p>
<p>The steps to achieve this are simple, assuming you have the Google Cloud SDK (gcloud) installed already:</p>
<ul>
<li>Create the certificate, e.g.<br>
<code>gcloud beta compute ssl-certificates create nodatime-org --domains nodatime.org</code></li>
<li>Attach the certificate to the load balancer, via the Kubernetes ingress in my case, with an annotation in the ingress metadata:<br>
<code>ingress.gcp.kubernetes.io/pre-shared-cert: "nodatime-org"</code></li>
<li>Apply the modifications to the ingress:<br>
<code>kubectl apply -f ingress.yaml</code></li>
<li>Wait for the certificate to become valid (the provisioning procedure takes a little while, and I‚Äôve seen some interesting errors while that‚Äôs taking place)</li>
<li>Enjoy HTTPS support, with auto-renewing certificates!</li>
</ul>
<p>There are only two downsides to this that I‚Äôve experienced so far:</p>
<ul>
<li>Currently each certificate can only be associated with a single domain. For example, I have different certificates for nodatime.org, <a href="http://www.nodatime.org/" rel="nofollow">http://www.nodatime.org</a> and test.nodatime.org. (More about the last of these later.) This is a minor annoyance, but the ingress supports multiple pre-shared certificates, so it has no practical implications for me.</li>
<li>I had to accept some downtime on HTTPS when transferring from Azure to GKE, while the certificate was provisioning after I‚Äôd transferred the DNS entry. This was a one-time issue of course, and one that wouldn‚Äôt affect most users.</li>
</ul>
<h2>Beyond the basics</h2>
<p>At this point I had working HTTPS URLs ‚Äì but any visitor using HTTP would stay that way. (At the time of writing this is still true for csharpindepth.com and jonskeet.uk.) Obviously I‚Äôd like to encourage secure browsing, so I‚Äôd like to use the two pieces of functionality provided by ASP .NET Core:</p>
<ul>
<li>Redirection of HTTP requests via <code>app.UseHttpsRedirection()</code></li>
<li><a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HSTS</a> support via <code>app.UseHsts()</code></li>
</ul>
<p>I should note here that the <a href="https://docs.microsoft.com/en-us/aspnet/core/security/enforcing-ssl">Microsoft documentation</a> was <em>fabulously</em> useful throughout. It didn‚Äôt quite get me all the way, but it was really close.</p>
<p>Now, I <em>could</em> have just added those calls into the code and deployed straight to production. Local testing would have worked ‚Äì it would have redirected from localhost:5000 on HTTP to localhost:5001 on HTTPS with no problems. It would also have failed massively for reasons we‚Äôll look at in a minute. Just for a change, I happened to do the right thing‚Ä¶</p>
<h3>For hosting changes, <em>always</em> use a test deployment first</h3>
<p>In Azure, I had a separate AppService I could deploy to, called <code>nodatimetest</code>. It didn‚Äôt have a fancy URL, but it worked okay. That‚Äôs where I tested Azure-specific changes before deploying to the real AppService. Unfortunately, it wouldn‚Äôt have helped in this situation, as it didn‚Äôt have a certificate.</p>
<p>Fortunately, creating a new service in Kubernetes, adding it to the ingress, and creating a managed certificate is so easy that I <em>did</em> do this for the new hosting ‚Äì and I‚Äôm <em>so</em> glad I did so. I use a <a href="https://github.com/nodatime/nodatime/blob/master/build/deploytestbuild.sh">small script</a> to publish the local ASP .NET Core build to Google Cloud Build which does the Docker packaging, pushes it to Google Container Registry and updates the Kubernetes deployment. As part of that script, I add a small text file containing the current timestamp so I can check that I‚Äôm really looking at the deployment I expect. It takes just under two minutes to build, push, package, deploy ‚Äì not a tight loop you‚Äôd want for every day development, but pretty good for the kind of change that can‚Äôt be tested locally.</p>
<p>So, I made the changes to use HTTPS redirection and HSTS, deployed, and‚Ä¶ there was no obvious change.</p>
<h3>Issue 1: No HTTPS port to redirect to</h3>
<p>Remember how the ASP .NET Core app in Kubernetes is only listening on HTTP? That means it doesn‚Äôt know which port to redirect users to for HTTPS. Oops. While I guess it would be reasonable to guess 443 if it didn‚Äôt know any better, the default of ‚Äúdon‚Äôt redirect if you haven‚Äôt been told a port‚Äù means that your application doesn‚Äôt stop working if you get things wrong ‚Äì it just doesn‚Äôt redirect.</p>
<p>This is easily fixed in <code>ConfigureServices</code>:</p>
<div><div id="highlighter_181697"><table><tbody><tr><td><p>1</p></td><td><div><p><code>services.AddHttpsRedirection(options =&gt; options.HttpsPort = 443);</code></p></div></td></tr></tbody></table></div></div>
<p>‚Ä¶ but I‚Äôve added conditional code so it <em>doesn‚Äôt</em> do that in development environment, as otherwise it would try to redirect from localhost:5000 to localhost:443, which wouldn‚Äôt work. This is a bit hacky at the moment, which is a common theme ‚Äì I want to clean up all the configuration at some point quite soon (moving things into <code>appsettings.json</code> as far as possible) but it‚Äôs just about hanging together for now.</p>
<p>So, make the change, redeploy to test, and‚Ä¶ observed infinite redirection in the browser. What?</p>
<h3>Issue 2: Forwarding proxied headers</h3>
<p>Remember <em>again</em> how the ASP .NET Core app is only listening on HTTP? We want it to behave differently depending on whether the end user made a request to the load balancer on HTTP or HTTPS. That means using headers forwarded from the proxy (in our case the load balancer) to determine the original request scheme. Fortunately, again there‚Äôs <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer">documentation on hand</a> for this.</p>
<p>There are two parts to configuring this:</p>
<ul>
<li>Configuring the <code>ForwardedHeadersOptions</code> in <code>ConfigureServices</code></li>
<li>Calling <code>app.UseForwardedHeaders()</code> in <code>Configure</code></li>
</ul>
<p>(At least, that‚Äôs the way that‚Äôs documented. I‚Äôm sure there are myriad alternatives, but my experience level of ASP .NET Core is such that I‚Äôm still in ‚Äúfollow the examples verbatim, changing as little as possible‚Äù at the moment.)</p>
<p>I won‚Äôt go into the gory details of exactly how many times I messed up the forwarded headers options, but I will say:</p>
<ul>
<li>The example which just changes <code>options.ForwardedHeaders</code> is probably fine if your proxy server is local to the application, but otherwise you <em>will</em> need do to extra work</li>
<li>The <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer#troubleshoot">troubleshooting part of the documentation</a> is spectacularly useful</li>
<li>There <em>are</em> warnings logged if you get things wrong, and those logs will help you ‚Äì but they‚Äôre at a debug log level, so you may need to update your logging settings. (I only realized this after I‚Äôd fixed the problem, partly thanks to Twitter.)</li>
</ul>
<p><em>Lesson to learn:</em> when debugging a problem, turn on debugging logs. Who‚Äôd have thought?</p>
<p>Configuring this properly is an area where you really need to understand your deployment and how a request reaches you. In my case, the steps are:</p>
<ul>
<li>The user‚Äôs HTTPS request is terminated by the load balancer</li>
<li>The load balancer makes a request to the Kubernetes service</li>
<li>The Kubernetes service makes a request to the application running on one of the suitable nodes</li>
</ul>
<p>This leads to a relatively complex configuration, as there are two networks to trust (Google Cloud load balancers, and my internal Kubernetes network) and we need to allow two ‚Äúhops‚Äù of proxying. So my configuration code looks like this:</p>
<div><div id="highlighter_661080"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p></td><td><div><p><code>services.Configure&lt;ForwardedHeadersOptions&gt;(options =&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.KnownNetworks.Clear();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.KnownNetworks.Add(</code><code>new</code> <code>IPNetwork(IPAddress.Parse(</code><code>"130.211.0.0"</code><code>), 22));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.KnownNetworks.Add(</code><code>new</code> <code>IPNetwork(IPAddress.Parse(</code><code>"35.191.0.0"</code><code>), 16));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.KnownNetworks.Add(</code><code>new</code> <code>IPNetwork(IPAddress.Parse(</code><code>"10.0.0.0"</code><code>), 8));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.ForwardLimit = 2;</code></p><p><code>});</code></p></div></td></tr></tbody></table></div></div>
<p>(The call to <code>KnownNetworks.Clear()</code> probably isn‚Äôt necessary. The default is to include the loopback, which is safe enough to leave in the list.)</p>
<p>Okay, deploy <em>that</em> to the test environment. Everything will work now, right? Well, sort of‚Ä¶</p>
<h3>Issue 3: make sure health checks are healthy!</h3>
<p>As it happens, when I‚Äôd finished fixing issue 2, I needed to help at a birthday party for a family we‚Äôre friends with. Still, I went to the party happily knowing everything was fine.</p>
<p>I then came home and found the test deployment was broken. Really broken. ‚Äú502 Bad Gateway‚Äù broken. For both HTTP and HTTPS. This is not good.</p>
<p>I tried adding more logging, but it looked like none of <em>my</em> requests were getting through to the application. I could see in the logs (thank you, Stackdriver!) that requests were being made, always to just ‚Äú/‚Äù on HTTP. They were all being redirected to HTTPS via a 307, as I‚Äôd expect.</p>
<p>This confused me for a while. I honestly can‚Äôt remember what gave me the lightbulb moment of ‚ÄúAh, these are load balancer health checks, and it thinks they‚Äôre failing!‚Äù but I checked with the load balancer in the <a href="https://console.cloud.google.com/">Google Cloud Console</a> and sure enough, I had multiple working backends, and one broken one ‚Äì my test backend. The reason I hadn‚Äôt seen this before was that I‚Äôd only checked the test deployment for a few minutes ‚Äì not long enough for the load balancer to deem the backend unhealthy.</p>
<p>I was stuck at this point for a little while. I considered reconfiguring the load balancer to make the health check over HTTPS, but I don‚Äôt think that could work as the app isn‚Äôt serving HTTPS itself ‚Äì I‚Äôd need to persuade it to make the request as if it were a user-generated HTTPS request, with appropriate <code>X-Forwarded-Proto</code> etc headers. However, I saw that I <em>could</em> change which URL the load balancer would check. So how about we add a <code>/healthz</code> URL that would be served directly without being redirected? (The ‚Äúz‚Äù at the end is a bit of Googler heritage. Just <code>/health</code> would be fine too, of course.)</p>
<p>I started thinking about adding custom inline middleware to do this, but fortunately didn‚Äôt get too far before realizing that ASP .NET Core provides health checking already‚Ä¶ so all I needed to do was add the health check middleware <em>before</em> the HTTPS redirection middleware, and all would be well.</p>
<p>So in <code>ConfigureServices</code>, I added a no-op health check service:</p>
<div><div id="highlighter_825469"><table><tbody><tr><td><p>1</p></td><td><div><p><code>services.AddHealthChecks();</code></p></div></td></tr></tbody></table></div></div>
<p>And in <code>Configure</code> I added the middleware at an appropriate spot:</p>
<div><div id="highlighter_341513"><table><tbody><tr><td><p>1</p></td><td><div><p><code>app.UseHealthChecks(</code><code>"/healthz"</code><code>);</code></p></div></td></tr></tbody></table></div></div>
<p>After reconfiguring the health check on the load balancer, I could see <code>/healthz</code> requests coming in and receiving 200 (OK) responses‚Ä¶ and the load balancer was then happy to use the backend again. Hooray!</p>
<p>After giving the test service long enough to fail, I deployed to production, changed the load balancer health check URL, and all was well. I did the two parts of this quickly enough so that it never failed ‚Äì a safer approach would have been to add the health check handler but without the HTTPS redirection first, deploy that, change the health check URL, <em>then</em> turn on HTTPS.</p>
<p>But the end result is, all is working! Hooray!</p>
<h2>Conclusion</h2>
<p>Moving the service in the first place has been a long process, mostly due to a lack of time to spend on it, but the HTTPS redirection has been its own interesting bit of simultaneous pleasure and frustration. I‚Äôve learned a number of lessons along the way:</p>
<ul>
<li>The combination of Google Kubernetes Engine, Google Cloud Load Balancing, Google Cloud Build and Google Container registry is pretty sweet.</li>
<li>Managed SSL certificates are wonderfully easy to use, even if there is a bit of a worrying delay while provisioning</li>
<li>It‚Äôs <strong><em>really, really</em></strong> important to be able to test deployment changes (such as HTTPS redirection) in an environment which is very similar to production, but which no-one is depending on. (Obviously if you have a site which few people care about anyway, there‚Äôs less risk. But as it‚Äôs easy to set up a test deployment on GKE, why not do it anyway?)</li>
<li>HTTPS redirection caused me three headaches, all predictable:
<ul>
<li>ASP .NET Core needs to know the HTTPS port to redirect to.</li>
<li>You need to configure forwarded headers really carefully, and know your deployment model thoroughly .</li>
<li>Be aware of health checks! Make sure you leave a test deployment ‚Äúlive‚Äù for long enough for the health checks to mark it as unhealthy if you‚Äôve done something wrong, before you deploy to production.</li>
</ul>
</li>
<li>When debugging, turn on debug logging. Sounds obvious in retrospect, doesn‚Äôt it? (Don‚Äôt start trying to copy middleware source code into your own application so you can add logging, rather than using the logging already there‚Ä¶)</li>
</ul>
<p>I also have some future work to do:</p>
<ul>
<li>There‚Äôs a particular URL (<a href="http://nodatime.org/tzdb/latest.txt" rel="nofollow">http://nodatime.org/tzdb/latest.txt</a>) which is polled by applications in order to spot time zone information changes. That‚Äôs the bulk of the traffic to the site. It currently redirects to HTTPS along with everything else, which leads to the total traffic being nearly double what it was before, for no real benefit. I‚Äôve encouraged app authors to use HTTPS instead, but I‚Äôve also <a href="https://github.com/nodatime/nodatime/issues/1319">filed a feature request against myself</a> to consider serving that particular URL without the redirect. It looks like that‚Äôs non-trivial though.</li>
<li>I have a bunch of hard-coded information which should really be in <code>appsettings.json</code>. I want to move all of that, but I need to learn more about the best way of doing it first.</li>
</ul>
<p>All in all, this has been a very positive experience ‚Äì I hope the details above are useful to anyone else hosting ASP .NET Core apps in Google Kubernetes Engine.</p>
	</div><!-- .entry-content -->
	
	</article></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>