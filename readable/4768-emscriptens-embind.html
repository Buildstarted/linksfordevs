<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Emscripten&#x2019;s embind -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Emscriptenâ€™s embind</h1><div><div class="devsite-article-body clearfix
      "><h2 id="it_binds_js_to_your_wasm">It <em>binds</em> JS to your wasm!</h2><section class="wf-byline" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><section class="wf-byline-meta"><p class="wf-byline-desc">
        Surma is a contributor to Web<b>Fundamentals</b></p></section></section><p>In my last <a href="/web/updates/2018/03/emscripting-a-c-library">wasm article</a>, I talked
about how to compile a C library to wasm so you can use it on the web. One thing
that stood out to me (and to many readers) is the crude and slightly awkward way
you have to manually declare which functions of your wasm module you are using.
To refresh your mind, this is the code snippet I am talking about:</p><pre class="prettyprint" translate="no" dir="ltr"><code translate="no" dir="ltr">const api = {
  version: Module.cwrap('version', 'number', []),
  create_buffer: Module.cwrap('create_buffer', 'number', ['number', 'number']),
  destroy_buffer: Module.cwrap('destroy_buffer', '', ['number']),
};
</code></pre><p>Here we declare the names of the functions that we marked with
<code translate="no" dir="ltr">EMSCRIPTEN_KEEPALIVE</code>, what their return types are, and what the types of their
arguments are. Afterwards, we can use the methods on the <code translate="no" dir="ltr">api</code> object to invoke
these functions. However, using wasm this way doesn't support strings and
requires you to manually move chunks of memory around which makes many library
APIs very tedious to use. Isn't there a better way? Why yes there is, otherwise
what would this article be about?</p><h2 id="c_name_mangling">C++ name mangling</h2><p>While the developer experience would be reason enough to build a tool that helps
with these bindings, there's actually a more pressing reason: When you compile C
or C++ code, each file is compiled separately. Then, a linker takes care of
munging all these so-called object files together and turning them into a wasm
file. With C, the names of the functions are still available in the object file
for the linker to use. All you need to be able to call a C function is the name,
which we are providing as a string to <code translate="no" dir="ltr">cwrap()</code>.</p><p>C++ on the other hand supports function overloading, meaning you can implement
the same function multiple times as long as the signature is different (e.g.
differently typed parameters). At the compiler level, a nice name like <code translate="no" dir="ltr">add</code>
would get <em>mangled</em> into something that encodes the signature in the function
name for the linker. As a result, we wouldn't be able to look up our function
with its name anymore.</p><aside class="note"><strong>Note:</strong><span> You can prevent the compiler from mangling your functions' names by
 annotating it with <code translate="no" dir="ltr">extern "C"</code>.</span></aside><h2 id="enter_embind">Enter embind</h2><p><a href="https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html">embind</a>
is part of the Emscripten toolchain and provides you with a bunch of C++ macros
that allow you to annotate C++ code. You can declare which functions, enums,
classes or value types you are planning to use from JavaScript. Let's start
simple with some plain functions:</p><pre class="prettyprint" translate="no" dir="ltr"><code translate="no" dir="ltr">#include &lt;emscripten/bind.h&gt;

using namespace emscripten;

double add(double a, double b) {
  return a + b;
}

std::string exclaim(std::string message) {
  return message + "!";
}

EMSCRIPTEN_BINDINGS(my_module) {
  function("add", &amp;add);
  function("exclaim", &amp;exclaim);
}
</code></pre><p>Compared to my previous article, we are not including <code translate="no" dir="ltr">emscripten.h</code> anymore, as
we don't have to annotate our functions with <code translate="no" dir="ltr">EMSCRIPTEN_KEEPALIVE</code> anymore.
Instead, we have an <code translate="no" dir="ltr">EMSCRIPTEN_BINDINGS</code> section in which we list the names under
which we want to expose our functions to JavaScript.</p><aside class="note"><strong>Note:</strong><span> The parameter for the <code translate="no" dir="ltr">EMSCRIPTEN_BINDINGS</code> macro is mostly used to avoid
name conflicts in bigger projects.</span></aside><p>To compile this file, we can use the same setup (or, if you want, the same
Docker image) as in the <a href="/web/updates/2018/03/emscripting-a-c-library">previous
article</a>. To use embind,
we add the <code translate="no" dir="ltr">--bind</code> flag:</p><pre class="prettyprint" translate="no" dir="ltr"><code translate="no" dir="ltr">$ emcc --bind -O3 add.cpp
</code></pre><p>Now all that's left is whipping up an HTML file that loads our freshly
created wasm module:</p><pre class="prettyprint" translate="no" dir="ltr"><code translate="no" dir="ltr">&lt;script src="/a.out.js"&gt;&lt;/script&gt;
&lt;script&gt;
Module.onRuntimeInitialized = _ =&gt; {
  console.log(Module.add(1, 2.3));
  console.log(Module.exclaim("hello world"));
};
&lt;/script&gt;
</code></pre><aside class="note"><strong>Note:</strong><span> If you are curious, <a href="https://gist.github.com/surma/d04cd0fd896610575126d30de36d7eb6">I wrote up the
same</a> C++ module
<em>without</em> embind to give you a feel for how much work it is doing for you.</span></aside><p>As you can see, we aren't using <code translate="no" dir="ltr">cwrap()</code> anymore. This just works straight out
of the box. But more importantly, we don't have to worry about manually copying
chunks of memory to make strings work! embind gives you that for free, along
with type checks:</p><p><img src="/web/updates/images/2018/08/embind/error.png" alt="DevTools errors when you invoke a function with the wrong number of arguments
or the arguments have the wrong
type"></p><p>This is pretty great as we can catch some errors early instead of dealing with
the occasionally quite unwieldy wasm errors.</p><h3 id="objects">Objects</h3><p>Many JavaScript constructors and functions use options objects. It's a nice
pattern in JavaScript, but extremely tedious to realize in wasm manually. embind
can help here, too!</p><p>For example, I came up with this <em>incredibly</em> useful C++ function that processes my
strings, and I urgently want to use it on the web. Here is how I did that:</p><pre class="prettyprint" translate="no" dir="ltr"><code translate="no" dir="ltr">#include &lt;emscripten/bind.h&gt;
#include &lt;algorithm&gt;

using namespace emscripten;

struct ProcessMessageOpts {
  bool reverse;
  bool exclaim;
  int repeat;
};

std::string processMessage(std::string message, ProcessMessageOpts opts) {
  std::string copy = std::string(message);
  if(opts.reverse) {
    std::reverse(copy.begin(), copy.end());
  }
  if(opts.exclaim) {
    copy += "!";
  }
  std::string acc = std::string("");
  for(int i = 0; i &lt; opts.repeat; i++) {
    acc += copy;
  }
  return acc;
}

EMSCRIPTEN_BINDINGS(my_module) {
  value_object&lt;ProcessMessageOpts&gt;("ProcessMessageOpts")
    .field("reverse", &amp;ProcessMessageOpts::reverse)
    .field("exclaim", &amp;ProcessMessageOpts::exclaim)
    .field("repeat", &amp;ProcessMessageOpts::repeat);

  function("processMessage", &amp;processMessage);
}
</code></pre><p>I am defining a struct for the options of my <code translate="no" dir="ltr">processMessage()</code> function. In the
<code translate="no" dir="ltr">EMSCRIPTEN_BINDINGS</code> block, I can use <code translate="no" dir="ltr">value_object</code> to make JavaScript see
this C++ value as an object. I could also use <code translate="no" dir="ltr">value_array</code> if I preferred to
use this C++ value as an array. I also bind the <code translate="no" dir="ltr">processMessage()</code> function, and
the rest is embind <em>magic</em>. I can now call the <code translate="no" dir="ltr">processMessage()</code> function from
JavaScript without any boilerplate code:</p><pre class="prettyprint" translate="no" dir="ltr"><code translate="no" dir="ltr">console.log(Module.processMessage(
  "hello world",
  {
    reverse: false,
    exclaim: true,
    repeat: 3
  }
)); // Prints "hello world!hello world!hello world!"
</code></pre><h3 id="classes">Classes</h3><p>For completeness sake, I should also show you how embind allows you to expose
entire classes, which brings a lot of synergy with ES6 classes. You can probably
start to see a pattern by now:</p><pre class="prettyprint" translate="no" dir="ltr"><code translate="no" dir="ltr">#include &lt;emscripten/bind.h&gt;
#include &lt;algorithm&gt;

using namespace emscripten;

class Counter {
public:
  int counter;

  Counter(int init) :
    counter(init) {
  }

  void increase() {
    counter++;
  }

  int squareCounter() {
    return counter * counter;
  }
};

EMSCRIPTEN_BINDINGS(my_module) {
  class_&lt;Counter&gt;("Counter")
    .constructor&lt;int&gt;()
    .function("increase", &amp;Counter::increase)
    .function("squareCounter", &amp;Counter::squareCounter)
    .property("counter", &amp;Counter::counter);
}
</code></pre><p>On the JavaScript side, this almost feels like a native class:</p><pre class="prettyprint" translate="no" dir="ltr"><code translate="no" dir="ltr">&lt;script src="/a.out.js"&gt;&lt;/script&gt;
&lt;script&gt;
Module.onRuntimeInitialized = _ =&gt; {
  const c = new Module.Counter(22);
  console.log(c.counter); // prints 22
  c.increase();
  console.log(c.counter); // prints 23
  console.log(c.squareCounter()); // prints 529
};
&lt;/script&gt;
</code></pre><h2 id="what_about_c">What about C?</h2><p>embind was written for C++ and can only be used in C++ files, but that doesn't
mean that you can't link against C files! To mix C and C++, you only need to
separate your input files into two groups: One for C and one for C++ files and
augment the CLI flags for <code translate="no" dir="ltr">emcc</code> as follows:</p><pre class="prettyprint" translate="no" dir="ltr"><code translate="no" dir="ltr">$ emcc --bind -O3 --std=c++11 a_c_file.c another_c_file.c -x c++ your_cpp_file.cpp
</code></pre><h2 id="conclusion">Conclusion</h2><p>embind gives you great improvements in the developer experience when working
with wasm and C/C++. This article does not cover all the options embind offers.
If you are interested, I recommend continuing with <a href="https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html">embind's
documentation</a>.
Keep in mind that using embind can make both your wasm module and your
JavaScript glue code bigger by up to 11k when gzip'd â€” most notably on small
modules. If you only have a very small wasm surface, embind might cost more than
it's worth in a production environment! Nonetheless, you should definitely give
it a try.</p><link rel="alternate" type="application/rss+xml" title="Web Updates RSS Feed" href="https://goo.gl/siLiwf"><link rel="alternate" type="application/atom+xml" title="Web Updates Atom Feed" href="https://goo.gl/oc2PGP"></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>