<!DOCTYPE html>
<html lang="en">
<head>
    <title>
&#x201C;Stack Walking&#x201D; in the .NET Runtime - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="&#x201C;Stack Walking&#x201D; in the .NET Runtime - linksfor.dev(s)"/>
    <meta property="article:author" content="Matt Warren"/>
    <meta property="og:description" content="What is &#x2018;stack walking&#x2019;, well as always the &#x2018;Book of the Runtime&#x2019; (BotR) helps us, from the relevant page:"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://www.mattwarren.org/2019/01/21/Stackwalking-in-the-.NET-Runtime/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - &#x201C;Stack Walking&#x201D; in the .NET Runtime</title>
<div class="readable">
        <h1>&#x201C;Stack Walking&#x201D; in the .NET Runtime</h1>
            <div>by Matt Warren</div>
            <div>Reading time: 36-46 minutes</div>
        <div>Posted here: 25 Dec 2019</div>
        <p><a href="http://www.mattwarren.org/2019/01/21/Stackwalking-in-the-.NET-Runtime/">http://www.mattwarren.org/2019/01/21/Stackwalking-in-the-.NET-Runtime/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
  
  <p><span>21 Jan 2019 - 6375 words</span></p><p>What is ‚Äòstack walking‚Äô, well as always the ‚ÄòBook of the Runtime‚Äô (BotR) helps us, from the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/stackwalking.md">relevant page</a>:</p>

<blockquote>
  <p>The CLR makes heavy use of a technique known as stack walking (or stack crawling). This involves <strong>iterating the sequence of call frames for a particular thread</strong>, from the most recent (the thread‚Äôs current function) back down to the base of the stack.</p>

  <p><strong>The runtime uses stack walks for a number of purposes</strong>:</p>

  <ul>
    <li>The runtime walks the stacks of all threads <strong>during garbage collection, looking for managed roots</strong> (local variables holding object references in the frames of managed methods that need to be reported to the GC to keep the objects alive and possibly track their movement if the GC decides to compact the heap).</li>
    <li>On some platforms the stack walker is used during the <strong>processing of exceptions</strong> (looking for handlers in the first pass and unwinding the stack in the second).</li>
    <li>The <strong>debugger uses the functionality</strong> when generating managed stack traces.</li>
    <li>Various miscellaneous methods, usually those close to some public managed API, perform a stack walk <strong>to pick up information about their caller</strong> (such as the method, class or assembly of that caller).</li>
  </ul>
</blockquote>

<p><strong>The rest of this post will explore what ‚ÄòStack Walking‚Äô is, how it works and why so many parts of the runtime need to be involved.</strong></p>

<hr>

<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#where-does-the-clr-use-stack-walking">Where does the CLR use ‚ÄòStack Walking‚Äô?</a>
    <ul>
      <li><a href="#common-scenarios">Common Scenarios</a></li>
      <li><a href="#debuggingdiagnostics">Debugging/Diagnostics</a></li>
      <li><a href="#obscure-scenarios">Obscure Scenarios</a></li>
      <li><a href="#stack-crawl-marks">Stack Crawl Marks</a></li>
      <li><a href="#exception-handling">Exception Handling</a></li>
    </ul>
  </li>
  <li><a href="#the-stack-walking-api">The ‚ÄòStack Walking‚Äô API</a>
    <ul>
      <li><a href="#how-to-use-it">How to use it</a></li>
      <li><a href="#how-it-works">How it works</a></li>
      <li><a href="#see-it-in-action">See it ‚Äòin Action‚Äô</a></li>
    </ul>
  </li>
  <li><a href="#unwinding-native-code">Unwinding ‚ÄòNative‚Äô Code</a>
    <ul>
      <li><a href="#frames">Frames</a></li>
      <li><a href="#helper-method-frames">‚ÄòHelper Method‚Äô Frames</a></li>
      <li><a href="#native-unwind-information">Native Unwind Information</a></li>
      <li><a href="#differences-between-windows-and-unix">Differences between Windows and Unix</a></li>
    </ul>
  </li>
  <li><a href="#unwinding-jitted-code">Unwinding ‚ÄòJITted‚Äô Code</a>
    <ul>
      <li><a href="#help-from-the-jit-compiler">Help from the ‚ÄòJIT Compiler‚Äô</a></li>
    </ul>
  </li>
  <li><a href="#further-reading">Further Reading</a>
    <ul>
      <li><a href="#stack-unwinding-general">Stack Unwinding (general)</a></li>
      <li><a href="#stack-unwinding-other-runtimes">Stack Unwinding (other runtimes)</a></li>
    </ul>
  </li>
</ul>

<hr>

<h2 id="where-does-the-clr-use-stack-walking">Where does the CLR use ‚ÄòStack Walking‚Äô?</h2>

<p>Before we dig into the ‚Äòinternals‚Äô, let‚Äôs take a look at where the runtime utilises ‚Äòstack walking‚Äô, below is the full list (as of .NET Core CLR ‚ÄòRelease 2.2‚Äô). All these examples end up calling into the <code>Thread::StackWalkFrames(..)</code> method <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L978-L1042">here</a> and provide a <code>callback</code> that is triggered whenever the API encounters a new section of the stack (see <a href="#how-to-use-it">How to use it</a> below for more info).</p>

<h3 id="common-scenarios">Common Scenarios</h3>

<ul>
  <li><strong>Garbage Collection (GC)</strong>
    <ul>
      <li><code>ScanStackRoots(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/gcenv.ee.cpp#L71-L151">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/gcenv.ee.common.cpp#L184-L293">callback</a></li>
    </ul>
  </li>
  <li><strong>Exception Handling</strong> (unwinding)
    <ul>
      <li><code>x86</code> - <code>UnwindFrames(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/excep.cpp#L2199-L2232">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/i386/excepx86.cpp#L2718-L3119">callback</a></li>
      <li><code>x64</code> - <code>ResetThreadAbortState(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/excep.cpp#L12770-L12868">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/excep.cpp#L12728-L12767">callback</a></li>
    </ul>
  </li>
  <li><strong>Exception Handling</strong> (resumption):
    <ul>
      <li><code>ExceptionTracker::FindNonvolatileRegisterPointers(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/exceptionhandling.cpp#L357-L436">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/exceptionhandling.cpp#L249-L354">callback</a></li>
      <li><code>ExceptionTracker::RareFindParentStackFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/exceptionhandling.cpp#L6991-L7031">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/exceptionhandling.cpp#L6924-L6989">callback</a></li>
    </ul>
  </li>
  <li><strong>Threads</strong>:
    <ul>
      <li><code>Thread::IsRunningIn(..)</code> (AppDomain) <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threads.cpp#L8402-L8428">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threads.cpp#L8368-L8396">callback</a></li>
      <li><code>Thread::DetectHandleILStubsForDebugger(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threads.cpp#L219-L282">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threads.cpp#L205-L217">callback</a></li>
    </ul>
  </li>
  <li><strong>Thread Suspension</strong>:
    <ul>
      <li><code>Thread::IsExecutingWithinCer()</code> (‚ÄòConstrained Execution Region‚Äô) <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threadsuspend.cpp#L962-L1006">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threadsuspend.cpp#L831-L960">wrapper</a> and <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threadsuspend.cpp#L672-L829">callback</a>)</li>
      <li><code>Thread::HandledJITCase(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threadsuspend.cpp#L6853-L6975">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threadsuspend.cpp#L6130-L6312">callback</a>, <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threadsuspend.cpp#L6498-L6544">alternative callback</a></li>
    </ul>
  </li>
</ul>

<h3 id="debuggingdiagnostics">Debugging/Diagnostics</h3>

<ul>
  <li><strong>Debugger</strong>
    <ul>
      <li><code>DebuggerWalkStack(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/debug/ee/frameinfo.cpp#L2061-L2188">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/debug/ee/frameinfo.cpp#L1367-L1874">callback</a></li>
      <li><code>DebuggerWalkStackProc()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/debug/ee/frameinfo.cpp#L1367-L1874">here</a> (called from <code>DebuggerWalkStack(..)</code>) -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/debug/ee/frameinfo.cpp#L952-L1240">callback</a></li>
    </ul>
  </li>
  <li><strong>Managed APIs</strong> (e.g  <code>System.Diagnostics.StackTrace</code>)
    <ul>
      <li>Managed code calls via an <code>InternalCall</code> (C#) <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/mscorlib/src/System/Diagnostics/Stacktrace.cs#L317-L318">here</a> into <code>DebugStackTrace::GetStackFramesInternal(..)</code> (C++) <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/debugdebugger.cpp#L327-L800">here</a></li>
      <li>Before ending up in <code>DebugStackTrace::GetStackFramesHelper(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/debugdebugger.cpp#L852-L956">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/debugdebugger.cpp#L976-L1060">callback</a></li>
    </ul>
  </li>
  <li><strong>DAC (via by SOS)</strong> - Scan for GC ‚ÄòRoots‚Äô
    <ul>
      <li><code>DacStackReferenceWalker::WalkStack&lt;..&gt;(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/debug/daccess/dacimpl.h#L1973-L2022">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/debug/daccess/daccess.cpp#L8466-L8638">callback</a></li>
    </ul>
  </li>
  <li><strong>Profiling API</strong>
    <ul>
      <li><code>ProfToEEInterfaceImpl::ProfilerStackWalkFramesWrapper(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/proftoeeinterfaceimpl.cpp#L7624-L7652">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/proftoeeinterfaceimpl.cpp#L7177-L7286">callback</a></li>
    </ul>
  </li>
  <li><strong>Event Pipe</strong> (Diagnostics)
    <ul>
      <li><code>EventPipe::WalkManagedStackForThread(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eventpipe.cpp#L971-L994">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eventpipe.cpp#L996-L1029">callback</a></li>
    </ul>
  </li>
  <li><strong>CLR prints a Stack Trace</strong> (to the console/log, DEBUG builds only)
    <ul>
      <li><code>PrintStackTrace()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/debughelp.cpp#L1015-L1109">here</a> (and other functions) -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/debughelp.cpp#L881-L1013">callback</a></li>
    </ul>
  </li>
</ul>

<h3 id="obscure-scenarios">Obscure Scenarios</h3>

<ul>
  <li><strong>Reflection</strong>
    <ul>
      <li><code>RuntimeMethodHandle::GetCurrentMethod(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/reflectioninvocation.cpp#L1487-L1511">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/reflectioninvocation.cpp#L1449-L1485">callback</a>)</li>
    </ul>
  </li>
  <li><strong>Application (App) Domains</strong> (See ‚ÄòStack Crawl Marks‚Äô below)
    <ul>
      <li><code>SystemDomain::GetCallersMethod(..)</code>  <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/appdomain.cpp#L3389-L3417">here</a> (also <code>GetCallersType(..)</code> and <code>GetCallersModule(..)</code>) (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/appdomain.cpp#L3520-L3664">callback</a>)</li>
      <li><code>SystemDomain::GetCallersModule(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/appdomain.cpp#L3494-L3518">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/appdomain.cpp#L3666-L3686">callback</a>)</li>
    </ul>
  </li>
  <li><strong>‚ÄòCode Pitching‚Äô</strong>
    <ul>
      <li><code>CheckStacksAndPitch()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codepitchingmanager.cpp#L446-L501">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codepitchingmanager.cpp#L340-L347">wrapper</a> and <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codepitchingmanager.cpp#L304-L338">callback</a>)</li>
    </ul>
  </li>
  <li><strong>Extensible Class Factory</strong> (<code>System.Runtime.InteropServices.ExtensibleClassFactory</code>)
    <ul>
      <li><code>RegisterObjectCreationCallback(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/extensibleclassfactory.cpp#L72-L130">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/extensibleclassfactory.cpp#L23-L69">callback</a>)</li>
    </ul>
  </li>
  <li><strong>Stack Sampler</strong> (unused?)
    <ul>
      <li><code>StackSampler::ThreadProc()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stacksampler.cpp#L264-L331">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stacksampler.cpp#L217-L224">wrapper</a> and <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stacksampler.cpp#L226-L262">callback</a>)</li>
    </ul>
  </li>
</ul>

<h3 id="stack-crawl-marks">Stack Crawl Marks</h3>

<p>One of the above scenarios deserves a closer look, but firstly why are ‚Äòstack crawl marks‚Äô used, from <a href="https://github.com/dotnet/coreclr/issues/21629#issuecomment-449225852">coreclr/issues/#21629 (comment)</a>:</p>

<blockquote>
  <p>Unfortunately, there is a ton of legacy APIs that were added during netstandard2.0 push whose behavior depend on the caller. <strong>The caller is basically passed in as an implicit argument to the API</strong>. Most of these StackCrawlMarks are there to support these APIs‚Ä¶</p>
</blockquote>

<p>So we can see that multiple functions within the CLR itself need to have knowledge of their <strong>caller</strong>. To understand this some more, let‚Äôs look an example, the <code>GetType(string typeName)</code> <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.gettype?view=netframework-4.7.2#System_Type_GetType_System_String_">method</a>. Here‚Äôs the flow from the externally-visible method all the way down to where the work is done, note how a <code>StackCrawlMark</code> instance is passed through:</p>

<ul>
  <li><code>Type::GetType(string typeName)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/System.Private.CoreLib/src/System/Type.CoreCLR.cs#L38-L43">implementation</a> (Creates <code>StackCrawlMark.LookForMyCaller</code>)</li>
  <li><code>RuntimeType::GetType(.., ref StackCrawlMark stackMark)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/System.Private.CoreLib/src/System/RtType.cs#L1741-L1749">implementation</a></li>
  <li><code>RuntimeType::GetTypeByName(.., ref StackCrawlMark stackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/System.Private.CoreLib/src/System/RuntimeHandles.cs#L431-L459">implementation</a></li>
  <li><code>extern void GetTypeByName(.., ref StackCrawlMark stackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/System.Private.CoreLib/src/System/RuntimeHandles.cs#L426-L429">definition</a> (call into native code, i.e. <code>[DllImport(JitHelpers.QCall, ..)]</code>)</li>
  <li><code>RuntimeTypeHandle::GetTypeByName(.., QCall::StackCrawlMarkHandle pStackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/runtimehandles.cpp#L1433-L1463">implementation</a></li>
  <li><code>TypeHandle TypeName::GetTypeManaged(.., StackCrawlMark* pStackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/typeparse.cpp#L1178-L1271">implementation</a></li>
  <li><code>TypeHandle TypeName::GetTypeWorker(.. , StackCrawlMark* pStackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/typeparse.cpp#L1405-L1662">implementation</a></li>
  <li><code>SystemDomain::GetCallersAssembly(StackCrawlMark *stackMark,..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/appdomain.cpp#L3430-L3438">implementation</a></li>
  <li><code>SystemDomain::GetCallersModule(StackCrawlMark* stackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/appdomain.cpp#L3394-L3421">implementation</a></li>
  <li><code>SystemDomain::CallersMethodCallbackWithStackMark(..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/appdomain.cpp#L3467-L3610">callback implementation</a></li>
</ul>

<p>In addition the JIT (via the VM) has to ensure that all relevant methods are available in the call-stack, i.e. they can‚Äôt be removed:</p>

<ul>
  <li>Prevent in-lining <code>CEEInfo::canInline(..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/jitinterface.cpp#L7847-L7854">implementation</a></li>
  <li>Prevent removal via a ‚Äòtail call‚Äô <code>CEEInfo::canTailCall(..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/jitinterface.cpp#L8321-L8332">implementation</a></li>
</ul>

<p>However, the <code>StackCrawlMark</code> feature is currently being <em>cleaned</em> up, so it may look different in the future:</p>

<ul>
  <li><a href="https://github.com/dotnet/coreclr/pull/9342">Remove NoInlining/StackCrawlMarks from Tasks</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/21812">Remove stack marks from GetSatelliteAssembly</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/21054">Delete unnecessary StackCrawlMarks in RtFieldInfo</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/21783">Avoid passing stack crawl mark unnecessarily deep in the call stack</a> (the example shown above!!)</li>
</ul>

<h3 id="exception-handling">Exception Handling</h3>

<p>The place that most .NET Developers will run into ‚Äòstack traces‚Äô is when dealing with exceptions. I originally intended to also describe ‚Äòexception handling‚Äô here, but then I opened up <a href="https://github.com/dotnet/coreclr/blob/master/src/vm/exceptionhandling.cpp">/src/vm/exceptionhandling.cpp</a> and saw that it contained <strong>over 7,000</strong> lines of code!! So I decided that it can wait for a future post üòÅ.</p>

<p>However, if you want to learn more about the ‚Äòinternals‚Äô I really recommend Chris Brumme‚Äôs post <a href="https://blogs.msdn.microsoft.com/cbrumme/2003/10/01/the-exception-model/">The Exception Model</a> (2003) which is the definitive guide on the topic (also see his <a href="https://channel9.msdn.com/Search?term=Christopher%20Brumme&amp;lang-en=true">Channel9 Videos</a>) and as always, the ‚ÄòBotR‚Äô chapter <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md">‚ÄòWhat Every (<em>Runtime</em>) Dev needs to Know About Exceptions in the Runtime‚Äô</a> is well worth a read.</p>

<p>Also, I recommend talking a look at the slides from the <a href="https://blog.adamfurmanek.pl/wp-content/uploads/2018/06/Internals_of_exceptions.pdf">‚ÄòInternals of Exceptions‚Äô talk‚Äô</a> and the related post <a href="https://blog.adamfurmanek.pl/blog/2016/10/01/handling-and-rethrowing-exceptions-in-c/">.NET Inside Out Part 2 ‚Äî Handling and rethrowing exceptions in C#</a> both by <a href="https://twitter.com/furmanekadam">Adam Furmanek</a>.</p>

<hr>

<h2 id="the-stack-walking-api">The ‚ÄòStack Walking‚Äô API</h2>

<p>Now that we‚Äôve seen <em>where</em> it‚Äôs used, let‚Äôs look at the ‚Äòstack walking‚Äô API itself. Firstly, <em>how</em> is it used?</p>

<h3 id="how-to-use-it">How to use it</h3>

<p>It‚Äôs worth pointing out that the only way you can access it from C#/F#/VB.NET code is via the <code>StackTrace</code> <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.stacktrace?view=netframework-4.7.2">class</a>, only the runtime itself can call into <code>Thread::StackWalkFrames(..)</code> directly. The simplest usage in the runtime is <code>EventPipe::WalkManagedStackForThread(..)</code> (see <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eventpipe.cpp#L971-L994">here</a>), which is shown below. As you can see it‚Äôs as simple as specifying the relevant flags, in this case <code>ALLOW_ASYNC_STACK_WALK | FUNCTIONSONLY | HANDLESKIPPEDFRAMES | ALLOW_INVALID_OBJECTS</code> and then providing the callback, which in the EventPipe class is the <code>StackWalkCallback</code> method (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eventpipe.cpp#L996-L102">here</a>)</p>

<div><div><pre><code><span>bool</span> <span>EventPipe</span><span>::</span><span>WalkManagedStackForThread</span><span>(</span><span>Thread</span> <span>*</span><span>pThread</span><span>,</span> <span>StackContents</span> <span>&amp;</span><span>stackContents</span><span>)</span>
<span>{</span>
    <span>CONTRACTL</span>
    <span>{</span>
        <span>NOTHROW</span><span>;</span>
        <span>GC_NOTRIGGER</span><span>;</span>
        <span>MODE_ANY</span><span>;</span>
        <span>PRECONDITION</span><span>(</span><span>pThread</span> <span>!=</span> <span>NULL</span><span>);</span>
    <span>}</span>
    <span>CONTRACTL_END</span><span>;</span>

    <span>// Calling into StackWalkFrames in preemptive mode violates the host contract,</span>
    <span>// but this contract is not used on CoreCLR.</span>
    <span>CONTRACT_VIOLATION</span><span>(</span> <span>HostViolation</span> <span>);</span>

    <span>stackContents</span><span>.</span><span>Reset</span><span>();</span>

    <span>StackWalkAction</span> <span>swaRet</span> <span>=</span> <span>pThread</span><span>-&gt;</span><span>StackWalkFrames</span><span>(</span>
        <span>(</span><span>PSTACKWALKFRAMESCALLBACK</span><span>)</span> <span>&amp;</span><span>StackWalkCallback</span><span>,</span>
        <span>&amp;</span><span>stackContents</span><span>,</span>
        <span>ALLOW_ASYNC_STACK_WALK</span> <span>|</span> <span>FUNCTIONSONLY</span> <span>|</span> <span>HANDLESKIPPEDFRAMES</span> <span>|</span> <span>ALLOW_INVALID_OBJECTS</span><span>);</span>

    <span>return</span> <span>((</span><span>swaRet</span> <span>==</span> <span>SWA_DONE</span><span>)</span> <span>||</span> <span>(</span><span>swaRet</span> <span>==</span> <span>SWA_CONTINUE</span><span>));</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>StackWalkFrame(..)</code> function then does the <em>heavy-lifting</em> of actually walking the stack, before triggering the callback shown below. In this case it just records the ‚ÄòInstruction Pointer‚Äô (IP/CP) and the ‚Äòmanaged function‚Äô, which is an instance of the <code>MethodDesc</code> obtained via the <code>pCf-&gt;GetFunction()</code> call:</p>

<div><div><pre><code><span>StackWalkAction</span> <span>EventPipe</span><span>::</span><span>StackWalkCallback</span><span>(</span><span>CrawlFrame</span> <span>*</span><span>pCf</span><span>,</span> <span>StackContents</span> <span>*</span><span>pData</span><span>)</span>
<span>{</span>
    <span>CONTRACTL</span>
    <span>{</span>
        <span>NOTHROW</span><span>;</span>
        <span>GC_NOTRIGGER</span><span>;</span>
        <span>MODE_ANY</span><span>;</span>
        <span>PRECONDITION</span><span>(</span><span>pCf</span> <span>!=</span> <span>NULL</span><span>);</span>
        <span>PRECONDITION</span><span>(</span><span>pData</span> <span>!=</span> <span>NULL</span><span>);</span>
    <span>}</span>
    <span>CONTRACTL_END</span><span>;</span>

    <span>// Get the IP.</span>
    <span>UINT_PTR</span> <span>controlPC</span> <span>=</span> <span>(</span><span>UINT_PTR</span><span>)</span><span>pCf</span><span>-&gt;</span><span>GetRegisterSet</span><span>()</span><span>-&gt;</span><span>ControlPC</span><span>;</span>
    <span>if</span> <span>(</span><span>controlPC</span> <span>==</span> <span>0</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>pData</span><span>-&gt;</span><span>GetLength</span><span>()</span> <span>==</span> <span>0</span><span>)</span>
        <span>{</span>
            <span>// This happens for pinvoke stubs on the top of the stack.</span>
            <span>return</span> <span>SWA_CONTINUE</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>_ASSERTE</span><span>(</span><span>controlPC</span> <span>!=</span> <span>0</span><span>);</span>

    <span>// Add the IP to the captured stack.</span>
    <span>pData</span><span>-&gt;</span><span>Append</span><span>(</span><span>controlPC</span><span>,</span> <span>pCf</span><span>-&gt;</span><span>GetFunction</span><span>());</span>

    <span>// Continue the stack walk.</span>
    <span>return</span> <span>SWA_CONTINUE</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h3 id="how-it-works">How it works</h3>

<p>Now onto the most interesting part, how to the runtime actually walks the stack. Well, first let‚Äôs understand what the stack looks like, from the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/stackwalking.md">‚ÄòBotR‚Äô page</a>:</p>

<p><img src="https://mattwarren.org/images/2019/01/Stack%20Description%20from%20BotR.png" alt="Stack Description from BotR"></p>

<p>The main thing to note is that a .NET ‚Äòstack‚Äô can contain 3 types of methods:</p>

<ol>
  <li><strong>Managed</strong> - this represents code that started off as C#/F#/VB.NET, was turned into IL and then finally compiled to native code by the ‚ÄòJIT Compiler‚Äô.</li>
  <li><strong>Unmanaged</strong> - completely <em>native</em> code that exists outside of the runtime, i.e. a OS function the runtime calls into or a user call via <code>P/Invoke</code>. The runtime <em>only</em> cares about transitions <em>into</em> or <em>out of</em> regular unmanaged code, is doesn‚Äôt care about the stack frame within it.</li>
  <li><strong>Runtime Managed</strong> - still <em>native</em> code, but this is slightly different because the runtime case more about this code. For example there are quite a few parts of the Base-Class libraries that make use of <code>InternalCall</code> methods, for more on this see the <a href="#helper-method-frames">‚ÄòHelper Method‚Äô Frames</a> section later on.</li>
</ol>

<p>So the ‚Äòstack walk‚Äô has to deal with these different scenarios as it proceeds. Now let‚Äôs look at the ‚Äòcode flow‚Äô starting with the entry-point method <code>StackWalkFrames(..)</code>:</p>

<ul>
  <li><code>Thread::StackWalkFrames(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L978-L1042">here</a>
    <ul>
      <li>the entry-point function, the type of ‚Äòstack walk‚Äô can be controlled via <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threads.h#L3302-L3361">these flags</a></li>
    </ul>
  </li>
  <li><code>Thread::StackWalkFramesEx(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L899-L976">here</a>
    <ul>
      <li>worker-function that sets up the <code>StackFrameIterator</code>, via a call to <code>StackFrameIterator::Init(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L1150-L1274">here</a></li>
    </ul>
  </li>
  <li><code>StackFrameIterator::Next()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L1586-L1621">here</a>, then hands off to the primary <em>worker</em> method <code>StackFrameIterator::NextRaw()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L2291-L2761">here</a> that does 5 things:
    <ol>
      <li><code>CheckForSkippedFrames(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L3009-L3119">here</a>, deals with frames that may have been allocated inside a managed stack frame (e.g. an inlined p/invoke call).</li>
      <li><code>UnwindStackFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eetwain.cpp#L4162-L4214">here</a>, in-turn calls:
        <ul>
          <li><strong><code>x64</code></strong> - <code>Thread::VirtualUnwindCallFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L553-L671">here</a>, then calls <code>VirtualUnwindNonLeafCallFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L711-L757">here</a> or <code>VirtualUnwindLeafCallFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L676-L708">here</a>. All of of these functions make use of the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/nf-winnt-rtllookupfunctionentry">Windows API function</a> <code>RtlLookupFunctionEntry(..)</code> to do the actual unwinding.</li>
          <li><strong><code>x86</code></strong> - <code>::UnwindStackFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eetwain.cpp#L4012-L4107">here</a>, in turn calls <code>UnwindEpilog(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eetwain.cpp#L3528-L3557">here</a> and <code>UnwindEspFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eetwain.cpp#L3663-L3721">here</a>. Unlike <code>x64</code>, under <code>x86</code> all the ‚Äòstack-unwinding‚Äô is done manually, within the CLR code.</li>
        </ul>
      </li>
      <li><code>PostProcessingForManagedFrames(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L3193-L3229">here</a>, determines if the stack-walk is actually within a <strong>managed method</strong> rather than a <strong>native frame</strong>.</li>
      <li><code>ProcessIp(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L2786-L2800">here</a> has the job of looking up the current <strong>managed method</strong> (if any) based on the current <strong>instruction pointer</strong> (IP). It does this by calling into  <code>EECodeInfo::Init(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/jitinterface.cpp#L13948-L13976">here</a> and then ends up in one of:
        <ul>
          <li><code>EEJitManager::JitCodeToMethodInfo(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codeman.cpp#L3631-L3676">here</a>, that uses a very cool looking data structure refereed to as a <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/inc/nibblemapmacros.h#L12-L26">‚Äònibble map‚Äô</a></li>
          <li><code>NativeImageJitManager::JitCodeToMethodInfo(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codeman.cpp#L5428-L5616">here</a></li>
          <li><code>ReadyToRunJitManager::JitCodeToMethodInfo(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codeman.cpp#L6875-L6953">here</a></li>
        </ul>
      </li>
      <li><code>ProcessCurrentFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L2802-L3007">here</a>, does some final house-keeping and tidy-up.</li>
    </ol>
  </li>
  <li><code>CrawlFrame::GotoNextFrame()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L369-L390">here</a>
    <ul>
      <li>in-turn calls <code>pFrame-&gt;Next()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/frames.h#L836-L840">here</a> to walk through the ‚Äòlinked list‚Äô of frames which drive the ‚Äòstack walk‚Äô (more on these ‚Äòframes‚Äô later)</li>
    </ul>
  </li>
  <li><code>StackFrameIterator::Filter()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L1623-L2289">here</a>
    <ul>
      <li>essentially a <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L1677-L2271">huge <code>switch</code> statement</a> that handles all the different <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.h#L602-L613">Frame States</a> and decides whether or not the ‚Äòstack walk‚Äô should continue.</li>
    </ul>
  </li>
</ul>

<p>When it gets a valid frame it triggers the callback in <code>Thread::MakeStackwalkerCallback(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L859-L891">here</a> and passes in a pointer to the current <code>CrawlFrame</code> class <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.h#L68-L496">defined here</a>, this exposes methods such as <code>IsFrameless()</code>, <code>GetFunction()</code> and <code>GetThisPointer()</code>. The <code>CrawlFrame</code> actually represents 2 scenarios, based on the current IP:</p>

<ul>
  <li><strong>Native</strong> code, represented by a <code>Frame</code> class <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/frames.h#L378-L284">defined here</a>, which we‚Äôll discuss more in a moment.</li>
  <li><strong>Managed</strong> code, well technically ‚Äòmanaged code‚Äô that was JITted to ‚Äònative code‚Äô, so more accurately a <strong>managed stack frame</strong>. In this situation the <code>MethodDesc</code> class <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/method.hpp#L187-L1879">defined here</a> is provided, you can read more about this key CLR data-structure in <a href="https://github.com/dotnet/coreclr/blob/release/2.2/Documentation/botr/method-descriptor.md">the corresponding BotR chapter</a>.</li>
</ul>

<h3 id="see-it-in-action">See it ‚Äòin Action‚Äô</h3>

<p>Fortunately we‚Äôre able to turn on some nice diagnostics in a debug build of the CLR (<code>COMPLUS_LogEnable</code>, <code>COMPLUS_LogToFile</code> &amp; <code>COMPLUS_LogFacility</code>). With that in place, given C# code like this:</p>

<div><div><pre><code><span>internal</span> <span>class</span> <span>Program</span> <span>{</span>
    <span>private</span> <span>static</span> <span>void</span> <span>Main</span><span>()</span> <span>{</span>
        <span>MethodA</span><span>();</span>
    <span>}</span>

    <span>[</span><span>MethodImpl</span><span>(</span><span>MethodImplOptions</span><span>.</span><span>NoInlining</span><span>)]</span>
    <span>private</span> <span>void</span> <span>MethodA</span><span>()</span> <span>{</span>
        <span>MethodB</span><span>();</span>
    <span>}</span>
    
    <span>[</span><span>MethodImpl</span><span>(</span><span>MethodImplOptions</span><span>.</span><span>NoInlining</span><span>)]</span>
    <span>private</span> <span>void</span> <span>MethodB</span><span>()</span> <span>{</span>
        <span>MethodC</span><span>();</span>
    <span>}</span>
    
    <span>[</span><span>MethodImpl</span><span>(</span><span>MethodImplOptions</span><span>.</span><span>NoInlining</span><span>)]</span>
    <span>private</span> <span>void</span> <span>MethodC</span><span>()</span> <span>{</span>
        <span>var</span> <span>stackTrace</span> <span>=</span> <span>new</span> <span>StackTrace</span><span>(</span><span>fNeedFileInfo</span><span>:</span> <span>true</span><span>);</span>
        <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>stackTrace</span><span>.</span><span>ToString</span><span>());</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>We get the output shown below, in which you can see the ‚Äòstack walking‚Äô process. It starts in <code>InitializeSourceInfo</code> and <code>CaptureStackTrace</code> which are methods internal to the <code>StackTrace</code> class (see <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/mscorlib/src/System/Diagnostics/Stacktrace.cs#L351-L407">here</a>), before moving up the stack <code>MethodC</code> -&gt; <code>MethodB</code> -&gt; <code>MethodA</code> and then finally stopping in the <code>Main</code> function. Along the way its does a ‚ÄòFILTER‚Äô and ‚ÄòCONSIDER‚Äô step before actually unwinding (‚Äòfinished unwind for ‚Ä¶‚Äô):</p>

<div><div><pre><code>TID 4740: STACKWALK    starting with partial context
TID 4740: STACKWALK: [000] FILTER  : EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cc48  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [001] CONSIDER: EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cc48  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [001] FILTER  : EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cc48  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [002] CONSIDER: EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cdd8  vtbl= 00007ffd`74995220 
TID 4740: STACKWALK    LazyMachState::unwindLazyState(ip:00007FFD7439C45C,sp:000000029977C338)
TID 4740: STACKWALK: [002] CALLBACK: EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cdd8  vtbl= 00007ffd`74995220 
TID 4740: STACKWALK    HelperMethodFrame::UpdateRegDisplay cached ip:00007FFD72FE9258, sp:000000029977D300
TID 4740: STACKWALK: [003] CONSIDER: FRAMELESS: PC= 00007ffd`72fe9258  SP= 00000002`9977d300  method=InitializeSourceInfo 
TID 4740: STACKWALK: [003] CALLBACK: FRAMELESS: PC= 00007ffd`72fe9258  SP= 00000002`9977d300  method=InitializeSourceInfo 
TID 4740: STACKWALK: [004] about to unwind for 'InitializeSourceInfo', SP: 00000002`9977d300 , IP: 00007ffd`72fe9258 
TID 4740: STACKWALK: [004] finished unwind for 'InitializeSourceInfo', SP: 00000002`9977d480 , IP: 00007ffd`72eeb671 
TID 4740: STACKWALK: [004] CONSIDER: FRAMELESS: PC= 00007ffd`72eeb671  SP= 00000002`9977d480  method=CaptureStackTrace 
TID 4740: STACKWALK: [004] CALLBACK: FRAMELESS: PC= 00007ffd`72eeb671  SP= 00000002`9977d480  method=CaptureStackTrace 
TID 4740: STACKWALK: [005] about to unwind for 'CaptureStackTrace', SP: 00000002`9977d480 , IP: 00007ffd`72eeb671 
TID 4740: STACKWALK: [005] finished unwind for 'CaptureStackTrace', SP: 00000002`9977d5b0 , IP: 00007ffd`72eeadd0 
TID 4740: STACKWALK: [005] CONSIDER: FRAMELESS: PC= 00007ffd`72eeadd0  SP= 00000002`9977d5b0  method=.ctor 
TID 4740: STACKWALK: [005] CALLBACK: FRAMELESS: PC= 00007ffd`72eeadd0  SP= 00000002`9977d5b0  method=.ctor 
TID 4740: STACKWALK: [006] about to unwind for '.ctor', SP: 00000002`9977d5b0 , IP: 00007ffd`72eeadd0 
TID 4740: STACKWALK: [006] finished unwind for '.ctor', SP: 00000002`9977d5f0 , IP: 00007ffd`14c620d3 
TID 4740: STACKWALK: [006] CONSIDER: FRAMELESS: PC= 00007ffd`14c620d3  SP= 00000002`9977d5f0  method=MethodC 
TID 4740: STACKWALK: [006] CALLBACK: FRAMELESS: PC= 00007ffd`14c620d3  SP= 00000002`9977d5f0  method=MethodC 
TID 4740: STACKWALK: [007] about to unwind for 'MethodC', SP: 00000002`9977d5f0 , IP: 00007ffd`14c620d3 
TID 4740: STACKWALK: [007] finished unwind for 'MethodC', SP: 00000002`9977d630 , IP: 00007ffd`14c62066 
TID 4740: STACKWALK: [007] CONSIDER: FRAMELESS: PC= 00007ffd`14c62066  SP= 00000002`9977d630  method=MethodB 
TID 4740: STACKWALK: [007] CALLBACK: FRAMELESS: PC= 00007ffd`14c62066  SP= 00000002`9977d630  method=MethodB 
TID 4740: STACKWALK: [008] about to unwind for 'MethodB', SP: 00000002`9977d630 , IP: 00007ffd`14c62066 
TID 4740: STACKWALK: [008] finished unwind for 'MethodB', SP: 00000002`9977d660 , IP: 00007ffd`14c62016 
TID 4740: STACKWALK: [008] CONSIDER: FRAMELESS: PC= 00007ffd`14c62016  SP= 00000002`9977d660  method=MethodA 
TID 4740: STACKWALK: [008] CALLBACK: FRAMELESS: PC= 00007ffd`14c62016  SP= 00000002`9977d660  method=MethodA 
TID 4740: STACKWALK: [009] about to unwind for 'MethodA', SP: 00000002`9977d660 , IP: 00007ffd`14c62016 
TID 4740: STACKWALK: [009] finished unwind for 'MethodA', SP: 00000002`9977d690 , IP: 00007ffd`14c61f65 
TID 4740: STACKWALK: [009] CONSIDER: FRAMELESS: PC= 00007ffd`14c61f65  SP= 00000002`9977d690  method=Main 
TID 4740: STACKWALK: [009] CALLBACK: FRAMELESS: PC= 00007ffd`14c61f65  SP= 00000002`9977d690  method=Main 
TID 4740: STACKWALK: [00a] about to unwind for 'Main', SP: 00000002`9977d690 , IP: 00007ffd`14c61f65 
TID 4740: STACKWALK: [00a] finished unwind for 'Main', SP: 00000002`9977d6d0 , IP: 00007ffd`742f9073 
TID 4740: STACKWALK: [00a] FILTER  : NATIVE   : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0 
TID 4740: STACKWALK: [00b] CONSIDER: EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977de58  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [00b] FILTER  : EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977de58  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [00c] CONSIDER: EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977e7e0  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [00c] FILTER  : EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977e7e0  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: SWA_DONE: reached the end of the stack
</code></pre></div></div>

<p>To find out more, you can search for these diagnostic message in <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp">\vm\stackwalk.cpp</a>, e.g. in <code>Thread::DebugLogStackWalkInfo(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L802-L856">here</a></p>

<hr>

<h2 id="unwinding-native-code">Unwinding ‚ÄòNative‚Äô Code</h2>

<p>As explained in <a href="https://science.raphael.poss.name/go-calling-convention-x86-64.html#aside-exceptions-in-c-c">this excellent article</a>:</p>

<blockquote>
  <p>There are fundamentally two main ways to implement exception propagation in an ABI (Application Binary Interface):</p>

  <ul>
    <li>
      <p>‚Äúdynamic registration‚Äù, <strong>with frame pointers in each activation record, organized as a linked list</strong>. This makes stack unwinding fast at the expense of having to set up the frame pointer in each function that calls other functions. This is also simpler to implement.</p>
    </li>
    <li>
      <p>‚Äútable-driven‚Äù, <strong>where the compiler and assembler create data structures alongside the program code to indicate which addresses of code correspond to which sizes of activation records</strong>. This is called ‚ÄúCall Frame Information‚Äù (CFI) data in e.g. the GNU tool chain. When an exception is generated, the data in this table is loaded to determine how to unwind. This makes exception propagation slower but the general case faster.</p>
    </li>
  </ul>
</blockquote>

<p>It turns out that .NET uses the ‚Äòtable-driven‚Äô approach, for the reason explained in the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/stackwalking.md#the-stack-model">‚ÄòBotR‚Äô</a>:</p>

<blockquote>
  <p>The exact definition of a frame varies from platform to platform and <strong>on many platforms there isn‚Äôt a hard definition of a frame format that all functions adhere to</strong> (x86 is an example of this). Instead the compiler is often free to optimize the exact format of frames. On such systems it is not possible to guarantee that a stackwalk will return 100% correct or complete results (for debugging purposes, debug symbols such as pdbs are used to fill in the gaps so that debuggers can generate more accurate stack traces).</p>

  <p>This is not a problem for the CLR, however, since we do not require a fully generalized stack walk. <strong>Instead we are only interested in those frames that are managed (i.e. represent a managed method) or, to some extent, frames coming from unmanaged code used to implement part of the runtime itself</strong>. In particular there is no guarantee about fidelity of 3rd party unmanaged frames other than to note where such frames transition into or out of the runtime itself (i.e. one of the frame types we do care about).</p>
</blockquote>

<h3 id="frames">Frames</h3>

<p>To enable ‚Äòunwinding‚Äô of native code or more strictly the transitions ‚Äòinto‚Äô and ‚Äòout of‚Äô native code, the CLR uses a mechanism of <code>Frames</code>, which are defined in the source code <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/frames.h#L7-L143">here</a>. These frames are arranged into a hierachy and there is one type of <code>Frame</code> for each scenario, for more info on these individual <code>Frames</code> take a look at the excellent source-code comments <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/frames.h#L145-L195">here</a>.</p>

<ul>
  <li><strong>Frame</strong> (abstract/base class)
    <ul>
      <li><strong>GCFrame</strong></li>
      <li><strong>FaultingExceptionFrame</strong></li>
      <li><strong>HijackFrame</strong></li>
      <li><strong>ResumableFrame</strong>
        <ul>
          <li>RedirectedThreadFrame</li>
        </ul>
      </li>
      <li><strong>InlinedCallFrame</strong></li>
      <li><strong>HelperMethodFrame</strong>
        <ul>
          <li>HelperMethodFrame_1OBJ</li>
          <li>HelperMethodFrame_2OBJ</li>
          <li>HelperMethodFrame_3OBJ</li>
          <li>HelperMethodFrame_PROTECTOBJ</li>
        </ul>
      </li>
      <li><strong>TransitionFrame</strong>
        <ul>
          <li>StubHelperFrame</li>
          <li>SecureDelegateFrame
            <ul>
              <li>MulticastFrame</li>
            </ul>
          </li>
          <li>FramedMethodFrame
            <ul>
              <li>ComPlusMethodFrame</li>
              <li>PInvokeCalliFrame</li>
              <li>PrestubMethodFrame</li>
              <li>StubDispatchFrame</li>
              <li>ExternalMethodFrame</li>
              <li>TPMethodFrame</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>UnmanagedToManagedFrame</strong>
        <ul>
          <li>ComMethodFrame
            <ul>
              <li>ComPrestubMethodFrame</li>
            </ul>
          </li>
          <li>UMThkCallFrame</li>
        </ul>
      </li>
      <li><strong>ContextTransitionFrame</strong></li>
      <li><strong>TailCallFrame</strong></li>
      <li><strong>ProtectByRefsFrame</strong></li>
      <li><strong>ProtectValueClassFrame</strong></li>
      <li><strong>DebuggerClassInitMarkFrame</strong></li>
      <li><strong>DebuggerSecurityCodeMarkFrame</strong></li>
      <li><strong>DebuggerExitFrame</strong></li>
      <li><strong>DebuggerU2MCatchHandlerFrame</strong></li>
      <li><strong>FuncEvalFrame</strong></li>
      <li><strong>ExceptionFilterFrame</strong></li>
    </ul>
  </li>
</ul>

<h3 id="helper-method-frames">‚ÄòHelper Method‚Äô Frames</h3>

<p>But to make sense of this, let‚Äôs look at one type of <code>Frame</code>, known as <code>HelperMethodFrame</code> (above). This is used when .NET code in the runtime calls into C++ code to do the heavy-lifting, often for performance reasons. One example is if you call <code>Environment.GetCommandLineArgs()</code> you end up <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Environment.cs#L151-L180">in this code</a> (C#), but note that it ends up calling an <code>extern</code> method marked with <code>InternalCall</code>:</p>

<div><div><pre><code><span>[</span><span>MethodImplAttribute</span><span>(</span><span>MethodImplOptions</span><span>.</span><span>InternalCall</span><span>)]</span>
<span>private</span> <span>static</span> <span>extern</span> <span>string</span><span>[]</span> <span>GetCommandLineArgsNative</span><span>();</span>
</code></pre></div></div>

<p>This means that the rest of the method is implemented in the runtime in C++, you can see how the method call is <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/ecalllist.h#L153">wired up</a>, before ending up <code>SystemNative::GetCommandLineArgs</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/classlibnative/bcltype/system.cpp#L178-L221">here</a>, which is shown below:</p>

<div><div><pre><code><span>FCIMPL0</span><span>(</span><span>Object</span><span>*</span><span>,</span> <span>SystemNative</span><span>::</span><span>GetCommandLineArgs</span><span>)</span>
<span>{</span>
    <span>FCALL_CONTRACT</span><span>;</span>

    <span>PTRARRAYREF</span> <span>strArray</span> <span>=</span> <span>NULL</span><span>;</span>

    <span>HELPER_METHOD_FRAME_BEGIN_RET_1</span><span>(</span><span>strArray</span><span>);</span> <span>// &lt;-- 'Helper method Frame' started here</span>

    <span>// Error handling and setup code removed for clarity</span>

    <span>strArray</span> <span>=</span> <span>(</span><span>PTRARRAYREF</span><span>)</span> <span>AllocateObjectArray</span><span>(</span><span>numArgs</span><span>,</span> <span>g_pStringClass</span><span>);</span>
    <span>// Copy each argument into new Strings.</span>
    <span>for</span><span>(</span><span>unsigned</span> <span>int</span> <span>i</span><span>=</span><span>0</span><span>;</span> <span>i</span><span>&lt;</span><span>numArgs</span><span>;</span> <span>i</span><span>++</span><span>)</span>
    <span>{</span>
        <span>STRINGREF</span> <span>str</span> <span>=</span> <span>StringObject</span><span>::</span><span>NewString</span><span>(</span><span>argv</span><span>[</span><span>i</span><span>]);</span>
        <span>STRINGREF</span> <span>*</span> <span>destData</span> <span>=</span> <span>((</span><span>STRINGREF</span><span>*</span><span>)(</span><span>strArray</span><span>-&gt;</span><span>GetDataPtr</span><span>()))</span> <span>+</span> <span>i</span><span>;</span>
        <span>SetObjectReference</span><span>((</span><span>OBJECTREF</span><span>*</span><span>)</span><span>destData</span><span>,</span> <span>(</span><span>OBJECTREF</span><span>)</span><span>str</span><span>,</span> <span>strArray</span><span>-&gt;</span><span>GetAppDomain</span><span>());</span>
    <span>}</span>
    <span>delete</span> <span>[]</span> <span>argv</span><span>;</span>

    <span>HELPER_METHOD_FRAME_END</span><span>();</span> <span>// &lt;-- 'Helper method Frame' ended/closed here</span>

    <span>return</span> <span>OBJECTREFToObject</span><span>(</span><span>strArray</span><span>);</span>
<span>}</span>
<span>FCIMPLEND</span>
</code></pre></div></div>

<p><strong>Note</strong>: this code makes heavy use of macros, see <a href="https://gist.github.com/mattwarren/36e52b3f80a411ca5a6b7211c9f1a3a9">this gist</a> for the original code and then the expanded versions (Release and Debug). In addition, if you want more information on these mysterious <code>FCalls</code> as they are known (and the related <code>QCalls</code>) see <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/mscorlib.md">Mscorlib and Calling Into the Runtime</a> in the ‚ÄòBotR‚Äô.</p>

<p>But the main thing to look at in the code sample is the <code>HELPER_METHOD_FRAME_BEGIN_RET_1()</code> macro, with ultimately installs an instance of the <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/frames.h#L1435-L1492">HelperMethodFrame_1OBJ class</a>. The macro expands into code like this:</p>

<div><div><pre><code><span>FrameWithCookie</span> <span>&lt;</span> <span>HelperMethodFrame_1OBJ</span> <span>&gt;</span> <span>__helperframe</span><span>(</span><span>__me</span><span>,</span> <span>Frame</span><span>::</span><span>FRAME_ATTR_NONE</span><span>,</span> <span>(</span><span>OBJECTREF</span> <span>*</span> <span>)</span> <span>&amp;</span> <span>strArray</span><span>);</span> 
<span>{</span>
  <span>__helperframe</span><span>.</span><span>Push</span><span>();</span> <span>// &lt;-- 'Helper method Frame' pushed</span>

  <span>Thread</span> <span>*</span> <span>CURRENT_THREAD</span> <span>=</span> <span>__helperframe</span><span>.</span><span>GetThread</span><span>();</span>
  <span>const</span> <span>bool</span> <span>CURRENT_THREAD_AVAILABLE</span> <span>=</span> <span>true</span><span>;</span>
  <span>(</span><span>void</span><span>)</span> <span>CURRENT_THREAD_AVAILABLE</span><span>;;</span> <span>{</span>
	<span>Exception</span> <span>*</span> <span>__pUnCException</span> <span>=</span> <span>0</span><span>;</span>
	<span>Frame</span> <span>*</span> <span>__pUnCEntryFrame</span> <span>=</span> <span>(</span> <span>&amp;</span> <span>__helperframe</span><span>);</span>
	<span>bool</span> <span>__fExceptionCatched</span> <span>=</span> <span>false</span><span>;;</span>
	<span>try</span> <span>{;</span>

	  <span>// Original code from SystemNative::GetCommandLineArgs goes in here</span>

	<span>}</span> <span>catch</span> <span>(</span><span>Exception</span> <span>*</span> <span>__pException</span><span>)</span> <span>{;</span>
	  <span>do</span> <span>{}</span> <span>while</span> <span>(</span><span>0</span><span>);</span>
	  <span>__pUnCException</span> <span>=</span> <span>__pException</span><span>;</span>
	  <span>UnwindAndContinueRethrowHelperInsideCatch</span><span>(</span><span>__pUnCEntryFrame</span><span>,</span> <span>__pUnCException</span><span>);</span>
	  <span>__fExceptionCatched</span> <span>=</span> <span>true</span><span>;;</span>
	<span>}</span>
	<span>if</span> <span>(</span><span>__fExceptionCatched</span><span>)</span> <span>{;</span>
	  <span>UnwindAndContinueRethrowHelperAfterCatch</span><span>(</span><span>__pUnCEntryFrame</span><span>,</span> <span>__pUnCException</span><span>);</span>
	<span>}</span>
  <span>};</span>
  
  <span>__helperframe</span><span>.</span><span>Pop</span><span>();</span> <span>// &lt;-- 'Helper method Frame' popped</span>
<span>};</span>
</code></pre></div></div>

<p><strong>Note</strong>: the <code>Push()</code> and <code>Pop()</code> against <code>_helperMethodFrame</code> that make it available for ‚Äòstack walking‚Äô. You can also see the <code>try</code>/<code>catch</code> block that the CLR puts in place to ensure any exceptions from <em>native</em> code are turned into <em>managed</em> exceptions that C#/F#/VB.NET code can handle. If you‚Äôre interested the full macro-expansion is available <a href="https://gist.github.com/mattwarren/36e52b3f80a411ca5a6b7211c9f1a3a9#expanded-code---release---81-loc">in this gist</a>.</p>

<p>So in summary, these <code>Frames</code> are <em>pushed onto</em> a ‚Äòlinked list‚Äô when calling into native code and <em>popped off</em> the list when returning from native code. This means that are any moment the ‚Äòlinked list‚Äô contains all the current or active <code>Frames</code>.</p>

<h3 id="native-unwind-information">Native Unwind Information</h3>

<p>In addition to creating ‚ÄòFrames‚Äô, the CLR also ensures that the C++ compiler emits ‚Äòunwind info‚Äô for native code. We can see this if we use the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference?view=vs-2017">DUMPBIN tool</a> and run <code>dumpbin /UNWINDINFO coreclr.dll</code>. We get the following output for <code>SystemNative::GetCommandLineArgs(..)</code> (that we looked at before):</p>

<div><div><pre><code>  0002F064 003789B0 00378B7E 004ED1D8  ?GetCommandLineArgs@SystemNative@@SAPEAVObject@@XZ (public: static class Object * __cdecl SystemNative::GetCommandLineArgs(void))
    Unwind version: 1
    Unwind flags: EHANDLER UHANDLER
    Size of prologue: 0x3B
    Count of codes: 13
    Unwind codes:
      29: SAVE_NONVOL, register=r12 offset=0x1C8
      25: SAVE_NONVOL, register=rdi offset=0x1C0
      21: SAVE_NONVOL, register=rsi offset=0x1B8
      1D: SAVE_NONVOL, register=rbx offset=0x1B0
      10: ALLOC_LARGE, size=0x190
      09: PUSH_NONVOL, register=r15
      07: PUSH_NONVOL, register=r14
      05: PUSH_NONVOL, register=r13
    Handler: 00148F14 __GSHandlerCheck_EH
    EH Handler Data: 00415990
    GS Unwind flags: EHandler UHandler
    Cookie Offset: 00000180

  0002F070 00378B7E 00378BB4 004ED26C
    Unwind version: 1
    Unwind flags: EHANDLER UHANDLER
    Size of prologue: 0x0A
    Count of codes: 2
    Unwind codes:
      0A: ALLOC_SMALL, size=0x20
      06: PUSH_NONVOL, register=rbp
    Handler: 0014978C __CxxFrameHandler3
    EH Handler Data: 00415990
</code></pre></div></div>

<p>If you want to understand more of what‚Äôs going on here I really recommend reading the excellent article <a href="https://blogs.msdn.microsoft.com/ntdebugging/2010/05/12/x64-manual-stack-reconstruction-and-stack-walking/">x64 Manual Stack Reconstruction and Stack Walking</a>. But in essence the ‚Äòunwind info‚Äô describes which registers are used within a method and how big stack is for that method. These pieces of information are enough to tell the runtime how to ‚Äòunwind‚Äô that particular method when walking the stack.</p>

<h3 id="differences-between-windows-and-unix">Differences between Windows and Unix</h3>

<p>However, to further complicate things, the ‚Äònative code unwinding‚Äô uses a different mechanism for ‚ÄòWindows‚Äô v. ‚ÄòUnix‚Äô, as explained in <a href="https://github.com/dotnet/coreclr/issues/177#issuecomment-73648128">coreclr/issues/#177 (comment)</a>:</p>

<blockquote>
  <ol>
    <li><strong>Stack walker for managed code</strong>. JIT will generate regular Windows style unwinding info. We will reuse Windows unwinder code that we currently have checked in for debugger components for unwinding calls in managed code on Linux/Mac. Unfortunately, this work requires changes in the runtime that currently cannot be tested in the CoreCLR repo so it is hard to do this in the public right now. But we are working on fixing that because, as I mentioned at the beginning, our goal is do most work in the public.</li>
    <li><strong>Stack walker for native code</strong>. Here, in addition to everything else, we need to allow GC to unwind native stack of any thread in the current process until it finds a managed frame. Currently we are considering using libunwind (http://www.nongnu.org/libunwind) for unwinding native call stacks. @janvorli did some prototyping/experiments and it seems to do what we need. If you have any experience with this library or have any comments/suggestions please let us know.</li>
  </ol>
</blockquote>

<p>This also shows that there are 2 different ‚Äòunwind‚Äô mechanisms for ‚Äòmanaged‚Äô or ‚Äònative‚Äô code, we will discuss how the ‚Äú<em>stack walker for managed code</em>‚Äù works in <a href="#unwinding-jitted-code">Unwinding ‚ÄòJITted‚Äô Code</a>.</p>

<p>There is also some more information in <a href="https://github.com/dotnet/coreclr/issues/177#issuecomment-73803242">coreclr/issues/#177 (comment)</a>:</p>

<blockquote>
  <p>My current work has two parts, as @sergiy-k has already mentioned. The <strong>windows style unwinder that will be used for the jitted code</strong> and <strong>Unix unwinder for native code</strong> that uses the libunwind‚Äôs low level <code>unw_xxxx</code> functions like <code>unw_step</code> etc.</p>
</blockquote>

<p>So, for ‚Äònative code‚Äô the runtime uses an OS specific mechanism, i.e. on Unix the <a href="https://github.com/libunwind/libunwind">Open Source ‚Äòlibunwind‚Äô library</a> is used. You can see the differences in the code below (from <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/amd64/gmsamd64.cpp#L54-L74">here</a>), under Windows <code>Thread::VirtualUnwindCallFrame(..)</code> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L552-L671">implementation</a>) is called, but on Unix (i.e. <code>FEATURE_PAL</code>) <code>PAL_VirtualUnwind(..)</code> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/pal/src/exception/seh-unwind.cpp#L249-L349">implementation</a>) is called instead:</p>

<div><div><pre><code><span>#ifndef FEATURE_PAL
</span>    <span>pvControlPc</span> <span>=</span> <span>Thread</span><span>::</span><span>VirtualUnwindCallFrame</span><span>(</span><span>&amp;</span><span>ctx</span><span>,</span> <span>&amp;</span><span>nonVolRegPtrs</span><span>);</span>
<span>#else // !FEATURE_PAL
</span>    <span>...</span>
    <span>BOOL</span> <span>success</span> <span>=</span> <span>PAL_VirtualUnwind</span><span>(</span><span>&amp;</span><span>ctx</span><span>,</span> <span>&amp;</span><span>nonVolRegPtrs</span><span>);</span>
    <span>...</span>
    <span>pvControlPc</span> <span>=</span> <span>GetIP</span><span>(</span><span>&amp;</span><span>ctx</span><span>);</span>
<span>#endif // !FEATURE_PAL
</span></code></pre></div></div>

<p>Before we more on, here are some links to the work that was done to support ‚Äòstack walking‚Äô when .NET Core CLR was <a href="https://blogs.msdn.microsoft.com/dotnet/2016/06/27/announcing-net-core-1-0/#the-net-core-journey">ported to Linux</a>:</p>

<ul>
  <li><a href="https://github.com/dotnet/coreclr/issues/8887">[x86/Linux] Support Simple Exception Catch</a></li>
  <li><a href="https://github.com/dotnet/coreclr/issues/6698">[ARM/Linux] coreclr fails due to lack of DWARF feature in libunwind #6698</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/259">Modify the windows amd64 unwinder to work as jitted code unwinder on Uni‚Ä¶ #259</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/284">Refactor libunwind to work on osx #284</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/308">Reimplement native exception handling for PAL #308</a></li>
  <li><a href="https://github.com/dotnet/coreclr/commit/6c2c7994f1412e8aa504800c7164de875c350fc1">Move the windows unwinder code out of the debug folder.</a></li>
  <li><a href="https://github.com/dotnet/core/blob/4c4642d548074b3fbfd425541a968aadd75fea99/release-notes/1.0/1.0.0.md#dependencies">.NET Core Dependencies</a> (includes ‚Äòlibunwind‚Äô)</li>
  <li><a href="https://github.com/dotnet/coreclr/pull/437">The sos ‚ÄúClrStack‚Äù command now works</a></li>
</ul>

<hr>

<h2 id="unwinding-jitted-code">Unwinding ‚ÄòJITted‚Äô Code</h2>

<p>Finally, we‚Äôre going to look at what happens with ‚Äòmanaged code‚Äô, i.e. code that started off as C#/F#/VB.NET, was turned into IL and then compiled into native code by the ‚ÄòJIT Compiler‚Äô. This is the code that you generally want to see in your ‚Äòstack trace‚Äô, because it‚Äôs code you wrote yourself!</p>

<h3 id="help-from-the-jit-compiler">Help from the ‚ÄòJIT Compiler‚Äô</h3>

<p>Simply, what happens is that when the code is ‚ÄòJITted‚Äô, the compiler also emits some extra information, stored via the <code>EECodeInfo</code> class, which is defined <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/jitinterface.cpp#L13922-L14300">here</a>. Also see the <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/jit/compiler.h#L7316-L7440">‚ÄòUnwind Info‚Äô section</a> in the JIT Compiler &lt;-&gt; Runtime interface, note how it features seperate sections for <code>TARGET_ARM</code>, <code>TARGET_ARM64</code>, <code>TARGET_X86</code> and <code>TARGET_UNIX</code>.</p>

<p>In addition, in <code>CodeGen::genFnProlog()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/jit/codegencommon.cpp#L8832-L9299">here</a> the JIT emits a function ‚Äòprologue‚Äô that contains several pieces of ‚Äòunwind‚Äô related data. This is also imlemented in <code>CEEJitInfo::allocUnwindInfo(..)</code> in <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/jitinterface.cpp#L11275-L11300">this piece of code</a>, which behaves differently for each CPU architecture:</p>

<div><div><pre><code><span>#if defined(_TARGET_X86_)
</span>    <span>// Do NOTHING</span>
<span>#elif defined(_TARGET_AMD64_)
</span>    <span>pUnwindInfo</span><span>-&gt;</span><span>Flags</span> <span>=</span> <span>UNW_FLAG_EHANDLER</span> <span>|</span> <span>UNW_FLAG_UHANDLER</span><span>;</span>
    <span>ULONG</span> <span>*</span> <span>pPersonalityRoutine</span> <span>=</span> <span>(</span><span>ULONG</span><span>*</span><span>)</span><span>ALIGN_UP</span><span>(</span><span>&amp;</span><span>(</span><span>pUnwindInfo</span><span>-&gt;</span><span>UnwindCode</span><span>[</span><span>pUnwindInfo</span><span>-&gt;</span><span>CountOfUnwindCodes</span><span>]),</span> <span>sizeof</span><span>(</span><span>ULONG</span><span>));</span>
    <span>*</span><span>pPersonalityRoutine</span> <span>=</span> <span>ExecutionManager</span><span>::</span><span>GetCLRPersonalityRoutineValue</span><span>();</span>
<span>#elif defined(_TARGET_ARM64_)
</span>    <span>*</span><span>(</span><span>LONG</span> <span>*</span><span>)</span><span>pUnwindInfo</span> <span>|=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>20</span><span>);</span> <span>// X bit</span>
    <span>ULONG</span> <span>*</span> <span>pPersonalityRoutine</span> <span>=</span> <span>(</span><span>ULONG</span><span>*</span><span>)((</span><span>BYTE</span> <span>*</span><span>)</span><span>pUnwindInfo</span> <span>+</span> <span>ALIGN_UP</span><span>(</span><span>unwindSize</span><span>,</span> <span>sizeof</span><span>(</span><span>ULONG</span><span>)));</span>
    <span>*</span><span>pPersonalityRoutine</span> <span>=</span> <span>ExecutionManager</span><span>::</span><span>GetCLRPersonalityRoutineValue</span><span>();</span>
<span>#elif defined(_TARGET_ARM_)
</span>    <span>*</span><span>(</span><span>LONG</span> <span>*</span><span>)</span><span>pUnwindInfo</span> <span>|=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>20</span><span>);</span> <span>// X bit</span>
    <span>ULONG</span> <span>*</span> <span>pPersonalityRoutine</span> <span>=</span> <span>(</span><span>ULONG</span><span>*</span><span>)((</span><span>BYTE</span> <span>*</span><span>)</span><span>pUnwindInfo</span> <span>+</span> <span>ALIGN_UP</span><span>(</span><span>unwindSize</span><span>,</span> <span>sizeof</span><span>(</span><span>ULONG</span><span>)));</span>
    <span>*</span><span>pPersonalityRoutine</span> <span>=</span> <span>(</span><span>TADDR</span><span>)</span><span>ProcessCLRException</span> <span>-</span> <span>baseAddress</span><span>;</span>
<span>#endif
</span></code></pre></div></div>

<p>Also, the JIT has several <code>Compiler::unwindXXX(..)</code> methods, that are all implemented in per-CPU source files:</p>

<ul>
  <li><a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/jit/unwind.cpp">/src/jit/unwind.cpp</a></li>
  <li><a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/jit/unwindarm.cpp">/src/jit/unwind<strong>arm</strong>.cpp</a></li>
  <li><a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/jit/unwindx86.cpp">/src/jit/unwind<strong>x86</strong>.cpp</a></li>
  <li><a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/jit/unwindamd64.cpp">/src/jit/unwind<strong>amd64</strong>.cpp</a></li>
  <li><a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/jit/unwindarm64.cpp">src/jit/unwind<strong>arm64</strong>.cpp</a></li>
</ul>

<p>Fortunately, we can <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/building/viewing-jit-dumps.md#useful-complus-variables">ask the JIT</a> to output the unwind info that it emits, however this <em>only works</em> with a Debug version of the CLR. Given a simple method like this:</p>

<div><div><pre><code><span>private</span> <span>void</span> <span>MethodA</span><span>()</span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>MethodB</span><span>();</span>
    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> <span>ex</span><span>)</span> <span>{</span>
        <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>ex</span><span>.</span><span>ToString</span><span>());</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>if we call <code>SET COMPlus_JitUnwindDump=MethodA</code>, we get the following output with 2 ‚ÄòUnwind Info‚Äô sections, one for the <code>try</code> and the other for the <code>catch</code> block:</p>

<div><div><pre><code>Unwind Info:
  &gt;&gt; Start offset   : 0x000000 (not in unwind data)
  &gt;&gt;   End offset   : 0x00004e (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x07
  CountOfUnwindCodes: 4
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 11 * 8 + 8 = 96 = 0x60
    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)
    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
Unwind Info:
  &gt;&gt; Start offset   : 0x00004e (not in unwind data)
  &gt;&gt;   End offset   : 0x0000e2 (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x07
  CountOfUnwindCodes: 4
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 5 * 8 + 8 = 48 = 0x30
    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)
    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
</code></pre></div></div>

<p>This ‚Äòunwind info‚Äô is then looked up during a ‚Äòstack walk‚Äô as explained in the <a href="#how-it-works">How it works</a> section above.</p>

<hr>

<p><strong>So next time you encounter a ‚Äòstack trace‚Äô remember that a lot of work went into making it possible!!</strong></p>

<hr>

<h2 id="further-reading">Further Reading</h2>

<p>‚ÄòStack Walking‚Äô or ‚ÄòStack Unwinding‚Äô is a very large topic, so if you want to know more, here are some links to get you started:</p>

<h3 id="stack-unwinding-general">Stack Unwinding (general)</h3>

<ul>
  <li><a href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/">Stack frame layout on x86-64</a> (also has a great list of links at the bottom)</li>
  <li><a href="https://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/">Where the top of the stack is on x86</a></li>
  <li><a href="https://eli.thegreenplace.net/2015/programmatic-access-to-the-call-stack-in-c/">Programmatic access to the call stack in C++</a></li>
  <li><a href="https://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information">How debuggers work: Part 3 - Debugging information</a></li>
  <li><a href="https://blog.tartanllama.xyz/writing-a-linux-debugger-unwinding/">Writing a Linux Debugger Part 8: Stack unwinding</a></li>
  <li><a href="http://blog.reverberate.org/2013/05/deep-wizardry-stack-unwinding.html">Deep Wizardry: Stack Unwinding</a></li>
  <li><a href="https://www.reddit.com/r/programming/comments/1ebswy/deep_wizardry_stack_unwinding/">Deep Wizardry: Stack Unwinding</a> (/r/programmming)</li>
  <li><a href="http://www.corsix.org/content/libunwind-dynamic-code-x86-64">On libunwind and dynamically generated code on x86-64</a></li>
  <li><a href="https://news.ycombinator.com/item?id=11477039">On libunwind and dynamically generated code on x86-64</a> (HackerNews)</li>
  <li><a href="https://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames">x86 Disassembly/Functions and Stack Frames</a></li>
  <li><a href="https://stackoverflow.com/questions/579262/what-is-the-purpose-of-the-ebp-frame-pointer-register">What is the purpose of the EBP frame pointer register?</a></li>
  <li><a href="http://blogs.microsoft.co.il/sasha/2011/07/20/manual-stack-walking/">Manual Stack Walking</a></li>
  <li><a href="http://blogs.microsoft.co.il/sasha/2011/08/22/walking-the-stack-without-symbols-and-with-fpo-frame-pointer-omission/">Walking the Stack Without Symbols and With FPO (Frame Pointer Omission)</a></li>
  <li><a href="https://cshung.gitbooks.io/how-to-write-a-debuggable-programming-language/content/stack-unwinder.html">how to write a debuggable programming language - stack unwinding</a></li>
  <li><a href="https://www.reddit.com/r/programming/comments/5v4ztx/how_the_net_runtime_walks_the_stack/">How the .NET Runtime Walks the Stack</a> (/r/programming discussion of the ‚ÄòBorR‚Äô page)</li>
  <li><a href="https://blog.slaks.net/2011/10/caller-info-attributes-vs-stack-walking.html">Caller Info Attributes vs. Stack Walking</a></li>
  <li><a href="http://www.osronline.com/article.cfm?id=202">Stacking the Deck ‚Äì Finding Your Way Through the Stack</a></li>
</ul>

<h3 id="stack-unwinding-other-runtimes">Stack Unwinding (other runtimes)</h3>

<p>In addition, it‚Äôs interesting to look at how other runtimes handles this process:</p>

<ul>
  <li><strong>Mono</strong>
    <ul>
      <li><a href="https://www.mono-project.com/docs/advanced/runtime/docs/mini-porting/#unwind-info">Porting the Engine - Unwind Info</a></li>
      <li><a href="https://www.mono-project.com/docs/advanced/runtime/docs/llvm-backend/#unwind-info">LLVM Backend - Unwind Info</a></li>
      <li><a href="https://www.mono-project.com/docs/advanced/runtime/docs/exception-handling/#stack-unwinding-during-exception-handling">Stack unwinding during exception handling</a></li>
      <li><a href="https://github.com/mono/mono/blob/master/mono/mini/unwind.c">/master/mono/mini/<strong>unwind.c</strong></a></li>
      <li><a href="https://github.com/mono/mono/blob/master/mono/utils/mono-stack-unwinding.h">/master/mono/utils/<strong>mono-stack-unwinding.h</strong></a></li>
    </ul>
  </li>
  <li><strong>CoreRT</strong> (<a href="https://mattwarren.org/2018/06/07/CoreRT-.NET-Runtime-for-AOT/">A .NET Runtime for AOT</a>)
    <ul>
      <li><a href="https://github.com/dotnet/corert/blob/master/Documentation/high-level-engineering-plan.md#runtime">High-level Engineering Plan - Runtime</a></li>
      <li><a href="https://github.com/dotnet/corert/blob/master/src/Native/Runtime/unix/UnwindHelpers.cpp">/src/Native/Runtime/unix/<strong>UnwindHelpers.cpp</strong></a></li>
      <li><a href="https://github.com/dotnet/corert/blob/master/src/Native/Runtime/StackFrameIterator.cpp">/src/Native/Runtime/<strong>StackFrameIterator.cpp</strong></a> (see <code>StackFrameIterator::NextInternal()</code>)</li>
      <li><a href="https://github.com/dotnet/corert/tree/master/src/Native/libunwind">/src/Native/<strong>libunwind</strong></a></li>
    </ul>
  </li>
  <li><strong>Go</strong>
    <ul>
      <li><a href="https://science.raphael.poss.name/go-calling-convention-x86-64.html#aside-exceptions-in-c-c">The Go low-level calling convention on x86-64</a></li>
      <li><a href="https://github.com/teh-cmc/go-internals/blob/master/chapter1_assembly_primer/README.md#dissecting-main">Go Internals - Chapter I: A Primer on Go Assembly</a></li>
      <li><a href="https://stackimpact.com/blog/go-profiler-internals/">Go Profiler Internals</a></li>
      <li><a href="https://golang.org/src/runtime/stack.go">golang.org/src/runtime/stack.go</a></li>
      <li><a href="https://golang.org/src/runtime/traceback.go?h=gentraceback#L98">golang.org/src/runtime/traceback.go</a> (see <code>gentraceback(..)</code>)</li>
      <li><a href="https://golang.org/src/runtime/symtab.go?h=findfunc#L659">golang.org/src/runtime/symtab.go</a> (see <code>findfunc(..)</code>)</li>
      <li><a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html">Language Mechanics On Stacks And Pointers</a></li>
      <li><a href="http://technosophos.com/2014/03/19/generating-stack-traces-in-go.html">Generating Stack Traces in Go</a></li>
    </ul>
  </li>
  <li><strong>Java</strong>
    <ul>
      <li><a href="http://openjdk.java.net/jeps/259">JEP 259: Stack-Walking API</a></li>
      <li><a href="https://alvinalexander.com/scala/fp-book/recursion-visual-look-jvm-stack-frames">A Visual Look at JVM Stacks and Frames</a></li>
      <li><a href="https://www.artima.com/insidejvm/ed2/jvm8.html">The Java Virtual Machine - The Java Stack</a></li>
      <li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.6">The Structure of the Java Virtual Machine - Native Method Stacks</a></li>
      <li><a href="https://harmony.apache.org/subcomponents/drlvm/developers_guide.html#Stack_Walking">Stack Walking - Dynamic Runtime Layer Virtual Machine Developer‚Äôs Guide</a></li>
      <li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.67.346&amp;rep=rep1&amp;type=pdf">A Study of Exception Handling and Its Dynamic Optimization in Java</a> (pdf)</li>
      <li><a href="https://books.google.co.uk/books?id=jZG_DQAAQBAJ&amp;lpg=PA125&amp;ots=KwhW3tYXUa&amp;dq=chapter%208%20stack%20unwinding&amp;pg=PA125#v=onepage&amp;q=chapter%208%20stack%20unwinding&amp;f=false">Chapter 8 of ‚ÄòAdvanced Design and Implementation of Virtual Machines‚Äô</a></li>
    </ul>
  </li>
  <li><strong>Rust</strong>
    <ul>
      <li><a href="https://doc.rust-lang.org/nomicon/unwinding.html">Unwinding</a></li>
      <li><a href="http://lucumr.pocoo.org/2014/10/30/dont-panic/">Don‚Äôt Panic! The Hitchhiker‚Äôs Guide to Unwinding</a></li>
      <li><a href="https://news.ycombinator.com/item?id=8537756">Stack unwinding in Rust</a> (Hacker News)</li>
      <li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1513-less-unwinding.md">RFC 1513 - Less unwinding</a></li>
      <li><a href="https://internals.rust-lang.org/t/disabling-panic-handling/1834">Disabling panic! handling</a></li>
      <li><a href="https://rust-lang-nursery.github.io/edition-guide/rust-2018/error-handling-and-panics/controlling-panics-with-std-panic.html">Controlling panics with std::panic</a></li>
      <li><a href="https://doc.rust-lang.org/1.3.0/std/rt/unwind/">Module std::rt::unwind</a></li>
    </ul>
  </li>
</ul>

</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>