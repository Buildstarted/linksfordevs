<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">🎉</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>RL &#x2014; Proximal Policy Optimization (PPO) Explained</h1>
        <p>
by Jonathan Hui <br/>Reading time: 9-12 minutes        </p>
        <p><a href="https://medium.com/@jonathan_hui/rl-proximal-policy-optimization-ppo-explained-77f014ec3f12">https://medium.com/@jonathan_hui/rl-proximal-policy-optimization-ppo-explained-77f014ec3f12</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@jonathan_hui?source=post_page-----77f014ec3f12----------------------"><img alt="Jonathan Hui" src="https://miro.medium.com/fit/c/96/96/1*c3Z3aOPBooxEX4tx4RkzLw.jpeg" width="48" height="48"></a></p></div></div></div></div></div></div><div><div><p id="53ee" data-selectable-paragraph="">A quote from OpenAI on PPO:</p><blockquote><p id="187e" data-selectable-paragraph="">Proximal Policy Optimization (PPO), which perform comparably or better than state-of-the-art approaches while being much simpler to implement and tune.</p></blockquote><p id="56a2" data-selectable-paragraph="">Actually, this is a very humble statement comparing with its real impact. Policy Gradient methods have convergence problem which is addressed by the natural policy gradient. However, in practice, natural policy gradient involves a second-order derivative matrix which makes it not scalable for large scale problems. The computational complexity is too high for real tasks. Intensive research is done to reduce the complexity by approximate the second-order method. PPO uses a slightly different approach. Instead of imposing a hard constraint, it formalizes the constraint as a penalty in the objective function. By not avoiding the constraint at all cost, we can use a first-order optimizer like the Gradient Descent method to optimize the objective. Even we may violate the constraint once a while, the damage is far less and the computation is much simple. Let’s go through quickly on the basic concepts before explaining PPO in details.</p><p id="fe92" data-selectable-paragraph="">How can we optimize a policy to maximize the rewards?</p><p id="980d" data-selectable-paragraph="">With the Minorize-Maximization <strong>MM</strong> algorithm, this is achieved <strong>iteratively</strong> by maximizing a lower bound function <strong><em>M</em></strong> (the blue line below) approximating the expected reward <em>η </em>locally<em>.</em></p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*JR_HgKDpNIzOX1t6JE7AQA.jpeg?q=20" width="1600" height="380" role="presentation"></p><p><img width="1600" height="380" role="presentation" src="https://miro.medium.com/max/1600/1*JR_HgKDpNIzOX1t6JE7AQA.jpeg"></p></div></div></div></div><figcaption data-selectable-paragraph="">Modified from <a href="https://drive.google.com/file/d/0BxXI_RttTZAhMVhsNk5VSXU0U3c/view" target="_blank" rel="noopener nofollow">source</a></figcaption></figure><p id="05a8" data-selectable-paragraph="">First, we start with an initial policy guess and find a lower bound <em>M</em> for <em>η </em>at this policy. We optimize M and use the optimal policy for <em>M</em> as the next guess. We approximate a new lower bound again at the new guess and repeat the iterations until the policy converges. To make it works, we do need to find a lower bound <em>M</em> that is easier to optimize.</p><p id="2909" data-selectable-paragraph="">There are two major optimization methods: the line search like the gradient descent and the trust region. Gradient descent is easy, fast and simple in optimizing an objective function. This is why it is so popular in deep learning even more accurate methods are available.</p><p id="7e62" data-selectable-paragraph="">Line search first picks the steepest direction and then move forward by a step size. But how can this strategy go wrong in reinforcement learning RL? Let’s take a robot to the Angels Landing for hiking. As shown below, we ascend the hill by determining the direction first. If the step size is too small, it will take forever to get to the peak. But if it is too big, we can fall down the cliff. Even if the robot survives the fall, it lands in areas with height much lower than where we were. Policy gradient is mainly an on-policy method. It searches actions from the current state. Hence, we resume the exploration from a bad state with a locally bad policy. This hurts performance badly.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*k9NFvgjf2XGiLiiarp0Q2Q.jpeg?q=20" width="1062" height="682" role="presentation"></p><p><img width="1062" height="682" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Modified from <a href="https://pronetowanderfriends.wordpress.com/2014/02/23/angels-landing-in-zion-national-park-check/" target="_blank" rel="noopener nofollow">Source</a></figcaption></figure><p id="4575" data-selectable-paragraph="">In the trust region, we determine the maximum step size that we want to explore first (the yellow circle below). Then we locate the optimal point within the trust region and resume the search from there.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*eQDsFaMkSXw0g6gVIErXaQ.jpeg?q=20" width="1062" height="684" role="presentation"></p><p><img width="1062" height="684" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Modified from <a href="https://pronetowanderfriends.wordpress.com/2014/02/23/angels-landing-in-zion-national-park-check/" target="_blank" rel="noopener nofollow">Source</a></figcaption></figure><p id="cd27" data-selectable-paragraph=""><strong>What is the maximum step size in a trust region? </strong>In the trust region method, we start with an initial guess. Optionally, we can readjust the region size dynamically. For example, we can shrink the region if the divergence of the new and current policy is getting large (or vice versa). In order not to make bad decisions, we can shrink the trust region if the policy is changing too much.</p><p id="24ad" data-selectable-paragraph="">In PPO, we limit how far we can change our policy in each iteration through the KL-divergence. KL-divergence measures the difference between two data distributions <em>p</em> and <em>q</em>.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*N1BvIhBD9vP5vlY-3eppLQ.png?q=20" width="1488" height="102" role="presentation"></p><p><img width="1488" height="102" role="presentation"></p></div></div></div></div></figure><p id="aa31" data-selectable-paragraph="">We repurpose it to measure the difference between the two policies. We don’t want any new policy to be too different from the current one.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*3QNN7laZTbW7guFT-YnJNg.png?q=20" width="1488" height="430" role="presentation"></p><p><img width="1488" height="430" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Source: Wikipedia</figcaption></figure><p id="ebef" data-selectable-paragraph="">So how can we limit policy change to make sure we don’t make bad decisions? It turns out we can find a lower bound function <strong><em>M </em></strong>as</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*Zx6Wd8SurELVlsmfF51wcA.png?q=20" width="1500" height="70" role="presentation"></p><p><img width="1500" height="70" role="presentation"></p></div></div></div></div></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*FQDiuNJ1WptAN3LnBKYzWw.jpeg?q=20" width="1600" height="565" role="presentation"></p><p><img width="1600" height="565" role="presentation"></p></div></div></div></div></figure><p id="74b5" data-selectable-paragraph="">with <strong><em>L(θ) </em></strong>equals</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*QZEVk1dguz_7dXO1TvYUQA.jpeg?q=20" width="1600" height="144" role="presentation"></p><p><img width="1600" height="144" role="presentation"></p></div></div></div></div></figure><p id="ad49" data-selectable-paragraph="">and the second terms is the KL-divergence.</p><p id="4e36" data-selectable-paragraph=""><em>L</em> is the expected advantage function (the expected rewards minus a baseline like V(s)) for the new policy. It is estimated by an old (or current) policy and then recalibrate using the probability ratio between the new and the old policy. <mark>We use the advantage function instead of the expected reward because it reduces the variance of the estimation</mark>. As long as the baseline does not dependent on our policy parameters, the optimal policy will be the same.</p><p id="9989" data-selectable-paragraph="">Let’s look into more detail on the second term in <strong><em>M</em></strong>. After two page of proof in the TRPO paper, we can establish the following lower bound.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*xqv1aAr6DSXnYFSUMWb6bg.jpeg?q=20" width="1261" height="218" role="presentation"></p><p><img width="1261" height="218" role="presentation"></p></div></div></div></div></figure><p id="4a28" data-selectable-paragraph="">The second term in <strong><em>M</em></strong> is the maximum of KL-divergence underlined in red above. But it is too hard to find and therefore we relax the requirement a little bit by using the mean of the KL-divergence instead. Let’s explain that intuitively.</p><p id="9595" data-selectable-paragraph=""><strong>Intuition</strong></p><p id="fcf5" data-selectable-paragraph=""><em>L</em> approximates the advantage function locally at the current policy. But it gets less accurate as it moves away from the old policy. This inaccuracy has an upper bound. That is the second term in <strong><em>M</em></strong>. After considering the upper bound of this error, we can guarantee that the calculated optimal policy within the trust region is always better than the old policy. If the policy is outside the trust region, even the calculated value may be better but the accuracy can be too off and cannot be trusted. So the bet is off. Let’s summarize the objective below as:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*LH3dbwj7MEYCICAQMzr-zg.jpeg?q=20" width="1600" height="772" role="presentation"></p><p><img width="1600" height="772" role="presentation"></p></div></div></div></div></figure><p id="611a" data-selectable-paragraph="">Mathematically, both equations above can be resolved to the same optimal policy. However, the theoretical threshold for <strong><em>δ </em></strong>is very small and is considered to be too conservative. So we relax the condition once more by setting them as tunable hyperparameters.</p><p id="5224" data-selectable-paragraph="">As mentioned before, <strong><em>M</em></strong> should be easy to optimize. So we further approximate it to a quadratic equation which is a convex function and heavily study on how to optimize it in high dimensional space.</p><p id="a0e5" data-selectable-paragraph="">We use Taylor’s series to expand the terms up to the second-order. But the second-order of 𝓛 is much smaller than the KL-divergence term and will be ignored.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*QKn9GhIMxJmXK_-nAQ8ojA.jpeg?q=20" width="1580" height="280" role="presentation"></p><p><img width="1580" height="280" role="presentation"></p></div></div></div></div></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*A386qkCNen7IXjwfFbH2Og.jpeg?q=20" width="1456" height="208" role="presentation"></p><p><img width="1456" height="208" role="presentation"></p></div></div></div></div></figure><p id="7940" data-selectable-paragraph="">Therefore, the objective and the constraint can be approximated as:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*Sm49fOBxZBvzgSIo8zm-fA.png?q=20" width="1450" height="173" role="presentation"></p><p><img width="1450" height="173" role="presentation"></p></div></div></div></div></figure><p id="849f" data-selectable-paragraph="">Our objective becomes:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*3aO-ncPjkdXwfTEsoik9Hg.png?q=20" width="1600" height="207" role="presentation"></p><p><img width="1600" height="207" role="presentation"></p></div></div></div></div></figure><p id="0d27" data-selectable-paragraph="">We can solve this quadratic equation analytical. The solution is:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*WL22zwP5Sw4v6qmimRY4pA.png?q=20" width="1600" height="229" role="presentation"></p><p><img width="1600" height="229" role="presentation"></p></div></div></div></div></figure><p id="e9e7" data-selectable-paragraph=""><strong>What are the challenges?</strong></p><p id="e451" data-selectable-paragraph="">This solution involves the calculation of the second-order derivative and its inverse, a very expensive operation.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*izpmCUnxEjeIN51cL0RFNQ.png?q=20" width="1600" height="372" role="presentation"></p><p><img width="1600" height="372" role="presentation"></p></div></div></div></div></figure><p id="591c" data-selectable-paragraph="">So there are two approaches to address this problem:</p><ul><li id="7451" data-selectable-paragraph="">Approximate some calculations involving the second order derivative and its inverse to lower the computational complexity, or</li><li id="84d2" data-selectable-paragraph="">Make the first order derivative solution, like the gradient descent, closer to the second-order derivative solution by adding soft constraints.</li></ul><p id="d727" data-selectable-paragraph="">TRPO and ACKTR adopt the first approach. PPO is closer to the second one. We can still live with a bad policy decision once a while so we stick with the first-order solution like the stochastic gradient descent. But we are going to add a soft constraint to the objective function so the optimization will have better insurance that we are optimizing within a trust region. So the chance of bad decision is smaller.</p><p id="b6fc" data-selectable-paragraph="">One way to formulate our objective is changing the constraint to a penalty in the objective function:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*bzSagTz4kZxRLuXLviWlxA.jpeg?q=20" width="1764" height="156" role="presentation"></p><p><img width="1764" height="156" role="presentation"></p></div></div></div></div></figure><p id="b334" data-selectable-paragraph=""><em>β </em>controls the weight of the penalty. It penalizes the objective if the new policy is different from the old policy. Borrow a page from the trust region, we can dynamically adjust <em>β. d</em> below is the KL-divergence between the old and the new policy. If it is higher than a target value, we shrink <em>β</em>. Similarly, if it falls below another target value, we expand the trust region.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*wAuSUKN4z235ogqYpDhQVA.png?q=20" width="1384" height="72" role="presentation"></p><p><img width="1384" height="72" role="presentation"></p></div></div></div></div></figure><p id="da61" data-selectable-paragraph="">Here is the algorithm:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*NZiUGpkiX5g4g-2yQR6ULg.png?q=20" width="1956" height="1052" role="presentation"></p><p><img width="1956" height="1052" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><a href="http://rail.eecs.berkeley.edu/deeprlcourse-fa17/f17docs/lecture_13_advanced_pg.pdf" target="_blank" rel="noopener nofollow">Source</a></figcaption></figure><p id="e0c8" data-selectable-paragraph="">This gets us the performance of TRPO with speed closer to the gradient descent method. But can we do better?</p><p id="5840" data-selectable-paragraph="">PPO with clipped objective can even do better. In its implementation, we maintain two policy networks. The first one is the current policy that we want to refine.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*R-yFsRXQFYlZ1qyC-ZmvBQ.png?q=20" width="1500" height="64" role="presentation"></p><p><img width="1500" height="64" role="presentation"></p></div></div></div></div></figure><p id="71dd" data-selectable-paragraph="">The second is the policy that we last used to collect samples.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*VVrOkbC4I2qpiZw8hlr5xA.png?q=20" width="1500" height="64" role="presentation"></p><p><img width="1500" height="64" role="presentation"></p></div></div></div></div></figure><p id="bfa8" data-selectable-paragraph="">With the idea of importance sampling, we can evaluate a new policy with samples collected from an older policy. This improves sample efficiency.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*OR5Vy1XwhWJQPeZIqE92TA.jpeg?q=20" width="1600" height="140" role="presentation"></p><p><img width="1600" height="140" role="presentation"></p></div></div></div></div></figure><p id="5c22" data-selectable-paragraph="">But as we refine the current policy, the difference between the current and the old policy is getting larger. The variance of the estimation will increase and we will make bad decision because of the inaccuracy. So, say for every 4 iterations, we synchronize the second network with the refined policy again.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*vzQrUazL63lk-MGgdqveRw.png?q=20" width="1500" height="64" role="presentation"></p><p><img width="1500" height="64" role="presentation"></p></div></div></div></div></figure><p id="4363" data-selectable-paragraph="">With clipped objective, we compute a ratio between the new policy and the old policy:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*lEVj3SmB3ja7F8Km7kPB4Q.png?q=20" width="1550" height="64" role="presentation"></p><p><img width="1550" height="64" role="presentation"></p></div></div></div></div></figure><p id="1a52" data-selectable-paragraph="">This ratio measures how difference between two policies. We construct a new objective function to clip the estimated advantage function if the new policy is far away from the old policy. Our new objective function becomes:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*7gu7oT4N0HOm_jA0335lVA.png?q=20" width="1600" height="132" role="presentation"></p><p><img width="1600" height="132" role="presentation"></p></div></div></div></div></figure><p id="45e3" data-selectable-paragraph="">If the probability ratio between the new policy and the old policy falls outside the range (1 — ε) and (1 + ε), the advantage function will be clipped. ε is set to 0.2 for the experiments in the PPO paper.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*MpPiARNoNGCxJE2a8m9itA.png?q=20" width="1450" height="410" role="presentation"></p><p><img width="1450" height="410" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><a href="https://arxiv.org/pdf/1707.06347.pdf" target="_blank" rel="noopener nofollow">Source</a></figcaption></figure><p id="1fcb" data-selectable-paragraph="">Effectively, this discourages large policy change if it is outside our comfortable zone.</p><p id="b277" data-selectable-paragraph="">Here is the algorithm:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*S8e9USP6x28PLXlu-FA_UQ.png?q=20" width="1600" height="760" role="presentation"></p><p><img width="1600" height="760" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><a href="http://rail.eecs.berkeley.edu/deeprlcourse-fa17/f17docs/lecture_13_advanced_pg.pdf" target="_blank" rel="noopener nofollow">Source</a></figcaption></figure><p id="2c06" data-selectable-paragraph="">This new method is simple and can use Gradient Descent like Adam to optimize it. In fact, it is anticlimax for taking so detail analysis on the issue but come up with such a simple solution.</p><p id="13c6" data-selectable-paragraph="">A quote from the PPO paper:</p><blockquote><p id="ae31" data-selectable-paragraph="">Q-learning (with function approximation) fails on many simple problems and is poorly understood, vanilla policy gradient methods have poor data efficiency and robustness; and trust region policy optimization (TRPO) is relatively complicated, and is not compatible with architectures that include noise (such as dropout) or parameter sharing (between the policy and value function, or with auxiliary tasks).</p></blockquote><p id="bf2a" data-selectable-paragraph="">PPO adds a soft constraint that can be optimized by a first-order optimizer. We may make some bad decisions once a while but it strikes a good balance on the speed of the optimization. Experimental results prove that this kind of balance achieves the best performance with the most simplicity.</p><blockquote><p id="8e00" data-selectable-paragraph="">Simplicity rules in deep learning.</p></blockquote><p id="5e79" data-selectable-paragraph="">Or at least until we invent a super fast GPU.</p><p id="1196" data-selectable-paragraph=""><a href="https://arxiv.org/pdf/1707.06347.pdf" target="_blank" rel="noopener nofollow">PPO paper</a></p><p id="d702" data-selectable-paragraph=""><a href="http://rail.eecs.berkeley.edu/deeprlcourse/" target="_blank" rel="noopener nofollow">UC Berkeley RL course</a></p><p id="6eab" data-selectable-paragraph=""><a href="https://sites.google.com/view/deep-rl-bootcamp/lectures" target="_blank" rel="noopener nofollow">UC Berkeley RL Bootcamp</a></p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>