<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">ðŸŽ‰</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Return of the Obra Dinn [Releasing Oct 18]</title>
<div class="readable">
        <h1>Return of the Obra Dinn [Releasing Oct 18]</h1>
        <p>
Reading time: 10-12 minutes        </p>
        <p><a href="https://forums.tigsource.com/index.php?topic=40832.msg1323787">https://forums.tigsource.com/index.php?topic=40832.msg1323787</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>Grab a cup of something.</p><p><b><span size="5">Collisions In 3D</span></b></p><p>Getting up and running with a 3D first-person game in&nbsp;Unity is quick and easy. When it comes to collision and player movement, scene&nbsp;meshes can be marked as a solid&nbsp;colliders on import and there's&nbsp;some half-decent FPS player movement controllers, with or without physics. Build a scene, make it solid, drop in your player, walk around. Done.</p><p><img src="http://3909.co/dev/od/img/Walkway-3dCollision.jpg" alt="" width="650" height="800"></p><p>Typical 3D colliders. The near table legs and distant chair have no collision, to avoid catching the player.</p><p>Except:</p><p><span size="3">Jittering</span><br>Without careful planning, walking into certain configurations of colliders can causing the player's capsule to jitter awkwardly.</p><p><span size="3">Unexpected collisions</span><br>The Obra Dinn is a dense ship with low ceilings, and there's often cargo and other stuff strewn about the decks. Smaller&nbsp;objects above or below the player's general line of sight&nbsp;can block the player's movement, hit their head, or bump them upwards while walking, which makes moving around uncomfortable and frustrating.</p><p><span size="3">Poor scene rotation</span><br>The game has basically one environment, but in many flashbacks the ship is statically pitched at a steep angle&nbsp;as it crashes through the waves. The player remains upright in these scenes and hits&nbsp;the tilted colliders normally in 3D. This leads to many previous&nbsp;walls becoming ramps that can now be&nbsp;walked right up, pinches that trap the player's capsule, or just general chaos.</p><p><span size="3">Falling through the floor</span><br>For whatever unfortunate reason, Unity 3D physics behave differently on different computers. With the FPS controller code I'm using, these differences manifest as falling through the solid decks at random spots.</p><p><img src="http://3909.co/dev/od/img/Walkway-3dCollision2.png" alt="" width="650" height="398"></p><p>A pitched ship with manually-added upright collision boxes to prevent walking over the edge or getting</p><p>pinched while walking around.</p><p>Most of these problems are pretty typical, and can be fixed with code hacks and careful collider placement and tweaking. Unfortunately for me, there's &gt;40 flashback scenes with drastically different ship configurations. Hand-tweaking each of these would take forever, and there's good odds I'd miss at least a few pinching ceilings, invalid ramps, annoying obstacles, jittery corners, etc somewhere. I'd really like a robust generalized solution for smooth, well-defined player movement.</p><p><span size="4"><b>Player Movement on the Obra Dinn</b></span></p><p>&nbsp; <b>1</b> The player's feet never leave the ground. No jumping, no falling.<br>&nbsp; <b>2</b> Player movement is mostly limited to traversing large manifold surfaces (decks).<br>&nbsp; <b>3</b> Decks are stacked vertically and connected via narrow staircases.<br>&nbsp; <b>4</b> Most ship geometry is static.<br>&nbsp; <b>5</b> The ship can be tilted in any direction, sometimes extremely.<br>&nbsp; <b>6</b> The player shape is modeled as a&nbsp;capsule with radius and height, always upright regardless of ship&nbsp;tilt.<br>&nbsp; <b>7</b> There are a few dynamic objects (doors) that affect player movement.<br>&nbsp; <b>8</b> There are many&nbsp;(statically built) ship configurations.</p><p><b><span size="4">Extra Dimensions Unwelcome</span></b></p><p>One thing that's always frustrated me with standard 3D collision is how hard it is to visualize. Can I creep under that branch? Fit through that doorway?&nbsp;Visualization is the core method I use solve problems and figuring out the best way to visualize something usually leads me to a decent solution. How can I visualize 3D collision better?</p><p>The key for Obra Dinn turns out to be ditching the 3rd dimension entirely and treating ship collision as top-down 2D maps. Each deck has its own map and they're connected via special staircases. I built a system called "Walkways" to automatically generate and use these 2D maps.</p><p><b><span size="5">Walkways</span></b></p><p>Once we decide that player movement and collision can happen in 2D, the challenge is how to automatically collapse the complex 3D scenes into 2D&nbsp;without the need&nbsp;for manual touchup. Walkways encapsulate this&nbsp;as an offline build process. I'll first cover how individual walkways are built to let the player walk around on a single manifold surface. After that I'll talk about how multiple stacked walkways can be connected together to allow full navigation through a complex 3D scene.</p><p><img src="http://3909.co/dev/od/img/Walkway-TestScene.png" alt="" width="700" height="400"></p><p>A small test scene. Blue capsule is the player.</p><p><span size="4">The Ground Floor</span></p><p>Walkways are built from several components, starting with a floor. The floor defines the ground surface that the player sticks to. It doesn't have to be flat - the geometry can include bumps, dips, ramps, etc. The only restriction is that the player's foot position always stays on the highest Y point of the surface; no overlapping.</p><p><img src="http://3909.co/dev/od/img/Walkway-Floor.png" alt="" width="700" height="400"></p><p>The floor</p><p><span size="4">Brow and Knee Heights</span></p><p>Our goal is to take the collection of 3D obstacles in the scene and reduce them to a top-down 2D representation.&nbsp;Since we're generating a 2D map of a 3D scene, we need to decide which slice of that scene will contribute to the map. Ideally we want to&nbsp;ignore small obstacles on the ground and ceiling and only consider the parts of obstacles that would cross the player's middle. To do this, "brow" and "knee" heights are defined as offsets from the floor. Anything above the knee&nbsp;and below the brow is considered solid. Anything outside this region should be ignored.</p><p><img src="http://3909.co/dev/od/img/Walkway-SolidRegion.png" alt=""></p><p>Solid region between brow and knee heights, defined as offsets from the floor.</p><p><span size="4">Poor Man's&nbsp;CSG</span></p><p>Ignoring anything outside the solid region is easy to say, but how can we actually implement it? One way would be to run full geometry CSG on the shapes, intersecting each obstacle with the solid region. That's mathy and prone to CSG fuckups, the worst kind.</p><p>Instead, we turn to the GPU:</p><p><b>&nbsp; 1</b>&nbsp;Create a down-facing orthogonal camera that encapsulates the entire scene.<br><b>&nbsp; 2</b>&nbsp;Render the floor+brow offset depth encoded into the RG channels of a render target.<br><b>&nbsp; 3</b>&nbsp;Render the floor+knee offset depth encoded into BA channels of the same render target.<br><b>&nbsp; 4</b>&nbsp;Render all the obstacles into another render target, clipping any pixels greater than or less than the brow/knee depths.</p><p><img src="http://3909.co/dev/od/img/Walkway-Targets1.png" alt="" width="700" height="400"><br>Floor with brow and knee height offsets encoded into RGBA, and resulting obstacle map</p><p><img src="http://3909.co/dev/od/img/Walkway-SolidBlocksScene.png" alt="" width="700" height="400"><br>Debug view of the result. Note how the geometry is properly clipped based on the uneven floor shape.<br></p><p><img src="http://3909.co/dev/od/img/Walkway-SolidRender.gif" alt="" width="700" height="400"></p><p>Animating through different brow/knee heights. First animated gif of the post and it's a good one.</p><p><span size="4">Almost</span></p><p>This "GPU CSG" technique is fast and easy&nbsp;but it critically misses writing&nbsp;any edges perpendicular to the top-down camera. In this case, the tall wall and tall cylinder are absent from the&nbsp;obstacle&nbsp;map. This is because their top/bottom caps are outside the solid region and the perpendicular edges resolve to no visible pixels.</p><p>There's a relatively simple fix for this. Instead of just rendering a single top-down orthogonal view it's possible accumulate multiple renders, skewing the view a little bit each time using a carefully-calculated oblique matrix:</p><p><img src="http://3909.co/dev/od/img/Walkway-SolidBlocks2.png" alt="" width="400" height="400"></p><p>Skewed accumulated obstacle&nbsp;map. The wall and cylinder now appear.</p><p>This accounts for all shapes within the solid region and has the added bonus of exposing an "expansion" feature:</p><p><img src="http://3909.co/dev/od/img/Walkway-Expand.gif" alt="" width="400" height="400"></p><p>Animating through various skew magnitudes</p><p><span size="4">Vectorizing</span></p><p>Now that we have the obstacle map, how can we use it? There's more than one way, but I decided keeping huge images around was a waste and I should&nbsp;vectorize it first. To do that, I reached back 9 years to dig out some code from one of&nbsp;our old games, <a href="http://www.ratloop.com/?games/mightier" target="_blank">Mightier</a>. There, the code was used to convert player drawings into inflated 3D characters that run around in small puzzle-platformer levels. Sort of. It's a weird game.</p><p>Anyways, my partner wrote the 1-bit bitmap vectorizer code for Mightier and after a quick port from C++ to C# it worked great for this task.&nbsp;The algorithms are pretty simple, based on flood fills and border tracing. The end result is a hierarchy of shapes.</p><p><img src="http://3909.co/dev/od/img/Walkway-Vectorized.png" alt="" width="400" height="400"></p><p>Vectorized obstacle map</p><p><img src="http://3909.co/dev/od/img/Walkway-VectorizedScene.png" alt="" width="700" height="400"></p><p>Debug shapes rendered in-scene</p><p>The vectorizer also has a simplification pass, which makes it easy to scale the level of detail. I don't adjust this currently; just set it once and forget it. Maybe it'll be useful later when I want to tweak the complexity in some scene. It makes another decent animated gif though so here:</p><p><img src="http://3909.co/dev/od/img/Walkway-Simplifier.gif" alt="" width="400" height="400"></p><p>Running through the simplifier with various thresholds</p><p><span size="4">To a Physical World</span></p><p>With the vectorized shapes, it's now possible to get a&nbsp;2D physics simulation going. You could add a simple circle or ray caster and be most of the way there. Or&nbsp;if you're on Unity you can just use the built-in Box2D implementation, which is totally independent of the 3D physics/collision system and can run concurrently.</p><p><img src="http://3909.co/dev/od/img/Walkway-Physics2D.png" alt="" width="700" height="506"></p><p>Shapes converted to PolygonCollider2Ds, from XZ to XY</p><p>Unity makes this really easy - the shape points can be fed directly into closed PolygonCollider2D or open&nbsp;EdgeCollider2D components. There's some need to consider the coordinate changes since the 2D physics system runs on XY and our 3D world uses XZ, but it's not too painful.</p><p><span size="4">Where's the Air</span></p><p>Because the vectorizer finds all the nested shapes, and there may be shapes that completely enclose the player's movement area (like the half-cylinder wall on the left), it's necessary to know which part of the obstacle map is considered "air" or empty space. In the Unity 2D physics world, this determines which shapes the player will be confined within (possibly-open&nbsp;EdgeCollider2Ds) and which ones they're prevented from entering (closed PolygonCollider2Ds).</p><p>Given my pipeline I found it simplest to just add a locator child to the floor plane to specify where the open air was.</p><p><img src="http://3909.co/dev/od/img/Walkway-AirMaya.png" alt="" width="700" height="450"></p><p>Placing the "air" locator to define empty space where the player can move</p><p><img src="http://3909.co/dev/od/img/Walkway-Air.gif" alt="" width="700" height="400"></p><p>Resultant shapes with different air positions (white cross)</p><p>In the debug view, the dotted orange line represents the&nbsp;EdgeCollider2D that contains the player's&nbsp;outer bounds of movement. Moving the air position to inside the small half-circle wall limits the player to that space since there's no connection to the outside.&nbsp;</p><p>This could be used with the shape expansion parameter set to the player's radius to easily show the&nbsp;accessible area, a super useful thing&nbsp;in navigation. I say "could" because right now the shape expansion is only good enough for catching perpendicular edges and doesn't give exact expansions. Visually auditing the walkway is so easy currently that I haven't gone further.</p><p><img src="http://3909.co/dev/od/img/Walkway-ShipStatic.png" alt="" width="700" height="400"></p><p>2D walkway generated for the top deck of the ship</p><p>(Too big for one post. Continued in next)</p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>