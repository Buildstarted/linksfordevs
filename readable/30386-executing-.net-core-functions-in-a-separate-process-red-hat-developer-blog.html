<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Executing .NET Core functions in a separate process - Red Hat Developer Blog -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Executing .NET Core functions in a separate process - Red Hat Developer Blog</h1>
    <article id="post-609757" class="post-609757 post type-post status-publish format-standard has-post-thumbnail hentry category-dot-net tag-net-core"> <div class="entry-content standard-post"> <img width="1916" src="https://developers.redhat.com/blog/wp-content/uploads/2019/07/forking-road-pixabay.jpg" class="single-post-featured-img wp-post-image" alt="Executing .NET Core functions in a separate process" srcset="https://developers.redhat.com/blog/wp-content/uploads/2019/07/forking-road-pixabay.jpg 1916w, https://developers.redhat.com/blog/wp-content/uploads/2019/07/forking-road-pixabay-300x163.jpg 300w, https://developers.redhat.com/blog/wp-content/uploads/2019/07/forking-road-pixabay-768x417.jpg 768w, https://developers.redhat.com/blog/wp-content/uploads/2019/07/forking-road-pixabay-1024x556.jpg 1024w" sizes="(max-width: 1916px) 100vw, 1916px"> <p>In this article, we&#x2019;ll take a look at <code><a href="https://github.com/tmds/Tmds.ExecFunction">Tmds.ExecFunction</a></code>, which is a library that allows developers to easily execute a .NET Core function in a separate process.</p>
<h2>Use cases</h2>
<p>Before we get to the code, let&#x2019;s cover a few scenarios where it makes sense to execute a function as a separate process. Processes have some global state, like environment variables and the working directory. Most of the time, this global state doesn&#x2019;t cause issues: When it is meaningful, libraries provide an API that allows the user to override the values. For testing, though, it&#x2019;s a different story. To verify the application is properly using the global state as a default, we need to modify it. This factor is an issue because the state is shared with the test host process and the other tests running in that process. We can solve this issue by running code in a separate process that we can fully control.</p>
<p>The second class of use cases occurs when we want code to run with a different lifetime from the parent process. For example, suppose we want to start a process and ensure it doesn&#x2019;t outlive the .NET parent (even on crashes). We could do this by putting a small process in between that monitors the parent, and kills the child when the parent has terminated. Another example is to implement <a href="http://thelinuxjedi.blogspot.com/2014/02/why-use-double-fork-to-daemonize.html">double forking</a>, which is used in script-based <code>init</code> managers to make sure the daemon outlives the shell that launched it. Most distributions (like <a href="https://getfedora.org/">Fedora</a> and <a href="https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux">Red Hat Enterprise Linux</a>) are now using <code>systemd</code> as their <code>init</code> manager, which doesn&#x2019;t need daemons to double fork.</p>
<h2><code>Tmds.ExecFunction</code></h2>
<p><code>Tmds.ExecFunction</code> is a library inspired by .NET Core&#x2019;s <code><a href="https://github.com/dotnet/arcade/tree/6a34948f7bdbc3ceb2fb16441b49f7748a462646/src/Microsoft.DotNet.RemoteExecutor/src/Microsoft.DotNet.RemoteExecutor">RemoteExecutor</a></code>, which is used in <a href="https://github.com/dotnet/corefx/">.NET Core&#x2019;s class library</a> for writing tests that need a separate process. This library is available on <a href="https://www.nuget.org">NuGet.org</a>, so we can add it to our project using:</p>
<pre>dotnet add package Tmds.ExecFunction</pre>
<p>Now, let&#x2019;s use it:</p>
<pre>ExecFunction.Run(() =&gt; Console.WriteLine(&quot;Hello world!&quot;));</pre>
<p>We are using <code>ExecFunction.Run</code> and passing it a lambda that prints <code>Hello world!</code> That lambda is executed in a separate process. The <code>Run</code> method then returns when the child has terminated. <code>ExecFunction</code> also provides a <code>Start</code> method that returns a <code>System.Diagnostics.Process</code> and then returns immediately when the process starts. A <code>RunAsync</code> method is also provided, which returns a <code>Task</code> that completes when the process terminates.</p>
<p>The function we pass can have a .NET <code>Main</code> signature: a <code>void</code>/<code>string[]</code> argument and a <code>void</code>/<code>int</code>/<code>Task</code>/<code>Task</code> return type.</p>
<p>For example, we can pass some arguments:</p>
<pre>ExecFunction.Run(
    (string[] args) =&gt; Console.WriteLine($&quot;Hello {args[0]}&quot;),
    new string[] { &quot;world!&quot; });
</pre>
<p>We can also control the environment variables, working directory, etc. by passing a configuration function:</p>
<pre>ExecFunction.Run(
    () =&gt; Console.WriteLine($&quot;HOME={Environment.GetEnvironmentVariable(&quot;HOME&quot;)}&quot;),
    o =&gt; o.StartInfo.Environment[&quot;HOME&quot;] = &quot;/tmp&quot;);
</pre>
<p>The <code>FunctionExecutor</code> class makes it easy to reuse the same configuration for multiple invocations, as well. For example, we can use it as follows in <a href="https://xunit.net/">xUnit</a> tests:</p>
<pre>private FunctionExecutor Executor = new FunctionExecutor(
    o =&gt;
    {
            o.StartInfo.RedirectStandardError = true;
            o.OnExit = p =&gt;
            {
                    if (p.ExitCode != 0)
                    {
                string message = $&quot;Function execution failed with exit code: {p.ExitCode}&quot; + Environment.NewLine +
                                p.StandardError.ReadToEnd();
                throw new Xunit.Sdk.XunitException(message);
                    }
            };
    });

[Fact]
public void Test()
{
    Executor.Run(
        () =&gt;
        {
                Assert.Equal(&quot;/tmp&quot;, Environment.GetEnvironmentVariable(&quot;HOME&quot;));
        },
        o =&gt; o.StartInfo.Environment[&quot;HOME&quot;] = &quot;/tmp&quot;
    );
}
</pre>
<p>So far, we&#x2019;ve been assuming you use the <code>dotnet</code> executable to host your application; for example, by starting xUnit tests using <code>dotnet test</code>. To make <code>ExecuteFunction</code> work from an application host (that is, you built your application into a native binary), we need to add a hook in the <code>Main</code> function:</p>
<pre>static int Main(string[] args)
{
    if (ExecFunction.IsExecFunctionCommand(args))
    {
            return ExecFunction.Program.Main(args);
    }
    else
    {
            ExecFunction.Run(() =&gt; System.Console.WriteLine(&quot;Hello world!&quot;));
            return 0;
    }
}
</pre>
<h2>Conclusion</h2>
<p>In this article, we&#x2019;ve shown how to execute .NET Core code easily in a separate process using <code><a href="https://github.com/tmds/Tmds.ExecFunction">Tmds.ExecFunction</a></code>, and when doing so can be useful. Now, explore what you can make this library do.</p> <div class="addtoany_share_save_container addtoany_content addtoany_content_bottom"><div class="a2a_kit a2a_kit_size_16 addtoany_list"><a class="a2a_button_facebook" href="https://www.addtoany.com/add_to/facebook?linkurl=https%3A%2F%2Fdevelopers.redhat.com%2Fblog%2F2019%2F07%2F17%2Fexecuting-net-core-functions-in-a-separate-process%2F&amp;linkname=Executing%20.NET%20Core%20functions%20in%20a%20separate%20process"></a><a class="a2a_button_twitter" href="https://www.addtoany.com/add_to/twitter?linkurl=https%3A%2F%2Fdevelopers.redhat.com%2Fblog%2F2019%2F07%2F17%2Fexecuting-net-core-functions-in-a-separate-process%2F&amp;linkname=Executing%20.NET%20Core%20functions%20in%20a%20separate%20process"></a><a class="a2a_button_linkedin" href="https://www.addtoany.com/add_to/linkedin?linkurl=https%3A%2F%2Fdevelopers.redhat.com%2Fblog%2F2019%2F07%2F17%2Fexecuting-net-core-functions-in-a-separate-process%2F&amp;linkname=Executing%20.NET%20Core%20functions%20in%20a%20separate%20process"></a><a class="a2a_button_email" href="https://www.addtoany.com/add_to/email?linkurl=https%3A%2F%2Fdevelopers.redhat.com%2Fblog%2F2019%2F07%2F17%2Fexecuting-net-core-functions-in-a-separate-process%2F&amp;linkname=Executing%20.NET%20Core%20functions%20in%20a%20separate%20process"></a><a class="a2a_button_print" href="https://www.addtoany.com/add_to/print?linkurl=https%3A%2F%2Fdevelopers.redhat.com%2Fblog%2F2019%2F07%2F17%2Fexecuting-net-core-functions-in-a-separate-process%2F&amp;linkname=Executing%20.NET%20Core%20functions%20in%20a%20separate%20process"></a><a class="a2a_button_reddit" href="https://www.addtoany.com/add_to/reddit?linkurl=https%3A%2F%2Fdevelopers.redhat.com%2Fblog%2F2019%2F07%2F17%2Fexecuting-net-core-functions-in-a-separate-process%2F&amp;linkname=Executing%20.NET%20Core%20functions%20in%20a%20separate%20process"></a><a class="a2a_button_flipboard" href="https://www.addtoany.com/add_to/flipboard?linkurl=https%3A%2F%2Fdevelopers.redhat.com%2Fblog%2F2019%2F07%2F17%2Fexecuting-net-core-functions-in-a-separate-process%2F&amp;linkname=Executing%20.NET%20Core%20functions%20in%20a%20separate%20process"></a><a class="a2a_dd addtoany_share_save addtoany_share" href="https://www.addtoany.com/share"><img src="https://static.addtoany.com/buttons/favicon.png" alt="Share"></a></div></div> </div> </article>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>