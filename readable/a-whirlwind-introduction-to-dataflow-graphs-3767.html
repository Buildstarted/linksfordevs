<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A whirlwind introduction to dataflow graphs - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="A whirlwind introduction to dataflow graphs - linksfor.dev(s)"/>
    <meta property="og:description" content="While in the middle of writing &#x201C;Reading bits in far too many ways, part 3&#x201D;, I realized that I had written a lot of background material that had absolutely nothing to do with bit I/O and&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://fgiesen.wordpress.com/2018/03/05/a-whirlwind-introduction-to-dataflow-graphs/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A whirlwind introduction to dataflow graphs</title>
<div class="readable">
        <h1>A whirlwind introduction to dataflow graphs</h1>
            <div>Watching time: 32-40 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://fgiesen.wordpress.com/2018/03/05/a-whirlwind-introduction-to-dataflow-graphs/">https://fgiesen.wordpress.com/2018/03/05/a-whirlwind-introduction-to-dataflow-graphs/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
								<p>While in the middle of writing ‚ÄúReading bits in far too many ways, part 3‚Äù, I realized that I had written a lot of background material that had absolutely nothing to do with bit I/O and really was worth putting in its own post. This is that post.</p>
<p>The problem I‚Äôm concerned with is fairly easy to state: say we have some piece of C++ code that we‚Äôre trying to understand (and perhaps improve) the performance of. A good first step is to profile it, which will give us some hints <em>which</em> parts are slow, but not necessarily <em>why</em>. On a fundamental level, any kind of profiling (or other measurement) is <em>descriptive</em>, not <em>predictive</em>: it can tell you how an existing system is behaving, but if you‚Äôre designing something that‚Äôs more than a few afternoons worth of work, you probably don‚Äôt have the time or resources to implement 5 or 6 completely different design alternatives, pick whichever one happens to work best, and throw the rest away. You should be able to make informed decisions up front from an algorithm sketch without having to actually write a fleshed-out implementation.</p>
<p>One thing I want to emphasize particularly here is that experiments coupled with before/after measurements are no adequate substitute for a useful performance model. These kinds of measurements can tell you how much you‚Äôve improved, but not if you are where you should be: if I tell you that by tweaking some config files, I managed to double the number of requests served per second by the web server, that sounds great. It sounds less good if I give you the additional piece of information that with this fix deployed, we‚Äôre now at a whopping 1.5 requests per second; having an absolute scale of reference matters!</p>
<p>This goes especially for microbenchmarks. With microbenchmarks, like a trial lawyer during cross-examination, <em>you should never ask a question you don‚Äôt know the answer to</em> (or at least have a pretty good idea of what it is). Real-world systems are generally too complex and intertwined to understand from surface measurements alone. If you have no idea how a system works at all, you don‚Äôt know what the right questions are, nor how to ask them, and any answers you get will be opaque at best, if not outright garbage. Microbenchmarks are a useful tool to confirm that an existing model is a good approximation to reality, but not very helpful in building these models to begin with.</p>
<h3>Machine models</h3>
<p>So, if we want to go deeper than just squinting at C/C++ code and doing some hand-waving, we need to start looking at a somewhat lower abstraction level and define a machine model that is more sophisticated than ‚Äústatements execute one by one‚Äù. If you‚Äôre only interested in a single specific processor, one option is to use whatever documentation and tools you can find for the chip in question and analyze your code in detail for that specific machine. And if you‚Äôre willing to go all-out on microarchitectural tweaking, that‚Äôs indeed the way to go, but it‚Äôs a giant step from looking at C++ code, and complete overkill in most cases.</p>
<p>Instead, what I‚Äôm going to do is use a simplified machine model that allows us to make quantitative predictions about the behavior of straightforward compute-bound loops, which is simple to describe but still gives us a lot of useful groundwork for more complex scenarios. Here‚Äôs what I‚Äôll use:</p>
<ul>
<li>We have an unlimited set of 64-bit integer general-purpose registers, which I‚Äôll refer to by names like <code>rSomething</code>. Any ‚Äúidentifiers‚Äù that aren‚Äôt prefixed with a lowercase r are either symbolic constants or things like labels.</li>
<li>We have the usual 64-bit integer arithmetic and logic operations. All operations can either be performed between two registers or a register and an immediate constant, and the result is placed in another register. All arithmetic uses two‚Äôs complement. For simplicity, all 64-bit values are permitted as immediate constants.</li>
<li>There‚Äôs a flat, byte-granular 64-bit address space, and pointers are just represented as integers.</li>
<li>All memory accesses require explicit load and store operations. Memory accesses are either 8, 16, 32, or 64 bits in size and can use (for my convenience) both little-endian or big-endian byte ordering, when requested. One of these is the default, but both are the same cost. Narrow stores store the least significant bits of the register in question; narrow loads zero-extend to 64 bits. Loads and stores have a few common addressing modes (that I‚Äôll introduce as I use them). Unaligned loads and stores are supported.</li>
<li>There‚Äôs unconditional branches, which just jump to a given location, and conditional branches, which compare a register to either another register or an immediate constant, and branch to a given destination if the condition is true.</li>
</ul>
<p>Code will be written in a pseudo-C form, at most one instruction per line. Here‚Äôs a brief example showing what kind of thing I have in mind:</p>
<pre>loop:                            // label
  rFoo = rBar | 1;               // bitwise logical OR
  rFoo = lsl(rFoo, 3);           // logical shift left
  rBar = asr(rBar, rBaz);        // arithmetic shift right
  rMem = load64LE(rBase + rFoo); // little-endian load
  store16BE(rDest + 3, rMem);    // big-endian store
  rCount = rCount - 1;           // basic arithmetic
  if rCount != 0 goto loop;      // branch
</pre>
<p>Shifts use explicit mnemonics because there‚Äôs different types of right shifts and at this level of abstraction, registers are generally treated as untyped bags of bits. I‚Äôll introduce other operations and addressing modes as we get to them. What we‚Äôve seen so far is quite close to classic RISC instruction sets, although I‚Äôll allow a larger set of addressing modes than some of the more minimalist designs, and require support for unaligned access on all loads and stores. It‚Äôs also close in spirit to an IR (Intermediate Representation) you‚Äôd expect to see early in the backend of a modern compiler: somewhat lower-level than LLVM IR, and comparable to early-stage LLVM Machine IR or GCC RTL.</p>
<p>This model requires us to make the distinction between values kept in registers and memory accesses explicit, and flattens down control flow to basic blocks connected by branches. But it‚Äôs still relatively easy to look at a small snippet of C++ and e.g. figure out how many arithmetic instructions it boils down to: just count the number of operations.</p>
<p>As a next step, we could now specify a virtual processor to go with our instruction set, but I don‚Äôt want to really get into that level of detail; instead of specifying the actual processor, I‚Äôll work the same way actual architectures do: we require that the end result (eventual register and memory contents in our model) of running a program must be as if we had executed the instructions sequentially one by one (as-if rule). Beyond that, an aggressive implementation is free to cut corners as much as it wants provided it doesn‚Äôt get caught. We‚Äôll assume we‚Äôre in an environment‚Äîthe combination of compilers/tools and the processor itself‚Äîthat uses pipelining and tries to extract instruction-level parallelism to achieve higher performance, in particular:</p>
<ul>
<li>Instructions can launch independent from each other, and take some number of clock cycles to complete. For an instruction to start executing, all the operands it depends on need to have been computed. As long as the dependencies are respected, all reorderings are valid.</li>
<li>There is <em>some</em> limit W (‚Äúwidth‚Äù) on how many new instructions we can start per clock cycle. In-flight instructions don‚Äôt interfere with each other; as long as we have enough independent work, we can start W new instructions every cycle. We‚Äôre going to treat W as variable.</li>
<li>Memory operations have a latency of 4 cycles, meaning that the result of a load is available 4 cycles after the load issued, and a load reading the bytes written by a prior store can issue 4 cycles after the store. That‚Äôs a fairly typical latency for a load that hits in the L1 cache, in case you were wondering.</li>
<li>Branches (conditional or not) count as a single instruction, but their latency is variable. Unconditional branches or easily predicted branches such as the loop counter in along-running loop have an effective latency of 0 cycles, meaning the instructions being branched to can issue at the same time as the branch itself. Unpredictable branches have a nonzero cost that depends on how unpredictable they are‚ÄîI won‚Äôt even try to be more precise here.</li>
<li>Every other instruction has a latency of 1 clock cycle, meaning the result is available in the next cycle.</li>
</ul>
<p>This model can be understood as approximating either a <a href="https://en.wikipedia.org/wiki/Dataflow_architecture">dataflow architecture</a>, an out-of-order machine with a very large issue window (and infinitely fast front-end), or a statically scheduled in-order machine running code compiled with a Sufficiently Smart Scheduler. (The kind that actually exists; e.g. a compiler implementing <a href="https://en.wikipedia.org/wiki/Software_pipelining">software pipelining</a>).</p>
<p>Furthermore, I‚Äôm assuming that while there is explicit control flow (unlike a pure dataflow machine), there is a branch prediction mechanism in place that allows the machine to guess the control flow path taken arbitrarily far in advance. When these guesses are correct, the branches are effectively free other than still taking an instruction slot, during which time the machine checks whether its prediction was correct. When the guess was incorrect, the machine reverts all computations that were down the incorrectly guessed path, and takes some number of clock cycles to recover. If this idea of branch prediction is new to you, I‚Äôll refer you to <a href="http://danluu.com/branch-prediction/">Dan Luu‚Äôs excellent article</a> on the subject, which explains both how and why computers would be doing this.</p>
<p>The end result of these model assumptions is that while control flow exists, it‚Äôs on the sidelines: its only observable effect is that it sometimes causes us to throw away a bunch of work and take a brief pause to recover when we guessed wrong. Dataflow, on the other hand‚Äîthe dependencies between instructions, and how long it takes for these dependencies to be satisfied‚Äîis front and center.</p>
<h3>Dataflow graphs</h3>
<p>Why this emphasis? Because dataflow and data dependencies is because they can be viewed as the fundamental expression of the structure of a particular computation, whether it‚Äôs done on a small sequential machine, a larger superscalar out-of-order CPU, a GPU, or in hardware (be it a hand-soldered digital circuit, a FPGA, or an ASIC). Dataflow and keeping track of the shape of data dependencies is an organizing principle of both the machines themselves and the compilers that target them.</p>
<p>And these dependencies are naturally expressed in graph form, with individual operations being the nodes and data dependencies denoted by directed edges. In this post, I‚Äôll have dependent operations point towards the operations they depend on, with the directed edges labeled with their latency. To reduce clutter, I‚Äôll only write latency numbers when they‚Äôre not 1.</p>
<p>With all that covered, and to see what the point of this all is, let‚Äôs start with a simple, short toy program that just sums the 64-bit integers in some array delineated by two pointers stored in <code>rCurPtr</code> (which starts pointing to the first element) and <code>rEndPtr</code> (which points to one past the last element), idiomatic C++ iterator-style.</p>
<pre>loop:
  rCurInt = load64(rCurPtr);        // Load
  rSum = rSum + rCurInt;            // Sum
  rCurPtr = rCurPtr + 8;            // Advance
  if rCurPtr != rEndPtr goto loop;  // Done?
</pre>
<p>We load a 64-bit integer from the current pointer, add it to our current running total in register <code>rSum</code>, increment the pointer by 8 bytes (since we grabbed a 64-bit integer), and then loop until we‚Äôre done. Now let‚Äôs say we run this program for a short 6 iterations and draw the corresponding dataflow graph (click to see full-size version):</p>
<p><a href="https://fgiesen.files.wordpress.com/2018/03/array_sum-gv1.png"><img data-attachment-id="7086" data-permalink="https://fgiesen.wordpress.com/2018/03/05/a-whirlwind-introduction-to-dataflow-graphs/array_sum-gv/" data-orig-file="https://fgiesen.files.wordpress.com/2018/03/array_sum-gv1.png" data-orig-size="832,481" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dataflow graph for basic array sum" data-image-description="" data-medium-file="https://fgiesen.files.wordpress.com/2018/03/array_sum-gv1.png?w=300" data-large-file="https://fgiesen.files.wordpress.com/2018/03/array_sum-gv1.png?w=497" src="https://fgiesen.files.wordpress.com/2018/03/array_sum-gv1.png?w=497" alt="Dataflow graph for basic array sum" srcset="https://fgiesen.files.wordpress.com/2018/03/array_sum-gv1.png?w=497 497w, https://fgiesen.files.wordpress.com/2018/03/array_sum-gv1.png?w=150 150w, https://fgiesen.files.wordpress.com/2018/03/array_sum-gv1.png?w=300 300w, https://fgiesen.files.wordpress.com/2018/03/array_sum-gv1.png?w=768 768w, https://fgiesen.files.wordpress.com/2018/03/array_sum-gv1.png 832w" sizes="(max-width: 497px) 100vw, 497px"></a></p>
<p>Note I group nodes into ranks by which cycle they can execute in, at the earliest, assuming we can issue as many instructions in parallel as we want, purely constrained by the data dependencies. The ‚ÄúLoad‚Äù and ‚ÄúAdvance‚Äù from the first iteration can execute immediately; the ‚ÄúDone?‚Äù check from the first iteration looks at the updated <code>rCurPtr</code>, which is only known one cycle later; and ‚ÄúSum‚Äù from the first iteration needs to wait for the load to finish, which means it can only start a full 4 cycles later.</p>
<p>As we can see, during the first four cycles, all we do is keep issuing more loads and advancing the pointer. It takes until cycle 4 for the results of the first load to become available, so we can actually do some summing. After that, one more load completes every cycle, allowing us to add one more integer to the running sum in turn. If we let this process continue for longer, all the middle iterations would look the way cycles 4 and 5 do: in our state state, we‚Äôre issuing a copy of all four instructions in the loop every cycle, but from different iterations.</p>
<p>There‚Äôs a few conclusions we can draw from this: first, we can see that this four-instruction loop achieves a steady-state throughput of one integer added to the sum in every clock cycle. We take a few cycles to get into the steady state, and then a few more cycles at the end to drain out the pipeline, but if we start in cycle 0 and keep running N iterations, then the final sum will be completed by cycle N+4. Second, even though I said that our model has infinite lookahead and is free to issue as many instructions per cycle as it wants, we ‚Äúonly‚Äù end up using at most 4 instructions per cycle. The limiter here ends up being the address increment (‚ÄúAdvance‚Äù); we increment the pointer after every load, per our cost model this increment takes a cycle of latency, and therefore the load in the next iteration of the loop (which wants to use the updated pointer) can start in the next cycle at the earliest.</p>
<p>This is a crucial point: the longest-latency instruction in this loop is definitely the load, at 4 cycles. But that‚Äôs not a limiting factor; we can schedule around the load and do the summing later. The actual problem here is with the pointer advance; every single instruction that comes after it in program order depends on it either directly or indirectly, and therefore, its 1 cycle of latency determines when the next loop iteration can start. We say it‚Äôs on the <em>critical path</em>. In loops specifically, we generally distinguish between intra-iteration dependencies (between instructions within the same iteration, say ‚ÄúSum 0‚Äù depending on ‚ÄúLoad 0‚Äù) and inter-iteration or loop-carried dependencies (say ‚ÄúSum 1‚Äù depending on ‚ÄúSum 0‚Äù, or ‚ÄúLoad 1‚Äù depending on ‚ÄúAdvance 0‚Äù). Intra-iteration dependencies may end up delaying instructions within that iteration quite a lot, but it‚Äôs inter-iteration dependencies that determine how soon we can start working on the next iteration of the loop, which is usually more important because it tends to open up more independent instructions to work on.</p>
<p>The good news is that W=4 is actually a fairly typical number of instructions decoded/retired per cycle in current (as of this writing in early 2018) out-of-order designs, and the instruction mixture here (1 load, 1 branch, 2 arithmetic instructions) is also one that is quite likely to be able to issue in parallel on a realistic 4-wide decode/retire design. While many machines can issue a lot more instructions than that in short bursts, a steady state of 4 instructions per cycle is definitely good. So even though we‚Äôre not making much of the infinite parallel computing power of our theoretical machine, in practical terms, we‚Äôre doing OK, although on real machines we might want to apply some more transforms to the loop; see below.</p>
<p>Because these real-world machines can‚Äôt start an arbitrary number of instructions at the same time, we have another concern: throughput. Say we‚Äôre running the same loop on a processor that has W=2, i.e. only two instructions can start every cycle. Because our loop has 4 instructions, that means that we can‚Äôt possibly start a new loop iteration more often than once every two clock cycles, and the limiter aren‚Äôt the data dependencies, but the number of instructions our imaginary processor can execute in a clock cycle; we‚Äôre throughput-bound. We would also be throughput-bound on a machine with W=3, with a steady state of 3 new instructions issued per clock cycle, where we can start working on a new iteration every 4/3‚âà1.33 cycles.</p>
<h3>A different example</h3>
<p>For the next example, we‚Äôre going to look at&nbsp;what‚Äôs turned into everyone‚Äôs favorite punching-bag of a data structure, the linked list. Let‚Äôs do the exact same task as before, only this time, the integers are stored in a singly-linked list instead of laid out as an array. We store first a 64-bit integer and then a 64-bit pointer to the next element, with the end of the list denoted by a special value stored in <code>rEndPtr</code> as before. We also assume the list has at least 1 element. The corresponding program looks like this:</p>
<pre>loop:
  rCurInt = load64(rCurPtr);        // LoadInt
  rSum = rSum + rCurInt;            // Sum
  rCurPtr = load64(rCurPtr + 8);    // LoadNext
  if rCurPtr != rEndPtr goto loop;  // Done?
</pre>
<p>Very similar to before, only this time, instead of incrementing the pointer, we do another load to grab the ‚Äúnext‚Äù pointer. And here‚Äôs what happens to the dataflow graph if we make this one-line change:</p>
<p><a href="https://fgiesen.files.wordpress.com/2018/03/linked_list_sum-gv.png"><img data-attachment-id="7087" data-permalink="https://fgiesen.wordpress.com/2018/03/05/a-whirlwind-introduction-to-dataflow-graphs/linked_list_sum-gv/" data-orig-file="https://fgiesen.files.wordpress.com/2018/03/linked_list_sum-gv.png" data-orig-size="607,629" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dataflow graph for linked list sum" data-image-description="" data-medium-file="https://fgiesen.files.wordpress.com/2018/03/linked_list_sum-gv.png?w=290" data-large-file="https://fgiesen.files.wordpress.com/2018/03/linked_list_sum-gv.png?w=497" src="https://fgiesen.files.wordpress.com/2018/03/linked_list_sum-gv.png?w=497" alt="Dataflow graph for linked list sum" srcset="https://fgiesen.files.wordpress.com/2018/03/linked_list_sum-gv.png?w=497 497w, https://fgiesen.files.wordpress.com/2018/03/linked_list_sum-gv.png?w=145 145w, https://fgiesen.files.wordpress.com/2018/03/linked_list_sum-gv.png?w=290 290w, https://fgiesen.files.wordpress.com/2018/03/linked_list_sum-gv.png 607w" sizes="(max-width: 497px) 100vw, 497px"></a></p>
<p>Switching from a contiguous array to a linked list means that we have to wait for the load to finish before we can start the next iteration. Because loads have a latency of 4 cycles in our model, that means we can‚Äôt start a new iteration any more often than once every 4 cycles. With our 4-instruction loop, we don‚Äôt even need any instruction-level parallelism to reach that target; we might as well just execute one instruction per cycle and still hit the same overall throughput.</p>
<p>Now, this example, with its short 4-instruction loop, is fairly extreme; if our loop had say a total of 12 instructions that worked out nicely, the same figure might well end up averaging 3 instructions per clock cycle, and that‚Äôs not so bad. But the underlying problem here is a nasty one: because our longest-latency instruction is on the critical path between iterations, it ends up determining the overall loop throughput.</p>
<p>In our model, we‚Äôre still primarily focused on compute-bound code, and memory access is very simple: there‚Äôs no memory hierarchy with different cache levels, all memory accesses take the same time. If we instead had a more realistic model, we would also have to deal with the fact that some memory accesses take a whole lot longer than 4 cycles to complete. For example, suppose we have three cache levels and, at the bottom, DRAM. Sticking with the powers-of-4 theme, let‚Äôs say that a L1 cache hit takes 4 cycles (i.e. our current memory access latency), a L2 hit takes 16 cycles, a L3 hit takes 64 cycles, and an actual memory access takes 256 cycles‚Äîfor what it‚Äôs worth, all these numbers are roughly in the right ballpark for high-frequency desktop CPUs under medium memory subsystem load as of this writing.</p>
<p>Finding work to keep the machine otherwise occupied for the next 4 cycles (L1 hit) is usually not that big a deal, unless we have a very short loop with unfavorable dependency structure, as in the above example. Fully covering the 16 cycles for a L1 miss but L2 hit is a bit trickier and requires a larger out-of-order window, but current out-of-order CPUs have those, and as long as there‚Äôs enough other independent work and not too many hard-to-predict branches along the way, things will work out okay. With a L3 cache hit, we‚Äôll generally be hard-pressed to find enough independent work to keep the core usefully busy during the wait for the result, and if we actually miss all the way to DRAM, then in our current model, the machine is all but guaranteed to stall; that is, to have many cycles with no instructions executed at all, just like the gaps in the diagram above.</p>
<p>Because linked lists have this nasty habit of putting memory access latencies on the critical path, they have a reputation of being slow ‚Äúbecause they‚Äôre bad for the cache‚Äù. Now while it‚Äôs definitely true that most CPUs with a cache would much rather have you iterate sequentially over an array, we have to be careful how we think about it. To elaborate, suppose we have yet another sum kernel, this time processing an array of pointers to integers, to compute the sum of the pointed-to values.</p>
<pre>loop:
  rCurIntPtr = load64(rCurPtr);      // LoadPtr
  rCurInt = load64(rCurIntPtr);      // LoadInt
  rSum = rSum + rCurInt;             // Sum
  rCurPtr = rCurPtr + 8;             // Advance
  if rCurPtr != rEndPtr goto loop;   // Done?
</pre>
<p>And this time, I‚Äôll prune the dataflow graph to show only the current iteration and its direct dependency relationships with earlier and later iterations, because otherwise these more complicated graphs will get cluttered and unreadable quickly:</p>
<p><a href="https://fgiesen.files.wordpress.com/2018/03/array_indir_sum-gv.png"><img data-attachment-id="7088" data-permalink="https://fgiesen.wordpress.com/2018/03/05/a-whirlwind-introduction-to-dataflow-graphs/array_indir_sum-gv/" data-orig-file="https://fgiesen.files.wordpress.com/2018/03/array_indir_sum-gv.png" data-orig-size="499,531" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dataflow graph for indirect array sum" data-image-description="" data-medium-file="https://fgiesen.files.wordpress.com/2018/03/array_indir_sum-gv.png?w=282" data-large-file="https://fgiesen.files.wordpress.com/2018/03/array_indir_sum-gv.png?w=497" src="https://fgiesen.files.wordpress.com/2018/03/array_indir_sum-gv.png?w=497" alt="Dataflow graph for indirect array sum" srcset="https://fgiesen.files.wordpress.com/2018/03/array_indir_sum-gv.png?w=497 497w, https://fgiesen.files.wordpress.com/2018/03/array_indir_sum-gv.png?w=141 141w, https://fgiesen.files.wordpress.com/2018/03/array_indir_sum-gv.png?w=282 282w, https://fgiesen.files.wordpress.com/2018/03/array_indir_sum-gv.png 499w" sizes="(max-width: 497px) 100vw, 497px"></a></p>
<p>A quick look over that graph shows us that copies of the same instruction from different iterations are all spaced 1 cycle apart; this means that in the steady state, we will again execute one iteration of the loop per clock cycle, this time issuing 5 instructions instead of 4 (because there are 5 instructions in the loop). Just like in the linked list case, the pointer indirection here allows us to jump all over memory (potentially incurring cache misses along the way) if we want to, but there‚Äôs a crucial difference: in this setup, we can keep setting up future iterations of the loop and get more loads started while we‚Äôre waiting for the first memory access to complete.</p>
<p>To explain what I mean, let‚Äôs pretend that every single of the ‚ÄúLoadInt‚Äùs misses the L1 cache, but hits in the L2 cache, so its actual latency is 16 cycles, not 4. But a latency of 16 cycles just means that it takes 16 cycles between issuing the load and getting the result; we can keep issuing other loads for the entire time. So the only thing that ends up happening is that the ‚ÄúSum k‚Äù in the graph above happens 12 cycles later. We still start two new loads every clock cycle in the steady state; some of them end up taking longer, but that does not keep us from starting work on a new iteration of the loop in every cycle.</p>
<p>Both the linked list and the indirect-sum examples have the opportunity to skip all over memory if they want to; but in the linked-list case, we need to wait for the result of the previous load until we can get started on the next one, whereas in the indirect-sum case, we get to overlap the wait times from the different iterations nicely. As a result, in the indirect-sum case, the extra latency towards reaching the final sum is essentially determined by the worst single iteration we had, whereas in the linked-list case, <em>every single cache miss</em> makes our final result later (and costs us throughput).</p>
<p>The fundamental issue isn‚Äôt that the linked-list traversal might end up missing the cache a lot; while this isn‚Äôt ideal (and might cost us in other ways), the far more serious issue is that <em>any such cache miss prevents us from making progress elsewhere</em>. Having a lot of cache misses isn‚Äôt necessarily a problem if we get to overlap them; having long stretches of time were we can‚Äôt do anything else, because everything else we could do depends on that one cache-missing load, is.</p>
<p>In fact, when we hit this kind of problem, our best bet is to just switch to doing something else entirely. This is what CPUs with simultaneous multithreading/hardware threads (‚Äúhyperthreads‚Äù) and essentially all GPUs do: build the machine so that it can process instructions from multiple instruction streams (threads), and then if one of the threads isn‚Äôt really making progress right now because it‚Äôs waiting for something, just work on something else for a while. If we have enough threads, then we can hopefully fill those gaps and always have something useful to work on. This trade-off is worthwhile if we have many threads and aren‚Äôt really worried about the extra latency caused by time-slicing, which is why this approach is especially popular in throughput-centric architectures that don‚Äôt worry about slight latency increases.</p>
<h3>Unrolling</h3>
<p>But let‚Äôs get back to our original integer sum code for a second:</p>
<pre>loop:
  rCurInt = load64(rCurPtr);        // Load
  rSum = rSum + rCurInt;            // Sum
  rCurPtr = rCurPtr + 8;            // Advance
  if rCurPtr != rEndPtr goto loop;  // Done?
</pre>
<p>We have a kernel with four instructions here. Out of these four, two (‚ÄúLoad‚Äù and ‚ÄúSum‚Äù) do the actual work we want done, whereas ‚ÄúAdvance‚Äù and ‚ÄúDone?‚Äù just implement the loop itself and are essentially overhead. This type of loop is a prime target for <a href="https://en.wikipedia.org/wiki/Loop_unrolling">unrolling</a>, where we collapse two or more iterations of the loop into one to decrease the overhead fraction. Let‚Äôs not worry about the setup or what to do when the number of elements in the array is odd right now, and only focus on the ‚Äúmeat‚Äù of the loop. Then a 2√ó unrolled version might look like this:</p>
<pre>loop:
  rCurInt = load64(rCurPtr);        // LoadEven
  rSum = rSum + rCurInt;            // SumEven
  rCurInt = load64(rCurPtr + 8);    // LoadOdd
  rSum = rSum + rCurInt;            // SumOdd
  rCurPtr = rCurPtr + 16;           // Advance
  if rCurPtr != rEndPtr goto loop;  // Done?
</pre>
<p>which has this dataflow graph:</p>
<p><a href="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum1-gv.png"><img data-attachment-id="7089" data-permalink="https://fgiesen.wordpress.com/2018/03/05/a-whirlwind-introduction-to-dataflow-graphs/unroll2x_array_sum1-gv/" data-orig-file="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum1-gv.png" data-orig-size="793,451" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dataflow graph for unrolled array sum, first attempt" data-image-description="" data-medium-file="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum1-gv.png?w=300" data-large-file="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum1-gv.png?w=497" src="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum1-gv.png?w=497" alt="Dataflow graph for unrolled array sum, first attempt" srcset="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum1-gv.png?w=497 497w, https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum1-gv.png?w=150 150w, https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum1-gv.png?w=300 300w, https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum1-gv.png?w=768 768w, https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum1-gv.png 793w" sizes="(max-width: 497px) 100vw, 497px"></a></p>
<p>Note that even though I‚Äôm writing to <code>rCurInt</code> twice in an iteration, which constitutes a write-after-write (WAW) or ‚Äúoutput dependency‚Äù, there‚Äôs no actual dataflow between the loads and sums for the first and second version of <code>rCurInt</code>, so the loads can issue in parallel just fine.</p>
<p>This isn‚Äôt bad: we now have two loads every iteration and spend 6N instructions to sum 2N integers, meaning we take 3 instructions per integer summed, whereas our original kernel took 4. That‚Äôs an improvement, and (among other things) means that while our original integer-summing loop needed a machine that sustained 4 instructions per clock cycle to hit full throughput, we can now hit the same throuhgput on a smaller machine that only does 3 instructions per clock. This is definitely progress.</p>
<p>However, there‚Äôs a problem: if we look at the diagram, we can see that we can indeed start a new pair of loads every clock cycle, but there‚Äôs a problem with the summing: we have two dependent adds in our loop, and as we can see from the relationship between ‚ÄúSumEven k‚Äù and ‚ÄúSumEven k+1‚Äù, the actual summing part of the computation still takes 2 cycles per iteration. On our idealized dataflow machine with infinite lookahead, that just means that all the loads will get front-loaded, and then the adds computing the final sum proceed at their own pace; the result will eventually be available, but it will still take a bit more than 2N cycles, no faster than we were in the original version of the loop. On a more realistic machine (which can only look ahead by a limited number of instructions), we would eventually stop being able to start new loop iterations until some of the old loop iterations have completed. No matter how we slice it, we‚Äôve gone from adding one integer to the sum per cycle to adding two integers to the sum every two cycles. We might take fewer instructions to do so, which is a nice consolation prize, but this is not what we wanted!</p>
<p>What‚Äôs happened is that unrolling shifted the critical path. Before, the critical path between iterations went through the pointer advance (or, to be more precise, there were two critical paths, one through the pointer advance and one through the sum, and they were both the same length). Now that we do half the number of advances per item, that isn‚Äôt a problem anymore; but the fact that we‚Äôre summing these integers sequentially is now the limiter.</p>
<p>A working solution is to change the algorithm slightly: instead of keeping a single sum of all integers, we keep two separate sums. One for the integers at even-numbered array positions, and one for the integers at odd-numberd positions. Then we need to sum those two values at the end. This is the algorithm:</p>
<pre>loop:
  rCurInt = load64(rCurPtr);        // LoadEven
  rSumEven = rSumEven + rCurInt;    // SumEven
  rCurInt = load64(rCurPtr + 8);    // LoadOdd
  rSumOdd = rSumOdd + rCurInt;      // SumOdd
  rCurPtr = rCurPtr + 16;           // Advance
  if rCurPtr != rEndPtr goto loop;  // Done?

  rSum = rSumEven + rSumOdd;        // FinalSum
</pre>
<p>And the dataflow graph for the loop kernel looks as follows:</p>
<p><a href="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum2-gv.png"><img data-attachment-id="7090" data-permalink="https://fgiesen.wordpress.com/2018/03/05/a-whirlwind-introduction-to-dataflow-graphs/unroll2x_array_sum2-gv/" data-orig-file="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum2-gv.png" data-orig-size="778,333" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Dataflow graph for unrolled array sum, second attempt" data-image-description="" data-medium-file="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum2-gv.png?w=300" data-large-file="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum2-gv.png?w=497" src="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum2-gv.png?w=497" alt="Dataflow graph for unrolled array sum, second attempt" srcset="https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum2-gv.png?w=497 497w, https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum2-gv.png?w=150 150w, https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum2-gv.png?w=300 300w, https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum2-gv.png?w=768 768w, https://fgiesen.files.wordpress.com/2018/03/unroll2x_array_sum2-gv.png 778w" sizes="(max-width: 497px) 100vw, 497px"></a></p>
<p>Where before all the summing was in what‚Äôs called the same dependency chain (the name should be self-explanatory by now, I hope), we have now split the summation into two dependency chains. And this is enough to make a sufficiently-wide machine that can sustain 6 instructions per cycle complete our integer-summing task in just slightly more than half a cycle per integer being summed. Progress!</p>
<p>On a somewhat narrower 4-wide design, we are now throughput-bound, and take around 6/4=1.5 cycles per two integers summed, or 0.75 cycles per integer. That‚Äôs still a good improvement from the 1 cycle per integer we would have gotten on the same machine from the non-unrolled version; this gain is purely from reduction the loop overhead fraction, and further unrolling could reduce it even further. (That said, unless your loop really is as tiny as our example, you don‚Äôt generally want to go overboard with unrolling.)</p>
<h3>Tying it all together</h3>
<p>In the introduction, I talked about the need for a model detailed enough to make quantitative, not just qualitative, predictions; and at least for very simple compute-bound loops, that is exactly what we have now. At this point, you should know enough to look at the dependency structure of simple loops, and have some idea for how much (or how little) latent parallelism there is, and be able to compute a coarse upper bound on their ‚Äúspeed of light‚Äù on various machines with different peak instructions/cycle rates.</p>
<p>Of course, there are many simplifications here, most of which have been already noted in the text; we‚Äôre mostly ignoring the effects of the memory hierarchy, we‚Äôre not worrying at all about where the decoded instructions come from and how fast they can possibly be delivered, we‚Äôve been flat-out assuming that our branch prediction oracle is perfect, and we‚Äôve been pretending that while there may be a limit on the total number of instructions we can issue per cycle, it doesn‚Äôt matter what these instructions are. None of these are true. And even if we‚Äôre still compute-bound, we need to worry at least about that latter constraint: sometimes it can make a noticeable difference to tweak the ‚Äúinstruction mix‚Äù so it matches better what the hardware can actually do in a given clock cycle.</p>
<p>But all these caveats aside, the basic concepts introduced here are very general, and even just sketching out the dependency graph of a loop like this and seeing it in front of you should give you useful ideas about what potential problems are and how you might address them. If you‚Äôre interested in performance optimization, it is definitely worth your time practicing this so you can look at loops and get a ‚Äúfeel‚Äù for how they execute, and how the shape of your algorithm (or your data structures, in the linked list case) aids or constrains the compiler and processor.</p>
<p><b>UPDATE</b>: Some additional clarifications in answer to some questions: paraphrasing one, ‚Äúif you have to first write C code, translate it to some pseudo-assembly, and then look at the graph, how can this possibly be a better process than just measuring the code in the first place?‚Äù Well, the trick here is that to measure anything, you actually need a working program. You don‚Äôt to draw a dataflow graph. For example, a common scenario is that there are many ways you could structure some task, and they all want their data structured differently. Actually implementing and testing multiple variants like this requires you to write a lot of plumbing to massage data from one format into another (all of which can be buggy). Drawing a graph can be done from a brief description of the inner loop alone, and you can leave out the parts that you don‚Äôt currently care about, or ‚Äúdummy them out‚Äù by replacing them with a coarse approximation (‚Äúrandom work here, maybe 10 cycles latency?‚Äù). You only need to make these things precise when they become close to the critical path (or you‚Äôre throughput-bound).</p>
<p>The other thing I‚Äôll say is that even though I‚Äôve been talking about adding cycle estimates for compute-bound loops here, this technique works and is useful at pretty much any scale. It‚Äôs applicable in any system where work is started and then processed asynchronously, with the results arriving some time later. If you‚Äôre analyzing a tight, compute-bound loop, cycle-level granularity is the way to go. But you can zoom out and use the same technique to figure out how your decomposition of an algorithm into tasklets processed by a thread pool works out: do you actually have some meaningful overlap, or is there still one long serial dependency chain that dominates everything, and all you‚Äôre doing by splitting it into tasklets like that is adding overhead? Zooming out even further, it works to analyze RPCs you‚Äôre sending to a different machine, or queries to some database. Say you have a 30ms target response time, and each RPC takes about 2ms to return its results. In a system that takes 50 RPCs to produce a result, can you meet that deadline? The answer depends on how the dataflow between them looks. If they‚Äôre all in series, almost certainly not. If they‚Äôre in 5 ‚Äúlayers‚Äù that each fan out to 10 different machines then collect the results, you probably can. It certainly applies in project scheduling, and is one of the big reasons the ‚Äúman-month‚Äù isn‚Äôt a very useful metric: adding manpower increases your available resources but does nothing to relax your dependencies. In fact, it often adds more of them, to bring new people up to speed. If the extra manpower ends up resulting in more work on the critical path towards finishing your project (for example to train new hires), then adding these extra people to the project made it finish later. And so forth. The point being, this is <em>not</em> just limited to cycle-by-cycle analysis, even though that‚Äôs the context I‚Äôve been introducing it in. It‚Äôs far more general than that.</p>
<p>And I think that‚Äôs enough material for today. Next up, I‚Äôll continue my ‚ÄúReading bits in far too many ways‚Äù series with the third part, where I‚Äôll be using these techniques to get some insight into what kind of difference the algorithm variants make. Until then!</p>
											</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>