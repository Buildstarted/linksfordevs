<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Certificate Authentication in ASP.NET Core 3.1 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Certificate Authentication in ASP.NET Core 3.1</h1><div><div class="entry-content"><p>This article shows how <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth">Certificate Authentication</a> can be implemented in ASP.NET Core 3.1. In this example, a shared self signed certificate is used to authenticate one application calling an API on a second ASP.NET Core application.</p><p><strong>Code</strong><a href="https://github.com/damienbod/AspNetCoreCertificateAuth" rel="nofollow">https://github.com/damienbod/AspNetCoreCertificateAuth</a></p><p>Posts in this series</p><p><strong>History</strong></p><p><strong>2019-12-06:</strong> Updated Nuget packages, .NET Core 3.1</p><p><strong>2019-09-06:</strong> Updated Nuget packages, .NET Core 3 preview 9</p><p><strong>Setting up the Server</strong></p><p>Add the Certificate Authentication using the Microsoft.AspNetCore.Authentication.Certificate NuGet package to the server ASP.NET Core application.</p><p><img data-attachment-id="12480" data-permalink="https://damienbod.com/2019/06/13/certificate-authentication-in-asp-net-core-3-0/certauth_01/" data-orig-file="https://damienbod.files.wordpress.com/2019/06/certauth_01.png" data-orig-size="1130,1195" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="certAuth_01" data-image-description="" data-medium-file="https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=567" data-large-file="https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=640" src="https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=640&amp;h=677" alt="" width="640" height="677" class="alignnone size-full wp-image-12480" srcset="https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=640&amp;h=677 640w, https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=142&amp;h=150 142w, https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=567&amp;h=600 567w, https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=768&amp;h=812 768w, https://damienbod.files.wordpress.com/2019/06/certauth_01.png?w=968&amp;h=1024 968w, https://damienbod.files.wordpress.com/2019/06/certauth_01.png 1130w" sizes="(max-width: 640px) 100vw, 640px"></p><p>This can also be added directly in the csproj file.</p><pre class="brush: xml; title: ; notranslate" title="">&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt;
    &lt;AspNetCoreHostingModel&gt;OutOfProcess&lt;/AspNetCoreHostingModel&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.Authentication.Certificate" 
      Version="3.1.0" /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;None Update="sts_dev_cert.pfx"&gt;
      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;

</pre><p>The authentication can be added in the ConfigureServices method in the Startup class. This example was built using the ASP.NET Core documentation.  The AddAuthentication extension method is used to define the default scheme as “Certificate” using the CertificateAuthenticationDefaults.AuthenticationScheme string. The AddCertificate method then adds the configuration for the certificate  authentication. At present, all certificates are excepted which is not good and the MyCertificateValidationService class is used to do extra validation of the client certificate. If the validation fails, the request is failed and the request for the resource will be rejected.</p><pre class="brush: csharp; title: ; notranslate" title="">public void ConfigureServices(IServiceCollection services)
{
	services.AddSingleton&lt;MyCertificateValidationService&gt;();

	services.AddAuthentication(CertificateAuthenticationDefaults.AuthenticationScheme)
		.AddCertificate(options =&gt; // code from ASP.NET Core sample
		{
			options.AllowedCertificateTypes = CertificateTypes.All;
			options.Events = new CertificateAuthenticationEvents
			{
				OnCertificateValidated = context =&gt;
				{
					var validationService =
						context.HttpContext.RequestServices.GetService&lt;MyCertificateValidationService&gt;();

					if (validationService.ValidateCertificate(context.ClientCertificate))
					{
						var claims = new[]
						{
							new Claim(ClaimTypes.NameIdentifier, context.ClientCertificate.Subject, ClaimValueTypes.String, context.Options.ClaimsIssuer),
							new Claim(ClaimTypes.Name, context.ClientCertificate.Subject, ClaimValueTypes.String, context.Options.ClaimsIssuer)
						};

						context.Principal = new ClaimsPrincipal(new ClaimsIdentity(claims, context.Scheme.Name));
						context.Success();
					}
					else
					{
						context.Fail("invalid cert");
					}

					return Task.CompletedTask;
				}
			};
		});

	services.AddAuthorization();

	services.AddControllers();
}
</pre><p><strong>Certificate Forwarding </strong></p><p><strong>Note: </strong>Before implementing CertificateForwarding, validate if you really need this. For example Azure App Services does this for you, and you can use the default implementation without this (server and client)</p><p>See <a href="https://damienbod.com/2019/09/07/using-certificate-authentication-with-ihttpclientfactory-and-httpclient/" rel="nofollow">https://damienbod.com/2019/09/07/using-certificate-authentication-with-ihttpclientfactory-and-httpclient/</a> for examples.</p><p>Or full Azure example:</p><p><a href="https://github.com/damienbod/AspNetCoreCertificates/tree/master/examplesUsingCertificateAuthentication/AzureCertAuth">Azure Certificate authentication</a></p><p>The AddCertificateForwarding can be used, if you need cannot use the default certificate implementation of the HTTPClient, for example if you have a custom proxy in between or something like this. The AddCertificateForwarding method is used so that the client header can be specified and how the certificate is to be loaded using the HeaderConverter option. When sending the certificate with the HttpClient using the default settings and a custom proxy, the ClientCertificate will not be set. The X-ARR-ClientCert header is used to pass the client certificate, and the cert is passed as a string to work around this.</p><pre class="brush: csharp; title: ; notranslate" title="">services.AddCertificateForwarding(options =&gt;
{
	options.CertificateHeader = "X-ARR-ClientCert";
	options.HeaderConverter = (headerValue) =&gt;
	{
		X509Certificate2 clientCertificate = null;
		if(!string.IsNullOrWhiteSpace(headerValue))
		{
			byte[] bytes = StringToByteArray(headerValue);
			clientCertificate = new X509Certificate2(bytes);
		}

		return clientCertificate;
	};
});

</pre><p>The Configure method then adds the middleware. UseCertificateForwarding is added before the UseAuthentication and the UseAuthorization.</p><pre class="brush: csharp; title: ; notranslate" title="">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
	...
	
	app.UseRouting();

	app.UseCertificateForwarding();
	app.UseAuthentication();
	app.UseAuthorization();

	app.UseEndpoints(endpoints =&gt;
	{
		endpoints.MapControllers();
	});
}
</pre><p>The MyCertificateValidationService is used to implement validation logic. Because we are using self signed certificates, we need to ensure that only our certificate can be used. We validate that the thumbprints of the client certificate and also the server one match, otherwise any certificate can be used and will be be enough to authenticate.</p><pre class="brush: csharp; title: ; notranslate" title="">using System.IO;
using System.Security.Cryptography.X509Certificates;

namespace AspNetCoreCertificateAuthApi
{
    public class MyCertificateValidationService
    {
        public bool ValidateCertificate(X509Certificate2 clientCertificate)
        {
            var cert = new X509Certificate2(Path.Combine("sts_dev_cert.pfx"), "1234");
            if (clientCertificate.Thumbprint == cert.Thumbprint)
            {
                return true;
            }

            return false;
        }
    }
}

</pre><p>The API ValuesController is then secured using the Authorize attribute. </p><pre class="brush: csharp; title: ; notranslate" title="">[Route("api/[controller]")]
[ApiController]
[Authorize]
public class ValuesController : ControllerBase
{

...
</pre><p>The ASP.NET Core server project is deployed in this example as an out of process application using kestrel. To use the service, a certificate is required. This is defined using the ClientCertificateMode.RequireCertificate option. </p><pre class="brush: csharp; title: ; notranslate" title="">public static IWebHost BuildWebHost(string[] args)
  =&gt; WebHost.CreateDefaultBuilder(args)
  .UseStartup&lt;Startup&gt;()
  .ConfigureKestrel(options =&gt;
  {
	var cert = new X509Certificate2(Path.Combine("sts_dev_cert.pfx"), "1234");
	options.ConfigureHttpsDefaults(o =&gt;
	{
		o.ServerCertificate = cert;
		o.ClientCertificateMode = ClientCertificateMode.RequireCertificate;
	});
  })
  .Build();
</pre><p><strong>Implementing the HttpClient</strong></p><p>The client of the API uses a HttpClient which was create using an instance of the IHttpClientFactory. This does not provide a way to define a handler for the HttpClient and so we use a HttpRequestMessage to add the Certificate to the “X-ARR-ClientCert” request header. The cert is added as a string using the GetRawCertDataString method. </p><pre class="brush: csharp; title: ; notranslate" title="">private async Task&lt;JArray&gt; GetApiDataAsync()
{
	try
	{
		var cert = new X509Certificate2(Path.Combine(_environment.ContentRootPath, "sts_dev_cert.pfx"), "1234");

		var client = _clientFactory.CreateClient();

		var request = new HttpRequestMessage()
		{
			RequestUri = new Uri("https://localhost:44379/api/values"),
			Method = HttpMethod.Get,
		};

		request.Headers.Add("X-ARR-ClientCert", cert.GetRawCertDataString());
		var response = await client.SendAsync(request);

		if (response.IsSuccessStatusCode)
		{
			var responseContent = await response.Content.ReadAsStringAsync();
			var data = JArray.Parse(responseContent);

			return data;
		}

		throw new ApplicationException($"Status code: {response.StatusCode}, Error: {response.ReasonPhrase}");
	}
	catch (Exception e)
	{
		throw new ApplicationException($"Exception {e}");
	}
}
</pre><p>If the correct certificate is sent to the server, the data will be returned. If no certificate is sent, or the wrong certificate, then a 403 will be returned. Sending the certificate in the X-ARR-ClientCert header is not required, or the certificate forwarding, I just wanted to show how a specific proxy could be implemented for this. See this repo for default exmaples:</p><p><a href="https://github.com/damienbod/AspNetCoreCertificates" rel="nofollow">https://github.com/damienbod/AspNetCoreCertificates</a></p><p>Certificate Authentication is great, and helps add another security layer which can be used together with other solutions. See the code and ASP.NET Core src code for further documentation and examples. Links underneath.</p><p><strong>Links</strong></p><p><a href="https://github.com/damienbod/AspNetCoreCertificates" rel="nofollow">https://github.com/damienbod/AspNetCoreCertificates</a></p><p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0</a></p><p><a href="https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/Certificate/src" rel="nofollow">https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/Certificate/src</a></p><p><a href="https://tools.ietf.org/html/rfc5246#section-7.4.4" rel="nofollow">https://tools.ietf.org/html/rfc5246#section-7.4.4</a></p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><h3 class="jp-relatedposts-headline"><em>Related</em></h3></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>