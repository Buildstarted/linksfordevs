<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Loading Related Data - EF Core - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Loading Related Data - EF Core - linksfor.dev(s)"/>
    <meta property="article:author" content="rowanmiller"/>
    <meta property="og:description" content="Entity Framework Core allows you to use the navigation properties in your model to load related entities. There are three common O/RM patterns used to load related data."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://docs.microsoft.com/en-us/ef/core/querying/related-data#single-and-split-queries"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Loading Related Data - EF Core</title>
<div class="readable">
        <h1>Loading Related Data - EF Core</h1>
            <div>by rowanmiller</div>
            <div>Reading time: 17-21 minutes</div>
        <div>Posted here: 10 Jul 2020</div>
        <p><a href="https://docs.microsoft.com/en-us/ef/core/querying/related-data#single-and-split-queries">https://docs.microsoft.com/en-us/ef/core/querying/related-data#single-and-split-queries</a></p>
        <hr/>
<div id="readability-page-1" class="page">


	<div data-bi-name="body">

		<div>

			

			<section>
				<div>


				<div id="main-column">

					<main id="main" role="main" data-bi-name="content" lang="en-us" dir="ltr">



						

						<ul data-bi-name="page info" lang="en-us" dir="ltr">
							<li>
								<time data-article-date="" aria-label="Article review date" datetime="2016-10-27T00:00:00.000Z" data-article-date-source="ms.date">10/27/2016</time>
							</li>
								<li>11 minutes to read</li>
								<li>
									<a href="https://github.com/dotnet/EntityFramework.Docs/blob/master/entity-framework/core/querying/related-data.md" title="13 Contributors" aria-label="13 Contributors">
										
									</a>
								</li>
						</ul>

						<nav id="center-doc-outline" data-bi-name="intopic toc" role="navigation" aria-label="Article Outline">
							<h3>In this article</h3>
						<ol><li><a href="#eager-loading">Eager loading</a></li><li><a href="#explicit-loading">Explicit loading</a></li><li><a href="#lazy-loading">Lazy loading</a></li><li><a href="#related-data-and-serialization">Related data and serialization</a></li></ol></nav>

						<!-- <content> -->
							<p>Entity Framework Core allows you to use the navigation properties in your model to load related entities. There are three common O/RM patterns used to load related data.</p>
<ul>
<li><strong>Eager loading</strong> means that the related data is loaded from the database as part of the initial query.</li>
<li><strong>Explicit loading</strong> means that the related data is explicitly loaded from the database at a later time.</li>
<li><strong>Lazy loading</strong> means that the related data is transparently loaded from the database when the navigation property is accessed.</li>
</ul>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>You can view this article's <a href="https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying" data-linktype="external">sample</a> on GitHub.</p>
</div>
<h2 id="eager-loading"><a href="#eager-loading" aria-labelledby="eager-loading"></a>Eager loading</h2>
<p>You can use the <code>Include</code> method to specify related data to be included in query results. In the following example, the blogs that are returned in the results will have their <code>Posts</code> property populated with the related posts.</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var blogs = context.Blogs
        .Include(blog => blog.Posts)
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> blogs = context.Blogs
        .Include(blog =&gt; blog.Posts)
        .ToList();
}
</span></code></pre>
<div>
<p><span aria-hidden="true"></span> Tip</p>
<p>Entity Framework Core will automatically fix-up navigation properties to any other entities that were previously loaded into the context instance. So even if you don't explicitly include the data for a navigation property, the property may still be populated if some or all of the related entities were previously loaded.</p>
</div>
<p>You can include related data from multiple relationships in a single query.</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var blogs = context.Blogs
        .Include(blog => blog.Posts)
        .Include(blog => blog.Owner)
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> blogs = context.Blogs
        .Include(blog =&gt; blog.Posts)
        .Include(blog =&gt; blog.Owner)
        .ToList();
}
</span></code></pre><h3 id="including-multiple-levels"><a href="#including-multiple-levels" aria-labelledby="including-multiple-levels"></a>Including multiple levels</h3>
<p>You can drill down through relationships to include multiple levels of related data using the <code>ThenInclude</code> method. The following example loads all blogs, their related posts, and the author of each post.</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var blogs = context.Blogs
        .Include(blog => blog.Posts)
            .ThenInclude(post => post.Author)
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> blogs = context.Blogs
        .Include(blog =&gt; blog.Posts)
            .ThenInclude(post =&gt; post.Author)
        .ToList();
}
</span></code></pre>
<p>You can chain multiple calls to <code>ThenInclude</code> to continue including further levels of related data.</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var blogs = context.Blogs
        .Include(blog => blog.Posts)
            .ThenInclude(post => post.Author)
                .ThenInclude(author => author.Photo)
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> blogs = context.Blogs
        .Include(blog =&gt; blog.Posts)
            .ThenInclude(post =&gt; post.Author)
                .ThenInclude(author =&gt; author.Photo)
        .ToList();
}
</span></code></pre>
<p>You can combine all of this to include related data from multiple levels and multiple roots in the same query.</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var blogs = context.Blogs
        .Include(blog => blog.Posts)
            .ThenInclude(post => post.Author)
                .ThenInclude(author => author.Photo)
        .Include(blog => blog.Owner)
            .ThenInclude(owner => owner.Photo)
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> blogs = context.Blogs
        .Include(blog =&gt; blog.Posts)
            .ThenInclude(post =&gt; post.Author)
                .ThenInclude(author =&gt; author.Photo)
        .Include(blog =&gt; blog.Owner)
            .ThenInclude(owner =&gt; owner.Photo)
        .ToList();
}
</span></code></pre>
<p>You may want to include multiple related entities for one of the entities that is being included. For example, when querying <code>Blogs</code>, you include <code>Posts</code> and then want to include both the <code>Author</code> and <code>Tags</code> of the <code>Posts</code>. To do this, you need to specify each include path starting at the root. For example, <code>Blog -&gt; Posts -&gt; Author</code> and <code>Blog -&gt; Posts -&gt; Tags</code>. This does not mean you will get redundant joins; in most cases, EF will consolidate the joins when generating SQL.</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var blogs = context.Blogs
        .Include(blog => blog.Posts)
            .ThenInclude(post => post.Author)
        .Include(blog => blog.Posts)
            .ThenInclude(post => post.Tags)
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> blogs = context.Blogs
        .Include(blog =&gt; blog.Posts)
            .ThenInclude(post =&gt; post.Author)
        .Include(blog =&gt; blog.Posts)
            .ThenInclude(post =&gt; post.Tags)
        .ToList();
}
</span></code></pre><h3 id="single-and-split-queries"><a href="#single-and-split-queries" aria-labelledby="single-and-split-queries"></a>Single and split queries</h3>
<div>
<p><span aria-hidden="true"></span> Note</p>
<p>This feature is introduced in EF Core 5.0.</p>
</div>
<p>In relational databases, all related entities are by default loaded by introducing JOINs:</p>
<pre tabindex="0"><code data-author-content="SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
"><span><span>SELECT</span> [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[<span>Url</span>], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[<span>Content</span>], [p].[Rating], [p].[Title]
<span>FROM</span> [Blogs] <span>AS</span> [b]
<span>LEFT</span> <span>JOIN</span> [Post] <span>AS</span> [p] <span>ON</span> [b].[BlogId] = [p].[BlogId]
<span>ORDER</span> <span>BY</span> [b].[BlogId], [p].[PostId]
</span></code></pre>
<p>If a typical blog has multiple related posts, rows for these posts will duplicate the blog's information, leading to the so-called "cartesian explosion" problem. As more one-to-many relationships are loaded, the amount of duplicated data may grow and adversely affect the performance of your application.</p>
<p>EF allows you to specify that a given LINQ query should be <em>split</em> into multiple SQL queries. Instead of JOINs, split queries perform an additional SQL query for each included one-to-many navigation:</p>
<pre tabindex="0"><code name="Main" highlight-lines="5" data-author-content="using (var context = new BloggingContext())
{
    var blogs = context.Blogs
        .Include(blog => blog.Posts)
        .AsSplitQuery()
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> blogs = context.Blogs
        .Include(blog =&gt; blog.Posts)</span>
<mark>        .AsSplitQuery()</mark>
<span>        .ToList();
}
</span></code></pre>
<p>This will produce the following SQL:</p>
<pre tabindex="0"><code data-author-content="SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
ORDER BY [b].[BlogId]

SELECT [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title], [b].[BlogId]
FROM [Blogs] AS [b]
INNER JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId]
"><span><span>SELECT</span> [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[<span>Url</span>]
<span>FROM</span> [Blogs] <span>AS</span> [b]
<span>ORDER</span> <span>BY</span> [b].[BlogId]

<span>SELECT</span> [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[<span>Content</span>], [p].[Rating], [p].[Title], [b].[BlogId]
<span>FROM</span> [Blogs] <span>AS</span> [b]
<span>INNER</span> <span>JOIN</span> [Post] <span>AS</span> [p] <span>ON</span> [b].[BlogId] = [p].[BlogId]
<span>ORDER</span> <span>BY</span> [b].[BlogId]
</span></code></pre>
<p>While this avoids the performance issues associated with JOINs and cartesian explosion, it also has some drawbacks:</p>
<ul>
<li>While most databases guarantee data consistency for single queries, no such guarantees exist for multiple queries. This means that if the database is being updated concurrently as your queries are being executed, resulting data may not be consistent. This may be mitigated by wrapping the queries in a serializable or snapshot transaction, although this may create performance issues of its own. Consult your database's documentation for more details.</li>
<li>Each query currently implies an additional network roundtrip to your database; this can degrade performance, especially where latency to the database is high (e.g. cloud services). EF Core will improve this in the future by batching the queries into a single roundtrip.</li>
<li>While some databases allow consuming the results of multiple queries at the same time (SQL Server with MARS, Sqlite), most allow only a single query to be active at any given point. This means that all results from earlier queries must be buffered in your application's memory before executing later queries, increasing your memory requirements in a potentially significant way.</li>
</ul>
<p>Unfortunately, there isn't one strategy for loading related entities that fits all scenarios. Carefully consider the advantages and disadvantages of single and split queries, and select the one that fits your needs.</p>
<div>
<p><span aria-hidden="true"></span> Note</p>
<p>One-to-one related entities are always loaded via JOINs, as this has no performance impact.</p>
<p>At the moment, use of query splitting on SQL Server requires settings <code>MultipleActiveResultSets=true</code> in your connection string. This requirement will be removed in a future preview.</p>
<p>Future previews of EF Core 5.0 will allow specifying query splitting as the default for your context.</p>
</div>
<h3 id="filtered-include"><a href="#filtered-include" aria-labelledby="filtered-include"></a>Filtered include</h3>
<div>
<p><span aria-hidden="true"></span> Note</p>
<p>This feature is introduced in EF Core 5.0.</p>
</div>
<p>When applying Include to load related data, you can apply certain enumerable operations on the included collection navigation, which allows for filtering and sorting of the results.</p>
<p>Supported operations are: <code>Where</code>, <code>OrderBy</code>, <code>OrderByDescending</code>, <code>ThenBy</code>, <code>ThenByDescending</code>, <code>Skip</code>, and <code>Take</code>.</p>
<p>Such operations should be applied on the collection navigation in the lambda passed to the Include method, as shown in example below:</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var filteredBlogs = context.Blogs
        .Include(blog => blog.Posts
            .Where(post => post.BlogId == 1)
            .OrderByDescending(post => post.Title)
            .Take(5))
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> filteredBlogs = context.Blogs
        .Include(blog =&gt; blog.Posts
            .Where(post =&gt; post.BlogId == <span>1</span>)
            .OrderByDescending(post =&gt; post.Title)
            .Take(<span>5</span>))
        .ToList();
}
</span></code></pre>
<p>Each included navigation allows only one unique set of filter operations. In cases where multiple Include operations are applied for a given collection navigation (<code>blog.Posts</code> in the examples below), filter operations can only be specified on one of them:</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var filteredBlogs = context.Blogs
        .Include(blog => blog.Posts.Where(post => post.BlogId == 1))
            .ThenInclude(post => post.Author)
        .Include(blog => blog.Posts)
            .ThenInclude(post => post.Tags.OrderBy(postTag => postTag.TagId).Skip(3))
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> filteredBlogs = context.Blogs
        .Include(blog =&gt; blog.Posts.Where(post =&gt; post.BlogId == <span>1</span>))
            .ThenInclude(post =&gt; post.Author)
        .Include(blog =&gt; blog.Posts)
            .ThenInclude(post =&gt; post.Tags.OrderBy(postTag =&gt; postTag.TagId).Skip(<span>3</span>))
        .ToList();
}
</span></code></pre>
<p>Alternatively, identical operations can be applied for each navigation that is included multiple times:</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var filteredBlogs = context.Blogs
        .Include(blog => blog.Posts.Where(post => post.BlogId == 1))
            .ThenInclude(post => post.Author)
        .Include(blog => blog.Posts.Where(post => post.BlogId == 1))
            .ThenInclude(post => post.Tags.OrderBy(postTag => postTag.TagId).Skip(3))
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> filteredBlogs = context.Blogs
        .Include(blog =&gt; blog.Posts.Where(post =&gt; post.BlogId == <span>1</span>))
            .ThenInclude(post =&gt; post.Author)
        .Include(blog =&gt; blog.Posts.Where(post =&gt; post.BlogId == <span>1</span>))
            .ThenInclude(post =&gt; post.Tags.OrderBy(postTag =&gt; postTag.TagId).Skip(<span>3</span>))
        .ToList();
}
</span></code></pre>
<div>
<p><span aria-hidden="true"></span> Caution</p>
<p>In case of tracking queries, results of Filtered Include may be unexpected due to <a href="https://docs.microsoft.com/en-us/ef/core/querying/tracking" data-linktype="relative-path">navigation fixup</a>. All relevant entities that have been querried for previously and have been stored in the Change Tracker will be present in the results of Filtered Include query, even if they don't meet the requirements of the filter. Consider using <code>NoTracking</code> queries or re-create the DbContext when using Filtered Include in those situations.</p>
</div>
<p>Example:</p>
<pre tabindex="0"><code data-author-content="var orders = context.Orders.Where(o => o.Id > 1000).ToList();

// customer entities will have references to all orders where Id > 1000, rathat than > 5000
var filtered = context.Customers.Include(c => c.Orders.Where(o => o.Id > 5000)).ToList();
"><span><span>var</span> orders = context.Orders.Where(o =&gt; o.Id &gt; <span>1000</span>).ToList();

<span>// customer entities will have references to all orders where Id &gt; 1000, rathat than &gt; 5000</span>
<span>var</span> filtered = context.Customers.Include(c =&gt; c.Orders.Where(o =&gt; o.Id &gt; <span>5000</span>)).ToList();
</span></code></pre>
<h3 id="include-on-derived-types"><a href="#include-on-derived-types" aria-labelledby="include-on-derived-types"></a>Include on derived types</h3>
<p>You can include related data from navigations defined only on a derived type using <code>Include</code> and <code>ThenInclude</code>.</p>
<p>Given the following model:</p>
<pre tabindex="0"><code data-author-content="public class SchoolContext : DbContext
{
    public DbSet<Person> People { get; set; }
    public DbSet<School> Schools { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<School>().HasMany(s => s.Students).WithOne(s => s.School);
    }
}

public class Person
{
    public int Id { get; set; }
    public string Name { get; set; }
}

public class Student : Person
{
    public School School { get; set; }
}

public class School
{
    public int Id { get; set; }
    public string Name { get; set; }

    public List<Student> Students { get; set; }
}
"><span><span>public</span> <span>class</span> <span>SchoolContext</span> : <span>DbContext</span>
{
    <span>public</span> DbSet&lt;Person&gt; People { <span>get</span>; <span>set</span>; }
    <span>public</span> DbSet&lt;School&gt; Schools { <span>get</span>; <span>set</span>; }

    <span><span>protected</span> <span>override</span> <span>void</span> <span>OnModelCreating</span>(<span>ModelBuilder modelBuilder</span>)</span>
    {
        modelBuilder.Entity&lt;School&gt;().HasMany(s =&gt; s.Students).WithOne(s =&gt; s.School);
    }
}

<span>public</span> <span>class</span> <span>Person</span>
{
    <span>public</span> <span>int</span> Id { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Name { <span>get</span>; <span>set</span>; }
}

<span>public</span> <span>class</span> <span>Student</span> : <span>Person</span>
{
    <span>public</span> School School { <span>get</span>; <span>set</span>; }
}

<span>public</span> <span>class</span> <span>School</span>
{
    <span>public</span> <span>int</span> Id { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Name { <span>get</span>; <span>set</span>; }

    <span>public</span> List&lt;Student&gt; Students { <span>get</span>; <span>set</span>; }
}
</span></code></pre>
<p>Contents of <code>School</code> navigation of all People who are Students can be eagerly loaded using a number of patterns:</p>
<ul>
<li><p>using cast</p>
<pre tabindex="0"><code data-author-content="context.People.Include(person => ((Student)person).School).ToList()
"><span>context.People.Include(person =&gt; ((Student)person).School).ToList()
</span></code></pre>
</li>
<li><p>using <code>as</code> operator</p>
<pre tabindex="0"><code data-author-content="context.People.Include(person => (person as Student).School).ToList()
"><span>context.People.Include(person =&gt; (person <span>as</span> Student).School).ToList()
</span></code></pre>
</li>
<li><p>using overload of <code>Include</code> that takes parameter of type <code>string</code></p>
<pre tabindex="0"><code data-author-content="context.People.Include(&quot;School&quot;).ToList()
"><span>context.People.Include(<span>"School"</span>).ToList()
</span></code></pre>
</li>
</ul>
<h2 id="explicit-loading"><a href="#explicit-loading" aria-labelledby="explicit-loading"></a>Explicit loading</h2>
<p>You can explicitly load a navigation property via the <code>DbContext.Entry(...)</code> API.</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var blog = context.Blogs
        .Single(b => b.BlogId == 1);

    context.Entry(blog)
        .Collection(b => b.Posts)
        .Load();

    context.Entry(blog)
        .Reference(b => b.Owner)
        .Load();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> blog = context.Blogs
        .Single(b =&gt; b.BlogId == <span>1</span>);

    context.Entry(blog)
        .Collection(b =&gt; b.Posts)
        .Load();

    context.Entry(blog)
        .Reference(b =&gt; b.Owner)
        .Load();
}
</span></code></pre>
<p>You can also explicitly load a navigation property by executing a separate query that returns the related entities. If change tracking is enabled, then when loading an entity, EF Core will automatically set the navigation properties of the newly-loaded entitiy to refer to any entities already loaded, and set the navigation properties of the already-loaded entities to refer to the newly-loaded entity.</p>
<h3 id="querying-related-entities"><a href="#querying-related-entities" aria-labelledby="querying-related-entities"></a>Querying related entities</h3>
<p>You can also get a LINQ query that represents the contents of a navigation property.</p>
<p>This allows you to do things such as running an aggregate operator over the related entities without loading them into memory.</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var blog = context.Blogs
        .Single(b => b.BlogId == 1);

    var postCount = context.Entry(blog)
        .Collection(b => b.Posts)
        .Query()
        .Count();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> blog = context.Blogs
        .Single(b =&gt; b.BlogId == <span>1</span>);

    <span>var</span> postCount = context.Entry(blog)
        .Collection(b =&gt; b.Posts)
        .Query()
        .Count();
}
</span></code></pre>
<p>You can also filter which related entities are loaded into memory.</p>
<pre tabindex="0"><code name="Main" data-author-content="using (var context = new BloggingContext())
{
    var blog = context.Blogs
        .Single(b => b.BlogId == 1);

    var goodPosts = context.Entry(blog)
        .Collection(b => b.Posts)
        .Query()
        .Where(p => p.Rating > 3)
        .ToList();
}
"><span><span>using</span> (<span>var</span> context = <span>new</span> BloggingContext())
{
    <span>var</span> blog = context.Blogs
        .Single(b =&gt; b.BlogId == <span>1</span>);

    <span>var</span> goodPosts = context.Entry(blog)
        .Collection(b =&gt; b.Posts)
        .Query()
        .Where(p =&gt; p.Rating &gt; <span>3</span>)
        .ToList();
}
</span></code></pre><h2 id="lazy-loading"><a href="#lazy-loading" aria-labelledby="lazy-loading"></a>Lazy loading</h2>
<p>The simplest way to use lazy-loading is by installing the <a href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Proxies/" data-linktype="external">Microsoft.EntityFrameworkCore.Proxies</a> package and enabling it with a call to <code>UseLazyLoadingProxies</code>. For example:</p>
<pre tabindex="0"><code data-author-content="protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    => optionsBuilder
        .UseLazyLoadingProxies()
        .UseSqlServer(myConnectionString);
"><span><span><span>protected</span> <span>override</span> <span>void</span> <span>OnConfiguring</span>(<span>DbContextOptionsBuilder optionsBuilder</span>)</span>
    =&gt; optionsBuilder
        .UseLazyLoadingProxies()
        .UseSqlServer(myConnectionString);
</span></code></pre>
<p>Or when using AddDbContext:</p>
<pre tabindex="0"><code data-author-content=".AddDbContext<BloggingContext>(
    b => b.UseLazyLoadingProxies()
          .UseSqlServer(myConnectionString));
"><span>.AddDbContext&lt;BloggingContext&gt;(
    b =&gt; b.UseLazyLoadingProxies()
          .UseSqlServer(myConnectionString));
</span></code></pre>
<p>EF Core will then enable lazy loading for any navigation property that can be overridden--that is, it must be <code>virtual</code> and on a class that can be inherited from. For example, in the following entities, the <code>Post.Blog</code> and <code>Blog.Posts</code> navigation properties will be lazy-loaded.</p>
<pre tabindex="0"><code data-author-content="public class Blog
{
    public int Id { get; set; }
    public string Name { get; set; }

    public virtual ICollection<Post> Posts { get; set; }
}

public class Post
{
    public int Id { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public virtual Blog Blog { get; set; }
}
"><span><span>public</span> <span>class</span> <span>Blog</span>
{
    <span>public</span> <span>int</span> Id { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Name { <span>get</span>; <span>set</span>; }

    <span>public</span> <span>virtual</span> ICollection&lt;Post&gt; Posts { <span>get</span>; <span>set</span>; }
}

<span>public</span> <span>class</span> <span>Post</span>
{
    <span>public</span> <span>int</span> Id { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Title { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Content { <span>get</span>; <span>set</span>; }

    <span>public</span> <span>virtual</span> Blog Blog { <span>get</span>; <span>set</span>; }
}
</span></code></pre>
<h3 id="lazy-loading-without-proxies"><a href="#lazy-loading-without-proxies" aria-labelledby="lazy-loading-without-proxies"></a>Lazy loading without proxies</h3>
<p>Lazy-loading proxies work by injecting the <code>ILazyLoader</code> service into an entity, as described in <a href="https://docs.microsoft.com/en-us/ef/core/modeling/constructors" data-linktype="relative-path">Entity Type Constructors</a>. For example:</p>
<pre tabindex="0"><code data-author-content="public class Blog
{
    private ICollection<Post> _posts;

    public Blog()
    {
    }

    private Blog(ILazyLoader lazyLoader)
    {
        LazyLoader = lazyLoader;
    }

    private ILazyLoader LazyLoader { get; set; }

    public int Id { get; set; }
    public string Name { get; set; }

    public ICollection<Post> Posts
    {
        get => LazyLoader.Load(this, ref _posts);
        set => _posts = value;
    }
}

public class Post
{
    private Blog _blog;

    public Post()
    {
    }

    private Post(ILazyLoader lazyLoader)
    {
        LazyLoader = lazyLoader;
    }

    private ILazyLoader LazyLoader { get; set; }

    public int Id { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public Blog Blog
    {
        get => LazyLoader.Load(this, ref _blog);
        set => _blog = value;
    }
}
"><span><span>public</span> <span>class</span> <span>Blog</span>
{
    <span>private</span> ICollection&lt;Post&gt; _posts;

    <span><span>public</span> <span>Blog</span>(<span></span>)</span>
    {
    }

    <span><span>private</span> <span>Blog</span>(<span>ILazyLoader lazyLoader</span>)</span>
    {
        LazyLoader = lazyLoader;
    }

    <span>private</span> ILazyLoader LazyLoader { <span>get</span>; <span>set</span>; }

    <span>public</span> <span>int</span> Id { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Name { <span>get</span>; <span>set</span>; }

    <span>public</span> ICollection&lt;Post&gt; Posts
    {
        <span>get</span> =&gt; LazyLoader.Load(<span>this</span>, <span>ref</span> _posts);
        <span>set</span> =&gt; _posts = <span>value</span>;
    }
}

<span>public</span> <span>class</span> <span>Post</span>
{
    <span>private</span> Blog _blog;

    <span><span>public</span> <span>Post</span>(<span></span>)</span>
    {
    }

    <span><span>private</span> <span>Post</span>(<span>ILazyLoader lazyLoader</span>)</span>
    {
        LazyLoader = lazyLoader;
    }

    <span>private</span> ILazyLoader LazyLoader { <span>get</span>; <span>set</span>; }

    <span>public</span> <span>int</span> Id { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Title { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Content { <span>get</span>; <span>set</span>; }

    <span>public</span> Blog Blog
    {
        <span>get</span> =&gt; LazyLoader.Load(<span>this</span>, <span>ref</span> _blog);
        <span>set</span> =&gt; _blog = <span>value</span>;
    }
}
</span></code></pre>
<p>This doesn't require entity types to be inherited from or navigation properties to be virtual, and allows entity instances created with <code>new</code> to lazy-load once attached to a context. However, it requires a reference to the <code>ILazyLoader</code> service, which is defined in the <a href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Abstractions/" data-linktype="external">Microsoft.EntityFrameworkCore.Abstractions</a> package. This package contains a minimal set of types so that there is very little impact in depending on it. However, to completely avoid depending on any EF Core packages in the entity types, it is possible to inject the <code>ILazyLoader.Load</code> method as a delegate. For example:</p>
<pre tabindex="0"><code data-author-content="public class Blog
{
    private ICollection<Post> _posts;

    public Blog()
    {
    }

    private Blog(Action<object, string> lazyLoader)
    {
        LazyLoader = lazyLoader;
    }

    private Action<object, string> LazyLoader { get; set; }

    public int Id { get; set; }
    public string Name { get; set; }

    public ICollection<Post> Posts
    {
        get => LazyLoader.Load(this, ref _posts);
        set => _posts = value;
    }
}

public class Post
{
    private Blog _blog;

    public Post()
    {
    }

    private Post(Action<object, string> lazyLoader)
    {
        LazyLoader = lazyLoader;
    }

    private Action<object, string> LazyLoader { get; set; }

    public int Id { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public Blog Blog
    {
        get => LazyLoader.Load(this, ref _blog);
        set => _blog = value;
    }
}
"><span><span>public</span> <span>class</span> <span>Blog</span>
{
    <span>private</span> ICollection&lt;Post&gt; _posts;

    <span><span>public</span> <span>Blog</span>(<span></span>)</span>
    {
    }

    <span><span>private</span> <span>Blog</span>(<span>Action&lt;<span>object</span>, <span>string</span>&gt; lazyLoader</span>)</span>
    {
        LazyLoader = lazyLoader;
    }

    <span>private</span> Action&lt;<span>object</span>, <span>string</span>&gt; LazyLoader { <span>get</span>; <span>set</span>; }

    <span>public</span> <span>int</span> Id { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Name { <span>get</span>; <span>set</span>; }

    <span>public</span> ICollection&lt;Post&gt; Posts
    {
        <span>get</span> =&gt; LazyLoader.Load(<span>this</span>, <span>ref</span> _posts);
        <span>set</span> =&gt; _posts = <span>value</span>;
    }
}

<span>public</span> <span>class</span> <span>Post</span>
{
    <span>private</span> Blog _blog;

    <span><span>public</span> <span>Post</span>(<span></span>)</span>
    {
    }

    <span><span>private</span> <span>Post</span>(<span>Action&lt;<span>object</span>, <span>string</span>&gt; lazyLoader</span>)</span>
    {
        LazyLoader = lazyLoader;
    }

    <span>private</span> Action&lt;<span>object</span>, <span>string</span>&gt; LazyLoader { <span>get</span>; <span>set</span>; }

    <span>public</span> <span>int</span> Id { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Title { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Content { <span>get</span>; <span>set</span>; }

    <span>public</span> Blog Blog
    {
        <span>get</span> =&gt; LazyLoader.Load(<span>this</span>, <span>ref</span> _blog);
        <span>set</span> =&gt; _blog = <span>value</span>;
    }
}
</span></code></pre>
<p>The code above uses a <code>Load</code> extension method to make using the delegate a bit cleaner:</p>
<pre tabindex="0"><code data-author-content="public static class PocoLoadingExtensions
{
    public static TRelated Load<TRelated>(
        this Action<object, string> loader,
        object entity,
        ref TRelated navigationField,
        [CallerMemberName] string navigationName = null)
        where TRelated : class
    {
        loader?.Invoke(entity, navigationName);

        return navigationField;
    }
}
"><span><span>public</span> <span>static</span> <span>class</span> <span>PocoLoadingExtensions</span>
{
    <span>public</span> <span>static</span> TRelated Load&lt;TRelated&gt;(
        <span>this</span> Action&lt;<span>object</span>, <span>string</span>&gt; loader,
        <span>object</span> entity,
        <span>ref</span> TRelated navigationField,
        [<span>CallerMemberName</span>] <span>string</span> navigationName = <span>null</span>)
        <span>where</span> TRelated : <span>class</span>
    {
        loader?.Invoke(entity, navigationName);

        <span>return</span> navigationField;
    }
}
</span></code></pre>
<div>
<p><span aria-hidden="true"></span> Note</p>
<p>The constructor parameter for the lazy-loading delegate must be called "lazyLoader". Configuration to use a different name than this is planned for a future release.</p>
</div>

<p>Because EF Core will automatically fix-up navigation properties, you can end up with cycles in your object graph. For example, loading a blog and its related posts will result in a blog object that references a collection of posts. Each of those posts will have a reference back to the blog.</p>
<p>Some serialization frameworks do not allow such cycles. For example, Json.NET will throw the following exception if a cycle is encountered.</p>
<blockquote>
<p>Newtonsoft.Json.JsonSerializationException: Self referencing loop detected for property 'Blog' with type 'MyApplication.Models.Blog'.</p>
</blockquote>
<p>If you are using ASP.NET Core, you can configure Json.NET to ignore cycles that it finds in the object graph. This is done in the <code>ConfigureServices(...)</code> method in <code>Startup.cs</code>.</p>
<pre tabindex="0"><code data-author-content="public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddMvc()
        .AddJsonOptions(
            options => options.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore
        );

    ...
}
"><span><span><span>public</span> <span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection services</span>)</span>
{
    ...

    services.AddMvc()
        .AddJsonOptions(
            options =&gt; options.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore
        );

    ...
}
</span></code></pre>
<p>Another alternative is to decorate one of the navigation properties with the <code>[JsonIgnore]</code> attribute, which instructs Json.NET to not traverse that navigation property while serializing.</p>

						<!-- </content> -->

						</main>

						<!-- recommended content page section -->

							<nav data-bi-name="recommendation-bottom" hidden="" id="recommended-content-center" aria-labelledby="recommended-content-center-title">
								<h3 id="recommended-content-center-title">Related Articles</h3>
							</nav>

						<!-- end recommended content page section -->

						<!-- page rating section -->
								
						<!-- end page rating section -->


						<!-- feedback section -->
<section data-bi-name="feedback-section">

    <h2 id="feedback">Feedback</h2>

    <div>
        <p aria-hidden="true" id="send-feedback-about">Submit and view feedback for</p>

        
    </div>

    
</section>

						<!-- end feedback section -->

						<!-- feedback report section -->
						<!-- end feedback report section -->

						
					</div>

					

					<!--end of div.columns -->
				</div>

			<!--end of .primary-holder -->
			</section>

			
		</div>

		<!--end of .mainContainer -->
	</div>

	

	

	
	<span id="adobe-target-experiment-container" hidden=""></span>


</div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>