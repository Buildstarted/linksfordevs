<!DOCTYPE html>
<html lang="en">
<head>
    <title>
StringInfo and TextElementEnumerator classes are now UAX29-compliant &#xB7; Issue #16702 &#xB7; dotnet/docs &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>StringInfo and TextElementEnumerator classes are now UAX29-compliant ¬∑ Issue #16702 ¬∑ dotnet/docs ¬∑ GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>Unicode has the concept of a "<a href="https://www.unicode.org/glossary/#grapheme" rel="nofollow">grapheme</a>", which roughly approximates what the user perceives as a single display character. In <a href="https://www.unicode.org/reports/tr29/tr29-35.html#Grapheme_Cluster_Boundaries" rel="nofollow">UAX#29</a>, this is properly formalized as a concept called an "<a href="https://www.unicode.org/glossary/#extended_grapheme_cluster" rel="nofollow">extended grapheme cluster</a>".</p><p>Consider the string containing the Thai character <em>kam</em> (<code>"‡∏Å‡∏≥"</code>). This string actually consists of two <code>char</code>s:</p><ul><li><code>' ‡∏Å '</code> (= <code>'\u0e01'</code>) THAI CHARACTER KO KAI, followed by</li><li><code>' ‡∏≥ '</code> (= <code>'\u0e33'</code>) THAI CHARACTER SARA AM</li></ul><p>When displayed to the user, the operating system combines them to form the single display character (or <em>grapheme</em>) <em>kam</em>, or <strong>‡∏Å‡∏≥</strong>.</p><p>This is also of use when displaying emoji. Consider the string containing the emoji <em>Woman Shrugging: Medium Skin Tone</em> (<code>"ü§∑üèΩ‚Äç‚ôÄÔ∏è"</code>). This string actually consists of seven <code>char</code>s: <code>[ '\ud83e', '\udd37', '\ud83c', '\udffd', '\u200d', '\u2640', '\ufe0f' ]</code>. But the operating system will combine all seven of these together and display them as a single unit.</p><p>In .NET, the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.globalization.stringinfo" rel="nofollow"><code>System.Globalization.StringInfo</code></a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.globalization.textelementenumerator" rel="nofollow"><code>System.Globalization.TextElementEnumerator</code></a> classes allow developers to inspect a string and to get information about the graphemes it contains. Prior to this change, the <code>StringInfo</code> and <code>TextElementEnumerator</code> types contained legacy logic that didn't properly handle all grapheme clusters. With this change, these two types process grapheme clusters according to the latest version of the Unicode Standard.</p><p>The .NET documentation sometimes uses the term "text element" when referring to a grapheme.</p><h3>Version introduced</h3><p>Introduced in .NET 5. The original tracking issue is <a href="https://github.com/dotnet/corefx/issues/41324">https://github.com/dotnet/corefx/issues/41324</a>.</p><h3>Old behavior</h3><p>In .NET Framework (all versions) and .NET Core 3.x and earlier, the <code>StringInfo</code> and <code>TextElementEnumerator</code> types implemented custom logic that handled certain combining classes but did not fully comply with the Unicode Standard.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span><span class="pl-en">System</span>.<span class="pl-en">Globalization</span>;

<span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Main</span>(<span class="pl-k">string</span>[] <span class="pl-smi">args</span>)
{
    <span class="pl-en">PrintGraphemes</span>(<span class="pl-s"><span class="pl-pds">"</span>‡∏Å‡∏≥<span class="pl-pds">"</span></span>);
    <span class="pl-en">PrintGraphemes</span>(<span class="pl-s"><span class="pl-pds">"</span>ü§∑üèΩ‚Äç‚ôÄÔ∏è<span class="pl-pds">"</span></span>);
}

<span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">PrintGraphemes</span>(<span class="pl-k">string</span><span class="pl-smi">str</span>)
{
    <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>Printing graphemes of <span class="pl-cce">\"</span>{<span class="pl-smi">str</span>}<span class="pl-cce">\"</span>...<span class="pl-pds">"</span></span>);
    <span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>;

    <span class="pl-en">TextElementEnumerator</span><span class="pl-smi">enumerator</span><span class="pl-k">=</span><span class="pl-smi">StringInfo</span>.<span class="pl-en">GetTextElementEnumerator</span>(<span class="pl-smi">str</span>);
    <span class="pl-k">while</span> (<span class="pl-smi">enumerator</span>.<span class="pl-en">MoveNext</span>())
    {
        <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>Grapheme {<span class="pl-k">++</span><span class="pl-smi">i</span>}: <span class="pl-cce">\"</span>{<span class="pl-smi">enumerator</span>.<span class="pl-smi">Current</span>}<span class="pl-cce">\"</span><span class="pl-pds">"</span></span>);
    }

    <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">$"</span>({<span class="pl-smi">i</span>} grapheme(s) total.)<span class="pl-pds">"</span></span>);
    <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>();
}</pre></div><p>Output:</p><pre lang="txt"><code>Printing graphemes of "‡∏Å‡∏≥"...
Grapheme 1: "‡∏Å"
Grapheme 2: "‡∏≥"
(2 grapheme(s) total.)

Printing graphemes of "ü§∑üèΩ‚Äç‚ôÄÔ∏è"...
Grapheme 1: "ü§∑"
Grapheme 2: "üèΩ"
Grapheme 3: "‚Äç"
Grapheme 4: "‚ôÄÔ∏è"
(4 grapheme(s) total.)
</code></pre><p>In the case of the single Thai character <em>kam</em>, the <code>StringInfo</code> and <code>TextElementEnumerator</code> classes incorrectly split the character back into its constituent components instead of keeping them together.</p><p>In the case of the emoji character, the <code>StringInfo</code> and <code>TextElementEnumerator</code> classes incorrectly split the emoji character into four clusters: person shrugging, skin tone modifier, gender modifier, and an invisible combiner. All of these should have been kept together as a single grapheme.</p><h3>New behavior</h3><p>Starting with .NET 5, the <code>StringInfo</code> and <code>TextElementEnumerator</code> classes follow the Unicode Standard exactly. In particular, they now return <a href="https://www.unicode.org/glossary/#extended_grapheme_cluster" rel="nofollow"><em>extended grapheme clusters</em></a>. Their logic implements the standard as defined by <a href="https://www.unicode.org/reports/tr29/tr29-35.html" rel="nofollow">Unicode Standard Annex #29, rev. 35</a>, sec. 3.</p><p>Re-running the sample program above now gives the correct output:</p><pre lang="txt"><code>Printing graphemes of "‡∏Å‡∏≥"...
Grapheme 1: "‡∏Å‡∏≥"
(1 grapheme(s) total.)

Printing graphemes of "ü§∑üèΩ‚Äç‚ôÄÔ∏è"...
Grapheme 1: "ü§∑üèΩ‚Äç‚ôÄÔ∏è"
(1 grapheme(s) total.)
</code></pre><p>Visual Basic's <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualbasic.strings.strreverse" rel="nofollow"><code>StrReverse</code></a> function is also updated to follow the standardized logic.</p><h3>Reason for change</h3><p>This change is part of a wider set of Unicode and UTF-8 improvements being made to .NET Core. It also provides a proper "extended grapheme cluster" enumeration API to complement the "Unicode scalar value" enumeration APIs which were introduced in .NET Core 3.0 with the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.rune" rel="nofollow"><code>System.Text.Rune</code></a> type.</p><h3>Recommended action</h3><p>No action is needed on the part of developers. Developers should find that their applications now behave in a more standards-compliant fashion in a wider variety of globalization-related scenarios.</p><h3>Category</h3><h3>Affected APIs</h3><hr><h4>Issue metadata</h4><ul><li>Issue type: breaking-change</li></ul></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>