<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Getting Dependencies by Name or Key using the .NET Core Container (Part 2) -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Getting Dependencies by Name or Key using the .NET Core Container (Part 2)</h1><div><div class="entry-content"><p>If you have come here from a search engine, I suggest reading <a href="named-dependencies-part-1">Part 1</a> first to get some background as to the problem that this post solves.</p><p>In Part 1, I gave the background as to why you may have a requirement to have a way of resolving instances from a DI container using a string name or some other key.</p><p>In this part, I propose a solution that leaves your code ignorant of any DI container and that is easily mockable for unit tests.</p><h2>Making Use of Strongly Typed Delegates</h2><p>A key thing to understand about DI containers is that the service type that is registered is exactly that – a type, not just interfaces and classes.&nbsp;Therefore, you can register delegates as well.</p><p>The idea of using delegates for resolution is not new. &nbsp;There is an example in the <a href="https://autofaccn.readthedocs.io/en/latest/advanced/delegate-factories.html" target="_blank" rel="noopener">Autofac documentation</a>&nbsp;and this&nbsp;<a href="https://www.c-sharpcorner.com/article/funct-dynamic-instantiation/" target="_blank" rel="noopener">article on c-sharpcorner</a>.</p><p>However, for .NET Core, when you search for something like ‘.NET Core named dependency injection’, you tend to only find the answer buried in StackOverflow answers.</p><p>That is why I have written this post, so that I can find the answer later myself, and also hopefully help other find it too.</p><h2>Func&lt;T&gt; Delegates Vs. Strongly Typed Delegates</h2><p>Before getting into a detail of using delegates as service types, we need to talk about generic <a href="https://docs.microsoft.com/en-us/dotnet/api/system.func-1?view=netcore-2.1" target="_blank" rel="noopener">Func delegates </a>vs <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/" target="_blank" rel="noopener">strongly typed delegates</a>.</p><p>The generic Func type was introducted in C# 3.0 and is a generic delegate included in the&nbsp;<code>System</code>&nbsp;namespace that has multiple overloads that accept between zero and sixteen input parameters (denoted T1 to T16) and a single output parameter (TResult). These are convenience types so that as a developer you do not need to repeatedly create your own customer delegates.</p><p>For the purposes of retrieving an instance of a type from the DI container, the various Func delegates can be used as the type for service registration and as a parameter to the constructors of classes. E.g. Func&lt;string, IServiceType&gt;.</p><p>However, I have two reasons for not using this approach.</p><ol><li>If you change the signature of the service registration to a different overload of Func, you have no tools in the IDE to reflect that change throughout all the references (as the dependency resolution does not take place until runtime). Instead you will need to perform a text ‘search and replace’ task across your whole code base (and hope that there are no other uses of the generic signature for other purposes). By using a strongly typed delegate, this is a unique type and therefore, when changing the signature of the delegate, the compiler will indicate when references and instances are broken (or a tool like Reshaper will do the work for you)</li><li>Though this is probably a very rare occurrence, you may have a need to have two different factories with the same signature. If the generic Func&lt;T, IServiceType&gt; is used, it will not be possible to differentiate the two factories. With strongly typed delegates, it is the delegate type that is registered and referenced in the constructor, so the same signature can be used with two different delegate types and the DI container will resolve tHem correctly.</li></ol><h2>How Does Using Typed Delegates Help?</h2><p>By using&nbsp;typed delegates, the code that requires the named/keyed dependency is ignorant of the DI container technology that is resolving the instance for it.</p><p>This differs from other approaches where either the consuming class itself or an intercepting factory class takes the IServiceProvider as a dependency in its constructor and has logic to resolve the instance itself which defeats the purpose of dependency injection as it is creating a glue between the classes.</p><p>By registering the delegate within the DI container registration code, it keeps the codebase (outside of Di registration) ignorant of how the name/key resolution is working.</p><h2>The Demo</h2><p>For the rest of this post, I am going to use a test project (which can be found on GitHub at&nbsp;<a href="https://github.com/configureappio/NamedDiDemo">https://github.com/configureappio/NamedDiDemo</a>) that converts temperatures to the Kelvin scale from four different scales – Centigrade, Fahrenheit, Rankine and Kelvins.</p><p>To do this, there are four formulas that are needed</p><table><tbody><tr><th>Calculation</th><th>Formula</th></tr><tr><td>Celcius(°C) to Kelvin(K)</td><td><i>T</i><sub>(K)</sub>&nbsp;=&nbsp;<i>T</i><sub>(°C)</sub>&nbsp;+ 273.15</td></tr><tr><td>Fahrenheit(°F) to Kelvin(K)</td><td><i>T</i><sub>(K)</sub>&nbsp;= &nbsp;(<i>T</i><sub>(°F)</sub>&nbsp;+ 459.67) x 5 / 9</td></tr><tr><td>Rankine to Kelvin(K)</td><td><i>T</i><sub>(K)</sub>&nbsp;=&nbsp;<i>T</i><sub>(°R)</sub>&nbsp;× 5/9</td></tr><tr><td>Kelvin(K) to Kelvin(K)</td><td><i>T</i><sub>(K)</sub>&nbsp;= <i>T</i><sub>(K)</sub></td></tr></tbody></table><p>Each formula is implemented as a mapper class with an implementation of the IKelvinMapper interface as defined below.</p><p>Each of the implementations is registered with the DI container</p><p>For the caller to retrieve the correct conversion, we need a delegate that uses the input temperature scale in order to retrieve the correct mapper and return the mapper as the IKelvinMapper interface</p><p>Lastly, a lookup function is registered with the DI container against the delegate type as the service type to perform the lookup of the correct mapper. To keep things simple, the lookup is based on the first (capitalised) letter of the input temperature scale (normally as more robust lookup would be used, but I’ve tried to keep it simple so as not to distract from the core purpose of what I am demonstrating).</p><p>With the returned interface implementation, a conversation from the input temperature scale and value can be made to a consistent value in the Kelvin scale.</p><h2>So How Does It Work?</h2><p>The demo works on a very simple basis of leveraging the DI container to do all the hard work of determining which mapping converter is required. The caller just needs to know that it uses the delegate to take in the input temperature scale and value and return the value in Kelvins.</p><h3>Object Instantiation</h3><p>Depending on the complexity of the type to be instantiated, there are three ways to instantiate the object:</p><ol><li>Perform the instantiation with a ‘new’ keyword. This is fine if the constructor of the type has no dependencies and a new instance is required on each occasion. However, I would discourage this approach as it is not an efficient way of managing the lifetimes of the objects and could lead to problems with garbage collection due to long lived objects</li><li>Rely on the DI container to instantiate the object. This is the approach taken in the demo. This has two benefits. The first is that if the object can be a singleton, then the DI container takes care of that for you provided the type has been registered as a singleton lifetime when registered. The second is that if the type has dependencies in the constructor, the DI container will resolve these for you</li><li>Lastly, if one or more parameters to the type constructor need the be generated from the delegate input (and therefore not directly resolvable from prior DI registrations), but other parameters can be resolved, then the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.activatorutilities.createinstance?view=dotnet-plat-ext-3.1" target="_blank" rel="noopener">ActivatorUtilities CreateInstance method </a>can be used to create an instance using a hybrid of provided parameters and using the DI container to resolve those parameters not provided.</li></ol><p>This is where you take advantage of the ability to register a service resolution using a lambda expression as it provides access to the IServiceProvider container instance to retrieve instances from the service provider for (2) and (3) above.</p><h3>Deciding Which Type to Instantiate</h3><p>For simple keys, you can use a case statement inside a lambda expression to derive the type required and let the DI container perform the object instantiation for you. (This is the approach I have used in the demo project).</p><p>However, if you have many different items or complex keys, you may want to consider other ways of deriving the service type required.</p><p>For example, by registering a singleton Dictionary&lt;string, serviceType&gt; to map keys to types, if there are many keys, you may gain a performance boost from the hash lookup algorithm.</p><p>Instead of using the out-of-the-box generic dictionary thought, I recommend creating a dedicated class that implements IDictionary&lt;string, Type&gt; for the same reasons that I recommend using custom delegates over the generic Func&lt;T&gt; – it removes any ambiguity if there is (deliberately or inadvertently) more than one registration of the generic dictionary.</p><h3>Care with Scoped Lifetimes</h3><p>Careful thought needs to be given to the lifetime of both the factory delegate and the object being retrieved from the DI container.</p><p>Typically, as&nbsp;factory classes have no state,&nbsp; they can usually be registered with a singleton lifetime. The same applies to the delegate being used as the factory or to access the factory class.</p><p>Where things get complicated is when the service type that the factory is instantiating for you has been registered in the DI container as having a scoped lifetime.</p><p>In this case, the resolution within the factory fails as the DI container cannot resolve scoped dependencies for constructor injection inside a singleton or transient lifetime object (in our case, the singleton factory delegate).</p><p>There are two ways to get around this problem.</p><p>(i) Register the factory delegate as scoped as well</p><p>(ii) Change the singleton factory delegate to take an IServiceProvider as part of the function signature. It is then the caller’s responsibility to pass the correctly scoped IServiceProvider to the delegate. However, this effectively takes us back to a service locator pattern again.</p><h3>Accessing the Delegate for Calling</h3><p>Now that we have abstracted the mapper instance generation into a delegate function, the client just needs to be able to resolve the instance.</p><p>For classes that want to use the mapper (and are also registered with the DI container), this is simply a case of making the delegate a constructor parameter.</p><h2>Conclusion</h2><p>Hopefully, these two posts have provided some insight into how the limitations of the Microsoft DI container to support named or keyed resolutions can be worked around without having to resort to using a third-party container or custom service locator pattern implementation.</p><p>Whilst not part of this two-part blog post, I have written another <a href="http://stevetalkscode.co.uk/simplifying-di-with-functions">post</a> about simplifying the demo to work in a more functional way by replacing the interface implementations with direct functions to (a) reduce the amount of code and (b) reduce the number of memory allocations required to create the objects.</p><h3 class="jp-relatedposts-headline"><em>Related</em></h3></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>