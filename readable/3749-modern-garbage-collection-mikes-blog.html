<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Modern garbage collection - Mike&#x2019;s blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Modern garbage collection - Mike’s blog</h1><div><div class="ac ae af ag ah ej aj ak"><h1 id="22ea" class="jm jn fj at as cf fl jo fn jp jq jr js jt ju jv jw">A primer on GC theory</h1><p id="93c3" class="ih ii fj at ij b gc jx ge jy im jz io ka iq kb is ee">Here are the different factors you will want to think about when designing a garbage collection algorithm:</p><ul class=""><li id="375f" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is kc kd ke"><strong class="ij jb">Program throughput</strong>: how much does your algorithm slow the program down? This is sometimes expressed as a percentage of CPU time spent doing collection vs useful work.</li><li id="6e4b" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">GC throughput:</strong> how much garbage can the collector clear given a fixed amount of CPU time?</li><li id="5c64" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Heap overhead:</strong> how much additional memory over the theoretical minimum does your collector require? If your algorithm allocates temporary structures whilst collecting, does that make memory usage of your program very spiky?</li><li id="4959" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Pause times:</strong> how long does your collector stop the world for?</li><li id="924d" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Pause frequency:</strong> how often does your collector stop the world?</li><li id="e88d" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Pause distribution:</strong> do you typically have very short pauses but sometimes have very long pauses? Or do you prefer pauses to be a bit longer but consistent?</li><li id="198c" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Allocation performance:</strong> is allocation of new memory fast, slow, or unpredictable?</li><li id="42b7" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Compaction:</strong> does your collector ever report an out-of-memory (OOM) error even if there’s sufficient free space to satisfy a request, because that space has become scattered over the heap in small chunks? If it doesn’t you may find your program slows down and eventually dies, even if it actually had enough memory to continue.</li><li id="0008" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Concurrency:</strong> how well does your collector use multi-core machines?</li><li id="59ae" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Scaling:</strong> how well does your collector work as heaps get larger?</li><li id="5b00" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Tuning:</strong> how complicated is the configuration of your collector, out of the box and to obtain optimal performance?</li><li id="f174" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Warmup time:</strong> does your algorithm self-adjust based on measured behaviour and if so, how long does it take to become optimal?</li><li id="ed28" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Page release:</strong> does your algorithm ever release unused memory back to the OS? If so, when?</li><li id="16d8" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Portability:</strong> does your GC work on CPU architectures that provide weaker memory consistency guarantees than x86?</li><li id="373b" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Compatibility:</strong> what languages and compilers does your collector work with? Can it be run with languages that weren’t designed for GC, like C++? Does it require compiler modifications? And if so, does changing GC algorithm require recompiling all your program and dependencies?</li></ul><p id="2c45" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">As you can see, there are a <em class="it">lot</em> of different factors that go into designing a garbage collector and some of them impact the design of the wider ecosystem around your platform. I’m not even sure I got them all.</p><p id="642c" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">Because the design space is so complex, garbage collection is a subfield of computer science rich in research papers. New algorithms are proposed and implemented at a steady rate, by both academia and industry. Unfortunately, nobody has yet found a single algorithm that is ideal for all situations.</p><h1 id="c8a3" class="jm jn fj at as cf fl kk fn kl jq km js kn ju ko jw">Tradeoffs, tradeoffs everywhere</h1><p id="df64" class="ih ii fj at ij b gc jx ge jy im jz io ka iq kb is ee">Let’s make that a bit more concrete.</p><p id="2fe1" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">The first garbage collection algorithms were designed for uniprocessor machines and programs that had small heaps. CPU and RAM was expensive and users were not very demanding, so visible pauses were OK. Algorithms designed for this world prioritised minimising the CPU and heap overhead of the collector. This meant a GC that did nothing at all until you failed to allocate memory. Then the program would be paused and a full mark/sweep of the heap would be done to mark parts as free as quickly as possible.</p><p id="49d2" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">These types of collectors are old but still have some advantages — they are simple, don’t slow down your program when not collecting and don’t add any memory overhead. In the case of conservative collectors like <a href="http://www.hboehm.info/gc/" class="dj by iu iv iw ix" target="_blank" rel="noopener">the Boehm GC</a> they don’t even need changes to your compiler or programming language! This can make them appropriate for desktop apps that typically have small heaps, <a href="https://wiki.unrealengine.com/Garbage_Collection_Overview" class="dj by iu iv iw ix" target="_blank" rel="noopener">including AAA video games</a> where the bulk of RAM is taken by data files which don’t need to be scanned.</p><p id="e5e9" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">Stop-the-world (STW) mark/sweep is the GC algorithm most commonly taught in undergrad computer science classes. When doing job interviews I sometimes ask candidates to talk a bit about GC and almost always, they either see GC as a black box and know nothing about it at all, or think it still uses this by now very old technique.</p><p id="67dd" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">The problem is that simple STW mark/sweep scales very badly. As you add cores and grow your heaps/allocation rates ever larger, this algorithm stops working well. But — sometimes you actually do have small heaps and the pause times from even simple approaches are good enough! In that case, maybe you still want to use this approach and keep your overheads low.</p><p id="b295" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">At the other end of the spectrum, perhaps you are using heaps hundreds of gigabytes in size on a machine with dozens of cores. Perhaps your server is doing trading in financial markets, or running a search engine, and thus low pause times are very important to you. In these cases you are probably willing to use an algorithm that actually slows down your program whilst it runs in order to do collection in the background and with low pause times.</p><p id="01e4" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">It’s not a simple spectrum! At the high end you can also have large batch jobs. As they are non-interactive pause times don’t matter at all, only total runtime. In such situations you are better off with an algorithm that maximises <em class="it">throughput </em>above all else, i.e. the ratio of useful work done to time spent doing collection.</p><p id="b68a" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">The problem is that there’s no single algorithm that is perfect in all aspects. Nor can a language runtime know whether your program is a batch job or an interactive latency-sensitive program. That’s the start of why “GC tuning” exists — it’s not because runtime engineers are dumb. It reflects fundamental limits in our capabilities in computer science.</p><h1 id="3c88" class="jm jn fj at as cf fl kk fn kl jq km js kn ju ko jw">The generational hypothesis</h1><p id="b49e" class="ih ii fj at ij b gc jx ge jy im jz io ka iq kb is ee"><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.122.4295&amp;rep=rep1&amp;type=pdf" class="dj by iu iv iw ix" target="_blank" rel="noopener">It has been known since 1984</a> that most allocations “die young” i.e. become garbage very soon after being allocated. This observation is called the generational hypothesis and is one of the strongest empirical observations in the entire PL engineering space. It has been consistently true across very different kinds of programming languages and across decades of change in the software industry: it is true for functional languages, imperative languages, languages that don’t have value types and languages that do.</p><p id="e48e" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">Discovering this fact about programs was useful because it meant GC algorithms could be designed to take advantage of it. These new <em class="it">generational collectors</em> had lots of improvements over the old stop-mark-sweep style:</p><ul class=""><li id="c8c1" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is kc kd ke"><strong class="ij jb">GC throughput:</strong> they could collect a lot more garbage a lot faster.</li><li id="ddf5" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Allocation performance:</strong> allocating new memory no longer required searching through the heap looking for a free slot, so allocation became effectively free.</li><li id="1c36" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Program throughput:</strong> allocations became neatly laid out in space next to each other, <a href="http://dl.acm.org/citation.cfm?id=1005693" class="dj by iu iv iw ix" target="_blank" rel="noopener">which improved cache utilisation significantly</a>. Generational collectors do require the program to do some extra work as it runs, but that hit seems empirically to be outweighed by the improved cache effects.</li><li id="44fe" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Pause times:</strong> most (but not all) pause times became much lower.</li></ul><p id="c52c" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">They also introduced some downsides:</p><ul class=""><li id="56af" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is kc kd ke"><strong class="ij jb">Compatibility:</strong> implementing a generational collector requires the ability to move things around in memory, and do extra work when the program writes to a pointer in some cases. This means the GC must be tightly integrated with the compiler. There are no generational collectors for C++.</li><li id="ef2a" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Heap overhead:</strong> these collectors work by copying allocations back and forth between various ‘spaces’. Because there must be space to copy to, these collectors impose some heap overhead. Also, they require various pointer maps to be maintained (the <em class="it">remembered sets</em>), further increasing overhead.</li><li id="c234" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Pause distribution:</strong> whilst many GC pauses were now very fast, some still required doing a full mark/sweep over the entire heap.</li><li id="45fc" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Tuning:</strong> generational collectors introduce the notion of a “young generation” or “eden space”, and program performance becomes quite sensitive to the sizing of this space.</li><li id="8870" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Warmup time:</strong> in response to the tuning issue, some collectors dynamically adapt the young generation size by observing how the program runs in practice, but now pause times depend on how long the program is running for as well. In practice this rarely matters outside of benchmarking.</li></ul><p id="639b" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">Still, the benefits are so huge that basically all modern GC algorithms are generational. If you can afford it — and you probably can — then you want it. Generational collectors can be enhanced with all sorts of other features, and a typical modern GC will be concurrent, parallel, compacting and generational all together.</p><h1 id="edab" class="jm jn fj at as cf fl kk fn kl jq km js kn ju ko jw">The Go concurrent collector</h1><p id="0992" class="ih ii fj at ij b gc jx ge jy im jz io ka iq kb is ee">As Go is a relatively ordinary imperative language with value types, its memory access patterns are probably comparable to C# where the generational hypothesis certainly holds and thus .NET uses a generational collector.</p><p id="6c8c" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">In fact Go programs are usually request/response processors like HTTP servers, meaning that Go programs exhibit strongly generational behaviour, and the Go team are exploring potentially exploiting that in future with something they call the <a href="https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/edit" class="dj by iu iv iw ix" target="_blank" rel="noopener">“request oriented collector”</a>. It <a href="https://news.ycombinator.com/item?id=11969740" class="dj by iu iv iw ix" target="_blank" rel="noopener">has been observed that this is essentially a renamed generational GC</a> with a tweaked tenuring policy. Such a GC can be simulated in other runtimes for request/response processors by ensuring the young generation is large enough that all garbage generated by handling a request fits within it.</p><p id="f003" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">Despite that, Go’s current GC is <strong class="ij jb">not</strong> generational. It just runs a plain old mark/sweep in the background.</p><p id="a69e" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">Doing it this way has one advantage — you can get very very low pause times — but makes almost everything else worse. Like what? Well, from our basic theory above we can see:</p><ul class=""><li id="d0ef" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is kc kd ke"><strong class="ij jb">GC throughput:</strong> The time needed to clear the heap of garbage scales with the size of a heap. Put simply, the more memory your program uses the more slowly memory gets freed up, and the more time your computer spends doing collection vs useful work. The only way this isn’t true is if your program doesn’t parallelise at all but you can keep throwing cores at the GC without limit.</li><li id="0a17" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Compaction:</strong> as there’s no compaction, your program can eventually fragment its heap. I’ll talk about heap fragmentation more below. You also don’t benefit from having things laid out neatly in the cache.</li><li id="ada5" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Program throughput:</strong> as the GC has to do a lot of work for every cycle, that steals CPU time from the program itself, slowing it down.</li><li id="f261" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Pause distribution:</strong> any garbage collector that runs concurrently with your program can encounter what the Java world calls a “concurrent mode failure”: your program creates garbage faster than the GC threads can clean it up. In this case the runtime has no choice but to stop your program entirely and wait for the GC cycle to complete. Thus when Go claims GC pauses are very low, this claim can only be true for the case where the GC has sufficient CPU time and headroom to outrun the main program. Additionally <a href="https://github.com/golang/go/issues/10958" class="dj by iu iv iw ix" target="_blank" rel="noopener">the Go compiler lacks features needed to ensure threads can be reliably paused quickly</a>, meaning that whether pause times are actually low or not depends heavily on what kind of code you’re running (e.g. base64 decoding a large blob in a single goroutine can cause pause times to go up).</li><li id="c5df" class="ih ii fj at ij b gc kf ge kg im kh io ki iq kj is kc kd ke"><strong class="ij jb">Heap overhead:</strong> because collecting the heap via mark/sweep is very slow, you need <em class="it">lots</em> of spare space to ensure you don’t suffer a “concurrent mode failure”. Go defaults to a heap overhead of 100% … it doubles the amount of memory your program needs.</li></ul><p id="3516" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">We can see these tradeoffs at work in <a href="https://groups.google.com/d/msg/golang-dev/Ab1sFeoZg_8/pv0Yg7tkAwAJ" class="dj by iu iv iw ix" target="_blank" rel="noopener">posts to golang-dev like this one</a>:</p><blockquote class="iy iz ja"><p id="67f8" class="ih ii fj it ij b gc ik ge il im in io ip iq ir is ee">The Service 1 allocates more than the Service 2, so STW pauses are higher there. But STW pause duration dropped by an order of magnitude on both services. We see ~20% increase in CPU usage spent in GC after the switch on both services.</p></blockquote><p id="6e63" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">So in this specific case Go bought an order of magnitude drop in pause times, but at a cost of an even slower collector. Was that a good tradeoff or were pause times low enough already? The poster does not say.</p><p id="5b3d" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">There comes a point though, where paying for more hardware to get lower pause times no longer makes sense. If your server pause times go from 10msec to 1msec, will your users really notice that? What if you had to double your machine count to get it?</p><p id="0255" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">Go optimises for pause times as the expense of throughput to such an extent that it seems willing to slow down your program by almost any amount in order to get even just slightly faster pauses.</p><h1 id="70a7" class="jm jn fj at as cf fl kk fn kl jq km js kn ju ko jw">Comparison with Java</h1><p id="65a1" class="ih ii fj at ij b gc jx ge jy im jz io ka iq kb is ee">The HotSpot JVM has several GC algorithms you can choose on the command line. None aim for pause times as low as Go’s because they balance them against other factors. It’s worth comparing them to get a feel for the tradeoffs. It’s possible to switch between GC’s just by restarting the program because compilation is done whilst the program runs, so the different barriers the different algorithms need can be compiled and optimised into the code as needed.</p><p id="5bb8" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">The default algorithm on any modern computer is the <em class="it">throughput collector</em>. This is designed for batch jobs and by default does not have any pause time goal (one can be given on the command line). This choice of defaults is one reason people tend to think Java GC must kind of suck: out of the box, Java tries to make your app run as fast as possible, with as little memory overhead as possible, and pause times be damned.</p><p id="2b79" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">If pause times matter to you more then you might switch to the <em class="it">concurrent mark/sweep collector</em> (CMS). This is the closest comparable algorithm to the one Go uses. But it’s also generational, and that’s why it has pause times longer than Go’s: the young generation is compacted whilst the app is paused because it involves moving objects around. There are two types of pauses in CMS. The first, faster kind, might last around 2–5 milliseconds. The second might be more like 20 milliseconds. CMS is adaptive: because it’s concurrent it has to guess when to start running (just like Go). Whereas Go asks you to configure the heap overhead to tune that, CMS will adapt itself at runtime to try and avoid concurrent mode failures. Because the bulk of the heap is ordinary mark/sweep, it’s possible to hit problems and slowdowns because of heap fragmentation.</p><p id="f0b9" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">The latest generation Java GC is called “G1” for “garbage first”. It’s not on by default in Java 8, but will be in Java 9. It is intended to be a general purpose one-size-fits-all algorithm, or as close as you can get right now. It is mostly concurrent, generational and compacting for the entire heap. It is also largely self tuning, but because (like all GC algorithms) it can’t know what you really want, it allows you to specify your preferred tradeoffs: just tell it the maximum amount of RAM you will let it use and a pause time goal in milliseconds, and it’ll adjust everything else as the app runs to try and meet the pause time goal. The default pause time goal is around 100msec, so you shouldn’t expect to see better than that unless you specify a different goal: G1 will prefer to make your app run faster than pause less than that. Pauses aren’t entirely consistent — most are extremely fast (less than a millisecond), and some will be slower (more like 50 milliseconds) when the heap is being compacted. G1 scales very well. There are reports of people using it with terabyte sized heaps. It also has some neat features, like deduplicating the strings in the heap.</p><p id="2419" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">Finally, a new GC algorithm has been developed called Shenandoah. It is being contributed to OpenJDK but won’t be in Java 9 unless you use special Java builds from Red Hat (who sponsor the project). This is designed to give very low pause times regardless of heap size whilst still being compacting. The cost is extra heap overhead and more barriers: to move objects around whilst the app is still running requires both pointer reads and writes to interact with the GC. In this sense it is similar to Azul’s “pauseless” collector.</p><h1 id="6eec" class="jm jn fj at as cf fl kk fn kl jq km js kn ju ko jw">Conclusion</h1><p id="5b5b" class="ih ii fj at ij b gc jx ge jy im jz io ka iq kb is ee">The point of this article is not to convince you to use a different programming language or tool. But if you take one thing away, let it be this: garbage collection is a hard problem, <em class="it">really</em> hard, one that has been studied by an army of computer scientists for decades. So be very suspicious of supposed breakthroughs that everyone else missed. They are more likely to just be strange or unusual tradeoffs in disguise, avoided by others for reasons that may only become apparent later.</p><p id="0d05" class="ih ii fj at ij b gc ik ge il im in io ip iq ir is ee">But if you do wish to minimize pause times at the expense of everything else, then by all means, check out the Go GC.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>