<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Building personal search infrastructure for your knowledge and code -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Building personal search infrastructure for your knowledge and code</h1><div><div class="outline-text-3" id="text-org0000010"><p>
Disappointed, I figured that least I could do is at somehow improve my workflow with grep.
</p><p>
So, what are the problems with using <code class="inline">grep</code>?
</p><ul class="org-ul"><li>running it against all of code results in false positives. <samp class="inline">node_modules</samp>, minified javascript, etc., you name it
<ul class="org-ul"><li>you probably want to at least ignore anything that's ignored by <code class="inline">.gitignore</code></li></ul></li><li>getting bunch of output lines in terminal is not interactive
<ul class="org-ul"><li>you have to repeat the command to refine the results</li><li>you can't quickly navigate to the result, check it and go back</li></ul></li><li>running it recursively against your filesystem root is ridiculously slow, even if you use an SSD
<ul class="org-ul"><li>you probably want to restrict your search to directories that look like a project (e.g. repositories), and again, exclude files ignored by version control</li></ul></li></ul><p><a id="ripgrep"></a>
As it turns out, <code class="inline">ripgrep</code> is the tool!
</p><ul class="org-ul"><li>respects <code class="inline">.gitignore</code> files, so by maintaining <code class="inline">.gitignore</code> properly (e.g. adding <samp class="inline">node_modules/venv</samp> etc) you can make sure you only get <b>meaningful matches</b> when searching for code.</li><li>respects <code class="inline">.ignore</code> files. Sometimes code has to be under version control, but you don't want it to show up in search (e.g. could happen if you have vendorized code or minified javascript or static html files).
In that case you can use <code class="inline">.ignore</code> files with the same syntax to exclude certain patterns from ripgrep's reach without messing with <code class="inline">.gitignore</code>.</li><li>it's <b>very</b> fast, both by <a href="https://github.com/BurntSushi/ripgrep#quick-examples-comparing-tools">benchmarks</a> and subjective experiments. You can read more comprehensive benchmarks <a href="https://blog.burntsushi.net/ripgrep/#code-search-benchmarks">here</a>.</li></ul><p>
If you just use ripgrep instead of grep, code search becomes magnitude more pleasant, but it's still not interactive. Long story short, we can use <code class="inline">helm</code> in Emacs to achieve <b>interactivity</b> and incremental search.
</p><p>
The only thing that's left is restricting the search to git repositories only.
Ripgrep relies on regexes, so we can't do something like Xpath queries and tell it to only search in directories, that contain <code class="inline">.git</code> directory. I ended up using a two step approach:
</p><ul class="org-ul"><li><p>
first, <a href="https://github.com/karlicoss/dotfiles-emacs/blob/4ea7a8deb48403cea712f1bd48b553b465da05f4/.spacemacs.d/config.el#L75-L83"><code class="inline">my/code-targets</code></a> returns all git repositories it can reach from <code class="inline">my/git-repos-search-root</code>.
</p><p>
I'm using <a href="https://github.com/sharkdp/fd"><code class="inline">fd</code></a> to go through the disk and collect all candidate git repositories.
</p><p>
Even though fd is already ridiculously <a href="https://github.com/sharkdp/fd#benchmark">fast</a>, this step still takes some time, so I'm caching the repositories. Cache is refreshed in the background every five minutes so we don't have to crawl the filesystem every time. That saves me few seconds on every search.
</p></li></ul><ul class="org-ul"><li>then, <a href="https://github.com/karlicoss/dotfiles-emacs/blob/4ea7a8deb48403cea712f1bd48b553b465da05f4/.spacemacs.d/config.el#L136-L140"><code class="inline">my/search-code</code></a> keybindings invokes <code class="inline">ripgrep</code> against all my directories with code, defined in <code class="inline">my/code-targets</code> function.</li></ul><p>
So, literally running grep against my code turned out to be a pretty good solution. I've got about 350 repositories and it works in a blink. Note, however, that I'm using SSD.
</p><p>
Ripgrep searches in real files on my disk, so any changes are reflected <b>immediately</b>, which removes the need for indexing (apart from performance concerns if you've got too many files to search in).
It would still be nice to avoid unnecessary disk operations, and of course, semantic search would be great, and that is definitely going to require some sort of indexer.
</p><p>
I've got a <a class="link-down" href="#snippet_code">global keybinding</a> to invoke Emacs with a prompt to search in code, so I can do in in a blink.
</p><p>
Here's a <a href="https://file.globalupload.io/onCac7sh9M.gif">gif (3.5 Mb)</a> showing it <b>in action</b>: say, I am working on testing a browser extension, and need to interact with in via hotkeys. I remember using <code class="inline">pyautogui</code> for automating <a href="https://github.com/karlicoss/grasp">Grasp</a> tests, but I forgot which function I actually need to use. Searching for 'pyautogui' brings me all the repositories where I'm using it and lets me quickly find out the command I need without having to read the documentation all over again.
</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>