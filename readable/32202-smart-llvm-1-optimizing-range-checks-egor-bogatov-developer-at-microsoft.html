<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Smart LLVM #1: Optimizing range checks | Egor Bogatov &#x2014; Developer at Microsoft -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Smart LLVM #1: Optimizing range checks | Egor Bogatov &#x2014; Developer at Microsoft</h1>
    <body> <p class="wrapper"> <aside class="user-profile fixed"> <p class="about-me">C#, C++, Performance</p> </aside> <main class="the-content"> <article class="post single"> <div class="post-content"> <p>Sometimes I explore LLVM sources and play with godbolt.org in order to find some interesting optimizations (not only the peephole ones) so I think I&#x2019;ll post some here in my blog from time to time. Also, if an optimization is simple enough I try to implement it in RuyJIT, e.g.:</p> <p>Today I am going to share a nice LLVM trick to optimize some common range checks.
So, let&#x2019;s say we have a function that checks if a char belongs to a list of reserved chars:</p><p>
(I actually copy-pasted it from CoreFX)</p></div></article></main></p> <figure class="highlight"><pre><code class="language-csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><p class="kt">bool</p> <p class="nf">IsReservedCharacter</p><p class="p">(</p><p class="kt">char</p> <p class="n">character</p><p class="p">)</p> <p class="c1">// uint16_t</p>
<p class="p">{</p> <p class="k">return</p> <p class="n">character</p> <p class="p">==</p> <p class="sc">&apos;;&apos;</p> <p class="p">||</p> <p class="n">character</p> <p class="p">==</p> <p class="sc">&apos;/&apos;</p> <p class="p">||</p> <p class="n">character</p> <p class="p">==</p> <p class="sc">&apos;:&apos;</p> <p class="p">||</p> <p class="n">character</p> <p class="p">==</p> <p class="sc">&apos;@&apos;</p> <p class="p">||</p> <p class="n">character</p> <p class="p">==</p> <p class="sc">&apos;&amp;&apos;</p> <p class="p">||</p> <p class="n">character</p> <p class="p">==</p> <p class="sc">&apos;=&apos;</p> <p class="p">||</p> <p class="n">character</p> <p class="p">==</p> <p class="sc">&apos;+&apos;</p> <p class="p">||</p> <p class="n">character</p> <p class="p">==</p> <p class="sc">&apos;$&apos;</p> <p class="p">||</p> <p class="n">character</p> <p class="p">==</p> <p class="sc">&apos;,&apos;</p><p class="p">;</p>
<p class="p">}</p></pre></td></tr></tbody></table></code></pre></figure> <p>Now let&#x2019;s compare outputs for RuyJIT and LLVM:
</p> <figure class="alignleft"> <figure class="highlight"><pre><code class="language-nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><p class="c">; C# RuyJIT</p> <p class="k">movzx</p> <p class="n">rax</p><p class="p">,</p> <p class="n">cx</p> <p class="k">cmp</p> <p class="n">eax</p><p class="p">,</p> <p class="mi">59</p> <p class="k">je</p> <p class="n">SHORT</p> <p class="n">G_IG04</p> <p class="k">cmp</p> <p class="n">eax</p><p class="p">,</p> <p class="mi">47</p> <p class="k">je</p> <p class="n">SHORT</p> <p class="n">G_IG04</p> <p class="k">cmp</p> <p class="n">eax</p><p class="p">,</p> <p class="mi">58</p> <p class="k">je</p> <p class="n">SHORT</p> <p class="n">G_IG04</p> <p class="k">cmp</p> <p class="n">eax</p><p class="p">,</p> <p class="mi">64</p> <p class="k">je</p> <p class="n">SHORT</p> <p class="n">G_IG04</p> <p class="k">cmp</p> <p class="n">eax</p><p class="p">,</p> <p class="mi">38</p> <p class="k">je</p> <p class="n">SHORT</p> <p class="n">G_IG04</p> <p class="k">cmp</p> <p class="n">eax</p><p class="p">,</p> <p class="mi">61</p> <p class="k">je</p> <p class="n">SHORT</p> <p class="n">G_IG04</p> <p class="k">cmp</p> <p class="n">eax</p><p class="p">,</p> <p class="mi">43</p> <p class="k">je</p> <p class="n">SHORT</p> <p class="n">G_IG04</p> <p class="k">cmp</p> <p class="n">eax</p><p class="p">,</p> <p class="mi">36</p> <p class="k">je</p> <p class="n">SHORT</p> <p class="n">G_IG04</p> <p class="k">cmp</p> <p class="n">eax</p><p class="p">,</p> <p class="mi">44</p> <p class="k">sete</p> <p class="n">al</p> <p class="k">movzx</p> <p class="n">rax</p><p class="p">,</p> <p class="n">al</p>
<p class="n">G_IG03</p><p class="o">:</p> <p class="k">ret</p> <p class="n">G_IG04</p><p class="o">:</p> <p class="k">mov</p> <p class="n">eax</p><p class="p">,</p> <p class="mi">1</p>
<p class="n">G_IG05</p><p class="o">:</p> <p class="k">ret</p></pre></td></tr></tbody></table></code></pre></figure> </figure> <figure class="alignleft"> <figure class="highlight"><pre><code class="language-nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><p class="c">; LLVM</p> <p class="k">add</p> <p class="n">edi</p><p class="p">,</p> <p class="o">-</p><p class="mi">36</p> <p class="k">cmp</p> <p class="n">di</p><p class="p">,</p> <p class="mi">28</p> <p class="k">ja</p> <p class="p">.</p><p class="n">LBB0_2</p> <p class="k">mov</p> <p class="n">al</p><p class="p">,</p> <p class="mi">1</p> <p class="k">movzx</p> <p class="n">ecx</p><p class="p">,</p> <p class="n">di</p> <p class="k">mov</p> <p class="n">edx</p><p class="p">,</p> <p class="mi">314575237</p> <p class="k">bt</p> <p class="n">rdx</p><p class="p">,</p> <p class="n">rcx</p> <p class="k">jae</p> <p class="p">.</p><p class="n">LBB0_2</p> <p class="k">ret</p>
<p class="p">.</p><p class="n">LBB0_2</p><p class="o">:</p> <p class="k">xor</p> <p class="n">eax</p><p class="p">,</p> <p class="n">eax</p> <p class="k">ret</p></pre></td></tr></tbody></table></code></pre></figure> </figure>
<figure class="aligncenter">
</figure> <p>As you can see C# generated a pretty simple set of 9 cmp + jumps for each logical OR. LLVM, at the same time, generated something strange with magic numbers and just two branches. Let&#x2019;s try to convert (disassemble) LLVM&#x2019;s output to C#:</p> <figure class="highlight"><pre><code class="language-csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><p class="kt">bool</p> <p class="nf">IsReservedCharacter</p><p class="p">(</p><p class="kt">char</p> <p class="n">c</p><p class="p">)</p>
<p class="p">{</p> <p class="n">c</p> <p class="p">=</p> <p class="p">(</p><p class="kt">char</p><p class="p">)(</p><p class="n">c</p> <p class="p">-</p> <p class="m">36</p><p class="p">);</p> <p class="k">if</p> <p class="p">(</p><p class="n">c</p> <p class="p">&gt;</p> <p class="m">28</p><p class="p">)</p> <p class="k">return</p> <p class="k">false</p><p class="p">;</p> <p class="k">return</p> <p class="p">((</p><p class="m">314575237</p> <p class="p">&gt;&gt;</p> <p class="n">c</p><p class="p">)</p> <p class="p">&amp;</p> <p class="m">1</p><p class="p">)</p> <p class="p">==</p> <p class="m">1</p><p class="p">;</p>
<p class="p">}</p></pre></td></tr></tbody></table></code></pre></figure> <p>so insted of 9 cmp we have <code class="highlighter-rouge">add, cmp, shr, and</code>
Let me explain the magic constants.<br>
First, we need to convert chars to their ASCII numbers:</p> <figure class="highlight"><pre><code class="language-csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><p class="sc">&apos;;&apos;</p> <p class="sc">&apos;/&apos;</p> <p class="sc">&apos;:&apos;</p> <p class="sc">&apos;@&apos;</p> <p class="sc">&apos;&amp;&apos;</p> <p class="sc">&apos;=&apos;</p> <p class="sc">&apos;+&apos;</p> <p class="sc">&apos;$&apos;</p> <p class="sc">&apos;,&apos;</p>
<p class="m">59</p> <p class="m">47</p> <p class="m">58</p> <p class="m">64</p> <p class="m">38</p> <p class="m">61</p> <p class="m">43</p> <p class="m">36</p> <p class="m">44</p></pre></td></tr></tbody></table></code></pre></figure> <p>The biggest is <code class="highlighter-rouge">@</code> (64) and the smallest is <code class="highlighter-rouge">$</code> (36). So, the range starts from 36 and the length is <code class="highlighter-rouge">64 - 36 = 28</code>. Thus the first <code class="highlighter-rouge">if</code> simply ignores all values outside of <code class="highlighter-rouge">[36..64]</code> range. Here is how I explained the first two magic numbers. Now it&#x2019;s <code class="highlighter-rouge">314575237</code>s turn:</p> <p>Since the range is known and the length is 28 which easily fits into a 32/64bit CPU register we can encode it to a special bit-map (a set of 0 and 1) - a 32/64 bit integer (depending on a platform).
Here is how it&#x2019;s done:</p> <figure class="highlight"><pre><code class="language-csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><p class="kt">long</p> <p class="n">bitmap</p> <p class="p">=</p> <p class="m">0</p><p class="p">;</p>
<p class="k">foreach</p> <p class="p">(</p><p class="kt">char</p> <p class="n">c</p> <p class="k">in</p> <p class="k">new</p> <p class="p">[]</p> <p class="p">{</p> <p class="sc">&apos;;&apos;</p><p class="p">,</p><p class="sc">&apos;/&apos;</p><p class="p">,</p><p class="sc">&apos;:&apos;</p><p class="p">,</p><p class="sc">&apos;@&apos;</p><p class="p">,</p><p class="sc">&apos;&amp;&apos;</p><p class="p">,</p><p class="sc">&apos;=&apos;</p><p class="p">,</p><p class="sc">&apos;+&apos;</p><p class="p">,</p><p class="sc">&apos;$&apos;</p><p class="p">,</p><p class="sc">&apos;,&apos;</p> <p class="p">})</p> <p class="n">bitmap</p> <p class="p">|=</p> <p class="m">1L</p> <p class="p">&lt;&lt;</p> <p class="n">c</p> <p class="p">-</p> <p class="m">36</p><p class="p">;</p></pre></td></tr></tbody></table></code></pre></figure> <p>So, for each char we push (shift) <code class="highlighter-rouge">1</code> to the left according to <code class="highlighter-rouge">c - 36</code> value (as you remember 36 stands for <code class="highlighter-rouge">$</code> so its index will be zero - on the right)<br>
and our bitmap becomes:</p> <figure class="highlight"><pre><code class="language-csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre> <p class="m">00010010110000000000100110000101</p> <p class="p">=</p> <p class="m">314575237</p> <p class="p">|</p> <p class="p">|</p> <p class="p">||</p> <p class="p">|</p> <p class="p">||</p> <p class="p">|</p> <p class="p">|</p> <p class="err">@</p> <p class="p">=</p> <p class="p">;:</p> <p class="p">/</p> <p class="p">,+</p> <p class="p">&amp;</p> <p class="err">$</p>
  </pre></td></tr></tbody></table></code></pre></figure> <p>Now when we do <code class="highlighter-rouge">314575237 &gt;&gt; (c - 36)</code> we either get <code class="highlighter-rouge">1</code> (symbol is one of the reserved) or <code class="highlighter-rouge">0</code> (doesn&#x2019;t belong to the set)</p> <p>Let&#x2019;s benchmark it! I have a random string here and I need to calculate how many symbols are reserved:</p> <figure class="highlight"><pre><code class="language-csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><p class="kt">string</p> <p class="n">str</p> <p class="p">=</p> <p class="s">&quot;Some link https://github.com/dotnet/coreclr/issues/12477, some@mail.com.&quot;</p><p class="p">;</p>
<p class="kt">int</p> <p class="n">count</p> <p class="p">=</p> <p class="m">0</p><p class="p">;</p>
<p class="k">foreach</p> <p class="p">(</p><p class="kt">char</p> <p class="n">c</p> <p class="k">in</p> <p class="n">str</p><p class="p">)</p> <p class="k">if</p> <p class="p">(</p><p class="nf">IsReservedCharacter</p><p class="p">(</p><p class="n">c</p><p class="p">))</p> <p class="n">count</p><p class="p">++;</p></pre></td></tr></tbody></table></code></pre></figure> <p>The results are:</p> <figure class="highlight"><pre><code class="language-csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><p class="p">|</p> <p class="n">Method</p> <p class="p">|</p> <p class="n">Mean</p> <p class="p">|</p> <p class="n">Error</p> <p class="p">|</p> <p class="n">StdDev</p> <p class="p">|</p> <p class="n">Ratio</p> <p class="p">|</p>
<p class="p">|----------------------------</p> <p class="p">|----------:|----------:|----------:|------:|</p>
<p class="p">|</p> <p class="n">CountReserverCharacters_old</p> <p class="p">|</p> <p class="m">197.6</p> <p class="n">ns</p> <p class="p">|</p> <p class="m">0.0422</p> <p class="n">ns</p> <p class="p">|</p> <p class="m">0.0352</p> <p class="n">ns</p> <p class="p">|</p> <p class="m">1.43</p> <p class="p">|</p>
<p class="p">|</p> <p class="n">CountReserverCharacters_new</p> <p class="p">|</p> <p class="m">138.4</p> <p class="n">ns</p> <p class="p">|</p> <p class="m">0.0735</p> <p class="n">ns</p> <p class="p">|</p> <p class="m">0.0652</p> <p class="n">ns</p> <p class="p">|</p> <p class="m">1.00</p> <p class="p">|</p></pre></td></tr></tbody></table></code></pre></figure> <p>The improved version is <strong>43%</strong> faster! (Core i7 8700K)</p> <p>Feature request for RuyJIT <a href="https://github.com/dotnet/coreclr/issues/12477">dotnet/coreclr#12477</a></p> <p>LLVM opt: <a href="https://godbolt.org/z/2B-00V">godbolt.org</a> (convert to switch)<br>
LLVM llc: <a href="https://godbolt.org/z/JSBhgh">godbolt.org</a> (DAG*)</p> </body>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>