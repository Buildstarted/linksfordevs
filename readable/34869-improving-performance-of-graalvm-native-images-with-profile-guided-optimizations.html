<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Improving performance of GraalVM native images with profile-guided optimizations -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Improving performance of GraalVM native images with profile-guided optimizations</h1>
    <div><section class="jj jk jl jm jn"><div class="ae jo ab dn v w"><div><div class="ka"><div class="ag af"><div><a href="https://link.medium.com/@jaroslav.tulach?source=post_page-----9c431a834edb----------------------"><img alt="Jaroslav Tulach" class="l fu kb kc" src="https://miro.medium.com/fit/c/96/96/0*pbdkvPUNRgzVDdfY" width="48"></a></div><div class="kd ab l"><span class="ao b ap aq ar as l at au"><span class="ao cr ee aq bx kg eg eh kh ej at"></span></span></div></div></div></div><p id="5cc0" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li"><strong class="kx lj">GraalVM Native Image</strong> tool rightfully attracts a lot of attention as it offers significant improvements in terms of startup speed and overall memory usage. However, if you create some benchmarks to evaluate peak performance you may observe that the native image sometimes doesn&#x2019;t offer better throughput too.</p><p id="e6a3" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">In this article we look at pros and cons of GraalVM <strong class="kx lj">Native Image</strong>. We show an easy way of generating PGO profiles for native images <a class="cw bt lk ll lm ln" href="https://link.medium.com/graalvm/graalvm-19-2-new-tools-b78a70f54b06">introduced in GraalVM 19.2</a> that significantly improves throughput of generated native images for known workloads.</p></div><div class="fb"><div class="af dg"><div class="dh lo di lp dj lq ff lr fg ls ab"><figure class="lu lv lw lx ly fb paragraph-image"><img alt class="gn n o gm ab" src="https://miro.medium.com/max/2128/1*FSkpfT9Vmg1Ps8sccQ016Q.png" width="1064"><figcaption class="at ee ml mm hn dn x y mn mo ao cr">A guide on how to use profile-guided optimizations for GraalVM native images.</figcaption></figure></div></div></div><div class="ae jo ab dn v w"><p id="c828" class="kv kw eb ap kx b ky nc la nd lc ne le nf lg ng li">Are you seeking a system with fast startup, low system requirements and multi-threaded communication? Do you want to code in a higher level language than C? Do you want to enjoy the benefits of memory safety and automatic garbage collection? There are few languages especially designed to fit such a design landscape and you may be considering to rewrite your application in one of those. However, if you are living in the JVM world then there is an easier option. Use GraalVM&#x2019;s <code class="mg nh ni nj b">native-image</code>tool!</p><p id="bb3a" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">The Native Image takes the bytecode of your application and compiles it to a native executable ahead of time. As a result one can program in any JVM language: Java, Scala, Kotlin &#x2014; and get a single, self-contained executable file as output. Single file has many benefits: It can be <em class="nk">easily copied</em> from one system to another just by itself &#x2014; it contains all the application code as well as necessary runtime support, like the garbage collector for example. Single file gets loaded and is ready to run &#x2014; no need to seek for various JAR, properties &amp; other miscellaneous files and wait for them to open, load and initialize. The file generated by Native Image gives us <em class="nk">instant startup</em>. In addition to that the Native Image tool is able to capture a snapshot of an application memory &#x2014; e.g. you can bring your system into <em class="nk">ready to run state</em> and when the generated native executable is started it continues exactly from where it was. This eliminates repetitive initialization and makes the startup time even more instant.</p><p id="6b63" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">Another benefit of ahead of time compilation is lower memory consumption. A typical JVM keeps enormous amount of metadata in memory in addition to the JIT generated native code. These metadata are needed to be able to de-optimize at almost any moment. Nothing like that is needed in case of Native Image &#x2014; the generated code covers all the possible code paths and never de-optimizes. The native code is known to be enough and all the metadata can be dropped when the native executable is being generated.</p><p id="4fd1" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">In spite of all the above goodies, the Native Image fulfils the most important aspects of a JVM &#x2014; one can use a language of own choice &#x2014; be it Java, Scala, Kotlin, etc. One can benefit from all the development tools available for the JVM. One can use the strong concurrency guarantees of a JVM and one doesn&#x2019;t need to care about garbage collection. The rich ecosystem of JVM full of useful libraries, tools and frameworks awaits to be compiled ahead of time.</p><h2 id="2865" class="mp">Trade-offs of Native Image</h2><p id="a1ac" class="kv kw eb ap kx b ky nc la nd lc ne le nf lg ng li">The previous text might make you believe that Native Image is great and it should replace the Java HotSpot VM immediately. That would not be accurate. The benefits brought by Native Image aren&#x2019;t for free &#x2014; they come with a cost. As such there are some aspects where Native Image limits its users more than classical Java HotSpot VM would.</p><p id="d955" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">Obviously the native executable can only run on a single platform. If you generate the image for 64-bit Linux, it only runs on Linux. If for Mac, it runs on Mac. If the executable is generated for Windows, it is going to run only on Windows. The portability is restricted compared to classical JAR file. Another limitation is caused by missing metadata during runtime. The previous section mentioned missing metadata as a benefit, but it also has its cost. Since by default native image doesn&#x2019;t retain information about classes and methods, one&#x2019;s ability to perform reflection is limited. The reflection is still possible, but it has to be configured and compiled into the native executable. As there are many Java frameworks that rely on reflective access, getting them run on Native Image may require additional configuration. Yet another restriction comes from the fact that the Native Image<strong class="kx lj"> </strong>runtime may not support all features of Java. Running Swing UI toolkit may not be possible as it is too dynamic. On the other hand, Native Image successfully managed to execute <em class="nk">Javac</em>, <em class="nk">Netty</em>, <em class="nk">Micronaut</em>, <em class="nk">Helidon</em> and <em class="nk">Fn Project</em> &#x2014; all large and nontrivial applications running on top of JDK.</p><p id="39b5" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">The last drawback associated with the ahead-of-time compilation is speed. What? I thought Native Image starts faster! Well, it does start significantly faster than similar JVM application, but at the end, when the application runs for a long time, the just-in-time compiler can actually outperform the AOT one. As the <a href="https://www.infoq.com/news/2019/07/helidon-supports-graalvm/" class="cw bt lk ll lm ln">helidon.io</a> team put it:</p><p id="f3e9" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li"><em class="nk">&#x201C;On the other hand, everything is always a tradeoff. Long running applications on traditional JVMs are still demonstrating better performance than GraalVM native executables due to runtime optimization. The key word here is long-running; for short-running applications like serverless functions, native executables have a performance advantage. So, you need to decide yourself between fast startup time and small size (and the additional step of building the native executable) versus better performance for long-running applications.&#x201D;</em></p><p id="bf28" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">Now we are getting to the main topic of this post. Let&#x2019;s take a look why the peak performance of AOT compilation is slower and then let&#x2019;s speed it up!</p><h2 id="9d53" class="mp">There is no Free Lunch!</h2><p id="5250" class="kv kw eb ap kx b ky nc la nd lc ne le nf lg ng li">By removing most of the typical metadata associated with JVM execution, native image gives up on further optimizations based on execution profiles. The ahead of time generated code is what one gets. There is no chance to do more inlining, co-locate code on hot paths or aggressively over optimize and rely on a trap to signal the need for de-optimization and less optimal compilation. These are exactly the optimizations that make JVM so great for reaching excellent peak performance. During ahead of time compilation <strong class="kx lj">Native Image</strong> doesn&#x2019;t have enough information to generate such optimal code.</p><p id="845f" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">On the other hand, there is no need for initial interpretation of the bytecode. There is no need for deoptimizations and there is no support for random reflection poking around your classes. As a result for short-lived application native image starts faster, overall uses less memory. The benefits are huge, however everything comes at some cost. There is no free lunch. Or is it?</p><h2 id="8d97" class="mp">Improving Peak Performance of Native Image</h2><p id="ba3e" class="kv kw eb ap kx b ky nc la nd lc ne le nf lg ng li">Commonly used technique to mitigate the missing just in time optimization is to gather the execution profiles at one run and then use them to optimize subsequent compilation(s). GraalVM 19.2.0 Enterprise comes with an improved <em class="nk">Profile Guide Optimizations</em> system. Let&#x2019;s demonstrate its functionality on a classical object oriented demo application &#x2014; let&#x2019;s work with shapes of geometric objects:</p><figure class="lu lv lw lx ly fb"><figcaption class="at ee ml mm hn dn x y mn mo ao cr">Shape.java</figcaption></figure><p id="3217" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">The above program introduces the <code class="mg nh ni nj b">Shape</code> interface and its four implementations: <code class="mg nh ni nj b">Circle</code>, <code class="mg nh ni nj b">Square</code>, <code class="mg nh ni nj b">Rectangle</code> and <code class="mg nh ni nj b">Triangle</code>. The base interface defines <code class="mg nh ni nj b">area()</code> method and each of the geometric classes overrides it and provides different implementation, suitable for its shape. Those who know how object oriented languages are implemented can already smell the problem. Right, if we create an array of shapes and go through it, the code will have to be ready for <em class="nk">virtual method dispatch</em>. Let&apos;s do it:</p><figure class="lu lv lw lx ly fb"><figcaption class="at ee ml mm hn dn x y mn mo ao cr">computeArea method</figcaption></figure><p id="698d" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">The array of <code class="mg nh ni nj b">all</code> shapes can contain any instances and as such the call <code class="mg nh ni nj b">shape.area()</code> has to be able to call any of the actual methods. That&apos;s usually done with a virtual method table associated with each geometric class. Find out the current <code class="mg nh ni nj b">shape</code> is <code class="mg nh ni nj b">Circle</code>, then lookup the actual implementation of <code class="mg nh ni nj b">Circle.area()</code> method and call it. Doing this requires a bit of calculation. To demonstrate that let&apos;s generate a huge array of random objects and measure how much time invoking the <code class="mg nh ni nj b">computeArea</code> method takes:</p><figure class="lu lv lw lx ly fb"><figcaption class="at ee ml mm hn dn x y mn mo ao cr">the main method which generates shapes and measures time</figcaption></figure><p id="8e18" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">If you put all the above code into file <code class="mg nh ni nj b"><a href="https://gist.github.com/JaroslavTulach/3d10da1ad1cc2e6fb7d9bacb78ea77ea" class="cw bt lk ll lm ln">Shape.java</a></code> (do it in an empty directory), you can compile it with GraalVM&apos;s <strong class="kx lj">Native Image </strong>tool. To get started <a href="https://www.graalvm.org/downloads/" class="cw bt lk ll lm ln">download GraalVM enterprise edition</a> as well as GraalVM Enterprise Edition Native Image tool. Unpack GraalVM and use its <code class="mg nh ni nj b">gu</code> tool to install (<code class="mg nh ni nj b">gu install --file native-image-installable-svm-svmee-*-19.2.0.jar</code>) the <code class="mg nh ni nj b">bin/native-image</code> utility. Then you can:</p><pre class="lu lv lw lx ly hl fo cg"><span id="c9fb" class="nm mq eb ap nj b ee nn no l np">$ /graalvm-ee-19.2.0/bin/javac Shape.java</span><span id="7e65" class="nm mq eb ap nj b ee nq nr ns nt nu no l np">$ /graalvm-ee-19.2.0/bin/native-image Shape</span><span id="85df" class="nm mq eb ap nj b ee nq nr ns nt nu no l np">$ ls -1<br>graalvm-ee-19.2.0<br>shape<br>&apos;Shape$Circle.class&apos;<br>&apos;Shape$Rectangle.class&apos;<br>&apos;Shape$Square.class&apos;<br>&apos;Shape$Triagle.class&apos;<br>Shape.class<br>Shape.java</span></pre><p id="2e4f" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">A <code class="mg nh ni nj b">shape</code> executable has been generated. When you run it, it is going to be completely standalone, start fast, require little memory, but it won&apos;t be optimized. Try it:</p><pre class="lu lv lw lx ly hl fo cg"><span id="1bd0" class="nm mq eb ap nj b ee nn no l np">$ ./shape 15000 43243223423 30 square rectangle<br>last round 35 ms.</span><span id="cbb1" class="nm mq eb ap nj b ee nq nr ns nt nu no l np">$ ./shape 15000 43243223423 30 triangle circle<br>last round 34 ms</span></pre><p id="5847" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">The actual execution time may vary depending on the speed of your computer. The absolute values do not matter much, we just want to make the execution faster. Let&#x2019;s train our program to be ready for square and rectangle. To do so we need to capture the data about the actual program execution. Let&#x2019;s thus generate the PGO data.</p><pre class="lu lv lw lx ly hl fo cg"><span id="cc67" class="nm mq eb ap nj b ee nn no l np">$ /graalvm-ee-19.2.0/bin/java -Dgraal.PGOInstrument=shape.iprof Shape 15000 43243223423 130 square rectangle</span></pre><p id="7225" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">The <code class="mg nh ni nj b">shape.iprof</code> file is generated once the execution is over. If you inspect its content, you may find out there is a reference to <code class="mg nh ni nj b">Shape$Square</code>, but there is no reference to <code class="mg nh ni nj b">Shape$Circle</code>. Of course - we&apos;ve been training the program for square and rectangles, not circles! The fact that <code class="mg nh ni nj b">Shape$Circle</code> is missing in the <code class="mg nh ni nj b">shape.iprof</code> file signals that the training was successful. Let&apos;s now use the data and regenerate our native image:</p><pre class="lu lv lw lx ly hl fo cg"><span id="d7c5" class="nm mq eb ap nj b ee nn no l np">$ /graalvm-ee-19.2.0/bin/native-image --pgo=shape.iprof Shape</span><span id="448c" class="nm mq eb ap nj b ee nq nr ns nt nu no l np">$ ./shape 15000 43243223423 30 square rectangle<br>last round 25 ms.</span></pre><p id="cd75" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">Speedup! Instead of 35ms we can now execute the trained program in 25ms. Just by training it, recording the compiler decisions and using them to guide the compilation, we have sped up our program <strong class="kx lj">by almost 30%</strong>.</p><p id="03e5" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">Note that this result is still not exactly on par with running with a warmed up JIT compiler. If we run the same code on with a JIT compiler we still see better results.</p><pre class="lu lv lw lx ly hl fo cg"><span id="ffe3" class="nm mq eb ap nj b ee nn no l np"> $ java Shape 15000 43243223423 130 square rectangle<br>last round 17 ms.</span></pre><p id="91af" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">We&#x2019;re working on enabling better optimizations in the GraalVM compiler used ahead-of-time, so the performance of native images should improve further in the future.</p><p id="8edb" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">If you&#x2019;re wondering whether the PGO optimization numbers translate well to the real world applications, you can try profile-guided optimizations on some larger project, for example on the <a href="https://guides.micronaut.io/micronaut-creating-first-graal-app/guide/index.html" class="cw bt lk ll lm ln">Micronaut demo application for GraalVM</a>. From our initial tests PGO shows good results there. We plan to expand on this topic in further articles.</p><p id="6eda" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">Of course, the speed up from PGO is only visible when the real workload mimics the one that we&#x2019;ve been training for. If the program input diverges and the execution gets into the non-optimized paths, it can actually be even slower than without any profiles:</p><pre class="lu lv lw lx ly hl fo cg"><span id="d252" class="nm mq eb ap nj b ee nn no l np">$ ./shape 15000 43243223423 30 triangle circle<br>last round 49 ms.</span></pre><p id="ce71" class="kv kw eb ap kx b ky kz la lb lc ld le lf lg lh li">Should something like that happen, it is time to re-profile your application, gather new PGO data and recompile. Note that prior to 19.2.0 one needed to create a special instrumented native image of the program to collect the profile information, but doing it by running application without preparing an instrumented native image is much simpler.</p><h2 id="ae7e" class="mp">Conclusions</h2><p id="09b9" class="kv kw eb ap kx b ky nc la nd lc ne le nf lg ng li">It is well known that GraalVM Native image gives you quick startup and consumes less memory. GraalVM 19.2.0 Enterprise brings you simplified way to use profile-guided optimizations (PGO) &#x2014; with its help it is possible to train your application for specific workloads and significantly improve the peak performance. <a href="https://www.oracle.com/technetwork/graalvm/downloads/index.html" class="cw bt lk ll lm ln">Download GraalVM 19.2.0 Enterprise and try it yourself</a>.</p></div></section></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>