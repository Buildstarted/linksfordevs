<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Creating an ASP.NET Core Markdown TagHelper and Parser - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Creating an ASP.NET Core Markdown TagHelper and Parser - linksfor.dev(s)"/>
    <meta property="article:author" content="Rick Strahl"/>
    <meta property="og:description" content="A couple of months ago I wrote about creating a WebForms based Markdown control. This time around I&#x27;ll build an ASP.NET Core MVC TagHelper that performs similar functionality for embedding Markdown text into a content area of a Razor page. The component also includes easy access to a Markdown parser using the blazing fast MarkDig Markdown parser."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://weblog.west-wind.com/posts/2018/mar/23/creating-an-aspnet-core-markdown-taghelper-and-parser"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Creating an ASP.NET Core Markdown TagHelper and Parser</title>
<div class="readable">
        <h1>Creating an ASP.NET Core Markdown TagHelper and Parser</h1>
            <div>by Rick Strahl</div>
            <div>Reading time: 24-31 minutes</div>
        <div>Posted here: 12 Apr 2019</div>
        <p><a href="https://weblog.west-wind.com/posts/2018/mar/23/creating-an-aspnet-core-markdown-taghelper-and-parser">https://weblog.west-wind.com/posts/2018/mar/23/creating-an-aspnet-core-markdown-taghelper-and-parser</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="ArticleBody" itemprop="articleBody">
        
        


        <p><a href="https://weblog.west-wind.com/images/2019/A-Markdown-TagHelper-and-Parser-for-ASP.NET-Core/ScribeImage.jpg"><img src="https://weblog.west-wind.com/images/2019/A-Markdown-TagHelper-and-Parser-for-ASP.NET-Core/ScribeImage.jpg" alt=""></a></p>
<p>A few months ago I wrote about creating a <a href="https://weblog.west-wind.com/posts/2017/Sep/13/A-Literal-Markdown-Control-for-ASPNET-WebForms">literal Markdown Control for WebForms</a>, where I described a simple content control that takes the content from within a tag and parses the embedded Markdown and then produces HTML output in its stead. I created a WebForms control mainly for selfish reasons, because I have tons of semi-static content on my content sites that still live in classic ASP.NET ASPX pages.</p>
<p>Since I wrote that article I've gotten a lot of requests to write about an ASP.NET Core version for something similar and - back to my own selfishness - I'm also starting to deploy a few content heavy sites that have mostly static html content that would be well served by Markdown using ASP.NET Core and Razor Pages. So it's time to build an ASP.NET Core version by creating a <code>&lt;markdown&gt;</code> TagHelper which I cover in this post. Along the same lines, I also created a <a href="https://weblog.west-wind.com/posts/2018/Apr/18/Creating-a-generic-Markdown-Page-Handler-using-ASPNET-Core-Middleware">generic markdown page processing Middleware component</a> that can be used to generically serve arbitrary Markdown documents in any ASP.NET Core site which I cover in a <a href="https://weblog.west-wind.com/posts/2018/Apr/18/Creating-a-generic-Markdown-Page-Handler-using-ASPNET-Core-Middleware">separate post</a> next week.</p>
<p>There are already a number of Markdown TagHelper implementations available, but I'm a big fan of the <a href="https://github.com/lunet-io/markdig">MarkDig Markdown Parser</a>, so I set out to create an <strong>ASP.NET Core Tag Helper</strong> that provides the same functionality as the WebForms control I previously created.</p>
<h2 id="get-it"><a name="get-it" href="#get-it"></a>Get it</h2>
<p>This library provides:</p>
<ul>
<li>A Markdown TagHelper</li>
<li>Markdown Parsing function</li>
<li>Markdown Page Processing Middleware that allows you to serve Markdown Pages as HTML</li>
</ul>
<p>In this post I cover the first two, the Markdown Page processor is covered in a <a href="https://weblog.west-wind.com/posts/2018/Apr/18/Creating-a-generic-Markdown-Page-Handler-using-ASPNET-Core-Middleware">separate post</a>.</p>
<p>The packaged <strong>Westwind.AspnetCore.Markdown</strong> component includes simple Markdown Parsing support for code or Razor pages and a the TagHelper for your ASP.NET Core applications.</p>
<p>It's available as a <a href="https://www.nuget.org/packages/Westwind.AspNetCore.Markdown">NuGet Package</a>:</p>
<pre><code><span>PM</span>&gt; <span>Install-Package</span> <span>Westwind</span><span>.AspNetCore</span><span>.Markdown</span>
</code></pre>
<p>And you can take a look at the source code on Github:</p>
<ul>
<li><a href="https://github.com/RickStrahl/Westwind.AspNetCore.Markdown">Westwind.AspnetCore.Markdown Github Repository</a></li>
<li><a href="https://www.nuget.org/packages/Westwind.AspNetCore.Markdown/">Westwind.AspnetCore.Markdown on NuGet</a></li>
</ul>
<p><em>Note: the GitHub repository was recently moved out of the <a href="https://github.com/RickStrahl/Westwind.AspNetCore">Westwind.AspnetCore</a> into its own dedicated package.</em></p>
<h2 id="quick-overview"><a name="quick-overview" href="#quick-overview"></a>Quick Overview</h2>
<p>The two key features are the Markdown Parser and the Markdown TagHelper.</p>
<h3 id="markdown-parsing"><a name="markdown-parsing" href="#markdown-parsing"></a>Markdown Parsing</h3>
<p>This library uses the popular Markdig Markdown parser along with configuration options to customize how Markdown is rendered.</p>
<p>At the highest level there are is a static Markdown instance that you can use to parse Markdown to an HTML string:</p>
<pre><code><span>var</span> html = Markdown.Parse(<span>"This is some **markdown** text and some `code`."</span>)
</code></pre>
<p>For use in Razor there's also another version that returns an <code>HtmlString</code> so you don't need <code>@html.Raw()</code> to display the rendered Markdown:</p>
<pre><code><span>&lt;<span>div</span>&gt;</span>@Markdown.ParseHtmlString(model.MarkdownNotes)<span>&lt;/<span>div</span>&gt;</span>
</code></pre>
<h3 id="markdown-taghelper"><a name="markdown-taghelper" href="#markdown-taghelper"></a>Markdown TagHelper</h3>
<p>Using the TagHelper you can render Markdown like this inside of a Razor Page:</p>
<pre><code><span>&lt;<span>markdown</span>&gt;</span>
    #### This is Markdown text inside of a Markdown block

    * Item 1
    * Item 2
 
    ### Dynamic Data is supported:
    The current Time is: @DateTime.Now.ToString("HH:mm:ss")

    ```cs
    // this c# is a code block
    for (int i = 0; i <span>&lt; <span>lines.Length</span>; <span>i</span>++)
    {
        <span>line1</span> = <span>lines[i];</span>
        <span>if</span> (!<span>string.IsNullOrEmpty</span>(<span>line1</span>))
            <span>break</span>;
    }
    ```
&lt;/<span>markdown</span>&gt;</span>
</code></pre>
<p>The Markdown is expanded into HTML to replace the markdown TagHelper content.</p>
<p>You can also bind to Model values using the <code>markdown</code> attribute:</p>
<pre><code>@model MarkdownModel

<span>&lt;<span>markdown</span> <span>markdown</span>=<span>"Model.MarkdownText"</span> /&gt;</span>
</code></pre>

<h2 id="why-do-i-need-a-markdown-taghelpercontrol"><a name="why-do-i-need-a-markdown-taghelpercontrol" href="#why-do-i-need-a-markdown-taghelpercontrol"></a>Why do I need a Markdown TagHelper/Control?</h2>
<p>Let's take a step back - why would you even need a content control for Markdown Parsing?</p>
<p>Markdown is everywhere these days and I for one have become incredibly dependent on it for a variety of text scenarios. I use it for blogging, for documentation both for code on Git repos and actual extended documentation. I use it for note keeping and collaboration in Gists or Github Repos, as well as a data entry format for many applications that need to display text content a little bit more richly than using plain text. Since I created the Markdown control I've also been using that extensively for quite a bit of my static content and it's made it much easier to manage some of my content this way.</p>
<h3 id="what-does-it-do"><a name="what-does-it-do" href="#what-does-it-do"></a>What does it do?</h3>
<p>The main reason for this component is the ability to <strong>embed</strong> Markdown into content with a simple tag that gets parsed into HTML at runtime. This is very useful for content pages that contain a lot of raw static text. It's a lot easier to write Markdown text in content pages than it is to write HTML tag soup consisting of <code>&lt;p&gt;</code>,<code>&lt;ul&gt;</code> and <code>&lt;h3&gt;</code> tags. Markdown is a heck of a lot more comfortable to type and maintain and this works well for common text content. It won't replace HTML for markup for an entire page, but it can be a great help with large content blocks inside of a larger HTML page.</p>
<p>In this post I'll create <code>&lt;markdown&gt;</code> TagHelper that can convert inline Markdown like this:</p>
<pre><code><span>&lt;<span>h3</span>&gt;</span>Markdown Tag Helper Block<span>&lt;/<span>h3</span>&gt;</span>

<span>&lt;<span>markdown</span>&gt;</span>
    #### This is Markdown text inside of a Markdown block

    * Item 1
    * Item 2
 
    ### Dynamic Data is supported:
    The current Time is: @DateTime.Now.ToString("HH:mm:ss")

    `` `cs
    // this c# is a code block
    for (int i = 0; i <span>&lt; <span>lines.Length</span>; <span>i</span>++)
    {
        <span>line1</span> = <span>lines[i];</span>
        <span>if</span> (!<span>string.IsNullOrEmpty</span>(<span>line1</span>))
            <span>break</span>;
    }
    `` `
    
&lt;/<span>markdown</span>&gt;</span>
</code></pre>
<p>The content of the control is rendered to HTML at runtime which looks like this:</p>
<p><a href="https://weblog.west-wind.com/images/2019/A-Markdown-TagHelper-and-Parser-for-ASP.NET-Core/MarkdownRendered.png"><img src="https://weblog.west-wind.com/images/2019/A-Markdown-TagHelper-and-Parser-for-ASP.NET-Core/MarkdownRendered.png" alt=""></a></p>
<p>The above renders with default Bootstrap styling of an ASP.NET Core MVC default Web site plus <a href="https://highlightjs.org/">hilightjs</a> for the code highlighting. You can check out the full <a href="https://github.com/RickStrahl/Westwind.AspNetCore/blob/master/SampleWeb/Pages/Markdown.cshtml"><code>Markdown.cshtml</code> page on Github</a>. The code of that page also includes the highlightjs hookup code to make the source code sample look nice.</p>
<p>It's important to understand that rendered Markdown is <strong>just HTML</strong> there's nothing in Markdown that handles styling of the content - that's left up to the host site or tool that displays the final HTML output. Any formatting comes from the host application, in this case the stock ASP.NET Core template for sample purposes.</p>
<p>Using this control allows you to easily create content areas inside of HTML documents that are rendered from Markdown. You write Markdown, the control renders HTML at runtime.</p>
<p>As part of this component I'll also provide a simple way to parse Markdown in code and inside of @RazorPages.</p>
<h2 id="creating-a-markdown-taghelper"><a name="creating-a-markdown-taghelper" href="#creating-a-markdown-taghelper"></a>Creating a Markdown TagHelper</h2>
<p>Before we dive in let's briefly discuss what TagHelpers are for those of you new to ASP.NET Core and then look at what it takes to create one.</p>
<h3 id="what-is-a-taghelper"><a name="what-is-a-taghelper" href="#what-is-a-taghelper"></a>What is a TagHelper?</h3>
<p>TagHelpers are a new feature for ASP.NET Core MVC, and it's easily one of the nicest improvements for server side HTML generation. TagHelpers are self contained components that are embedded into a <strong>@Razor</strong> page. TagHelpers look like HTML tags and unlike Razor expressions (@Expression) feel natural inside of standard HTML content in a Razor page.</p>
<p>Many of the existing Model binding and HTML helpers in ASP.NET have been replaced by TagHelpers and TagHelper behaviors that allow you to directly bind to HTML controls in a page. For example, here is an Input tag bound to a model value.</p>
<p>For example:</p>
<pre><code><span>&lt;<span>input</span> <span>type</span>=<span>"email"</span> <span>asp-for</span>=<span>"Email"</span> 
       <span>placeholder</span>=<span>"Your email address"</span>
       <span>class</span>=<span>"form-control"</span>/&gt;</span>
</code></pre>
<p>where <code>asp-for</code> extends the <code>input</code> element with an extension attribute to provide the model binding to the value property. This replaces:</p>
<pre><code>@Html.TextBoxFor(model =&gt; model.Email, 
                 new { @class = "form-control",
                      placeholder = "your email address", 
                      type = "email" })
</code></pre>
<p>Which would you rather use? ðŸ˜ƒ TagHelpers make it easier to write your HTML markup by sticking to standard HTML syntax which feels more natural than using Razor expressions.</p>
<h3 id="make-your-own-taghelpers"><a name="make-your-own-taghelpers" href="#make-your-own-taghelpers"></a>Make your own TagHelpers</h3>
<p>Another important point is that it's very easy to create your own TagHelpers which is the focus of this post. The interface to create a TagHelper is primarily a single method interface that takes a Context input to get element, tag and content information and an output string that has to be generated of for the actual TagHelper output. Using this approach feels very natural and makes it easy to create your own tag helpers with minimal fuss.</p>
<p>A TagHelper encapsulates rendering logic via a very simple <code>ProcessAsync()</code> interface that renders a chunk of HTML content into the page at the location the TagHelper is defined. The <code>ProcessAsync()</code> method takes a TagHelper Context as input to let you get at the element and attributes for input, and provides an output that you can write string output to generate your embedded content. As we'll see it takes very little code to create a very useful TagHelper.</p>
<p>In order to use TagHelpers they have to be registered with MVC, either in the page or more likely in the <code>_ViewImports.cshtml</code> page of the project.</p>
<p>To create a Tag Helper these are the things you typically need to do:</p>
<ul>
<li>Create a new Class and Inherit from <code>TagHelper</code></li>
<li>Create your TagHelper implementation via <code>ProcessAsync()</code> or <code>Process()</code>.</li>
<li>Register your TagHelper in <code>_ViewImports.cshtml</code></li>
<li>Reference your TagHelper in your pages</li>
<li>Rock on!</li>
</ul>

<h3 id="creating-the-markdowntaghelper-class"><a name="creating-the-markdowntaghelper-class" href="#creating-the-markdowntaghelper-class"></a>Creating the MarkdownTagHelper Class</h3>
<p>For the <code>&lt;markdown&gt;</code> TagHelper I want to create a content control whose content can be retrieved and parsed as Markdown and then converted into HTML. Optionally you can also use a <code>Markdown</code> property to bind Markdown for rendering - so if you have Markdown as part of data in your model you can bind it to this property/attribute in lieu of static content you provide.</p>
<p>Here's the base code for the <code>MarkdownTagHelper</code> that accomplishes these tasks:</p>
<pre><code>[<span>HtmlTargetElement(<span>"markdown"</span>)</span>]
<span>public</span> <span>class</span> <span>MarkdownTagHelper</span> : <span>TagHelper</span>
{
    [<span>HtmlAttributeName(<span>"normalize-whitespace"</span>)</span>]
    <span>public</span> <span>bool</span> NormalizeWhitespace { <span>get</span>; <span>set</span>; } = <span>true</span>;

    [<span>HtmlAttributeName(<span>"markdown"</span>)</span>]
    <span>public</span> ModelExpression Markdown { <span>get</span>; <span>set</span>; }

    <span><span>public</span> <span>override</span> <span>async</span> Task <span>ProcessAsync</span>(<span>TagHelperContext context, TagHelperOutput output</span>)</span>
    {
        <span>await</span> <span>base</span>.ProcessAsync(context, output);

        <span>string</span> content = <span>null</span>;
        <span>if</span> (Markdown != <span>null</span>)
            content = Markdown.Model?.ToString();

        <span>if</span> (content == <span>null</span>)            
            content = (<span>await</span> output.GetChildContentAsync(NullHtmlEncoder.Default))
                            .GetContent(NullHtmlEncoder.Default);

        <span>if</span> (<span>string</span>.IsNullOrEmpty(content))
            <span>return</span>;

        content = content.Trim(<span>'\n'</span>, <span>'\r'</span>);

        <span>string</span> markdown = NormalizeWhiteSpaceText(content);            

        <span>var</span> parser = MarkdownParserFactory.GetParser();
        <span>var</span> html = parser.Parse(markdown);

        output.TagName = <span>null</span>;  
        output.Content.SetHtmlContent(html);
    }
}
</code></pre>
<p>Before you can use the TagHelper in a page you'll need to register it with the MVC application by sticking the following into the <code>_ViewImports.cshtml</code>:</p>
<pre><code>@addTagHelper *, Westwind.AspNetCore.Markdown
</code></pre>
<p>Now you're ready to use the TagHelper:</p>
<pre><code><span>&lt;<span>markdown</span>&gt;</span>This is **Markdown Text**. Render me!<span>&lt;/<span>markdown</span>&gt;</span>
</code></pre>
<p>As you can see the code to handle the actual processing of the markdown is very short and easy to understand. It grabs either the content of the <code>&lt;markdown&gt;</code> element or the <code>markdown</code> attribute and then passes that to the the Markdown Parser to process. The parser turns the Markdown text into HTML which is the written out as HTML content using <code>output.Content.SetHtmlContent()</code>.</p>
<p>The code uses an abstraction for the Markdown Parser so the parser can be more easily replaced in the future without affecting the TagHelper code. I've gone through a few iterations of Markdown Parsers before landing on MarkDig, and I use this code in many places where I add Markdown parsing. I'll come back to the Markdown Parser in a minute.</p>
<h3 id="markdown-attribute-and-databinding"><a name="markdown-attribute-and-databinding" href="#markdown-attribute-and-databinding"></a>Markdown Attribute and DataBinding</h3>
<p>In addition to the content you can also bind to the <code>markdown</code> attribute which allows for programmatic assignment and databinding.</p>
<pre><code><span>@model MarkdownModel</span>
<span>@{</span>
    Model.MarkdownText = <span>"This is some **Markdown**!"</span>;
}

&lt;markdown markdown=<span>"Model.MarkdownText"</span> /&gt;
</code></pre>
<p>The <code>markdown</code> attribute accepts binding expressions you can bind Markdown for display from model values or other expressions easily.</p>
<h3 id="normalizing-markdown-text"><a name="normalizing-markdown-text" href="#normalizing-markdown-text"></a>Normalizing Markdown Text</h3>
<p>One issue with using a TagHelper or Control for Markdown is that Markdown expects no margins in the Markdown text to process.</p>
<p>If you have Markdown like this:</p>
<pre><code><span>&lt;<span>markdown</span>&gt;</span>
    #### This is Markdown text inside of a Markdown block

    * Item 1
    * Item 2
 
    ### Dynamic Data is supported:
    The current Time is: @DateTime.Now.ToString("HH:mm:ss")

    ```cs
    // this c# is a code block
    for (int i = 0; i <span>&lt; <span>lines.Length</span>; <span>i</span>++)
    {
        <span>line1</span> = <span>lines[i];</span>
        <span>if</span> (!<span>string.IsNullOrEmpty</span>(<span>line1</span>))
            <span>break</span>;
    }
    ```
&lt;/<span>markdown</span>&gt;</span>
</code></pre>
<p>and leave this Markdown in its raw form with the indent, the Markdown parser would render the entire Markdown text as a <strong>code block</strong>, because the text is indented with 4 spaces which is constitutes a code block in Markdown. Not what we want here!</p>
<p>This is where the <code>NormalizeWhiteSpace</code> property comes into play. This flag, which is <code>true</code> by default, determines whether leading repeated white space is stripped from the embedded Markdown block.</p>
<p>Here's the code to strip leading white space:</p>
<pre><code><span><span>string</span> <span>NormalizeWhiteSpaceText</span>(<span><span>string</span> text</span>)</span>
{
    <span>if</span> (!NormalizeWhitespace || <span>string</span>.IsNullOrEmpty(text))
        <span>return</span> text;

    <span>var</span> lines = GetLines(text);
    <span>if</span> (lines.Length &lt; <span>1</span>)
        <span>return</span> text;

    <span>string</span> line1 = <span>null</span>;

    
    <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; lines.Length; i++)
    {
        line1 = lines[i];
        <span>if</span> (!<span>string</span>.IsNullOrEmpty(line1))
            <span>break</span>;
    }

    <span>if</span> (<span>string</span>.IsNullOrEmpty(line1))
        <span>return</span> text;

    <span>string</span> trimLine = line1.TrimStart();
    <span>int</span> whitespaceCount = line1.Length - trimLine.Length;
    <span>if</span> (whitespaceCount == <span>0</span>)
        <span>return</span> text;

    StringBuilder sb = <span>new</span> StringBuilder();
    <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; lines.Length; i++)
    {
        <span>if</span> (lines[i].Length &gt; whitespaceCount)
            sb.AppendLine(lines[i].Substring(whitespaceCount));
        <span>else</span>
            sb.AppendLine(lines[i]);
    }

    <span>return</span> sb.ToString();
}

<span><span>string</span>[] <span>GetLines</span>(<span><span>string</span> s, <span>int</span> maxLines = <span>0</span></span>)</span>
{
    <span>if</span> (s == <span>null</span>)
        <span>return</span> <span>null</span>;

    s = s.Replace(<span>"\r\n"</span>, <span>"\n"</span>);

    <span>if</span> (maxLines &lt; <span>1</span>)
        <span>return</span> s.Split(<span>new</span> <span>char</span>[] { <span>'\n'</span> });

    <span>return</span> s.Split(<span>new</span> <span>char</span>[] { <span>'\n'</span> }).Take(maxLines).ToArray();
}
</code></pre>
<p>This code works by looking at the first non-empty line and checking for leading White space. It captures this white space and then removes that same leading whitespace from all lines of the content. This works as long as the Markdown Block uses consistent white space for all lines (ie. all tabs or all n spaces etc.).</p>
<p>If <code>normalize-whitespace="false"</code> in the document, you can still use the TagHelper but you have to ensure the that text is left justified in the saved razor file. This is hard if you're using Visual Studio as it'll try to reformat the doc and re-introduce the whitespace, so the default for this attribute is <code>true</code>.</p>
<p>To look at the complete code for this class you can check the code on Github:</p>
<ul>
<li><a href="https://github.com/RickStrahl/Westwind.AspNetCore.Markdown/blob/master/Westwind.AspNetCore.Markdown/MarkdownTagHelper.cs">MarkdownTagHelper.cs</a>
RickStrahl</li>
</ul>
<h3 id="razor-expressions-in-markdown"><a name="razor-expressions-in-markdown" href="#razor-expressions-in-markdown"></a>Razor Expressions in Markdown</h3>
<p>If you look back at the Markdown example above you might have noticed that the embedded Markdown includes a @Razor expression inside of the <code>&lt;markdown&gt;</code> tag.</p>
<p>The following works as you would expect:</p>
<pre><code><span>&lt;<span>markdown</span>&gt;</span>
The current Time is: **@DateTime.Now.ToString("HH:mm:ss")**
<span>&lt;/<span>markdown</span>&gt;</span>
</code></pre>
<p>Razor processes the expression <strong>before</strong> it passes the content to the TagHelper, so in this example the date is already expanded when the Markdown parsing is fired.</p>
<blockquote>
<h4 id="icon-info-circle-razor-expressions-and-encoding"><i></i>  Razor Expressions and Encoding</h4>
<p>If you look at the code that parses the <strong>content</strong> of the Razor tag helper element you'll notice this nasty syntax:</p>
<pre><code><span>if</span> (content == <span>null</span>)            
    content = (<span>await</span> output.GetChildContentAsync(NullHtmlEncoder.Default))
             .GetContent(NullHtmlEncoder.Default);
</code></pre>
<p>This is necessary to ensure that any expressions evaluated <strong>are not HTML encoded</strong> when parsed. Razor Expressions encode by default and that's not what we want inside of the Markdown content here, so the <code>NullHtmlEncoder.Default</code> essentially creates a pass-through encoder that does nothing and simply returns the raw output of an expression. Keep this in mind when building your own tag helpers that work with content. Thanks to <a href="https://twitter.com/DamianEdwards">Damien Edwards</a> for pointing that out.</p>
</blockquote>
<p>This is pretty cool - you can essentially use most of Razor's features in place. Just make sure that you generate <strong>Markdown</strong> compatible text from your Razor expressions and code.</p>

<h2 id="markdown-parsing-with-markdig"><a name="markdown-parsing-with-markdig" href="#markdown-parsing-with-markdig"></a>Markdown Parsing with Markdig</h2>
<p>The TagHelper above relies on a customized MarkdownParser implentation. As mentioned this component uses the MarkDig Markdown parser, but I added some abstraction around the Markdown Parser as I've switched parsers frequently in the past before settling pretty solidly on MarkDig.</p>
<p>Parsing Markdown with Markdig is pretty simple, and if you want to be quick about it, you can easily create a function that does the following to parse Markdown using MarkDig:</p>
<pre><code><span>public</span> <span>static</span> <span>class</span> <span>Markdown</span>
{
    <span><span>public</span> <span>static</span> <span>string</span> <span>Parse</span>(<span><span>string</span> markdown</span>)</span> 
    {
        <span>var</span> pipeline = <span>new</span> MarkdownPipelineBuilder()
                             .UseAdvancedExtensions()
                             .Build();
        <span>return</span> Markdown.ToHtml(markdown, pipeline);
    }
}        
</code></pre>
<p>MarkDig uses a configuration pipeline of support features that you can add on top of the base parser. The example above adds a number of common extensions (like Github Flavored Markdown, List Extensions etc.), but you can also add each of the components you want to customize exactly how you want Markdown to be parsed.</p>
<p>The code above is not super efficient as the pipeline needs to be recreated for each parse operation and that's part of the reason that I built a small abstraction layer around the Markdown parser so the parser can be easily switched without affecting the rest of the application and so that the generated Pipeline can be cached for better performance.</p>
<h3 id="a-markdownparserfactory"><a name="a-markdownparserfactory" href="#a-markdownparserfactory"></a>A MarkdownParserFactory</h3>
<p>The first thing is a Markdown Parser factory that provides an <code>IMarkdownParser</code> interface which has little more than that a <code>Parse()</code> method:</p>
<pre><code><span>public</span> <span>interface</span> <span>IMarkdownParser</span>
{
    <span><span>string</span> <span>Parse</span>(<span><span>string</span> markdown</span>)</span>;
}
</code></pre>
<p>The Factory then produces the Interface with at this point a hardcoded implementation for MarkDig in place. The factory also caches the Parser instance so it can be reused without reloading the entire parsing pipeline on each parse operation:</p>
<pre><code>


<span>public</span> <span>static</span> <span>class</span> <span>MarkdownParserFactory</span>
{
    
    
    
    <span>static</span> IMarkdownParser CurrentParser;

    
    
    
    
    
    
    <span><span>public</span> <span>static</span> IMarkdownParser <span>GetParser</span>(<span><span>bool</span> usePragmaLines = <span>false</span>,
                                            <span>bool</span> forceLoad = <span>false</span></span>)</span>                                                
    {
        <span>if</span> (!forceLoad &amp;&amp; CurrentParser != <span>null</span>)
            <span>return</span> CurrentParser;
        
        CurrentParser = <span>new</span> MarkdownParserMarkdig(usePragmaLines, forceLoad);

        <span>return</span> CurrentParser;
    }
}
</code></pre>
<p>Finally there's the actual <code>MarkDigMarkdownParser</code> implementation that's responsible for handling the actual configuration of the parser pipeline and parsing the Markdown to HTML. The class inherits from a <code>MarkdownParserBase</code> class that provides a few optional pre and post processing features such as font awesome font-embedding, yaml stripping (which is not built into MarkDig but not other parsers) etc.</p>
<pre><code>



<span>public</span> <span>class</span>  <span>MarkdownParserMarkdig</span> : <span>MarkdownParserBase</span>
{
    <span>public</span> <span>static</span> MarkdownPipeline Pipeline;

    <span>private</span> <span>readonly</span> <span>bool</span> _usePragmaLines;

    <span><span>public</span> <span>MarkdownParserMarkdig</span>(<span><span>bool</span> usePragmaLines = <span>false</span>, <span>bool</span> force = <span>false</span>, Action&lt;MarkdownPipelineBuilder&gt; markdigConfiguration = <span>null</span></span>)</span>
    {
        _usePragmaLines = usePragmaLines;
        <span>if</span> (force || Pipeline == <span>null</span>)
        {                
            <span>var</span> builder = CreatePipelineBuilder(markdigConfiguration);                
            Pipeline = builder.Build();
        }
    }

    
    
    
    
    
    <span><span>public</span> <span>override</span> <span>string</span> <span>Parse</span>(<span><span>string</span> markdown</span>)</span>
    {
        <span>if</span> (<span>string</span>.IsNullOrEmpty(markdown))
            <span>return</span> <span>string</span>.Empty;

        <span>var</span> htmlWriter = <span>new</span> StringWriter();
        <span>var</span> renderer = CreateRenderer(htmlWriter);

        Markdig.Markdown.Convert(markdown, renderer, Pipeline);

        <span>var</span> html = htmlWriter.ToString();
        
        html = ParseFontAwesomeIcons(html);

        
        html = ParseScript(html);  
                  
        <span>return</span> html;
    }

    <span><span>public</span> <span>virtual</span> MarkdownPipelineBuilder <span>CreatePipelineBuilder</span>(<span>Action&lt;MarkdownPipelineBuilder&gt; markdigConfiguration</span>)</span>
        {
            MarkdownPipelineBuilder builder = <span>null</span>;

            
            <span>if</span> (markdigConfiguration == <span>null</span>)
            {
                builder = <span>new</span> MarkdownPipelineBuilder()
                    .UseEmphasisExtras()
                    .UsePipeTables()
                    .UseGridTables()
                    .UseFooters()
                    .UseFootnotes()
                    .UseCitations()
                    .UseAutoLinks() 
                    .UseAutoIdentifiers(AutoIdentifierOptions.GitHub) 
                    .UseAbbreviations()
                    .UseYamlFrontMatter()
                    .UseEmojiAndSmiley(<span>true</span>)
                    .UseMediaLinks()
                    .UseListExtras()
                    .UseFigures()
                    .UseTaskLists()
                    .UseCustomContainers()
                    .UseGenericAttributes();

                

                <span>if</span> (_usePragmaLines)
                    builder = builder.UsePragmaLines();

                <span>return</span> builder;
            }
            
            
            
            builder = <span>new</span> MarkdownPipelineBuilder();
            markdigConfiguration.Invoke(builder);

            <span>if</span> (_usePragmaLines)
                builder = builder.UsePragmaLines();
            
            <span>return</span> builder;
        }

        <span><span>protected</span> <span>virtual</span> IMarkdownRenderer <span>CreateRenderer</span>(<span>TextWriter writer</span>)</span>
        {
            <span>return</span> <span>new</span> HtmlRenderer(writer);
        }
    }

    <span><span>protected</span> <span>virtual</span> IMarkdownRenderer <span>CreateRenderer</span>(<span>TextWriter writer</span>)</span>
    {
        <span>return</span> <span>new</span> HtmlRenderer(writer);
    }
}
</code></pre>
<p>The key bit about this class is that it can be used to configure how the Markdown Parser renders to HTML.</p>
<p>That's a bit of setup, but once it's all done you can now do:</p>
<pre><code><span>var</span> parser = MarkdownParserFactory.GetParser();
<span>var</span> html = parser.Parse(markdown);
</code></pre>
<p>and that's what the Markdown TagHelper uses to get a cached MarkdownParser instance for processing.</p>
<h3 id="overriding-markdig-pipeline-with-configuration"><a name="overriding-markdig-pipeline-with-configuration" href="#overriding-markdig-pipeline-with-configuration"></a>Overriding MarkDig Pipeline with Configuration</h3>
<p>This component uses the MarkDig Markdown Parser which allows for explicit feature configuration via many of its built-in extensions. The default configuration enables the most commonly used Markdown features and defaults to Github Flavored Markdown for most settings.</p>
<p>If you need to customize what features are supported you can override the pipeline creation explicitly in the <code>Startup.ConfigureServices</code> method and calling <code>services.AddMarkdown()</code>:</p>
<pre><code>services.AddMarkdown(config =&gt;
{
    
    
    config.ConfigureMarkdigPipeline = builder =&gt;
    {
        builder.UseEmphasisExtras(Markdig.Extensions.EmphasisExtras.EmphasisExtraOptions.Default)
            .UsePipeTables()
            .UseGridTables()                        
            .UseAutoIdentifiers(AutoIdentifierOptions.GitHub) 
            .UseAutoLinks() 
            .UseAbbreviations()
            .UseYamlFrontMatter()
            .UseEmojiAndSmiley(<span>true</span>)                        
            .UseListExtras()
            .UseFigures()
            .UseTaskLists()
            .UseCustomContainers()
            .UseGenericAttributes();
    };
});
</code></pre>
<p>This code gets passed an empty <code>MarkDigPipelineBuilder</code> that you can use to create a custom parser pipeline with just the features you need. When set this configuration is used every time the Markdown parser instance is created instead of the default behavior.</p>
<blockquote>
<h4 id="markdown-pipeline-configuration-options">Markdown Pipeline Configuration Options</h4>
<p>The library also supports configuration of the Markdown pileline via configuration handler that can be set up in the <code>Startup.Configure</code> method. <a href="https://weblog.west-wind.com/posts/2018/Apr/18/Creating-a-generic-Markdown-Page-Handler-in-ASPNET-Core#configuration-options">I cover the details of configuration in my next post</a> on the the Page Handling Markdown Middleware.</p>
</blockquote>
<h3 id="standalone-markdown-processing"><a name="standalone-markdown-processing" href="#standalone-markdown-processing"></a>Standalone Markdown Processing</h3>
<p>In addition to the TagHelper there's also a static class that lets you easily process Markdown in code or inside of a RazorPage, using a static <code>Markdown</code> class:</p>
<pre><code><span>public</span> <span>static</span> <span>class</span> <span>Markdown</span>
{
    
    
    
    
    
    
    
    <span><span>public</span> <span>static</span> <span>string</span> <span>Parse</span>(<span><span>string</span> markdown, <span>bool</span> usePragmaLines = <span>false</span>, <span>bool</span> forceReload = <span>false</span></span>)</span>
    {
        <span>if</span> (<span>string</span>.IsNullOrEmpty(markdown))
            <span>return</span> <span>""</span>;

        <span>var</span> parser = MarkdownParserFactory.GetParser(usePragmaLines, forceReload);
        <span>return</span> parser.Parse(markdown);
    }

    
    
    
    
    
    
    
    <span><span>public</span> <span>static</span> HtmlString <span>ParseHtmlString</span>(<span><span>string</span> markdown, <span>bool</span> usePragmaLines = <span>false</span>, <span>bool</span> forceReload = <span>false</span></span>)</span>
    {
        <span>return</span> <span>new</span> HtmlString(Parse(markdown, usePragmaLines, forceReload));
    }
}
</code></pre>
<p>In code you can now do:</p>
<pre><code><span>string</span> html = Markdown.Parse(markdownText)
</code></pre>
<p>Inside of Razor code you can do:</p>
<pre><code><span>&lt;<span>div</span>&gt;</span>@Markdown.ParseHtmlString(Model.ProductInfoMarkdown)<span>&lt;/<span>div</span>&gt;</span>
</code></pre>
<h3 id="summary"><a name="summary" href="#summary"></a>Summary</h3>
<p>As with the WebForms control none of this is anything very new, but I find that this is such a common use case that it's worth to have a reusable and easily accessible component for this sort of functionality. With a small Nuget package it's easy to add Markdown support both for content embedding as well as simple parsing.</p>
<p>As Markdown is getting ever more ubiquitous, most applications can benefit from including some Markdown features. For content sites especially Markdown can be a good fit for creating the actual text content inside of pages and the <code>&lt;markdown&gt;</code> control discussed here actually makes that very easy.</p>
<p>I was recently helping my girlfriend set up a landing page for her Web site and using Markdown I was able to actually set up a few content blocks in the page and let her loose on editing her own content easily. No way that would have worked with raw HTML.</p>
<p>Enjoy...</p>
<h3 id="resources"><a name="resources" href="#resources"></a>Resources</h3>
<ul>
<li><a href="https://www.nuget.org/packages/Westwind.AspNetCore.Markdown">Westwind.AspnetCore.Markdown NuGet Package</a></li>
<li><a href="https://github.com/RickStrahl/Westwind.AspNetCore.Markdown">Westwind.AspNetCore.Markdown on GitHub</a></li>
<li><a href="https://weblog.west-wind.com/posts/2018/Apr/18/Creating-a-generic-Markdown-Page-Handler-using-ASPNET-Core-Middleware">Creating generic Markdown Page Handling Middleware for ASP.NET Core</a></li>
<li><a href="https://weblog.west-wind.com/posts/2018/Dec/20/Updating-WestwindAspnetCoreMarkdown-with-Markdown-from-Files-and-URLs">File and URL Markdown Processing with Westwind.AspNetCore.Markdown</a></li>
<li><a href="https://weblog.west-wind.com/posts/2017/Sep/13/A-Literal-Markdown-Control-for-ASPNET-WebForms">A literal Markdown Control for ASP.NET WebForms</a></li>
</ul>





        
        
        
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>