<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Top 10 Things To Do With GraalVM - graalvm -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Top 10 Things To Do With GraalVM - graalvm</h1><div><div class="ac ae af ag ah ea aj ak"><figure class="ec ed ee ef eg eh dm dn paragraph-image"><p id="a074" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv"><em class="hs">This post has been updated to GraalVM 19.3.0</em></p><p id="0d6f" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">There are a lot of different parts to <a href="https://www.graalvm.org/" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">GraalVM</a>, so if you’ve heard the name before, or even seen some of our talks, there are for sure things that it can do that you don’t know about yet. In this article we’ll list some of the diverse features of GraalVM and show you what they can do for you.</p><p id="f948" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">You can reproduce everything that I’m showing in this article with GraalVM 19.3.0, which is available from <a href="https://www.graalvm.org/downloads" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">graalvm.org/downloads</a>. I’m using the Enterprise Edition on macOS, which is free to evaluate as we’re doing here, but the instructions will also work on Linux. Most of them will also work with the Community Edition.</p><p id="c711" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Follow along and run these programs while you’re reading! The code I’m running on GraalVM can be cloned from <a href="http://github.com/chrisseaton/graalvm-ten-things/" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">github.com/chrisseaton/graalvm-ten-things/</a>.</p><h1 id="b2b2" class="if ig ex at as ih ez ii fb ij ik il im in io ip iq">Setup</h1><p id="bcb2" class="he hf ex at hg b hh ir hj is hl it hn iu hp iv hr dv">I’ve downloaded GraalVM Enterprise Edition based on JDK8 for macOS from <a href="https://www.oracle.com/downloads/graalvm-downloads.html" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">https://www.oracle.com/downloads/graalvm-downloads.html</a>, and put the programs from it onto my <code class="ep iw ix iy iz b">$PATH</code>. This gives me the Java and JavaScript languages by default.</p><pre class="ja jb jc jd je jf jg cl"><span id="c480" class="jh ig ex at iz b ga ji jj r jk">$ git clone <a href="https://github.com/chrisseaton/graalvm-ten-things.git" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">https://github.com/chrisseaton/graalvm-ten-things.git</a><br>$ cd foo<br>$ tar -zxf graalvm-ee-java8-darwin-amd64-19.3.0.tar.gz<br># or graalvm-ee-java8-linux-amd64-19.3.0.tar.gz on Linux<br>$ export PATH=graalvm-ee-java8-19.3.0/Contents/Home/bin:$PATH<br># or PATH=graalvm-ee-java8-19.3.0/bin:$PATH on Linux</span></pre><p id="a89f" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">GraalVM comes with JavaScript included and has a package manager called <code class="ep iw ix iy iz b">gu</code> that lets you install additional languages. I’ve installed the Ruby, Python and R languages. I’ve also installed the <code class="ep iw ix iy iz b">native-image</code>tool. These all get downloaded from GitHub.</p><pre class="ja jb jc jd je jf jg cl"><span id="61c3" class="jh ig ex at iz b ga ji jj r jk">$ gu install native-image<br>$ gu install ruby<br>$ gu install python<br>$ gu install R</span></pre><p id="1222" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Now when you run <code class="ep iw ix iy iz b">java</code> or <code class="ep iw ix iy iz b">js</code> you'll get the GraalVM versions of those runtimes.</p><pre class="ja jb jc jd je jf jg cl"><span id="48ed" class="jh ig ex at iz b ga ji jj r jk">$ java -version<br>java version "1.8.0_231"<br>Java(TM) SE Runtime Environment (build 1.8.0_231-b11)<br>Java HotSpot(TM) 64-Bit GraalVM EE 19.3.0 (build 25.231-b11-jvmci-19.3-b05, mixed mode)</span><span id="bac6" class="jh ig ex at iz b ga jl jm jn jo jp jj r jk">$ js --version<br>GraalVM JavaScript (GraalVM EE Native 19.3.0)</span></pre><h1 id="a59d" class="if ig ex at as ih ez ii fb ij ik il im in io ip iq">1. High-performance modern Java</h1><p id="b872" class="he hf ex at hg b hh ir hj is hl it hn iu hp iv hr dv">The <em class="hs">Graal</em> name in the GraalVM comes from the GraalVM compiler. GraalVM is <a href="http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">one compiler to rule them all</a>, meaning that it’s a single implementation of a compiler written as a library which can be used for many different things. For example we use the GraalVM compiler to compile both <em class="hs">ahead-of-time</em> and <em class="hs">just-in-time</em>, to compile multiple programming languages, and to multiple architectures.</p><p id="037d" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">One simple way to use GraalVM is to use it as your Java JIT compiler.</p><p id="2999" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We’ll use this example program, which gives you the top-ten words in a document. It uses modern Java language features like streams and collectors.</p><figure class="ja jb jc jd je eh"><p id="c17f" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">GraalVM includes a <code class="ep iw ix iy iz b">javac</code> compiler, but it isn't any different from the standard one for the purposes of this demo, so you could use your system <code class="ep iw ix iy iz b">javac</code> instead if you wanted to.</p><pre class="ja jb jc jd je jf jg cl"><span id="7dcd" class="jh ig ex at iz b ga ji jj r jk">$ javac TopTen.java</span></pre><p id="4174" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">If we run the <code class="ep iw ix iy iz b">java</code> command included in GraalVM we'll be automatically using the Graal JIT compiler - no extra configuration is needed. I'll use the <code class="ep iw ix iy iz b">time</code> command to get the real, wall-clock elapsed time it takes to run the entire program from start to finish, rather than setting up a complicated micro-benchmark, and I'll use a large input so that we aren't quibbling about a few seconds here or there. The <code class="ep iw ix iy iz b">large.txt</code> file is 150 MB.</p><pre class="ja jb jc jd je jf jg cl"><span id="5c83" class="jh ig ex at iz b ga ji jj r jk">$ make large.txt<br>$ time java TopTen large.txt<br>sed = 502701<br>ut = 392657<br>in = 377651<br>et = 352641<br>id = 317627<br>eu = 317627<br>eget = 302621<br>vel = 300120<br>a = 287615<br>sit = 282613</span><span id="7a8a" class="jh ig ex at iz b ga jl jm jn jo jp jj r jk">real  0m12.950s<br>user  0m17.827s<br>sys 0m0.622s</span></pre><p id="a531" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">GraalVM is written in Java, rather than C++ like most other JIT compilers for Java. We think this allows us to improve it more quickly than existing compilers, with powerful new optimisations such as partial escape analysis that aren’t available in the standard JIT compilers for HotSpot. This can make your Java programs run significantly faster.</p><p id="bfaa" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">To run without the GraalVM JIT compiler to compare, I can use the flag <code class="ep iw ix iy iz b">-XX:-UseJVMCICompiler</code>. JVMCI is the interface between GraalVM and the JVM. You could also compare against your standard JVM as well.</p><pre class="ja jb jc jd je jf jg cl"><span id="2871" class="jh ig ex at iz b ga ji jj r jk">$ time java -XX:-UseJVMCICompiler TopTen large.txt<br>sed = 502701<br>ut = 392657<br>in = 377651<br>et = 352641<br>id = 317627<br>eu = 317627<br>eget = 302621<br>vel = 300120<br>a = 287615<br>sit = 282613</span><span id="5b96" class="jh ig ex at iz b ga jl jm jn jo jp jj r jk">real  0m19.602s<br>user  0m20.357s<br>sys 0m0.498s</span></pre><p id="8f8d" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">This shows GraalVM running our Java program in around two-thirds of the wall-clock time it takes to run it with a standard HotSpot compiler. In an area where we are used to treating single-digit percentage increases in performance as significant, this is a big-deal.</p><p id="e280" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">You’ll still get a result better than HotSpot if you use the Community Edition, but it won’t be quite as a good as the Enterprise Edition.</p><p id="22b0" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Twitter are one company <a href="https://www.youtube.com/watch?v=OSyvidFXL7M" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">using GraalVM in production today</a>, and they say that for them it is paying off in terms of real money saved. Twitter are using GraalVM to run Scala applications — GraalVM works at the level of JVM bytecode so it works for any JVM language.</p><p id="b6b1" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">This is the first way you can use GraalVM — simply as a drop-in better JIT compiler for your existing Java applications.</p><h1 id="0348" class="if ig ex at as ih ez ii fb ij ik il im in io ip iq">2. Low-footprint, fast-startup Java</h1><p id="412b" class="he hf ex at hg b hh ir hj is hl it hn iu hp iv hr dv">The Java platform is particularly strong for long-running processes and peak performance, but short-running processes can suffer from longer startup time and relatively high memory usage.</p><p id="7624" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">For example, if we run the same application with a much smaller input — around 1 KB instead of 150 MB, then it seems to take an unreasonably long time, and quite a lot of memory at 70 MB, to run for such a small file. We use <code class="ep iw ix iy iz b">-l</code> to print the memory used as well as time used.</p><pre class="ja jb jc jd je jf jg cl"><span id="2f24" class="jh ig ex at iz b ga ji jj r jk">$ make small.txt<br>$ /usr/bin/time -l java TopTen small.txt<br># -v on Linux instead of -l<br>sed = 6<br>sit = 6<br>amet = 6<br>mauris = 3<br>volutpat = 3<br>vitae = 3<br>dolor = 3<br>libero = 3<br>tempor = 2<br>suscipit = 2<br>0.17 real         0.28 user         0.04 sys<br>70737920  maximum resident set size<br>...</span></pre><p id="9511" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">GraalVM gives us a tool that solves this problem. We said that GraalVM is like a compiler library and it can be used in many different ways. One of those is to compile <em class="hs">ahead-of-time</em>, to a native executable image, instead of compiling <em class="hs">just-in-time</em> at runtime. This is similar to how a conventional compiler like <code class="ep iw ix iy iz b">gcc</code> works.</p><pre class="ja jb jc jd je jf jg cl"><span id="31f1" class="jh ig ex at iz b ga ji jj r jk">$ native-image --no-server --no-fallback TopTen<br>[topten:37970]    classlist:   1,801.57 ms<br>[topten:37970]        (cap):   1,289.45 ms<br>[topten:37970]        setup:   3,087.67 ms<br>[topten:37970]   (typeflow):   6,704.85 ms<br>[topten:37970]    (objects):   6,448.88 ms<br>[topten:37970]   (features):     820.90 ms<br>[topten:37970]     analysis:  14,271.88 ms<br>[topten:37970]     (clinit):     257.25 ms<br>[topten:37970]     universe:     766.11 ms<br>[topten:37970]      (parse):   1,365.29 ms<br>[topten:37970]     (inline):   3,829.55 ms<br>[topten:37970]    (compile):  34,674.51 ms<br>[topten:37970]      compile:  41,412.71 ms<br>[topten:37970]        image:   2,741.41 ms<br>[topten:37970]        write:     619.13 ms<br>[topten:37970]      [total]:  64,891.52 ms</span></pre><p id="fd05" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">This command produces a native executable called <code class="ep iw ix iy iz b">topten</code>. This executable isn’t a launcher for the JVM, it doesn’t link to the JVM, and it doesn’t bundle the JVM in any way. <code class="ep iw ix iy iz b">native-image</code> really does compile your Java code, and any Java libraries you use, all the way down to simple machine code. For runtime components like the garbage collector we are running our own new VM called the SubstrateVM, which like GraalVM is also written in Java.</p><p id="9b75" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">If we look at the libraries which <code class="ep iw ix iy iz b">topten</code> uses you can see they are only standard system libraries. We could also move just this one file to a system which has never had a JVM installed and run it there to verify it doesn’t use a JVM or any other files. It’s also pretty small - this executable is less than 8 MB.</p><pre class="ja jb jc jd je jf jg cl"><span id="8770" class="jh ig ex at iz b ga ji jj r jk">$ otool -L topten    # ldd topten on Linux<br>topten:<br>libSystem.B.dylib (current version 1252.250.1)<br>CoreFoundation (current version 1575.12.0)<br>/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)<br>$ du -h topten <br>7.5M  topten</span></pre><p id="cfb8" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">If we run the executable we can see that it starts around an order of magnitude faster, and uses around an order of magnitude less memory, than running the same program on the JVM does. It’s so fast that you don’t notice the time taken when using it at the command line — you don’t feel that pause you always get when running a short-running command with the JVM.</p><pre class="ja jb jc jd je jf jg cl"><span id="0b78" class="jh ig ex at iz b ga ji jj r jk">$ /usr/bin/time -l ./topten small.txt<br>sed = 6<br>sit = 6<br>amet = 6<br>mauris = 3<br>volutpat = 3<br>vitae = 3<br>dolor = 3<br>libero = 3<br>tempor = 2<br>suscipit = 2<br>0.02 real         0.00 user         0.00 sys<br>3158016  maximum resident set size<br>...</span></pre><p id="e54f" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">The <code class="ep iw ix iy iz b">native-image </code>tool has some <a href="https://github.com/oracle/graal/blob/master/substratevm/LIMITATIONS.md" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">restrictions</a> such as all classes having to be available during compilation, and some limitations around reflection. It has some additional advantages over basic compilation as well in that static initializers are run during compilation, so you can reduce the work done each time an application loads.</p><p id="69dc" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">This is a second way that you can use GraalVM — a way to distribute and run your existing Java programs with a low-footprint and fast-startup. It also frees you from configuration issues such as finding the right jar files at runtime, and allows you to have smaller Docker images.</p><h1 id="656f" class="if ig ex at as ih ez ii fb ij ik il im in io ip iq">3. Combine JavaScript, Java, Ruby, and R</h1><p id="ac57" class="he hf ex at hg b hh ir hj is hl it hn iu hp iv hr dv">As well as Java, GraalVM includes new implementations of JavaScript, Ruby, R and Python. These are written using a new language implementation framework called <em class="hs">Truffle</em> that makes it possible to implement language interpreters that are both simple and high performance. When you write a language interpreter using Truffle, Truffle will automatically use GraalVM on your behalf to give you a JIT compiler for your language. So GraalVM is not only a JIT compiler and ahead-of-time native compiler for Java, it can also be a JIT compiler for JavaScript, Ruby, R and Python.</p><p id="6413" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">The languages in GraalVM aim to be drop-in replacements for your existing languages. For example we can install a Node.js module:</p><pre class="ja jb jc jd je jf jg cl"><span id="4d62" class="jh ig ex at iz b ga ji jj r jk">$ npm install color<br>...<br>+ color@3.1.1<br>added 6 packages from 6 contributors and audited 7 packages in 6.931s</span></pre><p id="cad6" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We can write a little program <em class="hs">color.js</em> using this module to convert an RGB HTML color to HSL:</p><pre class="ja jb jc jd je jf jg cl"><span id="a75c" class="jh ig ex at iz b ga ji jj r jk">var Color = require('color');</span><span id="6796" class="jh ig ex at iz b ga jl jm jn jo jp jj r jk">process.argv.slice(2).forEach(function (val) {<br>console.log(Color(val).hsl().string());<br>});</span></pre><p id="de12" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Then we can run that in the usual way:</p><pre class="ja jb jc jd je jf jg cl"><span id="84c4" class="jh ig ex at iz b ga ji jj r jk">$ node color.js '#42aaf4'<br>hsl(204.89999999999998, 89%, 60.8%)</span></pre><p id="725e" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">The languages in GraalVM work together — there’s an API which lets you run code from one language in another. This lets you write polyglot programs — programs written in more than one language.</p><p id="aee0" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">You might want to do this because you want to write the majority of your application in one language, but there’s a library in another language’s ecosystem that you’d like to use. For example, say we’d like to write our application for converting a CSS color name to hexadecimal in Node.js, but we want to use a Ruby color library instead to do the conversion.</p><figure class="ja jb jc jd je eh"><p id="06d7" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We specify some Ruby code to run as a string, but notice that we don’t do much in it — we just require the libraries, and then return a Ruby object. The way to use this object from Ruby is normally to say <code class="ep iw ix iy iz b">Color::RGB.by_name(name).html</code>. If you look at how <code class="ep iw ix iy iz b">color_rgb</code> is used further down by JavaScript, you can see that actually we're calling these methods from JavaScript, even though they are Ruby objects and methods, and we pass them a JavaScript string, and we concatenate the result, which is a Ruby string, with other JavaScript strings.</p><p id="a7ea" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We’ll install both our Ruby and JavaScript dependencies.</p><pre class="ja jb jc jd je jf jg cl"><span id="80b6" class="jh ig ex at iz b ga ji jj r jk">$ gem install color<br>Fetching: color-1.8.gem (100%)<br>Successfully installed color-1.8<br>1 gem installed</span><span id="825d" class="jh ig ex at iz b ga jl jm jn jo jp jj r jk">$ npm install express<br>+ express@4.17.0<br>added 50 packages from 37 contributors and audited 143 packages in 22.431s</span></pre><p id="61ff" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We then need to run <code class="ep iw ix iy iz b">node</code> with a couple of options: <code class="ep iw ix iy iz b">--polyglot</code> to say we want access to other languages, and <code class="ep iw ix iy iz b">--jvm</code> because the <code class="ep iw ix iy iz b">node</code> native image by default doesn't include more than JavaScript.</p><pre class="ja jb jc jd je jf jg cl"><span id="19ec" class="jh ig ex at iz b ga ji jj r jk">$ node --polyglot --jvm color-server.js<br>serving at <a href="http://localhost:8080" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">http://localhost:8080</a></span></pre><p id="592e" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Then open <a href="http://localhost:8080/css/aquamarine" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">http://localhost:8080/css/aquamarine</a>, or some other colour name, as normal in your browser.</p><figure class="ja jb jc jd je eh dm dn paragraph-image"><p id="121c" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Let’s try a larger example using more languages and modules.</p><p id="f57f" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">JavaScript doesn’t have a great solution for arbitrarily-large integers. I found several modules like <code class="ep iw ix iy iz b">big-integer</code> but these are all inefficient as they store components of the number as JavaScript floating point numbers. Java's <code class="ep iw ix iy iz b">BigInteger</code> class is more efficient so let's use that instead to do some arbitrarily-large integer arithmetic.</p><p id="2b2c" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">JavaScript also doesn’t include any built-in support for drawing graphs, where R does include excellent support for this. Let’s use R’s <code class="ep iw ix iy iz b">svg</code> module to draw a 3D scatter plot of a trigonometric function.</p><p id="46de" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">In both cases we can use GraalVM’s polyglot API, and we can just compose the results from these other languages into JavaScript.</p><figure class="ja jb jc jd je eh"><p id="38aa" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Open <a href="http://localhost:3000/" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">http://localhost:3000/</a> in your browser to see the result.</p><figure class="ja jb jc jd je eh dm dn paragraph-image"><p id="1fe3" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">That’s the third thing we can do with GraalVM — run programs written in multiple languages and use modules from those languages together. We think of this as a kind of commoditisation of languages and modules — you can use whichever language you think is best for your problem at hand, and whichever library you want, no matter which language it came from.</p><h1 id="196d" class="if ig ex at as ih ez ii fb ij ik il im in io ip iq">4. Run native languages on the JVM</h1><p id="da89" class="he hf ex at hg b hh ir hj is hl it hn iu hp iv hr dv">Another language that GraalVM supports is C. GraalVM can run C code in the same way that it runs languages like JavaScript and Ruby.</p><p id="a39e" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">What GraalVM actually supports is running the output of the LLVM toolchain — LLVM bitcode — rather than directly supporting C. This means you can use your existing tooling with C, and also other languages that can output LLVM, such as C++, Fortran, and potentially other languages in the future. To make things simple for a demo I’m running a special <a href="http://people.csail.mit.edu/smcc/projects/single-file-programs/" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">single-file version</a> of gzip, maintained by <a href="http://people.csail.mit.edu/smcc/" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">Stephen McCamant</a>. It’s just the <code class="ep iw ix iy iz b">gzip</code> source code and the <code class="ep iw ix iy iz b">autoconf</code> configuration concatenated into one file for simplicity. I've also had to patch a couple of things to make it work on macOS and with clang, but not to get it working on GraalVM.</p><p id="ccfb" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Then we can compile using standard <code class="ep iw ix iy iz b">clang</code> (the LLVM C compiler), and we want it to compile to LLVM bitcode, not native assembly, because that's what GraalVM can run. I'm using <code class="ep iw ix iy iz b">clang</code> 4.0.1.</p><pre class="ja jb jc jd je jf jg cl"><span id="6721" class="jh ig ex at iz b ga ji jj r jk">$ clang -c -emit-llvm gzip.c</span></pre><p id="c14a" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">And then we run this directly using GraalVM using the <code class="ep iw ix iy iz b">lli</code> command (LLVM bitcode interpreter). Let's try compressing a file using my system <code class="ep iw ix iy iz b">gzip</code>, and then decompress using <code class="ep iw ix iy iz b">gzip</code> running on GraalVM.</p><pre class="ja jb jc jd je jf jg cl"><span id="512c" class="jh ig ex at iz b ga ji jj r jk">$ cat small.txt<br>Lorem ipsum dolor sit amet...<br>$ gzip small.txt<br>$ lli gzip.bc -d small.txt.gz<br>$ cat small.txt<br>Lorem ipsum dolor sit amet...</span></pre><p id="9f4a" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Alternatively, C/C++ code can be compiled to LLVM bitcode using the <code class="ep iw ix iy iz b">clang</code> shipped with GraalVM. For that you should enable a pre-built LLVM toolchain support and point the <code class="ep iw ix iy iz b">LLVM_TOOLCHAIN</code> environment variable to the directory containing a set of build tools, such as a C compiler and a linker, that enables compiling a native project to bitcode.</p><pre class="ja jb jc jd je jf jg cl"><span id="8e57" class="jh ig ex at iz b ga ji jj r jk">$ gu install llvm-toolchain<br>$ export LLVM_TOOLCHAIN=$(lli --print-toolchain-path)</span></pre><p id="9cd9" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Then you can compile <code class="ep iw ix iy iz b">gzip.c</code> source code to an executable with embedded LLVM bitcode and run it as follows:</p><pre class="ja jb jc jd je jf jg cl"><span id="5efb" class="jh ig ex at iz b ga ji jj r jk">$ $LLVM_TOOLCHAIN/clang gzip.c -o gzip<br>$ gzip small.txt<br>$ lli gzip -d small.txt.gz<br>$ cat small.txt<br>Lorem ipsum dolor sit amet...</span></pre><p id="e710" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">The implementations of Ruby and Python in GraalVM use this technique to run C extensions for these languages. This means that you can run C extensions inside the VM, and it allows us to maintain high performance even while supporting these legacy native extension interfaces.</p><p id="5019" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">This is a fourth thing you can do with the GraalVM — run programs written in native languages like C and C++, and also run C extensions to languages like Python and Ruby, which existing JVM implementations like JRuby are not able to do.</p><h1 id="4887" class="if ig ex at as ih ez ii fb ij ik il im in io ip iq">5. Tools that work across all languages</h1><p id="ffce" class="he hf ex at hg b hh ir hj is hl it hn iu hp iv hr dv">If you program in Java you’re probably used to very high quality tools like IDEs, debuggers and profilers. Not all languages have these kind of tools, but you get them if you use a language in GraalVM.</p><p id="cc9d" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">All the GraalVM languages (except for Java at the moment) are implemented using the common Truffle framework. This allows us to implement functionality like debuggers once and have it available to all languages.</p><p id="2b3d" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">To try this we’ll write a basic <em class="hs">FizzBuzz</em> program, because it prints things to the screen and it has clear branches that are only taken on some iterations, so we can set some breakpoints more easily. We’ll start with a JavaScript implementation.</p><figure class="ja jb jc jd je eh"><p id="f3f5" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We can run this JavaScript program as normal using GraalVM, using the <code class="ep iw ix iy iz b">js</code> executable.</p><pre class="ja jb jc jd je jf jg cl"><span id="40ce" class="jh ig ex at iz b ga ji jj r jk">$ js fizzbuzz.js<br>1<br>2<br>Fizz<br>4<br>Buzz<br>Fizz<br>...</span></pre><p id="5ad3" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We can also run the program with the flag <code class="ep iw ix iy iz b">--inspect</code>. This will give us a link to open in Chrome and will pause the program in the debugger.</p><pre class="ja jb jc jd je jf jg cl"><span id="5228" class="jh ig ex at iz b ga ji jj r jk">$ js --inspect fizzbuzz.js<br>Debugger listening on port 9229.<br>To start debugging, open the following URL in Chrome:<br>chrome-devtools://devtools/bundled/inspector.html?ws=127.0.0.1:9229/6c478d4e-1350b196b409<br>...</span></pre><p id="51f8" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We can then set a breakpoint on the <em class="hs">FizzBuzz</em> line and then continue execution. When it breaks we’ll see the value of <code class="ep iw ix iy iz b">n</code>, and can continue again, or explore the rest of the debugging interface.</p><figure class="ja jb jc jd je eh dm dn paragraph-image"><p id="ed24" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">The Chrome debugger is usually used with JavaScript, but there’s nothing special about JavaScript in GraalVM. This flag is also available and working in our implementations of Python, Ruby and R. I won’t show you the source of each program, but you run them in exactly the same way, and get the same Chrome debugger interface to each.</p><pre class="ja jb jc jd je jf jg cl"><span id="0c02" class="jh ig ex at iz b ga ji jj r jk">$ graalpython --inspect fizzbuzz.py</span></pre><figure class="ja jb jc jd je eh dm dn paragraph-image"><pre class="ja jb jc jd je jf jg cl"><span id="5852" class="jh ig ex at iz b ga ji jj r jk">$ ruby --inspect fizzbuzz.rb</span></pre><figure class="ja jb jc jd je eh dm dn paragraph-image"><pre class="ja jb jc jd je jf jg cl"><span id="bb1b" class="jh ig ex at iz b ga ji jj r jk">$ Rscript --inspect fizzbuzz.r</span></pre><figure class="ja jb jc jd je eh dm dn paragraph-image"><p id="d775" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">Another tool that you may be familiar with using already from Java is VisualVM. It gives you a user interface which you can connect to a running JVM on your machine or somewhere over a network to inspect various aspects such as how it is using memory and threads.</p><p id="f094" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">GraalVM includes VisualVM with the standard <code class="ep iw ix iy iz b">jvisualvm</code> command.</p><pre class="ja jb jc jd je jf jg cl"><span id="8cf1" class="jh ig ex at iz b ga ji jj r jk">$ jvisualvm &amp;&gt; /dev/null &amp;</span></pre><p id="b490" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">If we run it while we run our Java <code class="ep iw ix iy iz b">TopTen</code> application from before, we can watch the memory use over time, or we can do something like take a heap dump and inspect what kind of objects we have using memory in our heap.</p><pre class="ja jb jc jd je jf jg cl"><span id="84f0" class="jh ig ex at iz b ga ji jj r jk">$ java TopTen large.txt</span></pre><figure class="ja jb jc jd je eh dm dn paragraph-image"><p id="5b04" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">I’ve written this Ruby program to generate some garbage over time.</p><figure class="ja jb jc jd je eh"><p id="bfd9" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">If you run a standard JVM language, like JRuby, with VisualVM you’ll be disappointed in that you’ll see the underlying Java objects, rather than any information about your language’s objects.</p><p id="c532" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">If we use the GraalVM version of Ruby instead, VisualVM will recognise the Ruby objects themselves. We need to use the <code class="ep iw ix iy iz b">--jvm</code> command to use VisualVM, as it doesn't support the native version of Ruby.</p><pre class="ja jb jc jd je jf jg cl"><span id="1b03" class="jh ig ex at iz b ga ji jj r jk">$ ruby --jvm render.rb</span></pre><p id="4935" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We can see the same heap view dump of underlying Java objects if we want to, or under <em class="hs">Summary</em> we can select <em class="hs">Ruby Heap</em> and see proper Ruby objects instead.</p><figure class="ja jb jc jd je eh dm dn paragraph-image"><p id="5f89" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">The Truffle framework is a <a href="http://programming-journal.org/2018/2/14/" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">kind of nexus for languages and tools</a>. If you program your languages using Truffle, and you program your tools like this debugger against Truffle’s tool API, then each tool works with each language, and you only have to write the tool once.</p><p id="20eb" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">So the fifth way that you can use GraalVM is as a platform to get high quality tooling for languages which don’t always have the support behind them to build bespoke tools like the Chrome Debugger or VisualVM.</p><h1 id="2115" class="if ig ex at as ih ez ii fb ij ik il im in io ip iq">6. Extend a JVM-based application</h1><p id="afb6" class="he hf ex at hg b hh ir hj is hl it hn iu hp iv hr dv">As well as being usable as standalone language implementations, and together in a polyglot use case, these languages and tools can also be embedded in your Java application. A new <code class="ep iw ix iy iz b">org.graalvm.polyglot</code> API lets you load and run code in other languages and to use values from them.</p><figure class="ja jb jc jd je eh"><p id="19be" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">If you use the <code class="ep iw ix iy iz b">javac</code> and <code class="ep iw ix iy iz b">java</code> commands from GraalVM, the imports <code class="ep iw ix iy iz b">org.graalvm...</code> will already be on your classpath, so you can compile and run this without any extra flags.</p><pre class="ja jb jc jd je jf jg cl"><span id="3b08" class="jh ig ex at iz b ga ji jj r jk">$ javac ExtendJava.java<br>$ java ExtendJava '14 + 2'<br>16<br>$ java ExtendJava -js 'Math.sqrt(14)'<br>3.7416573867739413<br>$ java ExtendJava -python '[2**n for n in range(0, 8)]'<br>[1, 2, 4, 8, 16, 32, 64, 128]<br>$ java ExtendJava -ruby '[4, 2, 3].sort'<br>[2, 3, 4]</span></pre><p id="c6c6" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">These versions of the languages are the same high-performance polyglot versions that you get from using the commands like <code class="ep iw ix iy iz b">node</code> and <code class="ep iw ix iy iz b">ruby</code> as the GraalVM executables.</p><p id="55b2" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">This is a sixth way you can use GraalVM — as a single interface to embed many different languages in your Java application. The polyglot API allows you to take guest language objects and use them as Java interfaces and other sophisticated interoperability.</p><h1 id="7efc" class="if ig ex at as ih ez ii fb ij ik il im in io ip iq">7. Extend a native application</h1><p id="4031" class="he hf ex at hg b hh ir hj is hl it hn iu hp iv hr dv">GraalVM already includes one native library built like this — it’s a library that lets you run code written in any GraalVM language from native applications. JavaScript runtimes like V8, and Python interpreters like CPython, are often embeddable meaning that they can be linked as a library into another application. GraalVM lets you use any language in an embedded context, by linking to this one polyglot embedding library.</p><p id="191b" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">The library is already built when you get GraalVM, but by default it only includes the builtin language JavaScript. You can rebuild the polyglot library to include other languages using the command below, but you’ll need to download Oracle GraalVM Enterprise Edition Native Image Early Adopter based on JDK8 for MacOS (19.3.0) from <a href="https://www.oracle.com/downloads/graalvm-downloads.html" class="da by ht hu hv hw" target="_blank" rel="noopener nofollow">OTN</a>. Rebuilding does take a few minutes, so you may want to just experiment with JavaScript if you’re following along — you don’t need to rebuild if you just want JavaScript.</p><pre class="ja jb jc jd je jf jg cl"><span id="b7cb" class="jh ig ex at iz b ga ji jj r jk">$ gu install --force --file native-image-installable-svm-svmee-java8-darwin-amd64-19.3.0.jar<br>$ gu rebuild-images libpolyglot</span></pre><p id="b4e5" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We can write a simple C program that runs commands in any GraalVM language passed on the command line. We’re going to be doing the equivalent of our <code class="ep iw ix iy iz b">ExtendJava</code> example from above, but with C as the host language.</p><figure class="ja jb jc jd je eh"><p id="9e8b" class="he hf ex at hg b hh hi hj hk hl hm hn ho hp hq hr dv">We can then compile and run that using our system C compiler and link to the native polyglot library in GraalVM. Again, it doesn’t need a JVM.</p><pre class="ja jb jc jd je jf jg cl"><span id="90f0" class="jh ig ex at iz b ga ji jj r jk">$ clang -L$GRAALVM_HOME/jre/lib/polyglot -I${GRAALVM_HOME}/jre/lib/polyglot -lpolyglot -o extendc -O1 extendc.c -rpath $GRAALVM_HOME<br>$ otool -L extendc<br>extendc:<br>@rpath/jre/lib/polyglot/libpolyglot.dylib (compatibility version       0.0.0, current version 0.0.0)<br>/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.250.1)</span></pre></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>