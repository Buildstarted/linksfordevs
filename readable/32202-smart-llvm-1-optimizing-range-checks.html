<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Smart LLVM #1: Optimizing range checks -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Smart LLVM #1: Optimizing range checks</h1><div><div class="post-content"><p>Sometimes I explore LLVM sources and play with godbolt.org in order to find some interesting optimizations (not only the peephole ones) so I think I’ll post some here in my blog from time to time. Also, if an optimization is simple enough I try to implement it in RuyJIT, e.g.:</p><p>Today I am going to share a nice LLVM trick to optimize some common range checks.<br>So, let’s say we have a function that checks if a char belongs to a list of reserved chars:<br>(I actually copy-pasted it from CoreFX)</p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="kt">bool</span><span class="nf">IsReservedCharacter</span><span class="p">(</span><span class="kt">char</span><span class="n">character</span><span class="p">)</span><span class="c1">// uint16_t</span><span class="p">{</span><span class="k">return</span><span class="n">character</span><span class="p">==</span><span class="sc">';'</span><span class="p">||</span><span class="n">character</span><span class="p">==</span><span class="sc">'/'</span><span class="p">||</span><span class="n">character</span><span class="p">==</span><span class="sc">':'</span><span class="p">||</span><span class="n">character</span><span class="p">==</span><span class="sc">'@'</span><span class="p">||</span><span class="n">character</span><span class="p">==</span><span class="sc">'&amp;'</span><span class="p">||</span><span class="n">character</span><span class="p">==</span><span class="sc">'='</span><span class="p">||</span><span class="n">character</span><span class="p">==</span><span class="sc">'+'</span><span class="p">||</span><span class="n">character</span><span class="p">==</span><span class="sc">'$'</span><span class="p">||</span><span class="n">character</span><span class="p">==</span><span class="sc">','</span><span class="p">;</span><span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure><p>Now let’s compare outputs for RuyJIT and LLVM:
</p><figure class="alignleft"><figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="c">; C# RuyJIT</span><span class="k">movzx</span><span class="n">rax</span><span class="p">,</span><span class="n">cx</span><span class="k">cmp</span><span class="n">eax</span><span class="p">,</span><span class="mi">59</span><span class="k">je</span><span class="n">SHORT</span><span class="n">G_IG04</span><span class="k">cmp</span><span class="n">eax</span><span class="p">,</span><span class="mi">47</span><span class="k">je</span><span class="n">SHORT</span><span class="n">G_IG04</span><span class="k">cmp</span><span class="n">eax</span><span class="p">,</span><span class="mi">58</span><span class="k">je</span><span class="n">SHORT</span><span class="n">G_IG04</span><span class="k">cmp</span><span class="n">eax</span><span class="p">,</span><span class="mi">64</span><span class="k">je</span><span class="n">SHORT</span><span class="n">G_IG04</span><span class="k">cmp</span><span class="n">eax</span><span class="p">,</span><span class="mi">38</span><span class="k">je</span><span class="n">SHORT</span><span class="n">G_IG04</span><span class="k">cmp</span><span class="n">eax</span><span class="p">,</span><span class="mi">61</span><span class="k">je</span><span class="n">SHORT</span><span class="n">G_IG04</span><span class="k">cmp</span><span class="n">eax</span><span class="p">,</span><span class="mi">43</span><span class="k">je</span><span class="n">SHORT</span><span class="n">G_IG04</span><span class="k">cmp</span><span class="n">eax</span><span class="p">,</span><span class="mi">36</span><span class="k">je</span><span class="n">SHORT</span><span class="n">G_IG04</span><span class="k">cmp</span><span class="n">eax</span><span class="p">,</span><span class="mi">44</span><span class="k">sete</span><span class="n">al</span><span class="k">movzx</span><span class="n">rax</span><span class="p">,</span><span class="n">al</span><span class="n">G_IG03</span><span class="o">:</span><span class="k">ret</span><span class="n">G_IG04</span><span class="o">:</span><span class="k">mov</span><span class="n">eax</span><span class="p">,</span><span class="mi">1</span><span class="n">G_IG05</span><span class="o">:</span><span class="k">ret</span></pre></td></tr></tbody></table></code></pre></figure></figure><figure class="alignleft"><figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="c">; LLVM</span><span class="k">add</span><span class="n">edi</span><span class="p">,</span><span class="o">-</span><span class="mi">36</span><span class="k">cmp</span><span class="n">di</span><span class="p">,</span><span class="mi">28</span><span class="k">ja</span><span class="p">.</span><span class="n">LBB0_2</span><span class="k">mov</span><span class="n">al</span><span class="p">,</span><span class="mi">1</span><span class="k">movzx</span><span class="n">ecx</span><span class="p">,</span><span class="n">di</span><span class="k">mov</span><span class="n">edx</span><span class="p">,</span><span class="mi">314575237</span><span class="k">bt</span><span class="n">rdx</span><span class="p">,</span><span class="n">rcx</span><span class="k">jae</span><span class="p">.</span><span class="n">LBB0_2</span><span class="k">ret</span><span class="p">.</span><span class="n">LBB0_2</span><span class="o">:</span><span class="k">xor</span><span class="n">eax</span><span class="p">,</span><span class="n">eax</span><span class="k">ret</span></pre></td></tr></tbody></table></code></pre></figure></figure><figure class="aligncenter"></figure><p>As you can see C# generated a pretty simple set of 9 cmp + jumps for each logical OR. LLVM, at the same time, generated something strange with magic numbers and just two branches. Let’s try to convert (disassemble) LLVM’s output to C#:</p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="kt">bool</span><span class="nf">IsReservedCharacter</span><span class="p">(</span><span class="kt">char</span><span class="n">c</span><span class="p">)</span><span class="p">{</span><span class="n">c</span><span class="p">=</span><span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="n">c</span><span class="p">-</span><span class="m">36</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="p">&gt;</span><span class="m">28</span><span class="p">)</span><span class="k">return</span><span class="k">false</span><span class="p">;</span><span class="k">return</span><span class="p">((</span><span class="m">314575237</span><span class="p">&gt;&gt;</span><span class="n">c</span><span class="p">)</span><span class="p">&amp;</span><span class="m">1</span><span class="p">)</span><span class="p">==</span><span class="m">1</span><span class="p">;</span><span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure><p>so insted of 9 cmp we have <code class="highlighter-rouge">add, cmp, shr, and</code>
Let me explain the magic constants.<br>First, we need to convert chars to their ASCII numbers:</p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="sc">';'</span><span class="sc">'/'</span><span class="sc">':'</span><span class="sc">'@'</span><span class="sc">'&amp;'</span><span class="sc">'='</span><span class="sc">'+'</span><span class="sc">'$'</span><span class="sc">','</span><span class="m">59</span><span class="m">47</span><span class="m">58</span><span class="m">64</span><span class="m">38</span><span class="m">61</span><span class="m">43</span><span class="m">36</span><span class="m">44</span></pre></td></tr></tbody></table></code></pre></figure><p>The biggest is <code class="highlighter-rouge">@</code> (64) and the smallest is <code class="highlighter-rouge">$</code> (36). So, the range starts from 36 and the length is <code class="highlighter-rouge">64 - 36 = 28</code>. Thus the first <code class="highlighter-rouge">if</code> simply ignores all values outside of <code class="highlighter-rouge">[36..64]</code> range. Here is how I explained the first two magic numbers. Now it’s <code class="highlighter-rouge">314575237</code>s turn:</p><p>Since the range is known and the length is 28 which easily fits into a 32/64bit CPU register we can encode it to a special bit-map (a set of 0 and 1) - a 32/64 bit integer (depending on a platform).
Here is how it’s done:</p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="kt">long</span><span class="n">bitmap</span><span class="p">=</span><span class="m">0</span><span class="p">;</span><span class="k">foreach</span><span class="p">(</span><span class="kt">char</span><span class="n">c</span><span class="k">in</span><span class="k">new</span><span class="p">[]</span><span class="p">{</span><span class="sc">';'</span><span class="p">,</span><span class="sc">'/'</span><span class="p">,</span><span class="sc">':'</span><span class="p">,</span><span class="sc">'@'</span><span class="p">,</span><span class="sc">'&amp;'</span><span class="p">,</span><span class="sc">'='</span><span class="p">,</span><span class="sc">'+'</span><span class="p">,</span><span class="sc">'$'</span><span class="p">,</span><span class="sc">','</span><span class="p">})</span><span class="n">bitmap</span><span class="p">|=</span><span class="m">1L</span><span class="p">&lt;&lt;</span><span class="n">c</span><span class="p">-</span><span class="m">36</span><span class="p">;</span></pre></td></tr></tbody></table></code></pre></figure><p>So, for each char we push (shift) <code class="highlighter-rouge">1</code> to the left according to <code class="highlighter-rouge">c - 36</code> value (as you remember 36 stands for <code class="highlighter-rouge">$</code> so its index will be zero - on the right)<br>and our bitmap becomes:</p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="m">00010010110000000000100110000101</span><span class="p">=</span><span class="m">314575237</span><span class="p">|</span><span class="p">|</span><span class="p">||</span><span class="p">|</span><span class="p">||</span><span class="p">|</span><span class="p">|</span><span class="err">@</span><span class="p">=</span><span class="p">;:</span><span class="p">/</span><span class="p">,+</span><span class="p">&amp;</span><span class="err">$</span></pre></td></tr></tbody></table></code></pre></figure><p>Now when we do <code class="highlighter-rouge">314575237 &gt;&gt; (c - 36)</code> we either get <code class="highlighter-rouge">1</code> (symbol is one of the reserved) or <code class="highlighter-rouge">0</code> (doesn’t belong to the set)</p><p>Let’s benchmark it! I have a random string here and I need to calculate how many symbols are reserved:</p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="kt">string</span><span class="n">str</span><span class="p">=</span><span class="s">"Some link https://github.com/dotnet/coreclr/issues/12477, some@mail.com."</span><span class="p">;</span><span class="kt">int</span><span class="n">count</span><span class="p">=</span><span class="m">0</span><span class="p">;</span><span class="k">foreach</span><span class="p">(</span><span class="kt">char</span><span class="n">c</span><span class="k">in</span><span class="n">str</span><span class="p">)</span><span class="k">if</span><span class="p">(</span><span class="nf">IsReservedCharacter</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="n">count</span><span class="p">++;</span></pre></td></tr></tbody></table></code></pre></figure><p>The results are:</p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="p">|</span><span class="n">Method</span><span class="p">|</span><span class="n">Mean</span><span class="p">|</span><span class="n">Ratio</span><span class="p">|</span><span class="p">|----------------------------</span><span class="p">|----------:|------:|</span><span class="p">|</span><span class="n">CountReserverCharacters_old</span><span class="p">|</span><span class="m">197.6</span><span class="n">ns</span><span class="p">|</span><span class="m">1.43</span><span class="p">|</span><span class="p">|</span><span class="n">CountReserverCharacters_new</span><span class="p">|</span><span class="m">138.4</span><span class="n">ns</span><span class="p">|</span><span class="m">1.00</span><span class="p">|</span></pre></td></tr></tbody></table></code></pre></figure><p>The improved version is <strong>43%</strong> faster! (Core i7 8700K)</p><p>Feature request for RuyJIT <a href="https://github.com/dotnet/coreclr/issues/12477">dotnet/coreclr#12477</a></p><p>LLVM opt: <a href="https://godbolt.org/z/2B-00V">godbolt.org</a> (convert to switch)<br>LLVM llc: <a href="https://godbolt.org/z/JSBhgh">godbolt.org</a> (DAG*)</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>