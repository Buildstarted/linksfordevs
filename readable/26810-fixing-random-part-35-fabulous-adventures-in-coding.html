<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Fixing Random, part 35 | Fabulous adventures in coding -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Fixing Random, part 35 | Fabulous adventures in coding</h1><div><div class="entry-content"><p><a href="https://ericlippert.com/2019/06/10/fixing-random-part-34/">Last time on FAIC</a> we deduced the idea behind the “importance sampling” technique for determining the average value of a function from double to double — call it&nbsp;&nbsp;<code>f</code>&nbsp;— when it is applied to samples from a possibly-non-normalized weighted distribution of doubles — call it&nbsp;<code>p</code>.</p><p>Just for fun, I’m going to do the derivation all over again. I’ll again be using the technique “things equal to the same are equal to each other”, but this time we’re going to start from the other end. Let’s jump right in!</p><p>Again, for pedagogical purposes I’m going to consider only distributions with support from 0.0 to 1.0; we’ll eliminate that restriction when we can.</p><p>We discovered a while back that the expected value of <code>f</code>&nbsp;applied to samples of <code>p</code>is equal to the quotient of&nbsp;<code>Area(x =&gt; f(x) * p.Weight(x)</code>&nbsp;divided by ​​<code>Area(x =&gt; p.Weight(x))</code>. The latter term is the normalization constant for <code>p</code>, which we might not know.</p><p>Let’s take any weighted distribution <code>q</code>&nbsp;also with support from 0.0 to 1.0; it also might not be normalized.</p><p>We’re now going to do some manipulations to our expression that are obviously identities. We’ll start with the fact that</p><p><code>Area(x =&gt; f(x) * p.Weight(x))</code></p><p>obviously must be equal to:</p><p><code>Area(x =&gt; (f(x) * p.Weight(x) / q.Weight(x)) * q.Weight(x))</code></p><p>We’ve just divided and multiplied by the same quantity, so that is no change. And we’ve assumed that <code>q</code>&nbsp;has the same support as <code>p</code>, so the weight we’re dividing by is always non-zero.</p><p>Similarly,</p><p><code>Area(p.Weight)</code></p><p>must be equal to</p><p><code>(Area(q.Weight) * (Area(p.Weight) / Area(q.Weight)))</code></p><p>for the same reason.</p><p>So the quotient of these two quantities must also be equal to the expected value of <code>f</code>&nbsp;applied to samples from <code>p</code>; they’re the same quantities! Our original expression</p><p><code>Area(x =&gt; f(x) * p.Weight(x) /<br></code><code></code><code>&nbsp;Area(x =&gt; p.Weight(x))</code></p><p>is equal to:</p><pre><code>Area(x =&gt; (f(x) * p.Weight(x) / q.Weight(x)) * q.Weight(x)) /&nbsp;
&nbsp;&nbsp;(Area(q.Weight)&nbsp;* (Area(p.Weight)&nbsp;/&nbsp;Area(q.Weight)</code>))</pre><p>For any suitable <code>q</code>.</p><p>Let’s call that value <code>exp_fp</code>&nbsp;for “expected value of <code>f</code> on samples of <code>p</code>“. We’ve just written that value in two ways, one very straightforward, and one excessively complicated.</p><p>Unsurprisingly, my next question is: what is the expected value of function <code>g</code></p><p><code>x =&gt; f(x) * p.Weight(x) / q.Weight(x)</code></p><p>over samples from <code>q</code>?</p><p>We know that it is estimated by this quotient of areas:</p><p><code>Area(x =&gt; g(x) * q.Weight(x)) /<br>Area(q.Weight)</code></p><p>The denominator is the normalization constant of <code>q</code> which we might not know.</p><p>Call that value&nbsp;<code>exp_gq</code>, for “expected value of <code>g</code> on samples of <code>q</code>”</p><p><strong>What is the relationship between <code>exp_gq</code>&nbsp;and <code>exp_fp</code>?</strong></p><p>Well, just look at the two expressions carefully; plainly they differ by no more than a constant factor. <code>exp_fp</code>&nbsp;is equal to&nbsp;<code>exp_gq * Area(q.Weight) / Area(p.Weight)</code></p><p>And now we are right where we ended last time. Summing up:</p><ul><li>Once again, we have deduced that importance sampling works:
<ul><li><strong>An estimate of the expected value of <code>g</code> applied to samples from&nbsp;<code>q</code> is proportional to the expected value of <code>f</code>&nbsp;applied to samples from&nbsp;<code>p</code></strong></li><li>the proportionality constant is exactly the quotient of the normalization constants of <code>q</code>&nbsp;and <code>p</code></li><li>If <code>q</code> and <code>p</code> are known to be normalized, then that constant is 1.</li></ul></li><li>Once again, we can extend this result to <code>q</code>&nbsp;and <code>p</code>&nbsp;with any support
<ul><li>All we really need for an accurate estimate is that <code>q</code>&nbsp;have support in places where <code>f(x) * p.Weight(x)</code>&nbsp;has a lot of area.</li><li>But it is also nice if <code>q</code>&nbsp;has low weight in where that function has small area.</li></ul></li><li>Once again, we have two serious problems:
<ul><li>how do we find a good&nbsp;<code>q</code>?</li><li>we are required to know the normalization constants of both&nbsp;<code>p</code>&nbsp;and <code>q</code>, either of which might be hard to compute in general</li></ul></li><li>Once again, the previous statement contains a subtle error.
<ul><li>I’m so devious.</li><li>I asked what the error was in the previous episode as well, and there is already an answer in the comments to that episode, so beware of spoilers if you want to try to figure it out for yourself.</li></ul></li></ul><p>We are so close to success, but it seems to be just out of our grasp. It’s vexing!</p><hr><p><strong>Next time on FAIC:</strong> Amazingly, we’ll implement a version of this algorithm entirely based on sampling; we do not actually need to do the quadrature to compute the normalization factors!</p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><h3 class="jp-relatedposts-headline"><em>Related</em></h3></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>