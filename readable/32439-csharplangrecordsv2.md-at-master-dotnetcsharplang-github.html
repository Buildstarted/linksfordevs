<!DOCTYPE html>
<html lang="en">
<head>
    <title>
csharplang/recordsv2.md at master &#xB7; dotnet/csharplang &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>csharplang/recordsv2.md at master · dotnet/csharplang · GitHub</h1><div><div id="" class="markdown-body entry-content p-3 p-md-6"><h1><a id="user-content-records-v2" class="anchor" aria-hidden="true" href="#records-v2"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Records v2</h1><p>In the past we've thought about records as a feature to enable working with data.</p><p>"Working with data" is a big group with a number of facets, so it may be interesting to look at
each in isolation. Let's start by looking at an example of records today and some of its drawbacks.</p><p>For instance, a simple record would be defined today as follows</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">UserInfo</span>
{
    <span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-smi">Username</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-smi">Email</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-smi">IsAdmin</span>  { <span class="pl-k">get</span>; <span class="pl-k">set</span>; } <span class="pl-k">=</span><span class="pl-c1">false</span>;
}</pre></div><p>and the usage would read</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">void</span><span class="pl-en">M</span>()
{
    <span class="pl-k">var</span><span class="pl-smi">userInfo</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">UserInfo</span>() 
    {
        <span class="pl-smi">Username</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>andy<span class="pl-pds">"</span></span>,
        <span class="pl-smi">Email</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>angocke@microsoft.com<span class="pl-pds">"</span></span>,
        <span class="pl-smi">IsAdmin</span><span class="pl-k">=</span><span class="pl-c1">true</span>
    };
}</pre></div><p>There are significant advantages in this code:</p><ol><li>The definition is version resilient, properties can easily be added or moved</li><li>Properties can be set in any order, and the names in the initialization always
match the accessors</li><li>Properties with default values can simply be skipped</li></ol><p>The first flaw is that the properties must now be mutable.</p><h1><a id="user-content-mutability" class="anchor" aria-hidden="true" href="#mutability"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutability</h1><p>What we'd like is for C# to provide a way to set a <code>readonly</code> member in object initializers.
Since some types may not have been designed with this initialization in mind, we'd also like
it to be opt-in.</p><p>The proposed solution is a new modifier, <code>initonly</code>, that can be applied to
properties and fields:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">UserInfo</span>
{
    <span class="pl-k">public</span> initonly <span class="pl-k">string</span><span class="pl-smi">Username</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span> initonly <span class="pl-k">string</span><span class="pl-smi">Email</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span> initonly <span class="pl-k">bool</span><span class="pl-smi">IsAdmin</span> { <span class="pl-k">get</span>; } <span class="pl-k">=</span><span class="pl-c1">false</span>;
}</pre></div><p>The codegen for this is surprisingly straight forward: we just set the readonly field.
Specifically, the lowered properties would look like:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">UserInfo</span>
{
    <span class="pl-k">private</span><span class="pl-k">readonly</span> string &lt;Backing&gt;_username;
    <span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-en">get_Username</span>() <span class="pl-k">=&gt;</span><span class="pl-k">&lt;</span><span class="pl-smi">Backing</span><span class="pl-k">&gt;</span><span class="pl-smi">_username</span>;
    [<span class="pl-k">return</span>: <span class="pl-en">modreq</span>(<span class="pl-smi">initonly</span>)]
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">set_Username</span>(<span class="pl-k">string</span><span class="pl-smi">value</span>) { <span class="pl-k">&lt;</span><span class="pl-smi">Backing</span><span class="pl-k">&gt;</span><span class="pl-smi">_username</span><span class="pl-k">=</span><span class="pl-smi">value</span>; }
    ...
}</pre></div><p>The CLR considers setting readonly fields to be unverifiable, but not unsafe. To support
a more advanced verifier, the following rule is proposed: a readonly field can be modified
only inside <code>initonly</code> methods, or on a new object that is on the CLR stack and has not been
published via a store or method call.</p><p>This should solve many of the problems with mutability in the <code>UserInfo</code> example, while not
requiring complicated or brittle emit strategies. However, immutability does present a new
problem: easily constructing an object with changes.</p><h1><a id="user-content-with-ing" class="anchor" aria-hidden="true" href="#with-ing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>With-ing</h1><p>When programming with immutability, making changes to an object is done by constructing a
copy with changes instead of making the changes directly on the object. Unfortunately, there's
no convenient way to do this in C#, even with current-style records. It's been previously
proposed that some kind of autogenerated "With" method be provided for records that implements
that functionality. If we have such a mechanism, it's important that it work with <code>initonly</code>
members. To achieve this, it's proposed that we add a <code>with</code> expression, analogous to an object
initializer. Sample usage would be as follows:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span><span class="pl-smi">userInfo</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">UserInfo</span>() 
{
    <span class="pl-smi">Username</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>andy<span class="pl-pds">"</span></span>,
    <span class="pl-smi">Email</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>angocke@microsoft.com<span class="pl-pds">"</span></span>,
    <span class="pl-smi">IsAdmin</span><span class="pl-k">=</span><span class="pl-c1">true</span>
};
<span class="pl-k">var</span><span class="pl-smi">newUserName</span><span class="pl-k">=</span><span class="pl-smi">userInfo</span><span class="pl-smi">with</span> { <span class="pl-smi">Username</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>angocke<span class="pl-pds">"</span></span> };</pre></div><p>The resulting <code>newUserName</code> object would be a copy of <code>userInfo</code>, with <code>Username</code> set to "angocke".
The codegen on the <code>with</code> expression would also be similar to the object initializer: a new object
is constructed, and then the <code>initonly</code><code>Username</code> setter would be called in the method body.</p><p>Of course, the difference here is that the new object being constructed is not a simple new object
creation, it is a duplicate of the original object. To provide this functionality, we require that
the object provide a "With constructor" that provides a duplicate object. A sample <code>With</code> constructor
would look like:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span><span class="pl-en">UserInfo</span>
{
    ...
    [<span class="pl-en">WithConstructor</span>] <span class="pl-c"><span class="pl-c">//</span> placeholder syntax, up for debate</span><span class="pl-k">public</span><span class="pl-en">UserInfo</span><span class="pl-en">With</span>()
    {
        <span class="pl-k">return</span><span class="pl-k">new</span><span class="pl-en">UserInfo</span>() { <span class="pl-smi">Username</span><span class="pl-k">=</span><span class="pl-k">this</span>.<span class="pl-smi">Username</span>, <span class="pl-smi">Email</span><span class="pl-k">=</span><span class="pl-k">this</span>.<span class="pl-smi">Email</span>, <span class="pl-smi">IsAdmin</span><span class="pl-k">=</span><span class="pl-k">this</span>.<span class="pl-smi">IsAdmin</span> };
    }
}</pre></div><p>Notably, the <code>with</code> expression will set <code>initonly</code> members, just like the object initializer, so to
support verification we must ensure that the object cannot have been published before the <code>initonly</code>
members are set. To enforce this, the <code>WithConstructor</code> attribute (or equivalent syntax) will enforce
a new rule for the method: all return statements must directly contain an object creation expression,
possibly with an object initializer.</p><p>If the <code>With</code> constructor requires validation, the user may introduce a constructor to do that validation,
e.g.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span><span class="pl-en">UserInfo</span>
{
    ...
    <span class="pl-k">private</span><span class="pl-en">UserInfo</span>(<span class="pl-en">UserInfo</span><span class="pl-smi">original</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> validation code</span>
    }
    [<span class="pl-en">WithConstructor</span>]
    <span class="pl-k">public</span><span class="pl-en">UserInfo</span><span class="pl-en">With</span>() <span class="pl-k">=&gt;</span><span class="pl-k">new</span><span class="pl-en">UserInfo</span>(<span class="pl-k">this</span>);
}</pre></div><p>The last piece of complexity associated with <code>With</code> is inheritance. If your record is extensible, you
will need to provide a new <code>With</code> for the subclass. This can be achieved as follows:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span><span class="pl-en">Base</span>
{
    ...
    <span class="pl-k">protected</span><span class="pl-en">Base</span>(<span class="pl-en">Base</span><span class="pl-smi">original</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> validation</span>
    }
    [<span class="pl-en">WithConstructor</span>]
    <span class="pl-k">public</span><span class="pl-k">virtual</span><span class="pl-en">Base</span><span class="pl-en">With</span>() <span class="pl-k">=&gt;</span><span class="pl-k">new</span><span class="pl-en">Base</span>(<span class="pl-k">this</span>);
}
<span class="pl-k">class</span><span class="pl-en">Derived</span> : <span class="pl-en">Base</span>
{
    ...
    <span class="pl-k">protected</span><span class="pl-en">Derived</span>(<span class="pl-en">Derived</span><span class="pl-smi">original</span>)
    : <span class="pl-k">base</span>(<span class="pl-smi">original</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> validation</span>
    }
    [<span class="pl-en">WithConstructor</span>]
    <span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-en">Derived</span><span class="pl-en">With</span>() <span class="pl-k">=&gt;</span><span class="pl-k">new</span><span class="pl-en">Derived</span>(<span class="pl-k">this</span>);
}</pre></div><p>Note one additional piece of complexity here: in order to override the <code>With</code> constructor with
the derived type the language will also need to support covariant return types in overrides.
There is already a separate proposal for this feature
<a href="https://github.com/dotnet/csharplang/blob/725763343ad44a9251b03814e6897d87fe553769/proposals/covariant-returns.md">here</a>.</p><p><strong>Drawbacks</strong></p><ul><li>Making all return statements in <code>WithConstructor</code>s contain new object expressions is restrictive.
This could be possibly be mitigated by flow analysis that ensures the new object doesn't escape
the method</li><li>Supporting variance in overrides through compiler tricks will require stub methods, which will
grow quadratically with the inheritance depth. The need for a stub method is due to a runtime
requirement that override signatures match exactly. If the runtime requirement were loosened,
the stub methods would not be required at all.</li><li>Using chained constructors of the form <code>Type(Type original)</code> effectively reserves that constructor
for the use of the pattern. Since constructors have unique semantics and cannot be re-named this
could be limiting.</li></ul><h2><a id="user-content-wrapping-it-all-up-records" class="anchor" aria-hidden="true" href="#wrapping-it-all-up-records"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Wrapping it all up: Records</h2><p>The above features enable a style of programming that was very difficult before. But even with
the new features it could be quite verbose and error prone to annotate everything yourself. There
are also a few items, like Equals and GetHashCode, which can already be written today, it's just laborious.
Moreover, a significant flaw in implementing equality on top of these new primitives is that
structural equality is something that should change with your data type as new data is added, but
when handling it manually it is likely that these things can get out of sync.</p><p>Therefore, it is proposed that C# support new syntax for records, not for providing new features,
but for setting defaults and generating code designed for use in records. Example syntax would
look like</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">data</span><span class="pl-k">class</span><span class="pl-en">UserInfo</span>
{
    <span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-smi">Username</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-smi">Email</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-smi">IsAdmin</span> { <span class="pl-k">get</span>; } <span class="pl-k">=</span><span class="pl-c1">false</span>;
}</pre></div><p>The generated code for this class would regard all public fields and auto-properties as structural
members of the record. Record members could be customized using a new <code>RecordMember(bool)</code> attribute
that could be used to either include or exclude members. Record members would be <code>initonly</code> by default
and equality would be autogenerated for the class based on the record members. At any point the behavior
of these members could be customized simply by declaring them in source. The user-written implementation
would replace the default implementation in all pattern usage.</p><p>Note that equality in the face of inheritance is complex, but seems to have been
adequately solved in the <a href="/dotnet/csharplang/blob/master/proposals/records.md">other records proposal</a>.</p><h2><a id="user-content-primary-constructors" class="anchor" aria-hidden="true" href="#primary-constructors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Primary constructors</h2><p>Previous record proposal have also included a new syntax for a parameter list on the type itself, e.g.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span><span class="pl-en">Point</span>(int X, int Y);</pre></div><p>In the new design, the parameter list would be an orthogonal C# feature, which could be cleanly integrated
with records. If a primary constructor is included in a record, it would have new defaults, just like
public fields and auto-properties: the parameters in the primary constructor would be used to generate
public record-member properties with the same name. In addition, the primary constructor could now be
used to auto-generate a deconstructor.</p><p>For example, the following record with a primary constructor</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">data</span><span class="pl-k">class</span><span class="pl-en">Point</span>(int X, int Y);</pre></div><p>would be equivalent to</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">data</span><span class="pl-k">class</span><span class="pl-en">Point</span>
{
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-smi">X</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-smi">Y</span> { <span class="pl-k">get</span>; }

    <span class="pl-k">public</span><span class="pl-en">Point</span>(<span class="pl-k">int</span><span class="pl-smi">x</span>, <span class="pl-k">int</span><span class="pl-smi">y</span>)
    {
        <span class="pl-smi">X</span><span class="pl-k">=</span><span class="pl-smi">x</span>;
        <span class="pl-smi">Y</span><span class="pl-k">=</span><span class="pl-smi">y</span>;
    }

    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Deconstruct</span>(<span class="pl-k">out</span><span class="pl-k">int</span><span class="pl-smi">X</span>, <span class="pl-k">out</span><span class="pl-k">int</span><span class="pl-smi">Y</span>)
    {
        <span class="pl-smi">X</span><span class="pl-k">=</span><span class="pl-k">this</span>.<span class="pl-smi">X</span>;
        <span class="pl-smi">Y</span><span class="pl-k">=</span><span class="pl-k">this</span>.<span class="pl-smi">Y</span>;
    }
}</pre></div><p>and the final generation of the above would be</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span><span class="pl-en">Point</span>
{
    <span class="pl-k">public</span> initonly <span class="pl-k">int</span><span class="pl-smi">X</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span> initonly <span class="pl-k">int</span><span class="pl-smi">Y</span> { <span class="pl-k">get</span>; }

    <span class="pl-k">public</span><span class="pl-en">Point</span>(<span class="pl-k">int</span><span class="pl-smi">x</span>, <span class="pl-k">int</span><span class="pl-smi">y</span>)
    {
        <span class="pl-smi">X</span><span class="pl-k">=</span><span class="pl-smi">x</span>;
        <span class="pl-smi">Y</span><span class="pl-k">=</span><span class="pl-smi">y</span>;
    }

    <span class="pl-k">protected</span><span class="pl-en">Point</span>(<span class="pl-en">Point</span><span class="pl-smi">other</span>)
    : <span class="pl-k">this</span>(<span class="pl-smi">other</span>.<span class="pl-smi">X</span>, <span class="pl-smi">other</span>.<span class="pl-smi">Y</span>)
    { }

    [<span class="pl-en">WithConstructor</span>]
    <span class="pl-k">public</span><span class="pl-k">virtual</span><span class="pl-en">Point</span><span class="pl-en">With</span>() <span class="pl-k">=&gt;</span><span class="pl-k">new</span><span class="pl-en">Point</span>(<span class="pl-k">this</span>);

    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Deconstruct</span>(<span class="pl-k">out</span><span class="pl-k">int</span><span class="pl-smi">X</span>, <span class="pl-k">out</span><span class="pl-k">int</span><span class="pl-smi">Y</span>)
    {
        <span class="pl-smi">X</span><span class="pl-k">=</span><span class="pl-k">this</span>.<span class="pl-smi">X</span>;
        <span class="pl-smi">Y</span><span class="pl-k">=</span><span class="pl-k">this</span>.<span class="pl-smi">Y</span>;
    }

    <span class="pl-c"><span class="pl-c">//</span> Generated equality</span>
}</pre></div><p>Note that we've taken one other piece of information into account
for a data class with a primary constructor: instead of setting
the primary fields inside the generated protected constructor, we delegate
to the primary constructor. If the Point class had another non-primary
record member, e.g.</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">data</span><span class="pl-k">class</span><span class="pl-en">Point</span>(int X, int Y)
{
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-smi">Z</span> { <span class="pl-k">get</span>; }
}</pre></div><p>then that would change the generated protected constructor as follows:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span><span class="pl-en">Point</span>
{
    <span class="pl-c"><span class="pl-c">//</span> ...</span><span class="pl-k">protected</span><span class="pl-en">Point</span>(<span class="pl-en">Point</span><span class="pl-smi">other</span>)
    : <span class="pl-k">this</span>(<span class="pl-smi">other</span>.<span class="pl-smi">X</span>, <span class="pl-smi">other</span>.<span class="pl-smi">Y</span>)
    {
        <span class="pl-smi">Z</span><span class="pl-k">=</span><span class="pl-smi">other</span>.<span class="pl-smi">Z</span>;
    }
    <span class="pl-c"><span class="pl-c">//</span> ...</span>
}</pre></div><p>Notably, this doesn't answer what to do about inheritance of records
with primary constructors. For instance,</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">data</span><span class="pl-k">class</span><span class="pl-en">A</span>(int X, int Y);
data class B(int X, int Y, int Z) : <span class="pl-en">A</span>;</pre></div><p>Rather than resolving in an arbitrary manner, a more explicit approach
could require that a parameter list be provided with the base list, e.g.</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">data</span><span class="pl-k">class</span><span class="pl-en">A</span>(int X, int Y);
data class B(int X, int Y, int Z) : <span class="pl-en">A</span>(<span class="pl-en">X</span>, <span class="pl-en">Y</span>);</pre></div><p>The parameter list in the base list would then be applied to a <code>base</code> call
in the generated primary constructor:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span><span class="pl-en">B</span>
{
    <span class="pl-c"><span class="pl-c">//</span> ..</span><span class="pl-k">public</span><span class="pl-en">B</span>(<span class="pl-k">int</span><span class="pl-smi">x</span>, <span class="pl-k">int</span><span class="pl-smi">y</span>, <span class="pl-k">int</span><span class="pl-smi">z</span>)
    : <span class="pl-k">base</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>)
    // ..
}</pre></div><p>As for what a primary constructor could mean outside of a record, that is still open to further proposal.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>