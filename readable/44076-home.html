<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Home -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Home</h1>
    <div id="content" class="col-md-12"> <p><img src="/resources/me.jpg" class="headshot" alt="A headshot of me"></p> <p>William J. Bowman is an Assistant Professor of computer science in the Software
Practices Lab at University of British Columbia.
Broadly speaking, he is interested in making it easier for programmers to communicate their intent to
machines, and preserving that intent through compilation.
More specifically, his research interests include secure and verified compilation, dependently typed
programming, verification, meta-programming, and interoperability.
His recent work examines type-preserving compilation of dependently typed programming language like
Coq, a technique that can enable preserving security and correctness invariants of verified software
through compilation and statically enforcing those invariants in the low-level (assembly-like) code
generated by compilers.</p> <h2><a></a>Coordinates</h2> <ul> <li> <p class="SIntrapara">In Cyberspace:
</p> <div class="SIntrapara"> <table> <tbody> <tr> <td> <p>As a person or researcher:</p></td> <td> </td> <td> <p><span class="wjb">wjb</span></p></td></tr> <tr> <td> <p>As UBC faculty:</p></td> <td> </td> <td> <p><span class="ubc">wilbowma</span></p></td></tr></tbody></table></div></li> <li> <p>In Space:</p> <p>ICICS/CS Building Room 389</p> <p>201 Main Mall</p> <p>Vancouver, BC V6T 1Z4 Canada</p></li> <li> <p>In Time:
<a href="https://www.mail.ubc.ca/owa/calendar/b0faa3defdd84782877e7991f64e947d@cs.ubc.ca/7165080fec344798a6b8ca2347168a38805026380379205479/calendar.html">My Free/Busy Calendar</a></p></li></ul> <h2><a></a>Group</h2> <h2><a></a>Manuscripts</h2> <p><div class="paper" id="sized-coq"><span>Practical Sized Types for Coq</span>. Jonathan Chan and William J. Bowman 2019. <p> <div class="abstract" id="sized-coq-abstract">Termination of recursive functions and productivity of corecursive functions are important for maintaining logical consistency in proof assistants. However, contemporary proof assistants, such as Coq, rely on syntactic criteria that prevent users from easily writing obviously terminating or productive programs, such as quicksort. This is troublesome, since there exist theories for type-based termination- and productivity-checking. <p>
In this paper, we present a design and implementation of sized type checking and inference for Coq. We extend past work on sized types for the Calculus of (Co)\-Inductive Constructions (CIC) with support for global definitions found in Gallina, and extend the sized-type inference algorithm to support completely unannotated Gallina terms. This allows our design to maintain complete backwards compatibility with existing Coq developments. We provide an implementation that extends the Coq kernel with optional support for sized types.</p></div><a class="show-abstract" href="#sized-coq" id="sized-coq-show">Abstract</a><a class="hide-abstract" href="#" id="sized-coq-hide">Abstract (Hide)</a> |
<a href="/tmp/wjb-sized-coq.pdf">Paper</a> |
<a href="/tmp/wjb-sized-coq-artifact.zip">Artifact</a> |
<a href="https://github.com/ionathanch/coq/tree/dev">GitHub</a> |
<a href="https://doi.org/10.5281/zenodo.3516516">DOI Archived Repo</a></p></div></p> <p><div class="paper" id="anf-sigma"><span>Compiling Dependent Types Without Continuations</span>. William J. Bowman and Amal Ahmed 2019. <p> <div class="abstract" id="anf-sigma-abstract">Programmers rely on dependently typed languages, such as Coq, to machine-verify
high-assurance software, but get no guarantees after compiling or when linking
after compilation.
We could provide guarantees after compiling and linking by building
<span>type-preserving compilers</span>, which preserve specifications encoded
in types and use type checking to verify code after compilation and to ensure
safety when linking with unverified code.
Unfortunately, standard type-preserving translations do not scale to dependently
typed languages for two key reasons: assumptions valid in simpler type systems
no longer hold, and checking dependent types relies strongly on the syntax
of programs, which compilers change. <p>
We extend the A-normal form (ANF) translation&#x2014; <wbr>a standard
translation for making control flow explicit&#x2014; <wbr>to the Extended Calculus of
Constructions (ECC), a representative subset of Coq.
We prove type preservation, and prove correctness of separate
compilation from ECC to an ANF-restricted ECC with a machine semantics.
This is the first ANF translation for dependent types and, unlike related
translations, supports the infinite universe hierarchy, and does so without
relying on parametricity or impredicativity.
Our work provides general insights into dependent-type-preservation and
combining effects with dependent types.</p></div><a class="show-abstract" href="#anf-sigma" id="anf-sigma-show">Abstract</a><a class="hide-abstract" href="#" id="anf-sigma-hide">Abstract (Hide)</a> |
Proofs incomplete, but draft available on request.</p></div></p> <h2><a></a>Conference Publications</h2> <p><div class="paper" id="depmacros"><span>Dependent Type Systems as Macros</span>. Stephen Chang, Michael Ballantyne, Milo Turner, William J. Bowman <p>
To appear In <span>Proc. of the Symposium on Principles of Programming
Languages (POPL 2020)</span>. </p><br> <span class="abstract" id="depmacros-abstract">We present Turnstile+, a high-level, macros-based metaDSL for building
dependently typed languages.
With it, programmers may rapidly prototype and iterate on the design of new
dependently typed features and extensions.
Or they may create entirely new DSLs whose dependent type &#x201C;power&#x201D; is tailored
to a specific domain.
Our framework&#x2019;s support of language-oriented programming also makes it suitable
for experimenting with systems of interacting components, e.g., a proof
assistant and its companion DSLs.
This paper explains the implementation details of Turnstile+, as well as how it
may be used to create a wide-variety of dependently typed languages, from a
lightweight one with indexed types, to a full spectrum proof assistant, complete
with a tactic system and extensions for features like sized types and SMT
interaction.</span><a class="show-abstract" href="#depmacros" id="depmacros-show">Abstract</a><a class="hide-abstract" href="#" id="depmacros-hide">Abstract (Hide)</a> |
<a href="/resources/wjb2019-depmacros.pdf">Paper</a> |
<a href="https://doi.org/10.5281/zenodo.3543711">Artifact</a> |
<a href="https://github.com/stchang/macrotypes/tree/popl2020-artifact">GitHub (Turnstile+)</a> |
<a href="https://www.github.com/wilbowma/cur">GitHub (Cur)</a></div></p> <p><div class="paper" id="cccc"><span>Typed Closure Conversion of the Calculus of Constructions</span>. William J. Bowman and Amal Ahmed <p>
In <span>Proc. of the Conference on Programming Language Implementation and
Design (PLDI 2018)</span>. </p><br> <div class="abstract" id="cccc-abstract">Dependently typed languages such as Coq are used to specify and verify the full functional
correctness of source programs.
Type-preserving compilation can be used to preserve these specifications and proofs of correctness
through compilation into the generated target-language programs.
Unfortunately, type-preserving compilation of dependent types is hard.
In essence, the problem is that dependent type systems are designed around high-level compositional abstractions
to decide type checking, but compilation interferes with the type-system rules for reasoning about
run-time terms. <p>
We develop a type-preserving closure-conversion translation from the Calculus of Constructions
(CC) with strong dependent pairs (&#x3A3; types)&#x2014; <wbr>a subset of the core language of Coq&#x2014; <wbr>to
a type-safe, dependently typed compiler intermediate language named CC-CC.
The central challenge in this work is how to translate the source type-system rules for reasoning about
functions into target type-system rules for reasoning about closures.
To justify these rules, we prove soundness of CC-CC by giving a model in CC.
In addition to type preservation, we prove correctness of separate compilation.</p></div><a class="show-abstract" href="#cccc" id="cccc-show">Abstract</a><a class="hide-abstract" href="#" id="cccc-hide">Abstract (Hide)</a> |
<a href="/resources/wjb-paper-cccc.pdf">Paper</a> |
<a href="/resources/wjb-tr-cccc.pdf">Technical Appendix</a> |
<a href="https://youtu.be/qcJP5DmMdxg">PLDI 2018 Talk (by me)</a> |
<a href="/resources/wjb-slides-pldi2018-cccc.pdf">Slides</a></div> <br></p> <p><div class="paper" id="cps-sigma"><span>Type-Preserving CPS Translation of &#x3A3; and &#x3A0; Types is Not Not Possible</span>. William J. Bowman, Youyou Cong, Nick Rioux, and Amal Ahmed <p>
In <span>Proc. of the Symposium on Principles of Programming Languages (POPL 2018)</span> </p><br> <div class="abstract" id="cps-sigma-abstract">Dependently typed languages such as Coq are used to specify and prove functional correctness of source
programs, but what we ultimately need are guarantees about correctness of compiled code.
By preserving dependent types through each compiler pass, we could preserve source-level
specifications and correctness proofs into the generated target-language programs.
Unfortunately, type-preserving compilation of dependent types is a challenging problem.
In 2002, Barthe and Uustalu showed that type-preserving CPS is \emph{not possible} for languages such as
Coq.
Specifically, they showed that for strong dependent pairs ($\Sigma$ types), the standard typed
call-by-name CPS is \emph{not type preserving}.
They further proved that for dependent case analysis on sums, a class of typed CPS
translations&#x2014; <wbr>including the standard translation&#x2014; <wbr>is \emph{not possible}.
In 2016, Morrisett noticed a similar problem with the standard call-by-value CPS translation for
dependent functions ($\Pi$ types).
In essence, the problem is that the standard typed CPS translation by double-negation, in which
computations are assigned types of the form $(A \rightarrow \bot) \rightarrow \bot$, disrupts the
term/type equivalence that is used during type checking in a dependently typed language. <p>
In this paper, we prove that type-preserving CPS translation for dependently typed languages is
\emph{not} not possible.
We develop both call-by-name and call-by-value CPS translations from the Calculus of Constructions
with both $\Pi$ and $\Sigma$ types (CC) to a dependently typed target language, and prove type
preservation and compiler correctness of each translation.
Our target language is CC extended with an additional equivalence rule and an additional typing rule,
which we prove consistent by giving a model in the extensional Calculus of Constructions.
Our key observation is that we can use a CPS translation that employs \emph{answer-type polymorphism},
where CPS-translated computations have type $\forall \alpha. (A \rightarrow \alpha) \rightarrow
\alpha$.
This type justifies, by a \emph{free theorem}, the new equality rule in our target language and allows
us to recover the term/type equivalences that CPS translation disrupts.
Finally, we conjecture that our translation extends to dependent case analysis on sums, despite the
impossibility result, and provide a proof sketch.</p></div><a class="show-abstract" href="#cps-sigma" id="cps-sigma-show">Abstract</a><a class="hide-abstract" href="#" id="cps-sigma-hide">Abstract (Hide)</a> |
<a href="/resources/cps-sigma.pdf">Paper</a> |
<a href="/resources/cps-sigma-tr.pdf">Technical Appendix</a> |
<a href="https://www.youtube.com/watch?v=JhzMAVYA8pg">POPL 2018 Talk (by me)</a> |
<a href="https://youtu.be/gXF_o0MLZ0w?t=14m33s">POPL 2018 Lightning Talk (by me)</a> |
<a href="/resources/popl2018-cps-sigma.pdf">Slides</a> |
<a href="/resources/cps-sigma.tar.gz">Supplementary Materials</a></div> <br></p> <p><div class="paper" id="fabcc"><span>Fully Abstract Compilation via Universal Embedding</span>. Max New, William J. Bowman, and Amal Ahmed. <p>
In <span>Proc. of the International Conference on Functional
Programming (ICFP 2016)</span> </p><br> <div class="abstract" id="fabcc-abstract">A <span>fully abstract</span> compiler guarantees that two source components
are observationally equivalent in the source language if and only if
their translations are observationally equivalent in the target.
Full abstraction implies the translation is <span>secure</span>: target-language
attackers can make no more observations of a compiled component than a
source-language attacker interacting with the original source
component.
Proving full abstraction for realistic compilers is challenging because
realistic target languages contain features (such as control effects)
unavailable in the source, while proofs of full abstraction require showing
that every target context to which a compiled component may be linked can be
<span>back-translated</span> to a behaviorally equivalent source context. <p>
We prove the first full abstraction result for a translation whose target
language contains exceptions, but the source does not.
Our translation&#x2014; <wbr>specifically, closure conversion of simply typed &#x3BB;-calculus
with recursive types&#x2014; <wbr>uses types at the target level to ensure that a compiled
component is never linked with attackers that have more distinguishing power
than source-level attackers.
We present a new back-translation technique based on a deep embedding of the
target language into the source language at a dynamic type.
Then boundaries are inserted that mediate terms between the untyped embedding
and the strongly-typed source. This technique allows back-translating
non-terminating programs, target features that are untypeable in the source,
and well-bracketed effects.</p></div><a class="show-abstract" href="#fabcc" id="fabcc-show">Abstract</a><a class="hide-abstract" href="#" id="fabcc-hide">Abstract (Hide)</a> |
<a href="/resources/fabcc-paper.pdf">Paper</a> |
<a href="/resources/fabcc-techrpt.pdf">Technical Appendix</a> |
<a href="https://www.youtube.com/watch?v=Hylji4ezQHE">ICFP 2016 Talk (by Max New)</a> |
<a href="https://dl.acm.org/authorize?N14736">Author-Izer</a></div> <br></p> <p><div class="paper" id="niforfree"><span>Noninterference for Free</span>. William J. Bowman, and Amal Ahmed. <p>
In <span>Proc. of the International Conference on Functional
Programming (ICFP 2015)</span> </p><br> <div class="abstract" id="niforfree-abstract">Abadi et. al. (1999) introduced the dependency core calculus
(DCC) as a framework for studying a variety of dependency analyses
(e.g., secure information flow). The key property provided by DCC is
noninterference, which guarantees that a low-level observer
(attacker) cannot distinguish high-level (protected) computations.
The proof of noninterference for DCC suggests a connection to
parametricity in System F, which suggests that it should be possible
to implement dependency analyses in languages with parametric
polymorphism. <p>
In this paper, we present a translation from DCC into F&#x3C9; and
prove that the translation preserves noninterference. To express
noninterference in F&#x3C9; we define a notion of observer-sensitive
equivalence that makes essential use of both first-order and
higher-order polymorphism. Our translation provides insights into
DCC&#x2019;s type system and shows how DCC can be implemented in a
polymorphic language without loss of the security/noninterference
guarantees available in DCC. Our contributions include proof
techniques that should be valuable when proving other secure
compilation or full abstraction results.</p></div><a class="show-abstract" href="#niforfree" id="niforfree-show">Abstract</a><a class="hide-abstract" href="#" id="niforfree-hide">Abstract (Hide)</a> |
<a href="/resources/nonintforfree.pdf">Paper</a> |
<a href="/resources/nonintforfree-techrpt.pdf">Technical Appendix</a> |
<a href="https://youtu.be/-vgWefEXHt0">ICFP 2015 Talk (by me)</a> |
<a href="/resources/icfp2015-niforfree.pdf">Slides</a> |
<a href="https://dl.acm.org/authorize?N14737">Author-Izer</a></div></p> <p> <br>
<div class="paper" id="pgmp"><span>Profile-Guided Meta-Programming</span>. William J. Bowman, Swaha Miller, Vincent St-Amour, and R. Kent Dybvig. <p>
In <span>Proc. of the Conference on Programming Language Implementation and
Design (PLDI 2015).</span> </p><br> <div class="abstract" id="pgmp-abstract">Contemporary compiler systems such as GCC, .NET, and LLVM incorporate
profile-guided optimizations (PGOs) on low-level intermediate code and
basic blocks, with impressive results over purely static heuristics.
Recent work shows that profile information is also useful for performing
source-to-source optimizations via meta-programming.
For example, using profiling information to inform decisions about data
structures and algorithms can potentially lead to asymptotic
improvements in performance. <p>
We present a design for profile-guided meta-programming in a
general-purpose meta-programming system.
Our design is parametric over the particular profiler and
meta-programming system.
We implement this design in two different meta-programming systems&#x2014; <wbr>the
syntactic extensions systems of Chez Scheme and Racket&#x2014; <wbr>and provide
several profile-guided meta-programs as usability case studies.</p></div><a class="show-abstract" href="#pgmp" id="pgmp-show">Abstract</a><a class="hide-abstract" href="#" id="pgmp-hide">Abstract (Hide)</a> |
<a href="/resources/pgmp.pdf">Paper</a> |
<a href="/resources/pldi2015-pgmp.pdf">Slides</a> |
<a href="https://www.github.com/wilbowma/pgmp">GitHub</a> |
<a href="https://dl.acm.org/authorize?N14738">Author-Izer</a> <br></div></p> <h2><a></a>Workshop Publications</h2> <p><div class="paper" id="prisc2018-ccasm"><span>Dependently Typed Assembly and Secure Linking (short talk)</span> William J. Bowman. <p>
Talk at <span>the Workshop on Principles of Secure Compilation (PriSC 2018).</span> </p><br>
<span class="abstract" id="prisc2018-ccasm-abstract">Type-preserving compilation is used to statically enforce safety and security properties through
type checking.
The idea is to design strongly typed compiler target languages, preserve type information through the
compiler, then use the types in the target language to enforce invariants when linking with untrusted
code.
Unfortunately, this technique is limited by the expressiveness of the target type system, and existing
simple and polymorphic typed assembly languages cannot express all security invariants we wish to
enforce.
Dependent types could be used to express safety, security, and full functional correctness invariants.
In this talk, I briefly describe work-in-progress on developing a dependently typed assembly, and how
it could be used to statically enforce security guarantees when linking.</span><a class="show-abstract" href="#prisc2018-ccasm" id="prisc2018-ccasm-show">Abstract</a><a class="hide-abstract" href="#" id="prisc2018-ccasm-hide">Abstract (Hide)</a> |
<a href="/resources/prisc2018-ccasm.pdf">Slides</a></div> <br></p> <p><div class="paper" id="cur-control"><span>Only Control Effects and Dependent Types</span>. Youyou Cong, William J. Bowman. <p>
Talk at <span>the Workshop on Higher-order Programming with Effects (HOPE
2017).</span> </p><br>
<a href="/resources/cur-control.pdf">Abstract</a> |
<a href="https://www.github.com/wilbowma/cur-control">GitHub</a></div> <br></p> <p><div class="paper" id="cur"><span>Growing a Proof Assistant</span>. William J. Bowman. <p>
Talk at <span>the Workshop on Higher-order Programming with Effects (HOPE
2016).</span> </p><br> <div class="abstract" id="cur-abstract">Sophisticated domain-specific and user-defined notation is widely used in
formal models, but is poorly supported by proof assistants.
Many proof assistants support simple notation definitions, but no proof
assistant enables users to <span>conveniently</span> define <span>sophisticated</span>
notation.
For instance, in modeling a programming language, we often define infix
relations such as <span class="RktSym">&#x393;</span><span class="hspace">&#xA0;</span><span class="RktSym">&#x22A2;</span><span class="hspace">&#xA0;</span><span class="RktSym">e</span><span class="hspace">&#xA0;</span><span class="RktSym">:</span><span class="hspace">&#xA0;</span><span class="RktSym">t</span> and use BNF notation to specify the syntax
of the language.
In a proof assistant like Coq or Agda, users can easily define the notation
for <span class="RktSym">&#x393;</span><span class="hspace">&#xA0;</span><span class="RktSym">&#x22A2;</span><span class="hspace">&#xA0;</span><span class="RktSym">e</span><span class="hspace">&#xA0;</span><span class="RktSym">:</span><span class="hspace">&#xA0;</span><span class="RktSym">t</span>, but to use BNF notation the user must use a preprocessing
tool external to the proof assistant, which is cumbersome. <p>
To support sophisticated user-defined notation, we propose to use
<span>language extension</span> as a fundamental part of the design of a proof
assistant.
We describe how to design a language-extension systems that support safe,
convenient, and sophisticated user-defined extensions, and how to design a
proof assistant based on language extension.
We evaluate this design by building a proof assistant that features a small
dependent type theory as the core language and implementing the following
extensions in small user-defined libraries: pattern matching for inductive
types, dependently-typed staged meta-programming, a tactic-based proof
language, and BNF and inference-rule notation for inductive type definitions.</p></div><a class="show-abstract" href="#cur" id="cur-show">Abstract</a><a class="hide-abstract" href="#" id="cur-hide">Abstract (Hide)</a> |
<a href="/resources/cur.pdf">Draft Paper</a> |
<a href="https://youtu.be/vPYgzEdCxt8">HOPE 2016 Talk (by me)</a> |
<a href="https://www.github.com/wilbowma/cur">GitHub</a></div> <br></p> <p><div class="paper" id="catrev"><span>Dagger Traced Symmetric Monoidal Categories and Reversible Programming</span>. William J. Bowman, Roshan P. James, and Amr Sabry. <p>
In <span>Proc. of the 4th Workshop on Reversible Computation (RC
2011).</span> </p><br>
<a href="/resources/cat-rev.pdf">Paper</a> |
<a href="/resources/reversible.tar.gz">Code</a></div></p> <h2><a></a>Talks</h2> <p><div class="paper" id="talk-respinv"><span>Do Compilers Respect Programmers?</span> William J. Bowman <p>
<a href="https://video.seas.harvard.edu/media/CS+Colloquium+William+Bowman+2018-04-09/1_7ym9l24i/13151421">Video</a> |
<a href="/resources/wjb-talk-respinv.key">Keynote</a> |
<a href="/resources/wjb-talk-respinv.pdf">PDF</a></p></div></p> <h2><a></a>Other</h2> <p><div class="paper" id="cccc-popl17-src"><span>Toward Type Preserving Compilation of Coq</span>. William J. Bowman. <p>
<span>POPL 2017 Student Research Competition</span> </p><br> <a href="/resources/cccc-extended-abstract.pdf">Extended Abstract</a> |
<a href="/resources/cccc-poster.pdf">Poster</a></div> <br></p> <h2><a></a>Dissertation</h2> <p><span class id="talk-defense"></span>
<div class="paper" id="dissertation"><span>Compiling with Dependent Types</span>. William J. Bowman. <p>
<span>Northeastern University, Feb. 2019.</span> </p><br> <div class="abstract" id="dissertation-abstract">Dependently typed languages have proven useful for developing large-scale fully
verified software, but we do not have any guarantees after compiling that
verified software.
A verified program written in a dependently typed language, such as Coq, can be
type checked to ensure that the program meets its specification.
Similarly, type checking prevents us from importing a library and
violating the specification declared by its types.
Unfortunately, we cannot perform either of these checks after compiling a
dependently typed program, since all current implementations erase types before
compiling the program.
Instead, we must trust the compiler to not introduce errors into the
verified code, and, after compilation, trust the programmer to never introduce
errors by linking two incompatible program components.
As a result, the compiled and linked program is
<span>not verified</span>&#x2014; <wbr>we have no guarantees about what it will do. <p>
In this dissertation, I develop a theory for preserving dependent types through
compilation so that we can use type checking after compilation to check that no
errors are introduced by the compiler or by linking.
Type-preserving compilation is a well-known technique that has been used to
design compilers for non-dependently typed languages, such as ML, that
statically enforce safety and security guarantees in compiled code.
But there are many open challenges in scaling type preservation to dependent
types.
The key problems are adapting syntactic type systems to interpret low-level
representations of code, and breaking the complex mutually recursive structure
of dependent type systems to make proving type preservation and compiler
correctness feasible.
In this dissertation, I explain the concepts required to scale type preservation
to dependent types, present a proof architecture and language design that
support type preservation, and prove type preservation and compiler correctness
for four early-stage compiler translations of a realistic dependently typed
calculus.
These translations include an A-normal form (ANF), a continuation-passing style
(CPS), an abstract closure conversion, and a parametric closure conversion
translation.</p></div><a class="show-abstract" href="#dissertation" id="dissertation-show">Abstract</a><a class="hide-abstract" href="#" id="dissertation-hide">Abstract (Hide)</a> |
<a href="/resources/wjb-dissertation.pdf">PDF</a> |
<a href="/resources/wjb-defense.key">Slides (keynote)</a> |
<a href="/resources/wjb-defense.pdf">Slides (PDF)</a></div></p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>