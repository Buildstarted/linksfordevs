<!DOCTYPE html>
<html lang="en">
<head>
    <title>
My Favorite CLI Tools - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="My Favorite CLI Tools - linksfor.dev(s)"/>
    <meta property="og:description" content="Previously, I wrote about my favorite Mac apps. But I spend half of my time in the terminal, and I ha..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://dev.to/switowski/my-favorite-cli-tools-4p4g"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - My Favorite CLI Tools</title>
<div class="readable">
        <h1>My Favorite CLI Tools</h1>
            <div>Reading time: 17-21 minutes</div>
        <div>Posted here: 21 Jun 2020</div>
        <p><a href="https://dev.to/switowski/my-favorite-cli-tools-4p4g">https://dev.to/switowski/my-favorite-cli-tools-4p4g</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div data-article-id="358870" id="article-body">
        <p>Previously, I wrote about <a href="https://dev.to/switowski/my-favorite-macbook-tools-2apf">my favorite Mac apps</a>. But I spend half of my time in the terminal, and I have a handful of CLI tools that makes my life easier. Here are some of them:</p>

<h2>
  <a name="tools-that-i-use-every-day" href="#tools-that-i-use-every-day">
  </a>
  Tools that I use every day
</h2>

<h3>
  <a name="fish-shell" href="#fish-shell">
  </a>
  <a href="https://fishshell.com/">fish shell</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--4GHOmQOv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-fish.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--4GHOmQOv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-fish.jpg" alt="fish shell website" loading="lazy"></a></p>

<p>Shell - the most important tool that you use every time you open the terminal. I‚Äôve used Bash and Z shell in the past, and currently, I‚Äôm using fish. It‚Äôs a great shell with plenty of features out of the box, like the autosuggestions, syntax highlighting, or switching between folders with ‚å•+‚Üí and ‚å•+‚Üê.</p>

<p>On the one hand, this makes it perfect for beginners, because you don‚Äôt have to set up anything. On the other hand, because it‚Äôs using a different syntax than other shells, you usually can‚Äôt just paste scripts from the internet. You either have to change the incompatible commands to <a href="https://fishshell.com/docs/current/index.html#syntax-overview">fish scripts</a> or start a Bash session to run the bash scripts. I understand the idea behind this change (Bash is not the easiest language to use), but it doesn‚Äôt benefit me in any way. I write bash/fish scripts too seldom to memorize the syntax, so I always have to relearn it from scratch. And there are fewer resources for fish scripts than for bash scripts. I usually end up reading the documentation, instead of copy-pasting ready-made scripts from StackOverflow.</p>

<p>Do I recommend fish? Yes! Switching shells is easy, so give it a try. Especially if you don‚Äôt like to tinker with your shell and want to have something that works great with minimal configuration.</p>

<h4>
  <a name="fish-plugins" href="#fish-plugins">
  </a>
  Fish plugins
</h4>

<p>You can add more features to fish with plugins. The easiest way to install them is to use a plugin manager like <a href="https://github.com/jorgebucaran/fisher">Fisher</a>, <a href="https://github.com/oh-my-fish/oh-my-fish">Oh My Fish</a>, or <a href="https://github.com/danhper/fundle">fundle</a>.</p>

<p>Right now, I‚Äôm using Fisher with just three plugins:</p>

<ul>
<li>
<a href="https://github.com/franciscolourenco/done">franciscolourenco/done</a> - sends a notification when a long-running script is done. I don‚Äôt have a terminal open all the time. I‚Äôm using a <a href="http://guake-project.org/">Guake style</a> terminal that drops down from the top of the screen when I need it and hides when I don‚Äôt. With this plugin, when I run scripts that take longer than a few seconds, I get a macOS notification when they finish.</li>
<li>
<a href="https://github.com/evanlucas/fish-kubectl-completions">evanlucas/fish-kubectl-completions</a> - provides autocompletion for kubectl (Kubernetes command line tool).</li>
<li>
<a href="https://github.com/jethrokuan/fzf">fzf</a> - integrates the fzf tool (<a href="#fzf">see below</a>) with fish.</li>
</ul>

<p>I had more plugins in the past (rbenv, pyenv, nodenv, fzf, z), but I switched to different tools to avoid slowing down my shell (a mistake that I did in the past with Z shell).</p>

<p>If you want to see more resources for fish, check out the <a href="https://github.com/jorgebucaran/awesome-fish">awesome-fish</a> repository. Compared with Z shell and Bash, fish has fewer plugins, so it‚Äôs not the best option if you want to tweak it a lot. For me - that‚Äôs a plus. It stops me from enabling too many plugins and then complaining that it‚Äôs slow üòâ.</p>

<h3>
  <a name="starship" href="#starship">
  </a>
  <a href="https://starship.rs/">Starship</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--aYuqfFe2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-starship.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--aYuqfFe2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-starship.jpg" alt="Starship website" loading="lazy"></a></p>

<p>If I had to choose one favorite tool from this whole list - it would be Starship. Starship is a prompt that works for any shell. You install it, add one line of config to your <code>.bashrc</code>/<code>.zshrc</code>/<code>config.fish</code>, and it takes care of the rest.</p>

<p>It shows:</p>

<ul>
<li>git status of the current directory and different symbols, depending on if you have new files, pending changes, stashes, etc.</li>
<li>Python version if you are in a Python project folder (the same applies to Go/Node/Rust/Elm and many other programming languages)</li>
<li>How long it took the previous command to execute (if it was longer than a few milliseconds)</li>
<li>Error indicator if the last command failed</li>
</ul>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--vlp1kXPM--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-starship2.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--vlp1kXPM--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-starship2.jpg" alt="Starship prompt in action" loading="lazy"></a><figcaption>Starship prompt in action</figcaption></figure>

<p>And a bazillion other information. But, in a smart way! If you are not in a git repository, it hides the git info. If you are not in a Python project - there is no Python version (because there is no point in displaying it). It never overwhelms you with too much information, and the prompt stays beautiful, useful, and minimalistic.</p>

<p>Did I mention that it‚Äôs fast? It‚Äôs written in Rust, and even with so many features, it‚Äôs still faster than all my previous prompts! I‚Äôm very picky about my prompt, so I was usually hacking my own version. I was taking functions from existing prompts and gluing it together to make sure I only have things that I need and it stays fast. That‚Äôs why I was skeptical about Starship. <em>‚ÄúThere is no way that an external tool can be faster than my meticulously crafted prompt!</em>‚Äù Well, I was wrong. Give it a try, and I‚Äôm sure you are going to love it! Huge kudos to the creators of Starship!</p>

<h3>
  <a name="z" href="#z">
  </a>
  <a href="https://github.com/rupa/z">z</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--mS_zE34Q--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-z.gif"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--mS_zE34Q--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-z.gif" alt="z tool in action" loading="lazy"></a></p>

<p>‚Äúz‚Äù lets you quickly jump around your filesystem. It memorizes the folders that you visit, and after a short learning time, you can move between them using <code>z path_of_the_folder_name</code>.</p>

<p>For example, if I often go to folder <code>~/work/src/projects</code>, I can just run <code>z pro</code> and immediately jump there. z‚Äôs algorithm is based on <strong>frecency</strong> - a combination of <strong>frequency</strong> and <strong>recency</strong> that works very well. If it memorizes a folder that you don‚Äôt want to use, you can always remove it manually.</p>

<p>It speeds up moving between commonly visited folders on my computer and saves me a lot of keystrokes (and path memorization).</p>

<h3>
  <a name="fzf" href="#fzf">
  </a>
  <a href="https://github.com/junegunn/fzf">fzf</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--dCtFN2hI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-fzf.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--dCtFN2hI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-fzf.jpg" alt="fzf in action" loading="lazy"></a></p>

<p>fzf stands for <em>‚Äúfuzzy finder‚Äù</em>. It‚Äôs a general-purpose tool that lets you find files, commands in the history, processes, git commits, and more using a <strong>fuzzy search</strong>. You type some letters, and it tries to match those letters anywhere in the list of results. The more letters you type, the more accurate the results are. You probably know this type of search from your code editor - when you use the command to open a file, and you type just part of the file name instead of the full path - that‚Äôs a fuzzy search.</p>

<p>I use it through the <a href="https://github.com/jethrokuan/fzf">fish fzf plugin</a>, so I can search through command history or quickly open a file. It‚Äôs another small tool that saves me time every day.</p>

<h3>
  <a name="fd" href="#fd">
  </a>
  <a href="https://github.com/sharkdp/fd">fd</a>
</h3>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--iE0aKwSR--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-fd.gif"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--iE0aKwSR--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-fd.gif" alt="fd in action" loading="lazy"></a><figcaption>find (left) versus fd (right)</figcaption></figure>

<p>Like the <code>find</code> command but much simpler to use, faster, and comes with good default settings.</p>

<p>You want to find a file called ‚Äúinvoice,‚Äù but you are not sure what extension it has? Or maybe it was a directory that was holding all your invoices, not a single file? You can either roll up your sleeves and start writing those regex patterns for the <code>find</code> command or just run <code>fd invoice</code>. For me, the choice is easy üòâ.</p>

<p>By default, fd ignores files and directories that are hidden or listed in the <code>.gitignore</code>. Most of the time - that‚Äôs what you want, but for those rare cases when I need to disable this feature, I have an alias: <code>fda='fd -IH'</code>.</p>

<p>The output is nicely colorized and, <a href="https://github.com/sharkdp/fd#benchmark">according to the benchmarks</a> (or the GIF above), it‚Äôs even faster than <code>find</code>.</p>

<h3>
  <a name="ripgrep" href="#ripgrep">
  </a>
  <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>
</h3>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--ar8nth2_--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-rg.gif"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ar8nth2_--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-rg.gif" alt="ripgrep in action" loading="lazy"></a><figcaption>Poor grep (on the left) was running for ages through all the node_modules before finding something useful</figcaption></figure>

<p>In a similar manner to <code>fd</code> mentioned above, <code>ripgrep</code> is an alternative to the <code>grep</code> command - much faster one, with sane defaults and colorized output.</p>

<p>It skips files ignored by <code>.gitignore</code> and hidden ones, so you will probably need this alias: <code>rga='rg -uuu'</code>. It disables all smart filtering and makes <code>ripgrep</code> behave as standard grep.</p>

<h3>
  <a name="htop-and-glances" href="#htop-and-glances">
  </a>
  <a href="https://hisham.hm/htop/">htop</a> and <a href="https://nicolargo.github.io/glances/">glances</a>
</h3>

<p>The most common tool to show information about processes running on Linux or Mac is called <code>top</code>. It‚Äôs the best friend of every system administrator. And, even if you are mostly doing web development like me, it‚Äôs useful to see what‚Äôs going on with your computer. You know, just to see if it was Docker or Chrome that ate all your RAM this time.</p>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--LTamxERV--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-htop.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--LTamxERV--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-htop.jpg" alt="htop in action" loading="lazy"></a><figcaption>htop is an excellent alternative for top</figcaption></figure>

<p><code>top</code> is quite basic, so most people switch to <a href="https://hisham.hm/htop/">htop</a>. <code>htop</code> is top on steroids - colorful, with plenty of options, and overall more comfortable to use.</p>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--A3O_xzAC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-glances.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--A3O_xzAC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-glances.jpg" alt="Glances at a glance ;)" loading="lazy"></a><figcaption>glances gives you a quick overview of your system</figcaption></figure>

<p><a href="https://nicolargo.github.io/glances/">glances</a> is a complementary tool to <code>htop</code>. Apart from listing all the processes with their CPU and memory usage, it also displays additional information about your system.</p>

<p>You can see:</p>

<ul>
<li>network or disks usage</li>
<li>used and total space on your filesystem</li>
<li>data from different sensors (like the battery)</li>
<li>and a list of processes that recently consumed an excessive amount of resources</li>
</ul>

<p>I still use <code>htop</code> for faster filtering and killing processes, but I use <code>glances</code> to quickly <em>glance</em> at what‚Äôs going on with my computer. It comes with API, Web UI, and various export formats, so you can take system monitoring to the next level. I highly recommend it!</p>

<h3>
  <a name="virtualenv-and-virtualfish" href="#virtualenv-and-virtualfish">
  </a>
  <a href="https://pypi.org/project/virtualenv/">virtualenv</a> and <a href="https://github.com/justinmayer/virtualfish">virtualfish</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--W8MW-naL--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-virtualenv.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--W8MW-naL--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-virtualenv.jpg" alt="Virtualenv website" loading="lazy"></a></p>

<p>Virtualenv is a tool for creating virtual environments in Python (I like it more than the built-in <code>venv</code> module).</p>

<p>VirtualFish is virtual environment manager for the fish shell (if you are not using fish, check out <a href="https://pypi.org/project/virtualenvwrapper">virtualenvwrapper</a>). It provides a bunch of additional commands to create, list, or delete virtual environments quickly.</p>

<h3>
  <a name="pyenv-nodenv-and-rbenv" href="#pyenv-nodenv-and-rbenv">
  </a>
  <a href="https://github.com/pyenv/pyenv">pyenv</a>, <a href="https://github.com/nodenv/nodenv">nodenv</a>, and <a href="https://github.com/rbenv/rbenv">rbenv</a>
</h3>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--sUSzvELi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-pyenv.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--sUSzvELi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-pyenv.jpg" alt="pyenv in action" loading="lazy"></a><figcaption>pyenv makes it easy to switch Python versions</figcaption></figure>

<p>Pyenv, nodenv, and rubyenv are tools for managing different versions of Python, Node, and Ruby on my computer.</p>

<p>Let‚Äôs say you want to have two versions of Python on your computer. Maybe you are working on two different projects, or you still need to support Python 2. Managing different Python versions is hard. You need to make sure that different projects install packages with the correct version. If you are not careful, it‚Äôs easy to mess up this fragile setup and overwrite binaries used by other packages.</p>

<p>Version manager helps a lot and turns this nightmare into a pretty manageable task. Good version manager can swap the Python version globally or ‚Äúper folder‚Äù. And every version is isolated from others.</p>

<p>I‚Äôve recently found a tool called <a href="https://github.com/asdf-vm/asdf">asdf</a> that can replace pyenv, nodenv, rbenv, and other *envs with one tool to rule them all. It provides version management for pretty much <a href="https://asdf-vm.com/#/plugins-all?id=plugin-list">any programming language</a>, and I will definitely give it a try next time I need to set up a version manager for a programming language.</p>

<h3>
  <a name="pipx" href="#pipx">
  </a>
  <a href="https://github.com/pipxproject/pipx">pipx</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--dwXfY7qi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-pipx.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--dwXfY7qi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-pipx.jpg" alt="pipx logo" loading="lazy"></a></p>

<p>Virtualenv solves many problems with package management in Python, but there is one more use case to cover. If I want to install a Python package globally (because it‚Äôs a standalone tool, like <code>glances</code> mentioned before), I have a problem. Installing packages outside of a virtual environment is a bad idea and can lead to problems in the future. On the other hand, if I decide to use a virtual environment, then I need to activate that virtual environment each time I want to run my tool. Not the most convenient solution either.</p>

<p>It turns out that <code>pipx</code> tool can solve this problem. It installs Python packages into separate environments (so there is no risk that their dependencies will clash). But, at the same time, CLI commands provided by those tools are available globally. So I don‚Äôt have to activate anything - <code>pipx</code> will do this for me!</p>

<h3>
  <a name="ctop-and-lazydocker" href="#ctop-and-lazydocker">
  </a>
  <a href="https://github.com/bcicen/ctop">ctop</a> and <a href="https://github.com/jesseduffield/lazydocker">lazydocker</a>
</h3>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Qm5NooEp--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-ctop.gif"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Qm5NooEp--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-ctop.gif" alt="ctop in action" loading="lazy"></a><figcaption>ctop in action (source: <a href="https://github.com/bcicen/ctop">https://github.com/bcicen/ctop</a>)</figcaption></figure>

<p>Both of those tools are useful when you are working with Docker. <code>ctop</code> is a top-like interface for Docker containers. It gives you:</p>

<ul>
<li>A list of running and stopped containers</li>
<li>Statistics like memory usage, CPU, and an additional detailed window for each container (with open ports and other information)</li>
<li>A quick menu to stop, kill, or show logs of a given container</li>
</ul>

<p>It‚Äôs so much nicer than trying to figure out all this information from <code>docker ps</code>.</p>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--nesp0aJR--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-lazydocker.gif"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--nesp0aJR--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-lazydocker.gif" alt="lazydocker in action" loading="lazy"></a><figcaption>lazydocker is my favorite Docker tool (source: <a href="https://github.com/jesseduffield/lazydocker">https://github.com/jesseduffield/lazydocker</a>)</figcaption></figure>

<p>And if you think that <code>ctop</code> was cool, wait until you try <code>lazydocker</code>! It‚Äôs a full-fledged terminal UI for managing Docker with even more features. My favorite tool when it comes to Docker!</p>

<h2>
  <a name="tools-that-i-dont-use-every-day" href="#tools-that-i-dont-use-every-day">
  </a>
  Tools that I don‚Äôt use every day
</h2>

<p>Apart from the tools that I use almost every day, there are some that I collected over the years and found them particularly useful for specific tasks. There is something to record GIFs from the terminal (that you can pause and copy text from!), list directory structure, connect to databases, etc.</p>

<h3>
  <a name="homebrew" href="#homebrew">
  </a>
  <a href="https://brew.sh/">Homebrew</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--XtoErNtg--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-homebrew.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--XtoErNtg--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-homebrew.jpg" alt="Homebrew website" loading="lazy"></a></p>

<p>Homebrew needs no introduction if you are using a Mac. It‚Äôs a <em>de facto</em> package manager for macOS. It even has a GUI version called <a href="https://www.cakebrew.com/">Cakebrew</a>.</p>

<h3>
  <a name="asciinema" href="#asciinema">
  </a>
  <a href="https://asciinema.org/">asciinema</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--TyBVuzHv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-asciinema.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--TyBVuzHv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-asciinema.jpg" alt="Asciinema website" loading="lazy"></a></p>

<p><code>asciinema</code> is a tool that you can use to record your terminal sessions. But, unlike recording GIFs, it will let your viewers select and copy the code from those recordings!</p>

<p>It‚Äôs a great help for recording coding tutorials - not many things are as frustrating as typing long commands because the instructor didn‚Äôt provide you with code snippets.</p>

<h3>
  <a name="colordiff-and-diffsofancy" href="#colordiff-and-diffsofancy">
  </a>
  <a href="https://www.colordiff.org/">colordiff</a> and <a href="https://github.com/so-fancy/diff-so-fancy">diff-so-fancy</a>
</h3>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--DF7pKRRI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-colordiff.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--DF7pKRRI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-colordiff.jpg" alt="Colordiff in action" loading="lazy"></a><figcaption>colordiff brings some colors to your diffs</figcaption></figure>

<p>I rarely do diffs (compare differences between two files) in the terminal anymore, but if you need to do one, use <code>colordiff</code> instead of the unusable <code>diff</code> command. <code>colordiff</code> colorizes the output, so it‚Äôs much easier to see the changes instead of trying to follow all the ‚Äú&lt;‚Äù and ‚Äú&gt;‚Äù signs.</p>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--pV-de-NA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-diff-so-fancy.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--pV-de-NA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-diff-so-fancy.jpg" alt="diff-so-fancy in action" loading="lazy"></a><figcaption>diff-so-fancy - even better alternative to colordiff</figcaption></figure>

<p>For running <code>git diff</code> and <code>git show</code> commands, there is an even better tool called <a href="https://github.com/so-fancy/diff-so-fancy">diff-so-fancy</a>. It further improves how the diff looks like by:</p>

<ul>
<li>highlighting changed words (instead of the whole lines)</li>
<li>simplifying the headers for changed files</li>
<li>stripping the + and - symbols (you already have colors for this)</li>
<li>clearly indicating new and deleted empty lines</li>
</ul>

<h3>
  <a name="tree-raw-brew-install-tree-endraw-" href="#tree-raw-brew-install-tree-endraw-">
  </a>
  tree (<code>brew install tree</code>)
</h3>

<p>If you want to present the content of a given directory, <code>tree</code> is a go-to tool to do that. It displays all the subdirectories and files in a nice, tree-like structure:<br>
</p>

<div><pre><code><span>$ </span>tree <span>.</span>
<span>.</span>
‚îú‚îÄ‚îÄ recovery.md
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ archive
‚îú‚îÄ‚îÄ automator
‚îÇ   ‚îú‚îÄ‚îÄ Open<span> </span>Iterm2.workflow
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Contents
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Info.plist
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ QuickLook
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Thumbnail.png
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ document.wflow
‚îÇ   ‚îî‚îÄ‚îÄ Start<span> </span>Screen<span> </span>Saver.workflow
‚îú‚îÄ‚îÄ brew-cask.sh
</code></pre></div>



<h3>
  <a name="bat" href="#bat">
  </a>
  <a href="https://dev.to/scottw/bat-57pg-temp-slug-2229370">bat</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--yDeF27wD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-bat.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--yDeF27wD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-bat.jpg" alt="NANANANANANA, bat!" loading="lazy"></a></p>

<p>Like <code>cat</code> (command most commonly used to display the content of a file in a terminal) but better.</p>

<p>Adds syntax highlighting, git gutter marks (when applicable), automatic paging (if the file is large), and in general, makes the output much more enjoyable to read.</p>

<h3>
  <a name="httpie" href="#httpie">
  </a>
  <a href="https://httpie.org/">httpie</a>
</h3>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--a1-f3SNy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-httpie.gif"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--a1-f3SNy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-httpie.gif" alt="httpie tool in action" loading="lazy"></a><figcaption>httpie in action (source: <a href="https://httpie.org/">https://httpie.org/</a>)</figcaption></figure>

<p>If you need to send some HTTP requests and you find <code>curl</code> unintuitive to use, try <code>httpie</code>.</p>

<p>It‚Äôs an excellent alternative. It‚Äôs easier to use with sensible defaults and simple syntax, returns a colorized output, and even supports installing additional plugins (for different types of authentication).</p>

<h3>
  <a name="tldr" href="#tldr">
  </a>
  <a href="https://tldr.sh/">tldr</a>
</h3>

<p>Simplified man pages. <em>‚Äúman pages‚Äù</em> contain manuals for Linux software that explain how to use a given command. Try running <code>man cat</code> or <code>man grep</code> to see an example. They are very detailed and sometimes can be difficult to grasp. So <code>tldr</code> is a community effort to extract the essence of each man page into a brief description with some examples.</p>

<p><code>tldr</code> works for the most popular software. As I said, it‚Äôs a community effort, and there is a slim chance that someone will document an obscure package for you. But when it works, the information it provides usually contains what you are looking for.</p>

<p>For example, if you want to create a gzipped archive of a few files, <code>man tar</code> will overwhelm you with the possible options. <code>tldr tar</code> will instead list some common examples - the second one being exactly the thing that you want to do:</p>

<figure><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--cAOKeY3G--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-tldr.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--cAOKeY3G--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-tldr.jpg" alt="man page vs tldr" loading="lazy"></a><figcaption>man pages are great, but sometimes using tldr will be much faster to find a specific information</figcaption></figure>

<h3>
  <a name="exa" href="#exa">
  </a>
  <a href="https://the.exa.website/">exa</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--okzf4ymi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-exa.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--okzf4ymi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-exa.jpg" alt="exa in action" loading="lazy"></a></p>

<p><code>exa</code> can be a replacement for the <code>ls</code> command.</p>

<p>It‚Äôs colorful, displays additional information like the git status, automatically converts file size to human-readable units, and all that while staying equally fast to <code>ls</code>.</p>

<p>Even though I like it and recommend it, for some reason, I still stick with <code>ls</code> instead. Muscle memory, I guess?</p>

<h3>
  <a name="litecli-and-pgcli" href="#litecli-and-pgcli">
  </a>
  <a href="https://litecli.com/">litecli</a> and <a href="https://www.pgcli.com/">pgcli</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--dK2pgzbE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-litecli.gif"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--dK2pgzbE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-litecli.gif" alt="litecli in action" loading="lazy"></a></p>

<p>My go-to CLI solutions for SQLite and PostgreSQL. With the auto-completion and syntax highlighting, they are much better to use than the default <code>sqlite3</code> and <code>psql</code> tools.</p>

<h3>
  <a name="mas" href="#mas">
  </a>
  <a href="https://github.com/mas-cli/mas">mas</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--szO0WPJ6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-mas.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--szO0WPJ6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-mas.jpg" alt="mas website" loading="lazy"></a></p>

<p><code>mas</code> is a CLI tool to install software from the App Store. I used it once in my life - when I was setting up my Macbook. And I will use it to set up my next Macbook too.</p>

<p><code>mas</code> lets you automate the installation of software in macOS. It saves you from <em>a lot</em> of clicking. And, since you are reading an article about CLI tools, I assume that - just like me - you don‚Äôt like clicking.</p>

<p>I keep a list of apps installed from the App Store in my ‚Äúdisaster recovery‚Äù scripts. If something bad happens, I hopefully should be able to reinstall everything with minimal hassle.</p>

<h3>
  <a name="ncdu" href="#ncdu">
  </a>
  <a href="https://dev.yorhel.nl/ncdu">ncdu</a>
</h3>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--2ln7RPeE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-ncdu.jpg"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--2ln7RPeE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-ncdu.jpg" alt="ncdu in action" loading="lazy"></a></p>

<p>Disk usage analyzer for the terminal. Fast and easy to use. My default tool when I need to free some space (<em>‚ÄúOhh, I‚Äôm sure that 256GB of disk space will be plenty!‚Äù</em>).</p>

<h2>
  <a name="thats-all-folks" href="#thats-all-folks">
  </a>
  That‚Äôs all folks
</h2>

<p>It was a long list, but hopefully, you discovered something new today.</p>

<p>Some of the tools like the <code>fd</code>, <code>ripgrep</code>, or <code>httpie</code> are improved versions of things that you probably already know. Except that the new versions are easier to use, they provide better output, and sometimes are actually faster. So don‚Äôt cling to old tools only because everyone else is using them.</p>

<p>A common argument for sticking with the <em>‚Äústandard Linux tools‚Äù</em> that I hear is:</p>

<blockquote>
<p><em>But what if you need to log in to a Linux server and do some work there? You won‚Äôt have access to your fancy tools. It‚Äôs better to learn how to use tools that come built-in with most Linux distributions.</em></p>
</blockquote>

<p>When was the last time you had to log in to a Linux server? One where you can‚Äôt install software, but you had to debug some issues manually? I don‚Äôt even remember. Not many people do that anymore. Maybe it‚Äôs time to rethink how you do the deployment and move away from manual work into something more scalable?</p>

<p>Don‚Äôt let your tool-belt get rusty and add some new CLI tools there!</p>


<hr>

<p>Many of the tools that I mentioned are related to Python programming. If you want to learn more and see how I use them, I‚Äôve made a free video for PyCon 2020 conference called <em>"Modern Python Developer's Toolkit"</em>.  </p>

<p><a href="https://www.youtube.com/watch?v=WkUBx3g2QfQ"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ew1Gy3gt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://switowski.com/assets/img/posts/img_2020-06-18-cli-pycon.jpg" alt="" loading="lazy"></a>  </p>

<p>It's a two-hour-long tutorial on how to set up a Python development environment, which tools to use, and finally - how to make a TODO application from scratch (with tests and documentation). You can find <a href="https://www.youtube.com/watch?v=WkUBx3g2QfQ">it on YouTube</a>.</p>


      </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>