<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using Rust in Windows -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Using Rust in Windows</h1>
    <div class="entry-content clear"> <p>This Saturday 9<sup>th</sup> of November, there will be a <a href="https://barcelona.rustfest.eu/sessions/r-evolution">keynote</a> from Microsoft
engineers Ryan Levick and Sebastian Fernandez at RustFest Barcelona. They will be
talking about why Microsoft is exploring Rust adoption, some of the challenges we&#x2019;ve
faced in this process, and the future of Rust adoption in Microsoft. If you
want to talk with some of the people working on how Microsoft is evolving its
code practices for better security, be sure to attend the keynote and talk to
Ryan and Sebastian afterwards!</p> <p>This blog describes part of the story of Rust adoption at Microsoft. Recently, I&#x2019;ve been tasked with an experimental rewrite of a low-level system component of the Windows codebase (sorry, we can&#x2019;t say which one yet). Instead of rewriting the code in C++, I was asked to use Rust, a memory-safe alternative. Though the project is not yet finished, I can say that my experience with Rust has been generally positive. It&#x2019;s a good choice for those looking to avoid common mistakes that often lead to security vulnerabilities in C++ code bases. </p> <h2>Great dev experience</h2> <p>For C++ developers used to writing complex systems, using
Rust as a developer is a breath of fresh air. The memory and data safety
guarantees made by the compiler give the developer much greater confidence that
compiling code will be correct beyond memory safety vulnerabilities. Less time
is spent debugging trivial issues or frustrating race conditions. The compiler
warning and error messages are extremely well written, allowing novice Rust
programmers to quickly identify and resolve issues in their code. VSCode
already has a helpful extension (<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">RLS</a>),
which provides Intellisense suggestions and syntax highlighting. Additionally,
the Cargo build tool offers very helpful features around testing, documentation
generation, and auto formatting. </p> <h2>Learning Curve</h2> <p>Thanks to a plethora of online documentation and very helpful compiler error messages, Rust has a pretty easy learning curve for someone like me who has used C++ for the majority of my career. There are <a href="https://rust-unofficial.github.io/too-many-lists/">tutorials</a> aimed specifically at C/C++ systems engineers. In his <a href="https://www.youtube.com/watch?v=kylqq8pEgRs">talk at RustConf 2019</a>, Jeremy Fitzhardinge at Facebook noted that he saw experienced C/C++ developers become comfortable with Rust in around four weeks and pretty fluent in eight. This aligns with my own experience. I participated in the annual Microsoft internal &#x201C;One Week&#x201D; hackathon with one experienced Rust developer and one complete novice. Within three days, the novice Rust developer had written more than 1000 lines of idiomatic Rust code. In addition to the great documentation, there are helpful tools like <a href="https://github.com/rust-lang/rust-clippy">Clippy</a> which allow experienced C++ developers to jump right into coding Rust without much direct assistance from those experienced with Rust.</p> <p>As we expand the use of Rust inside of Microsoft, I believe
it will be prudent to start a RustReviewers group for any PRs that include Rust
code. This will help novices in diverse teams get feedback from Rust experts,
regardless of the specific problem domain.</p> <p>In general, new components or existing components with clean
interfaces will be the easiest to port to Rust. The component I&#x2019;ve been rewriting
has been challenging as there are many abstractions leaked from one layer to
the next, requiring some preliminary refactoring before progress could be made.</p> <h2>Foreign Function Interfaces (FFI)</h2> <p>It is straightforward to link Rust code against C ABI (application
binary interface) boundaries. There is a minimal amount of boilerplate code
necessary to write for simple functions using basic types. However, given that
FFI functions are always unsafe, a wrapper function is always desired. For
functions that involve more complicated structs, it is desirable to
automatically generate an equivalent Rust struct using <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a> as part of the
build process. Being able to interoperate with C++ directly will require some
more investigation, although we do have some teams already looking into this.
Microsoft has recently open sourced a <a href="https://github.com/microsoft/com-rs">COM library</a> that we see as the
first step towards this, but we&#x2019;ll eventually want more advanced tooling for
directly interfacing with complex C++ APIs. &#xA0;</p> <h2>Keeping it Safe</h2> <p>To obtain the desired safety guarantees from Rust, strict guidelines
must be placed around the use of the <strong>unsafe</strong> keyword. Any calls to an FFI
function should occur in a wrapper function that provides a safe abstraction
around it. Similarly, any other code that must use the <strong>unsafe</strong> keyword
should have a wrapper function or struct that provides a safe abstraction.</p> <p>In practice, besides FFI boundaries, <strong>unsafe</strong> has only been required for very basic protocol handling. In these cases, it&#x2019;s simple to write some generic <strong>unsafe</strong> code that can be thoroughly unit tested and used for a variety of scenarios, resulting in code that feels much safer than C++. After writing Rust code, I find writing C++ much more frustrating since I can&#x2019;t rely on the compiler to ensure memory safety.</p> <p>Beyond just ensuring safety guarantees, having a set of
internal Rust coding standards will help new developers get the most out of the
language. Best practices for error handling, logging, locking, and other
language-specific issues will obtain higher quality code faster.</p> <h2>Desired features and the Rust community</h2> <p>Given Rust&#x2019;s relative youth, there are still some missing language features that would be very desirable for our development. Foremost of these are safe transmutation (safely cast &#x201C;plain old data&#x201D; types to and from raw bytes), safe support for C style unions, and fallible allocation (fail gracefully from allocation failure, rather than panic). </p> <p>Another amazing capability from Rust is the unit testing built into Cargo which allows developers to write unit tests in the same file as production code and run them easily while developing. Unfortunately, we cannot rely on Cargo as a build tool today inside of our large and complex build system, so we cannot rely on these tests in automatic code integration flows without further work. Talk has already started with the Cargo team on how large companies like Microsoft with complex existing build systems can still take advantage of Cargo.</p> <p>Due to the interest in using Rust in microcontrollers and
low-level systems like kernels and hypervisors, the community is already working
in solving these issues. I&#x2019;m confident that we at Microsoft will be able to
help in these endeavors to shape the future of the language to improve its
usefulness in these scenarios. </p> <h2>Going from Here</h2> <p>In general, using Rust has been a really great experience. I
look forward to seeing more developers at Microsoft working with the language
and working with the wider community on making the language an even better fit
for some of the things we do here at Microsoft. </p> <p><strong><em>Adam Burch, Software Engineer, Hyper-V team</em></strong></p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>