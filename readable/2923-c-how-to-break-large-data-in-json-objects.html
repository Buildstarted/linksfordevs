<!DOCTYPE html>
<html lang="en">
<head>
    <title>
c# - How to break large data in json objects -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>c# - How to break large data in json objects</h1><div><div class="post-text" itemprop="text"><p>I want to send large file in chunks to Web API. File will have data in JSON objects.</p><p><strong>Condition</strong> : One JSON object <em>will never exceed 1 MB Size</em>. My API will ingest 1 MB JSON content from file <em>one at a time</em>, and it will break down 1 MB into JSON Objects. If there is one incomplete JSON Object left in 1 MB, then it needs to be stored and when next 1 MB chunk is received incomplete JSON Object will be merged to form the complete JSON Object and then process it.</p><pre><code>File Size: 1 GB
API Will receive : 1 MB
API needs to parse all the JSON object in 1 MB (as much as it can)
Incomplete JSON needs to be stored so that it can be merged in next 1 MB.
</code></pre><p>Below is what I have till now.</p><pre><code>public async Task&lt;bool&gt; Upload()
{
    const int bufferSize = 1024*1024;
    var filesReadToProvider = await Request.Content.ReadAsMultipartAsync();
    foreach (var content in filesReadToProvider.Contents)
    {
        var stream = await content.ReadAsStreamAsync();
        using (StreamReader sr = new StreamReader(stream))
        {
            int dataRead; 
            char[] buffer = new char[bufferSize];
            dataRead = sr.ReadBlock(buffer, 0, bufferSize);
            //forloop
            var bteArr = Encoding.GetEncoding("UTF-8").GetBytes(buffer);
            while ((dataRead) &gt; 0)
            {
                using (MemoryStream memoryStream = new MemoryStream(bteArr))
                {
                    try
                    {
                      // Process 1 COMPLETE JSON OBJECT out of many JSON's present in 1 MB
                    }

                }
                dataRead = sr.ReadBlock(buffer, 0, bufferSize);
            }
        }
    }
return true;
}
</code></pre><p>Please guide me on how can I achieve it.</p><p>Attempt Made:</p><p>I did make a novice attempt, but it is not fool proof. Still it breaks in certain corner cases and code is also too noisy. :-|</p><pre><code>public async Task&lt;bool&gt; Upload()
{
    const int bufferSize =  1024*1024;
    var filesReadToProvider = await Request.Content.ReadAsMultipartAsync();
    foreach (var content in filesReadToProvider.Contents)
    {
        var stream = await content.ReadAsStreamAsync();
        using (StreamReader sr = new StreamReader(stream))
        {
            int dataRead;
            char[] buffer = new char[bufferSize];
            char[] bufferToSend = new char[bufferSize];
            char[] stash = new char[bufferSize];
            // buffer getting all the content
            dataRead = sr.ReadBlock(buffer, 0, bufferSize);
            // finding index of where closing bracket in original buffer
            var index = Array.IndexOf(buffer, '}');
            // create the stash
            Array.Copy(buffer, index + 2, stash, 0, bytesRead - index - 2);
            // create the actual buffer to send.
            Array.Copy(buffer, 0, bufferToSend, 0, index + 1);
            // convert to byte to send.
            var bteArr = Encoding.GetEncoding("UTF-8").GetBytes(bufferToSend);
            while ((index) &gt; 0)
            {
                using (MemoryStream memoryStream = new MemoryStream(bteArr))
                {
                // PROCESS JSON ObJects "bufferToSend"
                }
                // to end the loop
                if (index &gt;= dataRead - 1)
                {
                    index = -1;
                    break;
                }
                // keep track of old index so that new stash can be created
                var oldindex = index;
                // increase the index to new place till where we need to create new buffertosend
                index = index + Array.IndexOf(stash, '}') + 2;
                // this is needed because if current payload is small then copy will keep the old payload intact
                bufferToSend = new char[bufferSize];
                // now copy the new stash content to buffer to send
                Array.Copy(stash, 0, bufferToSend, 0, index - oldindex - 1);
                // convert to bytearray
                bteArr = Encoding.GetEncoding("UTF-8").GetBytes(bufferToSend);
                // update the stash
                stash = new char[bufferSize];
                Array.Copy(buffer, index + 2, stash, 0, bytesRead - index - 2);
            }
            dataRead = sr.ReadBlock(buffer, 0, bufferSize);
        }
    }

return true;
}
</code></pre><p>Input:</p><pre><code>  {
    "id": 5,
    "nm": "Edwy",
    "cty": "United Kingdom",
    "hse": "House of Wessex",
    "yrs": "955-959"
  },
  {
    "id": 6,
    "nm": "Edgar",
    "cty": "United Kingdom",
    "hse": "House of Wessex",
    "yrs": "959-975"
  }
</code></pre><p>Output expected.</p><pre><code>  {
    "id": 5,
    "nm": "Edwy",
    "cty": "United Kingdom",
    "hse": "House of Wessex",
    "yrs": "955-959"
  }
</code></pre><p>Then in next loop</p><pre><code>{
    "id": 6,
    "nm": "Edgar",
    "cty": "United Kingdom",
    "hse": "House of Wessex",
    "yrs": "959-975"
  },
</code></pre></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>