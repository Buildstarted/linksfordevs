<!DOCTYPE html>
<html lang="en">
<head>
    <title>
vivri/Adjective: Programming is an exercise in linguistics; spice-up Scala types with Adjective. -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>vivri/Adjective: Programming is an exercise in linguistics; spice-up Scala types with Adjective.</h1><div><div id="" class="markdown-body entry-content p-5"><h3><a id="user-content-programming-is-an-exercise-in-linguistics-spice-up-scala-types-with-adjective" class="anchor" aria-hidden="true" href="#programming-is-an-exercise-in-linguistics-spice-up-scala-types-with-adjective"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Programming is an exercise in linguistics; spice-up Scala types with Adjective</h3><h3><a id="user-content-sonatype-artifact" class="anchor" aria-hidden="true" href="#sonatype-artifact"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sonatype Artifact</h3><p><strong>Currently builds for <code>2.12.x</code></strong></p><div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span><span class="pl-smi">adjectiveVersion</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>0.4.4<span class="pl-pds">"</span></span><span class="pl-c"><span class="pl-c">//</span> JVM</span>
libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>com.victorivri<span class="pl-pds">"</span></span><span class="pl-k">%%</span><span class="pl-s"><span class="pl-pds">"</span>adjective<span class="pl-pds">"</span></span><span class="pl-k">%</span> adjectiveVersion

<span class="pl-c"><span class="pl-c">//</span> Scala.js</span>
libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>com.victorivri<span class="pl-pds">"</span></span><span class="pl-k">%%%</span><span class="pl-s"><span class="pl-pds">"</span>adjective<span class="pl-pds">"</span></span><span class="pl-k">%</span> adjectiveVersion</pre></div><h3><a id="user-content-at-a-glance" class="anchor" aria-hidden="true" href="#at-a-glance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>At a Glance</h3><div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span><span class="pl-en">com</span>.<span class="pl-en">victorivri</span>.<span class="pl-en">adjective</span>.<span class="pl-en">AdjectiveBase</span>.<span class="pl-en">_</span><span class="pl-c"><span class="pl-c">//</span> First, we define the precise types that make up our domain/universe/ontology</span><span class="pl-k">object</span><span class="pl-en">PersonOntology</span> {
  <span class="pl-c"><span class="pl-c">//</span> `Adjective[T]` is the building block of our type algebra</span><span class="pl-c"><span class="pl-c">//</span> Try to make them as atomic as possible</span><span class="pl-k">case</span><span class="pl-k">object</span><span class="pl-en">DbId</span><span class="pl-k">extends</span><span class="pl-e">Adjective</span>[<span class="pl-en">Int</span>]    ((id)<span class="pl-k">=&gt;</span><span class="pl-c1">0</span><span class="pl-k">&lt;=</span> id <span class="pl-k">&amp;&amp;</span> id <span class="pl-k">&lt;</span><span class="pl-c1">2000000</span>)
  <span class="pl-k">case</span><span class="pl-k">object</span><span class="pl-en">NameSequence</span><span class="pl-k">extends</span><span class="pl-e">Adjective</span>[<span class="pl-en">String</span>] (_.matches(<span class="pl-s"><span class="pl-pds">"</span>^[A-Z][a-zA-Z]{1,31}$<span class="pl-pds">"</span></span>))
  <span class="pl-k">case</span><span class="pl-k">object</span><span class="pl-en">DisallowedSequences</span><span class="pl-k">extends</span><span class="pl-e">Adjective</span>[<span class="pl-en">String</span>] (_.toLowerCase.contains(<span class="pl-s"><span class="pl-pds">"</span>fbomb<span class="pl-pds">"</span></span>))
  <span class="pl-k">case</span><span class="pl-k">object</span><span class="pl-en">ScottishLastName</span><span class="pl-k">extends</span><span class="pl-e">Adjective</span>[<span class="pl-en">String</span>] (_ startsWith <span class="pl-s"><span class="pl-pds">"</span>Mc<span class="pl-pds">"</span></span>)
  <span class="pl-k">case</span><span class="pl-k">object</span><span class="pl-en">JewishLastName</span><span class="pl-k">extends</span><span class="pl-e">Adjective</span>[<span class="pl-en">String</span>] (_ endsWith <span class="pl-s"><span class="pl-pds">"</span>berg<span class="pl-pds">"</span></span>)

  <span class="pl-c"><span class="pl-c">//</span> We use boolean algebra to combine base adjectives into more nuanced adjectives</span><span class="pl-k">val</span><span class="pl-c1">LegalName</span><span class="pl-k">=</span><span class="pl-en">NameSequence</span> &amp; <span class="pl-k">~</span><span class="pl-en">DisallowedSequences</span><span class="pl-c"><span class="pl-c">//</span> `~X` negates `X`</span><span class="pl-k">val</span><span class="pl-c1">FirstName</span><span class="pl-k">=</span><span class="pl-en">LegalName</span><span class="pl-k">val</span><span class="pl-c1">SomeHeritageLastName</span><span class="pl-k">=</span><span class="pl-en">LegalName</span> &amp; (<span class="pl-en">ScottishLastName</span><span class="pl-k">&lt;</span><span class="pl-k">+</span><span class="pl-k">&gt;</span><span class="pl-en">JewishLastName</span>) <span class="pl-c"><span class="pl-c">//</span> `&lt;+&gt;` stands for Xor, ⊕ is the math notation</span>
}

<span class="pl-k">import</span><span class="pl-en">PersonOntology</span>.<span class="pl-en">_</span><span class="pl-c"><span class="pl-c">//</span> Our Domain is now ready to be used in ADTs, validations and elsewhere.</span><span class="pl-c"><span class="pl-c">//</span> As opposed to monadic types, the preferred way to integrate</span><span class="pl-c"><span class="pl-c">//</span> Adjective is to use its "successful" type, conveniently accessible through `_.^`</span><span class="pl-k">case</span><span class="pl-k">class</span><span class="pl-en">Person</span> (<span class="pl-v">id</span>: <span class="pl-en">DbId</span>.^, <span class="pl-v">firstName</span>: <span class="pl-en">FirstName</span>.^, <span class="pl-v">lastName</span>: <span class="pl-en">SomeHeritageLastName</span>.^)</pre></div><h3><a id="user-content-the-problem" class="anchor" aria-hidden="true" href="#the-problem"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Problem</h3><p>The current landscape restricts our ability to express our domain, our <strong>ontology</strong>, in a succinct and intuitive way.</p><ol><li>We cannot natively apply <strong>adjectives</strong> to our nouns (e.g. <strong>Positive</strong> number.)</li><li>We cannot natively <strong>combine</strong> our adjectives to form new ones (e.g. Positive <strong>AND</strong> even number.)</li><li>We cannot easily maintain semantic information in our types without clunky, non-composable custom wrapper-types.</li></ol><p>This prevents us from having native <strong>expressive</strong> types, such as:</p><ul><li>Natural numbers</li><li>All IPs in a net mask</li><li>Valid emails</li><li>Obtuse angles</li><li>Dates in the year 2525</li><li>...</li></ul><p>Encoding that domain knowledge into ad-hoc validation methods and smart constructors <strong>strips this information from the domain</strong>,
often leaving developers confused about valid values, unwritten rules, semantics, and intent.</p><p>And even if we did encode that knowledge into custom classes using smart constructors, we are still missing the ability
to natively perform <strong>algebra</strong> on those types, and <strong>derive new types</strong> from the basic ones.</p><p>For example:</p><ul><li><strong>Router rule range</strong>: NetMask1 <strong>OR</strong> NetMask2 <strong>AND NOT</strong> NetMask3</li><li><strong>Internal email</strong>: Valid email address <strong>AND</strong> Company hostname <strong>OR</strong> Subsidiary hostname</li><li><strong>Valid Names</strong>: Capitalized strings <strong>AND</strong> Strings of length 2 to 30 <strong>AND</strong> Strings comprised of only [a-zA-Z]</li><li>...</li></ul><h3><a id="user-content-the-solution" class="anchor" aria-hidden="true" href="#the-solution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Solution</h3><p><strong>Adjective.^</strong> solved these problems, such that:</p><ol><li>You can <strong>create arbitrary restrictions</strong> on base types (a.k.a. adjectives in linguistics.)</li><li>You can use <strong>Boolean Algebra</strong> to arbitrarily <strong>create new adjectives</strong> from existing ones at runtime.</li><li>The range of valid values, the semantics and intent <strong>are forever captured</strong> in the <code>Adjective</code>.</li><li>It is <strong>(somewhat)</strong> lightweight:
<ul><li>Runtime operations are cacheable and predictable (TODO: benchmark).</li><li>Adjective rules are best stored as singletons to conserve memory footprint and allocation.</li><li>Minimum boilerplate.</li><li>Little knowledge of advanced Scala/Typelevel features required.</li><li>Zero library dependencies.</li></ul></li></ol><h3><a id="user-content-usage-example" class="anchor" aria-hidden="true" href="#usage-example"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage Example</h3><h4><a id="user-content-the-following-is-a-passing-spec" class="anchor" aria-hidden="true" href="#the-following-is-a-passing-spec"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The following is a passing spec:</h4><div class="highlight highlight-source-scala"><pre><span class="pl-s"><span class="pl-pds">"</span>Usage example<span class="pl-pds">"</span></span> in {

    <span class="pl-c"><span class="pl-c">//</span> First, we define the precise types that make up our domain/universe/ontology</span><span class="pl-k">object</span><span class="pl-en">PersonOntology</span> {
      <span class="pl-c"><span class="pl-c">//</span> `Adjective[T]` is the building block of our type algebra</span><span class="pl-c"><span class="pl-c">//</span> Try to make them as atomic as possible</span><span class="pl-k">case</span><span class="pl-k">object</span><span class="pl-en">DbId</span><span class="pl-k">extends</span><span class="pl-e">Adjective</span>[<span class="pl-en">Int</span>]    ((id)<span class="pl-k">=&gt;</span><span class="pl-c1">0</span><span class="pl-k">&lt;=</span> id <span class="pl-k">&amp;&amp;</span> id <span class="pl-k">&lt;</span><span class="pl-c1">2000000</span>)
      <span class="pl-k">case</span><span class="pl-k">object</span><span class="pl-en">NameSequence</span><span class="pl-k">extends</span><span class="pl-e">Adjective</span>[<span class="pl-en">String</span>] (_.matches(<span class="pl-s"><span class="pl-pds">"</span>^[A-Z][a-zA-Z]{1,31}$<span class="pl-pds">"</span></span>))
      <span class="pl-k">case</span><span class="pl-k">object</span><span class="pl-en">DisallowedSequences</span><span class="pl-k">extends</span><span class="pl-e">Adjective</span>[<span class="pl-en">String</span>] (_.toLowerCase.contains(<span class="pl-s"><span class="pl-pds">"</span>fbomb<span class="pl-pds">"</span></span>))
      <span class="pl-k">case</span><span class="pl-k">object</span><span class="pl-en">ScottishLastName</span><span class="pl-k">extends</span><span class="pl-e">Adjective</span>[<span class="pl-en">String</span>] (_ startsWith <span class="pl-s"><span class="pl-pds">"</span>Mc<span class="pl-pds">"</span></span>)
      <span class="pl-k">case</span><span class="pl-k">object</span><span class="pl-en">JewishLastName</span><span class="pl-k">extends</span><span class="pl-e">Adjective</span>[<span class="pl-en">String</span>] (_ endsWith <span class="pl-s"><span class="pl-pds">"</span>berg<span class="pl-pds">"</span></span>)

      <span class="pl-c"><span class="pl-c">//</span> We use boolean algebra to combine base adjectives into more nuanced adjectives</span><span class="pl-k">val</span><span class="pl-c1">LegalName</span><span class="pl-k">=</span><span class="pl-en">NameSequence</span> &amp; <span class="pl-k">~</span><span class="pl-en">DisallowedSequences</span><span class="pl-c"><span class="pl-c">//</span> `~X` negates `X`</span><span class="pl-k">val</span><span class="pl-c1">FirstName</span><span class="pl-k">=</span><span class="pl-en">LegalName</span><span class="pl-k">val</span><span class="pl-c1">SomeHeritageLastName</span><span class="pl-k">=</span><span class="pl-en">LegalName</span> &amp; (<span class="pl-en">ScottishLastName</span><span class="pl-k">&lt;</span><span class="pl-k">+</span><span class="pl-k">&gt;</span><span class="pl-en">JewishLastName</span>) <span class="pl-c"><span class="pl-c">//</span> `&lt;+&gt;` stands for Xor, ⊕ is the math notation</span>
    }

    <span class="pl-k">import</span><span class="pl-en">PersonOntology</span>.<span class="pl-en">_</span><span class="pl-k">import</span><span class="pl-en">TildaFlow</span>.<span class="pl-en">_</span><span class="pl-c"><span class="pl-c">//</span> so we can use the convenient ~ operator</span><span class="pl-c"><span class="pl-c">//</span> Our Domain is now ready to be used in ADTs, validations and elsewhere.</span><span class="pl-c"><span class="pl-c">//</span> As opposed to monadic types, the preferred way to integrate</span><span class="pl-c"><span class="pl-c">//</span> AdjectiveBase is to use its "successful" type, conveniently accessible through `_.^`</span><span class="pl-k">case</span><span class="pl-k">class</span><span class="pl-en">Person</span> (<span class="pl-v">id</span>: <span class="pl-en">DbId</span>.^, <span class="pl-v">firstName</span>: <span class="pl-en">FirstName</span>.^, <span class="pl-v">lastName</span>: <span class="pl-en">SomeHeritageLastName</span>.^)

    <span class="pl-c"><span class="pl-c">//</span> We test membership to an adjective using `mightDescribe`.</span><span class="pl-c"><span class="pl-c">//</span> We string together the inputs, to form an easily-accessible data structure:</span><span class="pl-c"><span class="pl-c">//</span> Either (list of failures, tuple of successes in order of evaluation)</span><span class="pl-k">val</span><span class="pl-smi">validatedInput</span><span class="pl-k">=</span>
      (<span class="pl-en">DbId</span>                  mightDescribe <span class="pl-c1">123</span>) <span class="pl-k">~</span>
      (<span class="pl-en">FirstName</span>             mightDescribe <span class="pl-s"><span class="pl-pds">"</span>Bilbo<span class="pl-pds">"</span></span>) <span class="pl-k">~</span>
      (<span class="pl-en">SomeHeritageLastName</span>  mightDescribe <span class="pl-s"><span class="pl-pds">"</span>McBeggins<span class="pl-pds">"</span></span>)

    <span class="pl-c"><span class="pl-c">//</span> The tupled form allows easy application to case classes</span><span class="pl-k">val</span><span class="pl-smi">validPerson</span><span class="pl-k">=</span> validatedInput map <span class="pl-en">Person</span>.tupled

    <span class="pl-c"><span class="pl-c">//</span> Best way to access is via Either methods or pattern match</span>
    validPerson <span class="pl-k">match</span> {
      <span class="pl-k">case</span><span class="pl-en">Right</span>(<span class="pl-en">Person</span>(id, firstName, lastName)) <span class="pl-k">=&gt;</span><span class="pl-c"><span class="pl-c">//</span> as you'd expect</span><span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span><span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">RuntimeException</span>()
    }

    <span class="pl-c"><span class="pl-c">//</span> we can use `map` to operate on the underlying type without breaking the flow</span>
    validPerson map { _.id map (_ <span class="pl-k">+</span><span class="pl-c1">1</span>) } shouldBe <span class="pl-en">Right</span>(<span class="pl-en">DbId</span> mightDescribe <span class="pl-c1">124</span>)

    <span class="pl-c"><span class="pl-c">//</span> Trying to precisely type the Includes/Excludes exposes a</span><span class="pl-c"><span class="pl-c">//</span> little bit of clunkiness in the path-dependent types of `val`s</span>
    validPerson shouldBe <span class="pl-en">Right</span>(
      <span class="pl-en">Person</span>(
        <span class="pl-en">Includes</span>(<span class="pl-en">DbId</span>,<span class="pl-c1">123</span>), <span class="pl-c"><span class="pl-c">//</span> this works great because DbId is a type, not a `val`</span><span class="pl-en">Includes</span>(<span class="pl-en">FirstName</span>, <span class="pl-s"><span class="pl-pds">"</span>Bilbo<span class="pl-pds">"</span></span>).<span class="pl-c1">asInstanceOf</span>[<span class="pl-en">FirstName</span>.^], <span class="pl-c"><span class="pl-c">//</span> ouch!</span><span class="pl-en">Includes</span>(<span class="pl-en">SomeHeritageLastName</span>, <span class="pl-s"><span class="pl-pds">"</span>McBeggins<span class="pl-pds">"</span></span>).<span class="pl-c1">asInstanceOf</span>[<span class="pl-en">SomeHeritageLastName</span>.^])) <span class="pl-c"><span class="pl-c">//</span> one more ouch.</span><span class="pl-c"><span class="pl-c">//</span> Using the `_.base` we can access the base types if/when we wish</span><span class="pl-k">val</span><span class="pl-smi">baseTypes</span><span class="pl-k">=</span> validPerson map { person <span class="pl-k">=&gt;</span>
      (person.id.base, person.firstName.base, person.lastName.base)
    }

    baseTypes shouldBe <span class="pl-en">Right</span>((<span class="pl-c1">123</span>,<span class="pl-s"><span class="pl-pds">"</span>Bilbo<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>McBeggins<span class="pl-pds">"</span></span>))

    <span class="pl-c"><span class="pl-c">//</span> Using toString gives an intuitive peek at the rule algebra</span><span class="pl-c"><span class="pl-c">//</span></span><span class="pl-c"><span class="pl-c">//</span> The atomic [Adjective#toString] gets printed out.</span><span class="pl-c"><span class="pl-c">//</span> Beware that both `equals` and `hashCode` are (mostly) delegated to the `toString` implementation</span>
    validPerson.right.get.toString shouldBe
      <span class="pl-s"><span class="pl-pds">"</span>Person({ 123 ∈ DbId },{ Bilbo ∈ (NameSequence &amp; ~DisallowedSequences) },{ McBeggins ∈ ((NameSequence &amp; ~DisallowedSequences) &amp; (ScottishLastName ⊕ JewishLastName)) })<span class="pl-pds">"</span></span><span class="pl-c"><span class="pl-c">//</span> Applying an invalid set of inputs accumulates all rules that failed</span><span class="pl-k">val</span><span class="pl-smi">invalid</span><span class="pl-k">=</span>
      (<span class="pl-en">DbId</span>                  mightDescribe <span class="pl-k">-</span><span class="pl-c1">1</span>) <span class="pl-k">~</span>
      (<span class="pl-en">FirstName</span>             mightDescribe <span class="pl-s"><span class="pl-pds">"</span>Bilbo<span class="pl-pds">"</span></span>) <span class="pl-k">~</span>
      (<span class="pl-en">SomeHeritageLastName</span>  mightDescribe <span class="pl-s"><span class="pl-pds">"</span>Ivanov<span class="pl-pds">"</span></span>) map <span class="pl-en">Person</span>.tupled

    <span class="pl-c"><span class="pl-c">//</span> We can access the failures to belong to an adjective directly</span>
    invalid shouldBe <span class="pl-en">Left</span>(<span class="pl-en">List</span>(<span class="pl-en">Excludes</span>(<span class="pl-en">DbId</span>,<span class="pl-k">-</span><span class="pl-c1">1</span>), <span class="pl-en">Excludes</span>(<span class="pl-en">SomeHeritageLastName</span>, <span class="pl-s"><span class="pl-pds">"</span>Ivanov<span class="pl-pds">"</span></span>)))

    <span class="pl-c"><span class="pl-c">//</span> Slightly clunky, but we can translate exclusions to e.g. human-readable validation strings - or anything else</span><span class="pl-k">val</span><span class="pl-smi">exclusionMappings</span><span class="pl-k">=</span>
      invalid.left.map { exclusions <span class="pl-k">=&gt;</span>
        exclusions.map { y <span class="pl-k">=&gt;</span> y <span class="pl-k">match</span> {
            <span class="pl-k">case</span><span class="pl-en">Excludes</span>(<span class="pl-en">DbId</span>, x)                 <span class="pl-k">=&gt;</span><span class="pl-k">s</span><span class="pl-s">"</span><span class="pl-s">Bad DB id $x</span><span class="pl-s">"</span><span class="pl-k">case</span><span class="pl-en">Excludes</span>(<span class="pl-en">SomeHeritageLastName</span>, x) <span class="pl-k">=&gt;</span><span class="pl-k">s</span><span class="pl-s">"</span><span class="pl-s">Bad Last Name $x</span><span class="pl-s">"</span>
          }
        }
      }

    exclusionMappings shouldBe <span class="pl-en">Left</span>(<span class="pl-en">List</span>(<span class="pl-s"><span class="pl-pds">"</span>Bad DB id -1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Bad Last Name Ivanov<span class="pl-pds">"</span></span>))
  }</pre></div><h3><a id="user-content-literature-review" class="anchor" aria-hidden="true" href="#literature-review"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Literature Review</h3><ol><li>This document would be incomplete without mentioning the excellent <a href="https://github.com/fthomas/refined">refined</a>
library. The goals of <code>refined</code> are very similar, yet the scope and methods are different. The motivation to create
<code>Adjective</code> came in part from <code>refined</code>, however <code>Adjective</code>'s angle is slightly different, in that it foregoes the ability of compile-time refinement in favor of usability and simplicity.</li></ol></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>