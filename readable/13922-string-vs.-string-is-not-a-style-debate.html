<!DOCTYPE html>
<html lang="en">
<head>
    <title>
string vs. String is not a style debate -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>string vs. String is not a style debate</h1><div><div class="article_body"><p>Often I see developers debating using <code class="language-plaintext highlighter-rouge">String</code> vs. <code class="language-plaintext highlighter-rouge">string</code> as if it’s a simple style decision. No different than 
discussing the position of braces, tabs vs. spaces, etc … A meaningless distinction where there is no right answer, 
just finding a decision everyone can agree on. The debate between <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">string</code> though is not a simple 
style debate, instead it has the potential to radically change the semantics of a program.</p><p>The keyword <code class="language-plaintext highlighter-rouge">string</code> has concrete meaning in C#. It is the type <code class="language-plaintext highlighter-rouge">System.String</code> which exists in the core runtime 
assembly. The runtime intrinsictly understands this type and provides the capabilities developers expect for strings
in .NET. Its presence is so critical to C# that if that type doesn’t exist the compiler will exit before attempting to
even parse a line of code. Hence <code class="language-plaintext highlighter-rouge">string</code> has a precise, unambiguous meaning in C# code.</p><p>The identifier <code class="language-plaintext highlighter-rouge">String</code> though has no concrete meaning in C#. It is an identifier that goes through all the name 
lookup rules as <code class="language-plaintext highlighter-rouge">Widget</code>, <code class="language-plaintext highlighter-rouge">Student</code>, etc … It could bind to <code class="language-plaintext highlighter-rouge">string</code> or it could bind to a type in another assembly
entirely whose purposes may be entirely differnt than <code class="language-plaintext highlighter-rouge">string</code>. Worse it could be defined in a way such that code 
like <code class="language-plaintext highlighter-rouge">String s = "hello";</code> continued to compile.</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span><span class="nc">TricksterString</span><span class="p">{</span><span class="k">void</span><span class="nf">Example</span><span class="p">()</span><span class="p">{</span><span class="n">String</span><span class="n">s</span><span class="p">=</span><span class="s">"Hello World"</span><span class="p">;</span><span class="c1">// Okay but probably not what you expect.</span><span class="p">}</span><span class="p">}</span><span class="k">class</span><span class="nc">String</span><span class="p">{</span><span class="k">public</span><span class="k">static</span><span class="k">implicit</span><span class="k">operator</span><span class="nf">String</span><span class="p">(</span><span class="kt">string</span><span class="n">s</span><span class="p">)</span><span class="p">=&gt;</span><span class="k">null</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>The actual meaning of <code class="language-plaintext highlighter-rouge">String</code> will always depend on name resolution. That means it depends on all the source files in the 
project and all the types defined in all the referenced assemblies. In short it requires quite a bit of context to 
<em>know</em> what it means.</p><p>True that in the vast majority of cases <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">string</code> will bind to the same type. But using <code class="language-plaintext highlighter-rouge">String</code> still 
means developers are leaving their program up to interpretation in places where there is only one correct answer. When
<code class="language-plaintext highlighter-rouge">String</code> does bind to the wrong type it can leave developers debugging for hours, filing bugs on the compiler team
and generally wasting time that could’ve been saved by using <code class="language-plaintext highlighter-rouge">string</code>.</p><p>Another way to visualize the difference is with this sample:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span><span class="n">s1</span><span class="p">=</span><span class="m">42</span><span class="p">;</span><span class="c1">// Errors 100% of the time </span><span class="n">String</span><span class="n">s2</span><span class="p">=</span><span class="m">42</span><span class="p">;</span><span class="c1">// Might error, might not, depends on the code</span></code></pre></div></div><p>Many will argue that while this is information technically accurate using <code class="language-plaintext highlighter-rouge">String</code> is still fine because it’s 
exceedingly rare that a code base would define a type of this name. Or that when <code class="language-plaintext highlighter-rouge">String</code> is defined it’s a sign of a 
bad code base.</p><p>The reality though is quite different. Defining <code class="language-plaintext highlighter-rouge">String</code> happens with some regularity as is demonstrated by the 
following <a href="https://console.cloud.google.com/bigquery?sq=184227942691:b210a08dadec4efdb07eb6ff982893ae">BigQuery</a>:</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span><span class="n">sample_path</span><span class="p">,</span><span class="n">sample_repo_name</span><span class="k">FROM</span><span class="nv">`fh-bigquery.github_extracts.contents_net_cs`</span><span class="k">WHERE</span><span class="k">NOT</span><span class="n">STRPOS</span><span class="p">(</span><span class="n">sample_repo_name</span><span class="p">,</span><span class="s1">'coreclr'</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="k">AND</span><span class="k">NOT</span><span class="n">STRPOS</span><span class="p">(</span><span class="n">sample_repo_name</span><span class="p">,</span><span class="s1">'corefx'</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="k">AND</span><span class="k">NOT</span><span class="n">STRPOS</span><span class="p">(</span><span class="n">sample_repo_name</span><span class="p">,</span><span class="s1">'roslyn'</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="k">AND</span><span class="k">NOT</span><span class="n">STRPOS</span><span class="p">(</span><span class="n">sample_repo_name</span><span class="p">,</span><span class="s1">'corert'</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="k">AND</span><span class="k">NOT</span><span class="n">STRPOS</span><span class="p">(</span><span class="n">sample_repo_name</span><span class="p">,</span><span class="s1">'mono'</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="k">AND</span><span class="n">STRPOS</span><span class="p">(</span><span class="n">content</span><span class="p">,</span><span class="s1">'class String '</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="k">LIMIT</span><span class="mi">100</span></code></pre></div></div><p>Looking through these results you’ll see that <code class="language-plaintext highlighter-rouge">String</code> is defined for a number of completely valid purposes: 
reflection helpers, serialization libraries, lexers, protocols, etc … For any of these libraries <code class="language-plaintext highlighter-rouge">String</code> vs.
<code class="language-plaintext highlighter-rouge">string</code> has real consequences depending on where the code is used.</p><p>So remember when you see the <code class="language-plaintext highlighter-rouge">String</code> vs. <code class="language-plaintext highlighter-rouge">string</code> debate this is about semantics, not style. Choosing <code class="language-plaintext highlighter-rouge">string</code> gives
crisp meaning to your code base. Choosing <code class="language-plaintext highlighter-rouge">String</code> isn’t wrong but it’s leaving the door open for surprises in the
future.</p><p>Note: This discussion is not limited to <code class="language-plaintext highlighter-rouge">string</code>. It also applies to <code class="language-plaintext highlighter-rouge">object</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">short</code>, etc … 
essentially any of the type keywords introduced in C# 1.0.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>