<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Welcome back to C&#x2B;&#x2B; - Modern C&#x2B;&#x2B; - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Welcome back to C&#x2B;&#x2B; - Modern C&#x2B;&#x2B; - linksfor.dev(s)"/>
    <meta property="article:author" content="corob-msft"/>
    <meta property="og:description" content="Describes the new programming idioms in Modern C&#x2B;&#x2B; and their rationale."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=vs-2019"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Welcome back to C&#x2B;&#x2B; - Modern C&#x2B;&#x2B;</title>
<div class="readable">
        <h1>Welcome back to C&#x2B;&#x2B; - Modern C&#x2B;&#x2B;</h1>
            <div>by corob-msft</div>
            <div>Reading time: 12-15 minutes</div>
        <div>Posted here: 13 Apr 2020</div>
        <p><a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=vs-2019">https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=vs-2019</a></p>
        <hr/>
<div id="readability-page-1" class="page">


	<div data-bi-name="body">

		<div>

			

			<section>
				<div>


				<div id="main-column">

					<main id="main" role="main" data-bi-name="content" lang="en-us" dir="ltr">



						

						<ul data-bi-name="page info" lang="en-us" dir="ltr">
							<li>
								<time role="presentation" datetime="2020-01-10T00:00:00.000Z" data-article-date-source="ms.date">01/10/2020</time>
							</li>
								<li>8 minutes to read</li>
							<li>
								<a href="https://github.com/Microsoft/cpp-docs/blob/master/docs/cpp/welcome-back-to-cpp-modern-cpp.md" title="7 Contributors" aria-label="7 Contributors">
									
								</a>
							</li>

						</ul>

						<nav id="center-doc-outline" data-bi-name="intopic toc" role="navigation" aria-label="Article Outline">
							<h3>In this article</h3>
						<ol><li><a href="#resources-and-smart-pointers">Resources and smart pointers</a></li><li><a href="#stdstring-and-stdstring_view">std::string and std::string_view</a></li><li><a href="#stdvector-and-other-standard-library-containers">std::vector and other Standard Library containers</a></li><li><a href="#standard-library-algorithms">Standard Library algorithms</a></li><li><a href="#auto-instead-of-explicit-type-names">auto instead of explicit type names</a></li><li><a href="#range-based-for-loops">Range-based for loops</a></li><li><a href="#constexpr-expressions-instead-of-macros">constexpr expressions instead of macros</a></li><li><a href="#move-semantics">Move semantics</a></li><li><a href="#lambda-expressions">Lambda expressions</a></li><li><a href="#exceptions">Exceptions</a></li><li><a href="#stdatomic">std::atomic</a></li><li><a href="#stdvariant-c17">std::variant (C++17)</a></li><li><a href="#see-also">See also</a></li></ol></nav>

						<!-- <content> -->
							
<p>Since its creation, C++ has become one of the most widely used programming languages in the world. Well-written C++ programs are fast and efficient. The language is more flexible than other languages: It can work at the highest levels of abstraction, and down at the level of the silicon. C++ supplies highly optimized standard libraries. It enables access to low-level hardware features, to maximize speed and minimize memory requirements. Using C++, you can create a wide range of apps. Games, device drivers, and high-performance scientific software. Embedded programs. Windows client apps. Even libraries and compilers for other programming languages get written in C++.</p>
<p>One of the original requirements for C++ was backward compatibility with the C language. As a result, C++ has always permitted C-style programming, with raw pointers, arrays, null-terminated character strings, and other features. They may enable great performance, but can also spawn bugs and complexity. The evolution of C++ has emphasized features that greatly reduce the need to use C-style idioms. The old C-programming facilities are there when you need them, but with modern C++ code you should need them less and less. Modern C++ code is simpler, safer, more elegant, and still as fast as ever.</p>
<p>The following sections provide an overview of the main features of modern C++. Unless noted otherwise, the features listed here are available in C++11 and later. In the Microsoft C++ compiler, you can set the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/std-specify-language-standard-version?view=vs-2019" data-linktype="relative-path">/std</a> compiler option to specify which version of the standard to use for your project.</p>
<h2 id="resources-and-smart-pointers">Resources and smart pointers<a href="#resources-and-smart-pointers" aria-labelledby="resources-and-smart-pointers"></a></h2>
<p>One of the major classes of bugs in C-style programming is the <em>memory leak</em>. Leaks are often caused by a failure to call <strong>delete</strong> for memory that was allocated with <strong>new</strong>. Modern C++ emphasizes the principle of <em>resource acquisition is initialization</em> (RAII). The idea is simple. Resources (heap memory, file handles, sockets, and so on) should be <em>owned</em> by an object. That object creates, or receives, the newly allocated resource in its constructor, and deletes it in its destructor. The principle of RAII guarantees that all resources get properly returned to the operating system when the owning object goes out of scope.</p>
<p>To support easy adoption of RAII principles, the C++ Standard Library provides three smart pointer types: <a href="https://docs.microsoft.com/en-us/cpp/standard-library/unique-ptr-class?view=vs-2019" data-linktype="relative-path">std::unique_ptr</a>, <a href="https://docs.microsoft.com/en-us/cpp/standard-library/shared-ptr-class?view=vs-2019" data-linktype="relative-path">std::shared_ptr</a>, and <a href="https://docs.microsoft.com/en-us/cpp/standard-library/weak-ptr-class?view=vs-2019" data-linktype="relative-path">std::weak_ptr</a>. A smart pointer handles the allocation and deletion of the memory it owns. The following example shows a class with an array member that is allocated on the heap in the call to <code>make_unique()</code>. The calls to <strong>new</strong> and <strong>delete</strong> are encapsulated by the <code>unique_ptr</code> class. When a <code>widget</code> object goes out of scope, the unique_ptr destructor will be invoked and it will release the memory that was allocated for the array.</p>
<pre tabindex="0"><code data-author-content="#include <memory>
class widget
{
private:
    std::unique_ptr<int> data;
public:
    widget(const int size) { data = std::make_unique<int>(size); }
    void do_something() {}
};

void functionUsingWidget() {
    widget w(1000000);   // lifetime automatically tied to enclosing scope
                // constructs w, including the w.data gadget member
    // ...
    w.do_something();
    // ...
} // automatic destruction and deallocation for w and w.data

"><span><span>#<span>include</span> <span>&lt;memory&gt;</span></span>
<span><span>class</span> <span>widget</span>
{</span>
<span>private</span>:
    <span>std</span>::<span>unique_ptr</span>&lt;<span>int</span>&gt; data;
<span>public</span>:
    widget(<span>const</span> <span>int</span> size) { data = <span>std</span>::make_unique&lt;<span>int</span>&gt;(size); }
    <span><span>void</span> <span>do_something</span><span>()</span> </span>{}
};

<span><span>void</span> <span>functionUsingWidget</span><span>()</span> </span>{
    <span>widget <span>w</span><span>(<span>1000000</span>)</span></span>;   <span>// lifetime automatically tied to enclosing scope</span>
                <span>// constructs w, including the w.data gadget member</span>
    <span>// ...</span>
    w.do_something();
    <span>// ...</span>
} <span>// automatic destruction and deallocation for w and w.data</span>

</span></code></pre>
<p>Whenever possible, use a smart pointer when allocating heap memory. If you must use the new and delete operators explicitly, follow the principle of RAII. For more information, see <a href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=vs-2019" data-linktype="relative-path">Object lifetime and resource management (RAII)</a>.</p>
<h2 id="stdstring-and-stdstring_view">std::string and std::string_view<a href="#stdstring-and-stdstring_view" aria-labelledby="stdstring-and-stdstring_view"></a></h2>
<p>C-style strings are another major source of bugs. By using <a href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-string-class?view=vs-2019" data-linktype="relative-path">std::string and std::wstring</a>, you can eliminate virtually all the errors associated with C-style strings. You also gain the benefit of member functions for searching, appending, prepending, and so on. Both are highly optimized for speed. When passing a string to a function that requires only read-only access, in C++17 you can use <a href="https://docs.microsoft.com/en-us/cpp/standard-library/basic-string-view-class?view=vs-2019" data-linktype="relative-path">std::string_view</a> for even greater performance benefit.</p>
<h2 id="stdvector-and-other-standard-library-containers">std::vector and other Standard Library containers<a href="#stdvector-and-other-standard-library-containers" aria-labelledby="stdvector-and-other-standard-library-containers"></a></h2>
<p>The Standard Library containers all follow the principle of RAII. They provide iterators for safe traversal of elements. And, they're highly optimized for performance and have been thoroughly tested for correctness. By using these containers, you eliminate the potential for bugs or inefficiencies that might be introduced in custom data structures. Instead of raw arrays, use <a href="https://docs.microsoft.com/en-us/cpp/standard-library/vector-class?view=vs-2019" data-linktype="relative-path">vector</a> as a sequential container in C++.</p>
<pre tabindex="0"><code data-author-content="vector<string> apples;
apples.push_back(&quot;Granny Smith&quot;);
"><span><span>vector</span>&lt;<span>string</span>&gt; apples;
apples.push_back(<span>"Granny Smith"</span>);
</span></code></pre>
<p>Use <a href="https://docs.microsoft.com/en-us/cpp/standard-library/map-class?view=vs-2019" data-linktype="relative-path">map</a> (not <code>unordered_map</code>) as the default associative container. Use <a href="https://docs.microsoft.com/en-us/cpp/standard-library/set-class?view=vs-2019" data-linktype="relative-path">set</a>, <a href="https://docs.microsoft.com/en-us/cpp/standard-library/multimap-class?view=vs-2019" data-linktype="relative-path">multimap</a>, and <a href="https://docs.microsoft.com/en-us/cpp/standard-library/multiset-class?view=vs-2019" data-linktype="relative-path">multiset</a> for degenerate and multi cases.</p>
<pre tabindex="0"><code data-author-content="map<string, string> apple_color;
// ...
apple_color[&quot;Granny Smith&quot;] = &quot;Green&quot;;
"><span><span>map</span>&lt;<span>string</span>, <span>string</span>&gt; apple_color;
<span>// ...</span>
apple_color[<span>"Granny Smith"</span>] = <span>"Green"</span>;
</span></code></pre>
<p>When performance optimization is needed, consider using:</p>
<ul>
<li><p>The <a href="https://docs.microsoft.com/en-us/cpp/standard-library/array-class-stl?view=vs-2019" data-linktype="relative-path">array</a> type when embedding is important, for example, as a class member.</p>
</li>
<li><p>Unordered associative containers such as <a href="https://docs.microsoft.com/en-us/cpp/standard-library/unordered-map-class?view=vs-2019" data-linktype="relative-path">unordered_map</a>. These have lower per-element overhead and constant-time lookup, but they can be harder to use correctly and efficiently.</p>
</li>
<li><p>Sorted <code>vector</code>. For more information, see <a href="https://docs.microsoft.com/en-us/cpp/cpp/algorithms-modern-cpp?view=vs-2019" data-linktype="relative-path">Algorithms</a>.</p>
</li>
</ul>
<p>Donâ€™t use C-style arrays. For older APIs that need direct access to the data, use accessor methods such as <code>f(vec.data(), vec.size());</code> instead. For more information about containers, see <a href="https://docs.microsoft.com/en-us/cpp/standard-library/stl-containers?view=vs-2019" data-linktype="relative-path">C++ Standard Library Containers</a>.</p>
<h2 id="standard-library-algorithms">Standard Library algorithms<a href="#standard-library-algorithms" aria-labelledby="standard-library-algorithms"></a></h2>
<p>Before you assume that you need to write a custom algorithm for your program, first review the C++ Standard Library <a href="https://docs.microsoft.com/en-us/cpp/standard-library/algorithm?view=vs-2019" data-linktype="relative-path">algorithms</a>. The Standard Library contains an ever-growing assortment of algorithms for many common operations such as searching, sorting, filtering, and randomizing. The math library is extensive. Starting in C++17, parallel versions of many algorithms are provided.</p>
<p>Here are some important examples:</p>
<ul>
<li><p><strong>for_each</strong>, the default traversal algorithm (along with range-based for loops).</p>
</li>
<li><p><strong>transform</strong>, for not-in-place modification of container elements</p>
</li>
<li><p><strong>find_if</strong>, the default search algorithm.</p>
</li>
<li><p><strong>sort</strong>, <strong>lower_bound</strong>, and the other default sorting and searching algorithms.</p>
</li>
</ul>
<p>To write a comparator, use strict <strong>&lt;</strong> and use <em>named lambdas</em> when you can.</p>
<pre tabindex="0"><code data-author-content="auto comp = [](const widget&amp; w1, const widget&amp; w2)
     { return w1.weight() < w2.weight(); }

sort( v.begin(), v.end(), comp );

auto i = lower_bound( v.begin(), v.end(), comp );
"><span><span>auto</span> comp = [](<span>const</span> widget&amp; w1, <span>const</span> widget&amp; w2)
     { <span>return</span> w1.weight() &lt; w2.weight(); }

sort( v.begin(), v.end(), comp );

<span>auto</span> i = lower_bound( v.begin(), v.end(), comp );
</span></code></pre>
<h2 id="auto-instead-of-explicit-type-names">auto instead of explicit type names<a href="#auto-instead-of-explicit-type-names" aria-labelledby="auto-instead-of-explicit-type-names"></a></h2>
<p>C++11 introduced the <a href="https://docs.microsoft.com/en-us/cpp/cpp/auto-cpp?view=vs-2019" data-linktype="relative-path">auto</a> keyword for use in variable, function, and template declarations. <strong>auto</strong> tells the compiler to deduce the type of the object so that you don't have to type it explicitly. <strong>auto</strong> is especially useful when the deduced type is a nested template:</p>
<pre tabindex="0"><code data-author-content="map<int,list<string>>::iterator i = m.begin(); // C-style
auto i = m.begin(); // modern C++
"><span><span>map</span>&lt;<span>int</span>,<span>list</span>&lt;<span>string</span>&gt;&gt;::iterator i = m.begin(); <span>// C-style</span>
<span>auto</span> i = m.begin(); <span>// modern C++</span>
</span></code></pre>
<h2 id="range-based-for-loops">Range-based for loops<a href="#range-based-for-loops" aria-labelledby="range-based-for-loops"></a></h2>
<p>C-style iteration over arrays and containers is prone to indexing errors and is also tedious to type. To eliminate these errors, and make your code more readable, use range-based for loops with both Standard Library containers and raw arrays. For more information, see <a href="https://docs.microsoft.com/en-us/cpp/cpp/range-based-for-statement-cpp?view=vs-2019" data-linktype="relative-path">Range-based for statement</a>.</p>
<pre tabindex="0"><code data-author-content="#include <iostream>
#include <vector>

int main()
{
    std::vector<int> v {1,2,3};

    // C-style
    for(int i = 0; i < v.size(); ++i)
    {
        std::cout << v[i];
    }

    // Modern C++:
    for(auto&amp; num : v)
    {
        std::cout << num;
    }
}
"><span><span>#<span>include</span> <span>&lt;iostream&gt;</span></span>
<span>#<span>include</span> <span>&lt;vector&gt;</span></span>

<span><span>int</span> <span>main</span><span>()</span>
</span>{
    <span>std</span>::<span>vector</span>&lt;<span>int</span>&gt; v {<span>1</span>,<span>2</span>,<span>3</span>};

    <span>// C-style</span>
    <span>for</span>(<span>int</span> i = <span>0</span>; i &lt; v.size(); ++i)
    {
        <span>std</span>::<span>cout</span> &lt;&lt; v[i];
    }

    <span>// Modern C++:</span>
    <span>for</span>(<span>auto</span>&amp; num : v)
    {
        <span>std</span>::<span>cout</span> &lt;&lt; num;
    }
}
</span></code></pre>
<h2 id="constexpr-expressions-instead-of-macros">constexpr expressions instead of macros<a href="#constexpr-expressions-instead-of-macros" aria-labelledby="constexpr-expressions-instead-of-macros"></a></h2>
<p>Macros in C and C++ are tokens that are processed by the preprocessor before compilation. Each instance of a macro token is replaced with its defined value or expression before the file is compiled. Macros are commonly used in C-style programming to define compile-time constant values. However, macros are error-prone and difficult to debug. In modern C++, you should prefer <a href="https://docs.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=vs-2019" data-linktype="relative-path">constexpr</a> variables for compile-time constants:</p>
<pre tabindex="0"><code data-author-content="#define SIZE 10 / C-style
constexpr int size = 10; // modern C++
"><span><span>#<span>define</span> SIZE 10 / C-style</span>
<span>constexpr</span> <span>int</span> size = <span>10</span>; <span>// modern C++</span>
</span></code></pre>
<h3 id="uniform-initialization">Uniform initialization<a href="#uniform-initialization" aria-labelledby="uniform-initialization"></a></h3>
<p>In modern C++, you can use brace initialization for any type. This form of initialization is especially convenient when initializing arrays, vectors, or other containers. In the following example, <code>v2</code> is initialized with three instances of <code>S</code>. <code>v3</code> is initialized with three instances of <code>S</code> that are themselves initialized using braces. The compiler infers the type of each element based on the declared type of <code>v3</code>.</p>
<pre tabindex="0"><code data-author-content="#include <vector>

struct S
{
    std::string name;
    float num;
    S(std::string s, float f) : name(s), num(f) {}
};

int main()
{
    // C-style initialization
    std::vector<S> v;
    S s1(&quot;Norah&quot;, 2.7);
    S s2(&quot;Frank&quot;, 3.5);
    S s3(&quot;Jeri&quot;, 85.9);

    v.push_back(s1);
    v.push_back(s2);
    v.push_back(s3);

    // Modern C++:
    std::vector<S> v2 {s1, s2, s3};

    // or...
    std::vector<S> v3{ {&quot;Norah&quot;, 2.7}, {&quot;Frank&quot;, 3.5}, {&quot;Jeri&quot;, 85.9} };

}
"><span><span>#<span>include</span> <span>&lt;vector&gt;</span></span>

<span><span>struct</span> <span>S</span>
{</span>
    <span>std</span>::<span>string</span> name;
    <span>float</span> num;
    S(<span>std</span>::<span>string</span> s, <span>float</span> f) : name(s), num(f) {}
};

<span><span>int</span> <span>main</span><span>()</span>
</span>{
    <span>// C-style initialization</span>
    <span>std</span>::<span>vector</span>&lt;S&gt; v;
    <span>S <span>s1</span><span>(<span>"Norah"</span>, <span>2.7</span>)</span></span>;
    <span>S <span>s2</span><span>(<span>"Frank"</span>, <span>3.5</span>)</span></span>;
    <span>S <span>s3</span><span>(<span>"Jeri"</span>, <span>85.9</span>)</span></span>;

    v.push_back(s1);
    v.push_back(s2);
    v.push_back(s3);

    <span>// Modern C++:</span>
    <span>std</span>::<span>vector</span>&lt;S&gt; v2 {s1, s2, s3};

    <span>// or...</span>
    <span>std</span>::<span>vector</span>&lt;S&gt; v3{ {<span>"Norah"</span>, <span>2.7</span>}, {<span>"Frank"</span>, <span>3.5</span>}, {<span>"Jeri"</span>, <span>85.9</span>} };

}
</span></code></pre>
<p>For more information, see <a href="https://docs.microsoft.com/en-us/cpp/cpp/initializing-classes-and-structs-without-constructors-cpp?view=vs-2019" data-linktype="relative-path">Brace initialization</a>.</p>
<h2 id="move-semantics">Move semantics<a href="#move-semantics" aria-labelledby="move-semantics"></a></h2>
<p>Modern C++ provides <em>move semantics</em>, which make it possible to eliminate unnecessary memory copies. In earlier versions of the language, copies were unavoidable in certain situations. A <em>move</em> operation transfers ownership of a resource from one object to the next without making a copy. When implementing a class that owns a resource (such as heap memory, file handles, and so on), you can define a <em>move constructor</em> and <em>move assignment operator</em> for it. The compiler will choose these special members during overload resolution in situations where a copy isn't needed. The Standard Library container types invoke the move constructor on objects if one is defined. For more information, see <a href="https://docs.microsoft.com/en-us/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=vs-2019" data-linktype="relative-path">Move Constructors and Move Assignment Operators (C++)</a>.</p>
<h2 id="lambda-expressions">Lambda expressions<a href="#lambda-expressions" aria-labelledby="lambda-expressions"></a></h2>
<p>In C-style programming, a function can be passed to another function by using a <em>function pointer</em>. Function pointers are inconvenient to maintain and understand. The function they refer to may be defined elsewhere in the source code, far away from the point at which it's invoked. Also, they're not type-safe. Modern C++ provides <em>function objects</em>, classes that override the <a href="https://docs.microsoft.com/en-us/cpp/cpp/function-call-operator-parens?view=vs-2019" data-linktype="relative-path">()</a> operator, which enables them to be called like a function. The most convenient way to create function objects is with inline <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019" data-linktype="relative-path">lambda expressions</a>. The following example shows how to use a lambda expression to pass a function object, that the <code>for_each</code> function will invoke on each element in the vector:</p>
<pre tabindex="0"><code data-author-content="    std::vector<int> v {1,2,3,4,5};
    int x = 2;
    int y = 4;
    auto result = find_if(begin(v), end(v), [=](int i) { return i > x &amp;&amp; i < y; });
"><span>    <span>std</span>::<span>vector</span>&lt;<span>int</span>&gt; v {<span>1</span>,<span>2</span>,<span>3</span>,<span>4</span>,<span>5</span>};
    <span>int</span> x = <span>2</span>;
    <span>int</span> y = <span>4</span>;
    <span>auto</span> result = find_if(begin(v), end(v), [=](<span>int</span> i) { <span>return</span> i &gt; x &amp;&amp; i &lt; y; });
</span></code></pre>
<p>The lambda expression <code>[=](int i) { return i &gt; x &amp;&amp; i &lt; y; }</code> can be read as "function that takes a single argument of type <code>int</code> and returns a boolean that indicates whether the argument is greater than <code>x</code> and less than <code>y</code>." Notice that the variables <code>x</code> and <code>y</code> from the surrounding context can be used in the lambda. The <code>[=]</code> specifies that those variables are <em>captured</em> by value; in other words, the lambda expression has its own copies of those values.</p>
<h2 id="exceptions">Exceptions<a href="#exceptions" aria-labelledby="exceptions"></a></h2>
<p>Modern C++ emphasizes exceptions rather than error codes as the best way to report and handle error conditions. For more information, see <a href="https://docs.microsoft.com/en-us/cpp/cpp/errors-and-exception-handling-modern-cpp?view=vs-2019" data-linktype="relative-path">Modern C++ best practices for exceptions and error handling</a>.</p>
<h2 id="stdatomic">std::atomic<a href="#stdatomic" aria-labelledby="stdatomic"></a></h2>
<p>Use the C++ Standard Library <a href="https://docs.microsoft.com/en-us/cpp/standard-library/atomic-structure?view=vs-2019" data-linktype="relative-path">std::atomic</a> struct and related types for inter-thread communication mechanisms.</p>
<h2 id="stdvariant-c17">std::variant (C++17)<a href="#stdvariant-c17" aria-labelledby="stdvariant-c17"></a></h2>
<p>Unions are commonly used in C-style programming to conserve memory by enabling members of different types to occupy the same memory location. However, unions aren't type-safe and are prone to programming errors. C++17 introduces the <a href="https://docs.microsoft.com/en-us/cpp/standard-library/variant-class?view=vs-2019" data-linktype="relative-path">std::variant</a> class as a more robust and safe alternative to unions. The <a href="https://docs.microsoft.com/en-us/cpp/standard-library/variant-functions?view=vs-2019#visit" data-linktype="relative-path">std::visit</a> function can be used to access the members of a <code>variant</code> type in a type-safe manner.</p>
<h2 id="see-also">See also<a href="#see-also" aria-labelledby="see-also"></a></h2>
<p><a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-language-reference?view=vs-2019" data-linktype="relative-path">C++ Language Reference</a><br>
<a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019" data-linktype="relative-path">Lambda Expressions</a><br>
<a href="https://docs.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-reference?view=vs-2019" data-linktype="relative-path">C++ Standard Library</a><br>
<a href="https://docs.microsoft.com/en-us/cpp/overview/visual-cpp-language-conformance?view=vs-2019" data-linktype="relative-path">Microsoft C++ language conformance table</a></p>

						<!-- </content> -->

						</main>

						<!-- recommended content page section -->

							<nav data-bi-name="recommendation-bottom" hidden="" id="recommended-content-center" aria-labelledby="recommended-content-center-title">
								<h3 id="recommended-content-center-title">Related Articles</h3>
							</nav>

						<!-- end recommended content page section -->

						<!-- page rating section -->
								
						<!-- end page rating section -->


						<!-- feedback section -->
<section data-bi-name="feedback-section">

    <h2 id="feedback">Feedback</h2>

    

    

    

    <div data-tab-group-independent="" hidden="" data-bi-name="tab-group">
        <ul role="tablist">
            <li role="presentation">
                <a aria-controls="tabpanel-issues-open" data-tab="issues-open" href="#tabpanel-issues-open" role="tab" data-bi-name="tab" aria-selected="true" tabindex="0"></a>
            </li>
            <li role="presentation">
                <a aria-controls="tabpanel-issues-closed" data-tab="issues-closed" href="#tabpanel-issues-closed" role="tab" data-bi-name="tab" aria-selected="false" tabindex="-1"></a>
            </li>
        </ul>
        <section data-tab="issues-open" id="tabpanel-issues-open" role="tabpanel">
            
            <ul aria-label="Open Issues"></ul>
        </section>
        <section data-tab="issues-closed" id="tabpanel-issues-closed" role="tabpanel" hidden="hidden" aria-hidden="true">
            <div>There are no closed issues</div>
            <ul aria-label="Closed Issues"></ul>
        </section>
    </div>
    
</section>

						<!-- end feedback section -->

						<!-- feedback report section -->
						<!-- end feedback report section -->

						
					</div>

					

					<!--end of div.columns -->
				</div>

			<!--end of .primary-holder -->
			</section>

			
		</div>

		<!--end of .mainContainer -->
	</div>

	

	

	


</div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>