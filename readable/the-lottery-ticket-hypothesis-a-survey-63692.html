<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Lottery Ticket Hypothesis: A Survey - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The Lottery Ticket Hypothesis: A Survey - linksfor.dev(s)"/>
    <meta property="og:description" content="Metaphors are powerful tools to transfer ideas from one mind to another. Alan Kay introduced the alternative meaning of the term &#x2018;desktop&#x2019; at Xerox PARC in 1970. Nowadays everyone - for a glimpse of a second - has to wonder what is actually meant when referring to a desktop. Recently, Deep Learning had the pleasure to welcome a new powerful metaphor: The Lottery Ticket Hypothesis (LTH)."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://roberttlange.github.io/posts/2020/06/lottery-ticket-hypothesis/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The Lottery Ticket Hypothesis: A Survey</title>
<div class="readable">
        <h1>The Lottery Ticket Hypothesis: A Survey</h1>
            <div>Reading time: 36-46 minutes</div>
        <div>Posted here: 01 Jul 2020</div>
        <p><a href="https://roberttlange.github.io/posts/2020/06/lottery-ticket-hypothesis/">https://roberttlange.github.io/posts/2020/06/lottery-ticket-hypothesis/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
      
        <header>
          
          
            <p> 


  
	  38 minute read
	
</p>
          
        
        
        
          <p><strong> Published:</strong> <time datetime="2020-06-27T00:00:00-07:00">June 27, 2020</time></p>
        
        
             
        
    
        </header>
      

      <section itemprop="text">
        <p>Metaphors are powerful tools to transfer ideas from one mind to another. Alan Kay introduced the alternative meaning of the term ‘desktop’ at Xerox PARC in 1970. Nowadays everyone - for a glimpse of a second - has to wonder what is actually meant when referring to a desktop. Recently, Deep Learning had the pleasure to welcome a new powerful metaphor: The Lottery Ticket Hypothesis (LTH).
<!--more-->
But what idea does the Hypothesis try to transmit? In todays post we dive deeper into the hypothesis and review the literature after the original ICLR best paper award by <a href="#frankle_2019">Frankle &amp; Carbin (2019)</a>.</p>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lottery-ticket-banner.jpeg" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lottery-ticket-banner.jpeg"></a></p>

<h2 id="table-of-contents">Table of Contents</h2>

<!-- TOC depthFrom:1 depthTo:1 withLinks:1 updateOnSave:1 orderedList:0 -->



<!-- /TOC -->



<p>Pruning over-parametrized neural networks has a long tradition in Deep Learning. Most commonly it refers to setting a particular weight to 0 and freezing it for the course of any subsequent training. This can easily be done by element-wise multiplying the weights <span id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>W</mi></math></span></span> with a binary pruning mask <span id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>m</mi></math></span></span>. There are several <strong>motivating factors</strong> for performing such a surgical intervention:</p>

<ul>
  <li>It supports generalization by regularizing overparametrized functions.</li>
  <li>It reduces the memory constraints during inference time by identifying well-performing smaller networks which can fit in memory.</li>
  <li>It reduces energy costs, computations, storage and latency which can all support deployment on mobile devices.</li>
</ul>

<p>With the recent advent of deeper and deeper networks all 3 factors have been seeing a resurgence in attention. Broadly speaking any competitive pruning algorithm has to address 4 fundamental questions:</p>

<ol>
  <li>
<strong>What connectivity structures to prune?</strong>: <em>Unstructured pruning</em> does not consider any relationships between the pruned weights. <em>Structured pruning</em>, on the other hand, prunes weights in groups, e.g. by removing entire neurons (weight columns), filters or channels of CNNs. Although unstructured pruning often allows to cut down the number of weights more drastically (while maintaining high performance), this does not have to speed up computations on standard hardware. The key here is that dense computations can easily be parallelized while ‘scattered’ computations can’t. Another distinction has to be made between global and local pruning. <em>Local pruning</em> enforces that one prunes <span id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></span></span> percent of weights from each layer. <em>Global pruning</em>, on the other hand, is unrestricted and simply requires that the total number of weights across the entire network is pruned by <span id="MathJax-Element-4-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></span></span> percent.
    <center>
 <a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/pruning_overview.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/pruning_overview.png"></a>
 </center>
    <center><p>
     <em>Fig. 1: What, How, When and How often to prune?</em>
 </p></center>
  </li>
  <li>
    <p><strong>How to rank weights to prune?</strong>: There are many more or less heuristic ways to score the importance of a particular weight in a network. A common rule of thumb is that large magnitude weights have more impact on the function fit and should be pruned less. While working well in practice, this intuitively may seem to contradict ideas such as <span id="MathJax-Element-5-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>2</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>L</mi><mn>2</mn></msub></math></span></span>-weight regularization which actually punishes large magnitude weights. This motivates more involved techniques which learn pruning masks using gradient-based methods or even higher-order curvature information.</p>
  </li>
  <li>
    <p><strong>How often to prune?</strong>: Weight magnitude is often only a noisy proxy for weight importance. Pruning only a single time at the end of training (<em>one-shot</em>) can become victim to this noise. Iterative procedures, on the other hand, prune only a small number of weights after one training run but reiterate the <em>train - score - prune - rewind</em> cycle. This often times helps to de-noise the overall pruning process. Commonly the pruning rate per iteration is around 20% and a total of 20 to 30 pruning iterations are used (which leaves us with only 1% percent of non-pruned weights). One can be more conservative - at the cost of training for a lot longer!</p>
  </li>
  <li>
<strong>When to perform the pruning step?</strong>: One can perform pruning at 3 different stages of network training - after, during and before training. When pruning after the training has converged the performance often decreases, which makes it necessary to retrain/fine-tune and to give the network a chance to readjust. Pruning during training, on the other hand, is often associated with regularization and ideas of dropout/reinforcing distributed representations. Until very recently it was impossible to trained sparse networks from scratch.</li>
</ol>


<h2 id="frankle--carbin-2019---the-lottery-ticket-hypothesis-finding-sparse-trainable-neural-networks">Frankle &amp; Carbin (2019) - The Lottery Ticket Hypothesis: Finding Sparse, Trainable Neural Networks</h2>
<h3 id="paper--code">
<a href="https://openreview.net/forum?id=rJl-b3RcF7">Paper</a> | <a href="https://github.com/facebookresearch/open_lth">Code</a>
</h3>

<p>While the traditional literature has been able to show that a fully trained dense network can be pruned to little parameters without degrading performance too much, for a long time it has been impossible to successfully train a sparse sub-network from scratch. So why might this the case? The smaller subnetwork <strong>can</strong> approximate a well performing function. But the learning dynamics appear to be very different compared to the dense network.</p>

<p>The original lottery ticket hypothesis paper <a href="#frankle_2019">(Frankle &amp; Carbin, 2019)</a> first provided insight why this might be the case: After pruning the resulting sub-networks were <strong>randomly initialized</strong>. If one instead re-initializes the weights back to their original (but now masked) weights <span id="MathJax-Element-6-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi><mo>&amp;#x2299;</mo><msub><mi>W</mi><mn>0</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>m</mi><mo>⊙</mo><msub><mi>W</mi><mn>0</mn></msub></math></span></span>, it is possible to recover performance on par (or even better!) in potentially fewer training iterations. These high-performing sub-networks can then be thought of as winners of the weight initialization lottery. The hypothesis goes as follows:</p>

<blockquote>
  <p><strong>The Lottery Ticket Hypothesis</strong>: A randomly-initialized, dense neural network contains a subnetwork that is initialised such that — when trained in isolation — it can match the test accuracy of the original network after training for at most the same number of iterations. - Frankle &amp; Carbin (2019, p.2)</p>
</blockquote>

<p>So how can we attempt to find such a winning ticket? <a href="#frankle_2019">Frankle &amp; Carbin (2019)</a> propose <strong>iterative magnitude pruning</strong> (IMP): Starting from a dense initialization <span id="MathJax-Element-7-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>W</mi><mn>0</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>W</mi><mn>0</mn></msub></math></span></span> we train our network until convergence to obtain <span id="MathJax-Element-8-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>W</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msup><mi>T</mi><mo>&amp;#x22C6;</mo></msup></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></mrow></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>W</mi><mrow><msup><mi>T</mi><mo>⋆</mo></msup></mrow><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup></math></span></span>. Afterwards, we determine the <span id="MathJax-Element-9-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></span></span> percent smallest magnitude weights and create a binary mask <span id="MathJax-Element-10-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></mrow></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>m</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></math></span></span> that prunes these. We then retrain the sparsified network with its <strong>previous initial weights</strong> <span id="MathJax-Element-11-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></mrow></msup><mo>&amp;#x2299;</mo><msub><mi>W</mi><mn>0</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>m</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>⊙</mo><msub><mi>W</mi><mn>0</mn></msub></math></span></span>. After convergence we repeat the pruning process (masking additional <span id="MathJax-Element-12-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>s</mi><mn>2</mn></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>s</mi><mn>2</mn></msup></math></span></span> weights) and reset to the initial weights with the newly found mask <span id="MathJax-Element-13-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo></mrow></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>m</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup></math></span></span>. We iterate this process until we reach the desired level of sparsity or the test accuracy drops significantly.</p>

<p>
<img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lottery-ticket-imp.gif" width="100%" height="100%">
</p>
<!-- <center>
<a href="/images/blog_posts_2020/05_Lottery_Tickets/imp_static.png" data-lightbox="1"><img src="/images/blog_posts_2020/05_Lottery_Tickets/imp_static.png" style="width: 95%; margin-right: 2%; margin-left: 2%; margin-bottom: 0em; margin-top: 1em;"></a>
</center> -->
<center><p>
    <em>Fig. 2: Lottery Ticket Hypothesis - IMP procedure  <a href="https://openreview.net/forum?id=rJl-b3RcF7">(Frankle &amp; Carbin, 2019)</a></em>
</p></center>

<p>If IMP succeeds it finds the <em>winner of the initialization lottery</em>. This is simply the subnetwork <span id="MathJax-Element-14-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></mrow></msup><mo>&amp;#x2299;</mo><msub><mi>W</mi><mn>0</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>m</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mo>⊙</mo><msub><mi>W</mi><mn>0</mn></msub></math></span></span> that remains after this iterative pruning process. Note that it is also possible to simply prune in a one-shot fashion - but better results are obtained when spending that extra compute (see figure 4 of <a href="#frankle_2019">Frankle &amp; Carbin (2019)</a>). If we think back to the broad questions of the pruning literature IMP fits in as follows:</p>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/imp_classification.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/imp_classification.png"></a></p>
<center><p>
    <em>Fig. 3: IMP and the pillars of pruning</em>
</p></center>

<p>Some key empirical insights of the very first LTH paper are summarized in the figure below:</p>

<ul>
  <li>
<strong>Panel A</strong>: Randomly reinitializing &amp; re-training pruned networks leads to deteriorated performance. Results shown are on MNIST with the LeNet architecture.</li>
</ul>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_1.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_1.png"></a></p>
<center><p>
    <em>Fig. 4: LTH key results. Source: Adapted from <a href="https://openreview.net/forum?id=rJl-b3RcF7">Frankle &amp; Carbin (2019)</a></em>
</p></center>

<ul>
  <li>
    <p><strong>Panel B</strong>: Without any hyperparameter adjustments IMP is able to find sparse subnetworks that are able to outperform un-pruned dense networks in fewer training iterations (the legend refers to the percentage of pruned weights). The gap in final performance between a lottery winning initialization and a random re-initialization is referred to as the <em>lottery ticket effect</em>.</p>
  </li>
  <li>
    <p><strong>Panel C</strong> &amp; <strong>Panel D</strong>: In order to scale the original results to more complicated tasks/architectures like CIFAR-10, VGG-19 and Resnet-20, <a href="#frankle_2019">Frankle &amp; Carbin (2019)</a> had to adapt the learning rate as well as include a warmup (annealing from 0 to the final rate within a predefined set of iterations) schedule. Note that the required Resnet learning rate is a lot smaller than the VGG-19 learning rate.</p>
  </li>
</ul>

<p>So what can this tell us? First, IMP can find a substructure that is favourable for the task at hand and that the weight initialization of that subnetwork is <em>special</em> in terms of learning dynamics. Furthermore, over-parametrization is not necessary for successful training - it may only help by providing a combinatorial explosion of available subnetworks. A lot of the interesting follow-up work characterizes potential mechanisms behind the qualitative differences of winning tickets.</p>

<h2 id="frankle-dziugaite-roy--carbin-2019---stabilizing-the-lottery-ticket-hypothesis">Frankle, Dziugaite, Roy, &amp; Carbin (2019) - Stabilizing the Lottery Ticket Hypothesis</h2>
<h3 id="paper--code-1">
<a href="https://arxiv.org/abs/1903.01611">Paper</a> | <a href="https://github.com/facebookresearch/open_lth">Code</a>
</h3>

<p>One limitation of the original lottery ticket paper was that its restriction to small-scale tasks such as MNIST and CIFAR-10. In order to scale the LTH to competitive CIFAR-10 architectures, <a href="#frankle_2019">Frankle &amp; Carbin (2019)</a> had to tune learning rate schedules. Without this adjustment it is not possible to obtain a pruned network that is on par with the original dense network <a href="#liu_2018">(Liu, Sun, Zhou, Huang, &amp; Darrell, 2018; Gale, Elsen, &amp; Hooker, 2019)</a>. But what if we loosen up some of the ticket restrictions?</p>

<p>In follow-up work <a href="#frankle_2019b">Frankle, Dziugaite, Roy, &amp; Carbin (2019)</a> asked whether it might be possible to robustly obtain pruned subnetworks by not resetting the weights to their initial values <span id="MathJax-Element-15-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>W</mi><mn>0</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>W</mi><mn>0</mn></msub></math></span></span> but to weights found after a small number of <span id="MathJax-Element-16-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> training iterations. In other words, <strong>instead of rewinding to iteration 0 after pruning, we rewind to iteration <span id="MathJax-Element-17-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span></strong>. Here is the formal definition and a graphical illustration:</p>

<blockquote>
  <p><strong>The Lottery Ticket Hypothesis with Rewinding</strong>: Consider a dense, randomly-initialized neural network <span id="MathJax-Element-18-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo>;</mo><msub><mi>W</mi><mn>0</mn></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>;</mo><msub><mi>W</mi><mn>0</mn></msub><mo stretchy="false">)</mo></math></span></span> that trains to accuracy <span id="MathJax-Element-19-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>a</mi><mo>&amp;#x22C6;</mo></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>a</mi><mo>⋆</mo></msup></math></span></span> in <span id="MathJax-Element-20-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>T</mi><mo>&amp;#x22C6;</mo></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>T</mi><mo>⋆</mo></msup></math></span></span> iterations. Let <span id="MathJax-Element-21-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>W</mi><mi>t</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>W</mi><mi>t</mi></msub></math></span></span> be the weights at iteration <span id="MathJax-Element-22-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>t</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>t</mi></math></span></span> of training. There exist an iteration <span id="MathJax-Element-23-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xAB;</mo></mrow><msup><mi>T</mi><mo>&amp;#x22C6;</mo></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mrow><mo>«</mo></mrow><msup><mi>T</mi><mo>⋆</mo></msup></math></span></span> and fixed pruning mask <span id="MathJax-Element-24-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi><mo>&amp;#x2208;</mo><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>&amp;#x2223;</mo><msub><mi>W</mi><mn>0</mn></msub><mo stretchy=&quot;false&quot;>&amp;#x2223;</mo></mrow></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>m</mi><mo>∈</mo><mo fence="false" stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><msup><mo fence="false" stretchy="false">}</mo><mrow><mo stretchy="false">∣</mo><msub><mi>W</mi><mn>0</mn></msub><mo stretchy="false">∣</mo></mrow></msup></math></span></span> (where <span id="MathJax-Element-25-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>&amp;#x2223;</mo><mo>&amp;#x2223;</mo><mi>m</mi><mo>&amp;#x2223;</mo><msub><mo>&amp;#x2223;</mo><mn>1</mn></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xAB;</mo></mrow><mo>&amp;#x2223;</mo><msub><mi>W</mi><mn>0</mn></msub><mo stretchy=&quot;false&quot;>&amp;#x2223;</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">∣</mo><mo>∣</mo><mi>m</mi><mo>∣</mo><msub><mo>∣</mo><mn>1</mn></msub><mrow><mo>«</mo></mrow><mo>∣</mo><msub><mi>W</mi><mn>0</mn></msub><mo stretchy="false">∣</mo></math></span></span>) such that subnetwork <span id="MathJax-Element-26-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi><mo>&amp;#x2299;</mo><msub><mi>W</mi><mi>k</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>m</mi><mo>⊙</mo><msub><mi>W</mi><mi>k</mi></msub></math></span></span> trains to accuracy <span id="MathJax-Element-27-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi><mo>&amp;#x2265;</mo><msup><mi>a</mi><mo>&amp;#x22C6;</mo></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>≥</mo><msup><mi>a</mi><mo>⋆</mo></msup></math></span></span> in <span id="MathJax-Element-28-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>T</mi><mo>&amp;#x2264;</mo><msup><mi>T</mi><mo>&amp;#x22C6;</mo></msup><mo>&amp;#x2212;</mo><mi>k</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mo>≤</mo><msup><mi>T</mi><mo>⋆</mo></msup><mo>−</mo><mi>k</mi></math></span></span> iterations. - Frankle et al. (2019, p. 2)</p>
</blockquote>

<p>
<img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lottery-ticket-rewinding.gif" width="100%" height="100%">
</p>
<!-- <center>
<a href="/images/blog_posts_2020/05_Lottery_Tickets/imp_rewind_static.png" data-lightbox="1"><img src="/images/blog_posts_2020/05_Lottery_Tickets/imp_rewind_static.png" style="width: 95%; margin-right: 2%; margin-left: 2%; margin-bottom: 0em; margin-top: 1em;"></a>
</center> -->
<center><p>
    <em>Fig. 5: 'Matching Ticket' Hypothesis - IMP with Rewinding  <a href="https://arxiv.org/abs/1903.01611">(Frankle et al., 2019)</a></em>
</p></center>

<p>Since we perform a little bit of training, the resulting ticket <span id="MathJax-Element-29-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></mrow></msup><mo>,</mo><msup><mi>W</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>k</mi><mo stretchy=&quot;false&quot;>)</mo></mrow></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>m</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mo>,</mo><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup></math></span></span> is no longer called a lottery ticket but a <strong>matching ticket</strong>. The key insights are summarized in the figure below: Rewinding to an iteration <span id="MathJax-Element-30-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>&amp;gt;</mo><mn>0</mn></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>&gt;</mo><mn>0</mn></math></span></span> is highly effective when performing IMP. It is possible to prune up to ca. 85% of the weights while still obtaining matching test performance. This holds for both CIFAR-10 and Resnet-20 (rewinding to iteration 500; panel A) as well as ImageNet and Resnet-50 (rewind to epoch 6; panel B). There is no longer a need for a learning rate warmup.</p>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_2.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_2.png"></a></p>
<center><p>
    <em>Fig. 6: Scaling the LTH key results. Source: Adapted from <a href="https://arxiv.org/abs/1903.01611">Frankle et al. (2019)</a></em>
</p></center>

<h2 id="renda-frankle--carbin-2020---comparing-rewinding-and-fine-tuning-in-neural-network-pruning">Renda, Frankle, &amp; Carbin (2020) - Comparing Rewinding and Fine-tuning in Neural Network Pruning</h2>
<h3 id="paper--code-2">
<a href="https://arxiv.org/abs/2003.02389">Paper</a> | <a href="https://github.com/lottery-ticket/rewinding-iclr20-public">Code</a>
</h3>

<p>Until now we have discussed whether IMP is able to identify a matching network initialization. But how does the lottery procedure compare to other pruning methods? In their paper, <a href="#renda_2020">Renda, Frankle, &amp; Carbin (2020)</a> compare between three different procedures:</p>

<ol>
  <li>
<strong>Fine-Tuning</strong>: After pruning, the remaining weights are trained from their final trained values using a small learning rate. Usually this is simply the final learning rate of the original training procedure.</li>
  <li>
<strong>Weight Rewinding</strong>: This corresponds to the previously introduced method by <a href="#frankle_2019b">Frankle et al. (2019)</a>. After pruning, the remaining weights are reset to the value of a previous SGD iteration <span id="MathJax-Element-31-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span>. From that point on the weights are retrained using the learning rate schedule from iteration <span id="MathJax-Element-32-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> onwards. Both weights and learning rate schedule are reset.</li>
  <li>
<strong>Learning Rate Rewinding</strong>: Instead of rewinding the weight values <em>and</em> setting back the learning rate schedule, learning rate rewinding uses the final unpruned weight and <em>only</em> resets the learning rate schedule to iteration <span id="MathJax-Element-33-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span>.</li>
</ol>

<p><a href="#renda_2020">Renda et al. (2020)</a> contrast gains and losses of the three methods in terms of accuracy, search cost and parameter-efficiency. They answer the following questions:</p>

<ul>
  <li>
    <p>Given an unlimited budget to spend on search cost, how do final accuracy and parameter efficiency (compression ratio pre/post pruning) behave for the 3 methods?</p>
  </li>
  <li>
    <p>Given a fixed budget to spend on search cost, how do all 3 methods compare in terms of accuracy and parameter efficiency?</p>
  </li>
</ul>

<p>Experiments on Resnet-34/50/56 and the natural language benchmark GNMT reveal the following insights:</p>

<ol>
  <li>Weight rewinding and retraining outperforms simple fine-tuning and retraining in both unlimited and fixed budget experiments. The same holds when comparing structured and unstructured pruning.</li>
  <li>Learning rate rewinding outperforms weight rewinding. Furthermore, while weight rewinding can fail for <span id="MathJax-Element-34-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>=</mo><mn>0</mn></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>=</mo><mn>0</mn></math></span></span>, it is almost always beneficial to rewind the learning rate to the beginning of the training procedure.</li>
  <li>Weight rewinding LTH networks is the SOTA method for pruning at initialisation in terms of accuracy, compression and search cost efficiency.</li>
</ol>

<p>As with many empirical insights into Deep Learning which are generated by large-scale experiments there remains one daunting question: <em>What does this actually tell us about these highly non-linear systems we are trying to understand?</em></p>


<h2 id="zhou-lan-liu--yosinski-2019---deconstructing-lottery-tickets-zeros-signs-and-the-supermask">Zhou, Lan, Liu, &amp; Yosinski (2019) - Deconstructing lottery tickets: Zeros, signs, and the supermask</h2>
<h3 id="paper--code-3">
<a href="https://papers.nips.cc/paper/8618-deconstructing-lottery-tickets-zeros-signs-and-the-supermask.pdf">Paper</a> | <a href="https://github.com/uber-research/deconstructing-lottery-tickets">Code</a>
</h3>

<p>What are the main ingredients that determine whether an initialization is a winning ticket or not? It appears to be the combination of the masking criterion (magnitude of the weights), the rewinding of the non-masked weights, and the masking that sets weights to zero and freezes them. But what if we change any one of these 3 ingredients? What is special about large weights? Do other alternative rewinding strategies preserve winning tickets? And why set weights to zero? <a href="#zhou_2019">Zhou, Lan, Liu, &amp; Yosinski (2019)</a> investigate these questions in 3 ways:</p>

<ul>
  <li>
<strong>By comparing different scoring measures to select which weights to mask.</strong> Keeping the smallest trained weights, keeping the largest/smallest weights at initialisation, or the magnitude change/movement in weight space.</li>
  <li>
<strong>By analyzing if one still obtains winning tickets when rewinding weights not to their original initialization.</strong> They compare random reinitialisation, reshuffling of kept weights and a constant initialisation.</li>
  <li><strong>By freezing masked weights not to the value of 0 but to their initialisation value.</strong></li>
</ul>

<p>The conclusions of extensive experiments are the following:</p>

<ol>
  <li>Other scoring criteria that maintain weights “alive” proportionately to their distance from the origin perform equally well as the ‘largest magnitude’ criterion.</li>
  <li>As long as one keeps the same sign as the original sign of the weights at initialisation when performing rewinding, one can obtain lottery tickets that perform on par with the classical IMP formulation (<em>Note</em>: This finding could later not be replicated by <a href="#frankle_2020b">Frankle et al. (2020b)</a>).</li>
  <li>Masking weights to the value 0 is crucial.</li>
</ol>

<p>Based on these findings they postulate that <strong>‘informed’ masking can be viewed as a form of training</strong>: It simply accelerates the trajectory of weights which were already “heading” to zero during their optimization trajectory. Interestingly, a mask obtained from IMP applied to a randomly initialized network already (and without any additional training) yields performance that vastly outperforms a random mask and/or randomly initialized network. Hence, it is a form of <em>supermask</em> that <strong>encodes a strong inductive bias</strong>. This opens up an exciting perspective of not training network weights at all and instead simply finding the right mask. <a href="#zhou_2019">Zhou et al. (2019)</a> show that it is even possible to learn the mask by making it differentiable and training it with a REINFORCE-style loss. This idea very much reminds me of <a href="#gaier_2019">Gaier &amp; Ha’s (2019)</a> Weight Agnostic Neural Networks. A learned mask can be thought of as a connectivity pattern that encodes a solution regularity. By sampling weights multiple times to evaluate a mask, we essentially make it robust (or agnostic) to the sampled weights.</p>

<h2 id="frankle-dziugaite-roy--carbin-2020a---linear-mode-connectivity--the-lottery-ticket-hypothesis">Frankle, Dziugaite, Roy, &amp; Carbin (2020a) - Linear Mode Connectivity &amp; the Lottery Ticket Hypothesis</h2>
<h3 id="paper--code-4">
<a href="https://arxiv.org/abs/1912.05671">Paper</a> | <a href="https://github.com/facebookresearch/open_lth">Code</a>
</h3>

<p>When we train a neural network, we usually do so on a random ordering of data batches. Each batch is used to evaluate a gradient of the loss with respect to the network parameters. After a full loop over the dataset (aka an epoch) the batches are usually shuffled and we continue with the next epoch. The sequence of batches can be viewed as a source of noise which we inject into the training procedure. Depending on it, we might obtain very different final weights, but ideally our network training procedure is somewhat robust to such noise. More formally, we can think of single weight initialization <span id="MathJax-Element-35-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>W</mi><mn>0</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>W</mi><mn>0</mn></msub></math></span></span> which we train on two different batch orders to obtain the trained weights <span id="MathJax-Element-36-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>W</mi><mi>T</mi><mn>1</mn></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>W</mi><mi>T</mi><mn>1</mn></msubsup></math></span></span> and <span id="MathJax-Element-37-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msubsup><mi>W</mi><mi>T</mi><mn>2</mn></msubsup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>W</mi><mi>T</mi><mn>2</mn></msubsup></math></span></span>. Linear mode connectivity analysis <a href="#frankle_2020b">(Frankle, Dziugaite, Roy, &amp; Carbin, 2020a)</a>  asks the following question: <strong>How does the validation/test accuracy behave if we smoothly interpolate (convex combination) between these two final weight configurations resulting from the different data orders?</strong></p>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/mode_connectivity.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/mode_connectivity.png">
</a></p>
<center><p>
<em>Fig. 7: Linear Mode Connectivity. Source: <a href="https://arxiv.org/abs/1912.05671">Frankle et al. (2020a)</a></em>
</p></center>

<p>A network is referred to as stable if the error does not increase significantly as we interpolate between the two final weights. Furthermore, we can train <span id="MathJax-Element-38-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>W</mi><mn>0</mn></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>W</mi><mn>0</mn></msub></math></span></span> to <span id="MathJax-Element-39-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>W</mi><mi>k</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>W</mi><mi>k</mi></msub></math></span></span> on a single shared data ordering and only later split the training into two separate data orders. For which <span id="MathJax-Element-40-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> does the network then become stable? Trivially, this is the case for <span id="MathJax-Element-41-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>=</mo><mi>T</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>=</mo><mi>T</mi></math></span></span>, but what about earlier ones? As it turns out this is related to the iteration to which we have to rewind in order to obtain a matching ticket initialisation.</p>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_3.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_3.png"></a></p>
<center><p>
<em>Fig. 8: Linear Mode Connectivity key results. Source: Adapted from <a href="https://arxiv.org/abs/1912.05671">Frankle et al. (2020a)</a></em>
</p></center>

<ul>
  <li>
    <p><strong>Panel A</strong>: No tickets for now, just take a look at when the network becomes interpolation-stable to different data orderings. For LeNet this is already the case at initialization. For Resnet-20 this stability arises only later on in training. Isn’t this reminiscent of the rewinding iteration?</p>
  </li>
  <li>
    <p><strong>Panel B</strong>: Iterative magnitude pruning can induce stability. But this only works in combination with the learning rate schedule trick when rewinding to <span id="MathJax-Element-42-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>=</mo><mn>0</mn></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>=</mo><mn>0</mn></math></span></span>.</p>
  </li>
  <li>
    <p><strong>Panel C</strong>: There appear to be 3 regimes of parametrization which we move into by pruning more and more weights (focus on the blue line):</p>
    <ul>
      <li>
<em>Regime I</em>: The network is strongly overparametrized so that even random pruning still results in good performance.</li>
      <li>
<em>Regime II</em>: As we increase the percentage of pruned weights only IMP yields matching <em>and</em> stable tickets/networks.</li>
      <li>
<em>Regime III</em>: While IMP is still able to yield stable networks at severe sparsity, the resulting networks are no longer matching.</li>
    </ul>
  </li>
</ul>

<p>This is an example of how lottery tickets have been used to reveal characteristics of learning dynamics. Another more fine-grained analysis of different learning phases is given by the next paper:</p>

<h2 id="frankle-schwab--morcos-2020---the-early-phase-of-neural-network-training">Frankle, Schwab, &amp; Morcos (2020) - The Early Phase of Neural Network Training</h2>
<h3 id="paper--code-5">
<a href="https://openreview.net/forum?id=Hkl1iRNFwS">Paper</a> | <a href="https://github.com/facebookresearch/open_lth">Code</a>
</h3>

<p>So far we have seen that only a few training iterations (or epochs on Resnet) result in data-order robustness as well as the ability to obtain matching tickets when rewinding. A more general follow-up question is: How robust are these matching ticket initializations? How much can we wiggle and perturb the initialization before we loose the magical power? And how does this change with <span id="MathJax-Element-43-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span>?</p>

<p>In order to study the emergence of robustness <a href="#frankle_2020a">Frankle et al. (2020b)</a> performed permutation experiments using Resnet-20 on CIFAR-10. The protocol goes as follows: Derive a matching ticket using IMP with rewinding. Afterwards, perform a  perturbation to the matching ticket and train until convergence. The permutations include:</p>

<ul>
  <li>
<em>Setting the weights to the signs and/or magnitudes of iteration 0 or <span id="MathJax-Element-44-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span></em> (see <strong>panel A</strong>). Any permutation (sign or magnitude - ‘init’) hurts performance at high levels of sparsity. At low levels, on the other hand, the IMP-derived network appears to be robust to sign-flips. The same qualitative result holds for rewinding to <span id="MathJax-Element-45-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>=</mo><mn>2000</mn></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>=</mo><mn>2000</mn></math></span></span> (see figure 4 of <a href="#frankle_2020a">Frankle et al. (2020b)</a>).</li>
  <li>
<em>Permute the weights at iteration <span id="MathJax-Element-46-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> with structural sub-components of the net</em> (see <strong>panel B</strong>). This includes exchanging weights of the network globally (across layers), locally (within a layer) and within a given filter. The matching ticket is not robust to any of the perturbations and performance decreases to the level of rewinding to iteration <span id="MathJax-Element-47-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>=</mo><mn>0</mn></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>=</mo><mn>0</mn></math></span></span> . <strong>Panel C</strong>, on the other hand, limits the effect of permutation by only exchanging weights which have the same sign. In this case the network is robust to within filter shuffles at all sparsity levels.</li>
  <li>
<em>Add Gaussian noise to the matching ticket weights</em> (see <strong>panel D</strong>): In order to assure the right scale of the added noise, <a href="#frankle_2020a">Frankle et al. (2020b)</a> calculate a layer-wise normalized standard deviation <span id="MathJax-Element-48-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C3;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>σ</mi></math></span></span> resulting from initialization distribution of the specific layer. The size of the effective standard deviation very much affects the final performance of the perturbed lottery ticket. Larger perturbations = worse performance.</li>
  <li>
<em>Pretraining of a dense/sparse network with different self-supervised losses</em> (<strong>panel E</strong>): The previous results are largely preserved when going from <span id="MathJax-Element-49-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>=</mo><mn>500</mn></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>=</mo><mn>500</mn></math></span></span> to <span id="MathJax-Element-50-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>=</mo><mn>2000</mn></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>=</mo><mn>2000</mn></math></span></span>. This is indicative that there are other forces than simply weight distribution properties and signs. Instead it appears that the magic lies in the actual training. Hence, <a href="#frankle_2020a">Frankle et al. (2020b)</a> asked whether the early phase adaptations depend on information in the conditional label distribution or whether unsupervised representation learning is sufficient. Training for a small number of epochs on random labels does close the gap compared to rewinding to iteration 0. But longer pre-training can eventually hurt the performance of the network. Finally, pre-training (non-ticket) sparse networks is not sufficient to overcome the ‘wrong’/hurtful pruning mask (<strong>panel F</strong>).</li>
</ul>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_early_phase_2.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_early_phase_2.png"></a></p>
<center><p>
<em>Fig. 9: Early Phase key results.  Source: Adapted from <a href="https://arxiv.org/pdf/2002.10365.pdf">Frankle et al. (2020b)</a></em>
</p></center>

<p>All in all, this provides evidence that it is very hard to overcome the necessity of using rewinding since the emergence of the matching initialization appears highly non-trivial. Self-supervised pre-training appears to provide a potential way to circumvent rewinding.
Further insights in the early learning dynamics in training Resnet-20 on CIFAR-10 are summarized in the following awesome visualization by <a href="#frankle_2020a">Frankle et al. (2020b)</a>:</p>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_early_phase_1.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_early_phase_1.png"></a></p>
<center><p>
<em>Fig. 10: The Early Phase of NN Training. Source: <a href="https://arxiv.org/pdf/2002.10365.pdf">Frankle et al. (2020b)</a></em>
</p></center>



<p>While the original work by Jonathan Frankle provides an empirical existence proof, finding tickets is tricky and costly. IMP requires repeated training of sparser and sparser networks, something not every PhD researcher can do (without being hated by their lab members <img title=":hugs:" alt=":hugs:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f917.png" height="20" width="20">). The natural next question becomes how one can identify such networks with less compute. Here are two recent approaches which attempt to do so:</p>

<h2 id="you-li-xu-fu-wang-chen-lin-wang--baraniuk-2020---drawing-early-bird-tickets-towards-more-efficient-training-of-deep-networks">You, Li, Xu, Fu, Wang, Chen, Lin, Wang, &amp; Baraniuk (2020) - Drawing Early-Bird Tickets: Towards more efficient training of deep networks</h2>
<h3 id="paper--code-6">
<a href="https://arxiv.org/abs/1909.11957">Paper</a> | <a href="https://github.com/RICE-EIC/Early-Bird-Tickets">Code</a>
</h3>

<p><a href="#you_2020">You, Li, Xu, Fu, Wang, Chen, Lin, Wang, &amp; Baraniuk (2020)</a> identify winning tickets early on in training (hence ‘early-bird’ tickets) using a low cost training scheme which combines early stopping, low precision and large learning rates. They argue that this is due to the two-phase nature of optimization trajectories of neural networks <a href="#saxe_2013">(Saxe et al., 2013; Rahaman et al., 2018)</a>:</p>

<ol>
  <li>A robust first phase of learning lower frequency/large singular value components.</li>
  <li>An absorbing phase of learning higher frequency/low singular value components.</li>
</ol>

<p>By focusing on only identifying a connectivity pattern it is possible to identify early-bird tickets already during phase 1. A major difference to standard LTH work is that <a href="#you_2020">You et al. (2020)</a> prune entire convolution channels based on their batch normalization scaling factor. Furthermore, pruning is performed iteratively within a single training run.</p>

<p>The authors empirically observe that the pruning masks change significantly during the first epochs of training but appear to converge soon (see left part of the figure below).</p>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/drawing-early-birds.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/drawing-early-birds.png"></a></p>
<center><p>
    <em>Fig. 14: Mask Convergence &amp; Early Bird Algorithm. Source: Adapted from <a href="https://arxiv.org/abs/1909.11957">You et al. (2020)</a></em>
</p></center>

<p>Hence, they conclude that hypothesis of early emergence is true and formulate a suited detection algorithm: To detect the early emergence they propose a mask distance metric that computes the Hamming distance between two pruning masks at two consecutive pruning iterations. If the distance is smaller than a threshold <span id="MathJax-Element-51-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03F5;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>ϵ</mi></math></span></span>, they stop to prune. The resulting early-bird ticket can then simply be retrained to restore performance.</p>

<h2 id="tanaka-kunin-yamins--ganguli-2020---pruning-neural-networks-without-any-data-by-iteratively-conserving-synaptic-flow">Tanaka, Kunin, Yamins, &amp; Ganguli (2020) - Pruning neural networks without any data by iteratively conserving synaptic flow</h2>
<h3 id="paper--code-7">
<a href="https://arxiv.org/abs/2006.05467">Paper</a> | <a href="https://github.com/ganguli-lab/Synaptic-Flow">Code</a>
</h3>

<p>While <a href="#you_2020">You et al. (2020)</a> asked whether it is possible to reduce the amount of required computation, they still need to train the model on the data. <a href="#tanaka_2020">Tanaka et al. (2020)</a>, on the other hand, answer a more ambitious question: Can we obtain winning tickets without any training and in the absence of any data? They argue that the biggest challenge to pruning at initialisation is the problem of <strong>layer collapse</strong> - the over-eagerly pruning of an entire layer which renders the architecture untrainable (since the gradient flow is cut-off).</p>

<p>Think of an MLP that stacks a set of fully-connected layers. Layer collapse can be avoided by keeping a single weight per layer which corresponds to the theoretically achievable <strong>maximal compression</strong>. The level of compression which can be achieved by a pruning algorithm without collapse is called the <strong>critical compression</strong>. Ideally, we would like these two to be equal. Taking inspiration from flow networks, <a href="#tanaka_2020">Tanaka et al. (2020)</a> define a gradient-based score called <strong>synaptic saliency</strong>:</p>

<span><span id="MathJax-Element-52-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtable displaystyle=&quot;true&quot;><mlabeledtr><mtd id=&quot;mjx-eqn-1&quot;><mtext>(1)</mtext></mtd><mtd><mi>S</mi><mo stretchy=&quot;false&quot;>(</mo><mi>&amp;#x03B8;</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mfrac><mrow><mi mathvariant=&quot;normal&quot;>&amp;#x2202;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi class=&quot;MJX-tex-caligraphic&quot; mathvariant=&quot;script&quot;>R</mi></mrow></mrow><mrow><mi mathvariant=&quot;normal&quot;>&amp;#x2202;</mi><mi>&amp;#x03B8;</mi></mrow></mfrac><mo>&amp;#x2218;</mo><mi>&amp;#x03B8;</mi></mtd></mlabeledtr></mtable></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true"><mlabeledtr><mtd id="mjx-eqn-1"><mtext>(1)</mtext></mtd><mtd><mi>S</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mrow><mi mathvariant="script">R</mi></mrow></mrow><mrow><mi mathvariant="normal">∂</mi><mi>θ</mi></mrow></mfrac><mo>∘</mo><mi>θ</mi></mtd></mlabeledtr></mtable></math></span></span></span>

<p>where <span id="MathJax-Element-53-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi class=&quot;MJX-tex-caligraphic&quot; mathvariant=&quot;script&quot;>R</mi></mrow></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">R</mi></mrow></math></span></span>, <span id="MathJax-Element-54-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B8;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>θ</mi></math></span></span> and <span id="MathJax-Element-55-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2218;</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>∘</mo></math></span></span> refer to a flow objective, the parameters and the Hadamard product, respectively. This metric is somewhat related to layerwise relevance propagation and measures a form of contribution. The paper then proves two conservation laws of saliency on a “micro”-neuron and “macro”-network level. This allows the authors to show that - for sufficient compression - gradient-based methods will prune large layers entirely (if evaluated once). So why don’t we run into layer collapse in the IMP setting with training? <a href="#tanaka_2020">Tanaka et al. (2020)</a> show that this is due to gradient descent encouraging layer-wise conservation as well as iterative pruning at small rates. So any global pruning algorithm that wants to a maximal critical compression has to respect two things: positively score layer-wise conservation and iteratively re-evaluate the scores after pruning.</p>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/synaptic-flow.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/synaptic-flow.png"></a></p>
<center><p>
    <em>Fig. 15: Performance &amp; Synaptic Flow Algorithm. Source: Adapted from <a href="https://arxiv.org/abs/2006.05467">Tanaka et al. (2020)</a></em>
</p></center>

<p>Based on these observations the authors define an iterative procedure which generates a mask that preserves the flow of synaptic strengths through the initialized network (see above). Most importantly this procedure is entirely data-agnostic and only requires a random initialization. They are able to outperform other ‘pruning at init’ baselines on CIFAR-10/100 and Tiny ImageNet. I really enjoyed reading this paper since it exploits a theoretical result by turning it into an actionable algorithm.</p>


<h2 id="morcos-yu-paganini--tian-2019---one-ticket-to-win-them-all-generalizing-lottery-ticket-initializations-across-datasets-and-optimizers">Morcos, Yu, Paganini &amp; Tian (2019) - One ticket to win them all: Generalizing lottery ticket initializations across datasets and optimizers</h2>
<h3 id="paper--code-8">
<a href="https://arxiv.org/abs/1906.02773">Paper</a> | <a href="https://github.com/varungohil/Generalizing-Lottery-Tickets">Code</a>
</h3>

<p>A key question is whether matching tickets overfit. What does overfitting mean in the context of subnet initialization? The ticket is generated on a specific dataset (e.g. MNIST, CIFAR-10/0, ImageNet), with a specific optimizer (SGD, Adam, RMSprop), for a specific domain (vision) and a specific task (object classification). It is not obvious if a ticket would still be a winner if we would change any one of these ingredients. But what we are really interested in is to find the <strong>right inductive biases for learning</strong> - in a general sense.</p>

<p>Therefore, <a href="#morcos_2019">Morcos, Yu, Paganini &amp; Tian (2019)</a> asked whether one could identify a matching ticket on one vision dataset (e.g. ImageNet) and transfer it to another (e.g. CIFAR-100). The key question being whether the lottery ticket effect would hold up after training the matching ticket on the new dataset. The procedure goes as follows:</p>

<ol>
  <li>Find a lottery ticket on a <em>source</em> dataset using IMP.</li>
  <li>Evaluate the source lottery ticket on a new <em>target</em> dataset by training it until convergence.</li>
</ol>

<p>So at this point you might ask yourself how do input/output shape work in this case? At least I did <img title=":smile:" alt=":smile:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png" height="20" width="20">. Since we operate on images and the first layer in the of considered networks case is a convolution, we don’t have to change anything about the first hidden layer transformation. Puh. At the stage of network processing where we transition from convolution to fully-connected (FC) layers, <a href="#morcos_2019">Morcos et al. (2019)</a> use <a href="https://www.quora.com/What-is-global-average-pooling">global average pooling</a> in order to make sure that regardless of the channel size (which is going to differ between datasets) the FC layer dimensions work out. Last but not least, the final layer has to be excluded from the lottery ticket transfer and is instead randomly initialized. This is because different datasets have different numbers of target classes. This procedure <em>is different from traditional transfer learning since we do not transfer representations (in the form of trained weights) but an initialization and mask found on a separate dataset</em>. So what do <a href="#morcos_2019">Morcos et al. (2019)</a> find?</p>

<ul>
  <li>
    <p><strong>Panel A</strong> and <strong>Panel B</strong>: Transferring VGG-19 tickets from a small source dataset to ImageNet performs well - but worse than a ticket that is directly inferred on the target dataset. Tickets inferred from a larger dataset than the target dataset, on the other hand, perform even better than the ones inferred from the target dataset.</p>
  </li>
  <li>
    <p><strong>Panel C</strong> and <strong>Panel D</strong>: Approximately the same holds for Resnet-50. But one can also observe that performance degrades already for smaller pruning fractions than Resnet-50 (sharper “pruning” cliff for Resnet-50 than VGG-19).</p>
  </li>
</ul>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_gen_dataset.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_gen_dataset.png"></a></p>
<center><p>
    <em>Fig. 11: Transfer of tickets across datasets. Source: Adapted from <a href="https://arxiv.org/abs/1906.02773">Morcos et al. (2019)</a></em>
</p></center>

<p>Finally, <a href="#morcos_2019">Morcos et al. (2019)</a> also investigated whether a ticket inferred with one optimizer transfers to another. And yes, this is possible for VGG-19 if one carefully tunes learning rates. Again this is indicative that lottery tickets encode inductive biases that are invariant across data and optimization procedure.</p>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_gen_optimizers.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_gen_optimizers.png"></a></p>
<center><p>
    <em>Fig. 12: Transfer of tickets across optimizers. Source: Adapted from <a href="https://arxiv.org/abs/1906.02773">Morcos et al. (2019)</a></em>
</p></center>

<p>So what? This highlights a huge potential for tickets as general inductive bias. One could imagine finding a robust matching ticket on a very large dataset (using lots of compute). This <em>universal ticket</em> can then flexibly act as an initializer for (potentially all/most) loosely domain-associated tasks. Tickets, thereby, could - similarly to the concept of meta-learning a weight initialisation - <em>perform a form of amortized search in weight initialization space</em>.</p>

<h2 id="yu-edunov-tian--morcos-2019---playing-the-lottery-with-rewards-and-multiple-languages-lottery-tickets-in-rl-and-nlp">Yu, Edunov, Tian, &amp; Morcos (2019) - Playing the lottery with rewards and multiple languages: lottery tickets in RL and NLP</h2>
<h3 id="paper"><a href="https://openreview.net/forum?id=S1xnXRVFwH">Paper</a></h3>

<p>Until now we have looked at subnetwork initialisations in the context computer vision tasks. How about different domains with non-cross-entropy-based loss functions? <a href="#yu_2019">(Yu, Edunov, Tian, &amp; Morcos, 2019)</a> investigate the extension to language models (LSTM-based and Transformer models) as well as the Reinforcement Learning (actor-critic methods) setting. There are several differences to the previous work in vision: First, we also prune other types of layers aside from convolutional filters and FC layers (recurrent &amp; embedding layers and attention modules). Second, we train on very different loss surfaces (e.g. a non-stationary actor-critic loss). And finally, RL networks usually have a lot less parameters than large vision networks (especially for continuous control) which potentially makes it harder to prune at high levels of sparsity.</p>

<p><a href="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_language_rl.png" data-lightbox="1"><img src="https://roberttlange.github.io/images/blog_posts_2020/05_Lottery_Tickets/lth_language_rl.png"></a></p>
<center><p>
    <em>Fig. 13: Tickets in Language Models &amp; RL. Source: Adapted from <a href="https://arxiv.org/pdf/1906.02768.pdf">Yu et al. (2019)</a></em>
</p></center>

<p>In short - yes, there exit sparse initializations which significantly outperform random subnetworks for both language as well as RL tasks. Most interestingly, the authors find that one is able to prune up to 2/3 of all transformer weights while still obtaining strong performance. Late rewinding and iterative pruning are again key and embedding layers seem to be very overparametrized. Therefore, they are mainly targeted by IMP. For RL, on the other hand, well-performing pruning levels strongly varied across all considered games. This indicates that for some tasks standard CNN-based actor-critic networks have way too many parameters. This is most likely a function of RL benchmarks consisting of many games which are all being learned by the same architecture setup.</p>



<p>The lottery ticket hypothesis opens up many different views on topics such as optimization, initialisation, expressivity vs. trainability and the role of sparsity/over-parametrization. At the current point in time there are way more unanswered than answered questions - and that is what excites me! Here are a few of the top of my head:</p>

<ul>
  <li>
    <p>What are efficient initialisation schemes that evoke lottery tickets? Can meta-learning yield such winning ticket initialisation schemes (in compute wonderland)? Is it possible to formalise optimisation algorithms that exploit lottery tickets? Can the effects of connectivity and weight initialisation be disentangled? Can winning tickets be regarded as inductive biases?</p>
  </li>
  <li>
    <p>A network that has been initialized with weights that were pretrained on only half of the training data, the final network (trained on the full dataset) <strong>always</strong> yields a generalization gap <a href="#ash_2019">(Ash &amp; Adams, 2019)</a>. In other words - pretraining on a subset of the data generalizes worse than training from a random initialisation. Can lottery tickets overcome this warm starting problem? This should be an easy extension to investigate following <a href="#morcos_2019">Morcos et al. (2019)</a>.</p>
  </li>
  <li>
    <p>In which way do lottery tickets differ between domains (vision, language, RL) and tasks (classification, regression, etc.)? Are the differences a function of the loss surface and can we extract regularities simply from the masks?</p>
  </li>
</ul>

<p>All in all there is still a lot to discover and many lotteries to be won <img title=":game_die:" alt=":game_die:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f3b2.png" height="20" width="20">.</p>

<h2 id="some-final-pointers--acknowledgements">Some Final Pointers &amp; Acknowledgements</h2>

<blockquote>
  <p>I would like to thank <a href="https://twitter.com/jefrankle">Jonathan Frankle</a> for valuable feedback, pointers &amp; the open-sourcing of the entire LTH code base (see the <a href="https://github.com/facebookresearch/open_lth">open_lth repository</a>). Furthermore, a big shout out goes to <a href="https://twitter.com/joram_keijser">Joram Keijser</a> and <a href="https://twitter.com/FlorinGogianu">Florin Gogianu</a> who made this blogpost readable <img title=":hugs:" alt=":hugs:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f917.png" height="20" width="20"></p>
</blockquote>

<p>If you still can’t get enough of the LTH, these pointers are worth checking out:</p>

<ul>
  <li>Jonathan Frankle’s <a href="https://www.youtube.com/watch?v=s7DqRZVvRiQ">ICLR Best Paper Award Talk</a> - great 10 minute introduction of the key ideas and results with very digestible slides!</li>
  <li>Ari Morcos’ <a href="https://www.youtube.com/watch?v=oOgbHpjTwwA">RE-WORK talk</a> on generalising tickets across datasets.</li>
  <li>Jonathan Frankle’s <a href="https://ml-retrospectives.github.io/neurips2019/accepted_retrospectives/2019/lottery-ticket/">contribution to the NeurIPS 2019 retrospectives in ML workshop</a> &amp; the <a href="https://slideslive.com/38923503/retrospective-lightning-talks">accompanying personal story</a> (beginning at 12:30 minutes)</li>
  <li>I recommend everyone to have a look at the evolution of the original paper and the different versions of the <a href="https://arxiv.org/abs/1803.03635">ArXiv preprint</a>. Especially for a researcher at the beginning of their path, it was really enlightening to see the trajectory and scaling based on more and more powerful hypothesis testing.</li>
  <li>If you are interested in some maths and have an affinity for concentration inequalities, check out <a href="#malach_2020">Malach et al. (2020)</a>. They formally prove the LTH as well as posit an even stronger conjecture: Given a large enough dense network there exists an subnetwork that achieves matching performance <em>without any additional training</em>.</li>
  <li>Checkout this <a href="https://github.com/he-y/Awesome-Pruning">GitHub repository</a> with tons of recent (and not so recent) pruning papers.</li>
</ul>

<hr>
<p>You can find a pdf version of this blog post <a href="https://github.com/RobertTLange/code-and-blog/blob/master/05_lottery_tickets/lange2020_lottery_ticket_hypothesis.pdf">here</a>. If you use this blog in your scientific work, please cite it as:</p>

<div><div><pre><code>@article{lange2020_lottery_ticket_hypothesis,
  title   = "The Lottery Ticket Hypothesis: A Survey",
  author  = "Lange, Robert Tjarko",
  journal = "https://roberttlange.github.io/year-archive/posts/2020/06/lottery-ticket-hypothesis/",
  year    = "2020",
  url     = "https://roberttlange.github.io/posts/2020/06/lottery-ticket-hypothesis/"
}
</code></pre></div></div>



<ol>
<li><span id="ash_2019"><span>Ash, J. T., and R. P. Adams</span>. (2019): “On the Difficulty of Warm-Starting Neural Network Training,” <i>arXiv preprint arXiv:1910.08475</i>, .</span></li>
<li><span id="frankle_2019"><span>Frankle, J., and M. Carbin</span>. (2019): “The lottery ticket hypothesis: Finding sparse, trainable neural networks,” <i>arXiv preprint arXiv:1803.03635</i>, .</span></li>
<li><span id="frankle_2019b"><span>Frankle, J., G. K. Dziugaite, D. M. Roy, and M. Carbin</span>. (2019): “Stabilizing the lottery ticket hypothesis,” <i>arXiv preprint arXiv:1903.01611</i>, .</span></li>
<li><span id="frankle_2020a"><span>Frankle, J., D. J. Schwab, and A. S. Morcos</span>. (2020): “The Early Phase of Neural Network Training,” <i>arXiv preprint arXiv:2002.10365</i>, .</span></li>
<li><span id="frankle_2020b"><span>Frankle, J., G. K. Dziugaite, D. M. Roy, and M. Carbin</span>. (2020): “Linear Mode Connectivity and the Lottery Ticket Hypothesis,” <i>arXiv preprint arXiv:1912.05671</i>, .</span></li>
<li><span id="gale_2019"><span>Gale, T., E. Elsen, and S. Hooker</span>. (2019): “The state of sparsity in deep neural networks,” <i>arXiv preprint arXiv:1902.09574</i>, .</span></li>
<li><span id="gaier_2019"><span>Gaier, A., and D. Ha</span>. (2019): “Weight Agnostic Neural Networks,” <i>Advances in Neural Information Processing Systems</i>, .</span></li>
<li><span id="liu_2018"><span>Liu, Z., M. Sun, T. Zhou, G. Huang, and T. Darrell</span>. (2018): “Rethinking the value of network pruning,” <i>arXiv preprint arXiv:1810.05270</i>, .</span></li>
<li><span id="malach_2020"><span>Malach, E., G. Yehudai, S. Shalev-Shwartz, and O. Shamir</span>. (2020): “Proving the Lottery Ticket Hypothesis: Pruning is All You Need,” <i>arXiv preprint arXiv:2002.00585</i>, .</span></li>
<li><span id="morcos_2019"><span>Morcos, A., H. Yu, M. Paganini, and Y. Tian</span>. (2019): “One Ticket to Win Them All: Generalizing Lottery Ticket Initializations across Datasets and Optimizers,” <i>Advances in Neural Information Processing Systems</i>, .</span></li>
<li><span id="rahaman_2018"><span>Rahaman, N., A. Baratin, D. Arpit, F. Draxler, M. Lin, F. A. Hamprecht, Y. Bengio, and A. Courville</span>. (2018): “On the spectral bias of neural networks,” <i>arXiv preprint arXiv:1806.08734</i>, .</span></li>
<li><span id="renda_2020"><span>Renda, A., J. Frankle, and M. Carbin</span>. (2020): “Comparing rewinding and fine-tuning in neural network pruning,” <i>arXiv preprint arXiv:2003.02389</i>, .</span></li>
<li><span id="saxe_2013"><span>Saxe, A. M., J. L. McClelland, and S. Ganguli</span>. (2013): “Exact solutions to the nonlinear dynamics of learning in deep linear neural networks,” <i>arXiv preprint arXiv:1312.6120</i>, .</span></li>
<li><span id="tanaka_2020"><span>Tanaka, H., D. Kunin, D. L. K. Yamins, and S. Ganguli</span>. (2020): “Pruning neural networks without any data by iteratively conserving synaptic flow,” <i>arXiv preprint arXiv:2006.05467</i>, .</span></li>
<li><span id="you_2020"><span>You, H., C. Li, P. Xu, Y. Fu, Y. Wang, X. Chen, Y. Lin, Z. Wang, and R. G. Baraniuk</span>. (2020): “Drawing early-bird tickets: Towards more efficient training of deep networks,” <i>arXiv preprint arXiv:1909.11957</i>, .</span></li>
<li><span id="yu_2019"><span>Yu, H., S. Edunov, Y. Tian, and A. S. Morcos</span>. (2019): “Playing the lottery with rewards and multiple languages: lottery tickets in RL and NLP,” <i>arXiv preprint arXiv:1906.02768</i>, .</span></li>
<li><span id="zhou_2019"><span>Zhou, H., J. Lan, R. Liu, and J. Yosinski</span>. (2019): “Deconstructing Lottery Tickets: Zeros, Signs, and the Supermask,” <i>Advances in Neural Information Processing Systems</i>, .</span></li>
</ol>

        
      </section>

      

      



      


  

    </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>