<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Post title - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Post title - linksfor.dev(s)"/>
    <meta property="article:author" content="Erkin B Altunba&#x15F;"/>
    <meta property="og:description" content="Created:&#xA;          2020-07-15&#xA;          &#xA;          Updated:&#xA;          2020-07-16"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://erkin.party/blog/200715/evolution/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Post title</title>
<div class="readable">
        <h1>Post title</h1>
            <div>by Erkin B Altunba&#x15F;</div>
            <div>Reading time: 6-7 minutes</div>
        <div>Posted here: 16 Jul 2020</div>
        <p><a href="https://erkin.party/blog/200715/evolution/">https://erkin.party/blog/200715/evolution/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><article>
      <header>
        
        <p>
          <b>Created:</b>
          <time>2020-07-15</time>
          <br>
          <b>Updated:</b>
          <time>2020-07-16</time>
        </p>
        <hr>
        <a href="https://erkin.party/blog">← Back to index</a>
      </header>
      

      <p><code>;; Studying Scheme in university or reading The Little Schemer
<span>(</span>define factorial
  <span>(</span>lambda <span>(</span>n<span>)</span>
    <span>(</span>cond <span>(</span><span>(</span>= n 0<span>)</span> 1<span>)</span>
          <span>(</span>else <span>(</span>* <span>(</span>factorial <span>(</span>- n 1<span>)</span><span>)</span> n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>


;; Newbie programmer, enjoys recursion and simplicity in life
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>if <span>(</span>zero? n<span>)</span>
      1
      <span>(</span>* n <span>(</span>factorial <span>(</span>sub1 n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>


;; Hates functional programming and resents being taught Scheme in university
<span>(</span>define <span>(</span>return x<span>)</span> x<span>)</span>
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>define result 0<span>)</span>
  <span>(</span>do <span>(</span><span>(</span>counter 1 <span>(</span>add1 counter<span>)</span><span>)</span>
       <span>(</span>product 1 <span>(</span>* counter product<span>)</span><span>)</span><span>)</span>
      <span>(</span><span>(</span>&gt; counter <span>(</span>add1 n<span>)</span><span>)</span><span>)</span>
    <span>(</span>set! result product<span>)</span><span>)</span>
  <span>(</span>return result<span>)</span><span>)</span>


;; SICP reader, appreciates helper procedures and understands the power of tail calls
<span>(</span>define <span>(</span>fact-iter product counter max-count<span>)</span>
  <span>(</span>if <span>(</span>&gt; counter max-count<span>)</span>
      product
      <span>(</span>fact-iter <span>(</span>* counter product<span>)</span>
                 <span>(</span>add1 counter<span>)</span>
                 max-count<span>)</span><span>)</span><span>)</span>
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>fact-iter 1 1 n<span>)</span><span>)</span>


;; Astute SICP reader, doesn't want to clutter the namespace
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>define <span>(</span>fact-aux product counter<span>)</span>
    <span>(</span>if <span>(</span>&gt; counter n<span>)</span>
        product
        <span>(</span>fact-iter <span>(</span>* counter product<span>)</span>
                   <span>(</span>add1 counter<span>)</span><span>)</span><span>)</span><span>)</span>
  <span>(</span>fact-aux 1 1 n<span>)</span><span>)</span>


;; Adept programmer, getting a hang of the idioms
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>let loop <span>(</span><span>(</span>product 1<span>)</span> <span>(</span>counter 1<span>)</span><span>)</span>
    <span>(</span>if <span>(</span>&gt; counter n<span>)</span>
        product
        <span>(</span>loop <span>(</span>* counter product<span>)</span>
              <span>(</span>add1 counter<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>


;; Came from a different functional language, sees patterns everywhere
<span>(</span>define factorial
  <span>(</span>match-lambda
   <span>(</span>0 1<span>)</span>
   <span>(</span>n <span>(</span>* n <span>(</span>factorial <span>(</span>sub1 n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>


;; Really likes lists, carries around their own 300 line file of helper procedures
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>apply * <span>(</span>build-list n add1<span>)</span><span>)</span><span>)</span>


;; Discovering different functional approaches and came across SRFI-1
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>fold * 1 <span>(</span>iota 1 <span>(</span>add1 n<span>)</span><span>)</span><span>)</span><span>)</span>


;; Eagerly believes that the ideal solution can always be found in an SRFI
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>product-ec <span>(</span>: i 1 <span>(</span>add1 n<span>)</span><span>)</span> i<span>)</span><span>)</span>


;; Spoilt by Racket's macros
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>for/product <span>(</span><span>(</span>i <span>(</span>in-range 1 <span>(</span>add1 n<span>)</span><span>)</span><span>)</span><span>)</span> i<span>)</span><span>)</span>


;; Heard about the Y-combinator and went down a rabbithole
<span>(</span>define factorial
  <span>(</span><span>(</span>λ <span>(</span>f<span>)</span>
     <span>(</span><span>(</span>λ <span>(</span>g<span>)</span>
        <span>(</span>f <span>(</span>λ <span>(</span>x<span>)</span>
             <span>(</span><span>(</span>g g<span>)</span> x<span>)</span><span>)</span><span>)</span><span>)</span>
      <span>(</span>λ <span>(</span>g<span>)</span>
        <span>(</span>f <span>(</span>λ <span>(</span>x<span>)</span>
             <span>(</span><span>(</span>g g<span>)</span> x<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
   <span>(</span>λ <span>(</span>f<span>)</span>
     <span>(</span>λ <span>(</span>n<span>)</span>
       <span>(</span>if <span>(</span>zero? n<span>)</span>
           1
           <span>(</span>* n <span>(</span>f <span>(</span>sub1 n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>


;; Spent an idle weekend learning about Peano numerals and combinatory logic
;; Will forget about it all in a week and all this will become unreadable in two days
<span>(</span>define Ω <span>(</span>λ <span>(</span>f<span>)</span> <span>(</span>f f<span>)</span><span>)</span><span>)</span>
<span>(</span>define S <span>(</span>λ <span>(</span>f<span>)</span> <span>(</span>λ <span>(</span>g<span>)</span> <span>(</span>λ <span>(</span>x<span>)</span> <span>(</span><span>(</span>f x<span>)</span> <span>(</span>g x<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define K <span>(</span>λ <span>(</span>x<span>)</span> <span>(</span>λ <span>(</span>y<span>)</span> x<span>)</span><span>)</span><span>)</span>
<span>(</span>define ι <span>(</span>λ <span>(</span>x<span>)</span> <span>(</span>x <span>(</span>S K<span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define I <span>(</span>Ω ι<span>)</span><span>)</span>
<span>(</span>define Z <span>(</span>λ <span>(</span>f<span>)</span> <span>(</span>Ω <span>(</span>λ <span>(</span>x<span>)</span> <span>(</span>f <span>(</span>v<span>)</span> <span>(</span><span>(</span>Ω x<span>)</span> v<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define true <span>(</span>λ <span>(</span>a<span>)</span> <span>(</span>λ <span>(</span>b<span>)</span> a<span>)</span><span>)</span><span>)</span>
<span>(</span>define false <span>(</span>λ <span>(</span>a<span>)</span> <span>(</span>λ <span>(</span>b<span>)</span> b<span>)</span><span>)</span><span>)</span>
<span>(</span>define if <span>(</span>λ <span>(</span>p<span>)</span> <span>(</span>λ <span>(</span>a<span>)</span> <span>(</span>λ <span>(</span>b<span>)</span> <span>(</span><span>(</span>p a<span>)</span> b<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define and <span>(</span>λ <span>(</span>p<span>)</span> <span>(</span>λ <span>(</span>q<span>)</span> <span>(</span><span>(</span>p q<span>)</span> p<span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define zero <span>(</span>λ <span>(</span>f<span>)</span> <span>(</span>λ <span>(</span>x<span>)</span> x<span>)</span><span>)</span><span>)</span>
<span>(</span>define add1 <span>(</span>λ <span>(</span>n<span>)</span> <span>(</span>λ <span>(</span>f<span>)</span> <span>(</span>λ <span>(</span>x<span>)</span> <span>(</span>f <span>(</span><span>(</span>n f<span>)</span> x<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define sub1 <span>(</span>λ <span>(</span>n<span>)</span> <span>(</span>λ <span>(</span>f<span>)</span> <span>(</span>λ <span>(</span>x<span>)</span> <span>(</span><span>(</span><span>(</span>n <span>(</span>λ <span>(</span>g<span>)</span> <span>(</span>λ <span>(</span>h<span>)</span> <span>(</span>h <span>(</span>g f<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span> <span>(</span>λ <span>(</span>u<span>)</span> x<span>)</span><span>)</span> I<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define + <span>(</span>λ <span>(</span>m<span>)</span> <span>(</span>λ <span>(</span>n<span>)</span> <span>(</span>n <span>(</span>add1 m<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define * <span>(</span>λ <span>(</span>m<span>)</span> <span>(</span>λ <span>(</span>n<span>)</span> <span>(</span>λ <span>(</span>f<span>)</span> <span>(</span>m <span>(</span>n f<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define zero? <span>(</span>λ <span>(</span>n<span>)</span> <span>(</span><span>(</span>n <span>(</span>λ <span>(</span>x<span>)</span> false<span>)</span><span>)</span> true<span>)</span><span>)</span><span>)</span>
<span>(</span>define &lt;= <span>(</span>λ <span>(</span>m<span>)</span> <span>(</span>λ <span>(</span>n<span>)</span> <span>(</span>zero? <span>(</span><span>(</span>- m<span>)</span> n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define = <span>(</span>λ <span>(</span>m<span>)</span> <span>(</span>λ <span>(</span>n<span>)</span> <span>(</span><span>(</span>and <span>(</span><span>(</span>&lt;= m<span>)</span> n<span>)</span><span>)</span> <span>(</span><span>(</span>&lt;= n<span>)</span> m<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define factorial
  <span>(</span>λ <span>(</span>x<span>)</span>
    <span>(</span><span>(</span>Z <span>(</span>λ <span>(</span>f<span>)</span>
          <span>(</span>λ <span>(</span>n<span>)</span>
            <span>(</span><span>(</span><span>(</span>if <span>(</span>zero? n<span>)</span><span>)</span> <span>(</span>add1 zero<span>)</span><span>)</span> <span>(</span><span>(</span>* n<span>)</span> <span>(</span>f <span>(</span>sub1 n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span> x<span>)</span><span>)</span><span>)</span> 


;; Gone mad with power after discovering macros, likes -funroll-loops
<span>(</span>define-syntax factorial
  <span>(</span>lambda <span>(</span>stx<span>)</span>
    <span>(</span>syntax-case stx <span>(</span><span>)</span>
      <span>(</span><span>(</span>_ 0<span>)</span> #'1<span>)</span>
      <span>(</span><span>(</span>_ n<span>)</span> #`<span>(</span>* n <span>(</span>factorial
                     #,<span>(</span>sub1 <span>(</span>syntax-&gt;datum #'n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>


;; Feels enlightened after learning about CPS but doesn't know what to do with this information
<span>(</span>define <span>(</span>fact-cont n k<span>)</span>
  <span>(</span>if <span>(</span>= n 1<span>)</span>
      <span>(</span>k 1<span>)</span>
      <span>(</span>fact-cont <span>(</span>sub1 n<span>)</span>
                 <span>(</span>lambda <span>(</span>x<span>)</span>
                   <span>(</span>k <span>(</span>* n x<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>fact-cont n values<span>)</span><span>)</span>


;; Overjoyed to see first-class continuations in Scheme, still doesn't know what to do with them
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>letrec <span>(</span><span>(</span>f <span>(</span>lambda <span>(</span>n k<span>)</span>
                <span>(</span>if <span>(</span>= n 1<span>)</span>
                    <span>(</span>k 1<span>)</span>
                    <span>(</span>f <span>(</span>sub1 n<span>)</span>
                       <span>(</span>lambda <span>(</span>ret<span>)</span>
                         <span>(</span>k <span>(</span>* n ret<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
    <span>(</span>call-with-current-continuation
     <span>(</span>lambda <span>(</span>k<span>)</span>
       <span>(</span>f n k<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>


;; Attempted to make their CPS procedures simpler, failed
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>define retry #f<span>)</span>
  <span>(</span>if <span>(</span>= n 1<span>)</span>
      <span>(</span>call-with-current-continuation
       <span>(</span>lambda <span>(</span>k<span>)</span>
         <span>(</span>set! retry k<span>)</span> 1<span>)</span><span>)</span>
      <span>(</span>* n <span>(</span>factorial <span>(</span>sub1 n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>


;; Concerned about wasted performance, really likes the word 'amortised'
<span>(</span>define <span>(</span>memoise proc<span>)</span>
  <span>(</span>let <span>(</span><span>(</span>table <span>(</span>make-hashtable equal-hash equal?<span>)</span><span>)</span><span>)</span>
    <span>(</span>lambda args
      <span>(</span>hashtable-ref! table args <span>(</span>lambda <span>(</span><span>)</span> <span>(</span>apply proc args<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>define fact-iter
    <span>(</span>memoise
     <span>(</span>lambda <span>(</span>product counter<span>)</span>
       <span>(</span>if <span>(</span>&gt; counter n<span>)</span>
           product
           <span>(</span>fact-iter <span>(</span>* counter product<span>)</span>
                      <span>(</span>add1 counter<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
  <span>(</span>fact-iter 1 1<span>)</span><span>)</span>


;; Lazy programmer
<span>(</span>define-coroutine-generator <span>(</span>factorials<span>)</span>
  <span>(</span>let loop <span>(</span><span>(</span>product 1<span>)</span> <span>(</span>counter 1<span>)</span><span>)</span>
    <span>(</span>yield product<span>)</span>
    <span>(</span>loop <span>(</span>* product counter<span>)</span> <span>(</span>add1 counter<span>)</span><span>)</span><span>)</span><span>)</span>
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>car <span>(</span>generator-&gt;list <span>(</span>gindex factorials <span>(</span>generator n<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>


;; Lazier programmer
<span>(</span>define factorials <span>(</span>stream-scan * 1 <span>(</span>stream-from 1<span>)</span><span>)</span><span>)</span>
<span>(</span>define <span>(</span>factorial n<span>)</span>
  <span>(</span>stream-ref factorials n<span>)</span><span>)</span>


;; Laziest programmer
<span>(</span>define factorial
  <span>(</span>dynamic-require
   'math/number-theory
   'factorial
   <span>(</span>lambda <span>(</span><span>)</span>
     <span>(</span>lambda <span>(</span>n<span>)</span>
       <span>(</span>error 'factorial "Cannot import library: ~a" 'math/number-theory<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
</code></p>

      <p>Inspired by
	<a href="https://willamette.edu/~fruehr/haskell/evolution.html">The Evolution of a Haskell Programmer</a>.</p>
      <p>Some implementations taken from <a href="https://github.com/lwhjp">Leo Uino</a>'s
	<a href="https://gist.github.com/lwhjp/ba74b14f6a5eefa9c7fb">gist</a>.</p>
      <p>For a real-life implementation, see how Racket's
	<a href="https://docs.racket-lang.org/math/number-theory.html"><code>math/number-theory</code></a> does it
	<a href="https://github.com/racket/math/blob/master/math-lib/math/private/number-theory/factorial.rkt">here</a>.</p>
    </article></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>