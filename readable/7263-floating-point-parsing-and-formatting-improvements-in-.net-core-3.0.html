<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Floating-Point Parsing and Formatting improvements in .NET Core 3.0 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Floating-Point Parsing and Formatting improvements in .NET Core 3.0</h1><div><div class="entry-content col-12 sharepostcontent"><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://secure.gravatar.com/avatar/45d46131d8cd64c7fb83cba998b67c6f?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 photo avatar-default"><p>Tanner</p></div></div></div><p>March 5th, 2019</p><p class="code-line" data-line="2">Starting back with the .NET Core 2.1 release, we were making iterative improvements to the floating-point parsing and formatting code in .NET Core. Now, in .NET Core 3.0 Preview 3, we are nearing completion of this work and would like to share more details about these changes and some of the differences you might see in your applications.</p><p class="code-line" data-line="4">The primary goals of this work were to ensure correctness and standards compliance with <a title="https://en.wikipedia.org/wiki/IEEE_754-2008_revision" href="https://en.wikipedia.org/wiki/IEEE_754-2008_revision">IEEE 754-2008</a>. For those unfamiliar with the standard, it defines the underlying format, base operations, and behaviors for binary floating-point types such as <a title="https://docs.microsoft.com/en-us/dotnet/api/system.single?view=netcore-3.0" href="https://docs.microsoft.com/en-us/dotnet/api/system.single?view=netcore-3.0">System.Single</a> (<code>float</code>) and <a title="https://docs.microsoft.com/en-us/dotnet/api/system.double?view=netcore-3.0" href="https://docs.microsoft.com/en-us/dotnet/api/system.double?view=netcore-3.0">System.Double</a> (<code>double</code>). The majority of modern processors and programming languages support some version of this standard, so it is important to ensure it is implemented correctly. The standard does not impact the integer types, such as <a title="https://docs.microsoft.com/en-us/dotnet/api/system.int32?view=netcore-3.0" href="https://docs.microsoft.com/en-us/dotnet/api/system.int32?view=netcore-3.0">System.Int32</a> (<code>int</code>), nor does it impact the other floating-point types, such as <a title="https://docs.microsoft.com/en-us/dotnet/api/system.decimal?view=netcore-3.0" href="https://docs.microsoft.com/en-us/dotnet/api/system.decimal?view=netcore-3.0">System.Decimal</a> (<code>decimal</code>).</p><h2 id="initial-work" class="code-line" data-line="6">Initial Work</h2><p class="code-line" data-line="8">We started with parsing changes, as part of the .NET Core 2.1 release. Initially, this was just an attempt to fix a perf difference between Windows and Unix and was done by <a title="https://github.com/mazong1123" href="https://github.com/mazong1123">@mazong1123</a> in <a title="https://github.com/dotnet/coreclr/pull/12894" href="https://github.com/dotnet/coreclr/pull/12894">dotnet/coreclr#12894</a>, which implements the <a title="http://www.ryanjuckett.com/programming/printing-floating-point-numbers/" href="http://www.ryanjuckett.com/programming/printing-floating-point-numbers/">Dragon4</a> algorithm. <a title="https://github.com/mazong1123" href="https://github.com/mazong1123">@mazong1123</a> also made a follow up PR which improved perf even more by implementing the <a title="https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf" href="https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf">Grisu3</a> algorithm in <a title="https://github.com/dotnet/coreclr/pull/14646" href="https://github.com/dotnet/coreclr/pull/14646">dotnet/coreclr#14646</a>. However, in reviewing the code we determined that existing infrastructure had a number of issues that prevented us from always doing the right thing and that it would require significantly more work to make correct.</p><h2 id="porting-to-c" class="code-line" data-line="10">Porting to C#</h2><p class="code-line" data-line="12">The first step in fixing these underlying infrastructure issues was porting the code from native to managed. We did this work in <a title="https://github.com/dotnet/coreclr/pull/19999" href="https://github.com/dotnet/coreclr/pull/19999">dotnet/coreclr#19999</a> and <a title="https://github.com/dotnet/coreclr/pull/20080" href="https://github.com/dotnet/coreclr/pull/20080">dotnet/coreclr#20080</a>. The result was we made the code more portable, allowed it to be shared with the other frameworks/runtimes (such as Mono and CoreRT), made it possible to easily debug the code with the .NET Debugger, and made it available through SourceLink.</p><h2 id="making-the-parser-ieee-compliant" class="code-line" data-line="14">Making the parser IEEE compliant</h2><p class="code-line" data-line="16">We did some additional cleanup in <a title="https://github.com/dotnet/coreclr/pull/20619" href="https://github.com/dotnet/coreclr/pull/20619">dotnet/coreclr#20619</a> by removing various bits of duplicated code that was shared between the different parsers. Finally, we made the <code>double</code> and <code>float</code>&nbsp;parsing logic mostly IEEE compliant in <a title="https://github.com/dotnet/coreclr/pull/20707" href="https://github.com/dotnet/coreclr/pull/20707">dotnet/coreclr#20707</a> and this made available in the first .NET Core 3.0 Preview.</p><p class="code-line" data-line="18">These changes fixed three primary issues:</p><p class="code-line" data-line="23">The fixes ensured that <a title="https://docs.microsoft.com/en-us/dotnet/api/system.double.parse?view=netcore-3.0" href="https://docs.microsoft.com/en-us/dotnet/api/system.double.parse?view=netcore-3.0">double.Parse</a>/<a title="https://docs.microsoft.com/en-us/dotnet/api/system.single.parse?view=netcore-3.0" href="https://docs.microsoft.com/en-us/dotnet/api/system.single.parse?view=netcore-3.0">float.Parse</a> would return the same result as the C#, VB, or F# compiler for the corresponding literal value. Producing the same result as the language compilers is important for determinism of runtime and compile time expressions. Up until the change, this was not the case.</p><p class="code-line" data-line="25">To elaborate, every floating-point value requires between 1 and X significant digits (i.e. all digits that are not leading or trailing zeros) in order to roundtrip the value (that is, in order for <code>double.Parse(value.ToString())</code> to return exactly <code>value</code>). This is at most 17 digits for <code>double</code> and at most 9 digits for <code>float</code>. However, this only applies to strings that are first formatted from an existing floating-point value. When parsing from an arbitrary string, you may have to instead consider up to Y digits to ensure that you produce the “nearest” representable value. This is 768 digits for <code>double</code> and 113 digits for <code>float</code>. We have tests validating such strings parse correctly in <a title="https://github.com/dotnet/corefx/blob/master/src/Common/tests/System/RealParserTestsBase.netcoreapp.cs" href="https://github.com/dotnet/corefx/blob/master/src/Common/tests/System/RealParserTestsBase.netcoreapp.cs">RealParserTestsBase.netcoreapp.cs</a> and <a title="https://github.com/dotnet/corefx/pull/35701" href="https://github.com/dotnet/corefx/pull/35701">dotnet/corefx#35701</a>. More details on this can be found on Rick Regan’s <a title="https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/" href="https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/">Exploring Binary</a> blog.</p><p class="code-line" data-line="27">An example of such a string would be for <a title="https://docs.microsoft.com/en-us/dotnet/api/system.double.epsilon?view=netcore-3.0" href="https://docs.microsoft.com/en-us/dotnet/api/system.double.epsilon?view=netcore-3.0">double.Epsilon</a> (which is the smallest value that is greater than zero). The shortest roundtrippable string for this value is only <code>5e-324</code>, but the exact string (i.e. the string that contains all significant digits available in the underlying value) for this value is exactly 1074 digits long, which is comprised of 323 leading zeros and 751 significant digits. You then need one additional digit to ensure that the string is rounded in the correct direction (should it be exactly <code>double.Epsilon</code> or the smallest value that is greater than <code>double.Epsilon</code>).</p><p class="code-line" data-line="29">Some additional minor cleanup was done in <a title="https://github.com/dotnet/coreclr/pull/21036" href="https://github.com/dotnet/coreclr/pull/21036">dotnet/coreclr#21036</a> to ensure that the remaining compliance issues were resolved. These ended up mostly about ensuring we handle <code>Infinity</code>and <code>NaN</code> case-insensitively and that we allowed an optional preceding sign.</p><h2 id="making-the-formatter-ieee-754-2008-compliant" class="code-line" data-line="31">Making the formatter IEEE 754-2008 compliant</h2><p class="code-line" data-line="33">The formatting code required more significant changes and was primarily done in <a title="https://github.com/dotnet/coreclr/pull/22040" href="https://github.com/dotnet/coreclr/pull/22040">dotnet/coreclr#22040</a> with some followup work fixing some remaining issues in <a title="https://github.com/dotnet/coreclr/pull/22522" href="https://github.com/dotnet/coreclr/pull/22522">dotnet/coreclr#22522</a>.</p><p class="code-line" data-line="35">These changes fixed 5 primary issues:</p><p class="code-line" data-line="42">These changes are expected to have the largest potential impact to existing code.</p><p class="code-line" data-line="44">The summary of these changes is that (for <code>double</code>/<code>float</code>):</p><ul><li class="code-line" data-line="45"><code>ToString()</code>, <code>ToString("G")</code>, and <code>ToString("R")</code> will now return the shortest roundtrippable string. This ensures that users end up with something that just works by default. An example of where it was problematic was <code>Math.PI.ToString()</code> where the string that was previously being returned (for <code>ToString()</code> and <code>ToString("G")</code>) was <code>3.14159265358979</code>; instead, it should have returned <code>3.1415926535897931</code>. The previous result, when parsed, returned a value which was internally off by 7 ULP (units in last place) from the actual value of <a title="https://docs.microsoft.com/en-us/dotnet/api/system.math.pi?view=netcore-3.0" href="https://docs.microsoft.com/en-us/dotnet/api/system.math.pi?view=netcore-3.0">Math.PI</a>. This meant that it was very easy for users to get into a scenario where they would accidentally lose some precision on a floating-point value when the needed to serialize/deserialize it.</li><li class="code-line" data-line="46">For the <code>"G"</code> format specifier that takes a precision (e.g. <code>G3</code>), the precision specifier is now always respected. For <code>double</code> with precisions less than 15 (inclusive) and for <code>float</code> with precisions less than 6 (inclusive) this means you get the same string as before. For precisions greater than that, you will get up to that many significant digits, provided those digits are available (i.e. <code>(1.0).ToString("G17")</code> will still return <code>1</code> since the exact string only has one significant digit; but <code>Math.PI.ToString("G20")</code> will now return <code>3.141592653589793116</code>, since the exact string contains at least 20 significant digits).</li><li class="code-line" data-line="47">For the <code>"C"</code>, <code>"E"</code>, <code>"F"</code>, <code>"N"</code>, and <code>"P"</code> format specifiers the changes are similar. The difference is that these format specifiers treat the precision as the number of digits after the decimal point, in contrast to <code>"G"</code> which treats it as the number of significant digits. The previous implementation had a bug where, for strings that contained more than 15 significant digits, it would actually fill in the remaining digits with zero, regardless of whether they appeared before or after the decimal point. As an example, <code>(1844674407370955.25).ToString("F4")</code>would previously return <code>1844674407370960.0000</code>. The exact string, however, actually contains enough information to fill all the integral digits. With the changes made we instead fill out the available integral digits while still respecting the request for the 4 digits after the decimal point and instead return <code>1844674407370955.2500</code>.</li><li class="code-line" data-line="48">For custom format strings, they have the same behavior as before and will only print up to 15 significant digits, regardless of how many are requested. Fixing this to support an arbitrary number of digits would require more work to support and hasn’t been done at this time.</li></ul><h2 id="potential-impact-to-existing-code" class="code-line" data-line="50">Potential impact to existing code</h2><p class="code-line" data-line="52">When picking up .NET Core 3.0, it is expected that you may encounter some of the differences described in this post in your application or library code. The general recommendation is that the code be updated to handle these changes. However, this may not be possible in all cases and a workaround may be required. Focused testing for floating-point specific code is recommended.</p><p class="code-line" data-line="54">For differences in parsing, there is no mechanism to fallback to the old behavior. There were already differences across various operating systems (i.e. Linux, Windows, macOS, etc) and architectures (i.e. x86, x64, ARM, ARM64, etc). The new logic makes all of these consistent and ensures that the result returned is consistent with the corresponding language literal.</p><p class="code-line" data-line="56">For differences in formatting, you can get the equivalent behavior by:</p><ul><li class="code-line" data-line="57">For <code>ToString()</code> and <code>ToString("G")</code> you can use <code>G15</code> as the format specifier as this is what the previous logic would do internally.</li><li class="code-line" data-line="58">For <code>ToString("R")</code>, there is no mechanism to fallback to the old behavior. The previous behavior would first try “G15” and then using the internal buffer would see if it roundtrips; if that failed, it would instead return “G17”.</li><li class="code-line" data-line="59">For the <code>"G"</code> format-specifier that takes a precision, you can force precisions greater than 15 (exclusive) to be exactly 17. For example, if your code is doing <code>ToString("G20")</code> you can instead change this to <code>ToString("G17")</code>.</li><li class="code-line" data-line="60">For the remaining format-specifiers that take a precision (<code>"C"</code>, <code>"E"</code>, <code>"F"</code>, <code>"N"</code>, and <code>"P"</code>), there is no mechanism to fallback to the old behavior. The previous behavior would clamp precisions greater than 14 (exclusive) to be 17 for <code>"E"</code> and 15 for the others. However, this only impacted the significant digits that would be displayed, the remaining digits (even if available) would be filled in as zero.</li></ul><div class="authorinfoarea"><div><p>Software Engineer,&nbsp;.NET Team</p><p><strong>Follow Tanner</strong>&nbsp;&nbsp;&nbsp;<a class="no-underline stayinformed" aria-label="Tanner Gooding Twitter profile" target="_blank" href="https://twitter.com/tannergooding"></a><a class="no-underline stayinformed" aria-label="Tanner Gooding LinkedIn profile" target="_blank" href="https://www.linkedin.com/in/tanner-gooding-84b79054/"><i class="fa fa-linkedin"></i></a><a class="no-underline stayinformed" aria-label="Tanner Gooding GitHub profile" target="_blank" href="https://github.com/tannergooding"><i class="fa fa-github"></i></a><a class="no-underline stayinformed hvr-pop" aria-label="Tanner Gooding RSS Feed" target="_blank" href="https://devblogs.microsoft.com/dotnet/author/tagoomicrosoft-com/feed/"></a></p></div></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>