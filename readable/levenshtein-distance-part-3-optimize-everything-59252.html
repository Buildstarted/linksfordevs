<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Levenshtein Distance (Part 3: Optimize Everything!) - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Levenshtein Distance (Part 3: Optimize Everything!) - linksfor.dev(s)"/>
    <meta property="article:author" content="James Turner"/>
    <meta property="og:description" content="Less Allocations &amp; Smarter Processing. Tagged with algorithms, performance, csharp, dotnet."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://dev.to/turnerj/levenshtein-distance-part-3-optimize-everything-3o2j"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Levenshtein Distance (Part 3: Optimize Everything!)</title>
<div class="readable">
        <h1>Levenshtein Distance (Part 3: Optimize Everything!)</h1>
            <div>by James Turner</div>
            <div>Reading time: 24-30 minutes</div>
        <div>Posted here: 04 Mar 2020</div>
        <p><a href="https://dev.to/turnerj/levenshtein-distance-part-3-optimize-everything-3o2j">https://dev.to/turnerj/levenshtein-distance-part-3-optimize-everything-3o2j</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div data-article-id="257126" id="article-body" itemprop="articleBody">
        <p>In <a href="https://dev.to/turnerj/levenshtein-distance-part-1-what-is-it-4gbd">Part 1</a> we went through what the Levenshtein Distance is and in <a href="https://dev.to/turnerj/levenshtein-distance-part-2-gotta-go-fast-18bi">Part 2</a> we covered a few major optimizations for memory and performance. In Part 3 (this post) we will be taking things up to 11 and trying to squeeze every bit of performance out of our code.</p>

<p>While there are some aspects of this post that are language agnostic, this post will talk about a number of C# specific optimizations - there may be equivalent optimizations in your programming language of choice.</p>

<h2>
  <a name="being-smarter-with-data" href="#being-smarter-with-data">
  </a>
  Being Smarter with Data
</h2>

<p>In Part 2, one of our best versions had an inner loop that looked like this:<br>
</p>

<div><pre><code><span>for</span> <span>(</span><span>var</span> <span>i</span> <span>=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>source</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>i</span><span>)</span>
<span>{</span>
    <span>var</span> <span>previousDiagonal</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>];</span>
    <span>var</span> <span>previousColumn</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>]++;</span>

    <span>for</span> <span>(</span><span>var</span> <span>j</span> <span>=</span> <span>1</span><span>;</span> <span>j</span> <span>&lt;=</span> <span>target</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>j</span><span>)</span>
    <span>{</span>
        <span>var</span> <span>insertOrDelete</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>previousRow</span><span>[</span><span>j</span><span>])</span> <span>+</span> <span>1</span><span>;</span>
        <span>var</span> <span>edit</span> <span>=</span> <span>previousDiagonal</span> <span>+</span> <span>(</span><span>source</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>]</span> <span>==</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>]</span> <span>?</span> <span>0</span> <span>:</span> <span>1</span><span>);</span>

        <span>previousColumn</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>insertOrDelete</span><span>,</span> <span>edit</span><span>);</span>
        <span>previousDiagonal</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>previousRow</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>previousColumn</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div>


<p>If you look carefully at how we are accessing some of this data, we are doing some relatively repetitive actions - specifically, how we access the "source" character for the comparison.</p>

<p>Each iteration of the inner-loop, we are looking up <code>source[i - 1]</code> which we can actually cache in the body of the outer-loop like so:<br>
</p>
<div><pre><code><span>for</span> <span>(</span><span>var</span> <span>i</span> <span>=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>source</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>i</span><span>)</span>
<span>{</span>
    <span>var</span> <span>previousDiagonal</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>];</span>
    <span>var</span> <span>previousColumn</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>]++;</span>
    <span>var</span> <span>sourceChar</span> <span>=</span> <span>source</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>];</span>

    <span>for</span> <span>(</span><span>var</span> <span>j</span> <span>=</span> <span>1</span><span>;</span> <span>j</span> <span>&lt;=</span> <span>target</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>j</span><span>)</span>
    <span>{</span>
        <span>var</span> <span>insertOrDelete</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>previousRow</span><span>[</span><span>j</span><span>])</span> <span>+</span> <span>1</span><span>;</span>
        <span>var</span> <span>edit</span> <span>=</span> <span>previousDiagonal</span> <span>+</span> <span>(</span><span>sourceChar</span> <span>==</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>]</span> <span>?</span> <span>0</span> <span>:</span> <span>1</span><span>);</span>

        <span>previousColumn</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>insertOrDelete</span><span>,</span> <span>edit</span><span>);</span>
        <span>previousDiagonal</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>previousRow</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>previousColumn</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div>


<p>While it might not be the largest performance boost, we are in the territory where every little performance boost helps.</p>

<p>There is another way we can be smarter here by analysing that inner-most loop logic. We are always doing 2x <code>Math.Min</code> calls and always adding our source-target comparison to our <code>previousDiagonal</code> value. These might not be the slowest operations you can run but when you run them thousands of times, it does add up.</p>

<p>If you shift the code around just right, we can actually cut down the number of operations in one path of our code.<br>
</p>
<div><pre><code><span>for</span> <span>(</span><span>var</span> <span>i</span> <span>=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>source</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>i</span><span>)</span>
<span>{</span>
    <span>var</span> <span>previousDiagonal</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>];</span>
    <span>var</span> <span>previousColumn</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>]++;</span>
    <span>var</span> <span>sourceChar</span> <span>=</span> <span>source</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>];</span>

    <span>for</span> <span>(</span><span>var</span> <span>j</span> <span>=</span> <span>1</span><span>;</span> <span>j</span> <span>&lt;=</span> <span>target</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>j</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>==</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>previousColumn</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>}</span>
        <span>else</span>
        <span>{</span>
            <span>previousColumn</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>previousDiagonal</span><span>);</span>
            <span>previousColumn</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>previousRow</span><span>[</span><span>j</span><span>]);</span>
            <span>previousColumn</span><span>++;</span>
        <span>}</span>

        <span>previousDiagonal</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>previousRow</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>previousColumn</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div>


<p>This change plays on the fact that when the two characters are equal, the substitution cost (aka. <code>previousDiagonal</code>) will be the lowest cost of the three values to compare.</p>

<p>Going one step further, you might notice that one path actually has two calls to <code>previousRow[j]</code> - we can eliminate this too with more local variables. With a bit of refactoring, it could look something like this:<br>
</p>
<div><pre><code><span>for</span> <span>(</span><span>var</span> <span>i</span> <span>=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>source</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>i</span><span>)</span>
<span>{</span>
    <span>var</span> <span>previousDiagonal</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>];</span>
    <span>var</span> <span>previousColumn</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>]++;</span>
    <span>var</span> <span>sourceChar</span> <span>=</span> <span>source</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>];</span>

    <span>for</span> <span>(</span><span>var</span> <span>j</span> <span>=</span> <span>1</span><span>;</span> <span>j</span> <span>&lt;=</span> <span>target</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>j</span><span>)</span>
    <span>{</span>
        <span>var</span> <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>var</span> <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div>


<p>These tweaks combined will amount to a decent increase in performance but we aren't done yet...</p>
<h2>
  <a name="-raw-span-endraw-ing-the-memory" href="#-raw-span-endraw-ing-the-memory">
  </a>
  <code>Span</code>-ing the Memory
</h2>

<p>Memory allocations - they aren't all bad BUT if we can eliminate some, that will help us. We are dealing with strings, potentially very big strings, and depending how we handle them we can allocate a lot of memory.</p>

<p>In Part 2, I showed a way we can trim the strings that have equal prefixes and suffixes to give us a performance boost. This code, while works, actually isn't the best.</p>

<p>As a reminder, here is the piece of code I shared:<br>
</p>
<div><pre><code><span>var</span> <span>startIndex</span> <span>=</span> <span>0</span><span>;</span>
<span>var</span> <span>sourceEnd</span> <span>=</span> <span>source</span><span>.</span><span>Length</span><span>;</span>
<span>var</span> <span>targetEnd</span> <span>=</span> <span>target</span><span>.</span><span>Length</span><span>;</span>

<span>while</span> <span>(</span><span>startIndex</span> <span>&lt;</span> <span>sourceEnd</span> <span>&amp;&amp;</span> <span>startIndex</span> <span>&lt;</span> <span>targetEnd</span> <span>&amp;&amp;</span> <span>source</span><span>[</span><span>startIndex</span><span>]</span> <span>==</span> <span>target</span><span>[</span><span>startIndex</span><span>])</span>
<span>{</span>
    <span>startIndex</span><span>++;</span>
<span>}</span>
<span>while</span> <span>(</span><span>startIndex</span> <span>&lt;</span> <span>sourceEnd</span> <span>&amp;&amp;</span> <span>startIndex</span> <span>&lt;</span> <span>targetEnd</span> <span>&amp;&amp;</span> <span>source</span><span>[</span><span>sourceEnd</span> <span>-</span> <span>1</span><span>]</span> <span>==</span> <span>target</span><span>[</span><span>targetEnd</span> <span>-</span> <span>1</span><span>])</span>
<span>{</span>
    <span>sourceEnd</span><span>--;</span>
    <span>targetEnd</span><span>--;</span>
<span>}</span>

<span>var</span> <span>sourceLength</span> <span>=</span> <span>sourceEnd</span> <span>-</span> <span>startIndex</span><span>;</span>
<span>var</span> <span>targetLength</span> <span>=</span> <span>targetEnd</span> <span>-</span> <span>startIndex</span><span>;</span>

<span>source</span> <span>=</span> <span>source</span><span>.</span><span>Substring</span><span>(</span><span>startIndex</span><span>,</span> <span>sourceLength</span><span>);</span>
<span>target</span> <span>=</span> <span>target</span><span>.</span><span>Substring</span><span>(</span><span>startIndex</span><span>,</span> <span>targetLength</span><span>);</span>
</code></pre></div>


<p>Our biggest problem here is the last two lines and their <code>Substring</code> call. In C#, getting a substring of another string performs another allocation equal to the length of the new string. So if we had a 500 character string being substring'd to 200 characters, we would be allocating 200 characters worth of string.</p>

<p>This might not be bad individually but we can do better - we can do a ZERO allocation substring by using <a href="https://devblogs.microsoft.com/dotnet/welcome-to-c-7-2-and-span/">a (relatively) new feature of C# called <code>Span</code></a>.</p>

<p>The most concise description I can give, <code>Span</code> and its comparison type <code>ReadOnlySpan</code> allow access to a block of memory. This block of memory might be an array, it might be a pointer or it might be a string. Accessing data in a <code>Span</code> is the same as accessing data in a normal array like <code>mySpan[42]</code>. While wrapping these various types of memory is extremely useful for safe access to data, it also has one killer function - <code>Slice</code> - giving us a slice of the memory without actually allocating/copying it.</p>

<p>To use it in our example with a string, we need to cast it to <code>ReadOnlySpan&lt;char&gt;</code> (We must use <code>ReadOnlySpan</code> specifically because strings are immutable). After that, we simply replace our <code>Substring</code> calls with their <code>Slice</code> equivalent.<br>
</p>
<div><pre><code><span>var</span> <span>startIndex</span> <span>=</span> <span>0</span><span>;</span>
<span>var</span> <span>sourceEnd</span> <span>=</span> <span>source</span><span>.</span><span>Length</span><span>;</span>
<span>var</span> <span>targetEnd</span> <span>=</span> <span>target</span><span>.</span><span>Length</span><span>;</span>

<span>while</span> <span>(</span><span>startIndex</span> <span>&lt;</span> <span>sourceEnd</span> <span>&amp;&amp;</span> <span>startIndex</span> <span>&lt;</span> <span>targetEnd</span> <span>&amp;&amp;</span> <span>source</span><span>[</span><span>startIndex</span><span>]</span> <span>==</span> <span>target</span><span>[</span><span>startIndex</span><span>])</span>
<span>{</span>
    <span>startIndex</span><span>++;</span>
<span>}</span>
<span>while</span> <span>(</span><span>startIndex</span> <span>&lt;</span> <span>sourceEnd</span> <span>&amp;&amp;</span> <span>startIndex</span> <span>&lt;</span> <span>targetEnd</span> <span>&amp;&amp;</span> <span>source</span><span>[</span><span>sourceEnd</span> <span>-</span> <span>1</span><span>]</span> <span>==</span> <span>target</span><span>[</span><span>targetEnd</span> <span>-</span> <span>1</span><span>])</span>
<span>{</span>
    <span>sourceEnd</span><span>--;</span>
    <span>targetEnd</span><span>--;</span>
<span>}</span>

<span>var</span> <span>sourceLength</span> <span>=</span> <span>sourceEnd</span> <span>-</span> <span>startIndex</span><span>;</span>
<span>var</span> <span>targetLength</span> <span>=</span> <span>targetEnd</span> <span>-</span> <span>startIndex</span><span>;</span>

<span>ReadOnlySpan</span><span>&lt;</span><span>char</span><span>&gt;</span> <span>sourceSpan</span> <span>=</span> <span>source</span><span>;</span>
<span>ReadOnlySpan</span><span>&lt;</span><span>char</span><span>&gt;</span> <span>targetSpan</span> <span>=</span> <span>target</span><span>;</span>

<span>sourceSpan</span> <span>=</span> <span>sourceSpan</span><span>.</span><span>Slice</span><span>(</span><span>startIndex</span><span>,</span> <span>sourceLength</span><span>);</span>
<span>targetSpan</span> <span>=</span> <span>targetSpan</span><span>.</span><span>Slice</span><span>(</span><span>startIndex</span><span>,</span> <span>targetLength</span><span>);</span>
</code></pre></div>


<p>One caveat is that from now on, we can only deal with methods that accept <code>ReadOnlySpan&lt;char&gt;</code> so if a method only accepts <code>string</code> type, we would need to re-allocate our span back to a full string.</p>

<p>This can be one of the few downsides with these types - there are many APIs that simply don't have overloads to accept <code>Span</code> etc. That said, the .NET team have done a lot of work adding new overloads to accept <code>Span</code> or <code>ReadOnlySpan</code> across the entire framework.</p>

<p>Even with that in mind, <code>Span</code> has other limitations like it being stack-only, you can't store a <code>Span</code> on the heap (eg. as a property in a class). With what we are doing above though, <code>Span</code> works out perfectly.</p>

<p>For more information about <code>Span</code>, have a read of <a href="https://adamsitnik.com/Span/">Adam Sitnik's blog post about <code>Span</code></a>.</p>
<h2>
  <a name="f-pooling-around-with-arrays" href="#f-pooling-around-with-arrays">
  </a>
  <del>F</del> <strong>P</strong>ooling around with Arrays
</h2>

<p>Strings are not our only source of allocations in our code. If we look back to how we instantiate our <code>previousRow</code> array, that is itself an allocation.<br>
</p>
<div><pre><code><span>var</span> <span>previousRow</span> <span>=</span> <span>new</span> <span>int</span><span>[</span><span>target</span><span>.</span><span>Length</span> <span>+</span> <span>1</span><span>];</span>
</code></pre></div>


<p>Our problem is that we <em>need</em> this array but creating new arrays is an allocation - how do we remove this allocation? With <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1?view=netcore-3.1"><code>ArrayPool</code></a> of course!</p>

<p>Another one of the gems that have been added to .NET is sharing/renting arrays. We ask for an array of X size and we get an array at least that big. After we are done, we just return the array back to the pool for it to be used elsewhere.</p>

<p>While there is a lot of magic that goes on behind the scenes to make that work and scale with various size arrays, for the size arrays we can reasonably deal with, <code>ArrayPool</code> is a perfect fit.</p>

<p>So how do we use this in our code? Just two places need to change - the start and end of our code.</p>

<p><strong>Start of Code</strong><br>
</p>
<div><pre><code><span>var</span> <span>arrayPool</span> <span>=</span> <span>ArrayPool</span><span>&lt;</span><span>int</span><span>&gt;.</span><span>Shared</span><span>;</span>
<span>var</span> <span>previousRow</span> <span>=</span> <span>arrayPool</span><span>.</span><span>Rent</span><span>(</span><span>target</span><span>.</span><span>Length</span> <span>+</span> <span>1</span><span>);</span>
</code></pre></div>


<p><strong>End of Code</strong><br>
</p>
<div><pre><code><span>var</span> <span>result</span> <span>=</span> <span>previousRow</span><span>[</span><span>targetLength</span><span>];</span>
<span>arrayPool</span><span>.</span><span>Return</span><span>(</span><span>pooledArray</span><span>);</span>
<span>return</span> <span>result</span><span>;</span>
</code></pre></div>


<p>That's it - our array allocation is now gone thanks to the hard work of the .NET team.</p>

<p>There are limitations with <code>ArrayPool</code> like by default the array won't be empty, the array may be longer than what you rented and has a default max rent size of 1,048,576.</p>

<p>For more information about <code>ArrayPool</code>, Adam Sitnik did <a href="https://adamsitnik.com/Array-Pool/">another great post</a>.</p>
<h2>
  <a name="dabbling-in-parallel-processing" href="#dabbling-in-parallel-processing">
  </a>
  Dabbling in Parallel Processing
</h2>

<p>The Levenshtein Distance algorithm isn't exactly parallel friendly. In my effort to write the fastest Levenshtein Distance implementation, I did find a brute force way to make it happen. I don't want to get your hopes up - while the code can be very fast, it is riddled with race conditions because <em>threading is hard</em> - this means that it won't always be correct if you run it on the same strings each time. If you have the time and patience to implement it properly, you'll certainly have one of the fastest implementations around.</p>

<p>Anyway, let's dig into this!</p>

<p>The theory goes like this - if we divide a virtual matrix by the number of cores available on the machine, we could "stagger" our calculations. Visualising this as a matrix will give you some idea of how it would work and why it is hard.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--6Akrd--6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/xtg2d5o919td3fatlmrf.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--6Akrd--6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/xtg2d5o919td3fatlmrf.png" alt="Levenshtein Distance matrix of &quot;Saturday&quot; and &quot;Sunday&quot; divided into two sections for two threads" loading="lazy"></a></p>

<p>The two colours of the matrix above represent the area our threads will calculate and write to. When it comes to reading data is where the problem lies - the section on the right (blue) is dependent on the column with the letter "u" which is written to by the left side (pink). While it is certainly possible to carefully hand off from one thread to another - this is most certainly going to be the hardest part of the implementation to solve.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--JoLK74gc--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/hrn23v81dv7zgax68gc1.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--JoLK74gc--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/hrn23v81dv7zgax68gc1.png" alt="Levenshtein Distance matrix of &quot;Saturday&quot; and &quot;Sunday&quot; divided into two sections for two threads - partially calculated in each thread" loading="lazy"></a></p>

<p>We can see above what is might look like during a parallel calculation. The left thread (pink) needs to only perform scans on the first 4 characters of "Saturday" before moving onto the next line. The thread on the right (blue) can only start if the left thread (pink) has completed that row.</p>

<p>This doesn't seem all bad - the left thread (pink) could run dozens of rows ahead of the right thread (blue) and we would still calculate everything correctly. In Part 2 though, we covered shrinking a full matrix down to a single row - how will that work for our parallel-ness? If we want to adopt the same optimization, it is going to make our threading a lot more complicated.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--ffuHglyt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/zr3pmrbq8y799bhpgd06.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ffuHglyt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/zr3pmrbq8y799bhpgd06.png" alt="Single row of calculations for the Levenshtein Distance with threading sections" loading="lazy"></a></p>

<p>Using the row above (with our same threading colours) as an example of what our calculation row would look like. The left thread (pink) can proceed because the right thread (blue) has written its first value for that row.</p>

<p>Let's skip forward and say the left thread (pink) manages to fill in all its values for the next row while the right thread (blue) manages to fill one value.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--3KKPdk0l--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/tf7pqtw6dbtaqs695adm.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--3KKPdk0l--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/tf7pqtw6dbtaqs695adm.png" alt="Single row of calculations for the Levenshtein Distance with threading sections and the left thread being a row ahead." loading="lazy"></a></p>

<p>Now we are in a bit of a pickle - if the left thread (pink) manages to write another row before the right thread (blue) reads the "shared" value, it will miscalculate.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--uSwusLfZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/gkjibgh1h3cyxfav4cbc.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--uSwusLfZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/gkjibgh1h3cyxfav4cbc.png" alt="Single row of calculations for the Levenshtein Distance with threading sections and the left thread being two rows ahead." loading="lazy"></a></p>

<p>Oh no, now that shared value is <code>3</code> instead of the expected <code>2</code> - now our right thread (blue) will have the wrong insert cost when it starts the next row.</p>

<p>Expand this problem across bigger string comparisons with more threads and the chances of hitting this condition go up unless you have measures in place to trigger the right threads at the right time - not impossible but not trivial either.</p>

<p>Even with the performance bonus of a successful parallel implementation, you will be hit with performance penalities just keeping tracking of all the rows that threads are in not to mention the thread starting/stopping cost. You could (like me) just stuff threads in a <code>while(true)</code> loop but let's be honest, that is a bad idea.</p>

<p>With my (broken) implementation, for small strings it was up to 12x slower. For medium length strings (500 characters), it performed about the same as a non-parallel version. One the string length was around 8000 characters, it was performing up to 3x faster (with 8 threads) than a relatively well optimized non-parallel version. </p>

<p>Keeping in mind my version is flawed, that is still a significant speed boost. With more threads, bigger performance gains could likely be made.</p>

<p>In conclusion - I thought it would be interesting to share as a proof-of-concept but in reality, a good implementation of parallelism in Levenshtein Distance is not going to be a fun time.</p>

<p>Unless you have absolutely HUGE strings, I wouldn't even bother going this direction.</p>
<h2>
  <a name="the-enemy-of-processing-branch-misprediction" href="#the-enemy-of-processing-branch-misprediction">
  </a>
  The Enemy of Processing: Branch Misprediction
</h2>

<p>Processors are fast using a variety of tricks with one of them being <a href="https://en.wikipedia.org/wiki/Branch_predictor">branch prediction</a>. Put simply, it is the idea that the processor guesses whether a conditional jump will be taken or not. With its guess, it will start fetching, decoding and potentially even <a href="https://en.wikipedia.org/wiki/Speculative_execution">speculatively executing it</a>.</p>

<p>It works wonders when it guesses right but when it guesses wrong, a mispredict, the processor may need to unroll and re-execute the code correctly.</p>

<p>All of this is important to consider given our nested for-loops - every loop performs a conditional jump (our comparison to the source or target strings). With two 1,000 character strings to compare, our inner for-loop would iterate 1,000,000 times. Two 8,000 character strings would iterate 64,000,000 times.</p>

<p>Earlier in this post, we covered a clever optimization to avoid our <code>Math.Min</code> calls - part of the benefit there wasn't avoiding <em>just another instruction</em>, it was avoiding a conditional jump instruction.<br>
</p>
<div><pre><code><span>for</span> <span>(</span><span>var</span> <span>i</span> <span>=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>source</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>i</span><span>)</span>
<span>{</span>
    <span>var</span> <span>previousDiagonal</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>];</span>
    <span>var</span> <span>previousColumn</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>]++;</span>
    <span>var</span> <span>sourceChar</span> <span>=</span> <span>source</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>];</span>

    <span>for</span> <span>(</span><span>var</span> <span>j</span> <span>=</span> <span>1</span><span>;</span> <span>j</span> <span>&lt;=</span> <span>target</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>j</span><span>)</span>
    <span>{</span>
        <span>var</span> <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>var</span> <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>// The conditional jumps associated with Math.Min only execute</span>
            <span>// if the source character is not equal to the target character.</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div>


<p>Even with this in mind, we still have a lot of conditional jumps going on in our code. To take this to the next level, we will want to think about <a href="https://en.wikipedia.org/wiki/Loop_unrolling">loop unrolling</a>.</p>

<p>The basic premise is, cut down on the number of instructions for each iteration of the loop. In our case, we will use this to avoid our "j &lt;= target.Length;" cost for every iteration.<br>
</p>
<div><pre><code><span>for</span> <span>(</span><span>var</span> <span>i</span> <span>=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>source</span><span>.</span><span>Length</span><span>;</span> <span>++</span><span>i</span><span>)</span>
<span>{</span>
    <span>var</span> <span>previousDiagonal</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>];</span>
    <span>var</span> <span>previousColumn</span> <span>=</span> <span>previousRow</span><span>[</span><span>0</span><span>]++;</span>
    <span>var</span> <span>sourceChar</span> <span>=</span> <span>source</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>];</span>

    <span>var</span> <span>j</span> <span>=</span> <span>1</span><span>;</span>
    <span>var</span> <span>columnsRemaining</span> <span>=</span> <span>target</span><span>.</span><span>Length</span><span>;</span>

    <span>int</span> <span>localCost</span><span>;</span>
    <span>int</span> <span>deletionCost</span><span>;</span>

    <span>while</span> <span>(</span><span>columnsRemaining</span> <span>&gt;=</span> <span>8</span><span>)</span>
    <span>{</span>
        <span>columnsRemaining</span> <span>-=</span> <span>8</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>columnsRemaining</span> <span>&gt;=</span> <span>4</span><span>)</span>
    <span>{</span>
        <span>columnsRemaining</span> <span>-=</span> <span>4</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>
    <span>}</span>

    <span>while</span> <span>(</span><span>columnsRemaining</span> <span>&gt;</span> <span>0</span><span>)</span>
    <span>{</span>
        <span>columnsRemaining</span><span>--;</span>

        <span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
        <span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
        <span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
        <span>{</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
            <span>localCost</span><span>++;</span>
        <span>}</span>
        <span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
        <span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div>


<p>There is quite a bit to unpack for that code but one of the things you might be able to tell is how long some basic unrolling code might be.<br>
</p>
<div><pre><code><span>while</span> <span>(</span><span>columnsRemaining</span> <span>&gt;=</span> <span>8</span><span>)</span>
</code></pre></div>


<p>Our first of 3 processing chunks - we are unrolled to 8 columns of calculations at a time. This means for every loop, we've removed 7 conditional jumps that needed handling.</p>

<p>Once this has processed all it can, we have between 0 and 7 columns remaining for processing.<br>
</p>
<div><pre><code><span>if</span> <span>(</span><span>columnsRemaining</span> <span>&gt;=</span> <span>4</span><span>)</span>
</code></pre></div>


<p>In our second of 3 processing chunks, we attempt to unroll 4 columns if there are enough columns available to do so. We are removing 3 conditional jumps in this block.</p>

<p>Once this has processed all it can, we have between 0 and 3 columns remaining for processing.<br>
</p>
<div><pre><code><span>while</span> <span>(</span><span>columnsRemaining</span> <span>&gt;</span> <span>0</span><span>)</span>
</code></pre></div>


<p>In our final processing chunk, there is no unrolling - we process each item individually. At worst, we are only needing to loop through 3 columns.</p>

<p>The actual calculation code in each chunk is identical, just replicated the number of times needed for the given chunk.<br>
</p>
<div><pre><code><span>localCost</span> <span>=</span> <span>previousDiagonal</span><span>;</span>
<span>deletionCost</span> <span>=</span> <span>previousRow</span><span>[</span><span>j</span><span>];</span>
<span>if</span> <span>(</span><span>sourceChar</span> <span>!=</span> <span>target</span><span>[</span><span>j</span> <span>-</span> <span>1</span><span>])</span>
<span>{</span>
    <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>previousColumn</span><span>,</span> <span>localCost</span><span>);</span>
    <span>localCost</span> <span>=</span> <span>Math</span><span>.</span><span>Min</span><span>(</span><span>deletionCost</span><span>,</span> <span>localCost</span><span>);</span>
    <span>localCost</span><span>++;</span>
<span>}</span>
<span>previousColumn</span> <span>=</span> <span>localCost</span><span>;</span>
<span>previousRow</span><span>[</span><span>j</span><span>++]</span> <span>=</span> <span>localCost</span><span>;</span>
<span>previousDiagonal</span> <span>=</span> <span>deletionCost</span><span>;</span>
</code></pre></div>


<p>This technique above, going from 8 to 4 to 1, was inspired by how the .NET runtime does this for <a href="https://github.com/dotnet/runtime/blob/4f9ae42d861fcb4be2fcd5d3d55d5f227d30e723/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.T.cs#L62-L118">their <code>SpanHelpers</code> code</a>. While there likely was some significance to the numbers chosen for optimizing cache lines relative to the size of the code unrolled, our code likely doesn't benefit to the same extent.</p>

<p>One of the biggest drawbacks to applying loop unrolling like this is the dramatic increase in binary size for the same functionality, not to mention the maintenance overhead having all of those blocks repeated. A single mistake in one could break the whole calculation.</p>

<p><em>Don't even think about pushing that to its own function as function calls have overheads too unless the compiler will inline it for you!</em></p>

<p>That said, loop unrolling still provided us a net benefit if all we cared about was raw performance.</p>

<p>You could go further and unroll the outer loop some amount too. If done right, you would be able to minimise the number of lookups of characters in the target string. That however I will leave as an exercise to the reader.</p>
<h2>
  <a name="bonus-using-simd-instructions" href="#bonus-using-simd-instructions">
  </a>
  Bonus: Using SIMD Instructions
</h2>

<p>Due in part to the extraordinary length of this post, I've split the longest part about SIMD instructions to a separate post. If you want to dive into how vectorizing CPU instructions can help us perform even faster - check it out <a href="https://dev.to/turnerj/levenshtein-distance-with-simd-bonus-part-198h">here</a>.</p>
<h2>
  <a name="summary" href="#summary">
  </a>
  Summary
</h2>

<p>We've extracted a lot of performance out of an algorithm which isn't very performant while dramatically decreasing our memory usage.</p>

<p>This whole blog series about Levenshtein Distance came up purely because I wanted to build a fast and memory efficient implementation. Besides parallel support, I have actually made a version which implements every other performance feature I've talked about this series - I call it Quickenshtein!</p>


<div>
  
  <div>
    
<div id="readme" data-path="readme.md"><article itemprop="text">
<p>A quick and memory efficient Levenshtein Distance calculator for .NET</p>
<p><a href="https://ci.appveyor.com/project/Turnerj/Quickenshtein" rel="nofollow"><img src="https://camo.githubusercontent.com/fb256651e51e198573d9c73c2f34e8f842727596/68747470733a2f2f696d672e736869656c64732e696f2f6170707665796f722f63692f5475726e65726a2f517569636b656e73687465696e2f6d61737465722e737667" alt="AppVeyor" data-canonical-src="https://img.shields.io/appveyor/ci/Turnerj/Quickenshtein/master.svg"></a>
<a href="https://codecov.io/gh/Turnerj/Quickenshtein" rel="nofollow"><img src="https://camo.githubusercontent.com/17423d614bfbc6287f91340fb3546040d33de3db/68747470733a2f2f696d672e736869656c64732e696f2f636f6465636f762f632f6769746875622f5475726e65726a2f517569636b656e73687465696e2f6d61737465722e737667" alt="Codecov" data-canonical-src="https://img.shields.io/codecov/c/github/Turnerj/Quickenshtein/master.svg"></a>
<a href="https://www.nuget.org/packages/Quickenshtein/" rel="nofollow"><img src="https://camo.githubusercontent.com/43a9309c6c22de0026f7a87313a4d3cf7075793f/68747470733a2f2f696d672e736869656c64732e696f2f6e756765742f762f517569636b656e73687465696e2e737667" alt="NuGet" data-canonical-src="https://img.shields.io/nuget/v/Quickenshtein.svg"></a></p>
<h2>
Performance</h2>
<p>Quickenshtein gets its speed and memory effiency from a number of different optimizations
To get the most performance out of the library, you will need .NET Core 3 or higher as this has support for hardware intrinsics.</p>
<p>Quickenshtein takes advantage of the following hardware intrinsics. On any recent x86 system, you will likely have these available.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/SSE2#CPU_support" rel="nofollow">SSE2</a></li>
<li><a href="https://en.wikipedia.org/wiki/SSE4#Supporting_CPUs" rel="nofollow">SSE4.1</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#CPUs_with_AVX2" rel="nofollow">AVX2</a></li>
</ul>
<p>If your computer doesn't have one of the hardware intrinsics available, Quickenshtein will still work - just slower than optimal.</p>
<h2>
Benchmarking</h2>
<p>There are a number of benchmarks in the repository that you can run on your system to see how well Quickenshtein performs.</p>
<p>Most of these benchmarks...</p>
<ul>
<li>Run .NET Framework and .NET Core so you can see how the performance changes between them</li>
<li>Compare against a simple baseline Levenshtein Distance implementation with no specific optimizations</li>
<li>Compare against <a href="https://github.com/DanHarltey/Fastenshtein/">Fastenshtein</a></li>
</ul></article></div>
  </div>
  
</div>



<p>If its not the fastest Levenshtein Distance implementation, it is surely close to it - all while allocating 0 bytes.</p>

<p>If .NET is your thing and this could help you, check it out. If you want to implement your own version in another language, feel free to use my implementation as a guide.</p>

<p>Until next time fellow readers - let your code be fast and your allocations be nil.</p>


      </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>