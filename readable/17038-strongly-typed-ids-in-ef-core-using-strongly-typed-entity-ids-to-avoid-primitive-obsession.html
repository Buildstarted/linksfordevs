<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Strongly-typed IDs in EF Core: Using strongly-typed entity IDs to avoid primitive obsession -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Strongly-typed IDs in EF Core: Using strongly-typed entity IDs to avoid primitive obsession</h1><div><div class="post-content"><p>This is another post in my series on strongly-typed IDs. In the <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/">first</a> and <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/">second</a> posts, I looked at the reasons for using strongly-typed IDs, and how to add converters to interface nicely with ASP.NET Core. In the <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/">previous post</a> I looked at ways of using strongly-typed IDs with EF Core. Unfortunately, there was a significant issue with the approach I outlined: querying by a strongly-typed ID could result in client-side evaluation. The workarounds I proposed only partially fixed the problem.</p><p>In this post, I show a workaround that seems to solve the issue. EF Core is not my speciality, so it's possible there's some hidden issues, but from my testing so far it works perfectly! ðŸ¤ž The secret-sauce is <code>ValueConverterSelector</code>.</p><h2 id="strongly-typed-ids-in-ef-core" class="heading-with-anchor">Strongly-typed IDs in EF Core<a href="#strongly-typed-ids-in-ef-core"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>As a quick recap, <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/#creating-a-custom-valueconverter-for-ef-core">the solution I proposed in the previous post</a> centred around <em>value converters</em>. As their name suggests, these can be used to convert instances of one type (for example a strongly-typed ID like <code>OrderId</code>) into a type that is supported by a database provider (for example a <code>Guid</code> or an <code>int</code>). </p><p>In the last post I showed an example implementation of a custom <code>ValueConverter</code> for an <code>OrderId</code> that is stored in the database as a <code>Guid</code>. The version below is slightly modified to be a nested class of the strongly-typed ID <code>OrderId</code>, which is how we would generate it if using the "snippet" approach <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/">from my second post</a>. For this post, we don't need <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/#automatically-registering-value-converters-for-strongly-typed-ids">the <code>[StronglyTypedIdEfValueConverter]</code> attribute I previously described</a>.</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">readonly</span><span class="token keyword">struct</span> OrderId 
<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">StronglyTypedIdEfValueConverter</span><span class="token punctuation">:</span><span class="token class-name">ValueConverter</span><span class="token operator">&lt;</span>OrderId<span class="token punctuation">,</span> Guid<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token function">StronglyTypedIdEfValueConverter</span><span class="token punctuation">(</span><span class="token class-name">ConverterMappingHints</span> mappingHints <span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">base</span><span class="token punctuation">(</span>id <span class="token operator">=</span><span class="token operator">&gt;</span> id<span class="token punctuation">.</span>Value<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token keyword">new</span><span class="token class-name">OrderId</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mappingHints<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>You could <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/#registering-the-custom-valueconverter-with-ef-core-s-db-context">manually map every use of <code>OrderId</code> in your EF Core model properties to use this converter as before</a>. But as well as being verbose, this would leave you with <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/#custom-value-converters-result-in-client-side-evaluation">the client-side evaluation problem from the last post</a>.</p><p>Instead, we're going to look at one of the "internal" services of EF Core - the <code>ValueConverterSelector</code>. If you're not interested in why the solution works and just want to see the final code, <a href="#creating-a-custom-valueconverterselector-for-strongly-typed-ids">skip ahead</a>.</p><h2 id="a-semi-deep-dive-into-valueconverterselector-handling-built-in-conversions" class="heading-with-anchor">A semi-deep dive into <code>ValueConverterSelector</code> - handling built-in conversions<a href="#a-semi-deep-dive-into-valueconverterselector-handling-built-in-conversions"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>After reaching the conclusion of my last post, I felt like I had hit a brick wall trying to get strongly-typed IDs to work smoothly. There were all sorts of <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/#avoiding-client-side-evaluation-in-ef-core-with-conversion-operators">work arounds</a> you could use, but ultimately you were going to get a <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/#implicit-vs-explicit-operators">sub-par experience</a> no matter what.</p><p>This got me thinking: EF Core has all sorts of <a href="https://github.com/aspnet/EntityFrameworkCore/tree/master/src/EFCore/Storage/ValueConversion">"built-in" value converters</a> that convert between primitive types. These do conversions like <a href="https://github.com/aspnet/EntityFrameworkCore/blob/master/src/EFCore/Storage/ValueConversion/CharToStringConverter.cs"><code>Char</code> to <code>string</code></a>, <a href="https://github.com/aspnet/EntityFrameworkCore/blob/master/src/EFCore/Storage/ValueConversion/NumberToBytesConverter.cs">number to <code>byte[]</code></a>, or <a href="https://github.com/aspnet/EntityFrameworkCore/blob/master/src/EFCore/Storage/ValueConversion/StringToGuidConverter.cs"><code>string</code> to <code>Guid</code></a>. Using <em>these</em> value converters doesn't trigger the client-side evaluation problem, and they doesn't require you to register them against each property - they're used automatically.</p><p>These converters aren't built into the BCL or anything, so they must be registered somewhere in EF Core. After a bit of searching, I tracked the answer down to <a href="https://github.com/aspnet/EntityFrameworkCore/blob/v2.2.4/src/EFCore/Storage/ValueConversion/ValueConverterSelector.cs">the <code>ValueConverterSelector</code> class</a> and <a href="https://github.com/aspnet/EntityFrameworkCore/blob/v2.2.4/src/EFCore/Storage/ValueConversion/IValueConverterSelector.cs">the <code>IValueConverterSelector</code> interface</a>.</p><p>I've reproduced <a href="https://github.com/aspnet/EntityFrameworkCore/blob/v2.2.4/src/EFCore/Storage/ValueConversion/IValueConverterSelector.cs">the interface (from version 2.2.4)</a> below, as the xmldocs describe exactly what this type does:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">interface</span><span class="token class-name">IValueConverterSelector</span><span class="token punctuation">{</span>
    IEnumerable<span class="token operator">&lt;</span>ValueConverterInfo<span class="token operator">&gt;</span><span class="token function">Select</span><span class="token punctuation">(</span><span class="token class-name">Type</span> modelClrType<span class="token punctuation">,</span><span class="token class-name">Type</span> providerClrType <span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>EF Core uses an implementation of this interface to find the value converters for built-in types. It appears to use these types early in the query generation pipeline, so they don't cause the client-side evaluation issues you see with custom value converters.</p><p>The below code is a snippet taken from the <code>Select()</code> method of the default implementation, <code>ValueConverterSelector</code>. This method is essentially a giant <code>if</code>/<code>else</code> statement that finds all the applicable converters for a given <code>modelClrType</code> (the type used in your EF Core entities) and <code>providerClrType</code> (the type stored in the database).</p><p>Given the number of built-in converters, this method is <em>big</em>, so I've only shown <a href="https://github.com/aspnet/EntityFrameworkCore/blob/v2.2.4/src/EFCore/Storage/ValueConversion/ValueConverterSelector.cs">a snippet of it below</a>:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">private</span><span class="token keyword">readonly</span> ConcurrentDictionary<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token class-name">Type</span> ModelClrType<span class="token punctuation">,</span><span class="token class-name">Type</span> ProviderClrType<span class="token punctuation">)</span><span class="token punctuation">,</span> ValueConverterInfo<span class="token operator">&gt;</span> _converters
    <span class="token operator">=</span><span class="token keyword">new</span><span class="token generic-method"><span class="token function">ConcurrentDictionary</span><span class="token punctuation">&lt;</span><span class="token punctuation">(</span><span class="token class-name">Type</span><span class="token class-name">ModelClrType</span><span class="token punctuation">,</span><span class="token class-name">Type</span><span class="token class-name">ProviderClrType</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">ValueConverterInfo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token keyword">virtual</span> IEnumerable<span class="token operator">&lt;</span>ValueConverterInfo<span class="token operator">&gt;</span><span class="token function">Select</span><span class="token punctuation">(</span><span class="token class-name">Type</span> modelClrType<span class="token punctuation">,</span><span class="token class-name">Type</span> providerClrType <span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> underlyingModelType <span class="token operator">=</span> modelClrType<span class="token punctuation">.</span><span class="token function">UnwrapNullableType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> underlyingProviderType <span class="token operator">=</span> providerClrType<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">UnwrapNullableType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>underlyingModelType <span class="token operator">==</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Guid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>underlyingProviderType <span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">||</span> underlyingProviderType <span class="token operator">==</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">yield</span><span class="token keyword">return</span> _converters<span class="token punctuation">.</span><span class="token function">GetOrAdd</span><span class="token punctuation">(</span><span class="token punctuation">(</span>underlyingModelType<span class="token punctuation">,</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                k <span class="token operator">=</span><span class="token operator">&gt;</span> GuidToBytesConverter<span class="token punctuation">.</span>DefaultInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>underlyingProviderType <span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">||</span> underlyingProviderType <span class="token operator">==</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">yield</span><span class="token keyword">return</span> _converters<span class="token punctuation">.</span><span class="token function">GetOrAdd</span><span class="token punctuation">(</span><span class="token punctuation">(</span>underlyingModelType<span class="token punctuation">,</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                k <span class="token operator">=</span><span class="token operator">&gt;</span> GuidToStringConverter<span class="token punctuation">.</span>DefaultInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>So what is this code doing? First, the method "unwraps" any nullable types - so if the type is a <code>Guid?</code>, it returns a <code>Guid</code> and so on. If the type is not nullable, this is a no-op. It's worth noting that the <code>providerClrType</code> can be <code>null</code>: <code>null</code> here means "give me <em>all</em> the value converters for the modelClrType". </p><p>After unwrapping the types, we enter the nested <code>if</code>/<code>else</code> statements - I've shown the if statement for <code>Guid</code> above. There are two built-in converters for <code>Guid</code>: the <code>GuidToBytesConverter</code>, and the <code>GuidToStringConverter</code>. If the <code>underlyingProviderType</code> is <code>null</code> or the correct type, the method uses <code>yield return</code> to return a default instance of <code>ValueConverterInfo</code>.</p><blockquote><p>The implementation uses a <code>ConcurrentDictionary</code> to avoid creating multiple <code>ValueConverterInfo</code> objects, keyed on the <code>underlyingModelType</code> and <code>underlyingProviderType</code>.</p></blockquote><p>The <code>ValueConverterInfo</code> object is a simple DTO that contains a factory method for creating a <code>ValueConverter</code> instance:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">readonly</span><span class="token keyword">struct</span> ValueConverterInfo
<span class="token punctuation">{</span><span class="token keyword">private</span><span class="token keyword">readonly</span> Func<span class="token operator">&lt;</span>ValueConverterInfo<span class="token punctuation">,</span> ValueConverter<span class="token operator">&gt;</span> _factory<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token class-name">Type</span> ModelClrType <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token class-name">Type</span> ProviderClrType <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token class-name">ConverterMappingHints</span> MappingHints <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token class-name">ValueConverter</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token function">_factory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>If we look at one of the built-in value converters <code>GuidToStringConverter</code> for example, we see the <code>DefaultInfo</code> property that returns a <code>ValueConverterInfo</code> object:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">GuidToStringConverter</span><span class="token punctuation">:</span><span class="token class-name">StringGuidConverter</span><span class="token operator">&lt;</span>Guid<span class="token punctuation">,</span><span class="token keyword">string</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token function">GuidToStringConverter</span><span class="token punctuation">(</span><span class="token class-name">ConverterMappingHints</span> mappingHints <span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">base</span><span class="token punctuation">(</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">ToGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _defaultHints<span class="token punctuation">.</span><span class="token function">With</span><span class="token punctuation">(</span>mappingHints<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">static</span><span class="token class-name">ValueConverterInfo</span> DefaultInfo <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">=</span><span class="token keyword">new</span><span class="token class-name">ValueConverterInfo</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Guid<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
            i <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token keyword">new</span><span class="token class-name">GuidToStringConverter</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>MappingHints<span class="token punctuation">)</span><span class="token punctuation">,</span> 
            _defaultHints<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>I haven't shown the base classes involved, so the code above isn't entirely complete, but the <code>DefaultInfo</code> property implementation is pretty simple. It creates a new <code>ValueConverterInfo</code> object, providing the <code>ModelClrType</code> (<code>Guid</code>) the <code>ProviderClrType</code> (<code>string</code>), a function for creating a new <code>GuidToStringConverter</code> given the current <code>ValueConverterInfo</code> instance (i.e. call the constructor), and the default mapping hints to use (for controlling the size of the <code>string</code> column in the database etc).</p><p>That's as far as I went digging into the <code>ValueConverterSelector</code>. I haven't worked out <em>quite</em> how it fits in to the overall EF Core query translation system (other than it's used in the <code>ITypeMappingSource</code> implementations), but I know enough now to be dangerous - lets get back to fixing the original problem, strongly-typed IDs.</p><h2 id="creating-a-custom-valueconverterselector-for-strongly-typed-ids" class="heading-with-anchor">Creating a custom <code>ValueConverterSelector</code> for strongly-typed IDs<a href="#creating-a-custom-valueconverterselector-for-strongly-typed-ids"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>To recap, we have a number of strongly-typed IDs that are used in our EF Core entities. For each strongly-typed ID we have a nested <code>ValueConverter</code> implementation. In this section, we're going to create a custom <code>ValueConverterSelector</code> to automatically register our value converters so they're used in the same way as the built-in value converters.</p><p>Luckily, the <code>ValueConverterSelector</code> implementation isn't sealed, and the <code>Select()</code> method is even virtual, so we can easily create our own implementation, while preserving the existing behaviour for built-in converters. The following code is the entire <code>StronglyTypedIdValueConverterSelector</code> - I'll walk through and explain it afterwards.</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">StronglyTypedIdValueConverterSelector</span><span class="token punctuation">:</span><span class="token class-name">ValueConverterSelector</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token keyword">readonly</span> ConcurrentDictionary<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token class-name">Type</span> ModelClrType<span class="token punctuation">,</span><span class="token class-name">Type</span> ProviderClrType<span class="token punctuation">)</span><span class="token punctuation">,</span> ValueConverterInfo<span class="token operator">&gt;</span> _converters
        <span class="token operator">=</span><span class="token keyword">new</span><span class="token generic-method"><span class="token function">ConcurrentDictionary</span><span class="token punctuation">&lt;</span><span class="token punctuation">(</span><span class="token class-name">Type</span><span class="token class-name">ModelClrType</span><span class="token punctuation">,</span><span class="token class-name">Type</span><span class="token class-name">ProviderClrType</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">ValueConverterInfo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token function">StronglyTypedIdValueConverterSelector</span><span class="token punctuation">(</span><span class="token class-name">ValueConverterSelectorDependencies</span> dependencies<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">base</span><span class="token punctuation">(</span>dependencies<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">override</span> IEnumerable<span class="token operator">&lt;</span>ValueConverterInfo<span class="token operator">&gt;</span><span class="token function">Select</span><span class="token punctuation">(</span><span class="token class-name">Type</span> modelClrType<span class="token punctuation">,</span><span class="token class-name">Type</span> providerClrType <span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> baseConverters <span class="token operator">=</span><span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>modelClrType<span class="token punctuation">,</span> providerClrType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">var</span> converter <span class="token keyword">in</span> baseConverters<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">yield</span><span class="token keyword">return</span> converter<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> underlyingModelType <span class="token operator">=</span><span class="token function">UnwrapNullableType</span><span class="token punctuation">(</span>modelClrType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> underlyingProviderType <span class="token operator">=</span><span class="token function">UnwrapNullableType</span><span class="token punctuation">(</span>providerClrType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>underlyingProviderType <span class="token keyword">is</span><span class="token keyword">null</span><span class="token operator">||</span> underlyingProviderType <span class="token operator">==</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Guid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> converterType <span class="token operator">=</span> underlyingModelType<span class="token punctuation">.</span><span class="token function">GetNestedType</span><span class="token punctuation">(</span><span class="token string">"StronglyTypedIdEfValueConverter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>converterType <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">yield</span><span class="token keyword">return</span> _converters<span class="token punctuation">.</span><span class="token function">GetOrAdd</span><span class="token punctuation">(</span><span class="token punctuation">(</span>underlyingModelType<span class="token punctuation">,</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Guid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    k <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
                        Func<span class="token operator">&lt;</span>ValueConverterInfo<span class="token punctuation">,</span> ValueConverter<span class="token operator">&gt;</span> factory <span class="token operator">=</span>
                            info <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>ValueConverter<span class="token punctuation">)</span> Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>converterType<span class="token punctuation">,</span> info<span class="token punctuation">.</span>MappingHints<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token keyword">new</span><span class="token class-name">ValueConverterInfo</span><span class="token punctuation">(</span>modelClrType<span class="token punctuation">,</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Guid<span class="token punctuation">)</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token keyword">static</span><span class="token class-name">Type</span><span class="token function">UnwrapNullableType</span><span class="token punctuation">(</span><span class="token class-name">Type</span> type<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token keyword">is</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> Nullable<span class="token punctuation">.</span><span class="token function">GetUnderlyingType</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token operator">?</span><span class="token operator">?</span> type<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>The <code>StronglyTypedIdValueConverterSelector</code> is written to follow the same patterns as the <code>ValueConverterSelector</code> it overrides, so I've created a <code>ConcurrentDictionary&lt;&gt;</code> for tracking the value converters in the same way the base class does. The dictionary in the base class is <code>private</code> so we have to create a new instance of it here, but that's not a big deal. The constructor passes through the required <code>ValueConverterSelectorDependencies</code> object to the base class.</p><p>The meat of the implementation is in the <code>Select</code> method. We start by fetching all of the applicable built-in value converters by calling <code>base.Select()</code>, and <code>yield return</code> on all of the returned implementations. That preserves existing behaviour.</p><p>Next, we have to "unwrap" nullable types, just as the base class did. We call the simple static <code>UnwrapNullableType()</code> method defined at the end of the class. If the provider type is either <code>null</code> or <code>Guid</code>, then we try and create a converter, otherwise we're done.</p><blockquote><p>When testing the converter, I found that the method was only ever called with <code>providerClrType=null</code>. That's likely due to something specific about my models, I just thought I'd point it out.</p></blockquote><p>Assuming the <code>if()</code> branch returns <code>true</code>, we now need to see if the <code>modelClrType</code> is a strongly-typed ID type with a value converter implementation. This is where the change to the value converter implementation <a href="#strongly-typed-ids-in-ef-core">at the start of this post</a> makes sense:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">readonly</span><span class="token keyword">struct</span> OrderId 
<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">StronglyTypedIdEfValueConverter</span><span class="token punctuation">:</span><span class="token class-name">ValueConverter</span><span class="token operator">&lt;</span>OrderId<span class="token punctuation">,</span> Guid<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>By creating the value converter as a nested class, and using the same name across all strongly-typed ID types (<code>StronglyTypedIdEfValueConverter</code>), we can both fetch the converter type and test for a strongly-typed ID at the same time with a small bit of reflection:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">var</span> converterType <span class="token operator">=</span> underlyingModelType<span class="token punctuation">.</span><span class="token function">GetNestedType</span><span class="token punctuation">(</span><span class="token string">"StronglyTypedIdEfValueConverter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>converterType <span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>At this point we know we have a value converter for the <code>modelClrType</code>, so we need to create the correct <code>ValueConverterInfo</code> and <code>yield return</code> it. The base class simplifies this code by using a static <code>DefaultInfo</code> property, but we'd have to invoke a similar method using reflection, and it all gets a bit more hassle than it's worth. Instead, I opted for creating a factory function that creates an instance of the converter by calling <code>Activator.CreateInstance()</code>, passing in the required <code>ConverterMappingHints</code> argument:</p><pre class="language-csharp"><code class="language-csharp">Func<span class="token operator">&lt;</span>ValueConverterInfo<span class="token punctuation">,</span> ValueConverter<span class="token operator">&gt;</span> factory <span class="token operator">=</span>
    info <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>ValueConverter<span class="token punctuation">)</span> Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>converterType<span class="token punctuation">,</span> info<span class="token punctuation">.</span>MappingHints<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>Don't be fooled by the fact that the <code>StronglyTypedIdEfValueConverter</code><code>mappingHints</code> parameter has a default value of <code>null</code>. Even though you don't need to provide this value when invoking the constructor normally, you must provide it when invoking the method using reflection (and <code>Activator.CreateInstance()</code>)</p></blockquote><p>Finally, we can create an instance of <code>ValueConverterInfo</code>, add it to the dictionary, and <code>yield return</code> it. </p><p>This implementation looks a bit complicated because of the reflection required, but I'm pretty confident there's nothing untoward going on there. All that remains is for us to replace the default instance of <code>IValueConverterSelector</code> with our custom class.</p><h2 id="replacing-the-default-ivalueconverterselector-with-a-custom-implementation" class="heading-with-anchor">Replacing the default <code>IValueConverterSelector</code> with a custom implementation<a href="#replacing-the-default-ivalueconverterselector-with-a-custom-implementation"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>Replacing "framework" EF Core services is relatively painless thanks to the <code>ReplaceService</code> method exposed by <code>DbContextOptionsBuilder</code>. You can call this method as part of your EF Core configuration in <code>Startup.ConfigureServices</code>, in the <code>AddDbContext&lt;&gt;</code> configuration method:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">void</span><span class="token function">ConfigureServices</span><span class="token punctuation">(</span><span class="token class-name">IServiceCollection</span> services<span class="token punctuation">)</span><span class="token punctuation">{</span>
    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddDbContext</span><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationDbContext</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>options <span class="token operator">=</span><span class="token operator">&gt;</span>
        options
            <span class="token punctuation">.</span><span class="token generic-method"><span class="token function">ReplaceService</span><span class="token punctuation">&lt;</span><span class="token class-name">IValueConverterSelector</span><span class="token punctuation">,</span><span class="token class-name">StronglyTypedIdValueConverterSelector</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UseSqlServer</span><span class="token punctuation">(</span>
                Configuration<span class="token punctuation">.</span><span class="token function">GetConnectionString</span><span class="token punctuation">(</span><span class="token string">"DefaultConnection"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>That's it. </p><p>No more custom <code>DbContext.OnModelCreating</code> code. </p><p>No marker attributes. </p><p>No more <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/#avoiding-client-side-evaluation-in-ef-core-with-conversion-operators">implicit/explicit conversions to force use of the value converter</a>.</p><p>And most importantly, <em>no more client-side evaluation</em>.</p><p>I'm actually kind of surprised by how well it works, but it all <em>does</em> seem to work. Even the following code (<a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/#avoiding-client-side-evaluation-in-ef-core-with-conversion-operators">which was broken in the implementation from my last post</a>), works:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token class-name">Order</span><span class="token function">GetOrder</span><span class="token punctuation">(</span><span class="token class-name">OrderId</span> orderId<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _dbContext<span class="token punctuation">.</span>Orders
                <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>order <span class="token operator">=</span><span class="token operator">&gt;</span> order<span class="token punctuation">.</span>Id <span class="token operator">==</span> orderId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token class-name">Order</span><span class="token function">GetOrderUsingFind</span><span class="token punctuation">(</span><span class="token class-name">OrderId</span> orderId<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _dbContext<span class="token punctuation">.</span>Orders
                <span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Both of these usages generate the same SQL, which has a <em>server-side</em><code>where</code> clause:</p><pre class="language-bash"><code class="language-bash">info: Microsoft.EntityFrameworkCore.Database.Command<span class="token punctuation">[</span>20101<span class="token punctuation">]</span>
      Executed DbCommand <span class="token punctuation">(</span>6ms<span class="token punctuation">)</span><span class="token punctuation">[</span>Parameters<span class="token operator">=</span><span class="token punctuation">[</span>@__get_Item_0<span class="token operator">=</span><span class="token string">'?'</span><span class="token punctuation">(</span>DbType <span class="token operator">=</span> Guid<span class="token punctuation">)</span><span class="token punctuation">]</span>, CommandType<span class="token operator">=</span><span class="token string">'Text'</span>, CommandTimeout<span class="token operator">=</span><span class="token string">'30'</span><span class="token punctuation">]</span>

      SELECT TOP<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">[</span>e<span class="token punctuation">]</span>.<span class="token punctuation">[</span>OrderId<span class="token punctuation">]</span>, <span class="token punctuation">[</span>e<span class="token punctuation">]</span>.<span class="token punctuation">[</span>Name<span class="token punctuation">]</span>
      FROM <span class="token punctuation">[</span>Orders<span class="token punctuation">]</span> AS <span class="token punctuation">[</span>e<span class="token punctuation">]</span>
      WHERE <span class="token punctuation">[</span>e<span class="token punctuation">]</span>.<span class="token punctuation">[</span>OrderId<span class="token punctuation">]</span><span class="token operator">=</span> @__get_Item_0
</code></pre><p>Success! One more reason to use strongly-typed IDs in your next ASP.NET Core app ðŸ˜ƒ.</p><h2 id="summary" class="heading-with-anchor">Summary<a href="#summary"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>In this post I describe a solution to using strongly-typed IDs in your EF Core entities by using value converters and a custom <code>IValueConverterSelector</code>. The base <code>ValueConverterSelector</code> in the EF Core framework is used to register all built-in value conversions between primitive types. By deriving from this class, we can add our strongly-typed ID converters to this list, and get seamless conversion throughout our EF Core queries. As well as reducing the configuration required, this solves <a href="https://github.com/aspnet/EntityFrameworkCore/issues/12045">the client-side evaluation problem</a> that plagued the <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/">previous implementation</a>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>