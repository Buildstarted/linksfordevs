<!DOCTYPE html>
<html lang="en">
<head>
    <title>
I want off Mr. Golang&#x27;s Wild Ride - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="I want off Mr. Golang&#x27;s Wild Ride - linksfor.dev(s)"/>
    <meta property="og:description" content="My honeymoon with the Go language is extremely over.&#xA;This article is going to have a different tone from what I&#x27;ve been posting the past year - it&#x27;s a proper rant. And I always feel bad writing those, because, inevitably, it discusses things a lot of people have been working very hard on.&#xA;In spite of that, here we are.&#xA;Having invested thousands of hours into the language, and implemented several critical (to my employer) pieces of infrastructure with it, I wish I hadn&#x27;t."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://fasterthanli.me/blog/2020/i-want-off-mr-golangs-wild-ride/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - I want off Mr. Golang&#x27;s Wild Ride</title>
<div class="readable">
        <h1>I want off Mr. Golang&#x27;s Wild Ride</h1>
            <div>Reading time: 42-53 minutes</div>
        <div>Posted here: 28 Feb 2020</div>
        <p><a href="https://fasterthanli.me/blog/2020/i-want-off-mr-golangs-wild-ride/">https://fasterthanli.me/blog/2020/i-want-off-mr-golangs-wild-ride/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
          


          
    <p>My honeymoon with the <a href="https://golang.org/">Go language</a> is <em>extremely</em> over.</p>
<p>This article is going to have a different tone from what I've been posting
the past year - it's a proper rant. And I always feel bad writing those,
because, inevitably, it discusses things a lot of people have been working
very hard on.</p>
<p>In spite of that, here we are.</p>
<p>Having invested thousands of hours into the language, and implemented several
critical (to my employer) pieces of infrastructure with it, I wish I hadn't.</p>
<p>If you're <em>already</em> heavily invested in Go, you probably shouldn't read this,
it'll probably just twist the knife. If you work on Go, you <em>definitely</em>
shouldn't read this.</p>
<p>I've been suffering Go's idiosyncracies in relative silence for too long,
there's a few things I really need to get off my chest.</p>
<p>Alright? Alright.</p>
<h2 id="garden-variety-takes-on-go">Garden-variety takes on Go</h2>
<p>By now, everybody knows Go doesn't have generics, which makes a lot of
problems impossible to model accurately (instead, you have to fall back to
reflection, which is <em>extremely</em> unsafe, and the API is very error-prone),
error handling is wonky (even with your pick of the third-party libraries
that add context or stack traces), package management took a while to arrive,
etc.</p>
<p>But everybody also knows Go's strengths: static linking makes binaries easy
to deploy (although, Go binaries get <a href="https://blog.filippo.io/shrink-your-go-binaries-with-this-one-weird-trick/">very
large</a>,
even if you strip DWARF tables - stack trace annotations still remain, and are <em>costly</em>).</p>
<p>Compile times are short (unless you need cgo), there's an interactive runtime
profiler (pprof) at arm's reach, it's relatively cross-platform (there's even
a <a href="https://github.com/tinygo-org/tinygo">tiny variant</a> for embedded), it's
easy to syntax-highlight, and there's now an official <a href="https://github.com/golang/tools/blob/master/gopls/README.md">LSP
server</a> for it.</p>
<p>I've accepted all of these - the good and the bad.</p>
<p>We're here to talk about the ugly.</p>
<h2 id="simple-is-a-lie">Simple is a lie</h2>
<p>Over and over, every piece of documentation for the Go language markets it
as “simple”.</p>
<p>This is a lie.</p>
<p>Or rather, it's a half-truth that conveniently covers up the fact that, when
you make something simple, you move complexity elsewhere.</p>
<p>Computers, operating systems, networks are a hot mess. They're barely
manageable, even if you know a decent amount about what you're doing. Nine
out of ten software engineers agree: it's a miracle anything works at all.</p>
<p>So all the complexity is swept under the rug. Hidden from view, but not
solved.</p>
<p>Here's a simple example.</p>
<div>
    
<p>This example does go on for a while, actually - but don't let the specifics
distract you. While it goes rather in-depth, it illustrates a larger point.</p>
</div>
<p>Most of Go's APIs (much like NodeJS's APIs) are designed for Unix-like
operating systems. This is not surprising, as Rob &amp; Ken are from the <a href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs#History">Plan 9
gang</a>.</p>
<p>So, the file API in Go looks like this:</p>
<pre><code>
<span>type</span> File <span>struct</span> {
    *file 
}

<span><span>func</span> <span>(f *File)</span> <span>Stat</span><span>()</span> <span>(FileInfo, error)</span></span> {
    
}


<span>type</span> FileInfo <span>interface</span> {
	Name() <span>string</span>       
	Size() <span>int64</span>        
	Mode() FileMode     
	ModTime() time.Time 
	IsDir() <span>bool</span>        
	Sys() <span>interface</span>{}   
}






<span>type</span> FileMode <span>uint32</span>






<span>const</span> (
	
	
	ModeDir        FileMode = <span>1</span> &lt;&lt; (<span>32</span> - <span>1</span> - <span>iota</span>) 
	ModeAppend                                     
	ModeExclusive                                  
	ModeTemporary                                  
	ModeSymlink                                    
	ModeDevice                                     
	ModeNamedPipe                                  
	ModeSocket                                     
	ModeSetuid                                     
	ModeSetgid                                     
	ModeCharDevice                                 
	ModeSticky                                     
	ModeIrregular                                  

	
	ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice | ModeCharDevice | ModeIrregular

	ModePerm FileMode = <span>0777</span> 
)
</code></pre>
<p>Makes sense for a Unix, right?</p>
<p>Every file has a mode, there's even a command that lets you dump it as hex:</p>
<pre><code><span>$</span><span> <span>stat</span> -c <span>'%f'</span> /etc/hosts</span>
81a4
<span>$</span><span> <span>stat</span> -c <span>'%f'</span> /usr/bin/man</span>
81ed
</code></pre>
<p>And so, a simple Go program can easily grab those “Unix permission bits”:</p>
<pre><code><span>package</span> main

<span>import</span> (
        <span>"fmt"</span>
        <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
        arg := os.Args[<span>1</span>]
        fi, _ := os.Stat(arg)
        fmt.Printf(<span>"(%s) mode = %o\n"</span>, arg, fi.Mode() &amp; os.ModePerm)
}
</code></pre>
<pre><code><span>$</span><span> go run main.go /etc/hosts</span>
(/etc/hosts) mode = 644
<span>$</span><span> go run main.go /usr/bin/man</span>
(/etc/hosts) mode = 755
</code></pre>
<p>On Windows, files don't have modes. It doesn't have <code>stat</code>, <code>lstat</code>, <code>fstat</code>
syscalls - it has a <code>FindFirstFile</code> family of functions (alternatively,
<code>CreateFile</code> to open, then <code>GetFileAttributes</code>, alternatively,
<code>GetFileInformationByHandle</code>), which takes a pointer to a <code>WIN32_FIND_DATA</code>
structure, which contains <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants">file
attributes</a>.</p>
<p>So, what happens if you run that program on Windows?</p>
<pre><code><span>&gt;</span><span> go run main.go C:\Windows\notepad.exe</span>
(C:\Windows\notepad.exe) mode = 666
</code></pre>
<p>It makes up a mode.</p>
<pre><code>

<span><span>func</span> <span>(fs *fileStat)</span> <span>Mode</span><span>()</span> <span>(m FileMode)</span></span> {
	<span>if</span> fs == &amp;devNullStat {
		<span>return</span> ModeDevice | ModeCharDevice | <span>0666</span>
	}
	<span>if</span> fs.FileAttributes&amp;syscall.FILE_ATTRIBUTE_READONLY != <span>0</span> {
		m |= <span>0444</span>
	} <span>else</span> {
		m |= <span>0666</span>
	}
	<span>if</span> fs.isSymlink() {
		<span>return</span> m | ModeSymlink
	}
	<span>if</span> fs.FileAttributes&amp;syscall.FILE_ATTRIBUTE_DIRECTORY != <span>0</span> {
		m |= ModeDir | <span>0111</span>
	}
	<span>switch</span> fs.filetype {
	<span>case</span> syscall.FILE_TYPE_PIPE:
		m |= ModeNamedPipe
	<span>case</span> syscall.FILE_TYPE_CHAR:
		m |= ModeDevice | ModeCharDevice
	}
	<span>return</span> m
}
</code></pre>
<p>Node.js does the same. There's a <a href="https://nodejs.org/api/fs.html#fs_class_fs_stats">single fs.Stats
“type”</a> for all platforms.</p>
<p>Using “whatever Unix has” as the lowest common denominator is <em>extremely
common</em> in open-source codebases, so it's not surprising.</p>
<p>Let's go a little bit further. On Unix systems, you can change the modes of
files, to make them read-only, or flip the executable bit.</p>
<pre><code><span>package</span> main

<span>import</span> (
	<span>"fmt"</span>
	<span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
	arg := os.Args[<span>1</span>]

	fi, err := os.Stat(arg)
	must(err)
	fmt.Printf(<span>"(%s) old mode = %o\n"</span>, arg, fi.Mode()&amp;os.ModePerm)

	must(os.Chmod(arg, <span>0755</span>))

	fi, err = os.Stat(arg)
	must(err)
	fmt.Printf(<span>"(%s) new mode = %o\n"</span>, arg, fi.Mode()&amp;os.ModePerm)
}

<span><span>func</span> <span>must</span><span>(err error)</span></span> {
	<span>if</span> err != <span>nil</span> {
		<span>panic</span>(err)
	}
}
</code></pre>
<p>Let's run this on Linux:</p>
<pre><code><span>$</span><span> touch test.txt</span>
<span>$</span><span> go run main.go test.txt</span>
(test.txt) old mode = 644
(test.txt) new mode = 755
</code></pre>
<p>And now on Windows:</p>
<pre><code><span>&gt;</span><span> go run main.go test.txt</span>
(test.txt) old mode = 666
(test.txt) new mode = 666
</code></pre>
<p>So, no errors. <code>Chmod</code> just silently does… nothing. Which is reasonably -
there's no equivalent to the “executable bit” for files on Windows.</p>
<p>What does <code>Chmod</code> even do on Windows?</p>
<pre><code>

<span><span>func</span> <span>Chmod</span><span>(path <span>string</span>, mode <span>uint32</span>)</span> <span>(err error)</span></span> {
	p, e := UTF16PtrFromString(path)
	<span>if</span> e != <span>nil</span> {
		<span>return</span> e
	}
	attrs, e := GetFileAttributes(p)
	<span>if</span> e != <span>nil</span> {
		<span>return</span> e
	}
	<span>if</span> mode&amp;S_IWRITE != <span>0</span> {
		attrs &amp;^= FILE_ATTRIBUTE_READONLY
	} <span>else</span> {
		attrs |= FILE_ATTRIBUTE_READONLY
	}
	<span>return</span> SetFileAttributes(p, attrs)
}
</code></pre>
<p>It sets or clears the read-only bit. That's it.</p>
<p>We have an <code>uint32</code> argument, with four billion two hundred ninety-four
million nine hundred sixty-seven thousand two hundred ninety-five possible
values, to encode… one bit of information.</p>
<p>That's a pretty innocent lie. The assumption that files have modes was baked
into the API design from the start, and now, everyone has to live with it.
Just like in Node.JS, and probably tons of other languages.</p>
<p>But <em>it doesn't have to be like that</em>.</p>
<p>A language with a more involved type system, and better designed libraries
could avoid that pitfall.</p>
<p>Out of curiosity, what does Rust do?</p>
<div>
    
<p>Oh, here we go again - Rust, Rust, and Rust again.</p>
<p>Why always Rust?</p>
<p>Well, I tried <em>real hard</em> to keep Rust out of all of this. Among other
things, because people are going to dismiss this article as coming from “a
typical rustacean”.</p>
<p>But for all the problems I raise in this article… Rust gets it right.
If I had another good example, I'd use it. But I don't, so, here goes.</p>
</div>
<p>There's no <code>stat</code>-like function in the Rust standard library. There's
<code>std::fs::metadata</code>:</p>
<pre><code><span>pub</span> <span><span>fn</span> <span>metadata</span></span>&lt;P: <span>AsRef</span>&lt;Path&gt;&gt;(path: P) -&gt; <span>Result</span>&lt;Metadata&gt;
</code></pre>
<p>This function signatures tells us a lot already. It returns a <code>Result</code>, which
means, not only do we know this can fail, we <em>have</em> to handle it. Either by
panicking on error, with <code>.unwrap()</code> or <code>.expect()</code>, or by matching it against
<code>Result::Ok</code> / <code>Result::Err</code>, or by bubbling it up with the <code>?</code> operator.</p>
<p>The point is, this function signature makes it <em>impossible</em> for us to access
an invalid/uninitialized/null <code>Metadata</code>. With a Go function, if you ignore the
returned <code>error</code>, you <em>still</em> get the result - most probably a null pointer.</p>
<p>Also, the argument is not a string - it's a path. Or rather, it's something
that <em>can be turned into a path</em>.</p>
<p>And <code>String</code> <a href="https://doc.rust-lang.org/std/string/struct.String.html#impl-AsRef%3CPath%3E">does implement
<code>AsRef&lt;Path&gt;</code></a>,
so, for simple use cases, it's not troublesome:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> metadata = std::fs::metadata(<span>"Cargo.toml"</span>).unwrap();
    <span>println!</span>(<span>"is dir? {:?}"</span>, metadata.is_dir());
    <span>println!</span>(<span>"is file? {:?}"</span>, metadata.is_file());
}
</code></pre>
<p>But paths are not necessarily strings. On Unix (!), paths can be any sequence
of bytes, except null bytes.</p>
<pre><code><span>$</span><span> <span>cd</span> rustfun/</span>
<span>$</span><span> touch <span>"<span>$(printf "\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98")</span>"</span></span>
<span>$</span><span> ls</span>
ls: cannot compare file names ‘Cargo.lock’ and ‘\275\262=\274 ⌘’: Invalid or incomplete multibyte or wide character
 src   target   Cargo.lock   Cargo.toml  ''$'\275\262''='$'\274'' ⌘'
</code></pre>
<p>We've just made a file with a <em>very naughty</em> name - but it's a perfectly
valid file, even if <code>ls</code> struggles with it.</p>
<pre><code><span>$</span><span> <span>stat</span> <span>"<span>$(printf "\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98")</span>"</span></span>
  File: = ⌘
  Size: 0               Blocks: 0          IO Block: 65536  regular empty file
Device: 8c70d496h/2356204694d   Inode: 72620543991375285  Links: 1
Access: (0644/-rw-r--r--)  Uid: (197611/    amos)   Gid: (197611/    amos)
Access: 2020-02-28 13:12:12.783734000 +0100
Modify: 2020-02-28 13:12:12.783734000 +0100
Change: 2020-02-28 13:12:12.783329400 +0100
 Birth: 2020-02-28 13:12:12.783329400 +0100
</code></pre>
<p>That's not something we can represent with a <code>String</code> in Rust, because <a href="https://fasterthanli.me/blog/2020/working-with-strings-in-rust/">Rust
Strings are valid utf-8</a>, and this isn't.</p>
<p>Rust <code>Path</code>s, however, are… arbitrary byte sequences.</p>
<p>And so, if we use <code>std::fs::read_dir</code>, we have no problem listing it and
getting its metadata:</p>
<pre><code><span>use</span> std::fs;

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> entries = fs::read_dir(<span>"."</span>).unwrap();
    <span>for</span> entry <span>in</span> entries {
        <span>let</span> path = entry.unwrap().path();
        <span>let</span> meta = fs::metadata(&amp;path).unwrap();
        <span>if</span> meta.is_dir() {
            <span>println!</span>(<span>"(dir) {:?}"</span>, path);
        } <span>else</span> {
            <span>println!</span>(<span>"      {:?}"</span>, path);
        }
    }
}
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
(dir) "./src"
      "./Cargo.toml"
      "./.gitignore"
      "./\xBD\xB2=\xBC ⌘"
(dir) "./.git"
      "./Cargo.lock"
(dir) "./target"
</code></pre>
<p>What about Go?</p>
<pre><code><span>package</span> main

<span>import</span> (
        <span>"fmt"</span>
        <span>"os"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
        arg := os.Args[<span>1</span>]
        f, err := os.Open(arg)
        must(err)

        entries, err := f.Readdir(<span>-1</span>)
        must(err)

        <span>for</span> _, e := <span>range</span> entries {
                <span>if</span> e.IsDir() {
                        fmt.Printf(<span>"(dir) %s\n"</span>, e.Name())
                } <span>else</span> {
                        fmt.Printf(<span>"      %s\n"</span>, e.Name())
                }
        }
}

<span><span>func</span> <span>must</span><span>(err error)</span></span> {
        <span>if</span> err != <span>nil</span> {
                <span>panic</span>(err)
        }
}
</code></pre>
<pre><code><span>$</span><span> go build</span>
<span>$</span><span> ./gofun ../rustfun</span>
(dir) src
      Cargo.toml
      .gitignore
      = ⌘
(dir) .git
      Cargo.lock
(dir) target
</code></pre>
<p>It… silently prints a wrong version of the path.</p>
<p>See, there's no “path” type in Go. Just “string”. And Go strings <a href="https://blog.golang.org/strings">are just
byte slices</a>, with no guarantees what's inside.</p>
<p>So it prints garbage, whereas in Rust, <code>Path</code> does not implement <code>Display</code>, so
we couldn't do this:</p>
<pre><code><span>println!</span>(<span>"(dir) {}"</span>, path);
</code></pre>
<p>We had to do this:</p>
<pre><code><span>println!</span>(<span>"(dir) {:?}"</span>, path);
</code></pre>
<p>And if we wanted a friendlier output, we <em>could</em> handle both cases: when
the path happens to be a valid utf-8 string, and when it doesn't:</p>
<pre><code><span>use</span> std::fs;

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> entries = fs::read_dir(<span>"."</span>).unwrap();
    <span>for</span> entry <span>in</span> entries {
        <span>let</span> path = entry.unwrap().path();
        <span>let</span> meta = fs::metadata(&amp;path).unwrap();
        <span>let</span> prefix = <span>if</span> meta.is_dir() {
            <span>"(dir)"</span>
        } <span>else</span> {
            <span>"     "</span>
        };
        <span>match</span> path.to_str() {
            <span>Some</span>(s) =&gt; <span>println!</span>(<span>"{} {}"</span>, prefix, s),
            <span>None</span> =&gt; <span>println!</span>(<span>"{} {:?} (invalid utf-8)"</span>, prefix, path),
        }
    }
}
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
(dir) ./src
      ./Cargo.toml
      ./.gitignore
      "./\xBD\xB2=\xBC ⌘" (invalid utf-8)
(dir) ./.git
      ./Cargo.lock
(dir) ./target
</code></pre>
<p>Go says “don't worry about encodings! things are <em>probably</em> utf-8”.</p>
<p>Except when they aren't. And paths aren't. So, in Go, all path manipulation
routines operate on <code>string</code>, let's take a look at the <code>path/filepath</code> package.</p>
<blockquote>
<p>Package filepath implements utility routines for manipulating filename paths
in a way compatible with the target operating system-defined file paths.</p>
<p>The filepath package uses either forward slashes or backslashes, depending on
the operating system. To process paths such as URLs that always use forward
slashes regardless of the operating system, see the path package.</p>
</blockquote>
<p>What does this package give us?</p>
<pre><code><span><span>func</span> <span>Abs</span><span>(path <span>string</span>)</span> <span>(<span>string</span>, error)</span>
<span>func</span> <span>Base</span><span>(path <span>string</span>)</span> <span>string</span>
<span>func</span> <span>Clean</span><span>(path <span>string</span>)</span> <span>string</span>
<span>func</span> <span>Dir</span><span>(path <span>string</span>)</span> <span>string</span>
<span>func</span> <span>EvalSymlinks</span><span>(path <span>string</span>)</span> <span>(<span>string</span>, error)</span>
<span>func</span> <span>Ext</span><span>(path <span>string</span>)</span> <span>string</span>
<span>func</span> <span>FromSlash</span><span>(path <span>string</span>)</span> <span>string</span>
<span>func</span> <span>Glob</span><span>(pattern <span>string</span>)</span> <span>(matches []<span>string</span>, err error)</span>
<span>func</span> <span>HasPrefix</span><span>(p, prefix <span>string</span>)</span> <span>bool</span>
<span>func</span> <span>IsAbs</span><span>(path <span>string</span>)</span> <span>bool</span>
<span>func</span> <span>Join</span><span>(elem ...<span>string</span>)</span> <span>string</span>
<span>func</span> <span>Match</span><span>(pattern, name <span>string</span>)</span> <span>(matched <span>bool</span>, err error)</span>
<span>func</span> <span>Rel</span><span>(basepath, targpath <span>string</span>)</span> <span>(<span>string</span>, error)</span>
<span>func</span> <span>Split</span><span>(path <span>string</span>)</span> <span>(dir, file <span>string</span>)</span>
<span>func</span> <span>SplitList</span><span>(path <span>string</span>)</span> []<span>string</span>
<span>func</span> <span>ToSlash</span><span>(path <span>string</span>)</span> <span>string</span>
<span>func</span> <span>VolumeName</span><span>(path <span>string</span>)</span> <span>string</span>
<span>func</span> <span>Walk</span><span>(root <span>string</span>, walkFn WalkFunc)</span> <span>error</span>
</span></code></pre>
<p>Strings. Lots and lots of strings. Well, byte slices.</p>
<p>Speaking of bad design decisions - what's that <code>Ext</code> function I see?</p>
<pre><code>


<span><span>func</span> <span>Ext</span><span>(path <span>string</span>)</span> <span>string</span>
</span></code></pre>
<p>Interesting! Let's try it out.</p>
<pre><code><span>package</span> main

<span>import</span> (
        <span>"fmt"</span>
        <span>"path/filepath"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
        inputs := []<span>string</span>{
                <span>"/"</span>,
                <span>"/."</span>,
                <span>"/.foo"</span>,
                <span>"/foo"</span>,
                <span>"/foo.txt"</span>,
                <span>"/foo.txt/bar"</span>,
                <span>"C:\\"</span>,
                <span>"C:\\."</span>,
                <span>"C:\\foo.txt"</span>,
                <span>"C:\\foo.txt\\bar"</span>,
        }
        <span>for</span> _, i := <span>range</span> inputs {
                fmt.Printf(<span>"%24q =&gt; %q\n"</span>, i, filepath.Ext(i))
        }
}

<span><span>func</span> <span>must</span><span>(err error)</span></span> {
        <span>if</span> err != <span>nil</span> {
                <span>panic</span>(err)
        }
}
</code></pre>
<pre><code><span>$</span><span> go run main.go</span>
                     "/" =&gt; ""
                    "/." =&gt; "."
                 "/.foo" =&gt; ".foo"
                  "/foo" =&gt; ""
              "/foo.txt" =&gt; ".txt"
          "/foo.txt/bar" =&gt; ""
                  "C:\\" =&gt; ""
                 "C:\\." =&gt; "."
           "C:\\foo.txt" =&gt; ".txt"
      "C:\\foo.txt\\bar" =&gt; ".txt\\bar"
</code></pre>
<p>Right away, I'm in debating mood - is <code>.foo</code>'s extension <em>really</em> <code>.foo</code>? But
let's move on.</p>
<p>This example was run on Linux, so <code>C:\foo.txt\bar</code>'s extension, according
to <code>filepath.Ext</code>, is.. <code>.txt\bar</code>.</p>
<p>Why? Because the Go standard library makes the assumption that a platform has
a single path separator - on Unix and BSD-likes, it's <code>/</code>, and on Windows
it's <code>\\</code>.</p>
<p>Except… that's not the whole truth. I was curious, so I checked:</p>
<pre><code>

<span><span>void</span> <span>main</span><span>()</span> </span>{
  HANDLE hFile = CreateFile(<span>"C:/Users/amos/test.txt"</span>, GENERIC_WRITE, <span>0</span>, <span>NULL</span>,
                            CREATE_NEW, FILE_ATTRIBUTE_NORMAL, <span>NULL</span>);

  <span>char</span> *data = <span>"Hello from the Win32 API"</span>;
  DWORD dwToWrite = (DWORD) <span>strlen</span>(data);
  DWORD dwWritten = <span>0</span>;
  WriteFile(hFile, data, dwToWrite, &amp;dwWritten, <span>NULL</span>);
  CloseHandle(hFile);
}
</code></pre>
<pre><code><span>&gt;</span><span> cl fun.c</span>
Microsoft (R) C/C++ Optimizing Compiler Version 19.23.28107 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

fun.c
Microsoft (R) Incremental Linker Version 14.23.28107.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:fun.exe
fun.obj
<span>&gt;</span><span> .\fun.exe</span>
<span>&gt;</span><span> <span>type</span> C:\Users\amos\test.txt</span>
Hello from the Win32 API
</code></pre>
<p>No funny <a href="https://www.msys2.org/">Unix emulation</a> business going on - just
regular old Windows 10.</p>
<p>And yet, in Go's standard library, the <code>path/filepath</code> package exports those
constants:</p>
<pre><code><span>const</span> (
    Separator     = os.PathSeparator
    ListSeparator = os.PathListSeparator
)
</code></pre>
<p><code>os</code>, in turn, exports:</p>
<pre><code>
<span>const</span> (
	PathSeparator     = <span>'\\' // OS-specific path separator
	PathListSeparator = '</span>;<span>'  // OS-specific path list separator
)
</span></code></pre>
<p>So how comes <code>filepath.Ext</code> works with both separators on Windows?</p>
<pre><code><span>$</span><span> go run main.go</span>
                     "/" =&gt; ""
                    "/." =&gt; "."
                 "/.foo" =&gt; ".foo"
                  "/foo" =&gt; ""
              "/foo.txt" =&gt; ".txt"
          "/foo.txt/bar" =&gt; ""
                  "C:\\" =&gt; ""
                 "C:\\." =&gt; "."
           "C:\\foo.txt" =&gt; ".txt"
      "C:\\foo.txt\\bar" =&gt; ""
</code></pre>
<p>Let's look at its implementation:</p>
<pre><code>

<span><span>func</span> <span>Ext</span><span>(path <span>string</span>)</span> <span>string</span></span> {
	<span>for</span> i := <span>len</span>(path) - <span>1</span>; i &gt;= <span>0</span> &amp;&amp; !os.IsPathSeparator(path[i]); i-- {
		<span>if</span> path[i] == <span>'.'</span> {
			<span>return</span> path[i:]
		}
	}
	<span>return</span> <span>""</span>
}
</code></pre>
<p>Ah. An <code>IsPathSeparator</code> function.</p>
<p>Sure enough:</p>
<pre><code>


<span><span>func</span> <span>IsPathSeparator</span><span>(c <span>uint8</span>)</span> <span>bool</span></span> {
	
	<span>return</span> c == <span>'\\' || c == '</span>/<span>'
}
</span></code></pre>
<p>(Can I just point out how hilarious that “Extension” was deemed long
enough to abbreviate to “Ext”, but “IsPathSeparator” wasn't?)</p>
<p>How does Rust handle this?</p>
<p>It has <code>std::path::is_separator</code>:</p>
<pre><code>

<span>pub</span> <span><span>fn</span> <span>is_separator</span></span>(c: <span>char</span>) -&gt; <span>bool</span>
</code></pre>
<p>And it has <code>std::path::MAIN_SEPARATOR</code> - emphasis on <em>main</em> separator:</p>
<pre><code>


<span>pub</span> <span>const</span> MAIN_SEPARATOR: <span>char</span>
</code></pre>
<p>The naming along makes it much clearer that there <em>might</em> be secondary path
separators, and the rich Path manipulation API makes it much less likely
to find this kind of code, for example:</p>
<pre><code>	DefaultScripts = <span>"downloads"</span> + <span>string</span>(os.PathSeparator) + <span>"defaultScripts"</span>
</code></pre>
<p>Or this kind:</p>
<pre><code>	<span>if</span> os.PathSeparator == <span>'/'</span> {
		projname = strings.Replace(name, <span>"\\"</span>, <span>"/"</span>, <span>-1</span>)
	} <span>else</span> <span>if</span> os.PathSeparator == <span>'\\' {
		projname = strings.Replace(name, "/", "\\", -1)
	}
</span></code></pre>
<p>Or this… kind:</p>
<pre><code>filefullpath = fmt.Sprintf(<span>"%s%c%s%c%s%c%s%c%s%s"</span>,
		a.DataDir, os.PathSeparator,
		m[<span>0</span>:<span>1</span>], os.PathSeparator,
		m[<span>1</span>:<span>2</span>], os.PathSeparator,
		m[<span>2</span>:<span>3</span>], os.PathSeparator,
		m, ext)
</code></pre>
<p>It turns out Rust also has a “get a path's extension” function, but it's a lot
more conservative in the promises it makes:</p>
<pre><code>







<span>pub</span> <span><span>fn</span> <span>extension</span></span>(&amp;<span>self</span>) -&gt; <span>Option</span>&lt;&amp;OsStr&gt;
</code></pre>
<p>Let's submit it to the same test:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> inputs = [
        <span>r"/"</span>,
        <span>r"/."</span>,
        <span>r"/.foo"</span>,
        <span>r"/foo"</span>,
        <span>r"/foo.txt"</span>,
        <span>r"/foo.txt/bar"</span>,
        <span>r"C:\"</span>,
        <span>r"C:\."</span>,
        <span>r"C:\foo.txt"</span>,
        <span>r"C:\foo.txt\bar"</span>,
    ];
    <span>for</span> input <span>in</span> &amp;inputs {
        <span>use</span> std::path::Path;
        <span>println!</span>(<span>"{:&gt;20} =&gt; {:?}"</span>, input, Path::new(input).extension());
    }
}
</code></pre>
<p>On Linux:</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
                   / =&gt; None
                  /. =&gt; None
               /.foo =&gt; None
               /foo. =&gt; Some("")
                /foo =&gt; None
            /foo.txt =&gt; Some("txt")
        /foo.txt/bar =&gt; None
                 C:\ =&gt; None
                C:\. =&gt; Some("")
          C:\foo.txt =&gt; Some("txt")
      C:\foo.txt\bar =&gt; Some("txt\\bar")
</code></pre>
<p>On Windows:</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
                   / =&gt; None
                  /. =&gt; None
               /.foo =&gt; None
               /foo. =&gt; Some("")
                /foo =&gt; None
            /foo.txt =&gt; Some("txt")
        /foo.txt/bar =&gt; None
                 C:\ =&gt; None
                C:\. =&gt; None
          C:\foo.txt =&gt; Some("txt")
      C:\foo.txt\bar =&gt; None
</code></pre>
<p>Like Go, it gives a <code>txt\bar</code> extension for a Windows path on Linux.</p>
<p>Unlike Go, it:</p>
<ul>
<li>Doesn't think “/.foo” has a file extension</li>
<li>Distinguishes between the “/foo.” case (<code>Some("")</code>) and the “/foo” case (<code>None</code>)</li>
</ul>
<p>Let's also look at the Rust implementation of <code>std::path::extension</code>:</p>
<pre><code><span>pub</span> <span><span>fn</span> <span>extension</span></span>(&amp;<span>self</span>) -&gt; <span>Option</span>&lt;&amp;OsStr&gt; {
	<span>self</span>.file_name().map(split_file_at_dot).and_then(|(before, after)| before.and(after))
}
</code></pre>
<p>Let's dissect that: first it calls <code>file_name()</code>. How does that work? Is it where
it searches for path separators backwards from the end of the path?</p>
<pre><code><span>pub</span> <span><span>fn</span> <span>file_name</span></span>(&amp;<span>self</span>) -&gt; <span>Option</span>&lt;&amp;OsStr&gt; {
	<span>self</span>.components().next_back().and_then(|p| <span>match</span> p {
		Component::Normal(p) =&gt; <span>Some</span>(p.as_ref()),
		_ =&gt; <span>None</span>,
	})
}
</code></pre>
<p>No! It calls <code>components</code> which returns a type that implements <code>DoubleEndedIterator</code> -
an iterator you can navigate from the front or the back. <em>Then</em> it grabs the first item
from the back - if any - and returns that.</p>
<p>The iterator <em>does</em> look for path separators - lazily, in a re-usable way. There is
no code duplication, like in the Go library:</p>
<pre><code>

<span><span>func</span> <span>dirname</span><span>(path <span>string</span>)</span> <span>string</span></span> {
	vol := volumeName(path)
	i := <span>len</span>(path) - <span>1</span>
	<span>for</span> i &gt;= <span>len</span>(vol) &amp;&amp; !IsPathSeparator(path[i]) {
		i--
	}
	dir := path[<span>len</span>(vol) : i+<span>1</span>]
	last := <span>len</span>(dir) - <span>1</span>
	<span>if</span> last &gt; <span>0</span> &amp;&amp; IsPathSeparator(dir[last]) {
		dir = dir[:last]
	}
	<span>if</span> dir == <span>""</span> {
		dir = <span>"."</span>
	}
	<span>return</span> vol + dir
}
</code></pre>
<p>So, now we have <em>only the file name</em>. If we had <code>/foo/bar/baz.txt</code>, we're now only
dealing with <code>baz.txt</code> - as an <code>OsStr</code>, <em>not</em> a utf-8 <code>String</code>. We can still have
random bytes.</p>
<p>We then map this result through <code>split_file_at_dot</code>, which behaves like so:</p>
<ul>
<li>For <code>"foo"</code>, return <code>(Some("foo"), None)</code></li>
<li>For <code>"foo.bar"</code>, return <code>(Some("foo"), Some("bar"))</code></li>
<li>For <code>"foo.bar.baz"</code>, return <code>(Some("foo.bar"), Some("baz"))</code></li>
</ul>
<p><code>and_then</code>, we only return <code>after</code> if <code>before</code> wasn't <code>None</code>.</p>
<p>If we spelled out everything, we'd have:</p>
<pre><code><span>pub</span> <span><span>fn</span> <span>extension</span></span>(&amp;<span>self</span>) -&gt; <span>Option</span>&lt;&amp;OsStr&gt; {
	<span>if</span> <span>let</span> <span>Some</span>(file_name) = <span>self</span>.file_name() {
		<span>let</span> (before, after) = split_file_at_dot(file_name);
		<span>if</span> <span>let</span> <span>Some</span>(before) {
			
			
			<span>return</span> after
		}
	}
	<span>None</span>
}
</code></pre>
<p>The problem is carefully modelled. We can look at <em>what</em> we're manipulating
just by looking at its type. If it might not exist, it's an <code>Option&lt;T&gt;</code>! If
it's a path with multiple components, it's a <code>&amp;Path</code> (or its owned
counterpart, <code>PathBuf</code>). If it's just part of a path, it's an <code>&amp;OsStr</code>.</p>
<p>Of course there's a learning curve. Of course there's more concepts involved
than just throwing for loops at byte slices and seeing what sticks, like the
Go library does.</p>
<p>But the result is a high-performance, reliable and type-safe library.</p>
<p>It's worth it.</p>
<p>Speaking of Rust, we haven't seen how it handles the whole “mode” thing yet.</p>
<p>So <code>std::fs::Metadata</code> has <code>is_dir()</code> and <code>is_file()</code>, which return booleans.
It also has <code>len()</code>, which returns an <code>u64</code> (unsigned 64-bit integer).</p>
<p>It has <code>created()</code>, <code>modified()</code>, and <code>accessed()</code>, all of which return an
<code>Option&lt;SystemTime&gt;</code>. Again - the types inform us on what scenarios are
possible. Access timestamps might not exist at all.</p>
<p>The returned time is not an <code>std::time::Instant</code> - it's an
<code>std::time::SystemTime</code> - the documentation tells us the difference:</p>
<blockquote>
<p>A measurement of the system clock, useful for talking to external entities
like the file system or other processes.</p>
<p>Distinct from the
<a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>Instant</code></a> type,
this time measurement <strong>is not monotonic</strong>. This means that you can save a
file to the file system, then save another file to the file system, <strong>and the
second file has a <code>SystemTime</code> measurement earlier than the first</strong>. In other
words, an operation that happens after another operation in real time may
have an earlier <code>SystemTime</code>!</p>
<p>Consequently, comparing two <code>SystemTime</code> instances to learn about the
duration between them returns a
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> instead of
an infallible
<a href="https://doc.rust-lang.org/std/time/struct.Duration.html"><code>Duration</code></a> to
indicate that this sort of time drift may happen and needs to be handled.</p>
<p>Although a <code>SystemTime</code> cannot be directly inspected, the
<a href="https://doc.rust-lang.org/std/time/constant.UNIX_EPOCH.html"><code>UNIX_EPOCH</code></a>
constant is provided in this module as an anchor in time to learn information
about a <code>SystemTime</code>. By calculating the duration from this fixed point in
time, a <code>SystemTime</code> can be converted to a human-readable time, or perhaps
some other string representation.</p>
<p>The size of a <code>SystemTime</code> struct may vary depending on the target operating
system.</p>
<p>Source: <a href="https://doc.rust-lang.org/std/time/struct.SystemTime.html">https://doc.rust-lang.org/std/time/struct.SystemTime.html</a></p>
</blockquote>

<p>What about permissions? Well, there it is:</p>
<pre><code><span>pub</span> <span><span>fn</span> <span>permissions</span></span>(&amp;<span>self</span>) -&gt; Permissions
</code></pre>
<p>A <code>Permissions</code> type! Just for that! And we can afford it, too - because
types don't cost anything at runtime. Everything probably ends up inlined
anyway.</p>
<p>What does it expose?</p>
<pre><code><span>pub</span> <span><span>fn</span> <span>readonly</span></span>(&amp;<span>self</span>) -&gt; <span>bool</span> {}
<span>pub</span> <span><span>fn</span> <span>set_readonly</span></span>(&amp;<span>mut</span> <span>self</span>, readonly: <span>bool</span>) {}
</code></pre>
<p>Well! It exposes <em>only what all supported operating systems have in common</em>.</p>
<p>Can we still get Unix permission? Of course! But <em>only</em> on Unix:</p>
<blockquote>
<p>Representation of the various permissions on a file.</p>
<p>This module only currently provides one bit of information,
<a href="https://doc.rust-lang.org/std/fs/struct.Permissions.html#method.readonly"><code>readonly</code></a>,
which is exposed on all currently supported platforms. Unix-specific
functionality, such as mode bits, is available through the
<a href="https://doc.rust-lang.org/std/os/unix/fs/trait.PermissionsExt.html"><code>PermissionsExt</code></a>
trait.</p>
<p>Source: <a href="https://doc.rust-lang.org/std/fs/struct.Permissions.html">https://doc.rust-lang.org/std/fs/struct.Permissions.html</a></p>
</blockquote>
<p><code>std::os::unix::fs::PermissionsExt</code> is only compiled in on Unix, and exposes
the following functions:</p>
<pre><code><span><span>fn</span> <span>mode</span></span>(&amp;<span>self</span>) -&gt; <span>u32</span> {}
<span><span>fn</span> <span>set_mode</span></span>(&amp;<span>mut</span> <span>self</span>, mode: <span>u32</span>) {}
<span><span>fn</span> <span>from_mode</span></span>(mode: <span>u32</span>) -&gt; <span>Self</span> {}
</code></pre>
<p>The documentation makes it <em>really clear</em> it's Unix-only:</p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/unix-only.png" alt=""></p>
<p>But it's not just documentation. This sample program will compile and run
on Linux (and macOS, etc.)</p>
<pre><code><span>use</span> std::fs::File;
<span>use</span> std::os::unix::fs::PermissionsExt;

<span><span>fn</span> <span>main</span></span>() -&gt; std::io::<span>Result</span>&lt;()&gt; {
    <span>let</span> f = File::open(<span>"/usr/bin/man"</span>)?;
    <span>let</span> metadata = f.metadata()?;
    <span>let</span> permissions = metadata.permissions();

    <span>println!</span>(<span>"permissions: {:o}"</span>, permissions.mode());
    <span>Ok</span>(())
}
</code></pre>
<pre><code><span>$</span><span> cargo run --quiet</span>
permissions: 100755
</code></pre>
<p>But will fail to compile on Windows:</p>
<pre><code><span>$</span><span> cargo run --quiet</span>
error[E0433]: failed to resolve: could not find `unix` in `os`
<span> --&gt;</span><span> src\main.rs:2:14</span>
  |
2 | use std::os::unix::fs::PermissionsExt;
  |              ^^^^ could not find `unix` in `os`

error[E0599]: no method named `mode` found for type `std::fs::Permissions` in the current scope
<span> --&gt;</span><span> src\main.rs:9:47</span>
  |
9 |     println!("permissions: {:o}", permissions.mode());
  |                                               ^^^^ method not found in `std::fs::Permissions`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0433, E0599.
For more information about an error, try `rustc --explain E0433`.
error: could not compile `rustfun`.

To learn more, run the command again with --verbose.
</code></pre>
<p>How can we make a program that runs on Windows too? The same way
the standard library only exposes <code>PermissionsExt</code> on Unix: with
attributes.</p>
<pre><code><span>use</span> std::fs::File;
<span>#[cfg(target_family = <span>"unix"</span>)]</span>
<span>use</span> std::os::unix::fs::PermissionsExt;

<span><span>fn</span> <span>main</span></span>() -&gt; std::io::<span>Result</span>&lt;()&gt; {
    <span>let</span> arg = std::env::args().nth(<span>1</span>).unwrap();
    <span>let</span> f = File::open(&amp;arg)?;
    <span>let</span> metadata = f.metadata()?;
    <span>let</span> permissions = metadata.permissions();

    <span>#[cfg(target_family = <span>"unix"</span>)]</span>
    {
        <span>println!</span>(<span>"permissions: {:o}"</span>, permissions.mode());
    }

    <span>#[cfg(target_family = <span>"windows"</span>)]</span>
    {
        <span>println!</span>(<span>"readonly? {:?}"</span>, permissions.readonly());
    }

    <span>Ok</span>(())
}
</code></pre>
<p>Those aren't <code>#ifdef</code> - they're not preprocessor directives. There's no risk
of forgetting an <code>#endif</code>. And if you miss if/else chains, <a href="https://github.com/alexcrichton/cfg-if">there's a crate
for that</a>.</p>
<p>Here's that sample program on Linux:</p>
<pre><code><span>$</span><span> cargo run --quiet -- /usr/bin/man</span>
permissions: 100755
</code></pre>
<p>And on Windows:</p>
<pre><code><span>$</span><span> cargo run --quiet -- Cargo.toml</span>
readonly? false
</code></pre>
<p>Can you do that in Go? Sure! Kind of!</p>
<p>There's two ways to do something similar, and both involve multiple files.</p>
<p>Here's one:</p>
<pre><code><span>$</span><span> go mod init github.com/fasterthanlime/gofun</span>
</code></pre>
<p>In <code>main.go</code>, we need:</p>
<pre><code><span>package</span> main

<span>import</span> <span>"os"</span>

<span><span>func</span> <span>main</span><span>()</span></span> {
        poke(os.Args[<span>1</span>])
}
</code></pre>
<p>In <code>poke_windows.go</code>, we need:</p>
<pre><code><span>package</span> main

<span>import</span> (
        <span>"fmt"</span>
        <span>"os"</span>
)

<span><span>func</span> <span>poke</span><span>(path <span>string</span>)</span></span> {
        stats, _ := os.Stat(path)
        fmt.Printf(<span>"readonly? %v\n"</span>, (stats.Mode() &amp; <span>0</span>o600) == <span>0</span>);
}
</code></pre>
<p>And in <code>poke_unix.go</code>, we need:</p>
<pre><code>

<span>package</span> main

<span>import</span> (
        <span>"fmt"</span>
        <span>"os"</span>
)

<span><span>func</span> <span>poke</span><span>(path <span>string</span>)</span></span> {
		stats, _ := os.Stat(path)
		fmt.Printf(<span>"permissions: %o\n"</span>, stats.Mode() &amp; os.ModePerm);
}
</code></pre>
<p>Note how the <code>_windows.go</code> suffix is magic - it'll get automatically excluded
on non-Windows platforms. There's no magic suffix for Unix systems though!</p>
<p>So we have to add a <a href="https://golang.org/pkg/go/build/">build constraint</a>, which is:</p>
<ul>
<li>A comment</li>
<li>That must be “near the top of the file”</li>
<li>That can only be preceded by blank space</li>
<li>That must appear before the package clause</li>
<li>That has its own language</li>
</ul>
<p>From the docs:</p>
<blockquote>
<p>A build constraint is evaluated as the OR of space-separated options. Each
option evaluates as the AND of its comma-separated terms. Each term consists
of letters, digits, underscores, and dots. A term may be negated with a
preceding !. For example, the build constraint:</p>
<p><code>// +build linux,386 darwin,!cgo</code></p>
<p>corresponds to the boolean formula:</p>
<p><code>(linux AND 386) OR (darwin AND (NOT cgo))</code></p>
<p>A file may have multiple build constraints. The overall constraint is the AND
of the individual constraints. That is, the build constraints:</p>
<p><code>// +build linux darwin</code><br>
<code>// +build 386</code></p>
<p>corresponds to the boolean formula:</p>
<p><code>(linux OR darwin) AND 386</code></p>
</blockquote>
<p>Fun! Fun fun fun. So, on Linux, we get:</p>
<pre><code><span>$</span><span> go build</span>
<span>$</span><span> ./gofun /usr/bin/man</span>
permissions: 755
<span>$</span><span> ./gofun /etc/hosts</span>
permissions: 644
</code></pre>
<p>And on Windows, we get:</p>
<pre><code><span>&gt;</span><span> go build</span>
<span>&gt;</span><span> .\gofun.exe .\main.go</span>
readonly? false
</code></pre>
<p>Now, <em>at least there's a way</em> to write platform-specific code in Go.</p>
<p>In practice, it gets old very quickly. You now have related code split across
multiple files, even if <em>only one</em> of the functions is platform-specific.</p>
<p>Build constraints override the magic suffixes, so it's never obvious exactly
which files are compiled in. You also have to duplicate (and keep in sync!)
function signatures all over the place.</p>
<p>It's… a hack. A shortcut. And an annoying one, at that.</p>
<p>So what happens when you make it hard for users to do things the right way?
(The right way being, in this case, to <em>not</em> compile in code that isn't relevant
for a given platform). They take shortcuts, too.</p>
<p>Even in the official Go distribution, a lot of code just switches on the value
of <code>runtime.GOOS</code> at, well, run-time:</p>
<pre><code>

<span><span>func</span> <span>TestFileConn</span><span>(t *testing.T)</span></span> {
	<span>switch</span> runtime.GOOS {
	<span>case</span> <span>"plan9"</span>, <span>"windows"</span>:
		t.Skipf(<span>"not supported on %s"</span>, runtime.GOOS)
	}

	<span>for</span> _, tt := <span>range</span> fileConnTests {
		<span>if</span> !testableNetwork(tt.network) {
			t.Logf(<span>"skipping %s test"</span>, tt.network)
			<span>continue</span>
		}
</code></pre>
<p>“But these are little things!”</p>
<p>They're all little things. They add up. Quickly.</p>
<p>And they're symptomatic of the problems with “the Go way” in general. The Go
way is to half-ass things.</p>
<p>The Go way is to patch things up until they sorta kinda work, in the name of
simplicity.</p>
<h2 id="lots-of-little-things">Lots of little things</h2>
<p>Speaking of little things, let's consider what pushed me over the edge and
provoked me to write this whole rant in the first place.</p>
<p>It was <a href="https://github.com/getlantern/idletiming">this package</a>.</p>
<p>What does it do?</p>
<blockquote>
<p>Provides mechanisms for adding idle timeouts to <code>net.Conn</code> and <code>net.Listener</code>.</p>
</blockquote>
<p>Why do we need it?</p>
<p>Because the real-world is messy.</p>
<p>If you do a naive HTTP request in Go:</p>
<pre><code><span>package</span> main

<span>import</span> (
	<span>"fmt"</span>
	<span>"io/ioutil"</span>
	<span>"net/http"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
	res, err := http.Get(<span>"http://perdu.com"</span>)
	must(err)
	<span>defer</span> res.Body.Close() 

	body, err := ioutil.ReadAll(res.Body)
	must(err)
	fmt.Printf(<span>"%s"</span>, <span>string</span>(body))
}

<span><span>func</span> <span>must</span><span>(err error)</span></span> {
	<span>if</span> err != <span>nil</span> {
		<span>panic</span>(err)
	}
}
</code></pre>
<pre><code><span>$</span><span> go run main.go</span>
&lt;html&gt;&lt;head&gt;&lt;title&gt;Vous Etes Perdu ?&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Perdu sur l'Internet ?&lt;/h1&gt;&lt;h2&gt;Pas de panique, on va vous aider&lt;/h2&gt;&lt;strong&gt;&lt;pre&gt;    * &lt;----- vous &amp;ecirc;tes ici&lt;/pre&gt;&lt;/strong&gt;&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>Then it works. When it works.</p>
<p>If the server never accepts your connection - which might <em>definitely</em> happen
if it's dropping all the traffic to the relevant port, then you'll just hang
forever.</p>
<p>If you <em>don't</em> want to hang forever, you have to do something else.</p>
<p>Like this:</p>
<pre><code><span>package</span> main

<span>import</span> (
	<span>"fmt"</span>
	<span>"io/ioutil"</span>
	<span>"net"</span>
	<span>"net/http"</span>
	<span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
	client := &amp;http.Client{
		Transport: &amp;http.Transport{
			DialContext: (&amp;net.Dialer{
				Timeout: <span>5</span> * time.Second,
			}).DialContext,
		},
	}

	req, err := http.NewRequest(<span>"GET"</span>, <span>"http://perdu.com"</span>, <span>nil</span>)
	must(err)

	res, err := client.Do(req)
	must(err)
	<span>defer</span> res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	must(err)
	fmt.Printf(<span>"%s"</span>, <span>string</span>(body))
}

<span><span>func</span> <span>must</span><span>(err error)</span></span> {
	<span>if</span> err != <span>nil</span> {
		<span>panic</span>(err)
	}
}
</code></pre>
<p>Not so simple, but, eh, whatever, it works.</p>
<p>Unless the server accepts your connection, says it's going to send a bunch of bytes,
and then <em>never sends you anything</em>.</p>
<p>Which definitely, 100%, for-sure, if-it-can-happen-it-does-happen, happens.</p>
<p>And then you hang forever.</p>
<p>To avoid that, you can set a timeout on <em>the whole request</em>, like so:</p>
<pre><code><span>package</span> main

<span>import</span> (
	<span>"context"</span>
	<span>"fmt"</span>
	<span>"io/ioutil"</span>
	<span>"net/http"</span>
	<span>"time"</span>
)

<span><span>func</span> <span>main</span><span>()</span></span> {
	ctx, cancel := context.WithTimeout(context.Background(), <span>5</span>*time.Second)
	<span>defer</span> cancel()
	req, err := http.NewRequestWithContext(ctx, <span>"GET"</span>, <span>"http://perdu.com"</span>, <span>nil</span>)
	must(err)

	res, err := http.DefaultClient.Do(req)
	must(err)
	<span>defer</span> res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	must(err)
	fmt.Printf(<span>"%s"</span>, <span>string</span>(body))
}

<span><span>func</span> <span>must</span><span>(err error)</span></span> {
	<span>if</span> err != <span>nil</span> {
		<span>panic</span>(err)
	}
}
</code></pre>
<p>But that doesn't work if you're planning on uploading something large, for
example. How many seconds is enough to upload a large file? Is 30 seconds
enough? And how do you know you're spending those seconds uploading, and not
waiting for the server to accept your request?</p>
<p>So, <code>getlantern/idletiming</code> adds a mechanism for timing out <em>if there hasn't
been any data transmitted in a while</em>, which is distinct from a dial timeout,
and doesn't force you to set a timeout on the <em>whole request</em>, so that it
works for arbitrarily large uploads.</p>
<p>The repository looks innocent enough:</p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/idle-repo.png" alt=""></p>
<p>Just a couple files! And even some tests. Also - it works. I'm using it
in production. I'm happy with it.</p>
<p>There's just.. one thing.</p>
<pre><code><span>$</span><span> git <span>clone</span> https://github.com/getlantern/idletiming</span>
Cloning into 'idletiming'...
(cut)
<span>$</span><span> <span>cd</span> idletiming</span>
<span>$</span><span> go mod graph | wc -l</span>
196
</code></pre>
<p>I'm sorry?</p>
<p>One hundred and ninety-six packages?</p>
<p>Well, I mean… lots of small, well-maintained libraries isn't necessarily a
bad idea - I never really agreed that the takeaway from the <code>left-pad</code> disaster
was “small libraries are bad”.</p>
<p>Let's look at what we've got there:</p>
<pre><code><span>$</span><span> go mod graph</span>
github.com/getlantern/idletiming github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183
github.com/getlantern/idletiming github.com/getlantern/fdcount@v0.0.0-20190912142506-f89afd7367c4
github.com/getlantern/idletiming github.com/getlantern/golog@v0.0.0-20190830074920-4ef2e798c2d7
github.com/getlantern/idletiming github.com/getlantern/grtrack@v0.0.0-20160824195228-cbf67d3fa0fd
github.com/getlantern/idletiming github.com/getlantern/mtime@v0.0.0-20170117193331-ba114e4a82b0
github.com/getlantern/idletiming github.com/getlantern/netx@v0.0.0-20190110220209-9912de6f94fd
github.com/getlantern/idletiming github.com/stretchr/testify@v1.4.0
</code></pre>
<p>I'm sure all of these are reasonable. Lantern is a “site unblock” product, so
it has to deal with networking a lot, it makes sense that they'd have their
own libraries for a bunch of things, including logging (<code>golog</code>) and some
network extensions (<code>netx</code>). <code>testify</code> is a well-known set of testing
helpers, I use it too!</p>
<p>Let's keep going:</p>
<pre><code>github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/Shopify/sarama@v1.23.1
</code></pre>
<p>Uhh….</p>
<pre><code>github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/aristanetworks/fsnotify@v1.4.2
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/aristanetworks/glog@v0.0.0-20180419172825&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/aristanetworks/splunk-hec-go@v0.3.3
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/garyburd/redigo@v1.6.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/golang/protobuf@v1.3.2
</code></pre>
<p>Wait, I think we..</p>
<pre><code>github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/influxdata/influxdb1-client@v0.0.0-201908&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/klauspost/cpuid@v1.2.1
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/klauspost/reedsolomon@v1.9.2
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/kylelemons/godebug@v1.1.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/onsi/ginkgo@v1.10.1
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/onsi/gomega@v1.7.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/openconfig/gnmi@v0.0.0-20190823184014-89b&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/openconfig/reference@v0.0.0-2019072701583&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/prometheus/client_golang@v1.1.0
</code></pre>
<p>I can understand some of these but…</p>
<pre><code>github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/satori/go.uuid@v1.2.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/stretchr/testify@v1.3.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/templexxx/cpufeat@v0.0.0-20180724012125-c&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/templexxx/xor@v0.0.0-20181023030647-4e92f&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/tjfoc/gmsm@v1.0.1
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/xtaci/kcp-go@v5.4.5+incompatible
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/xtaci/lossyconn@v0.0.0-20190602105132-8df&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/net@v0.0.0-20190912160710-24e19bdeb0f2
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/sys@v0.0.0-20190912141932-bc967efca4b8
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/time@v0.0.0-20190308202827-9d24e82272b4
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/tools@v0.0.0-20190912185636-87d9f09c5d89
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 google.golang.org/grpc@v1.23.1
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/bsm/ratelimit.v1@v1.0.0-20160220154919-db14&gt;
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/jcmturner/goidentity.v3@v3.0.0
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/redis.v4@v4.2.4
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/yaml.v2@v2.2.2
</code></pre>
<p>STOP! Just stop. Stop it already.</p>
<p>It keeps going on, and on. There's everything.</p>
<p><a href="https://en.wikipedia.org/wiki/YAML">YAML</a>, <a href="https://redis.io/">Redis</a>,
<a href="https://grpc.io/">GRPC</a>, which in turns needs
<a href="https://developers.google.com/protocol-buffers/">protobuf</a>,
<a href="https://en.wikipedia.org/wiki/InfluxDB">InfluxDB</a>, an <a href="https://github.com/Shopify/sarama">Apache Kafka
client</a>, a
<a href="https://prometheus.io/">Prometheus</a> client,
<a href="https://en.wikipedia.org/wiki/Snappy_(compression)">Snappy</a>,
<a href="https://en.wikipedia.org/wiki/Zstandard">Zstandard</a>,
<a href="https://lz4.github.io/lz4/">LZ4</a>, <a href="https://github.com/shopify/toxiproxy">a chaos-testing TCP
proxy</a>, three other logging packages, and client
libraries for various Google Cloud services.</p>
<p>What could <em>possibly</em> justify all this?</p>
<p>Let's review:</p>
<pre><code>

<span>package</span> idletiming

<span>import</span> (
	<span>"net"</span>
	<span>"time"</span>
)
</code></pre>
<p>Only built-in imports. Good.</p>
<pre><code>



<span>package</span> idletiming

<span>import</span> (
	<span>"errors"</span>
	<span>"io"</span>
	<span>"net"</span>
	<span>"sync"</span>
	<span>"sync/atomic"</span>
	<span>"time"</span>

	<span>"github.com/getlantern/golog"</span>
	<span>"github.com/getlantern/mtime"</span>
	<span>"github.com/getlantern/netx"</span>
)
</code></pre>
<p>This one is the meat of the library, so to say, and it requires a few of the
<code>getlantern</code> packages we've seen:</p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/golog-graph.png" alt=""></p>
<p>It does end up importing <code>golang.org/x/net/http2/hpack</code> - but that's just because
of <code>net/http</code>. These are built-ins, so let's ignore them for now.</p>
<p><code>getlantern/hex</code> is self-contained, so, moving on to <code>getlantern/mtime</code>:</p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/mtime-graph.png" alt=""></p>
<p>That's it? What's why Go ends up fetching <em>the entire</em>
<code>github.com/aristanetworks/goarista</code> repository, and <em>all its transitive
dependencies</em>?</p>
<p>What does <code>aristanetworks/goariasta/monotime</code> even do?</p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/monotime-github.png" alt=""></p>
<p>Mh. Let's look inside <code>issue15006.s</code></p>
<pre><code>





</code></pre>
<p>I uh… okay.</p>
<p>What does <a href="https://github.com/golang/go/issues/15006">that issue</a> say?</p>
<blockquote>
<p>This is known and I think the empty assembly file is the accepted fix.</p>
<p>It's a rarely used feature and having an assembly file also make it
standout.</p>
<p>I don't think we should make this unsafe feature easy to use.</p>
</blockquote>
<p>And later (emphasis mine):</p>
<blockquote>
<p>I agree with Minux. If you're looking at a Go package to import, you might
want to know if it does any unsafe trickery. Currently you have to grep for
an import of unsafe <strong>and look for non-.go files</strong>. If we got rid of the
requirement for the empty .s file, then you'd have to grep for //go:linkname
also.</p>
</blockquote>
<p>That's… that's certainly a stance.</p>
<p>But <em>which</em> unsafe feature exactly?</p>
<p>Let's look at <code>nanotime.go</code>:</p>
<pre><code>




<span>package</span> monotime

<span>import</span> (
	<span>"time"</span>
	_ <span>"unsafe"</span> 
)



<span><span>func</span> <span>nanotime</span><span>()</span> <span>int64</span>

// <span>Now</span> <span>returns</span> <span>the</span> <span>current</span> <span>time</span> <span>in</span> <span>nanoseconds</span> <span>from</span> <span>a</span> <span>monotonic</span> <span>clock</span>.
// <span>The</span> <span>time</span> <span>returned</span> <span>is</span> <span>based</span> <span>on</span> <span>some</span> <span>arbitrary</span> <span>platform</span>-<span>specific</span> <span>point</span> <span>in</span> <span>the</span>
// <span>past</span>.  <span>The</span> <span>time</span> <span>returned</span> <span>is</span> <span>guaranteed</span> <span>to</span> <span>increase</span> <span>monotonically</span> <span>at</span> <span>a</span>
// <span>constant</span> <span>rate</span>, <span>unlike</span> <span>time</span>.<span>Now</span><span>()</span> <span>from</span> <span>the</span> <span>Go</span> <span>standard</span> <span>library</span>, <span>which</span> <span>may</span>
// <span>slow</span> <span>down</span>, <span>speed</span> <span>up</span>, <span>jump</span> <span>forward</span> <span>or</span> <span>backward</span>, <span>due</span> <span>to</span> <span>NTP</span> <span>activity</span> <span>or</span> <span>leap</span>
// <span>seconds</span>.
<span>func</span> <span>Now</span><span>()</span> <span>uint64</span></span> {
	<span>return</span> <span>uint64</span>(nanotime())
}



<span><span>func</span> <span>Since</span><span>(t <span>uint64</span>)</span> <span>time</span>.<span>Duration</span></span> {
	<span>return</span> time.Duration(Now() - t)
}
</code></pre>
<p>That's it. That's the whole package.</p>
<p>The unsafe feature in question is being able to access unexported (read:
lowercase, <em>sigh</em>) symbols from the Go standard library.</p>
<p>Why is that even needed?</p>
<p>If you remember from earlier, Rust has two types for time: <code>SystemTime</code>,
which corresponds to your… system's… time, which can be adjusted via
<a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">NTP</a>. It can go
back, so subtraction can fail.</p>
<p>And it has <code>Instant</code>, which is weakly monotonically increasing - at worse,
it'll give the same value twice, but never <em>less</em> than the previous value.
This is useful to measure elapsed time <em>within a process</em>.</p>
<p>How did Go solve that problem?</p>
<p>At first, <a href="https://github.com/golang/go/issues/16658">it didn't</a>. Monotonic
time measurement is a hard problem, so it was only available internally, in
the standard library, not for regular Go developers (a common theme):</p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/expose-nanotime.png" alt=""></p>
<p>And then, <a href="https://github.com/golang/go/issues/12914">it did</a>.</p>
<p>Sort of. In the most “Go way” possible.</p>
<blockquote>
<p>I thought some more about the suggestion above to reuse <code>time.Time</code> with a
special location. The special location still seems wrong, but what if we
reuse <code>time.Time</code> by storing inside it both a wall time and a monotonic time,
fetched one after the other?</p>
<p>Then there are two kinds of <code>time.Time</code>s: those with wall <em>and</em> monotonic
stored inside (let's call those “wall+monotonic Times”) and those with only
wall stored inside (let's call those “wall-only Times”).</p>
<p>Suppose further that:</p>
<ul>
<li><code>time.Now</code> returns a wall+monotonic Time.</li>
<li>for <code>t.Add(d)</code>, if t is a wall+monotonic Time, so is the result;
if t is wall-only, so is the result.</li>
<li>all other functions that return Times return wall-only Times. These include:
<code>time.Date</code>, <code>time.Unix</code>, <code>t.AddDate</code>, <code>t.In</code>, <code>t.Local</code>, <code>t.Round</code>, <code>t.Truncate</code>,
<code>t.UTC</code></li>
<li>for <code>t.Sub(u)</code>, if t and u are both wall+monotonic, the result is computed by
subtracting monotonics; otherwise the result is computed by subtracting wall
times. - <code>t.After(u)</code>, <code>t.Before(u)</code>, <code>t.Equal(u)</code> compare monotonics if available
(just like <code>t.Sub(u)</code>), otherwise walls.</li>
<li>all the other functions that operate on time.Times use the wall time only.
These include: <code>t.Day</code>, <code>t.Format</code>, <code>t.Month</code>, <code>t.Unix</code>, <code>t.UnixNano</code>, <code>t.Year</code>, and so on.</li>
</ul>
<p>Doing this returns a kind of hybrid time from <code>time.Now</code>: it works as a wall
time but also works as a monotonic time, and future operations use the right
one.</p>
</blockquote>
<p>So, as of Go 1.9 - problem solved!</p>
<p>If you're confused by the proposal, no worries, let's check out the release notes:</p>
<blockquote>
<h3 id="transparent-monotonic-time-support">Transparent Monotonic Time support</h3>
<p>The <a href="https://golang.org/pkg/time/"><code>time</code></a> package now transparently tracks
monotonic time in each <a href="https://golang.org/pkg/time/#Time"><code>Time</code></a> value,
making computing durations between two <code>Time</code> values a safe operation in the
presence of wall clock adjustments. See the <a href="https://golang.org/pkg/time/#hdr-Monotonic_Clocks">package
docs</a> and <a href="https://golang.org/design/12914-monotonic">design
document</a> for details.</p>
</blockquote>
<p>This changed the behavior of a number of Go packages, but, the core team
knows best:</p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/breaking-change.png" alt="">
This <em>is</em> a breaking change, but more importantly, it wasn't before the
introduction of Go modules (declared “stable” as of Go 1.14) that you could
require a certain Go version for a package.</p>
<p>So, if you have a package without a minimum required Go version, you can't be
sure you have the “transparent monotonic time support” of Go 1.9, and it's
better to rely on <code>aristanetworks/goarista/monotime</code>, which pulls 100+ packages,
because Go packages are “simple” and they're just folders in a git repository.</p>

<p>The change raised other questions: since <code>time.Time</code> now sometimes packs two
types of time, two calls are needed. This concern was dismissed.</p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/two-calls.png" alt=""></p>
<p>In order for <code>time.Time</code> not to grow, both values were <em>packed</em> inside it, which
restricted the range of times that could be represented with it:</p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/packing.png" alt=""></p>
<p>This issue was raised early on in the design process:</p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/embedded1.png" alt=""></p>
<p><img src="https://fasterthanli.me/img/i-want-off-mr-golangs-wild-ride/embedded2.png" alt=""></p>
<p>You can check out <a href="https://github.com/golang/go/issues/12914">the complete
thread</a> for a full history.</p>
<h2 id="parting-words">Parting words</h2>
<p>This is just one issue. But there are many like it - this one is as good an
example as any.</p>
<p>Over and over, Go is a victim of its own mantra - “simplicity”.</p>
<p>It constantly takes power away from its users, reserving it for itself.</p>
<p>It constantly lies about how complicated real-world systems are, and optimize
for the 90% case, ignoring correctness.</p>
<p>It is a minefield of subtle gotchas that have very real implications -
everything looks simple <em>on the surface</em>, but nothing is.</p>
<p>The <a href="https://dave.cheney.net/2014/03/19/channel-axioms">Channel Axioms</a> are a
good example. There is nothing explicit about them. They are invented truths,
that were convenient to implement, and who everyone must now work around.</p>
<p>Here's a fun gotcha I haven't mentioned yet:</p>
<pre><code>

<span>type</span> IdleTimingConn <span>struct</span> {
	
	
	lastActivityTime <span>uint64</span>

	
}
</code></pre>
<p>The documentation reads:</p>
<blockquote>
<p>BUGS</p>
<p>On ARM, x86-32, and 32-bit MIPS, it is the caller's responsibility to arrange
for 64-bit alignment of 64-bit words accessed atomically. The first word in a
variable or in an allocated struct, array, or slice can be relied upon to be
64-bit aligned.</p>
</blockquote>
<p>If the condition isn't satisfied, it panics at run-time. Only on 32-bit
platforms. I didn't have to go far to hit this one - I got bit by this bug
multiple times in the last few years.</p>
<p>It's a footnote. Not a compile-time check. There's an <a href="https://github.com/golang/go/issues/11891">in-progress
lint</a>, for very simple cases, because
Go's simplicity made it extremely hard to check for.</p>
<p>This fake “simplicity” runs deep in the Go ecosystem. Rust has the opposite
problem - things look scary at first, but it's for a good reason. The problems
tackled have inherent complexity, and it takes some effort to model them
appropriately.</p>
<p>At this point in time, I deeply regret investing in Go.</p>
<p>Go is a Bell Labs fantasy, and not a very good one at that.</p>


          



          
        </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>