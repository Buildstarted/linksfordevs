<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Excluding health check endpoints from Serilog request logging: Using Serilog.AspNetCore in ASP.NET Core 3.0 - Part 4 -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Excluding health check endpoints from Serilog request logging: Using Serilog.AspNetCore in ASP.NET Core 3.0 - Part 4</h1>
    <div class="post-content">
<p>In previous posts in this series I have described how to configure Serilog&apos;s RequestLogging middleware to add additional properties to Serilog&apos;s request log summary such as the request hostname or the selected endpoint name. I have also showed how to add MVC or RazorPage-specific properties to the summary log using Filters. </p>
<p>In this post I show how to <em>skip</em> adding the summary log message completely for specific requests. This can be useful when you have an endpoint that is hit a lot, where logging every request is of little value.</p> <p>The motivation for this post comes from behaviour we&apos;ve seen when running applications in Kubernetes. Kubernetes uses two types of &quot;health checks&quot; (or &quot;probes&quot;) for checking applications are running correctly - liveness probes and readiness probes. You can configure a probe to make an HTTP request to your application as an indicator that your application is running correctly.</p>
<blockquote>
<p>As of Kubernetes version 1.16 there is a third type of probe, <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes">startup probes</a>.</p>
</blockquote>
<p>The <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks">Health Check endpoints</a> available in ASP.NET Core 2.2+ are ideally suited for these probes. You can set up a simple, dumb, health check that returns a <code>200 OK</code> response to every request, to let Kubernetes know your app hasn&apos;t crashed.</p>
<p>In ASP.NET Core 3.x, you can configure your health checks using endpoint routing. You must add the required services in <em>Startup.cs</em> by calling <code>AddHealthChecks()</code>, and add a health check endpoint using <code>MapHealthChecks()</code>:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Startup</span>
<span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ConfigureServices</span><span class="token punctuation">(</span><span class="token class-name">IServiceCollection</span> services<span class="token punctuation">)</span> <span class="token punctuation">{</span> services<span class="token punctuation">.</span><span class="token function">AddHealthChecks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IApplicationBuilder</span> app<span class="token punctuation">,</span> <span class="token class-name">IWebHostEnvironment</span> env<span class="token punctuation">)</span> <span class="token punctuation">{</span> app<span class="token punctuation">.</span><span class="token function">UseRouting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> app<span class="token punctuation">.</span><span class="token function">UseAuthorization</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> app<span class="token punctuation">.</span><span class="token function">UseEndpoints</span><span class="token punctuation">(</span>endpoints <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> endpoints<span class="token punctuation">.</span><span class="token function">MapHealthChecks</span><span class="token punctuation">(</span><span class="token string">&quot;/healthz&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> endpoints<span class="token punctuation">.</span><span class="token function">MapControllers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the example above, sending a request to <code>/healthz</code> will invoke the health check endpoint. As I didn&apos;t configure any health checks to run, the endpoint will always return a <code>200</code> response, as long as the app is running:</p>
<p><img src="/content/images/2019/serilog_health_check.png" alt="Health check response"></p>
<p>The only problem with this is that Kubernetes will call this endpoint a <em>lot</em>. The exact frequency is up to you, but every 10s is common. You want a relatively high frequency so Kubernetes can restart faulty pods quickly.</p>
<p>That&apos;s not a problem in of itself; Kestrel can handle millions of requests a second, so it&apos;s not a performance concern. More irritating is the number of logs generated by each request. It&apos;s <a href="/using-serilog-aspnetcore-in-asp-net-core-3-reducing-log-verbosity/">not as many as I showed for a request to the MVC infrastructure</a>, but even 1 log per request (as we get with Serilog.AspNetCore) can get irritating. </p>
<p>The main problem is that the logs for successful health check requests don&apos;t actually tell us anything useful. They&apos;re not related to any business activities, they&apos;re purely infrastructural. It would be nice to be able to skip the Serilog request summary logs for these. In the next section I introduce the approach I came up with that relies on the changes from the previous posts in this series.</p> <p>In <a href="/using-serilog-aspnetcore-in-asp-net-core-3-logging-the-selected-endpoint-name-with-serilog/">a previous post</a> I showed how to include <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#endpoint-routing-differences-from-earlier-versions-of-routing">the selected endpoint</a> in your Serilog request logs. <a href="/using-serilog-aspnetcore-in-asp-net-core-3-logging-the-selected-endpoint-name-with-serilog/#setting-values-in-idiagnosticcontext">My approach was to provide a custom function</a> to the <code>RequestLoggingOptions.EnrichDiagnosticContext</code> property when registering the Serilog middleware:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IApplicationBuilder</span> app<span class="token punctuation">,</span> <span class="token class-name">IWebHostEnvironment</span> env<span class="token punctuation">)</span>
<span class="token punctuation">{</span> app<span class="token punctuation">.</span><span class="token function">UseSerilogRequestLogging</span><span class="token punctuation">(</span>opts <span class="token operator">=</span><span class="token operator">&gt;</span> opts<span class="token punctuation">.</span>EnrichDiagnosticContext <span class="token operator">=</span> LogHelper<span class="token punctuation">.</span>EnrichFromRequest<span class="token punctuation">)</span><span class="token punctuation">;</span> app<span class="token punctuation">.</span><span class="token function">UseRouting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> app<span class="token punctuation">.</span><span class="token function">UseAuthorization</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> app<span class="token punctuation">.</span><span class="token function">UseEndpoints</span><span class="token punctuation">(</span>endpoints <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> endpoints<span class="token punctuation">.</span><span class="token function">MapHealthChecks</span><span class="token punctuation">(</span><span class="token string">&quot;/healthz&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> endpoints<span class="token punctuation">.</span><span class="token function">MapControllers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>RequestLoggingOptions</code> has another property, <code>GetLevel</code>, which is a <code>Func&lt;&gt;</code> used to decide the logging level that should be used for a given request log. By default, <a href="https://github.com/serilog/serilog-aspnetcore/blob/dev/src/Serilog.AspNetCore/SerilogApplicationBuilderExtensions.cs#L31-L36">it&apos;s set to the following function</a>:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SerilogApplicationBuilderExtensions</span>
<span class="token punctuation">{</span> <span class="token keyword">static</span> <span class="token class-name">LogEventLevel</span> <span class="token function">DefaultGetLevel</span><span class="token punctuation">(</span><span class="token class-name">HttpContext</span> ctx<span class="token punctuation">,</span> <span class="token keyword">double</span> _<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> ex <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> LogEventLevel<span class="token punctuation">.</span>Error <span class="token punctuation">:</span> ctx<span class="token punctuation">.</span>Response<span class="token punctuation">.</span>StatusCode <span class="token operator">&gt;</span> <span class="token number">499</span> <span class="token operator">?</span> LogEventLevel<span class="token punctuation">.</span>Error <span class="token punctuation">:</span> LogEventLevel<span class="token punctuation">.</span>Information<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This function checks if an exception was thrown for the request, or if the response code is a <code>5xx</code> error. If so, it create an <code>Error</code> level summary log, otherwise it creates an <code>Information</code> level log. </p>
<p>Lets say you wanted the summary logs to be logged as <code>Debug</code> instead of <code>Information</code>. First, you would create a helper function like the following which has the required logic:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LogHelper</span>
<span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">LogEventLevel</span> <span class="token function">CustomGetLevel</span><span class="token punctuation">(</span><span class="token class-name">HttpContext</span> ctx<span class="token punctuation">,</span> <span class="token keyword">double</span> _<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> ex <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> LogEventLevel<span class="token punctuation">.</span>Error <span class="token punctuation">:</span> ctx<span class="token punctuation">.</span>Response<span class="token punctuation">.</span>StatusCode <span class="token operator">&gt;</span> <span class="token number">499</span> <span class="token operator">?</span> LogEventLevel<span class="token punctuation">.</span>Error <span class="token punctuation">:</span> LogEventLevel<span class="token punctuation">.</span>Debug<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
<p>Then you can set the level function when you call <code>UseSerilogRequestLogging()</code>:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IApplicationBuilder</span> app<span class="token punctuation">,</span> <span class="token class-name">IWebHostEnvironment</span> env<span class="token punctuation">)</span>
<span class="token punctuation">{</span> app<span class="token punctuation">.</span><span class="token function">UseSerilogRequestLogging</span><span class="token punctuation">(</span>opts <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> opts<span class="token punctuation">.</span>EnrichDiagnosticContext <span class="token operator">=</span> LogHelper<span class="token punctuation">.</span>EnrichFromRequest<span class="token punctuation">;</span> opts<span class="token punctuation">.</span>GetLevel <span class="token operator">=</span> LogHelper<span class="token punctuation">.</span>CustomGetLevel<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
<p>Now your request summary logs will all be logged as <code>Debug</code>, except when an error occurs (<a href="https://datalust.co/seq/">screenshot from Seq</a>):</p>
<p><img src="/content/images/2019/seq_debug.png" alt="Seq showing debug request logs"></p>
<p>But how does this help our verbosity problem? </p>
<p>When you configure Serilog, you typically define the minimum request level. For example, the following simple configuration sets the default level to <code>Debug()</code>, and writes to a console Sink:</p>
<pre class="language-csharp"><code class="language-csharp">Log<span class="token punctuation">.</span>Logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LoggerConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span>MinimumLevel<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span>WriteTo<span class="token punctuation">.</span><span class="token function">Console</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">CreateLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>So the simple way for a log to be filtered is for the <em>log level</em> to be lower than the <code>MinimumLevel</code> specified in the logger configuration. Generally speaking, if you use the lowest level available, <code>Verbose</code>, it will pretty much always be filtered out. </p>
<p>The difficulty is that we don&apos;t want to <em>always</em> use <code>Verbose</code> as the log level for our summary logs. If we do that, we won&apos;t get any request logs for non-errors, and the Serilog middleware becomes a bit pointless! </p>
<p>Instead, we want to set the log level to <code>Verbose</code> <em>only</em> for requests that hit the health check endpoint. In the next section I&apos;ll show how to identify those requests while leaving other requests unaffected.</p> <p>The key thing we need is the ability to identify a health-check request at the point the log is written. As shown previously, the <code>GetLevel()</code> method takes the current <code>HttpContext</code> as a parameter, so theoretically there&apos;s a few options. The most obvious choices to me are:</p>
<ul>
<li>Compare the <code>HttpContext.Request</code> path to a known list of health-check paths</li>
<li>Use the selected Endpoint metadata to identify when a health-check endpoint was called</li>
</ul>
<p>The first option is the most obvious, but it&apos;s not really worth the hassle. Once you get into the weeds of it, you find you have to start duplicating request paths around and handling various edge cases, so I&apos;m going to skip over that one here.</p>
<p>The second option uses a similar approach to the one <a href="/using-serilog-aspnetcore-in-asp-net-core-3-logging-the-selected-endpoint-name-with-serilog/#setting-values-in-idiagnosticcontext">in my previous post</a> where we obtain the <code>IEndpointFeature</code> that was selected by the <code>EndpointRoutingMiddleware</code> for a given request. This feature (if present) provides details such as the display name and route data for the selected Endpoint. </p>
<p>If we assume that health checks are <a href="https://github.com/aspnet/AspNetCore/blob/master/src/Middleware/HealthChecks/src/Builder/HealthCheckEndpointRouteBuilderExtensions.cs#L18">registered using their default Display Name</a> of <code>&quot;Health checks&quot;</code>, then we can identify a &quot;health check&quot; request using the <code>HttpContext</code> as follows:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LogHelper</span>
<span class="token punctuation">{</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">IsHealthCheckEndpoint</span><span class="token punctuation">(</span><span class="token class-name">HttpContext</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">var</span> endpoint <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">GetEndpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>endpoint <span class="token keyword">is</span> <span class="token keyword">object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span> endpoint<span class="token punctuation">.</span>DisplayName<span class="token punctuation">,</span> <span class="token string">&quot;Health checks&quot;</span><span class="token punctuation">,</span> StringComparison<span class="token punctuation">.</span>Ordinal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>We can use this function, combined with a custom version of <a href="https://github.com/serilog/serilog-aspnetcore/blob/dev/src/Serilog.AspNetCore/SerilogApplicationBuilderExtensions.cs#L31-L36">the default <code>GetLevel</code> function</a> to ensure that summary logs for health check requests use a <code>Verbose</code> level, while errors use <code>Error</code> and other requests use <code>Information</code>:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LogHelper</span>
<span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">LogEventLevel</span> <span class="token function">ExcludeHealthChecks</span><span class="token punctuation">(</span><span class="token class-name">HttpContext</span> ctx<span class="token punctuation">,</span> <span class="token keyword">double</span> _<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> ex <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> LogEventLevel<span class="token punctuation">.</span>Error <span class="token punctuation">:</span> ctx<span class="token punctuation">.</span>Response<span class="token punctuation">.</span>StatusCode <span class="token operator">&gt;</span> <span class="token number">499</span> <span class="token operator">?</span> LogEventLevel<span class="token punctuation">.</span>Error <span class="token punctuation">:</span> <span class="token function">IsHealthCheckEndpoint</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token operator">?</span> LogEventLevel<span class="token punctuation">.</span>Verbose <span class="token punctuation">:</span> LogEventLevel<span class="token punctuation">.</span>Information<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This nested ternary has an extra level to it - for non-errors we check if an endpoint with the display name <code>&quot;Health check&quot;</code> was selected, and if it was, we use the level <code>Verbose</code>, otherwise we use <code>Information</code>.</p>
<blockquote>
<p>You could generalise this code further, to allow passing in other display names, or customising the log levels used. I didn&apos;t do that here for simplicity, but <a href="https://github.com/andrewlock/blog-examples/tree/master/SerilogRequestLogging">the associated sample code on GitHub shows how you could do this</a>.</p>
</blockquote>
<p>All that remains is to update the Serilog middleware <code>RequestLoggingOptions</code> to use your new function:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IApplicationBuilder</span> app<span class="token punctuation">,</span> <span class="token class-name">IWebHostEnvironment</span> env<span class="token punctuation">)</span>
<span class="token punctuation">{</span> app<span class="token punctuation">.</span><span class="token function">UseSerilogRequestLogging</span><span class="token punctuation">(</span>opts <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> opts<span class="token punctuation">.</span>EnrichDiagnosticContext <span class="token operator">=</span> LogHelper<span class="token punctuation">.</span>EnrichFromRequest<span class="token punctuation">;</span> opts<span class="token punctuation">.</span>GetLevel <span class="token operator">=</span> LogHelper<span class="token punctuation">.</span>ExcludeHealthChecks<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
<p>When you check your logs after running your application you&apos;ll see your normal request logs for standard requests, but no sign of your health checks (unless an error occurs!). In the following screenshot I configured Serilog to also record <code>Verbose</code> logs so you can see the health check requests - normally they will be filtered out!</p>
<p><img src="/content/images/2019/seq_verbose.png" alt="Seq screenshot showing Health Check requests using Verbose level"></p> <p>In this post I showed how to provide a custom function to the Serilog middleware&apos;s <code>RequestLoggingOptions</code> that defines what <code>LogEventLevel</code> to use for a given request&apos;s log. I showed how this can be used to change the default level to <code>Debug</code> for example. If the level you choose is lower than the minimum level, it will be filtered out completely and not logged.</p>
<p>I showed that you could use this approach to filter out the common (but low-interest) request logs generated by calling health check endpoints. Generally speaking these requests are only interesting if they indicate a problem, but they will typically generate a request log when they succeed as well. As these endpoints are called very frequently they can significantly increase the number of logs written. </p>
<p>The approach in this post is to check the selected <code>IEndpointFeature</code> and check if it has the display name <code>&quot;Health checks&quot;</code>. If it does, the request log is written with the <code>Verbose</code> level, which is commonly filtered out. For more flexibility you could customise the logs shown in this post to handle multiple endpoint names, or any other criteria you have.</p>
</div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>