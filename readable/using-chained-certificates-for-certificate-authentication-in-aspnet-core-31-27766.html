<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using Chained Certificates for Certificate Authentication in ASP.NET Core 3.1 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Using Chained Certificates for Certificate Authentication in ASP.NET Core 3.1 - linksfor.dev(s)"/>
    <meta property="article:author" content="damienbod"/>
    <meta property="og:description" content="This article shows how to create self signed certificates and use these for chained certificate authentication in ASP.NET Core. By using chained certificates, each client application can use a uniq&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://damienbod.com/2019/06/27/using-chained-certificates-for-certificate-authentication-in-asp-net-core-3-0/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Using Chained Certificates for Certificate Authentication in ASP.NET Core 3.1</title>
<div class="readable">
        <h1>Using Chained Certificates for Certificate Authentication in ASP.NET Core 3.1</h1>
            <div>by damienbod</div>
            <div>Reading time: 11-14 minutes</div>
        <div>Posted here: 28 Jun 2019</div>
        <p><a href="https://damienbod.com/2019/06/27/using-chained-certificates-for-certificate-authentication-in-asp-net-core-3-0/">https://damienbod.com/2019/06/27/using-chained-certificates-for-certificate-authentication-in-asp-net-core-3-0/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>

							<p>This article shows how to create self signed certificates and use these for chained certificate authentication in ASP.NET Core. By using chained certificates, each client application can use a unique certificate which was created from a root CA directly, or an intermediate certificate which was created from the root CA. The clients can then be grouped or authenticated as required.</p>
<p><strong>Code</strong> <a href="https://github.com/damienbod/AspNetCoreCertificateAuth" rel="nofollow">https://github.com/damienbod/AspNetCoreCertificateAuth</a></p>
<p>Posts in this series</p>
<ul>
<li><a href="https://damienbod.com/2019/06/13/certificate-authentication-in-asp-net-core-3-0/">Certificate Authentication in ASP.NET Core 3.1 (Self Signed)</a>
</li>
<li>Using Chained Certificates for Certificate Authentication in ASP.NET Core 3.1</li>
<li><a href="https://damienbod.com/2019/09/07/using-certificate-authentication-with-ihttpclientfactory-and-httpclient/">Using Certificate Authentication with IHttpClientFactory and HttpClient</a></li>
</ul>
<p><strong>History</strong></p>
<p><strong>2020-01-22:</strong> Updated certificates, now using CertificateManager<br>
<strong>2019-12-06:</strong> Updated Nuget packages, .NET Core 3.1<br>
<strong>2019-09-06:</strong> Updated Nuget packages, .NET Core 3 preview 9</p>
<p><strong>Creating the Certificates</strong></p>
<p>Creating the certificates is the hardest part in setting up this flow. A self signed <strong>Root CA Certificate</strong> is created using the <a href="https://www.nuget.org/packages/CertificateManager/">CertificateManager </a>nuget package. When creating this, please use a strong password, replace the demo one, do not just copy the code.</p>
<div><div id="highlighter_793755"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p></td><td><div><p><code>var</code> <code>serviceProvider = </code><code>new</code> <code>ServiceCollection()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.AddCertificateManager()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.BuildServiceProvider();</code></p><p><code>var</code> <code>createClientServerAuthCerts = </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>serviceProvider.GetService&lt;CreateCertificatesClientServerAuth&gt;();</code></p><p><code>var</code> <code>root = createClientServerAuthCerts.NewRootCertificate(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>DistinguishedName { CommonName = </code><code>"root_localhost"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Country = </code><code>"CH"</code> <code>},</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>ValidityPeriod { ValidFrom = DateTime.UtcNow, </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ValidTo = DateTime.UtcNow.AddYears(10) },</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>3, </code><code>"localhost"</code><code>);</code></p><p><code>root.FriendlyName = </code><code>"root_localhost certificate"</code><code>;</code></p><p><code>string</code> <code>password = </code><code>"1234"</code><code>;</code></p><p><code>var</code> <code>importExportCertificate = serviceProvider.GetService&lt;ImportExportCertificate&gt;();</code></p><p><code>var</code> <code>rootCertInPfxBtyes = importExportCertificate.ExportRootPfx(password, root);</code></p><p><code>File.WriteAllBytes(</code><code>"root_localhost.pfx"</code><code>, rootCertInPfxBtyes);</code></p></div></td></tr></tbody></table></div></div>
<p>Install the root certificate in the trusted root of the host windows PC. If deploying this on Linux, different tools need to be used.</p>
<p><a href="https://social.msdn.microsoft.com/Forums/SqlServer/en-US/5ed119ef-1704-4be4-8a4f-ef11de7c8f34/a-certificate-chain-processed-but-terminated-in-a-root-certificate-which-is-not-trusted-by-the" rel="nofollow">https://social.msdn.microsoft.com/Forums/SqlServer/en-US/5ed119ef-1704-4be4-8a4f-ef11de7c8f34/a-certificate-chain-processed-but-terminated-in-a-root-certificate-which-is-not-trusted-by-the</a></p>
<p>A chained <strong>intermediate certificate</strong> can now be created from the root certificate. This is not required for all use cases, but you might need to create many certificates or need to activate, disable groups of certificates. The TextExtension parameter is required to set the pathlength in the basic constraints of the certificate. </p>
<p>The intermediate certificate can then be added to the trusted intermediate certificate in the windows host system.</p>
<div><div id="highlighter_508321"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p></td><td><div><p><code>var</code> <code>intermediate = createClientServerAuthCerts</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.NewIntermediateChainedCertificate(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>DistinguishedName { CommonName = </code><code>"intermediate_localhost"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Country = </code><code>"CH"</code> <code>},</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>ValidityPeriod { ValidFrom = DateTime.UtcNow, </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ValidTo = DateTime.UtcNow.AddYears(10) },</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>2, </code><code>"localhost"</code><code>, root);</code></p><p><code>intermediate.FriendlyName = </code><code>"intermediate_localhost certificate"</code><code>;</code></p><p><code>string</code> <code>password = </code><code>"1234"</code><code>;</code></p><p><code>var</code> <code>importExportCertificate = serviceProvider.GetService&lt;ImportExportCertificate&gt;();</code></p><p><code>var</code> <code>intermediateCertInPfxBtyes = importExportCertificate.ExportChainedCertificatePfx(password, intermediate, root);</code></p><p><code>File.WriteAllBytes(</code><code>"intermediate_localhost.pfx"</code><code>, intermediateCertInPfxBtyes);</code></p></div></td></tr></tbody></table></div></div>
<p>A <strong>child certificate</strong> can be created from the intermediate certificate. This is the end entity and does not need to create more child certificates.</p>
<div><div id="highlighter_305344"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p></td><td><div><p><code>var</code> <code>client = createClientServerAuthCerts.NewClientChainedCertificate(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>DistinguishedName { CommonName = </code><code>"client"</code><code>, Country = </code><code>"CH"</code> <code>},</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>ValidityPeriod { ValidFrom = DateTime.UtcNow, ValidTo = DateTime.UtcNow.AddYears(10) },</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"localhost"</code><code>, intermediate);</code></p><p><code>client.FriendlyName = </code><code>"client certificate"</code><code>;</code></p><p><code>string</code> <code>password = </code><code>"1234"</code><code>;</code></p><p><code>var</code> <code>importExportCertificate = serviceProvider.GetService&lt;ImportExportCertificate&gt;();</code></p><p><code>var</code> <code>clientCertInPfxBtyes = importExportCertificate.ExportChainedCertificatePfx(password, client, intermediate);</code></p><p><code>File.WriteAllBytes(</code><code>"client.pfx"</code><code>, clientCertInPfxBtyes);</code></p></div></td></tr></tbody></table></div></div>
<p>See the CertificateManager documentation for details in creating certificates.</p>
<p><a href="https://github.com/damienbod/AspNetCoreCertificates" rel="nofollow">https://github.com/damienbod/AspNetCoreCertificates</a></p>
<p><strong>Server Setup</strong></p>
<p>Now that the certificates are setup, the applications are created like in the previous <a href="https://damienbod.com/2019/06/13/certificate-authentication-in-asp-net-core-3-0/">blog</a>. The AddAuthentication is configured to only accept CertificateTypes.Chained and the RevocationMode is set to NoCheck because we are using self signed chained certificates.</p>
<div><div id="highlighter_141869"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p></td><td><div><p><code>services.AddAuthentication(CertificateAuthenticationDefaults.AuthenticationScheme)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.AddCertificate(options =&gt; </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.AllowedCertificateTypes = CertificateTypes.Chained;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.RevocationMode = X509RevocationMode.NoCheck;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.Events = </code><code>new</code> <code>CertificateAuthenticationEvents</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>OnCertificateValidated = context =&gt;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>validationService =</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context.HttpContext.RequestServices.GetService&lt;MyCertificateValidationService&gt;();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(validationService.ValidateCertificate(context.ClientCertificate))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>claims = </code><code>new</code><code>[]</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>Claim(ClaimTypes.NameIdentifier, context.ClientCertificate.Subject, ClaimValueTypes.String, context.Options.ClaimsIssuer),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>Claim(ClaimTypes.Name, context.ClientCertificate.Subject, ClaimValueTypes.String, context.Options.ClaimsIssuer)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>};</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context.Principal = </code><code>new</code> <code>ClaimsPrincipal(</code><code>new</code> <code>ClaimsIdentity(claims, context.Scheme.Name));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context.Success();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context.Fail(</code><code>"invalid cert"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>Task.CompletedTask;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>};</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>});</code></p></div></td></tr></tbody></table></div></div>
<p>The application is configured in the program class to use the root certificate to validate the requests.</p>
<div><div id="highlighter_294155"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p></td><td><div><p><code>public</code> <code>static</code> <code>IWebHost BuildWebHost(</code><code>string</code><code>[] args)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>=&gt; WebHost.CreateDefaultBuilder(args)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.UseStartup&lt;Startup&gt;()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.ConfigureKestrel(options =&gt;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>cert = </code><code>new</code> <code>X509Certificate2(Path.Combine(</code><code>"root_ca_dev_damienbod.pfx"</code><code>), </code><code>"1234"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.ConfigureHttpsDefaults(o =&gt;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>o.ServerCertificate = cert;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>o.ClientCertificateMode = ClientCertificateMode.RequireCertificate;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>});</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>})</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.Build();</code></p></div></td></tr></tbody></table></div></div>
<p>The custom validation can then be added to the MyCertificateValidationService class. Here the client certificates are validated against the root certificate, or the intermediate certificate. This change be extended to use a dynamic list of Issuers and Subjects so that certificates can be activated or deactivated at runtime.</p>
<div><div id="highlighter_718442"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p></td><td><div><p><code>using</code> <code>System.Collections.Generic;</code></p><p><code>using</code> <code>System.IO;</code></p><p><code>using</code> <code>System.Security.Cryptography.X509Certificates;</code></p><p><code>namespace</code> <code>AspNetCoreCertificateAuthApi</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>class</code> <code>MyCertificateValidationService </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>bool</code> <code>ValidateCertificate(X509Certificate2 clientCertificate)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>CheckIfThumbprintIsValid(clientCertificate);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>private</code> <code>bool</code> <code>CheckIfThumbprintIsValid(X509Certificate2 clientCertificate)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>listOfValidThumbprints = </code><code>new</code> <code>List&lt;</code><code>string</code><code>&gt;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"CBF52D037D4CF0401F8EC8260C6382520D60EDD3"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"BEE026E73A64D58943A66451D94389FA466169A4"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"70D38240A71DD2882B4103E703F94D0B22285B0D"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"ABF302B616CDEED10C53EA2C0E07CA1616814C68"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>};</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(listOfValidThumbprints.Contains(clientCertificate.Thumbprint))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>true</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>false</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p><strong>Client Code</strong></p>
<p>The client application is then setup to send the client certificate in the X-ARR-ClientCert request header. The server API is configured to use this to receive the certificates from the client. Now the chained certificates can be used to get access to the API.</p>
<div><div id="highlighter_760515"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p></td><td><div><p><code>private</code> <code>async</code> <code>Task&lt;JsonDocument&gt; CallApiClientIntermediateLocalhost()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>try</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>client = _clientFactory.CreateClient(</code><code>"client"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>request = </code><code>new</code> <code>HttpRequestMessage()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Method = HttpMethod.Get,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>};</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>response = </code><code>await</code> <code>client.SendAsync(request);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(response.IsSuccessStatusCode)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>responseContent = </code><code>await</code> <code>response.Content.ReadAsStringAsync();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>data = JsonDocument.Parse(responseContent);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>data;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>throw</code> <code>new</code> <code>ApplicationException($</code><code>"Status code: {response.StatusCode}, Error: {response.ReasonPhrase}"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>catch</code> <code>(Exception e)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>throw</code> <code>new</code> <code>ApplicationException($</code><code>"Exception {e}"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p>In the Startup ConfigureServices method, add the handler:</p>
<div><div id="highlighter_739323"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p></td><td><div><p><code>var</code> <code>clientCertificateIntermediate = </code><code>new</code> <code>X509Certificate2(</code><code>"../Certs/client.pfx"</code><code>, </code><code>"1234"</code><code>);</code></p><p><code>var</code> <code>handlerClientCertificateIntermediate = </code><code>new</code> <code>HttpClientHandler();</code></p><p><code>handlerClientCertificateIntermediate.ClientCertificates.Add(clientCertificateIntermediate);</code></p><p><code>services.AddHttpClient(</code><code>"client"</code><code>, c =&gt; {})</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.ConfigurePrimaryHttpMessageHandler(() =&gt; handlerClientCertificateIntermediate);</code></p></div></td></tr></tbody></table></div></div>
<p>See the github code for the full working example. By using chained certificates, new certificates can be created on the fly for usage with new API clients, and the root certificate does not need to be deployed. This would become really useful when securing APIs which are not always connected to the internet, or with distributed devices.</p>
<p><strong>Links</strong></p>
<p><a href="https://github.com/damienbod/AspNetCoreCertificates" rel="nofollow">https://github.com/damienbod/AspNetCoreCertificates</a></p>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/working-with-certificates" rel="nofollow">https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/working-with-certificates</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/how-to-create-temporary-certificates-for-use-during-development" rel="nofollow">https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/how-to-create-temporary-certificates-for-use-during-development</a></p>
<blockquote data-secret="pySoy6dWiP"><p><a href="https://blog.davidchristiansen.com/2016/09/howto-create-self-signed-certificates-with-powershell/">HowTo: Create Self-Signed Certificates with PowerShell</a></p></blockquote>

<p><a href="https://dotnetcodr.com/2015/06/01/https-and-x509-certificates-in-net-part-2-creating-self-signed-certificates/">HTTPS and X509 certificates in .NET Part 2: creating self-signed&nbsp;certificates</a></p>
<p><a href="https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core" rel="nofollow">https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core</a></p>
<p><a href="https://damienbod.com/2018/09/21/deploying-an-asp-net-core-application-to-windows-iis/" rel="nofollow">https://damienbod.com/2018/09/21/deploying-an-asp-net-core-application-to-windows-iis/</a></p>
<p><a href="https://docs.microsoft.com/en-us/powershell/module/pkiclient/new-selfsignedcertificate?view=win10-ps" rel="nofollow">https://docs.microsoft.com/en-us/powershell/module/pkiclient/new-selfsignedcertificate?view=win10-ps</a></p>
<p><a href="https://github.com/damienbod/IdentityServer4AspNetCoreIdentityTemplate#using-powershell-to-create-the-self-signed-certs" rel="nofollow">https://github.com/damienbod/IdentityServer4AspNetCoreIdentityTemplate#using-powershell-to-create-the-self-signed-certs</a></p>
<p><a href="https://dotnetcodr.com/2016/01/25/using-client-certificates-in-net-part-5-working-with-client-certificates-in-a-web-project/">Using client certificates in .NET part 5: working with client certificates in a web&nbsp;project</a></p>
<p><a href="https://stackoverflow.com/questions/42623080/how-to-validate-a-certificate-chain-from-a-specific-root-ca-in-c-sharp" rel="nofollow">https://stackoverflow.com/questions/42623080/how-to-validate-a-certificate-chain-from-a-specific-root-ca-in-c-sharp</a></p>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0</a></p>
<p><a href="https://social.msdn.microsoft.com/Forums/SqlServer/en-US/5ed119ef-1704-4be4-8a4f-ef11de7c8f34/a-certificate-chain-processed-but-terminated-in-a-root-certificate-which-is-not-trusted-by-the" rel="nofollow">https://social.msdn.microsoft.com/Forums/SqlServer/en-US/5ed119ef-1704-4be4-8a4f-ef11de7c8f34/a-certificate-chain-processed-but-terminated-in-a-root-certificate-which-is-not-trusted-by-the</a></p>
<p><a href="https://tools.ietf.org/html/rfc3280.html" rel="nofollow">https://tools.ietf.org/html/rfc3280.html</a></p>
<p><a href="https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/Certificate/src" rel="nofollow">https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/Certificate/src</a></p>
<p><a href="https://tools.ietf.org/html/rfc5246#section-7.4.4" rel="nofollow">https://tools.ietf.org/html/rfc5246#section-7.4.4</a></p>

							
							
						</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>