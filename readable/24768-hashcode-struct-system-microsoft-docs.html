<!DOCTYPE html>
<html lang="en">
<head>
    <title>
HashCode Struct (System) | Microsoft Docs -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>HashCode Struct (System) | Microsoft Docs</h1><div><div id="main" class="content "><h2 class="hiddenAnchor" id="definition">Definition</h2><div class="summaryHolder"><p>Combines the hash code for multiple values into a single hash code.</p></div><pre class="wrap"><code class="cpp lang-cpp" dir="ltr">public value class HashCode</code></pre><pre class="wrap"><code class="csharp lang-csharp" dir="ltr">public struct HashCode</code></pre><pre class="wrap"><code class="fsharp lang-fsharp" dir="ltr">type HashCode = struct</code></pre><pre class="wrap"><code class="vb lang-vb" dir="ltr">Public Structure HashCode</code></pre><dl class="attributeList stack"><dt>Inheritance</dt><dd></dd></dl><p>You can use <a class="xref" href="system.hashcode?view=netstandard-2.1" data-linktype="relative-path">HashCode</a> to combine multiple values (for example, fields on a structure or class) into a
single hash code. This structure operates in one of two ways:</p><ul><li>Static methods that accept a set of up to eight values to combine.</li><li>Two instance methods that operate in a streaming fashion, accepting values one at a time.</li></ul><div class="WARNING"><p>Warning</p><p>It is best-practice to consider hash codes as an implementation detail, as the implementation may change across
assembly versions. Do not store hash codes produced by <a class="xref" href="system.hashcode?view=netstandard-2.1" data-linktype="relative-path">HashCode</a> in serialized structures, for example,
on-disk. <a class="xref" href="system.hashcode?view=netstandard-2.1" data-linktype="relative-path">HashCode</a> uses a statically initialized random seed to enforce this best practice, meaning that
the hash codes are only deterministic within the scope of an operating system process.</p></div><h3 id="static-methods">Static Methods</h3><p>The static methods combine the default hash codes of up to eight values.</p><pre><code class="lang-csharp" name="System.HashCode.Structure#1">using System;
using System.Collections.Generic;

public struct OrderOrderLine : IEquatable&lt;OrderOrderLine&gt;
{
    public int OrderId { get; }
    public int OrderLineId { get; }

    public OrderOrderLine(int orderId, int orderLineId) =&gt; (OrderId, OrderLineId) = (orderId, orderLineId);

    public override bool Equals(object obj) =&gt; obj is OrderOrderLine o &amp;&amp; Equals(o);

    public bool Equals(OrderOrderLine other) =&gt; OrderId == other.OrderId &amp;&amp; OrderLineId == other.OrderLineId;

    public override int GetHashCode() =&gt; HashCode.Combine(OrderId, OrderLineId);
}

class Program
{
    static void Main(string[] args)
    {
        var set = new HashSet&lt;OrderOrderLine&gt;
        {
            new OrderOrderLine(1, 1),
            new OrderOrderLine(1, 1),
            new OrderOrderLine(1, 2)
        };

        Console.WriteLine($"Item count: {set.Count}.");
    }
}
// The example displays the following output:
// Item count: 2.
</code></pre><pre><code class="lang-vb" name="System.HashCode.Structure#1">Public Structure OrderOrderLine
    Implements IEquatable(Of OrderOrderLine)

    Public ReadOnly Property OrderId As Integer
    Public ReadOnly Property OrderLineId As Integer

    Public Sub New(ByVal orderId As Integer, ByVal orderLineId As Integer)
        Me.OrderId = orderId
        Me.OrderLineId = orderLineId
    End Sub

    Public Overrides Function Equals(obj As Object) As Boolean
        Return (TypeOf obj Is OrderOrderLine) AndAlso Equals(DirectCast(obj, OrderOrderLine))
    End Function

    Public Overloads Function Equals(other As OrderOrderLine) As Boolean Implements IEquatable(Of OrderOrderLine).Equals
        Return OrderId = other.OrderId AndAlso
               OrderLineId = other.OrderLineId
    End Function

    Public Overrides Function GetHashCode() As Integer
        Return HashCode.Combine(OrderId, OrderLineId)
    End Function

End Structure

Module Program

    Sub Main(args As String())
        Dim hashSet As HashSet(Of OrderOrderLine) = New HashSet(Of OrderOrderLine)
        hashSet.Add(New OrderOrderLine(1, 1))
        hashSet.Add(New OrderOrderLine(1, 1))
        hashSet.Add(New OrderOrderLine(1, 2))
        Console.WriteLine($"Item count: {hashSet.Count}")
    End Sub

End Module
' The example displays the following output:
' Item count: 2.
</code></pre><h3 id="instance-methods">Instance Methods</h3><p>The instance methods combine the hash codes of more than eight values.</p><pre><code class="lang-csharp" name="System.HashCode.Structure#2">using System;
using System.Collections.Generic;

public struct Path : IEquatable&lt;Path&gt;
{
    public IReadOnlyList&lt;string&gt; Segments { get; }

    public Path(params string[] segments) =&gt; Segments = segments;

    public override bool Equals(object obj) =&gt; obj is Path o &amp;&amp; Equals(o);

    public bool Equals(Path other)
    {
        if (ReferenceEquals(Segments, other.Segments)) return true;
        if (Segments is null || other.Segments is null) return false;
        if (Segments.Count != other.Segments.Count) return false;

        for (var i = 0; i &lt; Segments.Count; i++)
        {
            if (!string.Equals(Segments[i], other.Segments[i]))
                return false;
        }

        return true;
    }

    public override int GetHashCode()
    {
        var hash = new HashCode();

        for (var i = 0; i &lt; Segments?.Count; i++)
            hash.Add(Segments[i]);

        return hash.ToHashCode();
    }
}

class Program
{
    static void Main(string[] args)
    {
        var set = new HashSet&lt;Path&gt;
        {
            new Path("C:", "tmp", "file.txt"),
            new Path("C:", "tmp", "file.txt"),
            new Path("C:", "tmp", "file.tmp")
        };

        Console.WriteLine($"Item count: {set.Count}.");
    }
}
// The example displays the following output:
// Item count: 2.
</code></pre><pre><code class="lang-vb" name="System.HashCode.Structure#2">Public Structure Path
    Implements IEquatable(Of Path)

    Public ReadOnly Property Segments As IReadOnlyList(Of String)

    Public Sub New(ParamArray ByVal segments() As String)
        Me.Segments = segments
    End Sub

    Public Overrides Function Equals(obj As Object) As Boolean
        Return (TypeOf obj Is Path) AndAlso Equals(DirectCast(obj, Path))
    End Function

    Public Overloads Function Equals(other As Path) As Boolean Implements IEquatable(Of Path).Equals
        If ReferenceEquals(Segments, other.Segments) Then Return True
        If Segments Is Nothing OrElse other.Segments Is Nothing Then Return False
        If Segments.Count &lt;&gt; other.Segments.Count Then Return False

        For i As Integer = 0 To Segments.Count - 1
            If Not String.Equals(Segments(i), other.Segments(i)) Then Return False
        Next

        Return True
    End Function

    Public Overrides Function GetHashCode() As Integer
        Dim hash As HashCode = New HashCode()

        For i As Integer = 0 To Segments?.Count - 1
            hash.Add(Segments(i))
        Next

        Return hash.ToHashCode()
    End Function

End Structure

Module Program

    Sub Main(args As String())
        Dim hashSet As HashSet(Of Path) = New HashSet(Of Path) From {
            New Path("C:", "tmp", "file.txt"),
            New Path("C:", "tmp", "file.txt"),
            New Path("C:", "tmp", "file.tmp")
        }
        Console.WriteLine($"Item count: {hashSet.Count}.")
    End Sub

End Module
' The example displays the following output:
' Item count: 2.
</code></pre><p>The instance methods also combine the hash codes produced by a specific
<a class="xref" href="system.collections.generic.iequalitycomparer-1?view=netstandard-2.1" data-linktype="relative-path">IEqualityComparer&lt;T&gt;</a> implementation.</p><pre><code class="lang-csharp" name="System.HashCode.Structure#3">using System;
using System.Collections.Generic;

public struct Path : IEquatable&lt;Path&gt;
{
    public IReadOnlyList&lt;string&gt; Segments { get; }

    public Path(params string[] segments) =&gt; Segments = segments;

    public override bool Equals(object obj) =&gt; obj is Path o &amp;&amp; Equals(o);

    public bool Equals(Path other)
    {
        if (ReferenceEquals(Segments, other.Segments)) return true;
        if (Segments is null || other.Segments is null) return false;
        if (Segments.Count != other.Segments.Count) return false;

        for (var i = 0; i &lt; Segments.Count; i++)
        {
            if (!string.Equals(Segments[i], other.Segments[i], StringComparison.OrdinalIgnoreCase))
                return false;
        }

        return true;
    }

    public override int GetHashCode()
    {
        var hash = new HashCode();

        for (var i = 0; i &lt; Segments?.Count; i++)
            hash.Add(Segments[i], StringComparer.OrdinalIgnoreCase);

        return hash.ToHashCode();
    }
}

class Program
{
    static void Main(string[] args)
    {
        var set = new HashSet&lt;Path&gt;
        {
            new Path("C:", "tmp", "file.txt"),
            new Path("C:", "TMP", "file.txt"),
            new Path("C:", "tmp", "FILE.TXT")
        };

        Console.WriteLine($"Item count: {set.Count}.");
    }
}
// The example displays the following output:
// Item count: 1.
</code></pre><pre><code class="lang-vb" name="System.HashCode.Structure#3">Public Structure Path
    Implements IEquatable(Of Path)

    Public ReadOnly Property Segments As IReadOnlyList(Of String)

    Public Sub New(ParamArray ByVal segments() As String)
        Me.Segments = segments
    End Sub

    Public Overrides Function Equals(obj As Object) As Boolean
        Return (TypeOf obj Is Path) AndAlso Equals(DirectCast(obj, Path))
    End Function

    Public Overloads Function Equals(other As Path) As Boolean Implements IEquatable(Of Path).Equals
        If ReferenceEquals(Segments, other.Segments) Then Return True
        If Segments Is Nothing OrElse other.Segments Is Nothing Then Return False
        If Segments.Count &lt;&gt; other.Segments.Count Then Return False

        For i As Integer = 0 To Segments.Count - 1
            If Not String.Equals(Segments(i), other.Segments(i), StringComparison.OrdinalIgnoreCase) Then Return False
        Next

        Return True
    End Function

    Public Overrides Function GetHashCode() As Integer
        Dim hash As HashCode = New HashCode()

        For i As Integer = 0 To Segments?.Count - 1
            hash.Add(Segments(i), StringComparer.OrdinalIgnoreCase)
        Next

        Return hash.ToHashCode()
    End Function
    
End Structure

Module Program

    Sub Main(args As String())
        Dim hashSet As HashSet(Of Path) = New HashSet(Of Path) From {
            New Path("C:", "tmp", "file.txt"),
            New Path("C:", "TMP", "file.txt"),
            New Path("C:", "tmp", "FILE.TXT")
        }
        Console.WriteLine($"Item count: {hashSet.Count}.")
    End Sub

End Module
' The example displays the following output:
' Item count: 1.
</code></pre><p>The <a class="xref" href="system.hashcode?view=netstandard-2.1" data-linktype="relative-path">HashCode</a> structure must be passed by-reference to other methods, as it is a value type.</p><pre><code class="lang-csharp" name="System.HashCode.Structure#4">using System;
using System.Collections.Generic;

public struct Path : IEquatable&lt;Path&gt;
{
    public IReadOnlyList&lt;string&gt; Segments { get; }

    public Path(params string[] segments) =&gt; Segments = segments;

    public override bool Equals(object obj) =&gt; obj is Path o &amp;&amp; Equals(o);

    public bool Equals(Path other)
    {
        if (ReferenceEquals(Segments, other.Segments)) return true;
        if (Segments is null || other.Segments is null) return false;
        if (Segments.Count != other.Segments.Count) return false;

        for (var i = 0; i &lt; Segments.Count; i++)
        {
            if (!PlatformUtils.PathEquals(Segments[i], other.Segments[i]))
                return false;
        }

        return true;
    }

    public override int GetHashCode()
    {
        var hash = new HashCode();

        for (var i = 0; i &lt; Segments?.Count; i++)
            PlatformUtils.AddPath(ref hash, Segments[i]);

        return hash.ToHashCode();
    }
}

internal static class PlatformUtils
{
    public static bool PathEquals(string a, string b) =&gt; string.Equals(a, b, StringComparison.OrdinalIgnoreCase);
    public static void AddPath(ref HashCode hash, string path) =&gt; hash.Add(path, StringComparer.OrdinalIgnoreCase);
}

class Program
{
    static void Main(string[] args)
    {
        var set = new HashSet&lt;Path&gt;
        {
            new Path("C:", "tmp", "file.txt"),
            new Path("C:", "TMP", "file.txt"),
            new Path("C:", "tmp", "FILE.TXT")
        };

        Console.WriteLine($"Item count: {set.Count}.");
    }
}
// The example displays the following output:
// Item count: 1.
</code></pre><pre><code class="lang-vb" name="System.HashCode.Structure#4">Public Structure Path
    Implements IEquatable(Of Path)

    Public ReadOnly Property Segments As IReadOnlyList(Of String)

    Public Sub New(ParamArray ByVal segments() As String)
        Me.Segments = segments
    End Sub

    Public Overrides Function Equals(obj As Object) As Boolean
        Return (TypeOf obj Is Path) AndAlso Equals(DirectCast(obj, Path))
    End Function

    Public Overloads Function Equals(other As Path) As Boolean Implements IEquatable(Of Path).Equals
        If ReferenceEquals(Segments, other.Segments) Then Return True
        If Segments Is Nothing OrElse other.Segments Is Nothing Then Return False
        If Segments.Count &lt;&gt; other.Segments.Count Then Return False

        For i As Integer = 0 To Segments.Count - 1
            If Not PathEquals(Segments(i), other.Segments(i)) Then Return False
        Next

        Return True
    End Function

    Public Overrides Function GetHashCode() As Integer
        Dim hash As HashCode = New HashCode()

        For i As Integer = 0 To Segments?.Count - 1
            AddPath(hash, Segments(i))
        Next

        Return hash.ToHashCode()
    End Function
    
End Structure

Friend Module PlatformUtils

    Public Function PathEquals(ByVal a As String, ByVal b As String) As Boolean
        Return String.Equals(a, b, StringComparison.OrdinalIgnoreCase)
    End Function

    Public Sub AddPath(ByRef hash As HashCode, ByVal path As String)
        hash.Add(path, StringComparer.OrdinalIgnoreCase)
    End Sub

End Module

Module Program

    Sub Main(args As String())
        Dim hashSet As HashSet(Of Path) = New HashSet(Of Path) From {
            New Path("C:", "tmp", "file.txt"),
            New Path("C:", "TMP", "file.txt"),
            New Path("C:", "tmp", "FILE.TXT")
        }
        Console.WriteLine($"Item count: {hashSet.Count}.")
    End Sub

End Module
' The example displays the following output:
' Item count: 1.
</code></pre><h2 id="methods">
		Methods
	</h2><table class="nameValue"><tbody><tr><td><span class="break-text"><a class="xref" href="system.hashcode.add?view=netstandard-2.1#System_HashCode_Add__1___0_" data-linktype="relative-path">Add&lt;T&gt;(T)</a></span></td><td><p>Adds a single value to the hash code.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.add?view=netstandard-2.1#System_HashCode_Add__1___0_System_Collections_Generic_IEqualityComparer___0__" data-linktype="relative-path">Add&lt;T&gt;(T, IEqualityComparer&lt;T&gt;)</a></span></td><td><p>Adds a single value to the hash code, specifying the type that provides the hash code function.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.combine?view=netstandard-2.1#System_HashCode_Combine__8___0___1___2___3___4___5___6___7_" data-linktype="relative-path">Combine&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;(T1, T2, T3, T4, T5, T6, T7, T8)</a></span></td><td><p>Combines eight values into a hash code.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.combine?view=netstandard-2.1#System_HashCode_Combine__7___0___1___2___3___4___5___6_" data-linktype="relative-path">Combine&lt;T1,T2,T3,T4,T5,T6,T7&gt;(T1, T2, T3, T4, T5, T6, T7)</a></span></td><td><p>Combines seven values into a hash code.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.combine?view=netstandard-2.1#System_HashCode_Combine__6___0___1___2___3___4___5_" data-linktype="relative-path">Combine&lt;T1,T2,T3,T4,T5,T6&gt;(T1, T2, T3, T4, T5, T6)</a></span></td><td><p>Combines six values into a hash code.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.combine?view=netstandard-2.1#System_HashCode_Combine__5___0___1___2___3___4_" data-linktype="relative-path">Combine&lt;T1,T2,T3,T4,T5&gt;(T1, T2, T3, T4, T5)</a></span></td><td><p>Combines five values into a hash code.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.combine?view=netstandard-2.1#System_HashCode_Combine__4___0___1___2___3_" data-linktype="relative-path">Combine&lt;T1,T2,T3,T4&gt;(T1, T2, T3, T4)</a></span></td><td><p>Combines four values into a hash code.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.combine?view=netstandard-2.1#System_HashCode_Combine__3___0___1___2_" data-linktype="relative-path">Combine&lt;T1,T2,T3&gt;(T1, T2, T3)</a></span></td><td><p>Combines three values into a hash code.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.combine?view=netstandard-2.1#System_HashCode_Combine__2___0___1_" data-linktype="relative-path">Combine&lt;T1,T2&gt;(T1, T2)</a></span></td><td><p>Combines two values into a hash code.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.combine?view=netstandard-2.1#System_HashCode_Combine__1___0_" data-linktype="relative-path">Combine&lt;T1&gt;(T1)</a></span></td><td><p>Diffuses the hash code returned by the specified value.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.equals?view=netstandard-2.1#System_HashCode_Equals_System_Object_" data-linktype="relative-path">Equals(Object)</a></span></td><td><p>This method is not supported and should not be called.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.gethashcode?view=netstandard-2.1#System_HashCode_GetHashCode" data-linktype="relative-path">GetHashCode()</a></span></td><td><p>This method is not supported and should not be called.</p></td></tr><tr><td><span class="break-text"><a class="xref" href="system.hashcode.tohashcode?view=netstandard-2.1#System_HashCode_ToHashCode" data-linktype="relative-path">ToHashCode()</a></span></td><td><p>Calculates the final hash code after consecutive <a class="xref" href="system.hashcode.add?view=netstandard-2.1" data-linktype="relative-path">Add</a> invocations.</p></td></tr></tbody></table><h2 id="moniker-applies-to" class="moniker-applies-to">Applies to</h2></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>