<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How to Utilize gRPC-Web From a Blazor WebAssembly Application - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="How to Utilize gRPC-Web From a Blazor WebAssembly Application - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@waelkdouh"/>
    <meta property="og:description" content="Its no secret by now that there has been a lot of excitement about gRPC recently in the&#xA0;.Net community. gRPC is a modern high-performance&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://link.medium.com/DUMDRhtVr7"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - How to Utilize gRPC-Web From a Blazor WebAssembly Application</title>
<div class="readable">
        <h1>How to Utilize gRPC-Web From a Blazor WebAssembly Application</h1>
            <div>by https://medium.com/@waelkdouh</div>
            <div>Reading time: 3-4 minutes</div>
        <div>Posted here: 24 Jun 2020</div>
        <p><a href="https://link.medium.com/DUMDRhtVr7">https://link.medium.com/DUMDRhtVr7</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><p id="9ba1" data-selectable-paragraph="">The solution I provided includes three projects. The Blazor WebAssembly project is the front end which will consume both a gRPC-Web endpoint as well as Restful endpoint.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*bYshGoSBixsqLfzS7KA63A.png?q=20" width="1384" height="404" role="presentation"></p><p><img width="1384" height="404" srcset="https://miro.medium.com/max/552/1*bYshGoSBixsqLfzS7KA63A.png 276w, https://miro.medium.com/max/1104/1*bYshGoSBixsqLfzS7KA63A.png 552w, https://miro.medium.com/max/1280/1*bYshGoSBixsqLfzS7KA63A.png 640w, https://miro.medium.com/max/1400/1*bYshGoSBixsqLfzS7KA63A.png 700w" sizes="700px" role="presentation" src="https://miro.medium.com/max/1384/1*bYshGoSBixsqLfzS7KA63A.png"></p></div></div></div></div></figure><p id="db90" data-selectable-paragraph="">In order to add a gRPC-Web endpoint you actually have to start by adding a regular gRPC project.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*VjvqL5zHqi8pF11vEIx8zA.png?q=20" width="1094" height="460" role="presentation"></p><p><img width="1094" height="460" srcset="https://miro.medium.com/max/552/1*VjvqL5zHqi8pF11vEIx8zA.png 276w, https://miro.medium.com/max/1104/1*VjvqL5zHqi8pF11vEIx8zA.png 552w, https://miro.medium.com/max/1280/1*VjvqL5zHqi8pF11vEIx8zA.png 640w, https://miro.medium.com/max/1400/1*VjvqL5zHqi8pF11vEIx8zA.png 700w" sizes="700px" role="presentation" src="https://miro.medium.com/max/1094/1*VjvqL5zHqi8pF11vEIx8zA.png"></p></div></div></div></div><figcaption data-selectable-paragraph="">gRPC Template in Visual Studio 2019</figcaption></figure><p id="7934" data-selectable-paragraph="">gRPC services hosted in ASP.NET Core can be configured to support gRPC-Web alongside HTTP/2 gRPC. gRPC-Web does not require any changes to services. The only modification is startup configuration.</p><p id="fc92" data-selectable-paragraph="">To enable gRPC-Web with an ASP.NET Core gRPC service follow the instructions included in the documentation <a href="https://docs.microsoft.com/en-us/aspnet/core/grpc/browser?view=aspnetcore-3.1" target="_blank" rel="noopener nofollow">here</a>.</p><p id="7b2d" data-selectable-paragraph="">Similar to consuming a Restful endpoint, you will need to register the gRPC-Web service in the service container inside the Program.cs file. The service creates a channel with a GrpcWebHandler that is addressed to the backend server.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*TMBTJH-05ElomyO4zAHjWg.png?q=20" width="2048" height="639" role="presentation"></p><p><img width="2048" height="639" srcset="https://miro.medium.com/max/552/1*TMBTJH-05ElomyO4zAHjWg.png 276w, https://miro.medium.com/max/1104/1*TMBTJH-05ElomyO4zAHjWg.png 552w, https://miro.medium.com/max/1280/1*TMBTJH-05ElomyO4zAHjWg.png 640w, https://miro.medium.com/max/1400/1*TMBTJH-05ElomyO4zAHjWg.png 700w" sizes="700px" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Register the gRPC-Web Service</figcaption></figure><blockquote><p id="925e" data-selectable-paragraph="">Note: The GrpcWebMode was set to GrpcWeb. It is recommended to stick with this mode (vs. GrpcWebText) if you are not doing any server streaming calls as it leads to reductions of of the message size upwards of 30%. More information can be found <a href="https://grpc.io/blog/state-of-grpc-web/" target="_blank" rel="noopener nofollow">here</a>.</p></blockquote><p id="5862" data-selectable-paragraph="">Next I had to copy the Proto files from the Server project into the Blazor project and generate the client stubs (right click on the Proto file and click properties).</p><blockquote><p id="eaa4" data-selectable-paragraph="">Note: You can improve the solution by storing the Proto files in a centralized location to be consumed by both the client and server applications.</p></blockquote><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*Bj268XMeXVF9UTVnduhiVg.png?q=20" width="1567" height="1081" role="presentation"></p><p><img width="1567" height="1081" srcset="https://miro.medium.com/max/552/1*Bj268XMeXVF9UTVnduhiVg.png 276w, https://miro.medium.com/max/1104/1*Bj268XMeXVF9UTVnduhiVg.png 552w, https://miro.medium.com/max/1280/1*Bj268XMeXVF9UTVnduhiVg.png 640w, https://miro.medium.com/max/1400/1*Bj268XMeXVF9UTVnduhiVg.png 700w" sizes="700px" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Properties Window for a Proto file</figcaption></figure><blockquote><p id="6c4c" data-selectable-paragraph="">Note: You need to install the Grpc.Tools nuget package in order to get the above window. For sake of completion I am sharing all the nuget packages I had to install within the Blazor WebAssembly project to consume the gRPC-Web endpoint.</p></blockquote><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*eJeRqIK5Rfe1VeF3DweDLA.png?q=20" width="1832" height="562" role="presentation"></p><p><img width="1832" height="562" srcset="https://miro.medium.com/max/552/1*eJeRqIK5Rfe1VeF3DweDLA.png 276w, https://miro.medium.com/max/1104/1*eJeRqIK5Rfe1VeF3DweDLA.png 552w, https://miro.medium.com/max/1280/1*eJeRqIK5Rfe1VeF3DweDLA.png 640w, https://miro.medium.com/max/1400/1*eJeRqIK5Rfe1VeF3DweDLA.png 700w" sizes="700px" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Nuget Packages required to consume a gRPC-Web endpoint within a Blazor WebAssembly application</figcaption></figure><p id="7566" data-selectable-paragraph="">Now that I have all the settings in place to communicate with a gRPC-Web endpoint its time to wire the Blazor component to consume it. The following code shows the FetchData component consuming a gRPC-Web endpoint.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/44/1*o7okcpGHCzy9OirA6dUUNA.png?q=20" width="1211" height="1616" role="presentation"></p><p><img width="1211" height="1616" srcset="https://miro.medium.com/max/552/1*o7okcpGHCzy9OirA6dUUNA.png 276w, https://miro.medium.com/max/1104/1*o7okcpGHCzy9OirA6dUUNA.png 552w, https://miro.medium.com/max/1280/1*o7okcpGHCzy9OirA6dUUNA.png 640w, https://miro.medium.com/max/1400/1*o7okcpGHCzy9OirA6dUUNA.png 700w" sizes="700px" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">FetchDataGrpc.razor</figcaption></figure><p id="c5a7" data-selectable-paragraph="">For comparison, here is the same component consuming a Restful implementation of the same service.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/56/1*-jBweNARklo0sMWjsfXbwQ.png?q=20" width="1551" height="1682" role="presentation"></p><p><img width="1551" height="1682" srcset="https://miro.medium.com/max/552/1*-jBweNARklo0sMWjsfXbwQ.png 276w, https://miro.medium.com/max/1104/1*-jBweNARklo0sMWjsfXbwQ.png 552w, https://miro.medium.com/max/1280/1*-jBweNARklo0sMWjsfXbwQ.png 640w, https://miro.medium.com/max/1400/1*-jBweNARklo0sMWjsfXbwQ.png 700w" sizes="700px" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">FetchDataRest.razor</figcaption></figure><blockquote><p id="0ff6" data-selectable-paragraph="">Note: In the case of FetchDataGrpc.razor the WeatherForecast model is automatically generated from the Proto file. gRPC services require a service contract usually defined using the Protocol Buffer Language in Proto files. The service contract is then used to generate your C# (or language of your choice) server-side classes and your client side proxies</p></blockquote><p id="0b3f" data-selectable-paragraph="">Finally, the moment of truth. Does gRPC-Web delivers the promised optimizations compared to Restful endpoints as a result of using a binary format instead of JSON? Well I am happy to share that the answer is a yes. Here is the result of running the application with two components hitting both types of services and returning the same data. As you can see the gRPC-Web endpoint sends 427 Bytes compared to Rest’s 655 Bytes. I imagine the savings will be more pronounced when you send large amounts of data.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*MJLpBOi5zqBOSeFN0_wblA.png?q=20" width="3427" height="1483" role="presentation"></p><p><img width="3427" height="1483" srcset="https://miro.medium.com/max/552/1*MJLpBOi5zqBOSeFN0_wblA.png 276w, https://miro.medium.com/max/1104/1*MJLpBOi5zqBOSeFN0_wblA.png 552w, https://miro.medium.com/max/1280/1*MJLpBOi5zqBOSeFN0_wblA.png 640w, https://miro.medium.com/max/1400/1*MJLpBOi5zqBOSeFN0_wblA.png 700w" sizes="700px" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">The WeatherData payload size sent from both a gRPC-Web and Rest endpoints</figcaption></figure></div></div></section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>