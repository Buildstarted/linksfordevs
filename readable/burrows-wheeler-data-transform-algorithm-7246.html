<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Burrows - Wheeler Data Transform Algorithm - GeeksforGeeks - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Burrows - Wheeler Data Transform Algorithm - GeeksforGeeks - linksfor.dev(s)"/>
    <meta property="og:description" content="A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.geeksforgeeks.org/burrows-wheeler-data-transform-algorithm/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Burrows - Wheeler Data Transform Algorithm - GeeksforGeeks</title>
<div class="readable">
        <h1>Burrows - Wheeler Data Transform Algorithm - GeeksforGeeks</h1>
        <p>
Reading time: 6-8 minutes        </p>
        <p><a href="https://www.geeksforgeeks.org/burrows-wheeler-data-transform-algorithm/">https://www.geeksforgeeks.org/burrows-wheeler-data-transform-algorithm/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
			<p><u><strong>What is the Burrows-Wheeler Transform?</strong></u><br>
The BWT is a data transformation algorithm that restructures data in such a way that the transformed message is more compressible. Technically, it is a lexicographical reversible permutation of the characters of a string. It is first of the three steps to be performed in succession while implementing the Burrows-Wheeler Data Compression algorithm that forms the basis of the Unix compression utility bzip2. </p>
<p><u><strong>Why BWT? The main idea behind it.</strong></u><br>
The most important application of BWT is found in biological sciences where genomes(long strings written in A, C, T, G alphabets) don‚Äôt have many runs but they do have many repeats.<br>
The idea of the BWT is to build an array whose rows are all cyclic shifts of the input string in dictionary order and return the last column of the array that tends to have long runs of identical characters. The benefit of this is that once the characters have been clustered together, they effectively have an ordering, which can make our string more compressible for other algorithms like run-length encoding and Huffman Coding.<br>
The remarkable thing about BWT is that this particular transform is reversible with minimal data overhead.</p>
<p><u><strong>Steps involved in BWT algorithm</strong></u><br>
Let‚Äôs take the word <strong>‚Äúbanana$‚Äù</strong> as an example.</p><br>
        
          <!-- post_top_responsive -->
          <ins data-ad-client="ca-pub-9465609616171866" data-ad-slot="4501693235" data-ad-format="auto" data-adsbygoogle-status="done" data-overlap-observer-io="false"><ins id="aswift_2_expand"><ins id="aswift_2_anchor"></ins></ins></ins>
          
        <br>
            
<ul>
<li><strong>Step 1:</strong> Form all cyclic rotations of the given text.
<pre>                                     banana$ 
       $    b                        $banana 
    a           a                    a$banan
   Cyclic rotations    ----------&gt;   na$bana
    n         n                      ana$ban 
          a                          nana$ba
                                     anana$b
</pre>
</li>
<li><strong>Step 2:</strong> The next step is to sort the rotations lexicographically. The <strong>‚Äò$‚Äô</strong> sign  is viewed as first letter lexicographically, even before <strong>‚Äòa‚Äô</strong>.
<pre>banana$                    $banana
$banana                    a$banan
a$banan       Sorting      ana$ban
na$bana      ----------&gt;   anana$b 
ana$ban    alphabetically  banana$
nana$ba                    na$bana
anana$b                    nana$ba
</pre>
</li>
<li><strong>Step 3:</strong> The last column is what we output as BWT.
<pre>BWT(banana$) = a<strong>nn</strong>b$<strong>aa</strong>
</pre>
</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote><p>
<strong>Input:</strong> text = ‚Äúbanana$‚Äù<br>
<strong>Output:</strong> Burrows-Wheeler Transform = ‚Äúannb$aa‚Äù</p>
<p><strong>Input:</strong> text = ‚Äúabracadabra$‚Äù<br>
<strong>Output:</strong> Burrows-Wheeler Transform = ‚Äúard$rcaaaabb‚Äù
</p></blockquote>
<p><u><strong> Why last column is considered BWT?</strong></u></p>
<ol>
<li>The last column has a better symbol clustering than any other columns.</li>
<li>If we only have BWT of our string, we can recover the rest of the cyclic rotations entirely. The rest of the columns don‚Äôt possess this characteristic which is highly important while computing the inverse of BWT.</li>
</ol>
<p><u><strong> Why ‚Äò$‚Äô sign is embedded in the text?</strong></u><br>
We can compute BWT even if our text is not concatenated with any EOF character (<strong>‚Äò$‚Äô</strong> here). The implication of <strong>‚Äò$‚Äô</strong> sign comes while computing the inverse of BWT.</p>
<p><u><strong> Way of implementation</strong></u></p>
<ol>
<li>Let‚Äôs instantiate <strong>‚Äúbanana$‚Äù</strong> as our <strong>input_text</strong> and instantiate character array <strong>bwt_arr</strong> for our output.</li>
<li>Let‚Äôs get all the suffixes of <strong>‚Äúbanana$‚Äù</strong> and compute it‚Äôs <strong>suffix_arr</strong> to store index of each suffix.
<pre>0 banana$                6 $   
1 anana$                 5 a$
2 nana$      Sorting     3 ana$
3 ana$     ----------&gt;   1 anana$
4 na$     alphabetically 0 banana$
5 a$                     4 na$
6 $                      2 nana$
</pre>
</li>
<li>Iterating over the <strong><a href="https://www.geeksforgeeks.org/suffix-array-set-1-introduction/">suffix_arr</a></strong>, let‚Äôs now add to our output array <strong>bwt_arr</strong>, the last character of each rotation.</li>
<li>The last character of each rotation of <strong>input_text</strong> starting at the position denoted by the current value in the suffix array can be calculated with <strong>input_text[(suffix_arr[i] ‚Äì 1 + n ) % n]</strong>, where <strong>n</strong> is the number of elements in the <strong>suffix_arr</strong>.
<pre>bwt_arr[0] 
  = input_text[(suffix_arr[0] - 1 + 7) % 7] 
  = input_text[5] 
  = a
bwt_arr[1] 
  = input_text[(suffix_arr[1] - 1 + 7) % 7] 
  = input_text[4] 
  = n
</pre>
</li>
</ol>
<p>Following is the code for the way of implementation explained above</p>
<div>

<div>
<div id="highlighter_82800">
<div>
<div>



<p><code>#include &lt;stdio.h&gt; </code></p>
<p><code>#include &lt;stdlib.h&gt; </code></p>
<p><code>#include &lt;string.h&gt; </code></p>


<p><code>struct</code> <code>rotation { </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>index; </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>char</code><code>* suffix; </code></p>
<p><code>}; </code></p>



<p><code>int</code> <code>cmpfunc(</code><code>const</code> <code>void</code><code>* x, </code><code>const</code> <code>void</code><code>* y) </code></p>
<p><code>{ </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>struct</code> <code>rotation* rx = (</code><code>struct</code> <code>rotation*)x; </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>struct</code> <code>rotation* ry = (</code><code>struct</code> <code>rotation*)y; </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>strcmp</code><code>(rx-&gt;suffix, ry-&gt;suffix); </code></p>
<p><code>} </code></p>



<p><code>int</code><code>* computeSuffixArray(</code><code>char</code><code>* input_text, </code><code>int</code> <code>len_text) </code></p>
<p><code>{ </code></p>


<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>struct</code> <code>rotation suff[len_text]; </code></p>



<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>(</code><code>int</code> <code>i = 0; i &lt; len_text; i++) { </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>suff[i].index = i; </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>suff[i].suffix = (input_text + i); </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code></p>



<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>qsort</code><code>(suff, len_text, </code><code>sizeof</code><code>(</code><code>struct</code> <code>rotation), </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cmpfunc); </code></p>


<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code><code>* suffix_arr </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>= (</code><code>int</code><code>*)</code><code>malloc</code><code>(len_text * </code><code>sizeof</code><code>(</code><code>int</code><code>)); </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>(</code><code>int</code> <code>i = 0; i &lt; len_text; i++) </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>suffix_arr[i] = suff[i].index; </code></p>


<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>suffix_arr; </code></p>
<p><code>} </code></p>




<p><code>char</code><code>* findLastChar(</code><code>char</code><code>* input_text, </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code><code>* suffix_arr, </code><code>int</code> <code>n) </code></p>
<p><code>{ </code></p>


<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>char</code><code>* bwt_arr = (</code><code>char</code><code>*)</code><code>malloc</code><code>(n * </code><code>sizeof</code><code>(</code><code>char</code><code>)); </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>i; </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>(i = 0; i &lt; n; i++) { </code></p>


<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>j = suffix_arr[i] - 1; </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(j &lt; 0) </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>j = j + n; </code></p>

<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>bwt_arr[i] = input_text[j]; </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code></p>

<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>bwt_arr[i] = </code><code>'\0'</code><code>; </code></p>


<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>bwt_arr; </code></p>
<p><code>} </code></p>


<p><code>int</code> <code>main() </code></p>
<p><code>{ </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>char</code> <code>input_text[] = </code><code>"banana$"</code><code>; </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>len_text = </code><code>strlen</code><code>(input_text); </code></p>


<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code><code>* suffix_arr </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>= computeSuffixArray(input_text, len_text); </code></p>



<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>char</code><code>* bwt_arr </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>= findLastChar(input_text, suffix_arr, len_text); </code></p>

<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>printf</code><code>(</code><code>"Input text : %s\n"</code><code>, input_text); </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>printf</code><code>(</code><code>"Burrows - Wheeler Transform : %s\n"</code><code>, </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>bwt_arr); </code></p>
<p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>0; </code></p>
<p><code>} </code></p>
</div>
</div>
</div></div>

</div>

<div>
<p><b>Output:</b></p>
<pre>Input text : banana$
Burrows - Wheeler Transform : annb$aa
</pre>
</div>
<p><u><strong> Time Complexity:</strong></u> O(<img src="https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-fa1247fba8b4f9e33fb87d234a646a61_l3.svg" alt="n^2" title="Rendered by QuickLaTeX.com" height="24" width="26">Logn). This is because of the method used above to build suffix array which has O(<img src="https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-fa1247fba8b4f9e33fb87d234a646a61_l3.svg" alt="n^2" title="Rendered by QuickLaTeX.com" height="24" width="26">Logn) time complexity, due to O(n) time for strings comparisons in O(nLogn) sorting algorithm.</p>
<p><u><strong> Exercise: </strong></u> </p>
<ol>
<li><a href="https://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/">Compute suffix array in O(nLogn) time</a> and then implement BWT.</li>
<li><a href="https://www.geeksforgeeks.org/inverting-burrows-wheeler-transform/">Implement Inverse of Burrows-Wheeler Transform.</a></li>
</ol>
<p>This article is contributed by <strong>Anureet Kaur</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org/">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br>
          <ins data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-9465609616171866" data-ad-slot="2737637308" data-adsbygoogle-status="done"><ins id="aswift_3_expand"><ins id="aswift_3_anchor"></ins></ins></ins>
          
          <br>
          
					
		<!-- .entry-meta -->
	</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>