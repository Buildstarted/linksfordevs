<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Write your Own Virtual Machine - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Write your Own Virtual Machine - linksfor.dev(s)"/>
    <meta property="og:description" content="In this tutorial, I will teach you how to write your own virtual machine (VM) that can run assembly language programs, such as my friend&#x27;s 2048 or my Roguelike. If you know how to program, but would like to gain a deeper understanding of what is going on inside a computer and better understand how programming languages work, then this project is for you. Writing your own VM may sound a little scary, but I promise that you will find it to be surprisingly simple and enlightening."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://justinmeiners.github.io/lc3-vm/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Write your Own Virtual Machine</title>
<div class="readable">
        <h1>Write your Own Virtual Machine</h1>
            <div>Reading time: 44-56 minutes</div>
        <div>Posted here: 14 Aug 2020</div>
        <p><a href="https://justinmeiners.github.io/lc3-vm/">https://justinmeiners.github.io/lc3-vm/</a></p>
        <hr/>
<div id="readability-page-1" class="page">
<section>

<a name="1:1"></a>
<a name="1:2"></a><div><a name="1:2"><h4>2. Introduction</h4></a>
<p>In this tutorial, I will teach you how to write your own virtual machine (VM) that can run assembly language programs, such as my friend's <a href="https://github.com/rpendleton/lc3-2048">2048</a> or my <a href="https://github.com/justinmeiners/lc3-rogue">Roguelike</a>. If you know how to program, but would like to gain a deeper understanding of what is going on inside a computer and better understand how programming languages work, then this project is for you. Writing your own VM may sound a little scary, but I promise that you will find it to be surprisingly simple and enlightening.
</p>
<p>The final code is about 250 lines of C (<a href="https://justinmeiners.github.io/lc3-vm/src/lc3.c">unix</a>, <a href="https://justinmeiners.github.io/lc3-vm/src/lc3-win.c">windows</a>).
All you need to know is how to read basic C or C++ and how to do <a href="https://www.swarthmore.edu/NatSci/echeeve1/Ref/BinaryMath/BinaryMath.html">binary arithmetic</a>.
</p>
<blockquote><p> <strong>Note:</strong> This VM is a <a href="https://en.wikipedia.org/wiki/Literate_programming">literate program</a>. This means you are reading the source code right now! Each piece of code from the project will be shown and explained thoroughly, so you can be sure nothing is left out. The final code was created by <a href="https://github.com/zyedidia/Literate">"weaving"</a> the blocks of code together.
</p>
</blockquote>
<h3> What is a virtual machine?</h3>
<p>A VM is a program that acts like a computer. It simulates a CPU along with a few other hardware components, allowing it to perform arithmetic, read and write to memory, and interact with I/O devices, just like a physical computer. Most importantly, it can understand a machine language which you can use to program it.
</p>
<p>The amount of computer hardware the VM attempts to simulate depends on its purpose. Some VMs are designed to reproduce the behavior of some particular computer, such as video game emulators. Most people don't have an NES lying around anymore, but we can still play NES games by simulating the NES hardware in a program. These emulators must <a href="http://wiki.nesdev.com/w/index.php/Tricky-to-emulate_games">faithfully recreate</a> every <a href="http://wiki.nesdev.com/w/index.php/Emulator_tests">detail</a> and major hardware component of the original device.
</p>
<p>Other VMs don't act like any real computer and are entirely made up! This is primarily done to make software development easier. Imagine you wanted to create a program that ran on multiple computer architectures. A VM could offer a standard platform which provided portability for all of them. Instead of rewriting a program in different dialects of assembly for each CPU architecture, you would only need to write the small VM program in each assembly language. Each program would then be written only once in the VM's assembly language.
</p>
<p><img src="https://justinmeiners.github.io/lc3-vm/img/no_vm.gif" alt="architecture specific implementation">
</p>
<p><img src="https://justinmeiners.github.io/lc3-vm/img/vm.gif" alt="vm for each architecture">
</p>
<blockquote><p> <strong>Note:</strong> A compiler solves a similar problem by compiling a standard <em>high-level language</em> to several CPU architectures. A VM creates one standard <em>CPU architecture</em> which is simulated on various hardware devices. One advantage of a compiler is that it has no runtime overhead while a VM does. Even though compilers do a pretty good job, writing a new one that targets multiple platforms is very difficult, so VMs are still helpful here. In practice, VMs and compilers are mixed at various levels.
</p>
</blockquote>
<p>The <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">Java Virtual Machine (JVM)</a> is a very successful example. The JVM itself is a moderately sized program that is small enough for one programmer to understand. This has made it possible to be written for thousands of devices including phones. Once the JVM is implemented on a new device, any Java, Kotlin, or Clojure program ever written can run on it without modification. The only cost is the overhead of the VM itself and the <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/">further abstraction</a> from the machine. Most of the time, this is a pretty good tradeoff.
</p>
<p>A VM doesn't have to be large or pervasive to provide a similar benefit. Old <a href="https://fabiensanglard.net/anotherWorld_code_review/">video games</a> often used small VMs to provide simple <a href="https://sf2platinum.wordpress.com/page/1/">scripting systems</a>.
</p>
<p>VMs are also useful for executing code in a secure or isolated way. One application of this is garbage collection. There <a href="https://www.lua.org/pil/24.2.html">is no trivial way</a> to implement automatic garbage collection on top of C or C++ since a program cannot see its own stack or variables. However, a VM is “outside” the program it is running and can observe all of the <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">memory references</a> on the stack.
</p>
<p>Another example of this behavior is demonstrated by <a href="https://solidity.readthedocs.io/en/v0.4.24/introduction-to-smart-contracts.html">Ethereum smart contracts</a>. Smart contracts are small programs which are executed by each validating node in the blockchain network. This requires the node operators to run programs on their machines that have been written by complete strangers, without any opportunity to scrutinize them beforehand. To prevent a contract from doing malicious things, they are run inside a <a href="http://ethdocs.org/en/latest/introduction/what-is-ethereum.html#ethereum-virtual-machine">VM</a> that has no access to the file system, network, disc, etc. Ethereum is also a good application of the portability features that result when using a VM. Since Ethereum nodes can be run on many kinds of computers and operating systems, the use of a VM allows smart contracts to be written without any consideration of the many platforms they run on.
</p>

</div>
<a name="1:3"></a><div><a name="1:3"><h4>3. LC-3 Architecture</h4></a>
<p>Our VM will simulate a fictional computer called the <a href="https://en.wikipedia.org/wiki/Little_Computer_3">LC-3</a>. The LC-3 is popular for teaching university students how to program in assembly language. It has a simplified instruction set <a href="http://ref.x86asm.net/coder64.html">compared to x86</a>, but contains all the main ideas used in modern CPUs.
</p>
<p>First, we need to simulate the essential hardware components of the machine. Try to understand what each component is, but don't worry right now if you are unsure of how it fits into the larger picture. Start by creating a C file. Each of the code snippets in this section should be placed in the global scope of this file.
</p>
<h3> Memory</h3>
<p>The LC-3 has 65,536 memory locations (the maximum that is addressable by a 16-bit unsigned integer <code>2^16</code>), each of which stores a 16-bit value. This means it can store a total of only 128kb, which is a lot smaller than you may be used to! In our program, this memory will be stored in a simple array:
</p>

<div>
<p><span>{Memory Storage <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span></p><pre><span>/* 65536 locations */</span><span>
</span><span>uint16_t</span><span> memory</span><span>[</span><span>UINT16_MAX</span><span>];</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>
<h3> Registers</h3>
<p>A register is a slot for storing a single value on the CPU. Registers are like the "workbench" of the CPU. For the CPU to work with a piece of data, it has to be in one of the registers. However, since there are just a few registers, only a minimal amount of data can be loaded at any given time. Programs work around this by loading values from memory into registers, calculating values into other registers, and then storing the final results back in memory.
</p>
<p>The LC-3 has 10 total registers, each of which is 16 bits. Most of them are general purpose, but a few have designated roles.
</p>
<ul>
<li>8 general purpose registers  (<code>R0</code>-<code>R7</code>)
</li>
<li>1 program counter (<code>PC</code>) register
</li>
<li>1 condition flags (<code>COND</code>) register
</li>
</ul>
<p>The general purpose registers can be used to perform any program calculations. The program counter is an unsigned integer which is the address of the next instruction in memory to execute. The condition flags tell us information about the previous calculation.
</p>

<div>
<p><span>{Registers <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span></p><pre><span>enum</span><span>
</span><span>{</span><span>
    R_R0 </span><span>=</span><span> </span><span>0</span><span>,</span><span>
    R_R1</span><span>,</span><span>
    R_R2</span><span>,</span><span>
    R_R3</span><span>,</span><span>
    R_R4</span><span>,</span><span>
    R_R5</span><span>,</span><span>
    R_R6</span><span>,</span><span>
    R_R7</span><span>,</span><span>
    R_PC</span><span>,</span><span> </span><span>/* program counter */</span><span>
    R_COND</span><span>,</span><span>
    R_COUNT
</span><span>};</span></pre>



</div>
<p>Just like the memory, we will store the registers in an array:
</p>

<div>
<p><span>{Register Storage <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span></p><pre><span>uint16_t</span><span> reg</span><span>[</span><span>R_COUNT</span><span>];</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>
<h3> Instruction Set</h3>
<p>An instruction is a command which tells the CPU to do some fundamental task, such as add two numbers. Instructions have both an <strong>opcode</strong> which indicates the kind of task to perform and a set of <strong>parameters</strong> which provide inputs to the task being performed.
</p>
<p>Each <strong>opcode</strong> represents one task that the CPU "knows" how to do. There are just 16 opcodes in LC-3. Everything the computer can calculate is some sequence of these simple instructions. Each instruction is 16 bits long, with the left 4 bits storing the opcode. The rest of the bits are used to store the parameters.
</p>
<p>We will discuss, in detail, what each instruction does later. For now, define the following opcodes. Make sure they stay in this order so that they are assigned the proper enum value:
</p>

<div>
<p><span>{Opcodes <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span></p><pre><span>enum</span><span>
</span><span>{</span><span>
    OP_BR </span><span>=</span><span> </span><span>0</span><span>,</span><span> </span><span>/* branch */</span><span>
    OP_ADD</span><span>,</span><span>    </span><span>/* add  */</span><span>
    OP_LD</span><span>,</span><span>     </span><span>/* load */</span><span>
    OP_ST</span><span>,</span><span>     </span><span>/* store */</span><span>
    OP_JSR</span><span>,</span><span>    </span><span>/* jump register */</span><span>
    OP_AND</span><span>,</span><span>    </span><span>/* bitwise and */</span><span>
    OP_LDR</span><span>,</span><span>    </span><span>/* load register */</span><span>
    OP_STR</span><span>,</span><span>    </span><span>/* store register */</span><span>
    OP_RTI</span><span>,</span><span>    </span><span>/* unused */</span><span>
    OP_NOT</span><span>,</span><span>    </span><span>/* bitwise not */</span><span>
    OP_LDI</span><span>,</span><span>    </span><span>/* load indirect */</span><span>
    OP_STI</span><span>,</span><span>    </span><span>/* store indirect */</span><span>
    OP_JMP</span><span>,</span><span>    </span><span>/* jump */</span><span>
    OP_RES</span><span>,</span><span>    </span><span>/* reserved (unused) */</span><span>
    OP_LEA</span><span>,</span><span>    </span><span>/* load effective address */</span><span>
    OP_TRAP    </span><span>/* execute trap */</span><span>
</span><span>};</span></pre>



</div>
<blockquote><p> <strong>Note:</strong> The Intel x86 architecture has hundreds of instructions, while others such as ARM and LC-3 have very few. Small instruction sets are referred to as <a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer">RISCs</a> while larger ones are called <a href="https://en.wikipedia.org/wiki/Complex_instruction_set_computer">CISCs</a>. Larger instruction sets typically do not provide any fundamentally new possibilities, but they <a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/">often make it more convenient</a> to write assembly for. A single instruction in CISC might take the place of several in RISC. However, they tend to be more complex and expensive for engineers to design and manufacture. This and other tradeoffs cause the designs to come <a href="https://cs.stackexchange.com/questions/269/why-would-anyone-want-cisc">in and out of style</a>.
</p>
</blockquote>
<h3> Condition Flags</h3>
<p>The <code>R_COND</code> register stores condition flags which provide information about the most recently executed calculation. This allows programs to check logical conditions such as <code>if (x &gt; 0) { ... }</code>.
</p>
<p>Each CPU has a variety of condition flags to signal various situations. The LC-3 uses only 3 condition flags which indicate the sign of the previous calculation.
</p>

<div>
<p><span>{Condition Flags <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span></p><pre><span>enum</span><span>
</span><span>{</span><span>
    FL_POS </span><span>=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>0</span><span>,</span><span> </span><span>/* P */</span><span>
    FL_ZRO </span><span>=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span>,</span><span> </span><span>/* Z */</span><span>
    FL_NEG </span><span>=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>2</span><span>,</span><span> </span><span>/* N */</span><span>
</span><span>};</span></pre>



</div>
<blockquote><p> <strong>Note:</strong> (The <code>&lt;&lt;</code> symbol is called the <a href="https://msdn.microsoft.com/en-us/library/336xbhcz.aspx">left bitshift operator</a>. <code>(n &lt;&lt; k)</code> shifts the bits of <code>n</code> to the left <code>k</code> places. Thus <code>1 &lt;&lt; 2</code> will equal <code>4</code>. Read that link if you are not familiar. It will be important.)
</p>
</blockquote>
<p>We are finished setting up the hardware components of our VM! After adding standard includes (see reference), your file should look something like this:
</p>

<div>
<p><span>{<strong>lc3.c</strong> <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span></p><pre><span>{Includes, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span><span>

</span><span>{Registers, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span><span>
</span><span>{Opcodes, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span><span>
</span><span>{Condition Flags, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span>
</pre>
<p>Added to in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>


</div>
</div>
<a name="1:4"></a><div><a name="1:4"><h4>4. Assembly Examples</h4></a>
<p>Now let's look at an LC-3 assembly program to get an idea of what the VM actually runs. You don't need to know how to program assembly or understand everything that is going on. Just try to get a general idea of what is going on. Here is a simple "Hello World":
</p>

<div>
<p><span>{Hello World Assembly <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:4">4</a>}</span></p><pre><span>.</span><span>ORIG x3000                        </span><span>;</span><span> </span><span>this</span><span> is the address in memory </span><span>where</span><span> the program will be loaded
LEA R0</span><span>,</span><span> HELLO_STR                  </span><span>;</span><span> load the address of the HELLO_STR string into R0
</span><span>PUTs</span><span>                               </span><span>;</span><span> output the string pointed to by R0 to the console
HALT                               </span><span>;</span><span> halt the program
HELLO_STR </span><span>.</span><span>STRINGZ </span><span>"Hello World!"</span><span>  </span><span>;</span><span> store </span><span>this</span><span> string here in the program
</span><span>.</span><span>END                               </span><span>;</span><span> mark the end of the file</span></pre>



</div>
<p>Just like in C, the program starts at the top and executes one statement at a time. However, unlike C, there are no nested scopes <code>{}</code> or control structures such as <code>if</code> or <code>while</code>; just a flat list of statements. This makes it much easier to execute.
</p>
<p>Notice that some of the statements have names which match the opcodes we defined earlier. Previously, we learned that every instruction was 16 bits, but each line looks like it is a different number of characters. How is this inconsistency possible?
</p>
<p>This is because the code we are reading is written in <strong>assembly</strong> which is a human-readable and writable form, encoded in plain text. A tool called an <strong>assembler</strong> is used to transform each line of text into a 16-bit binary instruction the VM can understand. This binary form, which is essentially an array of 16-bit instructions, is called <strong>machine code</strong> and is what the VM actually runs.
</p>
<p><img src="https://justinmeiners.github.io/lc3-vm/img/assembler.gif" alt="assembler diagram">
</p>
<blockquote><p> <strong>Note:</strong> Although a compiler and an assembler play a similar role in development, they are not the same. An assembler simply encodes what the programmer has written in text into binary, replacing symbols with their binary representation and packing them into instructions.
</p>
</blockquote>
<p>The commands <code>.ORIG</code> and <code>.STRINGZ</code> look like instructions but they aren't. They are assembler directives which generate a piece of code or data (like macros). For example, the <code>.STRINGZ</code> inserts a string of characters into the program binary at the location it is written.
</p>
<p>Loops and conditions are done with a <a href="https://en.wikipedia.org/wiki/Goto">goto</a>-like instruction. Here is another example which counts to 10.
</p>

<div>
<p><span>{Loop Assembly <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:4">4</a>}</span></p><pre><span>AND R0</span><span>,</span><span> R0</span><span>,</span><span> </span><span>0</span><span>                      </span><span>;</span><span> clear R0
LOOP                               </span><span>;</span><span> label at the top of our loop
ADD R0</span><span>,</span><span> R0</span><span>,</span><span> </span><span>1</span><span>                      </span><span>;</span><span> add </span><span>1</span><span> to R0 and store back in R0
ADD R1</span><span>,</span><span> R0</span><span>,</span><span> </span><span>-</span><span>10</span><span>                    </span><span>;</span><span> subtract </span><span>10</span><span> from R0 and store back in R1
</span><span>BRn</span><span> LOOP                           </span><span>;</span><span> go back to LOOP </span><span>if</span><span> the result was negative
</span><span>...</span><span> </span><span>;</span><span> R0 is now </span><span>10</span><span>!</span></pre>



</div>
<blockquote><p> <strong>Note:</strong> Learning to write assembly is not necessary for this tutorial. However, if you are interested, you can write and assemble your own LC-3 programs using the <a href="http://highered.mheducation.com/sites/0072467509/student_view0/lc-3_simulator.html">LC-3 Tools</a>.
</p>
</blockquote>

</div>
<a name="1:5"></a><div><a name="1:5"><h4>5. Executing Programs</h4></a>
<p>Once again, the previous examples are just to give you an idea of what the VM does. To write a VM, you don't need to be fluent in assembly. As long as you follow the proper procedure for reading and executing instructions, <em>any</em> LC-3 program will run correctly, no matter how complicated it is. In theory, it could even run a web browser or an operating system like Linux!
</p>
<p>If you think about this property deeply, it is a philosophically remarkable idea. The programs themselves can do all kinds of intelligent things that we never anticipated and may not be able to understand, but at the same time, everything they can do is limited to the simple code we will write! We simultaneously know everything and nothing about how each program works. Turing observed this marvelous idea:
</p>
<blockquote><p> "The view that machines cannot give rise to surprises is due, I believe, to a fallacy to which philosophers and mathematicians are particularly subject. This is the assumption that as soon as a fact is presented to a mind all consequences of that fact spring into the mind simultaneously with it. It is a very useful assumption under many circumstances, but one too easily forgets that it is false." — <a href="https://academic.oup.com/mind/article-pdf/LIX/236/433/9866119/433.pdf">Alan M. Turing</a>
</p>
</blockquote>
<h3> Procedure</h3>
<p>Here is the procedure we need to write:
</p>
<ol>
<li>Load one instruction from memory at the address of the <code>PC</code> register.
</li>
<li>Increment the <code>PC</code> register.
</li>
<li>Look at the <em>opcode</em> to determine which type of instruction it should perform.
</li>
<li>Perform the instruction using the parameters in the instruction.
</li>
<li>Go back to step 1.
</li>
</ol>
<p>You may be wondering, "if the loop keeps incrementing the <code>PC</code>, and we don't have <code>if</code> or <code>while</code>, won't it quickly run out of instructions?" No. As we mentioned before, some goto-like instructions change the execution flow by jumping the <code>PC</code> around.
</p>
<p>Let's start outlining this process in the main loop:
</p>

<div>
<p><span>{Main Loop <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a>}</span></p><pre><span>
</span><span>int</span><span> main</span><span>(</span><span>int</span><span> argc</span><span>,</span><span> </span><span>const</span><span> </span><span>char</span><span>*</span><span> argv</span><span>[])</span><span>
</span><span>{</span><span>
</span><span>    {Load Arguments, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a>}</span><span>
</span><span>    {Setup, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span><span>

    </span><span>/* set the PC to starting position */</span><span>
    </span><span>/* 0x3000 is the default */</span><span>
    </span><span>enum</span><span> </span><span>{</span><span> PC_START </span><span>=</span><span> </span><span>0x3000</span><span> </span><span>};</span><span>
    reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>=</span><span> PC_START</span><span>;</span><span>

    </span><span>int</span><span> running </span><span>=</span><span> </span><span>1</span><span>;</span><span>
    </span><span>while</span><span> </span><span>(</span><span>running</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>/* FETCH */</span><span>
        </span><span>uint16_t</span><span> instr </span><span>=</span><span> mem_read</span><span>(</span><span>reg</span><span>[</span><span>R_PC</span><span>]++);</span><span>
        </span><span>uint16_t</span><span> op </span><span>=</span><span> instr </span><span>&gt;&gt;</span><span> </span><span>12</span><span>;</span><span>

        </span><span>switch</span><span> </span><span>(</span><span>op</span><span>)</span><span>
        </span><span>{</span><span>
            </span><span>case</span><span> OP_ADD</span><span>:</span><span>
</span><span>                {ADD, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_AND</span><span>:</span><span>
</span><span>                {AND, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_NOT</span><span>:</span><span>
</span><span>                {NOT, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_BR</span><span>:</span><span>
</span><span>                {BR, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_JMP</span><span>:</span><span>
</span><span>                {JMP, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_JSR</span><span>:</span><span>
</span><span>                {JSR, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_LD</span><span>:</span><span>
</span><span>                {LD, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_LDI</span><span>:</span><span>
</span><span>                {LDI, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_LDR</span><span>:</span><span>
</span><span>                {LDR, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_LEA</span><span>:</span><span>
</span><span>                {LEA, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_ST</span><span>:</span><span>
</span><span>                {ST, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_STI</span><span>:</span><span>
</span><span>                {STI, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_STR</span><span>:</span><span>
</span><span>                {STR, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_TRAP</span><span>:</span><span>
</span><span>                {TRAP, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a>}</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>case</span><span> OP_RES</span><span>:</span><span>
            </span><span>case</span><span> OP_RTI</span><span>:</span><span>
            </span><span>default</span><span>:</span><span>
</span><span>                {BAD OPCODE, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span><span>
                </span><span>break</span><span>;</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
</span><span>    {Shutdown, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>
<p>While we are at the main loop let's handle command line input to make our program usable.
We expect one or more paths to VM images and present a usage string if none are given.
</p>

<div>
<p><span>{Load Arguments <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a>}</span></p><pre><span>if</span><span> </span><span>(</span><span>argc </span><span>&lt;</span><span> </span><span>2</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>/* show usage string */</span><span>
    printf</span><span>(</span><span>"lc3 [image-file1] ...
"</span><span>);</span><span>
    exit</span><span>(</span><span>2</span><span>);</span><span>
</span><span>}</span><span>

</span><span>for</span><span> </span><span>(</span><span>int</span><span> j </span><span>=</span><span> </span><span>1</span><span>;</span><span> j </span><span>&lt;</span><span> argc</span><span>;</span><span> </span><span>++</span><span>j</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>if</span><span> </span><span>(!</span><span>read_image</span><span>(</span><span>argv</span><span>[</span><span>j</span><span>]))</span><span>
    </span><span>{</span><span>
        printf</span><span>(</span><span>"failed to load image: %s
"</span><span>,</span><span> argv</span><span>[</span><span>j</span><span>]);</span><span>
        exit</span><span>(</span><span>1</span><span>);</span><span>
    </span><span>}</span><span>
</span><span>}</span></pre>



</div>
</div>
<a name="1:6"></a><div><a name="1:6"><h4>6. Implementing Instructions</h4></a>
<p>Your task now is to fill in each opcode case with a correct implementation. This is easier than it sounds. A detailed specification for each instruction is included in the <a href="https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf">project documents</a>. The specificiation for each translates pretty easily to several lines of codes. I will demonstrate how to implement two of them here. The code for the rest can be found in the next section.
</p>
<h3> ADD</h3>
<p>The <code>ADD</code> instruction takes two numbers, adds them together, and stores the result in a register. Its specification is found on page 526. Each <code>ADD</code> instruction looks like the following:
</p>
<p><img src="https://justinmeiners.github.io/lc3-vm/img/add_layout.gif" alt="Add Encoding">
</p>
<p>The encoding shows two rows because there are two different "modes" for this instruction. Before I explain modes, let's try to find the similarities between them. In both rows, we can see that we start with 4 bits, <code>0001</code>. This is the opcode value for <code>OP_ADD</code>. The next 3 bits are marked <code>DR</code>. This stands for destination register. The destination register is where the added sum will be stored. The next 3 bits are <code>SR1</code>. This is the register containing the first number to add.
</p>
<p>So we know where we want to store the result and we know the first number to add. The last bit of information we need is the second number to add. At this point, the two rows start to look different. Notice that on the top row the 5th bit is a <code>0</code> and in the second row it is <code>1</code>. This bit indicates whether it is <em>immediate mode</em> or <em>register mode</em>. In <em>register mode</em>, the second number is stored in a register just like the first. This is marked <code>SR2</code> and is contained in bits 2-0. Bits 3 and 4 are unused. In assembly this would be written as:
</p>

<div>
<p><span>{Add Register Assembly <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span></p><pre><span>ADD R2 R0 R1 </span><span>;</span><span> add the contents of R0 to R1 and store in R2</span><span>.</span></pre>



</div>
<p>Immediate mode is a convenience which reduces the length of a typical program.
Instead of adding two values stored in separate registers, the second value is embedded in the instruction itself, marked
<code>imm5</code> in the diagram.
This removes the need to write instructions to load the value from memory.
The tradeoff is that the instruction only has room for a small number, up to <code>2^5=32</code> (unsigned) to be exact,
making immediate mode primarily useful for incrementing and decrementing. In assembly, it could be written as:
</p>

<div>
<p><span>{Add Immediate Assembly <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span></p><pre><span>ADD R0 R0 </span><span>1</span><span> </span><span>;</span><span> add </span><span>1</span><span> to R0 and store back in R0</span></pre>



</div>
<p>Here is a summary from the specification:
</p>
<blockquote><p> If bit [5] is 0, the second source operand is obtained from SR2. If bit [5] is 1, the second source operand is obtained by sign-extending the imm5 field to 16 bits. In both cases, the second source operand is added to the contents of SR1 and the result stored in DR. (Pg. 526)
</p>
</blockquote>
<p>That sounds just like the behaviour we discussed, but what is "sign-extending"? The immediate mode value has only 5 bits, but it needs to be added to a 16-bit number. To do the addition, those 5 bits need to be extended to 16 to match the other number. For positive numbers, we can simply fill in 0's for the additional bits. For negative numbers, this causes a problem. For example, -1 in 5 bits is <code>1 1111</code>. If we just extended it with 0's, this is <code>0000 0000 0001 1111</code> which is equal to 31. Sign extension corrects this problem by filling in 0's for positive numbers and 1's for negative numbers, so that original values are preserved.
</p>

<div>
<p><span>{Sign Extend <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span></p><pre><span>uint16_t</span><span> sign_extend</span><span>(</span><span>uint16_t</span><span> x</span><span>,</span><span> </span><span>int</span><span> bit_count</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>if</span><span> </span><span>((</span><span>x </span><span>&gt;&gt;</span><span> </span><span>(</span><span>bit_count </span><span>-</span><span> </span><span>1</span><span>))</span><span> </span><span>&amp;</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span>
        x </span><span>|=</span><span> </span><span>(</span><span>0xFFFF</span><span> </span><span>&lt;&lt;</span><span> bit_count</span><span>);</span><span>
    </span><span>}</span><span>
    </span><span>return</span><span> x</span><span>;</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>
<blockquote><p> <strong>Note:</strong> If you are interested in exactly how negative numbers can be represented in binary, you can read about <a href="https://en.wikipedia.org/wiki/Two%27s_complement">Two's Complement</a>. However, this is not essential. You can just copy the code above and use it whenever the specification says to sign extend numbers.
</p>
</blockquote>
<p>There is one last sentence in the specification:
</p>
<blockquote><p> The condition codes are set, based on whether the result is negative, zero, or positive. (Pg. 526)
</p>
</blockquote>
<p>Earlier we defined a condition flags enum, and now it's time to use them. <em>Any time</em> a value is written to a register, we need to update the flags to indicate its sign. We will write a function so that this can be reused:
</p>

<div>
<p><span>{Update Flags <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span></p><pre><span>void</span><span> update_flags</span><span>(</span><span>uint16_t</span><span> r</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>if</span><span> </span><span>(</span><span>reg</span><span>[</span><span>r</span><span>]</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span>
    </span><span>{</span><span>
        reg</span><span>[</span><span>R_COND</span><span>]</span><span> </span><span>=</span><span> FL_ZRO</span><span>;</span><span>
    </span><span>}</span><span>
    </span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>reg</span><span>[</span><span>r</span><span>]</span><span> </span><span>&gt;&gt;</span><span> </span><span>15</span><span>)</span><span> </span><span>/* a 1 in the left-most bit indicates negative */</span><span>
    </span><span>{</span><span>
        reg</span><span>[</span><span>R_COND</span><span>]</span><span> </span><span>=</span><span> FL_NEG</span><span>;</span><span>
    </span><span>}</span><span>
    </span><span>else</span><span>
    </span><span>{</span><span>
        reg</span><span>[</span><span>R_COND</span><span>]</span><span> </span><span>=</span><span> FL_POS</span><span>;</span><span>
    </span><span>}</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>
<p>Now we are ready to write the code for the <code>ADD</code> case:
</p>

<div>
<p><span>{ADD <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span></p><pre><span>{</span><span>
    </span><span>/* destination register (DR) */</span><span>
    </span><span>uint16_t</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>/* first operand (SR1) */</span><span>
    </span><span>uint16_t</span><span> r1 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>6</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>/* whether we are in immediate mode */</span><span>
    </span><span>uint16_t</span><span> imm_flag </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>5</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x1</span><span>;</span><span>

    </span><span>if</span><span> </span><span>(</span><span>imm_flag</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>uint16_t</span><span> imm5 </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x1F</span><span>,</span><span> </span><span>5</span><span>);</span><span>
        reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>+</span><span> imm5</span><span>;</span><span>
    </span><span>}</span><span>
    </span><span>else</span><span>
    </span><span>{</span><span>
        </span><span>uint16_t</span><span> r2 </span><span>=</span><span> instr </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
        reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>+</span><span> reg</span><span>[</span><span>r2</span><span>];</span><span>
    </span><span>}</span><span>

    update_flags</span><span>(</span><span>r0</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<p>This section contained a lot of information, so let's summarize.
</p>
<ul>
<li><code>ADD</code> takes two values and stores them in a register.
</li>
<li>In register mode, the second value to add is found in a register.
</li>
<li>In immediate mode, the second value is embedded in the right-most 5 bits of the instruction.
</li>
<li>Values which are shorter than 16 bits need to be sign extended.
</li>
<li>Any time an instruction modifies a register, the condition flags need to be updated.
</li>
</ul>
<p>You may be feeling overwhelmed about writing 15 more instructions. However, all of what you learned here will be reused. Most of the instructions use some combination of sign extension, different modes, and updating flags.
</p>
<h3> LDI</h3>
<p><code>LDI</code> stands for "load indirect." This instruction is used to load a value from a location in memory into a register. The specification is found on page 532.
</p>
<p>Here is what the binary layout looks like:
</p>
<p><img src="https://justinmeiners.github.io/lc3-vm/img/ldi_layout.gif" alt="LDI Encoding">
</p>
<p>In contrast to <code>ADD</code>, there are no modes and fewer parameters. This time, the opcode is <code>1010</code> which corresponds with the <code>OP_LDI</code> enum value. Just like <code>ADD</code>, it contains a 3-bit <code>DR</code> (the destination register) for storing the loaded value. The remaining bits are labeled <code>PCoffset9</code>. This is an immediate value embedded in the instruction (similar to <code>imm5</code>). Since this instruction loads from memory, we can guess that this number is some kind of address which tells us where to load from. The specification provides more detail:
</p>
<blockquote><p> An address is computed by sign-extending bits <code>[8:0]</code> to 16 bits and adding this value to the incremented <code>PC</code>. What is stored in memory at this address is the address of the data to be loaded into <code>DR</code>. (Pg. 532)
</p>
</blockquote>
<p>Just like before, we need to sign extend this 9-bit value, but this time add it to the current <code>PC</code>. (If you look back at the execution loop, the <code>PC</code> was incremented right after this instruction was loaded.) The resulting sum is an address to a location in memory, and that address <em>contains, yet another</em> value which is the address of the value to load.
</p>
<p>This may seem like a roundabout way to read from memory, but it is indispensable. The <code>LD</code> instruction is limited to address offsets that are 9 bits, whereas the memory requires 16 bits to address. <code>LDI</code> is useful for loading values that are stored in locations far away from the current PC, but to use it, the address of the final location needs to be stored in a neighborhood nearby. You can think of it like having a local variable in C which is a pointer to some data:
</p>

<div>
<p><span>{C LDI Sample <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span></p><pre><span>// the value of far_data is an address</span><span>
</span><span>// of course far_data itself (the location in memory containing the address) has an address</span><span>
</span><span>char</span><span>*</span><span> far_data </span><span>=</span><span> </span><span>"apple"</span><span>;</span><span>

</span><span>// In memory it may be layed out like this:</span><span>

</span><span>// Address Label      Value</span><span>
</span><span>// 0x123:  far_data = 0x456</span><span>
</span><span>// ...</span><span>
</span><span>// 0x456:  string   = 'a'</span><span>

</span><span>// if PC was at 0x100</span><span>
</span><span>// LDI R0 0x023</span><span>
</span><span>// would load 'a' into R0</span></pre>



</div>
<p>Same as before, the flags need to be updated after putting the value into <code>DR</code>:
</p>
<blockquote><p> The condition codes are set based on whether the value loaded is negative, zero, or positive. (Pg. 532)
</p>
</blockquote>
<p>Here is the code for this case: (<code>mem_read</code> will be discussed in a later section.)
</p>

<div>
<p><span>{LDI <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span></p><pre><span>{</span><span>
    </span><span>/* destination register (DR) */</span><span>
    </span><span>uint16_t</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>/* PCoffset 9*/</span><span>
    </span><span>uint16_t</span><span> pc_offset </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x1FF</span><span>,</span><span> </span><span>9</span><span>);</span><span>
    </span><span>/* add pc_offset to the current PC, look at that memory location to get the final address */</span><span>
    reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> mem_read</span><span>(</span><span>mem_read</span><span>(</span><span>reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>+</span><span> pc_offset</span><span>));</span><span>
    update_flags</span><span>(</span><span>r0</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<p>As I said, this instruction shared a lot of the code and knowledge learned from <code>ADD</code>. You will find this is the case with the remaining instructions.
</p>
<p>You now need to go back and implement the rest of the switch cases for the instructions. Follow <a href="https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf">the specification</a> and use the code listed here to complete the others. The code for all instructions is listed at the end of the tutorial. Two of the opcodes specified before will not be used, they are <code>OP_RTI</code> and <code>OP_RES</code>. You can ignore these cases or throw an error if they are executed. After you are done, the bulk of your VM will be completed!
</p>

</div>
<a name="1:7"></a><div><a name="1:7"><h4>7. Instruction Cheat Sheet</h4></a>
<p>This section contains the full implementations of the remaining instructions if you get stuck.
</p>
<h3> RTI &amp; RES</h3>
<p>(these are unused)
</p>

<div>
<p><span>{BAD OPCODE <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>abort</span><span>();</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> <a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND">Bitwise and</a></h3>

<div>
<p><span>{AND <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>uint16_t</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> r1 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>6</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> imm_flag </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>5</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x1</span><span>;</span><span>

    </span><span>if</span><span> </span><span>(</span><span>imm_flag</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>uint16_t</span><span> imm5 </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x1F</span><span>,</span><span> </span><span>5</span><span>);</span><span>
        reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>&amp;</span><span> imm5</span><span>;</span><span>
    </span><span>}</span><span>
    </span><span>else</span><span>
    </span><span>{</span><span>
        </span><span>uint16_t</span><span> r2 </span><span>=</span><span> instr </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
        reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>&amp;</span><span> reg</span><span>[</span><span>r2</span><span>];</span><span>
    </span><span>}</span><span>
    update_flags</span><span>(</span><span>r0</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> <a href="https://en.wikipedia.org/wiki/Bitwise_operation#NOT">Bitwise not</a></h3>

<div>
<p><span>{NOT <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>uint16_t</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> r1 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>6</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>

    reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> </span><span>~</span><span>reg</span><span>[</span><span>r1</span><span>];</span><span>
    update_flags</span><span>(</span><span>r0</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> Branch</h3>

<div>
<p><span>{BR <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>uint16_t</span><span> pc_offset </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x1FF</span><span>,</span><span> </span><span>9</span><span>);</span><span>
    </span><span>uint16_t</span><span> cond_flag </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>if</span><span> </span><span>(</span><span>cond_flag </span><span>&amp;</span><span> reg</span><span>[</span><span>R_COND</span><span>])</span><span>
    </span><span>{</span><span>
        reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>+=</span><span> pc_offset</span><span>;</span><span>
    </span><span>}</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> Jump</h3>
<p><code>RET</code> is listed as a separate instruction in the specification, since it is a different keyword in assembly. However, it is actually a special case of <code>JMP</code>. <code>RET</code> happens whenever <code>R1</code> is 7.
</p>

<div>
<p><span>{JMP <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>/* Also handles RET */</span><span>
    </span><span>uint16_t</span><span> r1 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>6</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>];</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> Jump Register</h3>

<div>
<p><span>{JSR <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>uint16_t</span><span> long_flag </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>11</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>1</span><span>;</span><span>
    reg</span><span>[</span><span>R_R7</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>R_PC</span><span>];</span><span>
    </span><span>if</span><span> </span><span>(</span><span>long_flag</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>uint16_t</span><span> long_pc_offset </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x7FF</span><span>,</span><span> </span><span>11</span><span>);</span><span>
        reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>+=</span><span> long_pc_offset</span><span>;</span><span>  </span><span>/* JSR */</span><span>
    </span><span>}</span><span>
    </span><span>else</span><span>
    </span><span>{</span><span>
        </span><span>uint16_t</span><span> r1 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>6</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
        reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>];</span><span> </span><span>/* JSRR */</span><span>
    </span><span>}</span><span>
    </span><span>break</span><span>;</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> Load</h3>

<div>
<p><span>{LD <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>uint16_t</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> pc_offset </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x1FF</span><span>,</span><span> </span><span>9</span><span>);</span><span>
    reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> mem_read</span><span>(</span><span>reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>+</span><span> pc_offset</span><span>);</span><span>
    update_flags</span><span>(</span><span>r0</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> Load Register</h3>

<div>
<p><span>{LDR <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>uint16_t</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> r1 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>6</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> offset </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x3F</span><span>,</span><span> </span><span>6</span><span>);</span><span>
    reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> mem_read</span><span>(</span><span>reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>+</span><span> offset</span><span>);</span><span>
    update_flags</span><span>(</span><span>r0</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> Load Effective Address</h3>

<div>
<p><span>{LEA <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>uint16_t</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> pc_offset </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x1FF</span><span>,</span><span> </span><span>9</span><span>);</span><span>
    reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>+</span><span> pc_offset</span><span>;</span><span>
    update_flags</span><span>(</span><span>r0</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> Store</h3>

<div>
<p><span>{ST <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>uint16_t</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> pc_offset </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x1FF</span><span>,</span><span> </span><span>9</span><span>);</span><span>
    mem_write</span><span>(</span><span>reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>+</span><span> pc_offset</span><span>,</span><span> reg</span><span>[</span><span>r0</span><span>]);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> Store Indirect</h3>

<div>
<p><span>{STI <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>uint16_t</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> pc_offset </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x1FF</span><span>,</span><span> </span><span>9</span><span>);</span><span>
    mem_write</span><span>(</span><span>mem_read</span><span>(</span><span>reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>+</span><span> pc_offset</span><span>),</span><span> reg</span><span>[</span><span>r0</span><span>]);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<h3> Store Register</h3>

<div>
<p><span>{STR <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:7">7</a>}</span></p><pre><span>{</span><span>
    </span><span>uint16_t</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> r1 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>6</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
    </span><span>uint16_t</span><span> offset </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x3F</span><span>,</span><span> </span><span>6</span><span>);</span><span>
    mem_write</span><span>(</span><span>reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>+</span><span> offset</span><span>,</span><span> reg</span><span>[</span><span>r0</span><span>]);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
</div>
<a name="1:8"></a><div><a name="1:8"><h4>8. Trap Routines</h4></a>
<p>The LC-3 provides a few predefined routines for performing common tasks and interacting with I/O devices. For example, there are routines for getting input from the keyboard and for displaying strings to the console. These are called <em>trap routines</em> which you can think of as the operating system or API for the LC-3. Each trap routine is assigned a <em>trap code</em> which identifies it (similar to an opcode). To execute one, the <code>TRAP</code> instruction is called with the trap code of the desired routine.
</p>
<p><img src="https://justinmeiners.github.io/lc3-vm/img/trap_layout.gif" alt="Trap Encoding">
</p>
<p>Define an enum for each trap code:
</p>

<div>
<p><span>{TRAP Codes <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a>}</span></p><pre><span>enum</span><span>
</span><span>{</span><span>
    TRAP_GETC </span><span>=</span><span> </span><span>0x20</span><span>,</span><span>  </span><span>/* get character from keyboard, not echoed onto the terminal */</span><span>
    TRAP_OUT </span><span>=</span><span> </span><span>0x21</span><span>,</span><span>   </span><span>/* output a character */</span><span>
    TRAP_PUTS </span><span>=</span><span> </span><span>0x22</span><span>,</span><span>  </span><span>/* output a word string */</span><span>
    TRAP_IN </span><span>=</span><span> </span><span>0x23</span><span>,</span><span>    </span><span>/* get character from keyboard, echoed onto the terminal */</span><span>
    TRAP_PUTSP </span><span>=</span><span> </span><span>0x24</span><span>,</span><span> </span><span>/* output a byte string */</span><span>
    TRAP_HALT </span><span>=</span><span> </span><span>0x25</span><span>   </span><span>/* halt the program */</span><span>
</span><span>};</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>
<p>You may be wondering why the trap codes are not included in the instructions. This is because they do not actually introduce any new functionality to the LC-3, they just provide a convenient way to perform a task (similar to system functions in C). In the official LC-3 simulator, trap routines are <a href="https://justinmeiners.github.io/lc3-vm/supplies/os.asm">written in assembly</a>. When a trap code is called, the <code>PC</code> is moved to that code's address. The CPU executes instructions of the procedure, and when it is complete, the PC is reset to the location the trap was called from.
</p>
<blockquote><p> <strong>Note:</strong> This is why programs start at address <code>0x3000</code> instead of <code>0x0</code>. The lower addresses are left empty to leave space for the trap routine code.
</p>
</blockquote>
<p>There is no specification for <em>how</em> trap routines must be implemented, only what they are supposed to do. In our VM, we are going to do things slightly differently by writing them in C. When a trap code is invoked, a C function will be called. When it is completed, execution will return to the instructions.
</p>
<p>Even though the trap routines can be written in assembly and this is what a physical LC-3 computer would do, it isn't the best fit for a VM. Instead of writing our own primitive I/O routines, we can take advantage of the ones available on our OS. This will make the VM run better on our computers, simplify the code, and provide a higher level of abstraction for portability.
</p>
<blockquote><p> <strong>Note:</strong> Getting input from the keyboard is one specific example of this. The assembly version uses a loop to continuously check the keyboard for input. This consumes a lot of CPU time for nothing! Using a proper OS input function allows the program to sleep until input is received.
</p>
</blockquote>
<p>In the switch case form the <code>TRAP</code> opcode, add another switch:
</p>

<div>
<p><span>{TRAP <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a>}</span></p><pre><span>switch</span><span> </span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0xFF</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>case</span><span> TRAP_GETC</span><span>:</span><span>
</span><span>        {TRAP GETC, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:9">9</a>}</span><span>
        </span><span>break</span><span>;</span><span>
    </span><span>case</span><span> TRAP_OUT</span><span>:</span><span>
</span><span>        {TRAP OUT, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:9">9</a>}</span><span>
        </span><span>break</span><span>;</span><span>
    </span><span>case</span><span> TRAP_PUTS</span><span>:</span><span>
</span><span>        {TRAP PUTS, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a>}</span><span>
        </span><span>break</span><span>;</span><span>
    </span><span>case</span><span> TRAP_IN</span><span>:</span><span>
</span><span>        {TRAP IN, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:9">9</a>}</span><span>
        </span><span>break</span><span>;</span><span>
    </span><span>case</span><span> TRAP_PUTSP</span><span>:</span><span>
</span><span>        {TRAP PUTSP, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:9">9</a>}</span><span>
        </span><span>break</span><span>;</span><span>
    </span><span>case</span><span> TRAP_HALT</span><span>:</span><span>
</span><span>        {TRAP HALT, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:9">9</a>}</span><span>
        </span><span>break</span><span>;</span><span>
</span><span>}</span></pre>


<p>Used in sections <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a> and <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:15">15</a></p>
</div>
<p>As with instructions, I will show you how to implement a single trap routine and leave the rest to you.
</p>
<h3> PUTS</h3>
<p>The <code>PUTS</code> trap code is used to output a null-terminated string (similar to <code>printf</code> in C). The specification is found on page 543.
</p>
<p>To display a string, we must give the trap routine a string to display. This is done by storing the address of the first character in <code>R0</code> before beginning the trap.
</p>
<p>The specification says:
</p>
<blockquote><p> Write a string of ASCII characters to the console display. The characters are contained
 in consecutive memory locations, one character per memory location, starting with the address specified in <code>R0</code>. Writing terminates with the occurrence of <code>x0000</code> in a memory location. (Pg. 543)
</p>
</blockquote>
<p>Notice that unlike C strings, characters are <em>not stored</em> in a single byte, but in a <em>single memory location</em>. Memory locations in LC-3 are 16 bits, so each character in the string is 16 bits wide. To display this with a C function, we will need to convert each value to a char and output them individually.
</p>

<div>
<p><span>{TRAP PUTS <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a>}</span></p><pre><span>{</span><span>
    </span><span>/* one char per word */</span><span>
    </span><span>uint16_t</span><span>*</span><span> c </span><span>=</span><span> memory </span><span>+</span><span> reg</span><span>[</span><span>R_R0</span><span>];</span><span>
    </span><span>while</span><span> </span><span>(*</span><span>c</span><span>)</span><span>
    </span><span>{</span><span>
        putc</span><span>((</span><span>char</span><span>)*</span><span>c</span><span>,</span><span> stdout</span><span>);</span><span>
        </span><span>++</span><span>c</span><span>;</span><span>
    </span><span>}</span><span>
    fflush</span><span>(</span><span>stdout</span><span>);</span><span>
</span><span>}</span></pre>



</div>
<p>That's all for this routine. The trap routines are pretty straightforward if you are familiar with C. Go back to the specification and implement the others now. As with the instructions, the full code can be found at the end of the tutorial.
</p>

</div>
<a name="1:9"></a><div><a name="1:9"><h4>9. Trap Routine Cheat Sheet</h4></a>
<p>This section contains the full implementations of the remaining trap routines.
</p>
<p>Input Character
</p>

<div>
<p><span>{TRAP GETC <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:9">9</a>}</span></p><pre><span>/* read a single ASCII char */</span><span>
reg</span><span>[</span><span>R_R0</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>uint16_t</span><span>)</span><span>getchar</span><span>();</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a></p>
</div>
<p>Output Character
</p>

<div>
<p><span>{TRAP OUT <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:9">9</a>}</span></p><pre><span>putc</span><span>((</span><span>char</span><span>)</span><span>reg</span><span>[</span><span>R_R0</span><span>],</span><span> stdout</span><span>);</span><span>
fflush</span><span>(</span><span>stdout</span><span>);</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a></p>
</div>
<p>Prompt for Input Character
</p>

<div>
<p><span>{TRAP IN <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:9">9</a>}</span></p><pre><span>{</span><span>
    printf</span><span>(</span><span>"Enter a character: "</span><span>);</span><span>
    </span><span>char</span><span> c </span><span>=</span><span> getchar</span><span>();</span><span>
    putc</span><span>(</span><span>c</span><span>,</span><span> stdout</span><span>);</span><span>
    reg</span><span>[</span><span>R_R0</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>uint16_t</span><span>)</span><span>c</span><span>;</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a></p>
</div>
<p>Output String
</p>

<div>
<p><span>{TRAP PUTSP <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:9">9</a>}</span></p><pre><span>{</span><span>
    </span><span>/* one char per byte (two bytes per word)
       here we need to swap back to
       big endian format */</span><span>
    </span><span>uint16_t</span><span>*</span><span> c </span><span>=</span><span> memory </span><span>+</span><span> reg</span><span>[</span><span>R_R0</span><span>];</span><span>
    </span><span>while</span><span> </span><span>(*</span><span>c</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>char</span><span> char1 </span><span>=</span><span> </span><span>(*</span><span>c</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0xFF</span><span>;</span><span>
        putc</span><span>(</span><span>char1</span><span>,</span><span> stdout</span><span>);</span><span>
        </span><span>char</span><span> char2 </span><span>=</span><span> </span><span>(*</span><span>c</span><span>)</span><span> </span><span>&gt;&gt;</span><span> </span><span>8</span><span>;</span><span>
        </span><span>if</span><span> </span><span>(</span><span>char2</span><span>)</span><span> putc</span><span>(</span><span>char2</span><span>,</span><span> stdout</span><span>);</span><span>
        </span><span>++</span><span>c</span><span>;</span><span>
    </span><span>}</span><span>
    fflush</span><span>(</span><span>stdout</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a></p>
</div>
<p>Halt Program
</p>

<div>
<p><span>{TRAP HALT <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:9">9</a>}</span></p><pre><span>puts</span><span>(</span><span>"HALT"</span><span>);</span><span>
fflush</span><span>(</span><span>stdout</span><span>);</span><span>
running </span><span>=</span><span> </span><span>0</span><span>;</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a></p>
</div>
</div>
<a name="1:10"></a><div><a name="1:10"><h4>10. Loading Programs</h4></a>
<p>We have mentioned a lot about loading and executing instructions from memory, but how do instructions get into memory in the first place? When an assembly program is converted to machine code, the result is a file containing an array of instructions and data. This can be loaded by just copying the contents right into an address in memory.
</p>
<p>The first 16 bits of the program file specify the address in memory where the program should start. This address is called the <strong>origin</strong>. It must be read first, after which the rest of the data can be read from the file into memory starting at the origin address.
</p>
<p>Here is the code for reading an LC-3 program into memory:
</p>

<div>
<p><span>{Read Image File <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:10">10</a>}</span></p><pre><span>void</span><span> read_image_file</span><span>(</span><span>FILE</span><span>*</span><span> file</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>/* the origin tells us where in memory to place the image */</span><span>
    </span><span>uint16_t</span><span> origin</span><span>;</span><span>
    fread</span><span>(&amp;</span><span>origin</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>origin</span><span>),</span><span> </span><span>1</span><span>,</span><span> file</span><span>);</span><span>
    origin </span><span>=</span><span> swap16</span><span>(</span><span>origin</span><span>);</span><span>

    </span><span>/* we know the maximum file size so we only need one fread */</span><span>
    </span><span>uint16_t</span><span> max_read </span><span>=</span><span> UINT16_MAX </span><span>-</span><span> origin</span><span>;</span><span>
    </span><span>uint16_t</span><span>*</span><span> p </span><span>=</span><span> memory </span><span>+</span><span> origin</span><span>;</span><span>
    </span><span>size_t</span><span> read </span><span>=</span><span> fread</span><span>(</span><span>p</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>uint16_t</span><span>),</span><span> max_read</span><span>,</span><span> file</span><span>);</span><span>

    </span><span>/* swap to little endian */</span><span>
    </span><span>while</span><span> </span><span>(</span><span>read</span><span>--</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>*</span><span>p </span><span>=</span><span> swap16</span><span>(*</span><span>p</span><span>);</span><span>
        </span><span>++</span><span>p</span><span>;</span><span>
    </span><span>}</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>
<p>Notice that <code>swap16</code> is called on each loaded value. LC-3 programs are big-endian, but most of the modern computers we use are little endian. As a result, we need to swap each <code>uint16</code> that is loaded. (If you happen to be using a <a href="https://en.wikipedia.org/wiki/Power_Mac_G4_Cube">strange computer</a>, like a <a href="https://en.wikipedia.org/wiki/PowerPC#Endian_modes">PPC</a> then you should not swap.)
</p>

<div>
<p><span>{Swap <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:10">10</a>}</span></p><pre><span>uint16_t</span><span> swap16</span><span>(</span><span>uint16_t</span><span> x</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>return</span><span> </span><span>(</span><span>x </span><span>&lt;&lt;</span><span> </span><span>8</span><span>)</span><span> </span><span>|</span><span> </span><span>(</span><span>x </span><span>&gt;&gt;</span><span> </span><span>8</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>
<blockquote><p> <strong>Note:</strong> <a href="https://en.wikipedia.org/wiki/Endianness">Endianness</a> refers to how bytes of an integer are interpreted. In little-endian, the first byte is the least significant digit, and in big-endian, it is reversed. As far as I know, the decision is <em>mostly</em> arbitrary. Different companies made different decisions, so now we are left with varying implementations. You do not need to know anything else about endianness for this project.
</p>
</blockquote>
<p>Let's also add a convenience function for <code>read_image_file</code> which takes a path a string;
</p>

<div>
<p><span>{Read Image <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:10">10</a>}</span></p><pre><span>int</span><span> read_image</span><span>(</span><span>const</span><span> </span><span>char</span><span>*</span><span> image_path</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>FILE</span><span>*</span><span> file </span><span>=</span><span> fopen</span><span>(</span><span>image_path</span><span>,</span><span> </span><span>"rb"</span><span>);</span><span>
    </span><span>if</span><span> </span><span>(!</span><span>file</span><span>)</span><span> </span><span>{</span><span> </span><span>return</span><span> </span><span>0</span><span>;</span><span> </span><span>};</span><span>
    read_image_file</span><span>(</span><span>file</span><span>);</span><span>
    fclose</span><span>(</span><span>file</span><span>);</span><span>
    </span><span>return</span><span> </span><span>1</span><span>;</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>
</div>
<a name="1:11"></a><div><a name="1:11"><h4>11. Memory Mapped Registers</h4></a>
<p>Some special registers are not accessible from the normal register table. Instead, a special address is reserved for them in memory. To read and write to these registers, you just read and write to their memory location. These are called <strong>memory mapped registers</strong>. They are commonly used to interact with special hardware devices.
</p>
<p>The LC-3 has two memory mapped registers that need to be implemented. They are the keyboard status register (<code>KBSR</code>) and keyboard data register (<code>KBDR</code>). The <code>KBSR</code> indicates whether a key has been pressed, and the <code>KBDR</code> identifies which key was pressed.
</p>
<p>Although you can request keyboard input using <code>GETC</code>, this blocks execution until input is received. <code>KBSR</code> and <code>KBDR</code> allows you to <a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">poll the state</a> of the device and continue execution, so the program can stay responsive while waiting for input.
</p>

<div>
<p><span>{Memory Mapped Registers <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a>}</span></p><pre><span>enum</span><span>
</span><span>{</span><span>
    MR_KBSR </span><span>=</span><span> </span><span>0xFE00</span><span>,</span><span> </span><span>/* keyboard status */</span><span>
    MR_KBDR </span><span>=</span><span> </span><span>0xFE02</span><span>  </span><span>/* keyboard data */</span><span>
</span><span>};</span></pre>



</div>
<p>Memory mapped registers make memory access a bit more complicated. We can't read and write to the memory array directly, but must instead call setter and getter functions. When memory is read from <code>KBSR</code>, the getter will check the keyboard and update both memory locations.
</p>

<div>
<p><span>{Memory Access <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a>}</span></p><pre><span>void</span><span> mem_write</span><span>(</span><span>uint16_t</span><span> address</span><span>,</span><span> </span><span>uint16_t</span><span> val</span><span>)</span><span>
</span><span>{</span><span>
    memory</span><span>[</span><span>address</span><span>]</span><span> </span><span>=</span><span> val</span><span>;</span><span>
</span><span>}</span><span>

</span><span>uint16_t</span><span> mem_read</span><span>(</span><span>uint16_t</span><span> address</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>if</span><span> </span><span>(</span><span>address </span><span>==</span><span> MR_KBSR</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>if</span><span> </span><span>(</span><span>check_key</span><span>())</span><span>
        </span><span>{</span><span>
            memory</span><span>[</span><span>MR_KBSR</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>15</span><span>);</span><span>
            memory</span><span>[</span><span>MR_KBDR</span><span>]</span><span> </span><span>=</span><span> getchar</span><span>();</span><span>
        </span><span>}</span><span>
        </span><span>else</span><span>
        </span><span>{</span><span>
            memory</span><span>[</span><span>MR_KBSR</span><span>]</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
    </span><span>return</span><span> memory</span><span>[</span><span>address</span><span>];</span><span>
</span><span>}</span></pre>



</div>
<p>That completes the last component of the VM! Provided that you implemented the rest of the trap routines and instructions, you are almost ready to try it out!
</p>
<p>All that we have written should have been added to the C file in the following order:
</p>

<div>
<p><span>{<strong>lc3.c</strong> <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>} +=</span></p><pre><span>{Memory Mapped Registers, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a>}</span><span>
</span><span>{TRAP Codes, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a>}</span><span>

</span><span>{Memory Storage, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span><span>
</span><span>{Register Storage, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a>}</span><span>

</span><span>{Sign Extend, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span><span>
</span><span>{Swap, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:10">10</a>}</span><span>
</span><span>{Update Flags, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:6">6</a>}</span><span>
</span><span>{Read Image File, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:10">10</a>}</span><span>
</span><span>{Read Image, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:10">10</a>}</span><span>
</span><span>{Check Key, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span><span>
</span><span>{Memory Access, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a>}</span><span>
</span><span>{Input Buffering, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span><span>
</span><span>{Handle Interrupt, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span><span>

</span><span>{Main Loop, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a>}</span>
</pre>



</div>
</div>
<a name="1:12"></a><div><a name="1:12"><h4>12. Platform Specifics (Unix)</h4></a>
<p>This section contains some tedious details that are needed to access the keyboard and behave nicely.
These are not insightful or relevant to learning about VMs. Feel free to copy paste!
</p>
<p>NOTE: Skip to the next section for the <strong>Windows</strong> versions of these functions.
</p>

<div>
<p><span>{Check Key <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span></p><pre><span>uint16_t</span><span> check_key</span><span>()</span><span>
</span><span>{</span><span>
    fd_set readfds</span><span>;</span><span>
    FD_ZERO</span><span>(&amp;</span><span>readfds</span><span>);</span><span>
    FD_SET</span><span>(</span><span>STDIN_FILENO</span><span>,</span><span> </span><span>&amp;</span><span>readfds</span><span>);</span><span>

    </span><span>struct</span><span> timeval timeout</span><span>;</span><span>
    timeout</span><span>.</span><span>tv_sec </span><span>=</span><span> </span><span>0</span><span>;</span><span>
    timeout</span><span>.</span><span>tv_usec </span><span>=</span><span> </span><span>0</span><span>;</span><span>
    </span><span>return</span><span> select</span><span>(</span><span>1</span><span>,</span><span> </span><span>&amp;</span><span>readfds</span><span>,</span><span> NULL</span><span>,</span><span> NULL</span><span>,</span><span> </span><span>&amp;</span><span>timeout</span><span>)</span><span> </span><span>!=</span><span> </span><span>0</span><span>;</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>
<p>This is Unix specific code for setting up terminal input.
</p>

<div>
<p><span>{Input Buffering <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span></p><pre><span>struct</span><span> termios original_tio</span><span>;</span><span>

</span><span>void</span><span> disable_input_buffering</span><span>()</span><span>
</span><span>{</span><span>
    tcgetattr</span><span>(</span><span>STDIN_FILENO</span><span>,</span><span> </span><span>&amp;</span><span>original_tio</span><span>);</span><span>
    </span><span>struct</span><span> termios new_tio </span><span>=</span><span> original_tio</span><span>;</span><span>
    new_tio</span><span>.</span><span>c_lflag </span><span>&amp;=</span><span> </span><span>~</span><span>ICANON </span><span>&amp;</span><span> </span><span>~</span><span>ECHO</span><span>;</span><span>
    tcsetattr</span><span>(</span><span>STDIN_FILENO</span><span>,</span><span> TCSANOW</span><span>,</span><span> </span><span>&amp;</span><span>new_tio</span><span>);</span><span>
</span><span>}</span><span>

</span><span>void</span><span> restore_input_buffering</span><span>()</span><span>
</span><span>{</span><span>
    tcsetattr</span><span>(</span><span>STDIN_FILENO</span><span>,</span><span> TCSANOW</span><span>,</span><span> </span><span>&amp;</span><span>original_tio</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>

<div>
<p><span>{Handle Interrupt <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span></p><pre><span>void</span><span> handle_interrupt</span><span>(</span><span>int</span><span> signal</span><span>)</span><span>
</span><span>{</span><span>
    restore_input_buffering</span><span>();</span><span>
    printf</span><span>(</span><span>"
"</span><span>);</span><span>
    exit</span><span>(-</span><span>2</span><span>);</span><span>
</span><span>}</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:11">11</a></p>
</div>

<div>
<p><span>{Setup <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span></p><pre><span>signal</span><span>(</span><span>SIGINT</span><span>,</span><span> handle_interrupt</span><span>);</span><span>
disable_input_buffering</span><span>();</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>
<p>When the program is interrupted, we want to restore the terminal
settings back to normal.
</p>

<div>
<p><span>{Shutdown <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span></p><pre><span>restore_input_buffering</span><span>();</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:5">5</a></p>
</div>

<div>
<p><span>{Includes <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">12</a>}</span></p><pre><span>#include</span><span> </span><span>&lt;stdio.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;stdlib.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;stdint.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;string.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;signal.h&gt;</span><span>
</span><span>/* unix */</span><span>
</span><span>#include</span><span> </span><span>&lt;unistd.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;fcntl.h&gt;</span><span>

</span><span>#include</span><span> </span><span>&lt;sys/time.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;sys/types.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;sys/termios.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;sys/mman.h&gt;</span></pre>


<p>Used in section <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:3">3</a></p>
</div>
</div>
<a name="1:13"></a><div><a name="1:13"><h4>13. Platform Specifics (Windows)</h4></a>
<p>This section contains some tedious details that are needed to access the keyboard and behave nicely.
These are not insightful or relevant to learning about VMs. Feel free to copy paste!
</p>
<p>NOTE: If you already included the <strong>Unix</strong> versions don't add these!
</p>

<div>
<p><span>{Check Key Windows <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:13">13</a>}</span></p><pre><span>uint16_t</span><span> check_key</span><span>()</span><span>
</span><span>{</span><span>
    </span><span>return</span><span> </span><span>WaitForSingleObject</span><span>(</span><span>hStdin</span><span>,</span><span> </span><span>1000</span><span>)</span><span> </span><span>==</span><span> WAIT_OBJECT_0 </span><span>&amp;&amp;</span><span> _kbhit</span><span>();</span><span>
</span><span>}</span></pre>



</div>

<div>
<p><span>{Input Buffering Windows <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:13">13</a>}</span></p><pre><span>DWORD fdwMode</span><span>,</span><span> fdwOldMode</span><span>;</span><span>

</span><span>void</span><span> disable_input_buffering</span><span>()</span><span>
</span><span>{</span><span>
    hStdin </span><span>=</span><span> </span><span>GetStdHandle</span><span>(</span><span>STD_INPUT_HANDLE</span><span>);</span><span>
    </span><span>GetConsoleMode</span><span>(</span><span>hStdin</span><span>,</span><span> </span><span>&amp;</span><span>fdwOldMode</span><span>);</span><span> </span><span>/* save old mode */</span><span>
    fdwMode </span><span>=</span><span> fdwOldMode 
            </span><span>^</span><span> ENABLE_ECHO_INPUT  </span><span>/* no input echo */</span><span>
            </span><span>^</span><span> ENABLE_LINE_INPUT</span><span>;</span><span> </span><span>/* return when one or 
                                    more characters are available */</span><span>
    </span><span>SetConsoleMode</span><span>(</span><span>hStdin</span><span>,</span><span> fdwMode</span><span>);</span><span> </span><span>/* set new mode */</span><span>
    </span><span>FlushConsoleInputBuffer</span><span>(</span><span>hStdin</span><span>);</span><span> </span><span>/* clear buffer */</span><span>
</span><span>}</span><span>

</span><span>void</span><span> restore_input_buffering</span><span>()</span><span>
</span><span>{</span><span>
    </span><span>SetConsoleMode</span><span>(</span><span>hStdin</span><span>,</span><span> fdwOldMode</span><span>);</span><span>
</span><span>}</span></pre>



</div>

<div>
<p><span>{Windows Setup <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:13">13</a>}</span></p><pre><span>signal</span><span>(</span><span>SIGINT</span><span>,</span><span> handle_interrupt</span><span>);</span><span>
disable_input_buffering</span><span>();</span></pre>



</div>
<p>When the program is interrupted, we want to restore the terminal
settings back to normal.
</p>

<div>
<p><span>{Windows Shutdown <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:13">13</a>}</span></p><pre><span>restore_input_buffering</span><span>();</span></pre>



</div>

<div>
<p><span>{Windows Includes <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:13">13</a>}</span></p><pre><span>#include</span><span> </span><span>&lt;stdint.h&gt;</span><span> </span><span>// uint16_t</span><span>
</span><span>#include</span><span> </span><span>&lt;stdio.h&gt;</span><span>  </span><span>// FILE</span><span>
</span><span>#include</span><span> </span><span>&lt;signal.h&gt;</span><span> </span><span>// SIGINT</span><span>
</span><span>/* windows only */</span><span>
</span><span>#include</span><span> </span><span>&lt;Windows.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&lt;conio.h&gt;</span><span>  </span><span>// _kbhit</span><span>

HANDLE hStdin </span><span>=</span><span> INVALID_HANDLE_VALUE</span><span>;</span></pre>



</div>

</div>
<a name="1:14"></a><div><a name="1:14"><h4>14. Running the VM</h4></a>
<p>You can now build and run the LC-3 VM!
</p>
<ol>
<li><p>Compile your program] with your favorite C compiler.
   (Final source for <a href="https://justinmeiners.github.io/lc3-vm/src/lc3.c">unix</a>, <a href="https://justinmeiners.github.io/lc3-vm/src/lc3-win.c">windows</a>).
</p>
<p>For gcc: <code>$ gcc lc3.c -o lc3</code>
</p>
</li>
<li><p>Download the assembled version of <a href="https://justinmeiners.github.io/lc3-vm/supplies/2048.obj">2048</a> or <a href="https://justinmeiners.github.io/lc3-vm/supplies/rogue.obj">Rogue</a>.
</p>
</li>
<li><p>Run the program with the obj file as an argument:
</p>
<p><code>$ lc3-vm path/to/2048.obj</code>
</p>
</li>
<li><p>Play 2048!
</p>
</li>
</ol>

<div>
<p><span>{2048 Example <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:14">14</a>}</span></p><pre><span>Control</span><span> the game </span><span>using</span><span> WASD keys</span><span>.</span><span>
</span><span>Are</span><span> you on an ANSI terminal </span><span>(</span><span>y</span><span>/</span><span>n</span><span>)?</span><span> y
</span><span>+--------------------------+</span><span>
</span><span>|</span><span>                          </span><span>|</span><span>
</span><span>|</span><span>                          </span><span>|</span><span>
</span><span>|</span><span>                          </span><span>|</span><span>
</span><span>|</span><span>                     </span><span>2</span><span>    </span><span>|</span><span>
</span><span>|</span><span>                          </span><span>|</span><span>
</span><span>|</span><span>   </span><span>2</span><span>                      </span><span>|</span><span>
</span><span>|</span><span>                          </span><span>|</span><span>
</span><span>|</span><span>                          </span><span>|</span><span>
</span><span>|</span><span>                          </span><span>|</span><span>
</span><span>+--------------------------+</span></pre>



</div>
<h3> Debugging</h3>
<p>If the program doesn't work correctly, it is likely because you programmed an instruction incorrectly. This can be tricky to debug. I recommend reading through the assembly source code of an LC-3 program while simultaneously using a debugger to step through the VM instructions one at a time. As you read the assembly, make sure the VM goes to the instruction that you expect it to. If a discrepancy occurs, you will then know which instruction caused the issue. Reread its specification and double check your code.
</p>

</div>
<a name="1:15"></a><div><a name="1:15"><h4>15. Alternate C++ Technique</h4></a>
<p>This section shows an advanced way of executing instructions that makes the code a whole lot smaller. This section is entirely optional.
</p>
<p>Since C++ has powerful compile-time generics, we can use the compiler to generate parts of the instructions for us. This method reduces code duplication and is actually closer to how the computer would be wired in hardware.
</p>
<p>The idea here is to reuse the steps common to each instruction. For example, several of the instructions use indirect addressing or sign extend a value and add it to the current PC value. Wouldn't it be nice if we could write this code once for all instructions?
</p>
<p>By thinking of the instruction as a pipeline of steps we can see that each instruction is just a permutation of several of the smaller steps. We will use bitwise flags to mark which steps to perform for each instruction. A <code>1</code> in the bit corresponding to the instruction number indicates the compiler should include this section of code for that instruction.
</p>

<div>
<p><span>{Instruction C++ <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:15">15</a>}</span></p><pre><span>template</span><span> </span><span>&lt;</span><span>unsigned</span><span> op</span><span>&gt;</span><span>
</span><span>void</span><span> ins</span><span>(</span><span>uint16_t</span><span> instr</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>uint16_t</span><span> r0</span><span>,</span><span> r1</span><span>,</span><span> r2</span><span>,</span><span> imm5</span><span>,</span><span> imm_flag</span><span>;</span><span>
    </span><span>uint16_t</span><span> pc_plus_off</span><span>,</span><span> base_plus_off</span><span>;</span><span>

    </span><span>constexpr</span><span> </span><span>uint16_t</span><span> opbit </span><span>=</span><span> </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> op</span><span>);</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x4EEE</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> r0 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span> </span><span>}</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x12F3</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> r1 </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>6</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span> </span><span>}</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0022</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span>
    </span><span>{</span><span>
        imm_flag </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>5</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x1</span><span>;</span><span>

        </span><span>if</span><span> </span><span>(</span><span>imm_flag</span><span>)</span><span>
        </span><span>{</span><span>
            imm5 </span><span>=</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x1F</span><span>,</span><span> </span><span>5</span><span>);</span><span>
        </span><span>}</span><span>
        </span><span>else</span><span>
        </span><span>{</span><span>
            r2 </span><span>=</span><span> instr </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x00C0</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span>
    </span><span>{</span><span>   </span><span>// Base + offset</span><span>
        base_plus_off </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>+</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x3F</span><span>,</span><span> </span><span>6</span><span>);</span><span>
    </span><span>}</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x4C0D</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>// Indirect address</span><span>
        pc_plus_off </span><span>=</span><span> reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>+</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x1FF</span><span>,</span><span> </span><span>9</span><span>);</span><span>
    </span><span>}</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0001</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>// BR</span><span>
        </span><span>uint16_t</span><span> cond </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>9</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x7</span><span>;</span><span>
        </span><span>if</span><span> </span><span>(</span><span>cond </span><span>&amp;</span><span> reg</span><span>[</span><span>R_COND</span><span>])</span><span> </span><span>{</span><span> reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>=</span><span> pc_plus_off</span><span>;</span><span> </span><span>}</span><span>
    </span><span>}</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0002</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span>  </span><span>// ADD</span><span>
    </span><span>{</span><span>
        </span><span>if</span><span> </span><span>(</span><span>imm_flag</span><span>)</span><span>
        </span><span>{</span><span>
            reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>+</span><span> imm5</span><span>;</span><span>
        </span><span>}</span><span>
        </span><span>else</span><span>
        </span><span>{</span><span>
            reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>+</span><span> reg</span><span>[</span><span>r2</span><span>];</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0020</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span>  </span><span>// AND</span><span>
    </span><span>{</span><span>
        </span><span>if</span><span> </span><span>(</span><span>imm_flag</span><span>)</span><span>
        </span><span>{</span><span>
            reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>&amp;</span><span> imm5</span><span>;</span><span>
        </span><span>}</span><span>
        </span><span>else</span><span>
        </span><span>{</span><span>
            reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>]</span><span> </span><span>&amp;</span><span> reg</span><span>[</span><span>r2</span><span>];</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0200</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> </span><span>~</span><span>reg</span><span>[</span><span>r1</span><span>];</span><span> </span><span>}</span><span> </span><span>// NOT</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x1000</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>];</span><span> </span><span>}</span><span> </span><span>// JMP</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0010</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span>  </span><span>// JSR</span><span>
    </span><span>{</span><span>
        </span><span>uint16_t</span><span> long_flag </span><span>=</span><span> </span><span>(</span><span>instr </span><span>&gt;&gt;</span><span> </span><span>11</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>1</span><span>;</span><span>
        reg</span><span>[</span><span>R_R7</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>R_PC</span><span>];</span><span>
        </span><span>if</span><span> </span><span>(</span><span>long_flag</span><span>)</span><span>
        </span><span>{</span><span>
            pc_plus_off </span><span>=</span><span> reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>+</span><span> sign_extend</span><span>(</span><span>instr </span><span>&amp;</span><span> </span><span>0x7FF</span><span>,</span><span> </span><span>11</span><span>);</span><span>
            reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>=</span><span> pc_plus_off</span><span>;</span><span>
        </span><span>}</span><span>
        </span><span>else</span><span>
        </span><span>{</span><span>
            reg</span><span>[</span><span>R_PC</span><span>]</span><span> </span><span>=</span><span> reg</span><span>[</span><span>r1</span><span>];</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>if</span><span> </span><span>(</span><span>0x0004</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> mem_read</span><span>(</span><span>pc_plus_off</span><span>);</span><span> </span><span>}</span><span> </span><span>// LD</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0400</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> mem_read</span><span>(</span><span>mem_read</span><span>(</span><span>pc_plus_off</span><span>));</span><span> </span><span>}</span><span> </span><span>// LDI</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0040</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> mem_read</span><span>(</span><span>base_plus_off</span><span>);</span><span> </span><span>}</span><span>  </span><span>// LDR</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x4000</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> reg</span><span>[</span><span>r0</span><span>]</span><span> </span><span>=</span><span> pc_plus_off</span><span>;</span><span> </span><span>}</span><span> </span><span>// LEA</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0008</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> mem_write</span><span>(</span><span>pc_plus_off</span><span>,</span><span> reg</span><span>[</span><span>r0</span><span>]);</span><span> </span><span>}</span><span> </span><span>// ST</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0800</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> mem_write</span><span>(</span><span>mem_read</span><span>(</span><span>pc_plus_off</span><span>),</span><span> reg</span><span>[</span><span>r0</span><span>]);</span><span> </span><span>}</span><span> </span><span>// STI</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x0080</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> mem_write</span><span>(</span><span>base_plus_off</span><span>,</span><span> reg</span><span>[</span><span>r0</span><span>]);</span><span> </span><span>}</span><span> </span><span>// STR</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x8000</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span>  </span><span>// TRAP</span><span>
    </span><span>{</span><span>
</span><span>         {TRAP, <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:8">8</a>}</span><span>
    </span><span>}</span><span>
    </span><span>//if (0x0100 &amp; opbit) { } // RTI</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0x4666</span><span> </span><span>&amp;</span><span> opbit</span><span>)</span><span> </span><span>{</span><span> update_flags</span><span>(</span><span>r0</span><span>);</span><span> </span><span>}</span><span>
</span><span>}</span></pre>



</div>

<div>
<p><span>{Op Table <a href="https://justinmeiners.github.io/lc3-vm/index.html#1:15">15</a>}</span></p><pre><span>static</span><span> </span><span>void</span><span> </span><span>(*</span><span>op_table</span><span>[</span><span>16</span><span>])(</span><span>uint16_t</span><span>)</span><span> </span><span>=</span><span> </span><span>{</span><span>
    ins</span><span>&lt;</span><span>0</span><span>&gt;,</span><span> ins</span><span>&lt;</span><span>1</span><span>&gt;,</span><span> ins</span><span>&lt;</span><span>2</span><span>&gt;,</span><span> ins</span><span>&lt;</span><span>3</span><span>&gt;,</span><span>
    ins</span><span>&lt;</span><span>4</span><span>&gt;,</span><span> ins</span><span>&lt;</span><span>5</span><span>&gt;,</span><span> ins</span><span>&lt;</span><span>6</span><span>&gt;,</span><span> ins</span><span>&lt;</span><span>7</span><span>&gt;,</span><span>
    NULL</span><span>,</span><span> ins</span><span>&lt;</span><span>9</span><span>&gt;,</span><span> ins</span><span>&lt;</span><span>10</span><span>&gt;,</span><span> ins</span><span>&lt;</span><span>11</span><span>&gt;,</span><span>
    ins</span><span>&lt;</span><span>12</span><span>&gt;,</span><span> NULL</span><span>,</span><span> ins</span><span>&lt;</span><span>14</span><span>&gt;,</span><span> ins</span><span>&lt;</span><span>15</span><span>&gt;</span><span>
</span><span>};</span></pre>



</div>
<blockquote><p> <strong>Note:</strong> I learned about this technique from <a href="https://www.youtube.com/watch?v=QIUVSD3yqqE">Bisqwit's NES emulator</a>.
 If you are interested in emulation, or the NES, I highly recommend his videos.
</p>
</blockquote>
<p>The rest of the C++ version uses the code we already wrote!
The full source is here: <a href="https://justinmeiners.github.io/lc3-vm/src/lc3-alt.cpp">unix</a>, <a href="https://justinmeiners.github.io/lc3-vm/src/lc3-alt-win.cpp">windows</a>.
</p>


</div>
<a name="1:16"></a><div><a name="1:16"><h4>16. Related Projects</h4></a>
<p>Many programmers have reached out to share their own VMs created with this tutorial.
These projects may be helpful for learners who are familiar with programming languages other than C.
Feel free to fork this <a href="https://github.com/justinmeiners/lc3-vm">repo</a> and contribute your own.
</p>
<p><strong>Windows</strong>
</p>
<ul>
<li><p>Special thanks to <a href="https://github.com/inkydragon">inkydragon</a> for contributing Windows platform support.
</p>
</li>
</ul>
<p><strong>C</strong>
</p>
<ul>
<li><a href="https://github.com/andyjung-dev/LC3-VM-Extended">andyjung-dev</a> extends the tutorial implementation with a few features.
</li>
<li><a href="https://github.com/rpendleton/lc3sim-c">rpendleton</a> uses assembly implementation of TRAP codes.
</li>
<li><a href="https://github.com/viking/lc3-vm">viking</a> well commented and adds tests.
</li>
</ul>
<p><strong>C++</strong>
</p>
<ul>
<li><a href="https://github.com/daniMaarouf/lc3-vm">daniMaarouf</a> Python based debugger.
</li>
<li><a href="https://github.com/jsawruk/lc3-vm">jsawruk</a> alternative C and C++ implementation.
</li>
</ul>
<p><strong>Common Lisp</strong>
</p>
<ul>
<li><p><a href="https://github.com/resttime/lc3">resttime</a> first Common Lisp implementation.
</p>
</li>
</ul>
<p><strong>Crystal</strong>
</p>
<ul>
<li><p><a href="https://github.com/andraantariksa/lc3-vm.cr">andraantariksa</a> first Crystal implementation.
</p>
</li>
</ul>
<p><strong>F#</strong>
</p>
<ul>
<li><p><a href="https://github.com/yurisliepins/lc3-vm">yurisliepins</a> first F# implementation.
</p>
</li>
</ul>
<p><strong>Go</strong>
</p>
<ul>
<li><a href="https://github.com/robmorgan/go-lc3-vm">robmorgan</a> alternative Go implementation.
</li>
<li><a href="https://github.com/ziggy42/gLC3">ziggy42</a> first Go implementation.
</li>
</ul>
<p><strong>Haskell</strong>
</p>
<ul>
<li><a href="https://github.com/dmjio/LC3">dmjio</a> first Haskell implementation.
</li>
<li><a href="https://github.com/cleverca22/LC3">cleverca22</a> alternative Haskell implementation.
</li>
</ul>
<p><strong>JavaScript</strong>
</p>
<ul>
<li><p><a href="https://github.com/rpendleton/lc3sim-js">rpendleton</a> first JavaScript implementation. Works in the browser.
</p>
</li>
</ul>
<p><strong>Python</strong>
</p>
<ul>
<li><a href="https://github.com/Bl41r/lc-3-virtual-machine">Bl41r</a> first Python implementation.
</li>
<li><a href="https://github.com/ianklatzco/lc3">ianklatzco</a> Python implementation. includes a disassembler.
</li>
<li><a href="https://github.com/paul-nameless/lc3-vm">paulnameless</a> alternative Python implementation.
</li>
<li><a href="https://github.com/mhashim6/LC-3">mhashim6</a> modular Python implementation.
</li>
</ul>
<p><strong>Racket</strong>
</p>
<ul>
<li><p><a href="https://github.com/whichxjy/LC3-VM-Racket">whichxjy</a> first Racket implementation.
</p>
</li>
</ul>
<p><strong>Rust</strong>
</p>
<ul>
<li><a href="https://github.com/erfur/lc3-vm-rust">erfur</a> alternative Rust implementation.
</li>
<li><a href="https://github.com/KuldeepSinh/lc3_vm">KuldeepSinh</a> first Rust implementation.
</li>
<li><a href="https://github.com/twe4ked/rs-lc3">twe4ked</a> includes debugging features.
</li>
</ul>
<p><strong>Swift</strong>
</p>
<ul>
<li><p><a href="https://github.com/hashemi/lc3-swift">hashemi</a> first Swift implementation.
</p>
</li>
</ul>
<p><strong>TypeScript</strong>
</p>
<ul>
<li><p><a href="https://github.com/mrhampson/lc3-typescript-vm">mrhampson</a> first TypeScript implementation. Node.js only.
</p>
</li>
</ul>

</div>

</section></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>