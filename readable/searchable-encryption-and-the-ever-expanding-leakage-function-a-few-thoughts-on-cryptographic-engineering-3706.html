<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Attack of the week: searchable encryption and the ever-expanding leakage function - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Attack of the week: searchable encryption and the ever-expanding leakage function - linksfor.dev(s)"/>
    <meta property="article:author" content="Matthew Green"/>
    <meta property="og:description" content="A few days ago I had the pleasure of hosting Kenny Paterson, who braved snow and historic cold (by Baltimore standards) to come talk to us about encrypted databases. Kenny&#x2019;s newest result is &#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.cryptographyengineering.com/2019/02/11/attack-of-the-week-searchable-encryption-and-the-ever-expanding-leakage-function/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Attack of the week: searchable encryption and the ever-expanding leakage function</title>
<div class="readable">
        <h1>Attack of the week: searchable encryption and the ever-expanding leakage function</h1>
            <div>by Matthew Green</div>
            <div>Reading time: 23-29 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://blog.cryptographyengineering.com/2019/02/11/attack-of-the-week-searchable-encryption-and-the-ever-expanding-leakage-function/">https://blog.cryptographyengineering.com/2019/02/11/attack-of-the-week-searchable-encryption-and-the-ever-expanding-leakage-function/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
		<p>A few days ago I had the pleasure of hosting Kenny Paterson, who braved snow and historic cold (by Baltimore standards) to come talk to us about encrypted databases.</p>
<p>Kenny‚Äôs newest result is with first authors <a href="https://eprint.iacr.org/2019/011.pdf">Paul Grubbs, Marie-Sarah Lacharit√© and Brice Minaud</a>&nbsp;(let‚Äôs call it GLMP). It isn‚Äôt so much about&nbsp;<em>building</em> encrypted databases, as it is about the risks of building them&nbsp;<em>badly.</em> And ‚Äî for reasons I will get into shortly ‚Äî there have been a lot of badly-constructed encrypted database schemes going around. What GLMP&nbsp;point out is that this weakness isn‚Äôt so much a knock against the authors of those schemes, but rather, an indication that they may just be trying to do the impossible.</p>
<p>Hopefully this is a good enough start to get you drawn in. Which is excellent, because I‚Äôm going to need to give you a lot of background.</p>
<h3>What‚Äôs an ‚Äúencrypted‚Äù database, and why are they a problem?</h3>
<p>Databases (both relational and otherwise) are a pretty important part of the computing experience. Modern systems make vast use of databases and their accompanying query technology in order to power just about every software application we depend on.</p>
<p>Because these databases often contain sensitive information, there has been a strong push to&nbsp;<em>secure</em> that data. A key goal is to encrypt the contents of the database, so that a malicious database operator (or a hacker) can‚Äôt get access to it if they compromise a single machine. If we lived in a world where security <em>was all that mattered</em>, the encryption part would be pretty easy: database records are, after all, just blobs of data ‚Äî and we know how to encrypt those. So we could generate a cryptographic key on our local machine, encrypt the data before we upload it to a vulnerable database server, and just keep that key locally on our client computer.</p>
<p>Voila: we‚Äôre safe against a database hack!</p>
<p>The problem with this approach is that encrypting the database records leaves us with a database full of opaque, unreadable encrypted junk. Since we have the decryption key on our client, we can decrypt and read those records after we‚Äôve downloaded them. But this approach completely disables one of the most useful features of modern databases: the ability for the database server itself to search (or&nbsp;<em>query</em>) the database for specific records, so that the client doesn‚Äôt have to.</p>
<p>Unfortunately, standard encryption borks search capability pretty badly. If I want to search a database for, say, employees whose salary is between $50,000 and $100,000, my database is helpless: all it sees is row after row of encrypted gibberish. In the worst case, the client will have to download&nbsp;<em>all</em> of the data rows and search them itself ‚Äî yuck.</p>
<p>This has led to much wailing and gnashing of teeth in the database community. As a result, many cryptographers (and a distressing number of&nbsp;<em>non-cryptographers</em>) have tried to fix the problem with ‚Äúfancier‚Äù crypto. This has not gone very well.</p>
<p>It would take me a hundred years to detail all of various solutions that have been put forward. But let me just hit a few of the high points:</p>
<ul>
<li>Some proposals have suggested using&nbsp;<a href="https://en.wikipedia.org/wiki/Deterministic_encryption">deterministic encryption</a> to encrypt database records. Deterministic encryption ensures that a given plaintext will <em>always</em> encrypt to a single ciphertext value, at least for a given key.&nbsp;This enables exact-match queries: a client can simply encrypt the exact value (‚ÄúJohn Smith‚Äù) that it‚Äôs searching for, and ask the database to identify encrypted rows that match it.</li>
<li>Of course, exact-match queries don‚Äôt support more powerful features. Most databases also need to support&nbsp;<a href="https://en.wikipedia.org/wiki/Range_query_(database)">range queries</a>. One approach to this is something called&nbsp;<a href="https://crypto.stanford.edu/ore/">order revealing encryption</a> (or its weaker sibling,&nbsp;<a href="https://eprint.iacr.org/2012/624.pdf">order preserving encryption</a>). These do exactly what they say they do: they allow the database to compare two encrypted records to determine which plaintext is greater than the other.</li>
<li>Some people have proposed to use trusted hardware to solve these problems in a ‚Äúsimpler‚Äù way, but as we like to say in cryptography: <em>if we actually had trusted hardware, nobody would pay our salaries. </em>And, speaking more seriously, even hardware might not stop the leakage-based attacks discussed below.</li>
</ul>
<p>This summary barely scratches the surface of this problem, and frankly you don‚Äôt need to know all the details for the purpose of this blog post.</p>
<p>What you&nbsp;<em>do</em> need to know is that each of the above proposals entails has some degree of ‚Äúleakage‚Äù. Namely, if I‚Äôm an attacker who is able to compromise the database, both to see its contents&nbsp;<em>and</em> to see how it responds when you (a legitimate user) makes a query, then I can learn&nbsp;<em>something</em> about the data being queried.</p>
<h3>What some examples of leakage, and what‚Äôs a leakage function?</h3>
<p>Leakage is a (nearly) unavoidable byproduct of an encrypted database that supports queries. It can happen when the attacker simply&nbsp;<em>looks</em> at the encrypted data, as she might if she was able to dump the contents of your database and post them on the dark web. But a more powerful type of leakage occurs&nbsp;when the attacker is able to <em>compromise</em> your database server and observe the query interaction between legitimate client(s) and your database.</p>
<p>Take deterministic encryption, for instance.</p>
<p>Deterministic encryption has the very useful, but also unpleasant feature that the same plaintext&nbsp;<em>will always</em> encrypt to the same ciphertext. This leads to very obvious types of leakage, in the sense that an attacker can see repeated records in the dataset itself. Extending this to the active setting, if a legitimate client queries on a specific encrypted value, the attacker can see exactly which records&nbsp;<em>match</em> the attacker‚Äôs encrypted value. She can see how often each value occurs, which gives and indication of what value it might be <em>(e.g.,</em>&nbsp;the last name ‚ÄúSmith‚Äù is more common than ‚ÄúAzriel‚Äù.) All of these vectors leak valuable information to an attacker.</p>
<p>Other systems leak more.&nbsp;<a href="https://eprint.iacr.org/2012/624.pdf">Order-preserving encryption</a> leaks the <em>exact order</em> of a list of underlying records, because it causes the resulting ciphertexts to have the same order. This is great for searching and sorting, but unfortunately it leaks tons of useful information to an attacker. Indeed, researchers have shown that, in real datasets, an ordering can be combined with knowledge about the record distribution in order to (approximately)&nbsp;<a href="https://eprint.iacr.org/2016/895.pdf">reconstruct the contents of an encrypted database</a>.</p>
<p>Fancier&nbsp;<a href="https://crypto.stanford.edu/ore/">order-revealing encryption</a>&nbsp;schemes aren‚Äôt quite so careless with your confidentiality: they enable the legitimate client to perform range queries, but without leaking the full ordering so trivially. This approach can leak<em>&nbsp;less</em>&nbsp;information: but a persistent attacker will still learn some data from observing a query and its response ‚Äî at a minimum, she will learn which rows constitute the response to a query, since the database must pack up the matching records and send them over to the client.</p>
<p>If you‚Äôre having trouble visualizing what this last type of leakage might look like, here‚Äôs a picture that shows what an attacker might see when a user queries an unencrypted database vs. what the attacker might see with a really ‚Äúgood‚Äù encrypted database that supports range queries:</p>
<p><img data-attachment-id="5039" data-permalink="https://blog.cryptographyengineering.com/2019/02/11/attack-of-the-week-searchable-encryption-and-the-ever-expanding-leakage-function/leakage/" data-orig-file="https://matthewdgreen.files.wordpress.com/2019/02/leakage.png" data-orig-size="563,455" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="leakage" data-image-description="" data-medium-file="https://matthewdgreen.files.wordpress.com/2019/02/leakage.png?w=300" data-large-file="https://matthewdgreen.files.wordpress.com/2019/02/leakage.png?w=563" src="https://matthewdgreen.files.wordpress.com/2019/02/leakage.png?w=700" alt="leakage" srcset="https://matthewdgreen.files.wordpress.com/2019/02/leakage.png 563w, https://matthewdgreen.files.wordpress.com/2019/02/leakage.png?w=150 150w, https://matthewdgreen.files.wordpress.com/2019/02/leakage.png?w=300 300w" sizes="(max-width: 563px) 100vw, 563px"></p>
<p>So the TL;DR here is that many encrypted database schemes have some sort of ‚Äúleakage‚Äù, and this leakage can potentially reveal information about (a) what a client is querying on, and (b) what data is in the actual database.</p>
<h3>But surely cryptographers don‚Äôt build leaky schemes?</h3>
<p>Sometimes the perfect is the enemy of the good.</p>
<p>Cryptographers could spend a million years stressing themselves to death over the practical impact of different types of leakage. They could also try to do things perfectly using expensive techniques like <a href="https://blog.cryptographyengineering.com/2012/01/02/very-casual-introduction-to-fully/">fully-homomorphic encryption</a>&nbsp;and <a href="https://en.wikipedia.org/wiki/Oblivious_ram">oblivious RAM</a> ‚Äî but the results would be highly inefficient. So a common view in the field is researchers should<em>&nbsp;do the very best we can</em>, and then carefully explain to users what the risks are.</p>
<p>For example, a real database system might provide the following guarantee:</p>
<blockquote><p>‚ÄúRecords are opaque. If the user queries for all records BETWEEN some hidden values&nbsp;<strong>X</strong> AND&nbsp;<strong>Y</strong> then all the database will learn is&nbsp;the <span>row numbers of the records that match this range</span>, and <span>nothing else</span>.‚Äù</p></blockquote>
<p>This is a pretty awesome guarantee, particularly if you can formalize it and <em>prove</em> that a scheme achieves it. And indeed, this is something that researchers have tried to do. The formalized description is typically achieved by defining something called a&nbsp;<em>leakage function. </em>It might not be possible to prove that a scheme is absolutely private, but we can prove that it only leaks as much as the leakage function allows.</p>
<p>Now, I may be overdoing this slightly, but I want to be very clear about this next part:</p>
<p>Proving your encrypted database protocol is secure&nbsp;with respect to a specific leakage function&nbsp;<em>does not mean it is safe to use in practice</em>. What it means is that you are punting <em>that question</em>&nbsp;<em>to the application developer</em>, who is presumed to know how this leakage will affect their dataset and their security needs. Your leakage function and proof simply tell the app developer what information your scheme is (provably) going to protect, and what it won‚Äôt.</p>
<p>The obvious problem with this approach is that application developers probably don‚Äôt have any idea what‚Äôs safe to use either. Helping them to figure this out is one goal of this new GLMP&nbsp;paper and its related work.</p>
<h3>So what leaks from these schemes?</h3>
<p>GLMP don‚Äôt look at a specific encryption scheme. Rather, they ask a more general question: let‚Äôs imagine that we can only see that a legitimate user has made a range query ‚Äî but <em>not</em> what the actual queried range values are. Further, let‚Äôs assume we can also see which records the database returns for that query, but not their actual values.</p>
<p><em>How much does just this information tell us about the contents of the database?</em></p>
<p>You can see that this is a very limited amount of leakage. Indeed, it is possibly the least amount of leakage you could imagine for any system that supports range queries, and is also efficient. So in one sense, you could say authors are asking a different and much more important question: <em>are any of these encrypted databases actually secure?</em></p>
<p>The answer is somewhat worrying.</p>
<h3>Can you give me a simple, illuminating example?</h3>
<p>Let‚Äôs say I‚Äôm an attacker who has compromised a database, and observes the following two range queries/results from a legitimate client:</p>
<p><strong>Query 1:</strong> SELECT * FROM Salaries BETWEEN ‚öôÔ∏è and üïπ&nbsp; &nbsp; <strong>Result 1:</strong> (rows 1, 3, 5)<br>
<strong>Query 2:</strong> SELECT * FROM Salaries BETWEEN üò® and üé±&nbsp; &nbsp; <strong>Result 2:&nbsp;</strong>(rows 1, 43, 3, 5)</p>
<p>Here I‚Äôm using the emoji to illustrate that an attacker can‚Äôt see the actual values submitted within the range queries ‚Äî those are protected by the scheme ‚Äî nor can she see the <em>actual values</em> of the result rows, since the fancy encryption scheme hides all this stuff. All the attacker sees is that a range query came in, and some specific rows were scooped up off disk after running the fancy search protocol.</p>
<p>So what can the attacker learn from the above queries? Surprisingly: quite a bit.</p>
<p>At very minimum, the attacker learns that Query 2 returned <em>all of the same records as Query 1.&nbsp;</em>Thus the range of the latter query clearly somewhat overlaps with the range of the former.&nbsp; There is an additional record (row 43) that is not within the range of Query 1. That tells us that row 43 must must be either the ‚Äúnext‚Äù greater or smaller record than each of rows (1, 3, 5). That‚Äôs useful information.</p>
<p>Get enough useful information, it turns out that it starts to add up. In 2016,&nbsp;<a href="https://scholar.harvard.edu/files/gkellaris/files/genericattacks.pdf">Kellaris, Kollios, Nissim and O‚ÄôNeill</a>&nbsp;showed that if you know the <em>distribution of the query range endpoints</em> ‚Äî for example, if you assumed that they were uniformly random ‚Äî then you can get more than just the order of records. You can reconstruct the&nbsp;<em>exact value of every record in the database.</em></p>
<p>This result is statistical in nature. If I know that the queries are uniformly random, then I can model how often a given value (say, Age=34 out of a range 1-120) should be responsive to a given random query results. By counting the actual occurrences of a specific row after many such queries, I can guess which rows correlate to specific record values. The more queries I see, the more certain I can be.The Kellaris&nbsp;<em>et al.</em> paper shows that this takes&nbsp;<img src="https://s0.wp.com/latex.php?latex=O%28N%5E4%7Elog%7EN%29&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="O(N^4~log~N)" title="O(N^4~log~N)"> queries, where <em>N&nbsp;</em>is the number of possible values your data can take on (e.g., the ages of your employees, ranging between 1 and 100 would give N=100.) This is assuming an arbitrary dataset. The results get much better&nbsp;if the database is ‚Äúdense‚Äù, meaning every possible value occurs once.</p>
<p>In practice the Kellaris&nbsp;<em>et al.</em> results mean that database fields with small domains (like ages) could be quickly reconstructed after observing a reasonable number of queries from a legitimate user, albeit one who likes to query everything randomly.</p>
<p>So that‚Äôs really bad!</p>
<p>The main bright spot in this research ‚Äî- at least up until recently ‚Äî was that&nbsp;many types of data have&nbsp;<em>much larger</em> domains. If you‚Äôre dealing with salary data ranging from, say, $1 to $200,000, then N=200,000 and this dominant <img src="https://s0.wp.com/latex.php?latex=N%5E4&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="N^4" title="N^4"> tends to make Kellaris&nbsp;<em>et al.</em> attacks impractical, simply because they‚Äôll take too long. Similarly, data like employee last names (encoded as a form that can be sorted and range-queries) gives you even vaster domains like <img src="https://s0.wp.com/latex.php?latex=N%3D26%5E%7B12%7D&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="N=26^{12}" title="N=26^{12}">, say, and so perhaps we could pleasantly ignore these results and spend our time on more amusing engagements.</p>
<h3>I bet we can‚Äôt ignore these results, can we?</h3>
<p>Indeed, it seems that we can‚Äôt. The reason we can‚Äôt sit on our laurels and hope for an attacker to die of old age recovering large-domain data sets is due to something called <em><a href="https://www.google.com/search?q=improved+reconstruction+attacks+on+encrypted+data+using+range+query+leakage&amp;oq=Improved+reconstruction+attacks+on+encrypted+data+using+range+query+leakage&amp;aqs=chrome.0.0.298j0j7&amp;sourceid=chrome&amp;ie=UTF-8">approximate database reconstruction</a>, </em>or <img src="https://s0.wp.com/latex.php?latex=%5Cepsilon-&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="\epsilon-" title="\epsilon-">ADR.</p>
<p>The setting here is the same: an attacker sits and watches an attacker make (uniformly random) range queries. The critical difference is that <em>this</em> attacker isn‚Äôt trying to get every database record back at its exact value: she‚Äôs willing to tolerate some degree of error, up to an additive <img src="https://s0.wp.com/latex.php?latex=%5Cepsilon+N&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="\epsilon N" title="\epsilon N">. For example, if I‚Äôm trying to recover employee salaries, I don‚Äôt need them to be exact: getting them within 1% or 5% is probably good enough for my purposes. Similarly, reconstructing&nbsp;<em>nearly all</em> of the letters in your last name probably lets me guess the rest, especially if I know the distribution of common last names.</p>
<p>Which <em>finally</em> brings us to this new GLMP&nbsp;<a href="https://eprint.iacr.org/2019/011.pdf">paper</a>, which puts <img src="https://s0.wp.com/latex.php?latex=%5Cepsilon-&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="\epsilon-" title="\epsilon-">ADR on steroids. What it shows is that the same setting, if one is willing to ‚Äúsacrifice‚Äù a few of the highest and lowest values in the database, an attacker can reconstruct nearly the full database in a much smaller (asymptotic) number of queries, specifically: <img src="https://s0.wp.com/latex.php?latex=O%28%5Cepsilon%5E%7B-2%7D+log%7E%5Cepsilon%5E%7B-1%7D%29&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="O(\epsilon^{-2} log~\epsilon^{-1})" title="O(\epsilon^{-2} log~\epsilon^{-1})"> queries, where <img src="https://s0.wp.com/latex.php?latex=%5Cepsilon&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="\epsilon" title="\epsilon"> is the error parameter.</p>
<p>The important thing to notice about these results is that the value&nbsp;<em>N</em> has dropped out of the equation. The only term that‚Äôs left is the&nbsp;<em>error term&nbsp;</em><img src="https://s0.wp.com/latex.php?latex=%5Cepsilon&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="\epsilon" title="\epsilon">. That means these results are ‚Äúscale-free‚Äù, and (asymptotically, at least), they work just as well for small values of&nbsp;<em>N</em> as large ones, and large databases and small ones. This is really remarkable.</p>
<h3>Big-O notation doesn‚Äôt do anything for me: what does this even mean?</h3>
<p>Big-O notation is beloved by computer scientists, but potentially meaningless in practice. There could be huge constants in these terms that render these attacks completely impractical. Besides, weird equations involving epsilon characters are impossible for humans to understand.</p>
<p>Sometimes the easiest way to understand a theoretical result is to plug some actual numbers in and see what happens. GLMP were kind enough to do this for us, by first generating several random databases ‚Äî each containing 1,000 records, for different values of&nbsp;<em>N</em>.&nbsp;They then ran their recovery algorithm against a simulated batch of random range queries to see what the actual error rate looked like as the query count increased.</p>
<p>Here are their results:</p>
<figure data-shortcode="caption" id="attachment_5041" aria-describedby="caption-attachment-5041"><img data-attachment-id="5041" data-permalink="https://blog.cryptographyengineering.com/2019/02/11/attack-of-the-week-searchable-encryption-and-the-ever-expanding-leakage-function/glmpgraph-2/" data-orig-file="https://matthewdgreen.files.wordpress.com/2019/02/glmpgraph-1.png" data-orig-size="922,588" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="GLMPgraph" data-image-description="" data-medium-file="https://matthewdgreen.files.wordpress.com/2019/02/glmpgraph-1.png?w=300" data-large-file="https://matthewdgreen.files.wordpress.com/2019/02/glmpgraph-1.png?w=700" src="https://matthewdgreen.files.wordpress.com/2019/02/glmpgraph-1.png?w=700" alt="GLMPgraph" srcset="https://matthewdgreen.files.wordpress.com/2019/02/glmpgraph-1.png?w=700 700w, https://matthewdgreen.files.wordpress.com/2019/02/glmpgraph-1.png?w=150 150w, https://matthewdgreen.files.wordpress.com/2019/02/glmpgraph-1.png?w=300 300w, https://matthewdgreen.files.wordpress.com/2019/02/glmpgraph-1.png?w=768 768w, https://matthewdgreen.files.wordpress.com/2019/02/glmpgraph-1.png 922w" sizes="(max-width: 700px) 100vw, 700px"><figcaption id="caption-attachment-5041">Experimental results (Figure 2) from <a href="https://eprint.iacr.org/2019/011.pdf">Grubbs&nbsp;</a><a href="https://eprint.iacr.org/2019/011.pdf"><em>et al.</em></a><em> (GLMP,&nbsp;</em>2019). The Y-axis represents the measured&nbsp;<em>error</em> between the reconstructed database and the actual dataset (smaller is better.) The X-axis represents the number of queries. Each database contains 1,000 records, but there are four different values of&nbsp;<em>N</em> tested here. Notice that the biggest error occurs around the very largest and smallest values in the dataset, so the results are&nbsp;<em>much</em> better if one is willing to ‚Äúsacrifice‚Äù these values.</figcaption></figure>
<p>Even after just 100 queries, the error in the dataset has been hugely reduced, and after 500 queries the contents of the database ‚Äî excluding the tails ‚Äî can be recovered with only about a 1-2% error rate.</p>
<p>Moreover, these experimental results illustrate the fact that recovery works at many scales: that is, they work nearly as well for very different values of N, ranging from 100 to 100,000. This means that the only variable you really need to think about as an attacker is:&nbsp;<em>how close do I need my reconstruction to be?</em> This is probably not very good news for any real data set.</p>
<h3>How do these techniques actually work?</h3>
<p>The answer is both very straightforward and deeply complex. The straightforward part is simple; the complex part requires an understanding of <a href="https://en.wikipedia.org/wiki/Vapnik%E2%80%93Chervonenkis_theory">Vapnik-Chervonenkis learning theory</a> (VC-theory) which is beyond the scope of this blog post, but is explained in <a href="https://eprint.iacr.org/2019/011.pdf">the paper</a>.</p>
<p>At the very highest level the recovery approach is similar to what‚Äôs been done in the past: using response probabilities to obtain record values. This paper does it much more efficiently and <em>approximately</em>, using some fancy learning theory results while making a few assumptions.</p>
<p>At the highest level: we are going to assume that the range queries are made on random endpoints ranging from 1 to <em>N</em>. This is a big assumption, and more on it later! Yet with just this knowledge in hand, we learn quite a bit. For example: we can compute the probability that a potential record value (say, the specific salary $34,234) is going to be sent back, provided we know the total value lies in the range 1-<em>N</em> (say, we know all salaries are between $1 and $200,000).</p>
<p>If we draw the resulting probability curve in freehand, it might look something like the chart below. This isn‚Äôt actually to scale or (probably) even accurate, but it illustrates a key point: by the nature of (random) range queries, records near the center are going to have a higher overall chance of being responsive to any given query, since the ‚Äúcenter‚Äù values are more frequently covered by random ranges, and records near the extreme high- and low values will be chosen less frequently.</p>
<figure data-shortcode="caption" id="attachment_5042" aria-describedby="caption-attachment-5042"><img data-attachment-id="5042" data-permalink="https://blog.cryptographyengineering.com/2019/02/11/attack-of-the-week-searchable-encryption-and-the-ever-expanding-leakage-function/badgraph/" data-orig-file="https://matthewdgreen.files.wordpress.com/2019/02/badgraph.png" data-orig-size="716,392" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="badgraph" data-image-description="" data-medium-file="https://matthewdgreen.files.wordpress.com/2019/02/badgraph.png?w=300" data-large-file="https://matthewdgreen.files.wordpress.com/2019/02/badgraph.png?w=700" src="https://matthewdgreen.files.wordpress.com/2019/02/badgraph.png?w=700" alt="badgraph" srcset="https://matthewdgreen.files.wordpress.com/2019/02/badgraph.png?w=700 700w, https://matthewdgreen.files.wordpress.com/2019/02/badgraph.png?w=150 150w, https://matthewdgreen.files.wordpress.com/2019/02/badgraph.png?w=300 300w, https://matthewdgreen.files.wordpress.com/2019/02/badgraph.png 716w" sizes="(max-width: 700px) 100vw, 700px"><figcaption id="caption-attachment-5042">I drew this graph freehand to mimic a picture in Kenny‚Äôs slides. Not a real plot!</figcaption></figure>
<p>The high-level goal of database reconstruction is to match the observed response rate for a given row (say, row 41) to the number of responses we‚Äôd expect see for different specific concrete values in the range. Clearly the accuracy of this approach is going to depend on the number of queries you, the attacker, can observe ‚Äî more is better. And since the response rates are lower at the highest and lowest values,&nbsp;it will take more queries to guess outlying data values.</p>
<p>You might also notice that there is one major pitfall here. Since the graph above is&nbsp;<em>symmetric</em> around its midpoint, the expected response rate will be the same for a record at .25*N and a record at .75*N ‚Äî that is, a $50,000 salary will be responsive to random queries at precisely same rate as a $150,000 salary. So even if you get every database row pegged precisely to its response rate, your results might still be ‚Äúflipped‚Äù horizontally around the midpoint. Usually this isn‚Äôt the end of the world, because databases aren‚Äôt normally full of unstructured random data ‚Äî high salaries will be less common than low salaries in most organizations, for example, so you can probably figure out the ordering based on that assumption. But this last ‚Äúbit‚Äù of information is technically not guaranteed to come back, minus some assumptions about the data set.</p>
<p>Thus, the recovery algorithm breaks down into two steps: first, observe the response rate for each record as random range queries arrive. For each record that responds to such a query, try to solve for a concrete value that&nbsp;<em>minimizes</em> the difference between the expected response rate on that value, and the observed rate. The probability estimation can be made more efficient (eliminating a quadratic term) by assuming that there is at least one record in the database within the range .2N-.3N (or .7N-.8N, due to symmetry). Using this ‚Äúanchor‚Äù record requires a mild assumption about the database contents.</p>
<p>What remains is to show that the resulting attack is efficient. You can do this by simply implementing it ‚Äî as illustrated by the charts above. Or you can <em>prove</em> that it‚Äôs efficient.&nbsp;The GLMP<em>&nbsp;</em>paper&nbsp;uses some very heavy statistical machinery to do the latter. Specifically, they make use of a result from <a href="https://en.wikipedia.org/wiki/Vapnik%E2%80%93Chervonenkis_theory">Vapnik-Chervonenkis learning theory</a> (VC-theory), which shows that the bound can be derived from something called the <a href="https://en.wikipedia.org/wiki/Vapnik%E2%80%93Chervonenkis_dimension">VC-dimension</a>&nbsp;(which is a small number, in this case) and is unrelated to the actual value of&nbsp;<em>N</em>. That proof forms the bulk of the result, but the empirical results are also pretty good.</p>
<h3>Is there anything else in the paper?</h3>
<p>Yes. It gets worse. There‚Äôs so much in this paper that I cannot possibly include it all here without risking carpal tunnel and boredom, and all of it is bad news for the field of encrypted databases.</p>
<p>The biggest additional result is one that shows that&nbsp;<em>if all you want is an approximate ordering</em> of the database rows, then you can do this efficiently using something called&nbsp;a <a href="https://en.wikipedia.org/wiki/PQ_tree">PQ tree.</a>&nbsp;Asymptotically, this requires <img src="https://s0.wp.com/latex.php?latex=O%28%5Cepsilon%5E%7B-1%7D+log%7E%5Cepsilon%5E%7B-1%7D%29&amp;bg=ffffff&amp;fg=000000&amp;s=0" alt="O(\epsilon^{-1} log~\epsilon^{-1})" title="O(\epsilon^{-1} log~\epsilon^{-1})"> queries, and experimentally the results are again even better than one would expect.</p>
<p>What‚Äôs even more important about this ordering result is that it works <em>independently of the query distribution</em>. That is: we do not need to have random range queries in order for this to work: it works reasonably well regardless of how the client puts its queries together (up to a point).</p>
<p>Even better, the authors show that this ordering, along with some knowledge of the underlying database distribution ‚Äî for example, let‚Äôs say we know that it consists of U.S. citizen last names ‚Äî can also be used to obtain approximate database reconstruction. Oy vey!</p>
<p>And there‚Äôs still even more:</p>
<ul>
<li>The authors show how to obtain <em>even more efficient&nbsp;</em>database recovery in a setting where the query range values are known to the attacker, using <a href="https://en.wikipedia.org/wiki/Probably_approximately_correct_learning">PAC learning</a>. This is a more generous setting than previous work, but it could be realistic in some cases.</li>
<li>Finally, they extend this result to&nbsp;<em>prefix</em> and&nbsp;<em>suffix</em> queries, as well as range queries, and show that they can run their attacks on a dataset from the Fraternal Order of Police, obtaining record recovery in a few hundred queries.</li>
</ul>
<p>In short: this is all really bad for the field of encrypted databases.</p>
<h3>So what do we do about this?</h3>
<p>I don‚Äôt know. Ignore these results? <a href="https://www.usenix.org/system/files/1401_08-12_mickens.pdf">Fake our own deaths and move into a submarine</a>?</p>
<p>In all seriousness: database encryption has been a controversial subject in our field. I wish I could say that there‚Äôs been an actual debate, but it‚Äôs more that different researchers have fallen into different camps, and nobody has really had the data to make their position in a compelling way. There have actually been some very personal arguments made about it.</p>
<p>The schools of thought are as follows:</p>
<p>The first holds that&nbsp;<em>any kind of database encryption is better than storing records in plaintext</em>&nbsp;and we should stop demanding things be perfect, when the alternative is a world of <a href="https://en.wikipedia.org/wiki/List_of_data_breaches">constant data breaches</a> and sadness.</p>
<p>To me this is a supportable position, given that the current attack model for plaintext databases is something like ‚Äúcopy the database files, or just run a local SELECT * query‚Äù, and the threat model for an encrypted database is ‚Äúgain persistence on the server and run sophisticated statistical attacks.‚Äù Most attackers are pretty lazy, so even a weak system is probably better than nothing.</p>
<p>The countervailing school of thought has two points: sometimes the&nbsp;<em>good</em> is much worse than the perfect, particularly if it gives application developers an outsized degree of confidence of the security that their encryption system is going to provide them.</p>
<p>If even the best encryption protocol is only throwing a tiny roadblock in the attacker‚Äôs way, why risk this&nbsp;<em>at all</em>? Just let the database community come up with some kind of ROT13 encryption&nbsp;<em>that everyone knows to be crap</em>&nbsp;and stop throwing good research time into a problem that has no good solution.</p>
<p>I don‚Äôt really know who is right in this debate. I‚Äôm just glad to see we‚Äôre getting closer to having it.</p>

	</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
</body>
</html>