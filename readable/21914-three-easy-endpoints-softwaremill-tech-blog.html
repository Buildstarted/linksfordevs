<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Three easy endpoints - SoftwareMill Tech Blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Three easy endpoints - SoftwareMill Tech Blog</h1><div><div class="ac ae af ag ah ea aj ak"><p id="c79c" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv"><a href="https://github.com/softwaremill/tapir" class="da by gy gz ha hb" target="_blank" rel="noopener">tapir</a> is a library for describing HTTP endpoints. It combines Scala’s <strong class="gm hc">typesafety</strong>, with the <strong class="gm hc">declarative</strong> style and <strong class="gm hc">introspection</strong> capabilities known from Java annotation-based frameworks, such as <a href="https://spring.io" class="da by gy gz ha hb" target="_blank" rel="noopener">Spring</a> or <a href="https://jersey.github.io" class="da by gy gz ha hb" target="_blank" rel="noopener">JAX-RS</a>.</p><p id="9ac5" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">By leveraging Scala’s flexibility and functional programming features, tapir relies only on Scala (no code generation or external DSLs) and is based on <strong class="gm hc">simple, immutable</strong> data structures. This is, in contrast to annotations, which are an <a class="da by gy gz ha hb" target="_blank" rel="noopener" href="/the-case-against-annotations-4b2fb170ed67">interpreted, not-typesafe, non-composable mini-language</a> embedded into Java.</p><figure class="he hf hg hh hi hj dm dn paragraph-image"><figcaption class="ax fg ia ib ic do dm dn id ie as cw">tapir sticker by <a href="https://twitter.com/ImpurePics" class="da by gy gz ha hb" target="_blank" rel="noopener">ImpurePics</a></figcaption></figure><p id="38c9" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">At the same time, being a Scala library, the main goal of tapir is to be <strong class="gm hc">programmer friendly</strong>:</p><ul class=""><li id="8cfc" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx if ig ih">result in code <strong class="gm hc">readable</strong> also by people not familiar with the library</li><li id="229e" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih">provide <strong class="gm hc">discoverable</strong> API through standard auto-complete</li><li id="6bc0" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih">use <strong class="gm hc">human-comprehensible</strong> types, which you are not afraid to write down</li><li id="ba44" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih"><strong class="gm hc">separate</strong> “business logic” from endpoint definition &amp; documentation</li><li id="5fef" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih">be reasonably <strong class="gm hc">type safe</strong></li></ul><p id="41fe" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">A tapir endpoint — which is only a <strong class="gm hc">description</strong> — can be interpreted as a server, client or documentation. tapir doesn’t include its own HTTP server or client. Instead, it leverages one of the existing implementations:</p><ul class=""><li id="6256" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx if ig ih"><a href="https://doc.akka.io/docs/akka-http/current/index.html" class="da by gy gz ha hb" target="_blank" rel="noopener">Akka HTTP</a> or <a href="https://http4s.org" class="da by gy gz ha hb" target="_blank" rel="noopener">http4s</a> for server</li><li id="e166" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih">Akka HTTP, async-http-client or OkHttp for client (through <a href="https://github.com/softwaremill/sttp" class="da by gy gz ha hb" target="_blank" rel="noopener">sttp</a>)</li><li id="9d28" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih"><a href="https://swagger.io/specification/" class="da by gy gz ha hb" target="_blank" rel="noopener">OpenAPI</a> (Swagger) for documentation.</li></ul><p id="7e89" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">But, how do endpoint definitions look in practice? Let’s find out, exploring <strong class="gm hc">three endpoints</strong>:</p><ol class=""><li id="76c6" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx in ig ih"><em class="io">getting a list of entities as json</em></li><li id="95e1" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx in ig ih"><em class="io">streaming data</em></li><li id="2147" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx in ig ih"><em class="io">submitting multipart forms with text and binary parts</em></li></ol><p id="576b" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Making a deep dive, below you’ll find the endpoints described using tapir’s API, as plain Scala values. Without knowing the library (yet!):</p><ul class=""><li id="5c9b" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx if ig ih">do you suspect how the endpoints are <strong class="gm hc">intended</strong> to be used?</li><li id="31cf" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih">do the types give a hint on what kind of information each endpoint <strong class="gm hc">consumes and produces</strong>?</li><li id="36d7" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih">is the code <strong class="gm hc">readable</strong>, are the intentions of the writer of the code clearly communicated?</li><li id="3998" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih">how does it compare to the meta-data that is expressible via Java <strong class="gm hc">annotations</strong>?</li></ul><figure class="he hf hg hh hi hj"><p id="ca75" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">In the subsequent sections, we’ll go through the code of each endpoint. Together with the first one, we’ll make a crash-course of tapir’s API. If you’d rather prefer to see how to interpret the endpoint as a server or documentation, you can safely skim most of the next section.</p><p id="7157" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">If you’d like to read and explore code at the same time, all of the code covered is <a href="https://github.com/adamw/tapir-three" class="da by gy gz ha hb" target="_blank" rel="noopener">available on GitHub</a>.</p><h1 id="974a" class="iq ir ed at as is ef it eh iu iv iw ix iy iz ja jb">Endpoint 1: getting a list of books</h1><p id="29c9" class="gk gl ed at gm b gn jc gp jd gr je gt jf gv jg gx dv">Our running example will revolve around books. Each book will have an id, a title, author, year in which it was published and an optional cover image. The first endpoint will allow retrieving a list of books in the system, optionally filtered by publishing year, and optionally limited to a given number of results.</p><p id="8cec" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Here’s the model which we’ll be using:</p><figure class="he hf hg hh hi hj"><p id="6d5d" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">The endpoint that we’d like to describe is:</p><pre class="he hf hg hh hi jh ji cl"><span id="e6c8" class="jj ir ed at jk b fg jl jm r jn">GET /api/v1.0/books?year=...&amp;limit=...</span></pre><p id="faaf" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">where <code class="hu jo jp jq jk b">year</code> and <code class="hu jo jp jq jk b">limit</code> are optional parameters, the first one being mapped to the <code class="hu jo jp jq jk b">Year</code> value class, the second represented as an integer. The result should be a JSON representation of a <code class="hu jo jp jq jk b">List[Book]</code>. Additionally, our API should signal any errors as JSON as well (e.g. when the given limit is negative), corresponding to the <code class="hu jo jp jq jk b">ErrorInfo</code> case class.</p><p id="a3f7" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">How to describe such an endpoint? Remember that at this point we only want to <strong class="gm hc">capture the structure</strong>. We’ll start with an empty endpoint, and gradually refine our description. After each step, we’ll obtain a <strong class="gm hc">new, immutable description</strong> of a (partial) endpoint.</p><p id="6d0a" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">We’ll start by adding support for a non-standard type that we’ll want to map to in the query: <code class="hu jo jp jq jk b">Year</code>. In tapir, custom types are supported by creating a <code class="hu jo jp jq jk b">Codec</code>, which defines a bi-directional mapping between a raw type and the custom type:</p><figure class="he hf hg hh hi hj"><p id="746f" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Next, we’ll define the endpoint itself:</p><figure class="he hf hg hh hi hj"><p id="591b" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Each endpoint consists of inputs, error-outputs and outputs. The distinction between error and normal outputs is due to the fact that usually an API has different responses in both cases — and that’s supported as a first-class construct.</p><p id="5b66" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">The first input (defined using the <code class="hu jo jp jq jk b">.in</code> method) specifies the path of the endpoint: <code class="hu jo jp jq jk b">.in("api" / "v1.0" / "books")</code>. This path is constant, and doesn’t map to any values in the HTTP request. The second and third inputs map to query parameter values in the URL: <code class="hu jo jp jq jk b">query[Option[Year]]("year")</code> and <code class="hu jo jp jq jk b">query[Option[Int]]("limit")</code>. Note that optional values are simply expressed using Scala’s <code class="hu jo jp jq jk b">Option</code>s.</p><p id="27d1" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">When there’s an error, the body will be a JSON mapping to the <code class="hu jo jp jq jk b">ErrorInfo</code> class. By default, error-responses map to the <code class="hu jo jp jq jk b">400 Bad Request</code> status code, and successful responses map to the <code class="hu jo jp jq jk b">200 OK</code> status code. However, depending on the exact error being returned, we’d like to use varying status codes. Hence, we additionally use the <code class="hu jo jp jq jk b">statusCode</code> output, which maps to an <code class="hu jo jp jq jk b">Int</code> in the response; we do that only for errors, the success case will continue using the default status code.</p><p id="88dc" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Finally, using the <code class="hu jo jp jq jk b">.out</code> method, we specify that upon success, the body should be a json, mapping to a <code class="hu jo jp jq jk b">List[Book]</code>.</p><blockquote class="jr js jt"><p id="d6a1" class="gk gl ed io gm b gn go gp gq gr gs gt gu gv gw gx dv">Inputs can be specified in any order, as well as interleaved with outputs. It is just for reading convenience that they are grouped here.</p></blockquote><h2 id="864c" class="jj ir ed at as is ju jv jw jx jy jz ka kb kc kd ke">Inputs/outputs</h2><p id="3fd5" class="gk gl ed at gm b gn jc gp jd gr je gt jf gv jg gx dv">All of the methods used in the example above — <code class="hu jo jp jq jk b">query</code>, <code class="hu jo jp jq jk b">/</code>, <code class="hu jo jp jq jk b">statusCode</code> and <code class="hu jo jp jq jk b">jsonBody</code> are defined in the <code class="hu jo jp jq jk b">tapir</code> package, and are in scope thanks to the import statement. If you’d like to explore what kind of inputs/outputs are available, just type <code class="hu jo jp jq jk b">tapir.</code> and let your IDE’s auto-complete guide you.</p><p id="e922" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Each of these methods yields a <strong class="gm hc">value</strong>, which is an <strong class="gm hc">immutable description</strong> of an input/output.</p><p id="ce8b" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">For example, <code class="hu jo jp jq jk b">jsonBody[List[Book]]</code> is a description of a body input or output, which will have the json content type and will be serialised or de-serialised to a list of books.</p><blockquote class="jr js jt"><p id="c0c3" class="gk gl ed io gm b gn go gp gq gr gs gt gu gv gw gx dv">An important note here: to be able to use the json body, we’ll need to integrate with an existing json library. Here, we use <a href="https://circe.github.io/circe/" class="da by gy gz ha hb" target="_blank" rel="noopener">Circe</a>, with automatic generic derivation (<code class="hu jo jp jq jk b">import io.circe.generic.auto._</code>), as well as import tapir-Circe integration: <code class="hu jo jp jq jk b">Codec</code>s which use Circe’s <code class="hu jo jp jq jk b">Encoder</code>s/<code class="hu jo jp jq jk b">Decoder</code>s, using <code class="hu jo jp jq jk b">import tapir.json.circe._</code>.</p></blockquote><h2 id="f56e" class="jj ir ed at as is ju jv jw jx jy jz ka kb kc kd ke">The type</h2><p id="86ac" class="gk gl ed at gm b gn jc gp jd gr je gt jf gv jg gx dv">The type of the endpoint description captures what is needed for the endpoint to be interpreted as a server or a client. We need information on all the inputs and outputs which map to values in the request/response. The <code class="hu jo jp jq jk b">Endpoint</code> class has four type parameters: one specifying the <strong class="gm hc">input type</strong>, the <strong class="gm hc">error output</strong> type, the <strong class="gm hc">output</strong> type and <strong class="gm hc">streaming requirements</strong> (which we’ll cover later). In our case, the type is:</p><figure class="he hf hg hh hi hj"><p id="4180" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">The path input contributes no values to the input (as the path is constant), so it doesn’t influence the input type. However, the query inputs both contribute a single value: the year and the limit. Combined, we get a 2-tuple <code class="hu jo jp jq jk b">(Option[Year], Option[Int])</code>. The same for the outputs.</p><h2 id="6b37" class="jj ir ed at as is ju jv jw jx jy jz ka kb kc kd ke">Refactoring the endpoint</h2><p id="8d7e" class="gk gl ed at gm b gn jc gp jd gr je gt jf gv jg gx dv">Leveraging the fact that both the endpoint, the inputs and the outputs are immutable values, we can do some refactoring, which will make writing subsequent endpoints easier. First, we’ll note that all of the endpoints that we’ll define in our system will have the <code class="hu jo jp jq jk b">/api/v1.0</code> path prefix, and upon an error will return an <code class="hu jo jp jq jk b">ErrorInfo</code> JSON (with a varying status code). To avoid duplication, we can create a custom base endpoint.</p><p id="044f" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">With tapir, we can use a very convenient and well-known technique of avoiding code duplication, which is called “<strong class="gm hc">extract value</strong>” or “<strong class="gm hc">extract method</strong>”. The same mechanism we use for “normal” code (because <strong class="gm hc">tapir code is normal code</strong>)!</p><figure class="he hf hg hh hi hj"><p id="7fa4" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Our base endpoint maps to no values from the HTTP request (hence the <code class="hu jo jp jq jk b">Unit</code> as the first type parameter), but specifies the type of the error output. Note that this type isn’t final, and can also be extended by other endpoints.</p><p id="b415" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">As a second step of our refactoring, we’ll note that the books filter: by-year and limit, will be probably reused by other endpoints (such as searching for books by title, by author etc.). Moreover, we could use a more descriptive representation than a <code class="hu jo jp jq jk b">(Option[Year], Option[Int])</code> tuple. Hence, we’ll create a case class representing the filter:</p><figure class="he hf hg hh hi hj"><p id="57c4" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">and extract a value which will describe a books query input:</p><figure class="he hf hg hh hi hj"><p id="92cd" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Note that we can combine multiple inputs not only by calling <code class="hu jo jp jq jk b">.in</code> or <code class="hu jo jp jq jk b">.out</code> on the endpoint description multiple times, but also by using <code class="hu jo jp jq jk b">.and</code> (and the alias for paths: <code class="hu jo jp jq jk b">/</code>) on inputs themselves.</p><p id="bc86" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Moreover, tapir provides a convenience <code class="hu jo jp jq jk b">.mapTo</code> method to map a tuple to a matching case class representation. In effect, we get a value of type <code class="hu jo jp jq jk b">EndpointInput[BooksQuery]</code>, which describes a (composite) input mapping to a <code class="hu jo jp jq jk b">BooksQuery</code> instance.</p><h2 id="69e1" class="jj ir ed at as is ju jv jw jx jy jz ka kb kc kd ke">Final result</h2><p id="ba99" class="gk gl ed at gm b gn jc gp jd gr je gt jf gv jg gx dv">After the refactoring, here’s the first of the three inputs that we are going to define:</p><figure class="he hf hg hh hi hj"><p id="20e7" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Some of the key features of this representation:</p><ul class=""><li id="112c" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx if ig ih">the endpoint is described as an <strong class="gm hc">immutable Scala value</strong> (a case class instance)</li><li id="eb42" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih">re-usable parts of the endpoint description are <strong class="gm hc">extracted as values</strong>, which can be navigated to using the IDE</li><li id="ebc9" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih"><strong class="gm hc">reading the definition</strong> (in english) gives a good idea of what the endpoint is</li><li id="43b1" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx if ig ih"><strong class="gm hc">the type</strong> of the endpoint gives <strong class="gm hc">precise</strong> (and readable) <strong class="gm hc">information</strong> on how the endpoint maps to HTTP requests and responses</li></ul><h1 id="f5fe" class="iq ir ed at as is ef it eh iu iv iw ix iy iz ja jb">Endpoint 2: streaming a book cover image</h1><p id="ce93" class="gk gl ed at gm b gn jc gp jd gr je gt jf gv jg gx dv">The second example will describe an endpoint for streaming book cover images. We’ll be using the same <code class="hu jo jp jq jk b">baseEndpoint</code> we’ve defined before:</p><figure class="he hf hg hh hi hj"><p id="602f" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Unlike in the first endpoint, here we capture one segment of the path, which maps to the id of the book, for which to get the cover image. This is done using the <code class="hu jo jp jq jk b">path[UUID]("bookId")</code> method.</p><p id="b9ae" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Moreover, we specify that the output body will be an Akka Stream: <code class="hu jo jp jq jk b">Source[ByteString, Any]</code>. That’s a special kind of input, as it not only influences the input/output type, but also the 4th type parameter of <code class="hu jo jp jq jk b">Endpoint</code>: the streaming requirements. While other inputs/outputs can be interpreted by any client/server interpreter, streams are interpreter-specific.</p><p id="8d22" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Endpoints using Akka Streams streaming bodies can only be used when using the Akka HTTP server interpreter, or the Akka HTTP sttp client interpreter. Similarly, an endpoint using <a href="https://fs2.io" class="da by gy gz ha hb" target="_blank" rel="noopener">FS2</a> streams as the body can only be used with an http4s server interpreter, or a compatible sttp client interpreter.</p><h1 id="f300" class="iq ir ed at as is ef it eh iu iv iw ix iy iz ja jb">Endpoint 3: submitting multipart forms</h1><p id="5bc3" class="gk gl ed at gm b gn jc gp jd gr je gt jf gv jg gx dv">Finally, we’ll describe an endpoint for adding a book. To add a book, besides the book details such as author and title, we’ll also give the user a possibility to submit a cover image. This is possible using multipart form submissions.</p><p id="c0d8" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">To handle multipart forms, we’ll first define a case class containing all the information that users will submit via the form:</p><figure class="he hf hg hh hi hj"><p id="05a6" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">We’ll also secure our endpoint via a bearer token, which will be a string, but for readability we’ll use a type alias:</p><figure class="he hf hg hh hi hj"><p id="c0eb" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Finally, here’s the endpoint itself:</p><figure class="he hf hg hh hi hj"><p id="0c30" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Again, we’re using the <code class="hu jo jp jq jk b">baseEndpoint</code>. Here however, we’re using the <code class="hu jo jp jq jk b">.post</code> method, as this endpoint corresponds to <code class="hu jo jp jq jk b">POST /api/v1.0/books</code>. Another important feature is the <code class="hu jo jp jq jk b">auth.bearer</code> input, which describes an <code class="hu jo jp jq jk b">Authorization</code> header input, additionally marking it as a means of authentication (which is important when generating documentation).</p><p id="f0ef" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">But the nicest part is specifying that the input body of the endpoint should be a multipart form. We use the <code class="hu jo jp jq jk b">multipartBody[NewBook]</code> method, which yields a description of an input (as always, an immutable value! — a case class instance), mapping <code class="hu jo jp jq jk b">title</code>, <code class="hu jo jp jq jk b">year</code>, <code class="hu jo jp jq jk b">authorName</code> and <code class="hu jo jp jq jk b">authorCountry</code><strong class="gm hc">text parts</strong> to the appropriate case class values, and storing the optional <code class="hu jo jp jq jk b">cover</code><strong class="gm hc">binary part</strong> as a temporary file (represented as Java’s <code class="hu jo jp jq jk b">Path</code>).</p><p id="6cb1" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv"><strong class="gm hc">And that’s it!</strong> Describing multipart forms is as easy as creating a case class with the appropriate fields.</p><h1 id="f7cf" class="iq ir ed at as is ef it eh iu iv iw ix iy iz ja jb">Interpreting as a server</h1><p id="52b5" class="gk gl ed at gm b gn jc gp jd gr je gt jf gv jg gx dv">Describing endpoints is nice, but the descriptions are just values: they don’t do anything. Let’s change this and interpret our endpoints as a server, and later as documentation. Endpoints can also be <a href="https://tapir-scala.readthedocs.io/en/latest/sttp.html" class="da by gy gz ha hb" target="_blank" rel="noopener">interpreted as clients</a>, which however isn’t covered in this article.</p><p id="ada6" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Before interpreting as a server, we need to first pick an underlying stack. Here, we’ll be using Akka HTTP and <code class="hu jo jp jq jk b">Future</code>s to represent asynchronous and side-effecting computations. If you’d rather work with <code class="hu jo jp jq jk b">Task</code>s, <code class="hu jo jp jq jk b">IO</code>s etc., you should use the http4s interpreter.</p><p id="d316" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">We’ll be using a thread-unsafe, var-based “database” with a couple of books already in place:</p><figure class="he hf hg hh hi hj"><p id="bf0b" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">To interpret an endpoint as a server, we’ll need to provide the business logic for each endpoint that we’ve defined. To do this, we’ll import an extension method to the <code class="hu jo jp jq jk b">Endpoint</code> class, <code class="hu jo jp jq jk b">toRoute</code>, from the <code class="hu jo jp jq jk b">tapir.server.akkahttp</code> package. This methods accepts the business logic as a parameter, and returns an Akka HTTP <code class="hu jo jp jq jk b">Route</code> as a result:</p><figure class="he hf hg hh hi hj"><p id="58b5" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">As we are in Akka-land, the business logic should return a <code class="hu jo jp jq jk b">Future</code>. Moreover, we need to signal that either the error-output, or that the normal-output should be used. We do this using an <code class="hu jo jp jq jk b">Either</code>: by convention, if the result is a <code class="hu jo jp jq jk b">Left</code>, that signals an error. If the result is wrapped in a <code class="hu jo jp jq jk b">Right</code>, this signals success.</p><p id="196e" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Hence, for the <code class="hu jo jp jq jk b">getBooks</code> endpoint, which has type:</p><pre class="he hf hg hh hi jh ji cl"><span id="6518" class="jj ir ed at jk b fg jl jm r jn">Endpoint[BooksQuery, (StatusCode, ErrorInfo), List[Book], Nothing]</span></pre><p id="8bbb" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">the corresponding type of the business logic that we need to provide is:</p><pre class="he hf hg hh hi jh ji cl"><span id="bb70" class="jj ir ed at jk b fg jl jm r jn">BooksQuery =&gt; Future[Either[(StatusCode, ErrorInfo), List[Book]]</span></pre><p id="a313" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Note, that everything is type-safe! The business logic accepts as parameters data which is extracted and parsed according to the description in the endpoint; moreover, it is required to return data of the specified type as well. The response is then serialised using the captured json Circe codecs.</p><p id="09d4" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">We implement the business logic of the remaining two endpoints in a similar way:</p><figure class="he hf hg hh hi hj"><p id="073c" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">We now have three completely regular Akka HTTP <code class="hu jo jp jq jk b">Route</code>s. We can surround them with other directives, e.g. for logging or metrics, or manipulate in any other way just as we would with a route created using Akka HTTP’s API. Here, we’ll simply start a server with these routes on the 8080 port:</p><figure class="he hf hg hh hi hj"><h1 id="ae4d" class="iq ir ed at as is ef it eh iu iv iw ix iy iz ja jb">Interpreting as documentation</h1><p id="f13c" class="gk gl ed at gm b gn jc gp jd gr je gt jf gv jg gx dv">Thanks to the fact that our endpoint descriptions capture the whole structure of the endpoint, we can also automatically generate API documentation.</p><p id="79ba" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Moreover, we can enrich the endpoint descriptions with meta-data, such as textual clarifications on the functionality of the API or data examples. For instance, we might provide an example of a book instance that is returned by the get books endpoint (note the <code class="hu jo jp jq jk b">.example</code> method invocation):</p><figure class="he hf hg hh hi hj"><p id="4721" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">tapir contains an OpenAPI interpreter, which translates a list of <code class="hu jo jp jq jk b">Endpoint</code>s to an instance of the <code class="hu jo jp jq jk b">OpenAPI</code> class. <code class="hu jo jp jq jk b">OpenAPI</code> is the root of a family of case classes, which directly model the OpenAPI specification.</p><p id="ead3" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Thanks to that approach, if there’s some feature of the specification that is not covered by tapir, and cannot be automatically generated, you can always add it to the generated documentation, by manipulating the returned instance. When modifying a deeply nested case class structure, projects such as <a href="https://github.com/adamw/quicklens" class="da by gy gz ha hb" target="_blank" rel="noopener">quicklens</a> might be very helpful!</p><p id="ce0a" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">We can later serialise the <code class="hu jo jp jq jk b">OpenAPI</code> instance as yaml or json:</p><figure class="he hf hg hh hi hj"><p id="9645" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">The generated yml can be exposed using Swagger’s UI by adding a couple of Akka HTTP routes to serve the static content (images, css, html) and the documentation itself. See the <code class="hu jo jp jq jk b">SwaggerUI</code> class in the <a href="https://github.com/adamw/tapir-three" class="da by gy gz ha hb" target="_blank" rel="noopener">sources</a> for details.</p><figure class="he hf hg hh hi hj dm dn paragraph-image"><h1 id="0140" class="iq ir ed at as is ef it eh iu iv iw ix iy iz ja jb">Summary</h1><p id="49e5" class="gk gl ed at gm b gn jc gp jd gr je gt jf gv jg gx dv">We’ve covered a lot of ground! Let’s summarise what we’ve seen so far.</p><p id="e30b" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Java frameworks use annotations to define the mapping between business logic methods and HTTP endpoints. This has three main benefits:</p><ol class=""><li id="9f27" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx in ig ih">the HTTP meta-data is <strong class="gm hc">separated</strong> from the business logic</li><li id="15de" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx in ig ih">annotations can be <strong class="gm hc">processed</strong> to generate documentation or a client</li><li id="fee1" class="gk gl ed at gm b gn ii gp ij gr ik gt il gv im gx in ig ih">the <strong class="gm hc">intention</strong> of the code is clearly communicated, that is, the code is not only easy to write, but also easy to read</li></ol><p id="a6ad" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">On the other hand, we have Scala, which has a much more <strong class="gm hc">advanced type system</strong>, as well as a number of features allowing flexibility in defining <strong class="gm hc">abstractions</strong>.</p><p id="bc9d" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">tapir <strong class="gm hc">combines the best of those worlds</strong>. Instead of using a separate language for defining the meta-data (the language of annotations), we use the same language to express the meta-data and the business logic. After all, why should we use a different one? Specifying HTTP mappings isn’t such a special task, that it should require a separate language! This allows us to use the same abstraction mechanisms as we use for all other code — for example, extracting common functionality as values or methods.</p><p id="bc90" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Hence, we manage to maintain the <strong class="gm hc">declarativeness</strong>, <strong class="gm hc">separation of concerns</strong> and <strong class="gm hc">readability</strong> of Java’s annotations; at the same time, significantly improving the <strong class="gm hc">type-safety</strong>, <strong class="gm hc">composability</strong> and <strong class="gm hc">abstraction</strong> capabilities.</p><p id="4918" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Remember that the descriptions are plain Scala values — instances of case classes. You can construct these case classes by hand, or pattern-match them to create your own interpreters. Describing HTTP endpoints isn’t a complex thing, and it shouldn’t require complex code. Let’s use <a class="da by gy gz ha hb" target="_blank" rel="noopener" href="/simple-scala-stack-70fc786132b5">simple code for simple problems</a>!</p><p id="62a2" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Give <a href="https://github.com/softwaremill/tapir" class="da by gy gz ha hb" target="_blank" rel="noopener">tapir</a> a try, <a href="https://github.com/adamw/tapir-three" class="da by gy gz ha hb" target="_blank" rel="noopener">run the example</a> developed above, in case of questions <a href="https://tapir-scala.readthedocs.io" class="da by gy gz ha hb" target="_blank" rel="noopener">consult the docs</a>, head over to the <a href="http://gitter.im/softwaremill/tapir" class="da by gy gz ha hb" target="_blank" rel="noopener">gitter room</a> or simply create an issue!</p></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>