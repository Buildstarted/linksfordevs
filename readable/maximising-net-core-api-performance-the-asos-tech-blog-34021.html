<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Maximising&#xA0;.NET Core API performance - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Maximising&#xA0;.NET Core API performance - linksfor.dev(s)"/>
    <meta property="article:author" content="Tom Longhurst"/>
    <meta property="og:description" content="Find bottlenecks and remove them!"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/asos-techblog/maximising-net-core-api-performance-11ad883436c"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Maximising&#xA0;.NET Core API performance</title>
<div class="readable">
        <h1>Maximising&#xA0;.NET Core API performance</h1>
            <div>by Tom Longhurst</div>
            <div>Reading time: 10-13 minutes</div>
        <div>Posted here: 23 Aug 2019</div>
        <p><a href="https://medium.com/asos-techblog/maximising-net-core-api-performance-11ad883436c">https://medium.com/asos-techblog/maximising-net-core-api-performance-11ad883436c</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@thomhurst?source=post_page-----11ad883436c----------------------"><img alt="Tom Longhurst" src="https://miro.medium.com/fit/c/96/96/0*ThnYAQ9JSM6duj8z.jpg" width="48" height="48"></a></p></div></div></div></div><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*8r6eTggDd-vBhCg4EZVdqQ.png?q=20" width="930" height="587" role="presentation"></p><p><img width="930" height="587" role="presentation" src="https://miro.medium.com/max/930/1*8r6eTggDd-vBhCg4EZVdqQ.png"></p></div></div></div></div></figure><p id="8ed5" data-selectable-paragraph="">You may or may not have heard of this statistic from Google:</p><blockquote><p id="9212" data-selectable-paragraph="">53% of mobile site visits leave a page that takes longer than three seconds to load<br><a href="https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/" target="_blank" rel="noopener nofollow">https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/</a></p></blockquote><p id="101b" data-selectable-paragraph="">With that in mind, it’s important to make our site as responsive and quick as possible.</p><p id="c76b" data-selectable-paragraph="">We recently rewrote one of our APIs from scratch, Saved Items, to better pave the way for new functionality and improve the performance by utilising new technologies such as .NET Core 2.</p><p id="8a31" data-selectable-paragraph="">The API has been rewritten. Functionally it’s performing as expected — we’ve got acceptance, integration, performance tests in place. It looks like we’re good to go!</p><p id="afff" data-selectable-paragraph="">We release our API contract to the relevant teams that will consume it and they get to work on switching their calls to us from the old endpoints to the new endpoints.</p><p id="7512" data-selectable-paragraph="">Our mobile applications were the first to have a working implementation and once any functional anomalies were ironed out, we rolled out these application updates as beta versions to our customers.</p><p id="084c" data-selectable-paragraph="">And so the traffic starts cranking up on our new API. Scary stuff as it’s brand new. We’ve tested what we can, but we all know how environment configurations can behave differently. This was our first live traffic with a significant amount of load behind it.</p><p id="3fc6" data-selectable-paragraph="">But it’s all looking smooth. Until some time later, we start getting alerts. Uh oh.</p><p id="98bd" data-selectable-paragraph="">We’re seeing some errors and dependency call response duration spikes in our logs.</p><p id="39f1" data-selectable-paragraph="">Then it would calm down and our performance would return to normal.</p><p id="a642" data-selectable-paragraph="">Then maybe the next day, some errors and dependency call duration spikes would happen again.</p><p id="269e" data-selectable-paragraph="">Then normality.</p><p id="79c5" data-selectable-paragraph="">We were in a random cycle of good performance, bad performance. There wasn’t any clear correlation as to what was happening. We were a bit stumped.</p><p id="bc09" data-selectable-paragraph="">The impact to our customers was minimal — it was only our beta app users, but this was definitely blocking us from releasing to all of our customers. We had to fix it quickly, but first, we had to find out what was causing these problems.</p><p id="ae2e" data-selectable-paragraph="">After some brainstorming as a team, we had some ideas.</p><p id="bbd0" data-selectable-paragraph="">One common cause of slow, bottlenecked code is thread pool starvation — Where your thread pool is too busy and exhausted and is unavailable to jump around and pick up new requests. These were the symptoms we were suffering from, and therefore the best place to start.</p><p id="e262" data-selectable-paragraph="">Our application followed asynchronous best practices to the best of our knowledge — unless we’d missed some. But the code-base isn’t small. How would we find them?</p><p id="223b" data-selectable-paragraph="">After some researching, we found this library — Ben.BlockingDetector:</p><p id="aef5" data-selectable-paragraph="">And we can’t thank it enough!</p><p id="b2bc" data-selectable-paragraph="">To add Blocking Detection to your API, follow these steps:</p><ul><li id="5c73" data-selectable-paragraph="">Install via NuGet &gt;</li></ul><pre><span id="958b" data-selectable-paragraph="">Install-Package Ben.BlockingDetector -Version 0.0.3</span></pre><ul><li id="1b77" data-selectable-paragraph="">Call a single method on your <code>IApplicationBuilder</code></li></ul><figure><div></div></figure><ul><li id="0dc8" data-selectable-paragraph="">There is no step three — it’s that easy.</li></ul><p id="c6a3" data-selectable-paragraph="">We pushed the API with this library included to our testing environments and ran our regression suite of tests against it.</p><p id="0d5c" data-selectable-paragraph="">We monitored the logs and started to see some stack traces.</p><blockquote><p id="8ec8" data-selectable-paragraph="">Blocking method has been invoked and blocked, this can lead to threadpool starvation at …. blah blah</p></blockquote><p id="4a6f" data-selectable-paragraph="">Following these stack traces, we found a number of blocking calls which had an async alternative. While yours (if you have any) will more than likely be different, these were ours:</p><h2 id="c633" data-selectable-paragraph="">Redis database connection</h2><p id="fa9e" data-selectable-paragraph="">We use Redis caching through the StackExchange client package.<br>On the initial connection, we were calling:</p><figure><div></div><figcaption>How to not connect to Redis</figcaption></figure><p id="7498" data-selectable-paragraph="">This one was one of the biggest culprits we think. If it connected quickly and successfully — great, but if it was having issues, it may have sat there for say, 30 seconds, blocking the thread.<br>We changed this to the below and awaited the async call wherever we used it.</p><figure><div></div><figcaption>How to actually connect to Redis</figcaption></figure><p id="839c" data-selectable-paragraph="">This is also a reason why we didn’t see it in our performance tests because we didn’t have any Redis connection issues while we were testing. Then in our live environment, we had some for whatever reason, and it was very damaging to our application.</p><h2 id="6947" data-selectable-paragraph="">Redis bulk data management</h2><p id="eb74" data-selectable-paragraph="">As well with Redis, we work with collections and multiple records at once, and so we add to or delete from Redis in bulk. Previously we were bulking our requests like this:</p><figure><div></div><figcaption>How to not bulk insert to Redis</figcaption></figure><p id="fde8" data-selectable-paragraph="">That <code>batch.Execute()</code> was another culprit that was apparently blocking.</p><p id="4243" data-selectable-paragraph="">Well, batching wasn’t doing us any favours apparently, so we switched to&nbsp;immediately&nbsp;executing&nbsp;and&nbsp;awaiting&nbsp;all&nbsp;the&nbsp;steps&nbsp;as&nbsp;tasks.</p><figure><div></div><figcaption>How to actually bulk insert to Redis</figcaption></figure><p id="37fa" data-selectable-paragraph="">Notice here that we aren’t creating a <code>batch</code> object. We’re creating records straight from our <code>database</code> object.</p><p id="b884" data-selectable-paragraph="">Notice also that we aren’t creating a <code>foreach</code> loop and awaiting inside it. Because that’s slow — it waits for each record to complete before continuing. Instead, we kick off all the tasks first and await them all afterwards — this way they run in parallel.</p><h2 id="8f27" data-selectable-paragraph="">Logging output</h2><p id="92de" data-selectable-paragraph="">And lastly, we use the Serilog library, and this was said to be blocking. Now we were writing to two different places. One of these was the Console Standard Out.</p><p id="cb40" data-selectable-paragraph="">We don’t look at the console output for production — we have another source for our logs that we’re able to query more easily. And after some interesting articles about production logging, there was the discussion that console output was slow.</p><p id="cfa0" data-selectable-paragraph="">So with these these three factors combined:</p><ul><li id="04b8" data-selectable-paragraph="">It’s slow</li><li id="6132" data-selectable-paragraph="">We didn’t read it</li><li id="3d10" data-selectable-paragraph="">It was a potentially blocking action</li></ul><p id="2b5b" data-selectable-paragraph="">We disabled writing to the console for production. <br>( Our <code>isDevelopmentEnvironment</code> boolean is set based on the value of our Environment variable <code>ASPNETCORE_ENVIRONMENT</code> )</p><figure><div></div><figcaption>Turn off Console Out for Production!</figcaption></figure><p id="d1b4" data-selectable-paragraph="">We noticed a few other blocking stack traces, but these were outside of our control. E.g. JSON serialisation.</p><p id="1781" data-selectable-paragraph="">It may be worth asking any libraries’ authors about these so that they can investigate.</p><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*awuiuSENTuPnYNJua63gLA.png?q=20" width="128" height="128" role="presentation"></p><p><img width="128" height="128" role="presentation"></p></div></div></div><figcaption data-selectable-paragraph=""><a href="https://github.com/App-vNext/Polly" target="_blank" rel="noopener nofollow">https://github.com/App-vNext/Polly</a></figcaption></figure><p id="2274" data-selectable-paragraph="">While we were performing this cleanup, we took a look at our classes responsible for making these dependency calls that were spiking in response duration randomly, to see if there was anything here that we’d missed.</p><p id="fa85" data-selectable-paragraph="">Now we use a popular library called Polly — It helps you easily control tasks such as timeouts, retrying failed code, and some other powerful functionality.</p><p id="b0a6" data-selectable-paragraph="">Polly, for these dependency calls, was set up to:</p><ul><li id="83dd" data-selectable-paragraph="">Timeout after 30 seconds</li><li id="cbd1" data-selectable-paragraph="">Retry three times if the request fails (this can include failing due to the timeout)</li><li id="2270" data-selectable-paragraph="">If it failed after three times, throw an exception back to our application so that we can return an error on our API response</li></ul><p id="d985" data-selectable-paragraph="">So if it’s timing out after 30 seconds, we shouldn’t see that request taking any longer, right?</p><p id="659b" data-selectable-paragraph="">In our monitoring, we saw some requests taking over 10 minutes!</p><p id="a182" data-selectable-paragraph="">We did a form of chaos testing where we forced a request to be slow by using a middleman proxy. After some testing and debugging with this configured delay, we were behaving as expected — we were definitely timing out and returning an error due to the call failing within our configured timeout duration.</p><p id="eb19" data-selectable-paragraph="">Back to the Polly documentation, and this important piece of information stuck out:</p><blockquote><p id="8615" data-selectable-paragraph="">Polly will not risk the state of your application by unilaterally terminating threads.</p></blockquote><p id="7f56" data-selectable-paragraph="">So even though Polly had dealt with timing out that request and resuming our application, that request was still sitting on a thread somewhere in the background of our application, running until it itself received a response. This was unwanted and unnecessary behaviour. That dependency call is no longer tied to an incoming request to our API. This means that if it does eventually return successfully, it doesn’t actually return to the request that initiated it, so it was wasting resources — it was a completely wasted connection.</p><p id="9bf3" data-selectable-paragraph="">Polly states this about connections:</p><blockquote><p id="9264" data-selectable-paragraph="">Waiting forever (having no timeout) is a bad design strategy: it specifically leads to the blocking up of threads or connections (itself often a cause of further failure)</p></blockquote><p id="b437" data-selectable-paragraph="">If this dependency call times out, we needed to proactively cancel them to prevent them from running in the background and wasting our application’s resources.</p><p id="527c" data-selectable-paragraph="">The change was surprisingly simple, as Polly has an implementation to easily deal with cancellations.</p><p id="a17b" data-selectable-paragraph="">The changes required:</p><ol><li id="5fe9" data-selectable-paragraph="">When declaring our Polly timeout policy, we must set the <code>TimeoutStrategy</code> to <code>Optimistic</code> (Optimistic should only be used for code that honours a CancellationToken).</li><li id="1787" data-selectable-paragraph="">When executing our request from the Polly policy, we should use the overloaded method that takes a cancellation token.</li></ol><p id="d352" data-selectable-paragraph="">The timeout policy looks as simple as:</p><figure><div></div><figcaption>The Policy Timeout</figcaption></figure><p id="397a" data-selectable-paragraph="">And our request changed from</p><figure><div></div><figcaption>How to not make requests (no cancellation tokens!)</figcaption></figure><p id="5a3b" data-selectable-paragraph="">to</p><figure><div></div><figcaption>How to make requests by passing in a Cancellation Token</figcaption></figure><p id="e412" data-selectable-paragraph="">(That <code>CancellationToken.None</code> can also be your own <code>CancellationToken</code>)</p><p id="246d" data-selectable-paragraph="">To explain what’s happening:</p><ul><li id="4766" data-selectable-paragraph="">We’re passing in a <code>CancellationToken</code>(or none) to the Polly Policy and the Polly Policy passes us another <code>CancellationToken</code> in a lambda. This is important, as this is the token we should pass into our executable code.</li><li id="3296" data-selectable-paragraph="">Polly internally is creating its own <code>CancellationTokenSource,</code>linking that to the <code>CancellationToken</code> that you pass in and then passing that newly created token back to you.</li><li id="eb49" data-selectable-paragraph="">If you cancel your original token passed in, the request will cancel (because they’re linked).</li></ul><p id="4c25" data-selectable-paragraph="">If the request times out, Polly has its own <code>CancellationTokenSource</code> available to cancel the token and the request will also cancel.</p><p id="bde3" data-selectable-paragraph="">Since we’ve released these changes, we cannot see any dependency calls over 30 seconds, meaning they’re successfully being cancelled by Polly, resulting in no connections being unnecessarily wasted.</p><p id="534a" data-selectable-paragraph="">We’re seeing much less spiking in general as well, most likely due to the fact that we’re not making blocking calls anymore — there are threads available to pick up work whereas before they weren’t always available.</p><p id="fb41" data-selectable-paragraph="">This is great — as before we were randomly receiving alerts every single day. Performance has definitely improved and our application monitoring is proof of this.</p><p id="0be3" data-selectable-paragraph="">The BlockingDetection we have left in our application is turned on only for our test environments. This means that going forward we can be confident that we won’t introduce any more blocking calls if we keep monitoring these, and will raise and fix what we do find.</p><p id="5793" data-selectable-paragraph="">Async calls must be used wherever possible to avoid thread pool starvation.</p><p id="3f14" data-selectable-paragraph="">As for long-running dependency calls, we now know that we need to provide cancellation support where appropriate, with the implementation in place of timing out and cancelling those tokens.</p><p id="0963" data-selectable-paragraph="">These best practices help ensure that we have a performant application and that we shouldn’t run into these issues again.</p></div></div></section></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>