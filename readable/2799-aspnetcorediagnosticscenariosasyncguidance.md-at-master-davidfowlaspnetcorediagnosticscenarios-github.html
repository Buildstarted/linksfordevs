<!DOCTYPE html>
<html lang="en">
<head>
    <title>
AspNetCoreDiagnosticScenarios/AsyncGuidance.md at master &#xB7; davidfowl/AspNetCoreDiagnosticScenarios &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>AspNetCoreDiagnosticScenarios/AsyncGuidance.md at master · davidfowl/AspNetCoreDiagnosticScenarios · GitHub</h1><div><div id="" class="markdown-body entry-content p-3 p-md-6"><h1><a id="user-content-table-of-contents" class="anchor" aria-hidden="true" href="#table-of-contents"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Table of contents</h1><h1><a id="user-content-asynchronous-programming" class="anchor" aria-hidden="true" href="#asynchronous-programming"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Asynchronous Programming</h1><p>Asynchronous programming has been around for several years on the .NET platform but has historically been very difficult to do well. Since the introduction of async/await
in C# 5 asynchronous programming has become mainstream. Modern frameworks (like ASP.NET Core) are fully asynchronous and it's very hard to avoid the async keyword when writing
web services. As a result, there's been lots of confusion on the best practices for async and how to use it properly. This section will try to lay out some guidance with examples of bad and good patterns of how to write asynchronous code.</p><h2><a id="user-content-asynchrony-is-viral" class="anchor" aria-hidden="true" href="#asynchrony-is-viral"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Asynchrony is viral</h2><p>Once you go async, all of your callers <strong>SHOULD</strong> be async, since efforts to be async amount to nothing unless the entire callstack is async. In many cases, being partially async can be worse than being entirely synchronous. Therefore it is best to go all in, and make everything async at once.</p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example uses the <code>Task.Result</code> and as a result blocks the current thread to wait for the result. This is an example of <a href="#avoid-using-taskresult-and-taskwait">sync over async</a>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">DoSomethingAsync</span>()
{
    <span class="pl-k">var</span><span class="pl-smi">result</span><span class="pl-k">=</span><span class="pl-en">CallDependencyAsync</span>().<span class="pl-smi">Result</span>;
    <span class="pl-k">return</span><span class="pl-smi">result</span><span class="pl-k">+</span><span class="pl-c1">1</span>;
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example uses the await keyword to get the result from <code>CallDependencyAsync</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">DoSomethingAsync</span>()
{
    <span class="pl-k">var</span><span class="pl-smi">result</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-en">CallDependencyAsync</span>();
    <span class="pl-k">return</span><span class="pl-smi">result</span><span class="pl-k">+</span><span class="pl-c1">1</span>;
}</pre></div><h2><a id="user-content-async-void" class="anchor" aria-hidden="true" href="#async-void"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Async void</h2><p>Use of async void in ASP.NET Core applications is <strong>ALWAYS</strong> bad. Avoid it, never do it. Typically, it's used when developers are trying to implement fire and forget patterns triggered by a controller action. Async void methods will crash the process if an exception is thrown. We'll look at more of the patterns that cause developers to do this in ASP.NET Core applications but here's a simple example:</p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> Async void methods can't be tracked and therefore unhandled exceptions can result in application crashes.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">MyController</span> : <span class="pl-en">Controller</span>
{
    [<span class="pl-en">HttpPost</span>(<span class="pl-s"><span class="pl-pds">"</span>/start<span class="pl-pds">"</span></span>)]
    <span class="pl-k">public</span><span class="pl-en">IActionResult</span><span class="pl-en">Post</span>()
    {
        <span class="pl-en">BackgroundOperationAsync</span>();
        <span class="pl-k">return</span><span class="pl-en">Accepted</span>();
    }
    
    <span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-k">void</span><span class="pl-en">BackgroundOperationAsync</span>()
    {
        <span class="pl-k">var</span><span class="pl-smi">result</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-en">CallDependencyAsync</span>();
        <span class="pl-en">DoSomething</span>(<span class="pl-smi">result</span>);
    }
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong><code>Task</code>-returning methods are better since unhandled exceptions trigger the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler.unobservedtaskexception?view=netframework-4.7.2" rel="nofollow"><code>TaskScheduler.UnobservedTaskException</code></a>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">MyController</span> : <span class="pl-en">Controller</span>
{
    [<span class="pl-en">HttpPost</span>(<span class="pl-s"><span class="pl-pds">"</span>/start<span class="pl-pds">"</span></span>)]
    <span class="pl-k">public</span><span class="pl-en">IActionResult</span><span class="pl-en">Post</span>()
    {
        <span class="pl-smi">Task</span>.<span class="pl-en">Run</span>(<span class="pl-smi">BackgroundOperationAsync</span>);
        <span class="pl-k">return</span><span class="pl-en">Accepted</span>();
    }
    
    <span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span><span class="pl-en">BackgroundOperationAsync</span>()
    {
        <span class="pl-k">var</span><span class="pl-smi">result</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-en">CallDependencyAsync</span>();
        <span class="pl-en">DoSomething</span>(<span class="pl-smi">result</span>);
    }
}</pre></div><h2><a id="user-content-prefer-taskfromresult-over-taskrun-for-pre-computed-or-trivially-computed-data" class="anchor" aria-hidden="true" href="#prefer-taskfromresult-over-taskrun-for-pre-computed-or-trivially-computed-data"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefer <code>Task.FromResult</code> over <code>Task.Run</code> for pre-computed or trivially computed data</h2><p>For pre-computed results, there's no need to call <code>Task.Run</code>, that will end up queuing a work item to the thread pool that will immediately complete with the pre-computed value. Instead, use <code>Task.FromResult</code>, to create a task wrapping already computed data.</p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example wastes a thread-pool thread to return a trivially computed value.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">MyLibrary</span>
{
   <span class="pl-k">public</span><span class="pl-en">Task</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">AddAsync</span>(<span class="pl-k">int</span><span class="pl-smi">a</span>, <span class="pl-k">int</span><span class="pl-smi">b</span>)
   {
       <span class="pl-k">return</span><span class="pl-smi">Task</span>.<span class="pl-en">Run</span>(() <span class="pl-k">=&gt;</span><span class="pl-smi">a</span><span class="pl-k">+</span><span class="pl-smi">b</span>);
   }
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example uses <code>Task.FromResult</code> to return the trivially computed value. It does not use any extra threads as a result.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">MyLibrary</span>
{
   <span class="pl-k">public</span><span class="pl-en">Task</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">AddAsync</span>(<span class="pl-k">int</span><span class="pl-smi">a</span>, <span class="pl-k">int</span><span class="pl-smi">b</span>)
   {
       <span class="pl-k">return</span><span class="pl-smi">Task</span>.<span class="pl-en">FromResult</span>(<span class="pl-smi">a</span><span class="pl-k">+</span><span class="pl-smi">b</span>);
   }
}</pre></div><p><g-emoji class="g-emoji" alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">💡</g-emoji><strong>NOTE: Using <code>Task.FromResult</code> will result in a <code>Task</code> allocation. Using <code>ValueTask&lt;T&gt;</code> can completely remove that allocation.</strong></p><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example uses a <code>ValueTask&lt;int&gt;</code> to return the trivially computed value. It does not use any extra threads as a result. It also does not allocate an object on the managed heap.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">MyLibrary</span>
{
   <span class="pl-k">public</span><span class="pl-en">ValueTask</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">AddAsync</span>(<span class="pl-k">int</span><span class="pl-smi">a</span>, <span class="pl-k">int</span><span class="pl-smi">b</span>)
   {
       <span class="pl-k">return</span><span class="pl-k">new</span><span class="pl-en">ValueTask</span>&lt;<span class="pl-k">int</span>&gt;(<span class="pl-smi">a</span><span class="pl-k">+</span><span class="pl-smi">b</span>);
   }
}</pre></div><h2><a id="user-content-avoid-using-taskrun-for-long-running-work-that-blocks-the-thread" class="anchor" aria-hidden="true" href="#avoid-using-taskrun-for-long-running-work-that-blocks-the-thread"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avoid using Task.Run for long running work that blocks the thread</h2><p>Long running work in this context refers to a thread that's running for the lifetime of the application doing background work (like processing queue items, or sleeping and waking up to process some data). <code>Task.Run</code> will queue a work item to the thread pool. The assumption is that that work will finish quickly (or quickly enough to allow reusing that thread within some reasonable timeframe). Stealing a thread-pool thread for long-running work is bad since it takes that thread away from other work that could be done (timer callbacks, task continuations etc). Instead, spawn a new thread manually to do long running blocking work.</p><p><g-emoji class="g-emoji" alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">💡</g-emoji><strong>NOTE: The thread pool grows if you block threads but it's bad practice to do so.</strong></p><p><g-emoji class="g-emoji" alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">💡</g-emoji><strong>NOTE:<code>Task.Factory.StartNew</code> has an option <code>TaskCreationOptions.LongRunning</code> that under the covers creates a new thread and returns a Task that represents the execution. Using this properly requires several non-obvious parameters to be passed in to get the right behavior on all platforms.</strong></p><p><g-emoji class="g-emoji" alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">💡</g-emoji><strong>NOTE: Don't use <code>TaskCreationOptions.LongRunning</code> with async code as this will create a new thread which will be destroyed after first <code>await</code>.</strong></p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example steals a thread-pool thread forever, to execute queued work on a <code>BlockingCollection&lt;T&gt;</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">QueueProcessor</span>
{
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">BlockingCollection</span>&lt;<span class="pl-en">Message</span>&gt; <span class="pl-smi">_messageQueue</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">BlockingCollection</span>&lt;<span class="pl-en">Message</span>&gt;();
    
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">StartProcessing</span>()
    {
        <span class="pl-smi">Task</span>.<span class="pl-en">Run</span>(<span class="pl-smi">ProcessQueue</span>);
    }
    
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Enqueue</span>(<span class="pl-en">Message</span><span class="pl-smi">message</span>)
    {
        <span class="pl-smi">_messageQueue</span>.<span class="pl-en">Add</span>(<span class="pl-smi">message</span>);
    }
    
    <span class="pl-k">private</span><span class="pl-k">void</span><span class="pl-en">ProcessQueue</span>()
    {
        <span class="pl-k">foreach</span> (<span class="pl-k">var</span><span class="pl-smi">item</span><span class="pl-k">in</span><span class="pl-smi">_messageQueue</span>.<span class="pl-en">GetConsumingEnumerable</span>())
        {
             <span class="pl-en">ProcessItem</span>(<span class="pl-smi">item</span>);
        }
    }
    
    <span class="pl-k">private</span><span class="pl-k">void</span><span class="pl-en">ProcessItem</span>(<span class="pl-en">Message</span><span class="pl-smi">message</span>) { }
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example uses a dedicated thread to process the message queue instead of a thread-pool thread.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">QueueProcessor</span>
{
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">BlockingCollection</span>&lt;<span class="pl-en">Message</span>&gt; <span class="pl-smi">_messageQueue</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">BlockingCollection</span>&lt;<span class="pl-en">Message</span>&gt;();
    
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">StartProcessing</span>()
    {
        <span class="pl-k">var</span><span class="pl-smi">thread</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Thread</span>(<span class="pl-smi">ProcessQueue</span>) 
        {
            <span class="pl-c"><span class="pl-c">//</span> This is important as it allows the process to exit while this thread is running</span><span class="pl-smi">IsBackground</span><span class="pl-k">=</span><span class="pl-c1">true</span>
        };
        <span class="pl-smi">thread</span>.<span class="pl-en">Start</span>();
    }
    
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Enqueue</span>(<span class="pl-en">Message</span><span class="pl-smi">message</span>)
    {
        <span class="pl-smi">_messageQueue</span>.<span class="pl-en">Add</span>(<span class="pl-smi">message</span>);
    }
    
    <span class="pl-k">private</span><span class="pl-k">void</span><span class="pl-en">ProcessQueue</span>()
    {
        <span class="pl-k">foreach</span> (<span class="pl-k">var</span><span class="pl-smi">item</span><span class="pl-k">in</span><span class="pl-smi">_messageQueue</span>.<span class="pl-en">GetConsumingEnumerable</span>())
        {
             <span class="pl-en">ProcessItem</span>(<span class="pl-smi">item</span>);
        }
    }
    
    <span class="pl-k">private</span><span class="pl-k">void</span><span class="pl-en">ProcessItem</span>(<span class="pl-en">Message</span><span class="pl-smi">message</span>) { }
}</pre></div><h2><a id="user-content-avoid-using-taskresult-and-taskwait" class="anchor" aria-hidden="true" href="#avoid-using-taskresult-and-taskwait"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avoid using <code>Task.Result</code> and <code>Task.Wait</code></h2><p>There are very few ways to use <code>Task.Result</code> and <code>Task.Wait</code> correctly so the general advice is to completely avoid using them in your code.</p><h3><a id="user-content-warning-sync-over-async" class="anchor" aria-hidden="true" href="#warning-sync-over-async"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><g-emoji class="g-emoji" alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">⚠️</g-emoji> Sync over <code>async</code></h3><p>Using <code>Task.Result</code> or <code>Task.Wait</code> to block wait on an asynchronous operation to complete is <em>MUCH</em> worse than calling a truly synchronous API to block. This phenomenon is dubbed "Sync over async". Here is what happens at a very high level:</p><ul><li>An asynchronous operation is kicked off.</li><li>The calling thread is blocked waiting for that operation to complete.</li><li>When the asynchronous operation completes, it unblocks the code waiting on that operation. This takes place on another thread.</li></ul><p>The result is that we need to use 2 threads instead of 1 to complete synchronous operations. This usually leads to <a href="https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/" rel="nofollow">thread-pool starvation</a> and results in service outages.</p><h3><a id="user-content-warning-deadlocks" class="anchor" aria-hidden="true" href="#warning-deadlocks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><g-emoji class="g-emoji" alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">⚠️</g-emoji> Deadlocks</h3><p>The <code>SynchronizationContext</code> is an abstraction that gives application models a chance to control where asynchronous continuations run. ASP.NET (non-core), WPF and Windows Forms each have an implementation that will result in a deadlock if Task.Wait or Task.Result is used on the main thread. This behavior has led to a bunch of "clever" code snippets that show the "right" way to block waiting for a Task. The truth is, there's no good way to block waiting for a Task to complete.</p><p><g-emoji class="g-emoji" alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">💡</g-emoji><strong>NOTE: ASP.NET Core does not have a <code>SynchronizationContext</code> and is not prone to the deadlock problem.</strong></p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> The below are all examples that are, in one way or another, trying to avoid the deadlock situation but still succumb to "sync over async" problems.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-en">DoOperationBlocking</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Bad - Blocking the thread that enters.</span><span class="pl-c"><span class="pl-c">//</span> DoAsyncOperation will be scheduled on the default task scheduler, and remove the risk of deadlocking.</span><span class="pl-c"><span class="pl-c">//</span> In the case of an exception, this method will throw an AggregateException wrapping the original exception.</span><span class="pl-k">return</span><span class="pl-smi">Task</span>.<span class="pl-en">Run</span>(() <span class="pl-k">=&gt;</span><span class="pl-en">DoAsyncOperation</span>()).<span class="pl-smi">Result</span>;
}

<span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-en">DoOperationBlocking2</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Bad - Blocking the thread that enters.</span><span class="pl-c"><span class="pl-c">//</span> DoAsyncOperation will be scheduled on the default task scheduler, and remove the risk of deadlocking.</span><span class="pl-k">return</span><span class="pl-smi">Task</span>.<span class="pl-en">Run</span>(() <span class="pl-k">=&gt;</span><span class="pl-en">DoAsyncOperation</span>()).<span class="pl-en">GetAwaiter</span>().<span class="pl-en">GetResult</span>();
}

<span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-en">DoOperationBlocking3</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Bad - Blocking the thread that enters, and blocking the theadpool thread inside.</span><span class="pl-c"><span class="pl-c">//</span> In the case of an exception, this method will throw an AggregateException containing another AggregateException, containing the original exception.</span><span class="pl-k">return</span><span class="pl-smi">Task</span>.<span class="pl-en">Run</span>(() <span class="pl-k">=&gt;</span><span class="pl-en">DoAsyncOperation</span>().<span class="pl-smi">Result</span>).<span class="pl-smi">Result</span>;
}

<span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-en">DoOperationBlocking4</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Bad - Blocking the thread that enters, and blocking the theadpool thread inside.</span><span class="pl-k">return</span><span class="pl-smi">Task</span>.<span class="pl-en">Run</span>(() <span class="pl-k">=&gt;</span><span class="pl-en">DoAsyncOperation</span>().<span class="pl-en">GetAwaiter</span>().<span class="pl-en">GetResult</span>()).<span class="pl-en">GetAwaiter</span>().<span class="pl-en">GetResult</span>();
}

<span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-en">DoOperationBlocking5</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Bad - Blocking the thread that enters.</span><span class="pl-c"><span class="pl-c">//</span> Bad - No effort has been made to prevent a present SynchonizationContext from becoming deadlocked.</span><span class="pl-c"><span class="pl-c">//</span> In the case of an exception, this method will throw an AggregateException wrapping the original exception.</span><span class="pl-k">return</span><span class="pl-en">DoAsyncOperation</span>().<span class="pl-smi">Result</span>;
}

<span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-en">DoOperationBlocking6</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Bad - Blocking the thread that enters.</span><span class="pl-c"><span class="pl-c">//</span> Bad - No effort has been made to prevent a present SynchonizationContext from becoming deadlocked.</span><span class="pl-k">return</span><span class="pl-en">DoAsyncOperation</span>().<span class="pl-en">GetAwaiter</span>().<span class="pl-en">GetResult</span>();
}

<span class="pl-k">public</span><span class="pl-k">string</span><span class="pl-en">DoOperationBlocking7</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Bad - Blocking the thread that enters.</span><span class="pl-c"><span class="pl-c">//</span> Bad - No effort has been made to prevent a present SynchonizationContext from becoming deadlocked.</span><span class="pl-k">var</span><span class="pl-smi">task</span><span class="pl-k">=</span><span class="pl-en">DoAsyncOperation</span>();
    <span class="pl-smi">task</span>.<span class="pl-en">Wait</span>();
    <span class="pl-k">return</span><span class="pl-smi">task</span>.<span class="pl-en">GetAwaiter</span>().<span class="pl-en">GetResult</span>();
}</pre></div><h2><a id="user-content-prefer-await-over-continuewith" class="anchor" aria-hidden="true" href="#prefer-await-over-continuewith"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefer <code>await</code> over <code>ContinueWith</code></h2><p><code>Task</code> existed before the async/await keywords were introduced and as such provided ways to execute continuations without relying on the language. Although these methods are still valid to use, we generally recommend that you prefer <code>async</code>/<code>await</code> to using <code>ContinueWith</code>. <code>ContinueWith</code> also does not capture the <code>SynchronizationContext</code> and as a result is actually semantically different to <code>async</code>/<code>await</code>.</p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> The example uses <code>ContinueWith</code> instead of <code>async</code></p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-en">Task</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">DoSomethingAsync</span>()
{
    <span class="pl-k">return</span><span class="pl-en">CallDependencyAsync</span>().<span class="pl-en">ContinueWith</span>(<span class="pl-smi">task</span><span class="pl-k">=&gt;</span>
    {
        <span class="pl-k">return</span><span class="pl-smi">task</span>.<span class="pl-smi">Result</span><span class="pl-k">+</span><span class="pl-c1">1</span>;
    });
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example uses the <code>await</code> keyword to get the result from <code>CallDependencyAsync</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">DoSomethingAsync</span>()
{
    <span class="pl-k">var</span><span class="pl-smi">result</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-en">CallDependencyAsync</span>();
    <span class="pl-k">return</span><span class="pl-smi">result</span><span class="pl-k">+</span><span class="pl-c1">1</span>;
}</pre></div><h2><a id="user-content-always-create-taskcompletionsourcet-with-taskcreationoptionsruncontinuationsasynchronously" class="anchor" aria-hidden="true" href="#always-create-taskcompletionsourcet-with-taskcreationoptionsruncontinuationsasynchronously"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Always create <code>TaskCompletionSource&lt;T&gt;</code> with <code>TaskCreationOptions.RunContinuationsAsynchronously</code></h2><p><code>TaskCompletionSource&lt;T&gt;</code> is an important building block for libraries trying to adapt things that are not inherently awaitable to be awaitable via a <code>Task</code>. It is also commonly used to build higher-level operations (such as batching and other combinators) on top of existing asynchronous APIs. By default, <code>Task</code> continuations will run <em>inline</em> on the same thread that calls Try/Set(Result/Exception/Canceled). As a library author, this means having to understand that calling code can resume directly on your thread. This is extremely dangerous and can result in deadlocks, thread-pool starvation, corruption of state (if code runs unexpectedly) and more.</p><p>Always use <code>TaskCreationOptions.RunContinuationsAsynchronously</code> when creating the <code>TaskCompletionSource&lt;T&gt;</code>. This will dispatch the continuation onto the thread pool instead of executing it inline.</p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example does not use <code>TaskCreationOptions.RunContinuationsAsynchronously</code> when creating the <code>TaskCompletionSource&lt;T&gt;</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-en">Task</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">DoSomethingAsync</span>()
{
    <span class="pl-k">var</span><span class="pl-smi">tcs</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">TaskCompletionSource</span>&lt;<span class="pl-k">int</span>&gt;();
    
    <span class="pl-k">var</span><span class="pl-smi">operation</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">LegacyAsyncOperation</span>();
    <span class="pl-smi">operation</span>.<span class="pl-smi">Completed</span><span class="pl-k">+=</span><span class="pl-smi">result</span><span class="pl-k">=&gt;</span>
    {
        <span class="pl-c"><span class="pl-c">//</span> Code awaiting on this task will resume on this thread!</span><span class="pl-smi">tcs</span>.<span class="pl-en">SetResult</span>(<span class="pl-smi">result</span>);
    };
    
    <span class="pl-k">return</span><span class="pl-smi">tcs</span>.<span class="pl-smi">Task</span>;
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example uses <code>TaskCreationOptions.RunContinuationsAsynchronously</code> when creating the <code>TaskCompletionSource&lt;T&gt;</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-en">Task</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">DoSomethingAsync</span>()
{
    <span class="pl-k">var</span><span class="pl-smi">tcs</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">TaskCompletionSource</span>&lt;<span class="pl-k">int</span>&gt;(<span class="pl-smi">TaskCreationOptions</span>.<span class="pl-smi">RunContinuationsAsynchronously</span>);
    
    <span class="pl-k">var</span><span class="pl-smi">operation</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">LegacyAsyncOperation</span>();
    <span class="pl-smi">operation</span>.<span class="pl-smi">Completed</span><span class="pl-k">+=</span><span class="pl-smi">result</span><span class="pl-k">=&gt;</span>
    {
        <span class="pl-c"><span class="pl-c">//</span> Code awaiting on this task will resume on a different thread-pool thread</span><span class="pl-smi">tcs</span>.<span class="pl-en">SetResult</span>(<span class="pl-smi">result</span>);
    };
    
    <span class="pl-k">return</span><span class="pl-smi">tcs</span>.<span class="pl-smi">Task</span>;
}</pre></div><p><g-emoji class="g-emoji" alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">💡</g-emoji><strong>NOTE: There are 2 enums that look alike. <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcreationoptions?view=netcore-2.0#System_Threading_Tasks_TaskCreationOptions_RunContinuationsAsynchronously" rel="nofollow"><code>TaskCreationOptions.RunContinuationsAsynchronously</code></a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=netcore-2.0" rel="nofollow"><code>TaskContinuationOptions.RunContinuationsAsynchronously</code></a>. Be careful not to confuse their usage.</strong></p><h2><a id="user-content-always-dispose-cancellationtokensources-used-for-timeouts" class="anchor" aria-hidden="true" href="#always-dispose-cancellationtokensources-used-for-timeouts"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Always dispose <code>CancellationTokenSource</code>(s) used for timeouts</h2><p><code>CancellationTokenSource</code> objects that are used for timeouts (are created with timers or uses the <code>CancelAfter</code> method), can put pressure on the timer queue if not disposed.</p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example does not dispose the <code>CancellationTokenSource</code> and as a result the timer stays in the queue for 10 seconds after each request is made.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-en">Stream</span>&gt; <span class="pl-en">HttpClientAsyncWithCancellationBad</span>()
{
    <span class="pl-k">var</span><span class="pl-smi">cts</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">CancellationTokenSource</span>(<span class="pl-smi">TimeSpan</span>.<span class="pl-en">FromSeconds</span>(<span class="pl-c1">10</span>));

    <span class="pl-k">using</span> (<span class="pl-k">var</span><span class="pl-smi">client</span><span class="pl-k">=</span><span class="pl-smi">_httpClientFactory</span>.<span class="pl-en">CreateClient</span>())
    {
        <span class="pl-k">var</span><span class="pl-smi">response</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-smi">client</span>.<span class="pl-en">GetAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>http://backend/api/1<span class="pl-pds">"</span></span>, <span class="pl-smi">cts</span>.<span class="pl-smi">Token</span>);
        <span class="pl-k">return</span><span class="pl-k">await</span><span class="pl-smi">response</span>.<span class="pl-smi">Content</span>.<span class="pl-en">ReadAsStreamAsync</span>();
    }
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example disposes the <code>CancellationTokenSource</code> and properly removes the timer from the queue.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-en">Stream</span>&gt; <span class="pl-en">HttpClientAsyncWithCancellationGood</span>()
{
    <span class="pl-k">using</span> (<span class="pl-k">var</span><span class="pl-smi">cts</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">CancellationTokenSource</span>(<span class="pl-smi">TimeSpan</span>.<span class="pl-en">FromSeconds</span>(<span class="pl-c1">10</span>)))
    {
        <span class="pl-k">using</span> (<span class="pl-k">var</span><span class="pl-smi">client</span><span class="pl-k">=</span><span class="pl-smi">_httpClientFactory</span>.<span class="pl-en">CreateClient</span>())
        {
            <span class="pl-k">var</span><span class="pl-smi">response</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-smi">client</span>.<span class="pl-en">GetAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>http://backend/api/1<span class="pl-pds">"</span></span>, <span class="pl-smi">cts</span>.<span class="pl-smi">Token</span>);
            <span class="pl-k">return</span><span class="pl-k">await</span><span class="pl-smi">response</span>.<span class="pl-smi">Content</span>.<span class="pl-en">ReadAsStreamAsync</span>();
        }
    }
}</pre></div><h2><a id="user-content-always-flow-cancellationtokens-to-apis-that-take-a-cancellationtoken" class="anchor" aria-hidden="true" href="#always-flow-cancellationtokens-to-apis-that-take-a-cancellationtoken"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Always flow <code>CancellationToken</code>(s) to APIs that take a <code>CancellationToken</code></h2><p>Cancellation is cooperative in .NET. Everything in the call-chain has to be explicitly passed the <code>CancellationToken</code> in order for it to work well. This means you need to explicitly pass the token into other APIs that take a token if you want cancellation to be most effective.</p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example neglects to pass the <code>CancellationToken</code> to <code>Stream.ReadAsync</code> making the operation effectively not cancellable.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-k">string</span>&gt; <span class="pl-en">DoAsyncThing</span>(<span class="pl-en">CancellationToken</span><span class="pl-smi">cancellationToken</span><span class="pl-k">=</span><span class="pl-smi">default</span>)
{
   <span class="pl-k">byte</span>[] <span class="pl-smi">buffer</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">byte</span>[<span class="pl-c1">1024</span>];
   <span class="pl-c"><span class="pl-c">//</span> We forgot to pass flow cancellationToken to ReadAsync</span><span class="pl-k">int</span><span class="pl-smi">read</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-smi">_stream</span>.<span class="pl-en">ReadAsync</span>(<span class="pl-smi">buffer</span>, <span class="pl-c1">0</span>, <span class="pl-smi">buffer</span>.<span class="pl-smi">Length</span>);
   <span class="pl-k">return</span><span class="pl-smi">Encoding</span>.<span class="pl-smi">UTF8</span>.<span class="pl-en">GetString</span>(<span class="pl-smi">buffer</span>, <span class="pl-c1">0</span>, <span class="pl-smi">read</span>);
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example passes the <code>CancellationToken</code> into <code>Stream.ReadAsync</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-k">string</span>&gt; <span class="pl-en">DoAsyncThing</span>(<span class="pl-en">CancellationToken</span><span class="pl-smi">cancellationToken</span><span class="pl-k">=</span><span class="pl-smi">default</span>)
{
   <span class="pl-k">byte</span>[] <span class="pl-smi">buffer</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">byte</span>[<span class="pl-c1">1024</span>];
   <span class="pl-c"><span class="pl-c">//</span> This properly flows cancellationToken to ReadAsync</span><span class="pl-k">int</span><span class="pl-smi">read</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-smi">_stream</span>.<span class="pl-en">ReadAsync</span>(<span class="pl-smi">buffer</span>, <span class="pl-c1">0</span>, <span class="pl-smi">buffer</span>.<span class="pl-smi">Length</span>, <span class="pl-smi">cancellationToken</span>);
   <span class="pl-k">return</span><span class="pl-smi">Encoding</span>.<span class="pl-smi">UTF8</span>.<span class="pl-en">GetString</span>(<span class="pl-smi">buffer</span>, <span class="pl-c1">0</span>, <span class="pl-smi">read</span>);
}</pre></div><h2><a id="user-content-cancelling-uncancellable-operations" class="anchor" aria-hidden="true" href="#cancelling-uncancellable-operations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cancelling uncancellable operations</h2><p>One of the coding patterns that appears when doing asynchronous programming is cancelling an uncancellable operation. This usually means creating another task that completes when a timeout or <code>CancellationToken</code> fires, and then using <code>Task.WhenAny</code> to detect a complete or cancelled operation.</p><h3><a id="user-content-using-cancellationtokens" class="anchor" aria-hidden="true" href="#using-cancellationtokens"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using CancellationTokens</h3><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example uses <code>Task.Delay(-1, token)</code> to create a <code>Task</code> that completes when the <code>CancellationToken</code> fires, but if it doesn't fire, there's no way to dispose the <code>CancellationTokenRegistration</code>. This can lead to a memory leak.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-en">WithCancellation</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-k">this</span><span class="pl-en">Task</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">task</span>, <span class="pl-en">CancellationToken</span><span class="pl-smi">cancellationToken</span>)
{
    <span class="pl-c"><span class="pl-c">//</span> There's no way to dispose the registration</span><span class="pl-k">var</span><span class="pl-smi">delayTask</span><span class="pl-k">=</span><span class="pl-smi">Task</span>.<span class="pl-en">Delay</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-smi">cancellationToken</span>);

    <span class="pl-k">var</span><span class="pl-smi">resultTask</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-smi">Task</span>.<span class="pl-en">WhenAny</span>(<span class="pl-smi">task</span>, <span class="pl-smi">delayTask</span>);
    <span class="pl-k">if</span> (<span class="pl-smi">resultTask</span><span class="pl-k">==</span><span class="pl-smi">delayTask</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> Operation cancelled</span><span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">OperationCanceledException</span>();
    }

    <span class="pl-k">return</span><span class="pl-k">await</span><span class="pl-smi">task</span>;
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example disposes the <code>CancellationTokenRegistration</code> when one of the <code>Task(s)</code> complete.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-en">WithCancellation</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-k">this</span><span class="pl-en">Task</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">task</span>, <span class="pl-en">CancellationToken</span><span class="pl-smi">cancellationToken</span>)
{
    <span class="pl-k">var</span><span class="pl-smi">tcs</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">TaskCompletionSource</span>&lt;<span class="pl-k">object</span>&gt;(<span class="pl-smi">TaskCreationOptions</span>.<span class="pl-smi">RunContinuationsAsynchronously</span>);

    <span class="pl-c"><span class="pl-c">//</span> This disposes the registration as soon as one of the tasks trigger</span><span class="pl-k">using</span> (<span class="pl-smi">cancellationToken</span>.<span class="pl-en">Register</span>(<span class="pl-smi">state</span><span class="pl-k">=&gt;</span>
    {
        ((<span class="pl-en">TaskCompletionSource</span>&lt;<span class="pl-k">object</span>&gt;)<span class="pl-smi">state</span>).<span class="pl-en">TrySetResult</span>(<span class="pl-c1">null</span>);
    },
    <span class="pl-smi">tcs</span>))
    {
        <span class="pl-k">var</span><span class="pl-smi">resultTask</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-smi">Task</span>.<span class="pl-en">WhenAny</span>(<span class="pl-smi">task</span>, <span class="pl-smi">tcs</span>.<span class="pl-smi">Task</span>);
        <span class="pl-k">if</span> (<span class="pl-smi">resultTask</span><span class="pl-k">==</span><span class="pl-smi">tcs</span>.<span class="pl-smi">Task</span>)
        {
            <span class="pl-c"><span class="pl-c">//</span> Operation cancelled</span><span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">OperationCanceledException</span>(<span class="pl-smi">cancellationToken</span>);
        }

        <span class="pl-k">return</span><span class="pl-k">await</span><span class="pl-smi">task</span>;
    }
}</pre></div><h3><a id="user-content-using-a-timeout" class="anchor" aria-hidden="true" href="#using-a-timeout"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using a timeout</h3><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example does not cancel the timer even if the operation successfuly completes. This means you could end up with lots of timers, which can flood the timer queue.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-en">TimeoutAfter</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-k">this</span><span class="pl-en">Task</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">task</span>, <span class="pl-en">TimeSpan</span><span class="pl-smi">timeout</span>)
{
    <span class="pl-k">var</span><span class="pl-smi">delayTask</span><span class="pl-k">=</span><span class="pl-smi">Task</span>.<span class="pl-en">Delay</span>(<span class="pl-smi">timeout</span>);

    <span class="pl-k">var</span><span class="pl-smi">resultTask</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-smi">Task</span>.<span class="pl-en">WhenAny</span>(<span class="pl-smi">task</span>, <span class="pl-smi">delayTask</span>);
    <span class="pl-k">if</span> (<span class="pl-smi">resultTask</span><span class="pl-k">==</span><span class="pl-smi">delayTask</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> Operation cancelled</span><span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">OperationCanceledException</span>();
    }

    <span class="pl-k">return</span><span class="pl-k">await</span><span class="pl-smi">task</span>;
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example cancels the timer if the operation succesfully completes.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-en">TimeoutAfter</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-k">this</span><span class="pl-en">Task</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">task</span>, <span class="pl-en">TimeSpan</span><span class="pl-smi">timeout</span>)
{
    <span class="pl-k">using</span> (<span class="pl-k">var</span><span class="pl-smi">cts</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">CancellationTokenSource</span>())
    {
        <span class="pl-k">var</span><span class="pl-smi">delayTask</span><span class="pl-k">=</span><span class="pl-smi">Task</span>.<span class="pl-en">Delay</span>(<span class="pl-smi">timeout</span>, <span class="pl-smi">cts</span>.<span class="pl-smi">Token</span>);

        <span class="pl-k">var</span><span class="pl-smi">resultTask</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-smi">Task</span>.<span class="pl-en">WhenAny</span>(<span class="pl-smi">task</span>, <span class="pl-smi">delayTask</span>);
        <span class="pl-k">if</span> (<span class="pl-smi">resultTask</span><span class="pl-k">==</span><span class="pl-smi">delayTask</span>)
        {
            <span class="pl-c"><span class="pl-c">//</span> Operation cancelled</span><span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">OperationCanceledException</span>();
        }
        <span class="pl-k">else</span>
        {
            <span class="pl-c"><span class="pl-c">//</span> Cancel the timer task so that it does not fire</span><span class="pl-smi">cts</span>.<span class="pl-en">Cancel</span>();
        }

        <span class="pl-k">return</span><span class="pl-k">await</span><span class="pl-smi">task</span>;
    }
}</pre></div><h2><a id="user-content-always-call-flushasync-on-streamwriters-or-streams-before-calling-dispose" class="anchor" aria-hidden="true" href="#always-call-flushasync-on-streamwriters-or-streams-before-calling-dispose"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Always call <code>FlushAsync</code> on <code>StreamWriter</code>(s) or <code>Stream</code>(s) before calling <code>Dispose</code></h2><p>When writing to a <code>Stream</code> or <code>StreamWriter</code>, even if the asynchronous overloads are used for writing, the underlying data might be buffered. When data is buffered, disposing the <code>Stream</code> or <code>StreamWriter</code> via the <code>Dispose</code> method will synchronously write/flush, which results in blocking the thread and could lead to thread-pool starvation. Either use the asynchronous <code>DisposeAsync</code> method (for example via <code>await using</code>) or call <code>FlushAsync</code> before calling <code>Dispose</code>.</p><p><g-emoji class="g-emoji" alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">💡</g-emoji><strong>NOTE: This is only problematic if the underlying subsystem does IO.</strong></p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example ends up blocking the request by writing synchronously to the HTTP-response body.</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">app</span>.<span class="pl-en">Run</span>(<span class="pl-k">async</span><span class="pl-smi">context</span><span class="pl-k">=&gt;</span>
{
    <span class="pl-c"><span class="pl-c">//</span> The implicit Dispose call will synchronously write to the response body</span><span class="pl-k">using</span> (<span class="pl-k">var</span><span class="pl-smi">streamWriter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StreamWriter</span>(<span class="pl-smi">context</span>.<span class="pl-smi">Response</span>.<span class="pl-smi">Body</span>))
    {
        <span class="pl-k">await</span><span class="pl-smi">streamWriter</span>.<span class="pl-en">WriteAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span>);
    }
});</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example asynchronously flushes any buffered data while disposing the <code>StreamWriter</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">app</span>.<span class="pl-en">Run</span>(<span class="pl-k">async</span><span class="pl-smi">context</span><span class="pl-k">=&gt;</span>
{
    <span class="pl-c"><span class="pl-c">//</span> The implicit AsyncDispose call will flush asynchronously</span><span class="pl-k">await</span><span class="pl-en">using</span> (<span class="pl-smi">var</span><span class="pl-smi">streamWriter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StreamWriter</span>(<span class="pl-smi">context</span>.<span class="pl-smi">Response</span>.<span class="pl-smi">Body</span>))
    {
        <span class="pl-k">await</span><span class="pl-smi">streamWriter</span>.<span class="pl-en">WriteAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span>);
    }
});</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example asynchronously flushes any buffered data before disposing the <code>StreamWriter</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">app</span>.<span class="pl-en">Run</span>(<span class="pl-k">async</span><span class="pl-smi">context</span><span class="pl-k">=&gt;</span>
{
    <span class="pl-k">using</span> (<span class="pl-k">var</span><span class="pl-smi">streamWriter</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StreamWriter</span>(<span class="pl-smi">context</span>.<span class="pl-smi">Response</span>.<span class="pl-smi">Body</span>))
    {
        <span class="pl-k">await</span><span class="pl-smi">streamWriter</span>.<span class="pl-en">WriteAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span>);

        <span class="pl-c"><span class="pl-c">//</span> Force an asynchronous flush</span><span class="pl-k">await</span><span class="pl-smi">streamWriter</span>.<span class="pl-en">FlushAsync</span>();
    }
});</pre></div><h2><a id="user-content-prefer-asyncawait-over-directly-returning-task" class="anchor" aria-hidden="true" href="#prefer-asyncawait-over-directly-returning-task"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefer <code>async</code>/<code>await</code> over directly returning <code>Task</code></h2><p>There are benefits to using the <code>async</code>/<code>await</code> keyword instead of directly returning the <code>Task</code>:</p><ul><li>Asynchronous and synchronous exceptions are normalized to always be asynchronous.</li><li>The code is easier to modify (consider adding a <code>using</code>, for example).</li><li>Diagnostics of asynchronous methods are easier (debugging hangs etc).</li><li>Exceptions thrown will be automatically wrapped in the returned <code>Task</code> instead of surprising the caller with an actual exception.</li></ul><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example directly returns the <code>Task</code> to the caller.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-en">Task</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">DoSomethingAsync</span>()
{
    <span class="pl-k">return</span><span class="pl-en">CallDependencyAsync</span>();
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This examples uses async/await instead of directly returning the Task.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-k">int</span>&gt; <span class="pl-en">DoSomethingAsync</span>()
{
    <span class="pl-k">return</span><span class="pl-k">await</span><span class="pl-en">CallDependencyAsync</span>();
}</pre></div><p><g-emoji class="g-emoji" alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">💡</g-emoji><strong>NOTE: There are performance considerations when using an async state machine over directly returning the <code>Task</code>. It's always faster to directly return the <code>Task</code> since it does less work but you end up changing the behavior and potentially losing some of the benefits of the async state machine.</strong></p><h2><a id="user-content-configureawait" class="anchor" aria-hidden="true" href="#configureawait"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ConfigureAwait</h2><p>TBD</p><h1><a id="user-content-scenarios" class="anchor" aria-hidden="true" href="#scenarios"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios</h1><p>The above tries to distill general guidance, but doesn't do justice to the kinds of real-world situations that cause code like this to be written in the first place (bad code). This section tries to take concrete examples from real applications and turn them into something simple to help you relate these problems to existing codebases.</p><h2><a id="user-content-timer-callbacks" class="anchor" aria-hidden="true" href="#timer-callbacks"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>Timer</code> callbacks</h2><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> The <code>Timer</code> callback is <code>void</code>-returning and we have asynchronous work to execute. This example uses <code>async void</code> to accomplish it and as a result can crash the process if an exception occurs.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">Pinger</span>
{
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">Timer</span><span class="pl-smi">_timer</span>;
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">HttpClient</span><span class="pl-smi">_client</span>;
    
    <span class="pl-k">public</span><span class="pl-en">Pinger</span>(<span class="pl-en">HttpClient</span><span class="pl-smi">client</span>)
    {
        <span class="pl-smi">_client</span><span class="pl-k">=</span><span class="pl-smi">client</span>;
        <span class="pl-smi">_timer</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Timer</span>(<span class="pl-smi">Heartbeat</span>, <span class="pl-c1">null</span>, <span class="pl-c1">1000</span>, <span class="pl-c1">1000</span>);
    }

    <span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-k">void</span><span class="pl-en">Heartbeat</span>(<span class="pl-k">object</span><span class="pl-smi">state</span>)
    {
        <span class="pl-k">await</span><span class="pl-smi">_client</span>.<span class="pl-en">GetAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>http://mybackend/api/ping<span class="pl-pds">"</span></span>);
    }
}</pre></div><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This attempts to block in the <code>Timer</code> callback. This may result in thread-pool starvation and is an example of <a href="#warning-sync-over-async">sync over async</a></p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">Pinger</span>
{
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">Timer</span><span class="pl-smi">_timer</span>;
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">HttpClient</span><span class="pl-smi">_client</span>;
    
    <span class="pl-k">public</span><span class="pl-en">Pinger</span>(<span class="pl-en">HttpClient</span><span class="pl-smi">client</span>)
    {
        <span class="pl-smi">_client</span><span class="pl-k">=</span><span class="pl-smi">client</span>;
        <span class="pl-smi">_timer</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Timer</span>(<span class="pl-smi">Heartbeat</span>, <span class="pl-c1">null</span>, <span class="pl-c1">1000</span>, <span class="pl-c1">1000</span>);
    }

    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Heartbeat</span>(<span class="pl-k">object</span><span class="pl-smi">state</span>)
    {
        <span class="pl-smi">_client</span>.<span class="pl-en">GetAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>http://mybackend/api/ping<span class="pl-pds">"</span></span>).<span class="pl-en">GetAwaiter</span>().<span class="pl-en">GetResult</span>();
    }
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This example uses an <code>async Task</code>-based method and discards the <code>Task</code> in the <code>Timer</code> callback. If this method fails, it will not crash the process. Instead, it will fire the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler.unobservedtaskexception?view=netframework-4.7.2" rel="nofollow"><code>TaskScheduler.UnobservedTaskException</code></a> event.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">Pinger</span>
{
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">Timer</span><span class="pl-smi">_timer</span>;
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">HttpClient</span><span class="pl-smi">_client</span>;
    
    <span class="pl-k">public</span><span class="pl-en">Pinger</span>(<span class="pl-en">HttpClient</span><span class="pl-smi">client</span>)
    {
        <span class="pl-smi">_client</span><span class="pl-k">=</span><span class="pl-smi">client</span>;
        <span class="pl-smi">_timer</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Timer</span>(<span class="pl-smi">Heartbeat</span>, <span class="pl-c1">null</span>, <span class="pl-c1">1000</span>, <span class="pl-c1">1000</span>);
    }

    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Heartbeat</span>(<span class="pl-k">object</span><span class="pl-smi">state</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> Discard the result</span><span class="pl-c1">_</span><span class="pl-k">=</span><span class="pl-en">DoAsyncPing</span>();
    }

    <span class="pl-k">private</span><span class="pl-k">async</span><span class="pl-en">Task</span><span class="pl-en">DoAsyncPing</span>()
    {
        <span class="pl-k">await</span><span class="pl-smi">_client</span>.<span class="pl-en">GetAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>http://mybackend/api/ping<span class="pl-pds">"</span></span>);
    }
}</pre></div><h2><a id="user-content-implicit-async-void-delegates" class="anchor" aria-hidden="true" href="#implicit-async-void-delegates"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implicit <code>async void</code> delegates</h2><p>Imagine a <code>BackgroundQueue</code> with a <code>FireAndForget</code> that takes a callback. This method will execute the callback at some time in the future.</p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This will force callers to either block in the callback or use an <code>async void</code> delegate.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">BackgroundQueue</span>
{
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">FireAndForget</span>(<span class="pl-en">Action</span><span class="pl-smi">action</span>) { }
}</pre></div><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This calling code is creating an <code>async void</code> method implicitly. The compiler fully supports this today.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">Program</span>
{
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Main</span>(<span class="pl-k">string</span>[] <span class="pl-smi">args</span>)
    {
        <span class="pl-k">var</span><span class="pl-smi">httpClient</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">HttpClient</span>();
        <span class="pl-smi">BackgroundQueue</span>.<span class="pl-en">FireAndForget</span>(<span class="pl-k">async</span> () <span class="pl-k">=&gt;</span>
        {
            <span class="pl-k">await</span><span class="pl-smi">httpClient</span>.<span class="pl-en">GetAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>http://pinger/api/1<span class="pl-pds">"</span></span>);
        });
        
        <span class="pl-smi">Console</span>.<span class="pl-en">ReadLine</span>();
    }
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This BackgroundQueue implementation offers both sync and <code>async</code> callback overloads.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">BackgroundQueue</span>
{
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">FireAndForget</span>(<span class="pl-en">Action</span><span class="pl-smi">action</span>) { }
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">FireAndForget</span>(<span class="pl-en">Func</span>&lt;<span class="pl-en">Task</span>&gt; <span class="pl-smi">action</span>) { }
}</pre></div><h2><a id="user-content-concurrentdictionarygetoradd" class="anchor" aria-hidden="true" href="#concurrentdictionarygetoradd"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>ConcurrentDictionary.GetOrAdd</code></h2><p>It's pretty common to cache the result of an asynchronous operation and <code>ConcurrentDictionary</code> is a good data structure for doing that. <code>GetOrAdd</code> is a convenience API for trying to get an item if it's already there or adding it if it isn't. The callback is synchronous so it's tempting to write code that uses <code>Task.Result</code> to produce the value of an asynchronous process but that can lead to thread-pool starvation.</p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This may result in thread-pool starvation since we're blocking the request thread if the person data is not cached.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">PersonController</span> : <span class="pl-en">Controller</span>
{
   <span class="pl-k">private</span><span class="pl-en">AppDbContext</span><span class="pl-smi">_db</span>;
   
   <span class="pl-c"><span class="pl-c">//</span> This cache needs expiration</span><span class="pl-k">private</span><span class="pl-k">static</span><span class="pl-en">ConcurrentDictionary</span>&lt;<span class="pl-k">int</span>, <span class="pl-en">Person</span>&gt; <span class="pl-smi">_cache</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ConcurrentDictionary</span>&lt;<span class="pl-k">int</span>, <span class="pl-en">Person</span>&gt;();
   
   <span class="pl-k">public</span><span class="pl-en">PersonController</span>(<span class="pl-en">AppDbContext</span><span class="pl-smi">db</span>)
   {
      <span class="pl-smi">_db</span><span class="pl-k">=</span><span class="pl-smi">db</span>;
   }
   
   <span class="pl-k">public</span><span class="pl-en">IActionResult</span><span class="pl-en">Get</span>(<span class="pl-k">int</span><span class="pl-smi">id</span>)
   {
       <span class="pl-k">var</span><span class="pl-smi">person</span><span class="pl-k">=</span><span class="pl-smi">_cache</span>.<span class="pl-en">GetOrAdd</span>(<span class="pl-smi">id</span>, (<span class="pl-smi">key</span>) <span class="pl-k">=&gt;</span><span class="pl-smi">_db</span>.<span class="pl-smi">People</span>.<span class="pl-en">FindAsync</span>(<span class="pl-smi">key</span>).<span class="pl-smi">Result</span>);
       <span class="pl-k">return</span><span class="pl-en">Ok</span>(<span class="pl-smi">person</span>);
   }
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This implementation won't result in thread-pool starvation since we're storing a task instead of the result itself.</p><p><g-emoji class="g-emoji" alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">⚠️</g-emoji><code>ConcurrentDictionary.GetOrAdd</code> will potentially run the cache callback multiple times in parallel. This can result in kicking off expensive computations multiple times.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">PersonController</span> : <span class="pl-en">Controller</span>
{
   <span class="pl-k">private</span><span class="pl-en">AppDbContext</span><span class="pl-smi">_db</span>;
   
   <span class="pl-c"><span class="pl-c">//</span> This cache needs expiration</span><span class="pl-k">private</span><span class="pl-k">static</span><span class="pl-en">ConcurrentDictionary</span>&lt;<span class="pl-k">int</span>, <span class="pl-en">Task</span>&lt;<span class="pl-en">Person</span>&gt;&gt; <span class="pl-smi">_cache</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ConcurrentDictionary</span>&lt;<span class="pl-k">int</span>, <span class="pl-en">Task</span>&lt;<span class="pl-en">Person</span>&gt;&gt;();
   
   <span class="pl-k">public</span><span class="pl-en">PersonController</span>(<span class="pl-en">AppDbContext</span><span class="pl-smi">db</span>)
   {
      <span class="pl-smi">_db</span><span class="pl-k">=</span><span class="pl-smi">db</span>;
   }
   
   <span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-en">IActionResult</span>&gt; <span class="pl-en">Get</span>(<span class="pl-k">int</span><span class="pl-smi">id</span>)
   {
       <span class="pl-k">var</span><span class="pl-smi">person</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-smi">_cache</span>.<span class="pl-en">GetOrAdd</span>(<span class="pl-smi">id</span>, (<span class="pl-smi">key</span>) <span class="pl-k">=&gt;</span><span class="pl-smi">_db</span>.<span class="pl-smi">People</span>.<span class="pl-en">FindAsync</span>(<span class="pl-smi">key</span>));
       <span class="pl-k">return</span><span class="pl-en">Ok</span>(<span class="pl-smi">person</span>);
   }
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This implementation fixes the multiple-executing callback issue by using the <code>async</code> lazy pattern.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">PersonController</span> : <span class="pl-en">Controller</span>
{
   <span class="pl-k">private</span><span class="pl-en">AppDbContext</span><span class="pl-smi">_db</span>;
   
   <span class="pl-c"><span class="pl-c">//</span> This cache needs expiration</span><span class="pl-k">private</span><span class="pl-k">static</span><span class="pl-en">ConcurrentDictionary</span>&lt;<span class="pl-k">int</span>, <span class="pl-en">AsyncLazy</span>&lt;<span class="pl-en">Person</span>&gt;&gt; <span class="pl-smi">_cache</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ConcurrentDictionary</span>&lt;<span class="pl-k">int</span>, <span class="pl-en">AsyncLazy</span>&lt;<span class="pl-en">Person</span>&gt;&gt;();
   
   <span class="pl-k">public</span><span class="pl-en">PersonController</span>(<span class="pl-en">AppDbContext</span><span class="pl-smi">db</span>)
   {
      <span class="pl-smi">_db</span><span class="pl-k">=</span><span class="pl-smi">db</span>;
   }
   
   <span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-en">IActionResult</span>&gt; <span class="pl-en">Get</span>(<span class="pl-k">int</span><span class="pl-smi">id</span>)
   {
       <span class="pl-k">var</span><span class="pl-smi">person</span><span class="pl-k">=</span><span class="pl-k">await</span><span class="pl-smi">_cache</span>.<span class="pl-en">GetOrAdd</span>(<span class="pl-smi">id</span>, (<span class="pl-smi">key</span>) <span class="pl-k">=&gt;</span><span class="pl-k">new</span><span class="pl-en">AsyncLazy</span>&lt;<span class="pl-en">Person</span>&gt;(() <span class="pl-k">=&gt;</span><span class="pl-smi">_db</span>.<span class="pl-smi">People</span>.<span class="pl-en">FindAsync</span>(<span class="pl-smi">key</span>))).<span class="pl-smi">Value</span>;
       <span class="pl-k">return</span><span class="pl-en">Ok</span>(<span class="pl-smi">person</span>);
   }
   
   <span class="pl-k">private</span><span class="pl-k">class</span><span class="pl-en">AsyncLazy</span>&lt;<span class="pl-en">T</span>&gt; : <span class="pl-en">Lazy</span>&lt;<span class="pl-en">Task</span>&lt;<span class="pl-en">T</span>&gt;&gt;
   {
      <span class="pl-k">public</span><span class="pl-en">AsyncLazy</span>(<span class="pl-en">Func</span>&lt;<span class="pl-en">Task</span>&lt;<span class="pl-en">T</span>&gt;&gt; <span class="pl-smi">valueFactory</span>) : <span class="pl-k">base</span>(<span class="pl-smi">valueFactory</span>)
      {
      }
   }
}</pre></div><h2><a id="user-content-constructors" class="anchor" aria-hidden="true" href="#constructors"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constructors</h2><p>Constructors are synchronous. If you need to initialize some logic that may be asynchronous, there are a couple of patterns for dealing with this.</p><p>Here's an example of using a client API that needs to connect asynchronously before use.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">interface</span><span class="pl-en">IRemoteConnectionFactory</span>
{
   <span class="pl-en">Task</span>&lt;<span class="pl-en">IRemoteConnection</span>&gt; <span class="pl-en">ConnectAsync</span>();
}

<span class="pl-k">public</span><span class="pl-k">interface</span><span class="pl-en">IRemoteConnection</span>
{
    <span class="pl-en">Task</span><span class="pl-en">PublishAsync</span>(<span class="pl-k">string</span><span class="pl-smi">channel</span>, <span class="pl-k">string</span><span class="pl-smi">message</span>);
    <span class="pl-en">Task</span><span class="pl-en">DisposeAsync</span>();
}</pre></div><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example uses <code>Task.Result</code> to get the connection in the constructor. This could lead to thread-pool starvation and deadlocks.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">Service</span> : <span class="pl-en">IService</span>
{
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">IRemoteConnection</span><span class="pl-smi">_connection</span>;
    
    <span class="pl-k">public</span><span class="pl-en">Service</span>(<span class="pl-en">IRemoteConnectionFactory</span><span class="pl-smi">connectionFactory</span>)
    {
        <span class="pl-smi">_connection</span><span class="pl-k">=</span><span class="pl-smi">connectionFactory</span>.<span class="pl-en">ConnectAsync</span>().<span class="pl-smi">Result</span>;
    }
}</pre></div><p><g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji><strong>GOOD</strong> This implementation uses a static factory pattern in order to allow asynchronous construction:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">Service</span> : <span class="pl-en">IService</span>
{
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">IRemoteConnection</span><span class="pl-smi">_connection</span>;

    <span class="pl-k">private</span><span class="pl-en">Service</span>(<span class="pl-en">IRemoteConnection</span><span class="pl-smi">connection</span>)
    {
        <span class="pl-smi">_connection</span><span class="pl-k">=</span><span class="pl-smi">connection</span>;
    }

    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-en">Service</span>&gt; <span class="pl-en">CreateAsync</span>(<span class="pl-en">IRemoteConnectionFactory</span><span class="pl-smi">connectionFactory</span>)
    {
        <span class="pl-k">return</span><span class="pl-k">new</span><span class="pl-en">Service</span>(<span class="pl-k">await</span><span class="pl-smi">connectionFactory</span>.<span class="pl-en">ConnectAsync</span>());
    }
}</pre></div><h2><a id="user-content-windowsidentityrunimpersonated" class="anchor" aria-hidden="true" href="#windowsidentityrunimpersonated"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>WindowsIdentity.RunImpersonated</h2><p>This API runs the specified action as the impersonated Windows identity. Unfortunately there's no asynchronous version of the callback.</p><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example tries to execute the query asynchronously, and then wait for it outside of the call to <code>RunImpersonated</code>. This will throw because the query might be executing outside of the impersonation context.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">async</span><span class="pl-en">Task</span>&lt;<span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">Product</span>&gt;&gt; <span class="pl-en">GetDataImpersonatedAsync</span>(<span class="pl-en">SafeAccessTokenHandle</span><span class="pl-smi">safeAccessTokenHandle</span>)
{
    <span class="pl-en">Task</span>&lt;<span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">Product</span>&gt;&gt; <span class="pl-smi">products</span><span class="pl-k">=</span><span class="pl-c1">null</span>;
    <span class="pl-smi">WindowsIdentity</span>.<span class="pl-en">RunImpersonated</span>(
        <span class="pl-smi">safeAccessTokenHandle</span>,
        <span class="pl-smi">context</span><span class="pl-k">=&gt;</span>
        {
            <span class="pl-smi">products</span><span class="pl-k">=</span><span class="pl-smi">_db</span>.<span class="pl-en">QueryAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>SELECT Name from Products<span class="pl-pds">"</span></span>);
        }};
    <span class="pl-smi">return</span><span class="pl-k">await</span><span class="pl-smi">products</span>;
}</pre></div><p><g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji><strong>BAD</strong> This example uses <code>Task.Result</code> to get the connection in the constructor. This could lead to thread-pool starvation and deadlocks.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">Product</span>&gt; <span class="pl-en">GetDataImpersonatedAsync</span>(<span class="pl-en">SafeAccessTokenHandle</span><span class="pl-smi">safeAccessTokenHandle</span>)
{
    <span class="pl-k">return</span><span class="pl-smi">WindowsIdentity</span>.<span class="pl-en">RunImpersonated</span>(
        <span class="pl-smi">safeAccessTokenHandle</span>,
        <span class="pl-smi">context</span><span class="pl-k">=&gt;</span><span class="pl-smi">_db</span>.<span class="pl-en">QueryAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>SELECT Name from Products<span class="pl-pds">"</span></span>).<span class="pl-smi">Result</span>);
}</pre></div><p><g-emoji class="g-emoji" alias="bulb" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png">💡</g-emoji><strong>NOTE There's no good alternative here. This API shouldn't be used with an asynchronous callback. See <a href="https://github.com/dotnet/corefx/issues/24977">https://github.com/dotnet/corefx/issues/24977</a></strong></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>