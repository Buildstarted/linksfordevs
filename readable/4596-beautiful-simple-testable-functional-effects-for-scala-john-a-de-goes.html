<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Beautiful, Simple, Testable Functional Effects for Scala &#x2013; John A De Goes -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Beautiful, Simple, Testable Functional Effects for Scala – John A De Goes</h1><div><div class="article-wrap" itemprop="text"><p><strong>See my accompanying talk, <a href="https://skillsmatter.com/skillscasts/13247-scala-matters">The Death of Finally Tagless</a>, which was released today and covers ZIO Environment.</strong></p><p>Today’s functional effect systems for Scala, such as the <a href="https://github.com/scalaz/scalaz-zio">ZIO library</a> that I work on, are <em>incredibly</em> powerful.</p><p>They provide an effect data type that unifies synchronous, asynchronous, concurrent, and resource effects, and support automatic error propagation across these boundaries.</p><p>They’re way faster and more powerful than Scala’s <code class="language-plaintext highlighter-rouge">Future</code>, well-documented, reasonably easy to use, and sometimes come equipped with concurrent data structures, a fiber-based concurrency model, and compositional interruption and timeouts for efficient global computation.</p><p>They’re also purely functional, and showcase the power of pure functional programming to solve modern business problems.</p><p>Unfortunately, there’s a dark secret to these functional effect systems: out of the box, they don’t live up to the full promise of functional programming. Despite being referentially transparent, they’re not really testable.</p><h2 id="untestable-effects">Untestable Effects</h2><p>Functional programming ordinarily gives us the incredible ability to easily test our software.</p><p>The reason for this is quite simple: in functional programming, all a function does is map its input to some output. Functions are total (they return an output for every input), deterministic (they return the same output for the same input), and free of side effects (they only compute the return value, and don’t interact with the outside world).</p><p>Surprisingly to many, these properties also hold for functions that returns functional <em>effects</em>. A functional effect, it turns out, is just an immutable data structure that <em>describes</em> an effect, without actually executing it.</p><p>Functional programs construct and compose these data structures together using operations like <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code>, resulting in a data structure that <em>models</em> the entire effectful application. Then in the application’s main function, the data structure is translated, step-by-step, into the effectful operations that it describes.</p><p>The simplest way to build a functional effect is to <em>describe</em> an effect by using a data structure to store a <em>thunk</em> (a <code class="language-plaintext highlighter-rouge">Function0</code> in Scala’s terminology) that holds an arbitrary hunk of effectful Scala code.</p><p>Here’s a data type called <code class="language-plaintext highlighter-rouge">IO</code> which does exactly this:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span><span class="nc">IO</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="k">val</span><span class="nv">unsafeInterpret</span><span class="k">:</span><span class="o">()</span><span class="o">=&gt;</span><span class="n">A</span><span class="o">)</span><span class="o">{</span><span class="n">s</span><span class="k">=&gt;</span><span class="k">def</span><span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span><span class="kt">A</span><span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span><span class="k">=</span><span class="nf">flatMap</span><span class="o">(</span><span class="nv">f</span><span class="o">.</span><span class="py">andThen</span><span class="o">(</span><span class="nv">IO</span><span class="o">.</span><span class="py">effect</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span><span class="k">def</span><span class="nf">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span><span class="kt">A</span><span class="o">=&gt;</span><span class="nc">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span><span class="k">=</span><span class="nv">IO</span><span class="o">.</span><span class="py">effect</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="nv">s</span><span class="o">.</span><span class="py">unsafeInterpret</span><span class="o">()).</span><span class="py">unsafeInterpret</span><span class="o">())</span><span class="o">}</span><span class="k">object</span><span class="nc">IO</span><span class="o">{</span><span class="k">def</span><span class="nf">effect</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">eff</span><span class="k">:</span><span class="o">=&gt;</span><span class="n">A</span><span class="o">)</span><span class="k">=</span><span class="k">new</span><span class="nc">IO</span><span class="o">(()</span><span class="k">=&gt;</span><span class="n">eff</span><span class="o">)</span><span class="o">}</span></code></pre></figure><p>Now we can construct pure functions that return functional effects (<em>models</em> of effects) quite simply:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">putStrLn</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="nv">IO</span><span class="o">.</span><span class="py">effect</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">line</span><span class="o">))</span><span class="k">val</span><span class="nv">getStrLn</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="nv">IO</span><span class="o">.</span><span class="py">effect</span><span class="o">(</span><span class="nv">scala</span><span class="o">.</span><span class="py">io</span><span class="o">.</span><span class="py">StdIn</span><span class="o">.</span><span class="py">readLine</span><span class="o">())</span></code></pre></figure><p>These functions are total, deterministic, and free of side effects, because they don’t <em>do</em> anything effectful, they merely build a data structure that <em>describes</em> effectful operations.</p><p>Using <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code>, we can build describes of whole effectful programs. For example, the following <code class="language-plaintext highlighter-rouge">IO</code> program asks the user for some input and prints it back out to them:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span><span class="nv">program</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="k">for</span><span class="o">{</span><span class="k">_</span><span class="k">&lt;-</span><span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Good morning, what's your name?"</span><span class="o">)</span><span class="n">name</span><span class="k">&lt;-</span><span class="n">getStrLn</span><span class="k">_</span><span class="k">&lt;-</span><span class="nf">putStrLn</span><span class="o">(</span><span class="n">s</span><span class="s">"Great to meet you, $name"</span><span class="o">)</span><span class="o">}</span><span class="k">yield</span><span class="n">name</span></code></pre></figure><p>Now if you evaluate <code class="language-plaintext highlighter-rouge">program</code> in the Scala REPL, you’ll find that it doesn’t actually <em>do</em> anything except construct an <code class="language-plaintext highlighter-rouge">IO</code> value, which is itself an immutable data structure.</p><p>However, you can (non-functionally) interpret this program to the effects that it describes by calling the <code class="language-plaintext highlighter-rouge">unsafeInterpret()</code> function:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nv">program</span><span class="o">.</span><span class="py">unsafeInterpret</span><span class="o">()</span></code></pre></figure><p>In this way, while we can’t avoid doing something “non-functional” forever, we can at least make the vast majority of our code purely functional, and benefit from increased power of abstraction, refactoring, and testability.</p><p>Well, <em>in theory</em>. There’s a big problem with <em>testability</em>.</p><p>In our tests, we need to call functions and verify their outputs match our expectations. Unfortunately, <code class="language-plaintext highlighter-rouge">IO</code> values, like the above <code class="language-plaintext highlighter-rouge">program</code> value, cannot be compared to other <code class="language-plaintext highlighter-rouge">IO</code> values. The reason is that they embed arbitrary hunks of Scala code inside them (functions), and Scala functions cannot be compared for equality.</p><p>Although Scala functions do have <code class="language-plaintext highlighter-rouge">equals</code> and <code class="language-plaintext highlighter-rouge">hashCode</code>, like all ojbects, these do not have meaningful implementations; they are not based on what the function does, but rather, based on the <em>reference</em> of the constructed object.</p><p>An easy way to see this is comparing the values of two <code class="language-plaintext highlighter-rouge">putStrLn</code> values constructed with the same text output:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="o">&gt;</span><span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">)</span><span class="o">==</span><span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">)</span><span class="k">:</span><span class="kt">false</span></code></pre></figure><p>Even though both of these <code class="language-plaintext highlighter-rouge">IO</code> values represent the <em>same</em> program, Scala cannot know that, because functions cannot be sensibly compared for equality. This is not just a limitation of Scala, but rather a fundamental limitation of computation: in Turing complete languages, we cannot know for sure if two functions are equal, even if we look at their implementations.</p><p>This means that while functional effect systems <em>do</em> provide us lots of concrete, tangible benefits (asynchronicity, concurrency, resource-safety, etc.), and while they <em>do</em> give us increased powers of abstraction and refactoring, they don’t make it any easier to test effectful code.</p><p>In part to solve this problem (and in part to gain a benefit called <em>parametric reasoning</em>), some Scala functional programmers have used <em>tagless-final</em>, a technique popularized in Haskell.</p><h2 id="tagless-final-101">Tagless-Final 101</h2><p>In tagless-final, we often use <em>type classes</em> to model effects (although it’s <em>possible</em> to use records, this approach seems not very popular in Scala).</p><p>So instead of interacting with <code class="language-plaintext highlighter-rouge">putStrLn</code> and <code class="language-plaintext highlighter-rouge">getStrLn</code> directly, we define a type class to describe console capabilities. The type class is <em>parameterized</em> over the effect type:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span><span class="nc">Console</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="o">{</span><span class="k">def</span><span class="nf">putStrLn</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">val</span><span class="nv">getStrLn</span><span class="k">:</span><span class="kt">F</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="o">}</span><span class="k">object</span><span class="nc">Console</span><span class="o">{</span><span class="k">def</span><span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span><span class="n">F</span><span class="k">:</span><span class="kt">Console</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span><span class="kt">Console</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span><span class="k">=</span><span class="n">F</span><span class="o">}</span></code></pre></figure><p>Then we can define instances of this type class for <code class="language-plaintext highlighter-rouge">IO</code>:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">implicit</span><span class="k">val</span><span class="nv">ConsoleIO</span><span class="k">:</span><span class="kt">Console</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span><span class="k">=</span><span class="k">new</span><span class="nc">Console</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span><span class="o">{</span><span class="k">def</span><span class="nf">putStrLn</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="nv">IO</span><span class="o">.</span><span class="py">effect</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">line</span><span class="o">))</span><span class="k">val</span><span class="nv">getStrLn</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="nv">IO</span><span class="o">.</span><span class="py">effect</span><span class="o">(</span><span class="nv">scala</span><span class="o">.</span><span class="py">io</span><span class="o">.</span><span class="py">StdIn</span><span class="o">.</span><span class="py">readLine</span><span class="o">())</span><span class="o">}</span></code></pre></figure><p>Now we write programs that are <em>polymorphic</em> in the effect type, which express which capabilities they require from the effect by using type class constraints (commonly modeled using context bounds, which desugar to implicit parameter lists):</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">Console:</span><span class="kt">Monad</span><span class="o">]</span><span class="k">:</span><span class="kt">F</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="k">for</span><span class="o">{</span><span class="k">_</span><span class="k">&lt;-</span><span class="nc">Console</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">putStrLn</span><span class="o">(</span><span class="s">"Good morning, what's your name?"</span><span class="o">)</span><span class="n">name</span><span class="k">&lt;-</span><span class="nc">Console</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">getStrLn</span><span class="k">_</span><span class="k">&lt;-</span><span class="nc">Console</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">putStrLn</span><span class="o">(</span><span class="n">s</span><span class="s">"Great to meet you, $name"</span><span class="o">)</span><span class="o">}</span><span class="k">yield</span><span class="n">name</span></code></pre></figure><p>Since this program is <em>polymorphic</em> in the effect type, you can <em>instantiate</em> it to any concrete data type (such as <code class="language-plaintext highlighter-rouge">IO</code>) that supports its required capabilities. For example:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span><span class="nv">programIO</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="n">program</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span></code></pre></figure><p>(This assumes a suitable instance of some <code class="language-plaintext highlighter-rouge">Monad</code> type class has been defined for <code class="language-plaintext highlighter-rouge">IO</code>, which is required because Scala’s <code class="language-plaintext highlighter-rouge">for</code> comprehension desugars to <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code>.)</p><p>Once all this machinery is in place, it becomes fairly straightforward to define a data type just for testing:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span><span class="k">class</span><span class="nc">TestData</span><span class="o">(</span><span class="n">input</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span><span class="n">output</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">case</span><span class="k">class</span><span class="nc">TestIO</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span><span class="kt">TestData</span><span class="o">=&gt;</span><span class="o">(</span><span class="nc">TestData</span><span class="o">,</span><span class="n">A</span><span class="o">))</span><span class="o">{</span><span class="n">s</span><span class="k">=&gt;</span><span class="k">def</span><span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span><span class="kt">A</span><span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span><span class="k">:</span><span class="kt">TestIO</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span><span class="k">=</span><span class="nf">flatMap</span><span class="o">(</span><span class="n">a</span><span class="k">=&gt;</span><span class="nv">TestIO</span><span class="o">.</span><span class="py">value</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span><span class="k">def</span><span class="nf">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span><span class="kt">A</span><span class="o">=&gt;</span><span class="nc">TestIO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span><span class="kt">TestIO</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span><span class="k">=</span><span class="nc">TestIO</span><span class="o">(</span><span class="n">d</span><span class="k">=&gt;</span><span class="o">(</span><span class="n">s</span><span class="n">run</span><span class="n">d</span><span class="o">)</span><span class="k">match</span><span class="o">{</span><span class="nf">case</span><span class="o">(</span><span class="n">d</span><span class="o">,</span><span class="n">a</span><span class="o">)</span><span class="k">=&gt;</span><span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span><span class="n">run</span><span class="n">d</span><span class="o">})</span><span class="o">}</span><span class="k">object</span><span class="nc">TestIO</span><span class="o">{</span><span class="k">def</span><span class="nf">value</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span><span class="o">=&gt;</span><span class="n">A</span><span class="o">)</span><span class="k">:</span><span class="kt">TestIO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="nc">TestIO</span><span class="o">(</span><span class="n">d</span><span class="k">=&gt;</span><span class="o">(</span><span class="n">d</span><span class="o">,</span><span class="n">a</span><span class="o">))</span><span class="o">}</span></code></pre></figure><p>With this test data type, you can define an instance of the <code class="language-plaintext highlighter-rouge">Console</code> type class that simply pulls lines of input from the test data, and writes lines of output to the test data (left as an exercise for the reader!).</p><p>Once you define this and the <code class="language-plaintext highlighter-rouge">Monad</code> instance, you can instantiate the polymorphic program to the test effect:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span><span class="nv">programTest</span><span class="k">:</span><span class="kt">TestIO</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="n">program</span><span class="o">[</span><span class="kt">TestIO</span><span class="o">]</span></code></pre></figure><p>Finally, at long last testability has been regained: you can write fast, deterministic unit tests that thoroughly test your application logic. Your CI builds will complete quickly and you can refactor with confidence.</p><p>Unfortunately, this benefit comes at considerable cost.</p><p>The tagless-final approach is robust, and many people are quite happy using the technique to build production business applications. However, the technique suffers from a number of drawbacks, each explored in the sections that follow.</p><h3 id="massive-ramp-up">Massive Ramp-Up</h3><p>As demonstrated in this article, the tagless-final technique is not for the faint of heart. It requires advanced knowledge of the Scala programming language, functional programming, and how we model some functional constructs in Scala.</p><p>In particular, to competently use tagless-final in all common scenarios, you will have to understand:</p><ol><li>Functional Effects.</li><li>Parametric Polymorphism.</li><li>Higher-kinded Types.</li><li>Type Classes &amp; their Scala encoding.</li><li>Type Class Instances &amp; their Scala encoding.</li><li>Partial Type Application (AKA <em>Type Lambdas</em>).</li><li>The Monad Hierarchy.</li></ol><p>These are not topics that one co-worker can casually introduce to another co-worker over a lunch break. It’s not possible to sneak tagless-final into a code base. Some combination of training and / or mentorship are required.</p><h3 id="type-class-abuse">Type Class Abuse</h3><p>Although you don’t have to use type classes for tagless-final (indeed, the earliest encoding used ML, but type classes were used in the seminal <em>Finally Tagless</em> paper), it’s overwhelmingly common to do so in the Scala community.</p><p>The reason is that type classes give you nicer syntax and help you thread the (many) constraints throughout your application.</p><p>Unfortunately, this is an abuse of the concept of a type class. A type class, fundamentally, is an <em>abstraction</em>. It lets us talk about the ways in which data types are similar, by describing those similarities with <em>algebraic laws</em>.</p><p>These algebraic laws let us write generic code across many different data types that share a mathematically-precise definition of <em>similar structure</em>, making our functional code principled in a way that ad hoc polymorphism is not.</p><p>Tagless-final type classes do not, in general, have algebraic laws. Most have no laws at all. This represents a serious abuse of the construct of a type class and an impediment for teaching type classes to Scala developers.</p><h3 id="big-bang">Big Bang</h3><p>If we wish to use tagless-final to test a method deep inside our code base, a method which uses <code class="language-plaintext highlighter-rouge">Future</code> or maybe <code class="language-plaintext highlighter-rouge">IO</code>, then we cannot make a small series of rote changes.</p><p>Instead, we have to perform a “big bang” style refactoring, which involves a commitment to tagless-final and a lot of work to obtain testability for a single method.</p><p><em>Big bang</em> refactoring can improve a code base, but it is often at odds with the needs of shipping software. It’s friendlier to the business if we can make changes incrementally and pay only for what we need today.</p><h3 id="tedious-repetition">Tedious Repetition</h3><p>Constraints on type classes are propagated with implicit parameter lists. Context bounds provide a more compact syntax for implicit parameter lists, but when a method that’s polymorphic in an effect requires a lot of different type classes, it can still be unwieldly:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">ef</span><span class="n">genFeed</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">Monad:</span><span class="kt">Logging:</span><span class="kt">UserDatabase:</span><span class="kt">ProfileDatabase:</span><span class="kt">RedisCache:</span><span class="kt">GeoIPService:</span><span class="kt">AuthService:</span><span class="kt">SessionManager:</span><span class="kt">Localization:</span><span class="kt">Config:</span><span class="kt">EventQueue:</span><span class="kt">Concurrent:</span><span class="kt">Async:</span><span class="kt">MetricsManager</span><span class="o">]</span><span class="k">:</span><span class="kt">F</span><span class="o">[</span><span class="kt">Feed</span><span class="o">]</span><span class="k">=</span><span class="o">???</span></code></pre></figure><p>Unfortunately, if you are following functional programming best practices, and pushing dependencies to the edges, requiring as little as possible from every method, then you will find yourself engaging in tedious repetition of similar lists of context bounds:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">cacheFeed</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">Monad:</span><span class="kt">Logging:</span><span class="kt">UserDatabase:</span><span class="kt">ProfileDatabase:</span><span class="kt">RedisCache:</span><span class="kt">Config:</span><span class="kt">EventQueue:</span><span class="kt">Concurrent:</span><span class="kt">Async:</span><span class="kt">MetricsManager</span><span class="o">](</span><span class="n">feed</span><span class="k">:</span><span class="kt">Feed</span><span class="o">)</span><span class="k">:</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="o">???</span></code></pre></figure><p>Some developers try to work around this tedium by creating “module” classes that declare the same set of dependencies for every method inside the module—even if many methods require less than the full set of constraints across all methods.</p><p>This technique makes it easier to deal with the tedium, but at the cost of overly constraining methods and making weakening so-called <em>parametric reasoning</em>.</p><h3 id="stubborn-repetition">Stubborn Repetition</h3><p>Not only is there a lot of repetition in tagless-final programs, but this repetition proves stubborn to abstraction.</p><p>Ideally, if we have two methods with the same set of type class constraints, we’d like to be able to create <em>something</em> to represent that set of constraints, and then use it to remove the duplication across the two methods:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">method1</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">AllConstraints</span><span class="o">]</span><span class="k">=</span><span class="o">???</span><span class="k">def</span><span class="nf">method2</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">AllConstraints</span><span class="o">]</span><span class="k">=</span><span class="o">???</span></code></pre></figure><p>Unfortunately, Scala does not have any mechanism to abstract across duplicated parameter lists.</p><p>So not only is the repetition quite tedious, but it’s unavoidable, due to limitations in the Scala programming language.</p><h3 id="completely-uninferrable">Completely Uninferrable</h3><p>One of the reasons writing Haskell or PureScript is so exceedingly pleasant is the universal and flawless type inference. Scala has enough type inference to make it a joy compared to Java, but many types in Scala cannot be infered (full inference for a higher-kinded type system in the presence of subtyping is still research-grade).</p><p>We would love to be able to take advantage of type inference for tagless-final programs, writing the equivalent of:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">genFeed</span><span class="k">=</span><span class="o">...</span></code></pre></figure><p>Unfortunately, the type class constraints cannot be inferred, even in theory, because they are not actually type parameters, but values in an implicit parameter list (in a language in which anything can be implicit), and asking any compiler to infer arbitrary implicit parameter lists is unreasonable.</p><p>Not only do we have to type out the full list of constraints every time, but if we get the constraints wrong, the error messages will fail with non-obvious “implicit not found” or “method not found” errors.</p><p>The lack of full type inference for tagless-final programs makes writing them an exercise in discipline and self-control, and raises the knowledge and skill barrier for becoming proficient in writing programs in this style.</p><h3 id="fake-parametric-guarantees">Fake Parametric Guarantees</h3><p>An often-touted benefit of tagless-final is that it provides us with <em>parametric reasoning</em>.</p><p>This claim is not without merit. For example, if we look at the following method signature, we should be able to tell from its type that it works with any effect that provides <code class="language-plaintext highlighter-rouge">Monad</code>, and is therefore free of effects (it may only use <code class="language-plaintext highlighter-rouge">Monad</code> operations, such as <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code>, and <code class="language-plaintext highlighter-rouge">ap</code>):</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">innocent</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">Monad</span><span class="o">]</span><span class="k">:</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="o">???</span></code></pre></figure><p>However, since Scala does not restrict procedural effects, this means that we can embed them anywhere, even in supposedly pure code like this:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">innocent</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">Monad</span><span class="o">]</span><span class="k">:</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="o">{</span><span class="nf">println</span><span class="o">(</span><span class="s">"What guarantees?"</span><span class="o">)</span><span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">point</span><span class="o">(())</span><span class="o">}</span></code></pre></figure><p>Worse still, it is trivial to write a helper method that can embed <em>any</em> effect into any <code class="language-plaintext highlighter-rouge">Applicative</code>, even an <code class="language-plaintext highlighter-rouge">Applicative</code> with a strict (non-lazy) version of <code class="language-plaintext highlighter-rouge">point</code>:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">effect</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">Applicative</span><span class="o">](</span><span class="n">a</span><span class="k">:</span><span class="o">=&gt;</span><span class="n">A</span><span class="o">)</span><span class="k">:</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">point</span><span class="o">(()).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span><span class="k">=&gt;</span><span class="n">a</span><span class="o">)</span></code></pre></figure><p>The <code class="language-plaintext highlighter-rouge">effect</code> helper method itself violates neither Scalazzi (the pure functional subset of Scala), nor any <code class="language-plaintext highlighter-rouge">Applicative</code> laws.</p><p>We may use this helper method to further contaminate the original definition of <code class="language-plaintext highlighter-rouge">innocent</code>:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">innocent</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">Monad</span><span class="o">]</span><span class="k">:</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="o">{</span><span class="nf">println</span><span class="o">(</span><span class="s">"What guarantees?"</span><span class="o">)</span><span class="nf">effect</span><span class="o">(</span><span class="nv">System</span><span class="o">.</span><span class="py">exit</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span><span class="o">}</span></code></pre></figure><p>We’ve now trivially embedding a raw effect, which will be executed before the creation of <code class="language-plaintext highlighter-rouge">F[Unit]</code>, and an effect inside the <code class="language-plaintext highlighter-rouge">Applicative</code>.</p><p>In a large code base, whatever <em>can</em> happen, <em>will</em> happen.</p><p>As a testament to this fact, it is common practice among new users of effect systems to accidentally embed effects inside the functions they pass to <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code> (in fact, some effect monads <em>encourage</em> this anti-pattern), as well as embed effects inside lazy versions of the <code class="language-plaintext highlighter-rouge">Monad</code><code class="language-plaintext highlighter-rouge">point</code> operation.</p><p>The benefits of <em>parametric reasoning</em> do apply to tagless-final programs, but only <em>up to discipline</em>. Yet, a lot of other techniques with fewer drawbacks <em>also</em> provide reasoning benefits <em>up to discipline</em>.</p><h3 id="summary-of-tagless-final">Summary of Tagless-Final</h3><p>Tagless-final does have benefits and experienced functional programmers have deployed many production-worthy applications using the technique.</p><p>However, looking at all these drawbacks, it’s hard to recommend tagless-final for most Scala shops.</p><p>In my opinion, the technique will never go mainstream, and because of all the machinery and ceremony involved, encouraging tagless-final may push more people away from functional programming in Scala than it lures in.</p><p>As I have long argued, some techniques that work well in other programming languages (like monad transformers in Haskell), simply don’t work well in Scala. We can’t make them work, and nor do we need to, because we can find other techniques that give us similar benefits without the costs.</p><p>In the next section, I present one such technique that I believe is exceptionally well-suited for Scala.</p><p>If testability is our primary concern, then it’s possible we can take a page from Java. If we want to write testable code in Java, then we use interfaces, and we provide different implementations for live and test scenarios.</p><p>In the case of our preceding example, we can create a simple Scala trait to represent console capabilities:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span><span class="nc">Console</span><span class="o">{</span><span class="k">def</span><span class="nf">putStrLn</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">val</span><span class="nv">getStrLn</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="o">}</span></code></pre></figure><p>This is just an ordinary interface. The only difference is that the methods return functional effects. They don’t actually <em>do</em>, they only <em>describe</em>.</p><p>It’s easy to teach this to Scala developers, because they probably have used interfaces in Scala and whatever programming languages they knew before Scala.</p><p>Now our program, which requires console capabilities, can simply accept <code class="language-plaintext highlighter-rouge">Console</code> as a parameter:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">program</span><span class="o">(</span><span class="n">c</span><span class="k">:</span><span class="kt">Console</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="k">for</span><span class="o">{</span><span class="k">_</span><span class="k">&lt;-</span><span class="nv">c</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="s">"Good morning, "</span><span class="o">+</span><span class="s">"What is your name?"</span><span class="o">)</span><span class="n">name</span><span class="k">&lt;-</span><span class="nv">c</span><span class="o">.</span><span class="py">readLine</span><span class="k">_</span><span class="k">&lt;-</span><span class="nv">c</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Good to meet you, $name!"</span><span class="o">)</span><span class="o">}</span><span class="nf">yield</span><span class="o">()</span></code></pre></figure><p>We can provide either test or production instances of <code class="language-plaintext highlighter-rouge">Console</code>, ensuring we can reliably test our program.</p><p>This technique works reasonably well for tiny programs, but most programs will require more than one service. If you try to scale this technique up, it becomes quite unpleasant:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">program</span><span class="o">(</span><span class="n">s1</span><span class="k">:</span><span class="kt">Service1</span><span class="o">,</span><span class="n">s2</span><span class="k">:</span><span class="kt">Service2</span><span class="o">,</span><span class="n">s3</span><span class="k">:</span><span class="kt">Service3</span><span class="o">,</span><span class="err">…</span><span class="n">sn</span><span class="k">:</span><span class="kt">ServiceN</span><span class="o">)</span><span class="k">=</span><span class="k">for</span><span class="o">{</span><span class="n">a</span><span class="k">&lt;-</span><span class="nf">foo</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span><span class="n">s9</span><span class="o">,</span><span class="n">s3</span><span class="o">)(</span><span class="s">"localhost"</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span><span class="n">b</span><span class="k">&lt;-</span><span class="nf">bar</span><span class="o">(</span><span class="n">sn</span><span class="o">,</span><span class="n">s19</span><span class="o">,</span><span class="n">s3</span><span class="o">)(</span><span class="n">a</span><span class="o">,</span><span class="mi">1024</span><span class="o">)</span><span class="o">...</span><span class="o">}</span><span class="k">yield</span><span class="n">z</span></code></pre></figure><p>The pain results from us having to thread <code class="language-plaintext highlighter-rouge">n</code> services into our methods, and then manually pass subsets of these services into all of the methods that we call.</p><p>Indeed, this is the pain that <em>dependency injection</em> was invented to solve. It should not be surprising if we take a more object-oriented approach to solving the testability problem, we will end up in dependency injection territory.</p><p>Fortunately, using the <em>module pattern</em>, we can at least make steps toward something usable.</p><h3 id="the-module-pattern">The Module Pattern</h3><p>The module pattern involves placing our services inside a module trait to provide easier composition. Sometimes this pattern can be identified by the <code class="language-plaintext highlighter-rouge">HasXYZ</code> naming convention—for example, <code class="language-plaintext highlighter-rouge">HasConsole</code>.</p><p>To use this pattern, you first define a module, which contains a single field with the appropriate service type:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span><span class="nc">HasConsole</span><span class="o">{</span><span class="k">def</span><span class="nf">console</span><span class="k">:</span><span class="kt">ConsoleService</span><span class="o">}</span></code></pre></figure><p>Then you define the service type as normal:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span><span class="nc">ConsoleService</span><span class="o">{</span><span class="k">def</span><span class="nf">putStrLn</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">val</span><span class="nv">getStrLn</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="o">}</span></code></pre></figure><p>Now personally, to avoid extraneous typing, I prefer to choose a simplified naming convention and organizational style: I use a shortname for the module, and put the service definition inside the companion object of the module.</p><p>For example:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span><span class="nc">Console</span><span class="o">{</span><span class="k">def</span><span class="nf">console</span><span class="k">:</span><span class="kt">Console.Service</span><span class="o">}</span><span class="k">object</span><span class="nc">Console</span><span class="o">{</span><span class="k">trait</span><span class="nc">Service</span><span class="o">{</span><span class="k">def</span><span class="nf">putStrLn</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">val</span><span class="nv">getStrLn</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="o">}</span><span class="o">}</span></code></pre></figure><p>In any case, with the module pattern, we are now able to take advantage of <em>intersection types</em> to compose multiple modules into a single module.</p><h3 id="module-composition">Module Composition</h3><p>Scala 3 has first-class support for intersection types. But in the meantime, we can use the <code class="language-plaintext highlighter-rouge">with</code> operator, which provides pseudo-intersection types.</p><p>The <code class="language-plaintext highlighter-rouge">with</code> operator enables us to create a type that must satisfy multiple requirements. In our case, we can use it to create a module that contains many services.</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">program</span><span class="o">(</span><span class="n">s</span><span class="k">:</span><span class="kt">Module1</span><span class="kt">with</span><span class="kt">Module2</span><span class="kt">...</span><span class="kt">with</span><span class="kt">ModuleN</span><span class="o">)</span><span class="k">=</span><span class="k">for</span><span class="o">{</span><span class="n">a</span><span class="k">&lt;-</span><span class="nf">foo</span><span class="o">(</span><span class="n">s</span><span class="o">)(</span><span class="s">"localhost"</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span><span class="n">b</span><span class="k">&lt;-</span><span class="nf">bar</span><span class="o">(</span><span class="n">s</span><span class="o">)(</span><span class="n">a</span><span class="o">,</span><span class="mi">1024</span><span class="o">)</span><span class="o">...</span><span class="o">}</span><span class="k">yield</span><span class="n">z</span></code></pre></figure><p>Notice the <em>dramatic</em> reduction in the amount of work necessary to thread services throughout our application.</p><p>Our method now takes a single service parameter, which, using intersection types, bundles together all of its module dependencies into a single module.</p><p>Further, when we pass service dependencies down the stack, we can simply pass the bundle, because due to Scala’s support for subtyping, we are free to pass methods <em>more</em> than they require (this is called <em>contravariance</em>).</p><p>While a satisfying improvement over the predecessor, there’s still the painful passing of a single parameter all the way from the top of our application to the bottom.</p><p>Fortunately, functional programming provides an extremely simple and elegant solution to this problem.</p><h3 id="the-reader-monad">The Reader Monad</h3><p>The <code class="language-plaintext highlighter-rouge">Reader</code> monad is a monadic data structure that can be used to automated passing an environment from one level in the application down to lower levels.</p><p>Every level of the application has access to the environment, and they can even do local modifications (the environment can vary at each level of the application, if so desired).</p><p>The <code class="language-plaintext highlighter-rouge">Reader</code> monad is explained elsewhere, so I won’t go into depth on how it works, but I’ll present a simple reference implementation:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span><span class="k">class</span><span class="nc">Reader</span><span class="o">[</span><span class="kt">-R</span>, <span class="kt">+A</span><span class="o">](</span><span class="n">provide</span><span class="k">:</span><span class="kt">R</span><span class="o">=&gt;</span><span class="n">A</span><span class="o">)</span><span class="o">{</span><span class="n">self</span><span class="k">=&gt;</span><span class="k">def</span><span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span><span class="kt">A</span><span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span><span class="k">=</span><span class="nf">flatMap</span><span class="o">(</span><span class="n">a</span><span class="k">=&gt;</span><span class="nv">Reader</span><span class="o">.</span><span class="py">point</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span><span class="k">def</span><span class="nf">flatMap</span><span class="o">[</span><span class="kt">R1</span><span class="k">&lt;:</span><span class="kt">R</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span><span class="kt">A</span><span class="o">=&gt;</span><span class="nc">Reader</span><span class="o">[</span><span class="kt">R1</span>, <span class="kt">B</span><span class="o">])</span><span class="k">=</span><span class="nc">Reader</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">B</span><span class="o">](</span><span class="n">r</span><span class="k">=&gt;</span><span class="nf">f</span><span class="o">(</span><span class="nv">self</span><span class="o">.</span><span class="py">provide</span><span class="o">(</span><span class="n">r</span><span class="o">)).</span><span class="py">provide</span><span class="o">(</span><span class="n">r</span><span class="o">))</span><span class="o">}</span><span class="k">object</span><span class="nc">Reader</span><span class="o">{</span><span class="k">def</span><span class="nf">point</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span><span class="o">=&gt;</span><span class="n">A</span><span class="o">)</span><span class="k">:</span><span class="kt">Reader</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="nc">Reader</span><span class="o">(</span><span class="k">_</span><span class="k">=&gt;</span><span class="n">a</span><span class="o">)</span><span class="k">def</span><span class="nf">environment</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span><span class="k">:</span><span class="kt">Reader</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">R</span><span class="o">]</span><span class="k">=</span><span class="nc">Reader</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span><span class="k">def</span><span class="nf">access</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span><span class="kt">R</span><span class="o">=&gt;</span><span class="n">A</span><span class="o">)</span><span class="k">:</span><span class="kt">Reader</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="n">environment</span><span class="o">[</span><span class="kt">R</span><span class="o">].</span><span class="py">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span><span class="o">}</span></code></pre></figure><p>A <code class="language-plaintext highlighter-rouge">Reader[R, A]</code> is an effect that requires environment <code class="language-plaintext highlighter-rouge">R</code> and produces a value of type <code class="language-plaintext highlighter-rouge">A</code>.</p><p>So, for example, a <code class="language-plaintext highlighter-rouge">Reader[Config, String]</code> is an effect that requires a <code class="language-plaintext highlighter-rouge">Config</code> and produces a value of type <code class="language-plaintext highlighter-rouge">String</code>. To extract the <code class="language-plaintext highlighter-rouge">String</code> from the <code class="language-plaintext highlighter-rouge">Reader</code>, you first have to <em>provide</em> the <code class="language-plaintext highlighter-rouge">Config</code> that it requires:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span><span class="k">class</span><span class="nc">Config</span><span class="o">(</span><span class="n">serverName</span><span class="k">:</span><span class="kt">String</span><span class="o">,</span><span class="n">port</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">val</span><span class="nv">serverName</span><span class="k">:</span><span class="kt">Reader</span><span class="o">[</span><span class="kt">Config</span>, <span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="nv">Reader</span><span class="o">.</span><span class="py">access</span><span class="o">[</span><span class="kt">Config</span><span class="o">](</span><span class="nv">_</span><span class="o">.</span><span class="py">serverName</span><span class="o">)</span><span class="k">val</span><span class="nv">name</span><span class="k">=</span><span class="nv">serverName</span><span class="o">.</span><span class="py">provide</span><span class="o">(</span><span class="nc">Config</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span><span class="mi">43</span><span class="o">))</span></code></pre></figure><p>Now a <code class="language-plaintext highlighter-rouge">Reader[Any, A]</code> means that the effect can work with <em>any</em> environment. This is equivalent to saying it requires <em>no</em> environment. You can extract values from these type of effects by supplying any value at all (for example, unit):</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span><span class="nv">tempFile</span><span class="k">:</span><span class="kt">Reader</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="nv">Reader</span><span class="o">.</span><span class="py">point</span><span class="o">(</span><span class="s">"/tmp/tempfile.dat"</span><span class="o">)</span><span class="k">val</span><span class="nv">file</span><span class="k">=</span><span class="nv">tempFile</span><span class="o">.</span><span class="py">provide</span><span class="o">(())</span></code></pre></figure><p>Note that the <code class="language-plaintext highlighter-rouge">Reader</code> definition above only models <em>reader</em> effects, not effects like input / output, which were modeled by our previous <code class="language-plaintext highlighter-rouge">IO</code> data type.</p><p>However, if we ignore that fact, then if one squints hard enough, one can see a path forward to a final simplification of the module pattern, which uses the <code class="language-plaintext highlighter-rouge">Reader</code> monad to pass modules:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">program</span><span class="k">:</span><span class="kt">Reader</span><span class="o">[</span><span class="kt">Module1</span><span class="kt">with</span><span class="kt">...</span><span class="kt">with</span><span class="kt">ModuleN</span>, <span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="k">for</span><span class="o">{</span><span class="n">a</span><span class="k">&lt;-</span><span class="nf">foo</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span><span class="n">b</span><span class="k">&lt;-</span><span class="nf">bar</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="mi">1024</span><span class="o">)</span><span class="o">...</span><span class="o">}</span><span class="k">yield</span><span class="n">z</span></code></pre></figure><p>This step is not so far away. There is a <code class="language-plaintext highlighter-rouge">Reader</code> monad transformer that can add the reader effect to any base monad, including the <code class="language-plaintext highlighter-rouge">IO</code> monad. However, not only are monad transformers very slow in Scala (adding 2-4x overhead per layer), but they have clumsy ergonomics and bad type inference.</p><p>So instead, using a technique called <a href="/articles/effect-rotation">effect rotation</a>, we can bake the reader effect into the base effect monad, yielding a data type that is high-performance, and, if we are <em>very thoughtful</em> in the design of the data type, opening the door to <em>delightful</em> ergonomics and <em>flawless</em> type inference.</p><p>This is the approach taken by <em>ZIO Environment</em>, a new feature in ZIO and quite possibly the most defining feature of the impending 1.0 release of the ZIO library.</p><h2 id="zio-environment">ZIO Environment</h2><p>ZIO Environment uses a functional effect data type with three type parameters:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nc">ZIO</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span></code></pre></figure><p>The interpretation of these type parameters is as follows:</p><ul><li><code class="language-plaintext highlighter-rouge">R</code>—This is the type of the environment required to run the effect, which can range from a bundle of modules, to just some configuration details, to <code class="language-plaintext highlighter-rouge">Any</code> (indicating no requirement).</li><li><code class="language-plaintext highlighter-rouge">E</code>—This is the type of error the effect may fail with, which can range from <code class="language-plaintext highlighter-rouge">Throwable</code>, to a custom data type (which may or may not extend <code class="language-plaintext highlighter-rouge">Throwable</code> / <code class="language-plaintext highlighter-rouge">Exception</code>), to <code class="language-plaintext highlighter-rouge">Nothing</code> (indicating the effect cannot fail).</li><li><code class="language-plaintext highlighter-rouge">A</code>—This is the type of value the effect may succeed with, which can be anything, but if the effect runs forever (or runs until error), it could also be <code class="language-plaintext highlighter-rouge">Nothing</code>.</li></ul><p>Not everyone may be comfortable using the full ZIO data type, so the library defines three type synonyms for common cases:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span><span class="kt">UIO</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span><span class="k">=</span><span class="nc">ZIO</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Nothing</span>, <span class="kt">A</span><span class="o">]</span><span class="k">type</span><span class="kt">Task</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span><span class="k">=</span><span class="nc">ZIO</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span><span class="k">type</span><span class="kt">IO</span><span class="o">[</span><span class="kt">+E</span>, <span class="kt">+A</span><span class="o">]</span><span class="k">=</span><span class="nc">ZIO</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span></code></pre></figure><p>The meaning of these types is as follows:</p><ul><li><code class="language-plaintext highlighter-rouge">UIO</code>—Unexceptional effect, which doesn’t require any specific environment and cannot fail.</li><li><code class="language-plaintext highlighter-rouge">Task</code>—An effect that doesn’t require any specific environment and can fail with any <code class="language-plaintext highlighter-rouge">Throwable</code>.</li><li><code class="language-plaintext highlighter-rouge">IO</code>—An effect that can fail with an <code class="language-plaintext highlighter-rouge">E</code>.</li></ul><p>All of these type aliases have companion objects, which can be used to construct values of these types. For example, <code class="language-plaintext highlighter-rouge">Task.succeed(42)</code> constructs a <code class="language-plaintext highlighter-rouge">Task[Int]</code>, which of course is really a <code class="language-plaintext highlighter-rouge">ZIO[Any, Throwable, Int]</code>.</p><p>This hierarchy of power allows users to start with <code class="language-plaintext highlighter-rouge">Task</code> and possibly <code class="language-plaintext highlighter-rouge">UIO</code> (any type they handle errors, they’ll get something that has type <code class="language-plaintext highlighter-rouge">UIO</code>), and then gradually migrate to either <code class="language-plaintext highlighter-rouge">IO</code> or <code class="language-plaintext highlighter-rouge">ZIO</code>, or maybe their own type alias that uses offers a combination of types suited to their application.</p><p>In this post, I won’t talk about the <code class="language-plaintext highlighter-rouge">E</code> and <code class="language-plaintext highlighter-rouge">A</code> parameters, since you can find <a href="/articles/bifunctor-io">previous material</a> on these, and <a href="https://github.com/scalaz/scalaz-zio">ZIO itself</a>, including Scaladoc and the microsite, have extensive documentation on failure and success values.</p><p>Rather, I’ll focus on a few methods that help you use the new <code class="language-plaintext highlighter-rouge">R</code> type parameter, and then we’ll take a look at how we can use these methods to solve the testability problem.</p><h3 id="core-environment">Core Environment</h3><p>ZIO Environment just adds two new primitive functions (and then a couple helpers based on these):</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">sealed</span><span class="k">trait</span><span class="nc">ZIO</span><span class="o">[</span><span class="kt">-R</span>, <span class="kt">+E</span>, <span class="kt">+A</span><span class="o">]</span><span class="o">{</span><span class="o">...</span><span class="k">def</span><span class="nf">provide</span><span class="o">(</span><span class="n">environment</span><span class="k">:</span><span class="kt">R</span><span class="o">)</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="o">...</span><span class="o">...</span><span class="o">}</span><span class="k">object</span><span class="nc">ZIO</span><span class="o">{</span><span class="o">...</span><span class="k">def</span><span class="nf">accessM</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span><span class="kt">R</span><span class="o">=&gt;</span><span class="nc">ZIO</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="o">...</span><span class="k">def</span><span class="nf">access</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span><span class="kt">R</span><span class="o">=&gt;</span><span class="n">A</span><span class="o">)</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">Nothing</span>, <span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="nf">accessM</span><span class="o">(</span><span class="nv">ZIO</span><span class="o">.</span><span class="py">succeed</span><span class="o">(</span><span class="k">_</span><span class="o">))</span><span class="k">def</span><span class="nf">environment</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">Nothing</span>, <span class="kt">R</span><span class="o">]</span><span class="k">=</span><span class="nf">access</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span><span class="o">}</span></code></pre></figure><p>The core functions are <code class="language-plaintext highlighter-rouge">ZIO#provide</code>, which allows you to “feed” an <code class="language-plaintext highlighter-rouge">R</code> to an effect that requires an <code class="language-plaintext highlighter-rouge">R</code>, to eliminate its requirement; by changing the environment type parameter to <code class="language-plaintext highlighter-rouge">Any</code>); and <code class="language-plaintext highlighter-rouge">ZIO.accessM</code>, which allows you to effectfully access part of the environment.</p><p>Just like a function whose input requires <code class="language-plaintext highlighter-rouge">Any</code> can be fed anything (including <code class="language-plaintext highlighter-rouge">()</code>), and which therefore has no requirements, an effect whose environment is <code class="language-plaintext highlighter-rouge">Any</code> has no requirements (this is different than <code class="language-plaintext highlighter-rouge">ZIO[Unit, E, A]</code>, which is a type indicating the effect requires the <code class="language-plaintext highlighter-rouge">Unit</code> value).</p><p>The helper functions are <code class="language-plaintext highlighter-rouge">ZIO.access</code>, which allows you to (non-effectfully) access part of the environment, and <code class="language-plaintext highlighter-rouge">ZIO.environment</code>, which gives you the whole environment.</p><p>To really understand how the core methods can help us solve the testability problem, let’s revisit the console example, this time using ZIO Environment.</p><h3 id="console-environment">Console Environment</h3><p>To make our console program testable, we’re going to start out defining a module and associated service class. We’ve seen these before, and there are no substantial changes this time around:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span><span class="nn">scalaz.zio._</span><span class="k">trait</span><span class="nc">Console</span><span class="o">{</span><span class="k">def</span><span class="nf">console</span><span class="k">:</span><span class="kt">Console.Service</span><span class="o">}</span><span class="k">object</span><span class="nc">Console</span><span class="o">{</span><span class="k">trait</span><span class="nc">Service</span><span class="o">{</span><span class="k">def</span><span class="nf">println</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">UIO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">val</span><span class="nv">readLine</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">IOException</span>, <span class="kt">String</span><span class="o">]</span><span class="o">}</span><span class="k">trait</span><span class="nc">Live</span><span class="k">extends</span><span class="nv">Console</span><span class="o">.</span><span class="py">Service</span><span class="o">{</span><span class="k">import</span><span class="nn">scala.io.StdIn.readLine</span><span class="k">def</span><span class="nf">println</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">=</span><span class="nv">UIO</span><span class="o">.</span><span class="py">effectTotal</span><span class="o">(</span><span class="nv">scala</span><span class="o">.</span><span class="py">io</span><span class="o">.</span><span class="py">StdIn</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">line</span><span class="o">))</span><span class="k">val</span><span class="nv">readLine</span><span class="k">=</span><span class="nv">IO</span><span class="o">.</span><span class="py">effect</span><span class="o">(</span><span class="nf">readLine</span><span class="o">()).</span><span class="py">refineOrDie</span><span class="o">(</span><span class="nc">JustIOExceptions</span><span class="o">)</span><span class="o">}</span><span class="k">object</span><span class="nc">Live</span><span class="k">extends</span><span class="nc">Live</span><span class="o">}</span></code></pre></figure><p>Note that in the console service, the <code class="language-plaintext highlighter-rouge">println</code> function returns a <code class="language-plaintext highlighter-rouge">UIO[Unit]</code> (because it cannot fail), while the <code class="language-plaintext highlighter-rouge">readLine</code> function returns an <code class="language-plaintext highlighter-rouge">IO[IOException, String]</code>, because it might fail because of an <code class="language-plaintext highlighter-rouge">IOException</code>.</p><p>If you wanted to be less precise, but also eliminate the need to think about the types, you could just use <code class="language-plaintext highlighter-rouge">Task</code> everywhere, which is more familiar to Scala developers who have used <code class="language-plaintext highlighter-rouge">Future</code> and don’t yet think about typed errors.</p><p>The <code class="language-plaintext highlighter-rouge">Console</code> companion object holds an implementation of the <code class="language-plaintext highlighter-rouge">Live</code> version, while a test implementation of the <code class="language-plaintext highlighter-rouge">Console.Service</code> interface could live inside a test package.</p><p>Notice how there are no polymorphic types, no higher-kinded types, no type classes, no type class instances, no implicits, and no monads. This is literally just an interface and implementation, where the methods return functional effects.</p><p>The next step is to define a few helper functions, to make using the module easier. This step isn’t necessary, but it’s convenient, so I’ll show the technique:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span><span class="nn">object</span><span class="n">console</span><span class="o">{</span><span class="k">def</span><span class="nf">println</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">Console</span>, <span class="kt">Nothing</span>, <span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="nv">ZIO</span><span class="o">.</span><span class="py">accessM</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">console</span><span class="n">println</span><span class="n">line</span><span class="o">)</span><span class="k">val</span><span class="nv">readLine</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">Console</span>, <span class="kt">IOException</span>, <span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="nv">ZIO</span><span class="o">.</span><span class="py">accessM</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">console</span><span class="o">.</span><span class="py">readLine</span><span class="o">)</span><span class="o">}</span></code></pre></figure><p>This package object, which I called <code class="language-plaintext highlighter-rouge">console</code>, defines <code class="language-plaintext highlighter-rouge">println</code> and <code class="language-plaintext highlighter-rouge">readLine</code> functions that return functional effects. These functional effects are defined by using <code class="language-plaintext highlighter-rouge">ZIO.accessM</code>, which gives us access to any set of modules we want. In this case, we just need the <code class="language-plaintext highlighter-rouge">Console</code> module, which is reflected in the return types.</p><p>Using these helper functions, we can now build our purely functional ZIO program:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span><span class="nn">console._</span><span class="k">val</span><span class="nv">program</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">Console</span>, <span class="kt">IOException</span>, <span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="k">for</span><span class="o">{</span><span class="k">_</span><span class="k">&lt;-</span><span class="nf">println</span><span class="o">(</span><span class="s">"Good morning, what is your name?"</span><span class="o">)</span><span class="n">name</span><span class="k">&lt;-</span><span class="n">readLine</span><span class="k">_</span><span class="k">&lt;-</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Good to meet you, $name!"</span><span class="o">)</span><span class="o">}</span><span class="k">yield</span><span class="n">name</span></code></pre></figure><p>Again notice the simplicity of this definition. Without any of the final tagless machinery, a basic understanding of functional effects and <code class="language-plaintext highlighter-rouge">for</code> comprehensions is all that’s necessary to write code like this.</p><p>Now when we need to unsafely interpret this data structure into the effect that it represents, we will generally first provide its required environment using the <code class="language-plaintext highlighter-rouge">ZIO#provide</code> method. Since this effect only requires <code class="language-plaintext highlighter-rouge">Console</code>, and since we have already written an implementation in <code class="language-plaintext highlighter-rouge">Console.Live</code>, we can easily provide our program its production environment:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span><span class="nv">programLive</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">IOException</span>, <span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="nv">program</span><span class="o">.</span><span class="py">provide</span><span class="o">(</span><span class="nv">Console</span><span class="o">.</span><span class="py">Live</span><span class="o">)</span></code></pre></figure><p>Notice the use of the type synonym <code class="language-plaintext highlighter-rouge">IO[IOException, String]</code>, which of course expands to <code class="language-plaintext highlighter-rouge">ZIO[Any, IOException, String]</code>, indicating our effect no longer requires any specific environment.</p><p>We’re now ready to run our program, which we can do with the default runtime system in ZIO:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nv">DefaultRuntime</span><span class="o">.</span><span class="py">unsafeRun</span><span class="o">(</span><span class="n">programLive</span><span class="o">)</span></code></pre></figure><p>It’s nearly as easy to test our program. All we have to do is construct an implementation of the <code class="language-plaintext highlighter-rouge">Console.Service</code> interface for testing:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span><span class="nc">TestConsole</span><span class="k">extends</span><span class="nc">Console</span><span class="o">{</span><span class="k">val</span><span class="nv">console</span><span class="k">:</span><span class="kt">Console.Service</span><span class="o">=</span><span class="o">...</span><span class="o">}</span></code></pre></figure><p>Now we can run the same program using our test service:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span><span class="nv">programTest</span><span class="k">=</span><span class="nv">program</span><span class="o">.</span><span class="py">provide</span><span class="o">(</span><span class="nc">TestConsole</span><span class="o">)</span><span class="nv">DefaultRuntime</span><span class="o">.</span><span class="py">unsafeRun</span><span class="o">(</span><span class="n">programTest</span><span class="o">)</span></code></pre></figure><p>That’s all there is to ZIO Environment! With just two primitives (<code class="language-plaintext highlighter-rouge">provide</code> and <code class="language-plaintext highlighter-rouge">accessM</code>), and an additional type parameter, we’re able to completely solve the testability problem in a way that requires only a tiny fraction of the knowledge and skills of tagless-final.</p><p>But it gets even better than this!</p><h3 id="delightful-functional-effects">Delightful Functional Effects</h3><p>Tagless-final had a number of drawbacks beyond just a massive ramp up curve. In the next few sections, we’ll look at how ZIO Environment stacks up against tagless-final.</p><h4 id="composable">Composable</h4><p>Like tagless-final, ZIO Environment is composable: we can compose requirements horizontally, using the <code class="language-plaintext highlighter-rouge">with</code> operator for type intersection:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span><span class="nc">Console</span><span class="o">{</span><span class="k">def</span><span class="nf">console</span><span class="k">:</span><span class="kt">Console.Service</span><span class="o">}</span><span class="k">trait</span><span class="nc">Logging</span><span class="o">{</span><span class="k">def</span><span class="nf">logging</span><span class="k">:</span><span class="kt">Logging.Service</span><span class="o">}</span><span class="k">trait</span><span class="nc">Persistence</span><span class="o">{</span><span class="k">def</span><span class="nf">persistence</span><span class="k">:</span><span class="kt">Persistence.Service</span><span class="o">}</span><span class="o">...</span><span class="k">val</span><span class="nv">program</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">Console</span><span class="kt">with</span><span class="kt">Logging</span><span class="kt">with</span><span class="kt">Persistence</span>,
                 <span class="kt">ProgramError</span>, <span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="o">...</span></code></pre></figure><h4 id="performant">Performant</h4><p>Like tagless-final, but to an even greater extent (because all ZIO methods are monomorphic), ZIO Environment is high-performance.</p><p>If you tried to emulate the ZIO Environment technique in another effect type, using the <code class="language-plaintext highlighter-rouge">ReaderT</code> monad transformer, then you would suffer as much as a 4x performance penalty. If you tried to emulate both ZIO Typed Errors as well, using an <code class="language-plaintext highlighter-rouge">EitherT</code> monad transformer, you could suffer as much as an 8x performance penalty.</p><p>Thanks to effect rotation, ZIO gives you the benefits of the reader and either monad transformers, without any of the cost, and with far better ergonomics and type inference.</p><h4 id="fully-inferable">Fully Inferable</h4><p>As an experienced functional programmer who has used and generally likes tagless-final, I personally find one of the most compelling benefits of ZIO Environment to be <em>type inference</em>.</p><p>Thanks to a careful design and appropriate use of variance, ZIO is fully inferable (!). In fact, as far as I’m aware, it’s the <em>only</em> approach to testable functional effects in Scala that’s demonstrated to be fully inferable.</p><p>This means if you use many different modules, you can call functions from all the modules, and the Scala compiler will infer the proper environment.</p><p>As an example:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span><span class="nv">program</span><span class="k">=</span><span class="k">for</span><span class="o">{</span><span class="k">_</span><span class="k">&lt;-</span><span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Good morning, what is your name?"</span><span class="o">)</span><span class="n">name</span><span class="k">&lt;-</span><span class="n">getStrLn</span><span class="k">_</span><span class="k">&lt;-</span><span class="nf">savePreferences</span><span class="o">(</span><span class="n">name</span><span class="o">)</span><span class="k">_</span><span class="k">&lt;-</span><span class="nv">log</span><span class="o">.</span><span class="py">debug</span><span class="o">(</span><span class="s">"Saved $name to configuration"</span><span class="o">)</span><span class="k">_</span><span class="k">&lt;-</span><span class="nf">putStrLn</span><span class="o">(</span><span class="n">s</span><span class="s">"Good to meet you, $name!"</span><span class="o">)</span><span class="o">}</span><span class="nf">yield</span><span class="o">()</span></code></pre></figure><p>In this case, Scala will infer the environment to be <code class="language-plaintext highlighter-rouge">Console with Persistence with Logging</code>.</p><p>Not only can Scala infer the type, but if you give an explicit type annotation, but it’s incorrect, the hints that Scala provides will eventually lead you to the correct type signature.</p><p>Even if you believe in providing top-level type signatures, being able to infer local signatures, have your IDE insert the top-level signatures, or just ask Scala for the correct type (by intentionally inserting the wrong type) is a tremendous benefit to productivity and makes working with ZIO effects an extremely pleasant experience.</p><h4 id="concise">Concise</h4><p>With full inference, ZIO can be extremely concise. However, inference is actually not necessary for concision.</p><p>Because ZIO Environment uses a type parameter, and because Scala has type aliases, this means we can eliminate all duplication in method signatures:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span><span class="nc">Console</span><span class="o">{</span><span class="k">def</span><span class="nf">console</span><span class="k">:</span><span class="kt">Console.Service</span><span class="o">}</span><span class="k">trait</span><span class="nc">Logging</span><span class="o">{</span><span class="k">def</span><span class="nf">logging</span><span class="k">:</span><span class="kt">Logging.Service</span><span class="o">}</span><span class="k">trait</span><span class="nc">Persistence</span><span class="o">{</span><span class="k">def</span><span class="nf">persistence</span><span class="k">:</span><span class="kt">Persistence.Service</span><span class="o">}</span><span class="o">...</span><span class="k">type</span><span class="kt">ProgramEnv</span><span class="o">=</span><span class="nc">Console</span><span class="k">with</span><span class="nc">Logging</span><span class="k">with</span><span class="nc">Persistence</span><span class="k">val</span><span class="nv">program1</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">ProgramEnv</span>, <span class="kt">AppError</span>, <span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="o">...</span><span class="k">val</span><span class="nv">program2</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">ProgramEnv</span>, <span class="kt">AppError</span>, <span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="o">...</span></code></pre></figure><p>In fact, if we want to create a custom effect type, with our own environment and error type, it’s easy to do that too:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span><span class="kt">Program</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="nc">ZIO</span><span class="o">[</span><span class="kt">Console</span><span class="kt">with</span><span class="kt">Logging</span><span class="kt">with</span><span class="kt">Persistence</span>, 
                      <span class="kt">AppError</span>, <span class="kt">A</span><span class="o">]</span><span class="k">val</span><span class="nv">program1</span><span class="k">:</span><span class="kt">Program</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="o">...</span><span class="k">val</span><span class="nv">program2</span><span class="k">:</span><span class="kt">Program</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">=</span><span class="o">...</span></code></pre></figure><p>Type synonyms like this, especially when combined with associated companion objects, can make it possible for beginners to rapidly become productive in a large code base. Further, they enable beginners and experts alike to avoid repeating themselves, which makes code maintenance easier, less costly, and more predictable.</p><h4 id="modular">Modular</h4><p>With ZIO Environment, there is no need to build up a monolithic environment. Rather, individual layers of the application can supply local environments to lower layers.</p><p>An example of this technique is shown below:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">fn1</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">R1</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="o">{</span><span class="k">def</span><span class="nf">fn2</span><span class="k">:</span><span class="kt">ZIO</span><span class="o">[</span><span class="kt">R2</span>, <span class="kt">E</span>, <span class="kt">B</span><span class="o">]</span><span class="k">=</span><span class="o">...</span><span class="k">val</span><span class="nv">localEnvironment</span><span class="k">:</span><span class="kt">R2</span><span class="o">=</span><span class="o">...</span><span class="k">val</span><span class="nv">v1</span><span class="k">=</span><span class="nv">fn2</span><span class="o">.</span><span class="py">provide</span><span class="o">(</span><span class="n">localEnvironment</span><span class="o">)</span><span class="o">...</span><span class="o">}</span><span class="k">val</span><span class="nv">globalEnvironment</span><span class="k">:</span><span class="kt">R1</span><span class="o">=</span><span class="o">...</span><span class="k">val</span><span class="nv">v2</span><span class="k">=</span><span class="nv">fn1</span><span class="o">.</span><span class="py">provide</span><span class="o">(</span><span class="n">globalEnvironment</span><span class="o">)</span><span class="o">...</span></code></pre></figure><p>This is only one technique to provide vertical modularity. Over time, other techniques may emerge.</p><p>Achieving modularity with tagless-final is possible, but quite difficult and hacky, relying on creating local type class instances. In comparison, modularity is something that other approaches like <code class="language-plaintext highlighter-rouge">Free</code> and MTL excel at.</p><h4 id="incremental">Incremental</h4><p>Unlike tagless-final, a code base that uses no abstraction, which is merely using some base functional effect like <code class="language-plaintext highlighter-rouge">Task</code>, can be modified every-so-slightly to allow testability of something deep in the stack.</p><p>For example, let’s say we have a database call deeply embedded everywhere inside our program:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// Deeply nested code:
</span><span class="k">def</span><span class="nf">myCode</span><span class="k">:</span><span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="err">…</span><span class="k">for</span><span class="o">{</span><span class="o">...</span><span class="n">result</span><span class="k">&lt;-</span><span class="nv">database</span><span class="o">.</span><span class="py">query</span><span class="o">(</span><span class="n">q</span><span class="o">)</span><span class="o">...</span><span class="o">}</span><span class="nf">yield</span><span class="o">()</span></code></pre></figure><p>We would like to be able to test application logic without connecting to a real database, because that will slow our tests down and may fail for unrelated reasons.</p><p>In order to do this, we need merely refactor the <code class="language-plaintext highlighter-rouge">database.query</code> function to require a <code class="language-plaintext highlighter-rouge">Database</code> module. Then with simple introduction of a type synonym, we can leave the code unchanged:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span><span class="kt">TaskDB</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="nc">ZIO</span><span class="o">[</span><span class="kt">Database</span>, <span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span><span class="o">...</span><span class="k">def</span><span class="nf">myCodeV2</span><span class="k">:</span><span class="kt">TaskDB</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="err">…</span><span class="k">for</span><span class="o">{</span><span class="o">...</span><span class="n">result</span><span class="k">&lt;-</span><span class="nv">database</span><span class="o">.</span><span class="py">query</span><span class="o">(</span><span class="n">q</span><span class="o">)</span><span class="o">...</span><span class="o">}</span><span class="nf">yield</span><span class="o">()</span></code></pre></figure><p>All of the other code can stay exactly the same as it is. The only change we needed to make was the type synonym (which we could have called <code class="language-plaintext highlighter-rouge">Task</code>, if we didn’t want to update the type signatures at all), and the single method we wanted to make testable.</p><p>In an ideal world, everything would always be 100% testable; and if we needed to make legacy code testable, we would have the resources necessary to make <em>all</em> the effects testable.</p><p>Yet in the real world, we often don’t have the time or luxury of making our greenfield code <em>fully</em> testable from day one; <em>or</em> of doing giant refactorings to legacy code.</p><p>ZIO Environment lets us make <em>pinpoint</em> changes, and pay for <em>only</em> the cost of testing what we <em>need</em> to test today. As a result, it helps us deal with real world code bases and meet the needs of the business.</p><h2 id="summary">Summary</h2><p>Functional effects can be enormously beneficial to solving modern business problems. Yet as we’ve seen in this approach, because of the way functional effects are implemented, we don’t gain all the benefits of pure functional code.</p><p>While functional effects give us the ability to abstract over our programs and to refactor them without changing their meaning, we can’t easily test functional effects, because we don’t have a way to compare two effects for equality.</p><p>Solutions like tagless-final help us re-introduce testability into our functional applications (along with other benefits, like parametric reasoning). However, they come with a massive ramp up curve, they don’t integrate well into Scala, and their ergonomics, boilerplate, and ceremony can be unpleasant and further alienating to developers.</p><p>The new approach pioneered in ZIO Environment allows us to regain testability, but without any additional ramp up time (beyond the ramp up required for functional effects). It’s friendly to beginning functional programmers, and unlike tagless-final, the new approach is fully inferable, modular, and can be used incrementally, just where we need it.</p><p>For the first time, it feels like Scala has an idiomatic solution for testable functional effects. Something that’s fast, fully inferable, with a low barrier to entry.</p><p>If you’d like to give it a try, head over to the <a href="https://github.com/scalaz/scalaz-zio">ZIO project page</a>, where you will find the <a href="https://scalaz.github.io/scalaz-zio/">ZIO microsite</a> and the <a href="https://gitter.im/scalaz/scalaz-zio">Gitter chatroom</a>.</p><p>As of today, the first release candidate (RC) for ZIO 1.0 has been published, which means a (nearly) stable API and a focus on documentation, polish, and performance. It’s my hope that ZIO 1.0 will be released sometime in March, and that the 1.x line will enjoy at least a full year of backward-compatible tweaks, fine-tunings, and enhancements to the microsite.</p><p>If you’re still using <code class="language-plaintext highlighter-rouge">Future</code> and on the fence about a functional effect system, now’s the perfect time to jump in and give ZIO (or one of the other functional effect systems) a try. You might just find you can’t live without one!</p><p><strong>P.S.</strong> A huge thanks to <a href="https://twitter.com/wiemzin">Wiem Zine Elabidine</a> for her work on ZIO Environment, and to <a href="https://twitter.com/itrvd">Itamar Ravid</a>, <a href="https://twitter.com/regiskuckaertz">Regis Kuckaertz</a>, and <a href="https://twitter.com/kaidaxofficial">Kai</a> for their early feedback on the ZIO Environment project, and to <a href="https://twitter.com/skillsmatter">SkillsMatter</a> for the opportunity to present this work at Scala Matters, London.</p><hr><footer role="contentinfo"><p class="byline"><strong>Beautiful, Simple, Testable Functional Effects for Scala</strong> was published on <time datetime="2019-02-26T00:00:00-07:00" itemprop="datePublished">February 26, 2019</time> by <span itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><span itemprop="name"><a href="http://degoes.net/about" title="About John A De Goes" itemprop="url">John A De Goes</a></span></span>.</p></footer></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>