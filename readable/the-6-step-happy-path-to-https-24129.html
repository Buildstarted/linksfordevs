<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The 6-Step &quot;Happy Path&quot; to HTTPS - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The 6-Step &quot;Happy Path&quot; to HTTPS - linksfor.dev(s)"/>
    <meta property="article:author" content="Troy Hunt"/>
    <meta property="og:description" content="It&#x27;s finally time: it&#x27;s time the pendulum swings further towards the &amp;quot;secure by default&amp;quot; end of the scale than what it ever has before. At least insofar as securing web traffic goes because as of this week&#x27;s Chrome 62&#x27;s launch, any website with an input box is now"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.troyhunt.com/the-6-step-happy-path-to-https/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The 6-Step &quot;Happy Path&quot; to HTTPS</title>
<div class="readable">
        <h1>The 6-Step &quot;Happy Path&quot; to HTTPS</h1>
            <div>by Troy Hunt</div>
            <div>Reading time: 26-33 minutes</div>
        <div>Posted here: 17 May 2019</div>
        <p><a href="https://www.troyhunt.com/the-6-step-happy-path-to-https/">https://www.troyhunt.com/the-6-step-happy-path-to-https/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section>
            <!--kg-card-begin: markdown--><p>It's finally time: it's time the pendulum swings further towards the "secure by default" end of the scale than what it ever has before. At least insofar as securing web traffic goes because as of this week's Chrome 62's launch, any website with an input box is now doing this when served over an insecure connection:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/CNN-Warning-2.jpg" alt="CNN Warning"></p>
<p><a href="https://textslashplain.com/2017/10/18/chrome-field-trials/">It's not doing it immediately for everyone</a>, but don't worry, it's coming very soon even if it hasn't yet arrived for you personally and it's going to take many people by surprise. It shouldn't though because we've known it's coming for quite a while now starting with <a href="https://blog.chromium.org/2017/04/next-steps-toward-more-connection.html">Google's announcement back in April</a>. That was then covered pretty extensively by the tech press as well as on this blog where I wrote about <a href="https://www.troyhunt.com/life-is-about-to-get-harder-for-websites-without-https/">how life is about to get a lot harder for websites without HTTPS</a>. Then back in August, <a href="http://searchengineland.com/google-emails-warnings-webmasters-chrome-will-mark-http-pages-forms-not-secure-280907">Google started emailing site owners</a> and made it very clear what was coming:</p>
<twitter-widget id="twitter-widget-0" data-tweet-id="898308603169439746"></twitter-widget>

<p>But even before that, back in Jan we saw both Chrome and Firefox starting to flag any page with login or credit card fields as "Not secure" so this is just continuing that march. In fact, back at that time I wrote about how <a href="https://www.troyhunt.com/https-adoption-has-reached-the-tipping-point/">HTTPS adoption has reached the tipping point</a> and I pointed to a range of facts supporting that, including the fact that in August last year, <a href="https://scotthelme.co.uk/alexa-top-1-million-crawl-aug-2016/">14% of the Alexa top 1 million sites were now forcing HTTPS</a>. But that wasn't the headline figure, rather it was <em>the rate of change</em> and 12 months later, <a href="https://scotthelme.co.uk/alexa-top-1-million-analysis-aug-2017/">that number was now 31%</a>. Yep, more than doubled in a year.</p>
<p>This will only come as a surprise to folks who haven't been paying attention. Either that or those who, against all evidence, continue to argue that HTTPS is unnecessary. In August, I highlighted how <a href="https://www.troyhunt.com/dont-take-security-advice-from-seo-experts-or-psychics-neil-patel/">SEO "experts" were advising customers against HTTPS based on fundamentally flawed reasoning</a>. Fortunately, even these guys are seeing the light and realising that HTTPS is, in fact, now somewhat of a necessity. However, doing it <em>right</em> can be more difficult than many people think:</p>
<twitter-widget id="twitter-widget-1" data-tweet-id="903475376612974592"></twitter-widget>

<p>Well, it <em>can</em> be more difficult but it can also be fundamentally simple. In this post I want to detail the 6-step "Happy Path", that is the fastest, easiest way you can get HTTPS up and running <em>right</em>. Let's dive into it!</p>
<h2 id="1getafreecert">1. Get a Free Cert</h2>
<p>This is the first thing most people think of when it comes to HTTPS - they need a certificate. There was a day when this would cost money and you'd pay a large company such as Comodo a fistful of dollars for them to issue you a cert, but those days are now behind us. There's now two primary routes you can go in my "Happy Path" and I want to detail both of those here:</p>
<p>Firstly, there's <a href="https://letsencrypt.org/">Let's Encrypt</a>. They've had an <em>enormously</em> positive impact on HTTPS adoption by making certificates available not just for free, but in an automated fashion that takes a lot of the legwork out of installing a cert on your site.</p>
<p>There was a time when Let's Encrypt was a newcomer and understandably, some people were a little reserved about using them. But check out <a href="https://letsencrypt.org/stats/">just how far they've come since just the start of last year</a>:</p>
<p><a href="https://letsencrypt.org/stats/"><img src="https://www.troyhunt.com/content/images/2017/10/Lets-Encrypt-Growth-1.png" alt="Let's Encrypt Growth"></a></p>
<p>The only real vocal criticism of Let's Encrypt has (unsurprisingly) come from commercial certificate authorities. I wrote about this at length in July when I talked about <a href="https://www.troyhunt.com/on-the-perceived-value-ev-certs-cas-phishing-lets-encrypt/">the perceived value of extended validation certs, commercial CAs and phishing</a>. That's essential reading if you've previously been hit with arguments ranging from "you need an EV cert" to "free certs aren't as good" and even "Let's Encrypt helps phishing sites". Read that now if you're not already across these issues and the FUD involved.</p>
<p>The one major <em>practical</em> barrier to Let's Encrypt is lack of first class support in PaaS and SaaS models. Last year I wrote about <a href="https://www.troyhunt.com/everything-you-need-to-know-about-loading-a-free-lets-encrypt-certificate-into-an-azure-website/">what's involved in loading a Let's Encrypt certificate into an Azure app service</a> and I concluded that as it stands, it's a risky model. Still to this day, I would not use Let's Encrypt in this way, there's a much better way...</p>
<p>That way is <a href="https://www.cloudflare.com/">Cloudflare</a>. I <em>love</em> the service that Cloudflare provides because it's not just about HTTPS. Like Let's Encrypt, it's free if all you want is a cert on your site and it's also highly automated, but where it differs is that Cloudflare is a globally distributed CDN with 118 edge nodes around the world:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Cloudflare-Edge-Nodes-1.png" alt="Cloudflare-Edge-Nodes-1"></p>
<p>What this means is that they don't just do free certs, they can also cache content, optimise traffic and block threats such as DDoS attacks. They can do this because your traffic literally routes through their infrastructure. Now on the one hand, this worries some people and frankly, those concerns are largely unfounded and I address them in my post on <a href="https://www.troyhunt.com/cloudflare-ssl-and-unhealthy-security-absolutism/">unhealthy security absolutism</a>. On the other hand, when an intermediary has the ability to modify your traffic on the fly, you can do some enormously cool things and I'm going to keep coming back to those throughout the remainder of this post.</p>
<p>My strong recommendation is Cloudflare not because there's anything wrong with Let's Encrypt - quite the opposite, I think they're awesome - but rather because there's so much more value to be had from a reverse proxy. I run this blog through them using their free service and I also run <a href="https://haveibeenpwned.com/">Have I been pwned</a> (HIBP) through Cloudflare which has made an <em>enormously</em> positive impact on the sustainability of the site.</p>
<p>Ok, so that's certs, but now we need to make some changes on the site too so let's jump into that next.</p>
<h2 id="2adda301permanentredirect">2. Add a 301 "Permanent Redirect"</h2>
<p>What we need to start doing now is ensuring that whenever a request comes in over the HTTP scheme, the site tells the browser that instead it must request that same content over the secure scheme. We do that with the <a href="https://en.wikipedia.org/wiki/HTTP_301">HTTP 301 response code</a> which indicates that the resource has "Moved Permanently". This is accompanied by a "Location" response header which indicates the new URL the browser should issue the request to.</p>
<p>For example, imagine making an insecure request to this blog:</p>
<p><code>GET http://www.troyhunt.com/ HTTP/1.1</code></p>
<p>When my site receives that request, it will respond like this:</p>
<pre><code>HTTP/1.1 301 Moved Permanently
Location: https://www.troyhunt.com/
</code></pre>
<p>The browser then turns around and makes a near-identical request to the first one, albeit it over the secure scheme:</p>
<p><code>GET https://www.troyhunt.com/ HTTP/1.1</code></p>
<p>How you implement this depends on your framework of choice. For example, <a href="https://blogs.technet.microsoft.com/dawiese/2016/06/07/redirect-from-http-to-https-using-the-iis-url-rewrite-module/">in ASP.NET you could use a URL Rewrite rule</a>. This is a simple configuration that can go into your web.config and constitutes a "no code" fix. Obviously, you're going to tackle a PHP or a Node site differently, but you get the idea.</p>
<p>An even cleaner way to tackle this is with Cloudflare. Remember that bit where I said there's a bunch of additional value to be had from a reverse proxy? How's this for an easy fix:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Always-Use-HTTPS.png" alt="Always Use HTTPS"></p>
<p>Toggling this switch allows Cloudflare to add the 301 response header on the fly so that you don't need to modify the site itself. It doesn't matter what tech stack you're running on, you simply hit the button and it's job done.</p>
<p>The 301 is necessary, but there's also a couple of problems. Firstly, you're forcing the user's browser to make an extra request. Every single time they attempt to load <em>any</em> resource on the site insecurely, the browser is going to need to make a subsequent request to the secure scheme after the 301 comes back so it's not great in terms of performance. But more serious than that from a security perspective is that the first request - the insecure one - can be intercepted and modified. This is exactly the sort of thing we're trying to protect people from in the first place and whilst every request <em>after</em> that first one the gets 301'd is good, we still need to protect it as well. Which brings us to HSTS.</p>
<h2 id="3addhsts">3. Add HSTS</h2>
<p>HSTS stands for "HTTP Strict Transport Security" - and it's <em>awesome!</em> <a href="https://www.troyhunt.com/understanding-http-strict-transport/">I've written about it before in depth</a> so I won't repeat everything here but for the sake of completeness in this post, we'll go through it again briefly.</p>
<p>The 301 situation left us with a risk in that any insecure requests could still be read by someone with access to the traffic. Sensitive data like any cookies sent with the request could be read and then the response itself could be manipulated. It's sub-optimal. HSTS changes that (to a degree) by way of a simple response header such as the one on this very blog:</p>
<p><code>Strict-Transport-Security: max-age=31536000</code></p>
<p>When returned over a secure connection, this header tells the browser that for the next 31,536,000 seconds (that's one year's worth of seconds), it may not make an insecure request to the site. If (for whatever reason), the browser then makes an insecure request - say by me explicitly typing <a href="http://www.troyhunt.com/">http://www.troyhunt.com</a> into the address bar - this happens:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/HSTS-Redirect.png" alt="HSTS Redirect"></p>
<p>What you're seeing here an HTTP 307 "Internal Redirect" followed by a secure request. This is the browser upgrading the request internally before sending it out over the wire. The really neat thing about this is that it avoids the problem we just had with the 301 where we could keep issuing insecure requests. Or does it?</p>
<p>The remaining problem with this model is known as "Trust On First Use" or TOFU; the browser needs to get <em>one good request</em> without it being intercepted in order to get the response header in the first place. This is where preload comes into play and <a href="https://haveibeenpwned.com/">you can see it in action on HIBP</a> as follows:</p>
<p><code>Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</code></p>
<p>Now this looks very similar to before except for two new directives:</p>
<ol>
<li>includeSubDomains does exactly what it sounds like it does</li>
<li>preload enables browser vendors to bake it into the browser itself</li>
</ol>
<p>That second item is the key because it means you can then head over to <a href="https://hstspreload.org/">hstspreload.org</a> and submit the site for preloading. That service is run by the Chromium Project and <em>all</em> the major browser manufacturers use sites submitted there to ensure that their browsers can't serve any content from those domains insecurely. <em>Ever!</em></p>
<p>And just in case you're wondering about browser support for HSTS, <a href="http://caniuse.com/#search=hsts">it's <em>very</em> broad</a>:</p>
<p><a href="http://caniuse.com/#search=hsts"><img src="https://www.troyhunt.com/content/images/2017/10/STS-Support.png" alt="HSTS-Support"></a></p>
<p>Now, why don't I preload this very blog? Because amongst <a href="https://hstspreload.org/">the requirements for preloading</a> is this one:</p>
<blockquote>
<p>The includeSubDomains directive must be specified</p>
</blockquote>
<p>Which is problematic because I need to run <a href="http://hackyourselffirst.troyhunt.com/">hackyourselffirst.troyhunt.com</a> over the insecure scheme so that when I run my workshops I can demonstrate what goes wrong when you don't get your HTTPS right! Ideally, I need to put this on a standalone domain so that I can get troyhunt.com preloaded and certainly that's on the cards.</p>
<p>In terms of implementing HSTS, it's just a response header you'll need to return upon an incoming request to the site. For the ASP.NET folks, check out <a href="https://www.nuget.org/packages/NWebsec/">NWebsec on NuGet</a> which is made by fellow developer security MVP AndrÃ© Klingsheim. That makes it dead simple to setup via the web.config like so:</p>
<p><code>&lt;strict-Transport-Security max-age="365" includeSubdomains="true" preload="true" /&gt;</code></p>
<p>Or just like with the 301 redirects, you can easily add it via a web interface if you're routing your traffic through Cloudflare:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Cloudflare-HSTS.png" alt="Cloudflare-HSTS"></p>
<p>Now you <em>definitely</em> want to be confident that you're always going to be serving traffic over HTTPS all of the time once you go down this route (especially with preload) but frankly, that's where you should be by now anyway.</p>
<p>Oh - and just as a very timely example of why HSTS with preload is important, the security news earlier this week was dominated by <a href="https://www.krackattacks.com/">the KRACK attack against wifi networks</a>. On that page, Mathy shows how match.com traffic could be intercepted using a combination of his WPA2 attack and <a href="https://moxie.org/software/sslstrip/">sslstrip</a>. This is only possible because there is no preloaded HSTS (even HSTS <em>without</em> preload would still save many returning visitors). With this in place, the traffic can't be downgraded to force HTTP connections as the browser simply won't allow it. Frankly, the whole match.com page load experience is pretty terrible:</p>
<twitter-widget id="twitter-widget-2" data-tweet-id="920073199445950464"></twitter-widget>

<p>For all the press this exploit has received over the last couple of days, it's amazing how simple it is to secure individual websites against it, you just need traffic served securely and a single response header plus preload.</p>
<h2 id="4changeinsecureschemereferences">4. Change Insecure Scheme References</h2>
<p>And now for the hard part. Actually, let me talk about what is <em>traditionally</em> the hard part then I'll talk about how to make it easy.</p>
<p>Once you go HTTPS, <em>everything on the page must be served securely</em>. Remember the SEO bloke in his pyjamas earlier who told people not to use HTTPS then deleted my comment saying you <em>should</em> use HTTPS then deleted his video saying you shouldn't use HTTPS then went and implemented HTTPS on his own site but got browser warnings? Visitors to his site were loading the page over HTTPS but didn't get a padlock, didn't get the "Secure" text next to the address bar and didn't get the HTTPS scheme represented in green. In fact, the browser security indicators looked exactly like <a href="https://mixed.badssl.com/">this example from badssl.com</a>:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Mixed-Content.png" alt="Mixed-Content"></p>
<p>This is simply because the image you see on the page above was embedded insecurely. (Incidentally, the image still loads as it's "passive content" in that it can't change anything, but <a href="https://mixed-script.badssl.com/">try it with "active content" like a script tag</a> and it will be blocked from loading in the first place.) Here's the root cause:</p>
<p><code>&lt;img class="mixed" src="http://mixed.badssl.com/image.jpg" alt="HTTP image"&gt;</code></p>
<p>It's simply embedding the image insecurely and there are many different ways to easily fix this:</p>
<p><code>&lt;img class="mixed" src="https://mixed.badssl.com/image.jpg" alt="HTTP image"&gt;</code></p>
<p><code>&lt;img class="mixed" src="//mixed.badssl.com/image.jpg" alt="HTTP image"&gt;</code></p>
<p><code>&lt;img class="mixed" src="image.jpg" alt="HTTP image"&gt;</code></p>
<p>Any one of these will immediately solve the problem... with that one image embedded in that one location. But that's not how web pages operate, rather they have a raft of images, style sheets JavaScript files and all sorts of other content embedded not just once on the one page, but all over the place. When moving to HTTPS, these need to be fixed which yes, means a lot of changes.</p>
<p>But this is where Cloudflare can help again (you seeing a theme here?) and it does so with what they call <a href="https://support.cloudflare.com/hc/en-us/articles/227227647-How-do-I-use-Automatic-HTTPS-Rewrites-">Automatic HTTPS Rewrites</a>:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Automatic-HTTPS-Rewrites.png" alt="Automatic-HTTPS-Rewrites"></p>
<p>The explanation in the image above is pretty self-explanatory and once again, when an intermediary can control the traffic then they can do some pretty awesome things with it. This is more intelligent than simply changing every HTTP source to HTTPS though:</p>
<blockquote>
<p>Only URLs that are known to support HTTPS will be rewritten. We use data from EFFâ€™s HTTPS Everywhere and Chromeâ€™s HSTS preload list, among others, to identify which domains support HTTPS.</p>
</blockquote>
<p>This is great and it helps enormously, but whether you're manually fixing insecure scheme references yourself or delegating the work to Cloudflare, there's another problem: what happens if <em>another</em> service you're using makes an insecure request? I mean you might embed, say, Disqus securely on your site but what happens if their JavaScript which you're embedding from their site then loads an image over HTTP? There's another easy answer for that one, and it involves another header.</p>
<h2 id="5addtheupgradeinsecurerequestscsp">5. Add The upgrade-insecure-requests CSP</h2>
<p>Let's go back to badssl.com for a moment and play with <a href="https://upgrade.badssl.com/">the "upgrade" demo</a>:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Upgraded-Request-1.png" alt="Upgraded-Request"></p>
<p>It looks normal, right? But check out the HTML source:</p>
<p><code>&lt;img id="http-vs-https" src="http://upgrade.badssl.com/upgrade-test/upgrade-test.svg" title="This is an image with an HTTP source location specified. If upgrade-insecure-requests is working, the source should be rewritten to HTTPS. The image will vary depending on the outcome."&gt;</code></p>
<p>I love the title attribute on that image because it saves me the work of explaining it :) This is all achieved by virtue of a Content Security Policy response header, otherwise known as a CSP:</p>
<p><code>Content-Security-Policy: upgrade-insecure-requests</code></p>
<p>What makes this awesome is that even if you screw up every single reference for embedded content on your site, this header will <em>automatically</em> fix it for you. Of all the things I'm imparting in this blog post, this is the one that I find is least frequently known and has the greatest impact on how easy it can be to implement HTTPS.</p>
<p>But as I alluded to at the end of the previous section on updating all your links, the joy of this CSP is that it can also fix downstream dependencies loaded insecurely by other services. Last year I wrote about <a href="https://www.troyhunt.com/disqus-mixed-content-problem-and-fixing-it-with-a-csp/">how Disqus caused browser warnings to be shown on my blog</a> and per the earlier example, it was simply because they screwed up and started embedding content insecurely in a location well beyond my control.</p>
<p>My website actually runs on <a href="https://ghost.org/pricing/">Ghost Pro</a> which is a hosted SaaS model and that meant I had zero control over headers - I couldn't even add the CSP via Cloudflare. However, you can also embed a CSP as a meta tag and if you view the source of this very page, you'll see the following:</p>
<p><code>&lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"&gt;</code></p>
<p>I actually use <a href="https://help.ghost.org/hc/en-us/articles/223403488-Code-Injection">their Code Injection feature</a> to add this in so I didn't even need to change my template:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Ghost-Code-Injection.png" alt="Ghost-Code-Injection"></p>
<p>And just to add another Cloudflare angle to this, it's not yet available at the time of writing, but <a href="https://blog.cloudflare.com/introducing-cloudflare-workers/">Cloudflare Workers</a> should make this a breeze:</p>
<twitter-widget id="twitter-widget-3" data-tweet-id="913954045064122368"></twitter-widget>

<p>I'll certainly write more about this feature once it lands because it's going to open up a world of opportunities and make features like a CSP in response headers dead simple to implement.</p>
<p>So, upgrade-insecure-requests is an awesome approach - what's not to love?! Well...</p>
<p><a href="https://caniuse.com/#search=upgrade"><img src="https://www.troyhunt.com/content/images/2017/10/Upgrade-Insecure-Requests-Support.png" alt="upgrade-insecure-requests Support"></a></p>
<p>This is frustrating, particularly for someone as Microsoft aligned as myself, and believe me when I say I continually raise this issue at every opportunity. People using Microsoft's browsers simply won't get the benefit of upgrade-insecure-requests so when we load up that test site in Edge, we see this:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Edge-Upgrade-Insecure-Requests.png" alt="Edge Upgrade Insecure Requests"></p>
<p>Edge is actually missing the padlock which is usually present on an HTTPS page which loads all child content securely:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Padlock-in-Edge.png" alt="Padlock in Edge"></p>
<p>This is one of the key reasons why it's still so important to get embedded content referenced over the secure scheme. However, there's another angle to all this which can help you complete that happy path and yes, it even makes for a happy experience on Edge!</p>
<h2 id="6monitorcspreports">6. Monitor CSP Reports</h2>
<p>One of the really neat features of content security policies is that you can configure them to report violations back to a URI of your choosing. This is (currently) achieved by using <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-uri">the report-uri directive</a> and it means that when a CSP is violated, you can get a neat report of what went wrong submitted directly by the user's browser. You can see precisely what this looks like via <a href="https://reporturidemos.azurewebsites.net/upgrade-https-and-report">this little demo I set up</a>:</p>
<p><a href="https://reporturidemos.azurewebsites.net/upgrade-https-and-report"><img src="https://www.troyhunt.com/content/images/2017/10/Report-URI-Demo-1.png" alt="Upgrade-and-Report"></a></p>
<p>Let's break down what's happening here: the page is obviously requested over HTTPS but the image and JavaScript are both embedded insecurely like this:</p>
<pre><code>&lt;img src="http://reporturidemos.azurewebsites.net/images/logo.png" /&gt;
&lt;script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;
</code></pre>
<p>Yet we see green bits and a padlock in the address bar which means that everything is secure. It's secure because of the upgrade-insecure-requests CSP discussed above:</p>
<p><code>Content-Security-Policy: upgrade-insecure-requests</code></p>
<p>So far that's nothing new, but now check out the other header I've added:</p>
<p><code>Content-Security-Policy-Report-Only: default-src https:;report-uri https://demo.report-uri.io/r/default/csp/enforce</code></p>
<p>This is a "report only" CSP which means that it doesn't <em>enforce</em> the policy, it merely <em>reports on violations</em>. The content is then set to declare that default-src (so basically the default policy for everything) requires that content be loaded over HTTPS. When an asset is found <em>not</em> loaded over HTTPS, a report is issued to the address after the report-uri directive (I'll come back to the significance of the demo.report-uri.io host name a bit later). By using a CSP in conjunction with a CSPRO (report only), we can get the benefit of both the insecure requests being upgraded <em>and</em> then reported. What that means is that you see the following network requests when loading the page:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Report-URI-Requests-1.png" alt="Report URI Requests"></p>
<p>You'll see the initial request for the page itself followed by a request for the image which was <em>embedded</em> over HTTP yet had the request <em>upgraded</em> to HTTPS and then one for jQuery, again embedded over HTTP which was then upgraded. Then there's the two "enforce" requests which we're seeing because that word is the last part of the path in the report-uri directive earlier on. There's 2 requests because every single CSP violation causes 1 to be fired. These are POST requests and they contain a JSON payload explaining precisely what went wrong:</p>
<pre><code>{  
   "csp-report":{  
      "document-uri":"https://reporturidemos.azurewebsites.net/upgrade-https-and-report",
      "referrer":"https://www.troyhunt.com/the-6-step-happy-path-to-https",
      "violated-directive":"img-src",
      "effective-directive":"img-src",
      "original-policy":"default-src https:;report-uri https://demo.report-uri.io/r/default/csp/enforce",
      "disposition":"report",
      "blocked-uri":"http://reporturidemos.azurewebsites.net/images/logo.png",
      "line-number":9,
      "source-file":"https://reporturidemos.azurewebsites.net/upgrade-https-and-report",
      "status-code":0,
      "script-sample":""
   }
}
</code></pre>
<p>This is the one for the image and we can see from the JSON above that the blocked-uri was an HTTP request made to the image and that the document-uri (the page that caused the violation) was our test page. I also clicked through to that page from this blog post so you see the referrer being the URL of this page too. This has everything you need to now track down the root cause of the mixed content and fix it at the source. And here's another cool thing - the reporting works in Edge too:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Edge-Reporting.png" alt="Edge-Reporting"></p>
<p>Even though neither of Microsoft's browsers understand upgrade-insecure-requests, Edge implements most of the CSP level 2 spec which means it's able to understand (and report on) the CSPRO which demanded HTTPS. No, this won't cause the content to be loaded securely (the image still loaded over HTTP and the script didn't load at all because it's "active content"), but now that you're getting reports you can actually do something about it. Which brings us to the final part of the "Happy Path" - Report URI.</p>
<p>The thing with CSP violation reports is that they can get <em>seriously</em> voluminous. Think about it - you have a site template with a few assets embedded insecurely and each page inherits from that template. Then you have thousands or tens of thousands or however many people coming by the site each day. It's a lot of requests. Furthermore, they're all just the JSON you saw earlier on, you still need to do something useful with that in terms of parsing and reporting on it.</p>
<p>This is where <a href="https://report-uri.io/">the Report URI service</a> comes in. This is a project stood up by my good friend <a href="https://scotthelme.co.uk/">Scott Helme</a> a few years back (Scott is behind the Alexa Top 1 Million reports I referenced earlier). He makes this service available to anyone who wants to lodge their reports there and you can get into it for free. There's commercial plans available if you want to help Scott support what he does, but the free tier is enough to start working out what's going on in terms of mixed content.</p>
<p>For example, here's a sample report for that demo site:</p>
<p><img src="https://www.troyhunt.com/content/images/2017/10/Report-URI-Report.png" alt="Report URI Report"></p>
<p>So now for me as a site owner, I can review the entries on Report URI and see precisely where I've got mixed content on my site. It's all aggregated into the one place which makes it dead simple to review before heading into the code of the site and fixing any broken references. But of course, with upgrade-insecure-requests, things would only break in the Microsoft browsers anyway so the vast majority of people they've already had a seamless experience but their browsers have kindly done the work of letting me know there's a problem anyway.</p>
<p>I love the way this rounds out the "Happy Path": get a free cert, implement the 301 redirect, add HSTS, change your insecure references, use the CSP to fix any of the ones you've missed in non-MS browsers then finally, sit back and watch for any violations by reporting to the free Report URI service. HTTPS doesn't have to be hard, you just have to follow the happy path ðŸ˜€</p>
<h2 id="gotchasandotherconsiderations">Gotchas and Other Considerations</h2>
<p>This can be a super-easy process and for the vast majority of sites out there, you can knock this off in an afternoon if not within an hour. But I don't want to overly trivialise it either and there are certainly various gotchas along the way.</p>
<p>For example, if you run a website like Stack Overflow which is the 55th most traffic'd in the world, <a href="https://nickcraver.com/blog/2017/05/22/https-on-stack-overflow/">things are somewhat trickier</a>. Complex applications running at scale introduce all sorts of other issues.</p>
<p>Even for smaller apps, putting them behind Cloudflare can throw some curve balls. For example, when I moved HIBP behind them I needed to update code that records the client's IP address because the nature of a reverse proxy means I was seeing the address of their edge node. Instead, I needed to look for <a href="https://support.cloudflare.com/hc/en-us/articles/200170986-How-does-Cloudflare-handle-HTTP-Request-headers-">the CF-Connecting-IP request header they add to the inbound traffic</a> and refer to that instead.</p>
<p>As for HSTS, it's awesome but it's also a bit of a one-way street, especially once using preload. You <em>should</em> use HSTS and you <em>should</em> preload, but I wouldn't begrudge anyone wanting to give it a few weeks in between going HTTPS, adding HSTS with a short max age then eventually preloading.</p>
<p>There are other aspects of implementing HTTPS <em>comprehensively</em> I haven't touched on here either. For example, flagging cookies as "secure" so they can't be passed over an insecure connection and also updating other references to the site to use HTTPS. Think about things like social media channels and email footers - you really want them referencing the secure scheme as well. Mind you, once HSTS is rolled out with preload that matters a lot less, but you still need browser vendors to bake in that preload list, roll out updates and customers to actually take them.</p>
<p>A classic argument <em>against</em> HTTPS is that every external service you embed must also support the secure scheme. It's extremely rare that this is a problem in this day and age, but there was a time when the likes of Google Adwords didn't and obviously that would present all sorts of dramas. Do check those dependencies if you're at all uncertain they can be embedded securely.</p>
<p>Cyclical redirects is another one I've seen a few times and some odd things can happen there. I've seen cases where someone is redirecting from HTTP to HTTPS but the HTTPS call then redirects back to another path on HTTP. It's a screwy scenario usually solved pretty quickly, but especially once combined with things like a canonical URL redirect (i.e. troyhunt.com redirects to www.troyhunt.com), then it can catch people out.</p>
<p>And finally, if you're going down that Cloudflare route as I've so emphatically suggested, I'd begin by making sure that everything plays nice over HTTP first. Give the site a comprehensive test and look for those little gotchas like the client IP I mentioned earlier first. It's a lot easier to iron those out first <em>and then</em> do the HTTPS thing than it is to try and troubleshoot everything at once.</p>
<h2 id="furtherresources">Further Resources</h2>
<p>Even with insurmountable volumes of evidence speaking to why HTTPS is important, there remain naysayers. Some of the comments on the blog posts I've linked to still astound me with some folks even suggesting it's a Google conspiracy theory. Frankly, I don't care because this isn't a negotiation; you either get HTTPS or your users get told the site is insecure. Don't bother arguing that you <em>don't</em> need HTTPS, invest that energy reading <a href="https://doesmysiteneedhttps.com/">doesmysiteneedhttps.com</a> instead.</p>
<p>A couple of additional favourite resources for those naysayers are <a href="https://istlsfastyet.com/">istlsfastyet.com</a> and <a href="http://www.httpvshttps.com/">HTTP vs HTTPS</a>. The latter in particular is a favourite as it totally turns conventional wisdom about the speed cost of HTTPS on its head. No, it's not fair and no, I don't care because as I've said before, <a href="https://www.troyhunt.com/i-wanna-go-fast-https-massive-speed-advantage/">I just wanna go fast</a>.</p>
<p>And finally, I'll leave you with a resource of my own which has proven pretty popular:</p>
<twitter-widget id="twitter-widget-4" data-tweet-id="852442262688550912"></twitter-widget>

<p><a href="https://app.pluralsight.com/library/courses/https-every-developer-must-know/table-of-contents">There's 3 and a half hours of HTTPS training on Pluralsight</a> and this course rocketed to as high as the 8th most popular out of a library of more than 6,000 recently. It's still rating 4.9 stars out of 5 too so if you really want to get into detail, check that out too. It turns out that people can actually find HTTPS pretty interesting ðŸ˜€</p>
<!--kg-card-end: markdown-->

            <section>
                <a href="https://www.troyhunt.com/tag/security/">Security</a>
                <a href="https://www.troyhunt.com/tag/ssl/">SSL</a>
                <a href="https://www.troyhunt.com/tag/csp/">CSP</a>
            </section>
        </section></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>