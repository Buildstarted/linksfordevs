<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A Fast and Lightweight Solution for CQRS and Event Sourcing - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="A Fast and Lightweight Solution for CQRS and Event Sourcing - linksfor.dev(s)"/>
    <meta property="article:author" content="Daniel Miller"/>
    <meta property="og:description" content="Describes a fast, lightweight implementation of the CQRS&#x2B;ES pattern using C#"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.codeproject.com/Articles/5264244/A-Fast-and-Lightweight-Solution-for-CQRS-and-Event"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A Fast and Lightweight Solution for CQRS and Event Sourcing</title>
<div class="readable">
        <h1>A Fast and Lightweight Solution for CQRS and Event Sourcing</h1>
            <div>by Daniel Miller</div>
            <div>Reading time: 45-57 minutes</div>
        <div>Posted here: 09 Apr 2020</div>
        <p><a href="https://www.codeproject.com/Articles/5264244/A-Fast-and-Lightweight-Solution-for-CQRS-and-Event">https://www.codeproject.com/Articles/5264244/A-Fast-and-Lightweight-Solution-for-CQRS-and-Event</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>The purpose of this article is to present a fast and lightweight implementation of the CQRS+ES pattern using the C# programming language and the .NET Framework. This implementation is relatively full-featured, including support for SQL Server serialization of commands and events, scheduled commands, snapshots, sagas (i.e., process managers), and plug-and-play overrides for multitenant customization. I will describe how the code is structured, and illustrate how it works with a sample application.</p><div id="contentdiv">
						



<h2>Introduction</h2>

<p>If you are reading this article then you probably already know something about Command Query Responsibility Segregation (CQRS) and Event Sourcing (ES), so I won't explain what that is, why you might want to use it, or why you might want to avoid it. There is a lot of good information available if you are looking for that kind of material.</p>

<p>For example:</p>

<ul>
	<li>	<p><a href="https://www.pluralsight.com/courses/cqrs-in-practice">CQRS in Practice</a></p>
	</li>	<li>	<p><a href="https://martinfowler.com/bliki/CQRS.html">CQRS by Martin Fowler</a></p>
	</li>	<li>	<p><a href="https://microservices.io/patterns/data/event-sourcing.html">Event Sourcing Pattern (Microservices.io)</a> or <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing">Event Sourcing Patterm (Microsoft.com)</a></p>
	</li>	<li>	<p><a href="https://www.continuousimprover.com/2017/11/event-sourcing-good-bad-and-ugly.html">Event Sourcing: The Good, the Bad, and the Ugly</a></p>
	</li>	<li>	<p><a href="https://medium.com/@hugo.oliveira.rocha/what-they-dont-tell-you-about-event-sourcing-6afc23c69e9a">What They Don't Tell You About Event Sourcing</a></p>
	</li></ul>

<p>The purpose of this article is to present a fast and lightweight implementation using the C# programming language and the .NET Framework.</p>

<p>This implementation is relatively full-featured, including support for SQL Server persistence of commands and events, scheduled commands, snapshots, sagas (i.e., process managers), snapshots, and plug-and-play overrides for multitenant customization.</p>

<p>I will describe how the code is structured and illustrate how it works with a sample application that follows the <a>Clean Architecture</a> pattern.</p>

<h2>Why Bother?</h2>

<p>That is almost certain to be your first question.</p>

<p>There are many CQRS+ES frameworks and solutions already out there, fully-developed and well-proven. If you are researching your options and evaluating a build-vs-buy decision, then there are excellent commercial products and open-source alternatives from which to choose.</p>

<p>For example:</p>

<ul>
	<li>	<p><a href="https://eventstore.com/">Event Store</a></p>
	</li>	<li>	<p><a href="http://geteventflow.net/">EventFlow</a></p>
	</li>	<li>	<p><a href="https://github.com/gautema/CQRSlite">CQRSlite</a></p>
	</li>	<li>	<p><a href="https://github.com/tyronegroves/SimpleCQRS">SimpleCQRS</a></p>
	</li></ul>

<p>Why implement another solution? Why have I started from scratch and developed my own?</p>

<p>I have studied and worked with CQRS and ES patterns for several years now. I have used both commercial and open-source solutions, and I have used them to build and/or improve real-world production systems. If your background and experience is similar to mine then you probably know the answer to that question already, but you might not want to believe it's true (as I did not for a long time):</p>

<p><strong>If you are serious about adopting a CQRS+ES architecture then you might have no choice except to build your own.</strong></p>

<p>As Chris Kiehl says in his article, "<a href="https://chriskiehl.com/article/event-sourcing-is-hard">Event Sourcing is Hard</a>":</p>

<blockquote>
<p>... you're probably going to be building the core components from scratch. Frameworks in this area tend to be heavyweight, overly prescriptive, and inflexible in terms of tech stacks. If you want to get something up in running ... rolling your own is the way to go (<a href="https://youtu.be/LDW0QWie21s?t=1926">and a suggested approach</a>).</p>
</blockquote>

<p>If that's the case, then how does it help you for me to write this article?</p>

<p>Simple: it's another example, with source code, so you can see how I have solved some of the problems that arise in a CQRS+ES solution. If you are starting out on a CQRS+ES project then you should study all the examples you can find.</p>

<p>I do not expect (or recommend) that you take this source code and incorporate it into any application you develop.</p>

<p>Instead, my intent is only to provide yet another example, from which you can draw some ideas - and perhaps (if I do a decent job of this) some small inspiration - for your own project.</p>

<h2>Priorities</h2>

<p>It is important to begin with a list of the priorities driving this implementation.</p>

<p>There are significant trade-offs to many of the design decisions I have made. CQRS+ES purists will object to some of my decisions, and flatly condemn others. I can live with that.</p>

<p>I have been designing and developing software for a long time (longer than I am prepared to admit here). I have shed more than a little blood, sweat, and gray hair - so I am acutely aware of the cost associated with a poor choice in the face of some trade-off decision.</p>

<p>The following priorities help to inform and guide those decisions. They are listed in rough order of importance, but <em>all</em> are requirements, so pour yourself a drink and settle in, because the preamble here is a long one</p>

<h3>1. Readability</h3>

<p>The code must be <em>readable</em>.</p>

<p>The more readable the code, the more usable and maintainable and extensible it is.</p>

<p>In some implementations I have used (and in some implementations I have developed myself), the code for the underlying CQRS+ES backbone is virtually impossible for anyone to understand except the original author. We cannot allow that here. It must be possible - and relatively easy - for a small team of developers to share and use the code, with a full understanding of how it works and why it is written in the way that it is.</p>

<p>It is especially important that the code for registering command handlers and event handlers is simple and explicit.</p>

<p>Many CQRS+ES frameworks use a mix of reflection and dependency injection to automate the registration of subscribers for handling commands and events. While this is often very clever - and often decreases the overall number of lines of code in the project - it hides the relationships between a command (or an event) and its subscriber(s), moving those relationships into an opaque, magical black-box. Many inversion-of-control (IoC) containers make this easy to do, hence the understandable temptation, but I believe it's a mistake.</p>

<p>To be clear: it is not a mistake to use an IoC container in your project. Dependency injection is an excellent best practice and an important technique to perfect. However, the <a href="https://en.wikipedia.org/wiki/Dependency_injection">dependency injection pattern</a> is not itself a <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">publish-subscribe pattern</a>, and conflating the two can lead to a lot of misery and woe. It is a mistake (I have made myself) to use highly specialized features in an IoC container library to automate functionality that is on the outside edge of that library's intended purpose, and then tightly couple the most critical components in your software architecture to that. When something in your application behaves unexpectedly, this can make it extraordinarily difficult and time-consuming to troubleshoot and debug.</p>

<p>Therefore, as part this readability goal, the registration of command handlers and event handlers must be defined <em>explicitly</em> in the code, and not <em>implicitly</em> via convention or automation.</p>

<h3>2. Performance</h3>

<p>The code must be <em>fast</em>.</p>

<p>Handling commands and events is at the heart of any system developed on a CQRS+ES architecture, so throughput optimization is a key performance indicator.</p>

<p>The implementation must handle the maximum possible volume, in terms of concurrent users and systems issuing commands and observing the effect of published events.</p>

<p>In some of my previous implementations, a lot of pain and suffering was caused by concurrency violations that occurred when commands were sent to large aggregates (e.g., long-lived aggregates with massive event streams). More often than not, the root cause was poor-performing code. Therefore algorithm optimization is critical.</p>

<p>Snapshots are integral to satisfying this requirement, therefore must be integral to the solution. The implementation must have built-in support for automated snapshots on every aggregate root.</p>

<p>In-memory cache is another important part of run-time optimization, therefore must be integral to the solution as well.</p>

<h3>3. Debuggability</h3>

<p>It must be easy to trace the code and follow its execution using a standard debugger like the Visual Studio IDE debugger.</p>

<p>I have seen more than a few CQRS+ES implementations rely on complex algorithms for dynamic registration, lookup, and invocation of methods for handling commands and events.</p>

<p>Again, many of these algorithms are extremely clever: they pack a lot of power and flexibility, and can significantly decrease the number of lines of code in the solution.</p>

<p>For example, I have used a <a href="https://gist.github.com/Daniel-Miller/902a7b435a7409941696c07eb5dd87e1">DynamicInvoker</a> class in some of my own past projects. It's an ingenious bit of code - less than 150 lines - and it works beautifully. (I didn't write it, so I'm not boasting when I say that.) However, if something goes haywire in code you've written to call methods on this kind of class, and if you need to step through it with a debugger, then you'll need to be especially adept at the mental gymnastics required to follow what's going on. I am not, so if any dynamic invocation is used then it must be trivially easy to understand the code and follow the thread of its execution when using a debugger.</p>

<h3>4. Minimal Dependencies</h3>

<p>External dependencies must be kept to an absolute bare-metal minimum.</p>

<p>Too many dependencies lead to code that is slower, heavier, and more brittle than you are likely to want in any critical components of your system. Minimizing dependencies helps to ensure your code is faster, lighter, and more robust.</p>

<p>Most important, minimizing dependencies helps to ensure the solution is not tightly coupled with any external assembly, service, or component unless that dependency is critical.</p>

<p>If the fundamental architecture of your software is dependent upon some external third-party component, then you must be prepared for the potential that changes to it might someday have an impact on your project. Sometimes this is an acceptable risk, other times it is not.</p>

<p>In this particular implementation, tolerance for this risk is very, very low.</p>

<p>Therefore, you will notice the core Timeline assembly (which implements the CQRS+ES backbone) has one and only one external dependency: i.e., the System namespace in the .NET Framework.</p>

<blockquote>
<p>Just a quick aside here, because it is an interesting article that illustrates my point: At the time <a href="https://www.techrepublic.com/article/why-its-finally-time-for-developers-to-address-the-chaos-of-node-js-and-npm/">this article</a> was written in 2018, the NPM JavaScript package "is-odd" had over 2.8 million installations in a single week. Rather than write the basic code for a function to return true if a number is odd, all those developers chose to incorporate the is-odd package into their solutions - along with its chain of 300+ dependencies!</p>
</blockquote>

<h3>5. Separate Commands and Events</h3>

<p>Many CQRS+ES frameworks implement a Command class and an Event class in such a way that both derive from a common base class.</p>

<p>The rationale for this obvious: it is natural to think of both Commands and Events as subtypes of a general-purpose Message. Both are "sent" using some form of "service bus", so why not implement common features in a shared base class, and write one dual-purpose class for routing messages - rather than write a lot of duplicate code?</p>

<p>This is an approach I have taken in the past, and there are good arguments for it.</p>

<p>However, I now believe it might be a mistake. To quote <a href="https://www.informit.com/authors/bio/361a5e70-f1e2-432b-9928-b30b4742ae80">Robert C. Martin</a>:</p>

<blockquote>
<p>Software developers often fall into a trap - a trap that hinges on their fear of duplication. Duplication is generally a bad thing in software. But there are different kinds of duplication. There is true duplication, in which every change to one instance necessitates the same change to every duplicate of that instance. Then there is false or accidental duplication. If two apparently duplicated sections of code evolve along different paths - if they change at different rates, and for different reasons - then they are not true duplicates... When you are vertically separating use cases from one another, you will run into this issue, and your temptation will be to couple the use cases because they have similar user interfaces, or similar algorithms, or similar database schemas. Be careful. Resist the temptation to commit the sin of knee-jerk elimination of duplication. Make sure the duplication is real.</p>
</blockquote>

<p>Commands and events are sufficiently different from one another to warrant separate paths along which they can evolve and adapt to the requirements of your system.</p>

<p>I have not (yet) experienced any scenario in which code quality, performance, or readability is improved by eliminating "duplicate" code for A) sending/handling commands, and B) publishing/handling events.</p>

<p>Therefore commands and events must <strong>not</strong> have any shared base class, and the mechanism used to send/publish commands/events must <strong>not</strong> be a shared queue.</p>

<h3>6. Multitenancy</h3>

<p>Multitenancy must be integral to the solution, and not a feature or facility that is bolted on after-the-fact.</p>

<p>These days I build and maintain enterprise, multitenant systems exclusively. That means I have a single instance of a single application serving multiple concurrent tenants with multiple concurrent users.</p>

<p>There are several reasons for making multitenancy a priority in this implementation:</p>

<ul>
	<li>	<p>Every aggregate must be assigned to a tenant. This makes ownership of data clear and well-defined.</p>
	</li>	<li>	<p>Sharding must be easy to implement when the need arises to scale up. Sharding is the distribution of aggregates to multiple write-side nodes, and "tenant" is the most natural boundary along which to partition aggregates.</p>
	</li>	<li>	<p>Tenant-specific customizations must be easy to implement. Every application has core default behavior for every command and every event, but in a large and complex application that serves many different organizations and/or stakeholders, different tenants are certain to have a variety of specific needs. Sometimes the differences are slight; sometimes they are significant. The solution here must allow the developer to override the default handling of a command and/or event with functionality that is custom to a specific tenant. Overrides must be explicit, so they are easy to identify and enable or disable.</p>
	</li></ul>

<h3>7. Sagas / Process Managers</h3>

<p>The number of steps required to implement a process manager must be relatively small, and the code for a process manager must be relatively easy to write.</p>

<p>A process manager (sometimes called a saga) is an independent component that reacts to domain events in a cross-aggregate, eventually consistent manner. A process manager is sometimes purely reactive, and sometimes represents a workflow.</p>

<blockquote>
<p>From a technical perspective, a process manager is a state machine driven forward by incoming events, which might be published from multiple aggregates. Each state can have side effects (e.g. sending commands, communicating with external web services, sending emails).</p>
</blockquote>

<p>I have worked with some CQRS+ES frameworks that do not support process managers at all, and others that support the concept but not in a way that is easy to understand or configure.</p>

<blockquote>
<p>For example, in one of my own past implementations, an event was published <em>by the event store</em> immediately after the event was appended to the database log. It was not published by the aggregate or by the command handler. This made it unusually difficult to implement even the most basic workflow: I could not send a synchronous command to an aggregate from within an event handler, because the event store's Save method executed inside a synchronization lock (to maintain thread-safety), and new events could not be published without creating a deadlock.</p>
</blockquote>

<p>Regardless of how simple or complex the state-machine for a workflow happens to be, coordinating the events in that process requires code that has side effects, such as as sending commands to other aggregates, sending requests to external web services, or sending emails. Therefore the solution here must have native, built-in support for achieving this.</p>

<h3>8. Scheduling</h3>

<p>The scheduling of commands must be integral to the solution.</p>

<p>It must be easy to send a command with a timer, so the command executes after the timer elapses. This enables the developer to indicate a specific date and time for the execution of any command.</p>

<p>This is useful for commands that must be triggered on a time-dependency.</p>

<p>It is also useful for commands that must be executed "offline", in a background process outside the normal flow of execution. This type of totally asynchronous operation is ideal for a command that is expected to require a long time to complete.</p>

<blockquote>
<p>For example, suppose you have a command that requires the invocation of a method on some external third-party web service, and suppose that service often takes more than 800,000 milliseconds to respond. Such a command must be scheduled to execute during off-peak hours, and/or outside the main thread of execution.</p>
</blockquote>

<h3>9. Aggregate Expiration</h3>

<p>The solution must have native, built-in support for aggregate expiration and cleanup.</p>

<p>I need a CQRS+ES solution that makes it easy to copy an aggregate event stream from the online structured log to offline storage, and purge it from the event store.</p>

<blockquote>
<p>Event sourcing purists will red-flag this immediately and say the event stream for an aggregate must never be altered or removed. They'll say that events (and therefore aggregates) are immutable by definition.</p>
</blockquote>

<p>However, I have scenarios in which this is a non-negotiable business requirement.</p>

<ul>
	<li>	<p>First: When a customer does not renew their subscription to a multitenant application, the service provider hosting the application often has a contractual obligation to remove that customer's data from its systems.</p>
	</li>	<li>	<p>Second: When a project team runs frequent integration tests to confirm system functions are operating correctly, the data input to and output from those tests is temporary by definition. Permanent storage of the event streams for test aggregates is a waste of disk space with no current or future business value; we need a mechanism for removing it.</p>
	</li></ul>

<p>Therefore the solution here must provide an easy way to move aggregates out of the operational system and into "cold storage", so to speak.</p>

<h3>10. Async/Await is Evil</h3>

<p>I am joking, of course.</p>

<p>But not really.</p>

<p>The <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">async/await</a> pattern in C# produces <em>very</em> high-performance code. There is no question about this. In some cases I have seen it boost performance by an order of magnitude or more.</p>

<p>The async/await pattern may be applied in a future iteration of this solution, but - despite the second priority in this list - it is disallowed in this solution, because it leads to breaking the first priority.</p>

<p>As soon as you introduce async/await into a method you are forced to transform its callers so they use async/await (or you are forced to start wrapping clean code in dirty threading blocks), and then you are forced to transform the callers of those callers so they use async/await, and so on throughout the entire code base. The async/await keywords spread like a contagious zombie virus. The resulting asynchronous mess of code is almost certain to be faster, but at the same time much more difficult to read, and even more difficult to debug.</p>

<p>Readability is the highest priority here, therefore I am avoiding async/await until it is the only remaining option for boosting performance (and that added boost is a non-negotiable business requirement).</p>

<h2>Clean Architecture</h2>

<p><a href="https://github.com/matthewrenze">Matthew Renze</a> has an excellent <a href="https://www.pluralsight.com/courses/clean-architecture-patterns-practices-principles">Pluralsight course</a> on the topic of clean architecture. The source code for this solution contains five assemblies and it follows the clean architecture pattern that he advocates.</p>

<h3>Timeline Project</h3>

<p>The Timeline assembly implements the CQRS+ES backbone. This assembly has no upstream dependencies, and therefore it is not specific to any application. It can be unplugged from the sample application and integrated into a new solution to develop an entirely different application.</p>

<p>The other four assemblies (Sample.*) implement the layers in a console application using the Timeline assembly to demonstrate my approach to common tasks in a CQRS+ES software system.</p>

<p>The project dependency diagram is illustrated here:</p>

<p><img alt="Figure-1" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-1.png" data-sizes="auto" data-srcset="/KB/dotnet/5264244/Figure-1-r-400.png 400w, /KB/dotnet/5264244/Figure-1.png 531w" srcset="/KB/dotnet/5264244/Figure-1-r-400.png 400w, /KB/dotnet/5264244/Figure-1.png 531w"></p>

<h3>Sample Projects</h3>

<p>Notice the Timeline assembly has no references to any Sample assembly.</p>

<p>Also notice the domain-centric approach: the Domain layer has no dependencies on the Presentation, Application, or Persistence layers.</p>

<p>The entity relationship diagram for the sample domain is illustrated in Figure 2:</p>

<p><img alt="Figure-2" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-2.png" data-src="/KB/dotnet/5264244/Figure-2.png"></p>

<p>In this basic data model:</p>

<ul>
	<li>a Person had 0..N bank Accounts;</li>	<li>a Transfer withdraws money from one account and deposits it in another account;</li>	<li>a User may be an administrator with no personal data, or someone with personal data owned by multiple tenants</li></ul>

<p>Keep in mind: every Person, Account, and Transfer is an aggregate root, therefore each of these entities has a Tenant attribute.</p>

<h2>Overview</h2>

<p>The overall approach to CQRS+ES in this solution is illustrated in Figure 3:</p>

<p><img alt="Figure-3" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-3.png" data-src="/KB/dotnet/5264244/Figure-3.png"></p>

<p>Notice the Write Side (Commands) and Read Side (Queries) are well-delineated.</p>

<p>You can also see that Event Sourcing is very much like a plug-in to the Write Side. Although it is not demonstrated in this solution, you can see how a CQRS solution <em>without</em> Event Sourcing might look, and sometimes that (CQRS-alone) is a better pattern, depending on the requirements for your project.</p>

<p>Here are the key characteristics of the architecture:</p>

<ul>
	<li>	<p>The command queue saves commands (required for scheduling) in a structured log.</p>
	</li>	<li>	<p>A command subscriber listens for commands on the command queue.</p>
	</li>	<li>	<p>A command subscriber is responsible for creating an aggregate and invoking methods on an aggregate when commands are executed.</p>
	</li>	<li>	<p>A command subscriber saves an aggregate (as an event stream) in a structured log.</p>
	</li>	<li>	<p>A command subscriber publishes events on the event queue.</p>
	</li>	<li>	<p>Published events are handled by event subscribers and process managers.</p>
	</li>	<li>	<p>A process manager can send commands on the command queue, in response to events.</p>
	</li>	<li>	<p>An event subscriber creates and updates projections in a query store.</p>
	</li>	<li>	<p>A query search is a lightweight data access layer for reading projections.</p>
	</li></ul>

<h2>Getting Started</h2>

<p>Before you compile and execute the source code:</p>

<ol>
	<li>	<p>Execute the script "Create Database.sql" to create a local SQL Server database</p>
	</li>	<li>	<p>Update the connection string in Web.config</p>
	</li>	<li>	<p>Update the appSetting value in Web.config for OfflineStoragePath</p>
	</li></ol>

<h2>Usage</h2>

<p>Rather than start at the bottom, and describe how the Timeline assembly works, I will start at the top and demonstrate how to use it, then work my way down through the application stack to the nuts and bolts of the CQRS+ES backbone.</p>

<p>If I have held your attention this long, then I owe you more than a little reward for staying with me thus far...</p>

<h3>Scenario A: How to create and update a contact</h3>

<p>This is the simplest possible usage.</p>

<p>Here we create a new contact person, then perform a name-change, simulating a use case in which Alice gets married:</p>

<p><span id="prehide675637" onclick="processCodeBlocks.togglePre(675637);">Hide</span>  &nbsp; <span id="copycode675637" onclick="return processCodeBlocks.copyCode(675637);">Copy Code</span></p><pre id="pre675637">public static void Run(ICommandQueue commander)
{
    var alice = Guid.NewGuid();
    commander.Send(new RegisterPerson(alice, "Alice", "O'Wonderland"));
    commander.Send(new RenamePerson(alice, "Alice", "Cooper"));
}</pre>

<p>The read-side projection looks good:</p>

<p><img alt="Figure-4" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-4.png" data-src="/KB/dotnet/5264244/Figure-4.png"></p>

<h4>Data Flow</h4>

<p>The steps performed by the system in this scenario are illustrated in the following diagram:</p>

<p><img alt="Figure-5" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-5.png" data-src="/KB/dotnet/5264244/Figure-5.png"></p>

<h3>Scenario B: How to take a snapshot of an aggregate</h3>

<p>Snapshots are automated by the Timeline assembly; they are enabled for every aggregate by default, so you don't have to do anything at all to get this working.</p>

<p>In this next test run, the Timeline assembly is configured to take a snapshot after every 10 events. We register a new contact person, then rename him 20 times. This produces a snapshot on event number 20, which is the second-to-last rename operation.</p>

<p><span id="prehide745797" onclick="processCodeBlocks.togglePre(745797);">Hide</span>  &nbsp; <span id="copycode745797" onclick="return processCodeBlocks.copyCode(745797);">Copy Code</span></p><pre id="pre745797">public static void Run(ICommandQueue commander)
{
    var henry = Guid.NewGuid();
    commander.Send(new RegisterPerson(henry, "King", "Henry I"));
    for (int i = 1; i &lt;= 20; i++)
        commander.Send(new RenamePerson(henry, "King", "Henry " + (i+1).ToRoman()));
}</pre>

<p>As expected, we have a snapshot at version 20, and the current-state projection after event number 21:</p>

<p><img alt="Figure-6" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-6.png" data-src="/KB/dotnet/5264244/Figure-6.png"></p>

<h3>Scenario C: How to take an aggregate offline</h3>

<p>The terms "boxing" and "unboxing" are used for taking an aggregate offline and bringing it back online.</p>

<p>When you send a command to <strong>box </strong>an aggregate, the Timeline assembly:</p>

<ol>
	<li>creates a snapshot;</li>	<li>copies that snapshot and the entire aggregate event stream to a JSON file stored in a directory on the file system; then</li>	<li>deletes the snapshot and the aggregate from the SQL Server structured log tables.</li></ol>

<p>This makes it a highly destructive operation, of course, and it should never be used except in circumstances where it is a mandatory business/legal requirement.</p>

<p>In the next test run, we register a new contact person, rename him 7 times, then box the aggregate.</p>

<p><span id="prehide376022" onclick="processCodeBlocks.togglePre(376022);">Hide</span>  &nbsp; <span id="copycode376022" onclick="return processCodeBlocks.copyCode(376022);">Copy Code</span></p><pre id="pre376022">public static void Run(ICommandQueue commander)
{
    var hatter = Guid.NewGuid();
    commander.Send(new RegisterPerson(hatter, "Mad", "Hatter One"));
    for (int i = 2; i &lt;= 8; i++)
        commander.Send(new RenamePerson(hatter, "Mad", "Hatter " + i.ToWords().Titleize()));
    commander.Send(new BoxPerson(hatter));
}</pre>

<p>As you can see, the aggregate no longer exists in the event store, and an offline copy of the final snapshot (along with the entire event stream) has been made on the file system.</p>

<p><img alt="Figure-7" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-7.png" data-src="/KB/dotnet/5264244/Figure-7.png"></p>

<h3>Scenario D: How to create a new user with a unique login name</h3>

<p>The question I encounter most frequently online from developers trying to understand CQRS+ES is this:</p>

<blockquote>
<p>"How do I enforce referential integrity to guarantee new users have unique login names?"</p>
</blockquote>

<p>I asked this same question myself (more than once) in the early days of my research on the CQRS+ES pattern.</p>

<p>A lot of the answers from experienced practitioners look something like this:</p>

<blockquote>
<p>"Your question indicates you do not understand CQRS+ES."</p>
</blockquote>

<p>This is true (I realize now) but completely unhelpful - especially to someone who is making an effort to learn.</p>

<p>Some of the answers are slightly better, offering a high-level recommendation in summary form, but loaded with CQRS+ES terminology, which is not always helpful either. One of my favorite recommendations was this (from the good folks at <a href="https://cqrs.nu/Faq">Edument</a>):</p>

<blockquote>
<p>"Create a reactive saga to flag down and inactivate accounts that were nevertheless created with a duplicate user name, whether by extreme coincidence or maliciously or because of a faulty client."</p>
</blockquote>

<p>The first time I read that I had only a vague sense of what it meant, and no idea at all how to begin to implement such a recommendation.</p>

<p>The next test run shows one way (but not the only way) to create a new user with a unique name, using real, working code as an example.</p>

<p>In this scenario the trick is to realize that you do in fact need a <em>saga</em> (or <em>process manager</em>, as I prefer to call it). Creating a new user account is not a single-step operation; it is a process, and therefore requires coordination. The flowchart (or <em>state machine</em>, if you prefer) might be very complex in your application, but even in the simplest of all possible cases it will look something like this:</p>

<p><img alt="Figure-8" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-8.png" data-src="/KB/dotnet/5264244/Figure-8.png"></p>

<p>The code that relies on a process manager to implement this functionality is shown in the next figure:</p>

<p><span id="prehide147566" onclick="processCodeBlocks.togglePre(147566);">Hide</span>  &nbsp; <span id="preShrink147566" onclick="processCodeBlocks.shrinkExpand(147566);">Shrink</span> <img id="preimg147566" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(147566);">  &nbsp; <span id="copycode147566" onclick="return processCodeBlocks.copyCode(147566);">Copy Code</span></p><pre id="pre147566" processed="true">public void Run()
{
    var login = "jack@example.com";
    var password = "Let_Me_In!";

    if (RegisterUser(Guid.NewGuid(), login, password)) // succeeds.
        System.Console.WriteLine($"User registration for {login} succeeded");
    
    if (!RegisterUser(Guid.NewGuid(), login, password)) // fails; duplicate login.
        System.Console.WriteLine($"User registration for {login} failed");
}

private bool RegisterUser(Guid id, string login, string password)
{
    bool isComplete(Guid user) { return _querySearch.IsUserRegistrationCompleted(user); }
    const int waitTime = 200; // ms
    const int maximumRetries = 15; // 15 retries (~3 seconds)

    _commander.Send(new StartUserRegistration(id, login, password));

    for (var retry = 0; retry &lt; maximumRetries &amp;&amp; !isComplete(id); retry++)
        Thread.Sleep(waitTime);

    if (isComplete(id))
    {
        var summary = _querySearch.SelectUserSummary(id);
        return summary?.UserRegistrationStatus == "Succeeded";
    }
    else
    {
        var error = $"Registration for {login} has not completed after {waitTime * maximumRetries} ms";
        throw new IncompleteUserRegistrationException(error);
    }
}</pre>

<p>Notice the caller in the example above does not assume synchronous handling of the command StartUserRegistration. Instead it polls the status of the registration, waiting for it to complete.</p>

<p>Knowing the code in the Timeline assembly is <strong>synchronous</strong>, we can refactor the method RegisterUser so it is even simpler:</p>

<p><span id="prehide580050" onclick="processCodeBlocks.togglePre(580050);">Hide</span>  &nbsp; <span id="copycode580050" onclick="return processCodeBlocks.copyCode(580050);">Copy Code</span></p><pre id="pre580050">private bool RegisterUserNoWait(Guid id, string login, string password)
{
    bool isComplete(Guid user) { return _querySearch.IsUserRegistrationCompleted(user); }

    _commander.Send(new StartUserRegistration(id, login, password));

    Debug.Assert(isComplete(id));

    return _querySearch.SelectUserSummary(id).UserRegistrationStatus == "Succeeded";
}</pre>

<p>The code for the process manager itself is simpler than you might guess:</p>

<p><span id="prehide76503" onclick="processCodeBlocks.togglePre(76503);">Hide</span>  &nbsp; <span id="preShrink76503" onclick="processCodeBlocks.shrinkExpand(76503);">Shrink</span> <img id="preimg76503" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(76503);">  &nbsp; <span id="copycode76503" onclick="return processCodeBlocks.copyCode(76503);">Copy Code</span></p><pre id="pre76503" processed="true">public class UserRegistrationProcessManager
{
    private readonly ICommandQueue _commander;
    private readonly IQuerySearch _querySearch;

    public UserRegistrationProcessManager(ICommandQueue commander, IEventQueue publisher, IQuerySearch querySearch)
    {
        _commander = commander;
        _querySearch = querySearch;

        publisher.Subscribe&lt;UserRegistrationStarted&gt;(Handle);
        publisher.Subscribe&lt;UserRegistrationSucceeded&gt;(Handle);
        publisher.Subscribe&lt;UserRegistrationFailed&gt;(Handle);
    }

    public void Handle(UserRegistrationStarted e)
    {
        // Registration succeeds only if no other user has the same login name.
        var status = _querySearch
            .UserExists(u =&gt; u.LoginName == e.Name 
			    &amp;&amp; u.UserIdentifier != e.AggregateIdentifier)
            ? "Failed" : "Succeeded";

        _commander.Send(new CompleteUserRegistration(e.AggregateIdentifier, status));
    }

    public void Handle(UserRegistrationSucceeded e) { }

    public void Handle(UserRegistrationFailed e) { }
}</pre>

<p>There you have a basic, reactive saga that flags inactivate accounts created with a duplicate user name. And there was much rejoicing.</p>

<p>As expected, the first registration succeeds and the second fails:</p>

<p><img alt="Figure-9" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-9.png" data-src="/KB/dotnet/5264244/Figure-9.png"></p>

<h3>Scenario E: How to schedule a command</h3>

<p>Scheduling a command to run at a future date/time is easy:</p>

<p><span id="prehide654387" onclick="processCodeBlocks.togglePre(654387);">Hide</span>  &nbsp; <span id="copycode654387" onclick="return processCodeBlocks.copyCode(654387);">Copy Code</span></p><pre id="pre654387">public static void Run(ICommandQueue commander)
{
    var alice = Guid.NewGuid();
    var tomorrow = DateTimeOffset.UtcNow.AddDays(1);
    commander.Schedule(new RegisterPerson(alice, "Alice", "O'Wonderland"), tomorrow);

    // After the above timer elapses, any call to Ping() executes the scheduled command.
    // commander.Ping();
}</pre>

<p>Notice this creates no aggregate in the event log, and the command log now contains a scheduled entry:</p>

<p><img alt="Figure-10" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-10.png" data-src="/KB/dotnet/5264244/Figure-10.png"></p>

<h3>Scenario F: How to update multiple aggregates with one command</h3>

<p>This is another common question asked by developers who are trying to understand how to implement the CQRS+ES pattern. It is another question I asked (many times) when I was learning it myself.</p>

<p>Practitioners often answer by saying:</p>

<blockquote>
<p>"You can't."</p>
</blockquote>

<p>This is not enormously instructive.</p>

<p>Some will offer a little more guidance with a statement something like this:</p>

<blockquote>
<p>"The factoring of your aggregates and command handlers will make this idea impossible to express in code."</p>
</blockquote>

<p>The first several times you read that statement it seems cryptic, and in the end you discover it can be quite helpful for validating your implementation, but in the beginning it isn't super helpful.</p>

<p>What's most helpful is an example with real, working code, which implements the type of functionality that motivated the question in the first place:</p>

<ul>
	<li>	<p>Suppose I have two bank accounts, each of which is an aggregate root, and I want to transfer money from one account to the other. How do I achieve this using CQRS+ES?</p>
	</li></ul>

<p>The next test run shows one way (and not the only way) this can be done.</p>

<p>In this scenario the trick is to realize you need another aggregate root - i.e., a money Transfer, which is not itself an Account - and you <em>also</em> need a process manager to coordinate the workflow.</p>

<p>The simplest possible flowchart is illustrated in the next figure. (An accounting system obviously needs something more sophisticated than this.)</p>

<p><img alt="Figure-11" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-11.png" data-src="/KB/dotnet/5264244/Figure-11.png"></p>

<p>The code that relies on a process manager to implement the workflow illustrated above is easy, once you have all the pieces in place:</p>

<p><span id="prehide938936" onclick="processCodeBlocks.togglePre(938936);">Hide</span>  &nbsp; <span id="preShrink938936" onclick="processCodeBlocks.shrinkExpand(938936);">Shrink</span> <img id="preimg938936" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(938936);">  &nbsp; <span id="copycode938936" onclick="return processCodeBlocks.copyCode(938936);">Copy Code</span></p><pre id="pre938936" processed="true">public void Run()
{
    // Start one account with $100.
    var bill = Guid.NewGuid();
    CreatePerson(bill, "Bill", "Esquire");
    var blue = Guid.NewGuid();
    StartAccount(bill, blue, "Bill's Blue Account", 100);

    // Start another account with $100.
    var ted = Guid.NewGuid();
    CreatePerson(ted, "Ted", "Logan");
    var red = Guid.NewGuid();
    StartAccount(ted, red, "Ted's Red Account", 100);

    // Create a money transfer for Bill giving money to Ted.
    var tx = Guid.NewGuid();
    _commander.Send(new StartTransfer(tx, blue, red, 69));
}

private void StartAccount(Guid person, Guid account, string code, decimal deposit)
{
    _commander.Send(new OpenAccount(account, person, code));
    _commander.Send(new DepositMoney(account, deposit));
}

private void CreatePerson(Guid person, string first, string last)
{
    _commander.Send(new RegisterPerson(person, first, last));
}</pre>

<p>After that test is executed, Bill's blue account has a balance of $31, and Ted's red account has a balance of $169, as expected:</p>

<p><img alt="Figure-12" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-12.png" data-src="/KB/dotnet/5264244/Figure-12.png"></p>

<p>The code for the money transfer process manager is not too difficult either:</p>

<p><span id="prehide347241" onclick="processCodeBlocks.togglePre(347241);">Hide</span>  &nbsp; <span id="preShrink347241" onclick="processCodeBlocks.shrinkExpand(347241);">Shrink</span> <img id="preimg347241" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(347241);">  &nbsp; <span id="copycode347241" onclick="return processCodeBlocks.copyCode(347241);">Copy Code</span></p><pre id="pre347241" processed="true">public class TransferProcessManager
{
    private readonly ICommandQueue _commander;
    private readonly IEventRepository _repository;

    public TransferProcessManager(ICommandQueue commander, IEventQueue publisher, IEventRepository repository)
    {
        _commander = commander;
        _repository = repository;

        publisher.Subscribe&lt;TransferStarted&gt;(Handle);
        publisher.Subscribe&lt;MoneyDeposited&gt;(Handle);
        publisher.Subscribe&lt;MoneyWithdrawn&gt;(Handle);
    }

    public void Handle(TransferStarted e)
    {
        var withdrawal = new WithdrawMoney(e.FromAccount, e.Amount, e.AggregateIdentifier);
        _commander.Send(withdrawal);
    }

    public void Handle(MoneyWithdrawn e)
    {
        if (e.Transaction == Guid.Empty)
            return;

        var status = new UpdateTransfer(e.Transaction, "Debit Succeeded");
        _commander.Send(status);

        var transfer = (Transfer) _repository.Get&lt;TransferAggregate&gt;(e.Transaction).State;

        var deposit = new DepositMoney(transfer.ToAccount, e.Amount, e.Transaction);
        _commander.Send(deposit);
    }

    public void Handle(MoneyDeposited e)
    {
        if (e.Transaction == Guid.Empty)
            return;

        var status = new UpdateTransfer(e.Transaction, "Credit Succeeded");
        _commander.Send(status);

        var complete = new CompleteTransfer(e.Transaction);
        _commander.Send(complete);
    }
}</pre>

<h3>Scenario G: How to implement a custom event handler</h3>

<p>In this next example I demonstrate how to define a custom event handler that is intended for use by one and only one tenant in a multitenant system.</p>

<p>In this scenario, Umbrella Corporation is one of our tenants, and the organization wants all the existing core functionality in our system. However, the company also wants an additional custom feature:</p>

<ul>
	<li>	<p>When a money transfer is started from or to any Umbrella account, if the dollar amount exceeds $10,000 then an email notification must be sent directly to the company owner.</p>
	</li></ul>

<p>To satisfy this requirement we implement a process manager for the tenant. The calling code that relies on this process manager is no different than it was in the previous scenario.</p>

<p><span id="prehide628528" onclick="processCodeBlocks.togglePre(628528);">Hide</span>  &nbsp; <span id="preShrink628528" onclick="processCodeBlocks.shrinkExpand(628528);">Shrink</span> <img id="preimg628528" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(628528);">  &nbsp; <span id="copycode628528" onclick="return processCodeBlocks.copyCode(628528);">Copy Code</span></p><pre id="pre628528" processed="true">public void Run()
{
    // Start one account with $50,000.
    var ada = Guid.NewGuid();
    CreatePerson(ada, "Ada", "Wong");
    var a = Guid.NewGuid();
    StartAccount(ada, a, "Ada's Account", 50000);

    // Start another account with $25,000.
    var albert = Guid.NewGuid();
    CreatePerson(albert, "Albert", "Wesker");
    var b = Guid.NewGuid();
    StartAccount(albert, b, "Albert's Account", 100);

    // Create a money transfer for Ada giving money to Albert.
    var tx = Guid.NewGuid();
    _commander.Send(new StartTransfer(tx, a, b, 18000));
}

private void StartAccount(Guid person, Guid account, string code, decimal deposit)
{
    _commander.Send(new OpenAccount(account, person, code));
    _commander.Send(new DepositMoney(account, deposit));
}

private void CreatePerson(Guid person, string first, string last)
{
    _commander.Send(new RegisterPerson(person, first, last));
}</pre>

<p>Here is a snapshot from the Visual Studio debugger, looking at the code for the process manager, with a breakpoint on the line that sends the email notification. Notice the body of the message in the popup is what we expect:</p>

<p><img alt="Figure-14" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-14.png" data-src="/KB/dotnet/5264244/Figure-14.png"></p>

<h3>Scenario H: How to override a command with a custom handler</h3>

<p>This final example is a variation on the preceding one. Umbrella Corporation wants to disable a core application feature entirely, and replace it with behavior that is entirely custom. The new business requirement looks like this:</p>

<ul>
	<li>	<p>Changing the name of a contact person in our system is not permitted. Ever.</p>
	</li></ul>

<p>To satisfy this requirement we make a few simple changes to the process manager. We add one line of code to the constructor, specifying the override, and we add the replacement function:</p>

<p><span id="prehide163918" onclick="processCodeBlocks.togglePre(163918);">Hide</span>  &nbsp; <span id="copycode163918" onclick="return processCodeBlocks.copyCode(163918);">Copy Code</span></p><pre id="pre163918">public class UmbrellaProcessManager
{
    private IQuerySearch _querySearch;

    public UmbrellaProcessManager(ICommandQueue commander, IEventQueue publisher, IQuerySearch querySearch)
    {
        _querySearch = querySearch;

        publisher.Subscribe&lt;TransferStarted&gt;(Handle);
        commander.Override&lt;RenamePerson&gt;(Handle, Tenants.Umbrella.Identifier);
    }

    public void Handle(TransferStarted e) { }

    public void Handle(RenamePerson c)
    {
        // Do nothing. Umbrella does not permit renaming people.
        
        // Throw an exception to make the consequences even more severe 
		// for any attempt to rename a person...
        // throw new DisallowRenamePersonException();
    }
}</pre>

<p>Here is a basic test run to demonstrate this works as expected:</p>

<p><span id="prehide829900" onclick="processCodeBlocks.togglePre(829900);">Hide</span>  &nbsp; <span id="copycode829900" onclick="return processCodeBlocks.copyCode(829900);">Copy Code</span></p><pre id="pre829900">public static class Test08
{
    public static void Run(ICommandQueue commander)
    {
        ProgramSettings.CurrentTenant = Tenants.Umbrella;

        var alice = Guid.NewGuid();
        commander.Send(new RegisterPerson(alice, "Alice", "Abernathy"));
        commander.Send(new RenamePerson(alice, "Alice", "Parks"));
    }
}</pre>

<p>Notice just one event in the log, and no change to the person's name:</p>

<p><img alt="Figure-15" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-15.png" data-src="/KB/dotnet/5264244/Figure-15.png"></p>

<h2>Presentation</h2>

<p>The presentation layer in the sample application is a console application intended only for writing and running test-case scenarios.</p>

<p>There is nothing here that warrants special attention. You will notice I have not used a third-party component for dependency injection; instead I have written a very basic in-memory service-locator.</p>

<p>This is done only for the sake of keeping the sample application as small and as focused as possible. In your own presentation layer you'll implement dependency injection in whatever way works best for you, using whatever IoC container you prefer.</p>

<h2>Application</h2>

<p>The application layer is divided into two distinct parts: a Write side for commands, and a Read side for queries. This division helps to ensure we don't accidentally mix write-side and read-side functionality.</p>

<p>Notice there are no references to external third-party assemblies here:</p>

<p><img alt="Figure-16" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-16.png" data-src="/KB/dotnet/5264244/Figure-16.png"></p>

<h3>Write Side</h3>

<p>Commands are Plain Old C# Object (POCO) classes, so they can be easily used as Data Transfer Objects (DTOs) for easy serialization:</p>

<p><span id="prehide665215" onclick="processCodeBlocks.togglePre(665215);">Hide</span>  &nbsp; <span id="copycode665215" onclick="return processCodeBlocks.copyCode(665215);">Copy Code</span></p><pre id="pre665215">public class RenamePerson : Command
{
    public string FirstName { get; set; }
    public string LastName { get; set; }

    public RenamePerson(Guid id, string firstName, string lastName)
    {
        AggregateIdentifier = id;
        FirstName = firstName;
        LastName = lastName;
    }
}</pre>

<blockquote>
<p>Note: I prefer the term "Packet" to "Data Transfer Object", and I know many readers will object to that, so choose terminology that works for you and your team.</p>
</blockquote>

<p>The registration of a command handler method is <strong>explicit</strong> in the constructor for a command subscriber class, and events are published <strong>after</strong> they have been saved to the event store:</p>

<p><span id="prehide156268" onclick="processCodeBlocks.togglePre(156268);">Hide</span>  &nbsp; <span id="preShrink156268" onclick="processCodeBlocks.shrinkExpand(156268);">Shrink</span> <img id="preimg156268" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(156268);">  &nbsp; <span id="copycode156268" onclick="return processCodeBlocks.copyCode(156268);">Copy Code</span></p><pre id="pre156268" processed="true">public class PersonCommandSubscriber
{
    private readonly IEventRepository _repository;
    private readonly IEventQueue _publisher;

    public PersonCommandSubscriber(ICommandQueue commander, IEventQueue publisher, IEventRepository repository)
    {
        _repository = repository;
        _publisher = publisher;

        commander.Subscribe&lt;RegisterPerson&gt;(Handle);
        commander.Subscribe&lt;RenamePerson&gt;(Handle);
    }

    private void Commit(PersonAggregate aggregate)
    {
        var changes = _repository.Save(aggregate);
        foreach (var change in changes)
            _publisher.Publish(change);
    }

    public void Handle(RegisterPerson c)
    {
        var aggregate = new PersonAggregate { AggregateIdentifier = c.AggregateIdentifier };
        aggregate.RegisterPerson(c.FirstName, c.LastName, DateTimeOffset.UtcNow);
        Commit(aggregate);
    }

    public void Handle(RenamePerson c)
    {
        var aggregate = _repository.Get&lt;PersonAggregate&gt;(c.AggregateIdentifier);
        aggregate.RenamePerson(c.FirstName, c.LastName);
        Commit(aggregate);
    }
}</pre>

<h3>Read Side</h3>

<p>Queries are POCO classes also, making them lightweight and easy to serialize.</p>

<p><span id="prehide24363" onclick="processCodeBlocks.togglePre(24363);">Hide</span>  &nbsp; <span id="copycode24363" onclick="return processCodeBlocks.copyCode(24363);">Copy Code</span></p><pre id="pre24363">public class PersonSummary
{
    public Guid TenantIdentifier { get; set; }

    public Guid PersonIdentifier { get; set; }
    public string PersonName { get; set; }
    public DateTimeOffset PersonRegistered { get; set; }

    public int OpenAccountCount { get; set; }
    public decimal TotalAccountBalance { get; set; }
}</pre>

<p>The registration of an event handler method is also <strong>explicit</strong> in the constructor for an event subscriber class:</p>

<p><span id="prehide677443" onclick="processCodeBlocks.togglePre(677443);">Hide</span>  &nbsp; <span id="copycode677443" onclick="return processCodeBlocks.copyCode(677443);">Copy Code</span></p><pre id="pre677443">public class PersonEventSubscriber
{
    private readonly IQueryStore _store;

    public PersonEventSubscriber(IEventQueue queue, IQueryStore store)
    {
        _store = store;

        queue.Subscribe&lt;PersonRegistered&gt;(Handle);
        queue.Subscribe&lt;PersonRenamed&gt;(Handle);
    }

    public void Handle(PersonRegistered c)
    {
        _store.InsertPerson(c.IdentityTenant, c.AggregateIdentifier, c.FirstName + " " + c.LastName, c.Registered);
    }

    public void Handle(PersonRenamed c)
    {
        _store.UpdatePersonName(c.AggregateIdentifier, c.FirstName + " " + c.LastName);
    }
}</pre>

<h2>Domain</h2>

<p>The domain contains only aggregates and events. Again you'll see the list of References here is as bare-metal as possible:</p>

<p><img alt="Figure-17" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-17.png" data-src="/KB/dotnet/5264244/Figure-17.png"></p>

<p>Each aggregate root class contains a function for each of the commands it accepts as a request to change its state:</p>

<p><span id="prehide695375" onclick="processCodeBlocks.togglePre(695375);">Hide</span>  &nbsp; <span id="copycode695375" onclick="return processCodeBlocks.copyCode(695375);">Copy Code</span></p><pre id="pre695375">public class PersonAggregate : AggregateRoot
{
    public override AggregateState CreateState() =&gt; new Person();

    public void RegisterPerson(string firstName, string lastName, DateTimeOffset registered)
    {
        // 1. Validate command
        // Omitted for the sake of brevity.

        // 2. Validate domain.
        // Omitted for the sake of brevity.

        // 3. Apply change to aggregate state.
        var e = new PersonRegistered(firstName, lastName, registered);
        Apply(e);
    }

    public void RenamePerson(string firstName, string lastName)
    {
        var e = new PersonRenamed(firstName, lastName);
        Apply(e);
    }
}</pre>

<p>Notice the aggregate state is implemented in a class that is separate from the aggregate root.</p>

<p>This makes serialization and snapshots easier to manage, and it helps with overall readability because it forces a stronger delineation between command-related functions and event-related functions:</p>

<p><span id="prehide711154" onclick="processCodeBlocks.togglePre(711154);">Hide</span>  &nbsp; <span id="copycode711154" onclick="return processCodeBlocks.copyCode(711154);">Copy Code</span></p><pre id="pre711154">public class Person : AggregateState
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public DateTimeOffset Registered { get; set; }

    public void When(PersonRegistered @event)
    {
        FirstName = @event.FirstName;
        LastName = @event.LastName;
        Registered = @event.Registered;
    }

    public void When(PersonRenamed @event)
    {
        FirstName = @event.FirstName;
        LastName = @event.LastName;
    }
}</pre>

<p>Events, like commands and queries, are lightweight POCO classes:</p>

<p><span id="prehide539270" onclick="processCodeBlocks.togglePre(539270);">Hide</span>  &nbsp; <span id="copycode539270" onclick="return processCodeBlocks.copyCode(539270);">Copy Code</span></p><pre id="pre539270">public class PersonRenamed : Event
{
    public string FirstName { get; set; }
    public string LastName { get; set; }

    public PersonRenamed(string first, string last) { FirstName = first; LastName = last; }
}</pre>

<h2>Persistence</h2>

<p>At the persistence layer we begin to see a larger number of dependencies on external third-party components. For example, here we rely on:</p>

<ul>
	<li>	<p><a href="https://www.newtonsoft.com/json">Json.NET</a> for JSON serialization and deserialization;</p>
	</li>	<li>	<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.data?view=netframework-4.8">System.Data</a> for logging commands and events and snapshots in SQL Server using ADO.NET; and</p>
	</li>	<li>	<p><a href="https://docs.microsoft.com/en-us/ef">Entity Framework</a> for query projections.</p>
	</li></ul>

<p><img alt="Figure-18" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-18.png" data-src="/KB/dotnet/5264244/Figure-18.png"></p>

<p>The source code in this project implements a standard run-of-the-mill data access layer, and there should be nothing in this layer that it is new, or especially innovative, or surprising to any experienced developer - so it needs no special discussion.</p>

<h2>CQRS+ES Backbone</h2>

<p>And at long (<em>long</em>) last, ladies and gentlemen, comes the part of the evening you've been waiting for: the Timeline assembly that actually implements the CQRS+ES pattern, which makes all of the above possible.</p>

<p>The funny thing is... now that we have arrived at the nuts and bolts there should be very little mystery remaining.</p>

<p><img alt="Figure-19" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-19.png" data-src="/KB/dotnet/5264244/Figure-19.png"></p>

<p>The first thing you'll notice is the Timeline assembly has <strong>no</strong> dependencies on external third-party components (besides the .NET Framework itself, obviously).</p>

<h3>Commands</h3>

<p>There are just a few things to note here.</p>

<p>The Command base class contains properties for the aggregate identifier and version number, as you'd expect. It also contains properties for the identity of the tenant and user sending the command.</p>

<p><span id="prehide614640" onclick="processCodeBlocks.togglePre(614640);">Hide</span>  &nbsp; <span id="copycode614640" onclick="return processCodeBlocks.copyCode(614640);">Copy Code</span></p><pre id="pre614640">/// &lt;summary&gt;
/// Defines the base class for all commands.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// A command is a request to change the domain. It is always are named with a verb in 
/// the imperative mood, such as Confirm Order. Unlike an event, a command is not a 
/// statement of fact; it is only a request, and thus may be refused. Commands are
/// immutable because their expected usage is to be sent directly to the domain model for 
/// processing. They do not need to change during their projected lifetime.
/// &lt;/remarks&gt;
public class Command : ICommand
{
    public Guid AggregateIdentifier { get; set; }
    public int? ExpectedVersion { get; set; }

    public Guid IdentityTenant { get; set; }
    public Guid IdentityUser { get; set; }

    public Guid CommandIdentifier { get; set; }
    public Command() { CommandIdentifier = Guid.NewGuid(); }
}</pre>

<p>The CommandQueue implements the ICommandQueue interface, which defines a small set of methods to register subscribers and overrides, as well as send and schedule commands. You can think of this as the <a href="https://en.wikipedia.org/wiki/Enterprise_service_bus">service bus</a> for your commands.</p>

<p><img alt="Figure-20" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-20.png" data-src="/KB/dotnet/5264244/Figure-20.png"></p>

<h3>Events</h3>

<p>The Event base class contains properties for the aggregate identifier and version number, as well as properties for the identity of the tenant and user for whom the event was raised/published. This ensures every event log entry is associated with a specific tenant and user.</p>

<p><img alt="Figure-21" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-21.png" data-src="/KB/dotnet/5264244/Figure-21.png"></p>

<p>You can think of the EventQueue as the service bus for your events.</p>

<h3>Aggregates</h3>

<p>There is one small bit of black magic in the AggregateState class. The Apply method uses reflection to determine which method to invoke when an event is applied to the aggregate state. I don't especially like this, but I cannot find any way to avoid it. Fortunately, the code easy to read and easy to understand:</p>

<p><span id="prehide10512" onclick="processCodeBlocks.togglePre(10512);">Hide</span>  &nbsp; <span id="copycode10512" onclick="return processCodeBlocks.copyCode(10512);">Copy Code</span></p><pre id="pre10512">/// &lt;summary&gt;
/// Represents the state (data) of an aggregate. A derived class should be a POCO
/// (DTO/Packet) that includes a When method for each event type that changes its
/// property values. Ideally, the property values for an instance of  this class 
/// should be modified only through its When methods.
/// &lt;/summary&gt;
public abstract class AggregateState
{
    public void Apply(IEvent @event)
    {
        var when = GetType().GetMethod("When", new[] { @event.GetType() });

        if (when == null)
            throw new MethodNotFoundException(GetType(), "When", @event.GetType());

        when.Invoke(this, new object[] { @event });
    }
}</pre>

<h3>Snapshots</h3>

<p>The source code to implement Snapshots is cleaner and simpler than I imagined it could be when I first started this project. The logic is somewhat intricate, but there's only 240 lines of code in the Snapshots namespace, so I won't add details on that here. I leave that as an exercise for you, the most patient of readers, if there are any of you still left at this point. :-)</p>

<h2>Metrics</h2>

<p>I will close the article with a few basic metrics. (More to come later.)</p>

<p>Here is the analysis report produced by <a href="https://www.ndepend.com/">NDepend</a> on the Timeline assembly:</p>

<p><img alt="Figure-22" src="https://www.codeproject.com/KB/dotnet/5264244/Figure-22.png" data-src="/KB/dotnet/5264244/Figure-22.png"></p>

<p>The source code is not perfect, as you can see, but does get an "A" rating, with technical debt estimated at only 1.3%. The project is also very compact, with only 439 lines of code, at the time I write this.</p>

<blockquote>
<p>Note: NDepend counts <a href="https://www.ndepend.com/docs/code-metrics#NbLinesOfCode">lines of code (LOC)</a> from the number of sequence points per method in the .pdb symbol file for an assembly. Visual Studio counts LOC differently; on the Timeline project it reports 1,916 lines of Source code - and 277 lines of Executable code.</p>
</blockquote>

<p>When time permits I will update this article with run-time performance results.</p>

<p>In the meantime, your comments and criticisms are most welcome.</p>


						</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>