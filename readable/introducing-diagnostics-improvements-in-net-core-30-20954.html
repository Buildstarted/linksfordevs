<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Introducing diagnostics improvements in .NET Core 3.0 | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Introducing diagnostics improvements in .NET Core 3.0 | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Sourabh ShirhattiFollow Sourabh"/>
    <meta property="og:description" content="In .NET Core 3.0, we are introducing a suite of tools that utilize new features in the .NET runtime that make it easier to diagnose and solve performance problems.&#xA;These runtime features help you answer some common diagnostic questions you may have:  Is my application healthy?"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/introducing-diagnostics-improvements-in-net-core-3-0/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Introducing diagnostics improvements in .NET Core 3.0 | .NET Blog</title>
<div class="readable">
        <h1>Introducing diagnostics improvements in .NET Core 3.0 | .NET Blog</h1>
            <div>by Sourabh ShirhattiFollow Sourabh</div>
            <div>Reading time: 7-8 minutes</div>
        <div>Posted here: 08 May 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/introducing-diagnostics-improvements-in-net-core-3-0/">https://devblogs.microsoft.com/dotnet/introducing-diagnostics-improvements-in-net-core-3-0/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/07efe6bbd54a0f6649a09f43acb183d8?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p><p>Sourabh</p></div></div></div><p>May 8th, 2019</p><p>In .NET Core 3.0, we are introducing a suite of tools that utilize new features in the .NET runtime that make it easier to diagnose and solve performance problems.</p><p>These runtime features help you answer some common diagnostic questions you may have:</p><ol type="1"><li>Is my application healthy?</li><li>Why does my application have anomalous behavior?</li><li>Why did my application crash?</li></ol><h3 id="is-my-application-healthy">Is my application healthy?</h3><p>Often times an application can slowly start leaking memory and eventually result in an out of memory exception. Other times, certain problematic code paths may result in a spike in CPU utilization. These are just some of the classes of problem you can pro-actively identify with <strong>metrics</strong>.</p><h4 id="metrics">Metrics</h4><p>Metrics are a representation of data measures over intervals of time. Metrics (or time-series) data allow you to observe the state of your system at a high-level. Unlike the .NET Framework on Windows, .NET Core doesn’t emit perf counters. Instead, we had introduced a new way of emitting metrics in .NET Core via the <a href="https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Diagnostics/Tracing/EventCounter.cs" target="_blank">EventCounter</a> API.</p><p>EventCounters offer an improvement over Windows perf counters as these are now usable on all OSes where .NET Core is supported. Additionally, unlike perf counters, they are also usable in low privilege environments (like xcopy deployments). Unfortunately, the lack of a tool like Performance Monitor (perfmon) made it difficult to consume these metrics in real time.</p><h4 id="dotnet-counters"><code>dotnet-counters</code></h4><p>In 3.0-preview5, we are introducing a new command-line tool for observing metrics emitted by .NET Core Applications in real time.</p><p>You can install this .NET global tool by running the following command</p><p><code><code><span>dotnet</span> tool install --global dotnet-counters --version 1.0.3-preview5.19251.2</code></code></p><p>In the example below, we see the CPU utilization and working set memory of our application jump up when we point a load generator at our web application.</p><p>For detailed instructions on how to use this tool, look at the <a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-counters-instructions.md" target="_blank">dotnet-counters readme</a>. For known limitations with <code>dotnet-counters</code>, look at the <a href="https://github.com/dotnet/diagnostics/issues?q=is%3Aopen+is%3Aissue+label%3Adotnet-counters" target="_blank">open issues on GitHub</a>.</p><h3 id="why-does-my-application-have-anomalous-behavior">Why does my application have anomalous behavior?</h3><p>While metrics help identify the occurence of anomalous behavior, they offer little visibility into what went wrong. To answer the question why your application has anomalous behavior you need to collect additional information via traces.&nbsp;As an example, CPU profiles collected via tracing can help you identify the hot path in your code.</p><h4 id="tracing">Tracing</h4><p>Traces are immutable timestamped records of discrete events. Traces contain local context that allow you to better infer the fate of a system. Traditionally, the .NET Framework (and frameworks like ASP.NET) emitted diagnostic traces about its internals via Event Tracing for Windows (ETW). In .NET Core, these trace were written to ETW on Windows and LTTng on Linux.</p><h4 id="dotnet-trace"><code>dotnet-trace</code></h4><p>In 3.0-preview5, every .NET Core application opens a duplex pipe named <code>EventPipe</code> (Unix domain socket on *nix/named pipe on Windows) over which it can emit events. While we’re still working on the controller protocol, <code>dotnet-trace</code> implements the preview version of this protocol.</p><p>You can install this .NET global tool by running the following command</p><p><code><code><span>dotnet</span> tool install --global dotnet-trace--version 1.0.3-preview5.19251.2</code></code></p><figure></figure><p>In the example above, I’m running <code>dotnet trace</code> with the default profile which enables the CPU profiler events and the .NET runtime events.</p><p>In addition to the default events, you can enable <a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md" target="_blank">additional providers</a> based on the investigation you are trying to perform.</p><p>As a result of running <code>dotnet trace</code> you are presented with a <code>.netperf</code> file. This file contains both the runtime events and sampled CPU stacks that can be visualized in <a href="https://github.com/Microsoft/perfview" target="_blank">perfview</a>. The next update of Visual Studio (16.1) will also add support for visualizing these traces.</p><figure><img src="https://user-images.githubusercontent.com/4734691/57052078-c5dc5e00-6c39-11e9-91d1-c515b8c00f49.png" alt="VS visualization"></figure><p>If you’re running on OS X or Linux when you capture a trace, you can choose to convert these <code>.netperf</code> files to <code>.speedscope.json</code> files that can be visualized with <a href="https://www.speedscope.app/" target="_blank">Speedscope.app</a>.</p><p>You can convert an existing trace by running the following command</p><p><code><code><span>dotnet</span> trace convert &lt;input-netperf-file&gt;</code></code></p><p>The image below shows the icicle chart visualizing the trace we just captured in speedscope.</p><figure><img src="https://user-images.githubusercontent.com/4734691/57051263-9297d000-6c35-11e9-8b7d-94bc2b70e45a.png" alt="icicle"></figure><p>For detailed instructions on how to use this tool, look at the <a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md" target="_blank">dotnet-trace readme</a>. For known limitations with <code>dotnet-trace</code>, look at the <a href="https://github.com/dotnet/diagnostics/issues?q=is%3Aopen+is%3Aissue+label%3Adotnet-trace" target="_blank">open issues on GitHub</a>.</p><h3 id="why-did-my-application-crash">Why did my application crash?</h3><p>In some cases, it is not possible to ascertain what caused anomalous behavior by just tracing the process. In the event that the process crashed or situations where we may need more information like access to entire process heap, a process dump may be more suitable for analysis.</p><h4 id="dump-analysis">Dump Analysis</h4><p>A dump is a recording of the state of working virtual memory of a process usually captured when the process has terminated unexpectedly. Diagnosing core dump is commonly used to identify the causes of application crashes or unexpected behavior.</p><p>Traditionally, you relied on your operating system to capture a dump on application crash (e.g., Windows Error Reporting) or used a tool like <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procdump" target="_blank">procdump</a> to capture a dump when certain trigger criteria are met.</p><p>The challenge thus far with capturing dumps with .NET on Linux was capturing dumps with <code>gcore</code> or a debugger resulted extremely large dumps as the existing tools didn’t know what virtual memory pages to trim in a .NET Core process.</p><p>Additionally, it was challenging to analyze these dumps even after you had collected them as it required acquiring a debugger and configuring it to load <code>sos</code>, a debugger extension for .NET.</p><h4 id="dotnet-dump"><code>dotnet-dump</code></h4><p>3.0.0-preview5, we’re introducing a new tool that allows you to capture and analyze process dumps on both Windows and Linux.</p><p><code>dotnet-dump</code> is still under active development and the table below shows what functionality is currently supported on what operating systems.</p><table><tbody><tr><td></td><td><strong>Windows</strong></td><td><strong>OS X</strong></td><td><strong>Linux</strong></td></tr><tr><td><strong>Collect</strong></td><td><div><p>✅</p></div></td><td><div><p>❌</p></div></td><td><div><p>✅</p></div></td></tr><tr><td><strong>Analyze</strong></td><td><div><p>❌</p></div></td><td><div><p>❌</p></div></td><td><div><p>✅</p></div></td></tr></tbody></table><p>You can install this .NET global tool by running the following command</p><p><code><code><span><span>dotnet</span> tool install --global dotnet-dump --version 1.0.3-preview5.19251.2</span></code></code></p><p>Once you’ve installed <code>dotnet dump</code>, you can capture a process dump by running the following command</p><p><code><code><span><span>sudo</span> $HOME/.dotnet/tools/dotnet-dump collect -p &lt;pid&gt;</span></code></code></p><p>On Linux, the resulting dump can be analyzed by loading the resulting dump by running the following command</p><p><code><code><span><span>dotnet</span> dump analyze &lt;dump-name&gt;</span></code></code></p><p>In the following example, I try to determine ASP.NET Core Hosting Environment of a crashed dump by walking the heap.</p><p>For detailed instructions on how to use this tool, look at the <a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-dump-instructions.md" target="_blank">dotnet-dump readme</a>. For known limitations with <code>dotnet-dump</code>, look at the <a href="https://github.com/dotnet/diagnostics/issues?q=is%3Aopen+is%3Aissue+label%3Adotnet-dump" target="_blank">open issues on GitHub</a>.</p><h3 id="closing">Closing</h3><p>Thanks for trying out the new diagnostics tools in .NET Core 3.0. Please continue to give us feedback, either in the comments or on <a href="https://github.com/dotnet/diagnostics" target="_blank">GitHub</a>. We are listening carefully and will continue to make changes based on your feedback.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>