<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Promiscuous Cookies and Their Impending Death via the SameSite Policy -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Promiscuous Cookies and Their Impending Death via the SameSite Policy</h1>
    <section class="article_text post"> <p>Cookies like to get around. They have no scruples about where they go save for some basic constraints relating to the origin from which they were set. I mean have a think about it:</p><p>If a website sets a cookie then you click a link to another page on that same site, will the cookie be automatically sent with the request? Yes.</p><p>What if an <em>attacker</em> sends you a link to that same website in a malicious email and you click that link, will the cookie be sent? Also yes.</p><p>Last one: what if an attacker directs you to a malicious website and upon visiting it your browser makes a <em>post</em> request to the original website that set the cookie - will that cookie still be sent with the request? Yes!</p><p>Cookies just don&apos;t care about how the request was initiated nor from which origin, all they care about is that they&apos;re valid for the requested resource. &quot;Origin&quot; is a key word here too; those last two examples above are &quot;cross-origin&quot; requests in that they were initiated from origins other than the original website that set the cookie. Problem is, that opens up a rather nasty attack vector we know as Cross Site Request Forgery or CSRF. Way back in 2010 <a href="https://www.troyhunt.com/owasp-top-10-for-net-developers-part-5/">I was writing about this as part of the OWASP Top 10 for ASP.NET series</a> and a near decade on, it&apos;s still a problem. Imagine this request:</p><pre><code>POST https://hack-yourself-first.com/Account/ChangePassword
Cookie: AuthCookie=EF29...

NewPassword: passw0rd
ConfirmPassword: passw0rd</code></pre><p>This is a real request from <a href="https://hack-yourself-first.com/">my Hack Yourself First website</a> I use as part of the workshops Scott Helme and I run. You can go and create an account there then try to change the password and watch the request that&apos;s sent via your browser&apos;s dev tools. Then, ask yourself the question: what does the HTTP request need to look like in order to change the user&apos;s password? There are only 3 requirements:</p><ol><li>It needs to be a POST request</li><li>It needs to be sent to the URL on the first line</li><li>It needs to have 2 fields in the body called NewPassword and ConfirmPassword</li></ol><p>That is all. It doesn&apos;t matter if the request is initiated from the website itself or from an external location, for example an attacker&apos;s website. If that malicious site can force the browser into making a POST request to that URL with that form data, the password is changed. Why is this possible? Because the auth cookie is sent with the request regardless of where it&apos;s initiated from and that, is how a CSRF attack works.</p><p>We (the industry) tackled this risk by applying copious amounts of sticky tape we refer to anti-forgery tokens. By way of example, here&apos;s what the request to <a href="https://haveibeenpwned.com/DomainSearch">perform a domain search</a> for troyhunt.com on HIBP looks like:</p><pre><code>POST https://haveibeenpwned.com/DomainSearch
.AspNet.ApplicationCookie=BjzGJ4...
__RequestVerificationToken=B0kTW2...

DomainName: troyhunt.com
__RequestVerificationToken: Llx764...</code></pre><p>There are two anti-forgery tokens passed in the request, one in a cookie and one in the body, both called &quot;__RequestVerificationToken&quot;. They&apos;re not identical but they&apos;re paired such that when the server receives the request it checks to see if both values exist and belong together. If not, the request is rejected. This works because whilst the one in the cookie will be automatically sent with the request regardless of its origin, in a forged request scenario the one in the body would need to be provided by the attacker and they have no idea what the value should be. The browser&apos;s security model ensures there&apos;s no way of the attacker causing the victim&apos;s browser to visit the target site, generate the token in the HTML then pull it out of the browser in a way the malicious actor can access. At least not without a cross site scripting vulnerability as well and then that&apos;s a whole different class of vulnerability with different defences.</p><p>This, frankly, is a mess. Whilst <a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks">it&apos;s relatively easy to implement via frameworks such as ASP.NET</a>, it leaves you wondering - do cookies really need to be that promiscuous? Do they need to accompany every single request regardless of the origin? No, they don&apos;t, which is why if you look in Chrome&apos;s dev tools on this very blog at the time of writing, you&apos;ll see the following:</p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2019/12/image-7.png" class="kg-image"></figure><p>The &quot;future release of Chrome&quot; is version 80 and <a href="https://www.chromestatus.com/features/schedule">it&apos;s scheduled to land on the 4th of Feb</a> which is rapidly approaching. Which brings us to the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie">SameSite cookies</a> mentioned in the console warning above. In a nutshell, they boil down to 3 different ways of handling cookies based on the value set:</p><ol><li>None: what Chrome defaults to today without a SameSite value set</li><li>Lax: some limits on sending cookies on a cross-origin request</li><li>Strict: tight limits on sending cookies on a cross-origin request</li></ol><p>Come version 80, any cookie without a SameSite attribute will be treated as &quot;Lax&quot; by Chrome. This is <em>really</em> important to understand because put simply, it&apos;ll very likely break a bunch of stuff. In order to demonstrate that, I&apos;ve set up a little demo site to show how &quot;Lax&quot; and &quot;Strict&quot; SameSite cookies behave alongside the traditional ones with no policy at all. I&apos;m going to do this with an &quot;origin&quot; site (the one that sets the cookies in the first place) and an &quot;external&quot; site (one which links to or embeds content from the origin site). Let&apos;s begin by visiting the origin site at <a href="http://originsite.azurewebsites.net/setcookies/">http://originsite.azurewebsites.net/setcookies/</a></p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-5.png" class="kg-image"></figure><p>That&apos;s intentionally loaded over the insecure scheme for reasons that will became apparent later. It sets a bunch of cookies which can then be read at <a href="http://originsite.azurewebsites.net/readcookies/">http://originsite.azurewebsites.net/readcookies/</a></p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-17.png" class="kg-image"></figure><p>I&apos;m showing the Chrome dev tools here as they make it easy to see the SameSite value that&apos;s been set for each cookie (if set at all). These have been given self-explanatory names so no need to delve into them here. The main thing is that the site setting the cookies can read them all. But that&apos;s not what SameSite is all about, let&apos;s make it interesting and load up <a href="http://externalsite.azurewebsites.net/">http://externalsite.azurewebsites.net/</a></p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-6.png" class="kg-image"></figure><p>There are 4 different things I want to demonstrate here as each implements a slightly different behaviour. Let&apos;s begin with by clicking the GET request button:</p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-7.png" class="kg-image"></figure><p>This loads the origin website with the GET verb and passes through all existing cookies <em>except </em>for the &quot;Strict&quot; one. Going back to the purpose of this blog post, once Chrome starts defaulting cookies without a SameSite policy to &quot;Lax&quot;, GET requests will still send them through.</p><p>Next up, let&apos;s try the POST request:</p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-8.png" class="kg-image"></figure><p>And this is where things start to get interesting as neither the &quot;Strict&quot; nor &quot;Lax&quot; cookies have been sent with the request. The default cookies with no SameSite policy has, but only because I&apos;m running Chrome 79. Come next month when Chrome 80 hits, the image above will no longer show the default cookie. By extension, any websites you&apos;re responsible for that are passing cookies around cross domain by POST request and don&apos;t already have a SameSite policy are going to start misbehaving pretty quickly.</p><p>Next up is the iframe:</p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-9.png" class="kg-image"></figure><p>You can see how the source of the frame is the origin website and embedding it like this will make a GET request, but even the &quot;Lax&quot; cookie hasn&apos;t been passed. This is really important to understand: not all resource types behave the same way even when the same verb is used.</p><p>The last one is the cookie image and it&apos;s easiest just to look at the request in the dev tools for this one:</p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-10.png" class="kg-image"></figure><p>As with the iframe, it&apos;s only the cookies with no SameSite policy that are sent either because it&apos;s explicitly set to &quot;None&quot; or because no policy has been set at all. But as with the iframe and the POST request, the default cookie shortly won&apos;t be sent at all and again, that&apos;s where the gotcha is going to hit next month.</p><p>Now, there&apos;s two more nuance to all this, the first of which is detailed on <a href="https://www.chromestatus.com/feature/5088147346030592">Chrome&apos;s Platform Status page</a>:</p><blockquote>Chrome will make an exception for cookies set without a SameSite attribute less than 2 minutes ago. Such cookies will also be sent with non-idempotent (e.g. POST) top-level cross-site requests despite normal SameSite=Lax cookies requiring top-level cross-site requests to have a safe (e.g. GET) HTTP method. Support for this intervention (&quot;Lax + POST&quot;) will be removed in the future.</blockquote><p>Given that last sentence, it&apos;s probably not something you want to be relying on though.</p><p>The second nuance relates to <a href="https://www.chromestatus.com/feature/5633521622188032">cookies with a &quot;None&quot; policy that are served insecurely</a>:</p><blockquote>Deprecate and remove the use of cookies with the SameSite=None attribute but without the Secure attribute. Any cookie that requests SameSite=None but is not marked Secure will be rejected.</blockquote><p>As a massive HTTPS proponent, this makes me happy &#x1F60A; To demonstrate this behaviour, I&apos;ve added an additional &quot;None&quot; cookie but flagged it as secure. As such, the cookie will only stick after being loaded over an HTTPS connection so give this a go: <a href="https://originsite.azurewebsites.net/setcookies/">https://originsite.azurewebsites.net/setcookies/</a></p><p>That results in the following cookies coming back in the response, the highlighted one being the new one:</p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-12.png" class="kg-image"></figure><p>Now try loading the <em>secure </em>version of the external site at <a href="https://externalsite.azurewebsites.net/">https://externalsite.azurewebsites.net/</a></p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-13.png" class="kg-image"></figure><p>Both the highlighted cookies will die as of Chrome 80: The &quot;None&quot; cookie because whilst it has a SameSite policy, it&apos;s not flagged as &quot;Secure&quot; and the default cookie because it will inherit the behaviour of a &quot;Lax&quot; cookie which will no longer be loaded into an iframe.</p><p>Want to try it all out? You can toggle these features in Chrome today by first changing the default behaviour for cookies without a SameSite policy at <a href="chrome://flags/#same-site-by-default-cookies">chrome://flags/#same-site-by-default-cookies</a></p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-14.png" class="kg-image"></figure><p>And then requiring that they be secure at <a href="chrome://flags/#cookies-without-same-site-must-be-secure">chrome://flags/#cookies-without-same-site-must-be-secure</a></p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-15.png" class="kg-image"></figure><p>Now let&apos;s try loading that last page again:</p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-16.png" class="kg-image"></figure><p>This change has the potential to break a lot of stuff so if you&apos;re in an environment where you&apos;re explicitly disabling the SameSite policy with &quot;None&quot; and still making insecure requests (*cough* enterprise), times are about to get interesting. Or if you&apos;re Google&apos;s own tracking service:</p><p><img src="https://www.troyhunt.com/content/images/2020/01/SameSite-Cookie-Warning.png" alt></p>
<p>This popped up on my blog as soon as I changed Chrome&apos;s default behaviour to reflect what&apos;s coming next month (it&apos;s subtly different to the one earlier in this blog post) so it&apos;s a good example of the sorts of things you can proactively pick up now. If you do see this sort of thing in the enterprise, Chrome&apos;s changed behaviour can also be reverted across the organisation:</p><blockquote>Enterprise IT administrators may need to implement <a href="https://www.chromium.org/administrators/policy-list-3/cookie-legacy-samesite-policies">special policies</a> to temporarily revert Chrome Browser to legacy behavior if some services such as single sign-on or internal applications are not ready for the February launch.</blockquote><p>As an example of the sort of stuff this change impacts, Microsoft have said <a href="https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/">it breaks OpenIdConnect logins</a> which is definitely something you want to be aware of in advance. If you&apos;re living in a Microsoft world, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.web.httpcookie.samesite?view=netframework-4.8">as of .NET 4.7.2 there&apos;s now a SameSite enum on cookies</a> to help make configuring your apps a little easier:</p><figure class="kg-card kg-image-card"><img src="https://www.troyhunt.com/content/images/2020/01/image-11.png" class="kg-image"></figure><p>(Quick note on Microsoft&apos;s implementation: <a href="https://stackoverflow.com/questions/56988877/samesite-cookie-attribute-ommited-by-asp-net-core">their first shot at it was buggy and caused the &quot;None&quot; policy to omit the SameSite cookie attribute altogether</a> which, as you&apos;re now aware, would cause issues come Chrome 80. It&apos;s since fixed in the latest framework releases but as of the time of writing, <em>hasn&apos;t</em> been pushed to the Azure App Service. I&apos;ve just finished a rather frustrating debugging process which culminated in manually sending a &quot;Set-Cookie&quot; header to make the demo app behave as I wanted it to.)</p><p>This changed cookie behaviour looks like it&apos;s going to stick and extend well beyond just Chrome. There&apos;s an <a href="https://tools.ietf.org/html/draft-west-cookie-incrementalism-00">IETF draft for Incrementally Better Cookies</a> specifying &quot;Lax&quot; by default and requiring &quot;Secure&quot; on all &quot;None&quot; cookies and <a href="https://groups.google.com/forum/#!msg/mozilla.dev.platform/nx2uP0CzA9k/BNVPWDHsAQAJ">Mozilla have an intent to implement the same behaviour in Firefox</a> (note that back in May they were targeting V69 but as of V71 which is current today, it&apos;s not yet implemented).</p><p>So that&apos;s the SameSite cookie story. It&apos;s a good move by Chrome IMHO as it takes us towards a more &quot;secure by default&quot; position but as with many changes that favour security, it&apos;ll also break some stuff along the way. The fix is easy, all it needs is for everyone responsible for maintaining any system that uses cookies that might be passed from an external origin to understand what&apos;s going on. Can&apos;t be that hard, right? Hello? Oh...</p> <section class="article-open_tag"> <a class="tag" href="/tag/cookies/">Cookies</a> <a class="tag" href="/tag/security/">Security</a> </section> </section>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>