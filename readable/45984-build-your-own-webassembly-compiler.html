<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Build your own WebAssembly Compiler -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Build your own WebAssembly Compiler</h1><div><div class="cell"><p>Have you ever wanted to write your own compiler? â€¦ yes? â€¦ of course you have! Iâ€™ve always wanted to have a go at writing a compiler, and with the recent release of WebAssembly, I had the perfect excuse to have a go.</p><p>My original plan was to <em>invent</em> my own programming language, create a compiler that targets WebAssembly, and share my experiences at <a href="https://skillsmatter.com/conferences/11077-fullstack-nyc-2019-the-conference-on-javascript-node-and-internet-of-things">FullStackNYC</a>. The first part went to plan, I spent many-an-evening building, tinkering and refining my compiler. Unfortunately the last part of my plan didnâ€™t go quite so well. Long delays, and an <a href="https://twitter.com/ColinEberhardt/status/1128753147969773569">eventual cancellation</a>, meant that I wasnâ€™t going to make it to New York after all. ðŸ˜”ðŸ˜¢ðŸ˜­</p><p>So, rather than waste all that work - I thought Iâ€™d write up my talk as a blog post instead - hence the â€˜19 minâ€™ reading time for this article. So sit back, make yourself comfortable, and weâ€™ll begin â€¦</p><h2 id="what-is-webassembly-and-why-does-it-exist">What is WebAssembly? (and why does it exist?)</h2><p>If you havenâ€™t heard of WebAssembly before, and want a really detailed introduction, Iâ€™d thoroughly recommend <a href="https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/">Lin Clarkâ€™s Cartoon Guide</a>.</p><p>Youâ€™ll learn the â€˜whatâ€™ of WebAssembly throughout this blog post, but I do want to briefly touch on the â€˜whyâ€™.</p><p>From my perspective, this diagram sums it up quite succinctly:</p><p><img src="/ceberhardt/assets/wasm-compiler/wasm-execution.png"></p><p>The top diagram shows a simplified timeline for the execution of some JavaScript code within the browser. From left-to-right, the code (typically delivered as a minified mess!) is parsed into an AST, initially executed in an interpreter, then progressively optimised / re-optimised until it eventually runs really quite quickly. These days JavaScript is fast - it just takes a while to get up to speed.</p><p>The bottom diagram is the WebAssembly equivalent. Code written in a wide variety of languages (Rust, C, C#, etc â€¦) is compiled to WebAssembly that is delivered in a binary format. This is very easily decoded, compiled and executed - giving fast and predictable performance.</p><h2 id="so-why-write-your-own-compiler">So why write your own compiler?</h2><p>WebAssembly has been causing quite a stir over the last year. So much so, that it was voted the fifth â€˜most lovedâ€™ language in <a href="https://insights.stackoverflow.com/survey/2019">Stack Overflowâ€™s developer insights survey</a>.</p><p><img src="/ceberhardt/assets/wasm-compiler/webassembly-love.png"></p><p>An interesting result, considering that for most people WebAssembly is a compilation target, rather than a language they will use directly.</p><p>This was part of my motivation for proposing the FullStackNYC talk in the first place. The technical aspects of WebAssembly are really fascinating (and remind me of 8-bit computers from a few decades back), yet most people will never get the chance to dabble with WebAssembly itself - it will just be a black box that they compile to.</p><p>Writing a compiler is a really good opportunity to delve into the details of WebAssembly to find it what it is and how it works. And itâ€™s fun too!</p><p>One final point, it was never my aim to create a fully-featured programming language, or one that is actually any good. My goal was to create â€˜enoughâ€™ of a language to allow me to write a program that renders a mandelbrot set. This language is compiled to WebAssembly using my compiler, which is written in TypeScript and runs in the browser.</p><p>Here it is in itâ€™s full glory:</p><p><img src="/ceberhardt/assets/wasm-compiler/wasm-mandelbrot.png"></p><p>I ended up calling the language <em>chasm</em> and you can <a href="https://colineberhardt.github.io/chasm/">play with it online if you like</a>.</p><p>Enough rambling - time for some code!</p><h2 id="a-minimal-wasm-module">A minimal wasm module</h2><p>Before tackling the compiler, weâ€™ll start with something simpler, creating a minimal WebAssembly module.</p><p>Here is an emitter (the term used for the part of a compiler that outputs instructions for the target system), that creates the smallest valid WebAssembly module:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">magicModuleHeader</span><span class="o">=</span><span class="p">[</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x61</span><span class="p">,</span><span class="mh">0x73</span><span class="p">,</span><span class="mh">0x6d</span><span class="p">];</span><span class="kd">const</span><span class="nx">moduleVersion</span><span class="o">=</span><span class="p">[</span><span class="mh">0x01</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">,</span><span class="mh">0x00</span><span class="p">];</span><span class="k">export</span><span class="kd">const</span><span class="nx">emitter</span><span class="p">:</span><span class="nx">Emitter</span><span class="o">=</span><span class="p">()</span><span class="o">=&gt;</span><span class="nb">Uint8Array</span><span class="p">.</span><span class="k">from</span><span class="p">([</span><span class="p">...</span><span class="nx">magicModuleHeader</span><span class="p">,</span><span class="p">...</span><span class="nx">moduleVersion</span><span class="p">]);</span></code></pre></div></div><p>It is comprised of two parts, the â€˜magicâ€™ header, which is the ASCII string <code class="language-plaintext highlighter-rouge">\0asm</code>, and a version number. These eight bytes form valid WebAssembly (or wasm) module. More typically these would be delivered to the browser as a <code class="language-plaintext highlighter-rouge">.wasm</code> file.</p><p>In order to execute the WebAssembly module it needs to be instantiated as follows:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">wasm</span><span class="o">=</span><span class="nx">emitter</span><span class="p">();</span><span class="kd">const</span><span class="nx">instance</span><span class="o">=</span><span class="k">await</span><span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">instantiate</span><span class="p">(</span><span class="nx">wasm</span><span class="p">);</span></code></pre></div></div><p>If you run the above youâ€™ll find that <code class="language-plaintext highlighter-rouge">instance</code> doesnâ€™t actually do anything because our wasm module doesnâ€™t contain any instructions!</p><p>If youâ€™re interested in trying out this code for yourself, it is all on GitHub - <a href="https://github.com/ColinEberhardt/chasm/commit/26db676f9147b16a0edff38ee20dcd636389f637">with a commit for each step</a>.</p><h2 id="an-add-function">An add function</h2><p>Letâ€™s make the wasm module do something more useful, by implementing a function that adds a couple of floating point numbers together.</p><p>WebAssembly is a binary format, which isnâ€™t terribly readable (to humans at least), which is why youâ€™ll more typically see it written in WebAssembly Text Format (WAT). Hereâ€™s a module, presented in WAT format, that defines an exported function named <code class="language-plaintext highlighter-rouge">$add</code> that takes two floating point parameters, adds them together and returns them:</p><pre><code class="language-webassembly">(module
 (func $add (param f32) (param f32) (result f32)
   get_local 0
   get_local 1
   f32.add)
 (export "add" (func 0))
)
</code></pre><p>If you just want to experiment with WAT you can use the <code class="language-plaintext highlighter-rouge">wat2wasm</code> tool from the <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a> to compile WAT files into wasm modules.</p><p>The above code reveals some interesting details around WebAssembly -</p><ul><li>WebAssembly is a low-level language, with a small (approx 60) instruction set, where many of the instructions map quite closely to CPU instructions. This makes it easy to compile wasm modules to CPU-specific machine code.</li><li>It has no built in I/O. There are no instructions for writing to the terminal, screen or network. In order to wasm modules to interact with the outside world they need to do so via their host environment, which in the case of the browser is JavaScript.</li><li>WebAssembly is a stack machine, in the above example <code class="language-plaintext highlighter-rouge">get_local 0</code> gets the local variable (in this case the function param) at the zeroth index and pushes it onto the stack, as does the subsequent instruction. The <code class="language-plaintext highlighter-rouge">f3.add</code> instruction pops two values form the stack, adds them together than pushes the value back on the stack.</li><li>WebAssembly has just four numeric types, two integer, two floats. More on this later â€¦</li></ul><p>Letâ€™s update the emitter to output this â€˜hard codedâ€™ WebAssembly module.</p><p>WebAssembly modules are composed of a pre-defined set of optional sections, each prefixed with a numeric identifier. These include a type section, which encode type signatures, and function section, which indicates the type of each function. Iâ€™ll not cover how these are constructed here - they are quite dull. If youâ€™re interested, <a href="TODO">look at the next commit in the project</a>.</p><p>The interesting part is the code section. Here is how the above <code class="language-plaintext highlighter-rouge">add</code> function is created in binary:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">code</span><span class="o">=</span><span class="p">[</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">get_local</span><span class="cm">/** 0x20 */</span><span class="p">,</span><span class="p">...</span><span class="nx">unsignedLEB128</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">get_local</span><span class="cm">/** 0x20 */</span><span class="p">,</span><span class="p">...</span><span class="nx">unsignedLEB128</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">f32_add</span><span class="cm">/** 0x92 */</span><span class="p">];</span><span class="kd">const</span><span class="nx">functionBody</span><span class="o">=</span><span class="nx">encodeVector</span><span class="p">([</span><span class="p">...</span><span class="nx">encodeVector</span><span class="p">([])</span><span class="cm">/** locals */</span><span class="p">,</span><span class="p">...</span><span class="nx">code</span><span class="p">,</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">end</span><span class="cm">/** 0x0b */</span><span class="p">]);</span><span class="kd">const</span><span class="nx">codeSection</span><span class="o">=</span><span class="nx">createSection</span><span class="p">(</span><span class="nx">Section</span><span class="p">.</span><span class="nx">code</span><span class="cm">/** 0x0a */</span><span class="p">,</span><span class="nx">encodeVector</span><span class="p">([</span><span class="nx">functionBody</span><span class="p">]));</span></code></pre></div></div><p>Iâ€™ve defined an <code class="language-plaintext highlighter-rouge">Opcodes</code> enum (Iâ€™m using TypeScript), which contains all of the wasm instructions. The <code class="language-plaintext highlighter-rouge">unsignedLEB128</code> function is a standard <a href="https://en.wikipedia.org/wiki/LEB128">variable length encoding</a> which is used for encoding instruction parameters.</p><p>The instructions for a function are combined with the functionâ€™s local variables (of which there are none in this case), and an <code class="language-plaintext highlighter-rouge">end</code> opcode that signals the end of a function. Finally all the functions are encoded into a section. The <code class="language-plaintext highlighter-rouge">encodeVector</code> function simply prefixes a collection of byte arrays with the total length.</p><p>And there you have it, the complete module, which is about 30 bytes in total.</p><p>The JavaScript hosting code can now be updated to involve this exported function:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="p">{</span><span class="nx">instance</span><span class="p">}</span><span class="o">=</span><span class="k">await</span><span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">instantiate</span><span class="p">(</span><span class="nx">wasm</span><span class="p">);</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">));</span></code></pre></div></div><p>Interestingly if you inspect the exported <code class="language-plaintext highlighter-rouge">add</code> function with the Chrome Dev Tools it identifier it as a â€˜native functionâ€™.</p><p>You can see the complete <a href="https://github.com/ColinEberhardt/chasm/tree/2ec3f7312a1d16043dccc1dae92ea22db91998d3">code for this step (with unit tests - go me!) on GitHub</a>.</p><h2 id="building-a-compiler">Building a compiler</h2><p>Now that youâ€™ve seen how to dynamically create wasm modules, itâ€™s time to turn our attention to the task of creating a compiler. Weâ€™ll start with a bit of terminology.</p><p>Hereâ€™s some <em>chasm</em> code annotated to show the key components of a language:</p><p><img src="/ceberhardt/assets/wasm-compiler/language-terminology.png"></p><p>Rather than give a â€˜textbook definitionâ€™ of each, youâ€™ll become familiar with them as the compiler evolves.</p><p>The compiler itself will be formed of three parts, the <strong>tokenizer</strong> which breaks up the input program (which is a string), into discrete tokens, the <strong>parser</strong> that takes these tokens and converts them into an Abstract Syntax Tree (AST), and finally the <strong>emitter</strong> which converts the AST into wasm binary module.</p><p>This is a pretty standard compiler architecture:</p><p><img src="/ceberhardt/assets/wasm-compiler/compiler-architecture.png"></p><p>Rather than dive into a complete implementation, weâ€™ll tackle a small subset of the problem. The goal is to create a compiler for a language that just supports print statements which print simple numeric literals â€¦</p><h2 id="the-tokenizer">The Tokenizer</h2><p>The tokenizer works by advancing through the input string, one character at a time, matching patterns that represent specific token types. The following code creates three matches (<code class="language-plaintext highlighter-rouge">number</code>, <code class="language-plaintext highlighter-rouge">keyword</code>, and <code class="language-plaintext highlighter-rouge">whitespace</code>), using simple regular expressions:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">keywords</span><span class="o">=</span><span class="p">[</span><span class="dl">"</span><span class="s2">print</span><span class="dl">"</span><span class="p">];</span><span class="c1">// returns a token if the given regex matches at the current index</span><span class="kd">const</span><span class="nx">regexMatcher</span><span class="o">=</span><span class="p">(</span><span class="nx">regex</span><span class="p">:</span><span class="nx">string</span><span class="p">,</span><span class="nx">type</span><span class="p">:</span><span class="nx">TokenType</span><span class="p">):</span><span class="nx">Matcher</span><span class="o">=&gt;</span><span class="p">(</span><span class="nx">input</span><span class="p">:</span><span class="nx">string</span><span class="p">,</span><span class="nx">index</span><span class="p">:</span><span class="nx">number</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span><span class="kd">const</span><span class="nx">match</span><span class="o">=</span><span class="nx">input</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">index</span><span class="p">).</span><span class="nx">match</span><span class="p">(</span><span class="nx">regex</span><span class="p">);</span><span class="k">return</span><span class="p">(</span><span class="nx">match</span><span class="o">&amp;&amp;</span><span class="p">{</span><span class="nx">type</span><span class="p">,</span><span class="na">value</span><span class="p">:</span><span class="nx">match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">}</span><span class="p">);</span><span class="p">};</span><span class="kd">const</span><span class="nx">matchers</span><span class="o">=</span><span class="p">[</span><span class="nx">regexMatcher</span><span class="p">(</span><span class="dl">"</span><span class="s2">^[.0-9]+</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">),</span><span class="nx">regexMatcher</span><span class="p">(</span><span class="s2">`^(</span><span class="p">${</span><span class="nx">keywords</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2">|</span><span class="dl">"</span><span class="p">)}</span><span class="s2">)`</span><span class="p">,</span><span class="dl">"</span><span class="s2">keyword</span><span class="dl">"</span><span class="p">),</span><span class="nx">regexMatcher</span><span class="p">(</span><span class="dl">"</span><span class="s2">^</span><span class="se">\\</span><span class="s2">s+</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">whitespace</span><span class="dl">"</span><span class="p">)</span><span class="p">];</span></code></pre></div></div><p>(Note, these regular expressions are not terribly robust!)</p><p>The <code class="language-plaintext highlighter-rouge">Matcher</code> interface defines a function that given an input string and an index returns a token if a match occurs.</p><p>The main body of the parser iterates over the characters of the string, finding the first match, adding the provided token to the output array:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span><span class="kd">const</span><span class="nx">tokenize</span><span class="p">:</span><span class="nx">Tokenizer</span><span class="o">=</span><span class="nx">input</span><span class="o">=&gt;</span><span class="p">{</span><span class="kd">const</span><span class="na">tokens</span><span class="p">:</span><span class="nx">Token</span><span class="p">[]</span><span class="o">=</span><span class="p">[];</span><span class="kd">let</span><span class="nx">index</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="k">while</span><span class="p">(</span><span class="nx">index</span><span class="o">&lt;</span><span class="nx">input</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span><span class="p">{</span><span class="kd">const</span><span class="nx">matches</span><span class="o">=</span><span class="nx">matchers</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">m</span><span class="o">=&gt;</span><span class="nx">m</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span><span class="nx">index</span><span class="p">)).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">f</span><span class="o">=&gt;</span><span class="nx">f</span><span class="p">)</span><span class="kd">const</span><span class="nx">match</span><span class="o">=</span><span class="nx">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="k">if</span><span class="p">(</span><span class="nx">match</span><span class="p">.</span><span class="nx">type</span><span class="o">!==</span><span class="dl">"</span><span class="s2">whitespace</span><span class="dl">"</span><span class="p">)</span><span class="p">{</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">match</span><span class="p">);</span><span class="p">}</span><span class="nx">index</span><span class="o">+=</span><span class="nx">match</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="p">}</span><span class="k">return</span><span class="nx">tokens</span><span class="p">;</span><span class="p">};</span></code></pre></div></div><p>Here is the tokenised output of the program <code class="language-plaintext highlighter-rouge">"print 23.1"</code>:</p><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"keyword"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">"print"</span><span class="p">,</span><span class="w"></span><span class="nl">"index"</span><span class="p">:</span><span class="w"></span><span class="mi">1</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"number"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">"23.1"</span><span class="p">,</span><span class="w"></span><span class="nl">"index"</span><span class="p">:</span><span class="w"></span><span class="mi">7</span><span class="w"></span><span class="p">}</span><span class="w"></span><span class="p">]</span><span class="w"></span></code></pre></div></div><p>As you can see from the above input, the tokeniser removes whitespace as it has no meaning (for this specific language), it also ensures that everything in the input string is a valid token. However, it doesnâ€™t make any guarantees about the input being well-formed, for example the tokeniser will happily handle <code class="language-plaintext highlighter-rouge">"print print"</code>, which is clearly incorrect.</p><p>The array of tokens is next fed into the parser.</p><h2 id="the-parser">The Parser</h2><p>The goal of the parser is the creation of an Abstract Syntax Tree (AST), a tree structure that encodes the relationship between these tokens, resulting in a form that could potentially be sent to an interpreter for direct execution.</p><p>The parser iterates through the supplied tokens, consuming them via an <code class="language-plaintext highlighter-rouge">eatToken</code> function.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span><span class="kd">const</span><span class="nx">parse</span><span class="p">:</span><span class="nx">Parser</span><span class="o">=</span><span class="nx">tokens</span><span class="o">=&gt;</span><span class="p">{</span><span class="kd">const</span><span class="nx">iterator</span><span class="o">=</span><span class="nx">tokens</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span><span class="kd">let</span><span class="nx">currentToken</span><span class="o">=</span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">;</span><span class="kd">const</span><span class="nx">eatToken</span><span class="o">=</span><span class="p">()</span><span class="o">=&gt;</span><span class="p">(</span><span class="nx">currentToken</span><span class="o">=</span><span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">);</span><span class="p">[...]</span><span class="kd">const</span><span class="na">nodes</span><span class="p">:</span><span class="nx">StatementNode</span><span class="p">[]</span><span class="o">=</span><span class="p">[];</span><span class="k">while</span><span class="p">(</span><span class="nx">index</span><span class="o">&lt;</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span><span class="p">{</span><span class="nx">nodes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">parseStatement</span><span class="p">());</span><span class="p">}</span><span class="k">return</span><span class="nx">nodes</span><span class="p">;</span><span class="p">};</span></code></pre></div></div><p>(Iâ€™ve no idea where the concept of eating tokens comes from, it appears to be standard parser terminology, they are clearly hungry beasts!)</p><p>The goal of the above parser is to turn the token array into an array of statements, which are the core building blocks of this language. It expects the given tokens to conform to this pattern, and will throw an error (not shown above) if it does not.</p><p>The <code class="language-plaintext highlighter-rouge">parseStatement</code> function expects each statement to start with a keyword - switching on its value:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">parseStatement</span><span class="o">=</span><span class="p">()</span><span class="o">=&gt;</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="nx">currentToken</span><span class="p">.</span><span class="nx">type</span><span class="o">===</span><span class="dl">"</span><span class="s2">keyword</span><span class="dl">"</span><span class="p">)</span><span class="p">{</span><span class="k">switch</span><span class="p">(</span><span class="nx">currentToken</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="p">{</span><span class="k">case</span><span class="dl">"</span><span class="s2">print</span><span class="dl">"</span><span class="p">:</span><span class="nx">eatToken</span><span class="p">();</span><span class="k">return</span><span class="p">{</span><span class="na">type</span><span class="p">:</span><span class="dl">"</span><span class="s2">printStatement</span><span class="dl">"</span><span class="p">,</span><span class="na">expression</span><span class="p">:</span><span class="nx">parseExpression</span><span class="p">()</span><span class="p">};</span><span class="p">}</span><span class="p">}</span><span class="p">};</span></code></pre></div></div><p>Currently the only supported keyword is <code class="language-plaintext highlighter-rouge">print</code>, in this case it returns an AST node of type <code class="language-plaintext highlighter-rouge">printStatement</code> parsing the associated expression.</p><p>And here is the expression parser:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">parseExpression</span><span class="o">=</span><span class="p">()</span><span class="o">=&gt;</span><span class="p">{</span><span class="kd">let</span><span class="na">node</span><span class="p">:</span><span class="nx">ExpressionNode</span><span class="p">;</span><span class="k">switch</span><span class="p">(</span><span class="nx">currentToken</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span><span class="p">{</span><span class="k">case</span><span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">:</span><span class="nx">node</span><span class="o">=</span><span class="p">{</span><span class="na">type</span><span class="p">:</span><span class="dl">"</span><span class="s2">numberLiteral</span><span class="dl">"</span><span class="p">,</span><span class="na">value</span><span class="p">:</span><span class="nb">Number</span><span class="p">(</span><span class="nx">currentToken</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="p">};</span><span class="nx">eatToken</span><span class="p">();</span><span class="k">return</span><span class="nx">node</span><span class="p">;</span><span class="p">}</span><span class="p">};</span></code></pre></div></div><p>In its present form the language only accepts expressions which are composed of a single number - i.e. a numeric literal. Therefore the above expression parser expects the next token to be a number, and when this matches, it returns a node of type <code class="language-plaintext highlighter-rouge">numberLiteral</code>.</p><p>Continuing the simple example of the program <code class="language-plaintext highlighter-rouge">"print 23.1"</code>, the parser outputs the following AST:</p><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"printStatement"</span><span class="p">,</span><span class="w"></span><span class="nl">"expression"</span><span class="p">:</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"numberLiteral"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="mf">23.1</span><span class="w"></span><span class="p">}</span><span class="w"></span><span class="p">}</span><span class="w"></span><span class="p">]</span><span class="w"></span></code></pre></div></div><p>As you can see the AST for this language is an array of statement nodes. Parsing guarantees that the input program is syntactically correct, i.e. it is properly constructed, but it doesnâ€™t of course guarantee that it will execute successfully, runtime errors might still be present (although for this simple language they are not possible!).</p><p>Weâ€™re onto the final step now â€¦</p><h2 id="the-emitter">The Emitter</h2><p>Currently the emitter outputs a hard-coded add function. It now needs to take this AST and emit the appropriate instructions, as follows:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">codeFromAst</span><span class="o">=</span><span class="nx">ast</span><span class="o">=&gt;</span><span class="p">{</span><span class="kd">const</span><span class="nx">code</span><span class="o">=</span><span class="p">[];</span><span class="kd">const</span><span class="nx">emitExpression</span><span class="o">=</span><span class="nx">node</span><span class="o">=&gt;</span><span class="p">{</span><span class="k">switch</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span><span class="p">{</span><span class="k">case</span><span class="dl">"</span><span class="s2">numberLiteral</span><span class="dl">"</span><span class="p">:</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">f32_const</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">ieee754</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span><span class="k">break</span><span class="p">;</span><span class="p">}</span><span class="p">};</span><span class="nx">ast</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">statement</span><span class="o">=&gt;</span><span class="p">{</span><span class="k">switch</span><span class="p">(</span><span class="nx">statement</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span><span class="p">{</span><span class="k">case</span><span class="dl">"</span><span class="s2">printStatement</span><span class="dl">"</span><span class="p">:</span><span class="nx">emitExpression</span><span class="p">(</span><span class="nx">statement</span><span class="p">.</span><span class="nx">expression</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">call</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">unsignedLEB128</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="k">break</span><span class="p">;</span><span class="p">}</span><span class="p">});</span><span class="k">return</span><span class="nx">code</span><span class="p">;</span><span class="p">};</span></code></pre></div></div><p>The emitter iterates over the statements that form the â€˜rootâ€™ of the AST, matching our only statement type - print. Notice that the first thing it does is emit the instructions for the statement expressions, recall that WebAssembly is a stack machine, hence the expression instructions must be processed first leaving the result on the stack.</p><p>The print function is implemented via a <code class="language-plaintext highlighter-rouge">call</code> operation, which invokes the function at index zero.</p><p>Previously weâ€™ve seen how wasm modules can export functions (as per the add example above), they can also import functions, which are supplied when you instantiate the module. Here we provide an <code class="language-plaintext highlighter-rouge">env.print</code> function that logs to the console:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">instance</span><span class="o">=</span><span class="k">await</span><span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">instantiate</span><span class="p">(</span><span class="nx">wasm</span><span class="p">,</span><span class="p">{</span><span class="na">env</span><span class="p">:</span><span class="p">{</span><span class="na">print</span><span class="p">:</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">}</span><span class="p">});</span></code></pre></div></div><p>This function is addressable by index, i.e. <code class="language-plaintext highlighter-rouge">call 0</code>.</p><p>You can see the complete code for the <a href="https://github.com/ColinEberhardt/chasm/tree/1edac4777e06b82da0133ef5554d1baaccea0726">compiler at this point on GitHub</a> - you can also have a play with this example via the <a href="https://colineberhardt.github.io/chasm/#cHJpbnQgMjMuMQ%3D%3D">online chasm compiler playground</a>.</p><p>Also, for completeness this is how the program progresses through the various compiler stages:</p><p><img src="/ceberhardt/assets/wasm-compiler/print-program.png"></p><p>So far weâ€™ve put quite a lot of structure in place, but not really felt the benefit. A separate tokenizer, parser and emitter is overkill for a language that only prints simple numerics. However, as the language complexity grows, this structure really starts to pay dividends.</p><h2 id="implementing-expressions">Implementing expressions</h2><p>Next up, weâ€™ll look at implementing binary expressions, allowing the language to perform simple mathematics, for example <code class="language-plaintext highlighter-rouge">print ((42 + 10) / 2)</code>.</p><p>For the tokeniser the changes are quite trivial, involving adding a couple of additional regex matchers for parentheses and operators. Iâ€™ll not reproduce them here - instead, just show the resultant output:</p><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"keyword"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">"print"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"parens"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">"("</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"parens"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">"("</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"number"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">"42"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"operator"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">"+"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"number"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">"10"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"parens"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">")"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"operator"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">"/"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"number"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">"2"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="nl">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"parens"</span><span class="p">,</span><span class="w"></span><span class="nl">"value"</span><span class="p">:</span><span class="w"></span><span class="s2">")"</span><span class="w"></span><span class="p">}</span><span class="w"></span><span class="p">]</span><span class="w"></span></code></pre></div></div><p>Next up, weâ€™ll look at the changes to the parser - where the expression parser can encounter either <code class="language-plaintext highlighter-rouge">number</code> of <code class="language-plaintext highlighter-rouge">parens</code> tokens:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">parseExpression</span><span class="o">=</span><span class="p">()</span><span class="o">=&gt;</span><span class="p">{</span><span class="kd">let</span><span class="na">node</span><span class="p">:</span><span class="nx">ExpressionNode</span><span class="p">;</span><span class="k">switch</span><span class="p">(</span><span class="nx">currentToken</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span><span class="p">{</span><span class="k">case</span><span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">:</span><span class="p">[...]</span><span class="k">case</span><span class="dl">"</span><span class="s2">parens</span><span class="dl">"</span><span class="p">:</span><span class="nx">eatToken</span><span class="p">();</span><span class="kd">const</span><span class="nx">left</span><span class="o">=</span><span class="nx">parseExpression</span><span class="p">();</span><span class="kd">const</span><span class="nx">operator</span><span class="o">=</span><span class="nx">currentToken</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span><span class="nx">eatToken</span><span class="p">();</span><span class="kd">const</span><span class="nx">right</span><span class="o">=</span><span class="nx">parseExpression</span><span class="p">();</span><span class="nx">eatToken</span><span class="p">();</span><span class="k">return</span><span class="p">{</span><span class="na">type</span><span class="p">:</span><span class="dl">"</span><span class="s2">binaryExpression</span><span class="dl">"</span><span class="p">,</span><span class="nx">left</span><span class="p">,</span><span class="nx">right</span><span class="p">,</span><span class="nx">operator</span><span class="p">};</span><span class="p">}</span><span class="p">};</span></code></pre></div></div><p>Notice that parsing of <code class="language-plaintext highlighter-rouge">parens</code> expressions is recursive, with the nodes for the left and right invoking the <code class="language-plaintext highlighter-rouge">parseExpression</code> function once again.</p><p>The AST for the program <code class="language-plaintext highlighter-rouge">print ((42 + 10) / 2)</code> is given below:</p><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="w"></span><span class="err">type:</span><span class="w"></span><span class="s2">"printStatement"</span><span class="p">,</span><span class="w"></span><span class="err">expression:</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="err">type:</span><span class="w"></span><span class="s2">"binaryExpression"</span><span class="p">,</span><span class="w"></span><span class="err">left:</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="err">type:</span><span class="w"></span><span class="s2">"binaryExpression"</span><span class="p">,</span><span class="w"></span><span class="err">left:</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="err">type:</span><span class="w"></span><span class="s2">"numberLiteral"</span><span class="p">,</span><span class="w"></span><span class="err">value:</span><span class="w"></span><span class="mi">42</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="err">right:</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="err">type:</span><span class="w"></span><span class="s2">"numberLiteral"</span><span class="p">,</span><span class="w"></span><span class="err">value:</span><span class="w"></span><span class="mi">10</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="err">operator:</span><span class="w"></span><span class="s2">"+"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="err">right:</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="err">type:</span><span class="w"></span><span class="s2">"numberLiteral"</span><span class="p">,</span><span class="w"></span><span class="err">value:</span><span class="w"></span><span class="mi">2</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="err">operator:</span><span class="w"></span><span class="s2">"/"</span><span class="w"></span><span class="p">}</span><span class="w"></span><span class="p">}]</span><span class="err">;</span><span class="w"></span></code></pre></div></div><p>The tree structure is becoming more obvious in this example.</p><p>Finally, the emitter needs to be updated in order to handle the <code class="language-plaintext highlighter-rouge">binaryExpression</code> node type, as follows:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">emitExpression</span><span class="o">=</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span><span class="o">=&gt;</span><span class="nx">traverse</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span><span class="k">switch</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span><span class="p">{</span><span class="k">case</span><span class="dl">"</span><span class="s2">numberLiteral</span><span class="dl">"</span><span class="p">:</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">f32_const</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">ieee754</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span><span class="k">break</span><span class="p">;</span><span class="k">case</span><span class="dl">"</span><span class="s2">binaryExpression</span><span class="dl">"</span><span class="p">:</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">binaryOpcode</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">operator</span><span class="p">]);</span><span class="k">break</span><span class="p">;</span><span class="p">}</span><span class="p">});</span></code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">traverse</code> function in the above code traverses tree structures invoking the given visitor for each node. While linear structures only have one logical way to traverse them (i.e. in order), trees can be <a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/">traversed in a number of different ways</a>. The traversal method used by the emitter is a depth-first post-order traversal, in other words as it encounters each node it visits left, right, then root - this order ensures that the wasm instructions are output in the correct order for the stack machine, operands then operator.</p><p>And thatâ€™s it, all the changes that are required to support expressions. Give it a <a href="https://colineberhardt.github.io/chasm/#cHJpbnQgKCg0MiArIDEwKSAvIDIp">go online</a>.</p><p>The compiler architecture is starting to prove its value!</p><h2 id="variables">Variables</h2><p>Next up, weâ€™ll add variables, allowing for more interesting <em>chasm</em> programs â€¦</p><p>Variables are declared using the <code class="language-plaintext highlighter-rouge">var</code> keyword, and can be used in expressions as identifiers.</p><p>Weâ€™ll not look at the changes to the tokeniser, itâ€™s just yet more regex! The main loop of the parser, which reads successive statements from the token array, determines the statement type based on the keyword it encounters:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">parseVariableDeclarationStatement</span><span class="o">=</span><span class="p">()</span><span class="o">=&gt;</span><span class="p">{</span><span class="nx">eatToken</span><span class="p">();</span><span class="c1">// var</span><span class="kd">const</span><span class="nx">name</span><span class="o">=</span><span class="nx">currentToken</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span><span class="nx">eatToken</span><span class="p">();</span><span class="nx">eatToken</span><span class="p">();</span><span class="c1">// =</span><span class="k">return</span><span class="p">{</span><span class="na">type</span><span class="p">:</span><span class="dl">"</span><span class="s2">variableDeclaration</span><span class="dl">"</span><span class="p">,</span><span class="nx">name</span><span class="p">,</span><span class="na">initializer</span><span class="p">:</span><span class="nx">parseExpression</span><span class="p">()</span><span class="p">};</span><span class="p">};</span><span class="kd">const</span><span class="na">parseStatement</span><span class="p">:</span><span class="nx">ParserStep</span><span class="o">&lt;</span><span class="nx">StatementNode</span><span class="o">&gt;</span><span class="o">=</span><span class="p">()</span><span class="o">=&gt;</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="nx">currentToken</span><span class="p">.</span><span class="nx">type</span><span class="o">===</span><span class="dl">"</span><span class="s2">keyword</span><span class="dl">"</span><span class="p">)</span><span class="p">{</span><span class="k">switch</span><span class="p">(</span><span class="nx">currentToken</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span><span class="p">{</span><span class="k">case</span><span class="dl">"</span><span class="s2">print</span><span class="dl">"</span><span class="p">:</span><span class="k">return</span><span class="nx">parsePrintStatement</span><span class="p">();</span><span class="k">case</span><span class="dl">"</span><span class="s2">var</span><span class="dl">"</span><span class="p">:</span><span class="k">return</span><span class="nx">parseVariableDeclarationStatement</span><span class="p">();</span><span class="p">}</span><span class="p">}</span><span class="p">};</span></code></pre></div></div><p>Variable declaration parsing is quite straight-forwards - notice that the <code class="language-plaintext highlighter-rouge">parseVariableDeclarationStatement</code> function also makes use of the expression parser, which ensures that variables can be declared and assigned an initial value from an expression, e.g. <code class="language-plaintext highlighter-rouge">var f = (1 + 4)</code>.</p><p>Next up, the emitter. WebAssembly functions can have local variables, these are declared at the beginning of the function definition, and are accessed via the <code class="language-plaintext highlighter-rouge">get_local</code> and <code class="language-plaintext highlighter-rouge">set_local</code> functions that also retrieve function parameters.</p><p>The variables in our AST are referenced via their identifier name, whereas wasm identifies locals by their index. The emitter needs to maintain this information in a symbol table, which is a simple map from the symbol name to index:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span><span class="nx">symbols</span><span class="o">=</span><span class="k">new</span><span class="nb">Map</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span><span class="nx">number</span><span class="o">&gt;</span><span class="p">();</span><span class="kd">const</span><span class="nx">localIndexForSymbol</span><span class="o">=</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span><span class="nx">string</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">symbols</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span><span class="p">{</span><span class="nx">symbols</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">symbols</span><span class="p">.</span><span class="nx">size</span><span class="p">);</span><span class="p">}</span><span class="k">return</span><span class="nx">symbols</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span><span class="p">};</span></code></pre></div></div><p>Within the node traversal, when a variable declaration is encountered, the expression is emitted, them <code class="language-plaintext highlighter-rouge">set_local</code> used to assign the value to the respective local variable.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span><span class="dl">"</span><span class="s2">variableDeclaration</span><span class="dl">"</span><span class="p">:</span><span class="nx">emitExpression</span><span class="p">(</span><span class="nx">statement</span><span class="p">.</span><span class="nx">initializer</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">set_local</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">unsignedLEB128</span><span class="p">(</span><span class="nx">localIndexForSymbol</span><span class="p">(</span><span class="nx">statement</span><span class="p">.</span><span class="nx">name</span><span class="p">)));</span><span class="k">break</span><span class="p">;</span></code></pre></div></div><p>Within expressions, when identifiers are found, the <code class="language-plaintext highlighter-rouge">get_local</code> operation is used to retrieve the value:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span><span class="dl">"</span><span class="s2">identifier</span><span class="dl">"</span><span class="p">:</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">get_local</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">unsignedLEB128</span><span class="p">(</span><span class="nx">localIndexForSymbol</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">)));</span><span class="k">break</span><span class="p">;</span></code></pre></div></div><p>Also, the function encoding we saw right back at the beginning is updated to add the locals for the function that the emitter builds. The <em>chasm</em> language has a single variable type, everything is a float.</p><p>Have a go at defining variables and using them within print statements <a href="https://colineberhardt.github.io/chasm/#dmFyIGYgPSAxMApwcmludCAoZiArIDEwKQ%3D%3D">online</a></p><h2 id="while-loops">while loops</h2><p>One of the final language constructs we need in order to achieve the goal of rendering a mandelbrot set is some kind of loop. For <em>chasm</em> I opted for a while loop, as show in this simple program that prints the numbers 0 to 9:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var f = 0
while (f &lt; 10)
  print f
  f = (f + 1)
endwhile
</code></pre></div></div><p>WebAssembly has various control flow instructions (branch, if, else, loop, block). The following WAT show how a while loop can be constructed:</p><pre><code class="language-webassembly">(block
 (loop
   [loop condition]
   i32.eqz
   [nested statements]
   br_if 1
   br 0)
 )
</code></pre><p>Branching within WebAssembly is based on stack depth. The outer <code class="language-plaintext highlighter-rouge">block</code> and <code class="language-plaintext highlighter-rouge">loop</code> instructions push entries onto the control-flow stack. The <code class="language-plaintext highlighter-rouge">br_if 1</code> instruction performs a conditional branch to a stack depth of one, and <code class="language-plaintext highlighter-rouge">br 0</code> an unconditional branch to a depth of zero, repeating the <code class="language-plaintext highlighter-rouge">loop</code>.</p><p>Hereâ€™s how the emitter produces the same in binary format:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span><span class="dl">"</span><span class="s2">whileStatement</span><span class="dl">"</span><span class="p">:</span><span class="c1">// outer block</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">block</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Blocktype</span><span class="p">.</span><span class="k">void</span><span class="p">);</span><span class="c1">// inner loop</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">loop</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Blocktype</span><span class="p">.</span><span class="k">void</span><span class="p">);</span><span class="c1">// compute the while expression</span><span class="nx">emitExpression</span><span class="p">(</span><span class="nx">statement</span><span class="p">.</span><span class="nx">expression</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">i32_eqz</span><span class="p">);</span><span class="c1">// br_if $label0</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">br_if</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">signedLEB128</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="c1">// the nested logic</span><span class="nx">emitStatements</span><span class="p">(</span><span class="nx">statement</span><span class="p">.</span><span class="nx">statements</span><span class="p">);</span><span class="c1">// br $label1</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">br</span><span class="p">);</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">signedLEB128</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="c1">// end loop</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">end</span><span class="p">);</span><span class="c1">// end block</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Opcodes</span><span class="p">.</span><span class="nx">end</span><span class="p">);</span><span class="k">break</span><span class="p">;</span></code></pre></div></div><p>And here it is <a href="https://colineberhardt.github.io/chasm/#dmFyIGYgPSAwCndoaWxlIChmIDwgMTApCiAgcHJpbnQgZgogIGYgPSAoZiArIDEpCmVuZHdoaWxl">running in the online playground</a>.</p><h2 id="graphics">graphics!</h2><p>Weâ€™re nearly there - up to the very last step now! Currently the only way weâ€™ve been able to see output from our <em>chasm</em> programs is via the <code class="language-plaintext highlighter-rouge">print</code> statement, which is wired to the console via a function imported by the WebAssembly module. For the mandelbrot set we somehow need to render graphics to the screen.</p><p>To achieve this weâ€™ll make use of another very important component of WebAssembly modules, linear memory:</p><p><img src="/ceberhardt/assets/wasm-compiler/linear-memory.png"></p><p>As I mentioned previously, WebAssembly only has 4 numeric data types. You might be wondering how languages with richer type systems (string, structs, arrays) can compile to WebAssembly?</p><p>WebAssembly modules can optionally define (or import) a block of linear memory, this is a contiguous block of memory that is shared by the wasm module and its host - in other words both can read and write to this memory. Therefore, if you want to pass a string to your WebAssembly module, you do this by <a href="https://stackoverflow.com/a/47676844/249933">writing it to linear memory</a>.</p><p>For <em>chasm</em> we just want some sort of display, so will use linear memory as a form of <a href="https://en.wikipedia.org/wiki/Video_RAM_(dual-ported_DRAM)">Video RAM</a>.</p><p>The <em>chasm</em> languages supports a simple set-pixel command which takes three expressions, the x location, y location and colour. For example, the following program fill the screen with a horizontal gradient:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var y  = 0
while (y &lt; 100)
  var x  = 0
  while (x &lt; 100)
    setpixel x y (x * 2)
    x = (x + 1)
  endwhile
  y = (y + 1)
endwhile
</code></pre></div></div><p>(Try it <a href="https://colineberhardt.github.io/chasm/#dmFyIHkgID0gMAp3aGlsZSAoeSA8IDEwMCkKICB2YXIgeCAgPSAwCiAgd2hpbGUgKHggPCAxMDApCiAgICBzZXRwaXhlbCB4IHkgKHggKiAyKQogICAgeCA9ICh4ICsgMSkKICBlbmR3aGlsZQogIHkgPSAoeSArIDEpCmVuZHdoaWxlCgogICAg">online</a>)</p><p>The <code class="language-plaintext highlighter-rouge">setpixel</code> command is implemented using the wasm <code class="language-plaintext highlighter-rouge">store</code> instruction that writes to linear memory. On the JavaScript â€˜hostingâ€™ side, this same linear memory is read and copied to a HTML canvas. Iâ€™ll not reproduce the changes to the code here, you can <a href="https://github.com/ColinEberhardt/chasm/commit/cb4c069e3b9ad827a10ced16921cd89176271111">see them on GitHub</a></p><p>And with that - the <em>chasm</em> language is complete, and able to render the mandelbrot set:</p><p><img src="/ceberhardt/assets/wasm-compiler/wasm-mandelbrot.png"></p><p>(Try it <a href="https://colineberhardt.github.io/chasm/">online</a>)</p><h2 id="conclusions">Conclusions</h2><p>I hope you enjoyed this journey and have either learnt a bit more about WebAssembly or how compilers work? For me, this project was a lot of fun - Iâ€™ve never written a compiler before, but have always wanted to.</p><p>As you can probably imagine, Iâ€™ve not stopped there, the temptation was too great to keep going - Iâ€™ve already implemented if / else, and functions / procedures are in the pipeline. Iâ€™d also really like to explore some of the more involved topics like memory management, for example introduce string, arrays and a memory allocator for storage within linear memory.</p><p>All topics for a future post!</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>