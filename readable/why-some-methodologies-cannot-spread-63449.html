<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Why some methodologies cannot spread? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Why some methodologies cannot spread? - linksfor.dev(s)"/>
    <meta property="og:description" content="The conveyor belt for software development"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://kodekonveyor.com/articles/Why%20some%20methodologies%20cannot%20spread"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Why some methodologies cannot spread?</title>
<div class="readable">
        <h1>Why some methodologies cannot spread?</h1>
            <div>Reading time: 8-10 minutes</div>
        <div>Posted here: 26 Jun 2020</div>
        <p><a href="https://kodekonveyor.com/articles/Why%20some%20methodologies%20cannot%20spread">https://kodekonveyor.com/articles/Why%20some%20methodologies%20cannot%20spread</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="content" role="main">
      
<p>You might also have your favourite nich√© methodologies. Mines include Common
Criteria, Test Driven Development and Model Driven Development.</p>
<p>They are all around for quite some time (sometimes decades), and all of them in
the through of disillusionment for quite a while. Yet a couple of professionals
(including me) practice them, and swear that they will change software
development once for all. Clearly someone is false. But who? (spoiler: their
current implementation have a common, rectifiable flaw)</p>
<p>To understand the reality, first we have to identity why those methodologies
cannot spread, and figure out whether the cause is fundamental to them, or just
a detail which no one could get right so far.</p>
<p>So let's analyse each of them from this perspective.</p>
<p><strong>Common Criteria</strong> (CC) is notorious for its detailed and rigid nature. One of the
reasons here is clearly the rigidity: your evaluation result is binary; you
either get it right, or get it wrong. It is against both agile practices and the
risk management approach of modern methodologies. Fortunately it is possible to
use every other part of CC along with the revolutionary (and rarely practiced)
risk management approach of iso27001-2). Iso 27001-2 basically says that
deviations are facts of life (it's also the foundation of agile methodologies),
and you will never have a fully green product: the job is to understand and
manage deviations. So the rigid nature probably can be rectified, but how does
it work out with a methodology meant to be rigid in the first place? The answer
is easier than you might think: the rigidity in the detail level can be kept.
For one small requirement (the kind CC operates with) regarding a single aspect
(like unit) of the code, it is easy to figure out whether it stands, and easy to
fix. The problem lies with the number of those requirement/aspect pairs: they
responsible for the emergent complexity, which - given the human nature that we
sometimes do mistakes - makes sure that the result will have problems.</p>
<p><strong>Test Driven Development</strong> (TDD) is quite another piece of cake: it is easy to do
in the technical level, but there are a lot of (sometimes conflicting) ways to
do it. If you want to do TDD, you have to choose one way to do it. If you have
chosen a way to do it, you still have to take care of a lot of details which
seem like orthogonal to TDD: how you structure your test artifacts, stubs et al,
and your production code. If you want it to get right, you will have a lot of
small rules, not unlike the Common Criteria requirements, and you will have the
same problem.</p>
<p><strong>Model Driven Development</strong> (MDD) is perceived to be more rigid than complex. If
you model something, and it is not right, you have to remodel it. To get things
right along the whole process, you have to get the ways you model (the
metamodel) right in every detail. That means that you have to be able to change
your metamodel quickly to get to the right point. Too bad all of the widespread
modeling tools have a built-in metamodel, so you cannot change them without
changing the code, and sometimes you don't even able to access the code. This is
why a lot of groups had to abandon MDD before they could get it right along the
whole long process of software development. We instead use Zenta, a
metamodel-driven modeling tool, and able to iterate our metamodel fast. Of
course when you model a real software, you will quickly get a lot of complexity.
This complexity can be handled only if you have a lot of small but strict rules
about what you are doing. And again, we are at the same problem what we had with
the other two methodologies.</p>
<p>If you take a look about the emerging complexity about those methodologies, you
will quickly realize that it is not an artifact of the given methodology, but
rather it merely reflects the complexity of software, which in turn reflects the
complexity of real world itself. The reason of rigidity of CC is merely the fact
that you have a lot of details, and you have to get all of them right to achieve
quality.</p>
<p>Therefore we are either find a way to tackle this kind of complexity, or will be
never able to solve the tasks at hand with adequate quality, no matter what
methodologies we use. Honestly, the current state of software development sadly
emphasizes this notion.</p>
<p>And what is the approach to tackle complexities of life? For me, getting there
for my meetings is a challenge, hence I use a calendar to notify me. Even to
figure out what to work on next is beyond me, so I use an issue tracker to track
my tasks. I honestly think that filling in a tax form is for some superheros, so
I ask them - accountants - to do the work with their specialized software. In
summary, I use automated tools and spread the work to people who know about the
given domain (who in turn use their automated tools).</p>
<p>Automated tools help to figure out problems, and rectify them. The faster the
problems are uncovered, the faster you can handle them.In order to leave no room
for mistakes, the detection should use logic which detect problems without false
negatives or positives. We actually use this approach when we code: you modify a
line, and the IDE flags you any problems immediately. Then you can choose
automated solutions, which will rectify the problem maybe in more than 80% of
the time. It is a great leap from the era of punch cards, when you have written
something, and you needed hours or to figure out if something went wrong.</p>
<p>Still we do exactly this with CC, TDD and MDD: we have no automated check for
the majority of the rules. We wait for some humans (the evaluator, the user or
the hacker) to pinpoint problems, and it can take days, weeks, sometimes even
years. When we have to apply hundreds of rules for each units of our codebase,
this will just not work.</p>
<p>You have to use automated tools with very short feedback loops, and be able to
spread the work to get there. This needs a very mature toolchain, which you will
not have when the technology is young. You will need very small and
automatically checkable rules, which you will not have when those who figure out
them have no intimate understanding of the area, or not concentrating on this
goal. To make rules checkable, sometimes you have to structure the work in ways
which either look strange for those already working on the field, introduce
redundancy, or both. Fortunately redundancies can be handled by even more
automated tools. Overcoming social resistance is harder. In our case the
solution was to emphasize that the coding work we do have nothing to do with
programming work programmers are accustomed to, and we gave it another name;
coding.</p>
<p>You might find it silly to introduce redundancies to an already complex process.
Isn't it against the KISS principle? Actually to able to check something, you
need two things to check them against each other. Sometimes you just don't have
both, and you have to create it. TDD in its foundation does just that: it
introduces the tests as the second leg of double-booking the code. Your
opportunity to even start checking have been made possible by exactly this
redundancy. And <em>that</em> enables you to break down your logic to simple and stupid
building blocks. But to do it (in London style at least), you introduce another
redundant element: the stubs. Now <em>that</em> is redundant without additional
advantage. What if you could somehow write the tests and the stubs in the same
time, however? The redundancy would gone, and you could get a free check for
inter-unit consistency. (Our cdd framework does just this).</p>
<p>The moral of the story is that having a great idea for a methodology is not
enough. TDD and MDD are great ideas, but executing them needs much more. You
have to make your homework, and dig out all the details, as the CC guys did. But
it is still just the beginning of the story: you have to structure your rules to
be checkable, you have to make automatic checks for all of them, and make tools
helping to rectify problems with fast feedback loops. When you are there, you
still have to handle the social changes inherent with every new significant
technology. Of course that is a lot of work, and with some methodologies there
was simply no one to realize the situation and work towards a solution which
actually works. Yet.</p>


      
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>