<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How we integrate Rust with C# - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="How we integrate Rust with C# - linksfor.dev(s)"/>
    <meta property="og:description" content="Seq is a log server that&#x27;s built using a few programming languages; we have a storage engine called Flare written in Rust, and a server application written in C#. Our language stack is something I&#x27;ve talked about previously.  Between Rust and C# we have a foreign function interface (FFI) that"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.datalust.co/rust-at-datalust-how-we-integrate-rust-with-csharp/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - How we integrate Rust with C#</title>
<div class="readable">
        <h1>How we integrate Rust with C#</h1>
            <div>Reading time: 32-41 minutes</div>
        <div>Posted here: 04 Jul 2019</div>
        <p><a href="https://blog.datalust.co/rust-at-datalust-how-we-integrate-rust-with-csharp/">https://blog.datalust.co/rust-at-datalust-how-we-integrate-rust-with-csharp/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div role="main">
    <article>

        

        <section>
            <!--kg-card-begin: markdown--><p>Seq is a log server that's built using a few programming languages; we have a storage engine called Flare written in Rust, and a server application written in C#. Our language stack is something <a href="https://blog.getseq.net/rust-at-datalust/">I've talked about previously</a>.</p>
<p>Between Rust and C# we have a foreign function interface (FFI) that lets us call out to Rust code from within the .NET runtime. In this post I'd like to explore our approach to FFI between Seq and its storage engine using the API for reading log events as a reference.</p>
<p>To give you an idea of what the reader API looks like, here's an example of how it can be used in C# to enumerate over all events in the storage engine in order:</p>
<pre><code>IEnumerable<span>&lt;</span><span>(</span>Key<span>,</span> <span>byte</span><span>[</span><span>]</span><span>)</span><span>&gt;</span> <span>ReadAllEvents</span><span>(</span><span>Store</span> store<span>)</span>
<span>{</span>
    <span>var</span> range <span>=</span> <span>new</span> <span>Range</span><span>(</span>Bound<span>.</span>Unbounded<span>,</span> Bound<span>.</span>Unbounded<span>)</span><span>;</span>
    <span>var</span> order <span>=</span> Ordering<span>.</span>Ascending<span>;</span>

    
    
    
    <span>using</span> <span>(</span><span>var</span> reader <span>=</span> store<span>.</span><span>BeginRead</span><span>(</span>range<span>,</span>  ordering<span>)</span><span>)</span>
    <span>{</span>
        
        
        <span>var</span> readInto <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1024</span><span>]</span><span>;</span>

        
        <span>ReadResult</span> read<span>;</span>
        <span>while</span> <span>(</span><span>!</span><span>(</span>read <span>=</span> reader<span>.</span><span>TryReadNext</span><span>(</span>readInto<span>.</span><span>AsSpan</span><span>(</span><span>)</span><span>)</span><span>)</span><span>.</span>IsDone<span>)</span>
        <span>{</span>
            
            <span>if</span> <span>(</span>read<span>.</span><span>IsBufferTooSmall</span><span>(</span><span>out</span> <span>var</span> required<span>)</span><span>)</span>
            <span>{</span>
                readInto <span>=</span> <span>new</span> <span>byte</span><span>[</span>required<span>]</span><span>;</span>
                <span>continue</span><span>;</span>
            <span>}</span>

            
            read<span>.</span><span>GetData</span><span>(</span><span>out</span> <span>var</span> key<span>,</span> <span>out</span> <span>var</span> payload<span>)</span><span>;</span>

            <span>yield</span> <span>return</span> <span>(</span>key<span>,</span> payload<span>.</span><span>ToArray</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>In the above example, the <code>store.BeginRead</code> and <code>reader.TryReadNext</code> methods are implemented in Rust. If any of that Rust code panics or returns an error then we capture them within .NET exceptions like this:</p>
<p><img src="https://blog.datalust.co/content/images/2018/09/flare-error.png" alt="Combining a Rust error and .NET Exception"></p>
<p>The <em>caused by</em> lines are the trace we get from Rust, which tells us that it ran into a data corruption trying to read an event from disk.</p>
<p>The main components of Seq's storage engine FFI that we'll be exploring are:</p>
<ul>
<li>The high-level C# class <code>Reader</code>. In the above example, the call to <code>store.BeginRead</code> returns a <code>Reader</code>.</li>
<li>The handles <code>FlareReaderHandle</code> in Rust and its C# counterpart <code>ReaderHandle</code>. These live a layer below the <code>Reader</code>.</li>
<li>The binding functions. These perform actions on the handles. There are three involved in reading events:
<ul>
<li><code>flare_read_begin</code>: Begin a read transaction, which has a time range to read from and direction to read in.</li>
<li><code>flare_read_next</code>: Read the next event into a caller-supplied buffer.</li>
<li><code>flare_read_end</code>: Finish the read transaction and clean up its resources.</li>
</ul>
</li>
<li>The infrastructure for capturing and surfacing Rust errors and panics as .NET exceptions.</li>
</ul>

<p>Building software in multiple languages allows different components to be implemented in particularly idiomatic ways, but integrating those components can be challenging. The challenge comes from Rust and C# both being safe languages, but only being able to talk to each other by pretending to be unsafe C. That means within the FFI itself we can't just rely on Rust's ownership system or .NET's garbage collector to guarantee referenced data is valid without some extra help. Contracts built up in one language aren't guaranteed to be enforced by the other. Mistakes in this unsafe interface are prime suspects for invoking undefined behavior so we have to design it carefully.</p>
<p>There are other constraints in the FFI in addition to its unsafe nature. We can only share certain kinds of values across the boundary, like primitive numbers, pointers, and simple datastructures. Specifically on the Rust side, we also have to deal with potentially null values, which aren't a feature of safe Rust code.</p>
<p>All things considered though, the surface area of the FFI is small compared to the codebases on either side of it. If we were going to tackle building a storage engine entirely in C# we'd need a liberal sprinkling of <code>unsafe</code> throughout the whole codebase. Having said that, the recent focus on lower-level features in C# 7 is starting to make it feel more idiomatic to write performance-sensitive code in C# without losing all notion of safety. We'll see some of those features at work in the C# side of our FFI later. All in all, we're happy to trade some design challenges in the FFI for access to Rust's safety and performance characteristics and ecosystem within the rest of the storage engine codebase, and to keep our C# app code within Seq itself productive.</p>
<p>With a little background behind us, let's dive straight into some code and look at the way state is managed between Rust and C#.</p>

<p>Rust and C# have different fundamental approaches to managing memory safely. Neither of these are available to us when sharing state between them in the FFI, because Rust doesn't understand C#'s garbage collector and C# doesn't understand Rust's ownership system. So to help us manage shared state safely we wrap raw pointers to its memory in <em>handles</em>. These handles carry additional semantics over the raw pointers to prevent unsafe behaviour at runtime. Each handle has a definition in Rust and a corresponding pair in C#.</p>
<p>Let's look at the Rust side first.</p>
<h2 id="inrust">In Rust</h2>
<p>The handles in Rust are responsible for allocating and deallocating shared FFI state in Rust's heap. The handle for a reader looks like this:</p>
<pre><code>
<span>pub</span> <span>struct</span> FlareReader <span>{</span>
    inner<span>:</span> StoreReader<span>,</span>
<span>}</span>

<span>pub</span> <span>type</span> FlareReaderHandle <span>=</span> HandleOwned<span>&lt;</span>FlareReader<span>&gt;</span><span>;</span>
</code></pre>
<p>Where <code>StoreReader</code> is the more idiomatic Rust type for reading from a Flare store that the handle is wrapping. We'll see it at work later.</p>
<h3 id="safemutablehandleswithhandleowned">Safe mutable handles with <code>HandleOwned</code></h3>
<p>There's not much to see in the <code>FlareReader</code>, because it just wraps <code>StoreReader</code>, and the meat of the <code>FlareReaderHandle</code> itself is in that generic <code>HandleOwned</code> type. So let's look at <code>HandleOwned</code> in more detail. Don't worry too much about the <code>Send</code> and <code>UnwindSafe</code> traits yet, I'll explain what they're all about in a moment. <code>HandleOwned</code> looks like this:</p>
<pre><code>
<span>#[repr(transparent)]</span>
<span>pub</span> <span>struct</span> HandleOwned<span>&lt;</span>T<span>&gt;</span><span>(</span><span>*</span><span>mut</span> ThreadBound<span>&lt;</span>T<span>&gt;</span><span>)</span> <span>where</span> T<span>:</span> ?Sized<span>;</span>

<span>unsafe_impl!</span><span>(</span>
    <span>"The handle is semantically `&amp;mut T`"</span> <span>=&gt;</span>
    <span>impl</span><span>&lt;</span>T<span>&gt;</span> Send <span>for</span> HandleOwned<span>&lt;</span>T<span>&gt;</span>
    <span>where</span>
        T<span>:</span> ?Sized <span>+</span> Send
    <span>{</span>
    <span>}</span>
<span>)</span><span>;</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> UnwindSafe <span>for</span> HandleOwned<span>&lt;</span>T<span>&gt;</span>
<span>where</span>
    T<span>:</span> ?Sized <span>+</span> RefUnwindSafe
<span>{</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> HandleOwned<span>&lt;</span>T<span>&gt;</span>
<span>where</span>
    T<span>:</span> Send <span>+</span> <span>'static</span>
<span>{</span>
    <span>fn</span> <span>alloc</span><span>(</span>value<span>:</span> T<span>)</span> <span>-&gt;</span> Self <span>{</span>
        <span>let</span> v <span>=</span> Box<span>:</span><span>:</span><span>new</span><span>(</span>ThreadBound<span>:</span><span>:</span><span>new</span><span>(</span>value<span>)</span><span>)</span><span>;</span>

        <span>HandleOwned</span><span>(</span>Box<span>:</span><span>:</span><span>into_raw</span><span>(</span>v<span>)</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> HandleOwned<span>&lt;</span>T<span>&gt;</span>
<span>where</span>
    T<span>:</span> ?Sized <span>+</span> Send
<span>{</span>
    <span>unsafe_fn!</span><span>(</span><span>"There are no other live references and the handle won't be used again"</span> <span>=&gt;</span>
        <span>fn</span> dealloc<span>&lt;</span>R<span>&gt;</span><span>(</span>handle<span>:</span> Self<span>,</span> f<span>:</span> <span>impl</span> <span>FnOnce</span><span>(</span><span>&amp;</span><span>mut</span> T<span>)</span> <span>-&gt;</span> R<span>)</span> <span>-&gt;</span> R <span>{</span>
            <span>let</span> <span>mut</span> v <span>=</span> Box<span>:</span><span>:</span><span>from_raw</span><span>(</span>handle<span>.0</span><span>)</span><span>;</span>

            <span>f</span><span>(</span><span>&amp;</span><span>mut</span> <span>*</span><span>*</span>v<span>)</span>
        <span>}</span>
    <span>)</span><span>;</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> Deref <span>for</span> HandleOwned<span>&lt;</span>T<span>&gt;</span>
<span>where</span>
    T<span>:</span> ?Sized
<span>{</span>
    <span>type</span> Target <span>=</span> T<span>;</span>

    <span>fn</span> <span>deref</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span>T <span>{</span>
        <span>unsafe_block!</span><span>(</span><span>"We own the interior value"</span> <span>=&gt;</span> <span>{</span>
            <span>&amp;</span><span>*</span><span>*</span><span>self</span><span>.</span><span>0</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> DerefMut <span>for</span> HandleOwned<span>&lt;</span>T<span>&gt;</span>
<span>where</span>
    T<span>:</span> ?Sized
<span>{</span>
    <span>fn</span> <span>deref_mut</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>mut</span> T <span>{</span>
        <span>unsafe_block!</span><span>(</span><span>"We own the interior value"</span> <span>=&gt;</span> <span>{</span>
            <span>&amp;</span><span>mut</span> <span>*</span><span>*</span><span>self</span><span>.</span><span>0</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p><code>HandleOwned</code> is an opaque wrapper over a <code>*mut T</code>, which is a raw pointer. <code>HandleOwned</code> is solely responsible for allocating, deallocating, and dereferencing the memory behind that pointer. It's not accessed in C#. We try to communicate the handle's safety contract using a few standard Rust traits. This contract is actually lost across the FFI boundary so we need a few safety nets at runtime to catch ourselves if we violate it. It's still worth having the traits appropriately implemented though even if they alone can't force the foreign C# code to use the handle correctly. Their presence serves as documentation for the way we expect the handles to be used. Let's look at these traits in some more detail now.</p>
<h3 id="maintainingthreadsafety">Maintaining thread safety</h3>
<p>Thread safety is a property of mutli-threaded code that only accesses shared state in a synchronized way that's free from potential data races (there are actually some additional requirements around dangling pointers that we'll deal with later).</p>
<p>Rust has a pair of traits for communicating thread safety; <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a> and <a href="https://doc.rust-lang.org/stable/std/marker/trait.Sync.html"><code>Sync</code></a>. Together, they form a framework for concurrency that allows Rust code to share state when it's safe, but prevent it when it's not. The <code>Send</code> trait tells us whether a value can safely be sent to different threads. The <code>Sync</code> trait tells us whether a value can safely be accessed from different threads.</p>
<p>The difference between <code>Send</code> and <code>Sync</code> can be a bit subtle. I think a helpful example of how they work together comes from an impl block in the standard library that looks a little like this:</p>
<pre><code><span>impl</span><span>&lt;</span><span>'a,</span> T<span>&gt;</span> Send <span>for</span> <span>&amp;</span><span>'a</span> T <span>where</span> T<span>:</span> Sync <span>{</span> <span>}</span>
</code></pre>
<p>It tells us that a borrowed reference, <code>&amp;'a T</code>, is safe to send across threads if the data it references, <code>T</code>, is safe to access from different threads.</p>
<p>Rust will automatically try and implement <code>Send</code> and <code>Sync</code> for a type, so long as its contents are <code>Send</code> and <code>Sync</code>. This is usually achieved through standard library abstractions like <code>Arc</code> for thread-safe reference counting, and <code>Mutex</code> for thread-safe mutability.</p>
<p>For <code>HandleOwned</code>, we simply don't want multiple threads to get a hold of the handle because we treat it like a mutable reference, and in Rust having multiple live mutable references to the same data is not allowed. There are a few complications though, <code>Send</code> and <code>Sync</code> are compile-time contracts that only Rust understands. There's nothing stopping a foreign caller from copying a <code>HandleOwned</code> into multiple threads and attempting to access the contents concurrently. As a safety net, <code>HandleOwned</code> wraps its contents in a <code>ThreadBound</code> type when allocating it. <code>ThreadBound</code> is similar to the <a href="https://docs.rs/fragile"><code>fragile::Fragile</code></a> type in the ecosystem in that it panics if it's dereferenced from a different thread than the one it was created on. This check effectively also enforces <code>!Sync</code> at runtime by catching cases where the handle has been passed to a different thread.</p>
<p>There's an important exception to binding <code>HandleOwned</code> to its initial thread though; in .NET resources aren't guaranteed to be reclaimed from the same thread that allocated them. That means we need to be able to logically <code>Send</code> the <code>HandleOwned</code> to another thread so the GC can finalize it. So our <code>HandleOwned</code> implements the <code>Send</code> trait so long as its contents do. That way it's safe to deallocate it from a finalization thread.</p>
<h3 id="maintainingunwindsafety">Maintaining unwind safety</h3>
<p>Unwind safety in Rust is like exception safety in C#. It's a property of code that guarantees that broken invariants aren't observable if a function panics and breaks normal control flow.</p>
<p>Rust has a pair of traits (Rust seems to have a lot of systems that are built up from a pair of traits) for communicating unwind safety; <a href="https://doc.rust-lang.org/stable/std/panic/trait.UnwindSafe.html"><code>UnwindSafe</code></a> and <a href="https://doc.rust-lang.org/stable/std/panic/trait.RefUnwindSafe.html"><code>RefUnwindSafe</code></a>. The <code>UnwindSafe</code> trait tells us whether an owned value is unwind safe. The <code>RefUnwindSafe</code> trait tells us whether a borrowed reference to a value is unwind safe.</p>
<p>To demonstrate the difference between <code>UnwindSafe</code> and <code>RefUnwindSafe</code>, let's turn to some more impl blocks in the standard library:</p>
<pre><code><span>impl</span><span>&lt;</span><span>'a,</span> T<span>&gt;</span> UnwindSafe <span>for</span> <span>&amp;</span><span>'a</span> T <span>where</span> T<span>:</span> RefUnwindSafe <span>{</span> <span>}</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> UnwindSafe <span>for</span> Rc<span>&lt;</span>T<span>&gt;</span> <span>where</span> T<span>:</span> RefUnwindSafe <span>{</span> <span>}</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> UnwindSafe <span>for</span> Arc<span>&lt;</span>T<span>&gt;</span> <span>where</span> T<span>:</span> RefUnwindSafe <span>{</span> <span>}</span>
</code></pre>
<p>These blocks tell us that some reference to a type, <code>T</code>, is unwind safe if <code>T</code> is unwind safe while it's borrowed. <code>RefUnwindSafe</code> lets us be abstract over the kind of reference to <code>T</code> that we're dealing when, whether it's <code>&amp;'a T</code>, <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>, or in our case, <code>HandleOwned&lt;T&gt;</code>.</p>
<p>Rust considers everything unwind safe by default unless it can be mutated:</p>
<pre><code><span>impl</span><span>&lt;</span><span>'a,</span> T<span>&gt;</span> <span>!</span>UnwindSafe <span>for</span> <span>&amp;</span><span>'a</span> <span>mut</span> T <span>{</span> <span>}</span>
</code></pre>
<p>Some types guarantee unwind safety by poisoning their state on a panic. The standard library's <code>Mutex</code> works this way. After being poisoned that state is no longer accessible. It's a broadly applicable technique for guaranteeing unwind safety regardless of how the state itself is mutated. Many types in the storage engine use poisoning to guarantee unwind safety in case something unexpected happens, like a write to disk fails.</p>
<h3 id="ensuringreferencesremainvalid">Ensuring references remain valid</h3>
<p>Rust uses a type system to try and prove a program only accesses its memory in valid ways. These types are called lifetimes (they're the little <code>'a</code> sigils in the <code>&amp;'a T</code>). When defining FFI handles in Rust we need to be careful with these lifetimes because, following the theme of <code>Send</code> and <code>Sync</code>, they're a compile-time contract with other Rust code. C# doesn't understand this contract so for data that's shared across the FFI boundary we can't just depend on lifetimes to ensure references to other pieces of state remain valid. Instead we depend on runtime reference counting using <code>Rc&lt;T&gt;</code> or <code>Arc&lt;T&gt;</code>. That's why <code>HandleOwned</code> has a <code>'static</code> requirement in its definition. <code>'static</code> is a special lifetime for data that <em>can</em> live for as long as the program itself. That means if <code>T: 'static</code>, then <code>T</code> is probably an owned value or a reference to static data compiled into the program itself. <code>HandleOwned</code> will only accept data that can live until we're ready to deallocate it.</p>
<p>Right now, handles are just wrappers over a raw pointer. This means there's nothing <em>technically</em> stopping a foreign caller from re-using that handle after it's been freed. At some point in the future we could turn those raw pointers into entries in some global handle table. That table could then detect attempts to access a handle that's already been freed.</p>
<h3 id="safeconcurrenthandleswithhandleshared">Safe concurrent handles with <code>HandleShared</code></h3>
<p>Having <code>HandleOwned</code> bound to a single thread makes it possible for us to ensure there's only a single live mutable reference to its state. That means thread-safety is achieved by simply forbidding multiple threads from using the handle. That's nice, but a bit limiting for potentially long-lived handles so we have a complement to <code>HandleOwned</code> called <code>HandleShared</code> that's safe for concurrent access, so long as its contents are. It looks like this:</p>
<pre><code>
<span>#[repr(transparent)]</span>
<span>pub</span> <span>struct</span> HandleShared<span>&lt;</span>T<span>:</span> ?Sized<span>&gt;</span><span>(</span><span>*</span><span>const</span> T<span>)</span><span>;</span>

<span>unsafe_impl!</span><span>(</span>
    <span>"The handle is semantically `&amp;T`"</span> <span>=&gt;</span>
    <span>impl</span><span>&lt;</span>T<span>&gt;</span> Send <span>for</span> HandleShared<span>&lt;</span>T<span>&gt;</span>
        <span>where</span> T<span>:</span> ?Sized <span>+</span> Sync
    <span>{</span>
    <span>}</span>
<span>)</span><span>;</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> UnwindSafe <span>for</span> HandleShared<span>&lt;</span>T<span>&gt;</span>
<span>where</span>
    T<span>:</span> ?Sized <span>+</span> RefUnwindSafe
<span>{</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> HandleShared<span>&lt;</span>T<span>&gt;</span>
<span>where</span>
    T<span>:</span> Send <span>+</span> Sync <span>+</span> <span>'static</span>
<span>{</span>
    <span>fn</span> <span>alloc</span><span>(</span>value<span>:</span> T<span>)</span> <span>-&gt;</span> Self <span>{</span>
        <span>let</span> v <span>=</span> Box<span>:</span><span>:</span><span>new</span><span>(</span>value<span>)</span><span>;</span>

        <span>HandleShared</span><span>(</span>Box<span>:</span><span>:</span><span>into_raw</span><span>(</span>v<span>)</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> HandleShared<span>&lt;</span>T<span>&gt;</span>
<span>where</span>
    T<span>:</span> ?Sized <span>+</span> Send <span>+</span> Sync
<span>{</span>
    <span>unsafe_fn!</span><span>(</span>
        <span>"There are no other live references and the handle won't be used again"</span> <span>=&gt;</span>
        <span>fn</span> dealloc<span>&lt;</span>R<span>&gt;</span><span>(</span>handle<span>:</span> Self<span>,</span> f<span>:</span> <span>impl</span> <span>FnOnce</span><span>(</span><span>&amp;</span><span>mut</span> T<span>)</span> <span>-&gt;</span> R<span>)</span> <span>-&gt;</span> R <span>{</span>
            <span>let</span> <span>mut</span> v <span>=</span> Box<span>:</span><span>:</span><span>from_raw</span><span>(</span>handle<span>.0</span> <span>as</span> <span>*</span><span>mut</span> T<span>)</span><span>;</span>

            <span>f</span><span>(</span><span>&amp;</span><span>mut</span> <span>*</span>v<span>)</span>
        <span>}</span>
    <span>)</span><span>;</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>&gt;</span> Deref <span>for</span> HandleShared<span>&lt;</span>T<span>&gt;</span>
<span>where</span>
    T<span>:</span> ?Sized
<span>{</span>
    <span>type</span> Target <span>=</span> T<span>;</span>

    <span>fn</span> <span>deref</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span>T <span>{</span>
        <span>unsafe_block!</span><span>(</span><span>"We own the interior value"</span> <span>=&gt;</span> <span>{</span>
            <span>&amp;</span><span>*</span><span>self</span><span>.</span><span>0</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>An example of a <code>HandleShared</code> is <code>StoreHandle</code>, which holds most of the state for an instance of the storage engine and is safe for concurrent access:</p>
<pre><code>
<span>pub</span> <span>struct</span> FlareStore <span>{</span>
    inner<span>:</span> Store<span>,</span>
<span>}</span>

<span>pub</span> <span>type</span> FlareStoreHandle <span>=</span> HandleShared<span>&lt;</span>FlareStore<span>&gt;</span><span>;</span>
</code></pre>
<p>The <code>StoreReader</code> type we saw before borrows a lot of state from the <code>Store</code>.</p>
<h2 id="inc">In C#</h2>
<p>Memory in C# is managed by a garbage collector in the .NET runtime. It takes care of keeping objects alive for as long as their accessible, and reclaiming their memory when they’re not. Rust doesn't know about the .NET garbage collector though, so from .NET's point of view Rust is unmanaged code. There are a lot of subtle design challenges that can lead to nasty memory safety issues when integrating managed and unmanaged code. Fortunately though, this is all very well-trodden territory and we have plenty of tools at our disposal in .NET to manage the complexity of building safe, managed APIs to unmanaged resources. We'll see some of these tools in action shortly.</p>
<p>Let's start by looking at the <code>Reader</code> class, which is the high-level C# API for reading events from the Rust storage engine. It looks like this:</p>
<pre><code><span>public</span> <span>sealed</span> <span>class</span> <span>Reader</span> <span>:</span> <span>IDisposable</span>
<span>{</span>
    <span>readonly</span> <span>ReaderHandle</span> _handle<span>;</span>
    
    <span>internal</span> <span>Reader</span><span>(</span><span>ReaderHandle</span> handle<span>)</span>
    <span>{</span>
        _handle <span>=</span> handle<span>;</span>
    <span>}</span>

    <span>public</span> <span>ReadResult</span> <span>TryReadNext</span><span>(</span>Span<span>&lt;</span><span>byte</span><span>&gt;</span> buffer<span>)</span>
    <span>{</span>
        <span>EnsureOpen</span><span>(</span><span>)</span><span>;</span>
        
        <span>unsafe</span>
        <span>{</span>
            <span>fixed</span> <span>(</span><span>byte</span><span>*</span> bufferPtr <span>=</span> buffer<span>)</span>
            <span>{</span>
                <span>var</span> result <span>=</span> Bindings<span>.</span><span>flare_read_next</span><span>(</span>
                    _handle<span>,</span>
                    <span>out</span> <span>var</span> key<span>,</span>
                    <span>(</span>IntPtr<span>)</span>bufferPtr<span>,</span>
                    <span>(</span>UIntPtr<span>)</span>buffer<span>.</span>Length<span>,</span>
                    <span>out</span> <span>var</span> actualValueLength<span>)</span><span>;</span>
                    
                <span>if</span> <span>(</span>result<span>.</span><span>IsBufferTooSmall</span><span>(</span><span>)</span><span>)</span>
                <span>{</span>
                    <span>return</span> ReadResult<span>.</span><span>BufferTooSmall</span><span>(</span><span>(</span><span>int</span><span>)</span>actualValueLength<span>)</span><span>;</span>
                <span>}</span>
                
                <span>if</span> <span>(</span>result<span>.</span><span>IsDone</span><span>(</span><span>)</span><span>)</span>
                <span>{</span>
                    <span>return</span> ReadResult<span>.</span><span>Done</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                
                result<span>.</span><span>EnsureSuccess</span><span>(</span><span>)</span><span>;</span>
                <span>return</span> ReadResult<span>.</span><span>Data</span><span>(</span>key<span>,</span> buffer<span>.</span><span>Slice</span><span>(</span><span>0</span><span>,</span> <span>(</span><span>int</span><span>)</span>actualValueLength<span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>Dispose</span><span>(</span><span>)</span>
    <span>{</span>
        _handle<span>.</span><span>Close</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>void</span> <span>EnsureOpen</span><span>(</span><span>)</span>
    <span>{</span>
        
        
        <span>if</span> <span>(</span>_handle<span>.</span>IsClosed<span>)</span>
            <span>throw</span> <span>new</span> <span>ObjectDisposedException</span><span>(</span>
                <span>nameof</span><span>(</span>Reader<span>)</span><span>,</span>
                <span>"The reader has been disposed."</span>
            <span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>The call to <code>Bindings.flare_read_next</code> is executing Rust code on the <code>FlareReaderHandle</code> we saw earlier. We'll look at the exact definition of <code>flare_read_next</code> a bit later.</p>
<h3 id="safearbitrarymemorywithoutallocating">Safe arbitrary memory, without allocating</h3>
<p>The <code>Reader.TryReadNext</code> method returns a type called <code>ReadResult</code> that carries the result of reading the event into a buffer, along with the event's byte payload. <code>ReadResult</code> is a <code>ref struct</code>, which is a new C# 7 feature to guarantee instances can never be boxed on the heap. That means a <code>ref struct</code> has a well-defined lifetime that's tied to a specific stack frame. This is what it looks like:</p>
<pre><code><span>public</span> <span>ref</span> <span>struct</span> ReadResult
<span>{</span>
    <span>Key</span> _key<span>;</span>
    Span<span>&lt;</span><span>byte</span><span>&gt;</span> _value<span>;</span>
    <span>int</span> _requiredLength<span>;</span>
    <span>Result</span> _result<span>;</span>

    <span>enum</span> Result
    <span>{</span>
        Ok<span>,</span>
        Done<span>,</span>
        BufferTooSmall
    <span>}</span>

    <span>internal</span> <span>static</span> <span>ReadResult</span> <span>Data</span><span>(</span><span>Key</span> key<span>,</span> Span<span>&lt;</span><span>byte</span><span>&gt;</span> <span>value</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>new</span> <span>ReadResult</span>
        <span>{</span>
            _key <span>=</span> key<span>,</span>
            _value <span>=</span> <span>value</span><span>,</span>
            _result <span>=</span> Result<span>.</span>Ok
        <span>}</span><span>;</span>
    <span>}</span>

    <span>internal</span> <span>static</span> <span>ReadResult</span> <span>Done</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>new</span> <span>ReadResult</span>
        <span>{</span>
            _result <span>=</span> Result<span>.</span>Done
        <span>}</span><span>;</span>
    <span>}</span>

    <span>internal</span> <span>static</span> <span>ReadResult</span> <span>BufferTooSmall</span><span>(</span><span>int</span> requiredLength<span>)</span>
    <span>{</span>
        <span>return</span> <span>new</span> <span>ReadResult</span>
        <span>{</span>
            _requiredLength <span>=</span> requiredLength<span>,</span>
            _result <span>=</span> Result<span>.</span>BufferTooSmall
        <span>}</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>bool</span> <span>IsBufferTooSmall</span><span>(</span><span>out</span> <span>int</span> required<span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span>_result <span>!=</span> Result<span>.</span>BufferTooSmall<span>)</span>
        <span>{</span>
            required <span>=</span> <span>0</span><span>;</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>}</span>
        
        required <span>=</span> _requiredLength<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>bool</span> IsDone <span>=</span><span>&gt;</span> _result <span>==</span> Result<span>.</span>Done<span>;</span>

    <span>public</span> <span>bool</span> HasValue <span>=</span><span>&gt;</span> _result <span>==</span> Result<span>.</span>Ok<span>;</span>

    <span>public</span> <span>void</span> <span>GetData</span><span>(</span><span>out</span> <span>Key</span> key<span>,</span> <span>out</span> Span<span>&lt;</span><span>byte</span><span>&gt;</span> <span>value</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>!</span>HasValue<span>)</span>
            <span>throw</span> <span>new</span> <span>InvalidOperationException</span><span>(</span>$<span>"`{nameof(ReadResult)}` has no data."</span><span>)</span><span>;</span>

        key <span>=</span> _key<span>;</span>
        <span>value</span> <span>=</span> _value<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>The payload field is a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1?view=netcore-2.1"><code>Span&lt;byte&gt;</code></a> which itself is a <code>ref struct</code> that acts like a potentially GC-aware pointer to arbitrary memory.</p>
<p>The effort so far in C# 7 to improve the semantics and safety of working with arbitrary memory, and for working with value types in general, makes the .NET side of the FFI easier to build safely with very little overhead.</p>
<h3 id="managingunmanagedresourceswithsafehandle">Managing unmanaged resources with <code>SafeHandle</code></h3>
<p>In the Rust FFI handles, we have a fundamental <code>HandleOwned</code> type that encapsulates the memory safety requirements that the consuming Rust code expects to be maintained. We have a similarly fundamental handle type behind <code>Reader</code> in C# called <code>ReaderHandle</code>. It looks like this:</p>
<pre><code><span>class</span> <span>ReaderHandle</span> <span>:</span> <span>SafeHandle</span>
<span>{</span>
    <span>public</span> <span>ReaderHandle</span><span>(</span><span>)</span>
        <span>:</span> <span>base</span><span>(</span>IntPtr<span>.</span>Zero<span>,</span> <span>true</span><span>)</span>
    <span>{</span>
    <span>}</span>
    
    <span>[</span><span>ReliabilityContract</span><span>(</span>Consistency<span>.</span>WillNotCorruptState<span>,</span> Cer<span>.</span>MayFail<span>)</span><span>]</span>
    <span>protected</span> <span>override</span> <span>bool</span> <span>ReleaseHandle</span><span>(</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span>handle <span>==</span> IntPtr<span>.</span>Zero<span>)</span> <span>return</span> <span>true</span><span>;</span>
        
        <span>var</span> h <span>=</span> handle<span>;</span>
        handle <span>=</span> IntPtr<span>.</span>Zero<span>;</span>
        
        <span>return</span> Bindings<span>.</span><span>flare_read_end</span><span>(</span>h<span>)</span><span>.</span><span>IsSuccess</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>override</span> <span>bool</span> IsInvalid <span>=</span><span>&gt;</span> handle <span>==</span> IntPtr<span>.</span>Zero<span>;</span>
<span>}</span>
</code></pre>
<p><code>ReaderHandle</code> is a class that is responsible for integrating with the .NET garbage collector by inheriting from the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle?view=netcore-2.1"><code>SafeHandle</code></a> class. <code>SafeHandle</code> takes care of a lot of the subtlety of acquiring and releasing unmanaged resources safely. It wraps a raw pointer and ensures the contents of the <code>ReleaseHandle</code> method will get called in a constrained execution region during finalization if the handle isn't released sooner. That means that one way or another, when the handle is no longer accessible the unmanaged resources it wraps will have a chance to get reclaimed.</p>

<p>When making FFI calls, we want to be able to capture normal errors in Rust and make them available to the foreign caller. In Seq, we also want to catch any potential panics from the storage engine (even though we don’t expect them under normal operation) so we have a chance to log them before either shutting down or attempting to recover. FFI error management is provided by the <code>FlareResult</code> type, which has both a Rust and a C# implementation.</p>
<h2 id="inrust">In Rust</h2>
<p><code>FlareResult</code> is an enum for returning a simple status code across an FFI boundary that follows a <a href="https://michael-f-bryan.github.io/rust-ffi-guide/errors/return_types.html#return-types">standard pattern</a> for making more detailed error information available to the foreign caller.</p>
<p><code>FlareResult</code> looks something like this:</p>
<pre><code>
<span>thread_local!</span> <span>{</span>
    <span>static</span> LAST_RESULT<span>:</span> RefCell<span>&lt;</span>Option<span>&lt;</span>LastResult<span>&gt;&gt;</span> <span>=</span> RefCell<span>:</span><span>:</span><span>new</span><span>(</span>None<span>)</span><span>;</span>
<span>}</span>

<span>struct</span> LastResult <span>{</span>
    value<span>:</span> FlareResult<span>,</span>
    err<span>:</span> Option<span>&lt;</span>String<span>&gt;</span><span>,</span>
<span>}</span>


<span>#[repr(u32)]</span>
<span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
<span>enum</span> FlareResult <span>{</span>
    Ok<span>,</span>
    Done<span>,</span>
    BufferTooSmall<span>,</span>
    ArgumentNull<span>,</span>
    InternalError<span>,</span>
    <span>..</span>
<span>}</span>

<span>impl</span> FlareResult <span>{</span>
    
    <span>fn</span> <span>as_err</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> Option<span>&lt;</span><span>&amp;</span><span>'static</span> str<span>&gt;</span> <span>{</span>
        <span>match</span> <span>*</span><span>self</span> <span>{</span>
            FlareResult<span>:</span><span>:</span>Ok <span>|</span> FlareResult<span>:</span><span>:</span>Done <span>=&gt;</span> None<span>,</span>
            FlareResult<span>:</span><span>:</span>ArgumentNull <span>=&gt;</span> <span>Some</span><span>(</span><span>"a required argument was null"</span><span>)</span><span>,</span>
            FlareResult<span>:</span><span>:</span>BufferTooSmall <span>=&gt;</span> <span>Some</span><span>(</span><span>"a supplied buffer was too small"</span><span>)</span><span>,</span>
            FlareResult<span>:</span><span>:</span>InternalError <span>=&gt;</span> <span>Some</span><span>(</span><span>"an internal error occurred"</span><span>)</span><span>,</span>
            <span>..</span>
        <span>}</span>
    <span>}</span>

    
    <span>pub</span><span>(</span><span>super</span><span>)</span> <span>fn</span> <span>catch</span><span>(</span>f<span>:</span> <span>impl</span> <span>FnOnce</span><span>(</span><span>)</span> <span>-&gt;</span> Self <span>+</span> UnwindSafe<span>)</span> <span>-&gt;</span> Self <span>{</span>
        LAST_RESULT<span>.</span><span>with</span><span>(</span><span><span>|</span>last_result<span>|</span></span> <span>{</span>
            <span>{</span>
                <span>*</span>last_result<span>.</span><span>borrow_mut</span><span>(</span><span>)</span> <span>=</span> None<span>;</span>
            <span>}</span>
            
            <span>match</span> <span>catch_unwind</span><span>(</span>f<span>)</span> <span>{</span>
                <span>Ok</span><span>(</span>flare_result<span>)</span> <span>=&gt;</span> <span>{</span>
                    <span>let</span> extract_err <span>=</span> <span>||</span> flare_result<span>.</span><span>as_err</span><span>(</span><span>)</span><span>.</span><span>map</span><span>(</span>Into<span>:</span><span>:</span>into<span>)</span><span>;</span>
                    
                    
                    
                    
                    last_result
                        <span>.</span><span>borrow_mut</span><span>(</span><span>)</span>
                        <span>.</span><span>map_mut</span><span>(</span><span><span>|</span>last_result<span>|</span></span> <span>{</span>
                            last_result<span>.</span>value <span>=</span> flare_result<span>;</span>
                            last_result<span>.</span>err<span>.</span><span>or_else_mut</span><span>(</span>extract_err<span>)</span><span>;</span>
                        <span>}</span><span>)</span>
                        <span>.</span><span>get_or_insert_with</span><span>(</span><span>||</span> LastResult <span>{</span>
                            value<span>:</span> flare_result<span>,</span>
                            err<span>:</span> <span>extract_err</span><span>(</span><span>)</span><span>,</span>
                        <span>}</span><span>)</span>
                        <span>.</span>value
                <span>}</span>
                <span>Err</span><span>(</span>e<span>)</span> <span>=&gt;</span> <span>{</span>
                    <span>let</span> extract_panic <span>=</span>
                        <span>||</span> error<span>:</span><span>:</span><span>extract_panic</span><span>(</span><span>&amp;</span>e<span>)</span>
                               <span>.</span><span>map</span><span>(</span><span>|</span>s<span>|</span> <span>format!</span><span>(</span><span>"internal panic with '{}'"</span><span>,</span> s<span>)</span><span>)</span><span>;</span>
                        
                    
                    last_result
                        <span>.</span><span>borrow_mut</span><span>(</span><span>)</span>
                        <span>.</span><span>map_mut</span><span>(</span><span><span>|</span>last_result<span>|</span></span> <span>{</span>
                            last_result<span>.</span>err<span>.</span><span>or_else_mut</span><span>(</span>extract_panic<span>)</span><span>;</span>
                        <span>}</span><span>)</span>
                        <span>.</span><span>get_or_insert_with</span><span>(</span><span>||</span> LastResult <span>{</span>
                            value<span>:</span> FlareResult<span>:</span><span>:</span>InternalError<span>,</span>
                            err<span>:</span> <span>extract_panic</span><span>(</span><span>)</span><span>,</span>
                        <span>}</span><span>)</span>
                        <span>.</span>value
                <span>}</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span>
    
    
    <span>fn</span> with_last_result<span>&lt;</span>R<span>&gt;</span><span>(</span>f<span>:</span> <span>impl</span> <span>Fn</span><span>(</span>Option<span>&lt;</span><span>(</span>FlareResult<span>,</span> Option<span>&lt;</span><span>&amp;</span>str<span>&gt;</span><span>)</span><span>&gt;</span><span>)</span> <span>-&gt;</span> R<span>)</span> <span>-&gt;</span> R <span>{</span>
        LAST_RESULT<span>.</span><span>with</span><span>(</span><span><span>|</span>last_result<span>|</span></span> <span>{</span>
            <span>let</span> last_result <span>=</span> last_result<span>.</span><span>borrow</span><span>(</span><span>)</span><span>;</span>
            <span>let</span> last_result <span>=</span> last_result<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span><span>map</span><span>(</span><span><span>|</span>last_result<span>|</span></span> <span>{</span>
                <span>let</span> msg <span>=</span> last_result<span>.</span>err<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>.</span><span>map</span><span>(</span><span>|</span>msg<span>|</span> msg<span>.</span><span>as_ref</span><span>(</span><span>)</span><span>)</span><span>;</span>
                <span>(</span>last_result<span>.</span>value<span>,</span> msg<span>)</span>
            <span>}</span><span>)</span><span>;</span>
            
            <span>f</span><span>(</span>last_result<span>)</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>The <code>map_mut</code> and <code>or_else_mut</code> methods are defined in an extension trait on <code>Option</code> that I introduced <a href="https://blog.getseq.net/rust-at-datalust-how-we-organize-a-complex-rust-codebase/#findingahomeforcrosscuttingconcerns">in a previous post</a>.</p>
<p><code>FlareResult</code> also implements the <code>Try</code> trait so FFI functions can use the <code>?</code> operator to early return errors:</p>
<pre><code>
<span>impl</span><span>&lt;</span>E<span>&gt;</span> From<span>&lt;</span>E<span>&gt;</span> <span>for</span> FlareResult
<span>where</span>
    E<span>:</span> Into<span>&lt;</span>error<span>:</span><span>:</span>FlareError<span>&gt;</span> <span>+</span> Fail<span>,</span>
<span>{</span>
    <span>fn</span> <span>from</span><span>(</span>e<span>:</span> E<span>)</span> <span>-&gt;</span> Self <span>{</span>
        
        
        <span>let</span> err <span>=</span> <span>Some</span><span>(</span>error<span>:</span><span>:</span><span>format</span><span>(</span><span>&amp;</span>e<span>)</span><span>)</span><span>;</span>
        
        
        
        <span>let</span> flare_result <span>=</span> e<span>.</span><span>into</span><span>(</span><span>)</span><span>.</span><span>into_flare_result</span><span>(</span><span>)</span><span>;</span>
        
        LAST_RESULT<span>.</span><span>with</span><span>(</span><span><span>|</span>last_result<span>|</span></span> <span>{</span>
            <span>*</span>last_result<span>.</span><span>borrow_mut</span><span>(</span><span>)</span> <span>=</span> <span>Some</span><span>(</span>LastResult <span>{</span>
                value<span>:</span> flare_result<span>,</span>
                err<span>,</span>
            <span>}</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
        
        flare_result
    <span>}</span>
<span>}</span>


<span>impl</span> Try <span>for</span> FlareResult <span>{</span>
    <span>type</span> Ok <span>=</span> Self<span>;</span>
    <span>type</span> Error <span>=</span> Self<span>;</span>
    
    <span>fn</span> <span>into_result</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> Result<span>&lt;</span>Self<span>:</span><span>:</span>Ok<span>,</span> Self<span>:</span><span>:</span>Error<span>&gt;</span> <span>{</span>
        <span>match</span> <span>self</span> <span>{</span>
            FlareResult<span>:</span><span>:</span>Ok <span>|</span> FlareResult<span>:</span><span>:</span>Done <span>=&gt;</span> <span>Ok</span><span>(</span><span>self</span><span>)</span><span>,</span>
            _ <span>=&gt;</span> <span>Err</span><span>(</span><span>self</span><span>)</span><span>,</span>
        <span>}</span>
    <span>}</span>
    
    <span>fn</span> <span>from_error</span><span>(</span>result<span>:</span> Self<span>:</span><span>:</span>Error<span>)</span> <span>-&gt;</span> Self <span>{</span>
        <span>if</span> result<span>.</span><span>as_err</span><span>(</span><span>)</span><span>.</span><span>is_none</span><span>(</span><span>)</span> <span>{</span>
            <span>panic!</span><span>(</span><span>format!</span><span>(</span>
                <span>"attempted to return success code `{:?}` as an error"</span><span>,</span>
                result
            <span>)</span><span>)</span><span>;</span>
        <span>}</span>
        result
    <span>}</span>
    
    <span>fn</span> <span>from_ok</span><span>(</span>result<span>:</span> Self<span>:</span><span>:</span>Ok<span>)</span> <span>-&gt;</span> Self <span>{</span>
        <span>if</span> result<span>.</span><span>as_err</span><span>(</span><span>)</span><span>.</span><span>is_some</span><span>(</span><span>)</span> <span>{</span>
            <span>panic!</span><span>(</span><span>format!</span><span>(</span>
                <span>"attempted to return error code `{:?}` as success"</span><span>,</span>
                result
            <span>)</span><span>)</span><span>;</span>
        <span>}</span>
        result
    <span>}</span>
<span>}</span>
</code></pre>
<p><code>FlareResult</code> makes it much nicer to write FFI functions more idiomatically and have error information captured or consumers across the boundary.</p>
<h2 id="inc">In C#</h2>
<p>The C# implementation of <code>FlareResult</code> wraps the error codes internally and exposes a higher-level API that we can use to determine how to proceed after making an FFI call. It looks like this:</p>
<pre><code><span>[</span><span>StructLayout</span><span>(</span>LayoutKind<span>.</span>Sequential<span>)</span><span>]</span>
<span>public</span> <span>struct</span> FlareResult
<span>{</span>
    <span>enum</span> FlareResultValue <span>:</span> <span>uint</span>
    <span>{</span>
        Ok<span>,</span>
        Done<span>,</span>
        BufferTooSmall<span>,</span>
        ArgumentNull<span>,</span>
        InternalError<span>,</span>
        <span>.</span><span>.</span>
    <span>}</span>
    
    <span>readonly</span> <span>FlareResultValue</span> _result<span>;</span>
    
    <span>public</span> <span>static</span> <span>(</span>FlareResult<span>,</span> <span>string</span><span>)</span> <span>GetLastResult</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> LastResult<span>.</span><span>GetLastResult</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    
    
    
    <span>public</span> <span>void</span> <span>EnsureSuccess</span><span>(</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>IsSuccess</span><span>(</span><span>)</span><span>)</span> <span>return</span><span>;</span>
        
        <span>var</span> <span>(</span>lastResult<span>,</span> msg<span>)</span> <span>=</span> <span>GetLastResult</span><span>(</span><span>)</span><span>;</span>
        
        
        
        <span>if</span> <span>(</span>lastResult<span>.</span>_result <span>==</span> _result<span>)</span>
        <span>{</span>
            <span>throw</span> <span>new</span> <span>Exception</span><span>(</span>$<span>"Flare failed with {_result}: {msg?.TrimEnd()}"</span><span>)</span><span>;</span>
        <span>}</span>
        
        <span>throw</span> <span>new</span> <span>Exception</span><span>(</span>$<span>"Flare failed with {_result}"</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>bool</span> <span>IsSuccess</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> _result <span>==</span> FlareResultValue<span>.</span>Ok <span>||</span> _result <span>==</span> FlareResultValue<span>.</span>Done<span>;</span>
    <span>}</span>
    
    <span>public</span> <span>bool</span> <span>IsDone</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> _result <span>==</span> FlareResultValue<span>.</span>Done<span>;</span>
    <span>}</span>
    
    <span>public</span> <span>bool</span> <span>IsBufferTooSmall</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> _result <span>==</span> FlareResultValue<span>.</span>BufferTooSmall<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>

<p>The raw bindings are a set of functions with a C calling convention exported by the Rust library, and imported by the .NET runtime.</p>
<h2 id="inrust">In Rust</h2>
<p>To simplify safety checks in the FFI binding functions, we use a macro to declare our bindings in Rust called <code>ffi!</code>. Macros are like compile-time functions that operate on fragments of syntax to generate code. The <code>ffi!</code> macro takes care of ensuring arguments aren't null and capturing panics and other errors so they can be consumed by the foreign caller.</p>
<p>Before looking at the definition of the macro itself, let's see how it's used. This is what our FFI bindings for the read API look like using the <code>ffi!</code> macro:</p>
<pre><code><span>ffi!</span> <span>{</span>
    <span>fn</span> <span>flare_read_begin</span><span>(</span>
        store<span>:</span> FlareStoreHandle<span>,</span>
        range<span>:</span> <span>*</span><span>const</span> FlareRange<span>,</span>
        direction<span>:</span> FlareOrdering<span>,</span>
        reader<span>:</span> Out<span>&lt;</span>FlareReaderHandle<span>&gt;</span>
    <span>)</span> <span>-&gt;</span> FlareResult <span>{</span>
        <span>let</span> range <span>=</span> <span>&amp;</span><span>*</span>range<span>;</span>

        <span>let</span> index_expr <span>=</span> range<span>.</span><span>index_expr</span><span>(</span><span>)</span>?<span>;</span>
        <span>let</span> direction <span>=</span> <span>match</span> direction <span>{</span>
            FlareOrdering<span>:</span><span>:</span>Ascending <span>=&gt;</span> Direction<span>:</span><span>:</span>Causal<span>,</span>
            FlareOrdering<span>:</span><span>:</span>Descending <span>=&gt;</span> Direction<span>:</span><span>:</span>Anticausal<span>,</span>
        <span>}</span><span>;</span>

        <span>let</span> range <span>=</span> range<span>.</span><span>range</span><span>(</span><span>)</span><span>;</span>

        <span>let</span> vread <span>=</span> store<span>.</span>inner<span>.</span><span>begin_read</span><span>(</span>range<span>,</span> index_expr<span>,</span> direction<span>)</span>?<span>;</span>

        <span>*</span>reader <span>=</span> FlareReaderHandle<span>:</span><span>:</span><span>alloc</span><span>(</span>FlareReader <span>{</span>
            inner<span>:</span> vread
        <span>}</span><span>)</span><span>;</span>

        FlareResult<span>:</span><span>:</span>Ok
    <span>}</span>

    <span>fn</span> <span>flare_read_next</span><span>(</span>
        reader<span>:</span> FlareReaderHandle<span>,</span>
        key<span>:</span> Out<span>&lt;</span>FlareKey<span>&gt;</span><span>,</span>
        value_buf<span>:</span> <span>*</span><span>mut</span> u8<span>,</span>
        value_buf_len<span>:</span> size_t<span>,</span>
        actual_value_len<span>:</span> Out<span>&lt;</span>size_t<span>&gt;</span>
    <span>)</span> <span>-&gt;</span> FlareResult <span>{</span>
        <span>fn</span> <span>call_read</span><span>(</span>
            vreader<span>:</span> <span>&amp;</span><span>mut</span> FlareReader<span>,</span>
            buf<span>:</span> <span>&amp;</span><span>mut</span> <span>[</span>u8<span>]</span><span>,</span>
            key<span>:</span> <span>&amp;</span><span>mut</span> FlareKey<span>,</span>
            actual_value_len<span>:</span> <span>&amp;</span><span>mut</span> usize
        <span>)</span> <span>-&gt;</span> FlareResult <span>{</span>
            <span>let</span> reader <span>=</span> <span>&amp;</span><span>mut</span> vreader<span>.</span>inner<span>;</span>

            
            
            <span>let</span> read_result <span>=</span> reader<span>.</span><span>with_current</span><span>(</span><span>|</span>current<span>|</span>
                stream_read<span>:</span><span>:</span><span>into_fixed_buffer</span><span>(</span>current<span>,</span> buf<span>,</span> key<span>,</span> actual_value_len<span>)</span><span>)</span>?<span>;</span>

            <span>match</span> read_result <span>{</span>
                <span>Some</span><span>(</span>result<span>)</span> <span>=&gt;</span> <span>{</span>
                    
                    
                    <span>if</span> <span>let</span> FlareResult<span>:</span><span>:</span>Ok <span>=</span> result <span>{</span>
                        reader<span>.</span><span>move_next</span><span>(</span><span>)</span>?<span>;</span>
                    <span>}</span>

                    result
                <span>}</span>
                
                
                None <span>=&gt;</span> <span>{</span>
                    <span>if</span> reader<span>.</span><span>move_next</span><span>(</span><span>)</span>? <span>{</span>
                        <span>call_read</span><span>(</span>vreader<span>,</span> buf<span>,</span> key<span>,</span> actual_value_len<span>)</span>
                    <span>}</span> <span>else</span> <span>{</span>
                        FlareResult<span>:</span><span>:</span>Done
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>

        <span>let</span> buf <span>=</span> slice<span>:</span><span>:</span><span>from_raw_parts_mut</span><span>(</span>value_buf<span>,</span> value_buf_len<span>)</span><span>;</span>
        <span>call_read</span><span>(</span><span>&amp;</span><span>mut</span> reader<span>,</span> buf<span>,</span> <span>&amp;</span><span>mut</span> <span>*</span>key<span>,</span> <span>&amp;</span><span>mut</span> <span>*</span>actual_value_len<span>)</span>
    <span>}</span>

    <span>fn</span> <span>flare_read_end</span><span>(</span>reader<span>:</span> FlareReaderHandle<span>)</span> <span>-&gt;</span> FlareResult <span>{</span>
        FlareReaderHandle<span>:</span><span>:</span><span>dealloc</span><span>(</span>reader<span>,</span> <span><span>|</span>r<span>|</span></span> <span>{</span>
            r<span>.</span>inner<span>.</span><span>complete</span><span>(</span><span>)</span>?<span>;</span>

            FlareResult<span>:</span><span>:</span>Ok
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>Most of the work here is in the <code>flare_read_next</code> function, which attempts to read an event into a caller-supplied buffer and return an appropriate error code if it doesn't fit. The <code>StoreReader</code> type it works with has a similar to API to the <a href="https://docs.rs/streaming-iterator"><code>streaming_iterator::StreamingIterator</code></a> trait. We saw the C# counterpart to the <code>flare_read_next</code> function in the <code>Reader.TryReadNext</code> method.</p>
<p>The <code>Out</code> type is a simple type alias that makes it clear that we expect the function to assign to that argument:</p>
<pre><code><span>type</span> Out<span>&lt;</span>T<span>&gt;</span> <span>=</span> <span>*</span><span>mut</span> T<span>;</span>
</code></pre>
<p>Now let's take a look at the <code>ffi!</code> macro itself and see what it does.</p>
<h3 id="usingmacrostobuildsaferbindings">Using macros to build safer bindings</h3>
<p>The <code>flare_read_begin</code>, <code>flare_read_next</code>, and <code>flare_read_end</code> functions are expanded by the <code>ffi!</code> macro to include boilerplate for ensuring arguments aren't null and to catch any panics using the <code>FlareResult</code> type we saw earlier.</p>
<p>The <code>ffi!</code> macro itself looks like this (don't worry if the syntax looks unfamiliar, Rust macros are a bit different from regular Rust code):</p>
<pre><code><span>macro_rules!</span> ffi <span>{</span>
    <span>(</span>$<span>(</span><span>fn</span> $name<span>:</span><span>ident</span><span>(</span>$<span>(</span>$arg_ident<span>:</span>ident<span>:</span> $arg_ty<span>:</span>ty<span>)</span><span>,</span><span>*</span><span>)</span> <span>-&gt;</span> FlareResult $body<span>:</span>expr<span>)</span><span>*</span><span>)</span> <span>=&gt;</span> <span>{</span>
        $<span>(</span>
            <span>#[no_mangle]</span>
            <span>pub</span> <span>unsafe</span> <span>extern</span> <span>"C"</span> <span>fn</span> $<span>name</span><span>(</span> $<span>(</span>$arg_ident <span>:</span> $arg_ty<span>)</span><span>,</span><span>*</span> <span>)</span> <span>-&gt;</span> FlareResult <span>{</span>
                <span>#[allow(unused_mut)]</span>
                <span>unsafe</span> <span>fn</span> <span>call</span><span>(</span> $<span>(</span><span>mut</span> $arg_ident<span>:</span> $arg_ty<span>)</span><span>,</span><span>*</span> <span>)</span> <span>-&gt;</span> FlareResult <span>{</span>
                    <span>if</span> $<span>(</span>$arg_ident<span>.</span><span>is_null</span><span>(</span><span>)</span><span>)</span> <span>||</span> <span>*</span> <span>{</span>
                        <span>return</span> FlareResult<span>:</span><span>:</span>ArgumentNull<span>;</span>
                    <span>}</span>

                    $body
                <span>}</span>

                FlareResult<span>:</span><span>:</span><span>catch</span><span>(</span><span>move</span> <span>||</span> <span>call</span><span>(</span> $<span>(</span>$arg_ident<span>)</span><span>,</span><span>*</span> <span>)</span><span>)</span>
            <span>}</span>
        <span>)</span><span>*</span>
    <span>}</span><span>;</span>
<span>}</span>
</code></pre>
<p>Argument null checking is handled by a trait called <code>IsNull</code>. This trait is fairly simple and we only implement it for argument types that are used in the FFI bindings:</p>
<pre><code>
<span>pub</span><span>(</span><span>super</span><span>)</span> <span>trait</span> IsNull <span>{</span>
    <span>fn</span> <span>is_null</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> bool<span>;</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>:</span> ?Sized<span>&gt;</span> IsNull <span>for</span> <span>*</span><span>const</span> T <span>{</span>
    <span>fn</span> <span>is_null</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> bool <span>{</span>
        <span>&lt;</span><span>*</span><span>const</span> T<span>&gt;</span><span>:</span><span>:</span><span>is_null</span><span>(</span><span>*</span><span>self</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>:</span> ?Sized<span>&gt;</span> IsNull <span>for</span> <span>*</span><span>mut</span> T <span>{</span>
    <span>fn</span> <span>is_null</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> bool <span>{</span>
        <span>&lt;</span><span>*</span><span>mut</span> T<span>&gt;</span><span>:</span><span>:</span><span>is_null</span><span>(</span><span>*</span><span>self</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>:</span> ?Sized<span>&gt;</span> IsNull <span>for</span> <span>super</span><span>:</span><span>:</span>HandleOwned<span>&lt;</span>T<span>&gt;</span> <span>{</span>
    <span>fn</span> <span>is_null</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> bool <span>{</span>
        <span>self</span><span>.</span><span>0</span><span>.</span><span>is_null</span><span>(</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>impl</span><span>&lt;</span>T<span>:</span> ?Sized <span>+</span> Sync<span>&gt;</span> IsNull <span>for</span> <span>super</span><span>:</span><span>:</span>HandleShared<span>&lt;</span>T<span>&gt;</span> <span>{</span>
    <span>fn</span> <span>is_null</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> bool <span>{</span>
        <span>self</span><span>.</span><span>0</span><span>.</span><span>is_null</span><span>(</span><span>)</span>
    <span>}</span>
<span>}</span>


<span>macro_rules!</span> never_null <span>{</span>
    <span>(</span>$<span>(</span>$t<span>:</span>ty<span>)</span><span>,</span><span>*</span><span>)</span> <span>=&gt;</span> <span>{</span>
        $<span>(</span>
            <span>impl</span> IsNull <span>for</span> $t <span>{</span>
                <span>fn</span> <span>is_null</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> bool <span>{</span> <span>false</span> <span>}</span>
            <span>}</span>
        <span>)</span><span>*</span>
    <span>}</span>
<span>}</span>


<span>never_null!</span><span>(</span>
    usize<span>,</span>
    isize<span>,</span>
    u8<span>,</span>
    u16<span>,</span>
    u32<span>,</span>
    u64<span>,</span>
    u128<span>,</span>
    i8<span>,</span>
    i16<span>,</span>
    i32<span>,</span>
    i64<span>,</span>
    i128<span>,</span>
    bool<span>,</span>
    <span>super</span><span>:</span><span>:</span>FlareOrdering
<span>)</span><span>;</span>
</code></pre>
<p>The magic is in the <code>ffi!</code> macro, that knows what all the arguments to the function are and can automatically call <code>IsNull::is_null</code> on each of them.</p>
<h2 id="inc">In C#</h2>
<p>There's a standard tool for importing unmanaged function bindings in .NET called P/Invoke. This feature comes with a runtime cost whenever one of the binding functions is invoked, but can be fairly cheap if you amortize the cost by doing as much work as possible in a single call, and are careful about only marshaling blittable types. A type is blittable if its values have the same in-memory representation for both managed and unmanaged code. A few examples of blittable types in .NET are <code>int</code>, <code>IntPtr</code>, and structs with only blittable fields.</p>
<p>The C# bindings for the three Rust functions needed to read events look like this:</p>
<pre><code><span>static</span> <span>class</span> <span>Bindings</span>
<span>{</span>
<span>#<span>if</span> WINDOWS</span>
    <span>const</span> <span>string</span> NativeLib <span>=</span> <span>"Native/flare"</span><span>;</span>
<span>#<span>else</span></span>
    <span>const</span> <span>string</span> NativeLib <span>=</span> <span>"Native/libflare"</span><span>;</span>
<span>#<span>endif</span></span>

    <span>[</span><span>DllImport</span><span>(</span>NativeLib<span>,</span> EntryPoint <span>=</span> <span>"flare_read_begin"</span><span>,</span> ExactSpelling <span>=</span> <span>true</span><span>)</span><span>]</span>
    <span>public</span> <span>static</span> <span>extern</span> <span>FlareResult</span> <span>flare_read_begin</span><span>(</span>
        <span>StoreHandle</span> store<span>,</span>
        <span>IntPtr</span> range<span>,</span>
        <span>Ordering</span> ordering<span>,</span>
        <span>out</span> <span>ReaderHandle</span> reader<span>)</span><span>;</span>
        
    <span>[</span><span>DllImport</span><span>(</span>NativeLib<span>,</span> EntryPoint <span>=</span> <span>"flare_read_next"</span><span>,</span> ExactSpelling <span>=</span> <span>true</span><span>)</span><span>]</span>
    <span>public</span> <span>static</span> <span>extern</span> <span>FlareResult</span> <span>flare_read_next</span><span>(</span>
        <span>ReaderHandle</span> reader<span>,</span>
        <span>out</span> <span>Key</span> key<span>,</span> 
        <span>IntPtr</span> valueBuf<span>,</span>
        <span>UIntPtr</span> valueBufLen<span>,</span>
        <span>out</span> <span>UIntPtr</span> actualValueLen<span>)</span><span>;</span>
        
    <span>[</span><span>DllImport</span><span>(</span>NativeLib<span>,</span> EntryPoint <span>=</span> <span>"flare_read_end"</span><span>,</span> ExactSpelling <span>=</span> <span>true</span><span>)</span><span>]</span>
    <span>public</span> <span>static</span> <span>extern</span> <span>FlareResult</span> <span>flare_read_end</span><span>(</span><span>IntPtr</span> reader<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<p>The <code>WINDOWS</code> variable is a build-time constant we use for platform-specific code blocks.</p>

<p>That's been a whirlwind tour of how we do FFI between Rust and C# in Seq! I hope there's something in there you've found interesting. We've tried to keep the source on either side of the Rust/C# FFI boundary idiomatic. Macros on the Rust side let us reduce a lot of boilerplate when defining the C ABI. Handles on the C# side take care of the subtleties of holding unmanaged resources alongside GC-managed ones. Using an FFI-specific result type lets us combine Rust errors with .NET exceptions so we have visibility into native code. The end result is an integrated, but independent set of codebases that are idiomatic within their target domains.</p>
<!--kg-card-end: markdown-->
        </section>

        
    </article>
</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>