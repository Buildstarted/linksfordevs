<!DOCTYPE html>
<html lang="en">
<head>
    <title>
google/schism: A self-hosting Scheme to WebAssembly compiler -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>google/schism: A self-hosting Scheme to WebAssembly compiler</h1><div><div id="" class="markdown-body entry-content p-5"><p>Schism is an experimental self-hosting compiler from a subset of R6RS Scheme to
WebAssembly.</p><p>This is not an officially supported Google product.</p><p>Development so far has focused on features necessary for
self-hosting. The compiler itself is written in, and compiles, a very
small subset of Scheme. Now that self-hosting has been achieved,
development can shift towards supporting a more complete subset of
Scheme. Just to be clear, by subset we mean that all programs
supported by Schism are also legal R6RS Scheme programs and they will
have the same behavior when run under Schism or an R6RS-compliant
Scheme.</p><p>Besides just being fun, one of the goals of this project is to explore different
ways to use WebAssembly. This includes implementing garbage collection, possibly
using the WebAssembly GC proposal, dynamic linking and code generation, etc.</p><p>Chez Scheme was used to bootstrap, but development no longer relies on
an existing Scheme implementation and can instead run purely based on
snapshots checked into the repository.  The compiler can also bootstrap
from GNU Guile.</p><p>As mentioned, the goal has been to prioritize features needed for self
hosting. Here are some of the current restrictions:</p><ul><li>Functions may only be created with <code>define</code>, and particularly only the
<code>(define (foo args ...) body)</code> form.</li><li>No use of <code>syntax-case</code>, <code>syntax-rules</code>, or <code>define-syntax</code>.</li><li>Only one file to start with, so we don't have to figure out how to link
multiple libraries.</li><li>Only use <code>define</code> to create functions, not global variables or objects.</li><li>Use a small amount of syntax, because we won't have a proper macro expander at
first. There is a pass to expand some of the simpler and more useful macros.</li><li>Restrict data types and operations on those. For now, we can use:
<ul><li>Booleans</li><li>Numbers (integers within the <code>int32</code> range)</li><li>Characters</li><li>Pairs</li><li>Strings</li><li>Symbols</li></ul></li></ul><p>As more features are supported by the compiler, we will remove these
restrictions.</p><p>See the <code>docs</code> directory for more information about how various
features are implemented.</p><h2><a id="user-content-current-status-and-next-steps" class="anchor" aria-hidden="true" href="#current-status-and-next-steps"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Current Status and Next Steps</h2><p>The compiler is self-hosting! Now the goal is to make a more complete
language. Some of the big missing features are:</p><ul><li>Variable length argument lists</li><li>Macros</li><li>Support for multiple files and modules</li><li>Ports</li></ul><h2><a id="user-content-testing" class="anchor" aria-hidden="true" href="#testing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testing</h2><p>We currently use a very simple testing protocol. The <code>test/</code> directory includes
a number of Scheme libraries, each of which export a function called
<code>do-test</code>. This function can do whatever it wants, but it must return a value
other than <code>#f</code> to pass.</p><p>To run all the tests, do <code>./run-tests.sh</code>.</p><h2><a id="user-content-schism-uses-experimental-webassembly-features" class="anchor" aria-hidden="true" href="#schism-uses-experimental-webassembly-features"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schism uses experimental WebAssembly features</h2><p>Note!  One of the purposes of Schism is to advance the state of the art
in WebAssembly implementations.  Currently, the WebAssembly emitted by
Schism uses the following experimental features:</p><p>As of August 2019, the only production WebAssembly implementation that
has both of these features is V8, and both features are behind a flag.
To use the features with Node, we add the
<code>--experimental-wasm-return-call</code> and <code>--experimental-wasm-anyref</code> flags
to Node's argument list.  We hope to improve this situation in the
future.</p><h2><a id="user-content-the-playground" class="anchor" aria-hidden="true" href="#the-playground"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Playground</h2><p>This repository includes a very simple <code>playground.html</code>, which gives a
lightweight way to play around with the compiler. Be warned, there is
almost no error checking right now, so strange things can happen.</p><p>The best way to use it is to start up a web server (<code>python -m SimpleHTTPServer</code> should work) and point your browser at the page.</p><p>Note that because Schism uses experimental WebAssembly features, you
need a browser that supports these features.  To get a Chrome that has
these features, try:</p><pre><code>chrome --js-flags="--experimental-wasm-anyref --experimental-wasm-return-call"
</code></pre><p>Then navigate to <code>http://localhost:8000/playground.html</code>.</p><h2><a id="user-content-development" class="anchor" aria-hidden="true" href="#development"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Development</h2><p>The compiler code all lives in <code>schism/compiler.ss</code>. There is a
JavaScript runtime in <code>rt/rt.mjs</code>. The goal is to keep as much code as
possible in Scheme, but the runtime is needed to interact with the rest
of the world. Also, until larger parts of the <a href="https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md">GC
proposal</a>
are implemented in WebAssembly engines, the run-time also has some
routines to allocate memory using the host (usually the JavaScript GC),
to enable garbage collection. In the future, the runtime should also
handle dynamic module loading.</p><p>We have a staged build system. Stage0 is the compiler snapshot, stored in
<code>schism-stage0.wasm</code>. Stage1 is generated by compiling <code>schism/compiler.ss</code> with
the Stage0 compiler, Stage2 by compiling with the Stage1 compiler, and Stage3 by
compiling with the Stage2 compiler. Stage3 should be equal to the Stage2
compiler, and currently we only generate it to verify this is the case.</p><p>To add a new feature, the usual flow is to start by adding a small test that
uses it. This test will probably fail at least the Stage0 compiler. Once the
feature is implemented, then the Stage1 and Stage2 compilers should pass the
test. Note that you cannot use the new feature in the compiler until it works in
stage2. Once this happens, you should make a new snapshot using <code>mksnapshot.sh</code>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>