<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The polygons of Another World: Game Boy Advance -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>The polygons of Another World: Game Boy Advance</h1>
    <body><br><center> <div>
<a href="/"><b>FABIEN SANGLARD&apos;S WEBSITE</b><br>
</a></div>
</center>
January 26, 2020
<p><b>The polygons of Another World: Game Boy Advance</b></p> <p> This article is part of a study about the ports of Another World. It is highly recommended to read <a href="../another_world_polygons/index.html">Another World 101</a> before reading this.
</p> <p><b>Game Boy Advance</b></p>
<p class="p">
<img src="Gameboy_advance_logo.svg" width="50%"> In 1989, Nintendo released a handheld console named &quot;Game Boy&quot;. The modest specs of the machine made of a weak 8-bit Sharp LR35902 CPU, four greenscale display, and no back-light did not scare away customers. It became a worldwide phenomenon able to outsell competitors with seemingly superior technology such as the Sega Game Gear, the Atari Lynx, and NEC&apos;s TurboExpress. A superior battery life, a robust construction, and quality games took Nintendo a long way. The smashing success turned out to be the beginning of the &quot;Game Boy Family&quot; which welcomed the Game Boy Pocket in 1996, the Game Boy Light and the Game Boy Color in 1998. Cumulative sales of the three early &quot;boys&quot; totaled close to 120 millions units. Over the course of nine years, the core technology did not evolve much. Even though the line saw improvements such as colors, CPU frequency, memory, battery life, weight, and size, the CPU remained a 8-bit Sharp LR35902. As a new decade started, the family found itself in dear need for a new, more powerful, member.
<p>
The Game Boy Advance (GBA) was released worldwide in 2001. In the USA it became the fastest-selling video game console with 500,000 unit sold in the first week. By late 2009, the GBA had sold 81.51 million units worldwide<a href="#footnote_1"><sup>[1]</sup></a>.
</p><p>
Perhaps more importantly, the GBA came out when powerful PCs and Internet were becoming readily available. This environment allowed fans to take their passion on-line, publish home-brew games, tutorials<a href="#footnote_2"><sup>[2]</sup></a>, and excellent documentation. Most of it lives on to this day.
</p><br> <picture> <source srcset="http://fabiensanglard.net/another_world_polygons_GBA/gba.webp" type="image/webp"> <img src="gba.png" width="100%">
</picture>
<span><i><small>The Nintendo Game Boy Advanced.</small></i></span>
</p> <p><b>Architecture</b></p>
<p> On the hardware side, the GBA is a mix of 8-bit, 16-bit and 32-bit components. The main chip contains not only a ARM7tdmi CPU running at 16.78 MHz but also the PPU (with its 96KiB VRAM), the DMA controller, and 32KiB of RAM (called IWRAM).<br> <img src="gba_arch.svg"> In order to lower manufacturing cost, Nintendo designers limited the amount of in-chip RAM (IWRAM). There is more RAM available externally on the board (EWRAM) and in the Game Pak (ROM) but those offer lesser performance.
</p> <pre>
Type         Bus     Access cycles
                       8   16   32
==================================                       
IWRAM         32       1    1    1
EWRAM         16       3    3    6 
VRAM          16       1    1    2 
ROM           16       5    5    8 
SRAM           8       5    5    5    

</pre>
<p> Notice the inverse proportion size/speed where the IWRAM can read/write anything thrown at her within 1 CPU cycle whereas the SRAM located on the Game Pak takes a consistent 5 cycles<a href="#footnote_3"><sup>[3]</sup></a> regardless of the access size. Even though these are disparates units, all these components are conveniently mapped into the same address space.<pre>
General Internal Memory
  00000000-00003FFF   BIOS - System ROM         ( 16 KiB)
  02000000-0203FFFF   WRAM - On-board Work RAM  (256 KiB)
  03000000-03007FFF   WRAM - In-chip Work RAM   ( 32 KiB)
  04000000-040003FE   I/O Registers
Internal Display Memory
  05000000-050003FF   BG/OBJ Palette RAM        (  1 KiB)
  06000000-06017FFF   VRAM - Video RAM          ( 96 KiB)
  07000000-070003FF   OAM - OBJ Attributes      (  1 KiB)
External Memory (Game Pak)
  08000000-09FFFFFF   Game Pak ROM/FlashROM  (max 32 MiB) *
  0A000000-0BFFFFFF   Game Pak ROM/FlashROM  (max 32 MiB) **
  0C000000-0DFFFFFF   Game Pak ROM/FlashROM  (max 32 MiB) ***
  0E000000-0E00FFFF   Game Pak SRAM          (max 64 KiB)   </pre>
</p><p> Note: *, **, and *** areas map to the same 32 MiB but with adjustable access time (a.k.a Wait State ID0, Wait State ID1, Wait State ID2) in case the Game Pak contains slower chips.
</p> <p><b>Beating the 16-bit bottleneck</b></p>
<p> With an underwhelming 16-bit data bus connecting the ROM to the CPU, the GBA seemed prompt to reduced performances. The small bus is a problem to transfer data but it even more of an bottleneck for the code since an ARM expects 32-bit instructions.
<p> A quick math shows that it would take at best 16 cycles for each instruction to be retrieved which would starve the CPU. The problem is exacerbated by the ARMtdmi&apos;s three-stage pipeline<a href="#footnote_4"><sup>[4]</sup></a> which introduces latency, taking stalls from annoyance level to straight up performance killer.
</p><p>
To get the best of both worlds (a cheap 16-bit data bus and performance), Nintendo designers used a prefetch buffer in front of the Game Pack. It is able to store up to 8 x 16-bit values and fills itself when the CPU is not using the bus. This trick completely removes wait states<a href="#footnote_5"><sup>[5]</sup></a> and provide 1-cycle latency on 16-bit read operations.
</p> The system has its limit since there is no branch prediction. Any jump instruction guarantees a prefetch miss and an empty ARM pipeline. Even with a prefetcher to remove the wait-states, there is still a problem with instructions which are twice as big as the bus. To solve this second problem, ARM engineers made their CPU compatible with a Thumb instruction set which use 16-bit per instruction. Performance-wise, the result is not exactly as good as ARM 32-bit but it gets close.<blockquote> * Thumb code is able to provide up to 65% of the code size of ARM, and 160% of the performance of an equivalent ARM processor connected to a 16-bit memory system. * For critical code size applications, the alternative 16-bit Thumb Mode reduces code by more than 30% with minimal performance penalty. </blockquote>
</p><p> To get a better understanding of the trade-off between Thumb and ARM, let&apos;s look at an example provided by Felix Jones.<br>
<pre><span>int</span> abs<span>(</span><span>int</span> value<span>)</span> <span>{</span> <span>return</span> <span>(</span>value <span>&gt;</span><span>=</span> <span>0</span><span>)</span> <span>?</span> value <span>:</span> <span>-</span>value<span>;</span>
<span>}</span>
</pre> </p><p> On ARM, the function takes three instructions. The Thumb version is 25% more verbose. However, the ARM code takes 12 bytes whereas the Thumb code takes 8 bytes.<br> <pre>
abs_arm(int):
    cmp     r0, #0
    rsblt   r0, r0, #0
    bx      lr

  </pre> <pre>
abs_thumb(int):
    asrs    r3, r0, #31
    adds    r0, r0, r3
    eors    r0, r3
    bx      lr
  </pre> <p><b>Video System</b></p>
</p><p> Having just reviewed the Super Nintendo and the MegaDrive, it is refreshing to not have to worry about resolution differences due to PAL/NTSC TVs. The GBA screen has a resolution of 240 &#xD7; 160 pixels refreshing at 60Hz. Alike the Super Nintendo, the PPU works around the concept of Background and Sprites. The interesting bit in the context of Another World are the three bitmap modes where each pixel can be set directly without having to fake a background with tiles.</p> <pre>
Mode      Type        Resolution         Backgrounds               Colors
=============================================================================
 0        Tile         240 x 160              4               8-bpp (indexed)        
 1        Tile         240 x 160              3               8-bpp (indexed)        
 2        Tile         240 x 160              2               8-bpp (indexed)        
 3      Bitmap         240 x 160              1              16-bpp  (direct)
 4      Bitmap         240 x 160              2               8-bpp (indexed)        
 5      Bitmap         160 x 128              2              16-bpp  (direct)       

</pre> <p> On the color side, the machine is able to uses 16-bit color encoded as 555 with 1 bit not used. In Mode 3, 16-bit RGB values can we written directly in the framebuffer without using a palette. This consumes so much VRAM that there is not enough space for a double buffer. <table> <tr> <td> <picture> <source srcset="http://fabiensanglard.net/another_world_polygons_GBA/clear_5bit.webp" type="image/webp"> <img src="clear_5bit.png"> </picture>
</td> <td> <picture> <source srcset="http://fabiensanglard.net/another_world_polygons_GBA/dark_5bit.webp" type="image/webp"> <img src="dark_5bit.png"> </picture> </td>
</tr>
</table> <span><i><small>15-bit per pixel color space</small></i></span> The timing of the display with regards to the CPU is very accurate and well-documented.<p> <img class="pixel" src="Gba_screen.png" width="40%"> </p><pre>
Type          Length          Cycles
====================================
Pixel            1                 4
HDraw          240               960
HBlank          68               272
Scanline    HDraw + HBlank      1232
VDraw       160 * Scanline    197120
VBlank       68 * Scanline     83776
Refresh     VDraw + VBlank    280896

</pre>
</p><p> In mode 4 (used by Another World), the location of the two framebuffers and the palette in VRAM are fixed in the global address space.<br> <pre>u16<span>*</span> VideoFrontBuffer <span>=</span> <span>(</span>u16<span>*</span><span>)</span> <span>0x6000000</span><span>;</span>
u16<span>*</span> VideoBackBuffer <span>=</span> <span>(</span>u16<span>*</span><span>)</span> <span>0x600a000</span><span>;</span>
u16<span>*</span> Palette <span>=</span> <span>(</span>u16<span>*</span><span>)</span> <span>0x5000000</span><span>;</span>
</pre> </p><p>
Waiting for VBLANK to avoid tearing illustrates well the creativity allowed by the machine. You can either rely on REG_VCOUNT register which counts scanlines or use an interrupt handler.
</p> <pre><p>#</p><p>define</p><p> REG_VCOUNT </p><p>*</p><p>(</p><p>vu16</p><p>*</p><p>)</p><p>0x04000006</p> <p>void</p> vid_vsync<p>(</p><p>)</p> <p>{</p> <p>while</p><p>(</p>REG_VCOUNT <p>&gt;</p><p>=</p> <p>160</p><p>)</p><p>;</p> <p>while</p><p>(</p>REG_VCOUNT <p>&lt;</p> <p>160</p><p>)</p><p>;</p> <p>}</p>


</pre> <pre><p>volatile</p> u16 num_vbl<p>=</p><p>0</p><p>;</p>
Set_Interrupt<p>(</p>IT_VBLANK<p>,</p> <p>&amp;</p>it_vbl<p>)</p><p>;</p>
<p>void</p> it_vbl<p>(</p><p>)</p> <p>{</p> num_vbl<p>+</p><p>+</p><p>;</p> REG_IF<p>=</p><p>.</p><p>.</p><p>.</p> <p>;</p><p>}</p> <p>void</p> vid_vsync<p>(</p><p>)</p> <p>{</p> u16 nv <p>=</p> num_vbl<p>;</p> <p>while</p><p>(</p>nv<p>=</p><p>=</p>num_vbl<p>)</p><p>;</p>
<p>}</p>
</pre> Of course, there is a third, better, way which uses the BIOS VBlankIntrWait<a href="#footnote_7"><sup>[7]</sup></a>. It avoids a busy loop and reduces battery consumption.<p> Swapping the two VRAM framebuffers is also done manually via the DISP_CR register.
</p>
<pre><p>#</p><p>define</p><p> DISP_CR </p><p>*</p><p>(</p><p>u16</p><p>*</p><p>)</p><p>0x4000000</p>
<p>#</p><p>define</p><p> BACKBUFFER 0x10</p> <p>void</p> flip<p>(</p><p>)</p> <p>{</p> vid_vsync<p>(</p><p>)</p> <p>if</p> <p>(</p>DISP_CR <p>&amp;</p> BACKBUFFER<p>)</p><p>{</p> DISP_CR <p>&amp;</p><p>=</p> <p>~</p>BACKBUFFER<p>;</p> VideoBuffer <p>=</p> VideoBackBuffer<p>;</p> <p>}</p> <p>else</p> <p>{</p> DISP_CR <p>|</p><p>=</p> BACKBUFFER<p>;</p> VideoBuffer <p>=</p> VideoFrontBuffer<p>;</p> <p>}</p>
<p>}</p>
</pre> <p> <b><u>Trivia:</u></b> The VRAM is specular in the sense that it can be read at will but will only accepts aligned 16-bit writes. Attempting to write a single byte also modify the adjacent one.<br>
</p> <p><b>GBA Toolchain</b></p>
<p> Over the years, the GBA community has developed several SDKs. The one used for Another World was Devkitpro. Based on GNU tools, it allows development in C++/C/ASM. A full build is performed in five steps.
</p> <pre>
1$ arm-gcc -c main.c -mthumb-interwork -mthumb -O2 -o main.o
2$ arm-thumb-elf-as crt0.s -o crt0.o
3$ arm-gcc main.o crt0.o -mthumb-interwork -mthumb -specs=gba.specs -o main.elf
4$ arm-objcopy -v -O binary main.elf main.gba
5$ gbafix main.gba
</pre>
<p> Steps 1 and 3 are exactly how development on linux would look like with compile/link resulting into an ELF executable containing Thumb instructions. The fourth step simply strips the ELF header, sections and segments descriptor into a blob of bytes<a href="#footnote_8"><sup>[8]</sup></a>. In the last step, a small GBA header is added. <p> Step 2 is a convenient feature allowing to populate the IWRAM automatically. There is no loader in the GBA since the ROM is simply mapped at 0x08000000. Using a special macro, a developer can express the wish to have portion of code/data loaded into IWRAM at startup. </p></p> <pre><p>#</p><p>define</p><p> CODE_IN_IWRAM __attribute__ </p><p>(</p><p>(</p><p>section</p><p>(</p><p>&quot;</p><p>.iwram</p><p>&quot;</p><p>)</p><p>,</p><p>long_call</p><p>)</p><p>)</p> <p>void</p> CODE_IN_IWRAM MyCriticalFunctionWhichNeedsSpeed<p>(</p><p>.</p><p>.</p><p>.</p><p>)</p> <p>{</p> <p>.</p><p>.</p><p>.</p>
<p>}</p>
</pre> <p> That is what CRT0.S is for. It is a piece of code that runs before main() function, detects the .iwram sections and copy them to 0x03000000. To be complete and allow full C programs, the toolchain also handles the minutia of &quot;long&quot; PC jumps between ROM and IWRAM transparently.
</p> <blockquote> The linker script is the important part. The script reference is in gba.specs<a href="#footnote_9"><sup>[9]</sup></a> which points to gba_cart.ld<a href="#footnote_10"><sup>[10]</sup></a>. On line 158 through 167 is where the copy source for iwram text and data is given the identifiers (__iwram_start__, __iwram_end__). <p> In the pre-main C runtime, crt0.s<a href="#footnote_11"><sup>[11]</sup></a>, on line 137 you can see where the iwram section is copied. Note that crt0.s also sets up the CPU stack in IWRAM for performance reasons. </p><p>- Interview with Felix &quot;Xilefian&quot; Jones</p> </blockquote>
<p>
<b><u>Trivia:</u></b> Can you guess where memory is allocated on malloc? If you guessed EWRAM, you were correct, that is where the heap is!
</p> <p><b>Another World on GBA</b></p>
<p> Another World on GBA was entirely programmed by French developer Cyril Corgordan (a.k.a Foxy). It was a passion project.<br> <blockquote> As soon as it was released, Another World became one of my references. I started reverse engineering it immediately when I got it on my Atari ST around 1991. <p> I was always passionate about reverse engineering. If you check out my website<a href="#footnote_12"><sup>[12]</sup></a> you will see that I have reverse-engineered close to 50 Atari ST games. </p> Around 2001, I wanted to revive the title I had loved on Atari ST. Since I already had Another World internals figured out, I challenged myself to make a pixel perfect port to a platform I enjoyed, the GBA. <p>- Interview with Cyril Corgordan</p>
</blockquote>
</p><p> The development environment relied on Windows XP running Visual Studio IDE. Compilation was done using Devkitpro, tests on No$GBA emulator and perf tests on real GBA via linker cartridge. For technical references, the developer bible was named &quot;GBATek&quot;. <p> <img class="pixel" src="settings.png" width="40%"> The overall architecture is similar to what we saw on SNES and Genesis. The game uses two VRAM framebuffers in double buffering mode to avoid tearing. The three &quot;work&quot; framebuffers are in EWRAM.
</p> When a frame is completed, the CPU wait for the next VBLANK, copy it to the unused double buffer, and swap. A sixth framebuffer is used to deal with luminosity/contrast settings without messing up the rest of the game. <p> The GBA is set in mode 4 and only uses background 2. This mode provide 8-bit per pixel which means one nibble per byte is wasted but there was no way around it.
</p><pre><span>#</span><span>define</span><span> MODE4 0x4</span>
<span>#</span><span>define</span><span> BG2 0x400</span>
<span>#</span><span>define</span><span> SetVideoMode</span><span>(</span><span>mode</span><span>)</span><span> DISP_CR</span><span>=</span><span>(</span><span>mode</span><span>)</span> SetVideoMode<span>(</span>MODE4 <span>|</span> BG2<span>)</span><span>;</span>
</pre> </p><p> To keep the aspect ratio 10 lines of pixels are not used resulting in a resolution of 240 * 150 pixels.<br> <img class="pixel" src="lester_gba.png"> <span><i><small>Resolution: 240 * 150. Ten lines of pixels are left blank to match the original aspect ratio.</small></i></span> </p> <blockquote> I reverse-engineered the whole game from my Atari ST m68k executable using IDA Pro and then re-implemented each function in C. That was not very difficult. What was challenging later on was to optimize for GBA and get a good framerate. <p>- Interview with Cyril Corgordan</p>
</blockquote>
<p> Like other developers before, Cyril ran into issues with opcodes COPY, FILL, DRAW, and surprisingly TEXTAT. His first attempt at tackling FILL/COPY with DMA where not fruitful. <pre><span>void</span> DMACopyCH3<span>(</span><span>void</span><span>*</span> source<span>,</span> <span>void</span><span>*</span> dest<span>,</span> u32 WordCount<span>,</span> u32 mode<span>)</span><span>;</span>
<span>void</span> DMAFillMemory16<span>(</span><span>void</span><span>*</span> dest<span>,</span> u32 WordCount<span>,</span> u16 val_fill<span>)</span><span>;</span>
</pre> </p><p> <blockquote> I had issues using DMA3 because these are blocking calls. No code is executed until the DMA request is completed. This resulted in hiccups for audio playback which was unacceptable. <p>- Interview with Cyril Corgordan</p>
</blockquote>
</p><p> To solve this problem Cyril changed his approach and performed COPY/FILL via the CPU but placed the code in IWRAM compiled in ARM instruction set (the rest of the game is in Thumb).<br> <pre><span>void</span> CODE_IN_IWRAM DMACopyCH3<span>(</span><span>void</span><span>*</span> source<span>,</span> <span>void</span><span>*</span> dest<span>,</span> u32 WordCount<span>,</span> u32 mode<span>)</span> <span>{</span> <span>for</span> <span>(</span>u32 i<span>=</span><span>0</span><span>;</span> i <span>&lt;</span> WordCount<span>;</span> i<span>+</span><span>+</span><span>)</span> <span>*</span><span>(</span><span>(</span>u16 <span>*</span><span>)</span>dest<span>)</span><span>+</span><span>+</span> <span>=</span> <span>*</span><span>(</span><span>(</span>u16 <span>*</span><span>)</span>source<span>)</span><span>+</span><span>+</span><span>;</span>
<span>}</span> <span>void</span> CODE_IN_IWRAM DMAFillMemory16<span>(</span><span>void</span><span>*</span> dest<span>,</span> u32 WordCount<span>,</span> u16 val_fill<span>)</span> <span>{</span> <span>for</span> <span>(</span>u32 i<span>=</span><span>0</span><span>;</span> i <span>&lt;</span> WordCount<span>;</span> i<span>+</span><span>+</span><span>)</span> <span>*</span><span>(</span><span>(</span>u16 <span>*</span><span>)</span>dest<span>)</span><span>+</span><span>+</span> <span>=</span> val_fill<span>;</span>
<span>}</span>
</pre> </p><p> Notice how operations are done on a 16-bit basis because the bus would have broken down 32-bit operations in two anyway. Cyril used the same IWRAM optimization for DRAW and TEXTAT.<br> <pre>
<span>void</span> CODE_IN_IWRAM draw_shape<span>(</span>u8 <span>*</span>pt_shape<span>,</span> s32 x<span>,</span> s32 y<span>,</span> u16 scale<span>,</span> u16 color<span>)</span><span>;</span>
<span>void</span> CODE_IN_IWRAM printat<span>(</span>u16 ntxt<span>,</span> u16 x<span>,</span> u16 y<span>,</span> u8 col<span>)</span><span>;</span>
</pre>
</p><p> To increase speed even more, draw_shape uses the same trick we saw in all other ports. Namely writing several pixels at the time along a line. In this case, 16-bit values are written to set pixels with one write.
</p> <pre>u16 col <p>=</p> <p>(</p>color<p>&lt;</p><p>&lt;</p><p>8</p><p>)</p><p>|</p>color<p>;</p> <p>if</p> <p>(</p>x1 <p>&amp;</p> <p>1</p><p>)</p> <p>{</p> <p>*</p>pt_scr<p>+</p><p>+</p><p>=</p><p>(</p>u8<p>)</p>color<p>;</p> lg<p>-</p><p>-</p><p>;</p>
<p>}</p> <p>for</p> <p>(</p><p>;</p> lg<p>&gt;</p><p>1</p><p>;</p> lg<p>-</p><p>=</p><p>2</p><p>)</p> <p>*</p><p>(</p><p>(</p>u16 <p>*</p><p>)</p>pt_scr<p>)</p> <p>+</p><p>+</p><p>=</p> col<p>;</p>
</pre> <blockquote> In the end I think I found the right trade-off between the original code, speed, and video/audio rendition. It would probably be possible to optimize the code further but I don&apos;t think it would bring much to the game. The core idea was to pay homage to Another World and be as faithful to the original as possible. <p>- Interview with Cyril Corgordan</p>
</blockquote>
<p>
Later on, Cyril got in touch with Eric Chahi himself!<br>
</p> <blockquote> I was getting close to having a finished product that I intended to release for free when Eric Chahi got in touch with me. He was working on buying back the right of Another World for the 20th anniversary. I agreed to not release the GBA version until he sorted things out. Later on, he actually helped me to complete the project by providing me with the 256 colors remastered backgrounds. I was already thrilled to have completed the game but to be able to release with Eric&apos;s blessing was amazing. <p>- Interview with Cyril Corgordan</p>
</blockquote> <p><b>Verdict</b></p>
<p> <blockquote> Another World on GBA remains one of my favorite ports. Not necessary because of the technical aspect but because I was able to meet Eric. <p> On top of that, the game was very well received on the home-brew scene. The release happened on playerAdvance.org, a site dedicated to home-brew games for consoles. Within a week the game had been downloaded 10,000 times. It was even featured in Joypad magazine<a href="#footnote_13"><sup>[13]</sup></a>. </p><p>- Interview with Cyril Corgordan</p>
</blockquote>
</p> <p><b>Source Code</b></p>
<p> <img class="pixel" src="intro.png" width="40%"> Cyril kindly shared the source code to help writing this article. He does not have the time to put it on github and I don&apos;t know what license would be appropriate anyway.
<p> Here is a <a href="Another_world_GBA.zip">zip</a> for your personal use if you are interested in a peek. The content of files.c has been removed since it contained the bytecode owned by Eric Chahi.</p> <p>If you want to upload it, fork it, or re-distribute it, I recommend to double-check with Foxy.
</p></p> <p><b>Acknowledgments</b></p>
<p>
Thanks to Cyril Corgordan and Felix &quot;Xilefian&quot; Jones for proof-reading this article.<br>
</p> <p><b>References</b></p> <center>*</center></body>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>