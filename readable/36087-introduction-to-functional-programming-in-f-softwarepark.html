<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Introduction to Functional Programming in F# &#x2014; Softwarepark -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div class="sqs-block-content"><p><strong>Introduction</strong></p>
<p>This series of posts will introduce you to the world of functional programming (FP) in F#. Rather than start with theory or a formal definition, I thought that I&apos;d start with a typical business problem and look at how we can use some of the functional programming features of F# to solve it.</p>
<p><strong>Setting up your environment</strong></p>
<ol>
<li>Install F# (Installing the dotnet core SDK will install F#)</li>
<li>Install VSCode with the ionide extension (VS2019 or JetBrains Rider will work as well)</li>
<li>Open VSCode and open a blank folder to store your code.</li>
<li>Add a new file and name it first.fsx</li>
<li>Type 1 = 1 into the file.</li>
<li>Highlight the code and press ALT + ENTER</li>
<li>You should see F# Interactive (FSI) open in your Terminal and be able to see &apos;val it : bool = true&apos;</li>
</ol>
<p>If all is OK, let&apos;s take a look at a simple business Use Case and see how we can use functional programming in F# to implement it. </p>
<p><strong>Stage 1 - The Problem</strong></p>
<pre><code>Feature: Applying a discount
Scenario: Eligible Registered Customers get 10% discount when they spend &#xA3;100 or more

Given the following Registered Customers
|Customer Id|Is Eligible|
|John       |true       |
|Mary       |true       |
|Richard    |false      |

When &lt;Customer Id&gt; spends &lt;Spend&gt;
Then their order total will be &lt;Total&gt;

Examples:
|Customer Id|   Spend|   Total|
|Mary       |   99.00|   99.00|
|John       |  100.00|   90.00|
|Richard    |  100.00|  100.00|
|Sarah      |  100.00|  100.00|</code></pre><p>Along with some examples showing how you can verify that your code is working correctly are a number of domain-specific words and concepts. I want to show how we can represent some of these in our code. We will start of with something simple but naive and then we&apos;ll see how F# can help us make it much more domain specific and as an added benefit, less susceptible to bugs.</p>
<p><strong>Stage 2 - Initial Version:</strong></p>
<p>Along with simple datatypes like string, decimal and boolean, F# has a powerful Algebraic Type System (ATS). At this stage, think of these types as data structures to use in functions. The first of the types we will use is the Record Type. We can define our customer like this:</p>
<pre><code>type Customer = {
    Id : string
    IsEligible : bool
    IsRegistered : bool
}</code></pre><p>To create an instance of a customer we would write the following below the type definition:</p>
<pre><code>let fred = { Id = &quot;Fred&quot;; IsEligible = true; IsRegistered = true }</code></pre><p>By using the let keyword, we have bound the name &apos;fred&apos; to the this instance of a Customer. It is immutable (cannot be changed).</p>
<p>Delete fred as we don&apos;t need him.</p>
<p>Below the Customer type, we need to create a function to calculate the total. The function should take a Customer and a Spend (decimal) and return the Total (decimal). </p>
<pre><code>let calculateTotal (customer:Customer) (spend:decimal) : decimal =
    let discount = if customer.IsRegistered &amp;&amp; customer.IsEligible &amp;&amp; spend &gt;= 100.0M then (spend * 0.1M) else 0.0M   
    let total = spend - discount
    total</code></pre><p>There are a few things to note about functions:</p>
<ul>
<li>We have used &apos;let&apos; again to define the function and inside the function to define discount and total.</li>
<li>There is no container as functions are first-class citizens.</li>
<li>The return type is to the right of the input arguments.</li>
<li>No return keyword. The last line is returned.</li>
<li>Significant whitespace (Tabs are not allowed).</li>
<li>The function signature is Customer -&gt; decimal -&gt; decimal. The item at the end of the signature (after the last arrow) is the return type of the function. </li>
</ul>
<p>Function Signatures are <strong>very important</strong>; Get used to looking at them.</p>
<p>The F# Compiler uses a feature called Type Inference which means that most of the time it can determine types through usage without you needing to explicitly define them. As a consequence, we can re-write the function as:</p>
<pre><code>let calculateTotal customer spend =
    let discount = if customer.IsRegistered &amp;&amp; customer.IsEligible &amp;&amp; spend &gt;= 100.0M then (spend * 0.1M) else 0.0M   
    spend - discount</code></pre><p>I also removed the total binding as I don&apos;t think it adds anything to the readability of the function. The function signature is still Customer -&gt; decimal -&gt; decimal.</p>
<p>Highlight the code you&apos;ve written so far and press ALT + ENTER. This will run this code in F# Interactive (FSI) in the Terminal window.</p>
<p>Now create a customer from our specification and run in FSI:</p>
<pre><code>let john = { Id = &quot;John&quot;; IsEligible = true; IsRegistered = true }</code></pre><p>Rather than write a formal test, we can use FSI to run simple verifications for us. We will look at writing proper unit tests later in the series. </p>
<pre><code>let assertJohn = (calculateTotal john 100.0M = 90.0M)</code></pre><p>What you should see after running the test in FSI is the following:</p>
<pre><code>val assertJohn : bool = true</code></pre><p>Add in the other users and test cases from the specification.</p>
<pre><code>let john = { Id = &quot;John&quot;; IsEligible = true; IsRegistered = true }
let mary = { Id = &quot;Mary&quot;; IsEligible = true; IsRegistered = true }
let richard = { Id = &quot;Richard&quot;; IsEligible = false; IsRegistered = true }
let sarah = { Id = &quot;Sarah&quot;; IsEligible = false; IsRegistered = false }

let assertJohn = calculateTotal john 100.0M = 90.0M
let assertMary = calculateTotal mary 99.0M = 99.0M
let assertRichard = calculateTotal richard 100.0M = 100.0M
let assertSarah = calculateTotal sarah 100.0M = 100.0M</code></pre><p>Highlight the new code and press ALT + ENTER. You should see the following in FSI.</p>
<pre><code>val assertJohn : bool = true
val assertMary : bool = true
val assertRichard : bool = true
val assertSarah : bool = true</code></pre><p>Your code should now look like this:</p>
<pre><code>type Customer = {
    Id : string
    IsEligible : bool
    IsRegistered : bool
}

let calculateTotal customer spend =
    let discount = if customer.IsRegistered &amp;&amp; customer.IsEligible &amp;&amp; spend &gt;= 100.0M then (spend * 0.1M) else 0.0M   
    spend - discount

let john = { Id = &quot;John&quot;; IsEligible = true; IsRegistered = true }
let mary = { Id = &quot;Mary&quot;; IsEligible = true; IsRegistered = true }
let richard = { Id = &quot;Richard&quot;; IsEligible = false; IsRegistered = true }
let sarah = { Id = &quot;Sarah&quot;; IsEligible = false; IsRegistered = false }

let assertJohn = calculateTotal john 100.0M = 90.0M
let assertMary = calculateTotal mary 99.0M = 99.0M
let assertRichard = calculateTotal richard 100.0M = 100.0M
let assertSarah = calculateTotal sarah 100.0M = 100.0M</code></pre><p>Whilst this code works, I don&apos;t like boolean properties representing domain concepts. To this end, we will make Registered/Unregistered explicit in the code.</p>
<p><strong>Stage 3 - Making the Implicit Explicit (1)</strong></p>
<p>Firstly, we create specific Record types for Registered and Unregistered Customers.</p>
<pre><code>type RegisteredCustomer = {
    Id : string
    IsEligible : bool
}

type UnregisteredCustomer = {
    Id : string
}</code></pre><p>To represent the fact that a Customer can be either Registered or Unregistered, we will use another of the built-in types in the ATS; the Discriminated Union (DU). We define the Customer type like this:</p>
<pre><code>type Customer =
    | RegisteredCustomer of RegisteredCustomer
    | Guest of UnregisteredCustomer</code></pre><p>It is very hard to describe a Discriminated Union to an OOP developer because there is nothing in OOP that is remotely close to them. This reads as &quot;a customer is either a registered customer of type RegisteredCustomer or a guest of type UnregisteredCustomer&quot;. </p>
<p>The easiest way to understand a DU is to use it! We have to make changes to the users that we have defined. Firstly the UnregisteredCustomer:</p>
<pre><code>let sarah = Guest { Id = &quot;Sarah&quot; } // Guest of UnregisteredCustomer</code></pre><p>Look at how the definition in the DU compares to the binding.</p>
<p>Now let&apos;s make the required changes to the RegisteredCustomers:</p>
<pre><code>let john = RegisteredCustomer { Id = &quot;John&quot;; IsEligible = true }
let mary = RegisteredCustomer { Id = &quot;Mary&quot;; IsEligible = true }
let richard = RegisteredCustomer { Id = &quot;Richard&quot;; IsEligible = false }</code></pre><p>Changing the Customer type to a DU has an impact on the function. We will need to re-write the discount calculation using another F# feature - Pattern Matching:</p>
<pre><code>let calculateTotal customer spend =
    let discount = 
        match customer with
        | RegisteredCustomer c -&gt; if c.IsEligible &amp;&amp; spend &gt;= 100.0M then (spend * 0.1M) else 0.0M
        | Guest _ -&gt; 0.0M
    spend - discount</code></pre><p>To understand what the pattern match is doing is matching, compare the match &apos;RegisteredCustomer c&apos; with how we constructed the users &apos;RegisteredCustomer { Id = &quot;John&quot;; IsEligible = true }&apos;. In this case, &apos;c&apos; is a placeholder for the customer instance. The underscore in the Guest pattern match is a wildcard and implies that we don&apos;t need access to the instance. Pattern matching against DUs is exhaustive. If you don&apos;t handle every case, you will get a warning on the customer in the match saying &apos;incomplete pattern match&apos;.</p>
<p>We can simplify the logic with a guard clause but it does mean that we need to account for non-eligible Registered customers otherwise the match is incomplete:</p>
<pre><code>let calculateTotal customer spend =
    let discount = 
        match customer with
        | RegisteredCustomer c when c.IsEligible &amp;&amp; spend &gt;= 100.0M -&gt; spend * 0.1M
        | RegisteredCustomer _ -&gt; 0.0M
        | Guest _ -&gt; 0.0M
    spend - discount</code></pre><p>We can simplify the last two matches using a wildcard like this:</p>
<pre><code>let calculateTotal customer spend =
    let discount = 
        match customer with
        | RegisteredCustomer c when c.IsEligible &amp;&amp; spend &gt;= 100.0M -&gt; spend * 0.1M
        | _ -&gt; 0.0M
    spend - discount</code></pre><p>The tests don&apos;t need to change.</p>
<p>This is much better than the naive version we had before. It is much easier to understand the logic and much more difficult to have data in an invalid state. Does it get better if we make Eligibility explicit as well? Let&apos;s see!</p>
<p><strong>Stage 4 - Making the Implicit Explicit (2)</strong></p>
<p>Remove the IsEligible flag from RegisteredCustomer and add EligibleRegisteredCustomer to the Customer DU.</p>
<pre><code>type RegisteredCustomer = {
    Id : string
}

type UnregisteredCustomer = {
    Id : string
}

type Customer =
    | EligibleRegisteredCustomer of RegisteredCustomer
    | RegisteredCustomer of RegisteredCustomer
    | Guest of UnregisteredCustomer</code></pre><p>We need to make a change to our function.</p>
<pre><code>let calculateTotal customer spend =
    let discount = 
        match customer with
        | EligibleRegisteredCustomer _ when spend &gt;= 100.0M -&gt; spend * 0.1M
        | _ -&gt; 0.0M
    spend - discount</code></pre><p>We no longer need to test for IsEligible and we also no longer need access to the instance, so we can replace the &apos;c&apos; with a underscore (wildcard).</p>
<p>We make some minor changes to our helpers.</p>
<pre><code>let john = EligibleRegisteredCustomer { Id = &quot;John&quot; }
let mary = EligibleRegisteredCustomer { Id = &quot;Mary&quot; }</code></pre><p>Run your code in FSI to check all is still OK.</p>
<p>The state of our code after all of our improvements is: </p>
<pre><code>type RegisteredCustomer = {
    Id : string
}

type UnregisteredCustomer = {
    Id : string
}

type Customer =
    | EligibleRegisteredCustomer of RegisteredCustomer
    | RegisteredCustomer of RegisteredCustomer
    | Guest of UnregisteredCustomer

let calculateTotal customer spend =
    let discount = 
        match customer with
        | EligibleRegisteredCustomer _ when spend &gt;= 100.0M -&gt; spend * 0.1M
        | _ -&gt; 0.0M
    spend - discount

let john = EligibleRegisteredCustomer { Id = &quot;John&quot; }
let mary = EligibleRegisteredCustomer { Id = &quot;Mary&quot; }
let richard = RegisteredCustomer { Id = &quot;Richard&quot; }
let sarah = Guest { Id = &quot;Sarah&quot; }

let assertJohn = calculateTotal john 100.0M = 90.0M
let assertMary = calculateTotal mary 99.0M = 99.0M
let assertRichard = calculateTotal richard 100.0M = 100.0M
let assertSarah = calculateTotal sarah 100.0M = 100.0M</code></pre><p>I think that this is a big improvement over where we started but we can do better! We will revisit this in a later post and we will look at Unit Testing where we can make use of the helpers and assertions we&apos;ve already written.</p>
<p><strong>Summary</strong></p>
<p>We have covered quite a lot in this post:</p>
<ul>
<li>F# Interactive (FSI)</li>
<li>Algebraic Type System <ul>
<li>Record Types</li>
<li>Discriminated Union</li>
</ul>
</li>
<li>Pattern Matching </li>
<li>Let bindings</li>
<li>Functions</li>
<li>Function Signatures</li>
</ul>
<p>In the next post, we will start to look at function composition - building bigger functions out of smaller ones.</p>
<p><strong>Postscript</strong></p>
<p>To illustrate the portability of the functional programming concepts we have covered in this post, one of my colleagues, Daniel Weller, wrote a Scala version of the final solution:</p>
<pre><code>sealed trait Customer

case class RegisteredCustomer(id : String) extends Customer
case class EligibleRegisteredCustomer(id : String) extends Customer
case class Guest(id: String) extends Customer

def calculateTotal(customer: Customer)(spend: Double) = {
    val discount = customer match {
        case EligibleRegisteredCustomer(_) if spend &gt;= 100.0 =&gt; spend * 0.1
        case _ =&gt; 0.0
    }
    spend - discount
}

val john = EligibleRegisteredCustomer(&quot;John&quot;)
val assertJohn = (calculateTotal (john) (100.0)) == 90.0</code></pre><p>You can find his code here -&gt; <a href="https://gist.github.com/frehn/661f525ca7361359f69c800203939eb1">https://gist.github.com/frehn/661f525ca7361359f69c800203939eb1</a></p>
</div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>