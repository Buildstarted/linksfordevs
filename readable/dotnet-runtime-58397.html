<!DOCTYPE html>
<html lang="en">
<head>
    <title>
dotnet/runtime - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="dotnet/runtime - linksfor.dev(s)"/>
    <meta property="og:description" content=".NET is a cross-platform runtime for cloud, IoT, and desktop apps. - dotnet/runtime"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/dotnet/runtime/blob/fcd862e/src/coreclr/src/jit/lclvars.cpp"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - dotnet/runtime</title>
<div class="readable">
        <h1>dotnet/runtime</h1>
            <div>Reading time: 453-576 minutes</div>
        <div>Posted here: 17 Feb 2020</div>
        <p><a href="https://github.com/dotnet/runtime/blob/fcd862e/src/coreclr/src/jit/lclvars.cpp">https://github.com/dotnet/runtime/blob/fcd862e/src/coreclr/src/jit/lclvars.cpp</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div itemprop="text">
      
<table data-tab-size="4">
      <tbody><tr>
        <td id="L1" data-line-number="1"></td>
        <td id="LC1"><span><span>//</span> Licensed to the .NET Foundation under one or more agreements.</span></td>
      </tr>
      <tr>
        <td id="L2" data-line-number="2"></td>
        <td id="LC2"><span><span>//</span> The .NET Foundation licenses this file to you under the MIT license.</span></td>
      </tr>
      <tr>
        <td id="L3" data-line-number="3"></td>
        <td id="LC3"><span><span>//</span> See the LICENSE file in the project root for more information.</span></td>
      </tr>
      <tr>
        <td id="L4" data-line-number="4"></td>
        <td id="LC4">
</td>
      </tr>
      <tr>
        <td id="L5" data-line-number="5"></td>
        <td id="LC5"><span><span>/*</span>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></td>
      </tr>
      <tr>
        <td id="L6" data-line-number="6"></td>
        <td id="LC6"><span>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></td>
      </tr>
      <tr>
        <td id="L7" data-line-number="7"></td>
        <td id="LC7"><span>XX                                                                           XX</span></td>
      </tr>
      <tr>
        <td id="L8" data-line-number="8"></td>
        <td id="LC8"><span>XX                           LclVarsInfo                                     XX</span></td>
      </tr>
      <tr>
        <td id="L9" data-line-number="9"></td>
        <td id="LC9"><span>XX                                                                           XX</span></td>
      </tr>
      <tr>
        <td id="L10" data-line-number="10"></td>
        <td id="LC10"><span>XX   The variables to be used by the code generator.                         XX</span></td>
      </tr>
      <tr>
        <td id="L11" data-line-number="11"></td>
        <td id="LC11"><span>XX                                                                           XX</span></td>
      </tr>
      <tr>
        <td id="L12" data-line-number="12"></td>
        <td id="LC12"><span>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></td>
      </tr>
      <tr>
        <td id="L13" data-line-number="13"></td>
        <td id="LC13"><span>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></td>
      </tr>
      <tr>
        <td id="L14" data-line-number="14"></td>
        <td id="LC14"><span><span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L15" data-line-number="15"></td>
        <td id="LC15">
</td>
      </tr>
      <tr>
        <td id="L16" data-line-number="16"></td>
        <td id="LC16">#<span>include</span> <span><span>"</span>jitpch.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L17" data-line-number="17"></td>
        <td id="LC17">#<span>ifdef</span> _MSC_VER</td>
      </tr>
      <tr>
        <td id="L18" data-line-number="18"></td>
        <td id="LC18">#<span>pragma</span> hdrstop</td>
      </tr>
      <tr>
        <td id="L19" data-line-number="19"></td>
        <td id="LC19">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L20" data-line-number="20"></td>
        <td id="LC20">
</td>
      </tr>
      <tr>
        <td id="L21" data-line-number="21"></td>
        <td id="LC21">#<span>include</span> <span><span>"</span>emit.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L22" data-line-number="22"></td>
        <td id="LC22">#<span>include</span> <span><span>"</span>register_arg_convention.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L23" data-line-number="23"></td>
        <td id="LC23">#<span>include</span> <span><span>"</span>jitstd/algorithm.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L24" data-line-number="24"></td>
        <td id="LC24">
</td>
      </tr>
      <tr>
        <td id="L25" data-line-number="25"></td>
        <td id="LC25"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L26" data-line-number="26"></td>
        <td id="LC26">
</td>
      </tr>
      <tr>
        <td id="L27" data-line-number="27"></td>
        <td id="LC27">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L28" data-line-number="28"></td>
        <td id="LC28">#<span>if</span> DOUBLE_ALIGN</td>
      </tr>
      <tr>
        <td id="L29" data-line-number="29"></td>
        <td id="LC29"><span><span>/*</span> static <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L30" data-line-number="30"></td>
        <td id="LC30"><span>unsigned</span> Compiler::s_lvaDoubleAlignedProcsCount = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L31" data-line-number="31"></td>
        <td id="LC31">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L32" data-line-number="32"></td>
        <td id="LC32">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L33" data-line-number="33"></td>
        <td id="LC33">
</td>
      </tr>
      <tr>
        <td id="L34" data-line-number="34"></td>
        <td id="LC34"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L35" data-line-number="35"></td>
        <td id="LC35">
</td>
      </tr>
      <tr>
        <td id="L36" data-line-number="36"></td>
        <td id="LC36"><span>void</span> <span>Compiler::lvaInit</span>()</td>
      </tr>
      <tr>
        <td id="L37" data-line-number="37"></td>
        <td id="LC37">{</td>
      </tr>
      <tr>
        <td id="L38" data-line-number="38"></td>
        <td id="LC38">    <span><span>/*</span> We haven't allocated stack variables yet <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L39" data-line-number="39"></td>
        <td id="LC39">    lvaRefCountState = RCS_INVALID;</td>
      </tr>
      <tr>
        <td id="L40" data-line-number="40"></td>
        <td id="LC40">
</td>
      </tr>
      <tr>
        <td id="L41" data-line-number="41"></td>
        <td id="LC41">    lvaGenericsContextUseCount = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L42" data-line-number="42"></td>
        <td id="LC42">
</td>
      </tr>
      <tr>
        <td id="L43" data-line-number="43"></td>
        <td id="LC43">    lvaTrackedToVarNumSize = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L44" data-line-number="44"></td>
        <td id="LC44">    lvaTrackedToVarNum     = <span>nullptr</span>;</td>
      </tr>
      <tr>
        <td id="L45" data-line-number="45"></td>
        <td id="LC45">
</td>
      </tr>
      <tr>
        <td id="L46" data-line-number="46"></td>
        <td id="LC46">    lvaTrackedFixed = <span>false</span>; <span><span>//</span> false: We can still add new tracked variables</span></td>
      </tr>
      <tr>
        <td id="L47" data-line-number="47"></td>
        <td id="LC47">
</td>
      </tr>
      <tr>
        <td id="L48" data-line-number="48"></td>
        <td id="LC48">    lvaDoneFrameLayout = NO_FRAME_LAYOUT;</td>
      </tr>
      <tr>
        <td id="L49" data-line-number="49"></td>
        <td id="LC49">#<span>if</span> !defined(FEATURE_EH_FUNCLETS)</td>
      </tr>
      <tr>
        <td id="L50" data-line-number="50"></td>
        <td id="LC50">    lvaShadowSPslotsVar = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L51" data-line-number="51"></td>
        <td id="LC51">#<span>endif</span> <span><span>//</span> !FEATURE_EH_FUNCLETS</span></td>
      </tr>
      <tr>
        <td id="L52" data-line-number="52"></td>
        <td id="LC52">    lvaInlinedPInvokeFrameVar = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L53" data-line-number="53"></td>
        <td id="LC53">    lvaReversePInvokeFrameVar = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L54" data-line-number="54"></td>
        <td id="LC54">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L55" data-line-number="55"></td>
        <td id="LC55">    lvaPInvokeFrameRegSaveVar = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L56" data-line-number="56"></td>
        <td id="LC56">    lvaOutgoingArgSpaceVar    = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L57" data-line-number="57"></td>
        <td id="LC57">    lvaOutgoingArgSpaceSize   = PhasedVar&lt;<span>unsigned</span>&gt;();</td>
      </tr>
      <tr>
        <td id="L58" data-line-number="58"></td>
        <td id="LC58">#<span>endif</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L59" data-line-number="59"></td>
        <td id="LC59">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L60" data-line-number="60"></td>
        <td id="LC60">    lvaPromotedStructAssemblyScratchVar = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L61" data-line-number="61"></td>
        <td id="LC61">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L62" data-line-number="62"></td>
        <td id="LC62">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L63" data-line-number="63"></td>
        <td id="LC63">    lvaLocAllocSPvar = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L64" data-line-number="64"></td>
        <td id="LC64">#<span>endif</span> <span><span>//</span> JIT32_GCENCODER</span></td>
      </tr>
      <tr>
        <td id="L65" data-line-number="65"></td>
        <td id="LC65">    lvaNewObjArrayArgs  = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L66" data-line-number="66"></td>
        <td id="LC66">    lvaGSSecurityCookie = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L67" data-line-number="67"></td>
        <td id="LC67">#<span>ifdef</span> TARGET_X86</td>
      </tr>
      <tr>
        <td id="L68" data-line-number="68"></td>
        <td id="LC68">    lvaVarargsBaseOfStkArgs = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L69" data-line-number="69"></td>
        <td id="LC69">#<span>endif</span> <span><span>//</span> TARGET_X86</span></td>
      </tr>
      <tr>
        <td id="L70" data-line-number="70"></td>
        <td id="LC70">    lvaVarargsHandleArg = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L71" data-line-number="71"></td>
        <td id="LC71">    lvaSecurityObject   = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L72" data-line-number="72"></td>
        <td id="LC72">    lvaStubArgumentVar  = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L73" data-line-number="73"></td>
        <td id="LC73">    lvaArg0Var          = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L74" data-line-number="74"></td>
        <td id="LC74">    lvaMonAcquired      = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L75" data-line-number="75"></td>
        <td id="LC75">
</td>
      </tr>
      <tr>
        <td id="L76" data-line-number="76"></td>
        <td id="LC76">    lvaInlineeReturnSpillTemp = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L77" data-line-number="77"></td>
        <td id="LC77">
</td>
      </tr>
      <tr>
        <td id="L78" data-line-number="78"></td>
        <td id="LC78">    gsShadowVarInfo = <span>nullptr</span>;</td>
      </tr>
      <tr>
        <td id="L79" data-line-number="79"></td>
        <td id="LC79">#<span>if</span> defined(FEATURE_EH_FUNCLETS)</td>
      </tr>
      <tr>
        <td id="L80" data-line-number="80"></td>
        <td id="LC80">    lvaPSPSym = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L81" data-line-number="81"></td>
        <td id="LC81">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L82" data-line-number="82"></td>
        <td id="LC82">#<span>if</span> FEATURE_SIMD</td>
      </tr>
      <tr>
        <td id="L83" data-line-number="83"></td>
        <td id="LC83">    lvaSIMDInitTempVarNum = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L84" data-line-number="84"></td>
        <td id="LC84">#<span>endif</span> <span><span>//</span> FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L85" data-line-number="85"></td>
        <td id="LC85">    lvaCurEpoch = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L86" data-line-number="86"></td>
        <td id="LC86">
</td>
      </tr>
      <tr>
        <td id="L87" data-line-number="87"></td>
        <td id="LC87">    structPromotionHelper = <span>new</span> (<span>this</span>, CMK_Generic) <span>StructPromotionHelper</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L88" data-line-number="88"></td>
        <td id="LC88">}</td>
      </tr>
      <tr>
        <td id="L89" data-line-number="89"></td>
        <td id="LC89">
</td>
      </tr>
      <tr>
        <td id="L90" data-line-number="90"></td>
        <td id="LC90"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L91" data-line-number="91"></td>
        <td id="LC91">
</td>
      </tr>
      <tr>
        <td id="L92" data-line-number="92"></td>
        <td id="LC92"><span>void</span> <span>Compiler::lvaInitTypeRef</span>()</td>
      </tr>
      <tr>
        <td id="L93" data-line-number="93"></td>
        <td id="LC93">{</td>
      </tr>
      <tr>
        <td id="L94" data-line-number="94"></td>
        <td id="LC94">
</td>
      </tr>
      <tr>
        <td id="L95" data-line-number="95"></td>
        <td id="LC95">    <span><span>/*</span> x86 args look something like this:</span></td>
      </tr>
      <tr>
        <td id="L96" data-line-number="96"></td>
        <td id="LC96"><span>        [this ptr] [hidden return buffer] [declared arguments]* [generic context] [var arg cookie]</span></td>
      </tr>
      <tr>
        <td id="L97" data-line-number="97"></td>
        <td id="LC97"><span></span></td>
      </tr>
      <tr>
        <td id="L98" data-line-number="98"></td>
        <td id="LC98"><span>       x64 is closer to the native ABI:</span></td>
      </tr>
      <tr>
        <td id="L99" data-line-number="99"></td>
        <td id="LC99"><span>        [this ptr] [hidden return buffer] [generic context] [var arg cookie] [declared arguments]*</span></td>
      </tr>
      <tr>
        <td id="L100" data-line-number="100"></td>
        <td id="LC100"><span>        (Note: prior to .NET Framework 4.5.1 for Windows 8.1 (but not .NET Framework 4.5.1 "downlevel"),</span></td>
      </tr>
      <tr>
        <td id="L101" data-line-number="101"></td>
        <td id="LC101"><span>        the "hidden return buffer" came before the "this ptr". Now, the "this ptr" comes first. This</span></td>
      </tr>
      <tr>
        <td id="L102" data-line-number="102"></td>
        <td id="LC102"><span>        is different from the C++ order, where the "hidden return buffer" always comes first.)</span></td>
      </tr>
      <tr>
        <td id="L103" data-line-number="103"></td>
        <td id="LC103"><span></span></td>
      </tr>
      <tr>
        <td id="L104" data-line-number="104"></td>
        <td id="LC104"><span>       ARM and ARM64 are the same as the current x64 convention:</span></td>
      </tr>
      <tr>
        <td id="L105" data-line-number="105"></td>
        <td id="LC105"><span>        [this ptr] [hidden return buffer] [generic context] [var arg cookie] [declared arguments]*</span></td>
      </tr>
      <tr>
        <td id="L106" data-line-number="106"></td>
        <td id="LC106"><span></span></td>
      </tr>
      <tr>
        <td id="L107" data-line-number="107"></td>
        <td id="LC107"><span>       Key difference:</span></td>
      </tr>
      <tr>
        <td id="L108" data-line-number="108"></td>
        <td id="LC108"><span>           The var arg cookie and generic context are swapped with respect to the user arguments</span></td>
      </tr>
      <tr>
        <td id="L109" data-line-number="109"></td>
        <td id="LC109"><span>    <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L110" data-line-number="110"></td>
        <td id="LC110">
</td>
      </tr>
      <tr>
        <td id="L111" data-line-number="111"></td>
        <td id="LC111">    <span><span>/*</span> Set compArgsCount and compLocalsCount <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L112" data-line-number="112"></td>
        <td id="LC112">
</td>
      </tr>
      <tr>
        <td id="L113" data-line-number="113"></td>
        <td id="LC113">    info.<span>compArgsCount</span> = info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>numArgs</span>;</td>
      </tr>
      <tr>
        <td id="L114" data-line-number="114"></td>
        <td id="LC114">
</td>
      </tr>
      <tr>
        <td id="L115" data-line-number="115"></td>
        <td id="LC115">    <span><span>//</span> Is there a 'this' pointer</span></td>
      </tr>
      <tr>
        <td id="L116" data-line-number="116"></td>
        <td id="LC116">
</td>
      </tr>
      <tr>
        <td id="L117" data-line-number="117"></td>
        <td id="LC117">    <span>if</span> (!info.<span>compIsStatic</span>)</td>
      </tr>
      <tr>
        <td id="L118" data-line-number="118"></td>
        <td id="LC118">    {</td>
      </tr>
      <tr>
        <td id="L119" data-line-number="119"></td>
        <td id="LC119">        info.<span>compArgsCount</span>++;</td>
      </tr>
      <tr>
        <td id="L120" data-line-number="120"></td>
        <td id="LC120">    }</td>
      </tr>
      <tr>
        <td id="L121" data-line-number="121"></td>
        <td id="LC121">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L122" data-line-number="122"></td>
        <td id="LC122">    {</td>
      </tr>
      <tr>
        <td id="L123" data-line-number="123"></td>
        <td id="LC123">        info.<span>compThisArg</span> = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L124" data-line-number="124"></td>
        <td id="LC124">    }</td>
      </tr>
      <tr>
        <td id="L125" data-line-number="125"></td>
        <td id="LC125">
</td>
      </tr>
      <tr>
        <td id="L126" data-line-number="126"></td>
        <td id="LC126">    info.<span>compILargsCount</span> = info.<span>compArgsCount</span>;</td>
      </tr>
      <tr>
        <td id="L127" data-line-number="127"></td>
        <td id="LC127">
</td>
      </tr>
      <tr>
        <td id="L128" data-line-number="128"></td>
        <td id="LC128">#<span>ifdef</span> FEATURE_SIMD</td>
      </tr>
      <tr>
        <td id="L129" data-line-number="129"></td>
        <td id="LC129">    <span>if</span> (<span>supportSIMDTypes</span>() &amp;&amp; (info.<span>compRetNativeType</span> == TYP_STRUCT))</td>
      </tr>
      <tr>
        <td id="L130" data-line-number="130"></td>
        <td id="LC130">    {</td>
      </tr>
      <tr>
        <td id="L131" data-line-number="131"></td>
        <td id="LC131">        var_types structType = <span>impNormStructType</span>(info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>retTypeClass</span>);</td>
      </tr>
      <tr>
        <td id="L132" data-line-number="132"></td>
        <td id="LC132">        info.<span>compRetType</span>     = structType;</td>
      </tr>
      <tr>
        <td id="L133" data-line-number="133"></td>
        <td id="LC133">    }</td>
      </tr>
      <tr>
        <td id="L134" data-line-number="134"></td>
        <td id="LC134">#<span>endif</span> <span><span>//</span> FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L135" data-line-number="135"></td>
        <td id="LC135">
</td>
      </tr>
      <tr>
        <td id="L136" data-line-number="136"></td>
        <td id="LC136">    <span><span>//</span> Are we returning a struct using a return buffer argument?</span></td>
      </tr>
      <tr>
        <td id="L137" data-line-number="137"></td>
        <td id="LC137">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L138" data-line-number="138"></td>
        <td id="LC138">    <span>const</span> <span>bool</span> hasRetBuffArg = <span>impMethodInfo_hasRetBuffArg</span>(info.<span>compMethodInfo</span>);</td>
      </tr>
      <tr>
        <td id="L139" data-line-number="139"></td>
        <td id="LC139">
</td>
      </tr>
      <tr>
        <td id="L140" data-line-number="140"></td>
        <td id="LC140">    <span><span>//</span> Possibly change the compRetNativeType from TYP_STRUCT to a "primitive" type</span></td>
      </tr>
      <tr>
        <td id="L141" data-line-number="141"></td>
        <td id="LC141">    <span><span>//</span> when we are returning a struct by value and it fits in one register</span></td>
      </tr>
      <tr>
        <td id="L142" data-line-number="142"></td>
        <td id="LC142">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L143" data-line-number="143"></td>
        <td id="LC143">    <span>if</span> (!hasRetBuffArg &amp;&amp; <span>varTypeIsStruct</span>(info.<span>compRetNativeType</span>))</td>
      </tr>
      <tr>
        <td id="L144" data-line-number="144"></td>
        <td id="LC144">    {</td>
      </tr>
      <tr>
        <td id="L145" data-line-number="145"></td>
        <td id="LC145">        CORINFO_CLASS_HANDLE retClsHnd = info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>retTypeClass</span>;</td>
      </tr>
      <tr>
        <td id="L146" data-line-number="146"></td>
        <td id="LC146">
</td>
      </tr>
      <tr>
        <td id="L147" data-line-number="147"></td>
        <td id="LC147">        Compiler::structPassingKind howToReturnStruct;</td>
      </tr>
      <tr>
        <td id="L148" data-line-number="148"></td>
        <td id="LC148">        var_types                   returnType = <span>getReturnTypeForStruct</span>(retClsHnd, &amp;howToReturnStruct);</td>
      </tr>
      <tr>
        <td id="L149" data-line-number="149"></td>
        <td id="LC149">
</td>
      </tr>
      <tr>
        <td id="L150" data-line-number="150"></td>
        <td id="LC150">        <span><span>//</span> We can safely widen the return type for enclosed structs.</span></td>
      </tr>
      <tr>
        <td id="L151" data-line-number="151"></td>
        <td id="LC151">        <span>if</span> ((howToReturnStruct == SPK_PrimitiveType) || (howToReturnStruct == SPK_EnclosingType))</td>
      </tr>
      <tr>
        <td id="L152" data-line-number="152"></td>
        <td id="LC152">        {</td>
      </tr>
      <tr>
        <td id="L153" data-line-number="153"></td>
        <td id="LC153">            <span>assert</span>(returnType != TYP_UNKNOWN);</td>
      </tr>
      <tr>
        <td id="L154" data-line-number="154"></td>
        <td id="LC154">            <span>assert</span>(returnType != TYP_STRUCT);</td>
      </tr>
      <tr>
        <td id="L155" data-line-number="155"></td>
        <td id="LC155">
</td>
      </tr>
      <tr>
        <td id="L156" data-line-number="156"></td>
        <td id="LC156">            info.<span>compRetNativeType</span> = returnType;</td>
      </tr>
      <tr>
        <td id="L157" data-line-number="157"></td>
        <td id="LC157">
</td>
      </tr>
      <tr>
        <td id="L158" data-line-number="158"></td>
        <td id="LC158">            <span><span>//</span> ToDo: Refactor this common code sequence into its own method as it is used 4+ times</span></td>
      </tr>
      <tr>
        <td id="L159" data-line-number="159"></td>
        <td id="LC159">            <span>if</span> ((returnType == TYP_LONG) &amp;&amp; (compLongUsed == <span>false</span>))</td>
      </tr>
      <tr>
        <td id="L160" data-line-number="160"></td>
        <td id="LC160">            {</td>
      </tr>
      <tr>
        <td id="L161" data-line-number="161"></td>
        <td id="LC161">                compLongUsed = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L162" data-line-number="162"></td>
        <td id="LC162">            }</td>
      </tr>
      <tr>
        <td id="L163" data-line-number="163"></td>
        <td id="LC163">            <span>else</span> <span>if</span> (((returnType == TYP_FLOAT) || (returnType == TYP_DOUBLE)) &amp;&amp; (compFloatingPointUsed == <span>false</span>))</td>
      </tr>
      <tr>
        <td id="L164" data-line-number="164"></td>
        <td id="LC164">            {</td>
      </tr>
      <tr>
        <td id="L165" data-line-number="165"></td>
        <td id="LC165">                compFloatingPointUsed = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L166" data-line-number="166"></td>
        <td id="LC166">            }</td>
      </tr>
      <tr>
        <td id="L167" data-line-number="167"></td>
        <td id="LC167">        }</td>
      </tr>
      <tr>
        <td id="L168" data-line-number="168"></td>
        <td id="LC168">    }</td>
      </tr>
      <tr>
        <td id="L169" data-line-number="169"></td>
        <td id="LC169">
</td>
      </tr>
      <tr>
        <td id="L170" data-line-number="170"></td>
        <td id="LC170">    <span><span>//</span> Do we have a RetBuffArg?</span></td>
      </tr>
      <tr>
        <td id="L171" data-line-number="171"></td>
        <td id="LC171">
</td>
      </tr>
      <tr>
        <td id="L172" data-line-number="172"></td>
        <td id="LC172">    <span>if</span> (hasRetBuffArg)</td>
      </tr>
      <tr>
        <td id="L173" data-line-number="173"></td>
        <td id="LC173">    {</td>
      </tr>
      <tr>
        <td id="L174" data-line-number="174"></td>
        <td id="LC174">        info.<span>compArgsCount</span>++;</td>
      </tr>
      <tr>
        <td id="L175" data-line-number="175"></td>
        <td id="LC175">    }</td>
      </tr>
      <tr>
        <td id="L176" data-line-number="176"></td>
        <td id="LC176">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L177" data-line-number="177"></td>
        <td id="LC177">    {</td>
      </tr>
      <tr>
        <td id="L178" data-line-number="178"></td>
        <td id="LC178">        info.<span>compRetBuffArg</span> = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L179" data-line-number="179"></td>
        <td id="LC179">    }</td>
      </tr>
      <tr>
        <td id="L180" data-line-number="180"></td>
        <td id="LC180">
</td>
      </tr>
      <tr>
        <td id="L181" data-line-number="181"></td>
        <td id="LC181">    <span><span>/*</span> There is a 'hidden' cookie pushed last when the</span></td>
      </tr>
      <tr>
        <td id="L182" data-line-number="182"></td>
        <td id="LC182"><span>       calling convention is varargs <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L183" data-line-number="183"></td>
        <td id="LC183">
</td>
      </tr>
      <tr>
        <td id="L184" data-line-number="184"></td>
        <td id="LC184">    <span>if</span> (info.<span>compIsVarArgs</span>)</td>
      </tr>
      <tr>
        <td id="L185" data-line-number="185"></td>
        <td id="LC185">    {</td>
      </tr>
      <tr>
        <td id="L186" data-line-number="186"></td>
        <td id="LC186">        info.<span>compArgsCount</span>++;</td>
      </tr>
      <tr>
        <td id="L187" data-line-number="187"></td>
        <td id="LC187">    }</td>
      </tr>
      <tr>
        <td id="L188" data-line-number="188"></td>
        <td id="LC188">
</td>
      </tr>
      <tr>
        <td id="L189" data-line-number="189"></td>
        <td id="LC189">    <span><span>//</span> Is there an extra parameter used to pass instantiation info to</span></td>
      </tr>
      <tr>
        <td id="L190" data-line-number="190"></td>
        <td id="LC190">    <span><span>//</span> shared generic methods and shared generic struct instance methods?</span></td>
      </tr>
      <tr>
        <td id="L191" data-line-number="191"></td>
        <td id="LC191">    <span>if</span> (info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>callConv</span> &amp; CORINFO_CALLCONV_PARAMTYPE)</td>
      </tr>
      <tr>
        <td id="L192" data-line-number="192"></td>
        <td id="LC192">    {</td>
      </tr>
      <tr>
        <td id="L193" data-line-number="193"></td>
        <td id="LC193">        info.<span>compArgsCount</span>++;</td>
      </tr>
      <tr>
        <td id="L194" data-line-number="194"></td>
        <td id="LC194">    }</td>
      </tr>
      <tr>
        <td id="L195" data-line-number="195"></td>
        <td id="LC195">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L196" data-line-number="196"></td>
        <td id="LC196">    {</td>
      </tr>
      <tr>
        <td id="L197" data-line-number="197"></td>
        <td id="LC197">        info.<span>compTypeCtxtArg</span> = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L198" data-line-number="198"></td>
        <td id="LC198">    }</td>
      </tr>
      <tr>
        <td id="L199" data-line-number="199"></td>
        <td id="LC199">
</td>
      </tr>
      <tr>
        <td id="L200" data-line-number="200"></td>
        <td id="LC200">    lvaCount = info.<span>compLocalsCount</span> = info.<span>compArgsCount</span> + info.<span>compMethodInfo</span>-&gt;<span>locals</span>.<span>numArgs</span>;</td>
      </tr>
      <tr>
        <td id="L201" data-line-number="201"></td>
        <td id="LC201">
</td>
      </tr>
      <tr>
        <td id="L202" data-line-number="202"></td>
        <td id="LC202">    info.<span>compILlocalsCount</span> = info.<span>compILargsCount</span> + info.<span>compMethodInfo</span>-&gt;<span>locals</span>.<span>numArgs</span>;</td>
      </tr>
      <tr>
        <td id="L203" data-line-number="203"></td>
        <td id="LC203">
</td>
      </tr>
      <tr>
        <td id="L204" data-line-number="204"></td>
        <td id="LC204">    <span><span>/*</span> Now allocate the variable descriptor table <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L205" data-line-number="205"></td>
        <td id="LC205">
</td>
      </tr>
      <tr>
        <td id="L206" data-line-number="206"></td>
        <td id="LC206">    <span>if</span> (<span>compIsForInlining</span>())</td>
      </tr>
      <tr>
        <td id="L207" data-line-number="207"></td>
        <td id="LC207">    {</td>
      </tr>
      <tr>
        <td id="L208" data-line-number="208"></td>
        <td id="LC208">        lvaTable    = impInlineInfo-&gt;<span>InlinerCompiler</span>-&gt;<span>lvaTable</span>;</td>
      </tr>
      <tr>
        <td id="L209" data-line-number="209"></td>
        <td id="LC209">        lvaCount    = impInlineInfo-&gt;<span>InlinerCompiler</span>-&gt;<span>lvaCount</span>;</td>
      </tr>
      <tr>
        <td id="L210" data-line-number="210"></td>
        <td id="LC210">        lvaTableCnt = impInlineInfo-&gt;<span>InlinerCompiler</span>-&gt;<span>lvaTableCnt</span>;</td>
      </tr>
      <tr>
        <td id="L211" data-line-number="211"></td>
        <td id="LC211">
</td>
      </tr>
      <tr>
        <td id="L212" data-line-number="212"></td>
        <td id="LC212">        <span><span>//</span> No more stuff needs to be done.</span></td>
      </tr>
      <tr>
        <td id="L213" data-line-number="213"></td>
        <td id="LC213">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L214" data-line-number="214"></td>
        <td id="LC214">    }</td>
      </tr>
      <tr>
        <td id="L215" data-line-number="215"></td>
        <td id="LC215">
</td>
      </tr>
      <tr>
        <td id="L216" data-line-number="216"></td>
        <td id="LC216">    lvaTableCnt = lvaCount * <span>2</span>;</td>
      </tr>
      <tr>
        <td id="L217" data-line-number="217"></td>
        <td id="LC217">
</td>
      </tr>
      <tr>
        <td id="L218" data-line-number="218"></td>
        <td id="LC218">    <span>if</span> (lvaTableCnt &lt; <span>16</span>)</td>
      </tr>
      <tr>
        <td id="L219" data-line-number="219"></td>
        <td id="LC219">    {</td>
      </tr>
      <tr>
        <td id="L220" data-line-number="220"></td>
        <td id="LC220">        lvaTableCnt = <span>16</span>;</td>
      </tr>
      <tr>
        <td id="L221" data-line-number="221"></td>
        <td id="LC221">    }</td>
      </tr>
      <tr>
        <td id="L222" data-line-number="222"></td>
        <td id="LC222">
</td>
      </tr>
      <tr>
        <td id="L223" data-line-number="223"></td>
        <td id="LC223">    lvaTable         = <span>getAllocator</span>(CMK_LvaTable).<span>allocate</span>&lt;LclVarDsc&gt;(lvaTableCnt);</td>
      </tr>
      <tr>
        <td id="L224" data-line-number="224"></td>
        <td id="LC224">    <span>size_t</span> tableSize = lvaTableCnt * <span>sizeof</span>(*lvaTable);</td>
      </tr>
      <tr>
        <td id="L225" data-line-number="225"></td>
        <td id="LC225">    <span>memset</span>(lvaTable, <span>0</span>, tableSize);</td>
      </tr>
      <tr>
        <td id="L226" data-line-number="226"></td>
        <td id="LC226">    <span>for</span> (<span>unsigned</span> i = <span>0</span>; i &lt; lvaTableCnt; i++)</td>
      </tr>
      <tr>
        <td id="L227" data-line-number="227"></td>
        <td id="LC227">    {</td>
      </tr>
      <tr>
        <td id="L228" data-line-number="228"></td>
        <td id="LC228">        <span>new</span> (&amp;lvaTable[i], <span>jitstd::placement_t</span>()) <span>LclVarDsc</span>(); <span><span>//</span> call the constructor.</span></td>
      </tr>
      <tr>
        <td id="L229" data-line-number="229"></td>
        <td id="LC229">    }</td>
      </tr>
      <tr>
        <td id="L230" data-line-number="230"></td>
        <td id="LC230">
</td>
      </tr>
      <tr>
        <td id="L231" data-line-number="231"></td>
        <td id="LC231">    <span><span>//</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L232" data-line-number="232"></td>
        <td id="LC232">    <span><span>//</span> Count the arguments and initialize the respective lvaTable[] entries</span></td>
      </tr>
      <tr>
        <td id="L233" data-line-number="233"></td>
        <td id="LC233">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L234" data-line-number="234"></td>
        <td id="LC234">    <span><span>//</span> First the implicit arguments</span></td>
      </tr>
      <tr>
        <td id="L235" data-line-number="235"></td>
        <td id="LC235">    <span><span>//</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L236" data-line-number="236"></td>
        <td id="LC236">
</td>
      </tr>
      <tr>
        <td id="L237" data-line-number="237"></td>
        <td id="LC237">    InitVarDscInfo varDscInfo;</td>
      </tr>
      <tr>
        <td id="L238" data-line-number="238"></td>
        <td id="LC238">    varDscInfo.<span>Init</span>(lvaTable, hasRetBuffArg);</td>
      </tr>
      <tr>
        <td id="L239" data-line-number="239"></td>
        <td id="LC239">
</td>
      </tr>
      <tr>
        <td id="L240" data-line-number="240"></td>
        <td id="LC240">    <span>lvaInitArgs</span>(&amp;varDscInfo);</td>
      </tr>
      <tr>
        <td id="L241" data-line-number="241"></td>
        <td id="LC241">
</td>
      </tr>
      <tr>
        <td id="L242" data-line-number="242"></td>
        <td id="LC242">    <span><span>//</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L243" data-line-number="243"></td>
        <td id="LC243">    <span><span>//</span> Finally the local variables</span></td>
      </tr>
      <tr>
        <td id="L244" data-line-number="244"></td>
        <td id="LC244">    <span><span>//</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L245" data-line-number="245"></td>
        <td id="LC245">
</td>
      </tr>
      <tr>
        <td id="L246" data-line-number="246"></td>
        <td id="LC246">    <span>unsigned</span>                varNum    = varDscInfo.<span>varNum</span>;</td>
      </tr>
      <tr>
        <td id="L247" data-line-number="247"></td>
        <td id="LC247">    LclVarDsc*              varDsc    = varDscInfo.<span>varDsc</span>;</td>
      </tr>
      <tr>
        <td id="L248" data-line-number="248"></td>
        <td id="LC248">    CORINFO_ARG_LIST_HANDLE localsSig = info.<span>compMethodInfo</span>-&gt;<span>locals</span>.<span>args</span>;</td>
      </tr>
      <tr>
        <td id="L249" data-line-number="249"></td>
        <td id="LC249">
</td>
      </tr>
      <tr>
        <td id="L250" data-line-number="250"></td>
        <td id="LC250">    <span>for</span> (<span>unsigned</span> i = <span>0</span>; i &lt; info.<span>compMethodInfo</span>-&gt;<span>locals</span>.<span>numArgs</span>;</td>
      </tr>
      <tr>
        <td id="L251" data-line-number="251"></td>
        <td id="LC251">         i++, varNum++, varDsc++, localsSig = info.<span>compCompHnd</span>-&gt;<span>getArgNext</span>(localsSig))</td>
      </tr>
      <tr>
        <td id="L252" data-line-number="252"></td>
        <td id="LC252">    {</td>
      </tr>
      <tr>
        <td id="L253" data-line-number="253"></td>
        <td id="LC253">        CORINFO_CLASS_HANDLE typeHnd;</td>
      </tr>
      <tr>
        <td id="L254" data-line-number="254"></td>
        <td id="LC254">        CorInfoTypeWithMod   corInfoTypeWithMod =</td>
      </tr>
      <tr>
        <td id="L255" data-line-number="255"></td>
        <td id="LC255">            info.<span>compCompHnd</span>-&gt;<span>getArgType</span>(&amp;info.<span>compMethodInfo</span>-&gt;<span>locals</span>, localsSig, &amp;typeHnd);</td>
      </tr>
      <tr>
        <td id="L256" data-line-number="256"></td>
        <td id="LC256">        CorInfoType corInfoType = <span>strip</span>(corInfoTypeWithMod);</td>
      </tr>
      <tr>
        <td id="L257" data-line-number="257"></td>
        <td id="LC257">
</td>
      </tr>
      <tr>
        <td id="L258" data-line-number="258"></td>
        <td id="LC258">        <span>lvaInitVarDsc</span>(varDsc, varNum, corInfoType, typeHnd, localsSig, &amp;info.<span>compMethodInfo</span>-&gt;<span>locals</span>);</td>
      </tr>
      <tr>
        <td id="L259" data-line-number="259"></td>
        <td id="LC259">
</td>
      </tr>
      <tr>
        <td id="L260" data-line-number="260"></td>
        <td id="LC260">        <span>if</span> ((corInfoTypeWithMod &amp; CORINFO_TYPE_MOD_PINNED) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L261" data-line-number="261"></td>
        <td id="LC261">        {</td>
      </tr>
      <tr>
        <td id="L262" data-line-number="262"></td>
        <td id="LC262">            <span>if</span> ((corInfoType == CORINFO_TYPE_CLASS) || (corInfoType == CORINFO_TYPE_BYREF))</td>
      </tr>
      <tr>
        <td id="L263" data-line-number="263"></td>
        <td id="LC263">            {</td>
      </tr>
      <tr>
        <td id="L264" data-line-number="264"></td>
        <td id="LC264">                <span>JITDUMP</span>(<span><span>"</span>Setting lvPinned for V%02u<span>\n</span><span>"</span></span>, varNum);</td>
      </tr>
      <tr>
        <td id="L265" data-line-number="265"></td>
        <td id="LC265">                varDsc-&gt;<span>lvPinned</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L266" data-line-number="266"></td>
        <td id="LC266">            }</td>
      </tr>
      <tr>
        <td id="L267" data-line-number="267"></td>
        <td id="LC267">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L268" data-line-number="268"></td>
        <td id="LC268">            {</td>
      </tr>
      <tr>
        <td id="L269" data-line-number="269"></td>
        <td id="LC269">                <span>JITDUMP</span>(<span><span>"</span>Ignoring pin for non-GC type V%02u<span>\n</span><span>"</span></span>, varNum);</td>
      </tr>
      <tr>
        <td id="L270" data-line-number="270"></td>
        <td id="LC270">            }</td>
      </tr>
      <tr>
        <td id="L271" data-line-number="271"></td>
        <td id="LC271">        }</td>
      </tr>
      <tr>
        <td id="L272" data-line-number="272"></td>
        <td id="LC272">
</td>
      </tr>
      <tr>
        <td id="L273" data-line-number="273"></td>
        <td id="LC273">        varDsc-&gt;<span>lvOnFrame</span> = <span>true</span>; <span><span>//</span> The final home for this local variable might be our local stack frame</span></td>
      </tr>
      <tr>
        <td id="L274" data-line-number="274"></td>
        <td id="LC274">
</td>
      </tr>
      <tr>
        <td id="L275" data-line-number="275"></td>
        <td id="LC275">        <span>if</span> (corInfoType == CORINFO_TYPE_CLASS)</td>
      </tr>
      <tr>
        <td id="L276" data-line-number="276"></td>
        <td id="LC276">        {</td>
      </tr>
      <tr>
        <td id="L277" data-line-number="277"></td>
        <td id="LC277">            CORINFO_CLASS_HANDLE clsHnd = info.<span>compCompHnd</span>-&gt;<span>getArgClass</span>(&amp;info.<span>compMethodInfo</span>-&gt;<span>locals</span>, localsSig);</td>
      </tr>
      <tr>
        <td id="L278" data-line-number="278"></td>
        <td id="LC278">            <span>lvaSetClass</span>(varNum, clsHnd);</td>
      </tr>
      <tr>
        <td id="L279" data-line-number="279"></td>
        <td id="LC279">        }</td>
      </tr>
      <tr>
        <td id="L280" data-line-number="280"></td>
        <td id="LC280">    }</td>
      </tr>
      <tr>
        <td id="L281" data-line-number="281"></td>
        <td id="LC281">
</td>
      </tr>
      <tr>
        <td id="L282" data-line-number="282"></td>
        <td id="LC282">    <span>if</span> ( <span><span>//</span> If there already exist unsafe buffers, don't mark more structs as unsafe</span></td>
      </tr>
      <tr>
        <td id="L283" data-line-number="283"></td>
        <td id="LC283">        <span><span>//</span> as that will cause them to be placed along with the real unsafe buffers,</span></td>
      </tr>
      <tr>
        <td id="L284" data-line-number="284"></td>
        <td id="LC284">        <span><span>//</span> unnecessarily exposing them to overruns. This can affect GS tests which</span></td>
      </tr>
      <tr>
        <td id="L285" data-line-number="285"></td>
        <td id="LC285">        <span><span>//</span> intentionally do buffer-overruns.</span></td>
      </tr>
      <tr>
        <td id="L286" data-line-number="286"></td>
        <td id="LC286">        !<span>getNeedsGSSecurityCookie</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L287" data-line-number="287"></td>
        <td id="LC287">        <span><span>//</span> GS checks require the stack to be re-ordered, which can't be done with EnC</span></td>
      </tr>
      <tr>
        <td id="L288" data-line-number="288"></td>
        <td id="LC288">        !opts.<span>compDbgEnC</span> &amp;&amp; <span>compStressCompile</span>(STRESS_UNSAFE_BUFFER_CHECKS, <span>25</span>))</td>
      </tr>
      <tr>
        <td id="L289" data-line-number="289"></td>
        <td id="LC289">    {</td>
      </tr>
      <tr>
        <td id="L290" data-line-number="290"></td>
        <td id="LC290">        <span>setNeedsGSSecurityCookie</span>();</td>
      </tr>
      <tr>
        <td id="L291" data-line-number="291"></td>
        <td id="LC291">        compGSReorderStackLayout = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L292" data-line-number="292"></td>
        <td id="LC292">
</td>
      </tr>
      <tr>
        <td id="L293" data-line-number="293"></td>
        <td id="LC293">        <span>for</span> (<span>unsigned</span> i = <span>0</span>; i &lt; lvaCount; i++)</td>
      </tr>
      <tr>
        <td id="L294" data-line-number="294"></td>
        <td id="LC294">        {</td>
      </tr>
      <tr>
        <td id="L295" data-line-number="295"></td>
        <td id="LC295">            <span>if</span> ((lvaTable[i].<span>lvType</span> == TYP_STRUCT) &amp;&amp; <span>compStressCompile</span>(STRESS_GENERIC_VARN, <span>60</span>))</td>
      </tr>
      <tr>
        <td id="L296" data-line-number="296"></td>
        <td id="LC296">            {</td>
      </tr>
      <tr>
        <td id="L297" data-line-number="297"></td>
        <td id="LC297">                lvaTable[i].<span>lvIsUnsafeBuffer</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L298" data-line-number="298"></td>
        <td id="LC298">            }</td>
      </tr>
      <tr>
        <td id="L299" data-line-number="299"></td>
        <td id="LC299">        }</td>
      </tr>
      <tr>
        <td id="L300" data-line-number="300"></td>
        <td id="LC300">    }</td>
      </tr>
      <tr>
        <td id="L301" data-line-number="301"></td>
        <td id="LC301">
</td>
      </tr>
      <tr>
        <td id="L302" data-line-number="302"></td>
        <td id="LC302">    <span>if</span> (<span>getNeedsGSSecurityCookie</span>())</td>
      </tr>
      <tr>
        <td id="L303" data-line-number="303"></td>
        <td id="LC303">    {</td>
      </tr>
      <tr>
        <td id="L304" data-line-number="304"></td>
        <td id="LC304">        <span><span>//</span> Ensure that there will be at least one stack variable since</span></td>
      </tr>
      <tr>
        <td id="L305" data-line-number="305"></td>
        <td id="LC305">        <span><span>//</span> we require that the GSCookie does not have a 0 stack offset.</span></td>
      </tr>
      <tr>
        <td id="L306" data-line-number="306"></td>
        <td id="LC306">        <span>unsigned</span> dummy         = <span>lvaGrabTempWithImplicitUse</span>(<span>false</span> <span>DEBUGARG</span>(<span><span>"</span>GSCookie dummy<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L307" data-line-number="307"></td>
        <td id="LC307">        lvaTable[dummy].<span>lvType</span> = TYP_INT;</td>
      </tr>
      <tr>
        <td id="L308" data-line-number="308"></td>
        <td id="LC308">    }</td>
      </tr>
      <tr>
        <td id="L309" data-line-number="309"></td>
        <td id="LC309">
</td>
      </tr>
      <tr>
        <td id="L310" data-line-number="310"></td>
        <td id="LC310">    <span><span>//</span> Allocate the lvaOutgoingArgSpaceVar now because we can run into problems in the</span></td>
      </tr>
      <tr>
        <td id="L311" data-line-number="311"></td>
        <td id="LC311">    <span><span>//</span> emitter when the varNum is greater that 32767 (see emitLclVarAddr::initLclVarAddr)</span></td>
      </tr>
      <tr>
        <td id="L312" data-line-number="312"></td>
        <td id="LC312">    <span>lvaAllocOutgoingArgSpaceVar</span>();</td>
      </tr>
      <tr>
        <td id="L313" data-line-number="313"></td>
        <td id="LC313">
</td>
      </tr>
      <tr>
        <td id="L314" data-line-number="314"></td>
        <td id="LC314">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L315" data-line-number="315"></td>
        <td id="LC315">    <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L316" data-line-number="316"></td>
        <td id="LC316">    {</td>
      </tr>
      <tr>
        <td id="L317" data-line-number="317"></td>
        <td id="LC317">        <span>lvaTableDump</span>(INITIAL_FRAME_LAYOUT);</td>
      </tr>
      <tr>
        <td id="L318" data-line-number="318"></td>
        <td id="LC318">    }</td>
      </tr>
      <tr>
        <td id="L319" data-line-number="319"></td>
        <td id="LC319">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L320" data-line-number="320"></td>
        <td id="LC320">}</td>
      </tr>
      <tr>
        <td id="L321" data-line-number="321"></td>
        <td id="LC321">
</td>
      </tr>
      <tr>
        <td id="L322" data-line-number="322"></td>
        <td id="LC322"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L323" data-line-number="323"></td>
        <td id="LC323"><span>void</span> <span>Compiler::lvaInitArgs</span>(InitVarDscInfo* varDscInfo)</td>
      </tr>
      <tr>
        <td id="L324" data-line-number="324"></td>
        <td id="LC324">{</td>
      </tr>
      <tr>
        <td id="L325" data-line-number="325"></td>
        <td id="LC325">    compArgSize = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L326" data-line-number="326"></td>
        <td id="LC326">
</td>
      </tr>
      <tr>
        <td id="L327" data-line-number="327"></td>
        <td id="LC327">#<span>if</span> defined(TARGET_ARM) &amp;&amp; defined(PROFILING_SUPPORTED)</td>
      </tr>
      <tr>
        <td id="L328" data-line-number="328"></td>
        <td id="LC328">    <span><span>//</span> Prespill all argument regs on to stack in case of Arm when under profiler.</span></td>
      </tr>
      <tr>
        <td id="L329" data-line-number="329"></td>
        <td id="LC329">    <span>if</span> (<span>compIsProfilerHookNeeded</span>())</td>
      </tr>
      <tr>
        <td id="L330" data-line-number="330"></td>
        <td id="LC330">    {</td>
      </tr>
      <tr>
        <td id="L331" data-line-number="331"></td>
        <td id="LC331">        codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegArg</span> |= RBM_ARG_REGS;</td>
      </tr>
      <tr>
        <td id="L332" data-line-number="332"></td>
        <td id="LC332">    }</td>
      </tr>
      <tr>
        <td id="L333" data-line-number="333"></td>
        <td id="LC333">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L334" data-line-number="334"></td>
        <td id="LC334">
</td>
      </tr>
      <tr>
        <td id="L335" data-line-number="335"></td>
        <td id="LC335">    <span><span>//</span>----------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L336" data-line-number="336"></td>
        <td id="LC336">
</td>
      </tr>
      <tr>
        <td id="L337" data-line-number="337"></td>
        <td id="LC337">    <span><span>/*</span> Is there a "this" pointer ? <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L338" data-line-number="338"></td>
        <td id="LC338">    <span>lvaInitThisPtr</span>(varDscInfo);</td>
      </tr>
      <tr>
        <td id="L339" data-line-number="339"></td>
        <td id="LC339">
</td>
      </tr>
      <tr>
        <td id="L340" data-line-number="340"></td>
        <td id="LC340">    <span><span>/*</span> If we have a hidden return-buffer parameter, that comes here <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L341" data-line-number="341"></td>
        <td id="LC341">    <span>lvaInitRetBuffArg</span>(varDscInfo);</td>
      </tr>
      <tr>
        <td id="L342" data-line-number="342"></td>
        <td id="LC342">
</td>
      </tr>
      <tr>
        <td id="L343" data-line-number="343"></td>
        <td id="LC343"><span><span>//</span>======================================================================</span></td>
      </tr>
      <tr>
        <td id="L344" data-line-number="344"></td>
        <td id="LC344">
</td>
      </tr>
      <tr>
        <td id="L345" data-line-number="345"></td>
        <td id="LC345">#<span>if</span> USER_ARGS_COME_LAST</td>
      </tr>
      <tr>
        <td id="L346" data-line-number="346"></td>
        <td id="LC346">    <span><span>//</span>@GENERICS: final instantiation-info argument for shared generic methods</span></td>
      </tr>
      <tr>
        <td id="L347" data-line-number="347"></td>
        <td id="LC347">    <span><span>//</span> and shared generic struct instance methods</span></td>
      </tr>
      <tr>
        <td id="L348" data-line-number="348"></td>
        <td id="LC348">    <span>lvaInitGenericsCtxt</span>(varDscInfo);</td>
      </tr>
      <tr>
        <td id="L349" data-line-number="349"></td>
        <td id="LC349">
</td>
      </tr>
      <tr>
        <td id="L350" data-line-number="350"></td>
        <td id="LC350">    <span><span>/*</span> If the method is varargs, process the varargs cookie <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L351" data-line-number="351"></td>
        <td id="LC351">    <span>lvaInitVarArgsHandle</span>(varDscInfo);</td>
      </tr>
      <tr>
        <td id="L352" data-line-number="352"></td>
        <td id="LC352">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L353" data-line-number="353"></td>
        <td id="LC353">
</td>
      </tr>
      <tr>
        <td id="L354" data-line-number="354"></td>
        <td id="LC354">    <span><span>//</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L355" data-line-number="355"></td>
        <td id="LC355">    <span><span>//</span> Now walk the function signature for the explicit user arguments</span></td>
      </tr>
      <tr>
        <td id="L356" data-line-number="356"></td>
        <td id="LC356">    <span><span>//</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L357" data-line-number="357"></td>
        <td id="LC357">    <span>lvaInitUserArgs</span>(varDscInfo);</td>
      </tr>
      <tr>
        <td id="L358" data-line-number="358"></td>
        <td id="LC358">
</td>
      </tr>
      <tr>
        <td id="L359" data-line-number="359"></td>
        <td id="LC359">#<span>if</span> !USER_ARGS_COME_LAST</td>
      </tr>
      <tr>
        <td id="L360" data-line-number="360"></td>
        <td id="LC360">    <span><span>//</span>@GENERICS: final instantiation-info argument for shared generic methods</span></td>
      </tr>
      <tr>
        <td id="L361" data-line-number="361"></td>
        <td id="LC361">    <span><span>//</span> and shared generic struct instance methods</span></td>
      </tr>
      <tr>
        <td id="L362" data-line-number="362"></td>
        <td id="LC362">    <span>lvaInitGenericsCtxt</span>(varDscInfo);</td>
      </tr>
      <tr>
        <td id="L363" data-line-number="363"></td>
        <td id="LC363">
</td>
      </tr>
      <tr>
        <td id="L364" data-line-number="364"></td>
        <td id="LC364">    <span><span>/*</span> If the method is varargs, process the varargs cookie <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L365" data-line-number="365"></td>
        <td id="LC365">    <span>lvaInitVarArgsHandle</span>(varDscInfo);</td>
      </tr>
      <tr>
        <td id="L366" data-line-number="366"></td>
        <td id="LC366">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L367" data-line-number="367"></td>
        <td id="LC367">
</td>
      </tr>
      <tr>
        <td id="L368" data-line-number="368"></td>
        <td id="LC368">    <span><span>//</span>----------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L369" data-line-number="369"></td>
        <td id="LC369">
</td>
      </tr>
      <tr>
        <td id="L370" data-line-number="370"></td>
        <td id="LC370">    <span><span>//</span> We have set info.compArgsCount in compCompile()</span></td>
      </tr>
      <tr>
        <td id="L371" data-line-number="371"></td>
        <td id="LC371">    <span>noway_assert</span>(varDscInfo-&gt;<span>varNum</span> == info.<span>compArgsCount</span>);</td>
      </tr>
      <tr>
        <td id="L372" data-line-number="372"></td>
        <td id="LC372">    <span>assert</span>(varDscInfo-&gt;<span>intRegArgNum</span> &lt;= MAX_REG_ARG);</td>
      </tr>
      <tr>
        <td id="L373" data-line-number="373"></td>
        <td id="LC373">
</td>
      </tr>
      <tr>
        <td id="L374" data-line-number="374"></td>
        <td id="LC374">    codeGen-&gt;<span>intRegState</span>.<span>rsCalleeRegArgCount</span>   = varDscInfo-&gt;<span>intRegArgNum</span>;</td>
      </tr>
      <tr>
        <td id="L375" data-line-number="375"></td>
        <td id="LC375">    codeGen-&gt;<span>floatRegState</span>.<span>rsCalleeRegArgCount</span> = varDscInfo-&gt;<span>floatRegArgNum</span>;</td>
      </tr>
      <tr>
        <td id="L376" data-line-number="376"></td>
        <td id="LC376">
</td>
      </tr>
      <tr>
        <td id="L377" data-line-number="377"></td>
        <td id="LC377">#<span>if</span> FEATURE_FASTTAILCALL</td>
      </tr>
      <tr>
        <td id="L378" data-line-number="378"></td>
        <td id="LC378">    <span><span>//</span> Save the stack usage information</span></td>
      </tr>
      <tr>
        <td id="L379" data-line-number="379"></td>
        <td id="LC379">    <span><span>//</span> We can get register usage information using codeGen-&gt;intRegState and</span></td>
      </tr>
      <tr>
        <td id="L380" data-line-number="380"></td>
        <td id="LC380">    <span><span>//</span> codeGen-&gt;floatRegState</span></td>
      </tr>
      <tr>
        <td id="L381" data-line-number="381"></td>
        <td id="LC381">    info.<span>compArgStackSize</span> = varDscInfo-&gt;<span>stackArgSize</span>;</td>
      </tr>
      <tr>
        <td id="L382" data-line-number="382"></td>
        <td id="LC382">#<span>endif</span> <span><span>//</span> FEATURE_FASTTAILCALL</span></td>
      </tr>
      <tr>
        <td id="L383" data-line-number="383"></td>
        <td id="LC383">
</td>
      </tr>
      <tr>
        <td id="L384" data-line-number="384"></td>
        <td id="LC384">    <span><span>//</span> The total argument size must be aligned.</span></td>
      </tr>
      <tr>
        <td id="L385" data-line-number="385"></td>
        <td id="LC385">    <span>noway_assert</span>((compArgSize % TARGET_POINTER_SIZE) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L386" data-line-number="386"></td>
        <td id="LC386">
</td>
      </tr>
      <tr>
        <td id="L387" data-line-number="387"></td>
        <td id="LC387">#<span>ifdef</span> TARGET_X86</td>
      </tr>
      <tr>
        <td id="L388" data-line-number="388"></td>
        <td id="LC388">    <span><span>/*</span> We can not pass more than 2^16 dwords as arguments as the "ret"</span></td>
      </tr>
      <tr>
        <td id="L389" data-line-number="389"></td>
        <td id="LC389"><span>       instruction can only pop 2^16 arguments. Could be handled correctly</span></td>
      </tr>
      <tr>
        <td id="L390" data-line-number="390"></td>
        <td id="LC390"><span>       but it will be very difficult for fully interruptible code <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L391" data-line-number="391"></td>
        <td id="LC391">
</td>
      </tr>
      <tr>
        <td id="L392" data-line-number="392"></td>
        <td id="LC392">    <span>if</span> (compArgSize != (<span>size_t</span>)(<span>unsigned</span> <span>short</span>)compArgSize)</td>
      </tr>
      <tr>
        <td id="L393" data-line-number="393"></td>
        <td id="LC393">        <span>NO_WAY</span>(<span><span>"</span>Too many arguments for the <span>\"</span>ret<span>\"</span> instruction to pop<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L394" data-line-number="394"></td>
        <td id="LC394">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L395" data-line-number="395"></td>
        <td id="LC395">}</td>
      </tr>
      <tr>
        <td id="L396" data-line-number="396"></td>
        <td id="LC396">
</td>
      </tr>
      <tr>
        <td id="L397" data-line-number="397"></td>
        <td id="LC397"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L398" data-line-number="398"></td>
        <td id="LC398"><span>void</span> <span>Compiler::lvaInitThisPtr</span>(InitVarDscInfo* varDscInfo)</td>
      </tr>
      <tr>
        <td id="L399" data-line-number="399"></td>
        <td id="LC399">{</td>
      </tr>
      <tr>
        <td id="L400" data-line-number="400"></td>
        <td id="LC400">    LclVarDsc* varDsc = varDscInfo-&gt;<span>varDsc</span>;</td>
      </tr>
      <tr>
        <td id="L401" data-line-number="401"></td>
        <td id="LC401">    <span>if</span> (!info.<span>compIsStatic</span>)</td>
      </tr>
      <tr>
        <td id="L402" data-line-number="402"></td>
        <td id="LC402">    {</td>
      </tr>
      <tr>
        <td id="L403" data-line-number="403"></td>
        <td id="LC403">        varDsc-&gt;<span>lvIsParam</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L404" data-line-number="404"></td>
        <td id="LC404">        varDsc-&gt;<span>lvIsPtr</span>   = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L405" data-line-number="405"></td>
        <td id="LC405">
</td>
      </tr>
      <tr>
        <td id="L406" data-line-number="406"></td>
        <td id="LC406">        lvaArg0Var = info.<span>compThisArg</span> = varDscInfo-&gt;<span>varNum</span>;</td>
      </tr>
      <tr>
        <td id="L407" data-line-number="407"></td>
        <td id="LC407">        <span>noway_assert</span>(info.<span>compThisArg</span> == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L408" data-line-number="408"></td>
        <td id="LC408">
</td>
      </tr>
      <tr>
        <td id="L409" data-line-number="409"></td>
        <td id="LC409">        <span>if</span> (<span>eeIsValueClass</span>(info.<span>compClassHnd</span>))</td>
      </tr>
      <tr>
        <td id="L410" data-line-number="410"></td>
        <td id="LC410">        {</td>
      </tr>
      <tr>
        <td id="L411" data-line-number="411"></td>
        <td id="LC411">            varDsc-&gt;<span>lvType</span> = TYP_BYREF;</td>
      </tr>
      <tr>
        <td id="L412" data-line-number="412"></td>
        <td id="LC412">#<span>ifdef</span> FEATURE_SIMD</td>
      </tr>
      <tr>
        <td id="L413" data-line-number="413"></td>
        <td id="LC413">            <span>if</span> (<span>supportSIMDTypes</span>())</td>
      </tr>
      <tr>
        <td id="L414" data-line-number="414"></td>
        <td id="LC414">            {</td>
      </tr>
      <tr>
        <td id="L415" data-line-number="415"></td>
        <td id="LC415">                var_types simdBaseType = TYP_UNKNOWN;</td>
      </tr>
      <tr>
        <td id="L416" data-line-number="416"></td>
        <td id="LC416">                var_types type         = <span>impNormStructType</span>(info.<span>compClassHnd</span>, &amp;simdBaseType);</td>
      </tr>
      <tr>
        <td id="L417" data-line-number="417"></td>
        <td id="LC417">                <span>if</span> (simdBaseType != TYP_UNKNOWN)</td>
      </tr>
      <tr>
        <td id="L418" data-line-number="418"></td>
        <td id="LC418">                {</td>
      </tr>
      <tr>
        <td id="L419" data-line-number="419"></td>
        <td id="LC419">                    <span>assert</span>(<span>varTypeIsSIMD</span>(type));</td>
      </tr>
      <tr>
        <td id="L420" data-line-number="420"></td>
        <td id="LC420">                    varDsc-&gt;<span>lvSIMDType</span>  = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L421" data-line-number="421"></td>
        <td id="LC421">                    varDsc-&gt;<span>lvBaseType</span>  = simdBaseType;</td>
      </tr>
      <tr>
        <td id="L422" data-line-number="422"></td>
        <td id="LC422">                    varDsc-&gt;<span>lvExactSize</span> = <span>genTypeSize</span>(type);</td>
      </tr>
      <tr>
        <td id="L423" data-line-number="423"></td>
        <td id="LC423">                }</td>
      </tr>
      <tr>
        <td id="L424" data-line-number="424"></td>
        <td id="LC424">            }</td>
      </tr>
      <tr>
        <td id="L425" data-line-number="425"></td>
        <td id="LC425">#<span>endif</span> <span><span>//</span> FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L426" data-line-number="426"></td>
        <td id="LC426">        }</td>
      </tr>
      <tr>
        <td id="L427" data-line-number="427"></td>
        <td id="LC427">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L428" data-line-number="428"></td>
        <td id="LC428">        {</td>
      </tr>
      <tr>
        <td id="L429" data-line-number="429"></td>
        <td id="LC429">            varDsc-&gt;<span>lvType</span> = TYP_REF;</td>
      </tr>
      <tr>
        <td id="L430" data-line-number="430"></td>
        <td id="LC430">            <span>lvaSetClass</span>(varDscInfo-&gt;<span>varNum</span>, info.<span>compClassHnd</span>);</td>
      </tr>
      <tr>
        <td id="L431" data-line-number="431"></td>
        <td id="LC431">        }</td>
      </tr>
      <tr>
        <td id="L432" data-line-number="432"></td>
        <td id="LC432">
</td>
      </tr>
      <tr>
        <td id="L433" data-line-number="433"></td>
        <td id="LC433">        <span>if</span> (tiVerificationNeeded)</td>
      </tr>
      <tr>
        <td id="L434" data-line-number="434"></td>
        <td id="LC434">        {</td>
      </tr>
      <tr>
        <td id="L435" data-line-number="435"></td>
        <td id="LC435">            varDsc-&gt;<span>lvVerTypeInfo</span> = <span>verMakeTypeInfo</span>(info.<span>compClassHnd</span>);</td>
      </tr>
      <tr>
        <td id="L436" data-line-number="436"></td>
        <td id="LC436">
</td>
      </tr>
      <tr>
        <td id="L437" data-line-number="437"></td>
        <td id="LC437">            <span>if</span> (varDsc-&gt;<span>lvVerTypeInfo</span>.<span>IsValueClass</span>())</td>
      </tr>
      <tr>
        <td id="L438" data-line-number="438"></td>
        <td id="LC438">            {</td>
      </tr>
      <tr>
        <td id="L439" data-line-number="439"></td>
        <td id="LC439">                varDsc-&gt;<span>lvVerTypeInfo</span>.<span>MakeByRef</span>();</td>
      </tr>
      <tr>
        <td id="L440" data-line-number="440"></td>
        <td id="LC440">            }</td>
      </tr>
      <tr>
        <td id="L441" data-line-number="441"></td>
        <td id="LC441">        }</td>
      </tr>
      <tr>
        <td id="L442" data-line-number="442"></td>
        <td id="LC442">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L443" data-line-number="443"></td>
        <td id="LC443">        {</td>
      </tr>
      <tr>
        <td id="L444" data-line-number="444"></td>
        <td id="LC444">            varDsc-&gt;<span>lvVerTypeInfo</span> = <span>typeInfo</span>();</td>
      </tr>
      <tr>
        <td id="L445" data-line-number="445"></td>
        <td id="LC445">        }</td>
      </tr>
      <tr>
        <td id="L446" data-line-number="446"></td>
        <td id="LC446">
</td>
      </tr>
      <tr>
        <td id="L447" data-line-number="447"></td>
        <td id="LC447">        <span><span>//</span> Mark the 'this' pointer for the method</span></td>
      </tr>
      <tr>
        <td id="L448" data-line-number="448"></td>
        <td id="LC448">        varDsc-&gt;<span>lvVerTypeInfo</span>.<span>SetIsThisPtr</span>();</td>
      </tr>
      <tr>
        <td id="L449" data-line-number="449"></td>
        <td id="LC449">
</td>
      </tr>
      <tr>
        <td id="L450" data-line-number="450"></td>
        <td id="LC450">        varDsc-&gt;<span>lvIsRegArg</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L451" data-line-number="451"></td>
        <td id="LC451">        <span>noway_assert</span>(varDscInfo-&gt;<span>intRegArgNum</span> == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L452" data-line-number="452"></td>
        <td id="LC452">
</td>
      </tr>
      <tr>
        <td id="L453" data-line-number="453"></td>
        <td id="LC453">        varDsc-&gt;<span>SetArgReg</span>(<span>genMapRegArgNumToRegNum</span>(varDscInfo-&gt;<span>allocRegArg</span>(TYP_INT), varDsc-&gt;<span>TypeGet</span>()));</td>
      </tr>
      <tr>
        <td id="L454" data-line-number="454"></td>
        <td id="LC454">#<span>if</span> FEATURE_MULTIREG_ARGS</td>
      </tr>
      <tr>
        <td id="L455" data-line-number="455"></td>
        <td id="LC455">        varDsc-&gt;<span>SetOtherArgReg</span>(REG_NA);</td>
      </tr>
      <tr>
        <td id="L456" data-line-number="456"></td>
        <td id="LC456">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L457" data-line-number="457"></td>
        <td id="LC457">        varDsc-&gt;<span>lvOnFrame</span> = <span>true</span>; <span><span>//</span> The final home for this incoming register might be our local stack frame</span></td>
      </tr>
      <tr>
        <td id="L458" data-line-number="458"></td>
        <td id="LC458">
</td>
      </tr>
      <tr>
        <td id="L459" data-line-number="459"></td>
        <td id="LC459">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L460" data-line-number="460"></td>
        <td id="LC460">        <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L461" data-line-number="461"></td>
        <td id="LC461">        {</td>
      </tr>
      <tr>
        <td id="L462" data-line-number="462"></td>
        <td id="LC462">            <span>printf</span>(<span><span>"</span>'this'    passed in register %s<span>\n</span><span>"</span></span>, <span>getRegName</span>(varDsc-&gt;<span>GetArgReg</span>()));</td>
      </tr>
      <tr>
        <td id="L463" data-line-number="463"></td>
        <td id="LC463">        }</td>
      </tr>
      <tr>
        <td id="L464" data-line-number="464"></td>
        <td id="LC464">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L465" data-line-number="465"></td>
        <td id="LC465">        compArgSize += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L466" data-line-number="466"></td>
        <td id="LC466">
</td>
      </tr>
      <tr>
        <td id="L467" data-line-number="467"></td>
        <td id="LC467">        varDscInfo-&gt;<span>varNum</span>++;</td>
      </tr>
      <tr>
        <td id="L468" data-line-number="468"></td>
        <td id="LC468">        varDscInfo-&gt;<span>varDsc</span>++;</td>
      </tr>
      <tr>
        <td id="L469" data-line-number="469"></td>
        <td id="LC469">    }</td>
      </tr>
      <tr>
        <td id="L470" data-line-number="470"></td>
        <td id="LC470">}</td>
      </tr>
      <tr>
        <td id="L471" data-line-number="471"></td>
        <td id="LC471">
</td>
      </tr>
      <tr>
        <td id="L472" data-line-number="472"></td>
        <td id="LC472"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L473" data-line-number="473"></td>
        <td id="LC473"><span>void</span> <span>Compiler::lvaInitRetBuffArg</span>(InitVarDscInfo* varDscInfo)</td>
      </tr>
      <tr>
        <td id="L474" data-line-number="474"></td>
        <td id="LC474">{</td>
      </tr>
      <tr>
        <td id="L475" data-line-number="475"></td>
        <td id="LC475">    LclVarDsc* varDsc        = varDscInfo-&gt;<span>varDsc</span>;</td>
      </tr>
      <tr>
        <td id="L476" data-line-number="476"></td>
        <td id="LC476">    <span>bool</span>       hasRetBuffArg = <span>impMethodInfo_hasRetBuffArg</span>(info.<span>compMethodInfo</span>);</td>
      </tr>
      <tr>
        <td id="L477" data-line-number="477"></td>
        <td id="LC477">
</td>
      </tr>
      <tr>
        <td id="L478" data-line-number="478"></td>
        <td id="LC478">    <span><span>//</span> These two should always match</span></td>
      </tr>
      <tr>
        <td id="L479" data-line-number="479"></td>
        <td id="LC479">    <span>noway_assert</span>(hasRetBuffArg == varDscInfo-&gt;<span>hasRetBufArg</span>);</td>
      </tr>
      <tr>
        <td id="L480" data-line-number="480"></td>
        <td id="LC480">
</td>
      </tr>
      <tr>
        <td id="L481" data-line-number="481"></td>
        <td id="LC481">    <span>if</span> (hasRetBuffArg)</td>
      </tr>
      <tr>
        <td id="L482" data-line-number="482"></td>
        <td id="LC482">    {</td>
      </tr>
      <tr>
        <td id="L483" data-line-number="483"></td>
        <td id="LC483">        info.<span>compRetBuffArg</span> = varDscInfo-&gt;<span>varNum</span>;</td>
      </tr>
      <tr>
        <td id="L484" data-line-number="484"></td>
        <td id="LC484">        varDsc-&gt;<span>lvType</span>      = TYP_BYREF;</td>
      </tr>
      <tr>
        <td id="L485" data-line-number="485"></td>
        <td id="LC485">        varDsc-&gt;<span>lvIsParam</span>   = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L486" data-line-number="486"></td>
        <td id="LC486">        varDsc-&gt;<span>lvIsRegArg</span>  = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L487" data-line-number="487"></td>
        <td id="LC487">
</td>
      </tr>
      <tr>
        <td id="L488" data-line-number="488"></td>
        <td id="LC488">        <span>if</span> (<span>hasFixedRetBuffReg</span>())</td>
      </tr>
      <tr>
        <td id="L489" data-line-number="489"></td>
        <td id="LC489">        {</td>
      </tr>
      <tr>
        <td id="L490" data-line-number="490"></td>
        <td id="LC490">            varDsc-&gt;<span>SetArgReg</span>(<span>theFixedRetBuffReg</span>());</td>
      </tr>
      <tr>
        <td id="L491" data-line-number="491"></td>
        <td id="LC491">        }</td>
      </tr>
      <tr>
        <td id="L492" data-line-number="492"></td>
        <td id="LC492">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L493" data-line-number="493"></td>
        <td id="LC493">        {</td>
      </tr>
      <tr>
        <td id="L494" data-line-number="494"></td>
        <td id="LC494">            <span>unsigned</span> retBuffArgNum = varDscInfo-&gt;<span>allocRegArg</span>(TYP_INT);</td>
      </tr>
      <tr>
        <td id="L495" data-line-number="495"></td>
        <td id="LC495">            varDsc-&gt;<span>SetArgReg</span>(<span>genMapIntRegArgNumToRegNum</span>(retBuffArgNum));</td>
      </tr>
      <tr>
        <td id="L496" data-line-number="496"></td>
        <td id="LC496">        }</td>
      </tr>
      <tr>
        <td id="L497" data-line-number="497"></td>
        <td id="LC497">
</td>
      </tr>
      <tr>
        <td id="L498" data-line-number="498"></td>
        <td id="LC498">#<span>if</span> FEATURE_MULTIREG_ARGS</td>
      </tr>
      <tr>
        <td id="L499" data-line-number="499"></td>
        <td id="LC499">        varDsc-&gt;<span>SetOtherArgReg</span>(REG_NA);</td>
      </tr>
      <tr>
        <td id="L500" data-line-number="500"></td>
        <td id="LC500">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L501" data-line-number="501"></td>
        <td id="LC501">        varDsc-&gt;<span>lvOnFrame</span> = <span>true</span>; <span><span>//</span> The final home for this incoming register might be our local stack frame</span></td>
      </tr>
      <tr>
        <td id="L502" data-line-number="502"></td>
        <td id="LC502">
</td>
      </tr>
      <tr>
        <td id="L503" data-line-number="503"></td>
        <td id="LC503">        info.<span>compRetBuffDefStack</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L504" data-line-number="504"></td>
        <td id="LC504">        <span>if</span> (info.<span>compRetType</span> == TYP_STRUCT)</td>
      </tr>
      <tr>
        <td id="L505" data-line-number="505"></td>
        <td id="LC505">        {</td>
      </tr>
      <tr>
        <td id="L506" data-line-number="506"></td>
        <td id="LC506">            CORINFO_SIG_INFO sigInfo;</td>
      </tr>
      <tr>
        <td id="L507" data-line-number="507"></td>
        <td id="LC507">            info.<span>compCompHnd</span>-&gt;<span>getMethodSig</span>(info.<span>compMethodHnd</span>, &amp;sigInfo);</td>
      </tr>
      <tr>
        <td id="L508" data-line-number="508"></td>
        <td id="LC508">            <span>assert</span>(<span>JITtype2varType</span>(sigInfo.<span>retType</span>) == info.<span>compRetType</span>); <span><span>//</span> Else shouldn't have a ret buff.</span></td>
      </tr>
      <tr>
        <td id="L509" data-line-number="509"></td>
        <td id="LC509">
</td>
      </tr>
      <tr>
        <td id="L510" data-line-number="510"></td>
        <td id="LC510">            info.<span>compRetBuffDefStack</span> =</td>
      </tr>
      <tr>
        <td id="L511" data-line-number="511"></td>
        <td id="LC511">                (info.<span>compCompHnd</span>-&gt;<span>isStructRequiringStackAllocRetBuf</span>(sigInfo.<span>retTypeClass</span>) == <span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L512" data-line-number="512"></td>
        <td id="LC512">            <span>if</span> (info.<span>compRetBuffDefStack</span>)</td>
      </tr>
      <tr>
        <td id="L513" data-line-number="513"></td>
        <td id="LC513">            {</td>
      </tr>
      <tr>
        <td id="L514" data-line-number="514"></td>
        <td id="LC514">                <span><span>//</span> If we're assured that the ret buff argument points into a callers stack, we will type it as</span></td>
      </tr>
      <tr>
        <td id="L515" data-line-number="515"></td>
        <td id="LC515">                <span><span>//</span> "TYP_I_IMPL"</span></td>
      </tr>
      <tr>
        <td id="L516" data-line-number="516"></td>
        <td id="LC516">                <span><span>//</span> (native int/unmanaged pointer) so that it's not tracked as a GC ref.</span></td>
      </tr>
      <tr>
        <td id="L517" data-line-number="517"></td>
        <td id="LC517">                varDsc-&gt;<span>lvType</span> = TYP_I_IMPL;</td>
      </tr>
      <tr>
        <td id="L518" data-line-number="518"></td>
        <td id="LC518">            }</td>
      </tr>
      <tr>
        <td id="L519" data-line-number="519"></td>
        <td id="LC519">        }</td>
      </tr>
      <tr>
        <td id="L520" data-line-number="520"></td>
        <td id="LC520">#<span>ifdef</span> FEATURE_SIMD</td>
      </tr>
      <tr>
        <td id="L521" data-line-number="521"></td>
        <td id="LC521">        <span>else</span> <span>if</span> (<span>supportSIMDTypes</span>() &amp;&amp; <span>varTypeIsSIMD</span>(info.<span>compRetType</span>))</td>
      </tr>
      <tr>
        <td id="L522" data-line-number="522"></td>
        <td id="LC522">        {</td>
      </tr>
      <tr>
        <td id="L523" data-line-number="523"></td>
        <td id="LC523">            varDsc-&gt;<span>lvSIMDType</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L524" data-line-number="524"></td>
        <td id="LC524">            varDsc-&gt;<span>lvBaseType</span> =</td>
      </tr>
      <tr>
        <td id="L525" data-line-number="525"></td>
        <td id="LC525">                <span>getBaseTypeAndSizeOfSIMDType</span>(info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>retTypeClass</span>, &amp;varDsc-&gt;<span>lvExactSize</span>);</td>
      </tr>
      <tr>
        <td id="L526" data-line-number="526"></td>
        <td id="LC526">            <span>assert</span>(varDsc-&gt;<span>lvBaseType</span> != TYP_UNKNOWN);</td>
      </tr>
      <tr>
        <td id="L527" data-line-number="527"></td>
        <td id="LC527">        }</td>
      </tr>
      <tr>
        <td id="L528" data-line-number="528"></td>
        <td id="LC528">#<span>endif</span> <span><span>//</span> FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L529" data-line-number="529"></td>
        <td id="LC529">
</td>
      </tr>
      <tr>
        <td id="L530" data-line-number="530"></td>
        <td id="LC530">        <span>assert</span>(<span>isValidIntArgReg</span>(varDsc-&gt;<span>GetArgReg</span>()));</td>
      </tr>
      <tr>
        <td id="L531" data-line-number="531"></td>
        <td id="LC531">
</td>
      </tr>
      <tr>
        <td id="L532" data-line-number="532"></td>
        <td id="LC532">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L533" data-line-number="533"></td>
        <td id="LC533">        <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L534" data-line-number="534"></td>
        <td id="LC534">        {</td>
      </tr>
      <tr>
        <td id="L535" data-line-number="535"></td>
        <td id="LC535">            <span>printf</span>(<span><span>"</span>'__retBuf'  passed in register %s<span>\n</span><span>"</span></span>, <span>getRegName</span>(varDsc-&gt;<span>GetArgReg</span>()));</td>
      </tr>
      <tr>
        <td id="L536" data-line-number="536"></td>
        <td id="LC536">        }</td>
      </tr>
      <tr>
        <td id="L537" data-line-number="537"></td>
        <td id="LC537">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L538" data-line-number="538"></td>
        <td id="LC538">
</td>
      </tr>
      <tr>
        <td id="L539" data-line-number="539"></td>
        <td id="LC539">        <span><span>/*</span> Update the total argument size, count and varDsc <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L540" data-line-number="540"></td>
        <td id="LC540">
</td>
      </tr>
      <tr>
        <td id="L541" data-line-number="541"></td>
        <td id="LC541">        compArgSize += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L542" data-line-number="542"></td>
        <td id="LC542">        varDscInfo-&gt;<span>varNum</span>++;</td>
      </tr>
      <tr>
        <td id="L543" data-line-number="543"></td>
        <td id="LC543">        varDscInfo-&gt;<span>varDsc</span>++;</td>
      </tr>
      <tr>
        <td id="L544" data-line-number="544"></td>
        <td id="LC544">    }</td>
      </tr>
      <tr>
        <td id="L545" data-line-number="545"></td>
        <td id="LC545">}</td>
      </tr>
      <tr>
        <td id="L546" data-line-number="546"></td>
        <td id="LC546">
</td>
      </tr>
      <tr>
        <td id="L547" data-line-number="547"></td>
        <td id="LC547"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L548" data-line-number="548"></td>
        <td id="LC548"><span>void</span> <span>Compiler::lvaInitUserArgs</span>(InitVarDscInfo* varDscInfo)</td>
      </tr>
      <tr>
        <td id="L549" data-line-number="549"></td>
        <td id="LC549">{</td>
      </tr>
      <tr>
        <td id="L550" data-line-number="550"></td>
        <td id="LC550"><span><span>//</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L551" data-line-number="551"></td>
        <td id="LC551"><span><span>//</span> Walk the function signature for the explicit arguments</span></td>
      </tr>
      <tr>
        <td id="L552" data-line-number="552"></td>
        <td id="LC552"><span><span>//</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L553" data-line-number="553"></td>
        <td id="LC553">
</td>
      </tr>
      <tr>
        <td id="L554" data-line-number="554"></td>
        <td id="LC554">#<span>if</span> defined(TARGET_X86)</td>
      </tr>
      <tr>
        <td id="L555" data-line-number="555"></td>
        <td id="LC555">    <span><span>//</span> Only (some of) the implicit args are enregistered for varargs</span></td>
      </tr>
      <tr>
        <td id="L556" data-line-number="556"></td>
        <td id="LC556">    varDscInfo-&gt;<span>maxIntRegArgNum</span> = info.<span>compIsVarArgs</span> ? varDscInfo-&gt;<span>intRegArgNum</span> : MAX_REG_ARG;</td>
      </tr>
      <tr>
        <td id="L557" data-line-number="557"></td>
        <td id="LC557">#<span>elif</span> defined(TARGET_AMD64) &amp;&amp; !defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L558" data-line-number="558"></td>
        <td id="LC558">    <span><span>//</span> On System V type environment the float registers are not indexed together with the int ones.</span></td>
      </tr>
      <tr>
        <td id="L559" data-line-number="559"></td>
        <td id="LC559">    varDscInfo-&gt;<span>floatRegArgNum</span> = varDscInfo-&gt;<span>intRegArgNum</span>;</td>
      </tr>
      <tr>
        <td id="L560" data-line-number="560"></td>
        <td id="LC560">#<span>endif</span> <span><span>//</span> _TARGET_*</span></td>
      </tr>
      <tr>
        <td id="L561" data-line-number="561"></td>
        <td id="LC561">
</td>
      </tr>
      <tr>
        <td id="L562" data-line-number="562"></td>
        <td id="LC562">    CORINFO_ARG_LIST_HANDLE argLst = info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>args</span>;</td>
      </tr>
      <tr>
        <td id="L563" data-line-number="563"></td>
        <td id="LC563">
</td>
      </tr>
      <tr>
        <td id="L564" data-line-number="564"></td>
        <td id="LC564">    <span>const</span> <span>unsigned</span> argSigLen = info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>numArgs</span>;</td>
      </tr>
      <tr>
        <td id="L565" data-line-number="565"></td>
        <td id="LC565">
</td>
      </tr>
      <tr>
        <td id="L566" data-line-number="566"></td>
        <td id="LC566">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L567" data-line-number="567"></td>
        <td id="LC567">    regMaskTP doubleAlignMask = RBM_NONE;</td>
      </tr>
      <tr>
        <td id="L568" data-line-number="568"></td>
        <td id="LC568">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L569" data-line-number="569"></td>
        <td id="LC569">
</td>
      </tr>
      <tr>
        <td id="L570" data-line-number="570"></td>
        <td id="LC570">    <span>for</span> (<span>unsigned</span> i = <span>0</span>; i &lt; argSigLen;</td>
      </tr>
      <tr>
        <td id="L571" data-line-number="571"></td>
        <td id="LC571">         i++, varDscInfo-&gt;<span>varNum</span>++, varDscInfo-&gt;<span>varDsc</span>++, argLst = info.<span>compCompHnd</span>-&gt;<span>getArgNext</span>(argLst))</td>
      </tr>
      <tr>
        <td id="L572" data-line-number="572"></td>
        <td id="LC572">    {</td>
      </tr>
      <tr>
        <td id="L573" data-line-number="573"></td>
        <td id="LC573">        LclVarDsc*           varDsc  = varDscInfo-&gt;<span>varDsc</span>;</td>
      </tr>
      <tr>
        <td id="L574" data-line-number="574"></td>
        <td id="LC574">        CORINFO_CLASS_HANDLE typeHnd = <span>nullptr</span>;</td>
      </tr>
      <tr>
        <td id="L575" data-line-number="575"></td>
        <td id="LC575">
</td>
      </tr>
      <tr>
        <td id="L576" data-line-number="576"></td>
        <td id="LC576">        CorInfoTypeWithMod corInfoType = info.<span>compCompHnd</span>-&gt;<span>getArgType</span>(&amp;info.<span>compMethodInfo</span>-&gt;<span>args</span>, argLst, &amp;typeHnd);</td>
      </tr>
      <tr>
        <td id="L577" data-line-number="577"></td>
        <td id="LC577">        varDsc-&gt;<span>lvIsParam</span>              = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L578" data-line-number="578"></td>
        <td id="LC578">
</td>
      </tr>
      <tr>
        <td id="L579" data-line-number="579"></td>
        <td id="LC579">        <span>lvaInitVarDsc</span>(varDsc, varDscInfo-&gt;<span>varNum</span>, <span>strip</span>(corInfoType), typeHnd, argLst, &amp;info.<span>compMethodInfo</span>-&gt;<span>args</span>);</td>
      </tr>
      <tr>
        <td id="L580" data-line-number="580"></td>
        <td id="LC580">
</td>
      </tr>
      <tr>
        <td id="L581" data-line-number="581"></td>
        <td id="LC581">        <span>if</span> (<span>strip</span>(corInfoType) == CORINFO_TYPE_CLASS)</td>
      </tr>
      <tr>
        <td id="L582" data-line-number="582"></td>
        <td id="LC582">        {</td>
      </tr>
      <tr>
        <td id="L583" data-line-number="583"></td>
        <td id="LC583">            CORINFO_CLASS_HANDLE clsHnd = info.<span>compCompHnd</span>-&gt;<span>getArgClass</span>(&amp;info.<span>compMethodInfo</span>-&gt;<span>args</span>, argLst);</td>
      </tr>
      <tr>
        <td id="L584" data-line-number="584"></td>
        <td id="LC584">            <span>lvaSetClass</span>(varDscInfo-&gt;<span>varNum</span>, clsHnd);</td>
      </tr>
      <tr>
        <td id="L585" data-line-number="585"></td>
        <td id="LC585">        }</td>
      </tr>
      <tr>
        <td id="L586" data-line-number="586"></td>
        <td id="LC586">
</td>
      </tr>
      <tr>
        <td id="L587" data-line-number="587"></td>
        <td id="LC587">        <span><span>//</span> For ARM, ARM64, and AMD64 varargs, all arguments go in integer registers</span></td>
      </tr>
      <tr>
        <td id="L588" data-line-number="588"></td>
        <td id="LC588">        var_types argType = <span>mangleVarArgsType</span>(varDsc-&gt;<span>TypeGet</span>());</td>
      </tr>
      <tr>
        <td id="L589" data-line-number="589"></td>
        <td id="LC589">
</td>
      </tr>
      <tr>
        <td id="L590" data-line-number="590"></td>
        <td id="LC590">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L591" data-line-number="591"></td>
        <td id="LC591">        var_types origArgType = argType;</td>
      </tr>
      <tr>
        <td id="L592" data-line-number="592"></td>
        <td id="LC592">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L593" data-line-number="593"></td>
        <td id="LC593">
</td>
      </tr>
      <tr>
        <td id="L594" data-line-number="594"></td>
        <td id="LC594">        <span><span>//</span> ARM softfp calling convention should affect only the floating point arguments.</span></td>
      </tr>
      <tr>
        <td id="L595" data-line-number="595"></td>
        <td id="LC595">        <span><span>//</span> Otherwise there appear too many surplus pre-spills and other memory operations</span></td>
      </tr>
      <tr>
        <td id="L596" data-line-number="596"></td>
        <td id="LC596">        <span><span>//</span> with the associated locations .</span></td>
      </tr>
      <tr>
        <td id="L597" data-line-number="597"></td>
        <td id="LC597">        <span>bool</span>      isSoftFPPreSpill = opts.<span>compUseSoftFP</span> &amp;&amp; <span>varTypeIsFloating</span>(varDsc-&gt;<span>TypeGet</span>());</td>
      </tr>
      <tr>
        <td id="L598" data-line-number="598"></td>
        <td id="LC598">        <span>unsigned</span>  argSize          = <span>eeGetArgSize</span>(argLst, &amp;info.<span>compMethodInfo</span>-&gt;<span>args</span>);</td>
      </tr>
      <tr>
        <td id="L599" data-line-number="599"></td>
        <td id="LC599">        <span>unsigned</span>  cSlots           = argSize / TARGET_POINTER_SIZE; <span><span>//</span> the total number of slots of this argument</span></td>
      </tr>
      <tr>
        <td id="L600" data-line-number="600"></td>
        <td id="LC600">        <span>bool</span>      isHfaArg         = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L601" data-line-number="601"></td>
        <td id="LC601">        var_types hfaType          = TYP_UNDEF;</td>
      </tr>
      <tr>
        <td id="L602" data-line-number="602"></td>
        <td id="LC602">
</td>
      </tr>
      <tr>
        <td id="L603" data-line-number="603"></td>
        <td id="LC603">#<span>if</span> defined(TARGET_ARM64) &amp;&amp; defined(TARGET_UNIX)</td>
      </tr>
      <tr>
        <td id="L604" data-line-number="604"></td>
        <td id="LC604">        <span><span>//</span> Native varargs on arm64 unix use the regular calling convention.</span></td>
      </tr>
      <tr>
        <td id="L605" data-line-number="605"></td>
        <td id="LC605">        <span>if</span> (!opts.<span>compUseSoftFP</span>)</td>
      </tr>
      <tr>
        <td id="L606" data-line-number="606"></td>
        <td id="LC606">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L607" data-line-number="607"></td>
        <td id="LC607">        <span><span>//</span> Methods that use VarArg or SoftFP cannot have HFA arguments</span></td>
      </tr>
      <tr>
        <td id="L608" data-line-number="608"></td>
        <td id="LC608">        <span>if</span> (!info.<span>compIsVarArgs</span> &amp;&amp; !opts.<span>compUseSoftFP</span>)</td>
      </tr>
      <tr>
        <td id="L609" data-line-number="609"></td>
        <td id="LC609">#<span>endif</span> <span><span>//</span> defined(TARGET_ARM64) &amp;&amp; defined(TARGET_UNIX)</span></td>
      </tr>
      <tr>
        <td id="L610" data-line-number="610"></td>
        <td id="LC610">        {</td>
      </tr>
      <tr>
        <td id="L611" data-line-number="611"></td>
        <td id="LC611">            <span><span>//</span> If the argType is a struct, then check if it is an HFA</span></td>
      </tr>
      <tr>
        <td id="L612" data-line-number="612"></td>
        <td id="LC612">            <span>if</span> (<span>varTypeIsStruct</span>(argType))</td>
      </tr>
      <tr>
        <td id="L613" data-line-number="613"></td>
        <td id="LC613">            {</td>
      </tr>
      <tr>
        <td id="L614" data-line-number="614"></td>
        <td id="LC614">                <span><span>//</span> hfaType is set to float, double or SIMD type if it is an HFA, otherwise TYP_UNDEF.</span></td>
      </tr>
      <tr>
        <td id="L615" data-line-number="615"></td>
        <td id="LC615">                hfaType  = <span>GetHfaType</span>(typeHnd);</td>
      </tr>
      <tr>
        <td id="L616" data-line-number="616"></td>
        <td id="LC616">                isHfaArg = <span>varTypeIsValidHfaType</span>(hfaType);</td>
      </tr>
      <tr>
        <td id="L617" data-line-number="617"></td>
        <td id="LC617">            }</td>
      </tr>
      <tr>
        <td id="L618" data-line-number="618"></td>
        <td id="LC618">        }</td>
      </tr>
      <tr>
        <td id="L619" data-line-number="619"></td>
        <td id="LC619">        <span>else</span> <span>if</span> (info.<span>compIsVarArgs</span>)</td>
      </tr>
      <tr>
        <td id="L620" data-line-number="620"></td>
        <td id="LC620">        {</td>
      </tr>
      <tr>
        <td id="L621" data-line-number="621"></td>
        <td id="LC621">#<span>ifdef</span> TARGET_UNIX</td>
      </tr>
      <tr>
        <td id="L622" data-line-number="622"></td>
        <td id="LC622">            <span><span>//</span> Currently native varargs is not implemented on non windows targets.</span></td>
      </tr>
      <tr>
        <td id="L623" data-line-number="623"></td>
        <td id="LC623">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L624" data-line-number="624"></td>
        <td id="LC624">            <span><span>//</span> Note that some targets like Arm64 Unix should not need much work as</span></td>
      </tr>
      <tr>
        <td id="L625" data-line-number="625"></td>
        <td id="LC625">            <span><span>//</span> the ABI is the same. While other targets may only need small changes</span></td>
      </tr>
      <tr>
        <td id="L626" data-line-number="626"></td>
        <td id="LC626">            <span><span>//</span> such as amd64 Unix, which just expects RAX to pass numFPArguments.</span></td>
      </tr>
      <tr>
        <td id="L627" data-line-number="627"></td>
        <td id="LC627">            <span>NYI</span>(<span><span>"</span>InitUserArgs for Vararg callee is not yet implemented on non Windows targets.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L628" data-line-number="628"></td>
        <td id="LC628">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L629" data-line-number="629"></td>
        <td id="LC629">        }</td>
      </tr>
      <tr>
        <td id="L630" data-line-number="630"></td>
        <td id="LC630">
</td>
      </tr>
      <tr>
        <td id="L631" data-line-number="631"></td>
        <td id="LC631">        <span>if</span> (isHfaArg)</td>
      </tr>
      <tr>
        <td id="L632" data-line-number="632"></td>
        <td id="LC632">        {</td>
      </tr>
      <tr>
        <td id="L633" data-line-number="633"></td>
        <td id="LC633">            <span><span>//</span> We have an HFA argument, so from here on out treat the type as a float, double or vector.</span></td>
      </tr>
      <tr>
        <td id="L634" data-line-number="634"></td>
        <td id="LC634">            <span><span>//</span> The orginal struct type is available by using origArgType</span></td>
      </tr>
      <tr>
        <td id="L635" data-line-number="635"></td>
        <td id="LC635">            <span><span>//</span> We also update the cSlots to be the number of float/double fields in the HFA</span></td>
      </tr>
      <tr>
        <td id="L636" data-line-number="636"></td>
        <td id="LC636">            argType = hfaType;</td>
      </tr>
      <tr>
        <td id="L637" data-line-number="637"></td>
        <td id="LC637">            varDsc-&gt;<span>SetHfaType</span>(hfaType);</td>
      </tr>
      <tr>
        <td id="L638" data-line-number="638"></td>
        <td id="LC638">            cSlots = varDsc-&gt;<span>lvHfaSlots</span>();</td>
      </tr>
      <tr>
        <td id="L639" data-line-number="639"></td>
        <td id="LC639">        }</td>
      </tr>
      <tr>
        <td id="L640" data-line-number="640"></td>
        <td id="LC640">        <span><span>//</span> The number of slots that must be enregistered if we are to consider this argument enregistered.</span></td>
      </tr>
      <tr>
        <td id="L641" data-line-number="641"></td>
        <td id="LC641">        <span><span>//</span> This is normally the same as cSlots, since we normally either enregister the entire object,</span></td>
      </tr>
      <tr>
        <td id="L642" data-line-number="642"></td>
        <td id="LC642">        <span><span>//</span> or none of it. For structs on ARM, however, we only need to enregister a single slot to consider</span></td>
      </tr>
      <tr>
        <td id="L643" data-line-number="643"></td>
        <td id="LC643">        <span><span>//</span> it enregistered, as long as we can split the rest onto the stack.</span></td>
      </tr>
      <tr>
        <td id="L644" data-line-number="644"></td>
        <td id="LC644">        <span>unsigned</span> cSlotsToEnregister = cSlots;</td>
      </tr>
      <tr>
        <td id="L645" data-line-number="645"></td>
        <td id="LC645">
</td>
      </tr>
      <tr>
        <td id="L646" data-line-number="646"></td>
        <td id="LC646">#<span>if</span> defined(TARGET_ARM64) &amp;&amp; FEATURE_ARG_SPLIT</td>
      </tr>
      <tr>
        <td id="L647" data-line-number="647"></td>
        <td id="LC647">
</td>
      </tr>
      <tr>
        <td id="L648" data-line-number="648"></td>
        <td id="LC648">        <span><span>//</span> On arm64 Windows we will need to properly handle the case where a &gt;8byte &lt;=16byte</span></td>
      </tr>
      <tr>
        <td id="L649" data-line-number="649"></td>
        <td id="LC649">        <span><span>//</span> struct is split between register r7 and virtual stack slot s[0]</span></td>
      </tr>
      <tr>
        <td id="L650" data-line-number="650"></td>
        <td id="LC650">        <span><span>//</span> We will only do this for calls to vararg methods on Windows Arm64</span></td>
      </tr>
      <tr>
        <td id="L651" data-line-number="651"></td>
        <td id="LC651">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L652" data-line-number="652"></td>
        <td id="LC652">        <span><span>//</span> !!This does not affect the normal arm64 calling convention or Unix Arm64!!</span></td>
      </tr>
      <tr>
        <td id="L653" data-line-number="653"></td>
        <td id="LC653">        <span>if</span> (<span>this</span>-&gt;<span>info</span>.<span>compIsVarArgs</span> &amp;&amp; argType == TYP_STRUCT)</td>
      </tr>
      <tr>
        <td id="L654" data-line-number="654"></td>
        <td id="LC654">        {</td>
      </tr>
      <tr>
        <td id="L655" data-line-number="655"></td>
        <td id="LC655">            <span>if</span> (varDscInfo-&gt;<span>canEnreg</span>(TYP_INT, <span>1</span>) &amp;&amp;     <span><span>//</span> The beginning of the struct can go in a register</span></td>
      </tr>
      <tr>
        <td id="L656" data-line-number="656"></td>
        <td id="LC656">                !varDscInfo-&gt;<span>canEnreg</span>(TYP_INT, cSlots)) <span><span>//</span> The end of the struct can't fit in a register</span></td>
      </tr>
      <tr>
        <td id="L657" data-line-number="657"></td>
        <td id="LC657">            {</td>
      </tr>
      <tr>
        <td id="L658" data-line-number="658"></td>
        <td id="LC658">                cSlotsToEnregister = <span>1</span>; <span><span>//</span> Force the split</span></td>
      </tr>
      <tr>
        <td id="L659" data-line-number="659"></td>
        <td id="LC659">            }</td>
      </tr>
      <tr>
        <td id="L660" data-line-number="660"></td>
        <td id="LC660">        }</td>
      </tr>
      <tr>
        <td id="L661" data-line-number="661"></td>
        <td id="LC661">
</td>
      </tr>
      <tr>
        <td id="L662" data-line-number="662"></td>
        <td id="LC662">#<span>endif</span> <span><span>//</span> defined(TARGET_ARM64) &amp;&amp; FEATURE_ARG_SPLIT</span></td>
      </tr>
      <tr>
        <td id="L663" data-line-number="663"></td>
        <td id="LC663">
</td>
      </tr>
      <tr>
        <td id="L664" data-line-number="664"></td>
        <td id="LC664">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L665" data-line-number="665"></td>
        <td id="LC665">        <span><span>//</span> On ARM we pass the first 4 words of integer arguments and non-HFA structs in registers.</span></td>
      </tr>
      <tr>
        <td id="L666" data-line-number="666"></td>
        <td id="LC666">        <span><span>//</span> But we pre-spill user arguments in varargs methods and structs.</span></td>
      </tr>
      <tr>
        <td id="L667" data-line-number="667"></td>
        <td id="LC667">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L668" data-line-number="668"></td>
        <td id="LC668">        <span>unsigned</span> cAlign;</td>
      </tr>
      <tr>
        <td id="L669" data-line-number="669"></td>
        <td id="LC669">        <span>bool</span>     preSpill = info.<span>compIsVarArgs</span> || isSoftFPPreSpill;</td>
      </tr>
      <tr>
        <td id="L670" data-line-number="670"></td>
        <td id="LC670">
</td>
      </tr>
      <tr>
        <td id="L671" data-line-number="671"></td>
        <td id="LC671">        <span>switch</span> (origArgType)</td>
      </tr>
      <tr>
        <td id="L672" data-line-number="672"></td>
        <td id="LC672">        {</td>
      </tr>
      <tr>
        <td id="L673" data-line-number="673"></td>
        <td id="LC673">            <span>case</span> TYP_STRUCT:</td>
      </tr>
      <tr>
        <td id="L674" data-line-number="674"></td>
        <td id="LC674">                <span>assert</span>(varDsc-&gt;<span>lvSize</span>() == argSize);</td>
      </tr>
      <tr>
        <td id="L675" data-line-number="675"></td>
        <td id="LC675">                cAlign = varDsc-&gt;<span>lvStructDoubleAlign</span> ? <span>2</span> : <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L676" data-line-number="676"></td>
        <td id="LC676">
</td>
      </tr>
      <tr>
        <td id="L677" data-line-number="677"></td>
        <td id="LC677">                <span><span>//</span> HFA arguments go on the stack frame. They don't get spilled in the prolog like struct</span></td>
      </tr>
      <tr>
        <td id="L678" data-line-number="678"></td>
        <td id="LC678">                <span><span>//</span> arguments passed in the integer registers but get homed immediately after the prolog.</span></td>
      </tr>
      <tr>
        <td id="L679" data-line-number="679"></td>
        <td id="LC679">                <span>if</span> (!isHfaArg)</td>
      </tr>
      <tr>
        <td id="L680" data-line-number="680"></td>
        <td id="LC680">                {</td>
      </tr>
      <tr>
        <td id="L681" data-line-number="681"></td>
        <td id="LC681">                    <span><span>//</span> TODO-Arm32-Windows: vararg struct should be forced to split like</span></td>
      </tr>
      <tr>
        <td id="L682" data-line-number="682"></td>
        <td id="LC682">                    <span><span>//</span> ARM64 above.</span></td>
      </tr>
      <tr>
        <td id="L683" data-line-number="683"></td>
        <td id="LC683">                    cSlotsToEnregister = <span>1</span>; <span><span>//</span> HFAs must be totally enregistered or not, but other structs can be split.</span></td>
      </tr>
      <tr>
        <td id="L684" data-line-number="684"></td>
        <td id="LC684">                    preSpill           = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L685" data-line-number="685"></td>
        <td id="LC685">                }</td>
      </tr>
      <tr>
        <td id="L686" data-line-number="686"></td>
        <td id="LC686">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L687" data-line-number="687"></td>
        <td id="LC687">
</td>
      </tr>
      <tr>
        <td id="L688" data-line-number="688"></td>
        <td id="LC688">            <span>case</span> TYP_DOUBLE:</td>
      </tr>
      <tr>
        <td id="L689" data-line-number="689"></td>
        <td id="LC689">            <span>case</span> TYP_LONG:</td>
      </tr>
      <tr>
        <td id="L690" data-line-number="690"></td>
        <td id="LC690">                cAlign = <span>2</span>;</td>
      </tr>
      <tr>
        <td id="L691" data-line-number="691"></td>
        <td id="LC691">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L692" data-line-number="692"></td>
        <td id="LC692">
</td>
      </tr>
      <tr>
        <td id="L693" data-line-number="693"></td>
        <td id="LC693">            <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L694" data-line-number="694"></td>
        <td id="LC694">                cAlign = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L695" data-line-number="695"></td>
        <td id="LC695">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L696" data-line-number="696"></td>
        <td id="LC696">        }</td>
      </tr>
      <tr>
        <td id="L697" data-line-number="697"></td>
        <td id="LC697">
</td>
      </tr>
      <tr>
        <td id="L698" data-line-number="698"></td>
        <td id="LC698">        <span>if</span> (<span>isRegParamType</span>(argType))</td>
      </tr>
      <tr>
        <td id="L699" data-line-number="699"></td>
        <td id="LC699">        {</td>
      </tr>
      <tr>
        <td id="L700" data-line-number="700"></td>
        <td id="LC700">            compArgSize += varDscInfo-&gt;<span>alignReg</span>(argType, cAlign) * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L701" data-line-number="701"></td>
        <td id="LC701">        }</td>
      </tr>
      <tr>
        <td id="L702" data-line-number="702"></td>
        <td id="LC702">
</td>
      </tr>
      <tr>
        <td id="L703" data-line-number="703"></td>
        <td id="LC703">        <span>if</span> (argType == TYP_STRUCT)</td>
      </tr>
      <tr>
        <td id="L704" data-line-number="704"></td>
        <td id="LC704">        {</td>
      </tr>
      <tr>
        <td id="L705" data-line-number="705"></td>
        <td id="LC705">            <span><span>//</span> Are we going to split the struct between registers and stack? We can do that as long as</span></td>
      </tr>
      <tr>
        <td id="L706" data-line-number="706"></td>
        <td id="LC706">            <span><span>//</span> no floating-point arguments have been put on the stack.</span></td>
      </tr>
      <tr>
        <td id="L707" data-line-number="707"></td>
        <td id="LC707">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L708" data-line-number="708"></td>
        <td id="LC708">            <span><span>//</span> From the ARM Procedure Call Standard:</span></td>
      </tr>
      <tr>
        <td id="L709" data-line-number="709"></td>
        <td id="LC709">            <span><span>//</span> Rule C.5: "If the NCRN is less than r4 **and** the NSAA is equal to the SP,"</span></td>
      </tr>
      <tr>
        <td id="L710" data-line-number="710"></td>
        <td id="LC710">            <span><span>//</span> then split the argument between registers and stack. Implication: if something</span></td>
      </tr>
      <tr>
        <td id="L711" data-line-number="711"></td>
        <td id="LC711">            <span><span>//</span> has already been spilled to the stack, then anything that would normally be</span></td>
      </tr>
      <tr>
        <td id="L712" data-line-number="712"></td>
        <td id="LC712">            <span><span>//</span> split between the core registers and the stack will be put on the stack.</span></td>
      </tr>
      <tr>
        <td id="L713" data-line-number="713"></td>
        <td id="LC713">            <span><span>//</span> Anything that follows will also be on the stack. However, if something from</span></td>
      </tr>
      <tr>
        <td id="L714" data-line-number="714"></td>
        <td id="LC714">            <span><span>//</span> floating point regs has been spilled to the stack, we can still use r0-r3 until they are full.</span></td>
      </tr>
      <tr>
        <td id="L715" data-line-number="715"></td>
        <td id="LC715">
</td>
      </tr>
      <tr>
        <td id="L716" data-line-number="716"></td>
        <td id="LC716">            <span>if</span> (varDscInfo-&gt;<span>canEnreg</span>(TYP_INT, <span>1</span>) &amp;&amp;       <span><span>//</span> The beginning of the struct can go in a register</span></td>
      </tr>
      <tr>
        <td id="L717" data-line-number="717"></td>
        <td id="LC717">                !varDscInfo-&gt;<span>canEnreg</span>(TYP_INT, cSlots) &amp;&amp; <span><span>//</span> The end of the struct can't fit in a register</span></td>
      </tr>
      <tr>
        <td id="L718" data-line-number="718"></td>
        <td id="LC718">                varDscInfo-&gt;<span>existAnyFloatStackArgs</span>())     <span><span>//</span> There's at least one stack-based FP arg already</span></td>
      </tr>
      <tr>
        <td id="L719" data-line-number="719"></td>
        <td id="LC719">            {</td>
      </tr>
      <tr>
        <td id="L720" data-line-number="720"></td>
        <td id="LC720">                varDscInfo-&gt;<span>setAllRegArgUsed</span>(TYP_INT); <span><span>//</span> Prevent all future use of integer registers</span></td>
      </tr>
      <tr>
        <td id="L721" data-line-number="721"></td>
        <td id="LC721">                preSpill = <span>false</span>;                      <span><span>//</span> This struct won't be prespilled, since it will go on the stack</span></td>
      </tr>
      <tr>
        <td id="L722" data-line-number="722"></td>
        <td id="LC722">            }</td>
      </tr>
      <tr>
        <td id="L723" data-line-number="723"></td>
        <td id="LC723">        }</td>
      </tr>
      <tr>
        <td id="L724" data-line-number="724"></td>
        <td id="LC724">
</td>
      </tr>
      <tr>
        <td id="L725" data-line-number="725"></td>
        <td id="LC725">        <span>if</span> (preSpill)</td>
      </tr>
      <tr>
        <td id="L726" data-line-number="726"></td>
        <td id="LC726">        {</td>
      </tr>
      <tr>
        <td id="L727" data-line-number="727"></td>
        <td id="LC727">            <span>for</span> (<span>unsigned</span> ix = <span>0</span>; ix &lt; cSlots; ix++)</td>
      </tr>
      <tr>
        <td id="L728" data-line-number="728"></td>
        <td id="LC728">            {</td>
      </tr>
      <tr>
        <td id="L729" data-line-number="729"></td>
        <td id="LC729">                <span>if</span> (!varDscInfo-&gt;<span>canEnreg</span>(TYP_INT, ix + <span>1</span>))</td>
      </tr>
      <tr>
        <td id="L730" data-line-number="730"></td>
        <td id="LC730">                {</td>
      </tr>
      <tr>
        <td id="L731" data-line-number="731"></td>
        <td id="LC731">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L732" data-line-number="732"></td>
        <td id="LC732">                }</td>
      </tr>
      <tr>
        <td id="L733" data-line-number="733"></td>
        <td id="LC733">                regMaskTP regMask = <span>genMapArgNumToRegMask</span>(varDscInfo-&gt;<span>regArgNum</span>(TYP_INT) + ix, TYP_INT);</td>
      </tr>
      <tr>
        <td id="L734" data-line-number="734"></td>
        <td id="LC734">                <span>if</span> (cAlign == <span>2</span>)</td>
      </tr>
      <tr>
        <td id="L735" data-line-number="735"></td>
        <td id="LC735">                {</td>
      </tr>
      <tr>
        <td id="L736" data-line-number="736"></td>
        <td id="LC736">                    doubleAlignMask |= regMask;</td>
      </tr>
      <tr>
        <td id="L737" data-line-number="737"></td>
        <td id="LC737">                }</td>
      </tr>
      <tr>
        <td id="L738" data-line-number="738"></td>
        <td id="LC738">                codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegArg</span> |= regMask;</td>
      </tr>
      <tr>
        <td id="L739" data-line-number="739"></td>
        <td id="LC739">            }</td>
      </tr>
      <tr>
        <td id="L740" data-line-number="740"></td>
        <td id="LC740">        }</td>
      </tr>
      <tr>
        <td id="L741" data-line-number="741"></td>
        <td id="LC741">#<span>else</span> <span><span>//</span> !TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L742" data-line-number="742"></td>
        <td id="LC742">#<span>if</span> defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L743" data-line-number="743"></td>
        <td id="LC743">        SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR structDesc;</td>
      </tr>
      <tr>
        <td id="L744" data-line-number="744"></td>
        <td id="LC744">        <span>if</span> (<span>varTypeIsStruct</span>(argType))</td>
      </tr>
      <tr>
        <td id="L745" data-line-number="745"></td>
        <td id="LC745">        {</td>
      </tr>
      <tr>
        <td id="L746" data-line-number="746"></td>
        <td id="LC746">            <span>assert</span>(typeHnd != <span>nullptr</span>);</td>
      </tr>
      <tr>
        <td id="L747" data-line-number="747"></td>
        <td id="LC747">            <span>eeGetSystemVAmd64PassStructInRegisterDescriptor</span>(typeHnd, &amp;structDesc);</td>
      </tr>
      <tr>
        <td id="L748" data-line-number="748"></td>
        <td id="LC748">            <span>if</span> (structDesc.<span>passedInRegisters</span>)</td>
      </tr>
      <tr>
        <td id="L749" data-line-number="749"></td>
        <td id="LC749">            {</td>
      </tr>
      <tr>
        <td id="L750" data-line-number="750"></td>
        <td id="LC750">                <span>unsigned</span> intRegCount   = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L751" data-line-number="751"></td>
        <td id="LC751">                <span>unsigned</span> floatRegCount = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L752" data-line-number="752"></td>
        <td id="LC752">
</td>
      </tr>
      <tr>
        <td id="L753" data-line-number="753"></td>
        <td id="LC753">                <span>for</span> (<span>unsigned</span> <span>int</span> i = <span>0</span>; i &lt; structDesc.<span>eightByteCount</span>; i++)</td>
      </tr>
      <tr>
        <td id="L754" data-line-number="754"></td>
        <td id="LC754">                {</td>
      </tr>
      <tr>
        <td id="L755" data-line-number="755"></td>
        <td id="LC755">                    <span>if</span> (structDesc.<span>IsIntegralSlot</span>(i))</td>
      </tr>
      <tr>
        <td id="L756" data-line-number="756"></td>
        <td id="LC756">                    {</td>
      </tr>
      <tr>
        <td id="L757" data-line-number="757"></td>
        <td id="LC757">                        intRegCount++;</td>
      </tr>
      <tr>
        <td id="L758" data-line-number="758"></td>
        <td id="LC758">                    }</td>
      </tr>
      <tr>
        <td id="L759" data-line-number="759"></td>
        <td id="LC759">                    <span>else</span> <span>if</span> (structDesc.<span>IsSseSlot</span>(i))</td>
      </tr>
      <tr>
        <td id="L760" data-line-number="760"></td>
        <td id="LC760">                    {</td>
      </tr>
      <tr>
        <td id="L761" data-line-number="761"></td>
        <td id="LC761">                        floatRegCount++;</td>
      </tr>
      <tr>
        <td id="L762" data-line-number="762"></td>
        <td id="LC762">                    }</td>
      </tr>
      <tr>
        <td id="L763" data-line-number="763"></td>
        <td id="LC763">                    <span>else</span></td>
      </tr>
      <tr>
        <td id="L764" data-line-number="764"></td>
        <td id="LC764">                    {</td>
      </tr>
      <tr>
        <td id="L765" data-line-number="765"></td>
        <td id="LC765">                        <span>assert</span>(<span>false</span> &amp;&amp; <span><span>"</span>Invalid eightbyte classification type.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L766" data-line-number="766"></td>
        <td id="LC766">                        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L767" data-line-number="767"></td>
        <td id="LC767">                    }</td>
      </tr>
      <tr>
        <td id="L768" data-line-number="768"></td>
        <td id="LC768">                }</td>
      </tr>
      <tr>
        <td id="L769" data-line-number="769"></td>
        <td id="LC769">
</td>
      </tr>
      <tr>
        <td id="L770" data-line-number="770"></td>
        <td id="LC770">                <span>if</span> (intRegCount != <span>0</span> &amp;&amp; !varDscInfo-&gt;<span>canEnreg</span>(TYP_INT, intRegCount))</td>
      </tr>
      <tr>
        <td id="L771" data-line-number="771"></td>
        <td id="LC771">                {</td>
      </tr>
      <tr>
        <td id="L772" data-line-number="772"></td>
        <td id="LC772">                    structDesc.<span>passedInRegisters</span> = <span>false</span>; <span><span>//</span> No register to enregister the eightbytes.</span></td>
      </tr>
      <tr>
        <td id="L773" data-line-number="773"></td>
        <td id="LC773">                }</td>
      </tr>
      <tr>
        <td id="L774" data-line-number="774"></td>
        <td id="LC774">
</td>
      </tr>
      <tr>
        <td id="L775" data-line-number="775"></td>
        <td id="LC775">                <span>if</span> (floatRegCount != <span>0</span> &amp;&amp; !varDscInfo-&gt;<span>canEnreg</span>(TYP_FLOAT, floatRegCount))</td>
      </tr>
      <tr>
        <td id="L776" data-line-number="776"></td>
        <td id="LC776">                {</td>
      </tr>
      <tr>
        <td id="L777" data-line-number="777"></td>
        <td id="LC777">                    structDesc.<span>passedInRegisters</span> = <span>false</span>; <span><span>//</span> No register to enregister the eightbytes.</span></td>
      </tr>
      <tr>
        <td id="L778" data-line-number="778"></td>
        <td id="LC778">                }</td>
      </tr>
      <tr>
        <td id="L779" data-line-number="779"></td>
        <td id="LC779">            }</td>
      </tr>
      <tr>
        <td id="L780" data-line-number="780"></td>
        <td id="LC780">        }</td>
      </tr>
      <tr>
        <td id="L781" data-line-number="781"></td>
        <td id="LC781">#<span>endif</span> <span><span>//</span> UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L782" data-line-number="782"></td>
        <td id="LC782">#<span>endif</span> <span><span>//</span> !TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L783" data-line-number="783"></td>
        <td id="LC783">
</td>
      </tr>
      <tr>
        <td id="L784" data-line-number="784"></td>
        <td id="LC784">        <span><span>//</span> The final home for this incoming register might be our local stack frame.</span></td>
      </tr>
      <tr>
        <td id="L785" data-line-number="785"></td>
        <td id="LC785">        <span><span>//</span> For System V platforms the final home will always be on the local stack frame.</span></td>
      </tr>
      <tr>
        <td id="L786" data-line-number="786"></td>
        <td id="LC786">        varDsc-&gt;<span>lvOnFrame</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L787" data-line-number="787"></td>
        <td id="LC787">
</td>
      </tr>
      <tr>
        <td id="L788" data-line-number="788"></td>
        <td id="LC788">        <span>bool</span> canPassArgInRegisters = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L789" data-line-number="789"></td>
        <td id="LC789">
</td>
      </tr>
      <tr>
        <td id="L790" data-line-number="790"></td>
        <td id="LC790">#<span>if</span> defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L791" data-line-number="791"></td>
        <td id="LC791">        <span>if</span> (<span>varTypeIsStruct</span>(argType))</td>
      </tr>
      <tr>
        <td id="L792" data-line-number="792"></td>
        <td id="LC792">        {</td>
      </tr>
      <tr>
        <td id="L793" data-line-number="793"></td>
        <td id="LC793">            canPassArgInRegisters = structDesc.<span>passedInRegisters</span>;</td>
      </tr>
      <tr>
        <td id="L794" data-line-number="794"></td>
        <td id="LC794">        }</td>
      </tr>
      <tr>
        <td id="L795" data-line-number="795"></td>
        <td id="LC795">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L796" data-line-number="796"></td>
        <td id="LC796">#<span>endif</span> <span><span>//</span> defined(UNIX_AMD64_ABI)</span></td>
      </tr>
      <tr>
        <td id="L797" data-line-number="797"></td>
        <td id="LC797">        {</td>
      </tr>
      <tr>
        <td id="L798" data-line-number="798"></td>
        <td id="LC798">            canPassArgInRegisters = varDscInfo-&gt;<span>canEnreg</span>(argType, cSlotsToEnregister);</td>
      </tr>
      <tr>
        <td id="L799" data-line-number="799"></td>
        <td id="LC799">        }</td>
      </tr>
      <tr>
        <td id="L800" data-line-number="800"></td>
        <td id="LC800">
</td>
      </tr>
      <tr>
        <td id="L801" data-line-number="801"></td>
        <td id="LC801">        <span>if</span> (canPassArgInRegisters)</td>
      </tr>
      <tr>
        <td id="L802" data-line-number="802"></td>
        <td id="LC802">        {</td>
      </tr>
      <tr>
        <td id="L803" data-line-number="803"></td>
        <td id="LC803">            <span><span>/*</span> Another register argument <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L804" data-line-number="804"></td>
        <td id="LC804">
</td>
      </tr>
      <tr>
        <td id="L805" data-line-number="805"></td>
        <td id="LC805">            <span><span>//</span> Allocate the registers we need. allocRegArg() returns the first argument register number of the set.</span></td>
      </tr>
      <tr>
        <td id="L806" data-line-number="806"></td>
        <td id="LC806">            <span><span>//</span> For non-HFA structs, we still "try" to enregister the whole thing; it will just max out if splitting</span></td>
      </tr>
      <tr>
        <td id="L807" data-line-number="807"></td>
        <td id="LC807">            <span><span>//</span> to the stack happens.</span></td>
      </tr>
      <tr>
        <td id="L808" data-line-number="808"></td>
        <td id="LC808">            <span>unsigned</span> firstAllocatedRegArgNum = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L809" data-line-number="809"></td>
        <td id="LC809">
</td>
      </tr>
      <tr>
        <td id="L810" data-line-number="810"></td>
        <td id="LC810">#<span>if</span> FEATURE_MULTIREG_ARGS</td>
      </tr>
      <tr>
        <td id="L811" data-line-number="811"></td>
        <td id="LC811">            varDsc-&gt;<span>SetOtherArgReg</span>(REG_NA);</td>
      </tr>
      <tr>
        <td id="L812" data-line-number="812"></td>
        <td id="LC812">#<span>endif</span> <span><span>//</span> FEATURE_MULTIREG_ARGS</span></td>
      </tr>
      <tr>
        <td id="L813" data-line-number="813"></td>
        <td id="LC813">
</td>
      </tr>
      <tr>
        <td id="L814" data-line-number="814"></td>
        <td id="LC814">#<span>if</span> defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L815" data-line-number="815"></td>
        <td id="LC815">            <span>unsigned</span>  secondAllocatedRegArgNum = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L816" data-line-number="816"></td>
        <td id="LC816">            var_types firstEightByteType       = TYP_UNDEF;</td>
      </tr>
      <tr>
        <td id="L817" data-line-number="817"></td>
        <td id="LC817">            var_types secondEightByteType      = TYP_UNDEF;</td>
      </tr>
      <tr>
        <td id="L818" data-line-number="818"></td>
        <td id="LC818">
</td>
      </tr>
      <tr>
        <td id="L819" data-line-number="819"></td>
        <td id="LC819">            <span>if</span> (<span>varTypeIsStruct</span>(argType))</td>
      </tr>
      <tr>
        <td id="L820" data-line-number="820"></td>
        <td id="LC820">            {</td>
      </tr>
      <tr>
        <td id="L821" data-line-number="821"></td>
        <td id="LC821">                <span>if</span> (structDesc.<span>eightByteCount</span> &gt;= <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L822" data-line-number="822"></td>
        <td id="LC822">                {</td>
      </tr>
      <tr>
        <td id="L823" data-line-number="823"></td>
        <td id="LC823">                    firstEightByteType      = <span>GetEightByteType</span>(structDesc, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L824" data-line-number="824"></td>
        <td id="LC824">                    firstAllocatedRegArgNum = varDscInfo-&gt;<span>allocRegArg</span>(firstEightByteType, <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L825" data-line-number="825"></td>
        <td id="LC825">                }</td>
      </tr>
      <tr>
        <td id="L826" data-line-number="826"></td>
        <td id="LC826">            }</td>
      </tr>
      <tr>
        <td id="L827" data-line-number="827"></td>
        <td id="LC827">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L828" data-line-number="828"></td>
        <td id="LC828">#<span>endif</span> <span><span>//</span> defined(UNIX_AMD64_ABI)</span></td>
      </tr>
      <tr>
        <td id="L829" data-line-number="829"></td>
        <td id="LC829">            {</td>
      </tr>
      <tr>
        <td id="L830" data-line-number="830"></td>
        <td id="LC830">                firstAllocatedRegArgNum = varDscInfo-&gt;<span>allocRegArg</span>(argType, cSlots);</td>
      </tr>
      <tr>
        <td id="L831" data-line-number="831"></td>
        <td id="LC831">            }</td>
      </tr>
      <tr>
        <td id="L832" data-line-number="832"></td>
        <td id="LC832">
</td>
      </tr>
      <tr>
        <td id="L833" data-line-number="833"></td>
        <td id="LC833">            <span>if</span> (isHfaArg)</td>
      </tr>
      <tr>
        <td id="L834" data-line-number="834"></td>
        <td id="LC834">            {</td>
      </tr>
      <tr>
        <td id="L835" data-line-number="835"></td>
        <td id="LC835">                <span><span>//</span> We need to save the fact that this HFA is enregistered</span></td>
      </tr>
      <tr>
        <td id="L836" data-line-number="836"></td>
        <td id="LC836">                <span><span>//</span> Note that we can have HVAs of SIMD types even if we are not recognizing intrinsics.</span></td>
      </tr>
      <tr>
        <td id="L837" data-line-number="837"></td>
        <td id="LC837">                <span><span>//</span> In that case, we won't have normalized the vector types on the varDsc, so if we have a single vector</span></td>
      </tr>
      <tr>
        <td id="L838" data-line-number="838"></td>
        <td id="LC838">                <span><span>//</span> register, we need to set the type now. Otherwise, later we'll assume this is passed by reference.</span></td>
      </tr>
      <tr>
        <td id="L839" data-line-number="839"></td>
        <td id="LC839">                <span>if</span> (varDsc-&gt;<span>lvHfaSlots</span>() != <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L840" data-line-number="840"></td>
        <td id="LC840">                {</td>
      </tr>
      <tr>
        <td id="L841" data-line-number="841"></td>
        <td id="LC841">                    varDsc-&gt;<span>lvIsMultiRegArg</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L842" data-line-number="842"></td>
        <td id="LC842">                }</td>
      </tr>
      <tr>
        <td id="L843" data-line-number="843"></td>
        <td id="LC843">            }</td>
      </tr>
      <tr>
        <td id="L844" data-line-number="844"></td>
        <td id="LC844">
</td>
      </tr>
      <tr>
        <td id="L845" data-line-number="845"></td>
        <td id="LC845">            varDsc-&gt;<span>lvIsRegArg</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L846" data-line-number="846"></td>
        <td id="LC846">
</td>
      </tr>
      <tr>
        <td id="L847" data-line-number="847"></td>
        <td id="LC847">#<span>if</span> FEATURE_MULTIREG_ARGS</td>
      </tr>
      <tr>
        <td id="L848" data-line-number="848"></td>
        <td id="LC848">#<span>ifdef</span> TARGET_ARM64</td>
      </tr>
      <tr>
        <td id="L849" data-line-number="849"></td>
        <td id="LC849">            <span>if</span> (argType == TYP_STRUCT)</td>
      </tr>
      <tr>
        <td id="L850" data-line-number="850"></td>
        <td id="LC850">            {</td>
      </tr>
      <tr>
        <td id="L851" data-line-number="851"></td>
        <td id="LC851">                varDsc-&gt;<span>SetArgReg</span>(<span>genMapRegArgNumToRegNum</span>(firstAllocatedRegArgNum, TYP_I_IMPL));</td>
      </tr>
      <tr>
        <td id="L852" data-line-number="852"></td>
        <td id="LC852">                <span>if</span> (cSlots == <span>2</span>)</td>
      </tr>
      <tr>
        <td id="L853" data-line-number="853"></td>
        <td id="LC853">                {</td>
      </tr>
      <tr>
        <td id="L854" data-line-number="854"></td>
        <td id="LC854">                    varDsc-&gt;<span>SetOtherArgReg</span>(<span>genMapRegArgNumToRegNum</span>(firstAllocatedRegArgNum + <span>1</span>, TYP_I_IMPL));</td>
      </tr>
      <tr>
        <td id="L855" data-line-number="855"></td>
        <td id="LC855">                }</td>
      </tr>
      <tr>
        <td id="L856" data-line-number="856"></td>
        <td id="LC856">            }</td>
      </tr>
      <tr>
        <td id="L857" data-line-number="857"></td>
        <td id="LC857">#<span>elif</span> defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L858" data-line-number="858"></td>
        <td id="LC858">            <span>if</span> (<span>varTypeIsStruct</span>(argType))</td>
      </tr>
      <tr>
        <td id="L859" data-line-number="859"></td>
        <td id="LC859">            {</td>
      </tr>
      <tr>
        <td id="L860" data-line-number="860"></td>
        <td id="LC860">                varDsc-&gt;<span>SetArgReg</span>(<span>genMapRegArgNumToRegNum</span>(firstAllocatedRegArgNum, firstEightByteType));</td>
      </tr>
      <tr>
        <td id="L861" data-line-number="861"></td>
        <td id="LC861">
</td>
      </tr>
      <tr>
        <td id="L862" data-line-number="862"></td>
        <td id="LC862">                <span><span>//</span> If there is a second eightbyte, get a register for it too and map the arg to the reg number.</span></td>
      </tr>
      <tr>
        <td id="L863" data-line-number="863"></td>
        <td id="LC863">                <span>if</span> (structDesc.<span>eightByteCount</span> &gt;= <span>2</span>)</td>
      </tr>
      <tr>
        <td id="L864" data-line-number="864"></td>
        <td id="LC864">                {</td>
      </tr>
      <tr>
        <td id="L865" data-line-number="865"></td>
        <td id="LC865">                    secondEightByteType      = <span>GetEightByteType</span>(structDesc, <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L866" data-line-number="866"></td>
        <td id="LC866">                    secondAllocatedRegArgNum = varDscInfo-&gt;<span>allocRegArg</span>(secondEightByteType, <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L867" data-line-number="867"></td>
        <td id="LC867">                }</td>
      </tr>
      <tr>
        <td id="L868" data-line-number="868"></td>
        <td id="LC868">
</td>
      </tr>
      <tr>
        <td id="L869" data-line-number="869"></td>
        <td id="LC869">                <span>if</span> (secondEightByteType != TYP_UNDEF)</td>
      </tr>
      <tr>
        <td id="L870" data-line-number="870"></td>
        <td id="LC870">                {</td>
      </tr>
      <tr>
        <td id="L871" data-line-number="871"></td>
        <td id="LC871">                    varDsc-&gt;<span>SetOtherArgReg</span>(<span>genMapRegArgNumToRegNum</span>(secondAllocatedRegArgNum, secondEightByteType));</td>
      </tr>
      <tr>
        <td id="L872" data-line-number="872"></td>
        <td id="LC872">                }</td>
      </tr>
      <tr>
        <td id="L873" data-line-number="873"></td>
        <td id="LC873">            }</td>
      </tr>
      <tr>
        <td id="L874" data-line-number="874"></td>
        <td id="LC874">#<span>else</span>  <span><span>//</span> ARM32</span></td>
      </tr>
      <tr>
        <td id="L875" data-line-number="875"></td>
        <td id="LC875">            <span>if</span> (<span>varTypeIsStruct</span>(argType))</td>
      </tr>
      <tr>
        <td id="L876" data-line-number="876"></td>
        <td id="LC876">            {</td>
      </tr>
      <tr>
        <td id="L877" data-line-number="877"></td>
        <td id="LC877">                varDsc-&gt;<span>SetArgReg</span>(<span>genMapRegArgNumToRegNum</span>(firstAllocatedRegArgNum, TYP_I_IMPL));</td>
      </tr>
      <tr>
        <td id="L878" data-line-number="878"></td>
        <td id="LC878">            }</td>
      </tr>
      <tr>
        <td id="L879" data-line-number="879"></td>
        <td id="LC879">#<span>endif</span> <span><span>//</span> ARM32</span></td>
      </tr>
      <tr>
        <td id="L880" data-line-number="880"></td>
        <td id="LC880">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L881" data-line-number="881"></td>
        <td id="LC881">#<span>endif</span> <span><span>//</span> FEATURE_MULTIREG_ARGS</span></td>
      </tr>
      <tr>
        <td id="L882" data-line-number="882"></td>
        <td id="LC882">            {</td>
      </tr>
      <tr>
        <td id="L883" data-line-number="883"></td>
        <td id="LC883">                varDsc-&gt;<span>SetArgReg</span>(<span>genMapRegArgNumToRegNum</span>(firstAllocatedRegArgNum, argType));</td>
      </tr>
      <tr>
        <td id="L884" data-line-number="884"></td>
        <td id="LC884">            }</td>
      </tr>
      <tr>
        <td id="L885" data-line-number="885"></td>
        <td id="LC885">
</td>
      </tr>
      <tr>
        <td id="L886" data-line-number="886"></td>
        <td id="LC886">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L887" data-line-number="887"></td>
        <td id="LC887">            <span>if</span> (varDsc-&gt;<span>TypeGet</span>() == TYP_LONG)</td>
      </tr>
      <tr>
        <td id="L888" data-line-number="888"></td>
        <td id="LC888">            {</td>
      </tr>
      <tr>
        <td id="L889" data-line-number="889"></td>
        <td id="LC889">                varDsc-&gt;<span>SetOtherArgReg</span>(<span>genMapRegArgNumToRegNum</span>(firstAllocatedRegArgNum + <span>1</span>, TYP_INT));</td>
      </tr>
      <tr>
        <td id="L890" data-line-number="890"></td>
        <td id="LC890">            }</td>
      </tr>
      <tr>
        <td id="L891" data-line-number="891"></td>
        <td id="LC891">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L892" data-line-number="892"></td>
        <td id="LC892">
</td>
      </tr>
      <tr>
        <td id="L893" data-line-number="893"></td>
        <td id="LC893">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L894" data-line-number="894"></td>
        <td id="LC894">            <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L895" data-line-number="895"></td>
        <td id="LC895">            {</td>
      </tr>
      <tr>
        <td id="L896" data-line-number="896"></td>
        <td id="LC896">                <span>printf</span>(<span><span>"</span>Arg #%u    passed in register(s) <span>"</span></span>, varDscInfo-&gt;<span>varNum</span>);</td>
      </tr>
      <tr>
        <td id="L897" data-line-number="897"></td>
        <td id="LC897">                <span>bool</span> isFloat = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L898" data-line-number="898"></td>
        <td id="LC898">#<span>if</span> defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L899" data-line-number="899"></td>
        <td id="LC899">                <span>if</span> (<span>varTypeIsStruct</span>(argType) &amp;&amp; (structDesc.<span>eightByteCount</span> &gt;= <span>1</span>))</td>
      </tr>
      <tr>
        <td id="L900" data-line-number="900"></td>
        <td id="LC900">                {</td>
      </tr>
      <tr>
        <td id="L901" data-line-number="901"></td>
        <td id="LC901">                    isFloat = <span>varTypeIsFloating</span>(firstEightByteType);</td>
      </tr>
      <tr>
        <td id="L902" data-line-number="902"></td>
        <td id="LC902">                }</td>
      </tr>
      <tr>
        <td id="L903" data-line-number="903"></td>
        <td id="LC903">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L904" data-line-number="904"></td>
        <td id="LC904">#<span>endif</span> <span><span>//</span> !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L905" data-line-number="905"></td>
        <td id="LC905">                {</td>
      </tr>
      <tr>
        <td id="L906" data-line-number="906"></td>
        <td id="LC906">                    isFloat = <span>varTypeIsFloating</span>(argType);</td>
      </tr>
      <tr>
        <td id="L907" data-line-number="907"></td>
        <td id="LC907">                }</td>
      </tr>
      <tr>
        <td id="L908" data-line-number="908"></td>
        <td id="LC908">
</td>
      </tr>
      <tr>
        <td id="L909" data-line-number="909"></td>
        <td id="LC909">#<span>if</span> defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L910" data-line-number="910"></td>
        <td id="LC910">                <span>if</span> (<span>varTypeIsStruct</span>(argType))</td>
      </tr>
      <tr>
        <td id="L911" data-line-number="911"></td>
        <td id="LC911">                {</td>
      </tr>
      <tr>
        <td id="L912" data-line-number="912"></td>
        <td id="LC912">                    <span><span>//</span> Print both registers, just to be clear</span></td>
      </tr>
      <tr>
        <td id="L913" data-line-number="913"></td>
        <td id="LC913">                    <span>if</span> (firstEightByteType == TYP_UNDEF)</td>
      </tr>
      <tr>
        <td id="L914" data-line-number="914"></td>
        <td id="LC914">                    {</td>
      </tr>
      <tr>
        <td id="L915" data-line-number="915"></td>
        <td id="LC915">                        <span>printf</span>(<span><span>"</span>firstEightByte: &lt;not used&gt;<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L916" data-line-number="916"></td>
        <td id="LC916">                    }</td>
      </tr>
      <tr>
        <td id="L917" data-line-number="917"></td>
        <td id="LC917">                    <span>else</span></td>
      </tr>
      <tr>
        <td id="L918" data-line-number="918"></td>
        <td id="LC918">                    {</td>
      </tr>
      <tr>
        <td id="L919" data-line-number="919"></td>
        <td id="LC919">                        <span>printf</span>(<span><span>"</span>firstEightByte: %s<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L920" data-line-number="920"></td>
        <td id="LC920">                               <span>getRegName</span>(<span>genMapRegArgNumToRegNum</span>(firstAllocatedRegArgNum, firstEightByteType),</td>
      </tr>
      <tr>
        <td id="L921" data-line-number="921"></td>
        <td id="LC921">                                          isFloat));</td>
      </tr>
      <tr>
        <td id="L922" data-line-number="922"></td>
        <td id="LC922">                    }</td>
      </tr>
      <tr>
        <td id="L923" data-line-number="923"></td>
        <td id="LC923">
</td>
      </tr>
      <tr>
        <td id="L924" data-line-number="924"></td>
        <td id="LC924">                    <span>if</span> (secondEightByteType == TYP_UNDEF)</td>
      </tr>
      <tr>
        <td id="L925" data-line-number="925"></td>
        <td id="LC925">                    {</td>
      </tr>
      <tr>
        <td id="L926" data-line-number="926"></td>
        <td id="LC926">                        <span>printf</span>(<span><span>"</span>, secondEightByte: &lt;not used&gt;<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L927" data-line-number="927"></td>
        <td id="LC927">                    }</td>
      </tr>
      <tr>
        <td id="L928" data-line-number="928"></td>
        <td id="LC928">                    <span>else</span></td>
      </tr>
      <tr>
        <td id="L929" data-line-number="929"></td>
        <td id="LC929">                    {</td>
      </tr>
      <tr>
        <td id="L930" data-line-number="930"></td>
        <td id="LC930">                        <span>printf</span>(<span><span>"</span>, secondEightByte: %s<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L931" data-line-number="931"></td>
        <td id="LC931">                               <span>getRegName</span>(<span>genMapRegArgNumToRegNum</span>(secondAllocatedRegArgNum, secondEightByteType),</td>
      </tr>
      <tr>
        <td id="L932" data-line-number="932"></td>
        <td id="LC932">                                          <span>varTypeIsFloating</span>(secondEightByteType)));</td>
      </tr>
      <tr>
        <td id="L933" data-line-number="933"></td>
        <td id="LC933">                    }</td>
      </tr>
      <tr>
        <td id="L934" data-line-number="934"></td>
        <td id="LC934">                }</td>
      </tr>
      <tr>
        <td id="L935" data-line-number="935"></td>
        <td id="LC935">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L936" data-line-number="936"></td>
        <td id="LC936">#<span>endif</span> <span><span>//</span> defined(UNIX_AMD64_ABI)</span></td>
      </tr>
      <tr>
        <td id="L937" data-line-number="937"></td>
        <td id="LC937">                {</td>
      </tr>
      <tr>
        <td id="L938" data-line-number="938"></td>
        <td id="LC938">                    isFloat            = <span>varTypeIsFloating</span>(argType);</td>
      </tr>
      <tr>
        <td id="L939" data-line-number="939"></td>
        <td id="LC939">                    <span>unsigned</span> regArgNum = <span>genMapRegNumToRegArgNum</span>(varDsc-&gt;<span>GetArgReg</span>(), argType);</td>
      </tr>
      <tr>
        <td id="L940" data-line-number="940"></td>
        <td id="LC940">
</td>
      </tr>
      <tr>
        <td id="L941" data-line-number="941"></td>
        <td id="LC941">                    <span>for</span> (<span>unsigned</span> ix = <span>0</span>; ix &lt; cSlots; ix++, regArgNum++)</td>
      </tr>
      <tr>
        <td id="L942" data-line-number="942"></td>
        <td id="LC942">                    {</td>
      </tr>
      <tr>
        <td id="L943" data-line-number="943"></td>
        <td id="LC943">                        <span>if</span> (ix &gt; <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L944" data-line-number="944"></td>
        <td id="LC944">                        {</td>
      </tr>
      <tr>
        <td id="L945" data-line-number="945"></td>
        <td id="LC945">                            <span>printf</span>(<span><span>"</span>,<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L946" data-line-number="946"></td>
        <td id="LC946">                        }</td>
      </tr>
      <tr>
        <td id="L947" data-line-number="947"></td>
        <td id="LC947">
</td>
      </tr>
      <tr>
        <td id="L948" data-line-number="948"></td>
        <td id="LC948">                        <span>if</span> (!isFloat &amp;&amp; (regArgNum &gt;= varDscInfo-&gt;<span>maxIntRegArgNum</span>)) <span><span>//</span> a struct has been split between</span></td>
      </tr>
      <tr>
        <td id="L949" data-line-number="949"></td>
        <td id="LC949">                                                                                    <span><span>//</span> registers and stack</span></td>
      </tr>
      <tr>
        <td id="L950" data-line-number="950"></td>
        <td id="LC950">                        {</td>
      </tr>
      <tr>
        <td id="L951" data-line-number="951"></td>
        <td id="LC951">                            <span>printf</span>(<span><span>"</span> stack slots:%d<span>"</span></span>, cSlots - ix);</td>
      </tr>
      <tr>
        <td id="L952" data-line-number="952"></td>
        <td id="LC952">                            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L953" data-line-number="953"></td>
        <td id="LC953">                        }</td>
      </tr>
      <tr>
        <td id="L954" data-line-number="954"></td>
        <td id="LC954">
</td>
      </tr>
      <tr>
        <td id="L955" data-line-number="955"></td>
        <td id="LC955">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L956" data-line-number="956"></td>
        <td id="LC956">                        <span>if</span> (isFloat)</td>
      </tr>
      <tr>
        <td id="L957" data-line-number="957"></td>
        <td id="LC957">                        {</td>
      </tr>
      <tr>
        <td id="L958" data-line-number="958"></td>
        <td id="LC958">                            <span><span>//</span> Print register size prefix</span></td>
      </tr>
      <tr>
        <td id="L959" data-line-number="959"></td>
        <td id="LC959">                            <span>if</span> (argType == TYP_DOUBLE)</td>
      </tr>
      <tr>
        <td id="L960" data-line-number="960"></td>
        <td id="LC960">                            {</td>
      </tr>
      <tr>
        <td id="L961" data-line-number="961"></td>
        <td id="LC961">                                <span><span>//</span> Print both registers, just to be clear</span></td>
      </tr>
      <tr>
        <td id="L962" data-line-number="962"></td>
        <td id="LC962">                                <span>printf</span>(<span><span>"</span>%s/%s<span>"</span></span>, <span>getRegName</span>(<span>genMapRegArgNumToRegNum</span>(regArgNum, argType), isFloat),</td>
      </tr>
      <tr>
        <td id="L963" data-line-number="963"></td>
        <td id="LC963">                                       <span>getRegName</span>(<span>genMapRegArgNumToRegNum</span>(regArgNum + <span>1</span>, argType), isFloat));</td>
      </tr>
      <tr>
        <td id="L964" data-line-number="964"></td>
        <td id="LC964">
</td>
      </tr>
      <tr>
        <td id="L965" data-line-number="965"></td>
        <td id="LC965">                                <span><span>//</span> doubles take 2 slots</span></td>
      </tr>
      <tr>
        <td id="L966" data-line-number="966"></td>
        <td id="LC966">                                <span>assert</span>(ix + <span>1</span> &lt; cSlots);</td>
      </tr>
      <tr>
        <td id="L967" data-line-number="967"></td>
        <td id="LC967">                                ++ix;</td>
      </tr>
      <tr>
        <td id="L968" data-line-number="968"></td>
        <td id="LC968">                                ++regArgNum;</td>
      </tr>
      <tr>
        <td id="L969" data-line-number="969"></td>
        <td id="LC969">                            }</td>
      </tr>
      <tr>
        <td id="L970" data-line-number="970"></td>
        <td id="LC970">                            <span>else</span></td>
      </tr>
      <tr>
        <td id="L971" data-line-number="971"></td>
        <td id="LC971">                            {</td>
      </tr>
      <tr>
        <td id="L972" data-line-number="972"></td>
        <td id="LC972">                                <span>printf</span>(<span><span>"</span>%s<span>"</span></span>, <span>getRegName</span>(<span>genMapRegArgNumToRegNum</span>(regArgNum, argType), isFloat));</td>
      </tr>
      <tr>
        <td id="L973" data-line-number="973"></td>
        <td id="LC973">                            }</td>
      </tr>
      <tr>
        <td id="L974" data-line-number="974"></td>
        <td id="LC974">                        }</td>
      </tr>
      <tr>
        <td id="L975" data-line-number="975"></td>
        <td id="LC975">                        <span>else</span></td>
      </tr>
      <tr>
        <td id="L976" data-line-number="976"></td>
        <td id="LC976">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L977" data-line-number="977"></td>
        <td id="LC977">                        {</td>
      </tr>
      <tr>
        <td id="L978" data-line-number="978"></td>
        <td id="LC978">                            <span>printf</span>(<span><span>"</span>%s<span>"</span></span>, <span>getRegName</span>(<span>genMapRegArgNumToRegNum</span>(regArgNum, argType), isFloat));</td>
      </tr>
      <tr>
        <td id="L979" data-line-number="979"></td>
        <td id="LC979">                        }</td>
      </tr>
      <tr>
        <td id="L980" data-line-number="980"></td>
        <td id="LC980">                    }</td>
      </tr>
      <tr>
        <td id="L981" data-line-number="981"></td>
        <td id="LC981">                }</td>
      </tr>
      <tr>
        <td id="L982" data-line-number="982"></td>
        <td id="LC982">                <span>printf</span>(<span><span>"</span><span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L983" data-line-number="983"></td>
        <td id="LC983">            }</td>
      </tr>
      <tr>
        <td id="L984" data-line-number="984"></td>
        <td id="LC984">#<span>endif</span>    <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L985" data-line-number="985"></td>
        <td id="LC985">        } <span><span>//</span> end if (canPassArgInRegisters)</span></td>
      </tr>
      <tr>
        <td id="L986" data-line-number="986"></td>
        <td id="LC986">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L987" data-line-number="987"></td>
        <td id="LC987">        {</td>
      </tr>
      <tr>
        <td id="L988" data-line-number="988"></td>
        <td id="LC988">#<span>if</span> defined(TARGET_ARM)</td>
      </tr>
      <tr>
        <td id="L989" data-line-number="989"></td>
        <td id="LC989">            varDscInfo-&gt;<span>setAllRegArgUsed</span>(argType);</td>
      </tr>
      <tr>
        <td id="L990" data-line-number="990"></td>
        <td id="LC990">            <span>if</span> (<span>varTypeIsFloating</span>(argType))</td>
      </tr>
      <tr>
        <td id="L991" data-line-number="991"></td>
        <td id="LC991">            {</td>
      </tr>
      <tr>
        <td id="L992" data-line-number="992"></td>
        <td id="LC992">                varDscInfo-&gt;<span>setAnyFloatStackArgs</span>();</td>
      </tr>
      <tr>
        <td id="L993" data-line-number="993"></td>
        <td id="LC993">            }</td>
      </tr>
      <tr>
        <td id="L994" data-line-number="994"></td>
        <td id="LC994">
</td>
      </tr>
      <tr>
        <td id="L995" data-line-number="995"></td>
        <td id="LC995">#<span>elif</span> defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L996" data-line-number="996"></td>
        <td id="LC996">
</td>
      </tr>
      <tr>
        <td id="L997" data-line-number="997"></td>
        <td id="LC997">            <span><span>//</span> If we needed to use the stack in order to pass this argument then</span></td>
      </tr>
      <tr>
        <td id="L998" data-line-number="998"></td>
        <td id="LC998">            <span><span>//</span> record the fact that we have used up any remaining registers of this 'type'</span></td>
      </tr>
      <tr>
        <td id="L999" data-line-number="999"></td>
        <td id="LC999">            <span><span>//</span> This prevents any 'backfilling' from occuring on ARM64</span></td>
      </tr>
      <tr>
        <td id="L1000" data-line-number="1000"></td>
        <td id="LC1000">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1001" data-line-number="1001"></td>
        <td id="LC1001">            varDscInfo-&gt;<span>setAllRegArgUsed</span>(argType);</td>
      </tr>
      <tr>
        <td id="L1002" data-line-number="1002"></td>
        <td id="LC1002">
</td>
      </tr>
      <tr>
        <td id="L1003" data-line-number="1003"></td>
        <td id="LC1003">#<span>endif</span> <span><span>//</span> _TARGET_XXX_</span></td>
      </tr>
      <tr>
        <td id="L1004" data-line-number="1004"></td>
        <td id="LC1004">
</td>
      </tr>
      <tr>
        <td id="L1005" data-line-number="1005"></td>
        <td id="LC1005">#<span>if</span> FEATURE_FASTTAILCALL</td>
      </tr>
      <tr>
        <td id="L1006" data-line-number="1006"></td>
        <td id="LC1006">            varDsc-&gt;<span>lvStkOffs</span> = varDscInfo-&gt;<span>stackArgSize</span>;</td>
      </tr>
      <tr>
        <td id="L1007" data-line-number="1007"></td>
        <td id="LC1007">            varDscInfo-&gt;<span>stackArgSize</span> += <span>roundUp</span>(argSize, TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L1008" data-line-number="1008"></td>
        <td id="LC1008">#<span>endif</span> <span><span>//</span> FEATURE_FASTTAILCALL</span></td>
      </tr>
      <tr>
        <td id="L1009" data-line-number="1009"></td>
        <td id="LC1009">        }</td>
      </tr>
      <tr>
        <td id="L1010" data-line-number="1010"></td>
        <td id="LC1010">
</td>
      </tr>
      <tr>
        <td id="L1011" data-line-number="1011"></td>
        <td id="LC1011">#<span>ifdef</span> UNIX_AMD64_ABI</td>
      </tr>
      <tr>
        <td id="L1012" data-line-number="1012"></td>
        <td id="LC1012">        <span><span>//</span> The arg size is returning the number of bytes of the argument. For a struct it could return a size not a</span></td>
      </tr>
      <tr>
        <td id="L1013" data-line-number="1013"></td>
        <td id="LC1013">        <span><span>//</span> multiple of TARGET_POINTER_SIZE. The stack allocated space should always be multiple of TARGET_POINTER_SIZE,</span></td>
      </tr>
      <tr>
        <td id="L1014" data-line-number="1014"></td>
        <td id="LC1014">        <span><span>//</span> so round it up.</span></td>
      </tr>
      <tr>
        <td id="L1015" data-line-number="1015"></td>
        <td id="LC1015">        compArgSize += <span>roundUp</span>(argSize, TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L1016" data-line-number="1016"></td>
        <td id="LC1016">#<span>else</span>  <span><span>//</span> !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L1017" data-line-number="1017"></td>
        <td id="LC1017">        compArgSize += argSize;</td>
      </tr>
      <tr>
        <td id="L1018" data-line-number="1018"></td>
        <td id="LC1018">#<span>endif</span> <span><span>//</span> !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L1019" data-line-number="1019"></td>
        <td id="LC1019">        <span>if</span> (info.<span>compIsVarArgs</span> || isHfaArg || isSoftFPPreSpill)</td>
      </tr>
      <tr>
        <td id="L1020" data-line-number="1020"></td>
        <td id="LC1020">        {</td>
      </tr>
      <tr>
        <td id="L1021" data-line-number="1021"></td>
        <td id="LC1021">#<span>if</span> defined(TARGET_X86)</td>
      </tr>
      <tr>
        <td id="L1022" data-line-number="1022"></td>
        <td id="LC1022">            varDsc-&gt;<span>lvStkOffs</span> = compArgSize;</td>
      </tr>
      <tr>
        <td id="L1023" data-line-number="1023"></td>
        <td id="LC1023">#<span>else</span>  <span><span>//</span> !TARGET_X86</span></td>
      </tr>
      <tr>
        <td id="L1024" data-line-number="1024"></td>
        <td id="LC1024">            <span><span>//</span> TODO-CQ: We shouldn't have to go as far as to declare these</span></td>
      </tr>
      <tr>
        <td id="L1025" data-line-number="1025"></td>
        <td id="LC1025">            <span><span>//</span> address-exposed -- DoNotEnregister should suffice.</span></td>
      </tr>
      <tr>
        <td id="L1026" data-line-number="1026"></td>
        <td id="LC1026">            <span>lvaSetVarAddrExposed</span>(varDscInfo-&gt;<span>varNum</span>);</td>
      </tr>
      <tr>
        <td id="L1027" data-line-number="1027"></td>
        <td id="LC1027">#<span>endif</span> <span><span>//</span> !TARGET_X86</span></td>
      </tr>
      <tr>
        <td id="L1028" data-line-number="1028"></td>
        <td id="LC1028">        }</td>
      </tr>
      <tr>
        <td id="L1029" data-line-number="1029"></td>
        <td id="LC1029">    } <span><span>//</span> for each user arg</span></td>
      </tr>
      <tr>
        <td id="L1030" data-line-number="1030"></td>
        <td id="LC1030">
</td>
      </tr>
      <tr>
        <td id="L1031" data-line-number="1031"></td>
        <td id="LC1031">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L1032" data-line-number="1032"></td>
        <td id="LC1032">    <span>if</span> (doubleAlignMask != RBM_NONE)</td>
      </tr>
      <tr>
        <td id="L1033" data-line-number="1033"></td>
        <td id="LC1033">    {</td>
      </tr>
      <tr>
        <td id="L1034" data-line-number="1034"></td>
        <td id="LC1034">        <span>assert</span>(RBM_ARG_REGS == <span>0xF</span>);</td>
      </tr>
      <tr>
        <td id="L1035" data-line-number="1035"></td>
        <td id="LC1035">        <span>assert</span>((doubleAlignMask &amp; RBM_ARG_REGS) == doubleAlignMask);</td>
      </tr>
      <tr>
        <td id="L1036" data-line-number="1036"></td>
        <td id="LC1036">        <span>if</span> (doubleAlignMask != RBM_NONE &amp;&amp; doubleAlignMask != RBM_ARG_REGS)</td>
      </tr>
      <tr>
        <td id="L1037" data-line-number="1037"></td>
        <td id="LC1037">        {</td>
      </tr>
      <tr>
        <td id="L1038" data-line-number="1038"></td>
        <td id="LC1038">            <span><span>//</span> doubleAlignMask can only be 0011 and/or 1100 as 'double aligned types' can</span></td>
      </tr>
      <tr>
        <td id="L1039" data-line-number="1039"></td>
        <td id="LC1039">            <span><span>//</span> begin at r0 or r2.</span></td>
      </tr>
      <tr>
        <td id="L1040" data-line-number="1040"></td>
        <td id="LC1040">            <span>assert</span>(doubleAlignMask == <span>0x3</span> || doubleAlignMask == <span>0xC</span> <span><span>/*</span> || 0xF is if'ed out <span>*/</span></span>);</td>
      </tr>
      <tr>
        <td id="L1041" data-line-number="1041"></td>
        <td id="LC1041">
</td>
      </tr>
      <tr>
        <td id="L1042" data-line-number="1042"></td>
        <td id="LC1042">            <span><span>//</span> Now if doubleAlignMask is 0011 i.e., {r0,r1} and we prespill r2 or r3</span></td>
      </tr>
      <tr>
        <td id="L1043" data-line-number="1043"></td>
        <td id="LC1043">            <span><span>//</span> but not both, then the stack would be misaligned for r0. So spill both</span></td>
      </tr>
      <tr>
        <td id="L1044" data-line-number="1044"></td>
        <td id="LC1044">            <span><span>//</span> r2 and r3.</span></td>
      </tr>
      <tr>
        <td id="L1045" data-line-number="1045"></td>
        <td id="LC1045">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1046" data-line-number="1046"></td>
        <td id="LC1046">            <span><span>//</span> ; +0 --- caller SP double aligned ----</span></td>
      </tr>
      <tr>
        <td id="L1047" data-line-number="1047"></td>
        <td id="LC1047">            <span><span>//</span> ; -4 r2    r3</span></td>
      </tr>
      <tr>
        <td id="L1048" data-line-number="1048"></td>
        <td id="LC1048">            <span><span>//</span> ; -8 r1    r1</span></td>
      </tr>
      <tr>
        <td id="L1049" data-line-number="1049"></td>
        <td id="LC1049">            <span><span>//</span> ; -c r0    r0   &lt;-- misaligned.</span></td>
      </tr>
      <tr>
        <td id="L1050" data-line-number="1050"></td>
        <td id="LC1050">            <span><span>//</span> ; callee saved regs</span></td>
      </tr>
      <tr>
        <td id="L1051" data-line-number="1051"></td>
        <td id="LC1051">            <span>if</span> (doubleAlignMask == <span>0x3</span> &amp;&amp; doubleAlignMask != codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L1052" data-line-number="1052"></td>
        <td id="LC1052">            {</td>
      </tr>
      <tr>
        <td id="L1053" data-line-number="1053"></td>
        <td id="LC1053">                codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillAlign</span> =</td>
      </tr>
      <tr>
        <td id="L1054" data-line-number="1054"></td>
        <td id="LC1054">                    (~codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegArg</span> &amp; ~doubleAlignMask) &amp; RBM_ARG_REGS;</td>
      </tr>
      <tr>
        <td id="L1055" data-line-number="1055"></td>
        <td id="LC1055">            }</td>
      </tr>
      <tr>
        <td id="L1056" data-line-number="1056"></td>
        <td id="LC1056">        }</td>
      </tr>
      <tr>
        <td id="L1057" data-line-number="1057"></td>
        <td id="LC1057">    }</td>
      </tr>
      <tr>
        <td id="L1058" data-line-number="1058"></td>
        <td id="LC1058">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L1059" data-line-number="1059"></td>
        <td id="LC1059">}</td>
      </tr>
      <tr>
        <td id="L1060" data-line-number="1060"></td>
        <td id="LC1060">
</td>
      </tr>
      <tr>
        <td id="L1061" data-line-number="1061"></td>
        <td id="LC1061"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1062" data-line-number="1062"></td>
        <td id="LC1062"><span>void</span> <span>Compiler::lvaInitGenericsCtxt</span>(InitVarDscInfo* varDscInfo)</td>
      </tr>
      <tr>
        <td id="L1063" data-line-number="1063"></td>
        <td id="LC1063">{</td>
      </tr>
      <tr>
        <td id="L1064" data-line-number="1064"></td>
        <td id="LC1064">    <span><span>//</span>@GENERICS: final instantiation-info argument for shared generic methods</span></td>
      </tr>
      <tr>
        <td id="L1065" data-line-number="1065"></td>
        <td id="LC1065">    <span><span>//</span> and shared generic struct instance methods</span></td>
      </tr>
      <tr>
        <td id="L1066" data-line-number="1066"></td>
        <td id="LC1066">    <span>if</span> (info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>callConv</span> &amp; CORINFO_CALLCONV_PARAMTYPE)</td>
      </tr>
      <tr>
        <td id="L1067" data-line-number="1067"></td>
        <td id="LC1067">    {</td>
      </tr>
      <tr>
        <td id="L1068" data-line-number="1068"></td>
        <td id="LC1068">        info.<span>compTypeCtxtArg</span> = varDscInfo-&gt;<span>varNum</span>;</td>
      </tr>
      <tr>
        <td id="L1069" data-line-number="1069"></td>
        <td id="LC1069">
</td>
      </tr>
      <tr>
        <td id="L1070" data-line-number="1070"></td>
        <td id="LC1070">        LclVarDsc* varDsc = varDscInfo-&gt;<span>varDsc</span>;</td>
      </tr>
      <tr>
        <td id="L1071" data-line-number="1071"></td>
        <td id="LC1071">        varDsc-&gt;<span>lvIsParam</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L1072" data-line-number="1072"></td>
        <td id="LC1072">        varDsc-&gt;<span>lvType</span>    = TYP_I_IMPL;</td>
      </tr>
      <tr>
        <td id="L1073" data-line-number="1073"></td>
        <td id="LC1073">
</td>
      </tr>
      <tr>
        <td id="L1074" data-line-number="1074"></td>
        <td id="LC1074">        <span>if</span> (varDscInfo-&gt;<span>canEnreg</span>(TYP_I_IMPL))</td>
      </tr>
      <tr>
        <td id="L1075" data-line-number="1075"></td>
        <td id="LC1075">        {</td>
      </tr>
      <tr>
        <td id="L1076" data-line-number="1076"></td>
        <td id="LC1076">            <span><span>/*</span> Another register argument <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1077" data-line-number="1077"></td>
        <td id="LC1077">
</td>
      </tr>
      <tr>
        <td id="L1078" data-line-number="1078"></td>
        <td id="LC1078">            varDsc-&gt;<span>lvIsRegArg</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L1079" data-line-number="1079"></td>
        <td id="LC1079">            varDsc-&gt;<span>SetArgReg</span>(<span>genMapRegArgNumToRegNum</span>(varDscInfo-&gt;<span>regArgNum</span>(TYP_INT), varDsc-&gt;<span>TypeGet</span>()));</td>
      </tr>
      <tr>
        <td id="L1080" data-line-number="1080"></td>
        <td id="LC1080">#<span>if</span> FEATURE_MULTIREG_ARGS</td>
      </tr>
      <tr>
        <td id="L1081" data-line-number="1081"></td>
        <td id="LC1081">            varDsc-&gt;<span>SetOtherArgReg</span>(REG_NA);</td>
      </tr>
      <tr>
        <td id="L1082" data-line-number="1082"></td>
        <td id="LC1082">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1083" data-line-number="1083"></td>
        <td id="LC1083">            varDsc-&gt;<span>lvOnFrame</span> = <span>true</span>; <span><span>//</span> The final home for this incoming register might be our local stack frame</span></td>
      </tr>
      <tr>
        <td id="L1084" data-line-number="1084"></td>
        <td id="LC1084">
</td>
      </tr>
      <tr>
        <td id="L1085" data-line-number="1085"></td>
        <td id="LC1085">            varDscInfo-&gt;<span>intRegArgNum</span>++;</td>
      </tr>
      <tr>
        <td id="L1086" data-line-number="1086"></td>
        <td id="LC1086">
</td>
      </tr>
      <tr>
        <td id="L1087" data-line-number="1087"></td>
        <td id="LC1087">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L1088" data-line-number="1088"></td>
        <td id="LC1088">            <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L1089" data-line-number="1089"></td>
        <td id="LC1089">            {</td>
      </tr>
      <tr>
        <td id="L1090" data-line-number="1090"></td>
        <td id="LC1090">                <span>printf</span>(<span><span>"</span>'GenCtxt'   passed in register %s<span>\n</span><span>"</span></span>, <span>getRegName</span>(varDsc-&gt;<span>GetArgReg</span>()));</td>
      </tr>
      <tr>
        <td id="L1091" data-line-number="1091"></td>
        <td id="LC1091">            }</td>
      </tr>
      <tr>
        <td id="L1092" data-line-number="1092"></td>
        <td id="LC1092">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1093" data-line-number="1093"></td>
        <td id="LC1093">        }</td>
      </tr>
      <tr>
        <td id="L1094" data-line-number="1094"></td>
        <td id="LC1094">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L1095" data-line-number="1095"></td>
        <td id="LC1095">        {</td>
      </tr>
      <tr>
        <td id="L1096" data-line-number="1096"></td>
        <td id="LC1096">            <span><span>//</span> We need to mark these as being on the stack, as this is not done elsewhere in the case that canEnreg</span></td>
      </tr>
      <tr>
        <td id="L1097" data-line-number="1097"></td>
        <td id="LC1097">            <span><span>//</span> returns false.</span></td>
      </tr>
      <tr>
        <td id="L1098" data-line-number="1098"></td>
        <td id="LC1098">            varDsc-&gt;<span>lvOnFrame</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1099" data-line-number="1099"></td>
        <td id="LC1099">#<span>if</span> FEATURE_FASTTAILCALL</td>
      </tr>
      <tr>
        <td id="L1100" data-line-number="1100"></td>
        <td id="LC1100">            varDsc-&gt;<span>lvStkOffs</span> = varDscInfo-&gt;<span>stackArgSize</span>;</td>
      </tr>
      <tr>
        <td id="L1101" data-line-number="1101"></td>
        <td id="LC1101">            varDscInfo-&gt;<span>stackArgSize</span> += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L1102" data-line-number="1102"></td>
        <td id="LC1102">#<span>endif</span> <span><span>//</span> FEATURE_FASTTAILCALL</span></td>
      </tr>
      <tr>
        <td id="L1103" data-line-number="1103"></td>
        <td id="LC1103">        }</td>
      </tr>
      <tr>
        <td id="L1104" data-line-number="1104"></td>
        <td id="LC1104">
</td>
      </tr>
      <tr>
        <td id="L1105" data-line-number="1105"></td>
        <td id="LC1105">        compArgSize += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L1106" data-line-number="1106"></td>
        <td id="LC1106">
</td>
      </tr>
      <tr>
        <td id="L1107" data-line-number="1107"></td>
        <td id="LC1107">#<span>if</span> defined(TARGET_X86)</td>
      </tr>
      <tr>
        <td id="L1108" data-line-number="1108"></td>
        <td id="LC1108">        <span>if</span> (info.<span>compIsVarArgs</span>)</td>
      </tr>
      <tr>
        <td id="L1109" data-line-number="1109"></td>
        <td id="LC1109">            varDsc-&gt;<span>lvStkOffs</span> = compArgSize;</td>
      </tr>
      <tr>
        <td id="L1110" data-line-number="1110"></td>
        <td id="LC1110">#<span>endif</span> <span><span>//</span> TARGET_X86</span></td>
      </tr>
      <tr>
        <td id="L1111" data-line-number="1111"></td>
        <td id="LC1111">
</td>
      </tr>
      <tr>
        <td id="L1112" data-line-number="1112"></td>
        <td id="LC1112">        varDscInfo-&gt;<span>varNum</span>++;</td>
      </tr>
      <tr>
        <td id="L1113" data-line-number="1113"></td>
        <td id="LC1113">        varDscInfo-&gt;<span>varDsc</span>++;</td>
      </tr>
      <tr>
        <td id="L1114" data-line-number="1114"></td>
        <td id="LC1114">    }</td>
      </tr>
      <tr>
        <td id="L1115" data-line-number="1115"></td>
        <td id="LC1115">}</td>
      </tr>
      <tr>
        <td id="L1116" data-line-number="1116"></td>
        <td id="LC1116">
</td>
      </tr>
      <tr>
        <td id="L1117" data-line-number="1117"></td>
        <td id="LC1117"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1118" data-line-number="1118"></td>
        <td id="LC1118"><span>void</span> <span>Compiler::lvaInitVarArgsHandle</span>(InitVarDscInfo* varDscInfo)</td>
      </tr>
      <tr>
        <td id="L1119" data-line-number="1119"></td>
        <td id="LC1119">{</td>
      </tr>
      <tr>
        <td id="L1120" data-line-number="1120"></td>
        <td id="LC1120">    <span>if</span> (info.<span>compIsVarArgs</span>)</td>
      </tr>
      <tr>
        <td id="L1121" data-line-number="1121"></td>
        <td id="LC1121">    {</td>
      </tr>
      <tr>
        <td id="L1122" data-line-number="1122"></td>
        <td id="LC1122">        lvaVarargsHandleArg = varDscInfo-&gt;<span>varNum</span>;</td>
      </tr>
      <tr>
        <td id="L1123" data-line-number="1123"></td>
        <td id="LC1123">
</td>
      </tr>
      <tr>
        <td id="L1124" data-line-number="1124"></td>
        <td id="LC1124">        LclVarDsc* varDsc = varDscInfo-&gt;<span>varDsc</span>;</td>
      </tr>
      <tr>
        <td id="L1125" data-line-number="1125"></td>
        <td id="LC1125">        varDsc-&gt;<span>lvType</span>    = TYP_I_IMPL;</td>
      </tr>
      <tr>
        <td id="L1126" data-line-number="1126"></td>
        <td id="LC1126">        varDsc-&gt;<span>lvIsParam</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L1127" data-line-number="1127"></td>
        <td id="LC1127">        <span><span>//</span> Make sure this lives in the stack -- address may be reported to the VM.</span></td>
      </tr>
      <tr>
        <td id="L1128" data-line-number="1128"></td>
        <td id="LC1128">        <span><span>//</span> TODO-CQ: This should probably be:</span></td>
      </tr>
      <tr>
        <td id="L1129" data-line-number="1129"></td>
        <td id="LC1129">        <span><span>//</span>   lvaSetVarDoNotEnregister(varDscInfo-&gt;varNum DEBUGARG(DNER_VMNeedsStackAddr));</span></td>
      </tr>
      <tr>
        <td id="L1130" data-line-number="1130"></td>
        <td id="LC1130">        <span><span>//</span> But that causes problems, so, for expedience, I switched back to this heavyweight</span></td>
      </tr>
      <tr>
        <td id="L1131" data-line-number="1131"></td>
        <td id="LC1131">        <span><span>//</span> hammer.  But I think it should be possible to switch; it may just work now</span></td>
      </tr>
      <tr>
        <td id="L1132" data-line-number="1132"></td>
        <td id="LC1132">        <span><span>//</span> that other problems are fixed.</span></td>
      </tr>
      <tr>
        <td id="L1133" data-line-number="1133"></td>
        <td id="LC1133">        <span>lvaSetVarAddrExposed</span>(varDscInfo-&gt;<span>varNum</span>);</td>
      </tr>
      <tr>
        <td id="L1134" data-line-number="1134"></td>
        <td id="LC1134">
</td>
      </tr>
      <tr>
        <td id="L1135" data-line-number="1135"></td>
        <td id="LC1135">        <span>if</span> (varDscInfo-&gt;<span>canEnreg</span>(TYP_I_IMPL))</td>
      </tr>
      <tr>
        <td id="L1136" data-line-number="1136"></td>
        <td id="LC1136">        {</td>
      </tr>
      <tr>
        <td id="L1137" data-line-number="1137"></td>
        <td id="LC1137">            <span><span>/*</span> Another register argument <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1138" data-line-number="1138"></td>
        <td id="LC1138">
</td>
      </tr>
      <tr>
        <td id="L1139" data-line-number="1139"></td>
        <td id="LC1139">            <span>unsigned</span> varArgHndArgNum = varDscInfo-&gt;<span>allocRegArg</span>(TYP_I_IMPL);</td>
      </tr>
      <tr>
        <td id="L1140" data-line-number="1140"></td>
        <td id="LC1140">
</td>
      </tr>
      <tr>
        <td id="L1141" data-line-number="1141"></td>
        <td id="LC1141">            varDsc-&gt;<span>lvIsRegArg</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L1142" data-line-number="1142"></td>
        <td id="LC1142">            varDsc-&gt;<span>SetArgReg</span>(<span>genMapRegArgNumToRegNum</span>(varArgHndArgNum, TYP_I_IMPL));</td>
      </tr>
      <tr>
        <td id="L1143" data-line-number="1143"></td>
        <td id="LC1143">#<span>if</span> FEATURE_MULTIREG_ARGS</td>
      </tr>
      <tr>
        <td id="L1144" data-line-number="1144"></td>
        <td id="LC1144">            varDsc-&gt;<span>SetOtherArgReg</span>(REG_NA);</td>
      </tr>
      <tr>
        <td id="L1145" data-line-number="1145"></td>
        <td id="LC1145">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1146" data-line-number="1146"></td>
        <td id="LC1146">            varDsc-&gt;<span>lvOnFrame</span> = <span>true</span>; <span><span>//</span> The final home for this incoming register might be our local stack frame</span></td>
      </tr>
      <tr>
        <td id="L1147" data-line-number="1147"></td>
        <td id="LC1147">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L1148" data-line-number="1148"></td>
        <td id="LC1148">            <span><span>//</span> This has to be spilled right in front of the real arguments and we have</span></td>
      </tr>
      <tr>
        <td id="L1149" data-line-number="1149"></td>
        <td id="LC1149">            <span><span>//</span> to pre-spill all the argument registers explicitly because we only have</span></td>
      </tr>
      <tr>
        <td id="L1150" data-line-number="1150"></td>
        <td id="LC1150">            <span><span>//</span> have symbols for the declared ones, not any potential variadic ones.</span></td>
      </tr>
      <tr>
        <td id="L1151" data-line-number="1151"></td>
        <td id="LC1151">            <span>for</span> (<span>unsigned</span> ix = varArgHndArgNum; ix &lt; <span>ArrLen</span>(intArgMasks); ix++)</td>
      </tr>
      <tr>
        <td id="L1152" data-line-number="1152"></td>
        <td id="LC1152">            {</td>
      </tr>
      <tr>
        <td id="L1153" data-line-number="1153"></td>
        <td id="LC1153">                codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegArg</span> |= intArgMasks[ix];</td>
      </tr>
      <tr>
        <td id="L1154" data-line-number="1154"></td>
        <td id="LC1154">            }</td>
      </tr>
      <tr>
        <td id="L1155" data-line-number="1155"></td>
        <td id="LC1155">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L1156" data-line-number="1156"></td>
        <td id="LC1156">
</td>
      </tr>
      <tr>
        <td id="L1157" data-line-number="1157"></td>
        <td id="LC1157">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L1158" data-line-number="1158"></td>
        <td id="LC1158">            <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L1159" data-line-number="1159"></td>
        <td id="LC1159">            {</td>
      </tr>
      <tr>
        <td id="L1160" data-line-number="1160"></td>
        <td id="LC1160">                <span>printf</span>(<span><span>"</span>'VarArgHnd' passed in register %s<span>\n</span><span>"</span></span>, <span>getRegName</span>(varDsc-&gt;<span>GetArgReg</span>()));</td>
      </tr>
      <tr>
        <td id="L1161" data-line-number="1161"></td>
        <td id="LC1161">            }</td>
      </tr>
      <tr>
        <td id="L1162" data-line-number="1162"></td>
        <td id="LC1162">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L1163" data-line-number="1163"></td>
        <td id="LC1163">        }</td>
      </tr>
      <tr>
        <td id="L1164" data-line-number="1164"></td>
        <td id="LC1164">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L1165" data-line-number="1165"></td>
        <td id="LC1165">        {</td>
      </tr>
      <tr>
        <td id="L1166" data-line-number="1166"></td>
        <td id="LC1166">            <span><span>//</span> We need to mark these as being on the stack, as this is not done elsewhere in the case that canEnreg</span></td>
      </tr>
      <tr>
        <td id="L1167" data-line-number="1167"></td>
        <td id="LC1167">            <span><span>//</span> returns false.</span></td>
      </tr>
      <tr>
        <td id="L1168" data-line-number="1168"></td>
        <td id="LC1168">            varDsc-&gt;<span>lvOnFrame</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1169" data-line-number="1169"></td>
        <td id="LC1169">#<span>if</span> FEATURE_FASTTAILCALL</td>
      </tr>
      <tr>
        <td id="L1170" data-line-number="1170"></td>
        <td id="LC1170">            varDsc-&gt;<span>lvStkOffs</span> = varDscInfo-&gt;<span>stackArgSize</span>;</td>
      </tr>
      <tr>
        <td id="L1171" data-line-number="1171"></td>
        <td id="LC1171">            varDscInfo-&gt;<span>stackArgSize</span> += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L1172" data-line-number="1172"></td>
        <td id="LC1172">#<span>endif</span> <span><span>//</span> FEATURE_FASTTAILCALL</span></td>
      </tr>
      <tr>
        <td id="L1173" data-line-number="1173"></td>
        <td id="LC1173">        }</td>
      </tr>
      <tr>
        <td id="L1174" data-line-number="1174"></td>
        <td id="LC1174">
</td>
      </tr>
      <tr>
        <td id="L1175" data-line-number="1175"></td>
        <td id="LC1175">        <span><span>/*</span> Update the total argument size, count and varDsc <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1176" data-line-number="1176"></td>
        <td id="LC1176">
</td>
      </tr>
      <tr>
        <td id="L1177" data-line-number="1177"></td>
        <td id="LC1177">        compArgSize += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L1178" data-line-number="1178"></td>
        <td id="LC1178">
</td>
      </tr>
      <tr>
        <td id="L1179" data-line-number="1179"></td>
        <td id="LC1179">        varDscInfo-&gt;<span>varNum</span>++;</td>
      </tr>
      <tr>
        <td id="L1180" data-line-number="1180"></td>
        <td id="LC1180">        varDscInfo-&gt;<span>varDsc</span>++;</td>
      </tr>
      <tr>
        <td id="L1181" data-line-number="1181"></td>
        <td id="LC1181">
</td>
      </tr>
      <tr>
        <td id="L1182" data-line-number="1182"></td>
        <td id="LC1182">#<span>if</span> defined(TARGET_X86)</td>
      </tr>
      <tr>
        <td id="L1183" data-line-number="1183"></td>
        <td id="LC1183">        varDsc-&gt;<span>lvStkOffs</span> = compArgSize;</td>
      </tr>
      <tr>
        <td id="L1184" data-line-number="1184"></td>
        <td id="LC1184">
</td>
      </tr>
      <tr>
        <td id="L1185" data-line-number="1185"></td>
        <td id="LC1185">        <span><span>//</span> Allocate a temp to point at the beginning of the args</span></td>
      </tr>
      <tr>
        <td id="L1186" data-line-number="1186"></td>
        <td id="LC1186">
</td>
      </tr>
      <tr>
        <td id="L1187" data-line-number="1187"></td>
        <td id="LC1187">        lvaVarargsBaseOfStkArgs                  = <span>lvaGrabTemp</span>(<span>false</span> <span>DEBUGARG</span>(<span><span>"</span>Varargs BaseOfStkArgs<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L1188" data-line-number="1188"></td>
        <td id="LC1188">        lvaTable[lvaVarargsBaseOfStkArgs].<span>lvType</span> = TYP_I_IMPL;</td>
      </tr>
      <tr>
        <td id="L1189" data-line-number="1189"></td>
        <td id="LC1189">
</td>
      </tr>
      <tr>
        <td id="L1190" data-line-number="1190"></td>
        <td id="LC1190">#<span>endif</span> <span><span>//</span> TARGET_X86</span></td>
      </tr>
      <tr>
        <td id="L1191" data-line-number="1191"></td>
        <td id="LC1191">    }</td>
      </tr>
      <tr>
        <td id="L1192" data-line-number="1192"></td>
        <td id="LC1192">}</td>
      </tr>
      <tr>
        <td id="L1193" data-line-number="1193"></td>
        <td id="LC1193">
</td>
      </tr>
      <tr>
        <td id="L1194" data-line-number="1194"></td>
        <td id="LC1194"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1195" data-line-number="1195"></td>
        <td id="LC1195"><span>void</span> <span>Compiler::lvaInitVarDsc</span>(LclVarDsc*              varDsc,</td>
      </tr>
      <tr>
        <td id="L1196" data-line-number="1196"></td>
        <td id="LC1196">                             <span>unsigned</span>                varNum,</td>
      </tr>
      <tr>
        <td id="L1197" data-line-number="1197"></td>
        <td id="LC1197">                             CorInfoType             corInfoType,</td>
      </tr>
      <tr>
        <td id="L1198" data-line-number="1198"></td>
        <td id="LC1198">                             CORINFO_CLASS_HANDLE    typeHnd,</td>
      </tr>
      <tr>
        <td id="L1199" data-line-number="1199"></td>
        <td id="LC1199">                             CORINFO_ARG_LIST_HANDLE varList,</td>
      </tr>
      <tr>
        <td id="L1200" data-line-number="1200"></td>
        <td id="LC1200">                             CORINFO_SIG_INFO*       varSig)</td>
      </tr>
      <tr>
        <td id="L1201" data-line-number="1201"></td>
        <td id="LC1201">{</td>
      </tr>
      <tr>
        <td id="L1202" data-line-number="1202"></td>
        <td id="LC1202">    <span>noway_assert</span>(varDsc == &amp;lvaTable[varNum]);</td>
      </tr>
      <tr>
        <td id="L1203" data-line-number="1203"></td>
        <td id="LC1203">
</td>
      </tr>
      <tr>
        <td id="L1204" data-line-number="1204"></td>
        <td id="LC1204">    <span>switch</span> (corInfoType)</td>
      </tr>
      <tr>
        <td id="L1205" data-line-number="1205"></td>
        <td id="LC1205">    {</td>
      </tr>
      <tr>
        <td id="L1206" data-line-number="1206"></td>
        <td id="LC1206">        <span><span>//</span> Mark types that looks like a pointer for doing shadow-copying of</span></td>
      </tr>
      <tr>
        <td id="L1207" data-line-number="1207"></td>
        <td id="LC1207">        <span><span>//</span> parameters if we have an unsafe buffer.</span></td>
      </tr>
      <tr>
        <td id="L1208" data-line-number="1208"></td>
        <td id="LC1208">        <span><span>//</span> Note that this does not handle structs with pointer fields. Instead,</span></td>
      </tr>
      <tr>
        <td id="L1209" data-line-number="1209"></td>
        <td id="LC1209">        <span><span>//</span> we rely on using the assign-groups/equivalence-groups in</span></td>
      </tr>
      <tr>
        <td id="L1210" data-line-number="1210"></td>
        <td id="LC1210">        <span><span>//</span> gsFindVulnerableParams() to determine if a buffer-struct contains a</span></td>
      </tr>
      <tr>
        <td id="L1211" data-line-number="1211"></td>
        <td id="LC1211">        <span><span>//</span> pointer. We could do better by having the EE determine this for us.</span></td>
      </tr>
      <tr>
        <td id="L1212" data-line-number="1212"></td>
        <td id="LC1212">        <span><span>//</span> Note that we want to keep buffers without pointers at lower memory</span></td>
      </tr>
      <tr>
        <td id="L1213" data-line-number="1213"></td>
        <td id="LC1213">        <span><span>//</span> addresses than buffers with pointers.</span></td>
      </tr>
      <tr>
        <td id="L1214" data-line-number="1214"></td>
        <td id="LC1214">        <span>case</span> CORINFO_TYPE_PTR:</td>
      </tr>
      <tr>
        <td id="L1215" data-line-number="1215"></td>
        <td id="LC1215">        <span>case</span> CORINFO_TYPE_BYREF:</td>
      </tr>
      <tr>
        <td id="L1216" data-line-number="1216"></td>
        <td id="LC1216">        <span>case</span> CORINFO_TYPE_CLASS:</td>
      </tr>
      <tr>
        <td id="L1217" data-line-number="1217"></td>
        <td id="LC1217">        <span>case</span> CORINFO_TYPE_STRING:</td>
      </tr>
      <tr>
        <td id="L1218" data-line-number="1218"></td>
        <td id="LC1218">        <span>case</span> CORINFO_TYPE_VAR:</td>
      </tr>
      <tr>
        <td id="L1219" data-line-number="1219"></td>
        <td id="LC1219">        <span>case</span> CORINFO_TYPE_REFANY:</td>
      </tr>
      <tr>
        <td id="L1220" data-line-number="1220"></td>
        <td id="LC1220">            varDsc-&gt;<span>lvIsPtr</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L1221" data-line-number="1221"></td>
        <td id="LC1221">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L1222" data-line-number="1222"></td>
        <td id="LC1222">        <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L1223" data-line-number="1223"></td>
        <td id="LC1223">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L1224" data-line-number="1224"></td>
        <td id="LC1224">    }</td>
      </tr>
      <tr>
        <td id="L1225" data-line-number="1225"></td>
        <td id="LC1225">
</td>
      </tr>
      <tr>
        <td id="L1226" data-line-number="1226"></td>
        <td id="LC1226">    var_types type = <span>JITtype2varType</span>(corInfoType);</td>
      </tr>
      <tr>
        <td id="L1227" data-line-number="1227"></td>
        <td id="LC1227">    <span>if</span> (<span>varTypeIsFloating</span>(type))</td>
      </tr>
      <tr>
        <td id="L1228" data-line-number="1228"></td>
        <td id="LC1228">    {</td>
      </tr>
      <tr>
        <td id="L1229" data-line-number="1229"></td>
        <td id="LC1229">        compFloatingPointUsed = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1230" data-line-number="1230"></td>
        <td id="LC1230">    }</td>
      </tr>
      <tr>
        <td id="L1231" data-line-number="1231"></td>
        <td id="LC1231">
</td>
      </tr>
      <tr>
        <td id="L1232" data-line-number="1232"></td>
        <td id="LC1232">    <span>if</span> (tiVerificationNeeded)</td>
      </tr>
      <tr>
        <td id="L1233" data-line-number="1233"></td>
        <td id="LC1233">    {</td>
      </tr>
      <tr>
        <td id="L1234" data-line-number="1234"></td>
        <td id="LC1234">        varDsc-&gt;<span>lvVerTypeInfo</span> = <span>verParseArgSigToTypeInfo</span>(varSig, varList);</td>
      </tr>
      <tr>
        <td id="L1235" data-line-number="1235"></td>
        <td id="LC1235">    }</td>
      </tr>
      <tr>
        <td id="L1236" data-line-number="1236"></td>
        <td id="LC1236">
</td>
      </tr>
      <tr>
        <td id="L1237" data-line-number="1237"></td>
        <td id="LC1237">    <span>if</span> (tiVerificationNeeded)</td>
      </tr>
      <tr>
        <td id="L1238" data-line-number="1238"></td>
        <td id="LC1238">    {</td>
      </tr>
      <tr>
        <td id="L1239" data-line-number="1239"></td>
        <td id="LC1239">        <span>if</span> (varDsc-&gt;<span>lvIsParam</span>)</td>
      </tr>
      <tr>
        <td id="L1240" data-line-number="1240"></td>
        <td id="LC1240">        {</td>
      </tr>
      <tr>
        <td id="L1241" data-line-number="1241"></td>
        <td id="LC1241">            <span><span>//</span> For an incoming ValueType we better be able to have the full type information</span></td>
      </tr>
      <tr>
        <td id="L1242" data-line-number="1242"></td>
        <td id="LC1242">            <span><span>//</span> so that we can layout the parameter offsets correctly</span></td>
      </tr>
      <tr>
        <td id="L1243" data-line-number="1243"></td>
        <td id="LC1243">
</td>
      </tr>
      <tr>
        <td id="L1244" data-line-number="1244"></td>
        <td id="LC1244">            <span>if</span> (<span>varTypeIsStruct</span>(type) &amp;&amp; varDsc-&gt;<span>lvVerTypeInfo</span>.<span>IsDead</span>())</td>
      </tr>
      <tr>
        <td id="L1245" data-line-number="1245"></td>
        <td id="LC1245">            {</td>
      </tr>
      <tr>
        <td id="L1246" data-line-number="1246"></td>
        <td id="LC1246">                <span>BADCODE</span>(<span><span>"</span>invalid ValueType parameter<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L1247" data-line-number="1247"></td>
        <td id="LC1247">            }</td>
      </tr>
      <tr>
        <td id="L1248" data-line-number="1248"></td>
        <td id="LC1248">
</td>
      </tr>
      <tr>
        <td id="L1249" data-line-number="1249"></td>
        <td id="LC1249">            <span><span>//</span> For an incoming reference type we need to verify that the actual type is</span></td>
      </tr>
      <tr>
        <td id="L1250" data-line-number="1250"></td>
        <td id="LC1250">            <span><span>//</span> a reference type and not a valuetype.</span></td>
      </tr>
      <tr>
        <td id="L1251" data-line-number="1251"></td>
        <td id="LC1251">
</td>
      </tr>
      <tr>
        <td id="L1252" data-line-number="1252"></td>
        <td id="LC1252">            <span>if</span> (type == TYP_REF &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L1253" data-line-number="1253"></td>
        <td id="LC1253">                !(varDsc-&gt;<span>lvVerTypeInfo</span>.<span>IsType</span>(TI_REF) || varDsc-&gt;<span>lvVerTypeInfo</span>.<span>IsUnboxedGenericTypeVar</span>()))</td>
      </tr>
      <tr>
        <td id="L1254" data-line-number="1254"></td>
        <td id="LC1254">            {</td>
      </tr>
      <tr>
        <td id="L1255" data-line-number="1255"></td>
        <td id="LC1255">                <span>BADCODE</span>(<span><span>"</span>parameter type mismatch<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L1256" data-line-number="1256"></td>
        <td id="LC1256">            }</td>
      </tr>
      <tr>
        <td id="L1257" data-line-number="1257"></td>
        <td id="LC1257">        }</td>
      </tr>
      <tr>
        <td id="L1258" data-line-number="1258"></td>
        <td id="LC1258">
</td>
      </tr>
      <tr>
        <td id="L1259" data-line-number="1259"></td>
        <td id="LC1259">        <span><span>//</span> Disallow byrefs to byref like objects (ArgTypeHandle)</span></td>
      </tr>
      <tr>
        <td id="L1260" data-line-number="1260"></td>
        <td id="LC1260">        <span><span>//</span> techncally we could get away with just not setting them</span></td>
      </tr>
      <tr>
        <td id="L1261" data-line-number="1261"></td>
        <td id="LC1261">        <span>if</span> (varDsc-&gt;<span>lvVerTypeInfo</span>.<span>IsByRef</span>() &amp;&amp; <span>verIsByRefLike</span>(<span>DereferenceByRef</span>(varDsc-&gt;<span>lvVerTypeInfo</span>)))</td>
      </tr>
      <tr>
        <td id="L1262" data-line-number="1262"></td>
        <td id="LC1262">        {</td>
      </tr>
      <tr>
        <td id="L1263" data-line-number="1263"></td>
        <td id="LC1263">            varDsc-&gt;<span>lvVerTypeInfo</span> = <span>typeInfo</span>();</td>
      </tr>
      <tr>
        <td id="L1264" data-line-number="1264"></td>
        <td id="LC1264">        }</td>
      </tr>
      <tr>
        <td id="L1265" data-line-number="1265"></td>
        <td id="LC1265">
</td>
      </tr>
      <tr>
        <td id="L1266" data-line-number="1266"></td>
        <td id="LC1266">        <span><span>//</span> we don't want the EE to assert in lvaSetStruct on bad sigs, so change</span></td>
      </tr>
      <tr>
        <td id="L1267" data-line-number="1267"></td>
        <td id="LC1267">        <span><span>//</span> the JIT type to avoid even trying to call back</span></td>
      </tr>
      <tr>
        <td id="L1268" data-line-number="1268"></td>
        <td id="LC1268">        <span>if</span> (<span>varTypeIsStruct</span>(type) &amp;&amp; varDsc-&gt;<span>lvVerTypeInfo</span>.<span>IsDead</span>())</td>
      </tr>
      <tr>
        <td id="L1269" data-line-number="1269"></td>
        <td id="LC1269">        {</td>
      </tr>
      <tr>
        <td id="L1270" data-line-number="1270"></td>
        <td id="LC1270">            type = TYP_VOID;</td>
      </tr>
      <tr>
        <td id="L1271" data-line-number="1271"></td>
        <td id="LC1271">        }</td>
      </tr>
      <tr>
        <td id="L1272" data-line-number="1272"></td>
        <td id="LC1272">    }</td>
      </tr>
      <tr>
        <td id="L1273" data-line-number="1273"></td>
        <td id="LC1273">
</td>
      </tr>
      <tr>
        <td id="L1274" data-line-number="1274"></td>
        <td id="LC1274">    <span>if</span> (typeHnd)</td>
      </tr>
      <tr>
        <td id="L1275" data-line-number="1275"></td>
        <td id="LC1275">    {</td>
      </tr>
      <tr>
        <td id="L1276" data-line-number="1276"></td>
        <td id="LC1276">        <span>unsigned</span> cFlags = info.<span>compCompHnd</span>-&gt;<span>getClassAttribs</span>(typeHnd);</td>
      </tr>
      <tr>
        <td id="L1277" data-line-number="1277"></td>
        <td id="LC1277">
</td>
      </tr>
      <tr>
        <td id="L1278" data-line-number="1278"></td>
        <td id="LC1278">        <span><span>//</span> We can get typeHnds for primitive types, these are value types which only contain</span></td>
      </tr>
      <tr>
        <td id="L1279" data-line-number="1279"></td>
        <td id="LC1279">        <span><span>//</span> a primitive. We will need the typeHnd to distinguish them, so we store it here.</span></td>
      </tr>
      <tr>
        <td id="L1280" data-line-number="1280"></td>
        <td id="LC1280">        <span>if</span> ((cFlags &amp; CORINFO_FLG_VALUECLASS) &amp;&amp; !<span>varTypeIsStruct</span>(type))</td>
      </tr>
      <tr>
        <td id="L1281" data-line-number="1281"></td>
        <td id="LC1281">        {</td>
      </tr>
      <tr>
        <td id="L1282" data-line-number="1282"></td>
        <td id="LC1282">            <span>if</span> (tiVerificationNeeded == <span>false</span>)</td>
      </tr>
      <tr>
        <td id="L1283" data-line-number="1283"></td>
        <td id="LC1283">            {</td>
      </tr>
      <tr>
        <td id="L1284" data-line-number="1284"></td>
        <td id="LC1284">                <span><span>//</span> printf("This is a struct that the JIT will treat as a primitive\n");</span></td>
      </tr>
      <tr>
        <td id="L1285" data-line-number="1285"></td>
        <td id="LC1285">                varDsc-&gt;<span>lvVerTypeInfo</span> = <span>verMakeTypeInfo</span>(typeHnd);</td>
      </tr>
      <tr>
        <td id="L1286" data-line-number="1286"></td>
        <td id="LC1286">            }</td>
      </tr>
      <tr>
        <td id="L1287" data-line-number="1287"></td>
        <td id="LC1287">        }</td>
      </tr>
      <tr>
        <td id="L1288" data-line-number="1288"></td>
        <td id="LC1288">
</td>
      </tr>
      <tr>
        <td id="L1289" data-line-number="1289"></td>
        <td id="LC1289">        varDsc-&gt;<span>lvOverlappingFields</span> = <span>StructHasOverlappingFields</span>(cFlags);</td>
      </tr>
      <tr>
        <td id="L1290" data-line-number="1290"></td>
        <td id="LC1290">    }</td>
      </tr>
      <tr>
        <td id="L1291" data-line-number="1291"></td>
        <td id="LC1291">
</td>
      </tr>
      <tr>
        <td id="L1292" data-line-number="1292"></td>
        <td id="LC1292">#<span>if</span> defined(TARGET_AMD64) || defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L1293" data-line-number="1293"></td>
        <td id="LC1293">    varDsc-&gt;<span>lvIsImplicitByRef</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1294" data-line-number="1294"></td>
        <td id="LC1294">#<span>endif</span> <span><span>//</span> defined(TARGET_AMD64) || defined(TARGET_ARM64)</span></td>
      </tr>
      <tr>
        <td id="L1295" data-line-number="1295"></td>
        <td id="LC1295">
</td>
      </tr>
      <tr>
        <td id="L1296" data-line-number="1296"></td>
        <td id="LC1296"><span><span>//</span> Set the lvType (before this point it is TYP_UNDEF).</span></td>
      </tr>
      <tr>
        <td id="L1297" data-line-number="1297"></td>
        <td id="LC1297">
</td>
      </tr>
      <tr>
        <td id="L1298" data-line-number="1298"></td>
        <td id="LC1298">#<span>ifdef</span> FEATURE_HFA</td>
      </tr>
      <tr>
        <td id="L1299" data-line-number="1299"></td>
        <td id="LC1299">    varDsc-&gt;<span>SetHfaType</span>(TYP_UNDEF);</td>
      </tr>
      <tr>
        <td id="L1300" data-line-number="1300"></td>
        <td id="LC1300">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1301" data-line-number="1301"></td>
        <td id="LC1301">    <span>if</span> ((<span>varTypeIsStruct</span>(type)))</td>
      </tr>
      <tr>
        <td id="L1302" data-line-number="1302"></td>
        <td id="LC1302">    {</td>
      </tr>
      <tr>
        <td id="L1303" data-line-number="1303"></td>
        <td id="LC1303">        <span>lvaSetStruct</span>(varNum, typeHnd, typeHnd != <span>nullptr</span>, !tiVerificationNeeded);</td>
      </tr>
      <tr>
        <td id="L1304" data-line-number="1304"></td>
        <td id="LC1304">        <span>if</span> (info.<span>compIsVarArgs</span>)</td>
      </tr>
      <tr>
        <td id="L1305" data-line-number="1305"></td>
        <td id="LC1305">        {</td>
      </tr>
      <tr>
        <td id="L1306" data-line-number="1306"></td>
        <td id="LC1306">            <span>lvaSetStructUsedAsVarArg</span>(varNum);</td>
      </tr>
      <tr>
        <td id="L1307" data-line-number="1307"></td>
        <td id="LC1307">        }</td>
      </tr>
      <tr>
        <td id="L1308" data-line-number="1308"></td>
        <td id="LC1308">    }</td>
      </tr>
      <tr>
        <td id="L1309" data-line-number="1309"></td>
        <td id="LC1309">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L1310" data-line-number="1310"></td>
        <td id="LC1310">    {</td>
      </tr>
      <tr>
        <td id="L1311" data-line-number="1311"></td>
        <td id="LC1311">        varDsc-&gt;<span>lvType</span> = type;</td>
      </tr>
      <tr>
        <td id="L1312" data-line-number="1312"></td>
        <td id="LC1312">    }</td>
      </tr>
      <tr>
        <td id="L1313" data-line-number="1313"></td>
        <td id="LC1313">
</td>
      </tr>
      <tr>
        <td id="L1314" data-line-number="1314"></td>
        <td id="LC1314">#<span>if</span> OPT_BOOL_OPS</td>
      </tr>
      <tr>
        <td id="L1315" data-line-number="1315"></td>
        <td id="LC1315">    <span>if</span> (type == TYP_BOOL)</td>
      </tr>
      <tr>
        <td id="L1316" data-line-number="1316"></td>
        <td id="LC1316">    {</td>
      </tr>
      <tr>
        <td id="L1317" data-line-number="1317"></td>
        <td id="LC1317">        varDsc-&gt;<span>lvIsBoolean</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1318" data-line-number="1318"></td>
        <td id="LC1318">    }</td>
      </tr>
      <tr>
        <td id="L1319" data-line-number="1319"></td>
        <td id="LC1319">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1320" data-line-number="1320"></td>
        <td id="LC1320">
</td>
      </tr>
      <tr>
        <td id="L1321" data-line-number="1321"></td>
        <td id="LC1321">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L1322" data-line-number="1322"></td>
        <td id="LC1322">    varDsc-&gt;<span>lvStkOffs</span> = BAD_STK_OFFS;</td>
      </tr>
      <tr>
        <td id="L1323" data-line-number="1323"></td>
        <td id="LC1323">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1324" data-line-number="1324"></td>
        <td id="LC1324">
</td>
      </tr>
      <tr>
        <td id="L1325" data-line-number="1325"></td>
        <td id="LC1325">#<span>if</span> FEATURE_MULTIREG_ARGS</td>
      </tr>
      <tr>
        <td id="L1326" data-line-number="1326"></td>
        <td id="LC1326">    varDsc-&gt;<span>SetOtherArgReg</span>(REG_NA);</td>
      </tr>
      <tr>
        <td id="L1327" data-line-number="1327"></td>
        <td id="LC1327">#<span>endif</span> <span><span>//</span> FEATURE_MULTIREG_ARGS</span></td>
      </tr>
      <tr>
        <td id="L1328" data-line-number="1328"></td>
        <td id="LC1328">}</td>
      </tr>
      <tr>
        <td id="L1329" data-line-number="1329"></td>
        <td id="LC1329">
</td>
      </tr>
      <tr>
        <td id="L1330" data-line-number="1330"></td>
        <td id="LC1330"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L1331" data-line-number="1331"></td>
        <td id="LC1331"><span> * Returns our internal varNum for a given IL variable.</span></td>
      </tr>
      <tr>
        <td id="L1332" data-line-number="1332"></td>
        <td id="LC1332"><span> * Asserts assume it is called after lvaTable[] has been set up.</span></td>
      </tr>
      <tr>
        <td id="L1333" data-line-number="1333"></td>
        <td id="LC1333"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1334" data-line-number="1334"></td>
        <td id="LC1334">
</td>
      </tr>
      <tr>
        <td id="L1335" data-line-number="1335"></td>
        <td id="LC1335"><span>unsigned</span> <span>Compiler::compMapILvarNum</span>(<span>unsigned</span> ILvarNum)</td>
      </tr>
      <tr>
        <td id="L1336" data-line-number="1336"></td>
        <td id="LC1336">{</td>
      </tr>
      <tr>
        <td id="L1337" data-line-number="1337"></td>
        <td id="LC1337">    <span>noway_assert</span>(ILvarNum &lt; info.<span>compILlocalsCount</span> || ILvarNum &gt; <span>unsigned</span>(ICorDebugInfo::UNKNOWN_ILNUM));</td>
      </tr>
      <tr>
        <td id="L1338" data-line-number="1338"></td>
        <td id="LC1338">
</td>
      </tr>
      <tr>
        <td id="L1339" data-line-number="1339"></td>
        <td id="LC1339">    <span>unsigned</span> varNum;</td>
      </tr>
      <tr>
        <td id="L1340" data-line-number="1340"></td>
        <td id="LC1340">
</td>
      </tr>
      <tr>
        <td id="L1341" data-line-number="1341"></td>
        <td id="LC1341">    <span>if</span> (ILvarNum == (<span>unsigned</span>)ICorDebugInfo::VARARGS_HND_ILNUM)</td>
      </tr>
      <tr>
        <td id="L1342" data-line-number="1342"></td>
        <td id="LC1342">    {</td>
      </tr>
      <tr>
        <td id="L1343" data-line-number="1343"></td>
        <td id="LC1343">        <span><span>//</span> The varargs cookie is the last argument in lvaTable[]</span></td>
      </tr>
      <tr>
        <td id="L1344" data-line-number="1344"></td>
        <td id="LC1344">        <span>noway_assert</span>(info.<span>compIsVarArgs</span>);</td>
      </tr>
      <tr>
        <td id="L1345" data-line-number="1345"></td>
        <td id="LC1345">
</td>
      </tr>
      <tr>
        <td id="L1346" data-line-number="1346"></td>
        <td id="LC1346">        varNum = lvaVarargsHandleArg;</td>
      </tr>
      <tr>
        <td id="L1347" data-line-number="1347"></td>
        <td id="LC1347">        <span>noway_assert</span>(lvaTable[varNum].<span>lvIsParam</span>);</td>
      </tr>
      <tr>
        <td id="L1348" data-line-number="1348"></td>
        <td id="LC1348">    }</td>
      </tr>
      <tr>
        <td id="L1349" data-line-number="1349"></td>
        <td id="LC1349">    <span>else</span> <span>if</span> (ILvarNum == (<span>unsigned</span>)ICorDebugInfo::RETBUF_ILNUM)</td>
      </tr>
      <tr>
        <td id="L1350" data-line-number="1350"></td>
        <td id="LC1350">    {</td>
      </tr>
      <tr>
        <td id="L1351" data-line-number="1351"></td>
        <td id="LC1351">        <span>noway_assert</span>(info.<span>compRetBuffArg</span> != BAD_VAR_NUM);</td>
      </tr>
      <tr>
        <td id="L1352" data-line-number="1352"></td>
        <td id="LC1352">        varNum = info.<span>compRetBuffArg</span>;</td>
      </tr>
      <tr>
        <td id="L1353" data-line-number="1353"></td>
        <td id="LC1353">    }</td>
      </tr>
      <tr>
        <td id="L1354" data-line-number="1354"></td>
        <td id="LC1354">    <span>else</span> <span>if</span> (ILvarNum == (<span>unsigned</span>)ICorDebugInfo::TYPECTXT_ILNUM)</td>
      </tr>
      <tr>
        <td id="L1355" data-line-number="1355"></td>
        <td id="LC1355">    {</td>
      </tr>
      <tr>
        <td id="L1356" data-line-number="1356"></td>
        <td id="LC1356">        <span>noway_assert</span>(info.<span>compTypeCtxtArg</span> &gt;= <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L1357" data-line-number="1357"></td>
        <td id="LC1357">        varNum = <span>unsigned</span>(info.<span>compTypeCtxtArg</span>);</td>
      </tr>
      <tr>
        <td id="L1358" data-line-number="1358"></td>
        <td id="LC1358">    }</td>
      </tr>
      <tr>
        <td id="L1359" data-line-number="1359"></td>
        <td id="LC1359">    <span>else</span> <span>if</span> (ILvarNum &lt; info.<span>compILargsCount</span>)</td>
      </tr>
      <tr>
        <td id="L1360" data-line-number="1360"></td>
        <td id="LC1360">    {</td>
      </tr>
      <tr>
        <td id="L1361" data-line-number="1361"></td>
        <td id="LC1361">        <span><span>//</span> Parameter</span></td>
      </tr>
      <tr>
        <td id="L1362" data-line-number="1362"></td>
        <td id="LC1362">        varNum = <span>compMapILargNum</span>(ILvarNum);</td>
      </tr>
      <tr>
        <td id="L1363" data-line-number="1363"></td>
        <td id="LC1363">        <span>noway_assert</span>(lvaTable[varNum].<span>lvIsParam</span>);</td>
      </tr>
      <tr>
        <td id="L1364" data-line-number="1364"></td>
        <td id="LC1364">    }</td>
      </tr>
      <tr>
        <td id="L1365" data-line-number="1365"></td>
        <td id="LC1365">    <span>else</span> <span>if</span> (ILvarNum &lt; info.<span>compILlocalsCount</span>)</td>
      </tr>
      <tr>
        <td id="L1366" data-line-number="1366"></td>
        <td id="LC1366">    {</td>
      </tr>
      <tr>
        <td id="L1367" data-line-number="1367"></td>
        <td id="LC1367">        <span><span>//</span> Local variable</span></td>
      </tr>
      <tr>
        <td id="L1368" data-line-number="1368"></td>
        <td id="LC1368">        <span>unsigned</span> lclNum = ILvarNum - info.<span>compILargsCount</span>;</td>
      </tr>
      <tr>
        <td id="L1369" data-line-number="1369"></td>
        <td id="LC1369">        varNum          = info.<span>compArgsCount</span> + lclNum;</td>
      </tr>
      <tr>
        <td id="L1370" data-line-number="1370"></td>
        <td id="LC1370">        <span>noway_assert</span>(!lvaTable[varNum].<span>lvIsParam</span>);</td>
      </tr>
      <tr>
        <td id="L1371" data-line-number="1371"></td>
        <td id="LC1371">    }</td>
      </tr>
      <tr>
        <td id="L1372" data-line-number="1372"></td>
        <td id="LC1372">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L1373" data-line-number="1373"></td>
        <td id="LC1373">    {</td>
      </tr>
      <tr>
        <td id="L1374" data-line-number="1374"></td>
        <td id="LC1374">        <span>unreached</span>();</td>
      </tr>
      <tr>
        <td id="L1375" data-line-number="1375"></td>
        <td id="LC1375">    }</td>
      </tr>
      <tr>
        <td id="L1376" data-line-number="1376"></td>
        <td id="LC1376">
</td>
      </tr>
      <tr>
        <td id="L1377" data-line-number="1377"></td>
        <td id="LC1377">    <span>noway_assert</span>(varNum &lt; info.<span>compLocalsCount</span>);</td>
      </tr>
      <tr>
        <td id="L1378" data-line-number="1378"></td>
        <td id="LC1378">    <span>return</span> varNum;</td>
      </tr>
      <tr>
        <td id="L1379" data-line-number="1379"></td>
        <td id="LC1379">}</td>
      </tr>
      <tr>
        <td id="L1380" data-line-number="1380"></td>
        <td id="LC1380">
</td>
      </tr>
      <tr>
        <td id="L1381" data-line-number="1381"></td>
        <td id="LC1381"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L1382" data-line-number="1382"></td>
        <td id="LC1382"><span> * Returns the IL variable number given our internal varNum.</span></td>
      </tr>
      <tr>
        <td id="L1383" data-line-number="1383"></td>
        <td id="LC1383"><span> * Special return values are VARG_ILNUM, RETBUF_ILNUM, TYPECTXT_ILNUM.</span></td>
      </tr>
      <tr>
        <td id="L1384" data-line-number="1384"></td>
        <td id="LC1384"><span> *</span></td>
      </tr>
      <tr>
        <td id="L1385" data-line-number="1385"></td>
        <td id="LC1385"><span> * Returns UNKNOWN_ILNUM if it can't be mapped.</span></td>
      </tr>
      <tr>
        <td id="L1386" data-line-number="1386"></td>
        <td id="LC1386"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1387" data-line-number="1387"></td>
        <td id="LC1387">
</td>
      </tr>
      <tr>
        <td id="L1388" data-line-number="1388"></td>
        <td id="LC1388"><span>unsigned</span> <span>Compiler::compMap2ILvarNum</span>(<span>unsigned</span> varNum) <span>const</span></td>
      </tr>
      <tr>
        <td id="L1389" data-line-number="1389"></td>
        <td id="LC1389">{</td>
      </tr>
      <tr>
        <td id="L1390" data-line-number="1390"></td>
        <td id="LC1390">    <span>if</span> (<span>compIsForInlining</span>())</td>
      </tr>
      <tr>
        <td id="L1391" data-line-number="1391"></td>
        <td id="LC1391">    {</td>
      </tr>
      <tr>
        <td id="L1392" data-line-number="1392"></td>
        <td id="LC1392">        <span>return</span> impInlineInfo-&gt;<span>InlinerCompiler</span>-&gt;<span>compMap2ILvarNum</span>(varNum);</td>
      </tr>
      <tr>
        <td id="L1393" data-line-number="1393"></td>
        <td id="LC1393">    }</td>
      </tr>
      <tr>
        <td id="L1394" data-line-number="1394"></td>
        <td id="LC1394">
</td>
      </tr>
      <tr>
        <td id="L1395" data-line-number="1395"></td>
        <td id="LC1395">    <span>noway_assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L1396" data-line-number="1396"></td>
        <td id="LC1396">
</td>
      </tr>
      <tr>
        <td id="L1397" data-line-number="1397"></td>
        <td id="LC1397">    <span>if</span> (varNum == info.<span>compRetBuffArg</span>)</td>
      </tr>
      <tr>
        <td id="L1398" data-line-number="1398"></td>
        <td id="LC1398">    {</td>
      </tr>
      <tr>
        <td id="L1399" data-line-number="1399"></td>
        <td id="LC1399">        <span>return</span> (<span>unsigned</span>)ICorDebugInfo::RETBUF_ILNUM;</td>
      </tr>
      <tr>
        <td id="L1400" data-line-number="1400"></td>
        <td id="LC1400">    }</td>
      </tr>
      <tr>
        <td id="L1401" data-line-number="1401"></td>
        <td id="LC1401">
</td>
      </tr>
      <tr>
        <td id="L1402" data-line-number="1402"></td>
        <td id="LC1402">    <span><span>//</span> Is this a varargs function?</span></td>
      </tr>
      <tr>
        <td id="L1403" data-line-number="1403"></td>
        <td id="LC1403">    <span>if</span> (info.<span>compIsVarArgs</span> &amp;&amp; varNum == lvaVarargsHandleArg)</td>
      </tr>
      <tr>
        <td id="L1404" data-line-number="1404"></td>
        <td id="LC1404">    {</td>
      </tr>
      <tr>
        <td id="L1405" data-line-number="1405"></td>
        <td id="LC1405">        <span>return</span> (<span>unsigned</span>)ICorDebugInfo::VARARGS_HND_ILNUM;</td>
      </tr>
      <tr>
        <td id="L1406" data-line-number="1406"></td>
        <td id="LC1406">    }</td>
      </tr>
      <tr>
        <td id="L1407" data-line-number="1407"></td>
        <td id="LC1407">
</td>
      </tr>
      <tr>
        <td id="L1408" data-line-number="1408"></td>
        <td id="LC1408">    <span><span>//</span> We create an extra argument for the type context parameter</span></td>
      </tr>
      <tr>
        <td id="L1409" data-line-number="1409"></td>
        <td id="LC1409">    <span><span>//</span> needed for shared generic code.</span></td>
      </tr>
      <tr>
        <td id="L1410" data-line-number="1410"></td>
        <td id="LC1410">    <span>if</span> ((info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>callConv</span> &amp; CORINFO_CALLCONV_PARAMTYPE) &amp;&amp; varNum == (<span>unsigned</span>)info.<span>compTypeCtxtArg</span>)</td>
      </tr>
      <tr>
        <td id="L1411" data-line-number="1411"></td>
        <td id="LC1411">    {</td>
      </tr>
      <tr>
        <td id="L1412" data-line-number="1412"></td>
        <td id="LC1412">        <span>return</span> (<span>unsigned</span>)ICorDebugInfo::TYPECTXT_ILNUM;</td>
      </tr>
      <tr>
        <td id="L1413" data-line-number="1413"></td>
        <td id="LC1413">    }</td>
      </tr>
      <tr>
        <td id="L1414" data-line-number="1414"></td>
        <td id="LC1414">
</td>
      </tr>
      <tr>
        <td id="L1415" data-line-number="1415"></td>
        <td id="LC1415">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L1416" data-line-number="1416"></td>
        <td id="LC1416">    <span>if</span> (varNum == lvaOutgoingArgSpaceVar)</td>
      </tr>
      <tr>
        <td id="L1417" data-line-number="1417"></td>
        <td id="LC1417">    {</td>
      </tr>
      <tr>
        <td id="L1418" data-line-number="1418"></td>
        <td id="LC1418">        <span>return</span> (<span>unsigned</span>)ICorDebugInfo::UNKNOWN_ILNUM; <span><span>//</span> Cannot be mapped</span></td>
      </tr>
      <tr>
        <td id="L1419" data-line-number="1419"></td>
        <td id="LC1419">    }</td>
      </tr>
      <tr>
        <td id="L1420" data-line-number="1420"></td>
        <td id="LC1420">#<span>endif</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L1421" data-line-number="1421"></td>
        <td id="LC1421">
</td>
      </tr>
      <tr>
        <td id="L1422" data-line-number="1422"></td>
        <td id="LC1422">    <span><span>//</span> Now mutate varNum to remove extra parameters from the count.</span></td>
      </tr>
      <tr>
        <td id="L1423" data-line-number="1423"></td>
        <td id="LC1423">    <span>if</span> ((info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>callConv</span> &amp; CORINFO_CALLCONV_PARAMTYPE) &amp;&amp; varNum &gt; (<span>unsigned</span>)info.<span>compTypeCtxtArg</span>)</td>
      </tr>
      <tr>
        <td id="L1424" data-line-number="1424"></td>
        <td id="LC1424">    {</td>
      </tr>
      <tr>
        <td id="L1425" data-line-number="1425"></td>
        <td id="LC1425">        varNum--;</td>
      </tr>
      <tr>
        <td id="L1426" data-line-number="1426"></td>
        <td id="LC1426">    }</td>
      </tr>
      <tr>
        <td id="L1427" data-line-number="1427"></td>
        <td id="LC1427">
</td>
      </tr>
      <tr>
        <td id="L1428" data-line-number="1428"></td>
        <td id="LC1428">    <span>if</span> (info.<span>compIsVarArgs</span> &amp;&amp; varNum &gt; lvaVarargsHandleArg)</td>
      </tr>
      <tr>
        <td id="L1429" data-line-number="1429"></td>
        <td id="LC1429">    {</td>
      </tr>
      <tr>
        <td id="L1430" data-line-number="1430"></td>
        <td id="LC1430">        varNum--;</td>
      </tr>
      <tr>
        <td id="L1431" data-line-number="1431"></td>
        <td id="LC1431">    }</td>
      </tr>
      <tr>
        <td id="L1432" data-line-number="1432"></td>
        <td id="LC1432">
</td>
      </tr>
      <tr>
        <td id="L1433" data-line-number="1433"></td>
        <td id="LC1433">    <span><span>/*</span> Is there a hidden argument for the return buffer.</span></td>
      </tr>
      <tr>
        <td id="L1434" data-line-number="1434"></td>
        <td id="LC1434"><span>       Note that this code works because if the RetBuffArg is not present,</span></td>
      </tr>
      <tr>
        <td id="L1435" data-line-number="1435"></td>
        <td id="LC1435"><span>       compRetBuffArg will be BAD_VAR_NUM <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1436" data-line-number="1436"></td>
        <td id="LC1436">    <span>if</span> (info.<span>compRetBuffArg</span> != BAD_VAR_NUM &amp;&amp; varNum &gt; info.<span>compRetBuffArg</span>)</td>
      </tr>
      <tr>
        <td id="L1437" data-line-number="1437"></td>
        <td id="LC1437">    {</td>
      </tr>
      <tr>
        <td id="L1438" data-line-number="1438"></td>
        <td id="LC1438">        varNum--;</td>
      </tr>
      <tr>
        <td id="L1439" data-line-number="1439"></td>
        <td id="LC1439">    }</td>
      </tr>
      <tr>
        <td id="L1440" data-line-number="1440"></td>
        <td id="LC1440">
</td>
      </tr>
      <tr>
        <td id="L1441" data-line-number="1441"></td>
        <td id="LC1441">    <span>if</span> (varNum &gt;= info.<span>compLocalsCount</span>)</td>
      </tr>
      <tr>
        <td id="L1442" data-line-number="1442"></td>
        <td id="LC1442">    {</td>
      </tr>
      <tr>
        <td id="L1443" data-line-number="1443"></td>
        <td id="LC1443">        <span>return</span> (<span>unsigned</span>)ICorDebugInfo::UNKNOWN_ILNUM; <span><span>//</span> Cannot be mapped</span></td>
      </tr>
      <tr>
        <td id="L1444" data-line-number="1444"></td>
        <td id="LC1444">    }</td>
      </tr>
      <tr>
        <td id="L1445" data-line-number="1445"></td>
        <td id="LC1445">
</td>
      </tr>
      <tr>
        <td id="L1446" data-line-number="1446"></td>
        <td id="LC1446">    <span>return</span> varNum;</td>
      </tr>
      <tr>
        <td id="L1447" data-line-number="1447"></td>
        <td id="LC1447">}</td>
      </tr>
      <tr>
        <td id="L1448" data-line-number="1448"></td>
        <td id="LC1448">
</td>
      </tr>
      <tr>
        <td id="L1449" data-line-number="1449"></td>
        <td id="LC1449"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L1450" data-line-number="1450"></td>
        <td id="LC1450"><span> * Returns true if variable "varNum" may be address-exposed.</span></td>
      </tr>
      <tr>
        <td id="L1451" data-line-number="1451"></td>
        <td id="LC1451"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1452" data-line-number="1452"></td>
        <td id="LC1452">
</td>
      </tr>
      <tr>
        <td id="L1453" data-line-number="1453"></td>
        <td id="LC1453"><span>bool</span> <span>Compiler::lvaVarAddrExposed</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L1454" data-line-number="1454"></td>
        <td id="LC1454">{</td>
      </tr>
      <tr>
        <td id="L1455" data-line-number="1455"></td>
        <td id="LC1455">    <span>noway_assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L1456" data-line-number="1456"></td>
        <td id="LC1456">    LclVarDsc* varDsc = &amp;lvaTable[varNum];</td>
      </tr>
      <tr>
        <td id="L1457" data-line-number="1457"></td>
        <td id="LC1457">
</td>
      </tr>
      <tr>
        <td id="L1458" data-line-number="1458"></td>
        <td id="LC1458">    <span>return</span> varDsc-&gt;<span>lvAddrExposed</span>;</td>
      </tr>
      <tr>
        <td id="L1459" data-line-number="1459"></td>
        <td id="LC1459">}</td>
      </tr>
      <tr>
        <td id="L1460" data-line-number="1460"></td>
        <td id="LC1460">
</td>
      </tr>
      <tr>
        <td id="L1461" data-line-number="1461"></td>
        <td id="LC1461"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L1462" data-line-number="1462"></td>
        <td id="LC1462"><span> * Returns true iff variable "varNum" should not be enregistered (or one of several reasons).</span></td>
      </tr>
      <tr>
        <td id="L1463" data-line-number="1463"></td>
        <td id="LC1463"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1464" data-line-number="1464"></td>
        <td id="LC1464">
</td>
      </tr>
      <tr>
        <td id="L1465" data-line-number="1465"></td>
        <td id="LC1465"><span>bool</span> <span>Compiler::lvaVarDoNotEnregister</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L1466" data-line-number="1466"></td>
        <td id="LC1466">{</td>
      </tr>
      <tr>
        <td id="L1467" data-line-number="1467"></td>
        <td id="LC1467">    <span>noway_assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L1468" data-line-number="1468"></td>
        <td id="LC1468">    LclVarDsc* varDsc = &amp;lvaTable[varNum];</td>
      </tr>
      <tr>
        <td id="L1469" data-line-number="1469"></td>
        <td id="LC1469">
</td>
      </tr>
      <tr>
        <td id="L1470" data-line-number="1470"></td>
        <td id="LC1470">    <span>return</span> varDsc-&gt;<span>lvDoNotEnregister</span>;</td>
      </tr>
      <tr>
        <td id="L1471" data-line-number="1471"></td>
        <td id="LC1471">}</td>
      </tr>
      <tr>
        <td id="L1472" data-line-number="1472"></td>
        <td id="LC1472">
</td>
      </tr>
      <tr>
        <td id="L1473" data-line-number="1473"></td>
        <td id="LC1473"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L1474" data-line-number="1474"></td>
        <td id="LC1474"><span> * Returns the handle to the class of the local variable varNum</span></td>
      </tr>
      <tr>
        <td id="L1475" data-line-number="1475"></td>
        <td id="LC1475"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L1476" data-line-number="1476"></td>
        <td id="LC1476">
</td>
      </tr>
      <tr>
        <td id="L1477" data-line-number="1477"></td>
        <td id="LC1477">CORINFO_CLASS_HANDLE <span>Compiler::lvaGetStruct</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L1478" data-line-number="1478"></td>
        <td id="LC1478">{</td>
      </tr>
      <tr>
        <td id="L1479" data-line-number="1479"></td>
        <td id="LC1479">    <span>noway_assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L1480" data-line-number="1480"></td>
        <td id="LC1480">    LclVarDsc* varDsc = &amp;lvaTable[varNum];</td>
      </tr>
      <tr>
        <td id="L1481" data-line-number="1481"></td>
        <td id="LC1481">
</td>
      </tr>
      <tr>
        <td id="L1482" data-line-number="1482"></td>
        <td id="LC1482">    <span>return</span> varDsc-&gt;<span>lvVerTypeInfo</span>.<span>GetClassHandleForValueClass</span>();</td>
      </tr>
      <tr>
        <td id="L1483" data-line-number="1483"></td>
        <td id="LC1483">}</td>
      </tr>
      <tr>
        <td id="L1484" data-line-number="1484"></td>
        <td id="LC1484">
</td>
      </tr>
      <tr>
        <td id="L1485" data-line-number="1485"></td>
        <td id="LC1485"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1486" data-line-number="1486"></td>
        <td id="LC1486"><span><span>//</span> lvaFieldOffsetCmp - a static compare function passed to qsort() by Compiler::StructPromotionHelper;</span></td>
      </tr>
      <tr>
        <td id="L1487" data-line-number="1487"></td>
        <td id="LC1487"><span><span>//</span>   compares fields' offsets.</span></td>
      </tr>
      <tr>
        <td id="L1488" data-line-number="1488"></td>
        <td id="LC1488"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1489" data-line-number="1489"></td>
        <td id="LC1489"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1490" data-line-number="1490"></td>
        <td id="LC1490"><span><span>//</span>   field1 - pointer to the first field;</span></td>
      </tr>
      <tr>
        <td id="L1491" data-line-number="1491"></td>
        <td id="LC1491"><span><span>//</span>   field2 - pointer to the second field.</span></td>
      </tr>
      <tr>
        <td id="L1492" data-line-number="1492"></td>
        <td id="LC1492"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1493" data-line-number="1493"></td>
        <td id="LC1493"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L1494" data-line-number="1494"></td>
        <td id="LC1494"><span><span>//</span>   0 if the fields' offsets are equal, 1 if the first field has bigger offset, -1 otherwise.</span></td>
      </tr>
      <tr>
        <td id="L1495" data-line-number="1495"></td>
        <td id="LC1495"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1496" data-line-number="1496"></td>
        <td id="LC1496"><span>int</span> __cdecl <span>Compiler::lvaFieldOffsetCmp</span>(<span>const</span> <span>void</span>* field1, <span>const</span> <span>void</span>* field2)</td>
      </tr>
      <tr>
        <td id="L1497" data-line-number="1497"></td>
        <td id="LC1497">{</td>
      </tr>
      <tr>
        <td id="L1498" data-line-number="1498"></td>
        <td id="LC1498">    lvaStructFieldInfo* pFieldInfo1 = (lvaStructFieldInfo*)field1;</td>
      </tr>
      <tr>
        <td id="L1499" data-line-number="1499"></td>
        <td id="LC1499">    lvaStructFieldInfo* pFieldInfo2 = (lvaStructFieldInfo*)field2;</td>
      </tr>
      <tr>
        <td id="L1500" data-line-number="1500"></td>
        <td id="LC1500">
</td>
      </tr>
      <tr>
        <td id="L1501" data-line-number="1501"></td>
        <td id="LC1501">    <span>if</span> (pFieldInfo1-&gt;<span>fldOffset</span> == pFieldInfo2-&gt;<span>fldOffset</span>)</td>
      </tr>
      <tr>
        <td id="L1502" data-line-number="1502"></td>
        <td id="LC1502">    {</td>
      </tr>
      <tr>
        <td id="L1503" data-line-number="1503"></td>
        <td id="LC1503">        <span>return</span> <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1504" data-line-number="1504"></td>
        <td id="LC1504">    }</td>
      </tr>
      <tr>
        <td id="L1505" data-line-number="1505"></td>
        <td id="LC1505">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L1506" data-line-number="1506"></td>
        <td id="LC1506">    {</td>
      </tr>
      <tr>
        <td id="L1507" data-line-number="1507"></td>
        <td id="LC1507">        <span>return</span> (pFieldInfo1-&gt;<span>fldOffset</span> &gt; pFieldInfo2-&gt;<span>fldOffset</span>) ? +<span>1</span> : -<span>1</span>;</td>
      </tr>
      <tr>
        <td id="L1508" data-line-number="1508"></td>
        <td id="LC1508">    }</td>
      </tr>
      <tr>
        <td id="L1509" data-line-number="1509"></td>
        <td id="LC1509">}</td>
      </tr>
      <tr>
        <td id="L1510" data-line-number="1510"></td>
        <td id="LC1510">
</td>
      </tr>
      <tr>
        <td id="L1511" data-line-number="1511"></td>
        <td id="LC1511"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1512" data-line-number="1512"></td>
        <td id="LC1512"><span><span>//</span> StructPromotionHelper constructor.</span></td>
      </tr>
      <tr>
        <td id="L1513" data-line-number="1513"></td>
        <td id="LC1513"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1514" data-line-number="1514"></td>
        <td id="LC1514"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1515" data-line-number="1515"></td>
        <td id="LC1515"><span><span>//</span>   compiler - pointer to a compiler to get access to an allocator, compHandle etc.</span></td>
      </tr>
      <tr>
        <td id="L1516" data-line-number="1516"></td>
        <td id="LC1516"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1517" data-line-number="1517"></td>
        <td id="LC1517"><span>Compiler::StructPromotionHelper::StructPromotionHelper</span>(Compiler* compiler)</td>
      </tr>
      <tr>
        <td id="L1518" data-line-number="1518"></td>
        <td id="LC1518">    : compiler(compiler)</td>
      </tr>
      <tr>
        <td id="L1519" data-line-number="1519"></td>
        <td id="LC1519">    , structPromotionInfo()</td>
      </tr>
      <tr>
        <td id="L1520" data-line-number="1520"></td>
        <td id="LC1520">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L1521" data-line-number="1521"></td>
        <td id="LC1521">    , requiresScratchVar(<span>false</span>)</td>
      </tr>
      <tr>
        <td id="L1522" data-line-number="1522"></td>
        <td id="LC1522">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L1523" data-line-number="1523"></td>
        <td id="LC1523">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L1524" data-line-number="1524"></td>
        <td id="LC1524">    , retypedFieldsMap(compiler-&gt;<span>getAllocator</span>(CMK_DebugOnly))</td>
      </tr>
      <tr>
        <td id="L1525" data-line-number="1525"></td>
        <td id="LC1525">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L1526" data-line-number="1526"></td>
        <td id="LC1526">{</td>
      </tr>
      <tr>
        <td id="L1527" data-line-number="1527"></td>
        <td id="LC1527">}</td>
      </tr>
      <tr>
        <td id="L1528" data-line-number="1528"></td>
        <td id="LC1528">
</td>
      </tr>
      <tr>
        <td id="L1529" data-line-number="1529"></td>
        <td id="LC1529">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L1530" data-line-number="1530"></td>
        <td id="LC1530"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1531" data-line-number="1531"></td>
        <td id="LC1531"><span><span>//</span> GetRequiresScratchVar - do we need a stack area to assemble small fields in order to place them in a register.</span></td>
      </tr>
      <tr>
        <td id="L1532" data-line-number="1532"></td>
        <td id="LC1532"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1533" data-line-number="1533"></td>
        <td id="LC1533"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L1534" data-line-number="1534"></td>
        <td id="LC1534"><span><span>//</span>   true if there was a small promoted variable and scratch var is required .</span></td>
      </tr>
      <tr>
        <td id="L1535" data-line-number="1535"></td>
        <td id="LC1535"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1536" data-line-number="1536"></td>
        <td id="LC1536"><span>bool</span> <span>Compiler::StructPromotionHelper::GetRequiresScratchVar</span>()</td>
      </tr>
      <tr>
        <td id="L1537" data-line-number="1537"></td>
        <td id="LC1537">{</td>
      </tr>
      <tr>
        <td id="L1538" data-line-number="1538"></td>
        <td id="LC1538">    <span>return</span> requiresScratchVar;</td>
      </tr>
      <tr>
        <td id="L1539" data-line-number="1539"></td>
        <td id="LC1539">}</td>
      </tr>
      <tr>
        <td id="L1540" data-line-number="1540"></td>
        <td id="LC1540">
</td>
      </tr>
      <tr>
        <td id="L1541" data-line-number="1541"></td>
        <td id="LC1541">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L1542" data-line-number="1542"></td>
        <td id="LC1542">
</td>
      </tr>
      <tr>
        <td id="L1543" data-line-number="1543"></td>
        <td id="LC1543"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1544" data-line-number="1544"></td>
        <td id="LC1544"><span><span>//</span> TryPromoteStructVar - promote struct var if it is possible and profitable.</span></td>
      </tr>
      <tr>
        <td id="L1545" data-line-number="1545"></td>
        <td id="LC1545"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1546" data-line-number="1546"></td>
        <td id="LC1546"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1547" data-line-number="1547"></td>
        <td id="LC1547"><span><span>//</span>   lclNum - struct number to try.</span></td>
      </tr>
      <tr>
        <td id="L1548" data-line-number="1548"></td>
        <td id="LC1548"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1549" data-line-number="1549"></td>
        <td id="LC1549"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L1550" data-line-number="1550"></td>
        <td id="LC1550"><span><span>//</span>   true if the struct var was promoted.</span></td>
      </tr>
      <tr>
        <td id="L1551" data-line-number="1551"></td>
        <td id="LC1551"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1552" data-line-number="1552"></td>
        <td id="LC1552"><span>bool</span> <span>Compiler::StructPromotionHelper::TryPromoteStructVar</span>(<span>unsigned</span> lclNum)</td>
      </tr>
      <tr>
        <td id="L1553" data-line-number="1553"></td>
        <td id="LC1553">{</td>
      </tr>
      <tr>
        <td id="L1554" data-line-number="1554"></td>
        <td id="LC1554">    <span>if</span> (<span>CanPromoteStructVar</span>(lclNum))</td>
      </tr>
      <tr>
        <td id="L1555" data-line-number="1555"></td>
        <td id="LC1555">    {</td>
      </tr>
      <tr>
        <td id="L1556" data-line-number="1556"></td>
        <td id="LC1556">#<span>if</span> <span>0</span></td>
      </tr>
      <tr>
        <td id="L1557" data-line-number="1557"></td>
        <td id="LC1557">            // Often-useful debugging code: if you've narrowed down a struct-promotion problem to a single</td>
      </tr>
      <tr>
        <td id="L1558" data-line-number="1558"></td>
        <td id="LC1558">            // method, this allows you to select a subset of the vars to promote (by 1-based ordinal number).</td>
      </tr>
      <tr>
        <td id="L1559" data-line-number="1559"></td>
        <td id="LC1559">            static int structPromoVarNum = 0;</td>
      </tr>
      <tr>
        <td id="L1560" data-line-number="1560"></td>
        <td id="LC1560">            structPromoVarNum++;</td>
      </tr>
      <tr>
        <td id="L1561" data-line-number="1561"></td>
        <td id="LC1561">            if (atoi(getenv("structpromovarnumlo")) &lt;= structPromoVarNum &amp;&amp; structPromoVarNum &lt;= atoi(getenv("structpromovarnumhi")))</td>
      </tr>
      <tr>
        <td id="L1562" data-line-number="1562"></td>
        <td id="LC1562">#<span>endif</span> <span><span>//</span> 0</span></td>
      </tr>
      <tr>
        <td id="L1563" data-line-number="1563"></td>
        <td id="LC1563">        <span>if</span> (<span>ShouldPromoteStructVar</span>(lclNum))</td>
      </tr>
      <tr>
        <td id="L1564" data-line-number="1564"></td>
        <td id="LC1564">        {</td>
      </tr>
      <tr>
        <td id="L1565" data-line-number="1565"></td>
        <td id="LC1565">            <span>PromoteStructVar</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L1566" data-line-number="1566"></td>
        <td id="LC1566">            <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1567" data-line-number="1567"></td>
        <td id="LC1567">        }</td>
      </tr>
      <tr>
        <td id="L1568" data-line-number="1568"></td>
        <td id="LC1568">    }</td>
      </tr>
      <tr>
        <td id="L1569" data-line-number="1569"></td>
        <td id="LC1569">    <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1570" data-line-number="1570"></td>
        <td id="LC1570">}</td>
      </tr>
      <tr>
        <td id="L1571" data-line-number="1571"></td>
        <td id="LC1571">
</td>
      </tr>
      <tr>
        <td id="L1572" data-line-number="1572"></td>
        <td id="LC1572">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L1573" data-line-number="1573"></td>
        <td id="LC1573"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1574" data-line-number="1574"></td>
        <td id="LC1574"><span><span>//</span> CheckRetypedAsScalar - check that the fldType for this fieldHnd was retyped as requested type.</span></td>
      </tr>
      <tr>
        <td id="L1575" data-line-number="1575"></td>
        <td id="LC1575"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1576" data-line-number="1576"></td>
        <td id="LC1576"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1577" data-line-number="1577"></td>
        <td id="LC1577"><span><span>//</span>   fieldHnd      - the field handle;</span></td>
      </tr>
      <tr>
        <td id="L1578" data-line-number="1578"></td>
        <td id="LC1578"><span><span>//</span>   requestedType - as which type the field was accessed;</span></td>
      </tr>
      <tr>
        <td id="L1579" data-line-number="1579"></td>
        <td id="LC1579"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1580" data-line-number="1580"></td>
        <td id="LC1580"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1581" data-line-number="1581"></td>
        <td id="LC1581"><span><span>//</span>   For example it can happen when such struct A { struct B { long c } } is compiled and we access A.B.c,</span></td>
      </tr>
      <tr>
        <td id="L1582" data-line-number="1582"></td>
        <td id="LC1582"><span><span>//</span>   it could look like "GT_FIELD struct B.c -&gt; ADDR -&gt; GT_FIELD struct A.B -&gt; ADDR -&gt; LCL_VAR A" , but</span></td>
      </tr>
      <tr>
        <td id="L1583" data-line-number="1583"></td>
        <td id="LC1583"><span><span>//</span>   "GT_FIELD struct A.B -&gt; ADDR -&gt; LCL_VAR A" can be promoted to "LCL_VAR long A.B" and then</span></td>
      </tr>
      <tr>
        <td id="L1584" data-line-number="1584"></td>
        <td id="LC1584"><span><span>//</span>   there is type mistmatch between "GT_FIELD struct B.c" and  "LCL_VAR long A.B".</span></td>
      </tr>
      <tr>
        <td id="L1585" data-line-number="1585"></td>
        <td id="LC1585"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1586" data-line-number="1586"></td>
        <td id="LC1586"><span>void</span> <span>Compiler::StructPromotionHelper::CheckRetypedAsScalar</span>(CORINFO_FIELD_HANDLE fieldHnd, var_types requestedType)</td>
      </tr>
      <tr>
        <td id="L1587" data-line-number="1587"></td>
        <td id="LC1587">{</td>
      </tr>
      <tr>
        <td id="L1588" data-line-number="1588"></td>
        <td id="LC1588">    <span>assert</span>(retypedFieldsMap.<span>Lookup</span>(fieldHnd));</td>
      </tr>
      <tr>
        <td id="L1589" data-line-number="1589"></td>
        <td id="LC1589">    <span>assert</span>(retypedFieldsMap[fieldHnd] == requestedType);</td>
      </tr>
      <tr>
        <td id="L1590" data-line-number="1590"></td>
        <td id="LC1590">}</td>
      </tr>
      <tr>
        <td id="L1591" data-line-number="1591"></td>
        <td id="LC1591">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L1592" data-line-number="1592"></td>
        <td id="LC1592">
</td>
      </tr>
      <tr>
        <td id="L1593" data-line-number="1593"></td>
        <td id="LC1593"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1594" data-line-number="1594"></td>
        <td id="LC1594"><span><span>//</span> CanPromoteStructType - checks if the struct type can be promoted.</span></td>
      </tr>
      <tr>
        <td id="L1595" data-line-number="1595"></td>
        <td id="LC1595"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1596" data-line-number="1596"></td>
        <td id="LC1596"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1597" data-line-number="1597"></td>
        <td id="LC1597"><span><span>//</span>   typeHnd - struct handle to check.</span></td>
      </tr>
      <tr>
        <td id="L1598" data-line-number="1598"></td>
        <td id="LC1598"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1599" data-line-number="1599"></td>
        <td id="LC1599"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L1600" data-line-number="1600"></td>
        <td id="LC1600"><span><span>//</span>   true if the struct type can be promoted.</span></td>
      </tr>
      <tr>
        <td id="L1601" data-line-number="1601"></td>
        <td id="LC1601"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1602" data-line-number="1602"></td>
        <td id="LC1602"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1603" data-line-number="1603"></td>
        <td id="LC1603"><span><span>//</span>   The last analyzed type is memorized to skip the check if we ask about the same time again next.</span></td>
      </tr>
      <tr>
        <td id="L1604" data-line-number="1604"></td>
        <td id="LC1604"><span><span>//</span>   However, it was not found profitable to memorize all analyzed types in a map.</span></td>
      </tr>
      <tr>
        <td id="L1605" data-line-number="1605"></td>
        <td id="LC1605"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1606" data-line-number="1606"></td>
        <td id="LC1606"><span><span>//</span>   The check initializes only nessasary fields in lvaStructPromotionInfo,</span></td>
      </tr>
      <tr>
        <td id="L1607" data-line-number="1607"></td>
        <td id="LC1607"><span><span>//</span>   so if the promotion is rejected early than most fields will be uninitialized.</span></td>
      </tr>
      <tr>
        <td id="L1608" data-line-number="1608"></td>
        <td id="LC1608"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1609" data-line-number="1609"></td>
        <td id="LC1609"><span>bool</span> <span>Compiler::StructPromotionHelper::CanPromoteStructType</span>(CORINFO_CLASS_HANDLE typeHnd)</td>
      </tr>
      <tr>
        <td id="L1610" data-line-number="1610"></td>
        <td id="LC1610">{</td>
      </tr>
      <tr>
        <td id="L1611" data-line-number="1611"></td>
        <td id="LC1611">    <span>if</span> (!compiler-&gt;<span>eeIsValueClass</span>(typeHnd))</td>
      </tr>
      <tr>
        <td id="L1612" data-line-number="1612"></td>
        <td id="LC1612">    {</td>
      </tr>
      <tr>
        <td id="L1613" data-line-number="1613"></td>
        <td id="LC1613">        <span><span>//</span> TODO-ObjectStackAllocation: Enable promotion of fields of stack-allocated objects.</span></td>
      </tr>
      <tr>
        <td id="L1614" data-line-number="1614"></td>
        <td id="LC1614">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1615" data-line-number="1615"></td>
        <td id="LC1615">    }</td>
      </tr>
      <tr>
        <td id="L1616" data-line-number="1616"></td>
        <td id="LC1616">
</td>
      </tr>
      <tr>
        <td id="L1617" data-line-number="1617"></td>
        <td id="LC1617">    <span>if</span> (structPromotionInfo.<span>typeHnd</span> == typeHnd)</td>
      </tr>
      <tr>
        <td id="L1618" data-line-number="1618"></td>
        <td id="LC1618">    {</td>
      </tr>
      <tr>
        <td id="L1619" data-line-number="1619"></td>
        <td id="LC1619">        <span><span>//</span> Asking for the same type of struct as the last time.</span></td>
      </tr>
      <tr>
        <td id="L1620" data-line-number="1620"></td>
        <td id="LC1620">        <span><span>//</span> Nothing need to be done.</span></td>
      </tr>
      <tr>
        <td id="L1621" data-line-number="1621"></td>
        <td id="LC1621">        <span><span>//</span> Fall through ...</span></td>
      </tr>
      <tr>
        <td id="L1622" data-line-number="1622"></td>
        <td id="LC1622">        <span>return</span> structPromotionInfo.<span>canPromote</span>;</td>
      </tr>
      <tr>
        <td id="L1623" data-line-number="1623"></td>
        <td id="LC1623">    }</td>
      </tr>
      <tr>
        <td id="L1624" data-line-number="1624"></td>
        <td id="LC1624">
</td>
      </tr>
      <tr>
        <td id="L1625" data-line-number="1625"></td>
        <td id="LC1625">    <span><span>//</span> Analyze this type from scratch.</span></td>
      </tr>
      <tr>
        <td id="L1626" data-line-number="1626"></td>
        <td id="LC1626">    structPromotionInfo = <span>lvaStructPromotionInfo</span>(typeHnd);</td>
      </tr>
      <tr>
        <td id="L1627" data-line-number="1627"></td>
        <td id="LC1627">
</td>
      </tr>
      <tr>
        <td id="L1628" data-line-number="1628"></td>
        <td id="LC1628">    <span><span>//</span> sizeof(double) represents the size of the largest primitive type that we can struct promote.</span></td>
      </tr>
      <tr>
        <td id="L1629" data-line-number="1629"></td>
        <td id="LC1629">    <span><span>//</span> In the future this may be changing to XMM_REGSIZE_BYTES.</span></td>
      </tr>
      <tr>
        <td id="L1630" data-line-number="1630"></td>
        <td id="LC1630">    <span><span>//</span> Note: MaxOffset is used below to declare a local array, and therefore must be a compile-time constant.</span></td>
      </tr>
      <tr>
        <td id="L1631" data-line-number="1631"></td>
        <td id="LC1631">    CLANG_FORMAT_COMMENT_ANCHOR;</td>
      </tr>
      <tr>
        <td id="L1632" data-line-number="1632"></td>
        <td id="LC1632">#<span>if</span> defined(FEATURE_SIMD)</td>
      </tr>
      <tr>
        <td id="L1633" data-line-number="1633"></td>
        <td id="LC1633">#<span>if</span> defined(TARGET_XARCH)</td>
      </tr>
      <tr>
        <td id="L1634" data-line-number="1634"></td>
        <td id="LC1634">    <span><span>//</span> This will allow promotion of 4 Vector&lt;T&gt; fields on AVX2 or Vector256&lt;T&gt; on AVX,</span></td>
      </tr>
      <tr>
        <td id="L1635" data-line-number="1635"></td>
        <td id="LC1635">    <span><span>//</span> or 8 Vector&lt;T&gt;/Vector128&lt;T&gt; fields on SSE2.</span></td>
      </tr>
      <tr>
        <td id="L1636" data-line-number="1636"></td>
        <td id="LC1636">    <span>const</span> <span>int</span> MaxOffset = MAX_NumOfFieldsInPromotableStruct * YMM_REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L1637" data-line-number="1637"></td>
        <td id="LC1637">#<span>elif</span> defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L1638" data-line-number="1638"></td>
        <td id="LC1638">    <span>const</span> <span>int</span> MaxOffset = MAX_NumOfFieldsInPromotableStruct * FP_REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L1639" data-line-number="1639"></td>
        <td id="LC1639">#<span>endif</span> <span><span>//</span> defined(TARGET_XARCH) || defined(TARGET_ARM64)</span></td>
      </tr>
      <tr>
        <td id="L1640" data-line-number="1640"></td>
        <td id="LC1640">#<span>else</span>  <span><span>//</span> !FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L1641" data-line-number="1641"></td>
        <td id="LC1641">    <span>const</span> <span>int</span> MaxOffset = MAX_NumOfFieldsInPromotableStruct * <span>sizeof</span>(<span>double</span>);</td>
      </tr>
      <tr>
        <td id="L1642" data-line-number="1642"></td>
        <td id="LC1642">#<span>endif</span> <span><span>//</span> !FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L1643" data-line-number="1643"></td>
        <td id="LC1643">
</td>
      </tr>
      <tr>
        <td id="L1644" data-line-number="1644"></td>
        <td id="LC1644">    <span>assert</span>((BYTE)MaxOffset == MaxOffset); <span><span>//</span> because lvaStructFieldInfo.fldOffset is byte-sized</span></td>
      </tr>
      <tr>
        <td id="L1645" data-line-number="1645"></td>
        <td id="LC1645">    <span>assert</span>((BYTE)MAX_NumOfFieldsInPromotableStruct ==</td>
      </tr>
      <tr>
        <td id="L1646" data-line-number="1646"></td>
        <td id="LC1646">           MAX_NumOfFieldsInPromotableStruct); <span><span>//</span> because lvaStructFieldInfo.fieldCnt is byte-sized</span></td>
      </tr>
      <tr>
        <td id="L1647" data-line-number="1647"></td>
        <td id="LC1647">
</td>
      </tr>
      <tr>
        <td id="L1648" data-line-number="1648"></td>
        <td id="LC1648">    <span>bool</span> containsGCpointers = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1649" data-line-number="1649"></td>
        <td id="LC1649">
</td>
      </tr>
      <tr>
        <td id="L1650" data-line-number="1650"></td>
        <td id="LC1650">    COMP_HANDLE compHandle = compiler-&gt;<span>info</span>.<span>compCompHnd</span>;</td>
      </tr>
      <tr>
        <td id="L1651" data-line-number="1651"></td>
        <td id="LC1651">
</td>
      </tr>
      <tr>
        <td id="L1652" data-line-number="1652"></td>
        <td id="LC1652">    <span>unsigned</span> structSize = compHandle-&gt;<span>getClassSize</span>(typeHnd);</td>
      </tr>
      <tr>
        <td id="L1653" data-line-number="1653"></td>
        <td id="LC1653">    <span>if</span> (structSize &gt; MaxOffset)</td>
      </tr>
      <tr>
        <td id="L1654" data-line-number="1654"></td>
        <td id="LC1654">    {</td>
      </tr>
      <tr>
        <td id="L1655" data-line-number="1655"></td>
        <td id="LC1655">        <span>return</span> <span>false</span>; <span><span>//</span> struct is too large</span></td>
      </tr>
      <tr>
        <td id="L1656" data-line-number="1656"></td>
        <td id="LC1656">    }</td>
      </tr>
      <tr>
        <td id="L1657" data-line-number="1657"></td>
        <td id="LC1657">
</td>
      </tr>
      <tr>
        <td id="L1658" data-line-number="1658"></td>
        <td id="LC1658">    <span>unsigned</span> fieldCnt = compHandle-&gt;<span>getClassNumInstanceFields</span>(typeHnd);</td>
      </tr>
      <tr>
        <td id="L1659" data-line-number="1659"></td>
        <td id="LC1659">    <span>if</span> (fieldCnt == <span>0</span> || fieldCnt &gt; MAX_NumOfFieldsInPromotableStruct)</td>
      </tr>
      <tr>
        <td id="L1660" data-line-number="1660"></td>
        <td id="LC1660">    {</td>
      </tr>
      <tr>
        <td id="L1661" data-line-number="1661"></td>
        <td id="LC1661">        <span>return</span> <span>false</span>; <span><span>//</span> struct must have between 1 and MAX_NumOfFieldsInPromotableStruct fields</span></td>
      </tr>
      <tr>
        <td id="L1662" data-line-number="1662"></td>
        <td id="LC1662">    }</td>
      </tr>
      <tr>
        <td id="L1663" data-line-number="1663"></td>
        <td id="LC1663">
</td>
      </tr>
      <tr>
        <td id="L1664" data-line-number="1664"></td>
        <td id="LC1664">    structPromotionInfo.<span>fieldCnt</span> = (<span>unsigned</span> <span>char</span>)fieldCnt;</td>
      </tr>
      <tr>
        <td id="L1665" data-line-number="1665"></td>
        <td id="LC1665">    DWORD typeFlags              = compHandle-&gt;<span>getClassAttribs</span>(typeHnd);</td>
      </tr>
      <tr>
        <td id="L1666" data-line-number="1666"></td>
        <td id="LC1666">
</td>
      </tr>
      <tr>
        <td id="L1667" data-line-number="1667"></td>
        <td id="LC1667">    <span>bool</span> overlappingFields = <span>StructHasOverlappingFields</span>(typeFlags);</td>
      </tr>
      <tr>
        <td id="L1668" data-line-number="1668"></td>
        <td id="LC1668">    <span>if</span> (overlappingFields)</td>
      </tr>
      <tr>
        <td id="L1669" data-line-number="1669"></td>
        <td id="LC1669">    {</td>
      </tr>
      <tr>
        <td id="L1670" data-line-number="1670"></td>
        <td id="LC1670">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1671" data-line-number="1671"></td>
        <td id="LC1671">    }</td>
      </tr>
      <tr>
        <td id="L1672" data-line-number="1672"></td>
        <td id="LC1672">
</td>
      </tr>
      <tr>
        <td id="L1673" data-line-number="1673"></td>
        <td id="LC1673">    <span><span>//</span> Don't struct promote if we have an CUSTOMLAYOUT flag on an HFA type</span></td>
      </tr>
      <tr>
        <td id="L1674" data-line-number="1674"></td>
        <td id="LC1674">    <span>if</span> (<span>StructHasCustomLayout</span>(typeFlags) &amp;&amp; compiler-&gt;<span>IsHfa</span>(typeHnd))</td>
      </tr>
      <tr>
        <td id="L1675" data-line-number="1675"></td>
        <td id="LC1675">    {</td>
      </tr>
      <tr>
        <td id="L1676" data-line-number="1676"></td>
        <td id="LC1676">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1677" data-line-number="1677"></td>
        <td id="LC1677">    }</td>
      </tr>
      <tr>
        <td id="L1678" data-line-number="1678"></td>
        <td id="LC1678">
</td>
      </tr>
      <tr>
        <td id="L1679" data-line-number="1679"></td>
        <td id="LC1679">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L1680" data-line-number="1680"></td>
        <td id="LC1680">    <span><span>//</span> On ARM, we have a requirement on the struct alignment; see below.</span></td>
      </tr>
      <tr>
        <td id="L1681" data-line-number="1681"></td>
        <td id="LC1681">    <span>unsigned</span> structAlignment = <span>roundUp</span>(compHandle-&gt;<span>getClassAlignmentRequirement</span>(typeHnd), TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L1682" data-line-number="1682"></td>
        <td id="LC1682">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L1683" data-line-number="1683"></td>
        <td id="LC1683">
</td>
      </tr>
      <tr>
        <td id="L1684" data-line-number="1684"></td>
        <td id="LC1684">    <span>unsigned</span> fieldsSize = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1685" data-line-number="1685"></td>
        <td id="LC1685">
</td>
      </tr>
      <tr>
        <td id="L1686" data-line-number="1686"></td>
        <td id="LC1686">    <span>for</span> (BYTE ordinal = <span>0</span>; ordinal &lt; fieldCnt; ++ordinal)</td>
      </tr>
      <tr>
        <td id="L1687" data-line-number="1687"></td>
        <td id="LC1687">    {</td>
      </tr>
      <tr>
        <td id="L1688" data-line-number="1688"></td>
        <td id="LC1688">        CORINFO_FIELD_HANDLE fieldHnd       = compHandle-&gt;<span>getFieldInClass</span>(typeHnd, ordinal);</td>
      </tr>
      <tr>
        <td id="L1689" data-line-number="1689"></td>
        <td id="LC1689">        structPromotionInfo.<span>fields</span>[ordinal] = <span>GetFieldInfo</span>(fieldHnd, ordinal);</td>
      </tr>
      <tr>
        <td id="L1690" data-line-number="1690"></td>
        <td id="LC1690">        <span>const</span> lvaStructFieldInfo&amp; fieldInfo = structPromotionInfo.<span>fields</span>[ordinal];</td>
      </tr>
      <tr>
        <td id="L1691" data-line-number="1691"></td>
        <td id="LC1691">
</td>
      </tr>
      <tr>
        <td id="L1692" data-line-number="1692"></td>
        <td id="LC1692">        <span>noway_assert</span>(fieldInfo.<span>fldOffset</span> &lt; structSize);</td>
      </tr>
      <tr>
        <td id="L1693" data-line-number="1693"></td>
        <td id="LC1693">
</td>
      </tr>
      <tr>
        <td id="L1694" data-line-number="1694"></td>
        <td id="LC1694">        <span>if</span> (fieldInfo.<span>fldSize</span> == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L1695" data-line-number="1695"></td>
        <td id="LC1695">        {</td>
      </tr>
      <tr>
        <td id="L1696" data-line-number="1696"></td>
        <td id="LC1696">            <span><span>//</span> Not a scalar type.</span></td>
      </tr>
      <tr>
        <td id="L1697" data-line-number="1697"></td>
        <td id="LC1697">            <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1698" data-line-number="1698"></td>
        <td id="LC1698">        }</td>
      </tr>
      <tr>
        <td id="L1699" data-line-number="1699"></td>
        <td id="LC1699">
</td>
      </tr>
      <tr>
        <td id="L1700" data-line-number="1700"></td>
        <td id="LC1700">        <span>if</span> ((fieldInfo.<span>fldOffset</span> % fieldInfo.<span>fldSize</span>) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L1701" data-line-number="1701"></td>
        <td id="LC1701">        {</td>
      </tr>
      <tr>
        <td id="L1702" data-line-number="1702"></td>
        <td id="LC1702">            <span><span>//</span> The code in Compiler::genPushArgList that reconstitutes</span></td>
      </tr>
      <tr>
        <td id="L1703" data-line-number="1703"></td>
        <td id="LC1703">            <span><span>//</span> struct values on the stack from promoted fields expects</span></td>
      </tr>
      <tr>
        <td id="L1704" data-line-number="1704"></td>
        <td id="LC1704">            <span><span>//</span> those fields to be at their natural alignment.</span></td>
      </tr>
      <tr>
        <td id="L1705" data-line-number="1705"></td>
        <td id="LC1705">            <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1706" data-line-number="1706"></td>
        <td id="LC1706">        }</td>
      </tr>
      <tr>
        <td id="L1707" data-line-number="1707"></td>
        <td id="LC1707">
</td>
      </tr>
      <tr>
        <td id="L1708" data-line-number="1708"></td>
        <td id="LC1708">        <span>if</span> (<span>varTypeIsGC</span>(fieldInfo.<span>fldType</span>))</td>
      </tr>
      <tr>
        <td id="L1709" data-line-number="1709"></td>
        <td id="LC1709">        {</td>
      </tr>
      <tr>
        <td id="L1710" data-line-number="1710"></td>
        <td id="LC1710">            containsGCpointers = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1711" data-line-number="1711"></td>
        <td id="LC1711">        }</td>
      </tr>
      <tr>
        <td id="L1712" data-line-number="1712"></td>
        <td id="LC1712">
</td>
      </tr>
      <tr>
        <td id="L1713" data-line-number="1713"></td>
        <td id="LC1713">        <span><span>//</span> The end offset for this field should never be larger than our structSize.</span></td>
      </tr>
      <tr>
        <td id="L1714" data-line-number="1714"></td>
        <td id="LC1714">        <span>noway_assert</span>(fieldInfo.<span>fldOffset</span> + fieldInfo.<span>fldSize</span> &lt;= structSize);</td>
      </tr>
      <tr>
        <td id="L1715" data-line-number="1715"></td>
        <td id="LC1715">
</td>
      </tr>
      <tr>
        <td id="L1716" data-line-number="1716"></td>
        <td id="LC1716">        fieldsSize += fieldInfo.<span>fldSize</span>;</td>
      </tr>
      <tr>
        <td id="L1717" data-line-number="1717"></td>
        <td id="LC1717">
</td>
      </tr>
      <tr>
        <td id="L1718" data-line-number="1718"></td>
        <td id="LC1718">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L1719" data-line-number="1719"></td>
        <td id="LC1719">        <span><span>//</span> On ARM, for struct types that don't use explicit layout, the alignment of the struct is</span></td>
      </tr>
      <tr>
        <td id="L1720" data-line-number="1720"></td>
        <td id="LC1720">        <span><span>//</span> at least the max alignment of its fields.  We take advantage of this invariant in struct promotion,</span></td>
      </tr>
      <tr>
        <td id="L1721" data-line-number="1721"></td>
        <td id="LC1721">        <span><span>//</span> so verify it here.</span></td>
      </tr>
      <tr>
        <td id="L1722" data-line-number="1722"></td>
        <td id="LC1722">        <span>if</span> (fieldInfo.<span>fldSize</span> &gt; structAlignment)</td>
      </tr>
      <tr>
        <td id="L1723" data-line-number="1723"></td>
        <td id="LC1723">        {</td>
      </tr>
      <tr>
        <td id="L1724" data-line-number="1724"></td>
        <td id="LC1724">            <span><span>//</span> Don't promote vars whose struct types violates the invariant.  (Alignment == size for primitives.)</span></td>
      </tr>
      <tr>
        <td id="L1725" data-line-number="1725"></td>
        <td id="LC1725">            <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1726" data-line-number="1726"></td>
        <td id="LC1726">        }</td>
      </tr>
      <tr>
        <td id="L1727" data-line-number="1727"></td>
        <td id="LC1727">        <span><span>//</span> If we have any small fields we will allocate a single PromotedStructScratch local var for the method.</span></td>
      </tr>
      <tr>
        <td id="L1728" data-line-number="1728"></td>
        <td id="LC1728">        <span><span>//</span> This is a stack area that we use to assemble the small fields in order to place them in a register</span></td>
      </tr>
      <tr>
        <td id="L1729" data-line-number="1729"></td>
        <td id="LC1729">        <span><span>//</span> argument.</span></td>
      </tr>
      <tr>
        <td id="L1730" data-line-number="1730"></td>
        <td id="LC1730">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1731" data-line-number="1731"></td>
        <td id="LC1731">        <span>if</span> (fieldInfo.<span>fldSize</span> &lt; TARGET_POINTER_SIZE)</td>
      </tr>
      <tr>
        <td id="L1732" data-line-number="1732"></td>
        <td id="LC1732">        {</td>
      </tr>
      <tr>
        <td id="L1733" data-line-number="1733"></td>
        <td id="LC1733">            requiresScratchVar = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1734" data-line-number="1734"></td>
        <td id="LC1734">        }</td>
      </tr>
      <tr>
        <td id="L1735" data-line-number="1735"></td>
        <td id="LC1735">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L1736" data-line-number="1736"></td>
        <td id="LC1736">    }</td>
      </tr>
      <tr>
        <td id="L1737" data-line-number="1737"></td>
        <td id="LC1737">
</td>
      </tr>
      <tr>
        <td id="L1738" data-line-number="1738"></td>
        <td id="LC1738">    <span><span>//</span> If we saw any GC pointer or by-ref fields above then CORINFO_FLG_CONTAINS_GC_PTR or</span></td>
      </tr>
      <tr>
        <td id="L1739" data-line-number="1739"></td>
        <td id="LC1739">    <span><span>//</span> CORINFO_FLG_CONTAINS_STACK_PTR has to be set!</span></td>
      </tr>
      <tr>
        <td id="L1740" data-line-number="1740"></td>
        <td id="LC1740">    <span>noway_assert</span>((containsGCpointers == <span>false</span>) ||</td>
      </tr>
      <tr>
        <td id="L1741" data-line-number="1741"></td>
        <td id="LC1741">                 ((typeFlags &amp; (CORINFO_FLG_CONTAINS_GC_PTR | CORINFO_FLG_CONTAINS_STACK_PTR)) != <span>0</span>));</td>
      </tr>
      <tr>
        <td id="L1742" data-line-number="1742"></td>
        <td id="LC1742">
</td>
      </tr>
      <tr>
        <td id="L1743" data-line-number="1743"></td>
        <td id="LC1743">    <span><span>//</span> If we have "Custom Layout" then we might have an explicit Size attribute</span></td>
      </tr>
      <tr>
        <td id="L1744" data-line-number="1744"></td>
        <td id="LC1744">    <span><span>//</span> Managed C++ uses this for its structs, such C++ types will not contain GC pointers.</span></td>
      </tr>
      <tr>
        <td id="L1745" data-line-number="1745"></td>
        <td id="LC1745">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1746" data-line-number="1746"></td>
        <td id="LC1746">    <span><span>//</span> The current VM implementation also incorrectly sets the CORINFO_FLG_CUSTOMLAYOUT</span></td>
      </tr>
      <tr>
        <td id="L1747" data-line-number="1747"></td>
        <td id="LC1747">    <span><span>//</span> whenever a managed value class contains any GC pointers.</span></td>
      </tr>
      <tr>
        <td id="L1748" data-line-number="1748"></td>
        <td id="LC1748">    <span><span>//</span> (See the comment for VMFLAG_NOT_TIGHTLY_PACKED in class.h)</span></td>
      </tr>
      <tr>
        <td id="L1749" data-line-number="1749"></td>
        <td id="LC1749">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1750" data-line-number="1750"></td>
        <td id="LC1750">    <span><span>//</span> It is important to struct promote managed value classes that have GC pointers</span></td>
      </tr>
      <tr>
        <td id="L1751" data-line-number="1751"></td>
        <td id="LC1751">    <span><span>//</span> So we compute the correct value for "CustomLayout" here</span></td>
      </tr>
      <tr>
        <td id="L1752" data-line-number="1752"></td>
        <td id="LC1752">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1753" data-line-number="1753"></td>
        <td id="LC1753">    <span>if</span> (<span>StructHasCustomLayout</span>(typeFlags) &amp;&amp; ((typeFlags &amp; CORINFO_FLG_CONTAINS_GC_PTR) == <span>0</span>))</td>
      </tr>
      <tr>
        <td id="L1754" data-line-number="1754"></td>
        <td id="LC1754">    {</td>
      </tr>
      <tr>
        <td id="L1755" data-line-number="1755"></td>
        <td id="LC1755">        structPromotionInfo.<span>customLayout</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1756" data-line-number="1756"></td>
        <td id="LC1756">    }</td>
      </tr>
      <tr>
        <td id="L1757" data-line-number="1757"></td>
        <td id="LC1757">
</td>
      </tr>
      <tr>
        <td id="L1758" data-line-number="1758"></td>
        <td id="LC1758">    <span><span>//</span> Check if this promoted struct contains any holes.</span></td>
      </tr>
      <tr>
        <td id="L1759" data-line-number="1759"></td>
        <td id="LC1759">    <span>assert</span>(!overlappingFields);</td>
      </tr>
      <tr>
        <td id="L1760" data-line-number="1760"></td>
        <td id="LC1760">    <span>if</span> (fieldsSize != structSize)</td>
      </tr>
      <tr>
        <td id="L1761" data-line-number="1761"></td>
        <td id="LC1761">    {</td>
      </tr>
      <tr>
        <td id="L1762" data-line-number="1762"></td>
        <td id="LC1762">        <span><span>//</span> If sizes do not match it means we have an overlapping fields or holes.</span></td>
      </tr>
      <tr>
        <td id="L1763" data-line-number="1763"></td>
        <td id="LC1763">        <span><span>//</span> Overlapping fields were rejected early, so here it can mean only holes.</span></td>
      </tr>
      <tr>
        <td id="L1764" data-line-number="1764"></td>
        <td id="LC1764">        structPromotionInfo.<span>containsHoles</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1765" data-line-number="1765"></td>
        <td id="LC1765">    }</td>
      </tr>
      <tr>
        <td id="L1766" data-line-number="1766"></td>
        <td id="LC1766">
</td>
      </tr>
      <tr>
        <td id="L1767" data-line-number="1767"></td>
        <td id="LC1767">    <span><span>//</span> Cool, this struct is promotable.</span></td>
      </tr>
      <tr>
        <td id="L1768" data-line-number="1768"></td>
        <td id="LC1768">
</td>
      </tr>
      <tr>
        <td id="L1769" data-line-number="1769"></td>
        <td id="LC1769">    structPromotionInfo.<span>canPromote</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1770" data-line-number="1770"></td>
        <td id="LC1770">    <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1771" data-line-number="1771"></td>
        <td id="LC1771">}</td>
      </tr>
      <tr>
        <td id="L1772" data-line-number="1772"></td>
        <td id="LC1772">
</td>
      </tr>
      <tr>
        <td id="L1773" data-line-number="1773"></td>
        <td id="LC1773"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1774" data-line-number="1774"></td>
        <td id="LC1774"><span><span>//</span> CanPromoteStructVar - checks if the struct can be promoted.</span></td>
      </tr>
      <tr>
        <td id="L1775" data-line-number="1775"></td>
        <td id="LC1775"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1776" data-line-number="1776"></td>
        <td id="LC1776"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1777" data-line-number="1777"></td>
        <td id="LC1777"><span><span>//</span>   lclNum - struct number to check.</span></td>
      </tr>
      <tr>
        <td id="L1778" data-line-number="1778"></td>
        <td id="LC1778"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1779" data-line-number="1779"></td>
        <td id="LC1779"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L1780" data-line-number="1780"></td>
        <td id="LC1780"><span><span>//</span>   true if the struct var can be promoted.</span></td>
      </tr>
      <tr>
        <td id="L1781" data-line-number="1781"></td>
        <td id="LC1781"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1782" data-line-number="1782"></td>
        <td id="LC1782"><span>bool</span> <span>Compiler::StructPromotionHelper::CanPromoteStructVar</span>(<span>unsigned</span> lclNum)</td>
      </tr>
      <tr>
        <td id="L1783" data-line-number="1783"></td>
        <td id="LC1783">{</td>
      </tr>
      <tr>
        <td id="L1784" data-line-number="1784"></td>
        <td id="LC1784">    LclVarDsc* varDsc = compiler-&gt;<span>lvaGetDesc</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L1785" data-line-number="1785"></td>
        <td id="LC1785">
</td>
      </tr>
      <tr>
        <td id="L1786" data-line-number="1786"></td>
        <td id="LC1786">    <span>assert</span>(<span>varTypeIsStruct</span>(varDsc));</td>
      </tr>
      <tr>
        <td id="L1787" data-line-number="1787"></td>
        <td id="LC1787">    <span>assert</span>(!varDsc-&gt;<span>lvPromoted</span>); <span><span>//</span> Don't ask again :)</span></td>
      </tr>
      <tr>
        <td id="L1788" data-line-number="1788"></td>
        <td id="LC1788">
</td>
      </tr>
      <tr>
        <td id="L1789" data-line-number="1789"></td>
        <td id="LC1789">    <span><span>//</span> If this lclVar is used in a SIMD intrinsic, then we don't want to struct promote it.</span></td>
      </tr>
      <tr>
        <td id="L1790" data-line-number="1790"></td>
        <td id="LC1790">    <span><span>//</span> Note, however, that SIMD lclVars that are NOT used in a SIMD intrinsic may be</span></td>
      </tr>
      <tr>
        <td id="L1791" data-line-number="1791"></td>
        <td id="LC1791">    <span><span>//</span> profitably promoted.</span></td>
      </tr>
      <tr>
        <td id="L1792" data-line-number="1792"></td>
        <td id="LC1792">    <span>if</span> (varDsc-&gt;<span>lvIsUsedInSIMDIntrinsic</span>())</td>
      </tr>
      <tr>
        <td id="L1793" data-line-number="1793"></td>
        <td id="LC1793">    {</td>
      </tr>
      <tr>
        <td id="L1794" data-line-number="1794"></td>
        <td id="LC1794">        <span>JITDUMP</span>(<span><span>"</span>  struct promotion of V%02u is disabled because lvIsUsedInSIMDIntrinsic()<span>\n</span><span>"</span></span>, lclNum);</td>
      </tr>
      <tr>
        <td id="L1795" data-line-number="1795"></td>
        <td id="LC1795">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1796" data-line-number="1796"></td>
        <td id="LC1796">    }</td>
      </tr>
      <tr>
        <td id="L1797" data-line-number="1797"></td>
        <td id="LC1797">
</td>
      </tr>
      <tr>
        <td id="L1798" data-line-number="1798"></td>
        <td id="LC1798">    <span><span>//</span> Reject struct promotion of parameters when -GS stack reordering is enabled</span></td>
      </tr>
      <tr>
        <td id="L1799" data-line-number="1799"></td>
        <td id="LC1799">    <span><span>//</span> as we could introduce shadow copies of them.</span></td>
      </tr>
      <tr>
        <td id="L1800" data-line-number="1800"></td>
        <td id="LC1800">    <span>if</span> (varDsc-&gt;<span>lvIsParam</span> &amp;&amp; compiler-&gt;<span>compGSReorderStackLayout</span>)</td>
      </tr>
      <tr>
        <td id="L1801" data-line-number="1801"></td>
        <td id="LC1801">    {</td>
      </tr>
      <tr>
        <td id="L1802" data-line-number="1802"></td>
        <td id="LC1802">        <span>JITDUMP</span>(<span><span>"</span>  struct promotion of V%02u is disabled because lvIsParam and compGSReorderStackLayout<span>\n</span><span>"</span></span>, lclNum);</td>
      </tr>
      <tr>
        <td id="L1803" data-line-number="1803"></td>
        <td id="LC1803">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1804" data-line-number="1804"></td>
        <td id="LC1804">    }</td>
      </tr>
      <tr>
        <td id="L1805" data-line-number="1805"></td>
        <td id="LC1805">
</td>
      </tr>
      <tr>
        <td id="L1806" data-line-number="1806"></td>
        <td id="LC1806">    <span><span>//</span> Explicitly check for HFA reg args and reject them for promotion here.</span></td>
      </tr>
      <tr>
        <td id="L1807" data-line-number="1807"></td>
        <td id="LC1807">    <span><span>//</span> Promoting HFA args will fire an assert in lvaAssignFrameOffsets</span></td>
      </tr>
      <tr>
        <td id="L1808" data-line-number="1808"></td>
        <td id="LC1808">    <span><span>//</span> when the HFA reg arg is struct promoted.</span></td>
      </tr>
      <tr>
        <td id="L1809" data-line-number="1809"></td>
        <td id="LC1809">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1810" data-line-number="1810"></td>
        <td id="LC1810">    <span><span>//</span> TODO-PERF - Allow struct promotion for HFA register arguments</span></td>
      </tr>
      <tr>
        <td id="L1811" data-line-number="1811"></td>
        <td id="LC1811">    <span>if</span> (varDsc-&gt;<span>lvIsHfaRegArg</span>())</td>
      </tr>
      <tr>
        <td id="L1812" data-line-number="1812"></td>
        <td id="LC1812">    {</td>
      </tr>
      <tr>
        <td id="L1813" data-line-number="1813"></td>
        <td id="LC1813">        <span>JITDUMP</span>(<span><span>"</span>  struct promotion of V%02u is disabled because lvIsHfaRegArg()<span>\n</span><span>"</span></span>, lclNum);</td>
      </tr>
      <tr>
        <td id="L1814" data-line-number="1814"></td>
        <td id="LC1814">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1815" data-line-number="1815"></td>
        <td id="LC1815">    }</td>
      </tr>
      <tr>
        <td id="L1816" data-line-number="1816"></td>
        <td id="LC1816">
</td>
      </tr>
      <tr>
        <td id="L1817" data-line-number="1817"></td>
        <td id="LC1817">#<span>if</span> !FEATURE_MULTIREG_STRUCT_PROMOTE</td>
      </tr>
      <tr>
        <td id="L1818" data-line-number="1818"></td>
        <td id="LC1818">    <span>if</span> (varDsc-&gt;<span>lvIsMultiRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L1819" data-line-number="1819"></td>
        <td id="LC1819">    {</td>
      </tr>
      <tr>
        <td id="L1820" data-line-number="1820"></td>
        <td id="LC1820">        <span>JITDUMP</span>(<span><span>"</span>  struct promotion of V%02u is disabled because lvIsMultiRegArg<span>\n</span><span>"</span></span>, lclNum);</td>
      </tr>
      <tr>
        <td id="L1821" data-line-number="1821"></td>
        <td id="LC1821">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1822" data-line-number="1822"></td>
        <td id="LC1822">    }</td>
      </tr>
      <tr>
        <td id="L1823" data-line-number="1823"></td>
        <td id="LC1823">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1824" data-line-number="1824"></td>
        <td id="LC1824">
</td>
      </tr>
      <tr>
        <td id="L1825" data-line-number="1825"></td>
        <td id="LC1825">    <span>if</span> (varDsc-&gt;<span>lvIsMultiRegRet</span>)</td>
      </tr>
      <tr>
        <td id="L1826" data-line-number="1826"></td>
        <td id="LC1826">    {</td>
      </tr>
      <tr>
        <td id="L1827" data-line-number="1827"></td>
        <td id="LC1827">        <span>JITDUMP</span>(<span><span>"</span>  struct promotion of V%02u is disabled because lvIsMultiRegRet<span>\n</span><span>"</span></span>, lclNum);</td>
      </tr>
      <tr>
        <td id="L1828" data-line-number="1828"></td>
        <td id="LC1828">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1829" data-line-number="1829"></td>
        <td id="LC1829">    }</td>
      </tr>
      <tr>
        <td id="L1830" data-line-number="1830"></td>
        <td id="LC1830">
</td>
      </tr>
      <tr>
        <td id="L1831" data-line-number="1831"></td>
        <td id="LC1831">    CORINFO_CLASS_HANDLE typeHnd = varDsc-&gt;<span>lvVerTypeInfo</span>.<span>GetClassHandle</span>();</td>
      </tr>
      <tr>
        <td id="L1832" data-line-number="1832"></td>
        <td id="LC1832">    <span>return</span> <span>CanPromoteStructType</span>(typeHnd);</td>
      </tr>
      <tr>
        <td id="L1833" data-line-number="1833"></td>
        <td id="LC1833">}</td>
      </tr>
      <tr>
        <td id="L1834" data-line-number="1834"></td>
        <td id="LC1834">
</td>
      </tr>
      <tr>
        <td id="L1835" data-line-number="1835"></td>
        <td id="LC1835"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1836" data-line-number="1836"></td>
        <td id="LC1836"><span><span>//</span> ShouldPromoteStructVar - Should a struct var be promoted if it can be promoted?</span></td>
      </tr>
      <tr>
        <td id="L1837" data-line-number="1837"></td>
        <td id="LC1837"><span><span>//</span> This routine mainly performs profitability checks.  Right now it also has</span></td>
      </tr>
      <tr>
        <td id="L1838" data-line-number="1838"></td>
        <td id="LC1838"><span><span>//</span> some correctness checks due to limitations of down-stream phases.</span></td>
      </tr>
      <tr>
        <td id="L1839" data-line-number="1839"></td>
        <td id="LC1839"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1840" data-line-number="1840"></td>
        <td id="LC1840"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1841" data-line-number="1841"></td>
        <td id="LC1841"><span><span>//</span>   lclNum - struct local number;</span></td>
      </tr>
      <tr>
        <td id="L1842" data-line-number="1842"></td>
        <td id="LC1842"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1843" data-line-number="1843"></td>
        <td id="LC1843"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L1844" data-line-number="1844"></td>
        <td id="LC1844"><span><span>//</span>   true if the struct should be promoted.</span></td>
      </tr>
      <tr>
        <td id="L1845" data-line-number="1845"></td>
        <td id="LC1845"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1846" data-line-number="1846"></td>
        <td id="LC1846"><span>bool</span> <span>Compiler::StructPromotionHelper::ShouldPromoteStructVar</span>(<span>unsigned</span> lclNum)</td>
      </tr>
      <tr>
        <td id="L1847" data-line-number="1847"></td>
        <td id="LC1847">{</td>
      </tr>
      <tr>
        <td id="L1848" data-line-number="1848"></td>
        <td id="LC1848">    <span>assert</span>(lclNum &lt; compiler-&gt;<span>lvaCount</span>);</td>
      </tr>
      <tr>
        <td id="L1849" data-line-number="1849"></td>
        <td id="LC1849">
</td>
      </tr>
      <tr>
        <td id="L1850" data-line-number="1850"></td>
        <td id="LC1850">    LclVarDsc* varDsc = &amp;compiler-&gt;<span>lvaTable</span>[lclNum];</td>
      </tr>
      <tr>
        <td id="L1851" data-line-number="1851"></td>
        <td id="LC1851">    <span>assert</span>(<span>varTypeIsStruct</span>(varDsc));</td>
      </tr>
      <tr>
        <td id="L1852" data-line-number="1852"></td>
        <td id="LC1852">    <span>assert</span>(varDsc-&gt;<span>lvVerTypeInfo</span>.<span>GetClassHandle</span>() == structPromotionInfo.<span>typeHnd</span>);</td>
      </tr>
      <tr>
        <td id="L1853" data-line-number="1853"></td>
        <td id="LC1853">    <span>assert</span>(structPromotionInfo.<span>canPromote</span>);</td>
      </tr>
      <tr>
        <td id="L1854" data-line-number="1854"></td>
        <td id="LC1854">
</td>
      </tr>
      <tr>
        <td id="L1855" data-line-number="1855"></td>
        <td id="LC1855">    <span>bool</span> shouldPromote = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1856" data-line-number="1856"></td>
        <td id="LC1856">
</td>
      </tr>
      <tr>
        <td id="L1857" data-line-number="1857"></td>
        <td id="LC1857">    <span><span>//</span> We *can* promote; *should* we promote?</span></td>
      </tr>
      <tr>
        <td id="L1858" data-line-number="1858"></td>
        <td id="LC1858">    <span><span>//</span> We should only do so if promotion has potential savings.  One source of savings</span></td>
      </tr>
      <tr>
        <td id="L1859" data-line-number="1859"></td>
        <td id="LC1859">    <span><span>//</span> is if a field of the struct is accessed, since this access will be turned into</span></td>
      </tr>
      <tr>
        <td id="L1860" data-line-number="1860"></td>
        <td id="LC1860">    <span><span>//</span> an access of the corresponding promoted field variable.  Even if there are no</span></td>
      </tr>
      <tr>
        <td id="L1861" data-line-number="1861"></td>
        <td id="LC1861">    <span><span>//</span> field accesses, but only block-level operations on the whole struct, if the struct</span></td>
      </tr>
      <tr>
        <td id="L1862" data-line-number="1862"></td>
        <td id="LC1862">    <span><span>//</span> has only one or two fields, then doing those block operations field-wise is probably faster</span></td>
      </tr>
      <tr>
        <td id="L1863" data-line-number="1863"></td>
        <td id="LC1863">    <span><span>//</span> than doing a whole-variable block operation (e.g., a hardware "copy loop" on x86).</span></td>
      </tr>
      <tr>
        <td id="L1864" data-line-number="1864"></td>
        <td id="LC1864">    <span><span>//</span> Struct promotion also provides the following benefits: reduce stack frame size,</span></td>
      </tr>
      <tr>
        <td id="L1865" data-line-number="1865"></td>
        <td id="LC1865">    <span><span>//</span> reduce the need for zero init of stack frame and fine grained constant/copy prop.</span></td>
      </tr>
      <tr>
        <td id="L1866" data-line-number="1866"></td>
        <td id="LC1866">    <span><span>//</span> Asm diffs indicate that promoting structs up to 3 fields is a net size win.</span></td>
      </tr>
      <tr>
        <td id="L1867" data-line-number="1867"></td>
        <td id="LC1867">    <span><span>//</span> So if no fields are accessed independently, and there are four or more fields,</span></td>
      </tr>
      <tr>
        <td id="L1868" data-line-number="1868"></td>
        <td id="LC1868">    <span><span>//</span> then do not promote.</span></td>
      </tr>
      <tr>
        <td id="L1869" data-line-number="1869"></td>
        <td id="LC1869">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1870" data-line-number="1870"></td>
        <td id="LC1870">    <span><span>//</span> TODO: Ideally we would want to consider the impact of whether the struct is</span></td>
      </tr>
      <tr>
        <td id="L1871" data-line-number="1871"></td>
        <td id="LC1871">    <span><span>//</span> passed as a parameter or assigned the return value of a call. Because once promoted,</span></td>
      </tr>
      <tr>
        <td id="L1872" data-line-number="1872"></td>
        <td id="LC1872">    <span><span>//</span> struct copying is done by field by field assignment instead of a more efficient</span></td>
      </tr>
      <tr>
        <td id="L1873" data-line-number="1873"></td>
        <td id="LC1873">    <span><span>//</span> rep.stos or xmm reg based copy.</span></td>
      </tr>
      <tr>
        <td id="L1874" data-line-number="1874"></td>
        <td id="LC1874">    <span>if</span> (structPromotionInfo.<span>fieldCnt</span> &gt; <span>3</span> &amp;&amp; !varDsc-&gt;<span>lvFieldAccessed</span>)</td>
      </tr>
      <tr>
        <td id="L1875" data-line-number="1875"></td>
        <td id="LC1875">    {</td>
      </tr>
      <tr>
        <td id="L1876" data-line-number="1876"></td>
        <td id="LC1876">        <span>JITDUMP</span>(<span><span>"</span>Not promoting promotable struct local V%02u: #fields = %d, fieldAccessed = %d.<span>\n</span><span>"</span></span>, lclNum,</td>
      </tr>
      <tr>
        <td id="L1877" data-line-number="1877"></td>
        <td id="LC1877">                structPromotionInfo.<span>fieldCnt</span>, varDsc-&gt;<span>lvFieldAccessed</span>);</td>
      </tr>
      <tr>
        <td id="L1878" data-line-number="1878"></td>
        <td id="LC1878">        shouldPromote = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1879" data-line-number="1879"></td>
        <td id="LC1879">    }</td>
      </tr>
      <tr>
        <td id="L1880" data-line-number="1880"></td>
        <td id="LC1880">#<span>if</span> defined(TARGET_AMD64) || defined(TARGET_ARM64) || defined(TARGET_ARM)</td>
      </tr>
      <tr>
        <td id="L1881" data-line-number="1881"></td>
        <td id="LC1881">    <span><span>//</span> TODO-PERF - Only do this when the LclVar is used in an argument context</span></td>
      </tr>
      <tr>
        <td id="L1882" data-line-number="1882"></td>
        <td id="LC1882">    <span><span>//</span> TODO-ARM64 - HFA support should also eliminate the need for this.</span></td>
      </tr>
      <tr>
        <td id="L1883" data-line-number="1883"></td>
        <td id="LC1883">    <span><span>//</span> TODO-ARM32 - HFA support should also eliminate the need for this.</span></td>
      </tr>
      <tr>
        <td id="L1884" data-line-number="1884"></td>
        <td id="LC1884">    <span><span>//</span> TODO-LSRA - Currently doesn't support the passing of floating point LCL_VARS in the integer registers</span></td>
      </tr>
      <tr>
        <td id="L1885" data-line-number="1885"></td>
        <td id="LC1885">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1886" data-line-number="1886"></td>
        <td id="LC1886">    <span><span>//</span> For now we currently don't promote structs with a single float field</span></td>
      </tr>
      <tr>
        <td id="L1887" data-line-number="1887"></td>
        <td id="LC1887">    <span><span>//</span> Promoting it can cause us to shuffle it back and forth between the int and</span></td>
      </tr>
      <tr>
        <td id="L1888" data-line-number="1888"></td>
        <td id="LC1888">    <span><span>//</span>  the float regs when it is used as a argument, which is very expensive for XARCH</span></td>
      </tr>
      <tr>
        <td id="L1889" data-line-number="1889"></td>
        <td id="LC1889">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1890" data-line-number="1890"></td>
        <td id="LC1890">    <span>else</span> <span>if</span> ((structPromotionInfo.<span>fieldCnt</span> == <span>1</span>) &amp;&amp; <span>varTypeIsFloating</span>(structPromotionInfo.<span>fields</span>[<span>0</span>].<span>fldType</span>))</td>
      </tr>
      <tr>
        <td id="L1891" data-line-number="1891"></td>
        <td id="LC1891">    {</td>
      </tr>
      <tr>
        <td id="L1892" data-line-number="1892"></td>
        <td id="LC1892">        <span>JITDUMP</span>(<span><span>"</span>Not promoting promotable struct local V%02u: #fields = %d because it is a struct with <span>"</span></span></td>
      </tr>
      <tr>
        <td id="L1893" data-line-number="1893"></td>
        <td id="LC1893">                <span><span>"</span>single float field.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L1894" data-line-number="1894"></td>
        <td id="LC1894">                lclNum, structPromotionInfo.<span>fieldCnt</span>);</td>
      </tr>
      <tr>
        <td id="L1895" data-line-number="1895"></td>
        <td id="LC1895">        shouldPromote = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1896" data-line-number="1896"></td>
        <td id="LC1896">    }</td>
      </tr>
      <tr>
        <td id="L1897" data-line-number="1897"></td>
        <td id="LC1897">#<span>endif</span> <span><span>//</span> TARGET_AMD64 || TARGET_ARM64 || TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L1898" data-line-number="1898"></td>
        <td id="LC1898">    <span>else</span> <span>if</span> (varDsc-&gt;<span>lvIsParam</span> &amp;&amp; !compiler-&gt;<span>lvaIsImplicitByRefLocal</span>(lclNum))</td>
      </tr>
      <tr>
        <td id="L1899" data-line-number="1899"></td>
        <td id="LC1899">    {</td>
      </tr>
      <tr>
        <td id="L1900" data-line-number="1900"></td>
        <td id="LC1900">#<span>if</span> FEATURE_MULTIREG_STRUCT_PROMOTE</td>
      </tr>
      <tr>
        <td id="L1901" data-line-number="1901"></td>
        <td id="LC1901">        <span><span>//</span> Is this a variable holding a value with exactly two fields passed in</span></td>
      </tr>
      <tr>
        <td id="L1902" data-line-number="1902"></td>
        <td id="LC1902">        <span><span>//</span> multiple registers?</span></td>
      </tr>
      <tr>
        <td id="L1903" data-line-number="1903"></td>
        <td id="LC1903">        <span>if</span> ((structPromotionInfo.<span>fieldCnt</span> != <span>2</span>) &amp;&amp; compiler-&gt;<span>lvaIsMultiregStruct</span>(varDsc, compiler-&gt;<span>info</span>.<span>compIsVarArgs</span>))</td>
      </tr>
      <tr>
        <td id="L1904" data-line-number="1904"></td>
        <td id="LC1904">        {</td>
      </tr>
      <tr>
        <td id="L1905" data-line-number="1905"></td>
        <td id="LC1905">            <span>JITDUMP</span>(<span><span>"</span>Not promoting multireg struct local V%02u, because lvIsParam is true and #fields != 2<span>\n</span><span>"</span></span>, lclNum);</td>
      </tr>
      <tr>
        <td id="L1906" data-line-number="1906"></td>
        <td id="LC1906">            shouldPromote = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1907" data-line-number="1907"></td>
        <td id="LC1907">        }</td>
      </tr>
      <tr>
        <td id="L1908" data-line-number="1908"></td>
        <td id="LC1908">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L1909" data-line-number="1909"></td>
        <td id="LC1909">#<span>endif</span> <span><span>//</span> !FEATURE_MULTIREG_STRUCT_PROMOTE</span></td>
      </tr>
      <tr>
        <td id="L1910" data-line-number="1910"></td>
        <td id="LC1910">
</td>
      </tr>
      <tr>
        <td id="L1911" data-line-number="1911"></td>
        <td id="LC1911">            <span><span>//</span> TODO-PERF - Implement struct promotion for incoming multireg structs</span></td>
      </tr>
      <tr>
        <td id="L1912" data-line-number="1912"></td>
        <td id="LC1912">            <span><span>//</span>             Currently it hits assert(lvFieldCnt==1) in lclvar.cpp line 4417</span></td>
      </tr>
      <tr>
        <td id="L1913" data-line-number="1913"></td>
        <td id="LC1913">            <span><span>//</span>             Also the implementation of jmp uses the 4 byte move to store</span></td>
      </tr>
      <tr>
        <td id="L1914" data-line-number="1914"></td>
        <td id="LC1914">            <span><span>//</span>             byte parameters to the stack, so that if we have a byte field</span></td>
      </tr>
      <tr>
        <td id="L1915" data-line-number="1915"></td>
        <td id="LC1915">            <span><span>//</span>             with something else occupying the same 4-byte slot, it will</span></td>
      </tr>
      <tr>
        <td id="L1916" data-line-number="1916"></td>
        <td id="LC1916">            <span><span>//</span>             overwrite other fields.</span></td>
      </tr>
      <tr>
        <td id="L1917" data-line-number="1917"></td>
        <td id="LC1917">            <span>if</span> (structPromotionInfo.<span>fieldCnt</span> != <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L1918" data-line-number="1918"></td>
        <td id="LC1918">        {</td>
      </tr>
      <tr>
        <td id="L1919" data-line-number="1919"></td>
        <td id="LC1919">            <span>JITDUMP</span>(<span><span>"</span>Not promoting promotable struct local V%02u, because lvIsParam is true and #fields = <span>"</span></span></td>
      </tr>
      <tr>
        <td id="L1920" data-line-number="1920"></td>
        <td id="LC1920">                    <span><span>"</span>%d.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L1921" data-line-number="1921"></td>
        <td id="LC1921">                    lclNum, structPromotionInfo.<span>fieldCnt</span>);</td>
      </tr>
      <tr>
        <td id="L1922" data-line-number="1922"></td>
        <td id="LC1922">            shouldPromote = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1923" data-line-number="1923"></td>
        <td id="LC1923">        }</td>
      </tr>
      <tr>
        <td id="L1924" data-line-number="1924"></td>
        <td id="LC1924">    }</td>
      </tr>
      <tr>
        <td id="L1925" data-line-number="1925"></td>
        <td id="LC1925">
</td>
      </tr>
      <tr>
        <td id="L1926" data-line-number="1926"></td>
        <td id="LC1926">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1927" data-line-number="1927"></td>
        <td id="LC1927">    <span><span>//</span> If the lvRefCnt is zero and we have a struct promoted parameter we can end up with an extra store of</span></td>
      </tr>
      <tr>
        <td id="L1928" data-line-number="1928"></td>
        <td id="LC1928">    <span><span>//</span> the the incoming register into the stack frame slot.</span></td>
      </tr>
      <tr>
        <td id="L1929" data-line-number="1929"></td>
        <td id="LC1929">    <span><span>//</span> In that case, we would like to avoid promortion.</span></td>
      </tr>
      <tr>
        <td id="L1930" data-line-number="1930"></td>
        <td id="LC1930">    <span><span>//</span> However we haven't yet computed the lvRefCnt values so we can't do that.</span></td>
      </tr>
      <tr>
        <td id="L1931" data-line-number="1931"></td>
        <td id="LC1931">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1932" data-line-number="1932"></td>
        <td id="LC1932">    CLANG_FORMAT_COMMENT_ANCHOR;</td>
      </tr>
      <tr>
        <td id="L1933" data-line-number="1933"></td>
        <td id="LC1933">
</td>
      </tr>
      <tr>
        <td id="L1934" data-line-number="1934"></td>
        <td id="LC1934">    <span>return</span> shouldPromote;</td>
      </tr>
      <tr>
        <td id="L1935" data-line-number="1935"></td>
        <td id="LC1935">}</td>
      </tr>
      <tr>
        <td id="L1936" data-line-number="1936"></td>
        <td id="LC1936">
</td>
      </tr>
      <tr>
        <td id="L1937" data-line-number="1937"></td>
        <td id="LC1937"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1938" data-line-number="1938"></td>
        <td id="LC1938"><span><span>//</span> SortStructFields - sort the fields according to the increasing order of the field offset.</span></td>
      </tr>
      <tr>
        <td id="L1939" data-line-number="1939"></td>
        <td id="LC1939"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1940" data-line-number="1940"></td>
        <td id="LC1940"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L1941" data-line-number="1941"></td>
        <td id="LC1941"><span><span>//</span>   This is needed because the fields need to be pushed on stack (when referenced as a struct) in offset order.</span></td>
      </tr>
      <tr>
        <td id="L1942" data-line-number="1942"></td>
        <td id="LC1942"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1943" data-line-number="1943"></td>
        <td id="LC1943"><span>void</span> <span>Compiler::StructPromotionHelper::SortStructFields</span>()</td>
      </tr>
      <tr>
        <td id="L1944" data-line-number="1944"></td>
        <td id="LC1944">{</td>
      </tr>
      <tr>
        <td id="L1945" data-line-number="1945"></td>
        <td id="LC1945">    <span>assert</span>(!structPromotionInfo.<span>fieldsSorted</span>);</td>
      </tr>
      <tr>
        <td id="L1946" data-line-number="1946"></td>
        <td id="LC1946">    <span>qsort</span>(structPromotionInfo.<span>fields</span>, structPromotionInfo.<span>fieldCnt</span>, <span>sizeof</span>(*structPromotionInfo.<span>fields</span>),</td>
      </tr>
      <tr>
        <td id="L1947" data-line-number="1947"></td>
        <td id="LC1947">          lvaFieldOffsetCmp);</td>
      </tr>
      <tr>
        <td id="L1948" data-line-number="1948"></td>
        <td id="LC1948">    structPromotionInfo.<span>fieldsSorted</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L1949" data-line-number="1949"></td>
        <td id="LC1949">}</td>
      </tr>
      <tr>
        <td id="L1950" data-line-number="1950"></td>
        <td id="LC1950">
</td>
      </tr>
      <tr>
        <td id="L1951" data-line-number="1951"></td>
        <td id="LC1951"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1952" data-line-number="1952"></td>
        <td id="LC1952"><span><span>//</span> GetFieldInfo - get struct field information.</span></td>
      </tr>
      <tr>
        <td id="L1953" data-line-number="1953"></td>
        <td id="LC1953"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L1954" data-line-number="1954"></td>
        <td id="LC1954"><span><span>//</span>   fieldHnd - field handle to get info for;</span></td>
      </tr>
      <tr>
        <td id="L1955" data-line-number="1955"></td>
        <td id="LC1955"><span><span>//</span>   ordinal  - field ordinal.</span></td>
      </tr>
      <tr>
        <td id="L1956" data-line-number="1956"></td>
        <td id="LC1956"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1957" data-line-number="1957"></td>
        <td id="LC1957"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L1958" data-line-number="1958"></td>
        <td id="LC1958"><span><span>//</span>  field information.</span></td>
      </tr>
      <tr>
        <td id="L1959" data-line-number="1959"></td>
        <td id="LC1959"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1960" data-line-number="1960"></td>
        <td id="LC1960">Compiler::lvaStructFieldInfo <span>Compiler::StructPromotionHelper::GetFieldInfo</span>(CORINFO_FIELD_HANDLE fieldHnd, BYTE ordinal)</td>
      </tr>
      <tr>
        <td id="L1961" data-line-number="1961"></td>
        <td id="LC1961">{</td>
      </tr>
      <tr>
        <td id="L1962" data-line-number="1962"></td>
        <td id="LC1962">    lvaStructFieldInfo fieldInfo;</td>
      </tr>
      <tr>
        <td id="L1963" data-line-number="1963"></td>
        <td id="LC1963">    fieldInfo.<span>fldHnd</span> = fieldHnd;</td>
      </tr>
      <tr>
        <td id="L1964" data-line-number="1964"></td>
        <td id="LC1964">
</td>
      </tr>
      <tr>
        <td id="L1965" data-line-number="1965"></td>
        <td id="LC1965">    <span>unsigned</span> fldOffset  = compiler-&gt;<span>info</span>.<span>compCompHnd</span>-&gt;<span>getFieldOffset</span>(fieldInfo.<span>fldHnd</span>);</td>
      </tr>
      <tr>
        <td id="L1966" data-line-number="1966"></td>
        <td id="LC1966">    fieldInfo.<span>fldOffset</span> = (BYTE)fldOffset;</td>
      </tr>
      <tr>
        <td id="L1967" data-line-number="1967"></td>
        <td id="LC1967">
</td>
      </tr>
      <tr>
        <td id="L1968" data-line-number="1968"></td>
        <td id="LC1968">    fieldInfo.<span>fldOrdinal</span> = ordinal;</td>
      </tr>
      <tr>
        <td id="L1969" data-line-number="1969"></td>
        <td id="LC1969">    CorInfoType corType  = compiler-&gt;<span>info</span>.<span>compCompHnd</span>-&gt;<span>getFieldType</span>(fieldInfo.<span>fldHnd</span>, &amp;fieldInfo.<span>fldTypeHnd</span>);</td>
      </tr>
      <tr>
        <td id="L1970" data-line-number="1970"></td>
        <td id="LC1970">    fieldInfo.<span>fldType</span>    = <span>JITtype2varType</span>(corType);</td>
      </tr>
      <tr>
        <td id="L1971" data-line-number="1971"></td>
        <td id="LC1971">    fieldInfo.<span>fldSize</span>    = <span>genTypeSize</span>(fieldInfo.<span>fldType</span>);</td>
      </tr>
      <tr>
        <td id="L1972" data-line-number="1972"></td>
        <td id="LC1972">
</td>
      </tr>
      <tr>
        <td id="L1973" data-line-number="1973"></td>
        <td id="LC1973">#<span>ifdef</span> FEATURE_SIMD</td>
      </tr>
      <tr>
        <td id="L1974" data-line-number="1974"></td>
        <td id="LC1974">    <span><span>//</span> Check to see if this is a SIMD type.</span></td>
      </tr>
      <tr>
        <td id="L1975" data-line-number="1975"></td>
        <td id="LC1975">    <span><span>//</span> We will only check this if we have already found a SIMD type, which will be true if</span></td>
      </tr>
      <tr>
        <td id="L1976" data-line-number="1976"></td>
        <td id="LC1976">    <span><span>//</span> we have encountered any SIMD intrinsics.</span></td>
      </tr>
      <tr>
        <td id="L1977" data-line-number="1977"></td>
        <td id="LC1977">    <span>if</span> (compiler-&gt;<span>usesSIMDTypes</span>() &amp;&amp; (fieldInfo.<span>fldSize</span> == <span>0</span>) &amp;&amp; compiler-&gt;<span>isSIMDorHWSIMDClass</span>(fieldInfo.<span>fldTypeHnd</span>))</td>
      </tr>
      <tr>
        <td id="L1978" data-line-number="1978"></td>
        <td id="LC1978">    {</td>
      </tr>
      <tr>
        <td id="L1979" data-line-number="1979"></td>
        <td id="LC1979">        <span>unsigned</span>  simdSize;</td>
      </tr>
      <tr>
        <td id="L1980" data-line-number="1980"></td>
        <td id="LC1980">        var_types simdBaseType = compiler-&gt;<span>getBaseTypeAndSizeOfSIMDType</span>(fieldInfo.<span>fldTypeHnd</span>, &amp;simdSize);</td>
      </tr>
      <tr>
        <td id="L1981" data-line-number="1981"></td>
        <td id="LC1981">        <span>if</span> ((simdSize &gt;= compiler-&gt;<span>minSIMDStructBytes</span>()) &amp;&amp; (simdSize &lt;= compiler-&gt;<span>maxSIMDStructBytes</span>()))</td>
      </tr>
      <tr>
        <td id="L1982" data-line-number="1982"></td>
        <td id="LC1982">        {</td>
      </tr>
      <tr>
        <td id="L1983" data-line-number="1983"></td>
        <td id="LC1983">            <span><span>//</span> We will only promote fields of SIMD types that fit into a SIMD register.</span></td>
      </tr>
      <tr>
        <td id="L1984" data-line-number="1984"></td>
        <td id="LC1984">            <span>if</span> (simdBaseType != TYP_UNKNOWN)</td>
      </tr>
      <tr>
        <td id="L1985" data-line-number="1985"></td>
        <td id="LC1985">            {</td>
      </tr>
      <tr>
        <td id="L1986" data-line-number="1986"></td>
        <td id="LC1986">                fieldInfo.<span>fldType</span> = compiler-&gt;<span>getSIMDTypeForSize</span>(simdSize);</td>
      </tr>
      <tr>
        <td id="L1987" data-line-number="1987"></td>
        <td id="LC1987">                fieldInfo.<span>fldSize</span> = simdSize;</td>
      </tr>
      <tr>
        <td id="L1988" data-line-number="1988"></td>
        <td id="LC1988">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L1989" data-line-number="1989"></td>
        <td id="LC1989">                retypedFieldsMap.<span>Set</span>(fieldInfo.<span>fldHnd</span>, fieldInfo.<span>fldType</span>, RetypedAsScalarFieldsMap::Overwrite);</td>
      </tr>
      <tr>
        <td id="L1990" data-line-number="1990"></td>
        <td id="LC1990">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L1991" data-line-number="1991"></td>
        <td id="LC1991">            }</td>
      </tr>
      <tr>
        <td id="L1992" data-line-number="1992"></td>
        <td id="LC1992">        }</td>
      </tr>
      <tr>
        <td id="L1993" data-line-number="1993"></td>
        <td id="LC1993">    }</td>
      </tr>
      <tr>
        <td id="L1994" data-line-number="1994"></td>
        <td id="LC1994">#<span>endif</span> <span><span>//</span> FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L1995" data-line-number="1995"></td>
        <td id="LC1995">
</td>
      </tr>
      <tr>
        <td id="L1996" data-line-number="1996"></td>
        <td id="LC1996">    <span>if</span> (fieldInfo.<span>fldSize</span> == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L1997" data-line-number="1997"></td>
        <td id="LC1997">    {</td>
      </tr>
      <tr>
        <td id="L1998" data-line-number="1998"></td>
        <td id="LC1998">        <span>TryPromoteStructField</span>(fieldInfo);</td>
      </tr>
      <tr>
        <td id="L1999" data-line-number="1999"></td>
        <td id="LC1999">    }</td>
      </tr>
      <tr>
        <td id="L2000" data-line-number="2000"></td>
        <td id="LC2000">
</td>
      </tr>
      <tr>
        <td id="L2001" data-line-number="2001"></td>
        <td id="LC2001">    <span>return</span> fieldInfo;</td>
      </tr>
      <tr>
        <td id="L2002" data-line-number="2002"></td>
        <td id="LC2002">}</td>
      </tr>
      <tr>
        <td id="L2003" data-line-number="2003"></td>
        <td id="LC2003">
</td>
      </tr>
      <tr>
        <td id="L2004" data-line-number="2004"></td>
        <td id="LC2004"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2005" data-line-number="2005"></td>
        <td id="LC2005"><span><span>//</span> TryPromoteStructField - checks that this struct's field is a struct that can be promoted as scalar type</span></td>
      </tr>
      <tr>
        <td id="L2006" data-line-number="2006"></td>
        <td id="LC2006"><span><span>//</span>   aligned at its natural boundary. Promotes the field as a scalar if the check succeeded.</span></td>
      </tr>
      <tr>
        <td id="L2007" data-line-number="2007"></td>
        <td id="LC2007"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2008" data-line-number="2008"></td>
        <td id="LC2008"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2009" data-line-number="2009"></td>
        <td id="LC2009"><span><span>//</span>   fieldInfo - information about the field in the outer struct.</span></td>
      </tr>
      <tr>
        <td id="L2010" data-line-number="2010"></td>
        <td id="LC2010"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2011" data-line-number="2011"></td>
        <td id="LC2011"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L2012" data-line-number="2012"></td>
        <td id="LC2012"><span><span>//</span>   true if the internal struct was promoted.</span></td>
      </tr>
      <tr>
        <td id="L2013" data-line-number="2013"></td>
        <td id="LC2013"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2014" data-line-number="2014"></td>
        <td id="LC2014"><span>bool</span> <span>Compiler::StructPromotionHelper::TryPromoteStructField</span>(lvaStructFieldInfo&amp; fieldInfo)</td>
      </tr>
      <tr>
        <td id="L2015" data-line-number="2015"></td>
        <td id="LC2015">{</td>
      </tr>
      <tr>
        <td id="L2016" data-line-number="2016"></td>
        <td id="LC2016">    <span><span>//</span> Size of TYP_BLK, TYP_FUNC, TYP_VOID and TYP_STRUCT is zero.</span></td>
      </tr>
      <tr>
        <td id="L2017" data-line-number="2017"></td>
        <td id="LC2017">    <span><span>//</span> Early out if field type is other than TYP_STRUCT.</span></td>
      </tr>
      <tr>
        <td id="L2018" data-line-number="2018"></td>
        <td id="LC2018">    <span><span>//</span> This is a defensive check as we don't expect a struct to have</span></td>
      </tr>
      <tr>
        <td id="L2019" data-line-number="2019"></td>
        <td id="LC2019">    <span><span>//</span> fields of TYP_BLK, TYP_FUNC or TYP_VOID.</span></td>
      </tr>
      <tr>
        <td id="L2020" data-line-number="2020"></td>
        <td id="LC2020">    <span>if</span> (fieldInfo.<span>fldType</span> != TYP_STRUCT)</td>
      </tr>
      <tr>
        <td id="L2021" data-line-number="2021"></td>
        <td id="LC2021">    {</td>
      </tr>
      <tr>
        <td id="L2022" data-line-number="2022"></td>
        <td id="LC2022">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2023" data-line-number="2023"></td>
        <td id="LC2023">    }</td>
      </tr>
      <tr>
        <td id="L2024" data-line-number="2024"></td>
        <td id="LC2024">
</td>
      </tr>
      <tr>
        <td id="L2025" data-line-number="2025"></td>
        <td id="LC2025">    COMP_HANDLE compHandle = compiler-&gt;<span>info</span>.<span>compCompHnd</span>;</td>
      </tr>
      <tr>
        <td id="L2026" data-line-number="2026"></td>
        <td id="LC2026">
</td>
      </tr>
      <tr>
        <td id="L2027" data-line-number="2027"></td>
        <td id="LC2027">    <span><span>//</span> Do not promote if the struct field in turn has more than one field.</span></td>
      </tr>
      <tr>
        <td id="L2028" data-line-number="2028"></td>
        <td id="LC2028">    <span>if</span> (compHandle-&gt;<span>getClassNumInstanceFields</span>(fieldInfo.<span>fldTypeHnd</span>) != <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L2029" data-line-number="2029"></td>
        <td id="LC2029">    {</td>
      </tr>
      <tr>
        <td id="L2030" data-line-number="2030"></td>
        <td id="LC2030">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2031" data-line-number="2031"></td>
        <td id="LC2031">    }</td>
      </tr>
      <tr>
        <td id="L2032" data-line-number="2032"></td>
        <td id="LC2032">
</td>
      </tr>
      <tr>
        <td id="L2033" data-line-number="2033"></td>
        <td id="LC2033">    <span><span>//</span> Do not promote if the single field is not aligned at its natural boundary within</span></td>
      </tr>
      <tr>
        <td id="L2034" data-line-number="2034"></td>
        <td id="LC2034">    <span><span>//</span> the struct field.</span></td>
      </tr>
      <tr>
        <td id="L2035" data-line-number="2035"></td>
        <td id="LC2035">    CORINFO_FIELD_HANDLE innerFieldHndl   = compHandle-&gt;<span>getFieldInClass</span>(fieldInfo.<span>fldTypeHnd</span>, <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L2036" data-line-number="2036"></td>
        <td id="LC2036">    <span>unsigned</span>             innerFieldOffset = compHandle-&gt;<span>getFieldOffset</span>(innerFieldHndl);</td>
      </tr>
      <tr>
        <td id="L2037" data-line-number="2037"></td>
        <td id="LC2037">    <span>if</span> (innerFieldOffset != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L2038" data-line-number="2038"></td>
        <td id="LC2038">    {</td>
      </tr>
      <tr>
        <td id="L2039" data-line-number="2039"></td>
        <td id="LC2039">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2040" data-line-number="2040"></td>
        <td id="LC2040">    }</td>
      </tr>
      <tr>
        <td id="L2041" data-line-number="2041"></td>
        <td id="LC2041">
</td>
      </tr>
      <tr>
        <td id="L2042" data-line-number="2042"></td>
        <td id="LC2042">    CorInfoType fieldCorType = compHandle-&gt;<span>getFieldType</span>(innerFieldHndl);</td>
      </tr>
      <tr>
        <td id="L2043" data-line-number="2043"></td>
        <td id="LC2043">    var_types   fieldVarType = <span>JITtype2varType</span>(fieldCorType);</td>
      </tr>
      <tr>
        <td id="L2044" data-line-number="2044"></td>
        <td id="LC2044">    <span>unsigned</span>    fieldSize    = <span>genTypeSize</span>(fieldVarType);</td>
      </tr>
      <tr>
        <td id="L2045" data-line-number="2045"></td>
        <td id="LC2045">
</td>
      </tr>
      <tr>
        <td id="L2046" data-line-number="2046"></td>
        <td id="LC2046">    <span><span>//</span> Do not promote if the field is not a primitive type, is floating-point,</span></td>
      </tr>
      <tr>
        <td id="L2047" data-line-number="2047"></td>
        <td id="LC2047">    <span><span>//</span> or is not properly aligned.</span></td>
      </tr>
      <tr>
        <td id="L2048" data-line-number="2048"></td>
        <td id="LC2048">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2049" data-line-number="2049"></td>
        <td id="LC2049">    <span><span>//</span> TODO-PERF: Structs containing a single floating-point field on Amd64</span></td>
      </tr>
      <tr>
        <td id="L2050" data-line-number="2050"></td>
        <td id="LC2050">    <span><span>//</span> need to be passed in integer registers. Right now LSRA doesn't support</span></td>
      </tr>
      <tr>
        <td id="L2051" data-line-number="2051"></td>
        <td id="LC2051">    <span><span>//</span> passing of floating-point LCL_VARS in integer registers.  Enabling promotion</span></td>
      </tr>
      <tr>
        <td id="L2052" data-line-number="2052"></td>
        <td id="LC2052">    <span><span>//</span> of such structs results in an assert in lsra right now.</span></td>
      </tr>
      <tr>
        <td id="L2053" data-line-number="2053"></td>
        <td id="LC2053">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2054" data-line-number="2054"></td>
        <td id="LC2054">    <span><span>//</span> TODO-CQ: Right now we only promote an actual SIMD typed field, which would cause</span></td>
      </tr>
      <tr>
        <td id="L2055" data-line-number="2055"></td>
        <td id="LC2055">    <span><span>//</span> a nested SIMD type to fail promotion.</span></td>
      </tr>
      <tr>
        <td id="L2056" data-line-number="2056"></td>
        <td id="LC2056">    <span>if</span> (fieldSize == <span>0</span> || fieldSize &gt; TARGET_POINTER_SIZE || <span>varTypeIsFloating</span>(fieldVarType))</td>
      </tr>
      <tr>
        <td id="L2057" data-line-number="2057"></td>
        <td id="LC2057">    {</td>
      </tr>
      <tr>
        <td id="L2058" data-line-number="2058"></td>
        <td id="LC2058">        <span>JITDUMP</span>(<span><span>"</span>Promotion blocked: struct contains struct field with one field,<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L2059" data-line-number="2059"></td>
        <td id="LC2059">                <span><span>"</span> but that field has invalid size or type.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2060" data-line-number="2060"></td>
        <td id="LC2060">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2061" data-line-number="2061"></td>
        <td id="LC2061">    }</td>
      </tr>
      <tr>
        <td id="L2062" data-line-number="2062"></td>
        <td id="LC2062">
</td>
      </tr>
      <tr>
        <td id="L2063" data-line-number="2063"></td>
        <td id="LC2063">    <span>if</span> (fieldSize != TARGET_POINTER_SIZE)</td>
      </tr>
      <tr>
        <td id="L2064" data-line-number="2064"></td>
        <td id="LC2064">    {</td>
      </tr>
      <tr>
        <td id="L2065" data-line-number="2065"></td>
        <td id="LC2065">        <span>unsigned</span> outerFieldOffset = compHandle-&gt;<span>getFieldOffset</span>(fieldInfo.<span>fldHnd</span>);</td>
      </tr>
      <tr>
        <td id="L2066" data-line-number="2066"></td>
        <td id="LC2066">
</td>
      </tr>
      <tr>
        <td id="L2067" data-line-number="2067"></td>
        <td id="LC2067">        <span>if</span> ((outerFieldOffset % fieldSize) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L2068" data-line-number="2068"></td>
        <td id="LC2068">        {</td>
      </tr>
      <tr>
        <td id="L2069" data-line-number="2069"></td>
        <td id="LC2069">            <span>JITDUMP</span>(<span><span>"</span>Promotion blocked: struct contains struct field with one field,<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L2070" data-line-number="2070"></td>
        <td id="LC2070">                    <span><span>"</span> but the outer struct offset %u is not a multiple of the inner field size %u.<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L2071" data-line-number="2071"></td>
        <td id="LC2071">                    outerFieldOffset, fieldSize);</td>
      </tr>
      <tr>
        <td id="L2072" data-line-number="2072"></td>
        <td id="LC2072">            <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2073" data-line-number="2073"></td>
        <td id="LC2073">        }</td>
      </tr>
      <tr>
        <td id="L2074" data-line-number="2074"></td>
        <td id="LC2074">    }</td>
      </tr>
      <tr>
        <td id="L2075" data-line-number="2075"></td>
        <td id="LC2075">
</td>
      </tr>
      <tr>
        <td id="L2076" data-line-number="2076"></td>
        <td id="LC2076">    <span><span>//</span> Insist this wrapped field occupy all of its parent storage.</span></td>
      </tr>
      <tr>
        <td id="L2077" data-line-number="2077"></td>
        <td id="LC2077">    <span>unsigned</span> innerStructSize = compHandle-&gt;<span>getClassSize</span>(fieldInfo.<span>fldTypeHnd</span>);</td>
      </tr>
      <tr>
        <td id="L2078" data-line-number="2078"></td>
        <td id="LC2078">
</td>
      </tr>
      <tr>
        <td id="L2079" data-line-number="2079"></td>
        <td id="LC2079">    <span>if</span> (fieldSize != innerStructSize)</td>
      </tr>
      <tr>
        <td id="L2080" data-line-number="2080"></td>
        <td id="LC2080">    {</td>
      </tr>
      <tr>
        <td id="L2081" data-line-number="2081"></td>
        <td id="LC2081">        <span>JITDUMP</span>(<span><span>"</span>Promotion blocked: struct contains struct field with one field,<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L2082" data-line-number="2082"></td>
        <td id="LC2082">                <span><span>"</span> but that field is not the same size as its parent.<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2083" data-line-number="2083"></td>
        <td id="LC2083">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2084" data-line-number="2084"></td>
        <td id="LC2084">    }</td>
      </tr>
      <tr>
        <td id="L2085" data-line-number="2085"></td>
        <td id="LC2085">
</td>
      </tr>
      <tr>
        <td id="L2086" data-line-number="2086"></td>
        <td id="LC2086">    <span><span>//</span> Retype the field as the type of the single field of the struct.</span></td>
      </tr>
      <tr>
        <td id="L2087" data-line-number="2087"></td>
        <td id="LC2087">    <span><span>//</span> This is a hack that allows us to promote such fields before we support recursive struct promotion</span></td>
      </tr>
      <tr>
        <td id="L2088" data-line-number="2088"></td>
        <td id="LC2088">    <span><span>//</span> (tracked by #10019).</span></td>
      </tr>
      <tr>
        <td id="L2089" data-line-number="2089"></td>
        <td id="LC2089">    fieldInfo.<span>fldType</span> = fieldVarType;</td>
      </tr>
      <tr>
        <td id="L2090" data-line-number="2090"></td>
        <td id="LC2090">    fieldInfo.<span>fldSize</span> = fieldSize;</td>
      </tr>
      <tr>
        <td id="L2091" data-line-number="2091"></td>
        <td id="LC2091">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2092" data-line-number="2092"></td>
        <td id="LC2092">    retypedFieldsMap.<span>Set</span>(fieldInfo.<span>fldHnd</span>, fieldInfo.<span>fldType</span>, RetypedAsScalarFieldsMap::Overwrite);</td>
      </tr>
      <tr>
        <td id="L2093" data-line-number="2093"></td>
        <td id="LC2093">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L2094" data-line-number="2094"></td>
        <td id="LC2094">    <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2095" data-line-number="2095"></td>
        <td id="LC2095">}</td>
      </tr>
      <tr>
        <td id="L2096" data-line-number="2096"></td>
        <td id="LC2096">
</td>
      </tr>
      <tr>
        <td id="L2097" data-line-number="2097"></td>
        <td id="LC2097"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2098" data-line-number="2098"></td>
        <td id="LC2098"><span><span>//</span> PromoteStructVar - promote struct variable.</span></td>
      </tr>
      <tr>
        <td id="L2099" data-line-number="2099"></td>
        <td id="LC2099"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2100" data-line-number="2100"></td>
        <td id="LC2100"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2101" data-line-number="2101"></td>
        <td id="LC2101"><span><span>//</span>   lclNum - struct local number;</span></td>
      </tr>
      <tr>
        <td id="L2102" data-line-number="2102"></td>
        <td id="LC2102"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2103" data-line-number="2103"></td>
        <td id="LC2103"><span>void</span> <span>Compiler::StructPromotionHelper::PromoteStructVar</span>(<span>unsigned</span> lclNum)</td>
      </tr>
      <tr>
        <td id="L2104" data-line-number="2104"></td>
        <td id="LC2104">{</td>
      </tr>
      <tr>
        <td id="L2105" data-line-number="2105"></td>
        <td id="LC2105">    LclVarDsc* varDsc = &amp;compiler-&gt;<span>lvaTable</span>[lclNum];</td>
      </tr>
      <tr>
        <td id="L2106" data-line-number="2106"></td>
        <td id="LC2106">
</td>
      </tr>
      <tr>
        <td id="L2107" data-line-number="2107"></td>
        <td id="LC2107">    <span><span>//</span> We should never see a reg-sized non-field-addressed struct here.</span></td>
      </tr>
      <tr>
        <td id="L2108" data-line-number="2108"></td>
        <td id="LC2108">    <span>assert</span>(!varDsc-&gt;<span>lvRegStruct</span>);</td>
      </tr>
      <tr>
        <td id="L2109" data-line-number="2109"></td>
        <td id="LC2109">
</td>
      </tr>
      <tr>
        <td id="L2110" data-line-number="2110"></td>
        <td id="LC2110">    <span>assert</span>(varDsc-&gt;<span>lvVerTypeInfo</span>.<span>GetClassHandle</span>() == structPromotionInfo.<span>typeHnd</span>);</td>
      </tr>
      <tr>
        <td id="L2111" data-line-number="2111"></td>
        <td id="LC2111">    <span>assert</span>(structPromotionInfo.<span>canPromote</span>);</td>
      </tr>
      <tr>
        <td id="L2112" data-line-number="2112"></td>
        <td id="LC2112">
</td>
      </tr>
      <tr>
        <td id="L2113" data-line-number="2113"></td>
        <td id="LC2113">    varDsc-&gt;<span>lvFieldCnt</span>      = structPromotionInfo.<span>fieldCnt</span>;</td>
      </tr>
      <tr>
        <td id="L2114" data-line-number="2114"></td>
        <td id="LC2114">    varDsc-&gt;<span>lvFieldLclStart</span> = compiler-&gt;<span>lvaCount</span>;</td>
      </tr>
      <tr>
        <td id="L2115" data-line-number="2115"></td>
        <td id="LC2115">    varDsc-&gt;<span>lvPromoted</span>      = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2116" data-line-number="2116"></td>
        <td id="LC2116">    varDsc-&gt;<span>lvContainsHoles</span> = structPromotionInfo.<span>containsHoles</span>;</td>
      </tr>
      <tr>
        <td id="L2117" data-line-number="2117"></td>
        <td id="LC2117">    varDsc-&gt;<span>lvCustomLayout</span>  = structPromotionInfo.<span>customLayout</span>;</td>
      </tr>
      <tr>
        <td id="L2118" data-line-number="2118"></td>
        <td id="LC2118">
</td>
      </tr>
      <tr>
        <td id="L2119" data-line-number="2119"></td>
        <td id="LC2119">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2120" data-line-number="2120"></td>
        <td id="LC2120">    <span><span>//</span> Don't change the source to a TYP_BLK either.</span></td>
      </tr>
      <tr>
        <td id="L2121" data-line-number="2121"></td>
        <td id="LC2121">    varDsc-&gt;<span>lvKeepType</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2122" data-line-number="2122"></td>
        <td id="LC2122">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2123" data-line-number="2123"></td>
        <td id="LC2123">
</td>
      </tr>
      <tr>
        <td id="L2124" data-line-number="2124"></td>
        <td id="LC2124">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2125" data-line-number="2125"></td>
        <td id="LC2125">    <span>if</span> (compiler-&gt;<span>verbose</span>)</td>
      </tr>
      <tr>
        <td id="L2126" data-line-number="2126"></td>
        <td id="LC2126">    {</td>
      </tr>
      <tr>
        <td id="L2127" data-line-number="2127"></td>
        <td id="LC2127">        <span>printf</span>(<span><span>"</span><span>\n</span>Promoting struct local V%02u (%s):<span>"</span></span>, lclNum,</td>
      </tr>
      <tr>
        <td id="L2128" data-line-number="2128"></td>
        <td id="LC2128">               compiler-&gt;<span>eeGetClassName</span>(varDsc-&gt;<span>lvVerTypeInfo</span>.<span>GetClassHandle</span>()));</td>
      </tr>
      <tr>
        <td id="L2129" data-line-number="2129"></td>
        <td id="LC2129">    }</td>
      </tr>
      <tr>
        <td id="L2130" data-line-number="2130"></td>
        <td id="LC2130">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2131" data-line-number="2131"></td>
        <td id="LC2131">
</td>
      </tr>
      <tr>
        <td id="L2132" data-line-number="2132"></td>
        <td id="LC2132">    <span>if</span> (!structPromotionInfo.<span>fieldsSorted</span>)</td>
      </tr>
      <tr>
        <td id="L2133" data-line-number="2133"></td>
        <td id="LC2133">    {</td>
      </tr>
      <tr>
        <td id="L2134" data-line-number="2134"></td>
        <td id="LC2134">        <span>SortStructFields</span>();</td>
      </tr>
      <tr>
        <td id="L2135" data-line-number="2135"></td>
        <td id="LC2135">    }</td>
      </tr>
      <tr>
        <td id="L2136" data-line-number="2136"></td>
        <td id="LC2136">
</td>
      </tr>
      <tr>
        <td id="L2137" data-line-number="2137"></td>
        <td id="LC2137">    <span>for</span> (<span>unsigned</span> <span>index</span> = <span>0</span>; <span>index</span> &lt; structPromotionInfo.<span>fieldCnt</span>; ++<span>index</span>)</td>
      </tr>
      <tr>
        <td id="L2138" data-line-number="2138"></td>
        <td id="LC2138">    {</td>
      </tr>
      <tr>
        <td id="L2139" data-line-number="2139"></td>
        <td id="LC2139">        <span>const</span> lvaStructFieldInfo* pFieldInfo = &amp;structPromotionInfo.<span>fields</span>[<span>index</span>];</td>
      </tr>
      <tr>
        <td id="L2140" data-line-number="2140"></td>
        <td id="LC2140">
</td>
      </tr>
      <tr>
        <td id="L2141" data-line-number="2141"></td>
        <td id="LC2141">        <span>if</span> (<span>varTypeIsFloating</span>(pFieldInfo-&gt;<span>fldType</span>) || <span>varTypeIsSIMD</span>(pFieldInfo-&gt;<span>fldType</span>))</td>
      </tr>
      <tr>
        <td id="L2142" data-line-number="2142"></td>
        <td id="LC2142">        {</td>
      </tr>
      <tr>
        <td id="L2143" data-line-number="2143"></td>
        <td id="LC2143">            <span><span>//</span> Whenever we promote a struct that contains a floating point field</span></td>
      </tr>
      <tr>
        <td id="L2144" data-line-number="2144"></td>
        <td id="LC2144">            <span><span>//</span> it's possible we transition from a method that originally only had integer</span></td>
      </tr>
      <tr>
        <td id="L2145" data-line-number="2145"></td>
        <td id="LC2145">            <span><span>//</span> local vars to start having FP.  We have to communicate this through this flag</span></td>
      </tr>
      <tr>
        <td id="L2146" data-line-number="2146"></td>
        <td id="LC2146">            <span><span>//</span> since LSRA later on will use this flag to determine whether or not to track FP register sets.</span></td>
      </tr>
      <tr>
        <td id="L2147" data-line-number="2147"></td>
        <td id="LC2147">            compiler-&gt;<span>compFloatingPointUsed</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2148" data-line-number="2148"></td>
        <td id="LC2148">        }</td>
      </tr>
      <tr>
        <td id="L2149" data-line-number="2149"></td>
        <td id="LC2149">
</td>
      </tr>
      <tr>
        <td id="L2150" data-line-number="2150"></td>
        <td id="LC2150"><span><span>//</span> Now grab the temp for the field local.</span></td>
      </tr>
      <tr>
        <td id="L2151" data-line-number="2151"></td>
        <td id="LC2151">
</td>
      </tr>
      <tr>
        <td id="L2152" data-line-number="2152"></td>
        <td id="LC2152">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2153" data-line-number="2153"></td>
        <td id="LC2153">        <span>char</span> buf[<span>200</span>];</td>
      </tr>
      <tr>
        <td id="L2154" data-line-number="2154"></td>
        <td id="LC2154">        <span>sprintf_s</span>(buf, <span>sizeof</span>(buf), <span><span>"</span>%s V%02u.%s (fldOffset=0x%x)<span>"</span></span>, <span><span>"</span>field<span>"</span></span>, lclNum,</td>
      </tr>
      <tr>
        <td id="L2155" data-line-number="2155"></td>
        <td id="LC2155">                  compiler-&gt;<span>eeGetFieldName</span>(pFieldInfo-&gt;<span>fldHnd</span>), pFieldInfo-&gt;<span>fldOffset</span>);</td>
      </tr>
      <tr>
        <td id="L2156" data-line-number="2156"></td>
        <td id="LC2156">
</td>
      </tr>
      <tr>
        <td id="L2157" data-line-number="2157"></td>
        <td id="LC2157">        <span><span>//</span> We need to copy 'buf' as lvaGrabTemp() below caches a copy to its argument.</span></td>
      </tr>
      <tr>
        <td id="L2158" data-line-number="2158"></td>
        <td id="LC2158">        <span>size_t</span> len  = <span>strlen</span>(buf) + <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2159" data-line-number="2159"></td>
        <td id="LC2159">        <span>char</span>*  bufp = compiler-&gt;<span>getAllocator</span>(CMK_DebugOnly).<span>allocate</span>&lt;<span>char</span>&gt;(len);</td>
      </tr>
      <tr>
        <td id="L2160" data-line-number="2160"></td>
        <td id="LC2160">        <span>strcpy_s</span>(bufp, len, buf);</td>
      </tr>
      <tr>
        <td id="L2161" data-line-number="2161"></td>
        <td id="LC2161">
</td>
      </tr>
      <tr>
        <td id="L2162" data-line-number="2162"></td>
        <td id="LC2162">        <span>if</span> (<span>index</span> &gt; <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L2163" data-line-number="2163"></td>
        <td id="LC2163">        {</td>
      </tr>
      <tr>
        <td id="L2164" data-line-number="2164"></td>
        <td id="LC2164">            <span>noway_assert</span>(pFieldInfo-&gt;<span>fldOffset</span> &gt; (pFieldInfo - <span>1</span>)-&gt;<span>fldOffset</span>);</td>
      </tr>
      <tr>
        <td id="L2165" data-line-number="2165"></td>
        <td id="LC2165">        }</td>
      </tr>
      <tr>
        <td id="L2166" data-line-number="2166"></td>
        <td id="LC2166">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2167" data-line-number="2167"></td>
        <td id="LC2167">
</td>
      </tr>
      <tr>
        <td id="L2168" data-line-number="2168"></td>
        <td id="LC2168">        <span><span>//</span> Lifetime of field locals might span multiple BBs, so they must be long lifetime temps.</span></td>
      </tr>
      <tr>
        <td id="L2169" data-line-number="2169"></td>
        <td id="LC2169">        <span>unsigned</span> varNum = compiler-&gt;<span>lvaGrabTemp</span>(<span>false</span> <span>DEBUGARG</span>(bufp));</td>
      </tr>
      <tr>
        <td id="L2170" data-line-number="2170"></td>
        <td id="LC2170">
</td>
      </tr>
      <tr>
        <td id="L2171" data-line-number="2171"></td>
        <td id="LC2171">        varDsc = &amp;compiler-&gt;<span>lvaTable</span>[lclNum]; <span><span>//</span> lvaGrabTemp can reallocate the lvaTable</span></td>
      </tr>
      <tr>
        <td id="L2172" data-line-number="2172"></td>
        <td id="LC2172">
</td>
      </tr>
      <tr>
        <td id="L2173" data-line-number="2173"></td>
        <td id="LC2173">        LclVarDsc* fieldVarDsc       = &amp;compiler-&gt;<span>lvaTable</span>[varNum];</td>
      </tr>
      <tr>
        <td id="L2174" data-line-number="2174"></td>
        <td id="LC2174">        fieldVarDsc-&gt;<span>lvType</span>          = pFieldInfo-&gt;<span>fldType</span>;</td>
      </tr>
      <tr>
        <td id="L2175" data-line-number="2175"></td>
        <td id="LC2175">        fieldVarDsc-&gt;<span>lvExactSize</span>     = pFieldInfo-&gt;<span>fldSize</span>;</td>
      </tr>
      <tr>
        <td id="L2176" data-line-number="2176"></td>
        <td id="LC2176">        fieldVarDsc-&gt;<span>lvIsStructField</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2177" data-line-number="2177"></td>
        <td id="LC2177">        fieldVarDsc-&gt;<span>lvFieldHnd</span>      = pFieldInfo-&gt;<span>fldHnd</span>;</td>
      </tr>
      <tr>
        <td id="L2178" data-line-number="2178"></td>
        <td id="LC2178">        fieldVarDsc-&gt;<span>lvFldOffset</span>     = pFieldInfo-&gt;<span>fldOffset</span>;</td>
      </tr>
      <tr>
        <td id="L2179" data-line-number="2179"></td>
        <td id="LC2179">        fieldVarDsc-&gt;<span>lvFldOrdinal</span>    = pFieldInfo-&gt;<span>fldOrdinal</span>;</td>
      </tr>
      <tr>
        <td id="L2180" data-line-number="2180"></td>
        <td id="LC2180">        fieldVarDsc-&gt;<span>lvParentLcl</span>     = lclNum;</td>
      </tr>
      <tr>
        <td id="L2181" data-line-number="2181"></td>
        <td id="LC2181">        fieldVarDsc-&gt;<span>lvIsParam</span>       = varDsc-&gt;<span>lvIsParam</span>;</td>
      </tr>
      <tr>
        <td id="L2182" data-line-number="2182"></td>
        <td id="LC2182">#<span>if</span> defined(TARGET_AMD64) || defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L2183" data-line-number="2183"></td>
        <td id="LC2183">
</td>
      </tr>
      <tr>
        <td id="L2184" data-line-number="2184"></td>
        <td id="LC2184">        <span><span>//</span> Reset the implicitByRef flag.</span></td>
      </tr>
      <tr>
        <td id="L2185" data-line-number="2185"></td>
        <td id="LC2185">        fieldVarDsc-&gt;<span>lvIsImplicitByRef</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2186" data-line-number="2186"></td>
        <td id="LC2186">
</td>
      </tr>
      <tr>
        <td id="L2187" data-line-number="2187"></td>
        <td id="LC2187">        <span><span>//</span> Do we have a parameter that can be enregistered?</span></td>
      </tr>
      <tr>
        <td id="L2188" data-line-number="2188"></td>
        <td id="LC2188">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2189" data-line-number="2189"></td>
        <td id="LC2189">        <span>if</span> (varDsc-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L2190" data-line-number="2190"></td>
        <td id="LC2190">        {</td>
      </tr>
      <tr>
        <td id="L2191" data-line-number="2191"></td>
        <td id="LC2191">            fieldVarDsc-&gt;<span>lvIsRegArg</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2192" data-line-number="2192"></td>
        <td id="LC2192">            fieldVarDsc-&gt;<span>SetArgReg</span>(varDsc-&gt;<span>GetArgReg</span>());</td>
      </tr>
      <tr>
        <td id="L2193" data-line-number="2193"></td>
        <td id="LC2193">#<span>if</span> FEATURE_MULTIREG_ARGS &amp;&amp; defined(FEATURE_SIMD)</td>
      </tr>
      <tr>
        <td id="L2194" data-line-number="2194"></td>
        <td id="LC2194">            <span>if</span> (<span>varTypeIsSIMD</span>(fieldVarDsc) &amp;&amp; !compiler-&gt;<span>lvaIsImplicitByRefLocal</span>(lclNum))</td>
      </tr>
      <tr>
        <td id="L2195" data-line-number="2195"></td>
        <td id="LC2195">            {</td>
      </tr>
      <tr>
        <td id="L2196" data-line-number="2196"></td>
        <td id="LC2196">                <span><span>//</span> This field is a SIMD type, and will be considered to be passed in multiple registers</span></td>
      </tr>
      <tr>
        <td id="L2197" data-line-number="2197"></td>
        <td id="LC2197">                <span><span>//</span> if the parent struct was. Note that this code relies on the fact that if there is</span></td>
      </tr>
      <tr>
        <td id="L2198" data-line-number="2198"></td>
        <td id="LC2198">                <span><span>//</span> a SIMD field of an enregisterable struct, it is the only field.</span></td>
      </tr>
      <tr>
        <td id="L2199" data-line-number="2199"></td>
        <td id="LC2199">                <span><span>//</span> We will assert that, in case future changes are made to the ABI.</span></td>
      </tr>
      <tr>
        <td id="L2200" data-line-number="2200"></td>
        <td id="LC2200">                <span>assert</span>(varDsc-&gt;<span>lvFieldCnt</span> == <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L2201" data-line-number="2201"></td>
        <td id="LC2201">                fieldVarDsc-&gt;<span>SetOtherArgReg</span>(varDsc-&gt;<span>GetOtherArgReg</span>());</td>
      </tr>
      <tr>
        <td id="L2202" data-line-number="2202"></td>
        <td id="LC2202">            }</td>
      </tr>
      <tr>
        <td id="L2203" data-line-number="2203"></td>
        <td id="LC2203">#<span>endif</span> <span><span>//</span> FEATURE_MULTIREG_ARGS &amp;&amp; defined(FEATURE_SIMD)</span></td>
      </tr>
      <tr>
        <td id="L2204" data-line-number="2204"></td>
        <td id="LC2204">        }</td>
      </tr>
      <tr>
        <td id="L2205" data-line-number="2205"></td>
        <td id="LC2205">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2206" data-line-number="2206"></td>
        <td id="LC2206">
</td>
      </tr>
      <tr>
        <td id="L2207" data-line-number="2207"></td>
        <td id="LC2207">#<span>ifdef</span> FEATURE_SIMD</td>
      </tr>
      <tr>
        <td id="L2208" data-line-number="2208"></td>
        <td id="LC2208">        <span>if</span> (<span>varTypeIsSIMD</span>(pFieldInfo-&gt;<span>fldType</span>))</td>
      </tr>
      <tr>
        <td id="L2209" data-line-number="2209"></td>
        <td id="LC2209">        {</td>
      </tr>
      <tr>
        <td id="L2210" data-line-number="2210"></td>
        <td id="LC2210">            <span><span>//</span> Set size to zero so that lvaSetStruct will appropriately set the SIMD-relevant fields.</span></td>
      </tr>
      <tr>
        <td id="L2211" data-line-number="2211"></td>
        <td id="LC2211">            fieldVarDsc-&gt;<span>lvExactSize</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2212" data-line-number="2212"></td>
        <td id="LC2212">            compiler-&gt;<span>lvaSetStruct</span>(varNum, pFieldInfo-&gt;<span>fldTypeHnd</span>, <span>false</span>, <span>true</span>);</td>
      </tr>
      <tr>
        <td id="L2213" data-line-number="2213"></td>
        <td id="LC2213">            <span><span>//</span> We will not recursively promote this, so mark it as 'lvRegStruct' (note that we wouldn't</span></td>
      </tr>
      <tr>
        <td id="L2214" data-line-number="2214"></td>
        <td id="LC2214">            <span><span>//</span> be promoting this if we didn't think it could be enregistered.</span></td>
      </tr>
      <tr>
        <td id="L2215" data-line-number="2215"></td>
        <td id="LC2215">            fieldVarDsc-&gt;<span>lvRegStruct</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2216" data-line-number="2216"></td>
        <td id="LC2216">        }</td>
      </tr>
      <tr>
        <td id="L2217" data-line-number="2217"></td>
        <td id="LC2217">#<span>endif</span> <span><span>//</span> FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L2218" data-line-number="2218"></td>
        <td id="LC2218">
</td>
      </tr>
      <tr>
        <td id="L2219" data-line-number="2219"></td>
        <td id="LC2219">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2220" data-line-number="2220"></td>
        <td id="LC2220">        <span><span>//</span> This temporary should not be converted to a double in stress mode,</span></td>
      </tr>
      <tr>
        <td id="L2221" data-line-number="2221"></td>
        <td id="LC2221">        <span><span>//</span> because we introduce assigns to it after the stress conversion</span></td>
      </tr>
      <tr>
        <td id="L2222" data-line-number="2222"></td>
        <td id="LC2222">        fieldVarDsc-&gt;<span>lvKeepType</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2223" data-line-number="2223"></td>
        <td id="LC2223">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2224" data-line-number="2224"></td>
        <td id="LC2224">    }</td>
      </tr>
      <tr>
        <td id="L2225" data-line-number="2225"></td>
        <td id="LC2225">}</td>
      </tr>
      <tr>
        <td id="L2226" data-line-number="2226"></td>
        <td id="LC2226">
</td>
      </tr>
      <tr>
        <td id="L2227" data-line-number="2227"></td>
        <td id="LC2227">#<span>if</span> !defined(TARGET_64BIT)</td>
      </tr>
      <tr>
        <td id="L2228" data-line-number="2228"></td>
        <td id="LC2228"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2229" data-line-number="2229"></td>
        <td id="LC2229"><span><span>//</span> lvaPromoteLongVars: "Struct promote" all register candidate longs as if they are structs of two ints.</span></td>
      </tr>
      <tr>
        <td id="L2230" data-line-number="2230"></td>
        <td id="LC2230"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2231" data-line-number="2231"></td>
        <td id="LC2231"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2232" data-line-number="2232"></td>
        <td id="LC2232"><span><span>//</span>    None.</span></td>
      </tr>
      <tr>
        <td id="L2233" data-line-number="2233"></td>
        <td id="LC2233"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2234" data-line-number="2234"></td>
        <td id="LC2234"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L2235" data-line-number="2235"></td>
        <td id="LC2235"><span><span>//</span>    None.</span></td>
      </tr>
      <tr>
        <td id="L2236" data-line-number="2236"></td>
        <td id="LC2236"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2237" data-line-number="2237"></td>
        <td id="LC2237"><span>void</span> <span>Compiler::lvaPromoteLongVars</span>()</td>
      </tr>
      <tr>
        <td id="L2238" data-line-number="2238"></td>
        <td id="LC2238">{</td>
      </tr>
      <tr>
        <td id="L2239" data-line-number="2239"></td>
        <td id="LC2239">    <span>if</span> ((opts.<span>compFlags</span> &amp; CLFLG_REGVAR) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L2240" data-line-number="2240"></td>
        <td id="LC2240">    {</td>
      </tr>
      <tr>
        <td id="L2241" data-line-number="2241"></td>
        <td id="LC2241">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L2242" data-line-number="2242"></td>
        <td id="LC2242">    }</td>
      </tr>
      <tr>
        <td id="L2243" data-line-number="2243"></td>
        <td id="LC2243">
</td>
      </tr>
      <tr>
        <td id="L2244" data-line-number="2244"></td>
        <td id="LC2244">    <span><span>//</span> The lvaTable might grow as we grab temps. Make a local copy here.</span></td>
      </tr>
      <tr>
        <td id="L2245" data-line-number="2245"></td>
        <td id="LC2245">    <span>unsigned</span> startLvaCount = lvaCount;</td>
      </tr>
      <tr>
        <td id="L2246" data-line-number="2246"></td>
        <td id="LC2246">    <span>for</span> (<span>unsigned</span> lclNum = <span>0</span>; lclNum &lt; startLvaCount; lclNum++)</td>
      </tr>
      <tr>
        <td id="L2247" data-line-number="2247"></td>
        <td id="LC2247">    {</td>
      </tr>
      <tr>
        <td id="L2248" data-line-number="2248"></td>
        <td id="LC2248">        LclVarDsc* varDsc = &amp;lvaTable[lclNum];</td>
      </tr>
      <tr>
        <td id="L2249" data-line-number="2249"></td>
        <td id="LC2249">        <span>if</span> (!<span>varTypeIsLong</span>(varDsc) || varDsc-&gt;<span>lvDoNotEnregister</span> || varDsc-&gt;<span>lvIsMultiRegArgOrRet</span>() ||</td>
      </tr>
      <tr>
        <td id="L2250" data-line-number="2250"></td>
        <td id="LC2250">            (varDsc-&gt;<span>lvRefCnt</span>() == <span>0</span>) || varDsc-&gt;<span>lvIsStructField</span> || (fgNoStructPromotion &amp;&amp; varDsc-&gt;<span>lvIsParam</span>))</td>
      </tr>
      <tr>
        <td id="L2251" data-line-number="2251"></td>
        <td id="LC2251">        {</td>
      </tr>
      <tr>
        <td id="L2252" data-line-number="2252"></td>
        <td id="LC2252">            <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L2253" data-line-number="2253"></td>
        <td id="LC2253">        }</td>
      </tr>
      <tr>
        <td id="L2254" data-line-number="2254"></td>
        <td id="LC2254">
</td>
      </tr>
      <tr>
        <td id="L2255" data-line-number="2255"></td>
        <td id="LC2255">        varDsc-&gt;<span>lvFieldCnt</span>      = <span>2</span>;</td>
      </tr>
      <tr>
        <td id="L2256" data-line-number="2256"></td>
        <td id="LC2256">        varDsc-&gt;<span>lvFieldLclStart</span> = lvaCount;</td>
      </tr>
      <tr>
        <td id="L2257" data-line-number="2257"></td>
        <td id="LC2257">        varDsc-&gt;<span>lvPromoted</span>      = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2258" data-line-number="2258"></td>
        <td id="LC2258">        varDsc-&gt;<span>lvContainsHoles</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2259" data-line-number="2259"></td>
        <td id="LC2259">
</td>
      </tr>
      <tr>
        <td id="L2260" data-line-number="2260"></td>
        <td id="LC2260">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2261" data-line-number="2261"></td>
        <td id="LC2261">        <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L2262" data-line-number="2262"></td>
        <td id="LC2262">        {</td>
      </tr>
      <tr>
        <td id="L2263" data-line-number="2263"></td>
        <td id="LC2263">            <span>printf</span>(<span><span>"</span><span>\n</span>Promoting long local V%02u:<span>"</span></span>, lclNum);</td>
      </tr>
      <tr>
        <td id="L2264" data-line-number="2264"></td>
        <td id="LC2264">        }</td>
      </tr>
      <tr>
        <td id="L2265" data-line-number="2265"></td>
        <td id="LC2265">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2266" data-line-number="2266"></td>
        <td id="LC2266">
</td>
      </tr>
      <tr>
        <td id="L2267" data-line-number="2267"></td>
        <td id="LC2267">        <span>bool</span> isParam = varDsc-&gt;<span>lvIsParam</span>;</td>
      </tr>
      <tr>
        <td id="L2268" data-line-number="2268"></td>
        <td id="LC2268">
</td>
      </tr>
      <tr>
        <td id="L2269" data-line-number="2269"></td>
        <td id="LC2269">        <span>for</span> (<span>unsigned</span> <span>index</span> = <span>0</span>; <span>index</span> &lt; <span>2</span>; ++<span>index</span>)</td>
      </tr>
      <tr>
        <td id="L2270" data-line-number="2270"></td>
        <td id="LC2270">        {</td>
      </tr>
      <tr>
        <td id="L2271" data-line-number="2271"></td>
        <td id="LC2271">            <span><span>//</span> Grab the temp for the field local.</span></td>
      </tr>
      <tr>
        <td id="L2272" data-line-number="2272"></td>
        <td id="LC2272">            CLANG_FORMAT_COMMENT_ANCHOR;</td>
      </tr>
      <tr>
        <td id="L2273" data-line-number="2273"></td>
        <td id="LC2273">
</td>
      </tr>
      <tr>
        <td id="L2274" data-line-number="2274"></td>
        <td id="LC2274">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2275" data-line-number="2275"></td>
        <td id="LC2275">            <span>char</span> buf[<span>200</span>];</td>
      </tr>
      <tr>
        <td id="L2276" data-line-number="2276"></td>
        <td id="LC2276">            <span>sprintf_s</span>(buf, <span>sizeof</span>(buf), <span><span>"</span>%s V%02u.%s (fldOffset=0x%x)<span>"</span></span>, <span><span>"</span>field<span>"</span></span>, lclNum, <span>index</span> == <span>0</span> ? <span><span>"</span>lo<span>"</span></span> : <span><span>"</span>hi<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L2277" data-line-number="2277"></td>
        <td id="LC2277">                      <span>index</span> * <span>4</span>);</td>
      </tr>
      <tr>
        <td id="L2278" data-line-number="2278"></td>
        <td id="LC2278">
</td>
      </tr>
      <tr>
        <td id="L2279" data-line-number="2279"></td>
        <td id="LC2279">            <span><span>//</span> We need to copy 'buf' as lvaGrabTemp() below caches a copy to its argument.</span></td>
      </tr>
      <tr>
        <td id="L2280" data-line-number="2280"></td>
        <td id="LC2280">            <span>size_t</span> len  = <span>strlen</span>(buf) + <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2281" data-line-number="2281"></td>
        <td id="LC2281">            <span>char</span>*  bufp = <span>getAllocator</span>(CMK_DebugOnly).<span>allocate</span>&lt;<span>char</span>&gt;(len);</td>
      </tr>
      <tr>
        <td id="L2282" data-line-number="2282"></td>
        <td id="LC2282">            <span>strcpy_s</span>(bufp, len, buf);</td>
      </tr>
      <tr>
        <td id="L2283" data-line-number="2283"></td>
        <td id="LC2283">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2284" data-line-number="2284"></td>
        <td id="LC2284">
</td>
      </tr>
      <tr>
        <td id="L2285" data-line-number="2285"></td>
        <td id="LC2285">            <span>unsigned</span> varNum = <span>lvaGrabTemp</span>(<span>false</span> <span>DEBUGARG</span>(bufp)); <span><span>//</span> Lifetime of field locals might span multiple BBs, so</span></td>
      </tr>
      <tr>
        <td id="L2286" data-line-number="2286"></td>
        <td id="LC2286">                                                                 <span><span>//</span> they are long lifetime temps.</span></td>
      </tr>
      <tr>
        <td id="L2287" data-line-number="2287"></td>
        <td id="LC2287">
</td>
      </tr>
      <tr>
        <td id="L2288" data-line-number="2288"></td>
        <td id="LC2288">            LclVarDsc* fieldVarDsc       = &amp;lvaTable[varNum];</td>
      </tr>
      <tr>
        <td id="L2289" data-line-number="2289"></td>
        <td id="LC2289">            fieldVarDsc-&gt;<span>lvType</span>          = TYP_INT;</td>
      </tr>
      <tr>
        <td id="L2290" data-line-number="2290"></td>
        <td id="LC2290">            fieldVarDsc-&gt;<span>lvExactSize</span>     = <span>genTypeSize</span>(TYP_INT);</td>
      </tr>
      <tr>
        <td id="L2291" data-line-number="2291"></td>
        <td id="LC2291">            fieldVarDsc-&gt;<span>lvIsStructField</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2292" data-line-number="2292"></td>
        <td id="LC2292">            fieldVarDsc-&gt;<span>lvFldOffset</span>     = (<span>unsigned</span> <span>char</span>)(<span>index</span> * <span>genTypeSize</span>(TYP_INT));</td>
      </tr>
      <tr>
        <td id="L2293" data-line-number="2293"></td>
        <td id="LC2293">            fieldVarDsc-&gt;<span>lvFldOrdinal</span>    = (<span>unsigned</span> <span>char</span>)<span>index</span>;</td>
      </tr>
      <tr>
        <td id="L2294" data-line-number="2294"></td>
        <td id="LC2294">            fieldVarDsc-&gt;<span>lvParentLcl</span>     = lclNum;</td>
      </tr>
      <tr>
        <td id="L2295" data-line-number="2295"></td>
        <td id="LC2295">            <span><span>//</span> Currently we do not support enregistering incoming promoted aggregates with more than one field.</span></td>
      </tr>
      <tr>
        <td id="L2296" data-line-number="2296"></td>
        <td id="LC2296">            <span>if</span> (isParam)</td>
      </tr>
      <tr>
        <td id="L2297" data-line-number="2297"></td>
        <td id="LC2297">            {</td>
      </tr>
      <tr>
        <td id="L2298" data-line-number="2298"></td>
        <td id="LC2298">                fieldVarDsc-&gt;<span>lvIsParam</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2299" data-line-number="2299"></td>
        <td id="LC2299">                <span>lvaSetVarDoNotEnregister</span>(varNum <span>DEBUGARG</span>(DNER_LongParamField));</td>
      </tr>
      <tr>
        <td id="L2300" data-line-number="2300"></td>
        <td id="LC2300">            }</td>
      </tr>
      <tr>
        <td id="L2301" data-line-number="2301"></td>
        <td id="LC2301">        }</td>
      </tr>
      <tr>
        <td id="L2302" data-line-number="2302"></td>
        <td id="LC2302">    }</td>
      </tr>
      <tr>
        <td id="L2303" data-line-number="2303"></td>
        <td id="LC2303">
</td>
      </tr>
      <tr>
        <td id="L2304" data-line-number="2304"></td>
        <td id="LC2304">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2305" data-line-number="2305"></td>
        <td id="LC2305">    <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L2306" data-line-number="2306"></td>
        <td id="LC2306">    {</td>
      </tr>
      <tr>
        <td id="L2307" data-line-number="2307"></td>
        <td id="LC2307">        <span>printf</span>(<span><span>"</span><span>\n</span>lvaTable after lvaPromoteLongVars<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2308" data-line-number="2308"></td>
        <td id="LC2308">        <span>lvaTableDump</span>();</td>
      </tr>
      <tr>
        <td id="L2309" data-line-number="2309"></td>
        <td id="LC2309">    }</td>
      </tr>
      <tr>
        <td id="L2310" data-line-number="2310"></td>
        <td id="LC2310">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L2311" data-line-number="2311"></td>
        <td id="LC2311">}</td>
      </tr>
      <tr>
        <td id="L2312" data-line-number="2312"></td>
        <td id="LC2312">#<span>endif</span> <span><span>//</span> !defined(TARGET_64BIT)</span></td>
      </tr>
      <tr>
        <td id="L2313" data-line-number="2313"></td>
        <td id="LC2313">
</td>
      </tr>
      <tr>
        <td id="L2314" data-line-number="2314"></td>
        <td id="LC2314"><span><span>//</span>--------------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2315" data-line-number="2315"></td>
        <td id="LC2315"><span><span>//</span> lvaGetFieldLocal - returns the local var index for a promoted field in a promoted struct var.</span></td>
      </tr>
      <tr>
        <td id="L2316" data-line-number="2316"></td>
        <td id="LC2316"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2317" data-line-number="2317"></td>
        <td id="LC2317"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2318" data-line-number="2318"></td>
        <td id="LC2318"><span><span>//</span>   varDsc    - the promoted struct var descriptor;</span></td>
      </tr>
      <tr>
        <td id="L2319" data-line-number="2319"></td>
        <td id="LC2319"><span><span>//</span>   fldOffset - field offset in the struct.</span></td>
      </tr>
      <tr>
        <td id="L2320" data-line-number="2320"></td>
        <td id="LC2320"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2321" data-line-number="2321"></td>
        <td id="LC2321"><span><span>//</span> Return value:</span></td>
      </tr>
      <tr>
        <td id="L2322" data-line-number="2322"></td>
        <td id="LC2322"><span><span>//</span>   the index of the local that represents this field.</span></td>
      </tr>
      <tr>
        <td id="L2323" data-line-number="2323"></td>
        <td id="LC2323"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2324" data-line-number="2324"></td>
        <td id="LC2324"><span>unsigned</span> <span>Compiler::lvaGetFieldLocal</span>(<span>const</span> LclVarDsc* varDsc, <span>unsigned</span> <span>int</span> fldOffset)</td>
      </tr>
      <tr>
        <td id="L2325" data-line-number="2325"></td>
        <td id="LC2325">{</td>
      </tr>
      <tr>
        <td id="L2326" data-line-number="2326"></td>
        <td id="LC2326">    <span>noway_assert</span>(<span>varTypeIsStruct</span>(varDsc));</td>
      </tr>
      <tr>
        <td id="L2327" data-line-number="2327"></td>
        <td id="LC2327">    <span>noway_assert</span>(varDsc-&gt;<span>lvPromoted</span>);</td>
      </tr>
      <tr>
        <td id="L2328" data-line-number="2328"></td>
        <td id="LC2328">
</td>
      </tr>
      <tr>
        <td id="L2329" data-line-number="2329"></td>
        <td id="LC2329">    <span>for</span> (<span>unsigned</span> i = varDsc-&gt;<span>lvFieldLclStart</span>; i &lt; varDsc-&gt;<span>lvFieldLclStart</span> + varDsc-&gt;<span>lvFieldCnt</span>; ++i)</td>
      </tr>
      <tr>
        <td id="L2330" data-line-number="2330"></td>
        <td id="LC2330">    {</td>
      </tr>
      <tr>
        <td id="L2331" data-line-number="2331"></td>
        <td id="LC2331">        <span>noway_assert</span>(lvaTable[i].<span>lvIsStructField</span>);</td>
      </tr>
      <tr>
        <td id="L2332" data-line-number="2332"></td>
        <td id="LC2332">        <span>noway_assert</span>(lvaTable[i].<span>lvParentLcl</span> == (<span>unsigned</span>)(varDsc - lvaTable));</td>
      </tr>
      <tr>
        <td id="L2333" data-line-number="2333"></td>
        <td id="LC2333">        <span>if</span> (lvaTable[i].<span>lvFldOffset</span> == fldOffset)</td>
      </tr>
      <tr>
        <td id="L2334" data-line-number="2334"></td>
        <td id="LC2334">        {</td>
      </tr>
      <tr>
        <td id="L2335" data-line-number="2335"></td>
        <td id="LC2335">            <span>return</span> i;</td>
      </tr>
      <tr>
        <td id="L2336" data-line-number="2336"></td>
        <td id="LC2336">        }</td>
      </tr>
      <tr>
        <td id="L2337" data-line-number="2337"></td>
        <td id="LC2337">    }</td>
      </tr>
      <tr>
        <td id="L2338" data-line-number="2338"></td>
        <td id="LC2338">
</td>
      </tr>
      <tr>
        <td id="L2339" data-line-number="2339"></td>
        <td id="LC2339">    <span><span>//</span> This is the not-found error return path, the caller should check for BAD_VAR_NUM</span></td>
      </tr>
      <tr>
        <td id="L2340" data-line-number="2340"></td>
        <td id="LC2340">    <span>return</span> BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L2341" data-line-number="2341"></td>
        <td id="LC2341">}</td>
      </tr>
      <tr>
        <td id="L2342" data-line-number="2342"></td>
        <td id="LC2342">
</td>
      </tr>
      <tr>
        <td id="L2343" data-line-number="2343"></td>
        <td id="LC2343"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L2344" data-line-number="2344"></td>
        <td id="LC2344"><span> *</span></td>
      </tr>
      <tr>
        <td id="L2345" data-line-number="2345"></td>
        <td id="LC2345"><span> *  Set the local var "varNum" as address-exposed.</span></td>
      </tr>
      <tr>
        <td id="L2346" data-line-number="2346"></td>
        <td id="LC2346"><span> *  If this is a promoted struct, label it's fields the same way.</span></td>
      </tr>
      <tr>
        <td id="L2347" data-line-number="2347"></td>
        <td id="LC2347"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L2348" data-line-number="2348"></td>
        <td id="LC2348">
</td>
      </tr>
      <tr>
        <td id="L2349" data-line-number="2349"></td>
        <td id="LC2349"><span>void</span> <span>Compiler::lvaSetVarAddrExposed</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L2350" data-line-number="2350"></td>
        <td id="LC2350">{</td>
      </tr>
      <tr>
        <td id="L2351" data-line-number="2351"></td>
        <td id="LC2351">    <span>noway_assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L2352" data-line-number="2352"></td>
        <td id="LC2352">
</td>
      </tr>
      <tr>
        <td id="L2353" data-line-number="2353"></td>
        <td id="LC2353">    LclVarDsc* varDsc = &amp;lvaTable[varNum];</td>
      </tr>
      <tr>
        <td id="L2354" data-line-number="2354"></td>
        <td id="LC2354">
</td>
      </tr>
      <tr>
        <td id="L2355" data-line-number="2355"></td>
        <td id="LC2355">    varDsc-&gt;<span>lvAddrExposed</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2356" data-line-number="2356"></td>
        <td id="LC2356">
</td>
      </tr>
      <tr>
        <td id="L2357" data-line-number="2357"></td>
        <td id="LC2357">    <span>if</span> (varDsc-&gt;<span>lvPromoted</span>)</td>
      </tr>
      <tr>
        <td id="L2358" data-line-number="2358"></td>
        <td id="LC2358">    {</td>
      </tr>
      <tr>
        <td id="L2359" data-line-number="2359"></td>
        <td id="LC2359">        <span>noway_assert</span>(<span>varTypeIsStruct</span>(varDsc));</td>
      </tr>
      <tr>
        <td id="L2360" data-line-number="2360"></td>
        <td id="LC2360">
</td>
      </tr>
      <tr>
        <td id="L2361" data-line-number="2361"></td>
        <td id="LC2361">        <span>for</span> (<span>unsigned</span> i = varDsc-&gt;<span>lvFieldLclStart</span>; i &lt; varDsc-&gt;<span>lvFieldLclStart</span> + varDsc-&gt;<span>lvFieldCnt</span>; ++i)</td>
      </tr>
      <tr>
        <td id="L2362" data-line-number="2362"></td>
        <td id="LC2362">        {</td>
      </tr>
      <tr>
        <td id="L2363" data-line-number="2363"></td>
        <td id="LC2363">            <span>noway_assert</span>(lvaTable[i].<span>lvIsStructField</span>);</td>
      </tr>
      <tr>
        <td id="L2364" data-line-number="2364"></td>
        <td id="LC2364">            lvaTable[i].<span>lvAddrExposed</span> = <span>1</span>; <span><span>//</span> Make field local as address-exposed.</span></td>
      </tr>
      <tr>
        <td id="L2365" data-line-number="2365"></td>
        <td id="LC2365">            <span>lvaSetVarDoNotEnregister</span>(i <span>DEBUGARG</span>(DNER_AddrExposed));</td>
      </tr>
      <tr>
        <td id="L2366" data-line-number="2366"></td>
        <td id="LC2366">        }</td>
      </tr>
      <tr>
        <td id="L2367" data-line-number="2367"></td>
        <td id="LC2367">    }</td>
      </tr>
      <tr>
        <td id="L2368" data-line-number="2368"></td>
        <td id="LC2368">
</td>
      </tr>
      <tr>
        <td id="L2369" data-line-number="2369"></td>
        <td id="LC2369">    <span>lvaSetVarDoNotEnregister</span>(varNum <span>DEBUGARG</span>(DNER_AddrExposed));</td>
      </tr>
      <tr>
        <td id="L2370" data-line-number="2370"></td>
        <td id="LC2370">}</td>
      </tr>
      <tr>
        <td id="L2371" data-line-number="2371"></td>
        <td id="LC2371">
</td>
      </tr>
      <tr>
        <td id="L2372" data-line-number="2372"></td>
        <td id="LC2372"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2373" data-line-number="2373"></td>
        <td id="LC2373"><span><span>//</span> lvaSetVarLiveInOutOfHandler: Set the local varNum as being live in and/or out of a handler</span></td>
      </tr>
      <tr>
        <td id="L2374" data-line-number="2374"></td>
        <td id="LC2374"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2375" data-line-number="2375"></td>
        <td id="LC2375"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2376" data-line-number="2376"></td>
        <td id="LC2376"><span><span>//</span>    varNum - the varNum of the local</span></td>
      </tr>
      <tr>
        <td id="L2377" data-line-number="2377"></td>
        <td id="LC2377"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2378" data-line-number="2378"></td>
        <td id="LC2378"><span>void</span> <span>Compiler::lvaSetVarLiveInOutOfHandler</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L2379" data-line-number="2379"></td>
        <td id="LC2379">{</td>
      </tr>
      <tr>
        <td id="L2380" data-line-number="2380"></td>
        <td id="LC2380">    LclVarDsc* varDsc = <span>lvaGetDesc</span>(varNum);</td>
      </tr>
      <tr>
        <td id="L2381" data-line-number="2381"></td>
        <td id="LC2381">
</td>
      </tr>
      <tr>
        <td id="L2382" data-line-number="2382"></td>
        <td id="LC2382">    <span>INDEBUG</span>(varDsc-&gt;<span>lvLiveInOutOfHndlr</span> = <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L2383" data-line-number="2383"></td>
        <td id="LC2383">
</td>
      </tr>
      <tr>
        <td id="L2384" data-line-number="2384"></td>
        <td id="LC2384">    <span>if</span> (varDsc-&gt;<span>lvPromoted</span>)</td>
      </tr>
      <tr>
        <td id="L2385" data-line-number="2385"></td>
        <td id="LC2385">    {</td>
      </tr>
      <tr>
        <td id="L2386" data-line-number="2386"></td>
        <td id="LC2386">        <span>noway_assert</span>(<span>varTypeIsStruct</span>(varDsc));</td>
      </tr>
      <tr>
        <td id="L2387" data-line-number="2387"></td>
        <td id="LC2387">
</td>
      </tr>
      <tr>
        <td id="L2388" data-line-number="2388"></td>
        <td id="LC2388">        <span>for</span> (<span>unsigned</span> i = varDsc-&gt;<span>lvFieldLclStart</span>; i &lt; varDsc-&gt;<span>lvFieldLclStart</span> + varDsc-&gt;<span>lvFieldCnt</span>; ++i)</td>
      </tr>
      <tr>
        <td id="L2389" data-line-number="2389"></td>
        <td id="LC2389">        {</td>
      </tr>
      <tr>
        <td id="L2390" data-line-number="2390"></td>
        <td id="LC2390">            <span>noway_assert</span>(lvaTable[i].<span>lvIsStructField</span>);</td>
      </tr>
      <tr>
        <td id="L2391" data-line-number="2391"></td>
        <td id="LC2391">            <span>INDEBUG</span>(lvaTable[i].<span>lvLiveInOutOfHndlr</span> = <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L2392" data-line-number="2392"></td>
        <td id="LC2392">            <span>lvaSetVarDoNotEnregister</span>(i <span>DEBUGARG</span>(DNER_LiveInOutOfHandler));</td>
      </tr>
      <tr>
        <td id="L2393" data-line-number="2393"></td>
        <td id="LC2393">        }</td>
      </tr>
      <tr>
        <td id="L2394" data-line-number="2394"></td>
        <td id="LC2394">    }</td>
      </tr>
      <tr>
        <td id="L2395" data-line-number="2395"></td>
        <td id="LC2395">
</td>
      </tr>
      <tr>
        <td id="L2396" data-line-number="2396"></td>
        <td id="LC2396">    <span>lvaSetVarDoNotEnregister</span>(varNum <span>DEBUGARG</span>(DNER_LiveInOutOfHandler));</td>
      </tr>
      <tr>
        <td id="L2397" data-line-number="2397"></td>
        <td id="LC2397">}</td>
      </tr>
      <tr>
        <td id="L2398" data-line-number="2398"></td>
        <td id="LC2398">
</td>
      </tr>
      <tr>
        <td id="L2399" data-line-number="2399"></td>
        <td id="LC2399"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L2400" data-line-number="2400"></td>
        <td id="LC2400"><span> *</span></td>
      </tr>
      <tr>
        <td id="L2401" data-line-number="2401"></td>
        <td id="LC2401"><span> *  Record that the local var "varNum" should not be enregistered (for one of several reasons.)</span></td>
      </tr>
      <tr>
        <td id="L2402" data-line-number="2402"></td>
        <td id="LC2402"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L2403" data-line-number="2403"></td>
        <td id="LC2403">
</td>
      </tr>
      <tr>
        <td id="L2404" data-line-number="2404"></td>
        <td id="LC2404"><span>void</span> <span>Compiler::lvaSetVarDoNotEnregister</span>(<span>unsigned</span> varNum <span>DEBUGARG</span>(DoNotEnregisterReason reason))</td>
      </tr>
      <tr>
        <td id="L2405" data-line-number="2405"></td>
        <td id="LC2405">{</td>
      </tr>
      <tr>
        <td id="L2406" data-line-number="2406"></td>
        <td id="LC2406">    <span>noway_assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L2407" data-line-number="2407"></td>
        <td id="LC2407">    LclVarDsc* varDsc         = &amp;lvaTable[varNum];</td>
      </tr>
      <tr>
        <td id="L2408" data-line-number="2408"></td>
        <td id="LC2408">    varDsc-&gt;<span>lvDoNotEnregister</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2409" data-line-number="2409"></td>
        <td id="LC2409">
</td>
      </tr>
      <tr>
        <td id="L2410" data-line-number="2410"></td>
        <td id="LC2410">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2411" data-line-number="2411"></td>
        <td id="LC2411">    <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L2412" data-line-number="2412"></td>
        <td id="LC2412">    {</td>
      </tr>
      <tr>
        <td id="L2413" data-line-number="2413"></td>
        <td id="LC2413">        <span>printf</span>(<span><span>"</span><span>\n</span>Local V%02u should not be enregistered because: <span>"</span></span>, varNum);</td>
      </tr>
      <tr>
        <td id="L2414" data-line-number="2414"></td>
        <td id="LC2414">    }</td>
      </tr>
      <tr>
        <td id="L2415" data-line-number="2415"></td>
        <td id="LC2415">    <span>switch</span> (reason)</td>
      </tr>
      <tr>
        <td id="L2416" data-line-number="2416"></td>
        <td id="LC2416">    {</td>
      </tr>
      <tr>
        <td id="L2417" data-line-number="2417"></td>
        <td id="LC2417">        <span>case</span> DNER_AddrExposed:</td>
      </tr>
      <tr>
        <td id="L2418" data-line-number="2418"></td>
        <td id="LC2418">            <span>JITDUMP</span>(<span><span>"</span>it is address exposed<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2419" data-line-number="2419"></td>
        <td id="LC2419">            <span>assert</span>(varDsc-&gt;<span>lvAddrExposed</span>);</td>
      </tr>
      <tr>
        <td id="L2420" data-line-number="2420"></td>
        <td id="LC2420">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2421" data-line-number="2421"></td>
        <td id="LC2421">        <span>case</span> DNER_IsStruct:</td>
      </tr>
      <tr>
        <td id="L2422" data-line-number="2422"></td>
        <td id="LC2422">            <span>JITDUMP</span>(<span><span>"</span>it is a struct<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2423" data-line-number="2423"></td>
        <td id="LC2423">            <span>assert</span>(<span>varTypeIsStruct</span>(varDsc));</td>
      </tr>
      <tr>
        <td id="L2424" data-line-number="2424"></td>
        <td id="LC2424">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2425" data-line-number="2425"></td>
        <td id="LC2425">        <span>case</span> DNER_IsStructArg:</td>
      </tr>
      <tr>
        <td id="L2426" data-line-number="2426"></td>
        <td id="LC2426">            <span>JITDUMP</span>(<span><span>"</span>it is a struct arg<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2427" data-line-number="2427"></td>
        <td id="LC2427">            <span>assert</span>(<span>varTypeIsStruct</span>(varDsc));</td>
      </tr>
      <tr>
        <td id="L2428" data-line-number="2428"></td>
        <td id="LC2428">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2429" data-line-number="2429"></td>
        <td id="LC2429">        <span>case</span> DNER_BlockOp:</td>
      </tr>
      <tr>
        <td id="L2430" data-line-number="2430"></td>
        <td id="LC2430">            <span>JITDUMP</span>(<span><span>"</span>written in a block op<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2431" data-line-number="2431"></td>
        <td id="LC2431">            varDsc-&gt;<span>lvLclBlockOpAddr</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2432" data-line-number="2432"></td>
        <td id="LC2432">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2433" data-line-number="2433"></td>
        <td id="LC2433">        <span>case</span> DNER_LocalField:</td>
      </tr>
      <tr>
        <td id="L2434" data-line-number="2434"></td>
        <td id="LC2434">            <span>JITDUMP</span>(<span><span>"</span>was accessed as a local field<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2435" data-line-number="2435"></td>
        <td id="LC2435">            varDsc-&gt;<span>lvLclFieldExpr</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2436" data-line-number="2436"></td>
        <td id="LC2436">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2437" data-line-number="2437"></td>
        <td id="LC2437">        <span>case</span> DNER_VMNeedsStackAddr:</td>
      </tr>
      <tr>
        <td id="L2438" data-line-number="2438"></td>
        <td id="LC2438">            <span>JITDUMP</span>(<span><span>"</span>needs stack addr<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2439" data-line-number="2439"></td>
        <td id="LC2439">            varDsc-&gt;<span>lvVMNeedsStackAddr</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2440" data-line-number="2440"></td>
        <td id="LC2440">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2441" data-line-number="2441"></td>
        <td id="LC2441">        <span>case</span> DNER_LiveInOutOfHandler:</td>
      </tr>
      <tr>
        <td id="L2442" data-line-number="2442"></td>
        <td id="LC2442">            <span>JITDUMP</span>(<span><span>"</span>live in/out of a handler<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2443" data-line-number="2443"></td>
        <td id="LC2443">            varDsc-&gt;<span>lvLiveInOutOfHndlr</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2444" data-line-number="2444"></td>
        <td id="LC2444">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2445" data-line-number="2445"></td>
        <td id="LC2445">        <span>case</span> DNER_LiveAcrossUnmanagedCall:</td>
      </tr>
      <tr>
        <td id="L2446" data-line-number="2446"></td>
        <td id="LC2446">            <span>JITDUMP</span>(<span><span>"</span>live across unmanaged call<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2447" data-line-number="2447"></td>
        <td id="LC2447">            varDsc-&gt;<span>lvLiveAcrossUCall</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2448" data-line-number="2448"></td>
        <td id="LC2448">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2449" data-line-number="2449"></td>
        <td id="LC2449">        <span>case</span> DNER_DepField:</td>
      </tr>
      <tr>
        <td id="L2450" data-line-number="2450"></td>
        <td id="LC2450">            <span>JITDUMP</span>(<span><span>"</span>field of a dependently promoted struct<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2451" data-line-number="2451"></td>
        <td id="LC2451">            <span>assert</span>(varDsc-&gt;<span>lvIsStructField</span> &amp;&amp; (<span>lvaGetParentPromotionType</span>(varNum) != PROMOTION_TYPE_INDEPENDENT));</td>
      </tr>
      <tr>
        <td id="L2452" data-line-number="2452"></td>
        <td id="LC2452">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2453" data-line-number="2453"></td>
        <td id="LC2453">        <span>case</span> DNER_NoRegVars:</td>
      </tr>
      <tr>
        <td id="L2454" data-line-number="2454"></td>
        <td id="LC2454">            <span>JITDUMP</span>(<span><span>"</span>opts.compFlags &amp; CLFLG_REGVAR is not set<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2455" data-line-number="2455"></td>
        <td id="LC2455">            <span>assert</span>((opts.<span>compFlags</span> &amp; CLFLG_REGVAR) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L2456" data-line-number="2456"></td>
        <td id="LC2456">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2457" data-line-number="2457"></td>
        <td id="LC2457">        <span>case</span> DNER_MinOptsGC:</td>
      </tr>
      <tr>
        <td id="L2458" data-line-number="2458"></td>
        <td id="LC2458">            <span>JITDUMP</span>(<span><span>"</span>It is a GC Ref and we are compiling MinOpts<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2459" data-line-number="2459"></td>
        <td id="LC2459">            <span>assert</span>(!JitConfig.<span>JitMinOptsTrackGCrefs</span>() &amp;&amp; <span>varTypeIsGC</span>(varDsc-&gt;<span>TypeGet</span>()));</td>
      </tr>
      <tr>
        <td id="L2460" data-line-number="2460"></td>
        <td id="LC2460">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2461" data-line-number="2461"></td>
        <td id="LC2461">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L2462" data-line-number="2462"></td>
        <td id="LC2462">        <span>case</span> DNER_PinningRef:</td>
      </tr>
      <tr>
        <td id="L2463" data-line-number="2463"></td>
        <td id="LC2463">            <span>JITDUMP</span>(<span><span>"</span>pinning ref<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2464" data-line-number="2464"></td>
        <td id="LC2464">            <span>assert</span>(varDsc-&gt;<span>lvPinned</span>);</td>
      </tr>
      <tr>
        <td id="L2465" data-line-number="2465"></td>
        <td id="LC2465">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2466" data-line-number="2466"></td>
        <td id="LC2466">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2467" data-line-number="2467"></td>
        <td id="LC2467">#<span>if</span> !defined(TARGET_64BIT)</td>
      </tr>
      <tr>
        <td id="L2468" data-line-number="2468"></td>
        <td id="LC2468">        <span>case</span> DNER_LongParamField:</td>
      </tr>
      <tr>
        <td id="L2469" data-line-number="2469"></td>
        <td id="LC2469">            <span>JITDUMP</span>(<span><span>"</span>it is a decomposed field of a long parameter<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2470" data-line-number="2470"></td>
        <td id="LC2470">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2471" data-line-number="2471"></td>
        <td id="LC2471">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2472" data-line-number="2472"></td>
        <td id="LC2472">        <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L2473" data-line-number="2473"></td>
        <td id="LC2473">            <span>unreached</span>();</td>
      </tr>
      <tr>
        <td id="L2474" data-line-number="2474"></td>
        <td id="LC2474">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2475" data-line-number="2475"></td>
        <td id="LC2475">    }</td>
      </tr>
      <tr>
        <td id="L2476" data-line-number="2476"></td>
        <td id="LC2476">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2477" data-line-number="2477"></td>
        <td id="LC2477">}</td>
      </tr>
      <tr>
        <td id="L2478" data-line-number="2478"></td>
        <td id="LC2478">
</td>
      </tr>
      <tr>
        <td id="L2479" data-line-number="2479"></td>
        <td id="LC2479"><span><span>//</span> Returns true if this local var is a multireg struct.</span></td>
      </tr>
      <tr>
        <td id="L2480" data-line-number="2480"></td>
        <td id="LC2480"><span><span>//</span> TODO-Throughput: This does a lookup on the class handle, and in the outgoing arg context</span></td>
      </tr>
      <tr>
        <td id="L2481" data-line-number="2481"></td>
        <td id="LC2481"><span><span>//</span> this information is already available on the fgArgTabEntry, and shouldn't need to be</span></td>
      </tr>
      <tr>
        <td id="L2482" data-line-number="2482"></td>
        <td id="LC2482"><span><span>//</span> recomputed.</span></td>
      </tr>
      <tr>
        <td id="L2483" data-line-number="2483"></td>
        <td id="LC2483"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2484" data-line-number="2484"></td>
        <td id="LC2484"><span>bool</span> <span>Compiler::lvaIsMultiregStruct</span>(LclVarDsc* varDsc, <span>bool</span> isVarArg)</td>
      </tr>
      <tr>
        <td id="L2485" data-line-number="2485"></td>
        <td id="LC2485">{</td>
      </tr>
      <tr>
        <td id="L2486" data-line-number="2486"></td>
        <td id="LC2486">    <span>if</span> (<span>varTypeIsStruct</span>(varDsc-&gt;<span>TypeGet</span>()))</td>
      </tr>
      <tr>
        <td id="L2487" data-line-number="2487"></td>
        <td id="LC2487">    {</td>
      </tr>
      <tr>
        <td id="L2488" data-line-number="2488"></td>
        <td id="LC2488">        CORINFO_CLASS_HANDLE clsHnd = varDsc-&gt;<span>lvVerTypeInfo</span>.<span>GetClassHandleForValueClass</span>();</td>
      </tr>
      <tr>
        <td id="L2489" data-line-number="2489"></td>
        <td id="LC2489">        structPassingKind    howToPassStruct;</td>
      </tr>
      <tr>
        <td id="L2490" data-line-number="2490"></td>
        <td id="LC2490">
</td>
      </tr>
      <tr>
        <td id="L2491" data-line-number="2491"></td>
        <td id="LC2491">        var_types type = <span>getArgTypeForStruct</span>(clsHnd, &amp;howToPassStruct, isVarArg, varDsc-&gt;<span>lvExactSize</span>);</td>
      </tr>
      <tr>
        <td id="L2492" data-line-number="2492"></td>
        <td id="LC2492">
</td>
      </tr>
      <tr>
        <td id="L2493" data-line-number="2493"></td>
        <td id="LC2493">        <span>if</span> (howToPassStruct == SPK_ByValueAsHfa)</td>
      </tr>
      <tr>
        <td id="L2494" data-line-number="2494"></td>
        <td id="LC2494">        {</td>
      </tr>
      <tr>
        <td id="L2495" data-line-number="2495"></td>
        <td id="LC2495">            <span>assert</span>(type == TYP_STRUCT);</td>
      </tr>
      <tr>
        <td id="L2496" data-line-number="2496"></td>
        <td id="LC2496">            <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2497" data-line-number="2497"></td>
        <td id="LC2497">        }</td>
      </tr>
      <tr>
        <td id="L2498" data-line-number="2498"></td>
        <td id="LC2498">
</td>
      </tr>
      <tr>
        <td id="L2499" data-line-number="2499"></td>
        <td id="LC2499">#<span>if</span> defined(UNIX_AMD64_ABI) || defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L2500" data-line-number="2500"></td>
        <td id="LC2500">        <span>if</span> (howToPassStruct == SPK_ByValue)</td>
      </tr>
      <tr>
        <td id="L2501" data-line-number="2501"></td>
        <td id="LC2501">        {</td>
      </tr>
      <tr>
        <td id="L2502" data-line-number="2502"></td>
        <td id="LC2502">            <span>assert</span>(type == TYP_STRUCT);</td>
      </tr>
      <tr>
        <td id="L2503" data-line-number="2503"></td>
        <td id="LC2503">            <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2504" data-line-number="2504"></td>
        <td id="LC2504">        }</td>
      </tr>
      <tr>
        <td id="L2505" data-line-number="2505"></td>
        <td id="LC2505">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2506" data-line-number="2506"></td>
        <td id="LC2506">    }</td>
      </tr>
      <tr>
        <td id="L2507" data-line-number="2507"></td>
        <td id="LC2507">    <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2508" data-line-number="2508"></td>
        <td id="LC2508">}</td>
      </tr>
      <tr>
        <td id="L2509" data-line-number="2509"></td>
        <td id="LC2509">
</td>
      </tr>
      <tr>
        <td id="L2510" data-line-number="2510"></td>
        <td id="LC2510"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L2511" data-line-number="2511"></td>
        <td id="LC2511"><span> * Set the lvClass for a local variable of a struct type <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L2512" data-line-number="2512"></td>
        <td id="LC2512">
</td>
      </tr>
      <tr>
        <td id="L2513" data-line-number="2513"></td>
        <td id="LC2513"><span>void</span> <span>Compiler::lvaSetStruct</span>(<span>unsigned</span> varNum, CORINFO_CLASS_HANDLE typeHnd, <span>bool</span> unsafeValueClsCheck, <span>bool</span> setTypeInfo)</td>
      </tr>
      <tr>
        <td id="L2514" data-line-number="2514"></td>
        <td id="LC2514">{</td>
      </tr>
      <tr>
        <td id="L2515" data-line-number="2515"></td>
        <td id="LC2515">    <span>noway_assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L2516" data-line-number="2516"></td>
        <td id="LC2516">
</td>
      </tr>
      <tr>
        <td id="L2517" data-line-number="2517"></td>
        <td id="LC2517">    LclVarDsc* varDsc = &amp;lvaTable[varNum];</td>
      </tr>
      <tr>
        <td id="L2518" data-line-number="2518"></td>
        <td id="LC2518">    <span>if</span> (setTypeInfo)</td>
      </tr>
      <tr>
        <td id="L2519" data-line-number="2519"></td>
        <td id="LC2519">    {</td>
      </tr>
      <tr>
        <td id="L2520" data-line-number="2520"></td>
        <td id="LC2520">        varDsc-&gt;<span>lvVerTypeInfo</span> = <span>typeInfo</span>(TI_STRUCT, typeHnd);</td>
      </tr>
      <tr>
        <td id="L2521" data-line-number="2521"></td>
        <td id="LC2521">    }</td>
      </tr>
      <tr>
        <td id="L2522" data-line-number="2522"></td>
        <td id="LC2522">
</td>
      </tr>
      <tr>
        <td id="L2523" data-line-number="2523"></td>
        <td id="LC2523">    <span><span>//</span> Set the type and associated info if we haven't already set it.</span></td>
      </tr>
      <tr>
        <td id="L2524" data-line-number="2524"></td>
        <td id="LC2524">    <span>if</span> (varDsc-&gt;<span>lvType</span> == TYP_UNDEF)</td>
      </tr>
      <tr>
        <td id="L2525" data-line-number="2525"></td>
        <td id="LC2525">    {</td>
      </tr>
      <tr>
        <td id="L2526" data-line-number="2526"></td>
        <td id="LC2526">        varDsc-&gt;<span>lvType</span> = TYP_STRUCT;</td>
      </tr>
      <tr>
        <td id="L2527" data-line-number="2527"></td>
        <td id="LC2527">    }</td>
      </tr>
      <tr>
        <td id="L2528" data-line-number="2528"></td>
        <td id="LC2528">    <span>if</span> (varDsc-&gt;<span>lvExactSize</span> == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L2529" data-line-number="2529"></td>
        <td id="LC2529">    {</td>
      </tr>
      <tr>
        <td id="L2530" data-line-number="2530"></td>
        <td id="LC2530">        ClassLayout* layout = <span>typGetObjLayout</span>(typeHnd);</td>
      </tr>
      <tr>
        <td id="L2531" data-line-number="2531"></td>
        <td id="LC2531">        varDsc-&gt;<span>SetLayout</span>(layout);</td>
      </tr>
      <tr>
        <td id="L2532" data-line-number="2532"></td>
        <td id="LC2532">        varDsc-&gt;<span>lvExactSize</span> = layout-&gt;<span>GetSize</span>();</td>
      </tr>
      <tr>
        <td id="L2533" data-line-number="2533"></td>
        <td id="LC2533">
</td>
      </tr>
      <tr>
        <td id="L2534" data-line-number="2534"></td>
        <td id="LC2534">        <span>if</span> (layout-&gt;<span>IsValueClass</span>())</td>
      </tr>
      <tr>
        <td id="L2535" data-line-number="2535"></td>
        <td id="LC2535">        {</td>
      </tr>
      <tr>
        <td id="L2536" data-line-number="2536"></td>
        <td id="LC2536">            var_types simdBaseType = TYP_UNKNOWN;</td>
      </tr>
      <tr>
        <td id="L2537" data-line-number="2537"></td>
        <td id="LC2537">            varDsc-&gt;<span>lvType</span>         = <span>impNormStructType</span>(typeHnd, &amp;simdBaseType);</td>
      </tr>
      <tr>
        <td id="L2538" data-line-number="2538"></td>
        <td id="LC2538">
</td>
      </tr>
      <tr>
        <td id="L2539" data-line-number="2539"></td>
        <td id="LC2539">#<span>if</span> defined(TARGET_AMD64) || defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L2540" data-line-number="2540"></td>
        <td id="LC2540">            <span><span>//</span> Mark implicit byref struct parameters</span></td>
      </tr>
      <tr>
        <td id="L2541" data-line-number="2541"></td>
        <td id="LC2541">            <span>if</span> (varDsc-&gt;<span>lvIsParam</span> &amp;&amp; !varDsc-&gt;<span>lvIsStructField</span>)</td>
      </tr>
      <tr>
        <td id="L2542" data-line-number="2542"></td>
        <td id="LC2542">            {</td>
      </tr>
      <tr>
        <td id="L2543" data-line-number="2543"></td>
        <td id="LC2543">                structPassingKind howToReturnStruct;</td>
      </tr>
      <tr>
        <td id="L2544" data-line-number="2544"></td>
        <td id="LC2544">                <span>getArgTypeForStruct</span>(typeHnd, &amp;howToReturnStruct, <span>this</span>-&gt;<span>info</span>.<span>compIsVarArgs</span>, varDsc-&gt;<span>lvExactSize</span>);</td>
      </tr>
      <tr>
        <td id="L2545" data-line-number="2545"></td>
        <td id="LC2545">
</td>
      </tr>
      <tr>
        <td id="L2546" data-line-number="2546"></td>
        <td id="LC2546">                <span>if</span> (howToReturnStruct == SPK_ByReference)</td>
      </tr>
      <tr>
        <td id="L2547" data-line-number="2547"></td>
        <td id="LC2547">                {</td>
      </tr>
      <tr>
        <td id="L2548" data-line-number="2548"></td>
        <td id="LC2548">                    <span>JITDUMP</span>(<span><span>"</span>Marking V%02i as a byref parameter<span>\n</span><span>"</span></span>, varNum);</td>
      </tr>
      <tr>
        <td id="L2549" data-line-number="2549"></td>
        <td id="LC2549">                    varDsc-&gt;<span>lvIsImplicitByRef</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2550" data-line-number="2550"></td>
        <td id="LC2550">                }</td>
      </tr>
      <tr>
        <td id="L2551" data-line-number="2551"></td>
        <td id="LC2551">            }</td>
      </tr>
      <tr>
        <td id="L2552" data-line-number="2552"></td>
        <td id="LC2552">#<span>endif</span> <span><span>//</span> defined(TARGET_AMD64) || defined(TARGET_ARM64)</span></td>
      </tr>
      <tr>
        <td id="L2553" data-line-number="2553"></td>
        <td id="LC2553">
</td>
      </tr>
      <tr>
        <td id="L2554" data-line-number="2554"></td>
        <td id="LC2554">#<span>if</span> FEATURE_SIMD</td>
      </tr>
      <tr>
        <td id="L2555" data-line-number="2555"></td>
        <td id="LC2555">            <span>if</span> (simdBaseType != TYP_UNKNOWN)</td>
      </tr>
      <tr>
        <td id="L2556" data-line-number="2556"></td>
        <td id="LC2556">            {</td>
      </tr>
      <tr>
        <td id="L2557" data-line-number="2557"></td>
        <td id="LC2557">                <span>assert</span>(<span>varTypeIsSIMD</span>(varDsc));</td>
      </tr>
      <tr>
        <td id="L2558" data-line-number="2558"></td>
        <td id="LC2558">                varDsc-&gt;<span>lvSIMDType</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2559" data-line-number="2559"></td>
        <td id="LC2559">                varDsc-&gt;<span>lvBaseType</span> = simdBaseType;</td>
      </tr>
      <tr>
        <td id="L2560" data-line-number="2560"></td>
        <td id="LC2560">            }</td>
      </tr>
      <tr>
        <td id="L2561" data-line-number="2561"></td>
        <td id="LC2561">#<span>endif</span> <span><span>//</span> FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L2562" data-line-number="2562"></td>
        <td id="LC2562">#<span>ifdef</span> FEATURE_HFA</td>
      </tr>
      <tr>
        <td id="L2563" data-line-number="2563"></td>
        <td id="LC2563">            <span><span>//</span> for structs that are small enough, we check and set lvIsHfa and lvHfaTypeIsFloat</span></td>
      </tr>
      <tr>
        <td id="L2564" data-line-number="2564"></td>
        <td id="LC2564">            <span>if</span> (varDsc-&gt;<span>lvExactSize</span> &lt;= MAX_PASS_MULTIREG_BYTES)</td>
      </tr>
      <tr>
        <td id="L2565" data-line-number="2565"></td>
        <td id="LC2565">            {</td>
      </tr>
      <tr>
        <td id="L2566" data-line-number="2566"></td>
        <td id="LC2566">                var_types hfaType = <span>GetHfaType</span>(typeHnd); <span><span>//</span> set to float or double if it is an HFA, otherwise TYP_UNDEF</span></td>
      </tr>
      <tr>
        <td id="L2567" data-line-number="2567"></td>
        <td id="LC2567">                <span>if</span> (<span>varTypeIsValidHfaType</span>(hfaType))</td>
      </tr>
      <tr>
        <td id="L2568" data-line-number="2568"></td>
        <td id="LC2568">                {</td>
      </tr>
      <tr>
        <td id="L2569" data-line-number="2569"></td>
        <td id="LC2569">                    varDsc-&gt;<span>SetHfaType</span>(hfaType);</td>
      </tr>
      <tr>
        <td id="L2570" data-line-number="2570"></td>
        <td id="LC2570">
</td>
      </tr>
      <tr>
        <td id="L2571" data-line-number="2571"></td>
        <td id="LC2571">                    <span><span>//</span> hfa variables can never contain GC pointers</span></td>
      </tr>
      <tr>
        <td id="L2572" data-line-number="2572"></td>
        <td id="LC2572">                    <span>assert</span>(!layout-&gt;<span>HasGCPtr</span>());</td>
      </tr>
      <tr>
        <td id="L2573" data-line-number="2573"></td>
        <td id="LC2573">                    <span><span>//</span> The size of this struct should be evenly divisible by 4 or 8</span></td>
      </tr>
      <tr>
        <td id="L2574" data-line-number="2574"></td>
        <td id="LC2574">                    <span>assert</span>((varDsc-&gt;<span>lvExactSize</span> % <span>genTypeSize</span>(hfaType)) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L2575" data-line-number="2575"></td>
        <td id="LC2575">                    <span><span>//</span> The number of elements in the HFA should fit into our MAX_ARG_REG_COUNT limit</span></td>
      </tr>
      <tr>
        <td id="L2576" data-line-number="2576"></td>
        <td id="LC2576">                    <span>assert</span>((varDsc-&gt;<span>lvExactSize</span> / <span>genTypeSize</span>(hfaType)) &lt;= MAX_ARG_REG_COUNT);</td>
      </tr>
      <tr>
        <td id="L2577" data-line-number="2577"></td>
        <td id="LC2577">                }</td>
      </tr>
      <tr>
        <td id="L2578" data-line-number="2578"></td>
        <td id="LC2578">            }</td>
      </tr>
      <tr>
        <td id="L2579" data-line-number="2579"></td>
        <td id="LC2579">#<span>endif</span> <span><span>//</span> FEATURE_HFA</span></td>
      </tr>
      <tr>
        <td id="L2580" data-line-number="2580"></td>
        <td id="LC2580">        }</td>
      </tr>
      <tr>
        <td id="L2581" data-line-number="2581"></td>
        <td id="LC2581">    }</td>
      </tr>
      <tr>
        <td id="L2582" data-line-number="2582"></td>
        <td id="LC2582">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L2583" data-line-number="2583"></td>
        <td id="LC2583">    {</td>
      </tr>
      <tr>
        <td id="L2584" data-line-number="2584"></td>
        <td id="LC2584">#<span>if</span> FEATURE_SIMD</td>
      </tr>
      <tr>
        <td id="L2585" data-line-number="2585"></td>
        <td id="LC2585">        <span>assert</span>(!<span>varTypeIsSIMD</span>(varDsc) || (varDsc-&gt;<span>lvBaseType</span> != TYP_UNKNOWN));</td>
      </tr>
      <tr>
        <td id="L2586" data-line-number="2586"></td>
        <td id="LC2586">#<span>endif</span> <span><span>//</span> FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L2587" data-line-number="2587"></td>
        <td id="LC2587">    }</td>
      </tr>
      <tr>
        <td id="L2588" data-line-number="2588"></td>
        <td id="LC2588">
</td>
      </tr>
      <tr>
        <td id="L2589" data-line-number="2589"></td>
        <td id="LC2589">#<span>ifndef</span> TARGET_64BIT</td>
      </tr>
      <tr>
        <td id="L2590" data-line-number="2590"></td>
        <td id="LC2590">    BOOL <span>fDoubleAlignHint</span> = <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L2591" data-line-number="2591"></td>
        <td id="LC2591">#<span>ifdef</span> TARGET_X86</td>
      </tr>
      <tr>
        <td id="L2592" data-line-number="2592"></td>
        <td id="LC2592">    <span>fDoubleAlignHint</span> = <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L2593" data-line-number="2593"></td>
        <td id="LC2593">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2594" data-line-number="2594"></td>
        <td id="LC2594">
</td>
      </tr>
      <tr>
        <td id="L2595" data-line-number="2595"></td>
        <td id="LC2595">    <span>if</span> (info.<span>compCompHnd</span>-&gt;<span>getClassAlignmentRequirement</span>(typeHnd, <span>fDoubleAlignHint</span>) == <span>8</span>)</td>
      </tr>
      <tr>
        <td id="L2596" data-line-number="2596"></td>
        <td id="LC2596">    {</td>
      </tr>
      <tr>
        <td id="L2597" data-line-number="2597"></td>
        <td id="LC2597">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2598" data-line-number="2598"></td>
        <td id="LC2598">        <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L2599" data-line-number="2599"></td>
        <td id="LC2599">        {</td>
      </tr>
      <tr>
        <td id="L2600" data-line-number="2600"></td>
        <td id="LC2600">            <span>printf</span>(<span><span>"</span>Marking struct in V%02i with double align flag<span>\n</span><span>"</span></span>, varNum);</td>
      </tr>
      <tr>
        <td id="L2601" data-line-number="2601"></td>
        <td id="LC2601">        }</td>
      </tr>
      <tr>
        <td id="L2602" data-line-number="2602"></td>
        <td id="LC2602">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2603" data-line-number="2603"></td>
        <td id="LC2603">        varDsc-&gt;<span>lvStructDoubleAlign</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2604" data-line-number="2604"></td>
        <td id="LC2604">    }</td>
      </tr>
      <tr>
        <td id="L2605" data-line-number="2605"></td>
        <td id="LC2605">#<span>endif</span> <span><span>//</span> not TARGET_64BIT</span></td>
      </tr>
      <tr>
        <td id="L2606" data-line-number="2606"></td>
        <td id="LC2606">
</td>
      </tr>
      <tr>
        <td id="L2607" data-line-number="2607"></td>
        <td id="LC2607">    <span>unsigned</span> classAttribs = info.<span>compCompHnd</span>-&gt;<span>getClassAttribs</span>(typeHnd);</td>
      </tr>
      <tr>
        <td id="L2608" data-line-number="2608"></td>
        <td id="LC2608">
</td>
      </tr>
      <tr>
        <td id="L2609" data-line-number="2609"></td>
        <td id="LC2609">    varDsc-&gt;<span>lvOverlappingFields</span> = <span>StructHasOverlappingFields</span>(classAttribs);</td>
      </tr>
      <tr>
        <td id="L2610" data-line-number="2610"></td>
        <td id="LC2610">
</td>
      </tr>
      <tr>
        <td id="L2611" data-line-number="2611"></td>
        <td id="LC2611">    <span><span>//</span> Check whether this local is an unsafe value type and requires GS cookie protection.</span></td>
      </tr>
      <tr>
        <td id="L2612" data-line-number="2612"></td>
        <td id="LC2612">    <span><span>//</span> GS checks require the stack to be re-ordered, which can't be done with EnC.</span></td>
      </tr>
      <tr>
        <td id="L2613" data-line-number="2613"></td>
        <td id="LC2613">    <span>if</span> (unsafeValueClsCheck &amp;&amp; (classAttribs &amp; CORINFO_FLG_UNSAFE_VALUECLASS) &amp;&amp; !opts.<span>compDbgEnC</span>)</td>
      </tr>
      <tr>
        <td id="L2614" data-line-number="2614"></td>
        <td id="LC2614">    {</td>
      </tr>
      <tr>
        <td id="L2615" data-line-number="2615"></td>
        <td id="LC2615">        <span>setNeedsGSSecurityCookie</span>();</td>
      </tr>
      <tr>
        <td id="L2616" data-line-number="2616"></td>
        <td id="LC2616">        compGSReorderStackLayout = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2617" data-line-number="2617"></td>
        <td id="LC2617">        varDsc-&gt;<span>lvIsUnsafeBuffer</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2618" data-line-number="2618"></td>
        <td id="LC2618">    }</td>
      </tr>
      <tr>
        <td id="L2619" data-line-number="2619"></td>
        <td id="LC2619">}</td>
      </tr>
      <tr>
        <td id="L2620" data-line-number="2620"></td>
        <td id="LC2620">
</td>
      </tr>
      <tr>
        <td id="L2621" data-line-number="2621"></td>
        <td id="LC2621"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2622" data-line-number="2622"></td>
        <td id="LC2622"><span><span>//</span> lvaSetStructUsedAsVarArg: update hfa information for vararg struct args</span></td>
      </tr>
      <tr>
        <td id="L2623" data-line-number="2623"></td>
        <td id="LC2623"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2624" data-line-number="2624"></td>
        <td id="LC2624"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2625" data-line-number="2625"></td>
        <td id="LC2625"><span><span>//</span>    varNum   -- number of the variable</span></td>
      </tr>
      <tr>
        <td id="L2626" data-line-number="2626"></td>
        <td id="LC2626"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2627" data-line-number="2627"></td>
        <td id="LC2627"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2628" data-line-number="2628"></td>
        <td id="LC2628"><span><span>//</span>    This only affects arm64 varargs on windows where we need to pass</span></td>
      </tr>
      <tr>
        <td id="L2629" data-line-number="2629"></td>
        <td id="LC2629"><span><span>//</span>    hfa arguments as if they are not HFAs.</span></td>
      </tr>
      <tr>
        <td id="L2630" data-line-number="2630"></td>
        <td id="LC2630"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2631" data-line-number="2631"></td>
        <td id="LC2631"><span><span>//</span>    This function should only be called if the struct is used in a varargs</span></td>
      </tr>
      <tr>
        <td id="L2632" data-line-number="2632"></td>
        <td id="LC2632"><span><span>//</span>    method.</span></td>
      </tr>
      <tr>
        <td id="L2633" data-line-number="2633"></td>
        <td id="LC2633">
</td>
      </tr>
      <tr>
        <td id="L2634" data-line-number="2634"></td>
        <td id="LC2634"><span>void</span> <span>Compiler::lvaSetStructUsedAsVarArg</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L2635" data-line-number="2635"></td>
        <td id="LC2635">{</td>
      </tr>
      <tr>
        <td id="L2636" data-line-number="2636"></td>
        <td id="LC2636">#<span>ifdef</span> FEATURE_HFA</td>
      </tr>
      <tr>
        <td id="L2637" data-line-number="2637"></td>
        <td id="LC2637">#<span>if</span> defined(TARGET_WINDOWS) &amp;&amp; defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L2638" data-line-number="2638"></td>
        <td id="LC2638">    LclVarDsc* varDsc = &amp;lvaTable[varNum];</td>
      </tr>
      <tr>
        <td id="L2639" data-line-number="2639"></td>
        <td id="LC2639">    <span><span>//</span> For varargs methods incoming and outgoing arguments should not be treated</span></td>
      </tr>
      <tr>
        <td id="L2640" data-line-number="2640"></td>
        <td id="LC2640">    <span><span>//</span> as HFA.</span></td>
      </tr>
      <tr>
        <td id="L2641" data-line-number="2641"></td>
        <td id="LC2641">    varDsc-&gt;<span>SetHfaType</span>(TYP_UNDEF);</td>
      </tr>
      <tr>
        <td id="L2642" data-line-number="2642"></td>
        <td id="LC2642">#<span>endif</span> <span><span>//</span> defined(TARGET_WINDOWS) &amp;&amp; defined(TARGET_ARM64)</span></td>
      </tr>
      <tr>
        <td id="L2643" data-line-number="2643"></td>
        <td id="LC2643">#<span>endif</span> <span><span>//</span> FEATURE_HFA</span></td>
      </tr>
      <tr>
        <td id="L2644" data-line-number="2644"></td>
        <td id="LC2644">}</td>
      </tr>
      <tr>
        <td id="L2645" data-line-number="2645"></td>
        <td id="LC2645">
</td>
      </tr>
      <tr>
        <td id="L2646" data-line-number="2646"></td>
        <td id="LC2646"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2647" data-line-number="2647"></td>
        <td id="LC2647"><span><span>//</span> lvaSetClass: set class information for a local var.</span></td>
      </tr>
      <tr>
        <td id="L2648" data-line-number="2648"></td>
        <td id="LC2648"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2649" data-line-number="2649"></td>
        <td id="LC2649"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2650" data-line-number="2650"></td>
        <td id="LC2650"><span><span>//</span>    varNum -- number of the variable</span></td>
      </tr>
      <tr>
        <td id="L2651" data-line-number="2651"></td>
        <td id="LC2651"><span><span>//</span>    clsHnd -- class handle to use in set or update</span></td>
      </tr>
      <tr>
        <td id="L2652" data-line-number="2652"></td>
        <td id="LC2652"><span><span>//</span>    isExact -- true if class is known exactly</span></td>
      </tr>
      <tr>
        <td id="L2653" data-line-number="2653"></td>
        <td id="LC2653"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2654" data-line-number="2654"></td>
        <td id="LC2654"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2655" data-line-number="2655"></td>
        <td id="LC2655"><span><span>//</span>    varNum must not already have a ref class handle.</span></td>
      </tr>
      <tr>
        <td id="L2656" data-line-number="2656"></td>
        <td id="LC2656">
</td>
      </tr>
      <tr>
        <td id="L2657" data-line-number="2657"></td>
        <td id="LC2657"><span>void</span> <span>Compiler::lvaSetClass</span>(<span>unsigned</span> varNum, CORINFO_CLASS_HANDLE clsHnd, <span>bool</span> isExact)</td>
      </tr>
      <tr>
        <td id="L2658" data-line-number="2658"></td>
        <td id="LC2658">{</td>
      </tr>
      <tr>
        <td id="L2659" data-line-number="2659"></td>
        <td id="LC2659">    <span>noway_assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L2660" data-line-number="2660"></td>
        <td id="LC2660">
</td>
      </tr>
      <tr>
        <td id="L2661" data-line-number="2661"></td>
        <td id="LC2661">    <span><span>//</span> If we are just importing, we cannot reliably track local ref types,</span></td>
      </tr>
      <tr>
        <td id="L2662" data-line-number="2662"></td>
        <td id="LC2662">    <span><span>//</span> since the jit maps CORINFO_TYPE_VAR to TYP_REF.</span></td>
      </tr>
      <tr>
        <td id="L2663" data-line-number="2663"></td>
        <td id="LC2663">    <span>if</span> (<span>compIsForImportOnly</span>())</td>
      </tr>
      <tr>
        <td id="L2664" data-line-number="2664"></td>
        <td id="LC2664">    {</td>
      </tr>
      <tr>
        <td id="L2665" data-line-number="2665"></td>
        <td id="LC2665">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L2666" data-line-number="2666"></td>
        <td id="LC2666">    }</td>
      </tr>
      <tr>
        <td id="L2667" data-line-number="2667"></td>
        <td id="LC2667">
</td>
      </tr>
      <tr>
        <td id="L2668" data-line-number="2668"></td>
        <td id="LC2668">    <span><span>//</span> Else we should have a type handle.</span></td>
      </tr>
      <tr>
        <td id="L2669" data-line-number="2669"></td>
        <td id="LC2669">    <span>assert</span>(clsHnd != <span>nullptr</span>);</td>
      </tr>
      <tr>
        <td id="L2670" data-line-number="2670"></td>
        <td id="LC2670">
</td>
      </tr>
      <tr>
        <td id="L2671" data-line-number="2671"></td>
        <td id="LC2671">    LclVarDsc* varDsc = &amp;lvaTable[varNum];</td>
      </tr>
      <tr>
        <td id="L2672" data-line-number="2672"></td>
        <td id="LC2672">    <span>assert</span>(varDsc-&gt;<span>lvType</span> == TYP_REF);</td>
      </tr>
      <tr>
        <td id="L2673" data-line-number="2673"></td>
        <td id="LC2673">
</td>
      </tr>
      <tr>
        <td id="L2674" data-line-number="2674"></td>
        <td id="LC2674">    <span><span>//</span> We shoud not have any ref type information for this var.</span></td>
      </tr>
      <tr>
        <td id="L2675" data-line-number="2675"></td>
        <td id="LC2675">    <span>assert</span>(varDsc-&gt;<span>lvClassHnd</span> == <span>nullptr</span>);</td>
      </tr>
      <tr>
        <td id="L2676" data-line-number="2676"></td>
        <td id="LC2676">    <span>assert</span>(!varDsc-&gt;<span>lvClassIsExact</span>);</td>
      </tr>
      <tr>
        <td id="L2677" data-line-number="2677"></td>
        <td id="LC2677">
</td>
      </tr>
      <tr>
        <td id="L2678" data-line-number="2678"></td>
        <td id="LC2678">    <span>JITDUMP</span>(<span><span>"</span><span>\n</span>lvaSetClass: setting class for V%02i to (%p) %s %s<span>\n</span><span>"</span></span>, varNum, <span>dspPtr</span>(clsHnd),</td>
      </tr>
      <tr>
        <td id="L2679" data-line-number="2679"></td>
        <td id="LC2679">            info.<span>compCompHnd</span>-&gt;<span>getClassName</span>(clsHnd), isExact ? <span><span>"</span> [exact]<span>"</span></span> : <span><span>"</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2680" data-line-number="2680"></td>
        <td id="LC2680">
</td>
      </tr>
      <tr>
        <td id="L2681" data-line-number="2681"></td>
        <td id="LC2681">    varDsc-&gt;<span>lvClassHnd</span>     = clsHnd;</td>
      </tr>
      <tr>
        <td id="L2682" data-line-number="2682"></td>
        <td id="LC2682">    varDsc-&gt;<span>lvClassIsExact</span> = isExact;</td>
      </tr>
      <tr>
        <td id="L2683" data-line-number="2683"></td>
        <td id="LC2683">}</td>
      </tr>
      <tr>
        <td id="L2684" data-line-number="2684"></td>
        <td id="LC2684">
</td>
      </tr>
      <tr>
        <td id="L2685" data-line-number="2685"></td>
        <td id="LC2685"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2686" data-line-number="2686"></td>
        <td id="LC2686"><span><span>//</span> lvaSetClass: set class information for a local var from a tree or stack type</span></td>
      </tr>
      <tr>
        <td id="L2687" data-line-number="2687"></td>
        <td id="LC2687"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2688" data-line-number="2688"></td>
        <td id="LC2688"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2689" data-line-number="2689"></td>
        <td id="LC2689"><span><span>//</span>    varNum -- number of the variable. Must be a single def local</span></td>
      </tr>
      <tr>
        <td id="L2690" data-line-number="2690"></td>
        <td id="LC2690"><span><span>//</span>    tree  -- tree establishing the variable's value</span></td>
      </tr>
      <tr>
        <td id="L2691" data-line-number="2691"></td>
        <td id="LC2691"><span><span>//</span>    stackHnd -- handle for the type from the evaluation stack</span></td>
      </tr>
      <tr>
        <td id="L2692" data-line-number="2692"></td>
        <td id="LC2692"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2693" data-line-number="2693"></td>
        <td id="LC2693"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2694" data-line-number="2694"></td>
        <td id="LC2694"><span><span>//</span>    Preferentially uses the tree's type, when available. Since not all</span></td>
      </tr>
      <tr>
        <td id="L2695" data-line-number="2695"></td>
        <td id="LC2695"><span><span>//</span>    tree kinds can track ref types, the stack type is used as a</span></td>
      </tr>
      <tr>
        <td id="L2696" data-line-number="2696"></td>
        <td id="LC2696"><span><span>//</span>    fallback. If there is no stack type, then the class is set to object.</span></td>
      </tr>
      <tr>
        <td id="L2697" data-line-number="2697"></td>
        <td id="LC2697">
</td>
      </tr>
      <tr>
        <td id="L2698" data-line-number="2698"></td>
        <td id="LC2698"><span>void</span> <span>Compiler::lvaSetClass</span>(<span>unsigned</span> varNum, GenTree* tree, CORINFO_CLASS_HANDLE stackHnd)</td>
      </tr>
      <tr>
        <td id="L2699" data-line-number="2699"></td>
        <td id="LC2699">{</td>
      </tr>
      <tr>
        <td id="L2700" data-line-number="2700"></td>
        <td id="LC2700">    <span>bool</span>                 isExact   = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2701" data-line-number="2701"></td>
        <td id="LC2701">    <span>bool</span>                 isNonNull = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2702" data-line-number="2702"></td>
        <td id="LC2702">    CORINFO_CLASS_HANDLE clsHnd    = <span>gtGetClassHandle</span>(tree, &amp;isExact, &amp;isNonNull);</td>
      </tr>
      <tr>
        <td id="L2703" data-line-number="2703"></td>
        <td id="LC2703">
</td>
      </tr>
      <tr>
        <td id="L2704" data-line-number="2704"></td>
        <td id="LC2704">    <span>if</span> (clsHnd != <span>nullptr</span>)</td>
      </tr>
      <tr>
        <td id="L2705" data-line-number="2705"></td>
        <td id="LC2705">    {</td>
      </tr>
      <tr>
        <td id="L2706" data-line-number="2706"></td>
        <td id="LC2706">        <span>lvaSetClass</span>(varNum, clsHnd, isExact);</td>
      </tr>
      <tr>
        <td id="L2707" data-line-number="2707"></td>
        <td id="LC2707">    }</td>
      </tr>
      <tr>
        <td id="L2708" data-line-number="2708"></td>
        <td id="LC2708">    <span>else</span> <span>if</span> (stackHnd != <span>nullptr</span>)</td>
      </tr>
      <tr>
        <td id="L2709" data-line-number="2709"></td>
        <td id="LC2709">    {</td>
      </tr>
      <tr>
        <td id="L2710" data-line-number="2710"></td>
        <td id="LC2710">        <span>lvaSetClass</span>(varNum, stackHnd);</td>
      </tr>
      <tr>
        <td id="L2711" data-line-number="2711"></td>
        <td id="LC2711">    }</td>
      </tr>
      <tr>
        <td id="L2712" data-line-number="2712"></td>
        <td id="LC2712">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L2713" data-line-number="2713"></td>
        <td id="LC2713">    {</td>
      </tr>
      <tr>
        <td id="L2714" data-line-number="2714"></td>
        <td id="LC2714">        <span>lvaSetClass</span>(varNum, <span>impGetObjectClass</span>());</td>
      </tr>
      <tr>
        <td id="L2715" data-line-number="2715"></td>
        <td id="LC2715">    }</td>
      </tr>
      <tr>
        <td id="L2716" data-line-number="2716"></td>
        <td id="LC2716">}</td>
      </tr>
      <tr>
        <td id="L2717" data-line-number="2717"></td>
        <td id="LC2717">
</td>
      </tr>
      <tr>
        <td id="L2718" data-line-number="2718"></td>
        <td id="LC2718"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2719" data-line-number="2719"></td>
        <td id="LC2719"><span><span>//</span> lvaUpdateClass: update class information for a local var.</span></td>
      </tr>
      <tr>
        <td id="L2720" data-line-number="2720"></td>
        <td id="LC2720"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2721" data-line-number="2721"></td>
        <td id="LC2721"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2722" data-line-number="2722"></td>
        <td id="LC2722"><span><span>//</span>    varNum -- number of the variable</span></td>
      </tr>
      <tr>
        <td id="L2723" data-line-number="2723"></td>
        <td id="LC2723"><span><span>//</span>    clsHnd -- class handle to use in set or update</span></td>
      </tr>
      <tr>
        <td id="L2724" data-line-number="2724"></td>
        <td id="LC2724"><span><span>//</span>    isExact -- true if class is known exactly</span></td>
      </tr>
      <tr>
        <td id="L2725" data-line-number="2725"></td>
        <td id="LC2725"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2726" data-line-number="2726"></td>
        <td id="LC2726"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2727" data-line-number="2727"></td>
        <td id="LC2727"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2728" data-line-number="2728"></td>
        <td id="LC2728"><span><span>//</span>    This method models the type update rule for an assignment.</span></td>
      </tr>
      <tr>
        <td id="L2729" data-line-number="2729"></td>
        <td id="LC2729"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2730" data-line-number="2730"></td>
        <td id="LC2730"><span><span>//</span>    Updates currently should only happen for single-def user args or</span></td>
      </tr>
      <tr>
        <td id="L2731" data-line-number="2731"></td>
        <td id="LC2731"><span><span>//</span>    locals, when we are processing the expression actually being</span></td>
      </tr>
      <tr>
        <td id="L2732" data-line-number="2732"></td>
        <td id="LC2732"><span><span>//</span>    used to initialize the local (or inlined arg). The update will</span></td>
      </tr>
      <tr>
        <td id="L2733" data-line-number="2733"></td>
        <td id="LC2733"><span><span>//</span>    change the local from the declared type to the type of the</span></td>
      </tr>
      <tr>
        <td id="L2734" data-line-number="2734"></td>
        <td id="LC2734"><span><span>//</span>    initial value.</span></td>
      </tr>
      <tr>
        <td id="L2735" data-line-number="2735"></td>
        <td id="LC2735"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2736" data-line-number="2736"></td>
        <td id="LC2736"><span><span>//</span>    These updates should always *improve* what we know about the</span></td>
      </tr>
      <tr>
        <td id="L2737" data-line-number="2737"></td>
        <td id="LC2737"><span><span>//</span>    type, that is making an inexact type exact, or changing a type</span></td>
      </tr>
      <tr>
        <td id="L2738" data-line-number="2738"></td>
        <td id="LC2738"><span><span>//</span>    to some subtype. However the jit lacks precise type information</span></td>
      </tr>
      <tr>
        <td id="L2739" data-line-number="2739"></td>
        <td id="LC2739"><span><span>//</span>    for shared code, so ensuring this is so is currently not</span></td>
      </tr>
      <tr>
        <td id="L2740" data-line-number="2740"></td>
        <td id="LC2740"><span><span>//</span>    possible.</span></td>
      </tr>
      <tr>
        <td id="L2741" data-line-number="2741"></td>
        <td id="LC2741">
</td>
      </tr>
      <tr>
        <td id="L2742" data-line-number="2742"></td>
        <td id="LC2742"><span>void</span> <span>Compiler::lvaUpdateClass</span>(<span>unsigned</span> varNum, CORINFO_CLASS_HANDLE clsHnd, <span>bool</span> isExact)</td>
      </tr>
      <tr>
        <td id="L2743" data-line-number="2743"></td>
        <td id="LC2743">{</td>
      </tr>
      <tr>
        <td id="L2744" data-line-number="2744"></td>
        <td id="LC2744">    <span>assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L2745" data-line-number="2745"></td>
        <td id="LC2745">
</td>
      </tr>
      <tr>
        <td id="L2746" data-line-number="2746"></td>
        <td id="LC2746">    <span><span>//</span> If we are just importing, we cannot reliably track local ref types,</span></td>
      </tr>
      <tr>
        <td id="L2747" data-line-number="2747"></td>
        <td id="LC2747">    <span><span>//</span> since the jit maps CORINFO_TYPE_VAR to TYP_REF.</span></td>
      </tr>
      <tr>
        <td id="L2748" data-line-number="2748"></td>
        <td id="LC2748">    <span>if</span> (<span>compIsForImportOnly</span>())</td>
      </tr>
      <tr>
        <td id="L2749" data-line-number="2749"></td>
        <td id="LC2749">    {</td>
      </tr>
      <tr>
        <td id="L2750" data-line-number="2750"></td>
        <td id="LC2750">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L2751" data-line-number="2751"></td>
        <td id="LC2751">    }</td>
      </tr>
      <tr>
        <td id="L2752" data-line-number="2752"></td>
        <td id="LC2752">
</td>
      </tr>
      <tr>
        <td id="L2753" data-line-number="2753"></td>
        <td id="LC2753">    <span><span>//</span> Else we should have a class handle to consider</span></td>
      </tr>
      <tr>
        <td id="L2754" data-line-number="2754"></td>
        <td id="LC2754">    <span>assert</span>(clsHnd != <span>nullptr</span>);</td>
      </tr>
      <tr>
        <td id="L2755" data-line-number="2755"></td>
        <td id="LC2755">
</td>
      </tr>
      <tr>
        <td id="L2756" data-line-number="2756"></td>
        <td id="LC2756">    LclVarDsc* varDsc = &amp;lvaTable[varNum];</td>
      </tr>
      <tr>
        <td id="L2757" data-line-number="2757"></td>
        <td id="LC2757">    <span>assert</span>(varDsc-&gt;<span>lvType</span> == TYP_REF);</td>
      </tr>
      <tr>
        <td id="L2758" data-line-number="2758"></td>
        <td id="LC2758">
</td>
      </tr>
      <tr>
        <td id="L2759" data-line-number="2759"></td>
        <td id="LC2759">    <span><span>//</span> We should already have a class</span></td>
      </tr>
      <tr>
        <td id="L2760" data-line-number="2760"></td>
        <td id="LC2760">    <span>assert</span>(varDsc-&gt;<span>lvClassHnd</span> != <span>nullptr</span>);</td>
      </tr>
      <tr>
        <td id="L2761" data-line-number="2761"></td>
        <td id="LC2761">
</td>
      </tr>
      <tr>
        <td id="L2762" data-line-number="2762"></td>
        <td id="LC2762">    <span><span>//</span> We should only be updating classes for single-def locals.</span></td>
      </tr>
      <tr>
        <td id="L2763" data-line-number="2763"></td>
        <td id="LC2763">    <span>assert</span>(varDsc-&gt;<span>lvSingleDef</span>);</td>
      </tr>
      <tr>
        <td id="L2764" data-line-number="2764"></td>
        <td id="LC2764">
</td>
      </tr>
      <tr>
        <td id="L2765" data-line-number="2765"></td>
        <td id="LC2765">    <span><span>//</span> Now see if we should update.</span></td>
      </tr>
      <tr>
        <td id="L2766" data-line-number="2766"></td>
        <td id="LC2766">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2767" data-line-number="2767"></td>
        <td id="LC2767">    <span><span>//</span> New information may not always be "better" so do some</span></td>
      </tr>
      <tr>
        <td id="L2768" data-line-number="2768"></td>
        <td id="LC2768">    <span><span>//</span> simple analysis to decide if the update is worthwhile.</span></td>
      </tr>
      <tr>
        <td id="L2769" data-line-number="2769"></td>
        <td id="LC2769">    <span>const</span> <span>bool</span> isNewClass   = (clsHnd != varDsc-&gt;<span>lvClassHnd</span>);</td>
      </tr>
      <tr>
        <td id="L2770" data-line-number="2770"></td>
        <td id="LC2770">    <span>bool</span>       shouldUpdate = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2771" data-line-number="2771"></td>
        <td id="LC2771">
</td>
      </tr>
      <tr>
        <td id="L2772" data-line-number="2772"></td>
        <td id="LC2772">    <span><span>//</span> Are we attempting to update the class? Only check this when we have</span></td>
      </tr>
      <tr>
        <td id="L2773" data-line-number="2773"></td>
        <td id="LC2773">    <span><span>//</span> an new type and the existing class is inexact... we should not be</span></td>
      </tr>
      <tr>
        <td id="L2774" data-line-number="2774"></td>
        <td id="LC2774">    <span><span>//</span> updating exact classes.</span></td>
      </tr>
      <tr>
        <td id="L2775" data-line-number="2775"></td>
        <td id="LC2775">    <span>if</span> (!varDsc-&gt;<span>lvClassIsExact</span> &amp;&amp; isNewClass)</td>
      </tr>
      <tr>
        <td id="L2776" data-line-number="2776"></td>
        <td id="LC2776">    {</td>
      </tr>
      <tr>
        <td id="L2777" data-line-number="2777"></td>
        <td id="LC2777">        shouldUpdate = !!info.<span>compCompHnd</span>-&gt;<span>isMoreSpecificType</span>(varDsc-&gt;<span>lvClassHnd</span>, clsHnd);</td>
      </tr>
      <tr>
        <td id="L2778" data-line-number="2778"></td>
        <td id="LC2778">    }</td>
      </tr>
      <tr>
        <td id="L2779" data-line-number="2779"></td>
        <td id="LC2779">    <span><span>//</span> Else are we attempting to update exactness?</span></td>
      </tr>
      <tr>
        <td id="L2780" data-line-number="2780"></td>
        <td id="LC2780">    <span>else</span> <span>if</span> (isExact &amp;&amp; !varDsc-&gt;<span>lvClassIsExact</span> &amp;&amp; !isNewClass)</td>
      </tr>
      <tr>
        <td id="L2781" data-line-number="2781"></td>
        <td id="LC2781">    {</td>
      </tr>
      <tr>
        <td id="L2782" data-line-number="2782"></td>
        <td id="LC2782">        shouldUpdate = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2783" data-line-number="2783"></td>
        <td id="LC2783">    }</td>
      </tr>
      <tr>
        <td id="L2784" data-line-number="2784"></td>
        <td id="LC2784">
</td>
      </tr>
      <tr>
        <td id="L2785" data-line-number="2785"></td>
        <td id="LC2785">#<span>if</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2786" data-line-number="2786"></td>
        <td id="LC2786">    <span>if</span> (isNewClass || (isExact != varDsc-&gt;<span>lvClassIsExact</span>))</td>
      </tr>
      <tr>
        <td id="L2787" data-line-number="2787"></td>
        <td id="LC2787">    {</td>
      </tr>
      <tr>
        <td id="L2788" data-line-number="2788"></td>
        <td id="LC2788">        <span>JITDUMP</span>(<span><span>"</span><span>\n</span>lvaUpdateClass:%s Updating class for V%02u<span>"</span></span>, shouldUpdate ? <span><span>"</span><span>"</span></span> : <span><span>"</span> NOT<span>"</span></span>, varNum);</td>
      </tr>
      <tr>
        <td id="L2789" data-line-number="2789"></td>
        <td id="LC2789">        <span>JITDUMP</span>(<span><span>"</span> from (%p) %s%s<span>"</span></span>, <span>dspPtr</span>(varDsc-&gt;<span>lvClassHnd</span>), info.<span>compCompHnd</span>-&gt;<span>getClassName</span>(varDsc-&gt;<span>lvClassHnd</span>),</td>
      </tr>
      <tr>
        <td id="L2790" data-line-number="2790"></td>
        <td id="LC2790">                varDsc-&gt;<span>lvClassIsExact</span> ? <span><span>"</span> [exact]<span>"</span></span> : <span><span>"</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2791" data-line-number="2791"></td>
        <td id="LC2791">        <span>JITDUMP</span>(<span><span>"</span> to (%p) %s%s<span>\n</span><span>"</span></span>, <span>dspPtr</span>(clsHnd), info.<span>compCompHnd</span>-&gt;<span>getClassName</span>(clsHnd), isExact ? <span><span>"</span> [exact]<span>"</span></span> : <span><span>"</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2792" data-line-number="2792"></td>
        <td id="LC2792">    }</td>
      </tr>
      <tr>
        <td id="L2793" data-line-number="2793"></td>
        <td id="LC2793">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L2794" data-line-number="2794"></td>
        <td id="LC2794">
</td>
      </tr>
      <tr>
        <td id="L2795" data-line-number="2795"></td>
        <td id="LC2795">    <span>if</span> (shouldUpdate)</td>
      </tr>
      <tr>
        <td id="L2796" data-line-number="2796"></td>
        <td id="LC2796">    {</td>
      </tr>
      <tr>
        <td id="L2797" data-line-number="2797"></td>
        <td id="LC2797">        varDsc-&gt;<span>lvClassHnd</span>     = clsHnd;</td>
      </tr>
      <tr>
        <td id="L2798" data-line-number="2798"></td>
        <td id="LC2798">        varDsc-&gt;<span>lvClassIsExact</span> = isExact;</td>
      </tr>
      <tr>
        <td id="L2799" data-line-number="2799"></td>
        <td id="LC2799">
</td>
      </tr>
      <tr>
        <td id="L2800" data-line-number="2800"></td>
        <td id="LC2800">#<span>if</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L2801" data-line-number="2801"></td>
        <td id="LC2801">        <span><span>//</span> Note we've modified the type...</span></td>
      </tr>
      <tr>
        <td id="L2802" data-line-number="2802"></td>
        <td id="LC2802">        varDsc-&gt;<span>lvClassInfoUpdated</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L2803" data-line-number="2803"></td>
        <td id="LC2803">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L2804" data-line-number="2804"></td>
        <td id="LC2804">    }</td>
      </tr>
      <tr>
        <td id="L2805" data-line-number="2805"></td>
        <td id="LC2805">
</td>
      </tr>
      <tr>
        <td id="L2806" data-line-number="2806"></td>
        <td id="LC2806">    <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L2807" data-line-number="2807"></td>
        <td id="LC2807">}</td>
      </tr>
      <tr>
        <td id="L2808" data-line-number="2808"></td>
        <td id="LC2808">
</td>
      </tr>
      <tr>
        <td id="L2809" data-line-number="2809"></td>
        <td id="LC2809"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2810" data-line-number="2810"></td>
        <td id="LC2810"><span><span>//</span> lvaUpdateClass: Uupdate class information for a local var from a tree</span></td>
      </tr>
      <tr>
        <td id="L2811" data-line-number="2811"></td>
        <td id="LC2811"><span><span>//</span>  or stack type</span></td>
      </tr>
      <tr>
        <td id="L2812" data-line-number="2812"></td>
        <td id="LC2812"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2813" data-line-number="2813"></td>
        <td id="LC2813"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2814" data-line-number="2814"></td>
        <td id="LC2814"><span><span>//</span>    varNum -- number of the variable. Must be a single def local</span></td>
      </tr>
      <tr>
        <td id="L2815" data-line-number="2815"></td>
        <td id="LC2815"><span><span>//</span>    tree  -- tree establishing the variable's value</span></td>
      </tr>
      <tr>
        <td id="L2816" data-line-number="2816"></td>
        <td id="LC2816"><span><span>//</span>    stackHnd -- handle for the type from the evaluation stack</span></td>
      </tr>
      <tr>
        <td id="L2817" data-line-number="2817"></td>
        <td id="LC2817"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2818" data-line-number="2818"></td>
        <td id="LC2818"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L2819" data-line-number="2819"></td>
        <td id="LC2819"><span><span>//</span>    Preferentially uses the tree's type, when available. Since not all</span></td>
      </tr>
      <tr>
        <td id="L2820" data-line-number="2820"></td>
        <td id="LC2820"><span><span>//</span>    tree kinds can track ref types, the stack type is used as a</span></td>
      </tr>
      <tr>
        <td id="L2821" data-line-number="2821"></td>
        <td id="LC2821"><span><span>//</span>    fallback.</span></td>
      </tr>
      <tr>
        <td id="L2822" data-line-number="2822"></td>
        <td id="LC2822">
</td>
      </tr>
      <tr>
        <td id="L2823" data-line-number="2823"></td>
        <td id="LC2823"><span>void</span> <span>Compiler::lvaUpdateClass</span>(<span>unsigned</span> varNum, GenTree* tree, CORINFO_CLASS_HANDLE stackHnd)</td>
      </tr>
      <tr>
        <td id="L2824" data-line-number="2824"></td>
        <td id="LC2824">{</td>
      </tr>
      <tr>
        <td id="L2825" data-line-number="2825"></td>
        <td id="LC2825">    <span>bool</span>                 isExact   = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2826" data-line-number="2826"></td>
        <td id="LC2826">    <span>bool</span>                 isNonNull = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2827" data-line-number="2827"></td>
        <td id="LC2827">    CORINFO_CLASS_HANDLE clsHnd    = <span>gtGetClassHandle</span>(tree, &amp;isExact, &amp;isNonNull);</td>
      </tr>
      <tr>
        <td id="L2828" data-line-number="2828"></td>
        <td id="LC2828">
</td>
      </tr>
      <tr>
        <td id="L2829" data-line-number="2829"></td>
        <td id="LC2829">    <span>if</span> (clsHnd != <span>nullptr</span>)</td>
      </tr>
      <tr>
        <td id="L2830" data-line-number="2830"></td>
        <td id="LC2830">    {</td>
      </tr>
      <tr>
        <td id="L2831" data-line-number="2831"></td>
        <td id="LC2831">        <span>lvaUpdateClass</span>(varNum, clsHnd, isExact);</td>
      </tr>
      <tr>
        <td id="L2832" data-line-number="2832"></td>
        <td id="LC2832">    }</td>
      </tr>
      <tr>
        <td id="L2833" data-line-number="2833"></td>
        <td id="LC2833">    <span>else</span> <span>if</span> (stackHnd != <span>nullptr</span>)</td>
      </tr>
      <tr>
        <td id="L2834" data-line-number="2834"></td>
        <td id="LC2834">    {</td>
      </tr>
      <tr>
        <td id="L2835" data-line-number="2835"></td>
        <td id="LC2835">        <span>lvaUpdateClass</span>(varNum, stackHnd);</td>
      </tr>
      <tr>
        <td id="L2836" data-line-number="2836"></td>
        <td id="LC2836">    }</td>
      </tr>
      <tr>
        <td id="L2837" data-line-number="2837"></td>
        <td id="LC2837">}</td>
      </tr>
      <tr>
        <td id="L2838" data-line-number="2838"></td>
        <td id="LC2838">
</td>
      </tr>
      <tr>
        <td id="L2839" data-line-number="2839"></td>
        <td id="LC2839"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2840" data-line-number="2840"></td>
        <td id="LC2840"><span><span>//</span> lvaLclSize: returns size of a local variable, in bytes</span></td>
      </tr>
      <tr>
        <td id="L2841" data-line-number="2841"></td>
        <td id="LC2841"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2842" data-line-number="2842"></td>
        <td id="LC2842"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L2843" data-line-number="2843"></td>
        <td id="LC2843"><span><span>//</span>    varNum -- variable to query</span></td>
      </tr>
      <tr>
        <td id="L2844" data-line-number="2844"></td>
        <td id="LC2844"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2845" data-line-number="2845"></td>
        <td id="LC2845"><span><span>//</span> Returns:</span></td>
      </tr>
      <tr>
        <td id="L2846" data-line-number="2846"></td>
        <td id="LC2846"><span><span>//</span>    Number of bytes needed on the frame for such a local.</span></td>
      </tr>
      <tr>
        <td id="L2847" data-line-number="2847"></td>
        <td id="LC2847">
</td>
      </tr>
      <tr>
        <td id="L2848" data-line-number="2848"></td>
        <td id="LC2848"><span>unsigned</span> <span>Compiler::lvaLclSize</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L2849" data-line-number="2849"></td>
        <td id="LC2849">{</td>
      </tr>
      <tr>
        <td id="L2850" data-line-number="2850"></td>
        <td id="LC2850">    <span>assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L2851" data-line-number="2851"></td>
        <td id="LC2851">
</td>
      </tr>
      <tr>
        <td id="L2852" data-line-number="2852"></td>
        <td id="LC2852">    var_types varType = lvaTable[varNum].<span>TypeGet</span>();</td>
      </tr>
      <tr>
        <td id="L2853" data-line-number="2853"></td>
        <td id="LC2853">
</td>
      </tr>
      <tr>
        <td id="L2854" data-line-number="2854"></td>
        <td id="LC2854">    <span>switch</span> (varType)</td>
      </tr>
      <tr>
        <td id="L2855" data-line-number="2855"></td>
        <td id="LC2855">    {</td>
      </tr>
      <tr>
        <td id="L2856" data-line-number="2856"></td>
        <td id="LC2856">        <span>case</span> TYP_STRUCT:</td>
      </tr>
      <tr>
        <td id="L2857" data-line-number="2857"></td>
        <td id="LC2857">        <span>case</span> TYP_BLK:</td>
      </tr>
      <tr>
        <td id="L2858" data-line-number="2858"></td>
        <td id="LC2858">            <span>return</span> lvaTable[varNum].<span>lvSize</span>();</td>
      </tr>
      <tr>
        <td id="L2859" data-line-number="2859"></td>
        <td id="LC2859">
</td>
      </tr>
      <tr>
        <td id="L2860" data-line-number="2860"></td>
        <td id="LC2860">        <span>case</span> TYP_LCLBLK:</td>
      </tr>
      <tr>
        <td id="L2861" data-line-number="2861"></td>
        <td id="LC2861">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L2862" data-line-number="2862"></td>
        <td id="LC2862">            <span><span>//</span> Note that this operation performs a read of a PhasedVar</span></td>
      </tr>
      <tr>
        <td id="L2863" data-line-number="2863"></td>
        <td id="LC2863">            <span>noway_assert</span>(varNum == lvaOutgoingArgSpaceVar);</td>
      </tr>
      <tr>
        <td id="L2864" data-line-number="2864"></td>
        <td id="LC2864">            <span>return</span> lvaOutgoingArgSpaceSize;</td>
      </tr>
      <tr>
        <td id="L2865" data-line-number="2865"></td>
        <td id="LC2865">#<span>else</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L2866" data-line-number="2866"></td>
        <td id="LC2866">            <span>assert</span>(!<span><span>"</span>Unknown size<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2867" data-line-number="2867"></td>
        <td id="LC2867">            <span>NO_WAY</span>(<span><span>"</span>Target doesn't support TYP_LCLBLK<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2868" data-line-number="2868"></td>
        <td id="LC2868">
</td>
      </tr>
      <tr>
        <td id="L2869" data-line-number="2869"></td>
        <td id="LC2869">            <span><span>//</span> Keep prefast happy</span></td>
      </tr>
      <tr>
        <td id="L2870" data-line-number="2870"></td>
        <td id="LC2870">            __fallthrough;</td>
      </tr>
      <tr>
        <td id="L2871" data-line-number="2871"></td>
        <td id="LC2871">
</td>
      </tr>
      <tr>
        <td id="L2872" data-line-number="2872"></td>
        <td id="LC2872">#<span>endif</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L2873" data-line-number="2873"></td>
        <td id="LC2873">
</td>
      </tr>
      <tr>
        <td id="L2874" data-line-number="2874"></td>
        <td id="LC2874">        <span>default</span>: <span><span>//</span> This must be a primitive var. Fall out of switch statement</span></td>
      </tr>
      <tr>
        <td id="L2875" data-line-number="2875"></td>
        <td id="LC2875">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2876" data-line-number="2876"></td>
        <td id="LC2876">    }</td>
      </tr>
      <tr>
        <td id="L2877" data-line-number="2877"></td>
        <td id="LC2877">#<span>ifdef</span> TARGET_64BIT</td>
      </tr>
      <tr>
        <td id="L2878" data-line-number="2878"></td>
        <td id="LC2878">    <span><span>//</span> We only need this Quirk for TARGET_64BIT</span></td>
      </tr>
      <tr>
        <td id="L2879" data-line-number="2879"></td>
        <td id="LC2879">    <span>if</span> (lvaTable[varNum].<span>lvQuirkToLong</span>)</td>
      </tr>
      <tr>
        <td id="L2880" data-line-number="2880"></td>
        <td id="LC2880">    {</td>
      </tr>
      <tr>
        <td id="L2881" data-line-number="2881"></td>
        <td id="LC2881">        <span>noway_assert</span>(lvaTable[varNum].<span>lvAddrExposed</span>);</td>
      </tr>
      <tr>
        <td id="L2882" data-line-number="2882"></td>
        <td id="LC2882">        <span>return</span> <span>genTypeStSz</span>(TYP_LONG) * <span>sizeof</span>(<span>int</span>); <span><span>//</span> return 8  (2 * 4)</span></td>
      </tr>
      <tr>
        <td id="L2883" data-line-number="2883"></td>
        <td id="LC2883">    }</td>
      </tr>
      <tr>
        <td id="L2884" data-line-number="2884"></td>
        <td id="LC2884">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2885" data-line-number="2885"></td>
        <td id="LC2885">    <span>return</span> <span>genTypeStSz</span>(varType) * <span>sizeof</span>(<span>int</span>);</td>
      </tr>
      <tr>
        <td id="L2886" data-line-number="2886"></td>
        <td id="LC2886">}</td>
      </tr>
      <tr>
        <td id="L2887" data-line-number="2887"></td>
        <td id="LC2887">
</td>
      </tr>
      <tr>
        <td id="L2888" data-line-number="2888"></td>
        <td id="LC2888"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2889" data-line-number="2889"></td>
        <td id="LC2889"><span><span>//</span> Return the exact width of local variable "varNum" -- the number of bytes</span></td>
      </tr>
      <tr>
        <td id="L2890" data-line-number="2890"></td>
        <td id="LC2890"><span><span>//</span> you'd need to copy in order to overwrite the value.</span></td>
      </tr>
      <tr>
        <td id="L2891" data-line-number="2891"></td>
        <td id="LC2891"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2892" data-line-number="2892"></td>
        <td id="LC2892"><span>unsigned</span> <span>Compiler::lvaLclExactSize</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L2893" data-line-number="2893"></td>
        <td id="LC2893">{</td>
      </tr>
      <tr>
        <td id="L2894" data-line-number="2894"></td>
        <td id="LC2894">    <span>assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L2895" data-line-number="2895"></td>
        <td id="LC2895">
</td>
      </tr>
      <tr>
        <td id="L2896" data-line-number="2896"></td>
        <td id="LC2896">    var_types varType = lvaTable[varNum].<span>TypeGet</span>();</td>
      </tr>
      <tr>
        <td id="L2897" data-line-number="2897"></td>
        <td id="LC2897">
</td>
      </tr>
      <tr>
        <td id="L2898" data-line-number="2898"></td>
        <td id="LC2898">    <span>switch</span> (varType)</td>
      </tr>
      <tr>
        <td id="L2899" data-line-number="2899"></td>
        <td id="LC2899">    {</td>
      </tr>
      <tr>
        <td id="L2900" data-line-number="2900"></td>
        <td id="LC2900">        <span>case</span> TYP_STRUCT:</td>
      </tr>
      <tr>
        <td id="L2901" data-line-number="2901"></td>
        <td id="LC2901">        <span>case</span> TYP_BLK:</td>
      </tr>
      <tr>
        <td id="L2902" data-line-number="2902"></td>
        <td id="LC2902">            <span>return</span> lvaTable[varNum].<span>lvExactSize</span>;</td>
      </tr>
      <tr>
        <td id="L2903" data-line-number="2903"></td>
        <td id="LC2903">
</td>
      </tr>
      <tr>
        <td id="L2904" data-line-number="2904"></td>
        <td id="LC2904">        <span>case</span> TYP_LCLBLK:</td>
      </tr>
      <tr>
        <td id="L2905" data-line-number="2905"></td>
        <td id="LC2905">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L2906" data-line-number="2906"></td>
        <td id="LC2906">            <span><span>//</span> Note that this operation performs a read of a PhasedVar</span></td>
      </tr>
      <tr>
        <td id="L2907" data-line-number="2907"></td>
        <td id="LC2907">            <span>noway_assert</span>(lvaOutgoingArgSpaceSize &gt;= <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L2908" data-line-number="2908"></td>
        <td id="LC2908">            <span>noway_assert</span>(varNum == lvaOutgoingArgSpaceVar);</td>
      </tr>
      <tr>
        <td id="L2909" data-line-number="2909"></td>
        <td id="LC2909">            <span>return</span> lvaOutgoingArgSpaceSize;</td>
      </tr>
      <tr>
        <td id="L2910" data-line-number="2910"></td>
        <td id="LC2910">
</td>
      </tr>
      <tr>
        <td id="L2911" data-line-number="2911"></td>
        <td id="LC2911">#<span>else</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L2912" data-line-number="2912"></td>
        <td id="LC2912">            <span>assert</span>(!<span><span>"</span>Unknown size<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2913" data-line-number="2913"></td>
        <td id="LC2913">            <span>NO_WAY</span>(<span><span>"</span>Target doesn't support TYP_LCLBLK<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L2914" data-line-number="2914"></td>
        <td id="LC2914">
</td>
      </tr>
      <tr>
        <td id="L2915" data-line-number="2915"></td>
        <td id="LC2915">            <span><span>//</span> Keep prefast happy</span></td>
      </tr>
      <tr>
        <td id="L2916" data-line-number="2916"></td>
        <td id="LC2916">            __fallthrough;</td>
      </tr>
      <tr>
        <td id="L2917" data-line-number="2917"></td>
        <td id="LC2917">
</td>
      </tr>
      <tr>
        <td id="L2918" data-line-number="2918"></td>
        <td id="LC2918">#<span>endif</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L2919" data-line-number="2919"></td>
        <td id="LC2919">
</td>
      </tr>
      <tr>
        <td id="L2920" data-line-number="2920"></td>
        <td id="LC2920">        <span>default</span>: <span><span>//</span> This must be a primitive var. Fall out of switch statement</span></td>
      </tr>
      <tr>
        <td id="L2921" data-line-number="2921"></td>
        <td id="LC2921">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L2922" data-line-number="2922"></td>
        <td id="LC2922">    }</td>
      </tr>
      <tr>
        <td id="L2923" data-line-number="2923"></td>
        <td id="LC2923">
</td>
      </tr>
      <tr>
        <td id="L2924" data-line-number="2924"></td>
        <td id="LC2924">    <span>return</span> <span>genTypeSize</span>(varType);</td>
      </tr>
      <tr>
        <td id="L2925" data-line-number="2925"></td>
        <td id="LC2925">}</td>
      </tr>
      <tr>
        <td id="L2926" data-line-number="2926"></td>
        <td id="LC2926">
</td>
      </tr>
      <tr>
        <td id="L2927" data-line-number="2927"></td>
        <td id="LC2927"><span><span>//</span> getCalledCount -- get the value used to normalized weights for this method</span></td>
      </tr>
      <tr>
        <td id="L2928" data-line-number="2928"></td>
        <td id="LC2928"><span><span>//</span>  if we don't have profile data then getCalledCount will return BB_UNITY_WEIGHT (100)</span></td>
      </tr>
      <tr>
        <td id="L2929" data-line-number="2929"></td>
        <td id="LC2929"><span><span>//</span>  otherwise it returns the number of times that profile data says the method was called.</span></td>
      </tr>
      <tr>
        <td id="L2930" data-line-number="2930"></td>
        <td id="LC2930"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2931" data-line-number="2931"></td>
        <td id="LC2931">BasicBlock::<span>weight_t</span> <span>BasicBlock::getCalledCount</span>(Compiler* comp)</td>
      </tr>
      <tr>
        <td id="L2932" data-line-number="2932"></td>
        <td id="LC2932">{</td>
      </tr>
      <tr>
        <td id="L2933" data-line-number="2933"></td>
        <td id="LC2933">    <span><span>//</span> when we don't have profile data then fgCalledCount will be BB_UNITY_WEIGHT (100)</span></td>
      </tr>
      <tr>
        <td id="L2934" data-line-number="2934"></td>
        <td id="LC2934">    BasicBlock::<span>weight_t</span> calledCount = comp-&gt;<span>fgCalledCount</span>;</td>
      </tr>
      <tr>
        <td id="L2935" data-line-number="2935"></td>
        <td id="LC2935">
</td>
      </tr>
      <tr>
        <td id="L2936" data-line-number="2936"></td>
        <td id="LC2936">    <span><span>//</span> If we haven't yet reach the place where we setup fgCalledCount it could still be zero</span></td>
      </tr>
      <tr>
        <td id="L2937" data-line-number="2937"></td>
        <td id="LC2937">    <span><span>//</span> so return a reasonable value to use until we set it.</span></td>
      </tr>
      <tr>
        <td id="L2938" data-line-number="2938"></td>
        <td id="LC2938">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2939" data-line-number="2939"></td>
        <td id="LC2939">    <span>if</span> (calledCount == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L2940" data-line-number="2940"></td>
        <td id="LC2940">    {</td>
      </tr>
      <tr>
        <td id="L2941" data-line-number="2941"></td>
        <td id="LC2941">        <span>if</span> (comp-&gt;<span>fgIsUsingProfileWeights</span>())</td>
      </tr>
      <tr>
        <td id="L2942" data-line-number="2942"></td>
        <td id="LC2942">        {</td>
      </tr>
      <tr>
        <td id="L2943" data-line-number="2943"></td>
        <td id="LC2943">            <span><span>//</span> When we use profile data block counts we have exact counts,</span></td>
      </tr>
      <tr>
        <td id="L2944" data-line-number="2944"></td>
        <td id="LC2944">            <span><span>//</span> not multiples of BB_UNITY_WEIGHT (100)</span></td>
      </tr>
      <tr>
        <td id="L2945" data-line-number="2945"></td>
        <td id="LC2945">            calledCount = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2946" data-line-number="2946"></td>
        <td id="LC2946">        }</td>
      </tr>
      <tr>
        <td id="L2947" data-line-number="2947"></td>
        <td id="LC2947">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L2948" data-line-number="2948"></td>
        <td id="LC2948">        {</td>
      </tr>
      <tr>
        <td id="L2949" data-line-number="2949"></td>
        <td id="LC2949">            calledCount = comp-&gt;<span>fgFirstBB</span>-&gt;<span>bbWeight</span>;</td>
      </tr>
      <tr>
        <td id="L2950" data-line-number="2950"></td>
        <td id="LC2950">
</td>
      </tr>
      <tr>
        <td id="L2951" data-line-number="2951"></td>
        <td id="LC2951">            <span>if</span> (calledCount == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L2952" data-line-number="2952"></td>
        <td id="LC2952">            {</td>
      </tr>
      <tr>
        <td id="L2953" data-line-number="2953"></td>
        <td id="LC2953">                calledCount = BB_UNITY_WEIGHT;</td>
      </tr>
      <tr>
        <td id="L2954" data-line-number="2954"></td>
        <td id="LC2954">            }</td>
      </tr>
      <tr>
        <td id="L2955" data-line-number="2955"></td>
        <td id="LC2955">        }</td>
      </tr>
      <tr>
        <td id="L2956" data-line-number="2956"></td>
        <td id="LC2956">    }</td>
      </tr>
      <tr>
        <td id="L2957" data-line-number="2957"></td>
        <td id="LC2957">    <span>return</span> calledCount;</td>
      </tr>
      <tr>
        <td id="L2958" data-line-number="2958"></td>
        <td id="LC2958">}</td>
      </tr>
      <tr>
        <td id="L2959" data-line-number="2959"></td>
        <td id="LC2959">
</td>
      </tr>
      <tr>
        <td id="L2960" data-line-number="2960"></td>
        <td id="LC2960"><span><span>//</span> getBBWeight -- get the normalized weight of this block</span></td>
      </tr>
      <tr>
        <td id="L2961" data-line-number="2961"></td>
        <td id="LC2961">BasicBlock::<span>weight_t</span> <span>BasicBlock::getBBWeight</span>(Compiler* comp)</td>
      </tr>
      <tr>
        <td id="L2962" data-line-number="2962"></td>
        <td id="LC2962">{</td>
      </tr>
      <tr>
        <td id="L2963" data-line-number="2963"></td>
        <td id="LC2963">    <span>if</span> (<span>this</span>-&gt;<span>bbWeight</span> == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L2964" data-line-number="2964"></td>
        <td id="LC2964">    {</td>
      </tr>
      <tr>
        <td id="L2965" data-line-number="2965"></td>
        <td id="LC2965">        <span>return</span> <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2966" data-line-number="2966"></td>
        <td id="LC2966">    }</td>
      </tr>
      <tr>
        <td id="L2967" data-line-number="2967"></td>
        <td id="LC2967">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L2968" data-line-number="2968"></td>
        <td id="LC2968">    {</td>
      </tr>
      <tr>
        <td id="L2969" data-line-number="2969"></td>
        <td id="LC2969">        <span>weight_t</span> calledCount = <span>getCalledCount</span>(comp);</td>
      </tr>
      <tr>
        <td id="L2970" data-line-number="2970"></td>
        <td id="LC2970">
</td>
      </tr>
      <tr>
        <td id="L2971" data-line-number="2971"></td>
        <td id="LC2971">        <span><span>//</span> Normalize the bbWeights by multiplying by BB_UNITY_WEIGHT and dividing by the calledCount.</span></td>
      </tr>
      <tr>
        <td id="L2972" data-line-number="2972"></td>
        <td id="LC2972">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2973" data-line-number="2973"></td>
        <td id="LC2973">        <span><span>//</span> 1. For methods that do not have IBC data the called weight will always be 100 (BB_UNITY_WEIGHT)</span></td>
      </tr>
      <tr>
        <td id="L2974" data-line-number="2974"></td>
        <td id="LC2974">        <span><span>//</span>     and the entry point bbWeight value is almost always 100 (BB_UNITY_WEIGHT)</span></td>
      </tr>
      <tr>
        <td id="L2975" data-line-number="2975"></td>
        <td id="LC2975">        <span><span>//</span> 2.  For methods that do have IBC data the called weight is the actual number of calls</span></td>
      </tr>
      <tr>
        <td id="L2976" data-line-number="2976"></td>
        <td id="LC2976">        <span><span>//</span>     from the IBC data and the entry point bbWeight value is almost always the actual</span></td>
      </tr>
      <tr>
        <td id="L2977" data-line-number="2977"></td>
        <td id="LC2977">        <span><span>//</span>     number of calls from the IBC data.</span></td>
      </tr>
      <tr>
        <td id="L2978" data-line-number="2978"></td>
        <td id="LC2978">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2979" data-line-number="2979"></td>
        <td id="LC2979">        <span><span>//</span> "almost always" - except for the rare case where a loop backedge jumps to BB01</span></td>
      </tr>
      <tr>
        <td id="L2980" data-line-number="2980"></td>
        <td id="LC2980">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2981" data-line-number="2981"></td>
        <td id="LC2981">        <span><span>//</span> We also perform a rounding operation by adding half of the 'calledCount' before performing</span></td>
      </tr>
      <tr>
        <td id="L2982" data-line-number="2982"></td>
        <td id="LC2982">        <span><span>//</span> the division.</span></td>
      </tr>
      <tr>
        <td id="L2983" data-line-number="2983"></td>
        <td id="LC2983">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2984" data-line-number="2984"></td>
        <td id="LC2984">        <span><span>//</span> Thus for both cases we will return 100 (BB_UNITY_WEIGHT) for the entry point BasicBlock</span></td>
      </tr>
      <tr>
        <td id="L2985" data-line-number="2985"></td>
        <td id="LC2985">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2986" data-line-number="2986"></td>
        <td id="LC2986">        <span><span>//</span> Note that with a 100 (BB_UNITY_WEIGHT) values between 1 and 99 represent decimal fractions.</span></td>
      </tr>
      <tr>
        <td id="L2987" data-line-number="2987"></td>
        <td id="LC2987">        <span><span>//</span> (i.e. 33 represents 33% and 75 represents 75%, and values greater than 100 require</span></td>
      </tr>
      <tr>
        <td id="L2988" data-line-number="2988"></td>
        <td id="LC2988">        <span><span>//</span>  some kind of loop backedge)</span></td>
      </tr>
      <tr>
        <td id="L2989" data-line-number="2989"></td>
        <td id="LC2989">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2990" data-line-number="2990"></td>
        <td id="LC2990">
</td>
      </tr>
      <tr>
        <td id="L2991" data-line-number="2991"></td>
        <td id="LC2991">        <span>if</span> (<span>this</span>-&gt;<span>bbWeight</span> &lt; (BB_MAX_WEIGHT / BB_UNITY_WEIGHT))</td>
      </tr>
      <tr>
        <td id="L2992" data-line-number="2992"></td>
        <td id="LC2992">        {</td>
      </tr>
      <tr>
        <td id="L2993" data-line-number="2993"></td>
        <td id="LC2993">            <span><span>//</span> Calculate the result using unsigned arithmetic</span></td>
      </tr>
      <tr>
        <td id="L2994" data-line-number="2994"></td>
        <td id="LC2994">            <span>weight_t</span> result = ((<span>this</span>-&gt;<span>bbWeight</span> * BB_UNITY_WEIGHT) + (calledCount / <span>2</span>)) / calledCount;</td>
      </tr>
      <tr>
        <td id="L2995" data-line-number="2995"></td>
        <td id="LC2995">
</td>
      </tr>
      <tr>
        <td id="L2996" data-line-number="2996"></td>
        <td id="LC2996">            <span><span>//</span> We don't allow a value of zero, as that would imply rarely run</span></td>
      </tr>
      <tr>
        <td id="L2997" data-line-number="2997"></td>
        <td id="LC2997">            <span>return</span> <span>max</span>(<span>1</span>, result);</td>
      </tr>
      <tr>
        <td id="L2998" data-line-number="2998"></td>
        <td id="LC2998">        }</td>
      </tr>
      <tr>
        <td id="L2999" data-line-number="2999"></td>
        <td id="LC2999">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L3000" data-line-number="3000"></td>
        <td id="LC3000">        {</td>
      </tr>
      <tr>
        <td id="L3001" data-line-number="3001"></td>
        <td id="LC3001">            <span><span>//</span> Calculate the full result using floating point</span></td>
      </tr>
      <tr>
        <td id="L3002" data-line-number="3002"></td>
        <td id="LC3002">            <span>double</span> fullResult = ((<span>double</span>)<span>this</span>-&gt;<span>bbWeight</span> * (<span>double</span>)BB_UNITY_WEIGHT) / (<span>double</span>)calledCount;</td>
      </tr>
      <tr>
        <td id="L3003" data-line-number="3003"></td>
        <td id="LC3003">
</td>
      </tr>
      <tr>
        <td id="L3004" data-line-number="3004"></td>
        <td id="LC3004">            <span>if</span> (fullResult &lt; (<span>double</span>)BB_MAX_WEIGHT)</td>
      </tr>
      <tr>
        <td id="L3005" data-line-number="3005"></td>
        <td id="LC3005">            {</td>
      </tr>
      <tr>
        <td id="L3006" data-line-number="3006"></td>
        <td id="LC3006">                <span><span>//</span> Add 0.5 and truncate to unsigned</span></td>
      </tr>
      <tr>
        <td id="L3007" data-line-number="3007"></td>
        <td id="LC3007">                <span>return</span> (<span>weight_t</span>)(fullResult + <span>0.5</span>);</td>
      </tr>
      <tr>
        <td id="L3008" data-line-number="3008"></td>
        <td id="LC3008">            }</td>
      </tr>
      <tr>
        <td id="L3009" data-line-number="3009"></td>
        <td id="LC3009">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L3010" data-line-number="3010"></td>
        <td id="LC3010">            {</td>
      </tr>
      <tr>
        <td id="L3011" data-line-number="3011"></td>
        <td id="LC3011">                <span>return</span> BB_MAX_WEIGHT;</td>
      </tr>
      <tr>
        <td id="L3012" data-line-number="3012"></td>
        <td id="LC3012">            }</td>
      </tr>
      <tr>
        <td id="L3013" data-line-number="3013"></td>
        <td id="LC3013">        }</td>
      </tr>
      <tr>
        <td id="L3014" data-line-number="3014"></td>
        <td id="LC3014">    }</td>
      </tr>
      <tr>
        <td id="L3015" data-line-number="3015"></td>
        <td id="LC3015">}</td>
      </tr>
      <tr>
        <td id="L3016" data-line-number="3016"></td>
        <td id="LC3016">
</td>
      </tr>
      <tr>
        <td id="L3017" data-line-number="3017"></td>
        <td id="LC3017"><span><span>//</span> LclVarDsc "less" comparer used to compare the weight of two locals, when optimizing for small code.</span></td>
      </tr>
      <tr>
        <td id="L3018" data-line-number="3018"></td>
        <td id="LC3018"><span>class</span> <span>LclVarDsc_SmallCode_Less</span></td>
      </tr>
      <tr>
        <td id="L3019" data-line-number="3019"></td>
        <td id="LC3019">{</td>
      </tr>
      <tr>
        <td id="L3020" data-line-number="3020"></td>
        <td id="LC3020">    <span>const</span> LclVarDsc* m_lvaTable;</td>
      </tr>
      <tr>
        <td id="L3021" data-line-number="3021"></td>
        <td id="LC3021">    <span>INDEBUG</span>(<span>unsigned</span> m_lvaCount;)</td>
      </tr>
      <tr>
        <td id="L3022" data-line-number="3022"></td>
        <td id="LC3022">
</td>
      </tr>
      <tr>
        <td id="L3023" data-line-number="3023"></td>
        <td id="LC3023"><span>public:</span></td>
      </tr>
      <tr>
        <td id="L3024" data-line-number="3024"></td>
        <td id="LC3024">    <span>LclVarDsc_SmallCode_Less</span>(<span>const</span> LclVarDsc* lvaTable <span>DEBUGARG</span>(<span>unsigned</span> lvaCount))</td>
      </tr>
      <tr>
        <td id="L3025" data-line-number="3025"></td>
        <td id="LC3025">        : m_lvaTable(lvaTable)</td>
      </tr>
      <tr>
        <td id="L3026" data-line-number="3026"></td>
        <td id="LC3026">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L3027" data-line-number="3027"></td>
        <td id="LC3027">        , m_lvaCount(lvaCount)</td>
      </tr>
      <tr>
        <td id="L3028" data-line-number="3028"></td>
        <td id="LC3028">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3029" data-line-number="3029"></td>
        <td id="LC3029">    {</td>
      </tr>
      <tr>
        <td id="L3030" data-line-number="3030"></td>
        <td id="LC3030">    }</td>
      </tr>
      <tr>
        <td id="L3031" data-line-number="3031"></td>
        <td id="LC3031">
</td>
      </tr>
      <tr>
        <td id="L3032" data-line-number="3032"></td>
        <td id="LC3032">    <span>bool</span> <span>operator</span>()(<span>unsigned</span> n1, <span>unsigned</span> n2)</td>
      </tr>
      <tr>
        <td id="L3033" data-line-number="3033"></td>
        <td id="LC3033">    {</td>
      </tr>
      <tr>
        <td id="L3034" data-line-number="3034"></td>
        <td id="LC3034">        <span>assert</span>(n1 &lt; m_lvaCount);</td>
      </tr>
      <tr>
        <td id="L3035" data-line-number="3035"></td>
        <td id="LC3035">        <span>assert</span>(n2 &lt; m_lvaCount);</td>
      </tr>
      <tr>
        <td id="L3036" data-line-number="3036"></td>
        <td id="LC3036">
</td>
      </tr>
      <tr>
        <td id="L3037" data-line-number="3037"></td>
        <td id="LC3037">        <span>const</span> LclVarDsc* dsc1 = &amp;m_lvaTable[n1];</td>
      </tr>
      <tr>
        <td id="L3038" data-line-number="3038"></td>
        <td id="LC3038">        <span>const</span> LclVarDsc* dsc2 = &amp;m_lvaTable[n2];</td>
      </tr>
      <tr>
        <td id="L3039" data-line-number="3039"></td>
        <td id="LC3039">
</td>
      </tr>
      <tr>
        <td id="L3040" data-line-number="3040"></td>
        <td id="LC3040">        <span><span>//</span> We should not be sorting untracked variables</span></td>
      </tr>
      <tr>
        <td id="L3041" data-line-number="3041"></td>
        <td id="LC3041">        <span>assert</span>(dsc1-&gt;<span>lvTracked</span>);</td>
      </tr>
      <tr>
        <td id="L3042" data-line-number="3042"></td>
        <td id="LC3042">        <span>assert</span>(dsc2-&gt;<span>lvTracked</span>);</td>
      </tr>
      <tr>
        <td id="L3043" data-line-number="3043"></td>
        <td id="LC3043">        <span><span>//</span> We should not be sorting after registers have been allocated</span></td>
      </tr>
      <tr>
        <td id="L3044" data-line-number="3044"></td>
        <td id="LC3044">        <span>assert</span>(!dsc1-&gt;<span>lvRegister</span>);</td>
      </tr>
      <tr>
        <td id="L3045" data-line-number="3045"></td>
        <td id="LC3045">        <span>assert</span>(!dsc2-&gt;<span>lvRegister</span>);</td>
      </tr>
      <tr>
        <td id="L3046" data-line-number="3046"></td>
        <td id="LC3046">
</td>
      </tr>
      <tr>
        <td id="L3047" data-line-number="3047"></td>
        <td id="LC3047">        <span>unsigned</span> weight1 = dsc1-&gt;<span>lvRefCnt</span>();</td>
      </tr>
      <tr>
        <td id="L3048" data-line-number="3048"></td>
        <td id="LC3048">        <span>unsigned</span> weight2 = dsc2-&gt;<span>lvRefCnt</span>();</td>
      </tr>
      <tr>
        <td id="L3049" data-line-number="3049"></td>
        <td id="LC3049">
</td>
      </tr>
      <tr>
        <td id="L3050" data-line-number="3050"></td>
        <td id="LC3050">#<span>ifndef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L3051" data-line-number="3051"></td>
        <td id="LC3051">        <span><span>//</span> ARM-TODO: this was disabled for ARM under !FEATURE_FP_REGALLOC; it was probably a left-over from</span></td>
      </tr>
      <tr>
        <td id="L3052" data-line-number="3052"></td>
        <td id="LC3052">        <span><span>//</span> legacy backend. It should be enabled and verified.</span></td>
      </tr>
      <tr>
        <td id="L3053" data-line-number="3053"></td>
        <td id="LC3053">
</td>
      </tr>
      <tr>
        <td id="L3054" data-line-number="3054"></td>
        <td id="LC3054">        <span><span>//</span> Force integer candidates to sort above float candidates.</span></td>
      </tr>
      <tr>
        <td id="L3055" data-line-number="3055"></td>
        <td id="LC3055">        <span>const</span> <span>bool</span> isFloat1 = <span>isFloatRegType</span>(dsc1-&gt;<span>lvType</span>);</td>
      </tr>
      <tr>
        <td id="L3056" data-line-number="3056"></td>
        <td id="LC3056">        <span>const</span> <span>bool</span> isFloat2 = <span>isFloatRegType</span>(dsc2-&gt;<span>lvType</span>);</td>
      </tr>
      <tr>
        <td id="L3057" data-line-number="3057"></td>
        <td id="LC3057">
</td>
      </tr>
      <tr>
        <td id="L3058" data-line-number="3058"></td>
        <td id="LC3058">        <span>if</span> (isFloat1 != isFloat2)</td>
      </tr>
      <tr>
        <td id="L3059" data-line-number="3059"></td>
        <td id="LC3059">        {</td>
      </tr>
      <tr>
        <td id="L3060" data-line-number="3060"></td>
        <td id="LC3060">            <span>if</span> ((weight2 != <span>0</span>) &amp;&amp; isFloat1)</td>
      </tr>
      <tr>
        <td id="L3061" data-line-number="3061"></td>
        <td id="LC3061">            {</td>
      </tr>
      <tr>
        <td id="L3062" data-line-number="3062"></td>
        <td id="LC3062">                <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3063" data-line-number="3063"></td>
        <td id="LC3063">            }</td>
      </tr>
      <tr>
        <td id="L3064" data-line-number="3064"></td>
        <td id="LC3064">
</td>
      </tr>
      <tr>
        <td id="L3065" data-line-number="3065"></td>
        <td id="LC3065">            <span>if</span> ((weight1 != <span>0</span>) &amp;&amp; isFloat2)</td>
      </tr>
      <tr>
        <td id="L3066" data-line-number="3066"></td>
        <td id="LC3066">            {</td>
      </tr>
      <tr>
        <td id="L3067" data-line-number="3067"></td>
        <td id="LC3067">                <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3068" data-line-number="3068"></td>
        <td id="LC3068">            }</td>
      </tr>
      <tr>
        <td id="L3069" data-line-number="3069"></td>
        <td id="LC3069">        }</td>
      </tr>
      <tr>
        <td id="L3070" data-line-number="3070"></td>
        <td id="LC3070">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3071" data-line-number="3071"></td>
        <td id="LC3071">
</td>
      </tr>
      <tr>
        <td id="L3072" data-line-number="3072"></td>
        <td id="LC3072">        <span>if</span> (weight1 != weight2)</td>
      </tr>
      <tr>
        <td id="L3073" data-line-number="3073"></td>
        <td id="LC3073">        {</td>
      </tr>
      <tr>
        <td id="L3074" data-line-number="3074"></td>
        <td id="LC3074">            <span>return</span> weight1 &gt; weight2;</td>
      </tr>
      <tr>
        <td id="L3075" data-line-number="3075"></td>
        <td id="LC3075">        }</td>
      </tr>
      <tr>
        <td id="L3076" data-line-number="3076"></td>
        <td id="LC3076">
</td>
      </tr>
      <tr>
        <td id="L3077" data-line-number="3077"></td>
        <td id="LC3077">        <span><span>//</span> If the weighted ref counts are different then use their difference.</span></td>
      </tr>
      <tr>
        <td id="L3078" data-line-number="3078"></td>
        <td id="LC3078">        <span>if</span> (dsc1-&gt;<span>lvRefCntWtd</span>() != dsc2-&gt;<span>lvRefCntWtd</span>())</td>
      </tr>
      <tr>
        <td id="L3079" data-line-number="3079"></td>
        <td id="LC3079">        {</td>
      </tr>
      <tr>
        <td id="L3080" data-line-number="3080"></td>
        <td id="LC3080">            <span>return</span> dsc1-&gt;<span>lvRefCntWtd</span>() &gt; dsc2-&gt;<span>lvRefCntWtd</span>();</td>
      </tr>
      <tr>
        <td id="L3081" data-line-number="3081"></td>
        <td id="LC3081">        }</td>
      </tr>
      <tr>
        <td id="L3082" data-line-number="3082"></td>
        <td id="LC3082">
</td>
      </tr>
      <tr>
        <td id="L3083" data-line-number="3083"></td>
        <td id="LC3083">        <span><span>//</span> We have equal ref counts and weighted ref counts.</span></td>
      </tr>
      <tr>
        <td id="L3084" data-line-number="3084"></td>
        <td id="LC3084">        <span><span>//</span> Break the tie by:</span></td>
      </tr>
      <tr>
        <td id="L3085" data-line-number="3085"></td>
        <td id="LC3085">        <span><span>//</span>   - Increasing the weight by 2   if we are a register arg.</span></td>
      </tr>
      <tr>
        <td id="L3086" data-line-number="3086"></td>
        <td id="LC3086">        <span><span>//</span>   - Increasing the weight by 0.5 if we are a GC type.</span></td>
      </tr>
      <tr>
        <td id="L3087" data-line-number="3087"></td>
        <td id="LC3087">
</td>
      </tr>
      <tr>
        <td id="L3088" data-line-number="3088"></td>
        <td id="LC3088">        <span>if</span> (weight1 != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3089" data-line-number="3089"></td>
        <td id="LC3089">        {</td>
      </tr>
      <tr>
        <td id="L3090" data-line-number="3090"></td>
        <td id="LC3090">            <span>if</span> (dsc1-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L3091" data-line-number="3091"></td>
        <td id="LC3091">            {</td>
      </tr>
      <tr>
        <td id="L3092" data-line-number="3092"></td>
        <td id="LC3092">                weight2 += <span>2</span> * BB_UNITY_WEIGHT;</td>
      </tr>
      <tr>
        <td id="L3093" data-line-number="3093"></td>
        <td id="LC3093">            }</td>
      </tr>
      <tr>
        <td id="L3094" data-line-number="3094"></td>
        <td id="LC3094">
</td>
      </tr>
      <tr>
        <td id="L3095" data-line-number="3095"></td>
        <td id="LC3095">            <span>if</span> (<span>varTypeIsGC</span>(dsc1-&gt;<span>TypeGet</span>()))</td>
      </tr>
      <tr>
        <td id="L3096" data-line-number="3096"></td>
        <td id="LC3096">            {</td>
      </tr>
      <tr>
        <td id="L3097" data-line-number="3097"></td>
        <td id="LC3097">                weight1 += BB_UNITY_WEIGHT / <span>2</span>;</td>
      </tr>
      <tr>
        <td id="L3098" data-line-number="3098"></td>
        <td id="LC3098">            }</td>
      </tr>
      <tr>
        <td id="L3099" data-line-number="3099"></td>
        <td id="LC3099">        }</td>
      </tr>
      <tr>
        <td id="L3100" data-line-number="3100"></td>
        <td id="LC3100">
</td>
      </tr>
      <tr>
        <td id="L3101" data-line-number="3101"></td>
        <td id="LC3101">        <span>if</span> (weight2 != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3102" data-line-number="3102"></td>
        <td id="LC3102">        {</td>
      </tr>
      <tr>
        <td id="L3103" data-line-number="3103"></td>
        <td id="LC3103">            <span>if</span> (dsc2-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L3104" data-line-number="3104"></td>
        <td id="LC3104">            {</td>
      </tr>
      <tr>
        <td id="L3105" data-line-number="3105"></td>
        <td id="LC3105">                weight2 += <span>2</span> * BB_UNITY_WEIGHT;</td>
      </tr>
      <tr>
        <td id="L3106" data-line-number="3106"></td>
        <td id="LC3106">            }</td>
      </tr>
      <tr>
        <td id="L3107" data-line-number="3107"></td>
        <td id="LC3107">
</td>
      </tr>
      <tr>
        <td id="L3108" data-line-number="3108"></td>
        <td id="LC3108">            <span>if</span> (<span>varTypeIsGC</span>(dsc2-&gt;<span>TypeGet</span>()))</td>
      </tr>
      <tr>
        <td id="L3109" data-line-number="3109"></td>
        <td id="LC3109">            {</td>
      </tr>
      <tr>
        <td id="L3110" data-line-number="3110"></td>
        <td id="LC3110">                weight2 += BB_UNITY_WEIGHT / <span>2</span>;</td>
      </tr>
      <tr>
        <td id="L3111" data-line-number="3111"></td>
        <td id="LC3111">            }</td>
      </tr>
      <tr>
        <td id="L3112" data-line-number="3112"></td>
        <td id="LC3112">        }</td>
      </tr>
      <tr>
        <td id="L3113" data-line-number="3113"></td>
        <td id="LC3113">
</td>
      </tr>
      <tr>
        <td id="L3114" data-line-number="3114"></td>
        <td id="LC3114">        <span>if</span> (weight1 != weight2)</td>
      </tr>
      <tr>
        <td id="L3115" data-line-number="3115"></td>
        <td id="LC3115">        {</td>
      </tr>
      <tr>
        <td id="L3116" data-line-number="3116"></td>
        <td id="LC3116">            <span>return</span> weight1 &gt; weight2;</td>
      </tr>
      <tr>
        <td id="L3117" data-line-number="3117"></td>
        <td id="LC3117">        }</td>
      </tr>
      <tr>
        <td id="L3118" data-line-number="3118"></td>
        <td id="LC3118">
</td>
      </tr>
      <tr>
        <td id="L3119" data-line-number="3119"></td>
        <td id="LC3119">        <span><span>//</span> To achieve a stable sort we use the LclNum (by way of the pointer address).</span></td>
      </tr>
      <tr>
        <td id="L3120" data-line-number="3120"></td>
        <td id="LC3120">        <span>return</span> dsc1 &lt; dsc2;</td>
      </tr>
      <tr>
        <td id="L3121" data-line-number="3121"></td>
        <td id="LC3121">    }</td>
      </tr>
      <tr>
        <td id="L3122" data-line-number="3122"></td>
        <td id="LC3122">};</td>
      </tr>
      <tr>
        <td id="L3123" data-line-number="3123"></td>
        <td id="LC3123">
</td>
      </tr>
      <tr>
        <td id="L3124" data-line-number="3124"></td>
        <td id="LC3124"><span><span>//</span> LclVarDsc "less" comparer used to compare the weight of two locals, when optimizing for blended code.</span></td>
      </tr>
      <tr>
        <td id="L3125" data-line-number="3125"></td>
        <td id="LC3125"><span>class</span> <span>LclVarDsc_BlendedCode_Less</span></td>
      </tr>
      <tr>
        <td id="L3126" data-line-number="3126"></td>
        <td id="LC3126">{</td>
      </tr>
      <tr>
        <td id="L3127" data-line-number="3127"></td>
        <td id="LC3127">    <span>const</span> LclVarDsc* m_lvaTable;</td>
      </tr>
      <tr>
        <td id="L3128" data-line-number="3128"></td>
        <td id="LC3128">    <span>INDEBUG</span>(<span>unsigned</span> m_lvaCount;)</td>
      </tr>
      <tr>
        <td id="L3129" data-line-number="3129"></td>
        <td id="LC3129">
</td>
      </tr>
      <tr>
        <td id="L3130" data-line-number="3130"></td>
        <td id="LC3130"><span>public:</span></td>
      </tr>
      <tr>
        <td id="L3131" data-line-number="3131"></td>
        <td id="LC3131">    <span>LclVarDsc_BlendedCode_Less</span>(<span>const</span> LclVarDsc* lvaTable <span>DEBUGARG</span>(<span>unsigned</span> lvaCount))</td>
      </tr>
      <tr>
        <td id="L3132" data-line-number="3132"></td>
        <td id="LC3132">        : m_lvaTable(lvaTable)</td>
      </tr>
      <tr>
        <td id="L3133" data-line-number="3133"></td>
        <td id="LC3133">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L3134" data-line-number="3134"></td>
        <td id="LC3134">        , m_lvaCount(lvaCount)</td>
      </tr>
      <tr>
        <td id="L3135" data-line-number="3135"></td>
        <td id="LC3135">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3136" data-line-number="3136"></td>
        <td id="LC3136">    {</td>
      </tr>
      <tr>
        <td id="L3137" data-line-number="3137"></td>
        <td id="LC3137">    }</td>
      </tr>
      <tr>
        <td id="L3138" data-line-number="3138"></td>
        <td id="LC3138">
</td>
      </tr>
      <tr>
        <td id="L3139" data-line-number="3139"></td>
        <td id="LC3139">    <span>bool</span> <span>operator</span>()(<span>unsigned</span> n1, <span>unsigned</span> n2)</td>
      </tr>
      <tr>
        <td id="L3140" data-line-number="3140"></td>
        <td id="LC3140">    {</td>
      </tr>
      <tr>
        <td id="L3141" data-line-number="3141"></td>
        <td id="LC3141">        <span>assert</span>(n1 &lt; m_lvaCount);</td>
      </tr>
      <tr>
        <td id="L3142" data-line-number="3142"></td>
        <td id="LC3142">        <span>assert</span>(n2 &lt; m_lvaCount);</td>
      </tr>
      <tr>
        <td id="L3143" data-line-number="3143"></td>
        <td id="LC3143">
</td>
      </tr>
      <tr>
        <td id="L3144" data-line-number="3144"></td>
        <td id="LC3144">        <span>const</span> LclVarDsc* dsc1 = &amp;m_lvaTable[n1];</td>
      </tr>
      <tr>
        <td id="L3145" data-line-number="3145"></td>
        <td id="LC3145">        <span>const</span> LclVarDsc* dsc2 = &amp;m_lvaTable[n2];</td>
      </tr>
      <tr>
        <td id="L3146" data-line-number="3146"></td>
        <td id="LC3146">
</td>
      </tr>
      <tr>
        <td id="L3147" data-line-number="3147"></td>
        <td id="LC3147">        <span><span>//</span> We should not be sorting untracked variables</span></td>
      </tr>
      <tr>
        <td id="L3148" data-line-number="3148"></td>
        <td id="LC3148">        <span>assert</span>(dsc1-&gt;<span>lvTracked</span>);</td>
      </tr>
      <tr>
        <td id="L3149" data-line-number="3149"></td>
        <td id="LC3149">        <span>assert</span>(dsc2-&gt;<span>lvTracked</span>);</td>
      </tr>
      <tr>
        <td id="L3150" data-line-number="3150"></td>
        <td id="LC3150">        <span><span>//</span> We should not be sorting after registers have been allocated</span></td>
      </tr>
      <tr>
        <td id="L3151" data-line-number="3151"></td>
        <td id="LC3151">        <span>assert</span>(!dsc1-&gt;<span>lvRegister</span>);</td>
      </tr>
      <tr>
        <td id="L3152" data-line-number="3152"></td>
        <td id="LC3152">        <span>assert</span>(!dsc2-&gt;<span>lvRegister</span>);</td>
      </tr>
      <tr>
        <td id="L3153" data-line-number="3153"></td>
        <td id="LC3153">
</td>
      </tr>
      <tr>
        <td id="L3154" data-line-number="3154"></td>
        <td id="LC3154">        <span>unsigned</span> weight1 = dsc1-&gt;<span>lvRefCntWtd</span>();</td>
      </tr>
      <tr>
        <td id="L3155" data-line-number="3155"></td>
        <td id="LC3155">        <span>unsigned</span> weight2 = dsc2-&gt;<span>lvRefCntWtd</span>();</td>
      </tr>
      <tr>
        <td id="L3156" data-line-number="3156"></td>
        <td id="LC3156">
</td>
      </tr>
      <tr>
        <td id="L3157" data-line-number="3157"></td>
        <td id="LC3157">#<span>ifndef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L3158" data-line-number="3158"></td>
        <td id="LC3158">        <span><span>//</span> ARM-TODO: this was disabled for ARM under !FEATURE_FP_REGALLOC; it was probably a left-over from</span></td>
      </tr>
      <tr>
        <td id="L3159" data-line-number="3159"></td>
        <td id="LC3159">        <span><span>//</span> legacy backend. It should be enabled and verified.</span></td>
      </tr>
      <tr>
        <td id="L3160" data-line-number="3160"></td>
        <td id="LC3160">
</td>
      </tr>
      <tr>
        <td id="L3161" data-line-number="3161"></td>
        <td id="LC3161">        <span><span>//</span> Force integer candidates to sort above float candidates.</span></td>
      </tr>
      <tr>
        <td id="L3162" data-line-number="3162"></td>
        <td id="LC3162">        <span>const</span> <span>bool</span> isFloat1 = <span>isFloatRegType</span>(dsc1-&gt;<span>lvType</span>);</td>
      </tr>
      <tr>
        <td id="L3163" data-line-number="3163"></td>
        <td id="LC3163">        <span>const</span> <span>bool</span> isFloat2 = <span>isFloatRegType</span>(dsc2-&gt;<span>lvType</span>);</td>
      </tr>
      <tr>
        <td id="L3164" data-line-number="3164"></td>
        <td id="LC3164">
</td>
      </tr>
      <tr>
        <td id="L3165" data-line-number="3165"></td>
        <td id="LC3165">        <span>if</span> (isFloat1 != isFloat2)</td>
      </tr>
      <tr>
        <td id="L3166" data-line-number="3166"></td>
        <td id="LC3166">        {</td>
      </tr>
      <tr>
        <td id="L3167" data-line-number="3167"></td>
        <td id="LC3167">            <span>if</span> ((weight2 != <span>0</span>) &amp;&amp; isFloat1)</td>
      </tr>
      <tr>
        <td id="L3168" data-line-number="3168"></td>
        <td id="LC3168">            {</td>
      </tr>
      <tr>
        <td id="L3169" data-line-number="3169"></td>
        <td id="LC3169">                <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3170" data-line-number="3170"></td>
        <td id="LC3170">            }</td>
      </tr>
      <tr>
        <td id="L3171" data-line-number="3171"></td>
        <td id="LC3171">
</td>
      </tr>
      <tr>
        <td id="L3172" data-line-number="3172"></td>
        <td id="LC3172">            <span>if</span> ((weight1 != <span>0</span>) &amp;&amp; isFloat2)</td>
      </tr>
      <tr>
        <td id="L3173" data-line-number="3173"></td>
        <td id="LC3173">            {</td>
      </tr>
      <tr>
        <td id="L3174" data-line-number="3174"></td>
        <td id="LC3174">                <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3175" data-line-number="3175"></td>
        <td id="LC3175">            }</td>
      </tr>
      <tr>
        <td id="L3176" data-line-number="3176"></td>
        <td id="LC3176">        }</td>
      </tr>
      <tr>
        <td id="L3177" data-line-number="3177"></td>
        <td id="LC3177">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3178" data-line-number="3178"></td>
        <td id="LC3178">
</td>
      </tr>
      <tr>
        <td id="L3179" data-line-number="3179"></td>
        <td id="LC3179">        <span>if</span> ((weight1 != <span>0</span>) &amp;&amp; dsc1-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L3180" data-line-number="3180"></td>
        <td id="LC3180">        {</td>
      </tr>
      <tr>
        <td id="L3181" data-line-number="3181"></td>
        <td id="LC3181">            weight1 += <span>2</span> * BB_UNITY_WEIGHT;</td>
      </tr>
      <tr>
        <td id="L3182" data-line-number="3182"></td>
        <td id="LC3182">        }</td>
      </tr>
      <tr>
        <td id="L3183" data-line-number="3183"></td>
        <td id="LC3183">
</td>
      </tr>
      <tr>
        <td id="L3184" data-line-number="3184"></td>
        <td id="LC3184">        <span>if</span> ((weight2 != <span>0</span>) &amp;&amp; dsc2-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L3185" data-line-number="3185"></td>
        <td id="LC3185">        {</td>
      </tr>
      <tr>
        <td id="L3186" data-line-number="3186"></td>
        <td id="LC3186">            weight2 += <span>2</span> * BB_UNITY_WEIGHT;</td>
      </tr>
      <tr>
        <td id="L3187" data-line-number="3187"></td>
        <td id="LC3187">        }</td>
      </tr>
      <tr>
        <td id="L3188" data-line-number="3188"></td>
        <td id="LC3188">
</td>
      </tr>
      <tr>
        <td id="L3189" data-line-number="3189"></td>
        <td id="LC3189">        <span>if</span> (weight1 != weight2)</td>
      </tr>
      <tr>
        <td id="L3190" data-line-number="3190"></td>
        <td id="LC3190">        {</td>
      </tr>
      <tr>
        <td id="L3191" data-line-number="3191"></td>
        <td id="LC3191">            <span>return</span> weight1 &gt; weight2;</td>
      </tr>
      <tr>
        <td id="L3192" data-line-number="3192"></td>
        <td id="LC3192">        }</td>
      </tr>
      <tr>
        <td id="L3193" data-line-number="3193"></td>
        <td id="LC3193">
</td>
      </tr>
      <tr>
        <td id="L3194" data-line-number="3194"></td>
        <td id="LC3194">        <span><span>//</span> If the weighted ref counts are different then try the unweighted ref counts.</span></td>
      </tr>
      <tr>
        <td id="L3195" data-line-number="3195"></td>
        <td id="LC3195">        <span>if</span> (dsc1-&gt;<span>lvRefCnt</span>() != dsc2-&gt;<span>lvRefCnt</span>())</td>
      </tr>
      <tr>
        <td id="L3196" data-line-number="3196"></td>
        <td id="LC3196">        {</td>
      </tr>
      <tr>
        <td id="L3197" data-line-number="3197"></td>
        <td id="LC3197">            <span>return</span> dsc1-&gt;<span>lvRefCnt</span>() &gt; dsc2-&gt;<span>lvRefCnt</span>();</td>
      </tr>
      <tr>
        <td id="L3198" data-line-number="3198"></td>
        <td id="LC3198">        }</td>
      </tr>
      <tr>
        <td id="L3199" data-line-number="3199"></td>
        <td id="LC3199">
</td>
      </tr>
      <tr>
        <td id="L3200" data-line-number="3200"></td>
        <td id="LC3200">        <span><span>//</span> If one is a GC type and the other is not the GC type wins.</span></td>
      </tr>
      <tr>
        <td id="L3201" data-line-number="3201"></td>
        <td id="LC3201">        <span>if</span> (<span>varTypeIsGC</span>(dsc1-&gt;<span>TypeGet</span>()) != <span>varTypeIsGC</span>(dsc2-&gt;<span>TypeGet</span>()))</td>
      </tr>
      <tr>
        <td id="L3202" data-line-number="3202"></td>
        <td id="LC3202">        {</td>
      </tr>
      <tr>
        <td id="L3203" data-line-number="3203"></td>
        <td id="LC3203">            <span>return</span> <span>varTypeIsGC</span>(dsc1-&gt;<span>TypeGet</span>());</td>
      </tr>
      <tr>
        <td id="L3204" data-line-number="3204"></td>
        <td id="LC3204">        }</td>
      </tr>
      <tr>
        <td id="L3205" data-line-number="3205"></td>
        <td id="LC3205">
</td>
      </tr>
      <tr>
        <td id="L3206" data-line-number="3206"></td>
        <td id="LC3206">        <span><span>//</span> To achieve a stable sort we use the LclNum (by way of the pointer address).</span></td>
      </tr>
      <tr>
        <td id="L3207" data-line-number="3207"></td>
        <td id="LC3207">        <span>return</span> dsc1 &lt; dsc2;</td>
      </tr>
      <tr>
        <td id="L3208" data-line-number="3208"></td>
        <td id="LC3208">    }</td>
      </tr>
      <tr>
        <td id="L3209" data-line-number="3209"></td>
        <td id="LC3209">};</td>
      </tr>
      <tr>
        <td id="L3210" data-line-number="3210"></td>
        <td id="LC3210">
</td>
      </tr>
      <tr>
        <td id="L3211" data-line-number="3211"></td>
        <td id="LC3211"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L3212" data-line-number="3212"></td>
        <td id="LC3212"><span> *</span></td>
      </tr>
      <tr>
        <td id="L3213" data-line-number="3213"></td>
        <td id="LC3213"><span> *  Sort the local variable table by refcount and assign tracking indices.</span></td>
      </tr>
      <tr>
        <td id="L3214" data-line-number="3214"></td>
        <td id="LC3214"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3215" data-line-number="3215"></td>
        <td id="LC3215">
</td>
      </tr>
      <tr>
        <td id="L3216" data-line-number="3216"></td>
        <td id="LC3216"><span>void</span> <span>Compiler::lvaSortByRefCount</span>()</td>
      </tr>
      <tr>
        <td id="L3217" data-line-number="3217"></td>
        <td id="LC3217">{</td>
      </tr>
      <tr>
        <td id="L3218" data-line-number="3218"></td>
        <td id="LC3218">    lvaTrackedCount             = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3219" data-line-number="3219"></td>
        <td id="LC3219">    lvaTrackedCountInSizeTUnits = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3220" data-line-number="3220"></td>
        <td id="LC3220">
</td>
      </tr>
      <tr>
        <td id="L3221" data-line-number="3221"></td>
        <td id="LC3221">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L3222" data-line-number="3222"></td>
        <td id="LC3222">    <span>VarSetOps::AssignNoCopy</span>(<span>this</span>, lvaTrackedVars, <span>VarSetOps::MakeEmpty</span>(<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L3223" data-line-number="3223"></td>
        <td id="LC3223">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3224" data-line-number="3224"></td>
        <td id="LC3224">
</td>
      </tr>
      <tr>
        <td id="L3225" data-line-number="3225"></td>
        <td id="LC3225">    <span>if</span> (lvaCount == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3226" data-line-number="3226"></td>
        <td id="LC3226">    {</td>
      </tr>
      <tr>
        <td id="L3227" data-line-number="3227"></td>
        <td id="LC3227">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L3228" data-line-number="3228"></td>
        <td id="LC3228">    }</td>
      </tr>
      <tr>
        <td id="L3229" data-line-number="3229"></td>
        <td id="LC3229">
</td>
      </tr>
      <tr>
        <td id="L3230" data-line-number="3230"></td>
        <td id="LC3230">    <span><span>/*</span> We'll sort the variables by ref count - allocate the sorted table <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3231" data-line-number="3231"></td>
        <td id="LC3231">
</td>
      </tr>
      <tr>
        <td id="L3232" data-line-number="3232"></td>
        <td id="LC3232">    <span>if</span> (lvaTrackedToVarNumSize &lt; lvaCount)</td>
      </tr>
      <tr>
        <td id="L3233" data-line-number="3233"></td>
        <td id="LC3233">    {</td>
      </tr>
      <tr>
        <td id="L3234" data-line-number="3234"></td>
        <td id="LC3234">        lvaTrackedToVarNumSize = lvaCount;</td>
      </tr>
      <tr>
        <td id="L3235" data-line-number="3235"></td>
        <td id="LC3235">        lvaTrackedToVarNum     = <span>new</span> (<span>getAllocator</span>(CMK_LvaTable)) <span>unsigned</span>[lvaTrackedToVarNumSize];</td>
      </tr>
      <tr>
        <td id="L3236" data-line-number="3236"></td>
        <td id="LC3236">    }</td>
      </tr>
      <tr>
        <td id="L3237" data-line-number="3237"></td>
        <td id="LC3237">
</td>
      </tr>
      <tr>
        <td id="L3238" data-line-number="3238"></td>
        <td id="LC3238">    <span>unsigned</span>  trackedCount = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3239" data-line-number="3239"></td>
        <td id="LC3239">    <span>unsigned</span>* tracked      = lvaTrackedToVarNum;</td>
      </tr>
      <tr>
        <td id="L3240" data-line-number="3240"></td>
        <td id="LC3240">
</td>
      </tr>
      <tr>
        <td id="L3241" data-line-number="3241"></td>
        <td id="LC3241">    <span><span>//</span> Fill in the table used for sorting</span></td>
      </tr>
      <tr>
        <td id="L3242" data-line-number="3242"></td>
        <td id="LC3242">
</td>
      </tr>
      <tr>
        <td id="L3243" data-line-number="3243"></td>
        <td id="LC3243">    <span>for</span> (<span>unsigned</span> lclNum = <span>0</span>; lclNum &lt; lvaCount; lclNum++)</td>
      </tr>
      <tr>
        <td id="L3244" data-line-number="3244"></td>
        <td id="LC3244">    {</td>
      </tr>
      <tr>
        <td id="L3245" data-line-number="3245"></td>
        <td id="LC3245">        LclVarDsc* varDsc = <span>lvaGetDesc</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L3246" data-line-number="3246"></td>
        <td id="LC3246">
</td>
      </tr>
      <tr>
        <td id="L3247" data-line-number="3247"></td>
        <td id="LC3247">        <span><span>//</span> Start by assuming that the variable will be tracked.</span></td>
      </tr>
      <tr>
        <td id="L3248" data-line-number="3248"></td>
        <td id="LC3248">        varDsc-&gt;<span>lvTracked</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L3249" data-line-number="3249"></td>
        <td id="LC3249">
</td>
      </tr>
      <tr>
        <td id="L3250" data-line-number="3250"></td>
        <td id="LC3250">        <span>if</span> (varDsc-&gt;<span>lvRefCnt</span>() == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3251" data-line-number="3251"></td>
        <td id="LC3251">        {</td>
      </tr>
      <tr>
        <td id="L3252" data-line-number="3252"></td>
        <td id="LC3252">            <span><span>//</span> Zero ref count, make this untracked.</span></td>
      </tr>
      <tr>
        <td id="L3253" data-line-number="3253"></td>
        <td id="LC3253">            varDsc-&gt;<span>lvTracked</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3254" data-line-number="3254"></td>
        <td id="LC3254">            varDsc-&gt;<span>setLvRefCntWtd</span>(<span>0</span>);</td>
      </tr>
      <tr>
        <td id="L3255" data-line-number="3255"></td>
        <td id="LC3255">        }</td>
      </tr>
      <tr>
        <td id="L3256" data-line-number="3256"></td>
        <td id="LC3256">
</td>
      </tr>
      <tr>
        <td id="L3257" data-line-number="3257"></td>
        <td id="LC3257">#<span>if</span> !defined(TARGET_64BIT)</td>
      </tr>
      <tr>
        <td id="L3258" data-line-number="3258"></td>
        <td id="LC3258">        <span>if</span> (<span>varTypeIsLong</span>(varDsc) &amp;&amp; varDsc-&gt;<span>lvPromoted</span>)</td>
      </tr>
      <tr>
        <td id="L3259" data-line-number="3259"></td>
        <td id="LC3259">        {</td>
      </tr>
      <tr>
        <td id="L3260" data-line-number="3260"></td>
        <td id="LC3260">            varDsc-&gt;<span>lvTracked</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3261" data-line-number="3261"></td>
        <td id="LC3261">        }</td>
      </tr>
      <tr>
        <td id="L3262" data-line-number="3262"></td>
        <td id="LC3262">#<span>endif</span> <span><span>//</span> !defined(TARGET_64BIT)</span></td>
      </tr>
      <tr>
        <td id="L3263" data-line-number="3263"></td>
        <td id="LC3263">
</td>
      </tr>
      <tr>
        <td id="L3264" data-line-number="3264"></td>
        <td id="LC3264">        <span><span>//</span> Variables that are address-exposed, and all struct locals, are never enregistered, or tracked.</span></td>
      </tr>
      <tr>
        <td id="L3265" data-line-number="3265"></td>
        <td id="LC3265">        <span><span>//</span> (The struct may be promoted, and its field variables enregistered/tracked, or the VM may "normalize"</span></td>
      </tr>
      <tr>
        <td id="L3266" data-line-number="3266"></td>
        <td id="LC3266">        <span><span>//</span> its type so that its not seen by the JIT as a struct.)</span></td>
      </tr>
      <tr>
        <td id="L3267" data-line-number="3267"></td>
        <td id="LC3267">        <span><span>//</span> Pinned variables may not be tracked (a condition of the GCInfo representation)</span></td>
      </tr>
      <tr>
        <td id="L3268" data-line-number="3268"></td>
        <td id="LC3268">        <span><span>//</span> or enregistered, on x86 -- it is believed that we can enregister pinned (more properly, "pinning")</span></td>
      </tr>
      <tr>
        <td id="L3269" data-line-number="3269"></td>
        <td id="LC3269">        <span><span>//</span> references when using the general GC encoding.</span></td>
      </tr>
      <tr>
        <td id="L3270" data-line-number="3270"></td>
        <td id="LC3270">        <span>if</span> (varDsc-&gt;<span>lvAddrExposed</span>)</td>
      </tr>
      <tr>
        <td id="L3271" data-line-number="3271"></td>
        <td id="LC3271">        {</td>
      </tr>
      <tr>
        <td id="L3272" data-line-number="3272"></td>
        <td id="LC3272">            varDsc-&gt;<span>lvTracked</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3273" data-line-number="3273"></td>
        <td id="LC3273">            <span>assert</span>(varDsc-&gt;<span>lvType</span> != TYP_STRUCT ||</td>
      </tr>
      <tr>
        <td id="L3274" data-line-number="3274"></td>
        <td id="LC3274">                   varDsc-&gt;<span>lvDoNotEnregister</span>); <span><span>//</span> For structs, should have set this when we set lvAddrExposed.</span></td>
      </tr>
      <tr>
        <td id="L3275" data-line-number="3275"></td>
        <td id="LC3275">        }</td>
      </tr>
      <tr>
        <td id="L3276" data-line-number="3276"></td>
        <td id="LC3276">        <span>else</span> <span>if</span> (<span>varTypeIsStruct</span>(varDsc))</td>
      </tr>
      <tr>
        <td id="L3277" data-line-number="3277"></td>
        <td id="LC3277">        {</td>
      </tr>
      <tr>
        <td id="L3278" data-line-number="3278"></td>
        <td id="LC3278">            <span><span>//</span> Promoted structs will never be considered for enregistration anyway,</span></td>
      </tr>
      <tr>
        <td id="L3279" data-line-number="3279"></td>
        <td id="LC3279">            <span><span>//</span> and the DoNotEnregister flag was used to indicate whether promotion was</span></td>
      </tr>
      <tr>
        <td id="L3280" data-line-number="3280"></td>
        <td id="LC3280">            <span><span>//</span> independent or dependent.</span></td>
      </tr>
      <tr>
        <td id="L3281" data-line-number="3281"></td>
        <td id="LC3281">            <span>if</span> (varDsc-&gt;<span>lvPromoted</span>)</td>
      </tr>
      <tr>
        <td id="L3282" data-line-number="3282"></td>
        <td id="LC3282">            {</td>
      </tr>
      <tr>
        <td id="L3283" data-line-number="3283"></td>
        <td id="LC3283">                varDsc-&gt;<span>lvTracked</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3284" data-line-number="3284"></td>
        <td id="LC3284">            }</td>
      </tr>
      <tr>
        <td id="L3285" data-line-number="3285"></td>
        <td id="LC3285">            <span>else</span> <span>if</span> ((varDsc-&gt;<span>lvType</span> == TYP_STRUCT) &amp;&amp; !varDsc-&gt;<span>lvRegStruct</span>)</td>
      </tr>
      <tr>
        <td id="L3286" data-line-number="3286"></td>
        <td id="LC3286">            {</td>
      </tr>
      <tr>
        <td id="L3287" data-line-number="3287"></td>
        <td id="LC3287">                <span>lvaSetVarDoNotEnregister</span>(lclNum <span>DEBUGARG</span>(DNER_IsStruct));</td>
      </tr>
      <tr>
        <td id="L3288" data-line-number="3288"></td>
        <td id="LC3288">            }</td>
      </tr>
      <tr>
        <td id="L3289" data-line-number="3289"></td>
        <td id="LC3289">        }</td>
      </tr>
      <tr>
        <td id="L3290" data-line-number="3290"></td>
        <td id="LC3290">        <span>else</span> <span>if</span> (varDsc-&gt;<span>lvIsStructField</span> &amp;&amp; (<span>lvaGetParentPromotionType</span>(lclNum) != PROMOTION_TYPE_INDEPENDENT))</td>
      </tr>
      <tr>
        <td id="L3291" data-line-number="3291"></td>
        <td id="LC3291">        {</td>
      </tr>
      <tr>
        <td id="L3292" data-line-number="3292"></td>
        <td id="LC3292">            <span><span>//</span> SSA must exclude struct fields that are not independently promoted</span></td>
      </tr>
      <tr>
        <td id="L3293" data-line-number="3293"></td>
        <td id="LC3293">            <span><span>//</span> as dependent fields could be assigned using a CopyBlock</span></td>
      </tr>
      <tr>
        <td id="L3294" data-line-number="3294"></td>
        <td id="LC3294">            <span><span>//</span> resulting in a single node causing multiple SSA definitions</span></td>
      </tr>
      <tr>
        <td id="L3295" data-line-number="3295"></td>
        <td id="LC3295">            <span><span>//</span> which isn't currently supported by SSA</span></td>
      </tr>
      <tr>
        <td id="L3296" data-line-number="3296"></td>
        <td id="LC3296">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3297" data-line-number="3297"></td>
        <td id="LC3297">            <span><span>//</span> TODO-CQ:  Consider using lvLclBlockOpAddr and only marking these LclVars</span></td>
      </tr>
      <tr>
        <td id="L3298" data-line-number="3298"></td>
        <td id="LC3298">            <span><span>//</span> untracked when a blockOp is used to assign the struct.</span></td>
      </tr>
      <tr>
        <td id="L3299" data-line-number="3299"></td>
        <td id="LC3299">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3300" data-line-number="3300"></td>
        <td id="LC3300">            varDsc-&gt;<span>lvTracked</span> = <span>0</span>; <span><span>//</span> so, don't mark as tracked</span></td>
      </tr>
      <tr>
        <td id="L3301" data-line-number="3301"></td>
        <td id="LC3301">            <span>lvaSetVarDoNotEnregister</span>(lclNum <span>DEBUGARG</span>(DNER_DepField));</td>
      </tr>
      <tr>
        <td id="L3302" data-line-number="3302"></td>
        <td id="LC3302">        }</td>
      </tr>
      <tr>
        <td id="L3303" data-line-number="3303"></td>
        <td id="LC3303">        <span>else</span> <span>if</span> (varDsc-&gt;<span>lvPinned</span>)</td>
      </tr>
      <tr>
        <td id="L3304" data-line-number="3304"></td>
        <td id="LC3304">        {</td>
      </tr>
      <tr>
        <td id="L3305" data-line-number="3305"></td>
        <td id="LC3305">            varDsc-&gt;<span>lvTracked</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3306" data-line-number="3306"></td>
        <td id="LC3306">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L3307" data-line-number="3307"></td>
        <td id="LC3307">            <span>lvaSetVarDoNotEnregister</span>(lclNum <span>DEBUGARG</span>(DNER_PinningRef));</td>
      </tr>
      <tr>
        <td id="L3308" data-line-number="3308"></td>
        <td id="LC3308">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3309" data-line-number="3309"></td>
        <td id="LC3309">        }</td>
      </tr>
      <tr>
        <td id="L3310" data-line-number="3310"></td>
        <td id="LC3310">        <span>else</span> <span>if</span> (opts.<span>MinOpts</span>() &amp;&amp; !JitConfig.<span>JitMinOptsTrackGCrefs</span>() &amp;&amp; <span>varTypeIsGC</span>(varDsc-&gt;<span>TypeGet</span>()))</td>
      </tr>
      <tr>
        <td id="L3311" data-line-number="3311"></td>
        <td id="LC3311">        {</td>
      </tr>
      <tr>
        <td id="L3312" data-line-number="3312"></td>
        <td id="LC3312">            varDsc-&gt;<span>lvTracked</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3313" data-line-number="3313"></td>
        <td id="LC3313">            <span>lvaSetVarDoNotEnregister</span>(lclNum <span>DEBUGARG</span>(DNER_MinOptsGC));</td>
      </tr>
      <tr>
        <td id="L3314" data-line-number="3314"></td>
        <td id="LC3314">        }</td>
      </tr>
      <tr>
        <td id="L3315" data-line-number="3315"></td>
        <td id="LC3315">        <span>else</span> <span>if</span> ((opts.<span>compFlags</span> &amp; CLFLG_REGVAR) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3316" data-line-number="3316"></td>
        <td id="LC3316">        {</td>
      </tr>
      <tr>
        <td id="L3317" data-line-number="3317"></td>
        <td id="LC3317">            <span>lvaSetVarDoNotEnregister</span>(lclNum <span>DEBUGARG</span>(DNER_NoRegVars));</td>
      </tr>
      <tr>
        <td id="L3318" data-line-number="3318"></td>
        <td id="LC3318">        }</td>
      </tr>
      <tr>
        <td id="L3319" data-line-number="3319"></td>
        <td id="LC3319">#<span>if</span> defined(JIT32_GCENCODER) &amp;&amp; defined(FEATURE_EH_FUNCLETS)</td>
      </tr>
      <tr>
        <td id="L3320" data-line-number="3320"></td>
        <td id="LC3320">        <span>else</span> <span>if</span> (<span>lvaIsOriginalThisArg</span>(lclNum) &amp;&amp; (info.<span>compMethodInfo</span>-&gt;<span>options</span> &amp; CORINFO_GENERICS_CTXT_FROM_THIS) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3321" data-line-number="3321"></td>
        <td id="LC3321">        {</td>
      </tr>
      <tr>
        <td id="L3322" data-line-number="3322"></td>
        <td id="LC3322">            <span><span>//</span> For x86/Linux, we need to track "this".</span></td>
      </tr>
      <tr>
        <td id="L3323" data-line-number="3323"></td>
        <td id="LC3323">            <span><span>//</span> However we cannot have it in tracked variables, so we set "this" pointer always untracked</span></td>
      </tr>
      <tr>
        <td id="L3324" data-line-number="3324"></td>
        <td id="LC3324">            varDsc-&gt;<span>lvTracked</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3325" data-line-number="3325"></td>
        <td id="LC3325">        }</td>
      </tr>
      <tr>
        <td id="L3326" data-line-number="3326"></td>
        <td id="LC3326">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3327" data-line-number="3327"></td>
        <td id="LC3327">
</td>
      </tr>
      <tr>
        <td id="L3328" data-line-number="3328"></td>
        <td id="LC3328">        <span><span>//</span>  Are we not optimizing and we have exception handlers?</span></td>
      </tr>
      <tr>
        <td id="L3329" data-line-number="3329"></td>
        <td id="LC3329">        <span><span>//</span>   if so mark all args and locals "do not enregister".</span></td>
      </tr>
      <tr>
        <td id="L3330" data-line-number="3330"></td>
        <td id="LC3330">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3331" data-line-number="3331"></td>
        <td id="LC3331">        <span>if</span> (opts.<span>MinOpts</span>() &amp;&amp; compHndBBtabCount &gt; <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3332" data-line-number="3332"></td>
        <td id="LC3332">        {</td>
      </tr>
      <tr>
        <td id="L3333" data-line-number="3333"></td>
        <td id="LC3333">            <span>lvaSetVarDoNotEnregister</span>(lclNum <span>DEBUGARG</span>(DNER_LiveInOutOfHandler));</td>
      </tr>
      <tr>
        <td id="L3334" data-line-number="3334"></td>
        <td id="LC3334">        }</td>
      </tr>
      <tr>
        <td id="L3335" data-line-number="3335"></td>
        <td id="LC3335">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L3336" data-line-number="3336"></td>
        <td id="LC3336">        {</td>
      </tr>
      <tr>
        <td id="L3337" data-line-number="3337"></td>
        <td id="LC3337">            var_types type = <span>genActualType</span>(varDsc-&gt;<span>TypeGet</span>());</td>
      </tr>
      <tr>
        <td id="L3338" data-line-number="3338"></td>
        <td id="LC3338">
</td>
      </tr>
      <tr>
        <td id="L3339" data-line-number="3339"></td>
        <td id="LC3339">            <span>switch</span> (type)</td>
      </tr>
      <tr>
        <td id="L3340" data-line-number="3340"></td>
        <td id="LC3340">            {</td>
      </tr>
      <tr>
        <td id="L3341" data-line-number="3341"></td>
        <td id="LC3341">#<span>if</span> CPU_HAS_FP_SUPPORT</td>
      </tr>
      <tr>
        <td id="L3342" data-line-number="3342"></td>
        <td id="LC3342">                <span>case</span> TYP_FLOAT:</td>
      </tr>
      <tr>
        <td id="L3343" data-line-number="3343"></td>
        <td id="LC3343">                <span>case</span> TYP_DOUBLE:</td>
      </tr>
      <tr>
        <td id="L3344" data-line-number="3344"></td>
        <td id="LC3344">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3345" data-line-number="3345"></td>
        <td id="LC3345">                <span>case</span> TYP_INT:</td>
      </tr>
      <tr>
        <td id="L3346" data-line-number="3346"></td>
        <td id="LC3346">                <span>case</span> TYP_LONG:</td>
      </tr>
      <tr>
        <td id="L3347" data-line-number="3347"></td>
        <td id="LC3347">                <span>case</span> TYP_REF:</td>
      </tr>
      <tr>
        <td id="L3348" data-line-number="3348"></td>
        <td id="LC3348">                <span>case</span> TYP_BYREF:</td>
      </tr>
      <tr>
        <td id="L3349" data-line-number="3349"></td>
        <td id="LC3349">#<span>ifdef</span> FEATURE_SIMD</td>
      </tr>
      <tr>
        <td id="L3350" data-line-number="3350"></td>
        <td id="LC3350">                <span>case</span> TYP_SIMD8:</td>
      </tr>
      <tr>
        <td id="L3351" data-line-number="3351"></td>
        <td id="LC3351">                <span>case</span> TYP_SIMD12:</td>
      </tr>
      <tr>
        <td id="L3352" data-line-number="3352"></td>
        <td id="LC3352">                <span>case</span> TYP_SIMD16:</td>
      </tr>
      <tr>
        <td id="L3353" data-line-number="3353"></td>
        <td id="LC3353">                <span>case</span> TYP_SIMD32:</td>
      </tr>
      <tr>
        <td id="L3354" data-line-number="3354"></td>
        <td id="LC3354">#<span>endif</span> <span><span>//</span> FEATURE_SIMD</span></td>
      </tr>
      <tr>
        <td id="L3355" data-line-number="3355"></td>
        <td id="LC3355">                <span>case</span> TYP_STRUCT:</td>
      </tr>
      <tr>
        <td id="L3356" data-line-number="3356"></td>
        <td id="LC3356">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L3357" data-line-number="3357"></td>
        <td id="LC3357">
</td>
      </tr>
      <tr>
        <td id="L3358" data-line-number="3358"></td>
        <td id="LC3358">                <span>case</span> TYP_UNDEF:</td>
      </tr>
      <tr>
        <td id="L3359" data-line-number="3359"></td>
        <td id="LC3359">                <span>case</span> TYP_UNKNOWN:</td>
      </tr>
      <tr>
        <td id="L3360" data-line-number="3360"></td>
        <td id="LC3360">                    <span>noway_assert</span>(!<span><span>"</span>lvType not set correctly<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3361" data-line-number="3361"></td>
        <td id="LC3361">                    varDsc-&gt;<span>lvType</span> = TYP_INT;</td>
      </tr>
      <tr>
        <td id="L3362" data-line-number="3362"></td>
        <td id="LC3362">
</td>
      </tr>
      <tr>
        <td id="L3363" data-line-number="3363"></td>
        <td id="LC3363">                    __fallthrough;</td>
      </tr>
      <tr>
        <td id="L3364" data-line-number="3364"></td>
        <td id="LC3364">
</td>
      </tr>
      <tr>
        <td id="L3365" data-line-number="3365"></td>
        <td id="LC3365">                <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L3366" data-line-number="3366"></td>
        <td id="LC3366">                    varDsc-&gt;<span>lvTracked</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3367" data-line-number="3367"></td>
        <td id="LC3367">            }</td>
      </tr>
      <tr>
        <td id="L3368" data-line-number="3368"></td>
        <td id="LC3368">        }</td>
      </tr>
      <tr>
        <td id="L3369" data-line-number="3369"></td>
        <td id="LC3369">
</td>
      </tr>
      <tr>
        <td id="L3370" data-line-number="3370"></td>
        <td id="LC3370">        <span>if</span> (varDsc-&gt;<span>lvTracked</span>)</td>
      </tr>
      <tr>
        <td id="L3371" data-line-number="3371"></td>
        <td id="LC3371">        {</td>
      </tr>
      <tr>
        <td id="L3372" data-line-number="3372"></td>
        <td id="LC3372">            tracked[trackedCount++] = lclNum;</td>
      </tr>
      <tr>
        <td id="L3373" data-line-number="3373"></td>
        <td id="LC3373">        }</td>
      </tr>
      <tr>
        <td id="L3374" data-line-number="3374"></td>
        <td id="LC3374">    }</td>
      </tr>
      <tr>
        <td id="L3375" data-line-number="3375"></td>
        <td id="LC3375">
</td>
      </tr>
      <tr>
        <td id="L3376" data-line-number="3376"></td>
        <td id="LC3376">    <span><span>//</span> Now sort the tracked variable table by ref-count</span></td>
      </tr>
      <tr>
        <td id="L3377" data-line-number="3377"></td>
        <td id="LC3377">    <span>if</span> (<span>compCodeOpt</span>() == SMALL_CODE)</td>
      </tr>
      <tr>
        <td id="L3378" data-line-number="3378"></td>
        <td id="LC3378">    {</td>
      </tr>
      <tr>
        <td id="L3379" data-line-number="3379"></td>
        <td id="LC3379">        <span>jitstd::sort</span>(tracked, tracked + trackedCount, <span>LclVarDsc_SmallCode_Less</span>(lvaTable <span>DEBUGARG</span>(lvaCount)));</td>
      </tr>
      <tr>
        <td id="L3380" data-line-number="3380"></td>
        <td id="LC3380">    }</td>
      </tr>
      <tr>
        <td id="L3381" data-line-number="3381"></td>
        <td id="LC3381">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L3382" data-line-number="3382"></td>
        <td id="LC3382">    {</td>
      </tr>
      <tr>
        <td id="L3383" data-line-number="3383"></td>
        <td id="LC3383">        <span>jitstd::sort</span>(tracked, tracked + trackedCount, <span>LclVarDsc_BlendedCode_Less</span>(lvaTable <span>DEBUGARG</span>(lvaCount)));</td>
      </tr>
      <tr>
        <td id="L3384" data-line-number="3384"></td>
        <td id="LC3384">    }</td>
      </tr>
      <tr>
        <td id="L3385" data-line-number="3385"></td>
        <td id="LC3385">
</td>
      </tr>
      <tr>
        <td id="L3386" data-line-number="3386"></td>
        <td id="LC3386">    lvaTrackedCount = <span>min</span>(lclMAX_TRACKED, trackedCount);</td>
      </tr>
      <tr>
        <td id="L3387" data-line-number="3387"></td>
        <td id="LC3387">
</td>
      </tr>
      <tr>
        <td id="L3388" data-line-number="3388"></td>
        <td id="LC3388">    <span>JITDUMP</span>(<span><span>"</span>Tracked variable (%u out of %u) table:<span>\n</span><span>"</span></span>, lvaTrackedCount, lvaCount);</td>
      </tr>
      <tr>
        <td id="L3389" data-line-number="3389"></td>
        <td id="LC3389">
</td>
      </tr>
      <tr>
        <td id="L3390" data-line-number="3390"></td>
        <td id="LC3390">    <span><span>//</span> Assign indices to all the variables we've decided to track</span></td>
      </tr>
      <tr>
        <td id="L3391" data-line-number="3391"></td>
        <td id="LC3391">    <span>for</span> (<span>unsigned</span> varIndex = <span>0</span>; varIndex &lt; lvaTrackedCount; varIndex++)</td>
      </tr>
      <tr>
        <td id="L3392" data-line-number="3392"></td>
        <td id="LC3392">    {</td>
      </tr>
      <tr>
        <td id="L3393" data-line-number="3393"></td>
        <td id="LC3393">        LclVarDsc* varDsc = <span>lvaGetDesc</span>(tracked[varIndex]);</td>
      </tr>
      <tr>
        <td id="L3394" data-line-number="3394"></td>
        <td id="LC3394">        <span>assert</span>(varDsc-&gt;<span>lvTracked</span>);</td>
      </tr>
      <tr>
        <td id="L3395" data-line-number="3395"></td>
        <td id="LC3395">        varDsc-&gt;<span>lvVarIndex</span> = <span>static_cast</span>&lt;<span>unsigned</span> <span>short</span>&gt;(varIndex);</td>
      </tr>
      <tr>
        <td id="L3396" data-line-number="3396"></td>
        <td id="LC3396">
</td>
      </tr>
      <tr>
        <td id="L3397" data-line-number="3397"></td>
        <td id="LC3397">        <span>INDEBUG</span>(<span>if</span> (verbose) { <span>gtDispLclVar</span>(tracked[varIndex]); })</td>
      </tr>
      <tr>
        <td id="L3398" data-line-number="3398"></td>
        <td id="LC3398">        <span>JITDUMP</span>(<span><span>"</span> [%6s]: refCnt = %4u, refCntWtd = %6s<span>\n</span><span>"</span></span>, <span>varTypeName</span>(varDsc-&gt;<span>TypeGet</span>()), varDsc-&gt;<span>lvRefCnt</span>(),</td>
      </tr>
      <tr>
        <td id="L3399" data-line-number="3399"></td>
        <td id="LC3399">                <span>refCntWtd2str</span>(varDsc-&gt;<span>lvRefCntWtd</span>()));</td>
      </tr>
      <tr>
        <td id="L3400" data-line-number="3400"></td>
        <td id="LC3400">    }</td>
      </tr>
      <tr>
        <td id="L3401" data-line-number="3401"></td>
        <td id="LC3401">
</td>
      </tr>
      <tr>
        <td id="L3402" data-line-number="3402"></td>
        <td id="LC3402">    <span>JITDUMP</span>(<span><span>"</span><span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3403" data-line-number="3403"></td>
        <td id="LC3403">
</td>
      </tr>
      <tr>
        <td id="L3404" data-line-number="3404"></td>
        <td id="LC3404">    <span><span>//</span> Mark all variables past the first 'lclMAX_TRACKED' as untracked</span></td>
      </tr>
      <tr>
        <td id="L3405" data-line-number="3405"></td>
        <td id="LC3405">    <span>for</span> (<span>unsigned</span> varIndex = lvaTrackedCount; varIndex &lt; trackedCount; varIndex++)</td>
      </tr>
      <tr>
        <td id="L3406" data-line-number="3406"></td>
        <td id="LC3406">    {</td>
      </tr>
      <tr>
        <td id="L3407" data-line-number="3407"></td>
        <td id="LC3407">        LclVarDsc* varDsc = <span>lvaGetDesc</span>(tracked[varIndex]);</td>
      </tr>
      <tr>
        <td id="L3408" data-line-number="3408"></td>
        <td id="LC3408">        <span>assert</span>(varDsc-&gt;<span>lvTracked</span>);</td>
      </tr>
      <tr>
        <td id="L3409" data-line-number="3409"></td>
        <td id="LC3409">        varDsc-&gt;<span>lvTracked</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3410" data-line-number="3410"></td>
        <td id="LC3410">    }</td>
      </tr>
      <tr>
        <td id="L3411" data-line-number="3411"></td>
        <td id="LC3411">
</td>
      </tr>
      <tr>
        <td id="L3412" data-line-number="3412"></td>
        <td id="LC3412">    <span><span>//</span> We have a new epoch, and also cache the tracked var count in terms of size_t's sufficient to hold that many bits.</span></td>
      </tr>
      <tr>
        <td id="L3413" data-line-number="3413"></td>
        <td id="LC3413">    lvaCurEpoch++;</td>
      </tr>
      <tr>
        <td id="L3414" data-line-number="3414"></td>
        <td id="LC3414">    lvaTrackedCountInSizeTUnits =</td>
      </tr>
      <tr>
        <td id="L3415" data-line-number="3415"></td>
        <td id="LC3415">        <span>roundUp</span>((<span>unsigned</span>)lvaTrackedCount, (<span>unsigned</span>)(<span>sizeof</span>(<span>size_t</span>) * <span>8</span>)) / <span>unsigned</span>(<span>sizeof</span>(<span>size_t</span>) * <span>8</span>);</td>
      </tr>
      <tr>
        <td id="L3416" data-line-number="3416"></td>
        <td id="LC3416">
</td>
      </tr>
      <tr>
        <td id="L3417" data-line-number="3417"></td>
        <td id="LC3417">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L3418" data-line-number="3418"></td>
        <td id="LC3418">    <span>VarSetOps::AssignNoCopy</span>(<span>this</span>, lvaTrackedVars, <span>VarSetOps::MakeFull</span>(<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L3419" data-line-number="3419"></td>
        <td id="LC3419">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3420" data-line-number="3420"></td>
        <td id="LC3420">}</td>
      </tr>
      <tr>
        <td id="L3421" data-line-number="3421"></td>
        <td id="LC3421">
</td>
      </tr>
      <tr>
        <td id="L3422" data-line-number="3422"></td>
        <td id="LC3422">#<span>if</span> ASSERTION_PROP</td>
      </tr>
      <tr>
        <td id="L3423" data-line-number="3423"></td>
        <td id="LC3423"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L3424" data-line-number="3424"></td>
        <td id="LC3424"><span> *</span></td>
      </tr>
      <tr>
        <td id="L3425" data-line-number="3425"></td>
        <td id="LC3425"><span> *  This is called by lvaMarkLclRefs to disqualify a variable from being</span></td>
      </tr>
      <tr>
        <td id="L3426" data-line-number="3426"></td>
        <td id="LC3426"><span> *  considered by optAddCopies()</span></td>
      </tr>
      <tr>
        <td id="L3427" data-line-number="3427"></td>
        <td id="LC3427"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3428" data-line-number="3428"></td>
        <td id="LC3428"><span>void</span> <span>LclVarDsc::lvaDisqualifyVar</span>()</td>
      </tr>
      <tr>
        <td id="L3429" data-line-number="3429"></td>
        <td id="LC3429">{</td>
      </tr>
      <tr>
        <td id="L3430" data-line-number="3430"></td>
        <td id="LC3430">    <span>this</span>-&gt;<span>lvDisqualify</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3431" data-line-number="3431"></td>
        <td id="LC3431">    <span>this</span>-&gt;<span>lvSingleDef</span>  = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3432" data-line-number="3432"></td>
        <td id="LC3432">    <span>this</span>-&gt;<span>lvDefStmt</span>    = <span>nullptr</span>;</td>
      </tr>
      <tr>
        <td id="L3433" data-line-number="3433"></td>
        <td id="LC3433">}</td>
      </tr>
      <tr>
        <td id="L3434" data-line-number="3434"></td>
        <td id="LC3434">#<span>endif</span> <span><span>//</span> ASSERTION_PROP</span></td>
      </tr>
      <tr>
        <td id="L3435" data-line-number="3435"></td>
        <td id="LC3435">
</td>
      </tr>
      <tr>
        <td id="L3436" data-line-number="3436"></td>
        <td id="LC3436"><span><span>/*</span>*********************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L3437" data-line-number="3437"></td>
        <td id="LC3437"><span>* Get stack size of the varDsc.</span></td>
      </tr>
      <tr>
        <td id="L3438" data-line-number="3438"></td>
        <td id="LC3438"><span><span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3439" data-line-number="3439"></td>
        <td id="LC3439"><span>size_t</span> <span>LclVarDsc::lvArgStackSize</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L3440" data-line-number="3440"></td>
        <td id="LC3440">{</td>
      </tr>
      <tr>
        <td id="L3441" data-line-number="3441"></td>
        <td id="LC3441">    <span><span>//</span> Make sure this will have a stack size</span></td>
      </tr>
      <tr>
        <td id="L3442" data-line-number="3442"></td>
        <td id="LC3442">    <span>assert</span>(!<span>this</span>-&gt;<span>lvIsRegArg</span>);</td>
      </tr>
      <tr>
        <td id="L3443" data-line-number="3443"></td>
        <td id="LC3443">
</td>
      </tr>
      <tr>
        <td id="L3444" data-line-number="3444"></td>
        <td id="LC3444">    <span>size_t</span> stackSize = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3445" data-line-number="3445"></td>
        <td id="LC3445">    <span>if</span> (<span>varTypeIsStruct</span>(<span>this</span>))</td>
      </tr>
      <tr>
        <td id="L3446" data-line-number="3446"></td>
        <td id="LC3446">    {</td>
      </tr>
      <tr>
        <td id="L3447" data-line-number="3447"></td>
        <td id="LC3447">#<span>if</span> defined(WINDOWS_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L3448" data-line-number="3448"></td>
        <td id="LC3448">        <span><span>//</span> Structs are either passed by reference or can be passed by value using one pointer</span></td>
      </tr>
      <tr>
        <td id="L3449" data-line-number="3449"></td>
        <td id="LC3449">        stackSize = TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L3450" data-line-number="3450"></td>
        <td id="LC3450">#<span>elif</span> defined(TARGET_ARM64) || defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L3451" data-line-number="3451"></td>
        <td id="LC3451">        <span><span>//</span> lvSize performs a roundup.</span></td>
      </tr>
      <tr>
        <td id="L3452" data-line-number="3452"></td>
        <td id="LC3452">        stackSize = <span>this</span>-&gt;<span>lvSize</span>();</td>
      </tr>
      <tr>
        <td id="L3453" data-line-number="3453"></td>
        <td id="LC3453">
</td>
      </tr>
      <tr>
        <td id="L3454" data-line-number="3454"></td>
        <td id="LC3454">#<span>if</span> defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L3455" data-line-number="3455"></td>
        <td id="LC3455">        <span>if</span> ((stackSize &gt; TARGET_POINTER_SIZE * <span>2</span>) &amp;&amp; (!<span>this</span>-&gt;<span>lvIsHfa</span>()))</td>
      </tr>
      <tr>
        <td id="L3456" data-line-number="3456"></td>
        <td id="LC3456">        {</td>
      </tr>
      <tr>
        <td id="L3457" data-line-number="3457"></td>
        <td id="LC3457">            <span><span>//</span> If the size is greater than 16 bytes then it will</span></td>
      </tr>
      <tr>
        <td id="L3458" data-line-number="3458"></td>
        <td id="LC3458">            <span><span>//</span> be passed by reference.</span></td>
      </tr>
      <tr>
        <td id="L3459" data-line-number="3459"></td>
        <td id="LC3459">            stackSize = TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L3460" data-line-number="3460"></td>
        <td id="LC3460">        }</td>
      </tr>
      <tr>
        <td id="L3461" data-line-number="3461"></td>
        <td id="LC3461">#<span>endif</span> <span><span>//</span> defined(TARGET_ARM64)</span></td>
      </tr>
      <tr>
        <td id="L3462" data-line-number="3462"></td>
        <td id="LC3462">
</td>
      </tr>
      <tr>
        <td id="L3463" data-line-number="3463"></td>
        <td id="LC3463">#<span>else</span> <span><span>//</span> !TARGET_ARM64 !WINDOWS_AMD64_ABI !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L3464" data-line-number="3464"></td>
        <td id="LC3464">
</td>
      </tr>
      <tr>
        <td id="L3465" data-line-number="3465"></td>
        <td id="LC3465">        <span>NYI</span>(<span><span>"</span>Unsupported target.<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3466" data-line-number="3466"></td>
        <td id="LC3466">        <span>unreached</span>();</td>
      </tr>
      <tr>
        <td id="L3467" data-line-number="3467"></td>
        <td id="LC3467">
</td>
      </tr>
      <tr>
        <td id="L3468" data-line-number="3468"></td>
        <td id="LC3468">#<span>endif</span> <span><span>//</span>  !TARGET_ARM64 !WINDOWS_AMD64_ABI !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L3469" data-line-number="3469"></td>
        <td id="LC3469">    }</td>
      </tr>
      <tr>
        <td id="L3470" data-line-number="3470"></td>
        <td id="LC3470">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L3471" data-line-number="3471"></td>
        <td id="LC3471">    {</td>
      </tr>
      <tr>
        <td id="L3472" data-line-number="3472"></td>
        <td id="LC3472">        stackSize = TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L3473" data-line-number="3473"></td>
        <td id="LC3473">    }</td>
      </tr>
      <tr>
        <td id="L3474" data-line-number="3474"></td>
        <td id="LC3474">
</td>
      </tr>
      <tr>
        <td id="L3475" data-line-number="3475"></td>
        <td id="LC3475">    <span>return</span> stackSize;</td>
      </tr>
      <tr>
        <td id="L3476" data-line-number="3476"></td>
        <td id="LC3476">}</td>
      </tr>
      <tr>
        <td id="L3477" data-line-number="3477"></td>
        <td id="LC3477">
</td>
      </tr>
      <tr>
        <td id="L3478" data-line-number="3478"></td>
        <td id="LC3478"><span><span>/*</span>*********************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L3479" data-line-number="3479"></td>
        <td id="LC3479"><span>* Get type of a variable when passed as an argument.</span></td>
      </tr>
      <tr>
        <td id="L3480" data-line-number="3480"></td>
        <td id="LC3480"><span><span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3481" data-line-number="3481"></td>
        <td id="LC3481">var_types <span>LclVarDsc::lvaArgType</span>()</td>
      </tr>
      <tr>
        <td id="L3482" data-line-number="3482"></td>
        <td id="LC3482">{</td>
      </tr>
      <tr>
        <td id="L3483" data-line-number="3483"></td>
        <td id="LC3483">    var_types type = <span>TypeGet</span>();</td>
      </tr>
      <tr>
        <td id="L3484" data-line-number="3484"></td>
        <td id="LC3484">
</td>
      </tr>
      <tr>
        <td id="L3485" data-line-number="3485"></td>
        <td id="LC3485">#<span>ifdef</span> TARGET_AMD64</td>
      </tr>
      <tr>
        <td id="L3486" data-line-number="3486"></td>
        <td id="LC3486">#<span>ifdef</span> UNIX_AMD64_ABI</td>
      </tr>
      <tr>
        <td id="L3487" data-line-number="3487"></td>
        <td id="LC3487">    <span>if</span> (type == TYP_STRUCT)</td>
      </tr>
      <tr>
        <td id="L3488" data-line-number="3488"></td>
        <td id="LC3488">    {</td>
      </tr>
      <tr>
        <td id="L3489" data-line-number="3489"></td>
        <td id="LC3489">        <span>NYI</span>(<span><span>"</span>lvaArgType<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3490" data-line-number="3490"></td>
        <td id="LC3490">    }</td>
      </tr>
      <tr>
        <td id="L3491" data-line-number="3491"></td>
        <td id="LC3491">#<span>else</span>  <span><span>//</span>! UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L3492" data-line-number="3492"></td>
        <td id="LC3492">    <span>if</span> (type == TYP_STRUCT)</td>
      </tr>
      <tr>
        <td id="L3493" data-line-number="3493"></td>
        <td id="LC3493">    {</td>
      </tr>
      <tr>
        <td id="L3494" data-line-number="3494"></td>
        <td id="LC3494">        <span>switch</span> (lvExactSize)</td>
      </tr>
      <tr>
        <td id="L3495" data-line-number="3495"></td>
        <td id="LC3495">        {</td>
      </tr>
      <tr>
        <td id="L3496" data-line-number="3496"></td>
        <td id="LC3496">            <span>case</span> <span>1</span>:</td>
      </tr>
      <tr>
        <td id="L3497" data-line-number="3497"></td>
        <td id="LC3497">                type = TYP_BYTE;</td>
      </tr>
      <tr>
        <td id="L3498" data-line-number="3498"></td>
        <td id="LC3498">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L3499" data-line-number="3499"></td>
        <td id="LC3499">            <span>case</span> <span>2</span>:</td>
      </tr>
      <tr>
        <td id="L3500" data-line-number="3500"></td>
        <td id="LC3500">                type = TYP_SHORT;</td>
      </tr>
      <tr>
        <td id="L3501" data-line-number="3501"></td>
        <td id="LC3501">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L3502" data-line-number="3502"></td>
        <td id="LC3502">            <span>case</span> <span>4</span>:</td>
      </tr>
      <tr>
        <td id="L3503" data-line-number="3503"></td>
        <td id="LC3503">                type = TYP_INT;</td>
      </tr>
      <tr>
        <td id="L3504" data-line-number="3504"></td>
        <td id="LC3504">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L3505" data-line-number="3505"></td>
        <td id="LC3505">            <span>case</span> <span>8</span>:</td>
      </tr>
      <tr>
        <td id="L3506" data-line-number="3506"></td>
        <td id="LC3506">                type = m_layout-&gt;<span>GetGCPtrType</span>(<span>0</span>);</td>
      </tr>
      <tr>
        <td id="L3507" data-line-number="3507"></td>
        <td id="LC3507">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L3508" data-line-number="3508"></td>
        <td id="LC3508">            <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L3509" data-line-number="3509"></td>
        <td id="LC3509">                type = TYP_BYREF;</td>
      </tr>
      <tr>
        <td id="L3510" data-line-number="3510"></td>
        <td id="LC3510">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L3511" data-line-number="3511"></td>
        <td id="LC3511">        }</td>
      </tr>
      <tr>
        <td id="L3512" data-line-number="3512"></td>
        <td id="LC3512">    }</td>
      </tr>
      <tr>
        <td id="L3513" data-line-number="3513"></td>
        <td id="LC3513">#<span>endif</span> <span><span>//</span> !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L3514" data-line-number="3514"></td>
        <td id="LC3514">#<span>elif</span> defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L3515" data-line-number="3515"></td>
        <td id="LC3515">    <span>if</span> (type == TYP_STRUCT)</td>
      </tr>
      <tr>
        <td id="L3516" data-line-number="3516"></td>
        <td id="LC3516">    {</td>
      </tr>
      <tr>
        <td id="L3517" data-line-number="3517"></td>
        <td id="LC3517">        <span>NYI</span>(<span><span>"</span>lvaArgType<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3518" data-line-number="3518"></td>
        <td id="LC3518">    }</td>
      </tr>
      <tr>
        <td id="L3519" data-line-number="3519"></td>
        <td id="LC3519">#<span>elif</span> defined(TARGET_X86)</td>
      </tr>
      <tr>
        <td id="L3520" data-line-number="3520"></td>
        <td id="LC3520"><span><span>//</span> Nothing to do; use the type as is.</span></td>
      </tr>
      <tr>
        <td id="L3521" data-line-number="3521"></td>
        <td id="LC3521">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L3522" data-line-number="3522"></td>
        <td id="LC3522">    <span>NYI</span>(<span><span>"</span>lvaArgType<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3523" data-line-number="3523"></td>
        <td id="LC3523">#<span>endif</span> <span><span>//</span> TARGET_AMD64</span></td>
      </tr>
      <tr>
        <td id="L3524" data-line-number="3524"></td>
        <td id="LC3524">
</td>
      </tr>
      <tr>
        <td id="L3525" data-line-number="3525"></td>
        <td id="LC3525">    <span>return</span> type;</td>
      </tr>
      <tr>
        <td id="L3526" data-line-number="3526"></td>
        <td id="LC3526">}</td>
      </tr>
      <tr>
        <td id="L3527" data-line-number="3527"></td>
        <td id="LC3527">
</td>
      </tr>
      <tr>
        <td id="L3528" data-line-number="3528"></td>
        <td id="LC3528"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3529" data-line-number="3529"></td>
        <td id="LC3529"><span><span>//</span> lvaMarkLclRefs: increment local var references counts and more</span></td>
      </tr>
      <tr>
        <td id="L3530" data-line-number="3530"></td>
        <td id="LC3530"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3531" data-line-number="3531"></td>
        <td id="LC3531"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L3532" data-line-number="3532"></td>
        <td id="LC3532"><span><span>//</span>     tree - some node in a tree</span></td>
      </tr>
      <tr>
        <td id="L3533" data-line-number="3533"></td>
        <td id="LC3533"><span><span>//</span>     block - block that the tree node belongs to</span></td>
      </tr>
      <tr>
        <td id="L3534" data-line-number="3534"></td>
        <td id="LC3534"><span><span>//</span>     stmt - stmt that the tree node belongs to</span></td>
      </tr>
      <tr>
        <td id="L3535" data-line-number="3535"></td>
        <td id="LC3535"><span><span>//</span>     isRecompute - true if we should just recompute counts</span></td>
      </tr>
      <tr>
        <td id="L3536" data-line-number="3536"></td>
        <td id="LC3536"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3537" data-line-number="3537"></td>
        <td id="LC3537"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L3538" data-line-number="3538"></td>
        <td id="LC3538"><span><span>//</span>     Invoked via the MarkLocalVarsVisitor</span></td>
      </tr>
      <tr>
        <td id="L3539" data-line-number="3539"></td>
        <td id="LC3539"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3540" data-line-number="3540"></td>
        <td id="LC3540"><span><span>//</span>     Primarily increments the regular and weighted local var ref</span></td>
      </tr>
      <tr>
        <td id="L3541" data-line-number="3541"></td>
        <td id="LC3541"><span><span>//</span>     counts for any local referred to directly by tree.</span></td>
      </tr>
      <tr>
        <td id="L3542" data-line-number="3542"></td>
        <td id="LC3542"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3543" data-line-number="3543"></td>
        <td id="LC3543"><span><span>//</span>     Also:</span></td>
      </tr>
      <tr>
        <td id="L3544" data-line-number="3544"></td>
        <td id="LC3544"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3545" data-line-number="3545"></td>
        <td id="LC3545"><span><span>//</span>     Accounts for implicit references to frame list root for</span></td>
      </tr>
      <tr>
        <td id="L3546" data-line-number="3546"></td>
        <td id="LC3546"><span><span>//</span>     pinvokes that will be expanded later.</span></td>
      </tr>
      <tr>
        <td id="L3547" data-line-number="3547"></td>
        <td id="LC3547"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3548" data-line-number="3548"></td>
        <td id="LC3548"><span><span>//</span>     Determines if locals of TYP_BOOL can safely be considered</span></td>
      </tr>
      <tr>
        <td id="L3549" data-line-number="3549"></td>
        <td id="LC3549"><span><span>//</span>     to hold only 0 or 1 or may have a broader range of true values.</span></td>
      </tr>
      <tr>
        <td id="L3550" data-line-number="3550"></td>
        <td id="LC3550"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3551" data-line-number="3551"></td>
        <td id="LC3551"><span><span>//</span>     Does some setup work for assertion prop, noting locals that are</span></td>
      </tr>
      <tr>
        <td id="L3552" data-line-number="3552"></td>
        <td id="LC3552"><span><span>//</span>     eligible for assertion prop, single defs, and tracking which blocks</span></td>
      </tr>
      <tr>
        <td id="L3553" data-line-number="3553"></td>
        <td id="LC3553"><span><span>//</span>     hold uses.</span></td>
      </tr>
      <tr>
        <td id="L3554" data-line-number="3554"></td>
        <td id="LC3554"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3555" data-line-number="3555"></td>
        <td id="LC3555"><span><span>//</span>     In checked builds:</span></td>
      </tr>
      <tr>
        <td id="L3556" data-line-number="3556"></td>
        <td id="LC3556"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3557" data-line-number="3557"></td>
        <td id="LC3557"><span><span>//</span>     Verifies that local accesses are consistenly typed.</span></td>
      </tr>
      <tr>
        <td id="L3558" data-line-number="3558"></td>
        <td id="LC3558"><span><span>//</span>     Verifies that casts remain in bounds.</span></td>
      </tr>
      <tr>
        <td id="L3559" data-line-number="3559"></td>
        <td id="LC3559">
</td>
      </tr>
      <tr>
        <td id="L3560" data-line-number="3560"></td>
        <td id="LC3560"><span>void</span> <span>Compiler::lvaMarkLclRefs</span>(GenTree* tree, BasicBlock* block, Statement* stmt, <span>bool</span> isRecompute)</td>
      </tr>
      <tr>
        <td id="L3561" data-line-number="3561"></td>
        <td id="LC3561">{</td>
      </tr>
      <tr>
        <td id="L3562" data-line-number="3562"></td>
        <td id="LC3562">    <span>const</span> BasicBlock::<span>weight_t</span> weight = block-&gt;<span>getBBWeight</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3563" data-line-number="3563"></td>
        <td id="LC3563">
</td>
      </tr>
      <tr>
        <td id="L3564" data-line-number="3564"></td>
        <td id="LC3564">    <span><span>/*</span> Is this a call to unmanaged code ? <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3565" data-line-number="3565"></td>
        <td id="LC3565">    <span>if</span> (tree-&gt;<span>IsCall</span>() &amp;&amp; <span>compMethodRequiresPInvokeFrame</span>())</td>
      </tr>
      <tr>
        <td id="L3566" data-line-number="3566"></td>
        <td id="LC3566">    {</td>
      </tr>
      <tr>
        <td id="L3567" data-line-number="3567"></td>
        <td id="LC3567">        <span>assert</span>((!opts.<span>ShouldUsePInvokeHelpers</span>()) || (info.<span>compLvFrameListRoot</span> == BAD_VAR_NUM));</td>
      </tr>
      <tr>
        <td id="L3568" data-line-number="3568"></td>
        <td id="LC3568">        <span>if</span> (!opts.<span>ShouldUsePInvokeHelpers</span>())</td>
      </tr>
      <tr>
        <td id="L3569" data-line-number="3569"></td>
        <td id="LC3569">        {</td>
      </tr>
      <tr>
        <td id="L3570" data-line-number="3570"></td>
        <td id="LC3570">            <span><span>/*</span> Get the special variable descriptor <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3571" data-line-number="3571"></td>
        <td id="LC3571">
</td>
      </tr>
      <tr>
        <td id="L3572" data-line-number="3572"></td>
        <td id="LC3572">            <span>unsigned</span> lclNum = info.<span>compLvFrameListRoot</span>;</td>
      </tr>
      <tr>
        <td id="L3573" data-line-number="3573"></td>
        <td id="LC3573">
</td>
      </tr>
      <tr>
        <td id="L3574" data-line-number="3574"></td>
        <td id="LC3574">            <span>noway_assert</span>(lclNum &lt;= lvaCount);</td>
      </tr>
      <tr>
        <td id="L3575" data-line-number="3575"></td>
        <td id="LC3575">            LclVarDsc* varDsc = lvaTable + lclNum;</td>
      </tr>
      <tr>
        <td id="L3576" data-line-number="3576"></td>
        <td id="LC3576">
</td>
      </tr>
      <tr>
        <td id="L3577" data-line-number="3577"></td>
        <td id="LC3577">            <span><span>/*</span> Increment the ref counts twice <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3578" data-line-number="3578"></td>
        <td id="LC3578">            varDsc-&gt;<span>incRefCnts</span>(weight, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3579" data-line-number="3579"></td>
        <td id="LC3579">            varDsc-&gt;<span>incRefCnts</span>(weight, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3580" data-line-number="3580"></td>
        <td id="LC3580">        }</td>
      </tr>
      <tr>
        <td id="L3581" data-line-number="3581"></td>
        <td id="LC3581">    }</td>
      </tr>
      <tr>
        <td id="L3582" data-line-number="3582"></td>
        <td id="LC3582">
</td>
      </tr>
      <tr>
        <td id="L3583" data-line-number="3583"></td>
        <td id="LC3583">    <span>if</span> (!isRecompute)</td>
      </tr>
      <tr>
        <td id="L3584" data-line-number="3584"></td>
        <td id="LC3584">    {</td>
      </tr>
      <tr>
        <td id="L3585" data-line-number="3585"></td>
        <td id="LC3585">        <span><span>/*</span> Is this an assigment? <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3586" data-line-number="3586"></td>
        <td id="LC3586">
</td>
      </tr>
      <tr>
        <td id="L3587" data-line-number="3587"></td>
        <td id="LC3587">        <span>if</span> (tree-&gt;<span>OperIs</span>(GT_ASG))</td>
      </tr>
      <tr>
        <td id="L3588" data-line-number="3588"></td>
        <td id="LC3588">        {</td>
      </tr>
      <tr>
        <td id="L3589" data-line-number="3589"></td>
        <td id="LC3589">            GenTree* op1 = tree-&gt;<span>AsOp</span>()-&gt;<span>gtOp1</span>;</td>
      </tr>
      <tr>
        <td id="L3590" data-line-number="3590"></td>
        <td id="LC3590">            GenTree* op2 = tree-&gt;<span>AsOp</span>()-&gt;<span>gtOp2</span>;</td>
      </tr>
      <tr>
        <td id="L3591" data-line-number="3591"></td>
        <td id="LC3591">
</td>
      </tr>
      <tr>
        <td id="L3592" data-line-number="3592"></td>
        <td id="LC3592">#<span>if</span> OPT_BOOL_OPS</td>
      </tr>
      <tr>
        <td id="L3593" data-line-number="3593"></td>
        <td id="LC3593">
</td>
      </tr>
      <tr>
        <td id="L3594" data-line-number="3594"></td>
        <td id="LC3594">            <span><span>/*</span> Is this an assignment to a local variable? <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3595" data-line-number="3595"></td>
        <td id="LC3595">
</td>
      </tr>
      <tr>
        <td id="L3596" data-line-number="3596"></td>
        <td id="LC3596">            <span>if</span> (op1-&gt;<span>gtOper</span> == GT_LCL_VAR &amp;&amp; op2-&gt;<span>gtType</span> != TYP_BOOL)</td>
      </tr>
      <tr>
        <td id="L3597" data-line-number="3597"></td>
        <td id="LC3597">            {</td>
      </tr>
      <tr>
        <td id="L3598" data-line-number="3598"></td>
        <td id="LC3598">                <span><span>/*</span> Only simple assignments allowed for booleans <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3599" data-line-number="3599"></td>
        <td id="LC3599">
</td>
      </tr>
      <tr>
        <td id="L3600" data-line-number="3600"></td>
        <td id="LC3600">                <span>if</span> (tree-&gt;<span>gtOper</span> != GT_ASG)</td>
      </tr>
      <tr>
        <td id="L3601" data-line-number="3601"></td>
        <td id="LC3601">                {</td>
      </tr>
      <tr>
        <td id="L3602" data-line-number="3602"></td>
        <td id="LC3602">                    <span>goto</span> NOT_BOOL;</td>
      </tr>
      <tr>
        <td id="L3603" data-line-number="3603"></td>
        <td id="LC3603">                }</td>
      </tr>
      <tr>
        <td id="L3604" data-line-number="3604"></td>
        <td id="LC3604">
</td>
      </tr>
      <tr>
        <td id="L3605" data-line-number="3605"></td>
        <td id="LC3605">                <span><span>/*</span> Is the RHS clearly a boolean value? <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3606" data-line-number="3606"></td>
        <td id="LC3606">
</td>
      </tr>
      <tr>
        <td id="L3607" data-line-number="3607"></td>
        <td id="LC3607">                <span>switch</span> (op2-&gt;<span>gtOper</span>)</td>
      </tr>
      <tr>
        <td id="L3608" data-line-number="3608"></td>
        <td id="LC3608">                {</td>
      </tr>
      <tr>
        <td id="L3609" data-line-number="3609"></td>
        <td id="LC3609">                    <span>unsigned</span> lclNum;</td>
      </tr>
      <tr>
        <td id="L3610" data-line-number="3610"></td>
        <td id="LC3610">
</td>
      </tr>
      <tr>
        <td id="L3611" data-line-number="3611"></td>
        <td id="LC3611">                    <span>case</span> GT_CNS_INT:</td>
      </tr>
      <tr>
        <td id="L3612" data-line-number="3612"></td>
        <td id="LC3612">
</td>
      </tr>
      <tr>
        <td id="L3613" data-line-number="3613"></td>
        <td id="LC3613">                        <span>if</span> (op2-&gt;<span>AsIntCon</span>()-&gt;<span>gtIconVal</span> == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3614" data-line-number="3614"></td>
        <td id="LC3614">                        {</td>
      </tr>
      <tr>
        <td id="L3615" data-line-number="3615"></td>
        <td id="LC3615">                            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L3616" data-line-number="3616"></td>
        <td id="LC3616">                        }</td>
      </tr>
      <tr>
        <td id="L3617" data-line-number="3617"></td>
        <td id="LC3617">                        <span>if</span> (op2-&gt;<span>AsIntCon</span>()-&gt;<span>gtIconVal</span> == <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L3618" data-line-number="3618"></td>
        <td id="LC3618">                        {</td>
      </tr>
      <tr>
        <td id="L3619" data-line-number="3619"></td>
        <td id="LC3619">                            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L3620" data-line-number="3620"></td>
        <td id="LC3620">                        }</td>
      </tr>
      <tr>
        <td id="L3621" data-line-number="3621"></td>
        <td id="LC3621">
</td>
      </tr>
      <tr>
        <td id="L3622" data-line-number="3622"></td>
        <td id="LC3622">                        <span><span>//</span> Not 0 or 1, fall through ....</span></td>
      </tr>
      <tr>
        <td id="L3623" data-line-number="3623"></td>
        <td id="LC3623">                        __fallthrough;</td>
      </tr>
      <tr>
        <td id="L3624" data-line-number="3624"></td>
        <td id="LC3624">
</td>
      </tr>
      <tr>
        <td id="L3625" data-line-number="3625"></td>
        <td id="LC3625">                    <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L3626" data-line-number="3626"></td>
        <td id="LC3626">
</td>
      </tr>
      <tr>
        <td id="L3627" data-line-number="3627"></td>
        <td id="LC3627">                        <span>if</span> (op2-&gt;<span>OperIsCompare</span>())</td>
      </tr>
      <tr>
        <td id="L3628" data-line-number="3628"></td>
        <td id="LC3628">                        {</td>
      </tr>
      <tr>
        <td id="L3629" data-line-number="3629"></td>
        <td id="LC3629">                            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L3630" data-line-number="3630"></td>
        <td id="LC3630">                        }</td>
      </tr>
      <tr>
        <td id="L3631" data-line-number="3631"></td>
        <td id="LC3631">
</td>
      </tr>
      <tr>
        <td id="L3632" data-line-number="3632"></td>
        <td id="LC3632">                    NOT_BOOL:</td>
      </tr>
      <tr>
        <td id="L3633" data-line-number="3633"></td>
        <td id="LC3633">
</td>
      </tr>
      <tr>
        <td id="L3634" data-line-number="3634"></td>
        <td id="LC3634">                        lclNum = op1-&gt;<span>AsLclVarCommon</span>()-&gt;<span>GetLclNum</span>();</td>
      </tr>
      <tr>
        <td id="L3635" data-line-number="3635"></td>
        <td id="LC3635">                        <span>noway_assert</span>(lclNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L3636" data-line-number="3636"></td>
        <td id="LC3636">
</td>
      </tr>
      <tr>
        <td id="L3637" data-line-number="3637"></td>
        <td id="LC3637">                        lvaTable[lclNum].<span>lvIsBoolean</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3638" data-line-number="3638"></td>
        <td id="LC3638">                        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L3639" data-line-number="3639"></td>
        <td id="LC3639">                }</td>
      </tr>
      <tr>
        <td id="L3640" data-line-number="3640"></td>
        <td id="LC3640">            }</td>
      </tr>
      <tr>
        <td id="L3641" data-line-number="3641"></td>
        <td id="LC3641">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3642" data-line-number="3642"></td>
        <td id="LC3642">        }</td>
      </tr>
      <tr>
        <td id="L3643" data-line-number="3643"></td>
        <td id="LC3643">    }</td>
      </tr>
      <tr>
        <td id="L3644" data-line-number="3644"></td>
        <td id="LC3644">
</td>
      </tr>
      <tr>
        <td id="L3645" data-line-number="3645"></td>
        <td id="LC3645">    <span>if</span> (tree-&gt;<span>OperIsLocalAddr</span>())</td>
      </tr>
      <tr>
        <td id="L3646" data-line-number="3646"></td>
        <td id="LC3646">    {</td>
      </tr>
      <tr>
        <td id="L3647" data-line-number="3647"></td>
        <td id="LC3647">        LclVarDsc* varDsc = <span>lvaGetDesc</span>(tree-&gt;<span>AsLclVarCommon</span>());</td>
      </tr>
      <tr>
        <td id="L3648" data-line-number="3648"></td>
        <td id="LC3648">        <span>assert</span>(varDsc-&gt;<span>lvAddrExposed</span>);</td>
      </tr>
      <tr>
        <td id="L3649" data-line-number="3649"></td>
        <td id="LC3649">        varDsc-&gt;<span>incRefCnts</span>(weight, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3650" data-line-number="3650"></td>
        <td id="LC3650">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L3651" data-line-number="3651"></td>
        <td id="LC3651">    }</td>
      </tr>
      <tr>
        <td id="L3652" data-line-number="3652"></td>
        <td id="LC3652">
</td>
      </tr>
      <tr>
        <td id="L3653" data-line-number="3653"></td>
        <td id="LC3653">    <span>if</span> ((tree-&gt;<span>gtOper</span> != GT_LCL_VAR) &amp;&amp; (tree-&gt;<span>gtOper</span> != GT_LCL_FLD))</td>
      </tr>
      <tr>
        <td id="L3654" data-line-number="3654"></td>
        <td id="LC3654">    {</td>
      </tr>
      <tr>
        <td id="L3655" data-line-number="3655"></td>
        <td id="LC3655">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L3656" data-line-number="3656"></td>
        <td id="LC3656">    }</td>
      </tr>
      <tr>
        <td id="L3657" data-line-number="3657"></td>
        <td id="LC3657">
</td>
      </tr>
      <tr>
        <td id="L3658" data-line-number="3658"></td>
        <td id="LC3658">    <span><span>/*</span> This must be a local variable reference <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3659" data-line-number="3659"></td>
        <td id="LC3659">
</td>
      </tr>
      <tr>
        <td id="L3660" data-line-number="3660"></td>
        <td id="LC3660">    <span>assert</span>((tree-&gt;<span>gtOper</span> == GT_LCL_VAR) || (tree-&gt;<span>gtOper</span> == GT_LCL_FLD));</td>
      </tr>
      <tr>
        <td id="L3661" data-line-number="3661"></td>
        <td id="LC3661">    <span>unsigned</span> lclNum = tree-&gt;<span>AsLclVarCommon</span>()-&gt;<span>GetLclNum</span>();</td>
      </tr>
      <tr>
        <td id="L3662" data-line-number="3662"></td>
        <td id="LC3662">
</td>
      </tr>
      <tr>
        <td id="L3663" data-line-number="3663"></td>
        <td id="LC3663">    <span>noway_assert</span>(lclNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L3664" data-line-number="3664"></td>
        <td id="LC3664">    LclVarDsc* varDsc = lvaTable + lclNum;</td>
      </tr>
      <tr>
        <td id="L3665" data-line-number="3665"></td>
        <td id="LC3665">
</td>
      </tr>
      <tr>
        <td id="L3666" data-line-number="3666"></td>
        <td id="LC3666">    <span><span>/*</span> Increment the reference counts <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3667" data-line-number="3667"></td>
        <td id="LC3667">
</td>
      </tr>
      <tr>
        <td id="L3668" data-line-number="3668"></td>
        <td id="LC3668">    varDsc-&gt;<span>incRefCnts</span>(weight, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L3669" data-line-number="3669"></td>
        <td id="LC3669">
</td>
      </tr>
      <tr>
        <td id="L3670" data-line-number="3670"></td>
        <td id="LC3670">    <span>if</span> (!isRecompute)</td>
      </tr>
      <tr>
        <td id="L3671" data-line-number="3671"></td>
        <td id="LC3671">    {</td>
      </tr>
      <tr>
        <td id="L3672" data-line-number="3672"></td>
        <td id="LC3672">        <span>if</span> (<span>lvaVarAddrExposed</span>(lclNum))</td>
      </tr>
      <tr>
        <td id="L3673" data-line-number="3673"></td>
        <td id="LC3673">        {</td>
      </tr>
      <tr>
        <td id="L3674" data-line-number="3674"></td>
        <td id="LC3674">            varDsc-&gt;<span>lvIsBoolean</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3675" data-line-number="3675"></td>
        <td id="LC3675">        }</td>
      </tr>
      <tr>
        <td id="L3676" data-line-number="3676"></td>
        <td id="LC3676">
</td>
      </tr>
      <tr>
        <td id="L3677" data-line-number="3677"></td>
        <td id="LC3677">        <span>if</span> (tree-&gt;<span>gtOper</span> == GT_LCL_FLD)</td>
      </tr>
      <tr>
        <td id="L3678" data-line-number="3678"></td>
        <td id="LC3678">        {</td>
      </tr>
      <tr>
        <td id="L3679" data-line-number="3679"></td>
        <td id="LC3679">#<span>if</span> ASSERTION_PROP</td>
      </tr>
      <tr>
        <td id="L3680" data-line-number="3680"></td>
        <td id="LC3680">            <span><span>//</span> variables that have uses inside a GT_LCL_FLD</span></td>
      </tr>
      <tr>
        <td id="L3681" data-line-number="3681"></td>
        <td id="LC3681">            <span><span>//</span> cause problems, so we will disqualify them here</span></td>
      </tr>
      <tr>
        <td id="L3682" data-line-number="3682"></td>
        <td id="LC3682">            varDsc-&gt;<span>lvaDisqualifyVar</span>();</td>
      </tr>
      <tr>
        <td id="L3683" data-line-number="3683"></td>
        <td id="LC3683">#<span>endif</span> <span><span>//</span> ASSERTION_PROP</span></td>
      </tr>
      <tr>
        <td id="L3684" data-line-number="3684"></td>
        <td id="LC3684">            <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L3685" data-line-number="3685"></td>
        <td id="LC3685">        }</td>
      </tr>
      <tr>
        <td id="L3686" data-line-number="3686"></td>
        <td id="LC3686">
</td>
      </tr>
      <tr>
        <td id="L3687" data-line-number="3687"></td>
        <td id="LC3687">#<span>if</span> ASSERTION_PROP</td>
      </tr>
      <tr>
        <td id="L3688" data-line-number="3688"></td>
        <td id="LC3688">        <span>if</span> (fgDomsComputed &amp;&amp; <span>IsDominatedByExceptionalEntry</span>(block))</td>
      </tr>
      <tr>
        <td id="L3689" data-line-number="3689"></td>
        <td id="LC3689">        {</td>
      </tr>
      <tr>
        <td id="L3690" data-line-number="3690"></td>
        <td id="LC3690">            <span>SetVolatileHint</span>(varDsc);</td>
      </tr>
      <tr>
        <td id="L3691" data-line-number="3691"></td>
        <td id="LC3691">        }</td>
      </tr>
      <tr>
        <td id="L3692" data-line-number="3692"></td>
        <td id="LC3692">
</td>
      </tr>
      <tr>
        <td id="L3693" data-line-number="3693"></td>
        <td id="LC3693">        <span><span>/*</span> Record if the variable has a single def or not <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3694" data-line-number="3694"></td>
        <td id="LC3694">
</td>
      </tr>
      <tr>
        <td id="L3695" data-line-number="3695"></td>
        <td id="LC3695">        <span>if</span> (!varDsc-&gt;<span>lvDisqualify</span>) <span><span>//</span> If this variable is already disqualified we can skip this</span></td>
      </tr>
      <tr>
        <td id="L3696" data-line-number="3696"></td>
        <td id="LC3696">        {</td>
      </tr>
      <tr>
        <td id="L3697" data-line-number="3697"></td>
        <td id="LC3697">            <span>if</span> (tree-&gt;<span>gtFlags</span> &amp; GTF_VAR_DEF) <span><span>//</span> Is this is a def of our variable</span></td>
      </tr>
      <tr>
        <td id="L3698" data-line-number="3698"></td>
        <td id="LC3698">            {</td>
      </tr>
      <tr>
        <td id="L3699" data-line-number="3699"></td>
        <td id="LC3699">                <span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L3700" data-line-number="3700"></td>
        <td id="LC3700"><span>                   If we have one of these cases:</span></td>
      </tr>
      <tr>
        <td id="L3701" data-line-number="3701"></td>
        <td id="LC3701"><span>                       1.    We have already seen a definition (i.e lvSingleDef is true)</span></td>
      </tr>
      <tr>
        <td id="L3702" data-line-number="3702"></td>
        <td id="LC3702"><span>                       2. or info.CompInitMem is true (thus this would be the second definition)</span></td>
      </tr>
      <tr>
        <td id="L3703" data-line-number="3703"></td>
        <td id="LC3703"><span>                       3. or we have an assignment inside QMARK-COLON trees</span></td>
      </tr>
      <tr>
        <td id="L3704" data-line-number="3704"></td>
        <td id="LC3704"><span>                       4. or we have an update form of assignment (i.e. +=, -=, *=)</span></td>
      </tr>
      <tr>
        <td id="L3705" data-line-number="3705"></td>
        <td id="LC3705"><span>                   Then we must disqualify this variable for use in optAddCopies()</span></td>
      </tr>
      <tr>
        <td id="L3706" data-line-number="3706"></td>
        <td id="LC3706"><span></span></td>
      </tr>
      <tr>
        <td id="L3707" data-line-number="3707"></td>
        <td id="LC3707"><span>                   Note that all parameters start out with lvSingleDef set to true</span></td>
      </tr>
      <tr>
        <td id="L3708" data-line-number="3708"></td>
        <td id="LC3708"><span>                <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3709" data-line-number="3709"></td>
        <td id="LC3709">                <span>if</span> ((varDsc-&gt;<span>lvSingleDef</span> == <span>true</span>) || (info.<span>compInitMem</span> == <span>true</span>) || (tree-&gt;<span>gtFlags</span> &amp; GTF_COLON_COND) ||</td>
      </tr>
      <tr>
        <td id="L3710" data-line-number="3710"></td>
        <td id="LC3710">                    (tree-&gt;<span>gtFlags</span> &amp; GTF_VAR_USEASG))</td>
      </tr>
      <tr>
        <td id="L3711" data-line-number="3711"></td>
        <td id="LC3711">                {</td>
      </tr>
      <tr>
        <td id="L3712" data-line-number="3712"></td>
        <td id="LC3712">                    varDsc-&gt;<span>lvaDisqualifyVar</span>();</td>
      </tr>
      <tr>
        <td id="L3713" data-line-number="3713"></td>
        <td id="LC3713">                }</td>
      </tr>
      <tr>
        <td id="L3714" data-line-number="3714"></td>
        <td id="LC3714">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L3715" data-line-number="3715"></td>
        <td id="LC3715">                {</td>
      </tr>
      <tr>
        <td id="L3716" data-line-number="3716"></td>
        <td id="LC3716">                    varDsc-&gt;<span>lvSingleDef</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3717" data-line-number="3717"></td>
        <td id="LC3717">                    varDsc-&gt;<span>lvDefStmt</span>   = stmt;</td>
      </tr>
      <tr>
        <td id="L3718" data-line-number="3718"></td>
        <td id="LC3718">                }</td>
      </tr>
      <tr>
        <td id="L3719" data-line-number="3719"></td>
        <td id="LC3719">            }</td>
      </tr>
      <tr>
        <td id="L3720" data-line-number="3720"></td>
        <td id="LC3720">            <span>else</span> <span><span>//</span> otherwise this is a ref of our variable</span></td>
      </tr>
      <tr>
        <td id="L3721" data-line-number="3721"></td>
        <td id="LC3721">            {</td>
      </tr>
      <tr>
        <td id="L3722" data-line-number="3722"></td>
        <td id="LC3722">                <span>if</span> (<span>BlockSetOps::MayBeUninit</span>(varDsc-&gt;<span>lvRefBlks</span>))</td>
      </tr>
      <tr>
        <td id="L3723" data-line-number="3723"></td>
        <td id="LC3723">                {</td>
      </tr>
      <tr>
        <td id="L3724" data-line-number="3724"></td>
        <td id="LC3724">                    <span><span>//</span> Lazy initialization</span></td>
      </tr>
      <tr>
        <td id="L3725" data-line-number="3725"></td>
        <td id="LC3725">                    <span>BlockSetOps::AssignNoCopy</span>(<span>this</span>, varDsc-&gt;<span>lvRefBlks</span>, <span>BlockSetOps::MakeEmpty</span>(<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L3726" data-line-number="3726"></td>
        <td id="LC3726">                }</td>
      </tr>
      <tr>
        <td id="L3727" data-line-number="3727"></td>
        <td id="LC3727">                <span>BlockSetOps::AddElemD</span>(<span>this</span>, varDsc-&gt;<span>lvRefBlks</span>, block-&gt;<span>bbNum</span>);</td>
      </tr>
      <tr>
        <td id="L3728" data-line-number="3728"></td>
        <td id="LC3728">            }</td>
      </tr>
      <tr>
        <td id="L3729" data-line-number="3729"></td>
        <td id="LC3729">        }</td>
      </tr>
      <tr>
        <td id="L3730" data-line-number="3730"></td>
        <td id="LC3730">#<span>endif</span> <span><span>//</span> ASSERTION_PROP</span></td>
      </tr>
      <tr>
        <td id="L3731" data-line-number="3731"></td>
        <td id="LC3731">
</td>
      </tr>
      <tr>
        <td id="L3732" data-line-number="3732"></td>
        <td id="LC3732">        <span>bool</span> allowStructs = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3733" data-line-number="3733"></td>
        <td id="LC3733">#<span>ifdef</span> UNIX_AMD64_ABI</td>
      </tr>
      <tr>
        <td id="L3734" data-line-number="3734"></td>
        <td id="LC3734">        <span><span>//</span> On System V the type of the var could be a struct type.</span></td>
      </tr>
      <tr>
        <td id="L3735" data-line-number="3735"></td>
        <td id="LC3735">        allowStructs = <span>varTypeIsStruct</span>(varDsc);</td>
      </tr>
      <tr>
        <td id="L3736" data-line-number="3736"></td>
        <td id="LC3736">#<span>endif</span> <span><span>//</span> UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L3737" data-line-number="3737"></td>
        <td id="LC3737">
</td>
      </tr>
      <tr>
        <td id="L3738" data-line-number="3738"></td>
        <td id="LC3738">        <span><span>/*</span> Variables must be used as the same type throughout the method <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3739" data-line-number="3739"></td>
        <td id="LC3739">        <span>noway_assert</span>(tiVerificationNeeded || varDsc-&gt;<span>lvType</span> == TYP_UNDEF || tree-&gt;<span>gtType</span> == TYP_UNKNOWN ||</td>
      </tr>
      <tr>
        <td id="L3740" data-line-number="3740"></td>
        <td id="LC3740">                     allowStructs || <span>genActualType</span>(varDsc-&gt;<span>TypeGet</span>()) == <span>genActualType</span>(tree-&gt;<span>gtType</span>) ||</td>
      </tr>
      <tr>
        <td id="L3741" data-line-number="3741"></td>
        <td id="LC3741">                     (tree-&gt;<span>gtType</span> == TYP_BYREF &amp;&amp; varDsc-&gt;<span>TypeGet</span>() == TYP_I_IMPL) ||</td>
      </tr>
      <tr>
        <td id="L3742" data-line-number="3742"></td>
        <td id="LC3742">                     (tree-&gt;<span>gtType</span> == TYP_I_IMPL &amp;&amp; varDsc-&gt;<span>TypeGet</span>() == TYP_BYREF) || (tree-&gt;<span>gtFlags</span> &amp; GTF_VAR_CAST) ||</td>
      </tr>
      <tr>
        <td id="L3743" data-line-number="3743"></td>
        <td id="LC3743">                     <span>varTypeIsFloating</span>(varDsc-&gt;<span>TypeGet</span>()) &amp;&amp; <span>varTypeIsFloating</span>(tree-&gt;<span>gtType</span>));</td>
      </tr>
      <tr>
        <td id="L3744" data-line-number="3744"></td>
        <td id="LC3744">
</td>
      </tr>
      <tr>
        <td id="L3745" data-line-number="3745"></td>
        <td id="LC3745">        <span><span>/*</span> Remember the type of the reference <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3746" data-line-number="3746"></td>
        <td id="LC3746">
</td>
      </tr>
      <tr>
        <td id="L3747" data-line-number="3747"></td>
        <td id="LC3747">        <span>if</span> (tree-&gt;<span>gtType</span> == TYP_UNKNOWN || varDsc-&gt;<span>lvType</span> == TYP_UNDEF)</td>
      </tr>
      <tr>
        <td id="L3748" data-line-number="3748"></td>
        <td id="LC3748">        {</td>
      </tr>
      <tr>
        <td id="L3749" data-line-number="3749"></td>
        <td id="LC3749">            varDsc-&gt;<span>lvType</span> = tree-&gt;<span>gtType</span>;</td>
      </tr>
      <tr>
        <td id="L3750" data-line-number="3750"></td>
        <td id="LC3750">            <span>noway_assert</span>(<span>genActualType</span>(varDsc-&gt;<span>TypeGet</span>()) == tree-&gt;<span>gtType</span>); <span><span>//</span> no truncation</span></td>
      </tr>
      <tr>
        <td id="L3751" data-line-number="3751"></td>
        <td id="LC3751">        }</td>
      </tr>
      <tr>
        <td id="L3752" data-line-number="3752"></td>
        <td id="LC3752">
</td>
      </tr>
      <tr>
        <td id="L3753" data-line-number="3753"></td>
        <td id="LC3753">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L3754" data-line-number="3754"></td>
        <td id="LC3754">        <span>if</span> (tree-&gt;<span>gtFlags</span> &amp; GTF_VAR_CAST)</td>
      </tr>
      <tr>
        <td id="L3755" data-line-number="3755"></td>
        <td id="LC3755">        {</td>
      </tr>
      <tr>
        <td id="L3756" data-line-number="3756"></td>
        <td id="LC3756">            <span><span>//</span> it should never be bigger than the variable slot</span></td>
      </tr>
      <tr>
        <td id="L3757" data-line-number="3757"></td>
        <td id="LC3757">
</td>
      </tr>
      <tr>
        <td id="L3758" data-line-number="3758"></td>
        <td id="LC3758">            <span><span>//</span> Trees don't store the full information about structs</span></td>
      </tr>
      <tr>
        <td id="L3759" data-line-number="3759"></td>
        <td id="LC3759">            <span><span>//</span> so we can't check them.</span></td>
      </tr>
      <tr>
        <td id="L3760" data-line-number="3760"></td>
        <td id="LC3760">            <span>if</span> (tree-&gt;<span>TypeGet</span>() != TYP_STRUCT)</td>
      </tr>
      <tr>
        <td id="L3761" data-line-number="3761"></td>
        <td id="LC3761">            {</td>
      </tr>
      <tr>
        <td id="L3762" data-line-number="3762"></td>
        <td id="LC3762">                <span>unsigned</span> treeSize = <span>genTypeSize</span>(tree-&gt;<span>TypeGet</span>());</td>
      </tr>
      <tr>
        <td id="L3763" data-line-number="3763"></td>
        <td id="LC3763">                <span>unsigned</span> varSize  = <span>genTypeSize</span>(varDsc-&gt;<span>TypeGet</span>());</td>
      </tr>
      <tr>
        <td id="L3764" data-line-number="3764"></td>
        <td id="LC3764">                <span>if</span> (varDsc-&gt;<span>TypeGet</span>() == TYP_STRUCT)</td>
      </tr>
      <tr>
        <td id="L3765" data-line-number="3765"></td>
        <td id="LC3765">                {</td>
      </tr>
      <tr>
        <td id="L3766" data-line-number="3766"></td>
        <td id="LC3766">                    varSize = varDsc-&gt;<span>lvSize</span>();</td>
      </tr>
      <tr>
        <td id="L3767" data-line-number="3767"></td>
        <td id="LC3767">                }</td>
      </tr>
      <tr>
        <td id="L3768" data-line-number="3768"></td>
        <td id="LC3768">
</td>
      </tr>
      <tr>
        <td id="L3769" data-line-number="3769"></td>
        <td id="LC3769">                <span>assert</span>(treeSize &lt;= varSize);</td>
      </tr>
      <tr>
        <td id="L3770" data-line-number="3770"></td>
        <td id="LC3770">            }</td>
      </tr>
      <tr>
        <td id="L3771" data-line-number="3771"></td>
        <td id="LC3771">        }</td>
      </tr>
      <tr>
        <td id="L3772" data-line-number="3772"></td>
        <td id="LC3772">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3773" data-line-number="3773"></td>
        <td id="LC3773">    }</td>
      </tr>
      <tr>
        <td id="L3774" data-line-number="3774"></td>
        <td id="LC3774">}</td>
      </tr>
      <tr>
        <td id="L3775" data-line-number="3775"></td>
        <td id="LC3775">
</td>
      </tr>
      <tr>
        <td id="L3776" data-line-number="3776"></td>
        <td id="LC3776"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3777" data-line-number="3777"></td>
        <td id="LC3777"><span><span>//</span> IsDominatedByExceptionalEntry: Check is the block dominated by an exception entry block.</span></td>
      </tr>
      <tr>
        <td id="L3778" data-line-number="3778"></td>
        <td id="LC3778"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3779" data-line-number="3779"></td>
        <td id="LC3779"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L3780" data-line-number="3780"></td>
        <td id="LC3780"><span><span>//</span>    block - the checking block.</span></td>
      </tr>
      <tr>
        <td id="L3781" data-line-number="3781"></td>
        <td id="LC3781"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3782" data-line-number="3782"></td>
        <td id="LC3782"><span>bool</span> <span>Compiler::IsDominatedByExceptionalEntry</span>(BasicBlock* block)</td>
      </tr>
      <tr>
        <td id="L3783" data-line-number="3783"></td>
        <td id="LC3783">{</td>
      </tr>
      <tr>
        <td id="L3784" data-line-number="3784"></td>
        <td id="LC3784">    <span>assert</span>(fgDomsComputed);</td>
      </tr>
      <tr>
        <td id="L3785" data-line-number="3785"></td>
        <td id="LC3785">    <span>return</span> block-&gt;<span>IsDominatedByExceptionalEntryFlag</span>();</td>
      </tr>
      <tr>
        <td id="L3786" data-line-number="3786"></td>
        <td id="LC3786">}</td>
      </tr>
      <tr>
        <td id="L3787" data-line-number="3787"></td>
        <td id="LC3787">
</td>
      </tr>
      <tr>
        <td id="L3788" data-line-number="3788"></td>
        <td id="LC3788"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3789" data-line-number="3789"></td>
        <td id="LC3789"><span><span>//</span> SetVolatileHint: Set a local var's volatile hint.</span></td>
      </tr>
      <tr>
        <td id="L3790" data-line-number="3790"></td>
        <td id="LC3790"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3791" data-line-number="3791"></td>
        <td id="LC3791"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L3792" data-line-number="3792"></td>
        <td id="LC3792"><span><span>//</span>    varDsc - the local variable that needs the hint.</span></td>
      </tr>
      <tr>
        <td id="L3793" data-line-number="3793"></td>
        <td id="LC3793"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3794" data-line-number="3794"></td>
        <td id="LC3794"><span>void</span> <span>Compiler::SetVolatileHint</span>(LclVarDsc* varDsc)</td>
      </tr>
      <tr>
        <td id="L3795" data-line-number="3795"></td>
        <td id="LC3795">{</td>
      </tr>
      <tr>
        <td id="L3796" data-line-number="3796"></td>
        <td id="LC3796">    varDsc-&gt;<span>lvVolatileHint</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3797" data-line-number="3797"></td>
        <td id="LC3797">}</td>
      </tr>
      <tr>
        <td id="L3798" data-line-number="3798"></td>
        <td id="LC3798">
</td>
      </tr>
      <tr>
        <td id="L3799" data-line-number="3799"></td>
        <td id="LC3799"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3800" data-line-number="3800"></td>
        <td id="LC3800"><span><span>//</span> lvaMarkLocalVars: update local var ref counts for IR in a basic block</span></td>
      </tr>
      <tr>
        <td id="L3801" data-line-number="3801"></td>
        <td id="LC3801"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3802" data-line-number="3802"></td>
        <td id="LC3802"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L3803" data-line-number="3803"></td>
        <td id="LC3803"><span><span>//</span>    block - the block in question</span></td>
      </tr>
      <tr>
        <td id="L3804" data-line-number="3804"></td>
        <td id="LC3804"><span><span>//</span>    isRecompute - true if counts are being recomputed</span></td>
      </tr>
      <tr>
        <td id="L3805" data-line-number="3805"></td>
        <td id="LC3805"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3806" data-line-number="3806"></td>
        <td id="LC3806"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L3807" data-line-number="3807"></td>
        <td id="LC3807"><span><span>//</span>    Invokes lvaMarkLclRefs on each tree node for each</span></td>
      </tr>
      <tr>
        <td id="L3808" data-line-number="3808"></td>
        <td id="LC3808"><span><span>//</span>    statement in the block.</span></td>
      </tr>
      <tr>
        <td id="L3809" data-line-number="3809"></td>
        <td id="LC3809">
</td>
      </tr>
      <tr>
        <td id="L3810" data-line-number="3810"></td>
        <td id="LC3810"><span>void</span> <span>Compiler::lvaMarkLocalVars</span>(BasicBlock* block, <span>bool</span> isRecompute)</td>
      </tr>
      <tr>
        <td id="L3811" data-line-number="3811"></td>
        <td id="LC3811">{</td>
      </tr>
      <tr>
        <td id="L3812" data-line-number="3812"></td>
        <td id="LC3812">    <span>class</span> <span>MarkLocalVarsVisitor</span> final : public GenTreeVisitor&lt;MarkLocalVarsVisitor&gt;</td>
      </tr>
      <tr>
        <td id="L3813" data-line-number="3813"></td>
        <td id="LC3813">    {</td>
      </tr>
      <tr>
        <td id="L3814" data-line-number="3814"></td>
        <td id="LC3814">    <span>private:</span></td>
      </tr>
      <tr>
        <td id="L3815" data-line-number="3815"></td>
        <td id="LC3815">        BasicBlock* m_block;</td>
      </tr>
      <tr>
        <td id="L3816" data-line-number="3816"></td>
        <td id="LC3816">        Statement*  m_stmt;</td>
      </tr>
      <tr>
        <td id="L3817" data-line-number="3817"></td>
        <td id="LC3817">        <span>bool</span>        m_isRecompute;</td>
      </tr>
      <tr>
        <td id="L3818" data-line-number="3818"></td>
        <td id="LC3818">
</td>
      </tr>
      <tr>
        <td id="L3819" data-line-number="3819"></td>
        <td id="LC3819">    <span>public:</span></td>
      </tr>
      <tr>
        <td id="L3820" data-line-number="3820"></td>
        <td id="LC3820">        <span>enum</span></td>
      </tr>
      <tr>
        <td id="L3821" data-line-number="3821"></td>
        <td id="LC3821">        {</td>
      </tr>
      <tr>
        <td id="L3822" data-line-number="3822"></td>
        <td id="LC3822">            DoPreOrder = <span>true</span>,</td>
      </tr>
      <tr>
        <td id="L3823" data-line-number="3823"></td>
        <td id="LC3823">        };</td>
      </tr>
      <tr>
        <td id="L3824" data-line-number="3824"></td>
        <td id="LC3824">
</td>
      </tr>
      <tr>
        <td id="L3825" data-line-number="3825"></td>
        <td id="LC3825">        <span>MarkLocalVarsVisitor</span>(Compiler* compiler, BasicBlock* block, Statement* stmt, <span>bool</span> isRecompute)</td>
      </tr>
      <tr>
        <td id="L3826" data-line-number="3826"></td>
        <td id="LC3826">            : GenTreeVisitor&lt;MarkLocalVarsVisitor&gt;(compiler), m_block(block), m_stmt(stmt), m_isRecompute(isRecompute)</td>
      </tr>
      <tr>
        <td id="L3827" data-line-number="3827"></td>
        <td id="LC3827">        {</td>
      </tr>
      <tr>
        <td id="L3828" data-line-number="3828"></td>
        <td id="LC3828">        }</td>
      </tr>
      <tr>
        <td id="L3829" data-line-number="3829"></td>
        <td id="LC3829">
</td>
      </tr>
      <tr>
        <td id="L3830" data-line-number="3830"></td>
        <td id="LC3830">        Compiler::fgWalkResult <span>PreOrderVisit</span>(GenTree** use, GenTree* user)</td>
      </tr>
      <tr>
        <td id="L3831" data-line-number="3831"></td>
        <td id="LC3831">        {</td>
      </tr>
      <tr>
        <td id="L3832" data-line-number="3832"></td>
        <td id="LC3832">            m_compiler-&gt;<span>lvaMarkLclRefs</span>(*use, m_block, m_stmt, m_isRecompute);</td>
      </tr>
      <tr>
        <td id="L3833" data-line-number="3833"></td>
        <td id="LC3833">            <span>return</span> WALK_CONTINUE;</td>
      </tr>
      <tr>
        <td id="L3834" data-line-number="3834"></td>
        <td id="LC3834">        }</td>
      </tr>
      <tr>
        <td id="L3835" data-line-number="3835"></td>
        <td id="LC3835">    };</td>
      </tr>
      <tr>
        <td id="L3836" data-line-number="3836"></td>
        <td id="LC3836">
</td>
      </tr>
      <tr>
        <td id="L3837" data-line-number="3837"></td>
        <td id="LC3837">    <span>JITDUMP</span>(<span><span>"</span><span>\n</span>*** %s local variables in block <span>"</span></span> FMT_BB <span><span>"</span> (weight=%s)<span>\n</span><span>"</span></span>, isRecompute ? <span><span>"</span>recomputing<span>"</span></span> : <span><span>"</span>marking<span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L3838" data-line-number="3838"></td>
        <td id="LC3838">            block-&gt;<span>bbNum</span>, <span>refCntWtd2str</span>(block-&gt;<span>getBBWeight</span>(<span>this</span>)));</td>
      </tr>
      <tr>
        <td id="L3839" data-line-number="3839"></td>
        <td id="LC3839">
</td>
      </tr>
      <tr>
        <td id="L3840" data-line-number="3840"></td>
        <td id="LC3840">    <span>for</span> (Statement* stmt : <span>StatementList</span>(block-&gt;<span>FirstNonPhiDef</span>()))</td>
      </tr>
      <tr>
        <td id="L3841" data-line-number="3841"></td>
        <td id="LC3841">    {</td>
      </tr>
      <tr>
        <td id="L3842" data-line-number="3842"></td>
        <td id="LC3842">        MarkLocalVarsVisitor <span>visitor</span>(<span>this</span>, block, stmt, isRecompute);</td>
      </tr>
      <tr>
        <td id="L3843" data-line-number="3843"></td>
        <td id="LC3843">        <span>DISPSTMT</span>(stmt);</td>
      </tr>
      <tr>
        <td id="L3844" data-line-number="3844"></td>
        <td id="LC3844">        visitor.<span>WalkTree</span>(stmt-&gt;<span>GetRootNodePointer</span>(), <span>nullptr</span>);</td>
      </tr>
      <tr>
        <td id="L3845" data-line-number="3845"></td>
        <td id="LC3845">    }</td>
      </tr>
      <tr>
        <td id="L3846" data-line-number="3846"></td>
        <td id="LC3846">}</td>
      </tr>
      <tr>
        <td id="L3847" data-line-number="3847"></td>
        <td id="LC3847">
</td>
      </tr>
      <tr>
        <td id="L3848" data-line-number="3848"></td>
        <td id="LC3848"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3849" data-line-number="3849"></td>
        <td id="LC3849"><span><span>//</span> lvaMarkLocalVars: enable normal ref counting, compute initial counts, sort locals table</span></td>
      </tr>
      <tr>
        <td id="L3850" data-line-number="3850"></td>
        <td id="LC3850"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3851" data-line-number="3851"></td>
        <td id="LC3851"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L3852" data-line-number="3852"></td>
        <td id="LC3852"><span><span>//</span>    Now behaves differently in minopts / debug. Instead of actually inspecting</span></td>
      </tr>
      <tr>
        <td id="L3853" data-line-number="3853"></td>
        <td id="LC3853"><span><span>//</span>    the IR and counting references, the jit assumes all locals are referenced</span></td>
      </tr>
      <tr>
        <td id="L3854" data-line-number="3854"></td>
        <td id="LC3854"><span><span>//</span>    and does not sort the locals table.</span></td>
      </tr>
      <tr>
        <td id="L3855" data-line-number="3855"></td>
        <td id="LC3855"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3856" data-line-number="3856"></td>
        <td id="LC3856"><span><span>//</span>    Also, when optimizing, lays the groundwork for assertion prop and more.</span></td>
      </tr>
      <tr>
        <td id="L3857" data-line-number="3857"></td>
        <td id="LC3857"><span><span>//</span>    See details in lvaMarkLclRefs.</span></td>
      </tr>
      <tr>
        <td id="L3858" data-line-number="3858"></td>
        <td id="LC3858">
</td>
      </tr>
      <tr>
        <td id="L3859" data-line-number="3859"></td>
        <td id="LC3859"><span>void</span> <span>Compiler::lvaMarkLocalVars</span>()</td>
      </tr>
      <tr>
        <td id="L3860" data-line-number="3860"></td>
        <td id="LC3860">{</td>
      </tr>
      <tr>
        <td id="L3861" data-line-number="3861"></td>
        <td id="LC3861">
</td>
      </tr>
      <tr>
        <td id="L3862" data-line-number="3862"></td>
        <td id="LC3862">    <span>JITDUMP</span>(<span><span>"</span><span>\n</span>*************** In lvaMarkLocalVars()<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3863" data-line-number="3863"></td>
        <td id="LC3863">
</td>
      </tr>
      <tr>
        <td id="L3864" data-line-number="3864"></td>
        <td id="LC3864">    <span><span>//</span> If we have direct pinvokes, verify the frame list root local was set up properly</span></td>
      </tr>
      <tr>
        <td id="L3865" data-line-number="3865"></td>
        <td id="LC3865">    <span>if</span> (<span>compMethodRequiresPInvokeFrame</span>())</td>
      </tr>
      <tr>
        <td id="L3866" data-line-number="3866"></td>
        <td id="LC3866">    {</td>
      </tr>
      <tr>
        <td id="L3867" data-line-number="3867"></td>
        <td id="LC3867">        <span>assert</span>((!opts.<span>ShouldUsePInvokeHelpers</span>()) || (info.<span>compLvFrameListRoot</span> == BAD_VAR_NUM));</td>
      </tr>
      <tr>
        <td id="L3868" data-line-number="3868"></td>
        <td id="LC3868">        <span>if</span> (!opts.<span>ShouldUsePInvokeHelpers</span>())</td>
      </tr>
      <tr>
        <td id="L3869" data-line-number="3869"></td>
        <td id="LC3869">        {</td>
      </tr>
      <tr>
        <td id="L3870" data-line-number="3870"></td>
        <td id="LC3870">            <span>noway_assert</span>(info.<span>compLvFrameListRoot</span> &gt;= info.<span>compLocalsCount</span> &amp;&amp; info.<span>compLvFrameListRoot</span> &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L3871" data-line-number="3871"></td>
        <td id="LC3871">        }</td>
      </tr>
      <tr>
        <td id="L3872" data-line-number="3872"></td>
        <td id="LC3872">    }</td>
      </tr>
      <tr>
        <td id="L3873" data-line-number="3873"></td>
        <td id="LC3873">
</td>
      </tr>
      <tr>
        <td id="L3874" data-line-number="3874"></td>
        <td id="LC3874">#<span>if</span> !defined(FEATURE_EH_FUNCLETS)</td>
      </tr>
      <tr>
        <td id="L3875" data-line-number="3875"></td>
        <td id="LC3875">
</td>
      </tr>
      <tr>
        <td id="L3876" data-line-number="3876"></td>
        <td id="LC3876">    <span><span>//</span> Grab space for exception handling</span></td>
      </tr>
      <tr>
        <td id="L3877" data-line-number="3877"></td>
        <td id="LC3877">
</td>
      </tr>
      <tr>
        <td id="L3878" data-line-number="3878"></td>
        <td id="LC3878">    <span>if</span> (<span>ehNeedsShadowSPslots</span>())</td>
      </tr>
      <tr>
        <td id="L3879" data-line-number="3879"></td>
        <td id="LC3879">    {</td>
      </tr>
      <tr>
        <td id="L3880" data-line-number="3880"></td>
        <td id="LC3880">        <span><span>//</span> The first slot is reserved for ICodeManager::FixContext(ppEndRegion)</span></td>
      </tr>
      <tr>
        <td id="L3881" data-line-number="3881"></td>
        <td id="LC3881">        <span><span>//</span> ie. the offset of the end-of-last-executed-filter</span></td>
      </tr>
      <tr>
        <td id="L3882" data-line-number="3882"></td>
        <td id="LC3882">        <span>unsigned</span> slotsNeeded = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L3883" data-line-number="3883"></td>
        <td id="LC3883">
</td>
      </tr>
      <tr>
        <td id="L3884" data-line-number="3884"></td>
        <td id="LC3884">        <span>unsigned</span> handlerNestingLevel = ehMaxHndNestingCount;</td>
      </tr>
      <tr>
        <td id="L3885" data-line-number="3885"></td>
        <td id="LC3885">
</td>
      </tr>
      <tr>
        <td id="L3886" data-line-number="3886"></td>
        <td id="LC3886">        <span>if</span> (opts.<span>compDbgEnC</span> &amp;&amp; (handlerNestingLevel &lt; (<span>unsigned</span>)MAX_EnC_HANDLER_NESTING_LEVEL))</td>
      </tr>
      <tr>
        <td id="L3887" data-line-number="3887"></td>
        <td id="LC3887">            handlerNestingLevel = (<span>unsigned</span>)MAX_EnC_HANDLER_NESTING_LEVEL;</td>
      </tr>
      <tr>
        <td id="L3888" data-line-number="3888"></td>
        <td id="LC3888">
</td>
      </tr>
      <tr>
        <td id="L3889" data-line-number="3889"></td>
        <td id="LC3889">        slotsNeeded += handlerNestingLevel;</td>
      </tr>
      <tr>
        <td id="L3890" data-line-number="3890"></td>
        <td id="LC3890">
</td>
      </tr>
      <tr>
        <td id="L3891" data-line-number="3891"></td>
        <td id="LC3891">        <span><span>//</span> For a filter (which can be active at the same time as a catch/finally handler)</span></td>
      </tr>
      <tr>
        <td id="L3892" data-line-number="3892"></td>
        <td id="LC3892">        slotsNeeded++;</td>
      </tr>
      <tr>
        <td id="L3893" data-line-number="3893"></td>
        <td id="LC3893">        <span><span>//</span> For zero-termination of the shadow-Stack-pointer chain</span></td>
      </tr>
      <tr>
        <td id="L3894" data-line-number="3894"></td>
        <td id="LC3894">        slotsNeeded++;</td>
      </tr>
      <tr>
        <td id="L3895" data-line-number="3895"></td>
        <td id="LC3895">
</td>
      </tr>
      <tr>
        <td id="L3896" data-line-number="3896"></td>
        <td id="LC3896">        lvaShadowSPslotsVar           = <span>lvaGrabTempWithImplicitUse</span>(<span>false</span> <span>DEBUGARG</span>(<span><span>"</span>lvaShadowSPslotsVar<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L3897" data-line-number="3897"></td>
        <td id="LC3897">        LclVarDsc* shadowSPslotsVar   = &amp;lvaTable[lvaShadowSPslotsVar];</td>
      </tr>
      <tr>
        <td id="L3898" data-line-number="3898"></td>
        <td id="LC3898">        shadowSPslotsVar-&gt;<span>lvType</span>      = TYP_BLK;</td>
      </tr>
      <tr>
        <td id="L3899" data-line-number="3899"></td>
        <td id="LC3899">        shadowSPslotsVar-&gt;<span>lvExactSize</span> = (slotsNeeded * TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L3900" data-line-number="3900"></td>
        <td id="LC3900">    }</td>
      </tr>
      <tr>
        <td id="L3901" data-line-number="3901"></td>
        <td id="LC3901">
</td>
      </tr>
      <tr>
        <td id="L3902" data-line-number="3902"></td>
        <td id="LC3902">#<span>endif</span> <span><span>//</span> !FEATURE_EH_FUNCLETS</span></td>
      </tr>
      <tr>
        <td id="L3903" data-line-number="3903"></td>
        <td id="LC3903">
</td>
      </tr>
      <tr>
        <td id="L3904" data-line-number="3904"></td>
        <td id="LC3904">    <span><span>//</span> PSPSym and LocAllocSPvar are not used by the CoreRT ABI</span></td>
      </tr>
      <tr>
        <td id="L3905" data-line-number="3905"></td>
        <td id="LC3905">    <span>if</span> (!<span>IsTargetAbi</span>(CORINFO_CORERT_ABI))</td>
      </tr>
      <tr>
        <td id="L3906" data-line-number="3906"></td>
        <td id="LC3906">    {</td>
      </tr>
      <tr>
        <td id="L3907" data-line-number="3907"></td>
        <td id="LC3907">#<span>if</span> defined(FEATURE_EH_FUNCLETS)</td>
      </tr>
      <tr>
        <td id="L3908" data-line-number="3908"></td>
        <td id="LC3908">        <span>if</span> (<span>ehNeedsPSPSym</span>())</td>
      </tr>
      <tr>
        <td id="L3909" data-line-number="3909"></td>
        <td id="LC3909">        {</td>
      </tr>
      <tr>
        <td id="L3910" data-line-number="3910"></td>
        <td id="LC3910">            lvaPSPSym            = <span>lvaGrabTempWithImplicitUse</span>(<span>false</span> <span>DEBUGARG</span>(<span><span>"</span>PSPSym<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L3911" data-line-number="3911"></td>
        <td id="LC3911">            LclVarDsc* lclPSPSym = &amp;lvaTable[lvaPSPSym];</td>
      </tr>
      <tr>
        <td id="L3912" data-line-number="3912"></td>
        <td id="LC3912">            lclPSPSym-&gt;<span>lvType</span>    = TYP_I_IMPL;</td>
      </tr>
      <tr>
        <td id="L3913" data-line-number="3913"></td>
        <td id="LC3913">        }</td>
      </tr>
      <tr>
        <td id="L3914" data-line-number="3914"></td>
        <td id="LC3914">#<span>endif</span> <span><span>//</span> FEATURE_EH_FUNCLETS</span></td>
      </tr>
      <tr>
        <td id="L3915" data-line-number="3915"></td>
        <td id="LC3915">
</td>
      </tr>
      <tr>
        <td id="L3916" data-line-number="3916"></td>
        <td id="LC3916">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L3917" data-line-number="3917"></td>
        <td id="LC3917">        <span><span>//</span> LocAllocSPvar is only required by the implicit frame layout expected by the VM on x86. Whether</span></td>
      </tr>
      <tr>
        <td id="L3918" data-line-number="3918"></td>
        <td id="LC3918">        <span><span>//</span> a function contains a Localloc is conveyed in the GC information, in the InfoHdrSmall.localloc</span></td>
      </tr>
      <tr>
        <td id="L3919" data-line-number="3919"></td>
        <td id="LC3919">        <span><span>//</span> field. The function must have an EBP frame. Then, the VM finds the LocAllocSP slot by assuming</span></td>
      </tr>
      <tr>
        <td id="L3920" data-line-number="3920"></td>
        <td id="LC3920">        <span><span>//</span> the following stack layout:</span></td>
      </tr>
      <tr>
        <td id="L3921" data-line-number="3921"></td>
        <td id="LC3921">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3922" data-line-number="3922"></td>
        <td id="LC3922">        <span><span>//</span>      -- higher addresses --</span></td>
      </tr>
      <tr>
        <td id="L3923" data-line-number="3923"></td>
        <td id="LC3923">        <span><span>//</span>      saved EBP                       &lt;-- EBP points here</span></td>
      </tr>
      <tr>
        <td id="L3924" data-line-number="3924"></td>
        <td id="LC3924">        <span><span>//</span>      other callee-saved registers    // InfoHdrSmall.savedRegsCountExclFP specifies this size</span></td>
      </tr>
      <tr>
        <td id="L3925" data-line-number="3925"></td>
        <td id="LC3925">        <span><span>//</span>      optional GS cookie              // InfoHdrSmall.security is 1 if this exists</span></td>
      </tr>
      <tr>
        <td id="L3926" data-line-number="3926"></td>
        <td id="LC3926">        <span><span>//</span>      LocAllocSP slot</span></td>
      </tr>
      <tr>
        <td id="L3927" data-line-number="3927"></td>
        <td id="LC3927">        <span><span>//</span>      -- lower addresses --</span></td>
      </tr>
      <tr>
        <td id="L3928" data-line-number="3928"></td>
        <td id="LC3928">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3929" data-line-number="3929"></td>
        <td id="LC3929">        <span><span>//</span> See also eetwain.cpp::GetLocallocSPOffset() and its callers.</span></td>
      </tr>
      <tr>
        <td id="L3930" data-line-number="3930"></td>
        <td id="LC3930">        <span>if</span> (compLocallocUsed)</td>
      </tr>
      <tr>
        <td id="L3931" data-line-number="3931"></td>
        <td id="LC3931">        {</td>
      </tr>
      <tr>
        <td id="L3932" data-line-number="3932"></td>
        <td id="LC3932">            lvaLocAllocSPvar         = <span>lvaGrabTempWithImplicitUse</span>(<span>false</span> <span>DEBUGARG</span>(<span><span>"</span>LocAllocSPvar<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L3933" data-line-number="3933"></td>
        <td id="LC3933">            LclVarDsc* locAllocSPvar = &amp;lvaTable[lvaLocAllocSPvar];</td>
      </tr>
      <tr>
        <td id="L3934" data-line-number="3934"></td>
        <td id="LC3934">            locAllocSPvar-&gt;<span>lvType</span>    = TYP_I_IMPL;</td>
      </tr>
      <tr>
        <td id="L3935" data-line-number="3935"></td>
        <td id="LC3935">        }</td>
      </tr>
      <tr>
        <td id="L3936" data-line-number="3936"></td>
        <td id="LC3936">#<span>endif</span> <span><span>//</span> JIT32_GCENCODER</span></td>
      </tr>
      <tr>
        <td id="L3937" data-line-number="3937"></td>
        <td id="LC3937">    }</td>
      </tr>
      <tr>
        <td id="L3938" data-line-number="3938"></td>
        <td id="LC3938">
</td>
      </tr>
      <tr>
        <td id="L3939" data-line-number="3939"></td>
        <td id="LC3939">    <span><span>//</span> Ref counting is now enabled normally.</span></td>
      </tr>
      <tr>
        <td id="L3940" data-line-number="3940"></td>
        <td id="LC3940">    lvaRefCountState = RCS_NORMAL;</td>
      </tr>
      <tr>
        <td id="L3941" data-line-number="3941"></td>
        <td id="LC3941">
</td>
      </tr>
      <tr>
        <td id="L3942" data-line-number="3942"></td>
        <td id="LC3942">#<span>if</span> defined(DEBUG)</td>
      </tr>
      <tr>
        <td id="L3943" data-line-number="3943"></td>
        <td id="LC3943">    <span>const</span> <span>bool</span> setSlotNumbers = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L3944" data-line-number="3944"></td>
        <td id="LC3944">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L3945" data-line-number="3945"></td>
        <td id="LC3945">    <span>const</span> <span>bool</span> setSlotNumbers = opts.<span>compScopeInfo</span> &amp;&amp; (info.<span>compVarScopesCount</span> &gt; <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L3946" data-line-number="3946"></td>
        <td id="LC3946">#<span>endif</span> <span><span>//</span> defined(DEBUG)</span></td>
      </tr>
      <tr>
        <td id="L3947" data-line-number="3947"></td>
        <td id="LC3947">
</td>
      </tr>
      <tr>
        <td id="L3948" data-line-number="3948"></td>
        <td id="LC3948">    <span>const</span> <span>bool</span> isRecompute = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L3949" data-line-number="3949"></td>
        <td id="LC3949">    <span>lvaComputeRefCounts</span>(isRecompute, setSlotNumbers);</td>
      </tr>
      <tr>
        <td id="L3950" data-line-number="3950"></td>
        <td id="LC3950">
</td>
      </tr>
      <tr>
        <td id="L3951" data-line-number="3951"></td>
        <td id="LC3951">    <span><span>//</span> If we're not optimizing, we're done.</span></td>
      </tr>
      <tr>
        <td id="L3952" data-line-number="3952"></td>
        <td id="LC3952">    <span>if</span> (opts.<span>OptimizationDisabled</span>())</td>
      </tr>
      <tr>
        <td id="L3953" data-line-number="3953"></td>
        <td id="LC3953">    {</td>
      </tr>
      <tr>
        <td id="L3954" data-line-number="3954"></td>
        <td id="LC3954">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L3955" data-line-number="3955"></td>
        <td id="LC3955">    }</td>
      </tr>
      <tr>
        <td id="L3956" data-line-number="3956"></td>
        <td id="LC3956">
</td>
      </tr>
      <tr>
        <td id="L3957" data-line-number="3957"></td>
        <td id="LC3957">#<span>if</span> ASSERTION_PROP</td>
      </tr>
      <tr>
        <td id="L3958" data-line-number="3958"></td>
        <td id="LC3958">    <span>assert</span>(opts.<span>OptimizationEnabled</span>());</td>
      </tr>
      <tr>
        <td id="L3959" data-line-number="3959"></td>
        <td id="LC3959">
</td>
      </tr>
      <tr>
        <td id="L3960" data-line-number="3960"></td>
        <td id="LC3960">    <span><span>//</span> Note: optAddCopies() depends on lvaRefBlks, which is set in lvaMarkLocalVars(BasicBlock*), called above.</span></td>
      </tr>
      <tr>
        <td id="L3961" data-line-number="3961"></td>
        <td id="LC3961">    <span>optAddCopies</span>();</td>
      </tr>
      <tr>
        <td id="L3962" data-line-number="3962"></td>
        <td id="LC3962">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3963" data-line-number="3963"></td>
        <td id="LC3963">
</td>
      </tr>
      <tr>
        <td id="L3964" data-line-number="3964"></td>
        <td id="LC3964">    <span>if</span> (<span>lvaKeepAliveAndReportThis</span>())</td>
      </tr>
      <tr>
        <td id="L3965" data-line-number="3965"></td>
        <td id="LC3965">    {</td>
      </tr>
      <tr>
        <td id="L3966" data-line-number="3966"></td>
        <td id="LC3966">        lvaTable[<span>0</span>].<span>lvImplicitlyReferenced</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L3967" data-line-number="3967"></td>
        <td id="LC3967">        <span><span>//</span> This isn't strictly needed as we will make a copy of the param-type-arg</span></td>
      </tr>
      <tr>
        <td id="L3968" data-line-number="3968"></td>
        <td id="LC3968">        <span><span>//</span> in the prolog. However, this ensures that the LclVarDsc corresponding to</span></td>
      </tr>
      <tr>
        <td id="L3969" data-line-number="3969"></td>
        <td id="LC3969">        <span><span>//</span> info.compTypeCtxtArg is valid.</span></td>
      </tr>
      <tr>
        <td id="L3970" data-line-number="3970"></td>
        <td id="LC3970">    }</td>
      </tr>
      <tr>
        <td id="L3971" data-line-number="3971"></td>
        <td id="LC3971">    <span>else</span> <span>if</span> (<span>lvaReportParamTypeArg</span>())</td>
      </tr>
      <tr>
        <td id="L3972" data-line-number="3972"></td>
        <td id="LC3972">    {</td>
      </tr>
      <tr>
        <td id="L3973" data-line-number="3973"></td>
        <td id="LC3973">        lvaTable[info.<span>compTypeCtxtArg</span>].<span>lvImplicitlyReferenced</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L3974" data-line-number="3974"></td>
        <td id="LC3974">    }</td>
      </tr>
      <tr>
        <td id="L3975" data-line-number="3975"></td>
        <td id="LC3975">}</td>
      </tr>
      <tr>
        <td id="L3976" data-line-number="3976"></td>
        <td id="LC3976">
</td>
      </tr>
      <tr>
        <td id="L3977" data-line-number="3977"></td>
        <td id="LC3977"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3978" data-line-number="3978"></td>
        <td id="LC3978"><span><span>//</span> lvaComputeRefCounts: compute ref counts for locals</span></td>
      </tr>
      <tr>
        <td id="L3979" data-line-number="3979"></td>
        <td id="LC3979"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3980" data-line-number="3980"></td>
        <td id="LC3980"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L3981" data-line-number="3981"></td>
        <td id="LC3981"><span><span>//</span>    isRecompute -- true if we just want ref counts and no other side effects;</span></td>
      </tr>
      <tr>
        <td id="L3982" data-line-number="3982"></td>
        <td id="LC3982"><span><span>//</span>                   false means to also look for true boolean locals, lay</span></td>
      </tr>
      <tr>
        <td id="L3983" data-line-number="3983"></td>
        <td id="LC3983"><span><span>//</span>                   groundwork for assertion prop, check type consistency, etc.</span></td>
      </tr>
      <tr>
        <td id="L3984" data-line-number="3984"></td>
        <td id="LC3984"><span><span>//</span>                   See lvaMarkLclRefs for details on what else goes on.</span></td>
      </tr>
      <tr>
        <td id="L3985" data-line-number="3985"></td>
        <td id="LC3985"><span><span>//</span>    setSlotNumbers -- true if local slot numbers should be assigned.</span></td>
      </tr>
      <tr>
        <td id="L3986" data-line-number="3986"></td>
        <td id="LC3986"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3987" data-line-number="3987"></td>
        <td id="LC3987"><span><span>//</span> Notes:</span></td>
      </tr>
      <tr>
        <td id="L3988" data-line-number="3988"></td>
        <td id="LC3988"><span><span>//</span>    Some implicit references are given actual counts or weight bumps here</span></td>
      </tr>
      <tr>
        <td id="L3989" data-line-number="3989"></td>
        <td id="LC3989"><span><span>//</span>    to match pre-existing behavior.</span></td>
      </tr>
      <tr>
        <td id="L3990" data-line-number="3990"></td>
        <td id="LC3990"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3991" data-line-number="3991"></td>
        <td id="LC3991"><span><span>//</span>    In fast-jitting modes where we don't ref count locals, this bypasses</span></td>
      </tr>
      <tr>
        <td id="L3992" data-line-number="3992"></td>
        <td id="LC3992"><span><span>//</span>    actual counting, and makes all locals implicitly referenced on first</span></td>
      </tr>
      <tr>
        <td id="L3993" data-line-number="3993"></td>
        <td id="LC3993"><span><span>//</span>    compute. It asserts all locals are implicitly referenced on recompute.</span></td>
      </tr>
      <tr>
        <td id="L3994" data-line-number="3994"></td>
        <td id="LC3994">
</td>
      </tr>
      <tr>
        <td id="L3995" data-line-number="3995"></td>
        <td id="LC3995"><span>void</span> <span>Compiler::lvaComputeRefCounts</span>(<span>bool</span> isRecompute, <span>bool</span> setSlotNumbers)</td>
      </tr>
      <tr>
        <td id="L3996" data-line-number="3996"></td>
        <td id="LC3996">{</td>
      </tr>
      <tr>
        <td id="L3997" data-line-number="3997"></td>
        <td id="LC3997">    <span>JITDUMP</span>(<span><span>"</span><span>\n</span>*** lvaComputeRefCounts ***<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L3998" data-line-number="3998"></td>
        <td id="LC3998">    <span>unsigned</span>   lclNum = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3999" data-line-number="3999"></td>
        <td id="LC3999">    LclVarDsc* varDsc = <span>nullptr</span>;</td>
      </tr>
      <tr>
        <td id="L4000" data-line-number="4000"></td>
        <td id="LC4000">
</td>
      </tr>
      <tr>
        <td id="L4001" data-line-number="4001"></td>
        <td id="LC4001">    <span><span>//</span> Fast path for minopts and debug codegen.</span></td>
      </tr>
      <tr>
        <td id="L4002" data-line-number="4002"></td>
        <td id="LC4002">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4003" data-line-number="4003"></td>
        <td id="LC4003">    <span><span>//</span> On first compute: mark all locals as implicitly referenced and untracked.</span></td>
      </tr>
      <tr>
        <td id="L4004" data-line-number="4004"></td>
        <td id="LC4004">    <span><span>//</span> On recompute: do nothing.</span></td>
      </tr>
      <tr>
        <td id="L4005" data-line-number="4005"></td>
        <td id="LC4005">    <span>if</span> (opts.<span>OptimizationDisabled</span>())</td>
      </tr>
      <tr>
        <td id="L4006" data-line-number="4006"></td>
        <td id="LC4006">    {</td>
      </tr>
      <tr>
        <td id="L4007" data-line-number="4007"></td>
        <td id="LC4007">        <span>if</span> (isRecompute)</td>
      </tr>
      <tr>
        <td id="L4008" data-line-number="4008"></td>
        <td id="LC4008">        {</td>
      </tr>
      <tr>
        <td id="L4009" data-line-number="4009"></td>
        <td id="LC4009">
</td>
      </tr>
      <tr>
        <td id="L4010" data-line-number="4010"></td>
        <td id="LC4010">#<span>if</span> defined(DEBUG)</td>
      </tr>
      <tr>
        <td id="L4011" data-line-number="4011"></td>
        <td id="LC4011">            <span><span>//</span> All local vars should be marked as implicitly referenced</span></td>
      </tr>
      <tr>
        <td id="L4012" data-line-number="4012"></td>
        <td id="LC4012">            <span><span>//</span> and not tracked.</span></td>
      </tr>
      <tr>
        <td id="L4013" data-line-number="4013"></td>
        <td id="LC4013">            <span>for</span> (lclNum = <span>0</span>, varDsc = lvaTable; lclNum &lt; lvaCount; lclNum++, varDsc++)</td>
      </tr>
      <tr>
        <td id="L4014" data-line-number="4014"></td>
        <td id="LC4014">            {</td>
      </tr>
      <tr>
        <td id="L4015" data-line-number="4015"></td>
        <td id="LC4015">                <span>const</span> <span>bool</span> isSpecialVarargsParam = varDsc-&gt;<span>lvIsParam</span> &amp;&amp; <span>raIsVarargsStackArg</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L4016" data-line-number="4016"></td>
        <td id="LC4016">
</td>
      </tr>
      <tr>
        <td id="L4017" data-line-number="4017"></td>
        <td id="LC4017">                <span>if</span> (isSpecialVarargsParam)</td>
      </tr>
      <tr>
        <td id="L4018" data-line-number="4018"></td>
        <td id="LC4018">                {</td>
      </tr>
      <tr>
        <td id="L4019" data-line-number="4019"></td>
        <td id="LC4019">                    <span>assert</span>(varDsc-&gt;<span>lvRefCnt</span>() == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L4020" data-line-number="4020"></td>
        <td id="LC4020">                }</td>
      </tr>
      <tr>
        <td id="L4021" data-line-number="4021"></td>
        <td id="LC4021">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L4022" data-line-number="4022"></td>
        <td id="LC4022">                {</td>
      </tr>
      <tr>
        <td id="L4023" data-line-number="4023"></td>
        <td id="LC4023">                    <span>assert</span>(varDsc-&gt;<span>lvImplicitlyReferenced</span>);</td>
      </tr>
      <tr>
        <td id="L4024" data-line-number="4024"></td>
        <td id="LC4024">                }</td>
      </tr>
      <tr>
        <td id="L4025" data-line-number="4025"></td>
        <td id="LC4025">
</td>
      </tr>
      <tr>
        <td id="L4026" data-line-number="4026"></td>
        <td id="LC4026">                <span>assert</span>(!varDsc-&gt;<span>lvTracked</span>);</td>
      </tr>
      <tr>
        <td id="L4027" data-line-number="4027"></td>
        <td id="LC4027">            }</td>
      </tr>
      <tr>
        <td id="L4028" data-line-number="4028"></td>
        <td id="LC4028">#<span>endif</span> <span><span>//</span> defined (DEBUG)</span></td>
      </tr>
      <tr>
        <td id="L4029" data-line-number="4029"></td>
        <td id="LC4029">
</td>
      </tr>
      <tr>
        <td id="L4030" data-line-number="4030"></td>
        <td id="LC4030">            <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L4031" data-line-number="4031"></td>
        <td id="LC4031">        }</td>
      </tr>
      <tr>
        <td id="L4032" data-line-number="4032"></td>
        <td id="LC4032">
</td>
      </tr>
      <tr>
        <td id="L4033" data-line-number="4033"></td>
        <td id="LC4033">        <span><span>//</span> First compute.</span></td>
      </tr>
      <tr>
        <td id="L4034" data-line-number="4034"></td>
        <td id="LC4034">        <span>for</span> (lclNum = <span>0</span>, varDsc = lvaTable; lclNum &lt; lvaCount; lclNum++, varDsc++)</td>
      </tr>
      <tr>
        <td id="L4035" data-line-number="4035"></td>
        <td id="LC4035">        {</td>
      </tr>
      <tr>
        <td id="L4036" data-line-number="4036"></td>
        <td id="LC4036">            <span><span>//</span> Using lvImplicitlyReferenced here ensures that we can't</span></td>
      </tr>
      <tr>
        <td id="L4037" data-line-number="4037"></td>
        <td id="LC4037">            <span><span>//</span> accidentally make locals be unreferenced later by decrementing</span></td>
      </tr>
      <tr>
        <td id="L4038" data-line-number="4038"></td>
        <td id="LC4038">            <span><span>//</span> the ref count to zero.</span></td>
      </tr>
      <tr>
        <td id="L4039" data-line-number="4039"></td>
        <td id="LC4039">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4040" data-line-number="4040"></td>
        <td id="LC4040">            <span><span>//</span> If, in minopts/debug, we really want to allow locals to become</span></td>
      </tr>
      <tr>
        <td id="L4041" data-line-number="4041"></td>
        <td id="LC4041">            <span><span>//</span> unreferenced later, we'll have to explicitly clear this bit.</span></td>
      </tr>
      <tr>
        <td id="L4042" data-line-number="4042"></td>
        <td id="LC4042">            varDsc-&gt;<span>setLvRefCnt</span>(<span>0</span>);</td>
      </tr>
      <tr>
        <td id="L4043" data-line-number="4043"></td>
        <td id="LC4043">            varDsc-&gt;<span>setLvRefCntWtd</span>(<span>0</span>);</td>
      </tr>
      <tr>
        <td id="L4044" data-line-number="4044"></td>
        <td id="LC4044">
</td>
      </tr>
      <tr>
        <td id="L4045" data-line-number="4045"></td>
        <td id="LC4045">            <span><span>//</span> Special case for some varargs params ... these must</span></td>
      </tr>
      <tr>
        <td id="L4046" data-line-number="4046"></td>
        <td id="LC4046">            <span><span>//</span> remain unreferenced.</span></td>
      </tr>
      <tr>
        <td id="L4047" data-line-number="4047"></td>
        <td id="LC4047">            <span>const</span> <span>bool</span> isSpecialVarargsParam = varDsc-&gt;<span>lvIsParam</span> &amp;&amp; <span>raIsVarargsStackArg</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L4048" data-line-number="4048"></td>
        <td id="LC4048">
</td>
      </tr>
      <tr>
        <td id="L4049" data-line-number="4049"></td>
        <td id="LC4049">            <span>if</span> (!isSpecialVarargsParam)</td>
      </tr>
      <tr>
        <td id="L4050" data-line-number="4050"></td>
        <td id="LC4050">            {</td>
      </tr>
      <tr>
        <td id="L4051" data-line-number="4051"></td>
        <td id="LC4051">                varDsc-&gt;<span>lvImplicitlyReferenced</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L4052" data-line-number="4052"></td>
        <td id="LC4052">            }</td>
      </tr>
      <tr>
        <td id="L4053" data-line-number="4053"></td>
        <td id="LC4053">
</td>
      </tr>
      <tr>
        <td id="L4054" data-line-number="4054"></td>
        <td id="LC4054">            varDsc-&gt;<span>lvTracked</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4055" data-line-number="4055"></td>
        <td id="LC4055">
</td>
      </tr>
      <tr>
        <td id="L4056" data-line-number="4056"></td>
        <td id="LC4056">            <span>if</span> (setSlotNumbers)</td>
      </tr>
      <tr>
        <td id="L4057" data-line-number="4057"></td>
        <td id="LC4057">            {</td>
      </tr>
      <tr>
        <td id="L4058" data-line-number="4058"></td>
        <td id="LC4058">                varDsc-&gt;<span>lvSlotNum</span> = lclNum;</td>
      </tr>
      <tr>
        <td id="L4059" data-line-number="4059"></td>
        <td id="LC4059">            }</td>
      </tr>
      <tr>
        <td id="L4060" data-line-number="4060"></td>
        <td id="LC4060">
</td>
      </tr>
      <tr>
        <td id="L4061" data-line-number="4061"></td>
        <td id="LC4061">            <span><span>//</span> Assert that it's ok to bypass the type repair logic in lvaMarkLclRefs</span></td>
      </tr>
      <tr>
        <td id="L4062" data-line-number="4062"></td>
        <td id="LC4062">            <span>assert</span>((varDsc-&gt;<span>lvType</span> != TYP_UNDEF) &amp;&amp; (varDsc-&gt;<span>lvType</span> != TYP_VOID) &amp;&amp; (varDsc-&gt;<span>lvType</span> != TYP_UNKNOWN));</td>
      </tr>
      <tr>
        <td id="L4063" data-line-number="4063"></td>
        <td id="LC4063">        }</td>
      </tr>
      <tr>
        <td id="L4064" data-line-number="4064"></td>
        <td id="LC4064">
</td>
      </tr>
      <tr>
        <td id="L4065" data-line-number="4065"></td>
        <td id="LC4065">        lvaCurEpoch++;</td>
      </tr>
      <tr>
        <td id="L4066" data-line-number="4066"></td>
        <td id="LC4066">        lvaTrackedCount             = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4067" data-line-number="4067"></td>
        <td id="LC4067">        lvaTrackedCountInSizeTUnits = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4068" data-line-number="4068"></td>
        <td id="LC4068">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L4069" data-line-number="4069"></td>
        <td id="LC4069">    }</td>
      </tr>
      <tr>
        <td id="L4070" data-line-number="4070"></td>
        <td id="LC4070">
</td>
      </tr>
      <tr>
        <td id="L4071" data-line-number="4071"></td>
        <td id="LC4071">    <span><span>//</span> Slower path we take when optimizing, to get accurate counts.</span></td>
      </tr>
      <tr>
        <td id="L4072" data-line-number="4072"></td>
        <td id="LC4072">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4073" data-line-number="4073"></td>
        <td id="LC4073">    <span><span>//</span> First, reset all explicit ref counts and weights.</span></td>
      </tr>
      <tr>
        <td id="L4074" data-line-number="4074"></td>
        <td id="LC4074">    <span>for</span> (lclNum = <span>0</span>, varDsc = lvaTable; lclNum &lt; lvaCount; lclNum++, varDsc++)</td>
      </tr>
      <tr>
        <td id="L4075" data-line-number="4075"></td>
        <td id="LC4075">    {</td>
      </tr>
      <tr>
        <td id="L4076" data-line-number="4076"></td>
        <td id="LC4076">        varDsc-&gt;<span>setLvRefCnt</span>(<span>0</span>);</td>
      </tr>
      <tr>
        <td id="L4077" data-line-number="4077"></td>
        <td id="LC4077">        varDsc-&gt;<span>setLvRefCntWtd</span>(BB_ZERO_WEIGHT);</td>
      </tr>
      <tr>
        <td id="L4078" data-line-number="4078"></td>
        <td id="LC4078">
</td>
      </tr>
      <tr>
        <td id="L4079" data-line-number="4079"></td>
        <td id="LC4079">        <span>if</span> (setSlotNumbers)</td>
      </tr>
      <tr>
        <td id="L4080" data-line-number="4080"></td>
        <td id="LC4080">        {</td>
      </tr>
      <tr>
        <td id="L4081" data-line-number="4081"></td>
        <td id="LC4081">            varDsc-&gt;<span>lvSlotNum</span> = lclNum;</td>
      </tr>
      <tr>
        <td id="L4082" data-line-number="4082"></td>
        <td id="LC4082">        }</td>
      </tr>
      <tr>
        <td id="L4083" data-line-number="4083"></td>
        <td id="LC4083">
</td>
      </tr>
      <tr>
        <td id="L4084" data-line-number="4084"></td>
        <td id="LC4084">        <span><span>//</span> Set initial value for lvSingleDef for explicit and implicit</span></td>
      </tr>
      <tr>
        <td id="L4085" data-line-number="4085"></td>
        <td id="LC4085">        <span><span>//</span> argument locals as they are "defined" on entry.</span></td>
      </tr>
      <tr>
        <td id="L4086" data-line-number="4086"></td>
        <td id="LC4086">        varDsc-&gt;<span>lvSingleDef</span> = varDsc-&gt;<span>lvIsParam</span>;</td>
      </tr>
      <tr>
        <td id="L4087" data-line-number="4087"></td>
        <td id="LC4087">    }</td>
      </tr>
      <tr>
        <td id="L4088" data-line-number="4088"></td>
        <td id="LC4088">
</td>
      </tr>
      <tr>
        <td id="L4089" data-line-number="4089"></td>
        <td id="LC4089">    <span>JITDUMP</span>(<span><span>"</span><span>\n</span>*** lvaComputeRefCounts -- explicit counts ***<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4090" data-line-number="4090"></td>
        <td id="LC4090">
</td>
      </tr>
      <tr>
        <td id="L4091" data-line-number="4091"></td>
        <td id="LC4091">    <span><span>//</span> Second, account for all explicit local variable references</span></td>
      </tr>
      <tr>
        <td id="L4092" data-line-number="4092"></td>
        <td id="LC4092">    <span>for</span> (BasicBlock* block = fgFirstBB; block; block = block-&gt;<span>bbNext</span>)</td>
      </tr>
      <tr>
        <td id="L4093" data-line-number="4093"></td>
        <td id="LC4093">    {</td>
      </tr>
      <tr>
        <td id="L4094" data-line-number="4094"></td>
        <td id="LC4094">        <span>if</span> (block-&gt;<span>IsLIR</span>())</td>
      </tr>
      <tr>
        <td id="L4095" data-line-number="4095"></td>
        <td id="LC4095">        {</td>
      </tr>
      <tr>
        <td id="L4096" data-line-number="4096"></td>
        <td id="LC4096">            <span>assert</span>(isRecompute);</td>
      </tr>
      <tr>
        <td id="L4097" data-line-number="4097"></td>
        <td id="LC4097">
</td>
      </tr>
      <tr>
        <td id="L4098" data-line-number="4098"></td>
        <td id="LC4098">            <span>const</span> BasicBlock::<span>weight_t</span> weight = block-&gt;<span>getBBWeight</span>(<span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4099" data-line-number="4099"></td>
        <td id="LC4099">            <span>for</span> (GenTree* node : <span>LIR::AsRange</span>(block).<span>NonPhiNodes</span>())</td>
      </tr>
      <tr>
        <td id="L4100" data-line-number="4100"></td>
        <td id="LC4100">            {</td>
      </tr>
      <tr>
        <td id="L4101" data-line-number="4101"></td>
        <td id="LC4101">                <span>switch</span> (node-&gt;<span>OperGet</span>())</td>
      </tr>
      <tr>
        <td id="L4102" data-line-number="4102"></td>
        <td id="LC4102">                {</td>
      </tr>
      <tr>
        <td id="L4103" data-line-number="4103"></td>
        <td id="LC4103">                    <span>case</span> GT_LCL_VAR:</td>
      </tr>
      <tr>
        <td id="L4104" data-line-number="4104"></td>
        <td id="LC4104">                    <span>case</span> GT_LCL_FLD:</td>
      </tr>
      <tr>
        <td id="L4105" data-line-number="4105"></td>
        <td id="LC4105">                    <span>case</span> GT_LCL_VAR_ADDR:</td>
      </tr>
      <tr>
        <td id="L4106" data-line-number="4106"></td>
        <td id="LC4106">                    <span>case</span> GT_LCL_FLD_ADDR:</td>
      </tr>
      <tr>
        <td id="L4107" data-line-number="4107"></td>
        <td id="LC4107">                    <span>case</span> GT_STORE_LCL_VAR:</td>
      </tr>
      <tr>
        <td id="L4108" data-line-number="4108"></td>
        <td id="LC4108">                    <span>case</span> GT_STORE_LCL_FLD:</td>
      </tr>
      <tr>
        <td id="L4109" data-line-number="4109"></td>
        <td id="LC4109">                    {</td>
      </tr>
      <tr>
        <td id="L4110" data-line-number="4110"></td>
        <td id="LC4110">                        <span>const</span> <span>unsigned</span> lclNum = node-&gt;<span>AsLclVarCommon</span>()-&gt;<span>GetLclNum</span>();</td>
      </tr>
      <tr>
        <td id="L4111" data-line-number="4111"></td>
        <td id="LC4111">                        lvaTable[lclNum].<span>incRefCnts</span>(weight, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4112" data-line-number="4112"></td>
        <td id="LC4112">                        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4113" data-line-number="4113"></td>
        <td id="LC4113">                    }</td>
      </tr>
      <tr>
        <td id="L4114" data-line-number="4114"></td>
        <td id="LC4114">
</td>
      </tr>
      <tr>
        <td id="L4115" data-line-number="4115"></td>
        <td id="LC4115">                    <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L4116" data-line-number="4116"></td>
        <td id="LC4116">                        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L4117" data-line-number="4117"></td>
        <td id="LC4117">                }</td>
      </tr>
      <tr>
        <td id="L4118" data-line-number="4118"></td>
        <td id="LC4118">            }</td>
      </tr>
      <tr>
        <td id="L4119" data-line-number="4119"></td>
        <td id="LC4119">        }</td>
      </tr>
      <tr>
        <td id="L4120" data-line-number="4120"></td>
        <td id="LC4120">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L4121" data-line-number="4121"></td>
        <td id="LC4121">        {</td>
      </tr>
      <tr>
        <td id="L4122" data-line-number="4122"></td>
        <td id="LC4122">            <span>lvaMarkLocalVars</span>(block, isRecompute);</td>
      </tr>
      <tr>
        <td id="L4123" data-line-number="4123"></td>
        <td id="LC4123">        }</td>
      </tr>
      <tr>
        <td id="L4124" data-line-number="4124"></td>
        <td id="LC4124">    }</td>
      </tr>
      <tr>
        <td id="L4125" data-line-number="4125"></td>
        <td id="LC4125">
</td>
      </tr>
      <tr>
        <td id="L4126" data-line-number="4126"></td>
        <td id="LC4126">    <span>JITDUMP</span>(<span><span>"</span><span>\n</span>*** lvaComputeRefCounts -- implicit counts ***<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4127" data-line-number="4127"></td>
        <td id="LC4127">
</td>
      </tr>
      <tr>
        <td id="L4128" data-line-number="4128"></td>
        <td id="LC4128">    <span><span>//</span> Third, bump ref counts for some implicit prolog references</span></td>
      </tr>
      <tr>
        <td id="L4129" data-line-number="4129"></td>
        <td id="LC4129">    <span>for</span> (lclNum = <span>0</span>, varDsc = lvaTable; lclNum &lt; lvaCount; lclNum++, varDsc++)</td>
      </tr>
      <tr>
        <td id="L4130" data-line-number="4130"></td>
        <td id="LC4130">    {</td>
      </tr>
      <tr>
        <td id="L4131" data-line-number="4131"></td>
        <td id="LC4131">        <span><span>//</span> Todo: review justification for these count bumps.</span></td>
      </tr>
      <tr>
        <td id="L4132" data-line-number="4132"></td>
        <td id="LC4132">        <span>if</span> (varDsc-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L4133" data-line-number="4133"></td>
        <td id="LC4133">        {</td>
      </tr>
      <tr>
        <td id="L4134" data-line-number="4134"></td>
        <td id="LC4134">            <span>if</span> ((lclNum &lt; info.<span>compArgsCount</span>) &amp;&amp; (varDsc-&gt;<span>lvRefCnt</span>() &gt; <span>0</span>))</td>
      </tr>
      <tr>
        <td id="L4135" data-line-number="4135"></td>
        <td id="LC4135">            {</td>
      </tr>
      <tr>
        <td id="L4136" data-line-number="4136"></td>
        <td id="LC4136">                <span><span>//</span> Fix 388376 ARM JitStress WP7</span></td>
      </tr>
      <tr>
        <td id="L4137" data-line-number="4137"></td>
        <td id="LC4137">                varDsc-&gt;<span>incRefCnts</span>(BB_UNITY_WEIGHT, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4138" data-line-number="4138"></td>
        <td id="LC4138">                varDsc-&gt;<span>incRefCnts</span>(BB_UNITY_WEIGHT, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4139" data-line-number="4139"></td>
        <td id="LC4139">            }</td>
      </tr>
      <tr>
        <td id="L4140" data-line-number="4140"></td>
        <td id="LC4140">
</td>
      </tr>
      <tr>
        <td id="L4141" data-line-number="4141"></td>
        <td id="LC4141">            <span><span>//</span> Ref count bump that was in lvaPromoteStructVar</span></td>
      </tr>
      <tr>
        <td id="L4142" data-line-number="4142"></td>
        <td id="LC4142">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4143" data-line-number="4143"></td>
        <td id="LC4143">            <span><span>//</span> This was formerly done during RCS_EARLY counting,</span></td>
      </tr>
      <tr>
        <td id="L4144" data-line-number="4144"></td>
        <td id="LC4144">            <span><span>//</span> and we did not used to reset counts like we do now.</span></td>
      </tr>
      <tr>
        <td id="L4145" data-line-number="4145"></td>
        <td id="LC4145">            <span>if</span> (varDsc-&gt;<span>lvIsStructField</span>)</td>
      </tr>
      <tr>
        <td id="L4146" data-line-number="4146"></td>
        <td id="LC4146">            {</td>
      </tr>
      <tr>
        <td id="L4147" data-line-number="4147"></td>
        <td id="LC4147">                varDsc-&gt;<span>incRefCnts</span>(BB_UNITY_WEIGHT, <span>this</span>);</td>
      </tr>
      <tr>
        <td id="L4148" data-line-number="4148"></td>
        <td id="LC4148">            }</td>
      </tr>
      <tr>
        <td id="L4149" data-line-number="4149"></td>
        <td id="LC4149">        }</td>
      </tr>
      <tr>
        <td id="L4150" data-line-number="4150"></td>
        <td id="LC4150">
</td>
      </tr>
      <tr>
        <td id="L4151" data-line-number="4151"></td>
        <td id="LC4151">        <span><span>//</span> If we have JMP, all arguments must have a location</span></td>
      </tr>
      <tr>
        <td id="L4152" data-line-number="4152"></td>
        <td id="LC4152">        <span><span>//</span> even if we don't use them inside the method</span></td>
      </tr>
      <tr>
        <td id="L4153" data-line-number="4153"></td>
        <td id="LC4153">        <span>if</span> (compJmpOpUsed &amp;&amp; varDsc-&gt;<span>lvIsParam</span> &amp;&amp; (varDsc-&gt;<span>lvRefCnt</span>() == <span>0</span>))</td>
      </tr>
      <tr>
        <td id="L4154" data-line-number="4154"></td>
        <td id="LC4154">        {</td>
      </tr>
      <tr>
        <td id="L4155" data-line-number="4155"></td>
        <td id="LC4155">            <span><span>//</span> except when we have varargs and the argument is</span></td>
      </tr>
      <tr>
        <td id="L4156" data-line-number="4156"></td>
        <td id="LC4156">            <span><span>//</span> passed on the stack.  In that case, it's important</span></td>
      </tr>
      <tr>
        <td id="L4157" data-line-number="4157"></td>
        <td id="LC4157">            <span><span>//</span> for the ref count to be zero, so that we don't attempt</span></td>
      </tr>
      <tr>
        <td id="L4158" data-line-number="4158"></td>
        <td id="LC4158">            <span><span>//</span> to track them for GC info (which is not possible since we</span></td>
      </tr>
      <tr>
        <td id="L4159" data-line-number="4159"></td>
        <td id="LC4159">            <span><span>//</span> don't know their offset in the stack).  See the assert at the</span></td>
      </tr>
      <tr>
        <td id="L4160" data-line-number="4160"></td>
        <td id="LC4160">            <span><span>//</span> end of raMarkStkVars and bug #28949 for more info.</span></td>
      </tr>
      <tr>
        <td id="L4161" data-line-number="4161"></td>
        <td id="LC4161">            <span>if</span> (!<span>raIsVarargsStackArg</span>(lclNum))</td>
      </tr>
      <tr>
        <td id="L4162" data-line-number="4162"></td>
        <td id="LC4162">            {</td>
      </tr>
      <tr>
        <td id="L4163" data-line-number="4163"></td>
        <td id="LC4163">                varDsc-&gt;<span>lvImplicitlyReferenced</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L4164" data-line-number="4164"></td>
        <td id="LC4164">            }</td>
      </tr>
      <tr>
        <td id="L4165" data-line-number="4165"></td>
        <td id="LC4165">        }</td>
      </tr>
      <tr>
        <td id="L4166" data-line-number="4166"></td>
        <td id="LC4166">    }</td>
      </tr>
      <tr>
        <td id="L4167" data-line-number="4167"></td>
        <td id="LC4167">}</td>
      </tr>
      <tr>
        <td id="L4168" data-line-number="4168"></td>
        <td id="LC4168">
</td>
      </tr>
      <tr>
        <td id="L4169" data-line-number="4169"></td>
        <td id="LC4169"><span>void</span> <span>Compiler::lvaAllocOutgoingArgSpaceVar</span>()</td>
      </tr>
      <tr>
        <td id="L4170" data-line-number="4170"></td>
        <td id="LC4170">{</td>
      </tr>
      <tr>
        <td id="L4171" data-line-number="4171"></td>
        <td id="LC4171">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L4172" data-line-number="4172"></td>
        <td id="LC4172">
</td>
      </tr>
      <tr>
        <td id="L4173" data-line-number="4173"></td>
        <td id="LC4173">    <span><span>//</span> Setup the outgoing argument region, in case we end up using it later</span></td>
      </tr>
      <tr>
        <td id="L4174" data-line-number="4174"></td>
        <td id="LC4174">
</td>
      </tr>
      <tr>
        <td id="L4175" data-line-number="4175"></td>
        <td id="LC4175">    <span>if</span> (lvaOutgoingArgSpaceVar == BAD_VAR_NUM)</td>
      </tr>
      <tr>
        <td id="L4176" data-line-number="4176"></td>
        <td id="LC4176">    {</td>
      </tr>
      <tr>
        <td id="L4177" data-line-number="4177"></td>
        <td id="LC4177">        lvaOutgoingArgSpaceVar = <span>lvaGrabTemp</span>(<span>false</span> <span>DEBUGARG</span>(<span><span>"</span>OutgoingArgSpace<span>"</span></span>));</td>
      </tr>
      <tr>
        <td id="L4178" data-line-number="4178"></td>
        <td id="LC4178">
</td>
      </tr>
      <tr>
        <td id="L4179" data-line-number="4179"></td>
        <td id="LC4179">        lvaTable[lvaOutgoingArgSpaceVar].<span>lvType</span>                 = TYP_LCLBLK;</td>
      </tr>
      <tr>
        <td id="L4180" data-line-number="4180"></td>
        <td id="LC4180">        lvaTable[lvaOutgoingArgSpaceVar].<span>lvImplicitlyReferenced</span> = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L4181" data-line-number="4181"></td>
        <td id="LC4181">    }</td>
      </tr>
      <tr>
        <td id="L4182" data-line-number="4182"></td>
        <td id="LC4182">
</td>
      </tr>
      <tr>
        <td id="L4183" data-line-number="4183"></td>
        <td id="LC4183">    <span>noway_assert</span>(lvaOutgoingArgSpaceVar &gt;= info.<span>compLocalsCount</span> &amp;&amp; lvaOutgoingArgSpaceVar &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L4184" data-line-number="4184"></td>
        <td id="LC4184">
</td>
      </tr>
      <tr>
        <td id="L4185" data-line-number="4185"></td>
        <td id="LC4185">#<span>endif</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L4186" data-line-number="4186"></td>
        <td id="LC4186">}</td>
      </tr>
      <tr>
        <td id="L4187" data-line-number="4187"></td>
        <td id="LC4187">
</td>
      </tr>
      <tr>
        <td id="L4188" data-line-number="4188"></td>
        <td id="LC4188"><span>inline</span> <span>void</span> <span>Compiler::lvaIncrementFrameSize</span>(<span>unsigned</span> size)</td>
      </tr>
      <tr>
        <td id="L4189" data-line-number="4189"></td>
        <td id="LC4189">{</td>
      </tr>
      <tr>
        <td id="L4190" data-line-number="4190"></td>
        <td id="LC4190">    <span>if</span> (size &gt; MAX_FrameSize || compLclFrameSize + size &gt; MAX_FrameSize)</td>
      </tr>
      <tr>
        <td id="L4191" data-line-number="4191"></td>
        <td id="LC4191">    {</td>
      </tr>
      <tr>
        <td id="L4192" data-line-number="4192"></td>
        <td id="LC4192">        <span>BADCODE</span>(<span><span>"</span>Frame size overflow<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4193" data-line-number="4193"></td>
        <td id="LC4193">    }</td>
      </tr>
      <tr>
        <td id="L4194" data-line-number="4194"></td>
        <td id="LC4194">
</td>
      </tr>
      <tr>
        <td id="L4195" data-line-number="4195"></td>
        <td id="LC4195">    compLclFrameSize += size;</td>
      </tr>
      <tr>
        <td id="L4196" data-line-number="4196"></td>
        <td id="LC4196">}</td>
      </tr>
      <tr>
        <td id="L4197" data-line-number="4197"></td>
        <td id="LC4197">
</td>
      </tr>
      <tr>
        <td id="L4198" data-line-number="4198"></td>
        <td id="LC4198"><span><span>/*</span>***************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L4199" data-line-number="4199"></td>
        <td id="LC4199"><span>*</span></td>
      </tr>
      <tr>
        <td id="L4200" data-line-number="4200"></td>
        <td id="LC4200"><span>*  Return true if absolute offsets of temps are larger than vars, or in other</span></td>
      </tr>
      <tr>
        <td id="L4201" data-line-number="4201"></td>
        <td id="LC4201"><span>*  words, did we allocate temps before of after vars.  The /GS buffer overrun</span></td>
      </tr>
      <tr>
        <td id="L4202" data-line-number="4202"></td>
        <td id="LC4202"><span>*  checks want temps to be at low stack addresses than buffers</span></td>
      </tr>
      <tr>
        <td id="L4203" data-line-number="4203"></td>
        <td id="LC4203"><span><span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4204" data-line-number="4204"></td>
        <td id="LC4204"><span>bool</span> <span>Compiler::lvaTempsHaveLargerOffsetThanVars</span>()</td>
      </tr>
      <tr>
        <td id="L4205" data-line-number="4205"></td>
        <td id="LC4205">{</td>
      </tr>
      <tr>
        <td id="L4206" data-line-number="4206"></td>
        <td id="LC4206">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L4207" data-line-number="4207"></td>
        <td id="LC4207">    <span><span>//</span> We never want to place the temps with larger offsets for ARM</span></td>
      </tr>
      <tr>
        <td id="L4208" data-line-number="4208"></td>
        <td id="LC4208">    <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L4209" data-line-number="4209"></td>
        <td id="LC4209">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L4210" data-line-number="4210"></td>
        <td id="LC4210">    <span>if</span> (compGSReorderStackLayout)</td>
      </tr>
      <tr>
        <td id="L4211" data-line-number="4211"></td>
        <td id="LC4211">    {</td>
      </tr>
      <tr>
        <td id="L4212" data-line-number="4212"></td>
        <td id="LC4212">        <span>return</span> codeGen-&gt;<span>isFramePointerUsed</span>();</td>
      </tr>
      <tr>
        <td id="L4213" data-line-number="4213"></td>
        <td id="LC4213">    }</td>
      </tr>
      <tr>
        <td id="L4214" data-line-number="4214"></td>
        <td id="LC4214">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L4215" data-line-number="4215"></td>
        <td id="LC4215">    {</td>
      </tr>
      <tr>
        <td id="L4216" data-line-number="4216"></td>
        <td id="LC4216">        <span>return</span> <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L4217" data-line-number="4217"></td>
        <td id="LC4217">    }</td>
      </tr>
      <tr>
        <td id="L4218" data-line-number="4218"></td>
        <td id="LC4218">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4219" data-line-number="4219"></td>
        <td id="LC4219">}</td>
      </tr>
      <tr>
        <td id="L4220" data-line-number="4220"></td>
        <td id="LC4220">
</td>
      </tr>
      <tr>
        <td id="L4221" data-line-number="4221"></td>
        <td id="LC4221"><span><span>/*</span>***************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L4222" data-line-number="4222"></td>
        <td id="LC4222"><span>*</span></td>
      </tr>
      <tr>
        <td id="L4223" data-line-number="4223"></td>
        <td id="LC4223"><span>*  Return an upper bound estimate for the size of the compiler spill temps</span></td>
      </tr>
      <tr>
        <td id="L4224" data-line-number="4224"></td>
        <td id="LC4224"><span>*</span></td>
      </tr>
      <tr>
        <td id="L4225" data-line-number="4225"></td>
        <td id="LC4225"><span><span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4226" data-line-number="4226"></td>
        <td id="LC4226"><span>unsigned</span> <span>Compiler::lvaGetMaxSpillTempSize</span>()</td>
      </tr>
      <tr>
        <td id="L4227" data-line-number="4227"></td>
        <td id="LC4227">{</td>
      </tr>
      <tr>
        <td id="L4228" data-line-number="4228"></td>
        <td id="LC4228">    <span>unsigned</span> result = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4229" data-line-number="4229"></td>
        <td id="LC4229">
</td>
      </tr>
      <tr>
        <td id="L4230" data-line-number="4230"></td>
        <td id="LC4230">    <span>if</span> (lvaDoneFrameLayout &gt;= REGALLOC_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L4231" data-line-number="4231"></td>
        <td id="LC4231">    {</td>
      </tr>
      <tr>
        <td id="L4232" data-line-number="4232"></td>
        <td id="LC4232">        result = codeGen-&gt;<span>regSet</span>.<span>tmpGetTotalSize</span>();</td>
      </tr>
      <tr>
        <td id="L4233" data-line-number="4233"></td>
        <td id="LC4233">    }</td>
      </tr>
      <tr>
        <td id="L4234" data-line-number="4234"></td>
        <td id="LC4234">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L4235" data-line-number="4235"></td>
        <td id="LC4235">    {</td>
      </tr>
      <tr>
        <td id="L4236" data-line-number="4236"></td>
        <td id="LC4236">        result = MAX_SPILL_TEMP_SIZE;</td>
      </tr>
      <tr>
        <td id="L4237" data-line-number="4237"></td>
        <td id="LC4237">    }</td>
      </tr>
      <tr>
        <td id="L4238" data-line-number="4238"></td>
        <td id="LC4238">    <span>return</span> result;</td>
      </tr>
      <tr>
        <td id="L4239" data-line-number="4239"></td>
        <td id="LC4239">}</td>
      </tr>
      <tr>
        <td id="L4240" data-line-number="4240"></td>
        <td id="LC4240">
</td>
      </tr>
      <tr>
        <td id="L4241" data-line-number="4241"></td>
        <td id="LC4241"><span><span>//</span> clang-format off</span></td>
      </tr>
      <tr>
        <td id="L4242" data-line-number="4242"></td>
        <td id="LC4242"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L4243" data-line-number="4243"></td>
        <td id="LC4243"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4244" data-line-number="4244"></td>
        <td id="LC4244"><span> *  Compute stack frame offsets for arguments, locals and optionally temps.</span></td>
      </tr>
      <tr>
        <td id="L4245" data-line-number="4245"></td>
        <td id="LC4245"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4246" data-line-number="4246"></td>
        <td id="LC4246"><span> *  The frame is laid out as follows for x86:</span></td>
      </tr>
      <tr>
        <td id="L4247" data-line-number="4247"></td>
        <td id="LC4247"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4248" data-line-number="4248"></td>
        <td id="LC4248"><span> *              ESP frames</span></td>
      </tr>
      <tr>
        <td id="L4249" data-line-number="4249"></td>
        <td id="LC4249"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4250" data-line-number="4250"></td>
        <td id="LC4250"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4251" data-line-number="4251"></td>
        <td id="LC4251"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4252" data-line-number="4252"></td>
        <td id="LC4252"><span> *      |       incoming        |</span></td>
      </tr>
      <tr>
        <td id="L4253" data-line-number="4253"></td>
        <td id="LC4253"><span> *      |       arguments       |</span></td>
      </tr>
      <tr>
        <td id="L4254" data-line-number="4254"></td>
        <td id="LC4254"><span> *      |-----------------------| &lt;---- Virtual '0'</span></td>
      </tr>
      <tr>
        <td id="L4255" data-line-number="4255"></td>
        <td id="LC4255"><span> *      |    return address     |</span></td>
      </tr>
      <tr>
        <td id="L4256" data-line-number="4256"></td>
        <td id="LC4256"><span> *      +=======================+</span></td>
      </tr>
      <tr>
        <td id="L4257" data-line-number="4257"></td>
        <td id="LC4257"><span> *      |Callee saved registers |</span></td>
      </tr>
      <tr>
        <td id="L4258" data-line-number="4258"></td>
        <td id="LC4258"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4259" data-line-number="4259"></td>
        <td id="LC4259"><span> *      |       Temps           |</span></td>
      </tr>
      <tr>
        <td id="L4260" data-line-number="4260"></td>
        <td id="LC4260"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4261" data-line-number="4261"></td>
        <td id="LC4261"><span> *      |       Variables       |</span></td>
      </tr>
      <tr>
        <td id="L4262" data-line-number="4262"></td>
        <td id="LC4262"><span> *      |-----------------------| &lt;---- Ambient ESP</span></td>
      </tr>
      <tr>
        <td id="L4263" data-line-number="4263"></td>
        <td id="LC4263"><span> *      |   Arguments for the   |</span></td>
      </tr>
      <tr>
        <td id="L4264" data-line-number="4264"></td>
        <td id="LC4264"><span> *      ~    next function      ~</span></td>
      </tr>
      <tr>
        <td id="L4265" data-line-number="4265"></td>
        <td id="LC4265"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4266" data-line-number="4266"></td>
        <td id="LC4266"><span> *      |       |               |</span></td>
      </tr>
      <tr>
        <td id="L4267" data-line-number="4267"></td>
        <td id="LC4267"><span> *      |       | Stack grows   |</span></td>
      </tr>
      <tr>
        <td id="L4268" data-line-number="4268"></td>
        <td id="LC4268"><span> *              | downward</span></td>
      </tr>
      <tr>
        <td id="L4269" data-line-number="4269"></td>
        <td id="LC4269"><span> *              V</span></td>
      </tr>
      <tr>
        <td id="L4270" data-line-number="4270"></td>
        <td id="LC4270"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4271" data-line-number="4271"></td>
        <td id="LC4271"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4272" data-line-number="4272"></td>
        <td id="LC4272"><span> *              EBP frames</span></td>
      </tr>
      <tr>
        <td id="L4273" data-line-number="4273"></td>
        <td id="LC4273"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4274" data-line-number="4274"></td>
        <td id="LC4274"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4275" data-line-number="4275"></td>
        <td id="LC4275"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4276" data-line-number="4276"></td>
        <td id="LC4276"><span> *      |       incoming        |</span></td>
      </tr>
      <tr>
        <td id="L4277" data-line-number="4277"></td>
        <td id="LC4277"><span> *      |       arguments       |</span></td>
      </tr>
      <tr>
        <td id="L4278" data-line-number="4278"></td>
        <td id="LC4278"><span> *      |-----------------------| &lt;---- Virtual '0'</span></td>
      </tr>
      <tr>
        <td id="L4279" data-line-number="4279"></td>
        <td id="LC4279"><span> *      |    return address     |</span></td>
      </tr>
      <tr>
        <td id="L4280" data-line-number="4280"></td>
        <td id="LC4280"><span> *      +=======================+</span></td>
      </tr>
      <tr>
        <td id="L4281" data-line-number="4281"></td>
        <td id="LC4281"><span> *      |    incoming EBP       |</span></td>
      </tr>
      <tr>
        <td id="L4282" data-line-number="4282"></td>
        <td id="LC4282"><span> *      |-----------------------| &lt;---- EBP</span></td>
      </tr>
      <tr>
        <td id="L4283" data-line-number="4283"></td>
        <td id="LC4283"><span> *      |Callee saved registers |</span></td>
      </tr>
      <tr>
        <td id="L4284" data-line-number="4284"></td>
        <td id="LC4284"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4285" data-line-number="4285"></td>
        <td id="LC4285"><span> *      |   security object     |</span></td>
      </tr>
      <tr>
        <td id="L4286" data-line-number="4286"></td>
        <td id="LC4286"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4287" data-line-number="4287"></td>
        <td id="LC4287"><span> *      |     ParamTypeArg      |</span></td>
      </tr>
      <tr>
        <td id="L4288" data-line-number="4288"></td>
        <td id="LC4288"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4289" data-line-number="4289"></td>
        <td id="LC4289"><span> *      |  Last-executed-filter |</span></td>
      </tr>
      <tr>
        <td id="L4290" data-line-number="4290"></td>
        <td id="LC4290"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4291" data-line-number="4291"></td>
        <td id="LC4291"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4292" data-line-number="4292"></td>
        <td id="LC4292"><span> *      ~      Shadow SPs       ~</span></td>
      </tr>
      <tr>
        <td id="L4293" data-line-number="4293"></td>
        <td id="LC4293"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4294" data-line-number="4294"></td>
        <td id="LC4294"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4295" data-line-number="4295"></td>
        <td id="LC4295"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4296" data-line-number="4296"></td>
        <td id="LC4296"><span> *      ~      Variables        ~</span></td>
      </tr>
      <tr>
        <td id="L4297" data-line-number="4297"></td>
        <td id="LC4297"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4298" data-line-number="4298"></td>
        <td id="LC4298"><span> *      ~-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4299" data-line-number="4299"></td>
        <td id="LC4299"><span> *      |       Temps           |</span></td>
      </tr>
      <tr>
        <td id="L4300" data-line-number="4300"></td>
        <td id="LC4300"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4301" data-line-number="4301"></td>
        <td id="LC4301"><span> *      |       localloc        |</span></td>
      </tr>
      <tr>
        <td id="L4302" data-line-number="4302"></td>
        <td id="LC4302"><span> *      |-----------------------| &lt;---- Ambient ESP</span></td>
      </tr>
      <tr>
        <td id="L4303" data-line-number="4303"></td>
        <td id="LC4303"><span> *      |   Arguments for the   |</span></td>
      </tr>
      <tr>
        <td id="L4304" data-line-number="4304"></td>
        <td id="LC4304"><span> *      |    next function      ~</span></td>
      </tr>
      <tr>
        <td id="L4305" data-line-number="4305"></td>
        <td id="LC4305"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4306" data-line-number="4306"></td>
        <td id="LC4306"><span> *      |       |               |</span></td>
      </tr>
      <tr>
        <td id="L4307" data-line-number="4307"></td>
        <td id="LC4307"><span> *      |       | Stack grows   |</span></td>
      </tr>
      <tr>
        <td id="L4308" data-line-number="4308"></td>
        <td id="LC4308"><span> *              | downward</span></td>
      </tr>
      <tr>
        <td id="L4309" data-line-number="4309"></td>
        <td id="LC4309"><span> *              V</span></td>
      </tr>
      <tr>
        <td id="L4310" data-line-number="4310"></td>
        <td id="LC4310"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4311" data-line-number="4311"></td>
        <td id="LC4311"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4312" data-line-number="4312"></td>
        <td id="LC4312"><span> *  The frame is laid out as follows for x64:</span></td>
      </tr>
      <tr>
        <td id="L4313" data-line-number="4313"></td>
        <td id="LC4313"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4314" data-line-number="4314"></td>
        <td id="LC4314"><span> *              RSP frames</span></td>
      </tr>
      <tr>
        <td id="L4315" data-line-number="4315"></td>
        <td id="LC4315"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4316" data-line-number="4316"></td>
        <td id="LC4316"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4317" data-line-number="4317"></td>
        <td id="LC4317"><span> *      |       incoming        |</span></td>
      </tr>
      <tr>
        <td id="L4318" data-line-number="4318"></td>
        <td id="LC4318"><span> *      |       arguments       |</span></td>
      </tr>
      <tr>
        <td id="L4319" data-line-number="4319"></td>
        <td id="LC4319"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4320" data-line-number="4320"></td>
        <td id="LC4320"><span> *      |   4 fixed incoming    |</span></td>
      </tr>
      <tr>
        <td id="L4321" data-line-number="4321"></td>
        <td id="LC4321"><span> *      |    argument slots     |</span></td>
      </tr>
      <tr>
        <td id="L4322" data-line-number="4322"></td>
        <td id="LC4322"><span> *      |-----------------------| &lt;---- Caller's SP &amp; Virtual '0'</span></td>
      </tr>
      <tr>
        <td id="L4323" data-line-number="4323"></td>
        <td id="LC4323"><span> *      |    return address     |</span></td>
      </tr>
      <tr>
        <td id="L4324" data-line-number="4324"></td>
        <td id="LC4324"><span> *      +=======================+</span></td>
      </tr>
      <tr>
        <td id="L4325" data-line-number="4325"></td>
        <td id="LC4325"><span> *      | Callee saved Int regs |</span></td>
      </tr>
      <tr>
        <td id="L4326" data-line-number="4326"></td>
        <td id="LC4326"><span> *      -------------------------</span></td>
      </tr>
      <tr>
        <td id="L4327" data-line-number="4327"></td>
        <td id="LC4327"><span> *      |        Padding        | &lt;---- this padding (0 or 8 bytes) is to ensure flt registers are saved at a mem location aligned at 16-bytes</span></td>
      </tr>
      <tr>
        <td id="L4328" data-line-number="4328"></td>
        <td id="LC4328"><span> *      |                       |       so that we can save 128-bit callee saved xmm regs using performant "movaps" instruction instead of "movups"</span></td>
      </tr>
      <tr>
        <td id="L4329" data-line-number="4329"></td>
        <td id="LC4329"><span> *      -------------------------</span></td>
      </tr>
      <tr>
        <td id="L4330" data-line-number="4330"></td>
        <td id="LC4330"><span> *      | Callee saved Flt regs | &lt;----- entire 128-bits of callee saved xmm registers are stored here</span></td>
      </tr>
      <tr>
        <td id="L4331" data-line-number="4331"></td>
        <td id="LC4331"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4332" data-line-number="4332"></td>
        <td id="LC4332"><span> *      |         Temps         |</span></td>
      </tr>
      <tr>
        <td id="L4333" data-line-number="4333"></td>
        <td id="LC4333"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4334" data-line-number="4334"></td>
        <td id="LC4334"><span> *      |       Variables       |</span></td>
      </tr>
      <tr>
        <td id="L4335" data-line-number="4335"></td>
        <td id="LC4335"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4336" data-line-number="4336"></td>
        <td id="LC4336"><span> *      |   Arguments for the   |</span></td>
      </tr>
      <tr>
        <td id="L4337" data-line-number="4337"></td>
        <td id="LC4337"><span> *      ~    next function      ~</span></td>
      </tr>
      <tr>
        <td id="L4338" data-line-number="4338"></td>
        <td id="LC4338"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4339" data-line-number="4339"></td>
        <td id="LC4339"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4340" data-line-number="4340"></td>
        <td id="LC4340"><span> *      |   4 fixed outgoing    |</span></td>
      </tr>
      <tr>
        <td id="L4341" data-line-number="4341"></td>
        <td id="LC4341"><span> *      |    argument slots     |</span></td>
      </tr>
      <tr>
        <td id="L4342" data-line-number="4342"></td>
        <td id="LC4342"><span> *      |-----------------------| &lt;---- Ambient RSP</span></td>
      </tr>
      <tr>
        <td id="L4343" data-line-number="4343"></td>
        <td id="LC4343"><span> *      |       |               |</span></td>
      </tr>
      <tr>
        <td id="L4344" data-line-number="4344"></td>
        <td id="LC4344"><span> *      ~       | Stack grows   ~</span></td>
      </tr>
      <tr>
        <td id="L4345" data-line-number="4345"></td>
        <td id="LC4345"><span> *      |       | downward      |</span></td>
      </tr>
      <tr>
        <td id="L4346" data-line-number="4346"></td>
        <td id="LC4346"><span> *              V</span></td>
      </tr>
      <tr>
        <td id="L4347" data-line-number="4347"></td>
        <td id="LC4347"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4348" data-line-number="4348"></td>
        <td id="LC4348"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4349" data-line-number="4349"></td>
        <td id="LC4349"><span> *              RBP frames</span></td>
      </tr>
      <tr>
        <td id="L4350" data-line-number="4350"></td>
        <td id="LC4350"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4351" data-line-number="4351"></td>
        <td id="LC4351"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4352" data-line-number="4352"></td>
        <td id="LC4352"><span> *      |       incoming        |</span></td>
      </tr>
      <tr>
        <td id="L4353" data-line-number="4353"></td>
        <td id="LC4353"><span> *      |       arguments       |</span></td>
      </tr>
      <tr>
        <td id="L4354" data-line-number="4354"></td>
        <td id="LC4354"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4355" data-line-number="4355"></td>
        <td id="LC4355"><span> *      |   4 fixed incoming    |</span></td>
      </tr>
      <tr>
        <td id="L4356" data-line-number="4356"></td>
        <td id="LC4356"><span> *      |    argument slots     |</span></td>
      </tr>
      <tr>
        <td id="L4357" data-line-number="4357"></td>
        <td id="LC4357"><span> *      |-----------------------| &lt;---- Caller's SP &amp; Virtual '0'</span></td>
      </tr>
      <tr>
        <td id="L4358" data-line-number="4358"></td>
        <td id="LC4358"><span> *      |    return address     |</span></td>
      </tr>
      <tr>
        <td id="L4359" data-line-number="4359"></td>
        <td id="LC4359"><span> *      +=======================+</span></td>
      </tr>
      <tr>
        <td id="L4360" data-line-number="4360"></td>
        <td id="LC4360"><span> *      | Callee saved Int regs |</span></td>
      </tr>
      <tr>
        <td id="L4361" data-line-number="4361"></td>
        <td id="LC4361"><span> *      -------------------------</span></td>
      </tr>
      <tr>
        <td id="L4362" data-line-number="4362"></td>
        <td id="LC4362"><span> *      |        Padding        |</span></td>
      </tr>
      <tr>
        <td id="L4363" data-line-number="4363"></td>
        <td id="LC4363"><span> *      -------------------------</span></td>
      </tr>
      <tr>
        <td id="L4364" data-line-number="4364"></td>
        <td id="LC4364"><span> *      | Callee saved Flt regs |</span></td>
      </tr>
      <tr>
        <td id="L4365" data-line-number="4365"></td>
        <td id="LC4365"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4366" data-line-number="4366"></td>
        <td id="LC4366"><span> *      |   security object     |</span></td>
      </tr>
      <tr>
        <td id="L4367" data-line-number="4367"></td>
        <td id="LC4367"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4368" data-line-number="4368"></td>
        <td id="LC4368"><span> *      |     ParamTypeArg      |</span></td>
      </tr>
      <tr>
        <td id="L4369" data-line-number="4369"></td>
        <td id="LC4369"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4370" data-line-number="4370"></td>
        <td id="LC4370"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4371" data-line-number="4371"></td>
        <td id="LC4371"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4372" data-line-number="4372"></td>
        <td id="LC4372"><span> *      ~       Variables       ~</span></td>
      </tr>
      <tr>
        <td id="L4373" data-line-number="4373"></td>
        <td id="LC4373"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4374" data-line-number="4374"></td>
        <td id="LC4374"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4375" data-line-number="4375"></td>
        <td id="LC4375"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4376" data-line-number="4376"></td>
        <td id="LC4376"><span> *      |        Temps          |</span></td>
      </tr>
      <tr>
        <td id="L4377" data-line-number="4377"></td>
        <td id="LC4377"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4378" data-line-number="4378"></td>
        <td id="LC4378"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4379" data-line-number="4379"></td>
        <td id="LC4379"><span> *      ~       localloc        ~   // not in frames with EH</span></td>
      </tr>
      <tr>
        <td id="L4380" data-line-number="4380"></td>
        <td id="LC4380"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4381" data-line-number="4381"></td>
        <td id="LC4381"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4382" data-line-number="4382"></td>
        <td id="LC4382"><span> *      |        PSPSym         |   // only in frames with EH (thus no localloc)</span></td>
      </tr>
      <tr>
        <td id="L4383" data-line-number="4383"></td>
        <td id="LC4383"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4384" data-line-number="4384"></td>
        <td id="LC4384"><span> *      |-----------------------| &lt;---- RBP in localloc frames (max 240 bytes from Initial-SP)</span></td>
      </tr>
      <tr>
        <td id="L4385" data-line-number="4385"></td>
        <td id="LC4385"><span> *      |   Arguments for the   |</span></td>
      </tr>
      <tr>
        <td id="L4386" data-line-number="4386"></td>
        <td id="LC4386"><span> *      ~    next function      ~</span></td>
      </tr>
      <tr>
        <td id="L4387" data-line-number="4387"></td>
        <td id="LC4387"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4388" data-line-number="4388"></td>
        <td id="LC4388"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4389" data-line-number="4389"></td>
        <td id="LC4389"><span> *      |   4 fixed outgoing    |</span></td>
      </tr>
      <tr>
        <td id="L4390" data-line-number="4390"></td>
        <td id="LC4390"><span> *      |    argument slots     |</span></td>
      </tr>
      <tr>
        <td id="L4391" data-line-number="4391"></td>
        <td id="LC4391"><span> *      |-----------------------| &lt;---- Ambient RSP (before localloc, this is Initial-SP)</span></td>
      </tr>
      <tr>
        <td id="L4392" data-line-number="4392"></td>
        <td id="LC4392"><span> *      |       |               |</span></td>
      </tr>
      <tr>
        <td id="L4393" data-line-number="4393"></td>
        <td id="LC4393"><span> *      ~       | Stack grows   ~</span></td>
      </tr>
      <tr>
        <td id="L4394" data-line-number="4394"></td>
        <td id="LC4394"><span> *      |       | downward      |</span></td>
      </tr>
      <tr>
        <td id="L4395" data-line-number="4395"></td>
        <td id="LC4395"><span> *              V</span></td>
      </tr>
      <tr>
        <td id="L4396" data-line-number="4396"></td>
        <td id="LC4396"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4397" data-line-number="4397"></td>
        <td id="LC4397"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4398" data-line-number="4398"></td>
        <td id="LC4398"><span> *  The frame is laid out as follows for ARM (this is a general picture; details may differ for different conditions):</span></td>
      </tr>
      <tr>
        <td id="L4399" data-line-number="4399"></td>
        <td id="LC4399"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4400" data-line-number="4400"></td>
        <td id="LC4400"><span> *              SP frames</span></td>
      </tr>
      <tr>
        <td id="L4401" data-line-number="4401"></td>
        <td id="LC4401"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4402" data-line-number="4402"></td>
        <td id="LC4402"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4403" data-line-number="4403"></td>
        <td id="LC4403"><span> *      |       incoming        |</span></td>
      </tr>
      <tr>
        <td id="L4404" data-line-number="4404"></td>
        <td id="LC4404"><span> *      |       arguments       |</span></td>
      </tr>
      <tr>
        <td id="L4405" data-line-number="4405"></td>
        <td id="LC4405"><span> *      +=======================+ &lt;---- Caller's SP</span></td>
      </tr>
      <tr>
        <td id="L4406" data-line-number="4406"></td>
        <td id="LC4406"><span> *      |  Pre-spill registers  |</span></td>
      </tr>
      <tr>
        <td id="L4407" data-line-number="4407"></td>
        <td id="LC4407"><span> *      |-----------------------| &lt;---- Virtual '0'</span></td>
      </tr>
      <tr>
        <td id="L4408" data-line-number="4408"></td>
        <td id="LC4408"><span> *      |Callee saved registers |</span></td>
      </tr>
      <tr>
        <td id="L4409" data-line-number="4409"></td>
        <td id="LC4409"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4410" data-line-number="4410"></td>
        <td id="LC4410"><span> *      ~ possible double align ~</span></td>
      </tr>
      <tr>
        <td id="L4411" data-line-number="4411"></td>
        <td id="LC4411"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4412" data-line-number="4412"></td>
        <td id="LC4412"><span> *      |   security object     |</span></td>
      </tr>
      <tr>
        <td id="L4413" data-line-number="4413"></td>
        <td id="LC4413"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4414" data-line-number="4414"></td>
        <td id="LC4414"><span> *      |     ParamTypeArg      |</span></td>
      </tr>
      <tr>
        <td id="L4415" data-line-number="4415"></td>
        <td id="LC4415"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4416" data-line-number="4416"></td>
        <td id="LC4416"><span> *      |  possible GS cookie   |</span></td>
      </tr>
      <tr>
        <td id="L4417" data-line-number="4417"></td>
        <td id="LC4417"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4418" data-line-number="4418"></td>
        <td id="LC4418"><span> *      |       Variables       |</span></td>
      </tr>
      <tr>
        <td id="L4419" data-line-number="4419"></td>
        <td id="LC4419"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4420" data-line-number="4420"></td>
        <td id="LC4420"><span> *      |  possible GS cookie   |</span></td>
      </tr>
      <tr>
        <td id="L4421" data-line-number="4421"></td>
        <td id="LC4421"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4422" data-line-number="4422"></td>
        <td id="LC4422"><span> *      |        Temps          |</span></td>
      </tr>
      <tr>
        <td id="L4423" data-line-number="4423"></td>
        <td id="LC4423"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4424" data-line-number="4424"></td>
        <td id="LC4424"><span> *      |   Stub Argument Var   |</span></td>
      </tr>
      <tr>
        <td id="L4425" data-line-number="4425"></td>
        <td id="LC4425"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4426" data-line-number="4426"></td>
        <td id="LC4426"><span> *      |Inlined PInvoke Frame V|</span></td>
      </tr>
      <tr>
        <td id="L4427" data-line-number="4427"></td>
        <td id="LC4427"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4428" data-line-number="4428"></td>
        <td id="LC4428"><span> *      ~ possible double align ~</span></td>
      </tr>
      <tr>
        <td id="L4429" data-line-number="4429"></td>
        <td id="LC4429"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4430" data-line-number="4430"></td>
        <td id="LC4430"><span> *      |   Arguments for the   |</span></td>
      </tr>
      <tr>
        <td id="L4431" data-line-number="4431"></td>
        <td id="LC4431"><span> *      ~    next function      ~</span></td>
      </tr>
      <tr>
        <td id="L4432" data-line-number="4432"></td>
        <td id="LC4432"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4433" data-line-number="4433"></td>
        <td id="LC4433"><span> *      |-----------------------| &lt;---- Ambient SP</span></td>
      </tr>
      <tr>
        <td id="L4434" data-line-number="4434"></td>
        <td id="LC4434"><span> *      |       |               |</span></td>
      </tr>
      <tr>
        <td id="L4435" data-line-number="4435"></td>
        <td id="LC4435"><span> *      ~       | Stack grows   ~</span></td>
      </tr>
      <tr>
        <td id="L4436" data-line-number="4436"></td>
        <td id="LC4436"><span> *      |       | downward      |</span></td>
      </tr>
      <tr>
        <td id="L4437" data-line-number="4437"></td>
        <td id="LC4437"><span> *              V</span></td>
      </tr>
      <tr>
        <td id="L4438" data-line-number="4438"></td>
        <td id="LC4438"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4439" data-line-number="4439"></td>
        <td id="LC4439"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4440" data-line-number="4440"></td>
        <td id="LC4440"><span> *              FP / R11 frames</span></td>
      </tr>
      <tr>
        <td id="L4441" data-line-number="4441"></td>
        <td id="LC4441"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4442" data-line-number="4442"></td>
        <td id="LC4442"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4443" data-line-number="4443"></td>
        <td id="LC4443"><span> *      |       incoming        |</span></td>
      </tr>
      <tr>
        <td id="L4444" data-line-number="4444"></td>
        <td id="LC4444"><span> *      |       arguments       |</span></td>
      </tr>
      <tr>
        <td id="L4445" data-line-number="4445"></td>
        <td id="LC4445"><span> *      +=======================+ &lt;---- Caller's SP</span></td>
      </tr>
      <tr>
        <td id="L4446" data-line-number="4446"></td>
        <td id="LC4446"><span> *      |  Pre-spill registers  |</span></td>
      </tr>
      <tr>
        <td id="L4447" data-line-number="4447"></td>
        <td id="LC4447"><span> *      |-----------------------| &lt;---- Virtual '0'</span></td>
      </tr>
      <tr>
        <td id="L4448" data-line-number="4448"></td>
        <td id="LC4448"><span> *      |Callee saved registers |</span></td>
      </tr>
      <tr>
        <td id="L4449" data-line-number="4449"></td>
        <td id="LC4449"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4450" data-line-number="4450"></td>
        <td id="LC4450"><span> *      |        PSPSym         |   // Only for frames with EH, which means FP-based frames</span></td>
      </tr>
      <tr>
        <td id="L4451" data-line-number="4451"></td>
        <td id="LC4451"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4452" data-line-number="4452"></td>
        <td id="LC4452"><span> *      ~ possible double align ~</span></td>
      </tr>
      <tr>
        <td id="L4453" data-line-number="4453"></td>
        <td id="LC4453"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4454" data-line-number="4454"></td>
        <td id="LC4454"><span> *      |   security object     |</span></td>
      </tr>
      <tr>
        <td id="L4455" data-line-number="4455"></td>
        <td id="LC4455"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4456" data-line-number="4456"></td>
        <td id="LC4456"><span> *      |     ParamTypeArg      |</span></td>
      </tr>
      <tr>
        <td id="L4457" data-line-number="4457"></td>
        <td id="LC4457"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4458" data-line-number="4458"></td>
        <td id="LC4458"><span> *      |  possible GS cookie   |</span></td>
      </tr>
      <tr>
        <td id="L4459" data-line-number="4459"></td>
        <td id="LC4459"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4460" data-line-number="4460"></td>
        <td id="LC4460"><span> *      |       Variables       |</span></td>
      </tr>
      <tr>
        <td id="L4461" data-line-number="4461"></td>
        <td id="LC4461"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4462" data-line-number="4462"></td>
        <td id="LC4462"><span> *      |  possible GS cookie   |</span></td>
      </tr>
      <tr>
        <td id="L4463" data-line-number="4463"></td>
        <td id="LC4463"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4464" data-line-number="4464"></td>
        <td id="LC4464"><span> *      |        Temps          |</span></td>
      </tr>
      <tr>
        <td id="L4465" data-line-number="4465"></td>
        <td id="LC4465"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4466" data-line-number="4466"></td>
        <td id="LC4466"><span> *      |   Stub Argument Var   |</span></td>
      </tr>
      <tr>
        <td id="L4467" data-line-number="4467"></td>
        <td id="LC4467"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4468" data-line-number="4468"></td>
        <td id="LC4468"><span> *      |Inlined PInvoke Frame V|</span></td>
      </tr>
      <tr>
        <td id="L4469" data-line-number="4469"></td>
        <td id="LC4469"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4470" data-line-number="4470"></td>
        <td id="LC4470"><span> *      ~ possible double align ~</span></td>
      </tr>
      <tr>
        <td id="L4471" data-line-number="4471"></td>
        <td id="LC4471"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4472" data-line-number="4472"></td>
        <td id="LC4472"><span> *      |       localloc        |</span></td>
      </tr>
      <tr>
        <td id="L4473" data-line-number="4473"></td>
        <td id="LC4473"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4474" data-line-number="4474"></td>
        <td id="LC4474"><span> *      |   Arguments for the   |</span></td>
      </tr>
      <tr>
        <td id="L4475" data-line-number="4475"></td>
        <td id="LC4475"><span> *      ~    next function      ~</span></td>
      </tr>
      <tr>
        <td id="L4476" data-line-number="4476"></td>
        <td id="LC4476"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4477" data-line-number="4477"></td>
        <td id="LC4477"><span> *      |-----------------------| &lt;---- Ambient SP</span></td>
      </tr>
      <tr>
        <td id="L4478" data-line-number="4478"></td>
        <td id="LC4478"><span> *      |       |               |</span></td>
      </tr>
      <tr>
        <td id="L4479" data-line-number="4479"></td>
        <td id="LC4479"><span> *      ~       | Stack grows   ~</span></td>
      </tr>
      <tr>
        <td id="L4480" data-line-number="4480"></td>
        <td id="LC4480"><span> *      |       | downward      |</span></td>
      </tr>
      <tr>
        <td id="L4481" data-line-number="4481"></td>
        <td id="LC4481"><span> *              V</span></td>
      </tr>
      <tr>
        <td id="L4482" data-line-number="4482"></td>
        <td id="LC4482"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4483" data-line-number="4483"></td>
        <td id="LC4483"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4484" data-line-number="4484"></td>
        <td id="LC4484"><span> *  The frame is laid out as follows for ARM64 (this is a general picture; details may differ for different conditions):</span></td>
      </tr>
      <tr>
        <td id="L4485" data-line-number="4485"></td>
        <td id="LC4485"><span> *  NOTE: SP must be 16-byte aligned, so there may be alignment slots in the frame.</span></td>
      </tr>
      <tr>
        <td id="L4486" data-line-number="4486"></td>
        <td id="LC4486"><span> *  We will often save and establish a frame pointer to create better ETW stack walks.</span></td>
      </tr>
      <tr>
        <td id="L4487" data-line-number="4487"></td>
        <td id="LC4487"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4488" data-line-number="4488"></td>
        <td id="LC4488"><span> *              SP frames</span></td>
      </tr>
      <tr>
        <td id="L4489" data-line-number="4489"></td>
        <td id="LC4489"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4490" data-line-number="4490"></td>
        <td id="LC4490"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4491" data-line-number="4491"></td>
        <td id="LC4491"><span> *      |       incoming        |</span></td>
      </tr>
      <tr>
        <td id="L4492" data-line-number="4492"></td>
        <td id="LC4492"><span> *      |       arguments       |</span></td>
      </tr>
      <tr>
        <td id="L4493" data-line-number="4493"></td>
        <td id="LC4493"><span> *      +=======================+ &lt;---- Caller's SP</span></td>
      </tr>
      <tr>
        <td id="L4494" data-line-number="4494"></td>
        <td id="LC4494"><span> *      |         homed         | // this is only needed if reg argument need to be homed, e.g., for varargs</span></td>
      </tr>
      <tr>
        <td id="L4495" data-line-number="4495"></td>
        <td id="LC4495"><span> *      |   register arguments  |</span></td>
      </tr>
      <tr>
        <td id="L4496" data-line-number="4496"></td>
        <td id="LC4496"><span> *      |-----------------------| &lt;---- Virtual '0'</span></td>
      </tr>
      <tr>
        <td id="L4497" data-line-number="4497"></td>
        <td id="LC4497"><span> *      |Callee saved registers |</span></td>
      </tr>
      <tr>
        <td id="L4498" data-line-number="4498"></td>
        <td id="LC4498"><span> *      |   except fp/lr        |</span></td>
      </tr>
      <tr>
        <td id="L4499" data-line-number="4499"></td>
        <td id="LC4499"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4500" data-line-number="4500"></td>
        <td id="LC4500"><span> *      |   security object     |</span></td>
      </tr>
      <tr>
        <td id="L4501" data-line-number="4501"></td>
        <td id="LC4501"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4502" data-line-number="4502"></td>
        <td id="LC4502"><span> *      |     ParamTypeArg      |</span></td>
      </tr>
      <tr>
        <td id="L4503" data-line-number="4503"></td>
        <td id="LC4503"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4504" data-line-number="4504"></td>
        <td id="LC4504"><span> *      |  possible GS cookie   |</span></td>
      </tr>
      <tr>
        <td id="L4505" data-line-number="4505"></td>
        <td id="LC4505"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4506" data-line-number="4506"></td>
        <td id="LC4506"><span> *      |       Variables       |</span></td>
      </tr>
      <tr>
        <td id="L4507" data-line-number="4507"></td>
        <td id="LC4507"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4508" data-line-number="4508"></td>
        <td id="LC4508"><span> *      |  possible GS cookie   |</span></td>
      </tr>
      <tr>
        <td id="L4509" data-line-number="4509"></td>
        <td id="LC4509"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4510" data-line-number="4510"></td>
        <td id="LC4510"><span> *      |        Temps          |</span></td>
      </tr>
      <tr>
        <td id="L4511" data-line-number="4511"></td>
        <td id="LC4511"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4512" data-line-number="4512"></td>
        <td id="LC4512"><span> *      |   Stub Argument Var   |</span></td>
      </tr>
      <tr>
        <td id="L4513" data-line-number="4513"></td>
        <td id="LC4513"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4514" data-line-number="4514"></td>
        <td id="LC4514"><span> *      |Inlined PInvoke Frame V|</span></td>
      </tr>
      <tr>
        <td id="L4515" data-line-number="4515"></td>
        <td id="LC4515"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4516" data-line-number="4516"></td>
        <td id="LC4516"><span> *      |      Saved LR         |</span></td>
      </tr>
      <tr>
        <td id="L4517" data-line-number="4517"></td>
        <td id="LC4517"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4518" data-line-number="4518"></td>
        <td id="LC4518"><span> *      |      Saved FP         | &lt;---- Frame pointer</span></td>
      </tr>
      <tr>
        <td id="L4519" data-line-number="4519"></td>
        <td id="LC4519"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4520" data-line-number="4520"></td>
        <td id="LC4520"><span> *      |  Stack arguments for  |</span></td>
      </tr>
      <tr>
        <td id="L4521" data-line-number="4521"></td>
        <td id="LC4521"><span> *      |   the next function   |</span></td>
      </tr>
      <tr>
        <td id="L4522" data-line-number="4522"></td>
        <td id="LC4522"><span> *      |-----------------------| &lt;---- SP</span></td>
      </tr>
      <tr>
        <td id="L4523" data-line-number="4523"></td>
        <td id="LC4523"><span> *      |       |               |</span></td>
      </tr>
      <tr>
        <td id="L4524" data-line-number="4524"></td>
        <td id="LC4524"><span> *      ~       | Stack grows   ~</span></td>
      </tr>
      <tr>
        <td id="L4525" data-line-number="4525"></td>
        <td id="LC4525"><span> *      |       | downward      |</span></td>
      </tr>
      <tr>
        <td id="L4526" data-line-number="4526"></td>
        <td id="LC4526"><span> *              V</span></td>
      </tr>
      <tr>
        <td id="L4527" data-line-number="4527"></td>
        <td id="LC4527"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4528" data-line-number="4528"></td>
        <td id="LC4528"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4529" data-line-number="4529"></td>
        <td id="LC4529"><span> *              FP (R29 / x29) frames</span></td>
      </tr>
      <tr>
        <td id="L4530" data-line-number="4530"></td>
        <td id="LC4530"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4531" data-line-number="4531"></td>
        <td id="LC4531"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4532" data-line-number="4532"></td>
        <td id="LC4532"><span> *      |       incoming        |</span></td>
      </tr>
      <tr>
        <td id="L4533" data-line-number="4533"></td>
        <td id="LC4533"><span> *      |       arguments       |</span></td>
      </tr>
      <tr>
        <td id="L4534" data-line-number="4534"></td>
        <td id="LC4534"><span> *      +=======================+ &lt;---- Caller's SP</span></td>
      </tr>
      <tr>
        <td id="L4535" data-line-number="4535"></td>
        <td id="LC4535"><span> *      |     optional homed    | // this is only needed if reg argument need to be homed, e.g., for varargs</span></td>
      </tr>
      <tr>
        <td id="L4536" data-line-number="4536"></td>
        <td id="LC4536"><span> *      |   register arguments  |</span></td>
      </tr>
      <tr>
        <td id="L4537" data-line-number="4537"></td>
        <td id="LC4537"><span> *      |-----------------------| &lt;---- Virtual '0'</span></td>
      </tr>
      <tr>
        <td id="L4538" data-line-number="4538"></td>
        <td id="LC4538"><span> *      |Callee saved registers |</span></td>
      </tr>
      <tr>
        <td id="L4539" data-line-number="4539"></td>
        <td id="LC4539"><span> *      |   except fp/lr        |</span></td>
      </tr>
      <tr>
        <td id="L4540" data-line-number="4540"></td>
        <td id="LC4540"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4541" data-line-number="4541"></td>
        <td id="LC4541"><span> *      |        PSPSym         | // Only for frames with EH, which requires FP-based frames</span></td>
      </tr>
      <tr>
        <td id="L4542" data-line-number="4542"></td>
        <td id="LC4542"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4543" data-line-number="4543"></td>
        <td id="LC4543"><span> *      |   security object     |</span></td>
      </tr>
      <tr>
        <td id="L4544" data-line-number="4544"></td>
        <td id="LC4544"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4545" data-line-number="4545"></td>
        <td id="LC4545"><span> *      |     ParamTypeArg      |</span></td>
      </tr>
      <tr>
        <td id="L4546" data-line-number="4546"></td>
        <td id="LC4546"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4547" data-line-number="4547"></td>
        <td id="LC4547"><span> *      |  possible GS cookie   |</span></td>
      </tr>
      <tr>
        <td id="L4548" data-line-number="4548"></td>
        <td id="LC4548"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4549" data-line-number="4549"></td>
        <td id="LC4549"><span> *      |       Variables       |</span></td>
      </tr>
      <tr>
        <td id="L4550" data-line-number="4550"></td>
        <td id="LC4550"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4551" data-line-number="4551"></td>
        <td id="LC4551"><span> *      |  possible GS cookie   |</span></td>
      </tr>
      <tr>
        <td id="L4552" data-line-number="4552"></td>
        <td id="LC4552"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4553" data-line-number="4553"></td>
        <td id="LC4553"><span> *      |        Temps          |</span></td>
      </tr>
      <tr>
        <td id="L4554" data-line-number="4554"></td>
        <td id="LC4554"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4555" data-line-number="4555"></td>
        <td id="LC4555"><span> *      |   Stub Argument Var   |</span></td>
      </tr>
      <tr>
        <td id="L4556" data-line-number="4556"></td>
        <td id="LC4556"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4557" data-line-number="4557"></td>
        <td id="LC4557"><span> *      |Inlined PInvoke Frame V|</span></td>
      </tr>
      <tr>
        <td id="L4558" data-line-number="4558"></td>
        <td id="LC4558"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4559" data-line-number="4559"></td>
        <td id="LC4559"><span> *      |      Saved LR         |</span></td>
      </tr>
      <tr>
        <td id="L4560" data-line-number="4560"></td>
        <td id="LC4560"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4561" data-line-number="4561"></td>
        <td id="LC4561"><span> *      |      Saved FP         | &lt;---- Frame pointer</span></td>
      </tr>
      <tr>
        <td id="L4562" data-line-number="4562"></td>
        <td id="LC4562"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4563" data-line-number="4563"></td>
        <td id="LC4563"><span> *      ~       localloc        ~</span></td>
      </tr>
      <tr>
        <td id="L4564" data-line-number="4564"></td>
        <td id="LC4564"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4565" data-line-number="4565"></td>
        <td id="LC4565"><span> *      |  Stack arguments for  |</span></td>
      </tr>
      <tr>
        <td id="L4566" data-line-number="4566"></td>
        <td id="LC4566"><span> *      |   the next function   |</span></td>
      </tr>
      <tr>
        <td id="L4567" data-line-number="4567"></td>
        <td id="LC4567"><span> *      |-----------------------| &lt;---- Ambient SP</span></td>
      </tr>
      <tr>
        <td id="L4568" data-line-number="4568"></td>
        <td id="LC4568"><span> *      |       |               |</span></td>
      </tr>
      <tr>
        <td id="L4569" data-line-number="4569"></td>
        <td id="LC4569"><span> *      ~       | Stack grows   ~</span></td>
      </tr>
      <tr>
        <td id="L4570" data-line-number="4570"></td>
        <td id="LC4570"><span> *      |       | downward      |</span></td>
      </tr>
      <tr>
        <td id="L4571" data-line-number="4571"></td>
        <td id="LC4571"><span> *              V</span></td>
      </tr>
      <tr>
        <td id="L4572" data-line-number="4572"></td>
        <td id="LC4572"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4573" data-line-number="4573"></td>
        <td id="LC4573"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4574" data-line-number="4574"></td>
        <td id="LC4574"><span> *              FP (R29 / x29) frames where FP/LR are stored at the top of the frame (frames requiring GS that have localloc)</span></td>
      </tr>
      <tr>
        <td id="L4575" data-line-number="4575"></td>
        <td id="LC4575"><span> *      |                       |</span></td>
      </tr>
      <tr>
        <td id="L4576" data-line-number="4576"></td>
        <td id="LC4576"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4577" data-line-number="4577"></td>
        <td id="LC4577"><span> *      |       incoming        |</span></td>
      </tr>
      <tr>
        <td id="L4578" data-line-number="4578"></td>
        <td id="LC4578"><span> *      |       arguments       |</span></td>
      </tr>
      <tr>
        <td id="L4579" data-line-number="4579"></td>
        <td id="LC4579"><span> *      +=======================+ &lt;---- Caller's SP</span></td>
      </tr>
      <tr>
        <td id="L4580" data-line-number="4580"></td>
        <td id="LC4580"><span> *      |     optional homed    | // this is only needed if reg argument need to be homed, e.g., for varargs</span></td>
      </tr>
      <tr>
        <td id="L4581" data-line-number="4581"></td>
        <td id="LC4581"><span> *      |   register arguments  |</span></td>
      </tr>
      <tr>
        <td id="L4582" data-line-number="4582"></td>
        <td id="LC4582"><span> *      |-----------------------| &lt;---- Virtual '0'</span></td>
      </tr>
      <tr>
        <td id="L4583" data-line-number="4583"></td>
        <td id="LC4583"><span> *      |      Saved LR         |</span></td>
      </tr>
      <tr>
        <td id="L4584" data-line-number="4584"></td>
        <td id="LC4584"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4585" data-line-number="4585"></td>
        <td id="LC4585"><span> *      |      Saved FP         | &lt;---- Frame pointer</span></td>
      </tr>
      <tr>
        <td id="L4586" data-line-number="4586"></td>
        <td id="LC4586"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4587" data-line-number="4587"></td>
        <td id="LC4587"><span> *      |Callee saved registers |</span></td>
      </tr>
      <tr>
        <td id="L4588" data-line-number="4588"></td>
        <td id="LC4588"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4589" data-line-number="4589"></td>
        <td id="LC4589"><span> *      |        PSPSym         | // Only for frames with EH, which requires FP-based frames</span></td>
      </tr>
      <tr>
        <td id="L4590" data-line-number="4590"></td>
        <td id="LC4590"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4591" data-line-number="4591"></td>
        <td id="LC4591"><span> *      |   security object     |</span></td>
      </tr>
      <tr>
        <td id="L4592" data-line-number="4592"></td>
        <td id="LC4592"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4593" data-line-number="4593"></td>
        <td id="LC4593"><span> *      |     ParamTypeArg      |</span></td>
      </tr>
      <tr>
        <td id="L4594" data-line-number="4594"></td>
        <td id="LC4594"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4595" data-line-number="4595"></td>
        <td id="LC4595"><span> *      |  possible GS cookie   |</span></td>
      </tr>
      <tr>
        <td id="L4596" data-line-number="4596"></td>
        <td id="LC4596"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4597" data-line-number="4597"></td>
        <td id="LC4597"><span> *      |       Variables       |</span></td>
      </tr>
      <tr>
        <td id="L4598" data-line-number="4598"></td>
        <td id="LC4598"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4599" data-line-number="4599"></td>
        <td id="LC4599"><span> *      |  possible GS cookie   |</span></td>
      </tr>
      <tr>
        <td id="L4600" data-line-number="4600"></td>
        <td id="LC4600"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4601" data-line-number="4601"></td>
        <td id="LC4601"><span> *      |        Temps          |</span></td>
      </tr>
      <tr>
        <td id="L4602" data-line-number="4602"></td>
        <td id="LC4602"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4603" data-line-number="4603"></td>
        <td id="LC4603"><span> *      |   Stub Argument Var   |</span></td>
      </tr>
      <tr>
        <td id="L4604" data-line-number="4604"></td>
        <td id="LC4604"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4605" data-line-number="4605"></td>
        <td id="LC4605"><span> *      |Inlined PInvoke Frame V|</span></td>
      </tr>
      <tr>
        <td id="L4606" data-line-number="4606"></td>
        <td id="LC4606"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4607" data-line-number="4607"></td>
        <td id="LC4607"><span> *      ~       localloc        ~</span></td>
      </tr>
      <tr>
        <td id="L4608" data-line-number="4608"></td>
        <td id="LC4608"><span> *      |-----------------------|</span></td>
      </tr>
      <tr>
        <td id="L4609" data-line-number="4609"></td>
        <td id="LC4609"><span> *      |  Stack arguments for  |</span></td>
      </tr>
      <tr>
        <td id="L4610" data-line-number="4610"></td>
        <td id="LC4610"><span> *      |   the next function   |</span></td>
      </tr>
      <tr>
        <td id="L4611" data-line-number="4611"></td>
        <td id="LC4611"><span> *      |-----------------------| &lt;---- Ambient SP</span></td>
      </tr>
      <tr>
        <td id="L4612" data-line-number="4612"></td>
        <td id="LC4612"><span> *      |       |               |</span></td>
      </tr>
      <tr>
        <td id="L4613" data-line-number="4613"></td>
        <td id="LC4613"><span> *      ~       | Stack grows   ~</span></td>
      </tr>
      <tr>
        <td id="L4614" data-line-number="4614"></td>
        <td id="LC4614"><span> *      |       | downward      |</span></td>
      </tr>
      <tr>
        <td id="L4615" data-line-number="4615"></td>
        <td id="LC4615"><span> *              V</span></td>
      </tr>
      <tr>
        <td id="L4616" data-line-number="4616"></td>
        <td id="LC4616"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4617" data-line-number="4617"></td>
        <td id="LC4617"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4618" data-line-number="4618"></td>
        <td id="LC4618"><span> *  Doing this all in one pass is 'hard'.  So instead we do it in 2 basic passes:</span></td>
      </tr>
      <tr>
        <td id="L4619" data-line-number="4619"></td>
        <td id="LC4619"><span> *    1. Assign all the offsets relative to the Virtual '0'. Offsets above (the</span></td>
      </tr>
      <tr>
        <td id="L4620" data-line-number="4620"></td>
        <td id="LC4620"><span> *      incoming arguments) are positive. Offsets below (everything else) are</span></td>
      </tr>
      <tr>
        <td id="L4621" data-line-number="4621"></td>
        <td id="LC4621"><span> *      negative.  This pass also calcuates the total frame size (between Caller's</span></td>
      </tr>
      <tr>
        <td id="L4622" data-line-number="4622"></td>
        <td id="LC4622"><span> *      SP/return address and the Ambient SP).</span></td>
      </tr>
      <tr>
        <td id="L4623" data-line-number="4623"></td>
        <td id="LC4623"><span> *    2. Figure out where to place the frame pointer, and then adjust the offsets</span></td>
      </tr>
      <tr>
        <td id="L4624" data-line-number="4624"></td>
        <td id="LC4624"><span> *      as needed for the final stack size and whether the offset is frame pointer</span></td>
      </tr>
      <tr>
        <td id="L4625" data-line-number="4625"></td>
        <td id="LC4625"><span> *      relative or stack pointer relative.</span></td>
      </tr>
      <tr>
        <td id="L4626" data-line-number="4626"></td>
        <td id="LC4626"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4627" data-line-number="4627"></td>
        <td id="LC4627"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4628" data-line-number="4628"></td>
        <td id="LC4628"><span><span>//</span> clang-format on</span></td>
      </tr>
      <tr>
        <td id="L4629" data-line-number="4629"></td>
        <td id="LC4629">
</td>
      </tr>
      <tr>
        <td id="L4630" data-line-number="4630"></td>
        <td id="LC4630"><span>void</span> <span>Compiler::lvaAssignFrameOffsets</span>(FrameLayoutState curState)</td>
      </tr>
      <tr>
        <td id="L4631" data-line-number="4631"></td>
        <td id="LC4631">{</td>
      </tr>
      <tr>
        <td id="L4632" data-line-number="4632"></td>
        <td id="LC4632">    <span>noway_assert</span>((lvaDoneFrameLayout &lt; curState) || (curState == REGALLOC_FRAME_LAYOUT));</td>
      </tr>
      <tr>
        <td id="L4633" data-line-number="4633"></td>
        <td id="LC4633">
</td>
      </tr>
      <tr>
        <td id="L4634" data-line-number="4634"></td>
        <td id="LC4634">    lvaDoneFrameLayout = curState;</td>
      </tr>
      <tr>
        <td id="L4635" data-line-number="4635"></td>
        <td id="LC4635">
</td>
      </tr>
      <tr>
        <td id="L4636" data-line-number="4636"></td>
        <td id="LC4636">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L4637" data-line-number="4637"></td>
        <td id="LC4637">    <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L4638" data-line-number="4638"></td>
        <td id="LC4638">    {</td>
      </tr>
      <tr>
        <td id="L4639" data-line-number="4639"></td>
        <td id="LC4639">
</td>
      </tr>
      <tr>
        <td id="L4640" data-line-number="4640"></td>
        <td id="LC4640">        <span>printf</span>(<span><span>"</span>*************** In lvaAssignFrameOffsets<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4641" data-line-number="4641"></td>
        <td id="LC4641">        <span>if</span> (curState == INITIAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L4642" data-line-number="4642"></td>
        <td id="LC4642">        {</td>
      </tr>
      <tr>
        <td id="L4643" data-line-number="4643"></td>
        <td id="LC4643">            <span>printf</span>(<span><span>"</span>(INITIAL_FRAME_LAYOUT)<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4644" data-line-number="4644"></td>
        <td id="LC4644">        }</td>
      </tr>
      <tr>
        <td id="L4645" data-line-number="4645"></td>
        <td id="LC4645">        <span>else</span> <span>if</span> (curState == PRE_REGALLOC_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L4646" data-line-number="4646"></td>
        <td id="LC4646">        {</td>
      </tr>
      <tr>
        <td id="L4647" data-line-number="4647"></td>
        <td id="LC4647">            <span>printf</span>(<span><span>"</span>(PRE_REGALLOC_FRAME_LAYOUT)<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4648" data-line-number="4648"></td>
        <td id="LC4648">        }</td>
      </tr>
      <tr>
        <td id="L4649" data-line-number="4649"></td>
        <td id="LC4649">        <span>else</span> <span>if</span> (curState == REGALLOC_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L4650" data-line-number="4650"></td>
        <td id="LC4650">        {</td>
      </tr>
      <tr>
        <td id="L4651" data-line-number="4651"></td>
        <td id="LC4651">            <span>printf</span>(<span><span>"</span>(REGALLOC_FRAME_LAYOUT)<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4652" data-line-number="4652"></td>
        <td id="LC4652">        }</td>
      </tr>
      <tr>
        <td id="L4653" data-line-number="4653"></td>
        <td id="LC4653">        <span>else</span> <span>if</span> (curState == TENTATIVE_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L4654" data-line-number="4654"></td>
        <td id="LC4654">        {</td>
      </tr>
      <tr>
        <td id="L4655" data-line-number="4655"></td>
        <td id="LC4655">            <span>printf</span>(<span><span>"</span>(TENTATIVE_FRAME_LAYOUT)<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4656" data-line-number="4656"></td>
        <td id="LC4656">        }</td>
      </tr>
      <tr>
        <td id="L4657" data-line-number="4657"></td>
        <td id="LC4657">        <span>else</span> <span>if</span> (curState == FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L4658" data-line-number="4658"></td>
        <td id="LC4658">        {</td>
      </tr>
      <tr>
        <td id="L4659" data-line-number="4659"></td>
        <td id="LC4659">            <span>printf</span>(<span><span>"</span>(FINAL_FRAME_LAYOUT)<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4660" data-line-number="4660"></td>
        <td id="LC4660">        }</td>
      </tr>
      <tr>
        <td id="L4661" data-line-number="4661"></td>
        <td id="LC4661">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L4662" data-line-number="4662"></td>
        <td id="LC4662">        {</td>
      </tr>
      <tr>
        <td id="L4663" data-line-number="4663"></td>
        <td id="LC4663">            <span>printf</span>(<span><span>"</span>(UNKNOWN)<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4664" data-line-number="4664"></td>
        <td id="LC4664">            <span>unreached</span>();</td>
      </tr>
      <tr>
        <td id="L4665" data-line-number="4665"></td>
        <td id="LC4665">        }</td>
      </tr>
      <tr>
        <td id="L4666" data-line-number="4666"></td>
        <td id="LC4666">        <span>printf</span>(<span><span>"</span><span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L4667" data-line-number="4667"></td>
        <td id="LC4667">    }</td>
      </tr>
      <tr>
        <td id="L4668" data-line-number="4668"></td>
        <td id="LC4668">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4669" data-line-number="4669"></td>
        <td id="LC4669">
</td>
      </tr>
      <tr>
        <td id="L4670" data-line-number="4670"></td>
        <td id="LC4670">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L4671" data-line-number="4671"></td>
        <td id="LC4671">    <span>assert</span>(lvaOutgoingArgSpaceVar != BAD_VAR_NUM);</td>
      </tr>
      <tr>
        <td id="L4672" data-line-number="4672"></td>
        <td id="LC4672">#<span>endif</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L4673" data-line-number="4673"></td>
        <td id="LC4673">
</td>
      </tr>
      <tr>
        <td id="L4674" data-line-number="4674"></td>
        <td id="LC4674">    <span><span>/*</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4675" data-line-number="4675"></td>
        <td id="LC4675"><span>     *</span></td>
      </tr>
      <tr>
        <td id="L4676" data-line-number="4676"></td>
        <td id="LC4676"><span>     * First process the arguments.</span></td>
      </tr>
      <tr>
        <td id="L4677" data-line-number="4677"></td>
        <td id="LC4677"><span>     *</span></td>
      </tr>
      <tr>
        <td id="L4678" data-line-number="4678"></td>
        <td id="LC4678"><span>     *-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4679" data-line-number="4679"></td>
        <td id="LC4679"><span>     <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4680" data-line-number="4680"></td>
        <td id="LC4680">
</td>
      </tr>
      <tr>
        <td id="L4681" data-line-number="4681"></td>
        <td id="LC4681">    <span>lvaAssignVirtualFrameOffsetsToArgs</span>();</td>
      </tr>
      <tr>
        <td id="L4682" data-line-number="4682"></td>
        <td id="LC4682">
</td>
      </tr>
      <tr>
        <td id="L4683" data-line-number="4683"></td>
        <td id="LC4683">    <span><span>/*</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4684" data-line-number="4684"></td>
        <td id="LC4684"><span>     *</span></td>
      </tr>
      <tr>
        <td id="L4685" data-line-number="4685"></td>
        <td id="LC4685"><span>     * Now compute stack offsets for any variables that don't live in registers</span></td>
      </tr>
      <tr>
        <td id="L4686" data-line-number="4686"></td>
        <td id="LC4686"><span>     *</span></td>
      </tr>
      <tr>
        <td id="L4687" data-line-number="4687"></td>
        <td id="LC4687"><span>     *-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4688" data-line-number="4688"></td>
        <td id="LC4688"><span>     <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4689" data-line-number="4689"></td>
        <td id="LC4689">
</td>
      </tr>
      <tr>
        <td id="L4690" data-line-number="4690"></td>
        <td id="LC4690">    <span>lvaAssignVirtualFrameOffsetsToLocals</span>();</td>
      </tr>
      <tr>
        <td id="L4691" data-line-number="4691"></td>
        <td id="LC4691">
</td>
      </tr>
      <tr>
        <td id="L4692" data-line-number="4692"></td>
        <td id="LC4692">    <span>lvaAlignFrame</span>();</td>
      </tr>
      <tr>
        <td id="L4693" data-line-number="4693"></td>
        <td id="LC4693">
</td>
      </tr>
      <tr>
        <td id="L4694" data-line-number="4694"></td>
        <td id="LC4694">    <span><span>/*</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4695" data-line-number="4695"></td>
        <td id="LC4695"><span>     *</span></td>
      </tr>
      <tr>
        <td id="L4696" data-line-number="4696"></td>
        <td id="LC4696"><span>     * Now patch the offsets</span></td>
      </tr>
      <tr>
        <td id="L4697" data-line-number="4697"></td>
        <td id="LC4697"><span>     *</span></td>
      </tr>
      <tr>
        <td id="L4698" data-line-number="4698"></td>
        <td id="LC4698"><span>     *-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4699" data-line-number="4699"></td>
        <td id="LC4699"><span>     <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4700" data-line-number="4700"></td>
        <td id="LC4700">
</td>
      </tr>
      <tr>
        <td id="L4701" data-line-number="4701"></td>
        <td id="LC4701">    <span>lvaFixVirtualFrameOffsets</span>();</td>
      </tr>
      <tr>
        <td id="L4702" data-line-number="4702"></td>
        <td id="LC4702">
</td>
      </tr>
      <tr>
        <td id="L4703" data-line-number="4703"></td>
        <td id="LC4703">    <span><span>//</span> Modify the stack offset for fields of promoted structs.</span></td>
      </tr>
      <tr>
        <td id="L4704" data-line-number="4704"></td>
        <td id="LC4704">    <span>lvaAssignFrameOffsetsToPromotedStructs</span>();</td>
      </tr>
      <tr>
        <td id="L4705" data-line-number="4705"></td>
        <td id="LC4705">
</td>
      </tr>
      <tr>
        <td id="L4706" data-line-number="4706"></td>
        <td id="LC4706">    <span><span>/*</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4707" data-line-number="4707"></td>
        <td id="LC4707"><span>     *</span></td>
      </tr>
      <tr>
        <td id="L4708" data-line-number="4708"></td>
        <td id="LC4708"><span>     * Finalize</span></td>
      </tr>
      <tr>
        <td id="L4709" data-line-number="4709"></td>
        <td id="LC4709"><span>     *</span></td>
      </tr>
      <tr>
        <td id="L4710" data-line-number="4710"></td>
        <td id="LC4710"><span>     *-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L4711" data-line-number="4711"></td>
        <td id="LC4711"><span>     <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4712" data-line-number="4712"></td>
        <td id="LC4712">
</td>
      </tr>
      <tr>
        <td id="L4713" data-line-number="4713"></td>
        <td id="LC4713">    <span><span>//</span> If it's not the final frame layout, then it's just an estimate. This means</span></td>
      </tr>
      <tr>
        <td id="L4714" data-line-number="4714"></td>
        <td id="LC4714">    <span><span>//</span> we're allowed to once again write to these variables, even if we've read</span></td>
      </tr>
      <tr>
        <td id="L4715" data-line-number="4715"></td>
        <td id="LC4715">    <span><span>//</span> from them to make tentative code generation or frame layout decisions.</span></td>
      </tr>
      <tr>
        <td id="L4716" data-line-number="4716"></td>
        <td id="LC4716">    <span>if</span> (curState &lt; FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L4717" data-line-number="4717"></td>
        <td id="LC4717">    {</td>
      </tr>
      <tr>
        <td id="L4718" data-line-number="4718"></td>
        <td id="LC4718">        codeGen-&gt;<span>resetFramePointerUsedWritePhase</span>();</td>
      </tr>
      <tr>
        <td id="L4719" data-line-number="4719"></td>
        <td id="LC4719">    }</td>
      </tr>
      <tr>
        <td id="L4720" data-line-number="4720"></td>
        <td id="LC4720">}</td>
      </tr>
      <tr>
        <td id="L4721" data-line-number="4721"></td>
        <td id="LC4721">
</td>
      </tr>
      <tr>
        <td id="L4722" data-line-number="4722"></td>
        <td id="LC4722"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L4723" data-line-number="4723"></td>
        <td id="LC4723"><span> *  lvaFixVirtualFrameOffsets() : Now that everything has a virtual offset,</span></td>
      </tr>
      <tr>
        <td id="L4724" data-line-number="4724"></td>
        <td id="LC4724"><span> *  determine the final value for the frame pointer (if needed) and then</span></td>
      </tr>
      <tr>
        <td id="L4725" data-line-number="4725"></td>
        <td id="LC4725"><span> *  adjust all the offsets appropriately.</span></td>
      </tr>
      <tr>
        <td id="L4726" data-line-number="4726"></td>
        <td id="LC4726"><span> *</span></td>
      </tr>
      <tr>
        <td id="L4727" data-line-number="4727"></td>
        <td id="LC4727"><span> *  This routine fixes virtual offset to be relative to frame pointer or SP</span></td>
      </tr>
      <tr>
        <td id="L4728" data-line-number="4728"></td>
        <td id="LC4728"><span> *  based on whether varDsc-&gt;lvFramePointerBased is true or false respectively.</span></td>
      </tr>
      <tr>
        <td id="L4729" data-line-number="4729"></td>
        <td id="LC4729"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4730" data-line-number="4730"></td>
        <td id="LC4730"><span>void</span> <span>Compiler::lvaFixVirtualFrameOffsets</span>()</td>
      </tr>
      <tr>
        <td id="L4731" data-line-number="4731"></td>
        <td id="LC4731">{</td>
      </tr>
      <tr>
        <td id="L4732" data-line-number="4732"></td>
        <td id="LC4732">    LclVarDsc* varDsc;</td>
      </tr>
      <tr>
        <td id="L4733" data-line-number="4733"></td>
        <td id="LC4733">
</td>
      </tr>
      <tr>
        <td id="L4734" data-line-number="4734"></td>
        <td id="LC4734">#<span>if</span> defined(FEATURE_EH_FUNCLETS) &amp;&amp; defined(TARGET_AMD64)</td>
      </tr>
      <tr>
        <td id="L4735" data-line-number="4735"></td>
        <td id="LC4735">    <span>if</span> (lvaPSPSym != BAD_VAR_NUM)</td>
      </tr>
      <tr>
        <td id="L4736" data-line-number="4736"></td>
        <td id="LC4736">    {</td>
      </tr>
      <tr>
        <td id="L4737" data-line-number="4737"></td>
        <td id="LC4737">        <span><span>//</span> We need to fix the offset of the PSPSym so there is no padding between it and the outgoing argument space.</span></td>
      </tr>
      <tr>
        <td id="L4738" data-line-number="4738"></td>
        <td id="LC4738">        <span><span>//</span> Without this code, lvaAlignFrame might have put the padding lower than the PSPSym, which would be between</span></td>
      </tr>
      <tr>
        <td id="L4739" data-line-number="4739"></td>
        <td id="LC4739">        <span><span>//</span> the PSPSym and the outgoing argument space.</span></td>
      </tr>
      <tr>
        <td id="L4740" data-line-number="4740"></td>
        <td id="LC4740">        varDsc = &amp;lvaTable[lvaPSPSym];</td>
      </tr>
      <tr>
        <td id="L4741" data-line-number="4741"></td>
        <td id="LC4741">        <span>assert</span>(varDsc-&gt;<span>lvFramePointerBased</span>); <span><span>//</span> We always access it RBP-relative.</span></td>
      </tr>
      <tr>
        <td id="L4742" data-line-number="4742"></td>
        <td id="LC4742">        <span>assert</span>(!varDsc-&gt;<span>lvMustInit</span>);         <span><span>//</span> It is never "must init".</span></td>
      </tr>
      <tr>
        <td id="L4743" data-line-number="4743"></td>
        <td id="LC4743">        varDsc-&gt;<span>lvStkOffs</span> = codeGen-&gt;<span>genCallerSPtoInitialSPdelta</span>() + <span>lvaLclSize</span>(lvaOutgoingArgSpaceVar);</td>
      </tr>
      <tr>
        <td id="L4744" data-line-number="4744"></td>
        <td id="LC4744">    }</td>
      </tr>
      <tr>
        <td id="L4745" data-line-number="4745"></td>
        <td id="LC4745">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4746" data-line-number="4746"></td>
        <td id="LC4746">
</td>
      </tr>
      <tr>
        <td id="L4747" data-line-number="4747"></td>
        <td id="LC4747">    <span><span>//</span> The delta to be added to virtual offset to adjust it relative to frame pointer or SP</span></td>
      </tr>
      <tr>
        <td id="L4748" data-line-number="4748"></td>
        <td id="LC4748">    <span>int</span> delta = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4749" data-line-number="4749"></td>
        <td id="LC4749">
</td>
      </tr>
      <tr>
        <td id="L4750" data-line-number="4750"></td>
        <td id="LC4750">#<span>ifdef</span> TARGET_XARCH</td>
      </tr>
      <tr>
        <td id="L4751" data-line-number="4751"></td>
        <td id="LC4751">    delta += REGSIZE_BYTES; <span><span>//</span> pushed PC (return address) for x86/x64</span></td>
      </tr>
      <tr>
        <td id="L4752" data-line-number="4752"></td>
        <td id="LC4752">
</td>
      </tr>
      <tr>
        <td id="L4753" data-line-number="4753"></td>
        <td id="LC4753">    <span>if</span> (codeGen-&gt;<span>doubleAlignOrFramePointerUsed</span>())</td>
      </tr>
      <tr>
        <td id="L4754" data-line-number="4754"></td>
        <td id="LC4754">    {</td>
      </tr>
      <tr>
        <td id="L4755" data-line-number="4755"></td>
        <td id="LC4755">        delta += REGSIZE_BYTES; <span><span>//</span> pushed EBP (frame pointer)</span></td>
      </tr>
      <tr>
        <td id="L4756" data-line-number="4756"></td>
        <td id="LC4756">    }</td>
      </tr>
      <tr>
        <td id="L4757" data-line-number="4757"></td>
        <td id="LC4757">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4758" data-line-number="4758"></td>
        <td id="LC4758">
</td>
      </tr>
      <tr>
        <td id="L4759" data-line-number="4759"></td>
        <td id="LC4759">    <span>if</span> (!codeGen-&gt;<span>isFramePointerUsed</span>())</td>
      </tr>
      <tr>
        <td id="L4760" data-line-number="4760"></td>
        <td id="LC4760">    {</td>
      </tr>
      <tr>
        <td id="L4761" data-line-number="4761"></td>
        <td id="LC4761">        <span><span>//</span> pushed registers, return address, and padding</span></td>
      </tr>
      <tr>
        <td id="L4762" data-line-number="4762"></td>
        <td id="LC4762">        delta += codeGen-&gt;<span>genTotalFrameSize</span>();</td>
      </tr>
      <tr>
        <td id="L4763" data-line-number="4763"></td>
        <td id="LC4763">    }</td>
      </tr>
      <tr>
        <td id="L4764" data-line-number="4764"></td>
        <td id="LC4764">#<span>if</span> defined(TARGET_ARM)</td>
      </tr>
      <tr>
        <td id="L4765" data-line-number="4765"></td>
        <td id="LC4765">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L4766" data-line-number="4766"></td>
        <td id="LC4766">    {</td>
      </tr>
      <tr>
        <td id="L4767" data-line-number="4767"></td>
        <td id="LC4767">        <span><span>//</span> We set FP to be after LR, FP</span></td>
      </tr>
      <tr>
        <td id="L4768" data-line-number="4768"></td>
        <td id="LC4768">        delta += <span>2</span> * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L4769" data-line-number="4769"></td>
        <td id="LC4769">    }</td>
      </tr>
      <tr>
        <td id="L4770" data-line-number="4770"></td>
        <td id="LC4770">#<span>elif</span> defined(TARGET_AMD64) || defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L4771" data-line-number="4771"></td>
        <td id="LC4771">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L4772" data-line-number="4772"></td>
        <td id="LC4772">    {</td>
      </tr>
      <tr>
        <td id="L4773" data-line-number="4773"></td>
        <td id="LC4773">        <span><span>//</span> FP is used.</span></td>
      </tr>
      <tr>
        <td id="L4774" data-line-number="4774"></td>
        <td id="LC4774">        delta += codeGen-&gt;<span>genTotalFrameSize</span>() - codeGen-&gt;<span>genSPtoFPdelta</span>();</td>
      </tr>
      <tr>
        <td id="L4775" data-line-number="4775"></td>
        <td id="LC4775">    }</td>
      </tr>
      <tr>
        <td id="L4776" data-line-number="4776"></td>
        <td id="LC4776">#<span>endif</span> <span><span>//</span> TARGET_AMD64</span></td>
      </tr>
      <tr>
        <td id="L4777" data-line-number="4777"></td>
        <td id="LC4777">
</td>
      </tr>
      <tr>
        <td id="L4778" data-line-number="4778"></td>
        <td id="LC4778">    <span>unsigned</span> lclNum;</td>
      </tr>
      <tr>
        <td id="L4779" data-line-number="4779"></td>
        <td id="LC4779">    <span>for</span> (lclNum = <span>0</span>, varDsc = lvaTable; lclNum &lt; lvaCount; lclNum++, varDsc++)</td>
      </tr>
      <tr>
        <td id="L4780" data-line-number="4780"></td>
        <td id="LC4780">    {</td>
      </tr>
      <tr>
        <td id="L4781" data-line-number="4781"></td>
        <td id="LC4781">        <span>bool</span> doAssignStkOffs = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L4782" data-line-number="4782"></td>
        <td id="LC4782">
</td>
      </tr>
      <tr>
        <td id="L4783" data-line-number="4783"></td>
        <td id="LC4783">        <span><span>//</span> Can't be relative to EBP unless we have an EBP</span></td>
      </tr>
      <tr>
        <td id="L4784" data-line-number="4784"></td>
        <td id="LC4784">        <span>noway_assert</span>(!varDsc-&gt;<span>lvFramePointerBased</span> || codeGen-&gt;<span>doubleAlignOrFramePointerUsed</span>());</td>
      </tr>
      <tr>
        <td id="L4785" data-line-number="4785"></td>
        <td id="LC4785">
</td>
      </tr>
      <tr>
        <td id="L4786" data-line-number="4786"></td>
        <td id="LC4786">        <span><span>//</span> Is this a non-param promoted struct field?</span></td>
      </tr>
      <tr>
        <td id="L4787" data-line-number="4787"></td>
        <td id="LC4787">        <span><span>//</span>   if so then set doAssignStkOffs to false.</span></td>
      </tr>
      <tr>
        <td id="L4788" data-line-number="4788"></td>
        <td id="LC4788">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4789" data-line-number="4789"></td>
        <td id="LC4789">        <span>if</span> (varDsc-&gt;<span>lvIsStructField</span> &amp;&amp; !varDsc-&gt;<span>lvIsParam</span>)</td>
      </tr>
      <tr>
        <td id="L4790" data-line-number="4790"></td>
        <td id="LC4790">        {</td>
      </tr>
      <tr>
        <td id="L4791" data-line-number="4791"></td>
        <td id="LC4791">            LclVarDsc*       parentvarDsc  = &amp;lvaTable[varDsc-&gt;<span>lvParentLcl</span>];</td>
      </tr>
      <tr>
        <td id="L4792" data-line-number="4792"></td>
        <td id="LC4792">            lvaPromotionType promotionType = <span>lvaGetPromotionType</span>(parentvarDsc);</td>
      </tr>
      <tr>
        <td id="L4793" data-line-number="4793"></td>
        <td id="LC4793">
</td>
      </tr>
      <tr>
        <td id="L4794" data-line-number="4794"></td>
        <td id="LC4794">            <span>if</span> (promotionType == PROMOTION_TYPE_DEPENDENT)</td>
      </tr>
      <tr>
        <td id="L4795" data-line-number="4795"></td>
        <td id="LC4795">            {</td>
      </tr>
      <tr>
        <td id="L4796" data-line-number="4796"></td>
        <td id="LC4796">                doAssignStkOffs = <span>false</span>; <span><span>//</span> Assigned later in lvaAssignFrameOffsetsToPromotedStructs()</span></td>
      </tr>
      <tr>
        <td id="L4797" data-line-number="4797"></td>
        <td id="LC4797">            }</td>
      </tr>
      <tr>
        <td id="L4798" data-line-number="4798"></td>
        <td id="LC4798">        }</td>
      </tr>
      <tr>
        <td id="L4799" data-line-number="4799"></td>
        <td id="LC4799">
</td>
      </tr>
      <tr>
        <td id="L4800" data-line-number="4800"></td>
        <td id="LC4800">        <span>if</span> (!varDsc-&gt;<span>lvOnFrame</span>)</td>
      </tr>
      <tr>
        <td id="L4801" data-line-number="4801"></td>
        <td id="LC4801">        {</td>
      </tr>
      <tr>
        <td id="L4802" data-line-number="4802"></td>
        <td id="LC4802">            <span>if</span> (!varDsc-&gt;<span>lvIsParam</span></td>
      </tr>
      <tr>
        <td id="L4803" data-line-number="4803"></td>
        <td id="LC4803">#<span>if</span> !defined(TARGET_AMD64)</td>
      </tr>
      <tr>
        <td id="L4804" data-line-number="4804"></td>
        <td id="LC4804">                || (varDsc-&gt;<span>lvIsRegArg</span></td>
      </tr>
      <tr>
        <td id="L4805" data-line-number="4805"></td>
        <td id="LC4805">#<span>if</span> defined(TARGET_ARM) &amp;&amp; defined(PROFILING_SUPPORTED)</td>
      </tr>
      <tr>
        <td id="L4806" data-line-number="4806"></td>
        <td id="LC4806">                    &amp;&amp; <span>compIsProfilerHookNeeded</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L4807" data-line-number="4807"></td>
        <td id="LC4807">                    !<span>lvaIsPreSpilled</span>(lclNum, codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegs</span>(<span>false</span>)) <span><span>//</span> We need assign stack offsets</span></td>
      </tr>
      <tr>
        <td id="L4808" data-line-number="4808"></td>
        <td id="LC4808">                                                                                        <span><span>//</span> for prespilled arguments</span></td>
      </tr>
      <tr>
        <td id="L4809" data-line-number="4809"></td>
        <td id="LC4809">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4810" data-line-number="4810"></td>
        <td id="LC4810">                    )</td>
      </tr>
      <tr>
        <td id="L4811" data-line-number="4811"></td>
        <td id="LC4811">#<span>endif</span> <span><span>//</span> !defined(TARGET_AMD64)</span></td>
      </tr>
      <tr>
        <td id="L4812" data-line-number="4812"></td>
        <td id="LC4812">                    )</td>
      </tr>
      <tr>
        <td id="L4813" data-line-number="4813"></td>
        <td id="LC4813">            {</td>
      </tr>
      <tr>
        <td id="L4814" data-line-number="4814"></td>
        <td id="LC4814">                doAssignStkOffs = <span>false</span>; <span><span>//</span> Not on frame or an incomming stack arg</span></td>
      </tr>
      <tr>
        <td id="L4815" data-line-number="4815"></td>
        <td id="LC4815">            }</td>
      </tr>
      <tr>
        <td id="L4816" data-line-number="4816"></td>
        <td id="LC4816">        }</td>
      </tr>
      <tr>
        <td id="L4817" data-line-number="4817"></td>
        <td id="LC4817">
</td>
      </tr>
      <tr>
        <td id="L4818" data-line-number="4818"></td>
        <td id="LC4818">        <span>if</span> (doAssignStkOffs)</td>
      </tr>
      <tr>
        <td id="L4819" data-line-number="4819"></td>
        <td id="LC4819">        {</td>
      </tr>
      <tr>
        <td id="L4820" data-line-number="4820"></td>
        <td id="LC4820">            varDsc-&gt;<span>lvStkOffs</span> += delta;</td>
      </tr>
      <tr>
        <td id="L4821" data-line-number="4821"></td>
        <td id="LC4821">
</td>
      </tr>
      <tr>
        <td id="L4822" data-line-number="4822"></td>
        <td id="LC4822">#<span>if</span> DOUBLE_ALIGN</td>
      </tr>
      <tr>
        <td id="L4823" data-line-number="4823"></td>
        <td id="LC4823">            <span>if</span> (<span>genDoubleAlign</span>() &amp;&amp; !codeGen-&gt;<span>isFramePointerUsed</span>())</td>
      </tr>
      <tr>
        <td id="L4824" data-line-number="4824"></td>
        <td id="LC4824">            {</td>
      </tr>
      <tr>
        <td id="L4825" data-line-number="4825"></td>
        <td id="LC4825">                <span>if</span> (varDsc-&gt;<span>lvFramePointerBased</span>)</td>
      </tr>
      <tr>
        <td id="L4826" data-line-number="4826"></td>
        <td id="LC4826">                {</td>
      </tr>
      <tr>
        <td id="L4827" data-line-number="4827"></td>
        <td id="LC4827">                    varDsc-&gt;<span>lvStkOffs</span> -= delta;</td>
      </tr>
      <tr>
        <td id="L4828" data-line-number="4828"></td>
        <td id="LC4828">
</td>
      </tr>
      <tr>
        <td id="L4829" data-line-number="4829"></td>
        <td id="LC4829">                    <span><span>//</span> We need to re-adjust the offsets of the parameters so they are EBP</span></td>
      </tr>
      <tr>
        <td id="L4830" data-line-number="4830"></td>
        <td id="LC4830">                    <span><span>//</span> relative rather than stack/frame pointer relative</span></td>
      </tr>
      <tr>
        <td id="L4831" data-line-number="4831"></td>
        <td id="LC4831">
</td>
      </tr>
      <tr>
        <td id="L4832" data-line-number="4832"></td>
        <td id="LC4832">                    varDsc-&gt;<span>lvStkOffs</span> += (<span>2</span> * TARGET_POINTER_SIZE); <span><span>//</span> return address and pushed EBP</span></td>
      </tr>
      <tr>
        <td id="L4833" data-line-number="4833"></td>
        <td id="LC4833">
</td>
      </tr>
      <tr>
        <td id="L4834" data-line-number="4834"></td>
        <td id="LC4834">                    <span>noway_assert</span>(varDsc-&gt;<span>lvStkOffs</span> &gt;= FIRST_ARG_STACK_OFFS);</td>
      </tr>
      <tr>
        <td id="L4835" data-line-number="4835"></td>
        <td id="LC4835">                }</td>
      </tr>
      <tr>
        <td id="L4836" data-line-number="4836"></td>
        <td id="LC4836">            }</td>
      </tr>
      <tr>
        <td id="L4837" data-line-number="4837"></td>
        <td id="LC4837">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4838" data-line-number="4838"></td>
        <td id="LC4838">            <span><span>//</span> On System V environments the stkOffs could be 0 for params passed in registers.</span></td>
      </tr>
      <tr>
        <td id="L4839" data-line-number="4839"></td>
        <td id="LC4839">            <span>assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>() ||</td>
      </tr>
      <tr>
        <td id="L4840" data-line-number="4840"></td>
        <td id="LC4840">                   varDsc-&gt;<span>lvStkOffs</span> &gt;= <span>0</span>); <span><span>//</span> Only EBP relative references can have negative offsets</span></td>
      </tr>
      <tr>
        <td id="L4841" data-line-number="4841"></td>
        <td id="LC4841">        }</td>
      </tr>
      <tr>
        <td id="L4842" data-line-number="4842"></td>
        <td id="LC4842">    }</td>
      </tr>
      <tr>
        <td id="L4843" data-line-number="4843"></td>
        <td id="LC4843">
</td>
      </tr>
      <tr>
        <td id="L4844" data-line-number="4844"></td>
        <td id="LC4844">    <span>assert</span>(codeGen-&gt;<span>regSet</span>.<span>tmpAllFree</span>());</td>
      </tr>
      <tr>
        <td id="L4845" data-line-number="4845"></td>
        <td id="LC4845">    <span>for</span> (TempDsc* temp = codeGen-&gt;<span>regSet</span>.<span>tmpListBeg</span>(); temp != <span>nullptr</span>; temp = codeGen-&gt;<span>regSet</span>.<span>tmpListNxt</span>(temp))</td>
      </tr>
      <tr>
        <td id="L4846" data-line-number="4846"></td>
        <td id="LC4846">    {</td>
      </tr>
      <tr>
        <td id="L4847" data-line-number="4847"></td>
        <td id="LC4847">        temp-&gt;<span>tdAdjustTempOffs</span>(delta);</td>
      </tr>
      <tr>
        <td id="L4848" data-line-number="4848"></td>
        <td id="LC4848">    }</td>
      </tr>
      <tr>
        <td id="L4849" data-line-number="4849"></td>
        <td id="LC4849">
</td>
      </tr>
      <tr>
        <td id="L4850" data-line-number="4850"></td>
        <td id="LC4850">    lvaCachedGenericContextArgOffs += delta;</td>
      </tr>
      <tr>
        <td id="L4851" data-line-number="4851"></td>
        <td id="LC4851">
</td>
      </tr>
      <tr>
        <td id="L4852" data-line-number="4852"></td>
        <td id="LC4852">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L4853" data-line-number="4853"></td>
        <td id="LC4853">
</td>
      </tr>
      <tr>
        <td id="L4854" data-line-number="4854"></td>
        <td id="LC4854">    <span>if</span> (lvaOutgoingArgSpaceVar != BAD_VAR_NUM)</td>
      </tr>
      <tr>
        <td id="L4855" data-line-number="4855"></td>
        <td id="LC4855">    {</td>
      </tr>
      <tr>
        <td id="L4856" data-line-number="4856"></td>
        <td id="LC4856">        varDsc                      = &amp;lvaTable[lvaOutgoingArgSpaceVar];</td>
      </tr>
      <tr>
        <td id="L4857" data-line-number="4857"></td>
        <td id="LC4857">        varDsc-&gt;<span>lvStkOffs</span>           = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4858" data-line-number="4858"></td>
        <td id="LC4858">        varDsc-&gt;<span>lvFramePointerBased</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L4859" data-line-number="4859"></td>
        <td id="LC4859">        varDsc-&gt;<span>lvMustInit</span>          = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L4860" data-line-number="4860"></td>
        <td id="LC4860">    }</td>
      </tr>
      <tr>
        <td id="L4861" data-line-number="4861"></td>
        <td id="LC4861">
</td>
      </tr>
      <tr>
        <td id="L4862" data-line-number="4862"></td>
        <td id="LC4862">#<span>endif</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L4863" data-line-number="4863"></td>
        <td id="LC4863">}</td>
      </tr>
      <tr>
        <td id="L4864" data-line-number="4864"></td>
        <td id="LC4864">
</td>
      </tr>
      <tr>
        <td id="L4865" data-line-number="4865"></td>
        <td id="LC4865">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L4866" data-line-number="4866"></td>
        <td id="LC4866"><span>bool</span> <span>Compiler::lvaIsPreSpilled</span>(<span>unsigned</span> lclNum, regMaskTP preSpillMask)</td>
      </tr>
      <tr>
        <td id="L4867" data-line-number="4867"></td>
        <td id="LC4867">{</td>
      </tr>
      <tr>
        <td id="L4868" data-line-number="4868"></td>
        <td id="LC4868">    <span>const</span> LclVarDsc&amp; desc = lvaTable[lclNum];</td>
      </tr>
      <tr>
        <td id="L4869" data-line-number="4869"></td>
        <td id="LC4869">    <span>return</span> desc.<span>lvIsRegArg</span> &amp;&amp; (preSpillMask &amp; <span>genRegMask</span>(desc.<span>GetArgReg</span>()));</td>
      </tr>
      <tr>
        <td id="L4870" data-line-number="4870"></td>
        <td id="LC4870">}</td>
      </tr>
      <tr>
        <td id="L4871" data-line-number="4871"></td>
        <td id="LC4871">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L4872" data-line-number="4872"></td>
        <td id="LC4872">
</td>
      </tr>
      <tr>
        <td id="L4873" data-line-number="4873"></td>
        <td id="LC4873"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L4874" data-line-number="4874"></td>
        <td id="LC4874"><span> *  lvaUpdateArgsWithInitialReg() : For each argument variable descriptor, update</span></td>
      </tr>
      <tr>
        <td id="L4875" data-line-number="4875"></td>
        <td id="LC4875"><span> *  its current register with the initial register as assigned by LSRA.</span></td>
      </tr>
      <tr>
        <td id="L4876" data-line-number="4876"></td>
        <td id="LC4876"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4877" data-line-number="4877"></td>
        <td id="LC4877"><span>void</span> <span>Compiler::lvaUpdateArgsWithInitialReg</span>()</td>
      </tr>
      <tr>
        <td id="L4878" data-line-number="4878"></td>
        <td id="LC4878">{</td>
      </tr>
      <tr>
        <td id="L4879" data-line-number="4879"></td>
        <td id="LC4879">    <span>if</span> (!compLSRADone)</td>
      </tr>
      <tr>
        <td id="L4880" data-line-number="4880"></td>
        <td id="LC4880">    {</td>
      </tr>
      <tr>
        <td id="L4881" data-line-number="4881"></td>
        <td id="LC4881">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L4882" data-line-number="4882"></td>
        <td id="LC4882">    }</td>
      </tr>
      <tr>
        <td id="L4883" data-line-number="4883"></td>
        <td id="LC4883">
</td>
      </tr>
      <tr>
        <td id="L4884" data-line-number="4884"></td>
        <td id="LC4884">    <span>for</span> (<span>unsigned</span> lclNum = <span>0</span>; lclNum &lt; info.<span>compArgsCount</span>; lclNum++)</td>
      </tr>
      <tr>
        <td id="L4885" data-line-number="4885"></td>
        <td id="LC4885">    {</td>
      </tr>
      <tr>
        <td id="L4886" data-line-number="4886"></td>
        <td id="LC4886">        LclVarDsc* varDsc = lvaTable + lclNum;</td>
      </tr>
      <tr>
        <td id="L4887" data-line-number="4887"></td>
        <td id="LC4887">
</td>
      </tr>
      <tr>
        <td id="L4888" data-line-number="4888"></td>
        <td id="LC4888">        <span>if</span> (varDsc-&gt;<span>lvPromotedStruct</span>())</td>
      </tr>
      <tr>
        <td id="L4889" data-line-number="4889"></td>
        <td id="LC4889">        {</td>
      </tr>
      <tr>
        <td id="L4890" data-line-number="4890"></td>
        <td id="LC4890">            <span>noway_assert</span>(varDsc-&gt;<span>lvFieldCnt</span> == <span>1</span>); <span><span>//</span> We only handle one field here</span></td>
      </tr>
      <tr>
        <td id="L4891" data-line-number="4891"></td>
        <td id="LC4891">
</td>
      </tr>
      <tr>
        <td id="L4892" data-line-number="4892"></td>
        <td id="LC4892">            <span>unsigned</span> fieldVarNum = varDsc-&gt;<span>lvFieldLclStart</span>;</td>
      </tr>
      <tr>
        <td id="L4893" data-line-number="4893"></td>
        <td id="LC4893">            varDsc               = lvaTable + fieldVarNum;</td>
      </tr>
      <tr>
        <td id="L4894" data-line-number="4894"></td>
        <td id="LC4894">        }</td>
      </tr>
      <tr>
        <td id="L4895" data-line-number="4895"></td>
        <td id="LC4895">
</td>
      </tr>
      <tr>
        <td id="L4896" data-line-number="4896"></td>
        <td id="LC4896">        <span>noway_assert</span>(varDsc-&gt;<span>lvIsParam</span>);</td>
      </tr>
      <tr>
        <td id="L4897" data-line-number="4897"></td>
        <td id="LC4897">
</td>
      </tr>
      <tr>
        <td id="L4898" data-line-number="4898"></td>
        <td id="LC4898">        <span>if</span> (varDsc-&gt;<span>lvIsRegCandidate</span>())</td>
      </tr>
      <tr>
        <td id="L4899" data-line-number="4899"></td>
        <td id="LC4899">        {</td>
      </tr>
      <tr>
        <td id="L4900" data-line-number="4900"></td>
        <td id="LC4900">            varDsc-&gt;<span>SetRegNum</span>(varDsc-&gt;<span>GetArgInitReg</span>());</td>
      </tr>
      <tr>
        <td id="L4901" data-line-number="4901"></td>
        <td id="LC4901">        }</td>
      </tr>
      <tr>
        <td id="L4902" data-line-number="4902"></td>
        <td id="LC4902">    }</td>
      </tr>
      <tr>
        <td id="L4903" data-line-number="4903"></td>
        <td id="LC4903">}</td>
      </tr>
      <tr>
        <td id="L4904" data-line-number="4904"></td>
        <td id="LC4904">
</td>
      </tr>
      <tr>
        <td id="L4905" data-line-number="4905"></td>
        <td id="LC4905"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L4906" data-line-number="4906"></td>
        <td id="LC4906"><span> *  lvaAssignVirtualFrameOffsetsToArgs() : Assign virtual stack offsets to the</span></td>
      </tr>
      <tr>
        <td id="L4907" data-line-number="4907"></td>
        <td id="LC4907"><span> *  arguments, and implicit arguments (this ptr, return buffer, generics,</span></td>
      </tr>
      <tr>
        <td id="L4908" data-line-number="4908"></td>
        <td id="LC4908"><span> *  and varargs).</span></td>
      </tr>
      <tr>
        <td id="L4909" data-line-number="4909"></td>
        <td id="LC4909"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4910" data-line-number="4910"></td>
        <td id="LC4910"><span>void</span> <span>Compiler::lvaAssignVirtualFrameOffsetsToArgs</span>()</td>
      </tr>
      <tr>
        <td id="L4911" data-line-number="4911"></td>
        <td id="LC4911">{</td>
      </tr>
      <tr>
        <td id="L4912" data-line-number="4912"></td>
        <td id="LC4912">    <span>unsigned</span> lclNum  = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4913" data-line-number="4913"></td>
        <td id="LC4913">    <span>int</span>      argOffs = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4914" data-line-number="4914"></td>
        <td id="LC4914">#<span>ifdef</span> UNIX_AMD64_ABI</td>
      </tr>
      <tr>
        <td id="L4915" data-line-number="4915"></td>
        <td id="LC4915">    <span>int</span> callerArgOffset = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L4916" data-line-number="4916"></td>
        <td id="LC4916">#<span>endif</span> <span><span>//</span> UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L4917" data-line-number="4917"></td>
        <td id="LC4917">
</td>
      </tr>
      <tr>
        <td id="L4918" data-line-number="4918"></td>
        <td id="LC4918">    <span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L4919" data-line-number="4919"></td>
        <td id="LC4919"><span>        Assign stack offsets to arguments (in reverse order of passing).</span></td>
      </tr>
      <tr>
        <td id="L4920" data-line-number="4920"></td>
        <td id="LC4920"><span></span></td>
      </tr>
      <tr>
        <td id="L4921" data-line-number="4921"></td>
        <td id="LC4921"><span>        This means that if we pass arguments left-&gt;right, we start at</span></td>
      </tr>
      <tr>
        <td id="L4922" data-line-number="4922"></td>
        <td id="LC4922"><span>        the end of the list and work backwards, for right-&gt;left we start</span></td>
      </tr>
      <tr>
        <td id="L4923" data-line-number="4923"></td>
        <td id="LC4923"><span>        with the first argument and move forward.</span></td>
      </tr>
      <tr>
        <td id="L4924" data-line-number="4924"></td>
        <td id="LC4924"><span></span></td>
      </tr>
      <tr>
        <td id="L4925" data-line-number="4925"></td>
        <td id="LC4925"><span>        This is all relative to our Virtual '0'</span></td>
      </tr>
      <tr>
        <td id="L4926" data-line-number="4926"></td>
        <td id="LC4926"><span>     <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4927" data-line-number="4927"></td>
        <td id="LC4927">
</td>
      </tr>
      <tr>
        <td id="L4928" data-line-number="4928"></td>
        <td id="LC4928">    <span>if</span> (Target::g_tgtArgOrder == Target::ARG_ORDER_L2R)</td>
      </tr>
      <tr>
        <td id="L4929" data-line-number="4929"></td>
        <td id="LC4929">    {</td>
      </tr>
      <tr>
        <td id="L4930" data-line-number="4930"></td>
        <td id="LC4930">        argOffs = compArgSize;</td>
      </tr>
      <tr>
        <td id="L4931" data-line-number="4931"></td>
        <td id="LC4931">    }</td>
      </tr>
      <tr>
        <td id="L4932" data-line-number="4932"></td>
        <td id="LC4932">
</td>
      </tr>
      <tr>
        <td id="L4933" data-line-number="4933"></td>
        <td id="LC4933">    <span><span>/*</span> Update the argOffs to reflect arguments that are passed in registers <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4934" data-line-number="4934"></td>
        <td id="LC4934">
</td>
      </tr>
      <tr>
        <td id="L4935" data-line-number="4935"></td>
        <td id="LC4935">    <span>noway_assert</span>(codeGen-&gt;<span>intRegState</span>.<span>rsCalleeRegArgCount</span> &lt;= MAX_REG_ARG);</td>
      </tr>
      <tr>
        <td id="L4936" data-line-number="4936"></td>
        <td id="LC4936">    <span>noway_assert</span>(compArgSize &gt;= codeGen-&gt;<span>intRegState</span>.<span>rsCalleeRegArgCount</span> * REGSIZE_BYTES);</td>
      </tr>
      <tr>
        <td id="L4937" data-line-number="4937"></td>
        <td id="LC4937">
</td>
      </tr>
      <tr>
        <td id="L4938" data-line-number="4938"></td>
        <td id="LC4938">#<span>ifdef</span> TARGET_X86</td>
      </tr>
      <tr>
        <td id="L4939" data-line-number="4939"></td>
        <td id="LC4939">    argOffs -= codeGen-&gt;<span>intRegState</span>.<span>rsCalleeRegArgCount</span> * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L4940" data-line-number="4940"></td>
        <td id="LC4940">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4941" data-line-number="4941"></td>
        <td id="LC4941">
</td>
      </tr>
      <tr>
        <td id="L4942" data-line-number="4942"></td>
        <td id="LC4942">    <span><span>//</span> Update the arg initial register locations.</span></td>
      </tr>
      <tr>
        <td id="L4943" data-line-number="4943"></td>
        <td id="LC4943">    <span>lvaUpdateArgsWithInitialReg</span>();</td>
      </tr>
      <tr>
        <td id="L4944" data-line-number="4944"></td>
        <td id="LC4944">
</td>
      </tr>
      <tr>
        <td id="L4945" data-line-number="4945"></td>
        <td id="LC4945">    <span><span>/*</span> Is there a "this" argument? <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4946" data-line-number="4946"></td>
        <td id="LC4946">
</td>
      </tr>
      <tr>
        <td id="L4947" data-line-number="4947"></td>
        <td id="LC4947">    <span>if</span> (!info.<span>compIsStatic</span>)</td>
      </tr>
      <tr>
        <td id="L4948" data-line-number="4948"></td>
        <td id="LC4948">    {</td>
      </tr>
      <tr>
        <td id="L4949" data-line-number="4949"></td>
        <td id="LC4949">        <span>noway_assert</span>(lclNum == info.<span>compThisArg</span>);</td>
      </tr>
      <tr>
        <td id="L4950" data-line-number="4950"></td>
        <td id="LC4950">#<span>ifndef</span> TARGET_X86</td>
      </tr>
      <tr>
        <td id="L4951" data-line-number="4951"></td>
        <td id="LC4951">        argOffs =</td>
      </tr>
      <tr>
        <td id="L4952" data-line-number="4952"></td>
        <td id="LC4952">            <span>lvaAssignVirtualFrameOffsetToArg</span>(lclNum, REGSIZE_BYTES, argOffs <span>UNIX_AMD64_ABI_ONLY_ARG</span>(&amp;callerArgOffset));</td>
      </tr>
      <tr>
        <td id="L4953" data-line-number="4953"></td>
        <td id="LC4953">#<span>endif</span> <span><span>//</span> TARGET_X86</span></td>
      </tr>
      <tr>
        <td id="L4954" data-line-number="4954"></td>
        <td id="LC4954">        lclNum++;</td>
      </tr>
      <tr>
        <td id="L4955" data-line-number="4955"></td>
        <td id="LC4955">    }</td>
      </tr>
      <tr>
        <td id="L4956" data-line-number="4956"></td>
        <td id="LC4956">
</td>
      </tr>
      <tr>
        <td id="L4957" data-line-number="4957"></td>
        <td id="LC4957">    <span><span>/*</span> if we have a hidden buffer parameter, that comes here <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L4958" data-line-number="4958"></td>
        <td id="LC4958">
</td>
      </tr>
      <tr>
        <td id="L4959" data-line-number="4959"></td>
        <td id="LC4959">    <span>if</span> (info.<span>compRetBuffArg</span> != BAD_VAR_NUM)</td>
      </tr>
      <tr>
        <td id="L4960" data-line-number="4960"></td>
        <td id="LC4960">    {</td>
      </tr>
      <tr>
        <td id="L4961" data-line-number="4961"></td>
        <td id="LC4961">        <span>noway_assert</span>(lclNum == info.<span>compRetBuffArg</span>);</td>
      </tr>
      <tr>
        <td id="L4962" data-line-number="4962"></td>
        <td id="LC4962">        <span>noway_assert</span>(lvaTable[lclNum].<span>lvIsRegArg</span>);</td>
      </tr>
      <tr>
        <td id="L4963" data-line-number="4963"></td>
        <td id="LC4963">#<span>ifndef</span> TARGET_X86</td>
      </tr>
      <tr>
        <td id="L4964" data-line-number="4964"></td>
        <td id="LC4964">        argOffs =</td>
      </tr>
      <tr>
        <td id="L4965" data-line-number="4965"></td>
        <td id="LC4965">            <span>lvaAssignVirtualFrameOffsetToArg</span>(lclNum, REGSIZE_BYTES, argOffs <span>UNIX_AMD64_ABI_ONLY_ARG</span>(&amp;callerArgOffset));</td>
      </tr>
      <tr>
        <td id="L4966" data-line-number="4966"></td>
        <td id="LC4966">#<span>endif</span> <span><span>//</span> TARGET_X86</span></td>
      </tr>
      <tr>
        <td id="L4967" data-line-number="4967"></td>
        <td id="LC4967">        lclNum++;</td>
      </tr>
      <tr>
        <td id="L4968" data-line-number="4968"></td>
        <td id="LC4968">    }</td>
      </tr>
      <tr>
        <td id="L4969" data-line-number="4969"></td>
        <td id="LC4969">
</td>
      </tr>
      <tr>
        <td id="L4970" data-line-number="4970"></td>
        <td id="LC4970">#<span>if</span> USER_ARGS_COME_LAST</td>
      </tr>
      <tr>
        <td id="L4971" data-line-number="4971"></td>
        <td id="LC4971">
</td>
      </tr>
      <tr>
        <td id="L4972" data-line-number="4972"></td>
        <td id="LC4972">    <span><span>//</span>@GENERICS: extra argument for instantiation info</span></td>
      </tr>
      <tr>
        <td id="L4973" data-line-number="4973"></td>
        <td id="LC4973">    <span>if</span> (info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>callConv</span> &amp; CORINFO_CALLCONV_PARAMTYPE)</td>
      </tr>
      <tr>
        <td id="L4974" data-line-number="4974"></td>
        <td id="LC4974">    {</td>
      </tr>
      <tr>
        <td id="L4975" data-line-number="4975"></td>
        <td id="LC4975">        <span>noway_assert</span>(lclNum == (<span>unsigned</span>)info.<span>compTypeCtxtArg</span>);</td>
      </tr>
      <tr>
        <td id="L4976" data-line-number="4976"></td>
        <td id="LC4976">        argOffs = <span>lvaAssignVirtualFrameOffsetToArg</span>(lclNum++, REGSIZE_BYTES,</td>
      </tr>
      <tr>
        <td id="L4977" data-line-number="4977"></td>
        <td id="LC4977">                                                   argOffs <span>UNIX_AMD64_ABI_ONLY_ARG</span>(&amp;callerArgOffset));</td>
      </tr>
      <tr>
        <td id="L4978" data-line-number="4978"></td>
        <td id="LC4978">    }</td>
      </tr>
      <tr>
        <td id="L4979" data-line-number="4979"></td>
        <td id="LC4979">
</td>
      </tr>
      <tr>
        <td id="L4980" data-line-number="4980"></td>
        <td id="LC4980">    <span>if</span> (info.<span>compIsVarArgs</span>)</td>
      </tr>
      <tr>
        <td id="L4981" data-line-number="4981"></td>
        <td id="LC4981">    {</td>
      </tr>
      <tr>
        <td id="L4982" data-line-number="4982"></td>
        <td id="LC4982">        argOffs = <span>lvaAssignVirtualFrameOffsetToArg</span>(lclNum++, REGSIZE_BYTES,</td>
      </tr>
      <tr>
        <td id="L4983" data-line-number="4983"></td>
        <td id="LC4983">                                                   argOffs <span>UNIX_AMD64_ABI_ONLY_ARG</span>(&amp;callerArgOffset));</td>
      </tr>
      <tr>
        <td id="L4984" data-line-number="4984"></td>
        <td id="LC4984">    }</td>
      </tr>
      <tr>
        <td id="L4985" data-line-number="4985"></td>
        <td id="LC4985">
</td>
      </tr>
      <tr>
        <td id="L4986" data-line-number="4986"></td>
        <td id="LC4986">#<span>endif</span> <span><span>//</span> USER_ARGS_COME_LAST</span></td>
      </tr>
      <tr>
        <td id="L4987" data-line-number="4987"></td>
        <td id="LC4987">
</td>
      </tr>
      <tr>
        <td id="L4988" data-line-number="4988"></td>
        <td id="LC4988">    CORINFO_ARG_LIST_HANDLE argLst    = info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>args</span>;</td>
      </tr>
      <tr>
        <td id="L4989" data-line-number="4989"></td>
        <td id="LC4989">    <span>unsigned</span>                argSigLen = info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>numArgs</span>;</td>
      </tr>
      <tr>
        <td id="L4990" data-line-number="4990"></td>
        <td id="LC4990">
</td>
      </tr>
      <tr>
        <td id="L4991" data-line-number="4991"></td>
        <td id="LC4991">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L4992" data-line-number="4992"></td>
        <td id="LC4992">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4993" data-line-number="4993"></td>
        <td id="LC4993">    <span><span>//</span> struct_n { int; int; ... n times };</span></td>
      </tr>
      <tr>
        <td id="L4994" data-line-number="4994"></td>
        <td id="LC4994">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4995" data-line-number="4995"></td>
        <td id="LC4995">    <span><span>//</span> Consider signature:</span></td>
      </tr>
      <tr>
        <td id="L4996" data-line-number="4996"></td>
        <td id="LC4996">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4997" data-line-number="4997"></td>
        <td id="LC4997">    <span><span>//</span> Foo (float a,double b,float c,double d,float e,double f,float g,double h,</span></td>
      </tr>
      <tr>
        <td id="L4998" data-line-number="4998"></td>
        <td id="LC4998">    <span><span>//</span>      float i,double j,float k,double l,struct_3 m) { }</span></td>
      </tr>
      <tr>
        <td id="L4999" data-line-number="4999"></td>
        <td id="LC4999">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5000" data-line-number="5000"></td>
        <td id="LC5000">    <span><span>//</span> Basically the signature is: (all float regs full, 1 double, struct_3);</span></td>
      </tr>
      <tr>
        <td id="L5001" data-line-number="5001"></td>
        <td id="LC5001">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5002" data-line-number="5002"></td>
        <td id="LC5002">    <span><span>//</span> The double argument occurs before pre spill in the argument iteration and</span></td>
      </tr>
      <tr>
        <td id="L5003" data-line-number="5003"></td>
        <td id="LC5003">    <span><span>//</span> computes an argOffset of 0. struct_3 offset becomes 8. This is wrong.</span></td>
      </tr>
      <tr>
        <td id="L5004" data-line-number="5004"></td>
        <td id="LC5004">    <span><span>//</span> Because struct_3 is prespilled and double occurs after prespill.</span></td>
      </tr>
      <tr>
        <td id="L5005" data-line-number="5005"></td>
        <td id="LC5005">    <span><span>//</span> The correct offsets are double = 16 (aligned stk), struct_3 = 0..12,</span></td>
      </tr>
      <tr>
        <td id="L5006" data-line-number="5006"></td>
        <td id="LC5006">    <span><span>//</span> Offset 12 will be skipped for double alignment of double.</span></td>
      </tr>
      <tr>
        <td id="L5007" data-line-number="5007"></td>
        <td id="LC5007">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5008" data-line-number="5008"></td>
        <td id="LC5008">    <span><span>//</span> Another example is (struct_2, all float regs full, double, struct_2);</span></td>
      </tr>
      <tr>
        <td id="L5009" data-line-number="5009"></td>
        <td id="LC5009">    <span><span>//</span> Here, notice the order is similarly messed up because of 2 pre-spilled</span></td>
      </tr>
      <tr>
        <td id="L5010" data-line-number="5010"></td>
        <td id="LC5010">    <span><span>//</span> struct_2.</span></td>
      </tr>
      <tr>
        <td id="L5011" data-line-number="5011"></td>
        <td id="LC5011">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5012" data-line-number="5012"></td>
        <td id="LC5012">    <span><span>//</span> Succinctly,</span></td>
      </tr>
      <tr>
        <td id="L5013" data-line-number="5013"></td>
        <td id="LC5013">    <span><span>//</span> ARG_INDEX(i) &gt; ARG_INDEX(j) DOES NOT IMPLY |ARG_OFFSET(i)| &gt; |ARG_OFFSET(j)|</span></td>
      </tr>
      <tr>
        <td id="L5014" data-line-number="5014"></td>
        <td id="LC5014">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5015" data-line-number="5015"></td>
        <td id="LC5015">    <span><span>//</span> Therefore, we'll do a two pass offset calculation, one that considers pre-spill</span></td>
      </tr>
      <tr>
        <td id="L5016" data-line-number="5016"></td>
        <td id="LC5016">    <span><span>//</span> and the next, stack args.</span></td>
      </tr>
      <tr>
        <td id="L5017" data-line-number="5017"></td>
        <td id="LC5017">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5018" data-line-number="5018"></td>
        <td id="LC5018">
</td>
      </tr>
      <tr>
        <td id="L5019" data-line-number="5019"></td>
        <td id="LC5019">    <span>unsigned</span> argLcls = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L5020" data-line-number="5020"></td>
        <td id="LC5020">
</td>
      </tr>
      <tr>
        <td id="L5021" data-line-number="5021"></td>
        <td id="LC5021">    <span><span>//</span> Take care of pre spill registers first.</span></td>
      </tr>
      <tr>
        <td id="L5022" data-line-number="5022"></td>
        <td id="LC5022">    regMaskTP preSpillMask = codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegs</span>(<span>false</span>);</td>
      </tr>
      <tr>
        <td id="L5023" data-line-number="5023"></td>
        <td id="LC5023">    regMaskTP tempMask     = RBM_NONE;</td>
      </tr>
      <tr>
        <td id="L5024" data-line-number="5024"></td>
        <td id="LC5024">    <span>for</span> (<span>unsigned</span> i = <span>0</span>, preSpillLclNum = lclNum; i &lt; argSigLen; ++i, ++preSpillLclNum)</td>
      </tr>
      <tr>
        <td id="L5025" data-line-number="5025"></td>
        <td id="LC5025">    {</td>
      </tr>
      <tr>
        <td id="L5026" data-line-number="5026"></td>
        <td id="LC5026">        <span>if</span> (<span>lvaIsPreSpilled</span>(preSpillLclNum, preSpillMask))</td>
      </tr>
      <tr>
        <td id="L5027" data-line-number="5027"></td>
        <td id="LC5027">        {</td>
      </tr>
      <tr>
        <td id="L5028" data-line-number="5028"></td>
        <td id="LC5028">            <span>unsigned</span> argSize = <span>eeGetArgSize</span>(argLst, &amp;info.<span>compMethodInfo</span>-&gt;<span>args</span>);</td>
      </tr>
      <tr>
        <td id="L5029" data-line-number="5029"></td>
        <td id="LC5029">            argOffs          = <span>lvaAssignVirtualFrameOffsetToArg</span>(preSpillLclNum, argSize, argOffs);</td>
      </tr>
      <tr>
        <td id="L5030" data-line-number="5030"></td>
        <td id="LC5030">            argLcls++;</td>
      </tr>
      <tr>
        <td id="L5031" data-line-number="5031"></td>
        <td id="LC5031">
</td>
      </tr>
      <tr>
        <td id="L5032" data-line-number="5032"></td>
        <td id="LC5032">            <span><span>//</span> Early out if we can. If size is 8 and base reg is 2, then the mask is 0x1100</span></td>
      </tr>
      <tr>
        <td id="L5033" data-line-number="5033"></td>
        <td id="LC5033">            tempMask |= ((((<span>1</span> &lt;&lt; (<span>roundUp</span>(argSize, TARGET_POINTER_SIZE) / REGSIZE_BYTES))) - <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L5034" data-line-number="5034"></td>
        <td id="LC5034">                         &lt;&lt; lvaTable[preSpillLclNum].<span>GetArgReg</span>());</td>
      </tr>
      <tr>
        <td id="L5035" data-line-number="5035"></td>
        <td id="LC5035">            <span>if</span> (tempMask == preSpillMask)</td>
      </tr>
      <tr>
        <td id="L5036" data-line-number="5036"></td>
        <td id="LC5036">            {</td>
      </tr>
      <tr>
        <td id="L5037" data-line-number="5037"></td>
        <td id="LC5037">                <span><span>//</span> We won't encounter more pre-spilled registers,</span></td>
      </tr>
      <tr>
        <td id="L5038" data-line-number="5038"></td>
        <td id="LC5038">                <span><span>//</span> so don't bother iterating further.</span></td>
      </tr>
      <tr>
        <td id="L5039" data-line-number="5039"></td>
        <td id="LC5039">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5040" data-line-number="5040"></td>
        <td id="LC5040">            }</td>
      </tr>
      <tr>
        <td id="L5041" data-line-number="5041"></td>
        <td id="LC5041">        }</td>
      </tr>
      <tr>
        <td id="L5042" data-line-number="5042"></td>
        <td id="LC5042">        argLst = info.<span>compCompHnd</span>-&gt;<span>getArgNext</span>(argLst);</td>
      </tr>
      <tr>
        <td id="L5043" data-line-number="5043"></td>
        <td id="LC5043">    }</td>
      </tr>
      <tr>
        <td id="L5044" data-line-number="5044"></td>
        <td id="LC5044">
</td>
      </tr>
      <tr>
        <td id="L5045" data-line-number="5045"></td>
        <td id="LC5045">    <span><span>//</span> Take care of non pre-spilled stack arguments.</span></td>
      </tr>
      <tr>
        <td id="L5046" data-line-number="5046"></td>
        <td id="LC5046">    argLst = info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>args</span>;</td>
      </tr>
      <tr>
        <td id="L5047" data-line-number="5047"></td>
        <td id="LC5047">    <span>for</span> (<span>unsigned</span> i = <span>0</span>, stkLclNum = lclNum; i &lt; argSigLen; ++i, ++stkLclNum)</td>
      </tr>
      <tr>
        <td id="L5048" data-line-number="5048"></td>
        <td id="LC5048">    {</td>
      </tr>
      <tr>
        <td id="L5049" data-line-number="5049"></td>
        <td id="LC5049">        <span>if</span> (!<span>lvaIsPreSpilled</span>(stkLclNum, preSpillMask))</td>
      </tr>
      <tr>
        <td id="L5050" data-line-number="5050"></td>
        <td id="LC5050">        {</td>
      </tr>
      <tr>
        <td id="L5051" data-line-number="5051"></td>
        <td id="LC5051">            argOffs =</td>
      </tr>
      <tr>
        <td id="L5052" data-line-number="5052"></td>
        <td id="LC5052">                <span>lvaAssignVirtualFrameOffsetToArg</span>(stkLclNum, <span>eeGetArgSize</span>(argLst, &amp;info.<span>compMethodInfo</span>-&gt;<span>args</span>), argOffs);</td>
      </tr>
      <tr>
        <td id="L5053" data-line-number="5053"></td>
        <td id="LC5053">            argLcls++;</td>
      </tr>
      <tr>
        <td id="L5054" data-line-number="5054"></td>
        <td id="LC5054">        }</td>
      </tr>
      <tr>
        <td id="L5055" data-line-number="5055"></td>
        <td id="LC5055">        argLst = info.<span>compCompHnd</span>-&gt;<span>getArgNext</span>(argLst);</td>
      </tr>
      <tr>
        <td id="L5056" data-line-number="5056"></td>
        <td id="LC5056">    }</td>
      </tr>
      <tr>
        <td id="L5057" data-line-number="5057"></td>
        <td id="LC5057">
</td>
      </tr>
      <tr>
        <td id="L5058" data-line-number="5058"></td>
        <td id="LC5058">    lclNum += argLcls;</td>
      </tr>
      <tr>
        <td id="L5059" data-line-number="5059"></td>
        <td id="LC5059">#<span>else</span> <span><span>//</span> !TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L5060" data-line-number="5060"></td>
        <td id="LC5060">    <span>for</span> (<span>unsigned</span> i = <span>0</span>; i &lt; argSigLen; i++)</td>
      </tr>
      <tr>
        <td id="L5061" data-line-number="5061"></td>
        <td id="LC5061">    {</td>
      </tr>
      <tr>
        <td id="L5062" data-line-number="5062"></td>
        <td id="LC5062">        <span>unsigned</span> argumentSize = <span>eeGetArgSize</span>(argLst, &amp;info.<span>compMethodInfo</span>-&gt;<span>args</span>);</td>
      </tr>
      <tr>
        <td id="L5063" data-line-number="5063"></td>
        <td id="LC5063">
</td>
      </tr>
      <tr>
        <td id="L5064" data-line-number="5064"></td>
        <td id="LC5064">#<span>ifdef</span> UNIX_AMD64_ABI</td>
      </tr>
      <tr>
        <td id="L5065" data-line-number="5065"></td>
        <td id="LC5065">        <span><span>//</span> On the stack frame the homed arg always takes a full number of slots</span></td>
      </tr>
      <tr>
        <td id="L5066" data-line-number="5066"></td>
        <td id="LC5066">        <span><span>//</span> for proper stack alignment. Make sure the real struct size is properly rounded up.</span></td>
      </tr>
      <tr>
        <td id="L5067" data-line-number="5067"></td>
        <td id="LC5067">        argumentSize = <span>roundUp</span>(argumentSize, TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L5068" data-line-number="5068"></td>
        <td id="LC5068">#<span>endif</span> <span><span>//</span> UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L5069" data-line-number="5069"></td>
        <td id="LC5069">
</td>
      </tr>
      <tr>
        <td id="L5070" data-line-number="5070"></td>
        <td id="LC5070">        argOffs =</td>
      </tr>
      <tr>
        <td id="L5071" data-line-number="5071"></td>
        <td id="LC5071">            <span>lvaAssignVirtualFrameOffsetToArg</span>(lclNum++, argumentSize, argOffs <span>UNIX_AMD64_ABI_ONLY_ARG</span>(&amp;callerArgOffset));</td>
      </tr>
      <tr>
        <td id="L5072" data-line-number="5072"></td>
        <td id="LC5072">        argLst = info.<span>compCompHnd</span>-&gt;<span>getArgNext</span>(argLst);</td>
      </tr>
      <tr>
        <td id="L5073" data-line-number="5073"></td>
        <td id="LC5073">    }</td>
      </tr>
      <tr>
        <td id="L5074" data-line-number="5074"></td>
        <td id="LC5074">#<span>endif</span> <span><span>//</span> !TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L5075" data-line-number="5075"></td>
        <td id="LC5075">
</td>
      </tr>
      <tr>
        <td id="L5076" data-line-number="5076"></td>
        <td id="LC5076">#<span>if</span> !USER_ARGS_COME_LAST</td>
      </tr>
      <tr>
        <td id="L5077" data-line-number="5077"></td>
        <td id="LC5077">
</td>
      </tr>
      <tr>
        <td id="L5078" data-line-number="5078"></td>
        <td id="LC5078">    <span><span>//</span>@GENERICS: extra argument for instantiation info</span></td>
      </tr>
      <tr>
        <td id="L5079" data-line-number="5079"></td>
        <td id="LC5079">    <span>if</span> (info.<span>compMethodInfo</span>-&gt;<span>args</span>.<span>callConv</span> &amp; CORINFO_CALLCONV_PARAMTYPE)</td>
      </tr>
      <tr>
        <td id="L5080" data-line-number="5080"></td>
        <td id="LC5080">    {</td>
      </tr>
      <tr>
        <td id="L5081" data-line-number="5081"></td>
        <td id="LC5081">        <span>noway_assert</span>(lclNum == (<span>unsigned</span>)info.<span>compTypeCtxtArg</span>);</td>
      </tr>
      <tr>
        <td id="L5082" data-line-number="5082"></td>
        <td id="LC5082">        argOffs = <span>lvaAssignVirtualFrameOffsetToArg</span>(lclNum++, REGSIZE_BYTES,</td>
      </tr>
      <tr>
        <td id="L5083" data-line-number="5083"></td>
        <td id="LC5083">                                                   argOffs <span>UNIX_AMD64_ABI_ONLY_ARG</span>(&amp;callerArgOffset));</td>
      </tr>
      <tr>
        <td id="L5084" data-line-number="5084"></td>
        <td id="LC5084">    }</td>
      </tr>
      <tr>
        <td id="L5085" data-line-number="5085"></td>
        <td id="LC5085">
</td>
      </tr>
      <tr>
        <td id="L5086" data-line-number="5086"></td>
        <td id="LC5086">    <span>if</span> (info.<span>compIsVarArgs</span>)</td>
      </tr>
      <tr>
        <td id="L5087" data-line-number="5087"></td>
        <td id="LC5087">    {</td>
      </tr>
      <tr>
        <td id="L5088" data-line-number="5088"></td>
        <td id="LC5088">        argOffs = <span>lvaAssignVirtualFrameOffsetToArg</span>(lclNum++, REGSIZE_BYTES,</td>
      </tr>
      <tr>
        <td id="L5089" data-line-number="5089"></td>
        <td id="LC5089">                                                   argOffs <span>UNIX_AMD64_ABI_ONLY_ARG</span>(&amp;callerArgOffset));</td>
      </tr>
      <tr>
        <td id="L5090" data-line-number="5090"></td>
        <td id="LC5090">    }</td>
      </tr>
      <tr>
        <td id="L5091" data-line-number="5091"></td>
        <td id="LC5091">
</td>
      </tr>
      <tr>
        <td id="L5092" data-line-number="5092"></td>
        <td id="LC5092">#<span>endif</span> <span><span>//</span> USER_ARGS_COME_LAST</span></td>
      </tr>
      <tr>
        <td id="L5093" data-line-number="5093"></td>
        <td id="LC5093">}</td>
      </tr>
      <tr>
        <td id="L5094" data-line-number="5094"></td>
        <td id="LC5094">
</td>
      </tr>
      <tr>
        <td id="L5095" data-line-number="5095"></td>
        <td id="LC5095">#<span>ifdef</span> UNIX_AMD64_ABI</td>
      </tr>
      <tr>
        <td id="L5096" data-line-number="5096"></td>
        <td id="LC5096"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5097" data-line-number="5097"></td>
        <td id="LC5097"><span><span>//</span>  lvaAssignVirtualFrameOffsetToArg() : Assign virtual stack offsets to an</span></td>
      </tr>
      <tr>
        <td id="L5098" data-line-number="5098"></td>
        <td id="LC5098"><span><span>//</span>  individual argument, and return the offset for the next argument.</span></td>
      </tr>
      <tr>
        <td id="L5099" data-line-number="5099"></td>
        <td id="LC5099"><span><span>//</span>  Note: This method only calculates the initial offset of the stack passed/spilled arguments</span></td>
      </tr>
      <tr>
        <td id="L5100" data-line-number="5100"></td>
        <td id="LC5100"><span><span>//</span>  (if any - the RA might decide to spill(home on the stack) register passed arguments, if rarely used.)</span></td>
      </tr>
      <tr>
        <td id="L5101" data-line-number="5101"></td>
        <td id="LC5101"><span><span>//</span>        The final offset is calculated in lvaFixVirtualFrameOffsets method. It accounts for FP existance,</span></td>
      </tr>
      <tr>
        <td id="L5102" data-line-number="5102"></td>
        <td id="LC5102"><span><span>//</span>        ret address slot, stack frame padding, alloca instructions, etc.</span></td>
      </tr>
      <tr>
        <td id="L5103" data-line-number="5103"></td>
        <td id="LC5103"><span><span>//</span>  Note: This is the implementation for UNIX_AMD64 System V platforms.</span></td>
      </tr>
      <tr>
        <td id="L5104" data-line-number="5104"></td>
        <td id="LC5104"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5105" data-line-number="5105"></td>
        <td id="LC5105"><span>int</span> <span>Compiler::lvaAssignVirtualFrameOffsetToArg</span>(<span>unsigned</span> lclNum,</td>
      </tr>
      <tr>
        <td id="L5106" data-line-number="5106"></td>
        <td id="LC5106">                                               <span>unsigned</span> argSize,</td>
      </tr>
      <tr>
        <td id="L5107" data-line-number="5107"></td>
        <td id="LC5107">                                               <span>int</span> argOffs <span>UNIX_AMD64_ABI_ONLY_ARG</span>(<span>int</span>* callerArgOffset))</td>
      </tr>
      <tr>
        <td id="L5108" data-line-number="5108"></td>
        <td id="LC5108">{</td>
      </tr>
      <tr>
        <td id="L5109" data-line-number="5109"></td>
        <td id="LC5109">    <span>noway_assert</span>(lclNum &lt; info.<span>compArgsCount</span>);</td>
      </tr>
      <tr>
        <td id="L5110" data-line-number="5110"></td>
        <td id="LC5110">    <span>noway_assert</span>(argSize);</td>
      </tr>
      <tr>
        <td id="L5111" data-line-number="5111"></td>
        <td id="LC5111">
</td>
      </tr>
      <tr>
        <td id="L5112" data-line-number="5112"></td>
        <td id="LC5112">    <span>if</span> (Target::g_tgtArgOrder == Target::ARG_ORDER_L2R)</td>
      </tr>
      <tr>
        <td id="L5113" data-line-number="5113"></td>
        <td id="LC5113">    {</td>
      </tr>
      <tr>
        <td id="L5114" data-line-number="5114"></td>
        <td id="LC5114">        argOffs -= argSize;</td>
      </tr>
      <tr>
        <td id="L5115" data-line-number="5115"></td>
        <td id="LC5115">    }</td>
      </tr>
      <tr>
        <td id="L5116" data-line-number="5116"></td>
        <td id="LC5116">
</td>
      </tr>
      <tr>
        <td id="L5117" data-line-number="5117"></td>
        <td id="LC5117">    <span>unsigned</span> fieldVarNum = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L5118" data-line-number="5118"></td>
        <td id="LC5118">
</td>
      </tr>
      <tr>
        <td id="L5119" data-line-number="5119"></td>
        <td id="LC5119">    <span>noway_assert</span>(lclNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L5120" data-line-number="5120"></td>
        <td id="LC5120">    LclVarDsc* varDsc = lvaTable + lclNum;</td>
      </tr>
      <tr>
        <td id="L5121" data-line-number="5121"></td>
        <td id="LC5121">
</td>
      </tr>
      <tr>
        <td id="L5122" data-line-number="5122"></td>
        <td id="LC5122">    <span>if</span> (varDsc-&gt;<span>lvPromotedStruct</span>())</td>
      </tr>
      <tr>
        <td id="L5123" data-line-number="5123"></td>
        <td id="LC5123">    {</td>
      </tr>
      <tr>
        <td id="L5124" data-line-number="5124"></td>
        <td id="LC5124">        <span>noway_assert</span>(varDsc-&gt;<span>lvFieldCnt</span> == <span>1</span>); <span><span>//</span> We only handle one field here</span></td>
      </tr>
      <tr>
        <td id="L5125" data-line-number="5125"></td>
        <td id="LC5125">        fieldVarNum = varDsc-&gt;<span>lvFieldLclStart</span>;</td>
      </tr>
      <tr>
        <td id="L5126" data-line-number="5126"></td>
        <td id="LC5126">
</td>
      </tr>
      <tr>
        <td id="L5127" data-line-number="5127"></td>
        <td id="LC5127">        lvaPromotionType promotionType = <span>lvaGetPromotionType</span>(varDsc);</td>
      </tr>
      <tr>
        <td id="L5128" data-line-number="5128"></td>
        <td id="LC5128">
</td>
      </tr>
      <tr>
        <td id="L5129" data-line-number="5129"></td>
        <td id="LC5129">        <span>if</span> (promotionType == PROMOTION_TYPE_INDEPENDENT)</td>
      </tr>
      <tr>
        <td id="L5130" data-line-number="5130"></td>
        <td id="LC5130">        {</td>
      </tr>
      <tr>
        <td id="L5131" data-line-number="5131"></td>
        <td id="LC5131">            lclNum = fieldVarNum;</td>
      </tr>
      <tr>
        <td id="L5132" data-line-number="5132"></td>
        <td id="LC5132">            <span>noway_assert</span>(lclNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L5133" data-line-number="5133"></td>
        <td id="LC5133">            varDsc = lvaTable + lclNum;</td>
      </tr>
      <tr>
        <td id="L5134" data-line-number="5134"></td>
        <td id="LC5134">            <span>assert</span>(varDsc-&gt;<span>lvIsStructField</span>);</td>
      </tr>
      <tr>
        <td id="L5135" data-line-number="5135"></td>
        <td id="LC5135">        }</td>
      </tr>
      <tr>
        <td id="L5136" data-line-number="5136"></td>
        <td id="LC5136">    }</td>
      </tr>
      <tr>
        <td id="L5137" data-line-number="5137"></td>
        <td id="LC5137">
</td>
      </tr>
      <tr>
        <td id="L5138" data-line-number="5138"></td>
        <td id="LC5138">    <span>noway_assert</span>(varDsc-&gt;<span>lvIsParam</span>);</td>
      </tr>
      <tr>
        <td id="L5139" data-line-number="5139"></td>
        <td id="LC5139">
</td>
      </tr>
      <tr>
        <td id="L5140" data-line-number="5140"></td>
        <td id="LC5140">    <span>if</span> (varDsc-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L5141" data-line-number="5141"></td>
        <td id="LC5141">    {</td>
      </tr>
      <tr>
        <td id="L5142" data-line-number="5142"></td>
        <td id="LC5142">        <span><span>//</span> Argument is passed in a register, don't count it</span></td>
      </tr>
      <tr>
        <td id="L5143" data-line-number="5143"></td>
        <td id="LC5143">        <span><span>//</span> when updating the current offset on the stack.</span></td>
      </tr>
      <tr>
        <td id="L5144" data-line-number="5144"></td>
        <td id="LC5144">
</td>
      </tr>
      <tr>
        <td id="L5145" data-line-number="5145"></td>
        <td id="LC5145">        <span>if</span> (varDsc-&gt;<span>lvOnFrame</span>)</td>
      </tr>
      <tr>
        <td id="L5146" data-line-number="5146"></td>
        <td id="LC5146">        {</td>
      </tr>
      <tr>
        <td id="L5147" data-line-number="5147"></td>
        <td id="LC5147">            <span><span>//</span> The offset for args needs to be set only for the stack homed arguments for System V.</span></td>
      </tr>
      <tr>
        <td id="L5148" data-line-number="5148"></td>
        <td id="LC5148">            varDsc-&gt;<span>lvStkOffs</span> = argOffs;</td>
      </tr>
      <tr>
        <td id="L5149" data-line-number="5149"></td>
        <td id="LC5149">        }</td>
      </tr>
      <tr>
        <td id="L5150" data-line-number="5150"></td>
        <td id="LC5150">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L5151" data-line-number="5151"></td>
        <td id="LC5151">        {</td>
      </tr>
      <tr>
        <td id="L5152" data-line-number="5152"></td>
        <td id="LC5152">            varDsc-&gt;<span>lvStkOffs</span> = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L5153" data-line-number="5153"></td>
        <td id="LC5153">        }</td>
      </tr>
      <tr>
        <td id="L5154" data-line-number="5154"></td>
        <td id="LC5154">    }</td>
      </tr>
      <tr>
        <td id="L5155" data-line-number="5155"></td>
        <td id="LC5155">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L5156" data-line-number="5156"></td>
        <td id="LC5156">    {</td>
      </tr>
      <tr>
        <td id="L5157" data-line-number="5157"></td>
        <td id="LC5157">        <span><span>//</span> For Windows AMD64 there are 4 slots for the register passed arguments on the top of the caller's stack.</span></td>
      </tr>
      <tr>
        <td id="L5158" data-line-number="5158"></td>
        <td id="LC5158">        <span><span>//</span> This is where they are always homed. So, they can be accessed with positive offset.</span></td>
      </tr>
      <tr>
        <td id="L5159" data-line-number="5159"></td>
        <td id="LC5159">        <span><span>//</span> On System V platforms, if the RA decides to home a register passed arg on the stack, it creates a stack</span></td>
      </tr>
      <tr>
        <td id="L5160" data-line-number="5160"></td>
        <td id="LC5160">        <span><span>//</span> location on the callee stack (like any other local var.) In such a case, the register passed, stack homed</span></td>
      </tr>
      <tr>
        <td id="L5161" data-line-number="5161"></td>
        <td id="LC5161">        <span><span>//</span> arguments are accessed using negative offsets and the stack passed arguments are accessed using positive</span></td>
      </tr>
      <tr>
        <td id="L5162" data-line-number="5162"></td>
        <td id="LC5162">        <span><span>//</span> offset (from the caller's stack.)</span></td>
      </tr>
      <tr>
        <td id="L5163" data-line-number="5163"></td>
        <td id="LC5163">        <span><span>//</span> For  System V platforms if there is no frame pointer the caller stack parameter offset should include the</span></td>
      </tr>
      <tr>
        <td id="L5164" data-line-number="5164"></td>
        <td id="LC5164">        <span><span>//</span> callee allocated space. If frame register is used, the callee allocated space should not be included for</span></td>
      </tr>
      <tr>
        <td id="L5165" data-line-number="5165"></td>
        <td id="LC5165">        <span><span>//</span> accessing the caller stack parameters. The last two requirements are met in lvaFixVirtualFrameOffsets</span></td>
      </tr>
      <tr>
        <td id="L5166" data-line-number="5166"></td>
        <td id="LC5166">        <span><span>//</span> method, which fixes the offsets, based on frame pointer existence, existence of alloca instructions, ret</span></td>
      </tr>
      <tr>
        <td id="L5167" data-line-number="5167"></td>
        <td id="LC5167">        <span><span>//</span> address pushed, ets.</span></td>
      </tr>
      <tr>
        <td id="L5168" data-line-number="5168"></td>
        <td id="LC5168">
</td>
      </tr>
      <tr>
        <td id="L5169" data-line-number="5169"></td>
        <td id="LC5169">        varDsc-&gt;<span>lvStkOffs</span> = *callerArgOffset;</td>
      </tr>
      <tr>
        <td id="L5170" data-line-number="5170"></td>
        <td id="LC5170">        <span><span>//</span> Structs passed on stack could be of size less than TARGET_POINTER_SIZE.</span></td>
      </tr>
      <tr>
        <td id="L5171" data-line-number="5171"></td>
        <td id="LC5171">        <span><span>//</span> Make sure they get at least TARGET_POINTER_SIZE on the stack - this is required for alignment.</span></td>
      </tr>
      <tr>
        <td id="L5172" data-line-number="5172"></td>
        <td id="LC5172">        <span>if</span> (argSize &gt; TARGET_POINTER_SIZE)</td>
      </tr>
      <tr>
        <td id="L5173" data-line-number="5173"></td>
        <td id="LC5173">        {</td>
      </tr>
      <tr>
        <td id="L5174" data-line-number="5174"></td>
        <td id="LC5174">            *callerArgOffset += (<span>int</span>)<span>roundUp</span>(argSize, TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L5175" data-line-number="5175"></td>
        <td id="LC5175">        }</td>
      </tr>
      <tr>
        <td id="L5176" data-line-number="5176"></td>
        <td id="LC5176">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L5177" data-line-number="5177"></td>
        <td id="LC5177">        {</td>
      </tr>
      <tr>
        <td id="L5178" data-line-number="5178"></td>
        <td id="LC5178">            *callerArgOffset += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5179" data-line-number="5179"></td>
        <td id="LC5179">        }</td>
      </tr>
      <tr>
        <td id="L5180" data-line-number="5180"></td>
        <td id="LC5180">    }</td>
      </tr>
      <tr>
        <td id="L5181" data-line-number="5181"></td>
        <td id="LC5181">
</td>
      </tr>
      <tr>
        <td id="L5182" data-line-number="5182"></td>
        <td id="LC5182">    <span><span>//</span> For struct promoted parameters we need to set the offsets for both LclVars.</span></td>
      </tr>
      <tr>
        <td id="L5183" data-line-number="5183"></td>
        <td id="LC5183">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5184" data-line-number="5184"></td>
        <td id="LC5184">    <span><span>//</span> For a dependent promoted struct we also assign the struct fields stack offset</span></td>
      </tr>
      <tr>
        <td id="L5185" data-line-number="5185"></td>
        <td id="LC5185">    <span>if</span> (varDsc-&gt;<span>lvPromotedStruct</span>())</td>
      </tr>
      <tr>
        <td id="L5186" data-line-number="5186"></td>
        <td id="LC5186">    {</td>
      </tr>
      <tr>
        <td id="L5187" data-line-number="5187"></td>
        <td id="LC5187">        lvaPromotionType promotionType = <span>lvaGetPromotionType</span>(varDsc);</td>
      </tr>
      <tr>
        <td id="L5188" data-line-number="5188"></td>
        <td id="LC5188">
</td>
      </tr>
      <tr>
        <td id="L5189" data-line-number="5189"></td>
        <td id="LC5189">        <span>if</span> (promotionType == PROMOTION_TYPE_DEPENDENT)</td>
      </tr>
      <tr>
        <td id="L5190" data-line-number="5190"></td>
        <td id="LC5190">        {</td>
      </tr>
      <tr>
        <td id="L5191" data-line-number="5191"></td>
        <td id="LC5191">            <span>noway_assert</span>(varDsc-&gt;<span>lvFieldCnt</span> == <span>1</span>); <span><span>//</span> We only handle one field here</span></td>
      </tr>
      <tr>
        <td id="L5192" data-line-number="5192"></td>
        <td id="LC5192">
</td>
      </tr>
      <tr>
        <td id="L5193" data-line-number="5193"></td>
        <td id="LC5193">            <span>assert</span>(fieldVarNum == varDsc-&gt;<span>lvFieldLclStart</span>);</td>
      </tr>
      <tr>
        <td id="L5194" data-line-number="5194"></td>
        <td id="LC5194">            lvaTable[fieldVarNum].<span>lvStkOffs</span> = varDsc-&gt;<span>lvStkOffs</span>;</td>
      </tr>
      <tr>
        <td id="L5195" data-line-number="5195"></td>
        <td id="LC5195">        }</td>
      </tr>
      <tr>
        <td id="L5196" data-line-number="5196"></td>
        <td id="LC5196">    }</td>
      </tr>
      <tr>
        <td id="L5197" data-line-number="5197"></td>
        <td id="LC5197">    <span><span>//</span> For an independent promoted struct field we also assign the parent struct stack offset</span></td>
      </tr>
      <tr>
        <td id="L5198" data-line-number="5198"></td>
        <td id="LC5198">    <span>else</span> <span>if</span> (varDsc-&gt;<span>lvIsStructField</span>)</td>
      </tr>
      <tr>
        <td id="L5199" data-line-number="5199"></td>
        <td id="LC5199">    {</td>
      </tr>
      <tr>
        <td id="L5200" data-line-number="5200"></td>
        <td id="LC5200">        <span>noway_assert</span>(varDsc-&gt;<span>lvParentLcl</span> &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L5201" data-line-number="5201"></td>
        <td id="LC5201">        lvaTable[varDsc-&gt;<span>lvParentLcl</span>].<span>lvStkOffs</span> = varDsc-&gt;<span>lvStkOffs</span>;</td>
      </tr>
      <tr>
        <td id="L5202" data-line-number="5202"></td>
        <td id="LC5202">    }</td>
      </tr>
      <tr>
        <td id="L5203" data-line-number="5203"></td>
        <td id="LC5203">
</td>
      </tr>
      <tr>
        <td id="L5204" data-line-number="5204"></td>
        <td id="LC5204">    <span>if</span> (Target::g_tgtArgOrder == Target::ARG_ORDER_R2L &amp;&amp; !varDsc-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L5205" data-line-number="5205"></td>
        <td id="LC5205">    {</td>
      </tr>
      <tr>
        <td id="L5206" data-line-number="5206"></td>
        <td id="LC5206">        argOffs += argSize;</td>
      </tr>
      <tr>
        <td id="L5207" data-line-number="5207"></td>
        <td id="LC5207">    }</td>
      </tr>
      <tr>
        <td id="L5208" data-line-number="5208"></td>
        <td id="LC5208">
</td>
      </tr>
      <tr>
        <td id="L5209" data-line-number="5209"></td>
        <td id="LC5209">    <span>return</span> argOffs;</td>
      </tr>
      <tr>
        <td id="L5210" data-line-number="5210"></td>
        <td id="LC5210">}</td>
      </tr>
      <tr>
        <td id="L5211" data-line-number="5211"></td>
        <td id="LC5211">
</td>
      </tr>
      <tr>
        <td id="L5212" data-line-number="5212"></td>
        <td id="LC5212">#<span>else</span> <span><span>//</span> !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L5213" data-line-number="5213"></td>
        <td id="LC5213">
</td>
      </tr>
      <tr>
        <td id="L5214" data-line-number="5214"></td>
        <td id="LC5214"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5215" data-line-number="5215"></td>
        <td id="LC5215"><span><span>//</span>  lvaAssignVirtualFrameOffsetToArg() : Assign virtual stack offsets to an</span></td>
      </tr>
      <tr>
        <td id="L5216" data-line-number="5216"></td>
        <td id="LC5216"><span><span>//</span>  individual argument, and return the offset for the next argument.</span></td>
      </tr>
      <tr>
        <td id="L5217" data-line-number="5217"></td>
        <td id="LC5217"><span><span>//</span>  Note: This method only calculates the initial offset of the stack passed/spilled arguments</span></td>
      </tr>
      <tr>
        <td id="L5218" data-line-number="5218"></td>
        <td id="LC5218"><span><span>//</span>  (if any - the RA might decide to spill(home on the stack) register passed arguments, if rarely used.)</span></td>
      </tr>
      <tr>
        <td id="L5219" data-line-number="5219"></td>
        <td id="LC5219"><span><span>//</span>        The final offset is calculated in lvaFixVirtualFrameOffsets method. It accounts for FP existance,</span></td>
      </tr>
      <tr>
        <td id="L5220" data-line-number="5220"></td>
        <td id="LC5220"><span><span>//</span>        ret address slot, stack frame padding, alloca instructions, etc.</span></td>
      </tr>
      <tr>
        <td id="L5221" data-line-number="5221"></td>
        <td id="LC5221"><span><span>//</span>  Note: This implementation for all the platforms but UNIX_AMD64 OSs (System V 64 bit.)</span></td>
      </tr>
      <tr>
        <td id="L5222" data-line-number="5222"></td>
        <td id="LC5222"><span>int</span> <span>Compiler::lvaAssignVirtualFrameOffsetToArg</span>(<span>unsigned</span> lclNum,</td>
      </tr>
      <tr>
        <td id="L5223" data-line-number="5223"></td>
        <td id="LC5223">                                               <span>unsigned</span> argSize,</td>
      </tr>
      <tr>
        <td id="L5224" data-line-number="5224"></td>
        <td id="LC5224">                                               <span>int</span> argOffs <span>UNIX_AMD64_ABI_ONLY_ARG</span>(<span>int</span>* callerArgOffset))</td>
      </tr>
      <tr>
        <td id="L5225" data-line-number="5225"></td>
        <td id="LC5225">{</td>
      </tr>
      <tr>
        <td id="L5226" data-line-number="5226"></td>
        <td id="LC5226">    <span>noway_assert</span>(lclNum &lt; info.<span>compArgsCount</span>);</td>
      </tr>
      <tr>
        <td id="L5227" data-line-number="5227"></td>
        <td id="LC5227">    <span>noway_assert</span>(argSize);</td>
      </tr>
      <tr>
        <td id="L5228" data-line-number="5228"></td>
        <td id="LC5228">
</td>
      </tr>
      <tr>
        <td id="L5229" data-line-number="5229"></td>
        <td id="LC5229">    <span>if</span> (Target::g_tgtArgOrder == Target::ARG_ORDER_L2R)</td>
      </tr>
      <tr>
        <td id="L5230" data-line-number="5230"></td>
        <td id="LC5230">    {</td>
      </tr>
      <tr>
        <td id="L5231" data-line-number="5231"></td>
        <td id="LC5231">        argOffs -= argSize;</td>
      </tr>
      <tr>
        <td id="L5232" data-line-number="5232"></td>
        <td id="LC5232">    }</td>
      </tr>
      <tr>
        <td id="L5233" data-line-number="5233"></td>
        <td id="LC5233">
</td>
      </tr>
      <tr>
        <td id="L5234" data-line-number="5234"></td>
        <td id="LC5234">    <span>unsigned</span> fieldVarNum = BAD_VAR_NUM;</td>
      </tr>
      <tr>
        <td id="L5235" data-line-number="5235"></td>
        <td id="LC5235">
</td>
      </tr>
      <tr>
        <td id="L5236" data-line-number="5236"></td>
        <td id="LC5236">    <span>noway_assert</span>(lclNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L5237" data-line-number="5237"></td>
        <td id="LC5237">    LclVarDsc* varDsc = lvaTable + lclNum;</td>
      </tr>
      <tr>
        <td id="L5238" data-line-number="5238"></td>
        <td id="LC5238">
</td>
      </tr>
      <tr>
        <td id="L5239" data-line-number="5239"></td>
        <td id="LC5239">    <span>if</span> (varDsc-&gt;<span>lvPromotedStruct</span>())</td>
      </tr>
      <tr>
        <td id="L5240" data-line-number="5240"></td>
        <td id="LC5240">    {</td>
      </tr>
      <tr>
        <td id="L5241" data-line-number="5241"></td>
        <td id="LC5241">        <span>noway_assert</span>(varDsc-&gt;<span>lvFieldCnt</span> == <span>1</span>); <span><span>//</span> We only handle one field here</span></td>
      </tr>
      <tr>
        <td id="L5242" data-line-number="5242"></td>
        <td id="LC5242">        fieldVarNum = varDsc-&gt;<span>lvFieldLclStart</span>;</td>
      </tr>
      <tr>
        <td id="L5243" data-line-number="5243"></td>
        <td id="LC5243">
</td>
      </tr>
      <tr>
        <td id="L5244" data-line-number="5244"></td>
        <td id="LC5244">        lvaPromotionType promotionType = <span>lvaGetPromotionType</span>(varDsc);</td>
      </tr>
      <tr>
        <td id="L5245" data-line-number="5245"></td>
        <td id="LC5245">
</td>
      </tr>
      <tr>
        <td id="L5246" data-line-number="5246"></td>
        <td id="LC5246">        <span>if</span> (promotionType == PROMOTION_TYPE_INDEPENDENT)</td>
      </tr>
      <tr>
        <td id="L5247" data-line-number="5247"></td>
        <td id="LC5247">        {</td>
      </tr>
      <tr>
        <td id="L5248" data-line-number="5248"></td>
        <td id="LC5248">            lclNum = fieldVarNum;</td>
      </tr>
      <tr>
        <td id="L5249" data-line-number="5249"></td>
        <td id="LC5249">            <span>noway_assert</span>(lclNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L5250" data-line-number="5250"></td>
        <td id="LC5250">            varDsc = lvaTable + lclNum;</td>
      </tr>
      <tr>
        <td id="L5251" data-line-number="5251"></td>
        <td id="LC5251">            <span>assert</span>(varDsc-&gt;<span>lvIsStructField</span>);</td>
      </tr>
      <tr>
        <td id="L5252" data-line-number="5252"></td>
        <td id="LC5252">        }</td>
      </tr>
      <tr>
        <td id="L5253" data-line-number="5253"></td>
        <td id="LC5253">    }</td>
      </tr>
      <tr>
        <td id="L5254" data-line-number="5254"></td>
        <td id="LC5254">
</td>
      </tr>
      <tr>
        <td id="L5255" data-line-number="5255"></td>
        <td id="LC5255">    <span>noway_assert</span>(varDsc-&gt;<span>lvIsParam</span>);</td>
      </tr>
      <tr>
        <td id="L5256" data-line-number="5256"></td>
        <td id="LC5256">
</td>
      </tr>
      <tr>
        <td id="L5257" data-line-number="5257"></td>
        <td id="LC5257">    <span>if</span> (varDsc-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L5258" data-line-number="5258"></td>
        <td id="LC5258">    {</td>
      </tr>
      <tr>
        <td id="L5259" data-line-number="5259"></td>
        <td id="LC5259">        <span><span>/*</span> Argument is passed in a register, don't count it</span></td>
      </tr>
      <tr>
        <td id="L5260" data-line-number="5260"></td>
        <td id="LC5260"><span>         * when updating the current offset on the stack <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L5261" data-line-number="5261"></td>
        <td id="LC5261">        CLANG_FORMAT_COMMENT_ANCHOR;</td>
      </tr>
      <tr>
        <td id="L5262" data-line-number="5262"></td>
        <td id="LC5262">
</td>
      </tr>
      <tr>
        <td id="L5263" data-line-number="5263"></td>
        <td id="LC5263">#<span>if</span> !defined(TARGET_ARMARCH)</td>
      </tr>
      <tr>
        <td id="L5264" data-line-number="5264"></td>
        <td id="LC5264">#<span>if</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L5265" data-line-number="5265"></td>
        <td id="LC5265">        <span><span>//</span> TODO: Remove this noway_assert and replace occurrences of TARGET_POINTER_SIZE with argSize</span></td>
      </tr>
      <tr>
        <td id="L5266" data-line-number="5266"></td>
        <td id="LC5266">        <span><span>//</span> Also investigate why we are incrementing argOffs for X86 as this seems incorrect</span></td>
      </tr>
      <tr>
        <td id="L5267" data-line-number="5267"></td>
        <td id="LC5267">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5268" data-line-number="5268"></td>
        <td id="LC5268">        <span>noway_assert</span>(argSize == TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L5269" data-line-number="5269"></td>
        <td id="LC5269">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L5270" data-line-number="5270"></td>
        <td id="LC5270">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5271" data-line-number="5271"></td>
        <td id="LC5271">
</td>
      </tr>
      <tr>
        <td id="L5272" data-line-number="5272"></td>
        <td id="LC5272">#<span>if</span> defined(TARGET_X86)</td>
      </tr>
      <tr>
        <td id="L5273" data-line-number="5273"></td>
        <td id="LC5273">        argOffs += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5274" data-line-number="5274"></td>
        <td id="LC5274">#<span>elif</span> defined(TARGET_AMD64)</td>
      </tr>
      <tr>
        <td id="L5275" data-line-number="5275"></td>
        <td id="LC5275">        <span><span>//</span> Register arguments on AMD64 also takes stack space. (in the backing store)</span></td>
      </tr>
      <tr>
        <td id="L5276" data-line-number="5276"></td>
        <td id="LC5276">        varDsc-&gt;<span>lvStkOffs</span> = argOffs;</td>
      </tr>
      <tr>
        <td id="L5277" data-line-number="5277"></td>
        <td id="LC5277">        argOffs += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5278" data-line-number="5278"></td>
        <td id="LC5278">#<span>elif</span> defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L5279" data-line-number="5279"></td>
        <td id="LC5279"><span><span>//</span> Register arguments on ARM64 only take stack space when they have a frame home.</span></td>
      </tr>
      <tr>
        <td id="L5280" data-line-number="5280"></td>
        <td id="LC5280"><span><span>//</span> Unless on windows and in a vararg method.</span></td>
      </tr>
      <tr>
        <td id="L5281" data-line-number="5281"></td>
        <td id="LC5281">#<span>if</span> FEATURE_ARG_SPLIT</td>
      </tr>
      <tr>
        <td id="L5282" data-line-number="5282"></td>
        <td id="LC5282">        <span>if</span> (<span>this</span>-&gt;<span>info</span>.<span>compIsVarArgs</span>)</td>
      </tr>
      <tr>
        <td id="L5283" data-line-number="5283"></td>
        <td id="LC5283">        {</td>
      </tr>
      <tr>
        <td id="L5284" data-line-number="5284"></td>
        <td id="LC5284">            <span>if</span> (varDsc-&gt;<span>lvType</span> == TYP_STRUCT &amp;&amp; varDsc-&gt;<span>GetOtherArgReg</span>() &gt;= MAX_REG_ARG &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L5285" data-line-number="5285"></td>
        <td id="LC5285">                varDsc-&gt;<span>GetOtherArgReg</span>() != REG_NA)</td>
      </tr>
      <tr>
        <td id="L5286" data-line-number="5286"></td>
        <td id="LC5286">            {</td>
      </tr>
      <tr>
        <td id="L5287" data-line-number="5287"></td>
        <td id="LC5287">                <span><span>//</span> This is a split struct. It will account for an extra (8 bytes)</span></td>
      </tr>
      <tr>
        <td id="L5288" data-line-number="5288"></td>
        <td id="LC5288">                <span><span>//</span> of alignment.</span></td>
      </tr>
      <tr>
        <td id="L5289" data-line-number="5289"></td>
        <td id="LC5289">                varDsc-&gt;<span>lvStkOffs</span> += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5290" data-line-number="5290"></td>
        <td id="LC5290">                argOffs += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5291" data-line-number="5291"></td>
        <td id="LC5291">            }</td>
      </tr>
      <tr>
        <td id="L5292" data-line-number="5292"></td>
        <td id="LC5292">        }</td>
      </tr>
      <tr>
        <td id="L5293" data-line-number="5293"></td>
        <td id="LC5293">#<span>endif</span> <span><span>//</span> FEATURE_ARG_SPLIT</span></td>
      </tr>
      <tr>
        <td id="L5294" data-line-number="5294"></td>
        <td id="LC5294">
</td>
      </tr>
      <tr>
        <td id="L5295" data-line-number="5295"></td>
        <td id="LC5295">#<span>elif</span> defined(TARGET_ARM)</td>
      </tr>
      <tr>
        <td id="L5296" data-line-number="5296"></td>
        <td id="LC5296">        <span><span>//</span> On ARM we spill the registers in codeGen-&gt;regSet.rsMaskPreSpillRegArg</span></td>
      </tr>
      <tr>
        <td id="L5297" data-line-number="5297"></td>
        <td id="LC5297">        <span><span>//</span> in the prolog, so we have to fill in lvStkOffs here</span></td>
      </tr>
      <tr>
        <td id="L5298" data-line-number="5298"></td>
        <td id="LC5298">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5299" data-line-number="5299"></td>
        <td id="LC5299">        regMaskTP regMask = <span>genRegMask</span>(varDsc-&gt;<span>GetArgReg</span>());</td>
      </tr>
      <tr>
        <td id="L5300" data-line-number="5300"></td>
        <td id="LC5300">        <span>if</span> (codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegArg</span> &amp; regMask)</td>
      </tr>
      <tr>
        <td id="L5301" data-line-number="5301"></td>
        <td id="LC5301">        {</td>
      </tr>
      <tr>
        <td id="L5302" data-line-number="5302"></td>
        <td id="LC5302">            <span><span>//</span> Signature: void foo(struct_8, int, struct_4)</span></td>
      </tr>
      <tr>
        <td id="L5303" data-line-number="5303"></td>
        <td id="LC5303">            <span><span>//</span> ------- CALLER SP -------</span></td>
      </tr>
      <tr>
        <td id="L5304" data-line-number="5304"></td>
        <td id="LC5304">            <span><span>//</span> r3 struct_4</span></td>
      </tr>
      <tr>
        <td id="L5305" data-line-number="5305"></td>
        <td id="LC5305">            <span><span>//</span> r2 int - not prespilled, but added for alignment. argOffs should skip this.</span></td>
      </tr>
      <tr>
        <td id="L5306" data-line-number="5306"></td>
        <td id="LC5306">            <span><span>//</span> r1 struct_8</span></td>
      </tr>
      <tr>
        <td id="L5307" data-line-number="5307"></td>
        <td id="LC5307">            <span><span>//</span> r0 struct_8</span></td>
      </tr>
      <tr>
        <td id="L5308" data-line-number="5308"></td>
        <td id="LC5308">            <span><span>//</span> -------------------------</span></td>
      </tr>
      <tr>
        <td id="L5309" data-line-number="5309"></td>
        <td id="LC5309">            <span><span>//</span> If we added alignment we need to fix argOffs for all registers above alignment.</span></td>
      </tr>
      <tr>
        <td id="L5310" data-line-number="5310"></td>
        <td id="LC5310">            <span>if</span> (codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillAlign</span> != RBM_NONE)</td>
      </tr>
      <tr>
        <td id="L5311" data-line-number="5311"></td>
        <td id="LC5311">            {</td>
      </tr>
      <tr>
        <td id="L5312" data-line-number="5312"></td>
        <td id="LC5312">                <span>assert</span>(<span>genCountBits</span>(codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillAlign</span>) == <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L5313" data-line-number="5313"></td>
        <td id="LC5313">                <span><span>//</span> Is register beyond the alignment pos?</span></td>
      </tr>
      <tr>
        <td id="L5314" data-line-number="5314"></td>
        <td id="LC5314">                <span>if</span> (regMask &gt; codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillAlign</span>)</td>
      </tr>
      <tr>
        <td id="L5315" data-line-number="5315"></td>
        <td id="LC5315">                {</td>
      </tr>
      <tr>
        <td id="L5316" data-line-number="5316"></td>
        <td id="LC5316">                    <span><span>//</span> Increment argOffs just once for the _first_ register after alignment pos</span></td>
      </tr>
      <tr>
        <td id="L5317" data-line-number="5317"></td>
        <td id="LC5317">                    <span><span>//</span> in the prespill mask.</span></td>
      </tr>
      <tr>
        <td id="L5318" data-line-number="5318"></td>
        <td id="LC5318">                    <span>if</span> (!<span>BitsBetween</span>(codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegArg</span>, regMask,</td>
      </tr>
      <tr>
        <td id="L5319" data-line-number="5319"></td>
        <td id="LC5319">                                     codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillAlign</span>))</td>
      </tr>
      <tr>
        <td id="L5320" data-line-number="5320"></td>
        <td id="LC5320">                    {</td>
      </tr>
      <tr>
        <td id="L5321" data-line-number="5321"></td>
        <td id="LC5321">                        argOffs += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5322" data-line-number="5322"></td>
        <td id="LC5322">                    }</td>
      </tr>
      <tr>
        <td id="L5323" data-line-number="5323"></td>
        <td id="LC5323">                }</td>
      </tr>
      <tr>
        <td id="L5324" data-line-number="5324"></td>
        <td id="LC5324">            }</td>
      </tr>
      <tr>
        <td id="L5325" data-line-number="5325"></td>
        <td id="LC5325">
</td>
      </tr>
      <tr>
        <td id="L5326" data-line-number="5326"></td>
        <td id="LC5326">            <span>switch</span> (varDsc-&gt;<span>lvType</span>)</td>
      </tr>
      <tr>
        <td id="L5327" data-line-number="5327"></td>
        <td id="LC5327">            {</td>
      </tr>
      <tr>
        <td id="L5328" data-line-number="5328"></td>
        <td id="LC5328">                <span>case</span> TYP_STRUCT:</td>
      </tr>
      <tr>
        <td id="L5329" data-line-number="5329"></td>
        <td id="LC5329">                    <span>if</span> (!varDsc-&gt;<span>lvStructDoubleAlign</span>)</td>
      </tr>
      <tr>
        <td id="L5330" data-line-number="5330"></td>
        <td id="LC5330">                    {</td>
      </tr>
      <tr>
        <td id="L5331" data-line-number="5331"></td>
        <td id="LC5331">                        <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5332" data-line-number="5332"></td>
        <td id="LC5332">                    }</td>
      </tr>
      <tr>
        <td id="L5333" data-line-number="5333"></td>
        <td id="LC5333">                    __fallthrough;</td>
      </tr>
      <tr>
        <td id="L5334" data-line-number="5334"></td>
        <td id="LC5334">
</td>
      </tr>
      <tr>
        <td id="L5335" data-line-number="5335"></td>
        <td id="LC5335">                <span>case</span> TYP_DOUBLE:</td>
      </tr>
      <tr>
        <td id="L5336" data-line-number="5336"></td>
        <td id="LC5336">                <span>case</span> TYP_LONG:</td>
      </tr>
      <tr>
        <td id="L5337" data-line-number="5337"></td>
        <td id="LC5337">                {</td>
      </tr>
      <tr>
        <td id="L5338" data-line-number="5338"></td>
        <td id="LC5338">                    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5339" data-line-number="5339"></td>
        <td id="LC5339">                    <span><span>//</span> Let's assign offsets to arg1, a double in r2. argOffs has to be 4 not 8.</span></td>
      </tr>
      <tr>
        <td id="L5340" data-line-number="5340"></td>
        <td id="LC5340">                    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5341" data-line-number="5341"></td>
        <td id="LC5341">                    <span><span>//</span> ------- CALLER SP -------</span></td>
      </tr>
      <tr>
        <td id="L5342" data-line-number="5342"></td>
        <td id="LC5342">                    <span><span>//</span> r3</span></td>
      </tr>
      <tr>
        <td id="L5343" data-line-number="5343"></td>
        <td id="LC5343">                    <span><span>//</span> r2 double   -- argOffs = 4, but it doesn't need to be skipped, because there is no skipping.</span></td>
      </tr>
      <tr>
        <td id="L5344" data-line-number="5344"></td>
        <td id="LC5344">                    <span><span>//</span> r1 VACookie -- argOffs = 0</span></td>
      </tr>
      <tr>
        <td id="L5345" data-line-number="5345"></td>
        <td id="LC5345">                    <span><span>//</span> -------------------------</span></td>
      </tr>
      <tr>
        <td id="L5346" data-line-number="5346"></td>
        <td id="LC5346">                    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5347" data-line-number="5347"></td>
        <td id="LC5347">                    <span><span>//</span> Consider argOffs as if it accounts for number of prespilled registers before the current</span></td>
      </tr>
      <tr>
        <td id="L5348" data-line-number="5348"></td>
        <td id="LC5348">                    <span><span>//</span> register. In the above example, for r2, it is r1 that is prespilled, but since r1 is</span></td>
      </tr>
      <tr>
        <td id="L5349" data-line-number="5349"></td>
        <td id="LC5349">                    <span><span>//</span> accounted for by argOffs being 4, there should have been no skipping. Instead, if we didn't</span></td>
      </tr>
      <tr>
        <td id="L5350" data-line-number="5350"></td>
        <td id="LC5350">                    <span><span>//</span> assign r1 to any variable, then argOffs would still be 0 which implies it is not accounting</span></td>
      </tr>
      <tr>
        <td id="L5351" data-line-number="5351"></td>
        <td id="LC5351">                    <span><span>//</span> for r1, equivalently r1 is skipped.</span></td>
      </tr>
      <tr>
        <td id="L5352" data-line-number="5352"></td>
        <td id="LC5352">                    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5353" data-line-number="5353"></td>
        <td id="LC5353">                    <span><span>//</span> If prevRegsSize is unaccounted for by a corresponding argOffs, we must have skipped a register.</span></td>
      </tr>
      <tr>
        <td id="L5354" data-line-number="5354"></td>
        <td id="LC5354">                    <span>int</span> prevRegsSize =</td>
      </tr>
      <tr>
        <td id="L5355" data-line-number="5355"></td>
        <td id="LC5355">                        <span>genCountBits</span>(codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegArg</span> &amp; (regMask - <span>1</span>)) * TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5356" data-line-number="5356"></td>
        <td id="LC5356">                    <span>if</span> (argOffs &lt; prevRegsSize)</td>
      </tr>
      <tr>
        <td id="L5357" data-line-number="5357"></td>
        <td id="LC5357">                    {</td>
      </tr>
      <tr>
        <td id="L5358" data-line-number="5358"></td>
        <td id="LC5358">                        <span><span>//</span> We must align up the argOffset to a multiple of 8 to account for skipped registers.</span></td>
      </tr>
      <tr>
        <td id="L5359" data-line-number="5359"></td>
        <td id="LC5359">                        argOffs = <span>roundUp</span>((<span>unsigned</span>)argOffs, <span>2</span> * TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L5360" data-line-number="5360"></td>
        <td id="LC5360">                    }</td>
      </tr>
      <tr>
        <td id="L5361" data-line-number="5361"></td>
        <td id="LC5361">                    <span><span>//</span> We should've skipped only a single register.</span></td>
      </tr>
      <tr>
        <td id="L5362" data-line-number="5362"></td>
        <td id="LC5362">                    <span>assert</span>(argOffs == prevRegsSize);</td>
      </tr>
      <tr>
        <td id="L5363" data-line-number="5363"></td>
        <td id="LC5363">                }</td>
      </tr>
      <tr>
        <td id="L5364" data-line-number="5364"></td>
        <td id="LC5364">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5365" data-line-number="5365"></td>
        <td id="LC5365">
</td>
      </tr>
      <tr>
        <td id="L5366" data-line-number="5366"></td>
        <td id="LC5366">                <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L5367" data-line-number="5367"></td>
        <td id="LC5367">                    <span><span>//</span> No alignment of argOffs required</span></td>
      </tr>
      <tr>
        <td id="L5368" data-line-number="5368"></td>
        <td id="LC5368">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5369" data-line-number="5369"></td>
        <td id="LC5369">            }</td>
      </tr>
      <tr>
        <td id="L5370" data-line-number="5370"></td>
        <td id="LC5370">            varDsc-&gt;<span>lvStkOffs</span> = argOffs;</td>
      </tr>
      <tr>
        <td id="L5371" data-line-number="5371"></td>
        <td id="LC5371">            argOffs += argSize;</td>
      </tr>
      <tr>
        <td id="L5372" data-line-number="5372"></td>
        <td id="LC5372">        }</td>
      </tr>
      <tr>
        <td id="L5373" data-line-number="5373"></td>
        <td id="LC5373">#<span>else</span> <span><span>//</span> _TARGET_*</span></td>
      </tr>
      <tr>
        <td id="L5374" data-line-number="5374"></td>
        <td id="LC5374">#<span>error</span> Unsupported or unset target architecture</td>
      </tr>
      <tr>
        <td id="L5375" data-line-number="5375"></td>
        <td id="LC5375">#<span>endif</span> <span><span>//</span> _TARGET_*</span></td>
      </tr>
      <tr>
        <td id="L5376" data-line-number="5376"></td>
        <td id="LC5376">    }</td>
      </tr>
      <tr>
        <td id="L5377" data-line-number="5377"></td>
        <td id="LC5377">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L5378" data-line-number="5378"></td>
        <td id="LC5378">    {</td>
      </tr>
      <tr>
        <td id="L5379" data-line-number="5379"></td>
        <td id="LC5379">#<span>if</span> defined(TARGET_ARM)</td>
      </tr>
      <tr>
        <td id="L5380" data-line-number="5380"></td>
        <td id="LC5380">        <span><span>//</span> Dev11 Bug 42817: incorrect codegen for DrawFlatCheckBox causes A/V in WinForms</span></td>
      </tr>
      <tr>
        <td id="L5381" data-line-number="5381"></td>
        <td id="LC5381">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5382" data-line-number="5382"></td>
        <td id="LC5382">        <span><span>//</span> Here we have method with a signature (int a1, struct a2, struct a3, int a4, int a5).</span></td>
      </tr>
      <tr>
        <td id="L5383" data-line-number="5383"></td>
        <td id="LC5383">        <span><span>//</span> Struct parameter 'a2' is 16-bytes with no alignment requirements;</span></td>
      </tr>
      <tr>
        <td id="L5384" data-line-number="5384"></td>
        <td id="LC5384">        <span><span>//</span>  it uses r1,r2,r3 and [OutArg+0] when passed.</span></td>
      </tr>
      <tr>
        <td id="L5385" data-line-number="5385"></td>
        <td id="LC5385">        <span><span>//</span> Struct parameter 'a3' is 16-bytes that is required to be double aligned;</span></td>
      </tr>
      <tr>
        <td id="L5386" data-line-number="5386"></td>
        <td id="LC5386">        <span><span>//</span>  the caller skips [OutArg+4] and starts the argument at [OutArg+8].</span></td>
      </tr>
      <tr>
        <td id="L5387" data-line-number="5387"></td>
        <td id="LC5387">        <span><span>//</span> Thus the caller generates the correct code to pass the arguments.</span></td>
      </tr>
      <tr>
        <td id="L5388" data-line-number="5388"></td>
        <td id="LC5388">        <span><span>//</span> When generating code to receive the arguments we set codeGen-&gt;regSet.rsMaskPreSpillRegArg to [r1,r2,r3]</span></td>
      </tr>
      <tr>
        <td id="L5389" data-line-number="5389"></td>
        <td id="LC5389">        <span><span>//</span>  and spill these three registers as the first instruction in the prolog.</span></td>
      </tr>
      <tr>
        <td id="L5390" data-line-number="5390"></td>
        <td id="LC5390">        <span><span>//</span> Then when we layout the arguments' stack offsets we have an argOffs 0 which</span></td>
      </tr>
      <tr>
        <td id="L5391" data-line-number="5391"></td>
        <td id="LC5391">        <span><span>//</span>  points at the location that we spilled r1 into the stack.  For this first</span></td>
      </tr>
      <tr>
        <td id="L5392" data-line-number="5392"></td>
        <td id="LC5392">        <span><span>//</span>  struct we take the lvIsRegArg path above with "codeGen-&gt;regSet.rsMaskPreSpillRegArg &amp;" matching.</span></td>
      </tr>
      <tr>
        <td id="L5393" data-line-number="5393"></td>
        <td id="LC5393">        <span><span>//</span> Next when we calculate the argOffs for the second 16-byte struct we have an argOffs</span></td>
      </tr>
      <tr>
        <td id="L5394" data-line-number="5394"></td>
        <td id="LC5394">        <span><span>//</span>  of 16, which appears to be aligned properly so we don't skip a stack slot.</span></td>
      </tr>
      <tr>
        <td id="L5395" data-line-number="5395"></td>
        <td id="LC5395">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5396" data-line-number="5396"></td>
        <td id="LC5396">        <span><span>//</span> To fix this we must recover the actual OutArg offset by subtracting off the</span></td>
      </tr>
      <tr>
        <td id="L5397" data-line-number="5397"></td>
        <td id="LC5397">        <span><span>//</span>  sizeof of the PreSpill register args.</span></td>
      </tr>
      <tr>
        <td id="L5398" data-line-number="5398"></td>
        <td id="LC5398">        <span><span>//</span> Then we align this offset to a multiple of 8 and add back the sizeof</span></td>
      </tr>
      <tr>
        <td id="L5399" data-line-number="5399"></td>
        <td id="LC5399">        <span><span>//</span>  of the PreSpill register args.</span></td>
      </tr>
      <tr>
        <td id="L5400" data-line-number="5400"></td>
        <td id="LC5400">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5401" data-line-number="5401"></td>
        <td id="LC5401">        <span><span>//</span> Dev11 Bug 71767: failure of assert(sizeofPreSpillRegArgs &lt;= argOffs)</span></td>
      </tr>
      <tr>
        <td id="L5402" data-line-number="5402"></td>
        <td id="LC5402">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5403" data-line-number="5403"></td>
        <td id="LC5403">        <span><span>//</span> We have a method with 'this' passed in r0, RetBuf arg in r1, VarArgs cookie</span></td>
      </tr>
      <tr>
        <td id="L5404" data-line-number="5404"></td>
        <td id="LC5404">        <span><span>//</span> in r2. The first user arg is a 144 byte struct with double alignment required,</span></td>
      </tr>
      <tr>
        <td id="L5405" data-line-number="5405"></td>
        <td id="LC5405">        <span><span>//</span> r3 is skipped, and the struct is passed on the stack. However, 'r3' is added</span></td>
      </tr>
      <tr>
        <td id="L5406" data-line-number="5406"></td>
        <td id="LC5406">        <span><span>//</span> to the codeGen-&gt;regSet.rsMaskPreSpillRegArg mask by the VarArgs cookie code, since we need to</span></td>
      </tr>
      <tr>
        <td id="L5407" data-line-number="5407"></td>
        <td id="LC5407">        <span><span>//</span> home all the potential varargs arguments in registers, even if we don't have</span></td>
      </tr>
      <tr>
        <td id="L5408" data-line-number="5408"></td>
        <td id="LC5408">        <span><span>//</span> signature type information for the variadic arguments. However, due to alignment,</span></td>
      </tr>
      <tr>
        <td id="L5409" data-line-number="5409"></td>
        <td id="LC5409">        <span><span>//</span> we have skipped a register that doesn't have a corresponding symbol. Make up</span></td>
      </tr>
      <tr>
        <td id="L5410" data-line-number="5410"></td>
        <td id="LC5410">        <span><span>//</span> for that by increasing argOffs here.</span></td>
      </tr>
      <tr>
        <td id="L5411" data-line-number="5411"></td>
        <td id="LC5411">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5412" data-line-number="5412"></td>
        <td id="LC5412">
</td>
      </tr>
      <tr>
        <td id="L5413" data-line-number="5413"></td>
        <td id="LC5413">        <span>int</span> sizeofPreSpillRegArgs = <span>genCountBits</span>(codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegs</span>(<span>true</span>)) * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L5414" data-line-number="5414"></td>
        <td id="LC5414">
</td>
      </tr>
      <tr>
        <td id="L5415" data-line-number="5415"></td>
        <td id="LC5415">        <span>if</span> (argOffs &lt; sizeofPreSpillRegArgs)</td>
      </tr>
      <tr>
        <td id="L5416" data-line-number="5416"></td>
        <td id="LC5416">        {</td>
      </tr>
      <tr>
        <td id="L5417" data-line-number="5417"></td>
        <td id="LC5417">            <span><span>//</span> This can only happen if we skipped the last register spot because current stk arg</span></td>
      </tr>
      <tr>
        <td id="L5418" data-line-number="5418"></td>
        <td id="LC5418">            <span><span>//</span> is a struct requiring alignment or a pre-spill alignment was required because the</span></td>
      </tr>
      <tr>
        <td id="L5419" data-line-number="5419"></td>
        <td id="LC5419">            <span><span>//</span> first reg arg needed alignment.</span></td>
      </tr>
      <tr>
        <td id="L5420" data-line-number="5420"></td>
        <td id="LC5420">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5421" data-line-number="5421"></td>
        <td id="LC5421">            <span><span>//</span> Example 1: First Stk Argument requiring alignment in vararg case (same as above comment.)</span></td>
      </tr>
      <tr>
        <td id="L5422" data-line-number="5422"></td>
        <td id="LC5422">            <span><span>//</span>            Signature (int a0, int a1, int a2, struct {long} a3, ...)</span></td>
      </tr>
      <tr>
        <td id="L5423" data-line-number="5423"></td>
        <td id="LC5423">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5424" data-line-number="5424"></td>
        <td id="LC5424">            <span><span>//</span> stk arg    a3             --&gt; argOffs here will be 12 (r0-r2) but pre-spill will be 16.</span></td>
      </tr>
      <tr>
        <td id="L5425" data-line-number="5425"></td>
        <td id="LC5425">            <span><span>//</span> ---- Caller SP ----</span></td>
      </tr>
      <tr>
        <td id="L5426" data-line-number="5426"></td>
        <td id="LC5426">            <span><span>//</span> r3                        --&gt; Stack slot is skipped in this case.</span></td>
      </tr>
      <tr>
        <td id="L5427" data-line-number="5427"></td>
        <td id="LC5427">            <span><span>//</span> r2    int  a2</span></td>
      </tr>
      <tr>
        <td id="L5428" data-line-number="5428"></td>
        <td id="LC5428">            <span><span>//</span> r1    int  a1</span></td>
      </tr>
      <tr>
        <td id="L5429" data-line-number="5429"></td>
        <td id="LC5429">            <span><span>//</span> r0    int  a0</span></td>
      </tr>
      <tr>
        <td id="L5430" data-line-number="5430"></td>
        <td id="LC5430">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5431" data-line-number="5431"></td>
        <td id="LC5431">            <span><span>//</span> Example 2: First Reg Argument requiring alignment in no-vararg case.</span></td>
      </tr>
      <tr>
        <td id="L5432" data-line-number="5432"></td>
        <td id="LC5432">            <span><span>//</span>            Signature (struct {long} a0, struct {int} a1, int a2, int a3)</span></td>
      </tr>
      <tr>
        <td id="L5433" data-line-number="5433"></td>
        <td id="LC5433">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5434" data-line-number="5434"></td>
        <td id="LC5434">            <span><span>//</span> stk arg                  --&gt; argOffs here will be 12 {r0-r2} but pre-spill will be 16.</span></td>
      </tr>
      <tr>
        <td id="L5435" data-line-number="5435"></td>
        <td id="LC5435">            <span><span>//</span> ---- Caller SP ----</span></td>
      </tr>
      <tr>
        <td id="L5436" data-line-number="5436"></td>
        <td id="LC5436">            <span><span>//</span> r3    int             a2 --&gt; pushed (not pre-spilled) for alignment of a0 by lvaInitUserArgs.</span></td>
      </tr>
      <tr>
        <td id="L5437" data-line-number="5437"></td>
        <td id="LC5437">            <span><span>//</span> r2    struct { int }  a1</span></td>
      </tr>
      <tr>
        <td id="L5438" data-line-number="5438"></td>
        <td id="LC5438">            <span><span>//</span> r0-r1 struct { long } a0</span></td>
      </tr>
      <tr>
        <td id="L5439" data-line-number="5439"></td>
        <td id="LC5439">            CLANG_FORMAT_COMMENT_ANCHOR;</td>
      </tr>
      <tr>
        <td id="L5440" data-line-number="5440"></td>
        <td id="LC5440">
</td>
      </tr>
      <tr>
        <td id="L5441" data-line-number="5441"></td>
        <td id="LC5441">#<span>ifdef</span> PROFILING_SUPPORTED</td>
      </tr>
      <tr>
        <td id="L5442" data-line-number="5442"></td>
        <td id="LC5442">            <span><span>//</span> On Arm under profiler, r0-r3 are always prespilled on stack.</span></td>
      </tr>
      <tr>
        <td id="L5443" data-line-number="5443"></td>
        <td id="LC5443">            <span><span>//</span> It is possible to have methods that accept only HFAs as parameters e.g. Signature(struct hfa1, struct</span></td>
      </tr>
      <tr>
        <td id="L5444" data-line-number="5444"></td>
        <td id="LC5444">            <span><span>//</span> hfa2), in which case hfa1 and hfa2 will be en-registered in co-processor registers and will have an</span></td>
      </tr>
      <tr>
        <td id="L5445" data-line-number="5445"></td>
        <td id="LC5445">            <span><span>//</span> argument offset less than size of preSpill.</span></td>
      </tr>
      <tr>
        <td id="L5446" data-line-number="5446"></td>
        <td id="LC5446">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5447" data-line-number="5447"></td>
        <td id="LC5447">            <span><span>//</span> For this reason the following conditions are asserted when not under profiler.</span></td>
      </tr>
      <tr>
        <td id="L5448" data-line-number="5448"></td>
        <td id="LC5448">            <span>if</span> (!<span>compIsProfilerHookNeeded</span>())</td>
      </tr>
      <tr>
        <td id="L5449" data-line-number="5449"></td>
        <td id="LC5449">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5450" data-line-number="5450"></td>
        <td id="LC5450">            {</td>
      </tr>
      <tr>
        <td id="L5451" data-line-number="5451"></td>
        <td id="LC5451">                <span>bool</span> cond = ((info.<span>compIsVarArgs</span> || opts.<span>compUseSoftFP</span>) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L5452" data-line-number="5452"></td>
        <td id="LC5452">                             <span><span>//</span> Does cur stk arg require double alignment?</span></td>
      </tr>
      <tr>
        <td id="L5453" data-line-number="5453"></td>
        <td id="LC5453">                             ((varDsc-&gt;<span>lvType</span> == TYP_STRUCT &amp;&amp; varDsc-&gt;<span>lvStructDoubleAlign</span>) ||</td>
      </tr>
      <tr>
        <td id="L5454" data-line-number="5454"></td>
        <td id="LC5454">                              (varDsc-&gt;<span>lvType</span> == TYP_DOUBLE) || (varDsc-&gt;<span>lvType</span> == TYP_LONG))) ||</td>
      </tr>
      <tr>
        <td id="L5455" data-line-number="5455"></td>
        <td id="LC5455">                            <span><span>//</span> Did first reg arg require alignment?</span></td>
      </tr>
      <tr>
        <td id="L5456" data-line-number="5456"></td>
        <td id="LC5456">                            (codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillAlign</span> &amp; <span>genRegMask</span>(REG_ARG_LAST));</td>
      </tr>
      <tr>
        <td id="L5457" data-line-number="5457"></td>
        <td id="LC5457">
</td>
      </tr>
      <tr>
        <td id="L5458" data-line-number="5458"></td>
        <td id="LC5458">                <span>noway_assert</span>(cond);</td>
      </tr>
      <tr>
        <td id="L5459" data-line-number="5459"></td>
        <td id="LC5459">                <span>noway_assert</span>(sizeofPreSpillRegArgs &lt;=</td>
      </tr>
      <tr>
        <td id="L5460" data-line-number="5460"></td>
        <td id="LC5460">                             argOffs + TARGET_POINTER_SIZE); <span><span>//</span> at most one register of alignment</span></td>
      </tr>
      <tr>
        <td id="L5461" data-line-number="5461"></td>
        <td id="LC5461">            }</td>
      </tr>
      <tr>
        <td id="L5462" data-line-number="5462"></td>
        <td id="LC5462">            argOffs = sizeofPreSpillRegArgs;</td>
      </tr>
      <tr>
        <td id="L5463" data-line-number="5463"></td>
        <td id="LC5463">        }</td>
      </tr>
      <tr>
        <td id="L5464" data-line-number="5464"></td>
        <td id="LC5464">
</td>
      </tr>
      <tr>
        <td id="L5465" data-line-number="5465"></td>
        <td id="LC5465">        <span>noway_assert</span>(argOffs &gt;= sizeofPreSpillRegArgs);</td>
      </tr>
      <tr>
        <td id="L5466" data-line-number="5466"></td>
        <td id="LC5466">        <span>int</span> argOffsWithoutPreSpillRegArgs = argOffs - sizeofPreSpillRegArgs;</td>
      </tr>
      <tr>
        <td id="L5467" data-line-number="5467"></td>
        <td id="LC5467">
</td>
      </tr>
      <tr>
        <td id="L5468" data-line-number="5468"></td>
        <td id="LC5468">        <span>switch</span> (varDsc-&gt;<span>lvType</span>)</td>
      </tr>
      <tr>
        <td id="L5469" data-line-number="5469"></td>
        <td id="LC5469">        {</td>
      </tr>
      <tr>
        <td id="L5470" data-line-number="5470"></td>
        <td id="LC5470">            <span>case</span> TYP_STRUCT:</td>
      </tr>
      <tr>
        <td id="L5471" data-line-number="5471"></td>
        <td id="LC5471">                <span>if</span> (!varDsc-&gt;<span>lvStructDoubleAlign</span>)</td>
      </tr>
      <tr>
        <td id="L5472" data-line-number="5472"></td>
        <td id="LC5472">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5473" data-line-number="5473"></td>
        <td id="LC5473">
</td>
      </tr>
      <tr>
        <td id="L5474" data-line-number="5474"></td>
        <td id="LC5474">                __fallthrough;</td>
      </tr>
      <tr>
        <td id="L5475" data-line-number="5475"></td>
        <td id="LC5475">
</td>
      </tr>
      <tr>
        <td id="L5476" data-line-number="5476"></td>
        <td id="LC5476">            <span>case</span> TYP_DOUBLE:</td>
      </tr>
      <tr>
        <td id="L5477" data-line-number="5477"></td>
        <td id="LC5477">            <span>case</span> TYP_LONG:</td>
      </tr>
      <tr>
        <td id="L5478" data-line-number="5478"></td>
        <td id="LC5478">                <span><span>//</span> We must align up the argOffset to a multiple of 8</span></td>
      </tr>
      <tr>
        <td id="L5479" data-line-number="5479"></td>
        <td id="LC5479">                argOffs =</td>
      </tr>
      <tr>
        <td id="L5480" data-line-number="5480"></td>
        <td id="LC5480">                    <span>roundUp</span>((<span>unsigned</span>)argOffsWithoutPreSpillRegArgs, <span>2</span> * TARGET_POINTER_SIZE) + sizeofPreSpillRegArgs;</td>
      </tr>
      <tr>
        <td id="L5481" data-line-number="5481"></td>
        <td id="LC5481">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5482" data-line-number="5482"></td>
        <td id="LC5482">
</td>
      </tr>
      <tr>
        <td id="L5483" data-line-number="5483"></td>
        <td id="LC5483">            <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L5484" data-line-number="5484"></td>
        <td id="LC5484">                <span><span>//</span> No alignment of argOffs required</span></td>
      </tr>
      <tr>
        <td id="L5485" data-line-number="5485"></td>
        <td id="LC5485">                <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L5486" data-line-number="5486"></td>
        <td id="LC5486">        }</td>
      </tr>
      <tr>
        <td id="L5487" data-line-number="5487"></td>
        <td id="LC5487">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L5488" data-line-number="5488"></td>
        <td id="LC5488">
</td>
      </tr>
      <tr>
        <td id="L5489" data-line-number="5489"></td>
        <td id="LC5489">        varDsc-&gt;<span>lvStkOffs</span> = argOffs;</td>
      </tr>
      <tr>
        <td id="L5490" data-line-number="5490"></td>
        <td id="LC5490">    }</td>
      </tr>
      <tr>
        <td id="L5491" data-line-number="5491"></td>
        <td id="LC5491">
</td>
      </tr>
      <tr>
        <td id="L5492" data-line-number="5492"></td>
        <td id="LC5492">    <span><span>//</span> For struct promoted parameters we need to set the offsets for both LclVars.</span></td>
      </tr>
      <tr>
        <td id="L5493" data-line-number="5493"></td>
        <td id="LC5493">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5494" data-line-number="5494"></td>
        <td id="LC5494">    <span><span>//</span> For a dependent promoted struct we also assign the struct fields stack offset</span></td>
      </tr>
      <tr>
        <td id="L5495" data-line-number="5495"></td>
        <td id="LC5495">    CLANG_FORMAT_COMMENT_ANCHOR;</td>
      </tr>
      <tr>
        <td id="L5496" data-line-number="5496"></td>
        <td id="LC5496">
</td>
      </tr>
      <tr>
        <td id="L5497" data-line-number="5497"></td>
        <td id="LC5497">#<span>if</span> !defined(TARGET_64BIT)</td>
      </tr>
      <tr>
        <td id="L5498" data-line-number="5498"></td>
        <td id="LC5498">    <span>if</span> ((varDsc-&gt;<span>TypeGet</span>() == TYP_LONG) &amp;&amp; varDsc-&gt;<span>lvPromoted</span>)</td>
      </tr>
      <tr>
        <td id="L5499" data-line-number="5499"></td>
        <td id="LC5499">    {</td>
      </tr>
      <tr>
        <td id="L5500" data-line-number="5500"></td>
        <td id="LC5500">        <span>noway_assert</span>(varDsc-&gt;<span>lvFieldCnt</span> == <span>2</span>);</td>
      </tr>
      <tr>
        <td id="L5501" data-line-number="5501"></td>
        <td id="LC5501">        fieldVarNum                         = varDsc-&gt;<span>lvFieldLclStart</span>;</td>
      </tr>
      <tr>
        <td id="L5502" data-line-number="5502"></td>
        <td id="LC5502">        lvaTable[fieldVarNum].<span>lvStkOffs</span>     = varDsc-&gt;<span>lvStkOffs</span>;</td>
      </tr>
      <tr>
        <td id="L5503" data-line-number="5503"></td>
        <td id="LC5503">        lvaTable[fieldVarNum + <span>1</span>].<span>lvStkOffs</span> = varDsc-&gt;<span>lvStkOffs</span> + <span>genTypeSize</span>(TYP_INT);</td>
      </tr>
      <tr>
        <td id="L5504" data-line-number="5504"></td>
        <td id="LC5504">    }</td>
      </tr>
      <tr>
        <td id="L5505" data-line-number="5505"></td>
        <td id="LC5505">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L5506" data-line-number="5506"></td>
        <td id="LC5506">#<span>endif</span> <span><span>//</span> !defined(TARGET_64BIT)</span></td>
      </tr>
      <tr>
        <td id="L5507" data-line-number="5507"></td>
        <td id="LC5507">        <span>if</span> (varDsc-&gt;<span>lvPromotedStruct</span>())</td>
      </tr>
      <tr>
        <td id="L5508" data-line-number="5508"></td>
        <td id="LC5508">    {</td>
      </tr>
      <tr>
        <td id="L5509" data-line-number="5509"></td>
        <td id="LC5509">        lvaPromotionType promotionType = <span>lvaGetPromotionType</span>(varDsc);</td>
      </tr>
      <tr>
        <td id="L5510" data-line-number="5510"></td>
        <td id="LC5510">
</td>
      </tr>
      <tr>
        <td id="L5511" data-line-number="5511"></td>
        <td id="LC5511">        <span>if</span> (promotionType == PROMOTION_TYPE_DEPENDENT)</td>
      </tr>
      <tr>
        <td id="L5512" data-line-number="5512"></td>
        <td id="LC5512">        {</td>
      </tr>
      <tr>
        <td id="L5513" data-line-number="5513"></td>
        <td id="LC5513">            <span>noway_assert</span>(varDsc-&gt;<span>lvFieldCnt</span> == <span>1</span>); <span><span>//</span> We only handle one field here</span></td>
      </tr>
      <tr>
        <td id="L5514" data-line-number="5514"></td>
        <td id="LC5514">
</td>
      </tr>
      <tr>
        <td id="L5515" data-line-number="5515"></td>
        <td id="LC5515">            <span>assert</span>(fieldVarNum == varDsc-&gt;<span>lvFieldLclStart</span>);</td>
      </tr>
      <tr>
        <td id="L5516" data-line-number="5516"></td>
        <td id="LC5516">            lvaTable[fieldVarNum].<span>lvStkOffs</span> = varDsc-&gt;<span>lvStkOffs</span>;</td>
      </tr>
      <tr>
        <td id="L5517" data-line-number="5517"></td>
        <td id="LC5517">        }</td>
      </tr>
      <tr>
        <td id="L5518" data-line-number="5518"></td>
        <td id="LC5518">    }</td>
      </tr>
      <tr>
        <td id="L5519" data-line-number="5519"></td>
        <td id="LC5519">    <span><span>//</span> For an independent promoted struct field we also assign the parent struct stack offset</span></td>
      </tr>
      <tr>
        <td id="L5520" data-line-number="5520"></td>
        <td id="LC5520">    <span>else</span> <span>if</span> (varDsc-&gt;<span>lvIsStructField</span>)</td>
      </tr>
      <tr>
        <td id="L5521" data-line-number="5521"></td>
        <td id="LC5521">    {</td>
      </tr>
      <tr>
        <td id="L5522" data-line-number="5522"></td>
        <td id="LC5522">        <span>noway_assert</span>(varDsc-&gt;<span>lvParentLcl</span> &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L5523" data-line-number="5523"></td>
        <td id="LC5523">        lvaTable[varDsc-&gt;<span>lvParentLcl</span>].<span>lvStkOffs</span> = varDsc-&gt;<span>lvStkOffs</span>;</td>
      </tr>
      <tr>
        <td id="L5524" data-line-number="5524"></td>
        <td id="LC5524">    }</td>
      </tr>
      <tr>
        <td id="L5525" data-line-number="5525"></td>
        <td id="LC5525">
</td>
      </tr>
      <tr>
        <td id="L5526" data-line-number="5526"></td>
        <td id="LC5526">    <span>if</span> (Target::g_tgtArgOrder == Target::ARG_ORDER_R2L &amp;&amp; !varDsc-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L5527" data-line-number="5527"></td>
        <td id="LC5527">    {</td>
      </tr>
      <tr>
        <td id="L5528" data-line-number="5528"></td>
        <td id="LC5528">        argOffs += argSize;</td>
      </tr>
      <tr>
        <td id="L5529" data-line-number="5529"></td>
        <td id="LC5529">    }</td>
      </tr>
      <tr>
        <td id="L5530" data-line-number="5530"></td>
        <td id="LC5530">
</td>
      </tr>
      <tr>
        <td id="L5531" data-line-number="5531"></td>
        <td id="LC5531">    <span>return</span> argOffs;</td>
      </tr>
      <tr>
        <td id="L5532" data-line-number="5532"></td>
        <td id="LC5532">}</td>
      </tr>
      <tr>
        <td id="L5533" data-line-number="5533"></td>
        <td id="LC5533">#endif <span><span>//</span> !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L5534" data-line-number="5534"></td>
        <td id="LC5534">
</td>
      </tr>
      <tr>
        <td id="L5535" data-line-number="5535"></td>
        <td id="LC5535"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L5536" data-line-number="5536"></td>
        <td id="LC5536"><span> *  lvaAssignVirtualFrameOffsetsToLocals() : Assign virtual stack offsets to</span></td>
      </tr>
      <tr>
        <td id="L5537" data-line-number="5537"></td>
        <td id="LC5537"><span> *  locals, temps, and anything else.  These will all be negative offsets</span></td>
      </tr>
      <tr>
        <td id="L5538" data-line-number="5538"></td>
        <td id="LC5538"><span> *  (stack grows down) relative to the virtual '0'/return address</span></td>
      </tr>
      <tr>
        <td id="L5539" data-line-number="5539"></td>
        <td id="LC5539"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L5540" data-line-number="5540"></td>
        <td id="LC5540"><span>void</span> <span>Compiler::lvaAssignVirtualFrameOffsetsToLocals</span>()</td>
      </tr>
      <tr>
        <td id="L5541" data-line-number="5541"></td>
        <td id="LC5541">{</td>
      </tr>
      <tr>
        <td id="L5542" data-line-number="5542"></td>
        <td id="LC5542">    <span>int</span> stkOffs = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L5543" data-line-number="5543"></td>
        <td id="LC5543">    <span><span>//</span> codeGen-&gt;isFramePointerUsed is set in regalloc phase. Initialize it to a guess for pre-regalloc layout.</span></td>
      </tr>
      <tr>
        <td id="L5544" data-line-number="5544"></td>
        <td id="LC5544">    <span>if</span> (lvaDoneFrameLayout &lt;= PRE_REGALLOC_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L5545" data-line-number="5545"></td>
        <td id="LC5545">    {</td>
      </tr>
      <tr>
        <td id="L5546" data-line-number="5546"></td>
        <td id="LC5546">        codeGen-&gt;<span>setFramePointerUsed</span>(codeGen-&gt;<span>isFramePointerRequired</span>());</td>
      </tr>
      <tr>
        <td id="L5547" data-line-number="5547"></td>
        <td id="LC5547">    }</td>
      </tr>
      <tr>
        <td id="L5548" data-line-number="5548"></td>
        <td id="LC5548">
</td>
      </tr>
      <tr>
        <td id="L5549" data-line-number="5549"></td>
        <td id="LC5549">#<span>ifdef</span> TARGET_ARM64</td>
      </tr>
      <tr>
        <td id="L5550" data-line-number="5550"></td>
        <td id="LC5550">    <span><span>//</span> Decide where to save FP and LR registers. We store FP/LR registers at the bottom of the frame if there is</span></td>
      </tr>
      <tr>
        <td id="L5551" data-line-number="5551"></td>
        <td id="LC5551">    <span><span>//</span> a frame pointer used (so we get positive offsets from the frame pointer to access locals), but not if we</span></td>
      </tr>
      <tr>
        <td id="L5552" data-line-number="5552"></td>
        <td id="LC5552">    <span><span>//</span> need a GS cookie AND localloc is used, since we need the GS cookie to protect the saved return value,</span></td>
      </tr>
      <tr>
        <td id="L5553" data-line-number="5553"></td>
        <td id="LC5553">    <span><span>//</span> and also the saved frame pointer. See CodeGen::genPushCalleeSavedRegisters() for more details about the</span></td>
      </tr>
      <tr>
        <td id="L5554" data-line-number="5554"></td>
        <td id="LC5554">    <span><span>//</span> frame types. Since saving FP/LR at high addresses is a relatively rare case, force using it during stress.</span></td>
      </tr>
      <tr>
        <td id="L5555" data-line-number="5555"></td>
        <td id="LC5555">    <span><span>//</span> (It should be legal to use these frame types for every frame).</span></td>
      </tr>
      <tr>
        <td id="L5556" data-line-number="5556"></td>
        <td id="LC5556">
</td>
      </tr>
      <tr>
        <td id="L5557" data-line-number="5557"></td>
        <td id="LC5557">    <span>if</span> (opts.<span>compJitSaveFpLrWithCalleeSavedRegisters</span> == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L5558" data-line-number="5558"></td>
        <td id="LC5558">    {</td>
      </tr>
      <tr>
        <td id="L5559" data-line-number="5559"></td>
        <td id="LC5559">        <span><span>//</span> Default configuration</span></td>
      </tr>
      <tr>
        <td id="L5560" data-line-number="5560"></td>
        <td id="LC5560">        codeGen-&gt;<span>SetSaveFpLrWithAllCalleeSavedRegisters</span>((<span>getNeedsGSSecurityCookie</span>() &amp;&amp; compLocallocUsed) ||</td>
      </tr>
      <tr>
        <td id="L5561" data-line-number="5561"></td>
        <td id="LC5561">                                                        <span>compStressCompile</span>(STRESS_GENERIC_VARN, <span>20</span>));</td>
      </tr>
      <tr>
        <td id="L5562" data-line-number="5562"></td>
        <td id="LC5562">    }</td>
      </tr>
      <tr>
        <td id="L5563" data-line-number="5563"></td>
        <td id="LC5563">    <span>else</span> <span>if</span> (opts.<span>compJitSaveFpLrWithCalleeSavedRegisters</span> == <span>1</span>)</td>
      </tr>
      <tr>
        <td id="L5564" data-line-number="5564"></td>
        <td id="LC5564">    {</td>
      </tr>
      <tr>
        <td id="L5565" data-line-number="5565"></td>
        <td id="LC5565">        codeGen-&gt;<span>SetSaveFpLrWithAllCalleeSavedRegisters</span>(<span>false</span>); <span><span>//</span> Disable using new frames</span></td>
      </tr>
      <tr>
        <td id="L5566" data-line-number="5566"></td>
        <td id="LC5566">    }</td>
      </tr>
      <tr>
        <td id="L5567" data-line-number="5567"></td>
        <td id="LC5567">    <span>else</span> <span>if</span> (opts.<span>compJitSaveFpLrWithCalleeSavedRegisters</span> == <span>2</span>)</td>
      </tr>
      <tr>
        <td id="L5568" data-line-number="5568"></td>
        <td id="LC5568">    {</td>
      </tr>
      <tr>
        <td id="L5569" data-line-number="5569"></td>
        <td id="LC5569">        codeGen-&gt;<span>SetSaveFpLrWithAllCalleeSavedRegisters</span>(<span>true</span>); <span><span>//</span> Force using new frames</span></td>
      </tr>
      <tr>
        <td id="L5570" data-line-number="5570"></td>
        <td id="LC5570">    }</td>
      </tr>
      <tr>
        <td id="L5571" data-line-number="5571"></td>
        <td id="LC5571">#<span>endif</span> <span><span>//</span> TARGET_ARM64</span></td>
      </tr>
      <tr>
        <td id="L5572" data-line-number="5572"></td>
        <td id="LC5572">
</td>
      </tr>
      <tr>
        <td id="L5573" data-line-number="5573"></td>
        <td id="LC5573">#<span>ifdef</span> TARGET_XARCH</td>
      </tr>
      <tr>
        <td id="L5574" data-line-number="5574"></td>
        <td id="LC5574">    <span><span>//</span> On x86/amd64, the return address has already been pushed by the call instruction in the caller.</span></td>
      </tr>
      <tr>
        <td id="L5575" data-line-number="5575"></td>
        <td id="LC5575">    stkOffs -= TARGET_POINTER_SIZE; <span><span>//</span> return address;</span></td>
      </tr>
      <tr>
        <td id="L5576" data-line-number="5576"></td>
        <td id="LC5576">
</td>
      </tr>
      <tr>
        <td id="L5577" data-line-number="5577"></td>
        <td id="LC5577">    <span><span>//</span> TODO-AMD64-CQ: for X64 eventually this should be pushed with all the other</span></td>
      </tr>
      <tr>
        <td id="L5578" data-line-number="5578"></td>
        <td id="LC5578">    <span><span>//</span> calleeregs.  When you fix this, you'll also need to fix</span></td>
      </tr>
      <tr>
        <td id="L5579" data-line-number="5579"></td>
        <td id="LC5579">    <span><span>//</span> the assert at the bottom of this method</span></td>
      </tr>
      <tr>
        <td id="L5580" data-line-number="5580"></td>
        <td id="LC5580">    <span>if</span> (codeGen-&gt;<span>doubleAlignOrFramePointerUsed</span>())</td>
      </tr>
      <tr>
        <td id="L5581" data-line-number="5581"></td>
        <td id="LC5581">    {</td>
      </tr>
      <tr>
        <td id="L5582" data-line-number="5582"></td>
        <td id="LC5582">        stkOffs -= REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L5583" data-line-number="5583"></td>
        <td id="LC5583">    }</td>
      </tr>
      <tr>
        <td id="L5584" data-line-number="5584"></td>
        <td id="LC5584">#<span>endif</span> <span><span>//</span> TARGET_XARCH</span></td>
      </tr>
      <tr>
        <td id="L5585" data-line-number="5585"></td>
        <td id="LC5585">
</td>
      </tr>
      <tr>
        <td id="L5586" data-line-number="5586"></td>
        <td id="LC5586">    <span>int</span>  preSpillSize    = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L5587" data-line-number="5587"></td>
        <td id="LC5587">    <span>bool</span> mustDoubleAlign = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L5588" data-line-number="5588"></td>
        <td id="LC5588">
</td>
      </tr>
      <tr>
        <td id="L5589" data-line-number="5589"></td>
        <td id="LC5589">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L5590" data-line-number="5590"></td>
        <td id="LC5590">    mustDoubleAlign = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L5591" data-line-number="5591"></td>
        <td id="LC5591">    preSpillSize    = <span>genCountBits</span>(codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegs</span>(<span>true</span>)) * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L5592" data-line-number="5592"></td>
        <td id="LC5592">#<span>else</span> <span><span>//</span> !TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L5593" data-line-number="5593"></td>
        <td id="LC5593">#<span>if</span> DOUBLE_ALIGN</td>
      </tr>
      <tr>
        <td id="L5594" data-line-number="5594"></td>
        <td id="LC5594">    <span>if</span> (<span>genDoubleAlign</span>())</td>
      </tr>
      <tr>
        <td id="L5595" data-line-number="5595"></td>
        <td id="LC5595">    {</td>
      </tr>
      <tr>
        <td id="L5596" data-line-number="5596"></td>
        <td id="LC5596">        mustDoubleAlign = <span>true</span>; <span><span>//</span> X86 only</span></td>
      </tr>
      <tr>
        <td id="L5597" data-line-number="5597"></td>
        <td id="LC5597">    }</td>
      </tr>
      <tr>
        <td id="L5598" data-line-number="5598"></td>
        <td id="LC5598">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5599" data-line-number="5599"></td>
        <td id="LC5599">#<span>endif</span> <span><span>//</span> !TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L5600" data-line-number="5600"></td>
        <td id="LC5600">
</td>
      </tr>
      <tr>
        <td id="L5601" data-line-number="5601"></td>
        <td id="LC5601">#<span>ifdef</span> TARGET_ARM64</td>
      </tr>
      <tr>
        <td id="L5602" data-line-number="5602"></td>
        <td id="LC5602">    <span><span>//</span> If the frame pointer is used, then we'll save FP/LR at the bottom of the stack.</span></td>
      </tr>
      <tr>
        <td id="L5603" data-line-number="5603"></td>
        <td id="LC5603">    <span><span>//</span> Otherwise, we won't store FP, and we'll store LR at the top, with the other callee-save</span></td>
      </tr>
      <tr>
        <td id="L5604" data-line-number="5604"></td>
        <td id="LC5604">    <span><span>//</span> registers (if any).</span></td>
      </tr>
      <tr>
        <td id="L5605" data-line-number="5605"></td>
        <td id="LC5605">
</td>
      </tr>
      <tr>
        <td id="L5606" data-line-number="5606"></td>
        <td id="LC5606">    <span>int</span> initialStkOffs = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L5607" data-line-number="5607"></td>
        <td id="LC5607">    <span>if</span> (info.<span>compIsVarArgs</span>)</td>
      </tr>
      <tr>
        <td id="L5608" data-line-number="5608"></td>
        <td id="LC5608">    {</td>
      </tr>
      <tr>
        <td id="L5609" data-line-number="5609"></td>
        <td id="LC5609">        <span><span>//</span> For varargs we always save all of the integer register arguments</span></td>
      </tr>
      <tr>
        <td id="L5610" data-line-number="5610"></td>
        <td id="LC5610">        <span><span>//</span> so that they are contiguous with the incoming stack arguments.</span></td>
      </tr>
      <tr>
        <td id="L5611" data-line-number="5611"></td>
        <td id="LC5611">        initialStkOffs = MAX_REG_ARG * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L5612" data-line-number="5612"></td>
        <td id="LC5612">        stkOffs -= initialStkOffs;</td>
      </tr>
      <tr>
        <td id="L5613" data-line-number="5613"></td>
        <td id="LC5613">    }</td>
      </tr>
      <tr>
        <td id="L5614" data-line-number="5614"></td>
        <td id="LC5614">
</td>
      </tr>
      <tr>
        <td id="L5615" data-line-number="5615"></td>
        <td id="LC5615">    <span>if</span> (codeGen-&gt;<span>IsSaveFpLrWithAllCalleeSavedRegisters</span>() ||</td>
      </tr>
      <tr>
        <td id="L5616" data-line-number="5616"></td>
        <td id="LC5616">        !<span>isFramePointerUsed</span>()) <span><span>//</span> Note that currently we always have a frame pointer</span></td>
      </tr>
      <tr>
        <td id="L5617" data-line-number="5617"></td>
        <td id="LC5617">    {</td>
      </tr>
      <tr>
        <td id="L5618" data-line-number="5618"></td>
        <td id="LC5618">        stkOffs -= compCalleeRegsPushed * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L5619" data-line-number="5619"></td>
        <td id="LC5619">    }</td>
      </tr>
      <tr>
        <td id="L5620" data-line-number="5620"></td>
        <td id="LC5620">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L5621" data-line-number="5621"></td>
        <td id="LC5621">    {</td>
      </tr>
      <tr>
        <td id="L5622" data-line-number="5622"></td>
        <td id="LC5622">        <span><span>//</span> Subtract off FP and LR.</span></td>
      </tr>
      <tr>
        <td id="L5623" data-line-number="5623"></td>
        <td id="LC5623">        <span>assert</span>(compCalleeRegsPushed &gt;= <span>2</span>);</td>
      </tr>
      <tr>
        <td id="L5624" data-line-number="5624"></td>
        <td id="LC5624">        stkOffs -= (compCalleeRegsPushed - <span>2</span>) * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L5625" data-line-number="5625"></td>
        <td id="LC5625">    }</td>
      </tr>
      <tr>
        <td id="L5626" data-line-number="5626"></td>
        <td id="LC5626">
</td>
      </tr>
      <tr>
        <td id="L5627" data-line-number="5627"></td>
        <td id="LC5627">#<span>else</span>  <span><span>//</span> !TARGET_ARM64</span></td>
      </tr>
      <tr>
        <td id="L5628" data-line-number="5628"></td>
        <td id="LC5628">    stkOffs -= compCalleeRegsPushed * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L5629" data-line-number="5629"></td>
        <td id="LC5629">#<span>endif</span> <span><span>//</span> !TARGET_ARM64</span></td>
      </tr>
      <tr>
        <td id="L5630" data-line-number="5630"></td>
        <td id="LC5630">
</td>
      </tr>
      <tr>
        <td id="L5631" data-line-number="5631"></td>
        <td id="LC5631">    compLclFrameSize = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L5632" data-line-number="5632"></td>
        <td id="LC5632">
</td>
      </tr>
      <tr>
        <td id="L5633" data-line-number="5633"></td>
        <td id="LC5633">#<span>ifdef</span> TARGET_AMD64</td>
      </tr>
      <tr>
        <td id="L5634" data-line-number="5634"></td>
        <td id="LC5634">    <span><span>//</span> In case of Amd64 compCalleeRegsPushed includes float regs (Xmm6-xmm15) that</span></td>
      </tr>
      <tr>
        <td id="L5635" data-line-number="5635"></td>
        <td id="LC5635">    <span><span>//</span> need to be pushed.  But Amd64 doesn't support push/pop of xmm registers.</span></td>
      </tr>
      <tr>
        <td id="L5636" data-line-number="5636"></td>
        <td id="LC5636">    <span><span>//</span> Instead we need to allocate space for them on the stack and save them in prolog.</span></td>
      </tr>
      <tr>
        <td id="L5637" data-line-number="5637"></td>
        <td id="LC5637">    <span><span>//</span> Therefore, we consider xmm registers being saved while computing stack offsets</span></td>
      </tr>
      <tr>
        <td id="L5638" data-line-number="5638"></td>
        <td id="LC5638">    <span><span>//</span> but space for xmm registers is considered part of compLclFrameSize.</span></td>
      </tr>
      <tr>
        <td id="L5639" data-line-number="5639"></td>
        <td id="LC5639">    <span><span>//</span> Notes</span></td>
      </tr>
      <tr>
        <td id="L5640" data-line-number="5640"></td>
        <td id="LC5640">    <span><span>//</span>  1) We need to save the entire 128-bits of xmm register to stack, since amd64</span></td>
      </tr>
      <tr>
        <td id="L5641" data-line-number="5641"></td>
        <td id="LC5641">    <span><span>//</span>     prolog unwind codes allow encoding of an instruction that stores the entire xmm reg</span></td>
      </tr>
      <tr>
        <td id="L5642" data-line-number="5642"></td>
        <td id="LC5642">    <span><span>//</span>     at an offset relative to SP</span></td>
      </tr>
      <tr>
        <td id="L5643" data-line-number="5643"></td>
        <td id="LC5643">    <span><span>//</span>  2) We adjust frame size so that SP is aligned at 16-bytes after pushing integer registers.</span></td>
      </tr>
      <tr>
        <td id="L5644" data-line-number="5644"></td>
        <td id="LC5644">    <span><span>//</span>     This means while saving the first xmm register to its allocated stack location we might</span></td>
      </tr>
      <tr>
        <td id="L5645" data-line-number="5645"></td>
        <td id="LC5645">    <span><span>//</span>     have to skip 8-bytes.  The reason for padding is to use efficient "movaps" to save/restore</span></td>
      </tr>
      <tr>
        <td id="L5646" data-line-number="5646"></td>
        <td id="LC5646">    <span><span>//</span>     xmm registers to/from stack to match Jit64 codegen.  Without the aligning on 16-byte</span></td>
      </tr>
      <tr>
        <td id="L5647" data-line-number="5647"></td>
        <td id="LC5647">    <span><span>//</span>     boundary we would have to use movups when offset turns out unaligned.  Movaps is more</span></td>
      </tr>
      <tr>
        <td id="L5648" data-line-number="5648"></td>
        <td id="LC5648">    <span><span>//</span>     performant than movups.</span></td>
      </tr>
      <tr>
        <td id="L5649" data-line-number="5649"></td>
        <td id="LC5649">    <span>unsigned</span> calleeFPRegsSavedSize = <span>genCountBits</span>(compCalleeFPRegsSavedMask) * XMM_REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L5650" data-line-number="5650"></td>
        <td id="LC5650">    <span>if</span> (calleeFPRegsSavedSize &gt; <span>0</span> &amp;&amp; ((stkOffs % XMM_REGSIZE_BYTES) != <span>0</span>))</td>
      </tr>
      <tr>
        <td id="L5651" data-line-number="5651"></td>
        <td id="LC5651">    {</td>
      </tr>
      <tr>
        <td id="L5652" data-line-number="5652"></td>
        <td id="LC5652">        <span><span>//</span> Take care of alignment</span></td>
      </tr>
      <tr>
        <td id="L5653" data-line-number="5653"></td>
        <td id="LC5653">        <span>int</span> alignPad = (<span>int</span>)<span>AlignmentPad</span>((<span>unsigned</span>)-stkOffs, XMM_REGSIZE_BYTES);</td>
      </tr>
      <tr>
        <td id="L5654" data-line-number="5654"></td>
        <td id="LC5654">        stkOffs -= alignPad;</td>
      </tr>
      <tr>
        <td id="L5655" data-line-number="5655"></td>
        <td id="LC5655">        <span>lvaIncrementFrameSize</span>(alignPad);</td>
      </tr>
      <tr>
        <td id="L5656" data-line-number="5656"></td>
        <td id="LC5656">    }</td>
      </tr>
      <tr>
        <td id="L5657" data-line-number="5657"></td>
        <td id="LC5657">
</td>
      </tr>
      <tr>
        <td id="L5658" data-line-number="5658"></td>
        <td id="LC5658">    stkOffs -= calleeFPRegsSavedSize;</td>
      </tr>
      <tr>
        <td id="L5659" data-line-number="5659"></td>
        <td id="LC5659">    <span>lvaIncrementFrameSize</span>(calleeFPRegsSavedSize);</td>
      </tr>
      <tr>
        <td id="L5660" data-line-number="5660"></td>
        <td id="LC5660">
</td>
      </tr>
      <tr>
        <td id="L5661" data-line-number="5661"></td>
        <td id="LC5661">    <span><span>//</span> Quirk for VS debug-launch scenario to work</span></td>
      </tr>
      <tr>
        <td id="L5662" data-line-number="5662"></td>
        <td id="LC5662">    <span>if</span> (compVSQuirkStackPaddingNeeded &gt; <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L5663" data-line-number="5663"></td>
        <td id="LC5663">    {</td>
      </tr>
      <tr>
        <td id="L5664" data-line-number="5664"></td>
        <td id="LC5664">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L5665" data-line-number="5665"></td>
        <td id="LC5665">        <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L5666" data-line-number="5666"></td>
        <td id="LC5666">        {</td>
      </tr>
      <tr>
        <td id="L5667" data-line-number="5667"></td>
        <td id="LC5667">            <span>printf</span>(<span><span>"</span><span>\n</span>Adding VS quirk stack padding of %d bytes between save-reg area and locals<span>\n</span><span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L5668" data-line-number="5668"></td>
        <td id="LC5668">                   compVSQuirkStackPaddingNeeded);</td>
      </tr>
      <tr>
        <td id="L5669" data-line-number="5669"></td>
        <td id="LC5669">        }</td>
      </tr>
      <tr>
        <td id="L5670" data-line-number="5670"></td>
        <td id="LC5670">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L5671" data-line-number="5671"></td>
        <td id="LC5671">
</td>
      </tr>
      <tr>
        <td id="L5672" data-line-number="5672"></td>
        <td id="LC5672">        stkOffs -= compVSQuirkStackPaddingNeeded;</td>
      </tr>
      <tr>
        <td id="L5673" data-line-number="5673"></td>
        <td id="LC5673">        <span>lvaIncrementFrameSize</span>(compVSQuirkStackPaddingNeeded);</td>
      </tr>
      <tr>
        <td id="L5674" data-line-number="5674"></td>
        <td id="LC5674">    }</td>
      </tr>
      <tr>
        <td id="L5675" data-line-number="5675"></td>
        <td id="LC5675">#<span>endif</span> <span><span>//</span> TARGET_AMD64</span></td>
      </tr>
      <tr>
        <td id="L5676" data-line-number="5676"></td>
        <td id="LC5676">
</td>
      </tr>
      <tr>
        <td id="L5677" data-line-number="5677"></td>
        <td id="LC5677">#<span>if</span> defined(FEATURE_EH_FUNCLETS) &amp;&amp; defined(TARGET_ARMARCH)</td>
      </tr>
      <tr>
        <td id="L5678" data-line-number="5678"></td>
        <td id="LC5678">    <span>if</span> (lvaPSPSym != BAD_VAR_NUM)</td>
      </tr>
      <tr>
        <td id="L5679" data-line-number="5679"></td>
        <td id="LC5679">    {</td>
      </tr>
      <tr>
        <td id="L5680" data-line-number="5680"></td>
        <td id="LC5680">        <span><span>//</span> On ARM/ARM64, if we need a PSPSym, allocate it first, before anything else, including</span></td>
      </tr>
      <tr>
        <td id="L5681" data-line-number="5681"></td>
        <td id="LC5681">        <span><span>//</span> padding (so we can avoid computing the same padding in the funclet</span></td>
      </tr>
      <tr>
        <td id="L5682" data-line-number="5682"></td>
        <td id="LC5682">        <span><span>//</span> frame). Note that there is no special padding requirement for the PSPSym.</span></td>
      </tr>
      <tr>
        <td id="L5683" data-line-number="5683"></td>
        <td id="LC5683">        <span>noway_assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>()); <span><span>//</span> We need an explicit frame pointer</span></td>
      </tr>
      <tr>
        <td id="L5684" data-line-number="5684"></td>
        <td id="LC5684">        stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaPSPSym, TARGET_POINTER_SIZE, stkOffs);</td>
      </tr>
      <tr>
        <td id="L5685" data-line-number="5685"></td>
        <td id="LC5685">    }</td>
      </tr>
      <tr>
        <td id="L5686" data-line-number="5686"></td>
        <td id="LC5686">#<span>endif</span> <span><span>//</span> FEATURE_EH_FUNCLETS &amp;&amp; defined(TARGET_ARMARCH)</span></td>
      </tr>
      <tr>
        <td id="L5687" data-line-number="5687"></td>
        <td id="LC5687">
</td>
      </tr>
      <tr>
        <td id="L5688" data-line-number="5688"></td>
        <td id="LC5688">    <span>if</span> (mustDoubleAlign)</td>
      </tr>
      <tr>
        <td id="L5689" data-line-number="5689"></td>
        <td id="LC5689">    {</td>
      </tr>
      <tr>
        <td id="L5690" data-line-number="5690"></td>
        <td id="LC5690">        <span>if</span> (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L5691" data-line-number="5691"></td>
        <td id="LC5691">        {</td>
      </tr>
      <tr>
        <td id="L5692" data-line-number="5692"></td>
        <td id="LC5692">            <span><span>//</span> Allocate a pointer sized stack slot, since we may need to double align here</span></td>
      </tr>
      <tr>
        <td id="L5693" data-line-number="5693"></td>
        <td id="LC5693">            <span><span>//</span> when lvaDoneFrameLayout == FINAL_FRAME_LAYOUT</span></td>
      </tr>
      <tr>
        <td id="L5694" data-line-number="5694"></td>
        <td id="LC5694">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5695" data-line-number="5695"></td>
        <td id="LC5695">            <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L5696" data-line-number="5696"></td>
        <td id="LC5696">            stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5697" data-line-number="5697"></td>
        <td id="LC5697">
</td>
      </tr>
      <tr>
        <td id="L5698" data-line-number="5698"></td>
        <td id="LC5698">            <span><span>//</span> If we have any TYP_LONG, TYP_DOUBLE or double aligned structs</span></td>
      </tr>
      <tr>
        <td id="L5699" data-line-number="5699"></td>
        <td id="LC5699">            <span><span>//</span> then we need to allocate a second pointer sized stack slot,</span></td>
      </tr>
      <tr>
        <td id="L5700" data-line-number="5700"></td>
        <td id="LC5700">            <span><span>//</span> since we may need to double align that LclVar when we see it</span></td>
      </tr>
      <tr>
        <td id="L5701" data-line-number="5701"></td>
        <td id="LC5701">            <span><span>//</span> in the loop below.  We will just always do this so that the</span></td>
      </tr>
      <tr>
        <td id="L5702" data-line-number="5702"></td>
        <td id="LC5702">            <span><span>//</span> offsets that we calculate for the stack frame will always</span></td>
      </tr>
      <tr>
        <td id="L5703" data-line-number="5703"></td>
        <td id="LC5703">            <span><span>//</span> be greater (or equal) to what they can be in the final layout.</span></td>
      </tr>
      <tr>
        <td id="L5704" data-line-number="5704"></td>
        <td id="LC5704">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5705" data-line-number="5705"></td>
        <td id="LC5705">            <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L5706" data-line-number="5706"></td>
        <td id="LC5706">            stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5707" data-line-number="5707"></td>
        <td id="LC5707">        }</td>
      </tr>
      <tr>
        <td id="L5708" data-line-number="5708"></td>
        <td id="LC5708">        <span>else</span> <span><span>//</span> FINAL_FRAME_LAYOUT</span></td>
      </tr>
      <tr>
        <td id="L5709" data-line-number="5709"></td>
        <td id="LC5709">        {</td>
      </tr>
      <tr>
        <td id="L5710" data-line-number="5710"></td>
        <td id="LC5710">            <span>if</span> (((stkOffs + preSpillSize) % (<span>2</span> * TARGET_POINTER_SIZE)) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L5711" data-line-number="5711"></td>
        <td id="LC5711">            {</td>
      </tr>
      <tr>
        <td id="L5712" data-line-number="5712"></td>
        <td id="LC5712">                <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L5713" data-line-number="5713"></td>
        <td id="LC5713">                stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5714" data-line-number="5714"></td>
        <td id="LC5714">            }</td>
      </tr>
      <tr>
        <td id="L5715" data-line-number="5715"></td>
        <td id="LC5715">            <span><span>//</span> We should now have a double-aligned (stkOffs+preSpillSize)</span></td>
      </tr>
      <tr>
        <td id="L5716" data-line-number="5716"></td>
        <td id="LC5716">            <span>noway_assert</span>(((stkOffs + preSpillSize) % (<span>2</span> * TARGET_POINTER_SIZE)) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L5717" data-line-number="5717"></td>
        <td id="LC5717">        }</td>
      </tr>
      <tr>
        <td id="L5718" data-line-number="5718"></td>
        <td id="LC5718">    }</td>
      </tr>
      <tr>
        <td id="L5719" data-line-number="5719"></td>
        <td id="LC5719">
</td>
      </tr>
      <tr>
        <td id="L5720" data-line-number="5720"></td>
        <td id="LC5720">    <span>if</span> (lvaMonAcquired != BAD_VAR_NUM)</td>
      </tr>
      <tr>
        <td id="L5721" data-line-number="5721"></td>
        <td id="LC5721">    {</td>
      </tr>
      <tr>
        <td id="L5722" data-line-number="5722"></td>
        <td id="LC5722">        <span><span>//</span> This var must go first, in what is called the 'frame header' for EnC so that it is</span></td>
      </tr>
      <tr>
        <td id="L5723" data-line-number="5723"></td>
        <td id="LC5723">        <span><span>//</span> preserved when remapping occurs.  See vm\eetwain.cpp for detailed comment specifying frame</span></td>
      </tr>
      <tr>
        <td id="L5724" data-line-number="5724"></td>
        <td id="LC5724">        <span><span>//</span> layout requirements for EnC to work.</span></td>
      </tr>
      <tr>
        <td id="L5725" data-line-number="5725"></td>
        <td id="LC5725">        stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaMonAcquired, <span>lvaLclSize</span>(lvaMonAcquired), stkOffs);</td>
      </tr>
      <tr>
        <td id="L5726" data-line-number="5726"></td>
        <td id="LC5726">    }</td>
      </tr>
      <tr>
        <td id="L5727" data-line-number="5727"></td>
        <td id="LC5727">
</td>
      </tr>
      <tr>
        <td id="L5728" data-line-number="5728"></td>
        <td id="LC5728">    <span>if</span> (opts.<span>compNeedSecurityCheck</span>)</td>
      </tr>
      <tr>
        <td id="L5729" data-line-number="5729"></td>
        <td id="LC5729">    {</td>
      </tr>
      <tr>
        <td id="L5730" data-line-number="5730"></td>
        <td id="LC5730">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L5731" data-line-number="5731"></td>
        <td id="LC5731">        <span><span>/*</span> This can't work without an explicit frame, so make sure <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L5732" data-line-number="5732"></td>
        <td id="LC5732">        <span>noway_assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>());</td>
      </tr>
      <tr>
        <td id="L5733" data-line-number="5733"></td>
        <td id="LC5733">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5734" data-line-number="5734"></td>
        <td id="LC5734">        stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaSecurityObject, TARGET_POINTER_SIZE, stkOffs);</td>
      </tr>
      <tr>
        <td id="L5735" data-line-number="5735"></td>
        <td id="LC5735">    }</td>
      </tr>
      <tr>
        <td id="L5736" data-line-number="5736"></td>
        <td id="LC5736">
</td>
      </tr>
      <tr>
        <td id="L5737" data-line-number="5737"></td>
        <td id="LC5737">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L5738" data-line-number="5738"></td>
        <td id="LC5738">    <span>if</span> (lvaLocAllocSPvar != BAD_VAR_NUM)</td>
      </tr>
      <tr>
        <td id="L5739" data-line-number="5739"></td>
        <td id="LC5739">    {</td>
      </tr>
      <tr>
        <td id="L5740" data-line-number="5740"></td>
        <td id="LC5740">        <span>noway_assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>()); <span><span>//</span> else offsets of locals of frameless methods will be incorrect</span></td>
      </tr>
      <tr>
        <td id="L5741" data-line-number="5741"></td>
        <td id="LC5741">        stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaLocAllocSPvar, TARGET_POINTER_SIZE, stkOffs);</td>
      </tr>
      <tr>
        <td id="L5742" data-line-number="5742"></td>
        <td id="LC5742">    }</td>
      </tr>
      <tr>
        <td id="L5743" data-line-number="5743"></td>
        <td id="LC5743">#<span>endif</span> <span><span>//</span> JIT32_GCENCODER</span></td>
      </tr>
      <tr>
        <td id="L5744" data-line-number="5744"></td>
        <td id="LC5744">
</td>
      </tr>
      <tr>
        <td id="L5745" data-line-number="5745"></td>
        <td id="LC5745">    <span>if</span> (<span>lvaReportParamTypeArg</span>())</td>
      </tr>
      <tr>
        <td id="L5746" data-line-number="5746"></td>
        <td id="LC5746">    {</td>
      </tr>
      <tr>
        <td id="L5747" data-line-number="5747"></td>
        <td id="LC5747">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L5748" data-line-number="5748"></td>
        <td id="LC5748">        <span>noway_assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>());</td>
      </tr>
      <tr>
        <td id="L5749" data-line-number="5749"></td>
        <td id="LC5749">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5750" data-line-number="5750"></td>
        <td id="LC5750">        <span><span>//</span> For CORINFO_CALLCONV_PARAMTYPE (if needed)</span></td>
      </tr>
      <tr>
        <td id="L5751" data-line-number="5751"></td>
        <td id="LC5751">        <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L5752" data-line-number="5752"></td>
        <td id="LC5752">        stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5753" data-line-number="5753"></td>
        <td id="LC5753">        lvaCachedGenericContextArgOffs = stkOffs;</td>
      </tr>
      <tr>
        <td id="L5754" data-line-number="5754"></td>
        <td id="LC5754">    }</td>
      </tr>
      <tr>
        <td id="L5755" data-line-number="5755"></td>
        <td id="LC5755">#<span>ifndef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L5756" data-line-number="5756"></td>
        <td id="LC5756">    <span>else</span> <span>if</span> (<span>lvaKeepAliveAndReportThis</span>())</td>
      </tr>
      <tr>
        <td id="L5757" data-line-number="5757"></td>
        <td id="LC5757">    {</td>
      </tr>
      <tr>
        <td id="L5758" data-line-number="5758"></td>
        <td id="LC5758">        <span><span>//</span> When "this" is also used as generic context arg.</span></td>
      </tr>
      <tr>
        <td id="L5759" data-line-number="5759"></td>
        <td id="LC5759">        <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L5760" data-line-number="5760"></td>
        <td id="LC5760">        stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5761" data-line-number="5761"></td>
        <td id="LC5761">        lvaCachedGenericContextArgOffs = stkOffs;</td>
      </tr>
      <tr>
        <td id="L5762" data-line-number="5762"></td>
        <td id="LC5762">    }</td>
      </tr>
      <tr>
        <td id="L5763" data-line-number="5763"></td>
        <td id="LC5763">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5764" data-line-number="5764"></td>
        <td id="LC5764">
</td>
      </tr>
      <tr>
        <td id="L5765" data-line-number="5765"></td>
        <td id="LC5765">#<span>if</span> !defined(FEATURE_EH_FUNCLETS)</td>
      </tr>
      <tr>
        <td id="L5766" data-line-number="5766"></td>
        <td id="LC5766">    <span><span>/*</span> If we need space for slots for shadow SP, reserve it now <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L5767" data-line-number="5767"></td>
        <td id="LC5767">    <span>if</span> (<span>ehNeedsShadowSPslots</span>())</td>
      </tr>
      <tr>
        <td id="L5768" data-line-number="5768"></td>
        <td id="LC5768">    {</td>
      </tr>
      <tr>
        <td id="L5769" data-line-number="5769"></td>
        <td id="LC5769">        <span>noway_assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>()); <span><span>//</span> else offsets of locals of frameless methods will be incorrect</span></td>
      </tr>
      <tr>
        <td id="L5770" data-line-number="5770"></td>
        <td id="LC5770">        <span>if</span> (!<span>lvaReportParamTypeArg</span>())</td>
      </tr>
      <tr>
        <td id="L5771" data-line-number="5771"></td>
        <td id="LC5771">        {</td>
      </tr>
      <tr>
        <td id="L5772" data-line-number="5772"></td>
        <td id="LC5772">#<span>ifndef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L5773" data-line-number="5773"></td>
        <td id="LC5773">            <span>if</span> (!<span>lvaKeepAliveAndReportThis</span>())</td>
      </tr>
      <tr>
        <td id="L5774" data-line-number="5774"></td>
        <td id="LC5774">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5775" data-line-number="5775"></td>
        <td id="LC5775">            {</td>
      </tr>
      <tr>
        <td id="L5776" data-line-number="5776"></td>
        <td id="LC5776">                <span><span>//</span> In order to keep the gc info encoding smaller, the VM assumes that all methods with EH</span></td>
      </tr>
      <tr>
        <td id="L5777" data-line-number="5777"></td>
        <td id="LC5777">                <span><span>//</span> have also saved space for a ParamTypeArg, so we need to do that here</span></td>
      </tr>
      <tr>
        <td id="L5778" data-line-number="5778"></td>
        <td id="LC5778">                <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L5779" data-line-number="5779"></td>
        <td id="LC5779">                stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L5780" data-line-number="5780"></td>
        <td id="LC5780">            }</td>
      </tr>
      <tr>
        <td id="L5781" data-line-number="5781"></td>
        <td id="LC5781">        }</td>
      </tr>
      <tr>
        <td id="L5782" data-line-number="5782"></td>
        <td id="LC5782">        stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaShadowSPslotsVar, <span>lvaLclSize</span>(lvaShadowSPslotsVar), stkOffs);</td>
      </tr>
      <tr>
        <td id="L5783" data-line-number="5783"></td>
        <td id="LC5783">    }</td>
      </tr>
      <tr>
        <td id="L5784" data-line-number="5784"></td>
        <td id="LC5784">#<span>endif</span> <span><span>//</span> !FEATURE_EH_FUNCLETS</span></td>
      </tr>
      <tr>
        <td id="L5785" data-line-number="5785"></td>
        <td id="LC5785">
</td>
      </tr>
      <tr>
        <td id="L5786" data-line-number="5786"></td>
        <td id="LC5786">    <span>if</span> (compGSReorderStackLayout)</td>
      </tr>
      <tr>
        <td id="L5787" data-line-number="5787"></td>
        <td id="LC5787">    {</td>
      </tr>
      <tr>
        <td id="L5788" data-line-number="5788"></td>
        <td id="LC5788">        <span>assert</span>(<span>getNeedsGSSecurityCookie</span>());</td>
      </tr>
      <tr>
        <td id="L5789" data-line-number="5789"></td>
        <td id="LC5789">        stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaGSSecurityCookie, <span>lvaLclSize</span>(lvaGSSecurityCookie), stkOffs);</td>
      </tr>
      <tr>
        <td id="L5790" data-line-number="5790"></td>
        <td id="LC5790">    }</td>
      </tr>
      <tr>
        <td id="L5791" data-line-number="5791"></td>
        <td id="LC5791">
</td>
      </tr>
      <tr>
        <td id="L5792" data-line-number="5792"></td>
        <td id="LC5792">    <span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L5793" data-line-number="5793"></td>
        <td id="LC5793"><span>        If we're supposed to track lifetimes of pointer temps, we'll</span></td>
      </tr>
      <tr>
        <td id="L5794" data-line-number="5794"></td>
        <td id="LC5794"><span>        assign frame offsets in the following order:</span></td>
      </tr>
      <tr>
        <td id="L5795" data-line-number="5795"></td>
        <td id="LC5795"><span></span></td>
      </tr>
      <tr>
        <td id="L5796" data-line-number="5796"></td>
        <td id="LC5796"><span>            non-pointer local variables (also untracked pointer variables)</span></td>
      </tr>
      <tr>
        <td id="L5797" data-line-number="5797"></td>
        <td id="LC5797"><span>                pointer local variables</span></td>
      </tr>
      <tr>
        <td id="L5798" data-line-number="5798"></td>
        <td id="LC5798"><span>                pointer temps</span></td>
      </tr>
      <tr>
        <td id="L5799" data-line-number="5799"></td>
        <td id="LC5799"><span>            non-pointer temps</span></td>
      </tr>
      <tr>
        <td id="L5800" data-line-number="5800"></td>
        <td id="LC5800"><span>     <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L5801" data-line-number="5801"></td>
        <td id="LC5801">
</td>
      </tr>
      <tr>
        <td id="L5802" data-line-number="5802"></td>
        <td id="LC5802">    <span>enum</span> Allocation</td>
      </tr>
      <tr>
        <td id="L5803" data-line-number="5803"></td>
        <td id="LC5803">    {</td>
      </tr>
      <tr>
        <td id="L5804" data-line-number="5804"></td>
        <td id="LC5804">        ALLOC_NON_PTRS                 = <span>0x1</span>, <span><span>//</span> assign offsets to non-ptr</span></td>
      </tr>
      <tr>
        <td id="L5805" data-line-number="5805"></td>
        <td id="LC5805">        ALLOC_PTRS                     = <span>0x2</span>, <span><span>//</span> Second pass, assign offsets to tracked ptrs</span></td>
      </tr>
      <tr>
        <td id="L5806" data-line-number="5806"></td>
        <td id="LC5806">        ALLOC_UNSAFE_BUFFERS           = <span>0x4</span>,</td>
      </tr>
      <tr>
        <td id="L5807" data-line-number="5807"></td>
        <td id="LC5807">        ALLOC_UNSAFE_BUFFERS_WITH_PTRS = <span>0x8</span></td>
      </tr>
      <tr>
        <td id="L5808" data-line-number="5808"></td>
        <td id="LC5808">    };</td>
      </tr>
      <tr>
        <td id="L5809" data-line-number="5809"></td>
        <td id="LC5809">    UINT alloc_order[<span>5</span>];</td>
      </tr>
      <tr>
        <td id="L5810" data-line-number="5810"></td>
        <td id="LC5810">
</td>
      </tr>
      <tr>
        <td id="L5811" data-line-number="5811"></td>
        <td id="LC5811">    <span>unsigned</span> <span>int</span> cur = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L5812" data-line-number="5812"></td>
        <td id="LC5812">
</td>
      </tr>
      <tr>
        <td id="L5813" data-line-number="5813"></td>
        <td id="LC5813">    <span>if</span> (compGSReorderStackLayout)</td>
      </tr>
      <tr>
        <td id="L5814" data-line-number="5814"></td>
        <td id="LC5814">    {</td>
      </tr>
      <tr>
        <td id="L5815" data-line-number="5815"></td>
        <td id="LC5815">        <span>noway_assert</span>(<span>getNeedsGSSecurityCookie</span>());</td>
      </tr>
      <tr>
        <td id="L5816" data-line-number="5816"></td>
        <td id="LC5816">
</td>
      </tr>
      <tr>
        <td id="L5817" data-line-number="5817"></td>
        <td id="LC5817">        <span>if</span> (codeGen-&gt;<span>isFramePointerUsed</span>())</td>
      </tr>
      <tr>
        <td id="L5818" data-line-number="5818"></td>
        <td id="LC5818">        {</td>
      </tr>
      <tr>
        <td id="L5819" data-line-number="5819"></td>
        <td id="LC5819">            alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS;</td>
      </tr>
      <tr>
        <td id="L5820" data-line-number="5820"></td>
        <td id="LC5820">            alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS_WITH_PTRS;</td>
      </tr>
      <tr>
        <td id="L5821" data-line-number="5821"></td>
        <td id="LC5821">        }</td>
      </tr>
      <tr>
        <td id="L5822" data-line-number="5822"></td>
        <td id="LC5822">    }</td>
      </tr>
      <tr>
        <td id="L5823" data-line-number="5823"></td>
        <td id="LC5823">
</td>
      </tr>
      <tr>
        <td id="L5824" data-line-number="5824"></td>
        <td id="LC5824">    <span>bool</span> tempsAllocated = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L5825" data-line-number="5825"></td>
        <td id="LC5825">
</td>
      </tr>
      <tr>
        <td id="L5826" data-line-number="5826"></td>
        <td id="LC5826">    <span>if</span> (<span>lvaTempsHaveLargerOffsetThanVars</span>() &amp;&amp; !codeGen-&gt;<span>isFramePointerUsed</span>())</td>
      </tr>
      <tr>
        <td id="L5827" data-line-number="5827"></td>
        <td id="LC5827">    {</td>
      </tr>
      <tr>
        <td id="L5828" data-line-number="5828"></td>
        <td id="LC5828">        <span><span>//</span> Because we want the temps to have a larger offset than locals</span></td>
      </tr>
      <tr>
        <td id="L5829" data-line-number="5829"></td>
        <td id="LC5829">        <span><span>//</span> and we're not using a frame pointer, we have to place the temps</span></td>
      </tr>
      <tr>
        <td id="L5830" data-line-number="5830"></td>
        <td id="LC5830">        <span><span>//</span> above the vars.  Otherwise we place them after the vars (at the</span></td>
      </tr>
      <tr>
        <td id="L5831" data-line-number="5831"></td>
        <td id="LC5831">        <span><span>//</span> bottom of the frame).</span></td>
      </tr>
      <tr>
        <td id="L5832" data-line-number="5832"></td>
        <td id="LC5832">        <span>noway_assert</span>(!tempsAllocated);</td>
      </tr>
      <tr>
        <td id="L5833" data-line-number="5833"></td>
        <td id="LC5833">        stkOffs        = <span>lvaAllocateTemps</span>(stkOffs, mustDoubleAlign);</td>
      </tr>
      <tr>
        <td id="L5834" data-line-number="5834"></td>
        <td id="LC5834">        tempsAllocated = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L5835" data-line-number="5835"></td>
        <td id="LC5835">    }</td>
      </tr>
      <tr>
        <td id="L5836" data-line-number="5836"></td>
        <td id="LC5836">
</td>
      </tr>
      <tr>
        <td id="L5837" data-line-number="5837"></td>
        <td id="LC5837">    alloc_order[cur++] = ALLOC_NON_PTRS;</td>
      </tr>
      <tr>
        <td id="L5838" data-line-number="5838"></td>
        <td id="LC5838">
</td>
      </tr>
      <tr>
        <td id="L5839" data-line-number="5839"></td>
        <td id="LC5839">    <span>if</span> (opts.<span>compDbgEnC</span>)</td>
      </tr>
      <tr>
        <td id="L5840" data-line-number="5840"></td>
        <td id="LC5840">    {</td>
      </tr>
      <tr>
        <td id="L5841" data-line-number="5841"></td>
        <td id="LC5841">        <span><span>/*</span> We will use just one pass, and assign offsets to all variables <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L5842" data-line-number="5842"></td>
        <td id="LC5842">        alloc_order[cur - <span>1</span>] |= ALLOC_PTRS;</td>
      </tr>
      <tr>
        <td id="L5843" data-line-number="5843"></td>
        <td id="LC5843">        <span>noway_assert</span>(compGSReorderStackLayout == <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L5844" data-line-number="5844"></td>
        <td id="LC5844">    }</td>
      </tr>
      <tr>
        <td id="L5845" data-line-number="5845"></td>
        <td id="LC5845">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L5846" data-line-number="5846"></td>
        <td id="LC5846">    {</td>
      </tr>
      <tr>
        <td id="L5847" data-line-number="5847"></td>
        <td id="LC5847">        alloc_order[cur++] = ALLOC_PTRS;</td>
      </tr>
      <tr>
        <td id="L5848" data-line-number="5848"></td>
        <td id="LC5848">    }</td>
      </tr>
      <tr>
        <td id="L5849" data-line-number="5849"></td>
        <td id="LC5849">
</td>
      </tr>
      <tr>
        <td id="L5850" data-line-number="5850"></td>
        <td id="LC5850">    <span>if</span> (!codeGen-&gt;<span>isFramePointerUsed</span>() &amp;&amp; compGSReorderStackLayout)</td>
      </tr>
      <tr>
        <td id="L5851" data-line-number="5851"></td>
        <td id="LC5851">    {</td>
      </tr>
      <tr>
        <td id="L5852" data-line-number="5852"></td>
        <td id="LC5852">        alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS_WITH_PTRS;</td>
      </tr>
      <tr>
        <td id="L5853" data-line-number="5853"></td>
        <td id="LC5853">        alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS;</td>
      </tr>
      <tr>
        <td id="L5854" data-line-number="5854"></td>
        <td id="LC5854">    }</td>
      </tr>
      <tr>
        <td id="L5855" data-line-number="5855"></td>
        <td id="LC5855">
</td>
      </tr>
      <tr>
        <td id="L5856" data-line-number="5856"></td>
        <td id="LC5856">    alloc_order[cur] = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L5857" data-line-number="5857"></td>
        <td id="LC5857">
</td>
      </tr>
      <tr>
        <td id="L5858" data-line-number="5858"></td>
        <td id="LC5858">    <span>noway_assert</span>(cur &lt; <span>_countof</span>(alloc_order));</td>
      </tr>
      <tr>
        <td id="L5859" data-line-number="5859"></td>
        <td id="LC5859">
</td>
      </tr>
      <tr>
        <td id="L5860" data-line-number="5860"></td>
        <td id="LC5860">    <span><span>//</span> Force first pass to happen</span></td>
      </tr>
      <tr>
        <td id="L5861" data-line-number="5861"></td>
        <td id="LC5861">    UINT assignMore             = <span>0xFFFFFFFF</span>;</td>
      </tr>
      <tr>
        <td id="L5862" data-line-number="5862"></td>
        <td id="LC5862">    <span>bool</span> have_LclVarDoubleAlign = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L5863" data-line-number="5863"></td>
        <td id="LC5863">
</td>
      </tr>
      <tr>
        <td id="L5864" data-line-number="5864"></td>
        <td id="LC5864">    <span>for</span> (cur = <span>0</span>; alloc_order[cur]; cur++)</td>
      </tr>
      <tr>
        <td id="L5865" data-line-number="5865"></td>
        <td id="LC5865">    {</td>
      </tr>
      <tr>
        <td id="L5866" data-line-number="5866"></td>
        <td id="LC5866">        <span>if</span> ((assignMore &amp; alloc_order[cur]) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L5867" data-line-number="5867"></td>
        <td id="LC5867">        {</td>
      </tr>
      <tr>
        <td id="L5868" data-line-number="5868"></td>
        <td id="LC5868">            <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5869" data-line-number="5869"></td>
        <td id="LC5869">        }</td>
      </tr>
      <tr>
        <td id="L5870" data-line-number="5870"></td>
        <td id="LC5870">
</td>
      </tr>
      <tr>
        <td id="L5871" data-line-number="5871"></td>
        <td id="LC5871">        assignMore = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L5872" data-line-number="5872"></td>
        <td id="LC5872">
</td>
      </tr>
      <tr>
        <td id="L5873" data-line-number="5873"></td>
        <td id="LC5873">        <span>unsigned</span>   lclNum;</td>
      </tr>
      <tr>
        <td id="L5874" data-line-number="5874"></td>
        <td id="LC5874">        LclVarDsc* varDsc;</td>
      </tr>
      <tr>
        <td id="L5875" data-line-number="5875"></td>
        <td id="LC5875">
</td>
      </tr>
      <tr>
        <td id="L5876" data-line-number="5876"></td>
        <td id="LC5876">        <span>for</span> (lclNum = <span>0</span>, varDsc = lvaTable; lclNum &lt; lvaCount; lclNum++, varDsc++)</td>
      </tr>
      <tr>
        <td id="L5877" data-line-number="5877"></td>
        <td id="LC5877">        {</td>
      </tr>
      <tr>
        <td id="L5878" data-line-number="5878"></td>
        <td id="LC5878">            <span><span>/*</span> Ignore field locals of the promotion type PROMOTION_TYPE_FIELD_DEPENDENT.</span></td>
      </tr>
      <tr>
        <td id="L5879" data-line-number="5879"></td>
        <td id="LC5879"><span>               In other words, we will not calculate the "base" address of the struct local if</span></td>
      </tr>
      <tr>
        <td id="L5880" data-line-number="5880"></td>
        <td id="LC5880"><span>               the promotion type is PROMOTION_TYPE_FIELD_DEPENDENT.</span></td>
      </tr>
      <tr>
        <td id="L5881" data-line-number="5881"></td>
        <td id="LC5881"><span>            <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L5882" data-line-number="5882"></td>
        <td id="LC5882">            <span>if</span> (<span>lvaIsFieldOfDependentlyPromotedStruct</span>(varDsc))</td>
      </tr>
      <tr>
        <td id="L5883" data-line-number="5883"></td>
        <td id="LC5883">            {</td>
      </tr>
      <tr>
        <td id="L5884" data-line-number="5884"></td>
        <td id="LC5884">                <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5885" data-line-number="5885"></td>
        <td id="LC5885">            }</td>
      </tr>
      <tr>
        <td id="L5886" data-line-number="5886"></td>
        <td id="LC5886">
</td>
      </tr>
      <tr>
        <td id="L5887" data-line-number="5887"></td>
        <td id="LC5887">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L5888" data-line-number="5888"></td>
        <td id="LC5888">            <span><span>//</span> The scratch mem is used for the outgoing arguments, and it must be absolutely last</span></td>
      </tr>
      <tr>
        <td id="L5889" data-line-number="5889"></td>
        <td id="LC5889">            <span>if</span> (lclNum == lvaOutgoingArgSpaceVar)</td>
      </tr>
      <tr>
        <td id="L5890" data-line-number="5890"></td>
        <td id="LC5890">            {</td>
      </tr>
      <tr>
        <td id="L5891" data-line-number="5891"></td>
        <td id="LC5891">                <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5892" data-line-number="5892"></td>
        <td id="LC5892">            }</td>
      </tr>
      <tr>
        <td id="L5893" data-line-number="5893"></td>
        <td id="LC5893">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5894" data-line-number="5894"></td>
        <td id="LC5894">
</td>
      </tr>
      <tr>
        <td id="L5895" data-line-number="5895"></td>
        <td id="LC5895">            <span>bool</span> allocateOnFrame = varDsc-&gt;<span>lvOnFrame</span>;</td>
      </tr>
      <tr>
        <td id="L5896" data-line-number="5896"></td>
        <td id="LC5896">
</td>
      </tr>
      <tr>
        <td id="L5897" data-line-number="5897"></td>
        <td id="LC5897">            <span>if</span> (varDsc-&gt;<span>lvRegister</span> &amp;&amp; (lvaDoneFrameLayout == REGALLOC_FRAME_LAYOUT) &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L5898" data-line-number="5898"></td>
        <td id="LC5898">                ((varDsc-&gt;<span>TypeGet</span>() != TYP_LONG) || (varDsc-&gt;<span>GetOtherReg</span>() != REG_STK)))</td>
      </tr>
      <tr>
        <td id="L5899" data-line-number="5899"></td>
        <td id="LC5899">            {</td>
      </tr>
      <tr>
        <td id="L5900" data-line-number="5900"></td>
        <td id="LC5900">                allocateOnFrame = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L5901" data-line-number="5901"></td>
        <td id="LC5901">            }</td>
      </tr>
      <tr>
        <td id="L5902" data-line-number="5902"></td>
        <td id="LC5902">
</td>
      </tr>
      <tr>
        <td id="L5903" data-line-number="5903"></td>
        <td id="LC5903">            <span><span>/*</span> Ignore variables that are not on the stack frame <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L5904" data-line-number="5904"></td>
        <td id="LC5904">
</td>
      </tr>
      <tr>
        <td id="L5905" data-line-number="5905"></td>
        <td id="LC5905">            <span>if</span> (!allocateOnFrame)</td>
      </tr>
      <tr>
        <td id="L5906" data-line-number="5906"></td>
        <td id="LC5906">            {</td>
      </tr>
      <tr>
        <td id="L5907" data-line-number="5907"></td>
        <td id="LC5907">                <span><span>/*</span> For EnC, all variables have to be allocated space on the</span></td>
      </tr>
      <tr>
        <td id="L5908" data-line-number="5908"></td>
        <td id="LC5908"><span>                   stack, even though they may actually be enregistered. This</span></td>
      </tr>
      <tr>
        <td id="L5909" data-line-number="5909"></td>
        <td id="LC5909"><span>                   way, the frame layout can be directly inferred from the</span></td>
      </tr>
      <tr>
        <td id="L5910" data-line-number="5910"></td>
        <td id="LC5910"><span>                   locals-sig.</span></td>
      </tr>
      <tr>
        <td id="L5911" data-line-number="5911"></td>
        <td id="LC5911"><span>                 <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L5912" data-line-number="5912"></td>
        <td id="LC5912">
</td>
      </tr>
      <tr>
        <td id="L5913" data-line-number="5913"></td>
        <td id="LC5913">                <span>if</span> (!opts.<span>compDbgEnC</span>)</td>
      </tr>
      <tr>
        <td id="L5914" data-line-number="5914"></td>
        <td id="LC5914">                {</td>
      </tr>
      <tr>
        <td id="L5915" data-line-number="5915"></td>
        <td id="LC5915">                    <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5916" data-line-number="5916"></td>
        <td id="LC5916">                }</td>
      </tr>
      <tr>
        <td id="L5917" data-line-number="5917"></td>
        <td id="LC5917">                <span>else</span> <span>if</span> (lclNum &gt;= info.<span>compLocalsCount</span>)</td>
      </tr>
      <tr>
        <td id="L5918" data-line-number="5918"></td>
        <td id="LC5918">                { <span><span>//</span> ignore temps for EnC</span></td>
      </tr>
      <tr>
        <td id="L5919" data-line-number="5919"></td>
        <td id="LC5919">                    <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5920" data-line-number="5920"></td>
        <td id="LC5920">                }</td>
      </tr>
      <tr>
        <td id="L5921" data-line-number="5921"></td>
        <td id="LC5921">            }</td>
      </tr>
      <tr>
        <td id="L5922" data-line-number="5922"></td>
        <td id="LC5922">            <span>else</span> <span>if</span> (lvaGSSecurityCookie == lclNum &amp;&amp; <span>getNeedsGSSecurityCookie</span>())</td>
      </tr>
      <tr>
        <td id="L5923" data-line-number="5923"></td>
        <td id="LC5923">            {</td>
      </tr>
      <tr>
        <td id="L5924" data-line-number="5924"></td>
        <td id="LC5924">                <span>continue</span>; <span><span>//</span> This is allocated outside of this loop.</span></td>
      </tr>
      <tr>
        <td id="L5925" data-line-number="5925"></td>
        <td id="LC5925">            }</td>
      </tr>
      <tr>
        <td id="L5926" data-line-number="5926"></td>
        <td id="LC5926">
</td>
      </tr>
      <tr>
        <td id="L5927" data-line-number="5927"></td>
        <td id="LC5927">            <span><span>//</span> These need to be located as the very first variables (highest memory address)</span></td>
      </tr>
      <tr>
        <td id="L5928" data-line-number="5928"></td>
        <td id="LC5928">            <span><span>//</span> and so they have already been assigned an offset</span></td>
      </tr>
      <tr>
        <td id="L5929" data-line-number="5929"></td>
        <td id="LC5929">            <span>if</span> (</td>
      </tr>
      <tr>
        <td id="L5930" data-line-number="5930"></td>
        <td id="LC5930">#<span>if</span> defined(FEATURE_EH_FUNCLETS)</td>
      </tr>
      <tr>
        <td id="L5931" data-line-number="5931"></td>
        <td id="LC5931">                lclNum == lvaPSPSym ||</td>
      </tr>
      <tr>
        <td id="L5932" data-line-number="5932"></td>
        <td id="LC5932">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L5933" data-line-number="5933"></td>
        <td id="LC5933">                lclNum == lvaShadowSPslotsVar ||</td>
      </tr>
      <tr>
        <td id="L5934" data-line-number="5934"></td>
        <td id="LC5934">#<span>endif</span> <span><span>//</span> FEATURE_EH_FUNCLETS</span></td>
      </tr>
      <tr>
        <td id="L5935" data-line-number="5935"></td>
        <td id="LC5935">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L5936" data-line-number="5936"></td>
        <td id="LC5936">                lclNum == lvaLocAllocSPvar ||</td>
      </tr>
      <tr>
        <td id="L5937" data-line-number="5937"></td>
        <td id="LC5937">#<span>endif</span> <span><span>//</span> JIT32_GCENCODER</span></td>
      </tr>
      <tr>
        <td id="L5938" data-line-number="5938"></td>
        <td id="LC5938">                lclNum == lvaSecurityObject)</td>
      </tr>
      <tr>
        <td id="L5939" data-line-number="5939"></td>
        <td id="LC5939">            {</td>
      </tr>
      <tr>
        <td id="L5940" data-line-number="5940"></td>
        <td id="LC5940">                <span>assert</span>(varDsc-&gt;<span>lvStkOffs</span> != BAD_STK_OFFS);</td>
      </tr>
      <tr>
        <td id="L5941" data-line-number="5941"></td>
        <td id="LC5941">                <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5942" data-line-number="5942"></td>
        <td id="LC5942">            }</td>
      </tr>
      <tr>
        <td id="L5943" data-line-number="5943"></td>
        <td id="LC5943">
</td>
      </tr>
      <tr>
        <td id="L5944" data-line-number="5944"></td>
        <td id="LC5944">            <span>if</span> (lclNum == lvaMonAcquired)</td>
      </tr>
      <tr>
        <td id="L5945" data-line-number="5945"></td>
        <td id="LC5945">            {</td>
      </tr>
      <tr>
        <td id="L5946" data-line-number="5946"></td>
        <td id="LC5946">                <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5947" data-line-number="5947"></td>
        <td id="LC5947">            }</td>
      </tr>
      <tr>
        <td id="L5948" data-line-number="5948"></td>
        <td id="LC5948">
</td>
      </tr>
      <tr>
        <td id="L5949" data-line-number="5949"></td>
        <td id="LC5949">            <span><span>//</span> This should be low on the stack. Hence, it will be assigned later.</span></td>
      </tr>
      <tr>
        <td id="L5950" data-line-number="5950"></td>
        <td id="LC5950">            <span>if</span> (lclNum == lvaStubArgumentVar)</td>
      </tr>
      <tr>
        <td id="L5951" data-line-number="5951"></td>
        <td id="LC5951">            {</td>
      </tr>
      <tr>
        <td id="L5952" data-line-number="5952"></td>
        <td id="LC5952">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L5953" data-line-number="5953"></td>
        <td id="LC5953">                <span>noway_assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>());</td>
      </tr>
      <tr>
        <td id="L5954" data-line-number="5954"></td>
        <td id="LC5954">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5955" data-line-number="5955"></td>
        <td id="LC5955">                <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5956" data-line-number="5956"></td>
        <td id="LC5956">            }</td>
      </tr>
      <tr>
        <td id="L5957" data-line-number="5957"></td>
        <td id="LC5957">
</td>
      </tr>
      <tr>
        <td id="L5958" data-line-number="5958"></td>
        <td id="LC5958">            <span><span>//</span> This should be low on the stack. Hence, it will be assigned later.</span></td>
      </tr>
      <tr>
        <td id="L5959" data-line-number="5959"></td>
        <td id="LC5959">            <span>if</span> (lclNum == lvaInlinedPInvokeFrameVar)</td>
      </tr>
      <tr>
        <td id="L5960" data-line-number="5960"></td>
        <td id="LC5960">            {</td>
      </tr>
      <tr>
        <td id="L5961" data-line-number="5961"></td>
        <td id="LC5961">                <span>noway_assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>());</td>
      </tr>
      <tr>
        <td id="L5962" data-line-number="5962"></td>
        <td id="LC5962">                <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5963" data-line-number="5963"></td>
        <td id="LC5963">            }</td>
      </tr>
      <tr>
        <td id="L5964" data-line-number="5964"></td>
        <td id="LC5964">
</td>
      </tr>
      <tr>
        <td id="L5965" data-line-number="5965"></td>
        <td id="LC5965">            <span>if</span> (varDsc-&gt;<span>lvIsParam</span>)</td>
      </tr>
      <tr>
        <td id="L5966" data-line-number="5966"></td>
        <td id="LC5966">            {</td>
      </tr>
      <tr>
        <td id="L5967" data-line-number="5967"></td>
        <td id="LC5967">#<span>if</span> defined(TARGET_AMD64) &amp;&amp; !defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L5968" data-line-number="5968"></td>
        <td id="LC5968">
</td>
      </tr>
      <tr>
        <td id="L5969" data-line-number="5969"></td>
        <td id="LC5969">                <span><span>//</span> On Windows AMD64 we can use the caller-reserved stack area that is already setup</span></td>
      </tr>
      <tr>
        <td id="L5970" data-line-number="5970"></td>
        <td id="LC5970">                <span>assert</span>(varDsc-&gt;<span>lvStkOffs</span> != BAD_STK_OFFS);</td>
      </tr>
      <tr>
        <td id="L5971" data-line-number="5971"></td>
        <td id="LC5971">                <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5972" data-line-number="5972"></td>
        <td id="LC5972">
</td>
      </tr>
      <tr>
        <td id="L5973" data-line-number="5973"></td>
        <td id="LC5973">#<span>else</span> <span><span>//</span> !TARGET_AMD64</span></td>
      </tr>
      <tr>
        <td id="L5974" data-line-number="5974"></td>
        <td id="LC5974">
</td>
      </tr>
      <tr>
        <td id="L5975" data-line-number="5975"></td>
        <td id="LC5975">                <span><span>//</span>  A register argument that is not enregistered ends up as</span></td>
      </tr>
      <tr>
        <td id="L5976" data-line-number="5976"></td>
        <td id="LC5976">                <span><span>//</span>  a local variable which will need stack frame space.</span></td>
      </tr>
      <tr>
        <td id="L5977" data-line-number="5977"></td>
        <td id="LC5977">                <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5978" data-line-number="5978"></td>
        <td id="LC5978">                <span>if</span> (!varDsc-&gt;<span>lvIsRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L5979" data-line-number="5979"></td>
        <td id="LC5979">                {</td>
      </tr>
      <tr>
        <td id="L5980" data-line-number="5980"></td>
        <td id="LC5980">                    <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5981" data-line-number="5981"></td>
        <td id="LC5981">                }</td>
      </tr>
      <tr>
        <td id="L5982" data-line-number="5982"></td>
        <td id="LC5982">
</td>
      </tr>
      <tr>
        <td id="L5983" data-line-number="5983"></td>
        <td id="LC5983">#<span>ifdef</span> TARGET_ARM64</td>
      </tr>
      <tr>
        <td id="L5984" data-line-number="5984"></td>
        <td id="LC5984">                <span>if</span> (info.<span>compIsVarArgs</span> &amp;&amp; varDsc-&gt;<span>GetArgReg</span>() != <span>theFixedRetBuffArgNum</span>())</td>
      </tr>
      <tr>
        <td id="L5985" data-line-number="5985"></td>
        <td id="LC5985">                {</td>
      </tr>
      <tr>
        <td id="L5986" data-line-number="5986"></td>
        <td id="LC5986">                    <span><span>//</span> Stack offset to varargs (parameters) should point to home area which will be preallocated.</span></td>
      </tr>
      <tr>
        <td id="L5987" data-line-number="5987"></td>
        <td id="LC5987">                    varDsc-&gt;<span>lvStkOffs</span> =</td>
      </tr>
      <tr>
        <td id="L5988" data-line-number="5988"></td>
        <td id="LC5988">                        -initialStkOffs + <span>genMapIntRegNumToRegArgNum</span>(varDsc-&gt;<span>GetArgReg</span>()) * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L5989" data-line-number="5989"></td>
        <td id="LC5989">                    <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L5990" data-line-number="5990"></td>
        <td id="LC5990">                }</td>
      </tr>
      <tr>
        <td id="L5991" data-line-number="5991"></td>
        <td id="LC5991">
</td>
      </tr>
      <tr>
        <td id="L5992" data-line-number="5992"></td>
        <td id="LC5992">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L5993" data-line-number="5993"></td>
        <td id="LC5993">
</td>
      </tr>
      <tr>
        <td id="L5994" data-line-number="5994"></td>
        <td id="LC5994">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L5995" data-line-number="5995"></td>
        <td id="LC5995">                <span><span>//</span> On ARM we spill the registers in codeGen-&gt;regSet.rsMaskPreSpillRegArg</span></td>
      </tr>
      <tr>
        <td id="L5996" data-line-number="5996"></td>
        <td id="LC5996">                <span><span>//</span> in the prolog, thus they don't need stack frame space.</span></td>
      </tr>
      <tr>
        <td id="L5997" data-line-number="5997"></td>
        <td id="LC5997">                <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5998" data-line-number="5998"></td>
        <td id="LC5998">                <span>if</span> ((codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegs</span>(<span>false</span>) &amp; <span>genRegMask</span>(varDsc-&gt;<span>GetArgReg</span>())) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L5999" data-line-number="5999"></td>
        <td id="LC5999">                {</td>
      </tr>
      <tr>
        <td id="L6000" data-line-number="6000"></td>
        <td id="LC6000">                    <span>assert</span>(varDsc-&gt;<span>lvStkOffs</span> != BAD_STK_OFFS);</td>
      </tr>
      <tr>
        <td id="L6001" data-line-number="6001"></td>
        <td id="LC6001">                    <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L6002" data-line-number="6002"></td>
        <td id="LC6002">                }</td>
      </tr>
      <tr>
        <td id="L6003" data-line-number="6003"></td>
        <td id="LC6003">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6004" data-line-number="6004"></td>
        <td id="LC6004">
</td>
      </tr>
      <tr>
        <td id="L6005" data-line-number="6005"></td>
        <td id="LC6005">#<span>endif</span> <span><span>//</span> !TARGET_AMD64</span></td>
      </tr>
      <tr>
        <td id="L6006" data-line-number="6006"></td>
        <td id="LC6006">            }</td>
      </tr>
      <tr>
        <td id="L6007" data-line-number="6007"></td>
        <td id="LC6007">
</td>
      </tr>
      <tr>
        <td id="L6008" data-line-number="6008"></td>
        <td id="LC6008">            <span><span>/*</span> Make sure the type is appropriate <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6009" data-line-number="6009"></td>
        <td id="LC6009">
</td>
      </tr>
      <tr>
        <td id="L6010" data-line-number="6010"></td>
        <td id="LC6010">            <span>if</span> (varDsc-&gt;<span>lvIsUnsafeBuffer</span> &amp;&amp; compGSReorderStackLayout)</td>
      </tr>
      <tr>
        <td id="L6011" data-line-number="6011"></td>
        <td id="LC6011">            {</td>
      </tr>
      <tr>
        <td id="L6012" data-line-number="6012"></td>
        <td id="LC6012">                <span>if</span> (varDsc-&gt;<span>lvIsPtr</span>)</td>
      </tr>
      <tr>
        <td id="L6013" data-line-number="6013"></td>
        <td id="LC6013">                {</td>
      </tr>
      <tr>
        <td id="L6014" data-line-number="6014"></td>
        <td id="LC6014">                    <span>if</span> ((alloc_order[cur] &amp; ALLOC_UNSAFE_BUFFERS_WITH_PTRS) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6015" data-line-number="6015"></td>
        <td id="LC6015">                    {</td>
      </tr>
      <tr>
        <td id="L6016" data-line-number="6016"></td>
        <td id="LC6016">                        assignMore |= ALLOC_UNSAFE_BUFFERS_WITH_PTRS;</td>
      </tr>
      <tr>
        <td id="L6017" data-line-number="6017"></td>
        <td id="LC6017">                        <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L6018" data-line-number="6018"></td>
        <td id="LC6018">                    }</td>
      </tr>
      <tr>
        <td id="L6019" data-line-number="6019"></td>
        <td id="LC6019">                }</td>
      </tr>
      <tr>
        <td id="L6020" data-line-number="6020"></td>
        <td id="LC6020">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L6021" data-line-number="6021"></td>
        <td id="LC6021">                {</td>
      </tr>
      <tr>
        <td id="L6022" data-line-number="6022"></td>
        <td id="LC6022">                    <span>if</span> ((alloc_order[cur] &amp; ALLOC_UNSAFE_BUFFERS) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6023" data-line-number="6023"></td>
        <td id="LC6023">                    {</td>
      </tr>
      <tr>
        <td id="L6024" data-line-number="6024"></td>
        <td id="LC6024">                        assignMore |= ALLOC_UNSAFE_BUFFERS;</td>
      </tr>
      <tr>
        <td id="L6025" data-line-number="6025"></td>
        <td id="LC6025">                        <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L6026" data-line-number="6026"></td>
        <td id="LC6026">                    }</td>
      </tr>
      <tr>
        <td id="L6027" data-line-number="6027"></td>
        <td id="LC6027">                }</td>
      </tr>
      <tr>
        <td id="L6028" data-line-number="6028"></td>
        <td id="LC6028">            }</td>
      </tr>
      <tr>
        <td id="L6029" data-line-number="6029"></td>
        <td id="LC6029">            <span>else</span> <span>if</span> (<span>varTypeIsGC</span>(varDsc-&gt;<span>TypeGet</span>()) &amp;&amp; varDsc-&gt;<span>lvTracked</span>)</td>
      </tr>
      <tr>
        <td id="L6030" data-line-number="6030"></td>
        <td id="LC6030">            {</td>
      </tr>
      <tr>
        <td id="L6031" data-line-number="6031"></td>
        <td id="LC6031">                <span>if</span> ((alloc_order[cur] &amp; ALLOC_PTRS) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6032" data-line-number="6032"></td>
        <td id="LC6032">                {</td>
      </tr>
      <tr>
        <td id="L6033" data-line-number="6033"></td>
        <td id="LC6033">                    assignMore |= ALLOC_PTRS;</td>
      </tr>
      <tr>
        <td id="L6034" data-line-number="6034"></td>
        <td id="LC6034">                    <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L6035" data-line-number="6035"></td>
        <td id="LC6035">                }</td>
      </tr>
      <tr>
        <td id="L6036" data-line-number="6036"></td>
        <td id="LC6036">            }</td>
      </tr>
      <tr>
        <td id="L6037" data-line-number="6037"></td>
        <td id="LC6037">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L6038" data-line-number="6038"></td>
        <td id="LC6038">            {</td>
      </tr>
      <tr>
        <td id="L6039" data-line-number="6039"></td>
        <td id="LC6039">                <span>if</span> ((alloc_order[cur] &amp; ALLOC_NON_PTRS) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6040" data-line-number="6040"></td>
        <td id="LC6040">                {</td>
      </tr>
      <tr>
        <td id="L6041" data-line-number="6041"></td>
        <td id="LC6041">                    assignMore |= ALLOC_NON_PTRS;</td>
      </tr>
      <tr>
        <td id="L6042" data-line-number="6042"></td>
        <td id="LC6042">                    <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L6043" data-line-number="6043"></td>
        <td id="LC6043">                }</td>
      </tr>
      <tr>
        <td id="L6044" data-line-number="6044"></td>
        <td id="LC6044">            }</td>
      </tr>
      <tr>
        <td id="L6045" data-line-number="6045"></td>
        <td id="LC6045">
</td>
      </tr>
      <tr>
        <td id="L6046" data-line-number="6046"></td>
        <td id="LC6046">            <span><span>/*</span> Need to align the offset? <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6047" data-line-number="6047"></td>
        <td id="LC6047">
</td>
      </tr>
      <tr>
        <td id="L6048" data-line-number="6048"></td>
        <td id="LC6048">            <span>if</span> (mustDoubleAlign &amp;&amp; (varDsc-&gt;<span>lvType</span> == TYP_DOUBLE <span><span>//</span> Align doubles for ARM and x86</span></td>
      </tr>
      <tr>
        <td id="L6049" data-line-number="6049"></td>
        <td id="LC6049">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L6050" data-line-number="6050"></td>
        <td id="LC6050">                                    || varDsc-&gt;<span>lvType</span> == TYP_LONG <span><span>//</span> Align longs for ARM</span></td>
      </tr>
      <tr>
        <td id="L6051" data-line-number="6051"></td>
        <td id="LC6051">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6052" data-line-number="6052"></td>
        <td id="LC6052">#<span>ifndef</span> TARGET_64BIT</td>
      </tr>
      <tr>
        <td id="L6053" data-line-number="6053"></td>
        <td id="LC6053">                                    || varDsc-&gt;<span>lvStructDoubleAlign</span> <span><span>//</span> Align when lvStructDoubleAlign is true</span></td>
      </tr>
      <tr>
        <td id="L6054" data-line-number="6054"></td>
        <td id="LC6054">#<span>endif</span>                                                             <span><span>//</span> !TARGET_64BIT</span></td>
      </tr>
      <tr>
        <td id="L6055" data-line-number="6055"></td>
        <td id="LC6055">                                    ))</td>
      </tr>
      <tr>
        <td id="L6056" data-line-number="6056"></td>
        <td id="LC6056">            {</td>
      </tr>
      <tr>
        <td id="L6057" data-line-number="6057"></td>
        <td id="LC6057">                <span>noway_assert</span>((compLclFrameSize % TARGET_POINTER_SIZE) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6058" data-line-number="6058"></td>
        <td id="LC6058">
</td>
      </tr>
      <tr>
        <td id="L6059" data-line-number="6059"></td>
        <td id="LC6059">                <span>if</span> ((lvaDoneFrameLayout != FINAL_FRAME_LAYOUT) &amp;&amp; !have_LclVarDoubleAlign)</td>
      </tr>
      <tr>
        <td id="L6060" data-line-number="6060"></td>
        <td id="LC6060">                {</td>
      </tr>
      <tr>
        <td id="L6061" data-line-number="6061"></td>
        <td id="LC6061">                    <span><span>//</span> If this is the first TYP_LONG, TYP_DOUBLE or double aligned struct</span></td>
      </tr>
      <tr>
        <td id="L6062" data-line-number="6062"></td>
        <td id="LC6062">                    <span><span>//</span> then we have seen in this loop then we allocate a pointer sized</span></td>
      </tr>
      <tr>
        <td id="L6063" data-line-number="6063"></td>
        <td id="LC6063">                    <span><span>//</span> stack slot since we may need to double align this LclVar</span></td>
      </tr>
      <tr>
        <td id="L6064" data-line-number="6064"></td>
        <td id="LC6064">                    <span><span>//</span> when lvaDoneFrameLayout == FINAL_FRAME_LAYOUT</span></td>
      </tr>
      <tr>
        <td id="L6065" data-line-number="6065"></td>
        <td id="LC6065">                    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6066" data-line-number="6066"></td>
        <td id="LC6066">                    <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L6067" data-line-number="6067"></td>
        <td id="LC6067">                    stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L6068" data-line-number="6068"></td>
        <td id="LC6068">                }</td>
      </tr>
      <tr>
        <td id="L6069" data-line-number="6069"></td>
        <td id="LC6069">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L6070" data-line-number="6070"></td>
        <td id="LC6070">                {</td>
      </tr>
      <tr>
        <td id="L6071" data-line-number="6071"></td>
        <td id="LC6071">                    <span>if</span> (((stkOffs + preSpillSize) % (<span>2</span> * TARGET_POINTER_SIZE)) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6072" data-line-number="6072"></td>
        <td id="LC6072">                    {</td>
      </tr>
      <tr>
        <td id="L6073" data-line-number="6073"></td>
        <td id="LC6073">                        <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L6074" data-line-number="6074"></td>
        <td id="LC6074">                        stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L6075" data-line-number="6075"></td>
        <td id="LC6075">                    }</td>
      </tr>
      <tr>
        <td id="L6076" data-line-number="6076"></td>
        <td id="LC6076">
</td>
      </tr>
      <tr>
        <td id="L6077" data-line-number="6077"></td>
        <td id="LC6077">                    <span><span>//</span> We should now have a double-aligned (stkOffs+preSpillSize)</span></td>
      </tr>
      <tr>
        <td id="L6078" data-line-number="6078"></td>
        <td id="LC6078">                    <span>noway_assert</span>(((stkOffs + preSpillSize) % (<span>2</span> * TARGET_POINTER_SIZE)) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6079" data-line-number="6079"></td>
        <td id="LC6079">                }</td>
      </tr>
      <tr>
        <td id="L6080" data-line-number="6080"></td>
        <td id="LC6080">
</td>
      </tr>
      <tr>
        <td id="L6081" data-line-number="6081"></td>
        <td id="LC6081">                <span><span>//</span> Remember that we had to double align a LclVar</span></td>
      </tr>
      <tr>
        <td id="L6082" data-line-number="6082"></td>
        <td id="LC6082">                have_LclVarDoubleAlign = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L6083" data-line-number="6083"></td>
        <td id="LC6083">            }</td>
      </tr>
      <tr>
        <td id="L6084" data-line-number="6084"></td>
        <td id="LC6084">
</td>
      </tr>
      <tr>
        <td id="L6085" data-line-number="6085"></td>
        <td id="LC6085">            <span><span>//</span> Reserve the stack space for this variable</span></td>
      </tr>
      <tr>
        <td id="L6086" data-line-number="6086"></td>
        <td id="LC6086">            stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lclNum, <span>lvaLclSize</span>(lclNum), stkOffs);</td>
      </tr>
      <tr>
        <td id="L6087" data-line-number="6087"></td>
        <td id="LC6087">#<span>ifdef</span> TARGET_ARM64</td>
      </tr>
      <tr>
        <td id="L6088" data-line-number="6088"></td>
        <td id="LC6088">            <span><span>//</span> If we have an incoming register argument that has a struct promoted field</span></td>
      </tr>
      <tr>
        <td id="L6089" data-line-number="6089"></td>
        <td id="LC6089">            <span><span>//</span> then we need to copy the lvStkOff (the stack home) from the reg arg to the field lclvar</span></td>
      </tr>
      <tr>
        <td id="L6090" data-line-number="6090"></td>
        <td id="LC6090">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6091" data-line-number="6091"></td>
        <td id="LC6091">            <span>if</span> (varDsc-&gt;<span>lvIsRegArg</span> &amp;&amp; varDsc-&gt;<span>lvPromotedStruct</span>())</td>
      </tr>
      <tr>
        <td id="L6092" data-line-number="6092"></td>
        <td id="LC6092">            {</td>
      </tr>
      <tr>
        <td id="L6093" data-line-number="6093"></td>
        <td id="LC6093">                <span>noway_assert</span>(varDsc-&gt;<span>lvFieldCnt</span> == <span>1</span>); <span><span>//</span> We only handle one field here</span></td>
      </tr>
      <tr>
        <td id="L6094" data-line-number="6094"></td>
        <td id="LC6094">
</td>
      </tr>
      <tr>
        <td id="L6095" data-line-number="6095"></td>
        <td id="LC6095">                <span>unsigned</span> fieldVarNum            = varDsc-&gt;<span>lvFieldLclStart</span>;</td>
      </tr>
      <tr>
        <td id="L6096" data-line-number="6096"></td>
        <td id="LC6096">                lvaTable[fieldVarNum].<span>lvStkOffs</span> = varDsc-&gt;<span>lvStkOffs</span>;</td>
      </tr>
      <tr>
        <td id="L6097" data-line-number="6097"></td>
        <td id="LC6097">            }</td>
      </tr>
      <tr>
        <td id="L6098" data-line-number="6098"></td>
        <td id="LC6098">#<span>endif</span> <span><span>//</span> TARGET_ARM64</span></td>
      </tr>
      <tr>
        <td id="L6099" data-line-number="6099"></td>
        <td id="LC6099">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L6100" data-line-number="6100"></td>
        <td id="LC6100">            <span><span>//</span> If we have an incoming register argument that has a promoted long</span></td>
      </tr>
      <tr>
        <td id="L6101" data-line-number="6101"></td>
        <td id="LC6101">            <span><span>//</span> then we need to copy the lvStkOff (the stack home) from the reg arg to the field lclvar</span></td>
      </tr>
      <tr>
        <td id="L6102" data-line-number="6102"></td>
        <td id="LC6102">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6103" data-line-number="6103"></td>
        <td id="LC6103">            <span>if</span> (varDsc-&gt;<span>lvIsRegArg</span> &amp;&amp; varDsc-&gt;<span>lvPromoted</span>)</td>
      </tr>
      <tr>
        <td id="L6104" data-line-number="6104"></td>
        <td id="LC6104">            {</td>
      </tr>
      <tr>
        <td id="L6105" data-line-number="6105"></td>
        <td id="LC6105">                <span>assert</span>(<span>varTypeIsLong</span>(varDsc) &amp;&amp; (varDsc-&gt;<span>lvFieldCnt</span> == <span>2</span>));</td>
      </tr>
      <tr>
        <td id="L6106" data-line-number="6106"></td>
        <td id="LC6106">
</td>
      </tr>
      <tr>
        <td id="L6107" data-line-number="6107"></td>
        <td id="LC6107">                <span>unsigned</span> fieldVarNum                = varDsc-&gt;<span>lvFieldLclStart</span>;</td>
      </tr>
      <tr>
        <td id="L6108" data-line-number="6108"></td>
        <td id="LC6108">                lvaTable[fieldVarNum].<span>lvStkOffs</span>     = varDsc-&gt;<span>lvStkOffs</span>;</td>
      </tr>
      <tr>
        <td id="L6109" data-line-number="6109"></td>
        <td id="LC6109">                lvaTable[fieldVarNum + <span>1</span>].<span>lvStkOffs</span> = varDsc-&gt;<span>lvStkOffs</span> + <span>4</span>;</td>
      </tr>
      <tr>
        <td id="L6110" data-line-number="6110"></td>
        <td id="LC6110">            }</td>
      </tr>
      <tr>
        <td id="L6111" data-line-number="6111"></td>
        <td id="LC6111">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L6112" data-line-number="6112"></td>
        <td id="LC6112">        }</td>
      </tr>
      <tr>
        <td id="L6113" data-line-number="6113"></td>
        <td id="LC6113">    }</td>
      </tr>
      <tr>
        <td id="L6114" data-line-number="6114"></td>
        <td id="LC6114">
</td>
      </tr>
      <tr>
        <td id="L6115" data-line-number="6115"></td>
        <td id="LC6115">    <span>if</span> (<span>getNeedsGSSecurityCookie</span>() &amp;&amp; !compGSReorderStackLayout)</td>
      </tr>
      <tr>
        <td id="L6116" data-line-number="6116"></td>
        <td id="LC6116">    {</td>
      </tr>
      <tr>
        <td id="L6117" data-line-number="6117"></td>
        <td id="LC6117">        <span><span>//</span> LOCALLOC used, but we have no unsafe buffer.  Allocated cookie last, close to localloc buffer.</span></td>
      </tr>
      <tr>
        <td id="L6118" data-line-number="6118"></td>
        <td id="LC6118">        stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaGSSecurityCookie, <span>lvaLclSize</span>(lvaGSSecurityCookie), stkOffs);</td>
      </tr>
      <tr>
        <td id="L6119" data-line-number="6119"></td>
        <td id="LC6119">    }</td>
      </tr>
      <tr>
        <td id="L6120" data-line-number="6120"></td>
        <td id="LC6120">
</td>
      </tr>
      <tr>
        <td id="L6121" data-line-number="6121"></td>
        <td id="LC6121">    <span>if</span> (tempsAllocated == <span>false</span>)</td>
      </tr>
      <tr>
        <td id="L6122" data-line-number="6122"></td>
        <td id="LC6122">    {</td>
      </tr>
      <tr>
        <td id="L6123" data-line-number="6123"></td>
        <td id="LC6123">        <span><span>/*</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L6124" data-line-number="6124"></td>
        <td id="LC6124"><span>         *</span></td>
      </tr>
      <tr>
        <td id="L6125" data-line-number="6125"></td>
        <td id="LC6125"><span>         * Now the temps</span></td>
      </tr>
      <tr>
        <td id="L6126" data-line-number="6126"></td>
        <td id="LC6126"><span>         *</span></td>
      </tr>
      <tr>
        <td id="L6127" data-line-number="6127"></td>
        <td id="LC6127"><span>         *-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L6128" data-line-number="6128"></td>
        <td id="LC6128"><span>         <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6129" data-line-number="6129"></td>
        <td id="LC6129">        stkOffs = <span>lvaAllocateTemps</span>(stkOffs, mustDoubleAlign);</td>
      </tr>
      <tr>
        <td id="L6130" data-line-number="6130"></td>
        <td id="LC6130">    }</td>
      </tr>
      <tr>
        <td id="L6131" data-line-number="6131"></td>
        <td id="LC6131">
</td>
      </tr>
      <tr>
        <td id="L6132" data-line-number="6132"></td>
        <td id="LC6132">    <span><span>/*</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L6133" data-line-number="6133"></td>
        <td id="LC6133"><span>     *</span></td>
      </tr>
      <tr>
        <td id="L6134" data-line-number="6134"></td>
        <td id="LC6134"><span>     * Now do some final stuff</span></td>
      </tr>
      <tr>
        <td id="L6135" data-line-number="6135"></td>
        <td id="LC6135"><span>     *</span></td>
      </tr>
      <tr>
        <td id="L6136" data-line-number="6136"></td>
        <td id="LC6136"><span>     *-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L6137" data-line-number="6137"></td>
        <td id="LC6137"><span>     <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6138" data-line-number="6138"></td>
        <td id="LC6138">
</td>
      </tr>
      <tr>
        <td id="L6139" data-line-number="6139"></td>
        <td id="LC6139">    <span><span>//</span> lvaInlinedPInvokeFrameVar and lvaStubArgumentVar need to be assigned last</span></td>
      </tr>
      <tr>
        <td id="L6140" data-line-number="6140"></td>
        <td id="LC6140">    <span><span>//</span> Important: The stack walker depends on lvaStubArgumentVar immediately</span></td>
      </tr>
      <tr>
        <td id="L6141" data-line-number="6141"></td>
        <td id="LC6141">    <span><span>//</span> following lvaInlinedPInvokeFrameVar in the frame.</span></td>
      </tr>
      <tr>
        <td id="L6142" data-line-number="6142"></td>
        <td id="LC6142">
</td>
      </tr>
      <tr>
        <td id="L6143" data-line-number="6143"></td>
        <td id="LC6143">    <span>if</span> (lvaStubArgumentVar != BAD_VAR_NUM)</td>
      </tr>
      <tr>
        <td id="L6144" data-line-number="6144"></td>
        <td id="LC6144">    {</td>
      </tr>
      <tr>
        <td id="L6145" data-line-number="6145"></td>
        <td id="LC6145">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L6146" data-line-number="6146"></td>
        <td id="LC6146">        <span>noway_assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>());</td>
      </tr>
      <tr>
        <td id="L6147" data-line-number="6147"></td>
        <td id="LC6147">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6148" data-line-number="6148"></td>
        <td id="LC6148">        stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaStubArgumentVar, <span>lvaLclSize</span>(lvaStubArgumentVar), stkOffs);</td>
      </tr>
      <tr>
        <td id="L6149" data-line-number="6149"></td>
        <td id="LC6149">    }</td>
      </tr>
      <tr>
        <td id="L6150" data-line-number="6150"></td>
        <td id="LC6150">
</td>
      </tr>
      <tr>
        <td id="L6151" data-line-number="6151"></td>
        <td id="LC6151">    <span>if</span> (lvaInlinedPInvokeFrameVar != BAD_VAR_NUM)</td>
      </tr>
      <tr>
        <td id="L6152" data-line-number="6152"></td>
        <td id="LC6152">    {</td>
      </tr>
      <tr>
        <td id="L6153" data-line-number="6153"></td>
        <td id="LC6153">        <span>noway_assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>());</td>
      </tr>
      <tr>
        <td id="L6154" data-line-number="6154"></td>
        <td id="LC6154">        stkOffs =</td>
      </tr>
      <tr>
        <td id="L6155" data-line-number="6155"></td>
        <td id="LC6155">            <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaInlinedPInvokeFrameVar, <span>lvaLclSize</span>(lvaInlinedPInvokeFrameVar), stkOffs);</td>
      </tr>
      <tr>
        <td id="L6156" data-line-number="6156"></td>
        <td id="LC6156">    }</td>
      </tr>
      <tr>
        <td id="L6157" data-line-number="6157"></td>
        <td id="LC6157">
</td>
      </tr>
      <tr>
        <td id="L6158" data-line-number="6158"></td>
        <td id="LC6158">    <span>if</span> (mustDoubleAlign)</td>
      </tr>
      <tr>
        <td id="L6159" data-line-number="6159"></td>
        <td id="LC6159">    {</td>
      </tr>
      <tr>
        <td id="L6160" data-line-number="6160"></td>
        <td id="LC6160">        <span>if</span> (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6161" data-line-number="6161"></td>
        <td id="LC6161">        {</td>
      </tr>
      <tr>
        <td id="L6162" data-line-number="6162"></td>
        <td id="LC6162">            <span><span>//</span> Allocate a pointer sized stack slot, since we may need to double align here</span></td>
      </tr>
      <tr>
        <td id="L6163" data-line-number="6163"></td>
        <td id="LC6163">            <span><span>//</span> when lvaDoneFrameLayout == FINAL_FRAME_LAYOUT</span></td>
      </tr>
      <tr>
        <td id="L6164" data-line-number="6164"></td>
        <td id="LC6164">            <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6165" data-line-number="6165"></td>
        <td id="LC6165">            <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L6166" data-line-number="6166"></td>
        <td id="LC6166">            stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L6167" data-line-number="6167"></td>
        <td id="LC6167">
</td>
      </tr>
      <tr>
        <td id="L6168" data-line-number="6168"></td>
        <td id="LC6168">            <span>if</span> (have_LclVarDoubleAlign)</td>
      </tr>
      <tr>
        <td id="L6169" data-line-number="6169"></td>
        <td id="LC6169">            {</td>
      </tr>
      <tr>
        <td id="L6170" data-line-number="6170"></td>
        <td id="LC6170">                <span><span>//</span> If we have any TYP_LONG, TYP_DOUBLE or double aligned structs</span></td>
      </tr>
      <tr>
        <td id="L6171" data-line-number="6171"></td>
        <td id="LC6171">                <span><span>//</span> the we need to allocate a second pointer sized stack slot,</span></td>
      </tr>
      <tr>
        <td id="L6172" data-line-number="6172"></td>
        <td id="LC6172">                <span><span>//</span> since we may need to double align the last LclVar that we saw</span></td>
      </tr>
      <tr>
        <td id="L6173" data-line-number="6173"></td>
        <td id="LC6173">                <span><span>//</span> in the loop above. We do this so that the offsets that we</span></td>
      </tr>
      <tr>
        <td id="L6174" data-line-number="6174"></td>
        <td id="LC6174">                <span><span>//</span> calculate for the stack frame are always greater than they will</span></td>
      </tr>
      <tr>
        <td id="L6175" data-line-number="6175"></td>
        <td id="LC6175">                <span><span>//</span> be in the final layout.</span></td>
      </tr>
      <tr>
        <td id="L6176" data-line-number="6176"></td>
        <td id="LC6176">                <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6177" data-line-number="6177"></td>
        <td id="LC6177">                <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L6178" data-line-number="6178"></td>
        <td id="LC6178">                stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L6179" data-line-number="6179"></td>
        <td id="LC6179">            }</td>
      </tr>
      <tr>
        <td id="L6180" data-line-number="6180"></td>
        <td id="LC6180">        }</td>
      </tr>
      <tr>
        <td id="L6181" data-line-number="6181"></td>
        <td id="LC6181">        <span>else</span> <span><span>//</span> FINAL_FRAME_LAYOUT</span></td>
      </tr>
      <tr>
        <td id="L6182" data-line-number="6182"></td>
        <td id="LC6182">        {</td>
      </tr>
      <tr>
        <td id="L6183" data-line-number="6183"></td>
        <td id="LC6183">            <span>if</span> (((stkOffs + preSpillSize) % (<span>2</span> * TARGET_POINTER_SIZE)) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6184" data-line-number="6184"></td>
        <td id="LC6184">            {</td>
      </tr>
      <tr>
        <td id="L6185" data-line-number="6185"></td>
        <td id="LC6185">                <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L6186" data-line-number="6186"></td>
        <td id="LC6186">                stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L6187" data-line-number="6187"></td>
        <td id="LC6187">            }</td>
      </tr>
      <tr>
        <td id="L6188" data-line-number="6188"></td>
        <td id="LC6188">            <span><span>//</span> We should now have a double-aligned (stkOffs+preSpillSize)</span></td>
      </tr>
      <tr>
        <td id="L6189" data-line-number="6189"></td>
        <td id="LC6189">            <span>noway_assert</span>(((stkOffs + preSpillSize) % (<span>2</span> * TARGET_POINTER_SIZE)) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6190" data-line-number="6190"></td>
        <td id="LC6190">        }</td>
      </tr>
      <tr>
        <td id="L6191" data-line-number="6191"></td>
        <td id="LC6191">    }</td>
      </tr>
      <tr>
        <td id="L6192" data-line-number="6192"></td>
        <td id="LC6192">
</td>
      </tr>
      <tr>
        <td id="L6193" data-line-number="6193"></td>
        <td id="LC6193">#<span>if</span> defined(FEATURE_EH_FUNCLETS) &amp;&amp; defined(TARGET_AMD64)</td>
      </tr>
      <tr>
        <td id="L6194" data-line-number="6194"></td>
        <td id="LC6194">    <span>if</span> (lvaPSPSym != BAD_VAR_NUM)</td>
      </tr>
      <tr>
        <td id="L6195" data-line-number="6195"></td>
        <td id="LC6195">    {</td>
      </tr>
      <tr>
        <td id="L6196" data-line-number="6196"></td>
        <td id="LC6196">        <span><span>//</span> On AMD64, if we need a PSPSym, allocate it last, immediately above the outgoing argument</span></td>
      </tr>
      <tr>
        <td id="L6197" data-line-number="6197"></td>
        <td id="LC6197">        <span><span>//</span> space. Any padding will be higher on the stack than this</span></td>
      </tr>
      <tr>
        <td id="L6198" data-line-number="6198"></td>
        <td id="LC6198">        <span><span>//</span> (including the padding added by lvaAlignFrame()).</span></td>
      </tr>
      <tr>
        <td id="L6199" data-line-number="6199"></td>
        <td id="LC6199">        <span>noway_assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>()); <span><span>//</span> We need an explicit frame pointer</span></td>
      </tr>
      <tr>
        <td id="L6200" data-line-number="6200"></td>
        <td id="LC6200">        stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaPSPSym, TARGET_POINTER_SIZE, stkOffs);</td>
      </tr>
      <tr>
        <td id="L6201" data-line-number="6201"></td>
        <td id="LC6201">    }</td>
      </tr>
      <tr>
        <td id="L6202" data-line-number="6202"></td>
        <td id="LC6202">#<span>endif</span> <span><span>//</span> FEATURE_EH_FUNCLETS &amp;&amp; defined(TARGET_AMD64)</span></td>
      </tr>
      <tr>
        <td id="L6203" data-line-number="6203"></td>
        <td id="LC6203">
</td>
      </tr>
      <tr>
        <td id="L6204" data-line-number="6204"></td>
        <td id="LC6204">#<span>ifdef</span> TARGET_ARM64</td>
      </tr>
      <tr>
        <td id="L6205" data-line-number="6205"></td>
        <td id="LC6205">    <span>if</span> (!codeGen-&gt;<span>IsSaveFpLrWithAllCalleeSavedRegisters</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L6206" data-line-number="6206"></td>
        <td id="LC6206">        <span>isFramePointerUsed</span>()) <span><span>//</span> Note that currently we always have a frame pointer</span></td>
      </tr>
      <tr>
        <td id="L6207" data-line-number="6207"></td>
        <td id="LC6207">    {</td>
      </tr>
      <tr>
        <td id="L6208" data-line-number="6208"></td>
        <td id="LC6208">        <span><span>//</span> Create space for saving FP and LR.</span></td>
      </tr>
      <tr>
        <td id="L6209" data-line-number="6209"></td>
        <td id="LC6209">        stkOffs -= <span>2</span> * REGSIZE_BYTES;</td>
      </tr>
      <tr>
        <td id="L6210" data-line-number="6210"></td>
        <td id="LC6210">    }</td>
      </tr>
      <tr>
        <td id="L6211" data-line-number="6211"></td>
        <td id="LC6211">#<span>endif</span> <span><span>//</span> TARGET_ARM64</span></td>
      </tr>
      <tr>
        <td id="L6212" data-line-number="6212"></td>
        <td id="LC6212">
</td>
      </tr>
      <tr>
        <td id="L6213" data-line-number="6213"></td>
        <td id="LC6213">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L6214" data-line-number="6214"></td>
        <td id="LC6214">    <span>if</span> (lvaOutgoingArgSpaceSize &gt; <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6215" data-line-number="6215"></td>
        <td id="LC6215">    {</td>
      </tr>
      <tr>
        <td id="L6216" data-line-number="6216"></td>
        <td id="LC6216">#<span>if</span> defined(TARGET_AMD64) &amp;&amp; !defined(UNIX_AMD64_ABI) <span><span>//</span> No 4 slots for outgoing params on System V.</span></td>
      </tr>
      <tr>
        <td id="L6217" data-line-number="6217"></td>
        <td id="LC6217">        <span>noway_assert</span>(lvaOutgoingArgSpaceSize &gt;= (<span>4</span> * TARGET_POINTER_SIZE));</td>
      </tr>
      <tr>
        <td id="L6218" data-line-number="6218"></td>
        <td id="LC6218">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6219" data-line-number="6219"></td>
        <td id="LC6219">        <span>noway_assert</span>((lvaOutgoingArgSpaceSize % TARGET_POINTER_SIZE) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6220" data-line-number="6220"></td>
        <td id="LC6220">
</td>
      </tr>
      <tr>
        <td id="L6221" data-line-number="6221"></td>
        <td id="LC6221">        <span><span>//</span> Give it a value so we can avoid asserts in CHK builds.</span></td>
      </tr>
      <tr>
        <td id="L6222" data-line-number="6222"></td>
        <td id="LC6222">        <span><span>//</span> Since this will always use an SP relative offset of zero</span></td>
      </tr>
      <tr>
        <td id="L6223" data-line-number="6223"></td>
        <td id="LC6223">        <span><span>//</span> at the end of lvaFixVirtualFrameOffsets, it will be set to absolute '0'</span></td>
      </tr>
      <tr>
        <td id="L6224" data-line-number="6224"></td>
        <td id="LC6224">
</td>
      </tr>
      <tr>
        <td id="L6225" data-line-number="6225"></td>
        <td id="LC6225">        stkOffs = <span>lvaAllocLocalAndSetVirtualOffset</span>(lvaOutgoingArgSpaceVar, <span>lvaLclSize</span>(lvaOutgoingArgSpaceVar), stkOffs);</td>
      </tr>
      <tr>
        <td id="L6226" data-line-number="6226"></td>
        <td id="LC6226">    }</td>
      </tr>
      <tr>
        <td id="L6227" data-line-number="6227"></td>
        <td id="LC6227">#<span>endif</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L6228" data-line-number="6228"></td>
        <td id="LC6228">
</td>
      </tr>
      <tr>
        <td id="L6229" data-line-number="6229"></td>
        <td id="LC6229">    <span><span>//</span> compLclFrameSize equals our negated virtual stack offset minus the pushed registers and return address</span></td>
      </tr>
      <tr>
        <td id="L6230" data-line-number="6230"></td>
        <td id="LC6230">    <span><span>//</span> and the pushed frame pointer register which for some strange reason isn't part of 'compCalleeRegsPushed'.</span></td>
      </tr>
      <tr>
        <td id="L6231" data-line-number="6231"></td>
        <td id="LC6231">    <span>int</span> pushedCount = compCalleeRegsPushed;</td>
      </tr>
      <tr>
        <td id="L6232" data-line-number="6232"></td>
        <td id="LC6232">
</td>
      </tr>
      <tr>
        <td id="L6233" data-line-number="6233"></td>
        <td id="LC6233">#<span>ifdef</span> TARGET_ARM64</td>
      </tr>
      <tr>
        <td id="L6234" data-line-number="6234"></td>
        <td id="LC6234">    <span>if</span> (info.<span>compIsVarArgs</span>)</td>
      </tr>
      <tr>
        <td id="L6235" data-line-number="6235"></td>
        <td id="LC6235">    {</td>
      </tr>
      <tr>
        <td id="L6236" data-line-number="6236"></td>
        <td id="LC6236">        pushedCount += MAX_REG_ARG;</td>
      </tr>
      <tr>
        <td id="L6237" data-line-number="6237"></td>
        <td id="LC6237">    }</td>
      </tr>
      <tr>
        <td id="L6238" data-line-number="6238"></td>
        <td id="LC6238">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6239" data-line-number="6239"></td>
        <td id="LC6239">
</td>
      </tr>
      <tr>
        <td id="L6240" data-line-number="6240"></td>
        <td id="LC6240">#<span>ifdef</span> TARGET_XARCH</td>
      </tr>
      <tr>
        <td id="L6241" data-line-number="6241"></td>
        <td id="LC6241">    <span>if</span> (codeGen-&gt;<span>doubleAlignOrFramePointerUsed</span>())</td>
      </tr>
      <tr>
        <td id="L6242" data-line-number="6242"></td>
        <td id="LC6242">    {</td>
      </tr>
      <tr>
        <td id="L6243" data-line-number="6243"></td>
        <td id="LC6243">        pushedCount += <span>1</span>; <span><span>//</span> pushed EBP (frame pointer)</span></td>
      </tr>
      <tr>
        <td id="L6244" data-line-number="6244"></td>
        <td id="LC6244">    }</td>
      </tr>
      <tr>
        <td id="L6245" data-line-number="6245"></td>
        <td id="LC6245">    pushedCount += <span>1</span>; <span><span>//</span> pushed PC (return address)</span></td>
      </tr>
      <tr>
        <td id="L6246" data-line-number="6246"></td>
        <td id="LC6246">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6247" data-line-number="6247"></td>
        <td id="LC6247">
</td>
      </tr>
      <tr>
        <td id="L6248" data-line-number="6248"></td>
        <td id="LC6248">    <span>noway_assert</span>(compLclFrameSize == (<span>unsigned</span>)-(stkOffs + (pushedCount * (<span>int</span>)TARGET_POINTER_SIZE)));</td>
      </tr>
      <tr>
        <td id="L6249" data-line-number="6249"></td>
        <td id="LC6249">}</td>
      </tr>
      <tr>
        <td id="L6250" data-line-number="6250"></td>
        <td id="LC6250">
</td>
      </tr>
      <tr>
        <td id="L6251" data-line-number="6251"></td>
        <td id="LC6251"><span>int</span> <span>Compiler::lvaAllocLocalAndSetVirtualOffset</span>(<span>unsigned</span> lclNum, <span>unsigned</span> size, <span>int</span> stkOffs)</td>
      </tr>
      <tr>
        <td id="L6252" data-line-number="6252"></td>
        <td id="LC6252">{</td>
      </tr>
      <tr>
        <td id="L6253" data-line-number="6253"></td>
        <td id="LC6253">    <span>noway_assert</span>(lclNum != BAD_VAR_NUM);</td>
      </tr>
      <tr>
        <td id="L6254" data-line-number="6254"></td>
        <td id="LC6254">
</td>
      </tr>
      <tr>
        <td id="L6255" data-line-number="6255"></td>
        <td id="LC6255">#<span>ifdef</span> TARGET_64BIT</td>
      </tr>
      <tr>
        <td id="L6256" data-line-number="6256"></td>
        <td id="LC6256">    <span><span>//</span> Before final frame layout, assume the worst case, that every &gt;=8 byte local will need</span></td>
      </tr>
      <tr>
        <td id="L6257" data-line-number="6257"></td>
        <td id="LC6257">    <span><span>//</span> maximum padding to be aligned. This is because we generate code based on the stack offset</span></td>
      </tr>
      <tr>
        <td id="L6258" data-line-number="6258"></td>
        <td id="LC6258">    <span><span>//</span> computed during tentative frame layout. These offsets cannot get bigger during final</span></td>
      </tr>
      <tr>
        <td id="L6259" data-line-number="6259"></td>
        <td id="LC6259">    <span><span>//</span> frame layout, as that would possibly require different code generation (for example,</span></td>
      </tr>
      <tr>
        <td id="L6260" data-line-number="6260"></td>
        <td id="LC6260">    <span><span>//</span> using a 4-byte offset instead of a 1-byte offset in an instruction). The offsets can get</span></td>
      </tr>
      <tr>
        <td id="L6261" data-line-number="6261"></td>
        <td id="LC6261">    <span><span>//</span> smaller. It is possible there is different alignment at the point locals are allocated</span></td>
      </tr>
      <tr>
        <td id="L6262" data-line-number="6262"></td>
        <td id="LC6262">    <span><span>//</span> between tentative and final frame layout which would introduce padding between locals</span></td>
      </tr>
      <tr>
        <td id="L6263" data-line-number="6263"></td>
        <td id="LC6263">    <span><span>//</span> and thus increase the offset (from the stack pointer) of one of the locals. Hence the</span></td>
      </tr>
      <tr>
        <td id="L6264" data-line-number="6264"></td>
        <td id="LC6264">    <span><span>//</span> need to assume the worst alignment before final frame layout.</span></td>
      </tr>
      <tr>
        <td id="L6265" data-line-number="6265"></td>
        <td id="LC6265">    <span><span>//</span> We could probably improve this by sorting all the objects by alignment,</span></td>
      </tr>
      <tr>
        <td id="L6266" data-line-number="6266"></td>
        <td id="LC6266">    <span><span>//</span> such that all 8 byte objects are together, 4 byte objects are together, etc., which</span></td>
      </tr>
      <tr>
        <td id="L6267" data-line-number="6267"></td>
        <td id="LC6267">    <span><span>//</span> would require at most one alignment padding per group.</span></td>
      </tr>
      <tr>
        <td id="L6268" data-line-number="6268"></td>
        <td id="LC6268">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6269" data-line-number="6269"></td>
        <td id="LC6269">    <span><span>//</span> TYP_SIMD structs locals have alignment preference given by getSIMDTypeAlignment() for</span></td>
      </tr>
      <tr>
        <td id="L6270" data-line-number="6270"></td>
        <td id="LC6270">    <span><span>//</span> better performance.</span></td>
      </tr>
      <tr>
        <td id="L6271" data-line-number="6271"></td>
        <td id="LC6271">    <span>if</span> ((size &gt;= <span>8</span>) &amp;&amp; ((lvaDoneFrameLayout != FINAL_FRAME_LAYOUT) || ((stkOffs % <span>8</span>) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6272" data-line-number="6272"></td>
        <td id="LC6272">#<span>if</span> defined(FEATURE_SIMD) &amp;&amp; ALIGN_SIMD_TYPES</td>
      </tr>
      <tr>
        <td id="L6273" data-line-number="6273"></td>
        <td id="LC6273">                        || <span>lclVarIsSIMDType</span>(lclNum)</td>
      </tr>
      <tr>
        <td id="L6274" data-line-number="6274"></td>
        <td id="LC6274">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6275" data-line-number="6275"></td>
        <td id="LC6275">                            ))</td>
      </tr>
      <tr>
        <td id="L6276" data-line-number="6276"></td>
        <td id="LC6276">    {</td>
      </tr>
      <tr>
        <td id="L6277" data-line-number="6277"></td>
        <td id="LC6277">        <span><span>//</span> Note that stack offsets are negative or equal to zero</span></td>
      </tr>
      <tr>
        <td id="L6278" data-line-number="6278"></td>
        <td id="LC6278">        <span>assert</span>(stkOffs &lt;= <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6279" data-line-number="6279"></td>
        <td id="LC6279">
</td>
      </tr>
      <tr>
        <td id="L6280" data-line-number="6280"></td>
        <td id="LC6280">        <span><span>//</span> alignment padding</span></td>
      </tr>
      <tr>
        <td id="L6281" data-line-number="6281"></td>
        <td id="LC6281">        <span>unsigned</span> pad = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6282" data-line-number="6282"></td>
        <td id="LC6282">#<span>if</span> defined(FEATURE_SIMD) &amp;&amp; ALIGN_SIMD_TYPES</td>
      </tr>
      <tr>
        <td id="L6283" data-line-number="6283"></td>
        <td id="LC6283">        <span>if</span> (<span>lclVarIsSIMDType</span>(lclNum) &amp;&amp; !<span>lvaIsImplicitByRefLocal</span>(lclNum))</td>
      </tr>
      <tr>
        <td id="L6284" data-line-number="6284"></td>
        <td id="LC6284">        {</td>
      </tr>
      <tr>
        <td id="L6285" data-line-number="6285"></td>
        <td id="LC6285">            <span>int</span> alignment = <span>getSIMDTypeAlignment</span>(lvaTable[lclNum].<span>lvType</span>);</td>
      </tr>
      <tr>
        <td id="L6286" data-line-number="6286"></td>
        <td id="LC6286">
</td>
      </tr>
      <tr>
        <td id="L6287" data-line-number="6287"></td>
        <td id="LC6287">            <span>if</span> (stkOffs % alignment != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6288" data-line-number="6288"></td>
        <td id="LC6288">            {</td>
      </tr>
      <tr>
        <td id="L6289" data-line-number="6289"></td>
        <td id="LC6289">                <span>if</span> (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6290" data-line-number="6290"></td>
        <td id="LC6290">                {</td>
      </tr>
      <tr>
        <td id="L6291" data-line-number="6291"></td>
        <td id="LC6291">                    pad = alignment - <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L6292" data-line-number="6292"></td>
        <td id="LC6292">                    <span><span>//</span> Note that all the objects will probably be misaligned, but we'll fix that in final layout.</span></td>
      </tr>
      <tr>
        <td id="L6293" data-line-number="6293"></td>
        <td id="LC6293">                }</td>
      </tr>
      <tr>
        <td id="L6294" data-line-number="6294"></td>
        <td id="LC6294">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L6295" data-line-number="6295"></td>
        <td id="LC6295">                {</td>
      </tr>
      <tr>
        <td id="L6296" data-line-number="6296"></td>
        <td id="LC6296">                    pad = alignment + (stkOffs % alignment); <span><span>//</span> +1 to +(alignment-1) bytes</span></td>
      </tr>
      <tr>
        <td id="L6297" data-line-number="6297"></td>
        <td id="LC6297">                }</td>
      </tr>
      <tr>
        <td id="L6298" data-line-number="6298"></td>
        <td id="LC6298">            }</td>
      </tr>
      <tr>
        <td id="L6299" data-line-number="6299"></td>
        <td id="LC6299">        }</td>
      </tr>
      <tr>
        <td id="L6300" data-line-number="6300"></td>
        <td id="LC6300">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L6301" data-line-number="6301"></td>
        <td id="LC6301">#<span>endif</span> <span><span>//</span> FEATURE_SIMD &amp;&amp; ALIGN_SIMD_TYPES</span></td>
      </tr>
      <tr>
        <td id="L6302" data-line-number="6302"></td>
        <td id="LC6302">        {</td>
      </tr>
      <tr>
        <td id="L6303" data-line-number="6303"></td>
        <td id="LC6303">            <span>if</span> (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6304" data-line-number="6304"></td>
        <td id="LC6304">            {</td>
      </tr>
      <tr>
        <td id="L6305" data-line-number="6305"></td>
        <td id="LC6305">                pad = <span>7</span>;</td>
      </tr>
      <tr>
        <td id="L6306" data-line-number="6306"></td>
        <td id="LC6306">                <span><span>//</span> Note that all the objects will probably be misaligned, but we'll fix that in final layout.</span></td>
      </tr>
      <tr>
        <td id="L6307" data-line-number="6307"></td>
        <td id="LC6307">            }</td>
      </tr>
      <tr>
        <td id="L6308" data-line-number="6308"></td>
        <td id="LC6308">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L6309" data-line-number="6309"></td>
        <td id="LC6309">            {</td>
      </tr>
      <tr>
        <td id="L6310" data-line-number="6310"></td>
        <td id="LC6310">                pad = <span>8</span> + (stkOffs % <span>8</span>); <span><span>//</span> +1 to +7 bytes</span></td>
      </tr>
      <tr>
        <td id="L6311" data-line-number="6311"></td>
        <td id="LC6311">            }</td>
      </tr>
      <tr>
        <td id="L6312" data-line-number="6312"></td>
        <td id="LC6312">        }</td>
      </tr>
      <tr>
        <td id="L6313" data-line-number="6313"></td>
        <td id="LC6313">        <span><span>//</span> Will the pad ever be anything except 4? Do we put smaller-than-4-sized objects on the stack?</span></td>
      </tr>
      <tr>
        <td id="L6314" data-line-number="6314"></td>
        <td id="LC6314">        <span>lvaIncrementFrameSize</span>(pad);</td>
      </tr>
      <tr>
        <td id="L6315" data-line-number="6315"></td>
        <td id="LC6315">        stkOffs -= pad;</td>
      </tr>
      <tr>
        <td id="L6316" data-line-number="6316"></td>
        <td id="LC6316">
</td>
      </tr>
      <tr>
        <td id="L6317" data-line-number="6317"></td>
        <td id="LC6317">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L6318" data-line-number="6318"></td>
        <td id="LC6318">        <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L6319" data-line-number="6319"></td>
        <td id="LC6319">        {</td>
      </tr>
      <tr>
        <td id="L6320" data-line-number="6320"></td>
        <td id="LC6320">            <span>printf</span>(<span><span>"</span>Pad <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6321" data-line-number="6321"></td>
        <td id="LC6321">            <span>gtDispLclVar</span>(lclNum, <span><span>/*</span>pad<span>*/</span></span> <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L6322" data-line-number="6322"></td>
        <td id="LC6322">            <span>printf</span>(<span><span>"</span>, size=%d, stkOffs=%c0x%x, pad=%d<span>\n</span><span>"</span></span>, size, stkOffs &lt; <span>0</span> ? <span><span>'</span>-<span>'</span></span> : <span><span>'</span>+<span>'</span></span>,</td>
      </tr>
      <tr>
        <td id="L6323" data-line-number="6323"></td>
        <td id="LC6323">                   stkOffs &lt; <span>0</span> ? -stkOffs : stkOffs, pad);</td>
      </tr>
      <tr>
        <td id="L6324" data-line-number="6324"></td>
        <td id="LC6324">        }</td>
      </tr>
      <tr>
        <td id="L6325" data-line-number="6325"></td>
        <td id="LC6325">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6326" data-line-number="6326"></td>
        <td id="LC6326">    }</td>
      </tr>
      <tr>
        <td id="L6327" data-line-number="6327"></td>
        <td id="LC6327">#<span>endif</span> <span><span>//</span> TARGET_64BIT</span></td>
      </tr>
      <tr>
        <td id="L6328" data-line-number="6328"></td>
        <td id="LC6328">
</td>
      </tr>
      <tr>
        <td id="L6329" data-line-number="6329"></td>
        <td id="LC6329">    <span><span>/*</span> Reserve space on the stack by bumping the frame size <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6330" data-line-number="6330"></td>
        <td id="LC6330">
</td>
      </tr>
      <tr>
        <td id="L6331" data-line-number="6331"></td>
        <td id="LC6331">    <span>lvaIncrementFrameSize</span>(size);</td>
      </tr>
      <tr>
        <td id="L6332" data-line-number="6332"></td>
        <td id="LC6332">    stkOffs -= size;</td>
      </tr>
      <tr>
        <td id="L6333" data-line-number="6333"></td>
        <td id="LC6333">    lvaTable[lclNum].<span>lvStkOffs</span> = stkOffs;</td>
      </tr>
      <tr>
        <td id="L6334" data-line-number="6334"></td>
        <td id="LC6334">
</td>
      </tr>
      <tr>
        <td id="L6335" data-line-number="6335"></td>
        <td id="LC6335">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L6336" data-line-number="6336"></td>
        <td id="LC6336">    <span>if</span> (verbose)</td>
      </tr>
      <tr>
        <td id="L6337" data-line-number="6337"></td>
        <td id="LC6337">    {</td>
      </tr>
      <tr>
        <td id="L6338" data-line-number="6338"></td>
        <td id="LC6338">        <span>printf</span>(<span><span>"</span>Assign <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6339" data-line-number="6339"></td>
        <td id="LC6339">        <span>gtDispLclVar</span>(lclNum, <span><span>/*</span>pad<span>*/</span></span> <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L6340" data-line-number="6340"></td>
        <td id="LC6340">        <span>printf</span>(<span><span>"</span>, size=%d, stkOffs=%c0x%x<span>\n</span><span>"</span></span>, size, stkOffs &lt; <span>0</span> ? <span><span>'</span>-<span>'</span></span> : <span><span>'</span>+<span>'</span></span>, stkOffs &lt; <span>0</span> ? -stkOffs : stkOffs);</td>
      </tr>
      <tr>
        <td id="L6341" data-line-number="6341"></td>
        <td id="LC6341">    }</td>
      </tr>
      <tr>
        <td id="L6342" data-line-number="6342"></td>
        <td id="LC6342">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6343" data-line-number="6343"></td>
        <td id="LC6343">
</td>
      </tr>
      <tr>
        <td id="L6344" data-line-number="6344"></td>
        <td id="LC6344">    <span>return</span> stkOffs;</td>
      </tr>
      <tr>
        <td id="L6345" data-line-number="6345"></td>
        <td id="LC6345">}</td>
      </tr>
      <tr>
        <td id="L6346" data-line-number="6346"></td>
        <td id="LC6346">
</td>
      </tr>
      <tr>
        <td id="L6347" data-line-number="6347"></td>
        <td id="LC6347">#<span>ifdef</span> TARGET_AMD64</td>
      </tr>
      <tr>
        <td id="L6348" data-line-number="6348"></td>
        <td id="LC6348"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L6349" data-line-number="6349"></td>
        <td id="LC6349"><span> *  lvaIsCalleeSavedIntRegCountEven() :  returns true if the number of integer registers</span></td>
      </tr>
      <tr>
        <td id="L6350" data-line-number="6350"></td>
        <td id="LC6350"><span> *  pushed onto stack is even including RBP if used as frame pointer</span></td>
      </tr>
      <tr>
        <td id="L6351" data-line-number="6351"></td>
        <td id="LC6351"><span> *</span></td>
      </tr>
      <tr>
        <td id="L6352" data-line-number="6352"></td>
        <td id="LC6352"><span> *  Note that this excludes return address (PC) pushed by caller.  To know whether</span></td>
      </tr>
      <tr>
        <td id="L6353" data-line-number="6353"></td>
        <td id="LC6353"><span> *  the SP offset after pushing integer registers is aligned, we need to take</span></td>
      </tr>
      <tr>
        <td id="L6354" data-line-number="6354"></td>
        <td id="LC6354"><span> *  negation of this routine.</span></td>
      </tr>
      <tr>
        <td id="L6355" data-line-number="6355"></td>
        <td id="LC6355"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6356" data-line-number="6356"></td>
        <td id="LC6356"><span>bool</span> <span>Compiler::lvaIsCalleeSavedIntRegCountEven</span>()</td>
      </tr>
      <tr>
        <td id="L6357" data-line-number="6357"></td>
        <td id="LC6357">{</td>
      </tr>
      <tr>
        <td id="L6358" data-line-number="6358"></td>
        <td id="LC6358">    <span>unsigned</span> regsPushed = compCalleeRegsPushed + (codeGen-&gt;<span>isFramePointerUsed</span>() ? <span>1</span> : <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6359" data-line-number="6359"></td>
        <td id="LC6359">    <span>return</span> (regsPushed % (<span>16</span> / REGSIZE_BYTES)) == <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6360" data-line-number="6360"></td>
        <td id="LC6360">}</td>
      </tr>
      <tr>
        <td id="L6361" data-line-number="6361"></td>
        <td id="LC6361">#<span>endif</span> <span><span>//</span> TARGET_AMD64</span></td>
      </tr>
      <tr>
        <td id="L6362" data-line-number="6362"></td>
        <td id="LC6362">
</td>
      </tr>
      <tr>
        <td id="L6363" data-line-number="6363"></td>
        <td id="LC6363"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L6364" data-line-number="6364"></td>
        <td id="LC6364"><span> *  lvaAlignFrame() :  After allocating everything on the frame, reserve any</span></td>
      </tr>
      <tr>
        <td id="L6365" data-line-number="6365"></td>
        <td id="LC6365"><span> *  extra space needed to keep the frame aligned</span></td>
      </tr>
      <tr>
        <td id="L6366" data-line-number="6366"></td>
        <td id="LC6366"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6367" data-line-number="6367"></td>
        <td id="LC6367"><span>void</span> <span>Compiler::lvaAlignFrame</span>()</td>
      </tr>
      <tr>
        <td id="L6368" data-line-number="6368"></td>
        <td id="LC6368">{</td>
      </tr>
      <tr>
        <td id="L6369" data-line-number="6369"></td>
        <td id="LC6369">#<span>if</span> defined(TARGET_AMD64)</td>
      </tr>
      <tr>
        <td id="L6370" data-line-number="6370"></td>
        <td id="LC6370">
</td>
      </tr>
      <tr>
        <td id="L6371" data-line-number="6371"></td>
        <td id="LC6371">    <span><span>//</span> Leaf frames do not need full alignment, but the unwind info is smaller if we</span></td>
      </tr>
      <tr>
        <td id="L6372" data-line-number="6372"></td>
        <td id="LC6372">    <span><span>//</span> are at least 8 byte aligned (and we assert as much)</span></td>
      </tr>
      <tr>
        <td id="L6373" data-line-number="6373"></td>
        <td id="LC6373">    <span>if</span> ((compLclFrameSize % <span>8</span>) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6374" data-line-number="6374"></td>
        <td id="LC6374">    {</td>
      </tr>
      <tr>
        <td id="L6375" data-line-number="6375"></td>
        <td id="LC6375">        <span>lvaIncrementFrameSize</span>(<span>8</span> - (compLclFrameSize % <span>8</span>));</td>
      </tr>
      <tr>
        <td id="L6376" data-line-number="6376"></td>
        <td id="LC6376">    }</td>
      </tr>
      <tr>
        <td id="L6377" data-line-number="6377"></td>
        <td id="LC6377">    <span>else</span> <span>if</span> (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6378" data-line-number="6378"></td>
        <td id="LC6378">    {</td>
      </tr>
      <tr>
        <td id="L6379" data-line-number="6379"></td>
        <td id="LC6379">        <span><span>//</span> If we are not doing final layout, we don't know the exact value of compLclFrameSize</span></td>
      </tr>
      <tr>
        <td id="L6380" data-line-number="6380"></td>
        <td id="LC6380">        <span><span>//</span> and thus do not know how much we will need to add in order to be aligned.</span></td>
      </tr>
      <tr>
        <td id="L6381" data-line-number="6381"></td>
        <td id="LC6381">        <span><span>//</span> We add 8 so compLclFrameSize is still a multiple of 8.</span></td>
      </tr>
      <tr>
        <td id="L6382" data-line-number="6382"></td>
        <td id="LC6382">        <span>lvaIncrementFrameSize</span>(<span>8</span>);</td>
      </tr>
      <tr>
        <td id="L6383" data-line-number="6383"></td>
        <td id="LC6383">    }</td>
      </tr>
      <tr>
        <td id="L6384" data-line-number="6384"></td>
        <td id="LC6384">    <span>assert</span>((compLclFrameSize % <span>8</span>) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6385" data-line-number="6385"></td>
        <td id="LC6385">
</td>
      </tr>
      <tr>
        <td id="L6386" data-line-number="6386"></td>
        <td id="LC6386">    <span><span>//</span> Ensure that the stack is always 16-byte aligned by grabbing an unused QWORD</span></td>
      </tr>
      <tr>
        <td id="L6387" data-line-number="6387"></td>
        <td id="LC6387">    <span><span>//</span> if needed, but off by 8 because of the return value.</span></td>
      </tr>
      <tr>
        <td id="L6388" data-line-number="6388"></td>
        <td id="LC6388">    <span><span>//</span> And don't forget that compCalleeRegsPused does *not* include RBP if we are</span></td>
      </tr>
      <tr>
        <td id="L6389" data-line-number="6389"></td>
        <td id="LC6389">    <span><span>//</span> using it as the frame pointer.</span></td>
      </tr>
      <tr>
        <td id="L6390" data-line-number="6390"></td>
        <td id="LC6390">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6391" data-line-number="6391"></td>
        <td id="LC6391">    <span>bool</span> regPushedCountAligned = <span>lvaIsCalleeSavedIntRegCountEven</span>();</td>
      </tr>
      <tr>
        <td id="L6392" data-line-number="6392"></td>
        <td id="LC6392">    <span>bool</span> lclFrameSizeAligned   = (compLclFrameSize % <span>16</span>) == <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6393" data-line-number="6393"></td>
        <td id="LC6393">
</td>
      </tr>
      <tr>
        <td id="L6394" data-line-number="6394"></td>
        <td id="LC6394">    <span><span>//</span> If this isn't the final frame layout, assume we have to push an extra QWORD</span></td>
      </tr>
      <tr>
        <td id="L6395" data-line-number="6395"></td>
        <td id="LC6395">    <span><span>//</span> Just so the offsets are true upper limits.</span></td>
      </tr>
      <tr>
        <td id="L6396" data-line-number="6396"></td>
        <td id="LC6396">    CLANG_FORMAT_COMMENT_ANCHOR;</td>
      </tr>
      <tr>
        <td id="L6397" data-line-number="6397"></td>
        <td id="LC6397">
</td>
      </tr>
      <tr>
        <td id="L6398" data-line-number="6398"></td>
        <td id="LC6398">#<span>ifdef</span> UNIX_AMD64_ABI</td>
      </tr>
      <tr>
        <td id="L6399" data-line-number="6399"></td>
        <td id="LC6399">    <span><span>//</span> The compNeedToAlignFrame flag  is indicating if there is a need to align the frame.</span></td>
      </tr>
      <tr>
        <td id="L6400" data-line-number="6400"></td>
        <td id="LC6400">    <span><span>//</span> On AMD64-Windows, if there are calls, 4 slots for the outgoing ars are allocated, except for</span></td>
      </tr>
      <tr>
        <td id="L6401" data-line-number="6401"></td>
        <td id="LC6401">    <span><span>//</span> FastTailCall. This slots makes the frame size non-zero, so alignment logic will be called.</span></td>
      </tr>
      <tr>
        <td id="L6402" data-line-number="6402"></td>
        <td id="LC6402">    <span><span>//</span> On AMD64-Unix, there are no such slots. There is a possibility to have calls in the method with frame size of 0.</span></td>
      </tr>
      <tr>
        <td id="L6403" data-line-number="6403"></td>
        <td id="LC6403">    <span><span>//</span> The frame alignment logic won't kick in. This flags takes care of the AMD64-Unix case by remembering that there</span></td>
      </tr>
      <tr>
        <td id="L6404" data-line-number="6404"></td>
        <td id="LC6404">    <span><span>//</span> are calls and making sure the frame alignment logic is executed.</span></td>
      </tr>
      <tr>
        <td id="L6405" data-line-number="6405"></td>
        <td id="LC6405">    <span>bool</span> stackNeedsAlignment = (compLclFrameSize != <span>0</span> || opts.<span>compNeedToAlignFrame</span>);</td>
      </tr>
      <tr>
        <td id="L6406" data-line-number="6406"></td>
        <td id="LC6406">#<span>else</span>  <span><span>//</span> !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L6407" data-line-number="6407"></td>
        <td id="LC6407">    <span>bool</span> stackNeedsAlignment = compLclFrameSize != <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6408" data-line-number="6408"></td>
        <td id="LC6408">#<span>endif</span> <span><span>//</span> !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L6409" data-line-number="6409"></td>
        <td id="LC6409">    <span>if</span> ((!codeGen-&gt;<span>isFramePointerUsed</span>() &amp;&amp; (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)) ||</td>
      </tr>
      <tr>
        <td id="L6410" data-line-number="6410"></td>
        <td id="LC6410">        (stackNeedsAlignment &amp;&amp; (regPushedCountAligned == lclFrameSizeAligned)))</td>
      </tr>
      <tr>
        <td id="L6411" data-line-number="6411"></td>
        <td id="LC6411">    {</td>
      </tr>
      <tr>
        <td id="L6412" data-line-number="6412"></td>
        <td id="LC6412">        <span>lvaIncrementFrameSize</span>(REGSIZE_BYTES);</td>
      </tr>
      <tr>
        <td id="L6413" data-line-number="6413"></td>
        <td id="LC6413">    }</td>
      </tr>
      <tr>
        <td id="L6414" data-line-number="6414"></td>
        <td id="LC6414">
</td>
      </tr>
      <tr>
        <td id="L6415" data-line-number="6415"></td>
        <td id="LC6415">#<span>elif</span> defined(TARGET_ARM64)</td>
      </tr>
      <tr>
        <td id="L6416" data-line-number="6416"></td>
        <td id="LC6416">
</td>
      </tr>
      <tr>
        <td id="L6417" data-line-number="6417"></td>
        <td id="LC6417">    <span><span>//</span> The stack on ARM64 must be 16 byte aligned.</span></td>
      </tr>
      <tr>
        <td id="L6418" data-line-number="6418"></td>
        <td id="LC6418">
</td>
      </tr>
      <tr>
        <td id="L6419" data-line-number="6419"></td>
        <td id="LC6419">    <span><span>//</span> First, align up to 8.</span></td>
      </tr>
      <tr>
        <td id="L6420" data-line-number="6420"></td>
        <td id="LC6420">    <span>if</span> ((compLclFrameSize % <span>8</span>) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6421" data-line-number="6421"></td>
        <td id="LC6421">    {</td>
      </tr>
      <tr>
        <td id="L6422" data-line-number="6422"></td>
        <td id="LC6422">        <span>lvaIncrementFrameSize</span>(<span>8</span> - (compLclFrameSize % <span>8</span>));</td>
      </tr>
      <tr>
        <td id="L6423" data-line-number="6423"></td>
        <td id="LC6423">    }</td>
      </tr>
      <tr>
        <td id="L6424" data-line-number="6424"></td>
        <td id="LC6424">    <span>else</span> <span>if</span> (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6425" data-line-number="6425"></td>
        <td id="LC6425">    {</td>
      </tr>
      <tr>
        <td id="L6426" data-line-number="6426"></td>
        <td id="LC6426">        <span><span>//</span> If we are not doing final layout, we don't know the exact value of compLclFrameSize</span></td>
      </tr>
      <tr>
        <td id="L6427" data-line-number="6427"></td>
        <td id="LC6427">        <span><span>//</span> and thus do not know how much we will need to add in order to be aligned.</span></td>
      </tr>
      <tr>
        <td id="L6428" data-line-number="6428"></td>
        <td id="LC6428">        <span><span>//</span> We add 8 so compLclFrameSize is still a multiple of 8.</span></td>
      </tr>
      <tr>
        <td id="L6429" data-line-number="6429"></td>
        <td id="LC6429">        <span>lvaIncrementFrameSize</span>(<span>8</span>);</td>
      </tr>
      <tr>
        <td id="L6430" data-line-number="6430"></td>
        <td id="LC6430">    }</td>
      </tr>
      <tr>
        <td id="L6431" data-line-number="6431"></td>
        <td id="LC6431">    <span>assert</span>((compLclFrameSize % <span>8</span>) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6432" data-line-number="6432"></td>
        <td id="LC6432">
</td>
      </tr>
      <tr>
        <td id="L6433" data-line-number="6433"></td>
        <td id="LC6433">    <span><span>//</span> Ensure that the stack is always 16-byte aligned by grabbing an unused QWORD</span></td>
      </tr>
      <tr>
        <td id="L6434" data-line-number="6434"></td>
        <td id="LC6434">    <span><span>//</span> if needed.</span></td>
      </tr>
      <tr>
        <td id="L6435" data-line-number="6435"></td>
        <td id="LC6435">    <span>bool</span> regPushedCountAligned = (compCalleeRegsPushed % (<span>16</span> / REGSIZE_BYTES)) == <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6436" data-line-number="6436"></td>
        <td id="LC6436">    <span>bool</span> lclFrameSizeAligned   = (compLclFrameSize % <span>16</span>) == <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6437" data-line-number="6437"></td>
        <td id="LC6437">
</td>
      </tr>
      <tr>
        <td id="L6438" data-line-number="6438"></td>
        <td id="LC6438">    <span><span>//</span> If this isn't the final frame layout, assume we have to push an extra QWORD</span></td>
      </tr>
      <tr>
        <td id="L6439" data-line-number="6439"></td>
        <td id="LC6439">    <span><span>//</span> Just so the offsets are true upper limits.</span></td>
      </tr>
      <tr>
        <td id="L6440" data-line-number="6440"></td>
        <td id="LC6440">    <span>if</span> ((lvaDoneFrameLayout != FINAL_FRAME_LAYOUT) || (regPushedCountAligned != lclFrameSizeAligned))</td>
      </tr>
      <tr>
        <td id="L6441" data-line-number="6441"></td>
        <td id="LC6441">    {</td>
      </tr>
      <tr>
        <td id="L6442" data-line-number="6442"></td>
        <td id="LC6442">        <span>lvaIncrementFrameSize</span>(REGSIZE_BYTES);</td>
      </tr>
      <tr>
        <td id="L6443" data-line-number="6443"></td>
        <td id="LC6443">    }</td>
      </tr>
      <tr>
        <td id="L6444" data-line-number="6444"></td>
        <td id="LC6444">
</td>
      </tr>
      <tr>
        <td id="L6445" data-line-number="6445"></td>
        <td id="LC6445">#<span>elif</span> defined(TARGET_ARM)</td>
      </tr>
      <tr>
        <td id="L6446" data-line-number="6446"></td>
        <td id="LC6446">
</td>
      </tr>
      <tr>
        <td id="L6447" data-line-number="6447"></td>
        <td id="LC6447">    <span><span>//</span> Ensure that stack offsets will be double-aligned by grabbing an unused DWORD if needed.</span></td>
      </tr>
      <tr>
        <td id="L6448" data-line-number="6448"></td>
        <td id="LC6448">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6449" data-line-number="6449"></td>
        <td id="LC6449">    <span>bool</span> lclFrameSizeAligned   = (compLclFrameSize % <span>sizeof</span>(<span>double</span>)) == <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6450" data-line-number="6450"></td>
        <td id="LC6450">    <span>bool</span> regPushedCountAligned = ((compCalleeRegsPushed + <span>genCountBits</span>(codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegs</span>(<span>true</span>))) %</td>
      </tr>
      <tr>
        <td id="L6451" data-line-number="6451"></td>
        <td id="LC6451">                                  (<span>sizeof</span>(<span>double</span>) / TARGET_POINTER_SIZE)) == <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6452" data-line-number="6452"></td>
        <td id="LC6452">
</td>
      </tr>
      <tr>
        <td id="L6453" data-line-number="6453"></td>
        <td id="LC6453">    <span>if</span> (regPushedCountAligned != lclFrameSizeAligned)</td>
      </tr>
      <tr>
        <td id="L6454" data-line-number="6454"></td>
        <td id="LC6454">    {</td>
      </tr>
      <tr>
        <td id="L6455" data-line-number="6455"></td>
        <td id="LC6455">        <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L6456" data-line-number="6456"></td>
        <td id="LC6456">    }</td>
      </tr>
      <tr>
        <td id="L6457" data-line-number="6457"></td>
        <td id="LC6457">
</td>
      </tr>
      <tr>
        <td id="L6458" data-line-number="6458"></td>
        <td id="LC6458">#<span>elif</span> defined(TARGET_X86)</td>
      </tr>
      <tr>
        <td id="L6459" data-line-number="6459"></td>
        <td id="LC6459">
</td>
      </tr>
      <tr>
        <td id="L6460" data-line-number="6460"></td>
        <td id="LC6460">#<span>if</span> DOUBLE_ALIGN</td>
      </tr>
      <tr>
        <td id="L6461" data-line-number="6461"></td>
        <td id="LC6461">    <span>if</span> (<span>genDoubleAlign</span>())</td>
      </tr>
      <tr>
        <td id="L6462" data-line-number="6462"></td>
        <td id="LC6462">    {</td>
      </tr>
      <tr>
        <td id="L6463" data-line-number="6463"></td>
        <td id="LC6463">        <span><span>//</span> Double Frame Alignement for x86 is handled in Compiler::lvaAssignVirtualFrameOffsetsToLocals()</span></td>
      </tr>
      <tr>
        <td id="L6464" data-line-number="6464"></td>
        <td id="LC6464">
</td>
      </tr>
      <tr>
        <td id="L6465" data-line-number="6465"></td>
        <td id="LC6465">        <span>if</span> (compLclFrameSize == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6466" data-line-number="6466"></td>
        <td id="LC6466">        {</td>
      </tr>
      <tr>
        <td id="L6467" data-line-number="6467"></td>
        <td id="LC6467">            <span><span>//</span> This can only happen with JitStress=1 or JitDoubleAlign=2</span></td>
      </tr>
      <tr>
        <td id="L6468" data-line-number="6468"></td>
        <td id="LC6468">            <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L6469" data-line-number="6469"></td>
        <td id="LC6469">        }</td>
      </tr>
      <tr>
        <td id="L6470" data-line-number="6470"></td>
        <td id="LC6470">    }</td>
      </tr>
      <tr>
        <td id="L6471" data-line-number="6471"></td>
        <td id="LC6471">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6472" data-line-number="6472"></td>
        <td id="LC6472">
</td>
      </tr>
      <tr>
        <td id="L6473" data-line-number="6473"></td>
        <td id="LC6473">    <span>if</span> (STACK_ALIGN &gt; REGSIZE_BYTES)</td>
      </tr>
      <tr>
        <td id="L6474" data-line-number="6474"></td>
        <td id="LC6474">    {</td>
      </tr>
      <tr>
        <td id="L6475" data-line-number="6475"></td>
        <td id="LC6475">        <span>if</span> (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6476" data-line-number="6476"></td>
        <td id="LC6476">        {</td>
      </tr>
      <tr>
        <td id="L6477" data-line-number="6477"></td>
        <td id="LC6477">            <span><span>//</span> If we are not doing final layout, we don't know the exact value of compLclFrameSize</span></td>
      </tr>
      <tr>
        <td id="L6478" data-line-number="6478"></td>
        <td id="LC6478">            <span><span>//</span> and thus do not know how much we will need to add in order to be aligned.</span></td>
      </tr>
      <tr>
        <td id="L6479" data-line-number="6479"></td>
        <td id="LC6479">            <span><span>//</span> We add the maximum pad that we could ever have (which is 12)</span></td>
      </tr>
      <tr>
        <td id="L6480" data-line-number="6480"></td>
        <td id="LC6480">            <span>lvaIncrementFrameSize</span>(STACK_ALIGN - REGSIZE_BYTES);</td>
      </tr>
      <tr>
        <td id="L6481" data-line-number="6481"></td>
        <td id="LC6481">        }</td>
      </tr>
      <tr>
        <td id="L6482" data-line-number="6482"></td>
        <td id="LC6482">
</td>
      </tr>
      <tr>
        <td id="L6483" data-line-number="6483"></td>
        <td id="LC6483">        <span><span>//</span> Align the stack with STACK_ALIGN value.</span></td>
      </tr>
      <tr>
        <td id="L6484" data-line-number="6484"></td>
        <td id="LC6484">        <span>int</span>  adjustFrameSize = compLclFrameSize;</td>
      </tr>
      <tr>
        <td id="L6485" data-line-number="6485"></td>
        <td id="LC6485">#<span>if</span> defined(UNIX_X86_ABI)</td>
      </tr>
      <tr>
        <td id="L6486" data-line-number="6486"></td>
        <td id="LC6486">        <span>bool</span> isEbpPushed     = codeGen-&gt;<span>isFramePointerUsed</span>();</td>
      </tr>
      <tr>
        <td id="L6487" data-line-number="6487"></td>
        <td id="LC6487">#<span>if</span> DOUBLE_ALIGN</td>
      </tr>
      <tr>
        <td id="L6488" data-line-number="6488"></td>
        <td id="LC6488">        isEbpPushed |= <span>genDoubleAlign</span>();</td>
      </tr>
      <tr>
        <td id="L6489" data-line-number="6489"></td>
        <td id="LC6489">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6490" data-line-number="6490"></td>
        <td id="LC6490">        <span><span>//</span> we need to consider spilled register(s) plus return address and/or EBP</span></td>
      </tr>
      <tr>
        <td id="L6491" data-line-number="6491"></td>
        <td id="LC6491">        <span>int</span> adjustCount = compCalleeRegsPushed + <span>1</span> + (isEbpPushed ? <span>1</span> : <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6492" data-line-number="6492"></td>
        <td id="LC6492">        adjustFrameSize += (adjustCount * REGSIZE_BYTES) % STACK_ALIGN;</td>
      </tr>
      <tr>
        <td id="L6493" data-line-number="6493"></td>
        <td id="LC6493">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6494" data-line-number="6494"></td>
        <td id="LC6494">        <span>if</span> ((adjustFrameSize % STACK_ALIGN) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6495" data-line-number="6495"></td>
        <td id="LC6495">        {</td>
      </tr>
      <tr>
        <td id="L6496" data-line-number="6496"></td>
        <td id="LC6496">            <span>lvaIncrementFrameSize</span>(STACK_ALIGN - (adjustFrameSize % STACK_ALIGN));</td>
      </tr>
      <tr>
        <td id="L6497" data-line-number="6497"></td>
        <td id="LC6497">        }</td>
      </tr>
      <tr>
        <td id="L6498" data-line-number="6498"></td>
        <td id="LC6498">    }</td>
      </tr>
      <tr>
        <td id="L6499" data-line-number="6499"></td>
        <td id="LC6499">
</td>
      </tr>
      <tr>
        <td id="L6500" data-line-number="6500"></td>
        <td id="LC6500">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L6501" data-line-number="6501"></td>
        <td id="LC6501">    <span>NYI</span>(<span><span>"</span>TARGET specific lvaAlignFrame<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6502" data-line-number="6502"></td>
        <td id="LC6502">#<span>endif</span> <span><span>//</span> !TARGET_AMD64</span></td>
      </tr>
      <tr>
        <td id="L6503" data-line-number="6503"></td>
        <td id="LC6503">}</td>
      </tr>
      <tr>
        <td id="L6504" data-line-number="6504"></td>
        <td id="LC6504">
</td>
      </tr>
      <tr>
        <td id="L6505" data-line-number="6505"></td>
        <td id="LC6505"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L6506" data-line-number="6506"></td>
        <td id="LC6506"><span> *  lvaAssignFrameOffsetsToPromotedStructs() :  Assign offsets to fields</span></td>
      </tr>
      <tr>
        <td id="L6507" data-line-number="6507"></td>
        <td id="LC6507"><span> *  within a promoted struct (worker for lvaAssignFrameOffsets).</span></td>
      </tr>
      <tr>
        <td id="L6508" data-line-number="6508"></td>
        <td id="LC6508"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6509" data-line-number="6509"></td>
        <td id="LC6509"><span>void</span> <span>Compiler::lvaAssignFrameOffsetsToPromotedStructs</span>()</td>
      </tr>
      <tr>
        <td id="L6510" data-line-number="6510"></td>
        <td id="LC6510">{</td>
      </tr>
      <tr>
        <td id="L6511" data-line-number="6511"></td>
        <td id="LC6511">    LclVarDsc* varDsc = lvaTable;</td>
      </tr>
      <tr>
        <td id="L6512" data-line-number="6512"></td>
        <td id="LC6512">    <span>for</span> (<span>unsigned</span> lclNum = <span>0</span>; lclNum &lt; lvaCount; lclNum++, varDsc++)</td>
      </tr>
      <tr>
        <td id="L6513" data-line-number="6513"></td>
        <td id="LC6513">    {</td>
      </tr>
      <tr>
        <td id="L6514" data-line-number="6514"></td>
        <td id="LC6514">        <span><span>//</span> For promoted struct fields that are params, we will</span></td>
      </tr>
      <tr>
        <td id="L6515" data-line-number="6515"></td>
        <td id="LC6515">        <span><span>//</span> assign their offsets in lvaAssignVirtualFrameOffsetToArg().</span></td>
      </tr>
      <tr>
        <td id="L6516" data-line-number="6516"></td>
        <td id="LC6516">        <span><span>//</span> This is not true for the System V systems since there is no</span></td>
      </tr>
      <tr>
        <td id="L6517" data-line-number="6517"></td>
        <td id="LC6517">        <span><span>//</span> outgoing args space. Assign the dependently promoted fields properly.</span></td>
      </tr>
      <tr>
        <td id="L6518" data-line-number="6518"></td>
        <td id="LC6518">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6519" data-line-number="6519"></td>
        <td id="LC6519">        <span>if</span> (varDsc-&gt;<span>lvIsStructField</span></td>
      </tr>
      <tr>
        <td id="L6520" data-line-number="6520"></td>
        <td id="LC6520">#<span>ifndef</span> UNIX_AMD64_ABI</td>
      </tr>
      <tr>
        <td id="L6521" data-line-number="6521"></td>
        <td id="LC6521">#<span>if</span> !defined(TARGET_ARM)</td>
      </tr>
      <tr>
        <td id="L6522" data-line-number="6522"></td>
        <td id="LC6522">            <span><span>//</span> ARM: lo/hi parts of a promoted long arg need to be updated.</span></td>
      </tr>
      <tr>
        <td id="L6523" data-line-number="6523"></td>
        <td id="LC6523">
</td>
      </tr>
      <tr>
        <td id="L6524" data-line-number="6524"></td>
        <td id="LC6524">            <span><span>//</span> For System V platforms there is no outgoing args space.</span></td>
      </tr>
      <tr>
        <td id="L6525" data-line-number="6525"></td>
        <td id="LC6525">            <span><span>//</span> A register passed struct arg is homed on the stack in a separate local var.</span></td>
      </tr>
      <tr>
        <td id="L6526" data-line-number="6526"></td>
        <td id="LC6526">            <span><span>//</span> The offset of these structs is already calculated in lvaAssignVirtualFrameOffsetToArg methos.</span></td>
      </tr>
      <tr>
        <td id="L6527" data-line-number="6527"></td>
        <td id="LC6527">            <span><span>//</span> Make sure the code below is not executed for these structs and the offset is not changed.</span></td>
      </tr>
      <tr>
        <td id="L6528" data-line-number="6528"></td>
        <td id="LC6528">            &amp;&amp; !varDsc-&gt;<span>lvIsParam</span></td>
      </tr>
      <tr>
        <td id="L6529" data-line-number="6529"></td>
        <td id="LC6529">#<span>endif</span> <span><span>//</span> !defined(TARGET_ARM)</span></td>
      </tr>
      <tr>
        <td id="L6530" data-line-number="6530"></td>
        <td id="LC6530">#<span>endif</span> <span><span>//</span> !UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L6531" data-line-number="6531"></td>
        <td id="LC6531">            )</td>
      </tr>
      <tr>
        <td id="L6532" data-line-number="6532"></td>
        <td id="LC6532">        {</td>
      </tr>
      <tr>
        <td id="L6533" data-line-number="6533"></td>
        <td id="LC6533">            LclVarDsc*       parentvarDsc  = &amp;lvaTable[varDsc-&gt;<span>lvParentLcl</span>];</td>
      </tr>
      <tr>
        <td id="L6534" data-line-number="6534"></td>
        <td id="LC6534">            lvaPromotionType promotionType = <span>lvaGetPromotionType</span>(parentvarDsc);</td>
      </tr>
      <tr>
        <td id="L6535" data-line-number="6535"></td>
        <td id="LC6535">
</td>
      </tr>
      <tr>
        <td id="L6536" data-line-number="6536"></td>
        <td id="LC6536">            <span>if</span> (promotionType == PROMOTION_TYPE_INDEPENDENT)</td>
      </tr>
      <tr>
        <td id="L6537" data-line-number="6537"></td>
        <td id="LC6537">            {</td>
      </tr>
      <tr>
        <td id="L6538" data-line-number="6538"></td>
        <td id="LC6538">                <span><span>//</span> The stack offset for these field locals must have been calculated</span></td>
      </tr>
      <tr>
        <td id="L6539" data-line-number="6539"></td>
        <td id="LC6539">                <span><span>//</span> by the normal frame offset assignment.</span></td>
      </tr>
      <tr>
        <td id="L6540" data-line-number="6540"></td>
        <td id="LC6540">                <span>continue</span>;</td>
      </tr>
      <tr>
        <td id="L6541" data-line-number="6541"></td>
        <td id="LC6541">            }</td>
      </tr>
      <tr>
        <td id="L6542" data-line-number="6542"></td>
        <td id="LC6542">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L6543" data-line-number="6543"></td>
        <td id="LC6543">            {</td>
      </tr>
      <tr>
        <td id="L6544" data-line-number="6544"></td>
        <td id="LC6544">                <span>noway_assert</span>(promotionType == PROMOTION_TYPE_DEPENDENT);</td>
      </tr>
      <tr>
        <td id="L6545" data-line-number="6545"></td>
        <td id="LC6545">                <span>noway_assert</span>(varDsc-&gt;<span>lvOnFrame</span>);</td>
      </tr>
      <tr>
        <td id="L6546" data-line-number="6546"></td>
        <td id="LC6546">                <span>if</span> (parentvarDsc-&gt;<span>lvOnFrame</span>)</td>
      </tr>
      <tr>
        <td id="L6547" data-line-number="6547"></td>
        <td id="LC6547">                {</td>
      </tr>
      <tr>
        <td id="L6548" data-line-number="6548"></td>
        <td id="LC6548">                    varDsc-&gt;<span>lvStkOffs</span> = parentvarDsc-&gt;<span>lvStkOffs</span> + varDsc-&gt;<span>lvFldOffset</span>;</td>
      </tr>
      <tr>
        <td id="L6549" data-line-number="6549"></td>
        <td id="LC6549">                }</td>
      </tr>
      <tr>
        <td id="L6550" data-line-number="6550"></td>
        <td id="LC6550">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L6551" data-line-number="6551"></td>
        <td id="LC6551">                {</td>
      </tr>
      <tr>
        <td id="L6552" data-line-number="6552"></td>
        <td id="LC6552">                    varDsc-&gt;<span>lvOnFrame</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L6553" data-line-number="6553"></td>
        <td id="LC6553">                    <span>noway_assert</span>(varDsc-&gt;<span>lvRefCnt</span>() == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6554" data-line-number="6554"></td>
        <td id="LC6554">                }</td>
      </tr>
      <tr>
        <td id="L6555" data-line-number="6555"></td>
        <td id="LC6555">            }</td>
      </tr>
      <tr>
        <td id="L6556" data-line-number="6556"></td>
        <td id="LC6556">        }</td>
      </tr>
      <tr>
        <td id="L6557" data-line-number="6557"></td>
        <td id="LC6557">    }</td>
      </tr>
      <tr>
        <td id="L6558" data-line-number="6558"></td>
        <td id="LC6558">}</td>
      </tr>
      <tr>
        <td id="L6559" data-line-number="6559"></td>
        <td id="LC6559">
</td>
      </tr>
      <tr>
        <td id="L6560" data-line-number="6560"></td>
        <td id="LC6560"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L6561" data-line-number="6561"></td>
        <td id="LC6561"><span> *  lvaAllocateTemps() :  Assign virtual offsets to temps (always negative).</span></td>
      </tr>
      <tr>
        <td id="L6562" data-line-number="6562"></td>
        <td id="LC6562"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6563" data-line-number="6563"></td>
        <td id="LC6563"><span>int</span> <span>Compiler::lvaAllocateTemps</span>(<span>int</span> stkOffs, <span>bool</span> mustDoubleAlign)</td>
      </tr>
      <tr>
        <td id="L6564" data-line-number="6564"></td>
        <td id="LC6564">{</td>
      </tr>
      <tr>
        <td id="L6565" data-line-number="6565"></td>
        <td id="LC6565">    <span>unsigned</span> spillTempSize = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6566" data-line-number="6566"></td>
        <td id="LC6566">
</td>
      </tr>
      <tr>
        <td id="L6567" data-line-number="6567"></td>
        <td id="LC6567">    <span>if</span> (lvaDoneFrameLayout == FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6568" data-line-number="6568"></td>
        <td id="LC6568">    {</td>
      </tr>
      <tr>
        <td id="L6569" data-line-number="6569"></td>
        <td id="LC6569">        <span>int</span> preSpillSize = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L6570" data-line-number="6570"></td>
        <td id="LC6570">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L6571" data-line-number="6571"></td>
        <td id="LC6571">        preSpillSize = <span>genCountBits</span>(codeGen-&gt;<span>regSet</span>.<span>rsMaskPreSpillRegs</span>(<span>true</span>)) * TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L6572" data-line-number="6572"></td>
        <td id="LC6572">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6573" data-line-number="6573"></td>
        <td id="LC6573">
</td>
      </tr>
      <tr>
        <td id="L6574" data-line-number="6574"></td>
        <td id="LC6574">        <span><span>/*</span> Allocate temps <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6575" data-line-number="6575"></td>
        <td id="LC6575">
</td>
      </tr>
      <tr>
        <td id="L6576" data-line-number="6576"></td>
        <td id="LC6576">        <span>assert</span>(codeGen-&gt;<span>regSet</span>.<span>tmpAllFree</span>());</td>
      </tr>
      <tr>
        <td id="L6577" data-line-number="6577"></td>
        <td id="LC6577">
</td>
      </tr>
      <tr>
        <td id="L6578" data-line-number="6578"></td>
        <td id="LC6578">        <span>for</span> (TempDsc* temp = codeGen-&gt;<span>regSet</span>.<span>tmpListBeg</span>(); temp != <span>nullptr</span>; temp = codeGen-&gt;<span>regSet</span>.<span>tmpListNxt</span>(temp))</td>
      </tr>
      <tr>
        <td id="L6579" data-line-number="6579"></td>
        <td id="LC6579">        {</td>
      </tr>
      <tr>
        <td id="L6580" data-line-number="6580"></td>
        <td id="LC6580">            var_types tempType = temp-&gt;<span>tdTempType</span>();</td>
      </tr>
      <tr>
        <td id="L6581" data-line-number="6581"></td>
        <td id="LC6581">            <span>unsigned</span>  size     = temp-&gt;<span>tdTempSize</span>();</td>
      </tr>
      <tr>
        <td id="L6582" data-line-number="6582"></td>
        <td id="LC6582">
</td>
      </tr>
      <tr>
        <td id="L6583" data-line-number="6583"></td>
        <td id="LC6583">            <span><span>/*</span> Figure out and record the stack offset of the temp <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6584" data-line-number="6584"></td>
        <td id="LC6584">
</td>
      </tr>
      <tr>
        <td id="L6585" data-line-number="6585"></td>
        <td id="LC6585">            <span><span>/*</span> Need to align the offset? <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6586" data-line-number="6586"></td>
        <td id="LC6586">            CLANG_FORMAT_COMMENT_ANCHOR;</td>
      </tr>
      <tr>
        <td id="L6587" data-line-number="6587"></td>
        <td id="LC6587">
</td>
      </tr>
      <tr>
        <td id="L6588" data-line-number="6588"></td>
        <td id="LC6588">#<span>ifdef</span> TARGET_64BIT</td>
      </tr>
      <tr>
        <td id="L6589" data-line-number="6589"></td>
        <td id="LC6589">            <span>if</span> (<span>varTypeIsGC</span>(tempType) &amp;&amp; ((stkOffs % TARGET_POINTER_SIZE) != <span>0</span>))</td>
      </tr>
      <tr>
        <td id="L6590" data-line-number="6590"></td>
        <td id="LC6590">            {</td>
      </tr>
      <tr>
        <td id="L6591" data-line-number="6591"></td>
        <td id="LC6591">                <span><span>//</span> Calculate 'pad' as the number of bytes to align up 'stkOffs' to be a multiple of TARGET_POINTER_SIZE</span></td>
      </tr>
      <tr>
        <td id="L6592" data-line-number="6592"></td>
        <td id="LC6592">                <span><span>//</span> In practice this is really just a fancy way of writing 4. (as all stack locations are at least 4-byte</span></td>
      </tr>
      <tr>
        <td id="L6593" data-line-number="6593"></td>
        <td id="LC6593">                <span><span>//</span> aligned). Note stkOffs is always negative, so (stkOffs % TARGET_POINTER_SIZE) yields a negative</span></td>
      </tr>
      <tr>
        <td id="L6594" data-line-number="6594"></td>
        <td id="LC6594">                <span><span>//</span> value.</span></td>
      </tr>
      <tr>
        <td id="L6595" data-line-number="6595"></td>
        <td id="LC6595">                <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L6596" data-line-number="6596"></td>
        <td id="LC6596">                <span>int</span> alignPad = (<span>int</span>)<span>AlignmentPad</span>((<span>unsigned</span>)-stkOffs, TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L6597" data-line-number="6597"></td>
        <td id="LC6597">
</td>
      </tr>
      <tr>
        <td id="L6598" data-line-number="6598"></td>
        <td id="LC6598">                spillTempSize += alignPad;</td>
      </tr>
      <tr>
        <td id="L6599" data-line-number="6599"></td>
        <td id="LC6599">                <span>lvaIncrementFrameSize</span>(alignPad);</td>
      </tr>
      <tr>
        <td id="L6600" data-line-number="6600"></td>
        <td id="LC6600">                stkOffs -= alignPad;</td>
      </tr>
      <tr>
        <td id="L6601" data-line-number="6601"></td>
        <td id="LC6601">
</td>
      </tr>
      <tr>
        <td id="L6602" data-line-number="6602"></td>
        <td id="LC6602">                <span>noway_assert</span>((stkOffs % TARGET_POINTER_SIZE) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6603" data-line-number="6603"></td>
        <td id="LC6603">            }</td>
      </tr>
      <tr>
        <td id="L6604" data-line-number="6604"></td>
        <td id="LC6604">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6605" data-line-number="6605"></td>
        <td id="LC6605">
</td>
      </tr>
      <tr>
        <td id="L6606" data-line-number="6606"></td>
        <td id="LC6606">            <span>if</span> (mustDoubleAlign &amp;&amp; (tempType == TYP_DOUBLE)) <span><span>//</span> Align doubles for x86 and ARM</span></td>
      </tr>
      <tr>
        <td id="L6607" data-line-number="6607"></td>
        <td id="LC6607">            {</td>
      </tr>
      <tr>
        <td id="L6608" data-line-number="6608"></td>
        <td id="LC6608">                <span>noway_assert</span>((compLclFrameSize % TARGET_POINTER_SIZE) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6609" data-line-number="6609"></td>
        <td id="LC6609">
</td>
      </tr>
      <tr>
        <td id="L6610" data-line-number="6610"></td>
        <td id="LC6610">                <span>if</span> (((stkOffs + preSpillSize) % (<span>2</span> * TARGET_POINTER_SIZE)) != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6611" data-line-number="6611"></td>
        <td id="LC6611">                {</td>
      </tr>
      <tr>
        <td id="L6612" data-line-number="6612"></td>
        <td id="LC6612">                    spillTempSize += TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L6613" data-line-number="6613"></td>
        <td id="LC6613">                    <span>lvaIncrementFrameSize</span>(TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L6614" data-line-number="6614"></td>
        <td id="LC6614">                    stkOffs -= TARGET_POINTER_SIZE;</td>
      </tr>
      <tr>
        <td id="L6615" data-line-number="6615"></td>
        <td id="LC6615">                }</td>
      </tr>
      <tr>
        <td id="L6616" data-line-number="6616"></td>
        <td id="LC6616">                <span><span>//</span> We should now have a double-aligned (stkOffs+preSpillSize)</span></td>
      </tr>
      <tr>
        <td id="L6617" data-line-number="6617"></td>
        <td id="LC6617">                <span>noway_assert</span>(((stkOffs + preSpillSize) % (<span>2</span> * TARGET_POINTER_SIZE)) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L6618" data-line-number="6618"></td>
        <td id="LC6618">            }</td>
      </tr>
      <tr>
        <td id="L6619" data-line-number="6619"></td>
        <td id="LC6619">
</td>
      </tr>
      <tr>
        <td id="L6620" data-line-number="6620"></td>
        <td id="LC6620">            spillTempSize += size;</td>
      </tr>
      <tr>
        <td id="L6621" data-line-number="6621"></td>
        <td id="LC6621">            <span>lvaIncrementFrameSize</span>(size);</td>
      </tr>
      <tr>
        <td id="L6622" data-line-number="6622"></td>
        <td id="LC6622">            stkOffs -= size;</td>
      </tr>
      <tr>
        <td id="L6623" data-line-number="6623"></td>
        <td id="LC6623">            temp-&gt;<span>tdSetTempOffs</span>(stkOffs);</td>
      </tr>
      <tr>
        <td id="L6624" data-line-number="6624"></td>
        <td id="LC6624">        }</td>
      </tr>
      <tr>
        <td id="L6625" data-line-number="6625"></td>
        <td id="LC6625">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L6626" data-line-number="6626"></td>
        <td id="LC6626">        <span><span>//</span> Only required for the ARM platform that we have an accurate estimate for the spillTempSize</span></td>
      </tr>
      <tr>
        <td id="L6627" data-line-number="6627"></td>
        <td id="LC6627">        <span>noway_assert</span>(spillTempSize &lt;= <span>lvaGetMaxSpillTempSize</span>());</td>
      </tr>
      <tr>
        <td id="L6628" data-line-number="6628"></td>
        <td id="LC6628">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6629" data-line-number="6629"></td>
        <td id="LC6629">    }</td>
      </tr>
      <tr>
        <td id="L6630" data-line-number="6630"></td>
        <td id="LC6630">    <span>else</span> <span><span>//</span> We haven't run codegen, so there are no Spill temps yet!</span></td>
      </tr>
      <tr>
        <td id="L6631" data-line-number="6631"></td>
        <td id="LC6631">    {</td>
      </tr>
      <tr>
        <td id="L6632" data-line-number="6632"></td>
        <td id="LC6632">        <span>unsigned</span> size = <span>lvaGetMaxSpillTempSize</span>();</td>
      </tr>
      <tr>
        <td id="L6633" data-line-number="6633"></td>
        <td id="LC6633">
</td>
      </tr>
      <tr>
        <td id="L6634" data-line-number="6634"></td>
        <td id="LC6634">        <span>lvaIncrementFrameSize</span>(size);</td>
      </tr>
      <tr>
        <td id="L6635" data-line-number="6635"></td>
        <td id="LC6635">        stkOffs -= size;</td>
      </tr>
      <tr>
        <td id="L6636" data-line-number="6636"></td>
        <td id="LC6636">    }</td>
      </tr>
      <tr>
        <td id="L6637" data-line-number="6637"></td>
        <td id="LC6637">
</td>
      </tr>
      <tr>
        <td id="L6638" data-line-number="6638"></td>
        <td id="LC6638">    <span>return</span> stkOffs;</td>
      </tr>
      <tr>
        <td id="L6639" data-line-number="6639"></td>
        <td id="LC6639">}</td>
      </tr>
      <tr>
        <td id="L6640" data-line-number="6640"></td>
        <td id="LC6640">
</td>
      </tr>
      <tr>
        <td id="L6641" data-line-number="6641"></td>
        <td id="LC6641">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L6642" data-line-number="6642"></td>
        <td id="LC6642">
</td>
      </tr>
      <tr>
        <td id="L6643" data-line-number="6643"></td>
        <td id="LC6643"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L6644" data-line-number="6644"></td>
        <td id="LC6644"><span> *</span></td>
      </tr>
      <tr>
        <td id="L6645" data-line-number="6645"></td>
        <td id="LC6645"><span> *  Dump the register a local is in right now. It is only the current location, since the location changes and it</span></td>
      </tr>
      <tr>
        <td id="L6646" data-line-number="6646"></td>
        <td id="LC6646"><span> *  is updated throughout code generation based on LSRA register assignments.</span></td>
      </tr>
      <tr>
        <td id="L6647" data-line-number="6647"></td>
        <td id="LC6647"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6648" data-line-number="6648"></td>
        <td id="LC6648">
</td>
      </tr>
      <tr>
        <td id="L6649" data-line-number="6649"></td>
        <td id="LC6649"><span>void</span> <span>Compiler::lvaDumpRegLocation</span>(<span>unsigned</span> lclNum)</td>
      </tr>
      <tr>
        <td id="L6650" data-line-number="6650"></td>
        <td id="LC6650">{</td>
      </tr>
      <tr>
        <td id="L6651" data-line-number="6651"></td>
        <td id="LC6651">    LclVarDsc* varDsc = lvaTable + lclNum;</td>
      </tr>
      <tr>
        <td id="L6652" data-line-number="6652"></td>
        <td id="LC6652">
</td>
      </tr>
      <tr>
        <td id="L6653" data-line-number="6653"></td>
        <td id="LC6653">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L6654" data-line-number="6654"></td>
        <td id="LC6654">    <span>if</span> (varDsc-&gt;<span>TypeGet</span>() == TYP_DOUBLE)</td>
      </tr>
      <tr>
        <td id="L6655" data-line-number="6655"></td>
        <td id="LC6655">    {</td>
      </tr>
      <tr>
        <td id="L6656" data-line-number="6656"></td>
        <td id="LC6656">        <span><span>//</span> The assigned registers are `lvRegNum:RegNext(lvRegNum)`</span></td>
      </tr>
      <tr>
        <td id="L6657" data-line-number="6657"></td>
        <td id="LC6657">        <span>printf</span>(<span><span>"</span>%3s:%-3s    <span>"</span></span>, <span>getRegName</span>(varDsc-&gt;<span>GetRegNum</span>()), <span>getRegName</span>(<span>REG_NEXT</span>(varDsc-&gt;<span>GetRegNum</span>())));</td>
      </tr>
      <tr>
        <td id="L6658" data-line-number="6658"></td>
        <td id="LC6658">    }</td>
      </tr>
      <tr>
        <td id="L6659" data-line-number="6659"></td>
        <td id="LC6659">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L6660" data-line-number="6660"></td>
        <td id="LC6660">#<span>endif</span> <span><span>//</span> TARGET_ARM</span></td>
      </tr>
      <tr>
        <td id="L6661" data-line-number="6661"></td>
        <td id="LC6661">    {</td>
      </tr>
      <tr>
        <td id="L6662" data-line-number="6662"></td>
        <td id="LC6662">        <span>printf</span>(<span><span>"</span>%3s        <span>"</span></span>, <span>getRegName</span>(varDsc-&gt;<span>GetRegNum</span>()));</td>
      </tr>
      <tr>
        <td id="L6663" data-line-number="6663"></td>
        <td id="LC6663">    }</td>
      </tr>
      <tr>
        <td id="L6664" data-line-number="6664"></td>
        <td id="LC6664">}</td>
      </tr>
      <tr>
        <td id="L6665" data-line-number="6665"></td>
        <td id="LC6665">
</td>
      </tr>
      <tr>
        <td id="L6666" data-line-number="6666"></td>
        <td id="LC6666"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L6667" data-line-number="6667"></td>
        <td id="LC6667"><span> *</span></td>
      </tr>
      <tr>
        <td id="L6668" data-line-number="6668"></td>
        <td id="LC6668"><span> *  Dump the frame location assigned to a local.</span></td>
      </tr>
      <tr>
        <td id="L6669" data-line-number="6669"></td>
        <td id="LC6669"><span> *  It's the home location, even though the variable doesn't always live</span></td>
      </tr>
      <tr>
        <td id="L6670" data-line-number="6670"></td>
        <td id="LC6670"><span> *  in its home location.</span></td>
      </tr>
      <tr>
        <td id="L6671" data-line-number="6671"></td>
        <td id="LC6671"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6672" data-line-number="6672"></td>
        <td id="LC6672">
</td>
      </tr>
      <tr>
        <td id="L6673" data-line-number="6673"></td>
        <td id="LC6673"><span>void</span> <span>Compiler::lvaDumpFrameLocation</span>(<span>unsigned</span> lclNum)</td>
      </tr>
      <tr>
        <td id="L6674" data-line-number="6674"></td>
        <td id="LC6674">{</td>
      </tr>
      <tr>
        <td id="L6675" data-line-number="6675"></td>
        <td id="LC6675">    <span>int</span>       offset;</td>
      </tr>
      <tr>
        <td id="L6676" data-line-number="6676"></td>
        <td id="LC6676">    regNumber baseReg;</td>
      </tr>
      <tr>
        <td id="L6677" data-line-number="6677"></td>
        <td id="LC6677">
</td>
      </tr>
      <tr>
        <td id="L6678" data-line-number="6678"></td>
        <td id="LC6678">#<span>ifdef</span> TARGET_ARM</td>
      </tr>
      <tr>
        <td id="L6679" data-line-number="6679"></td>
        <td id="LC6679">    offset = <span>lvaFrameAddress</span>(lclNum, compLocallocUsed, &amp;baseReg, <span>0</span>, <span><span>/*</span> isFloatUsage <span>*/</span></span> <span>false</span>);</td>
      </tr>
      <tr>
        <td id="L6680" data-line-number="6680"></td>
        <td id="LC6680">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L6681" data-line-number="6681"></td>
        <td id="LC6681">    <span>bool</span> EBPbased;</td>
      </tr>
      <tr>
        <td id="L6682" data-line-number="6682"></td>
        <td id="LC6682">    offset  = <span>lvaFrameAddress</span>(lclNum, &amp;EBPbased);</td>
      </tr>
      <tr>
        <td id="L6683" data-line-number="6683"></td>
        <td id="LC6683">    baseReg = EBPbased ? REG_FPBASE : REG_SPBASE;</td>
      </tr>
      <tr>
        <td id="L6684" data-line-number="6684"></td>
        <td id="LC6684">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L6685" data-line-number="6685"></td>
        <td id="LC6685">
</td>
      </tr>
      <tr>
        <td id="L6686" data-line-number="6686"></td>
        <td id="LC6686">    <span>printf</span>(<span><span>"</span>[%2s%1s0x%02X]  <span>"</span></span>, <span>getRegName</span>(baseReg), (offset &lt; <span>0</span> ? <span><span>"</span>-<span>"</span></span> : <span><span>"</span>+<span>"</span></span>), (offset &lt; <span>0</span> ? -offset : offset));</td>
      </tr>
      <tr>
        <td id="L6687" data-line-number="6687"></td>
        <td id="LC6687">}</td>
      </tr>
      <tr>
        <td id="L6688" data-line-number="6688"></td>
        <td id="LC6688">
</td>
      </tr>
      <tr>
        <td id="L6689" data-line-number="6689"></td>
        <td id="LC6689"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L6690" data-line-number="6690"></td>
        <td id="LC6690"><span> *</span></td>
      </tr>
      <tr>
        <td id="L6691" data-line-number="6691"></td>
        <td id="LC6691"><span> *  dump a single lvaTable entry</span></td>
      </tr>
      <tr>
        <td id="L6692" data-line-number="6692"></td>
        <td id="LC6692"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6693" data-line-number="6693"></td>
        <td id="LC6693">
</td>
      </tr>
      <tr>
        <td id="L6694" data-line-number="6694"></td>
        <td id="LC6694"><span>void</span> <span>Compiler::lvaDumpEntry</span>(<span>unsigned</span> lclNum, FrameLayoutState curState, <span>size_t</span> refCntWtdWidth)</td>
      </tr>
      <tr>
        <td id="L6695" data-line-number="6695"></td>
        <td id="LC6695">{</td>
      </tr>
      <tr>
        <td id="L6696" data-line-number="6696"></td>
        <td id="LC6696">    LclVarDsc* varDsc = lvaTable + lclNum;</td>
      </tr>
      <tr>
        <td id="L6697" data-line-number="6697"></td>
        <td id="LC6697">    var_types  type   = varDsc-&gt;<span>TypeGet</span>();</td>
      </tr>
      <tr>
        <td id="L6698" data-line-number="6698"></td>
        <td id="LC6698">
</td>
      </tr>
      <tr>
        <td id="L6699" data-line-number="6699"></td>
        <td id="LC6699">    <span>if</span> (curState == INITIAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6700" data-line-number="6700"></td>
        <td id="LC6700">    {</td>
      </tr>
      <tr>
        <td id="L6701" data-line-number="6701"></td>
        <td id="LC6701">        <span>printf</span>(<span><span>"</span>;  <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6702" data-line-number="6702"></td>
        <td id="LC6702">        <span>gtDispLclVar</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L6703" data-line-number="6703"></td>
        <td id="LC6703">
</td>
      </tr>
      <tr>
        <td id="L6704" data-line-number="6704"></td>
        <td id="LC6704">        <span>printf</span>(<span><span>"</span> %7s <span>"</span></span>, <span>varTypeName</span>(type));</td>
      </tr>
      <tr>
        <td id="L6705" data-line-number="6705"></td>
        <td id="LC6705">        <span>if</span> (<span>genTypeSize</span>(type) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6706" data-line-number="6706"></td>
        <td id="LC6706">        {</td>
      </tr>
      <tr>
        <td id="L6707" data-line-number="6707"></td>
        <td id="LC6707">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L6708" data-line-number="6708"></td>
        <td id="LC6708">            <span>if</span> (lclNum == lvaOutgoingArgSpaceVar)</td>
      </tr>
      <tr>
        <td id="L6709" data-line-number="6709"></td>
        <td id="LC6709">            {</td>
      </tr>
      <tr>
        <td id="L6710" data-line-number="6710"></td>
        <td id="LC6710">                <span><span>//</span> Since lvaOutgoingArgSpaceSize is a PhasedVar we can't read it for Dumping until</span></td>
      </tr>
      <tr>
        <td id="L6711" data-line-number="6711"></td>
        <td id="LC6711">                <span><span>//</span> after we set it to something.</span></td>
      </tr>
      <tr>
        <td id="L6712" data-line-number="6712"></td>
        <td id="LC6712">                <span>if</span> (lvaOutgoingArgSpaceSize.<span>HasFinalValue</span>())</td>
      </tr>
      <tr>
        <td id="L6713" data-line-number="6713"></td>
        <td id="LC6713">                {</td>
      </tr>
      <tr>
        <td id="L6714" data-line-number="6714"></td>
        <td id="LC6714">                    <span><span>//</span> A PhasedVar&lt;T&gt; can't be directly used as an arg to a variadic function</span></td>
      </tr>
      <tr>
        <td id="L6715" data-line-number="6715"></td>
        <td id="LC6715">                    <span>unsigned</span> value = lvaOutgoingArgSpaceSize;</td>
      </tr>
      <tr>
        <td id="L6716" data-line-number="6716"></td>
        <td id="LC6716">                    <span>printf</span>(<span><span>"</span>(%2d) <span>"</span></span>, value);</td>
      </tr>
      <tr>
        <td id="L6717" data-line-number="6717"></td>
        <td id="LC6717">                }</td>
      </tr>
      <tr>
        <td id="L6718" data-line-number="6718"></td>
        <td id="LC6718">                <span>else</span></td>
      </tr>
      <tr>
        <td id="L6719" data-line-number="6719"></td>
        <td id="LC6719">                {</td>
      </tr>
      <tr>
        <td id="L6720" data-line-number="6720"></td>
        <td id="LC6720">                    <span>printf</span>(<span><span>"</span>(na) <span>"</span></span>); <span><span>//</span> The value hasn't yet been determined</span></td>
      </tr>
      <tr>
        <td id="L6721" data-line-number="6721"></td>
        <td id="LC6721">                }</td>
      </tr>
      <tr>
        <td id="L6722" data-line-number="6722"></td>
        <td id="LC6722">            }</td>
      </tr>
      <tr>
        <td id="L6723" data-line-number="6723"></td>
        <td id="LC6723">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L6724" data-line-number="6724"></td>
        <td id="LC6724">#<span>endif</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L6725" data-line-number="6725"></td>
        <td id="LC6725">            {</td>
      </tr>
      <tr>
        <td id="L6726" data-line-number="6726"></td>
        <td id="LC6726">                <span>printf</span>(<span><span>"</span>(%2d) <span>"</span></span>, <span>lvaLclSize</span>(lclNum));</td>
      </tr>
      <tr>
        <td id="L6727" data-line-number="6727"></td>
        <td id="LC6727">            }</td>
      </tr>
      <tr>
        <td id="L6728" data-line-number="6728"></td>
        <td id="LC6728">        }</td>
      </tr>
      <tr>
        <td id="L6729" data-line-number="6729"></td>
        <td id="LC6729">    }</td>
      </tr>
      <tr>
        <td id="L6730" data-line-number="6730"></td>
        <td id="LC6730">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L6731" data-line-number="6731"></td>
        <td id="LC6731">    {</td>
      </tr>
      <tr>
        <td id="L6732" data-line-number="6732"></td>
        <td id="LC6732">        <span>if</span> (varDsc-&gt;<span>lvRefCnt</span>() == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6733" data-line-number="6733"></td>
        <td id="LC6733">        {</td>
      </tr>
      <tr>
        <td id="L6734" data-line-number="6734"></td>
        <td id="LC6734">            <span><span>//</span> Print this with a special indicator that the variable is unused. Even though the</span></td>
      </tr>
      <tr>
        <td id="L6735" data-line-number="6735"></td>
        <td id="LC6735">            <span><span>//</span> variable itself is unused, it might be a struct that is promoted, so seeing it</span></td>
      </tr>
      <tr>
        <td id="L6736" data-line-number="6736"></td>
        <td id="LC6736">            <span><span>//</span> can be useful when looking at the promoted struct fields. It's also weird to see</span></td>
      </tr>
      <tr>
        <td id="L6737" data-line-number="6737"></td>
        <td id="LC6737">            <span><span>//</span> missing var numbers if these aren't printed.</span></td>
      </tr>
      <tr>
        <td id="L6738" data-line-number="6738"></td>
        <td id="LC6738">            <span>printf</span>(<span><span>"</span>;* <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6739" data-line-number="6739"></td>
        <td id="LC6739">        }</td>
      </tr>
      <tr>
        <td id="L6740" data-line-number="6740"></td>
        <td id="LC6740">#<span>if</span> FEATURE_FIXED_OUT_ARGS</td>
      </tr>
      <tr>
        <td id="L6741" data-line-number="6741"></td>
        <td id="LC6741">        <span><span>//</span> Since lvaOutgoingArgSpaceSize is a PhasedVar we can't read it for Dumping until</span></td>
      </tr>
      <tr>
        <td id="L6742" data-line-number="6742"></td>
        <td id="LC6742">        <span><span>//</span> after we set it to something.</span></td>
      </tr>
      <tr>
        <td id="L6743" data-line-number="6743"></td>
        <td id="LC6743">        <span>else</span> <span>if</span> ((lclNum == lvaOutgoingArgSpaceVar) &amp;&amp; lvaOutgoingArgSpaceSize.<span>HasFinalValue</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L6744" data-line-number="6744"></td>
        <td id="LC6744">                 (lvaOutgoingArgSpaceSize == <span>0</span>))</td>
      </tr>
      <tr>
        <td id="L6745" data-line-number="6745"></td>
        <td id="LC6745">        {</td>
      </tr>
      <tr>
        <td id="L6746" data-line-number="6746"></td>
        <td id="LC6746">            <span><span>//</span> Similar to above; print this anyway.</span></td>
      </tr>
      <tr>
        <td id="L6747" data-line-number="6747"></td>
        <td id="LC6747">            <span>printf</span>(<span><span>"</span>;# <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6748" data-line-number="6748"></td>
        <td id="LC6748">        }</td>
      </tr>
      <tr>
        <td id="L6749" data-line-number="6749"></td>
        <td id="LC6749">#<span>endif</span> <span><span>//</span> FEATURE_FIXED_OUT_ARGS</span></td>
      </tr>
      <tr>
        <td id="L6750" data-line-number="6750"></td>
        <td id="LC6750">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L6751" data-line-number="6751"></td>
        <td id="LC6751">        {</td>
      </tr>
      <tr>
        <td id="L6752" data-line-number="6752"></td>
        <td id="LC6752">            <span>printf</span>(<span><span>"</span>;  <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6753" data-line-number="6753"></td>
        <td id="LC6753">        }</td>
      </tr>
      <tr>
        <td id="L6754" data-line-number="6754"></td>
        <td id="LC6754">
</td>
      </tr>
      <tr>
        <td id="L6755" data-line-number="6755"></td>
        <td id="LC6755">        <span>gtDispLclVar</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L6756" data-line-number="6756"></td>
        <td id="LC6756">
</td>
      </tr>
      <tr>
        <td id="L6757" data-line-number="6757"></td>
        <td id="LC6757">        <span>printf</span>(<span><span>"</span>[V%02u<span>"</span></span>, lclNum);</td>
      </tr>
      <tr>
        <td id="L6758" data-line-number="6758"></td>
        <td id="LC6758">        <span>if</span> (varDsc-&gt;<span>lvTracked</span>)</td>
      </tr>
      <tr>
        <td id="L6759" data-line-number="6759"></td>
        <td id="LC6759">        {</td>
      </tr>
      <tr>
        <td id="L6760" data-line-number="6760"></td>
        <td id="LC6760">            <span>printf</span>(<span><span>"</span>,T%02u]<span>"</span></span>, varDsc-&gt;<span>lvVarIndex</span>);</td>
      </tr>
      <tr>
        <td id="L6761" data-line-number="6761"></td>
        <td id="LC6761">        }</td>
      </tr>
      <tr>
        <td id="L6762" data-line-number="6762"></td>
        <td id="LC6762">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L6763" data-line-number="6763"></td>
        <td id="LC6763">        {</td>
      </tr>
      <tr>
        <td id="L6764" data-line-number="6764"></td>
        <td id="LC6764">            <span>printf</span>(<span><span>"</span>    ]<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6765" data-line-number="6765"></td>
        <td id="LC6765">        }</td>
      </tr>
      <tr>
        <td id="L6766" data-line-number="6766"></td>
        <td id="LC6766">
</td>
      </tr>
      <tr>
        <td id="L6767" data-line-number="6767"></td>
        <td id="LC6767">        <span>printf</span>(<span><span>"</span> (%3u,%*s)<span>"</span></span>, varDsc-&gt;<span>lvRefCnt</span>(), (<span>int</span>)refCntWtdWidth, <span>refCntWtd2str</span>(varDsc-&gt;<span>lvRefCntWtd</span>()));</td>
      </tr>
      <tr>
        <td id="L6768" data-line-number="6768"></td>
        <td id="LC6768">
</td>
      </tr>
      <tr>
        <td id="L6769" data-line-number="6769"></td>
        <td id="LC6769">        <span>printf</span>(<span><span>"</span> %7s <span>"</span></span>, <span>varTypeName</span>(type));</td>
      </tr>
      <tr>
        <td id="L6770" data-line-number="6770"></td>
        <td id="LC6770">        <span>if</span> (<span>genTypeSize</span>(type) == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6771" data-line-number="6771"></td>
        <td id="LC6771">        {</td>
      </tr>
      <tr>
        <td id="L6772" data-line-number="6772"></td>
        <td id="LC6772">            <span>printf</span>(<span><span>"</span>(%2d) <span>"</span></span>, <span>lvaLclSize</span>(lclNum));</td>
      </tr>
      <tr>
        <td id="L6773" data-line-number="6773"></td>
        <td id="LC6773">        }</td>
      </tr>
      <tr>
        <td id="L6774" data-line-number="6774"></td>
        <td id="LC6774">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L6775" data-line-number="6775"></td>
        <td id="LC6775">        {</td>
      </tr>
      <tr>
        <td id="L6776" data-line-number="6776"></td>
        <td id="LC6776">            <span>printf</span>(<span><span>"</span> -&gt;  <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6777" data-line-number="6777"></td>
        <td id="LC6777">        }</td>
      </tr>
      <tr>
        <td id="L6778" data-line-number="6778"></td>
        <td id="LC6778">
</td>
      </tr>
      <tr>
        <td id="L6779" data-line-number="6779"></td>
        <td id="LC6779">        <span><span>//</span> The register or stack location field is 11 characters wide.</span></td>
      </tr>
      <tr>
        <td id="L6780" data-line-number="6780"></td>
        <td id="LC6780">        <span>if</span> (varDsc-&gt;<span>lvRefCnt</span>() == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6781" data-line-number="6781"></td>
        <td id="LC6781">        {</td>
      </tr>
      <tr>
        <td id="L6782" data-line-number="6782"></td>
        <td id="LC6782">            <span>printf</span>(<span><span>"</span>zero-ref   <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6783" data-line-number="6783"></td>
        <td id="LC6783">        }</td>
      </tr>
      <tr>
        <td id="L6784" data-line-number="6784"></td>
        <td id="LC6784">        <span>else</span> <span>if</span> (varDsc-&gt;<span>lvRegister</span> != <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6785" data-line-number="6785"></td>
        <td id="LC6785">        {</td>
      </tr>
      <tr>
        <td id="L6786" data-line-number="6786"></td>
        <td id="LC6786">            <span><span>//</span> It's always a register, and always in the same register.</span></td>
      </tr>
      <tr>
        <td id="L6787" data-line-number="6787"></td>
        <td id="LC6787">            <span>lvaDumpRegLocation</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L6788" data-line-number="6788"></td>
        <td id="LC6788">        }</td>
      </tr>
      <tr>
        <td id="L6789" data-line-number="6789"></td>
        <td id="LC6789">        <span>else</span> <span>if</span> (varDsc-&gt;<span>lvOnFrame</span> == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L6790" data-line-number="6790"></td>
        <td id="LC6790">        {</td>
      </tr>
      <tr>
        <td id="L6791" data-line-number="6791"></td>
        <td id="LC6791">            <span>printf</span>(<span><span>"</span>registers  <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6792" data-line-number="6792"></td>
        <td id="LC6792">        }</td>
      </tr>
      <tr>
        <td id="L6793" data-line-number="6793"></td>
        <td id="LC6793">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L6794" data-line-number="6794"></td>
        <td id="LC6794">        {</td>
      </tr>
      <tr>
        <td id="L6795" data-line-number="6795"></td>
        <td id="LC6795">            <span><span>//</span> For RyuJIT backend, it might be in a register part of the time, but it will definitely have a stack home</span></td>
      </tr>
      <tr>
        <td id="L6796" data-line-number="6796"></td>
        <td id="LC6796">            <span><span>//</span> location. Otherwise, it's always on the stack.</span></td>
      </tr>
      <tr>
        <td id="L6797" data-line-number="6797"></td>
        <td id="LC6797">            <span>if</span> (lvaDoneFrameLayout != NO_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6798" data-line-number="6798"></td>
        <td id="LC6798">            {</td>
      </tr>
      <tr>
        <td id="L6799" data-line-number="6799"></td>
        <td id="LC6799">                <span>lvaDumpFrameLocation</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L6800" data-line-number="6800"></td>
        <td id="LC6800">            }</td>
      </tr>
      <tr>
        <td id="L6801" data-line-number="6801"></td>
        <td id="LC6801">        }</td>
      </tr>
      <tr>
        <td id="L6802" data-line-number="6802"></td>
        <td id="LC6802">    }</td>
      </tr>
      <tr>
        <td id="L6803" data-line-number="6803"></td>
        <td id="LC6803">
</td>
      </tr>
      <tr>
        <td id="L6804" data-line-number="6804"></td>
        <td id="LC6804">    <span>if</span> (varDsc-&gt;<span>lvIsHfa</span>())</td>
      </tr>
      <tr>
        <td id="L6805" data-line-number="6805"></td>
        <td id="LC6805">    {</td>
      </tr>
      <tr>
        <td id="L6806" data-line-number="6806"></td>
        <td id="LC6806">        <span>printf</span>(<span><span>"</span> HFA(%s) <span>"</span></span>, <span>varTypeName</span>(varDsc-&gt;<span>GetHfaType</span>()));</td>
      </tr>
      <tr>
        <td id="L6807" data-line-number="6807"></td>
        <td id="LC6807">    }</td>
      </tr>
      <tr>
        <td id="L6808" data-line-number="6808"></td>
        <td id="LC6808">
</td>
      </tr>
      <tr>
        <td id="L6809" data-line-number="6809"></td>
        <td id="LC6809">    <span>if</span> (varDsc-&gt;<span>lvLiveInOutOfHndlr</span>)</td>
      </tr>
      <tr>
        <td id="L6810" data-line-number="6810"></td>
        <td id="LC6810">    {</td>
      </tr>
      <tr>
        <td id="L6811" data-line-number="6811"></td>
        <td id="LC6811">        <span>printf</span>(<span><span>"</span> EH<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6812" data-line-number="6812"></td>
        <td id="LC6812">    }</td>
      </tr>
      <tr>
        <td id="L6813" data-line-number="6813"></td>
        <td id="LC6813">
</td>
      </tr>
      <tr>
        <td id="L6814" data-line-number="6814"></td>
        <td id="LC6814">    <span>if</span> (varDsc-&gt;<span>lvDoNotEnregister</span>)</td>
      </tr>
      <tr>
        <td id="L6815" data-line-number="6815"></td>
        <td id="LC6815">    {</td>
      </tr>
      <tr>
        <td id="L6816" data-line-number="6816"></td>
        <td id="LC6816">        <span>printf</span>(<span><span>"</span> do-not-enreg[<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6817" data-line-number="6817"></td>
        <td id="LC6817">        <span>if</span> (varDsc-&gt;<span>lvAddrExposed</span>)</td>
      </tr>
      <tr>
        <td id="L6818" data-line-number="6818"></td>
        <td id="LC6818">        {</td>
      </tr>
      <tr>
        <td id="L6819" data-line-number="6819"></td>
        <td id="LC6819">            <span>printf</span>(<span><span>"</span>X<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6820" data-line-number="6820"></td>
        <td id="LC6820">        }</td>
      </tr>
      <tr>
        <td id="L6821" data-line-number="6821"></td>
        <td id="LC6821">        <span>if</span> (<span>varTypeIsStruct</span>(varDsc))</td>
      </tr>
      <tr>
        <td id="L6822" data-line-number="6822"></td>
        <td id="LC6822">        {</td>
      </tr>
      <tr>
        <td id="L6823" data-line-number="6823"></td>
        <td id="LC6823">            <span>printf</span>(<span><span>"</span>S<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6824" data-line-number="6824"></td>
        <td id="LC6824">        }</td>
      </tr>
      <tr>
        <td id="L6825" data-line-number="6825"></td>
        <td id="LC6825">        <span>if</span> (varDsc-&gt;<span>lvVMNeedsStackAddr</span>)</td>
      </tr>
      <tr>
        <td id="L6826" data-line-number="6826"></td>
        <td id="LC6826">        {</td>
      </tr>
      <tr>
        <td id="L6827" data-line-number="6827"></td>
        <td id="LC6827">            <span>printf</span>(<span><span>"</span>V<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6828" data-line-number="6828"></td>
        <td id="LC6828">        }</td>
      </tr>
      <tr>
        <td id="L6829" data-line-number="6829"></td>
        <td id="LC6829">        <span>if</span> (varDsc-&gt;<span>lvLiveInOutOfHndlr</span>)</td>
      </tr>
      <tr>
        <td id="L6830" data-line-number="6830"></td>
        <td id="LC6830">        {</td>
      </tr>
      <tr>
        <td id="L6831" data-line-number="6831"></td>
        <td id="LC6831">            <span>printf</span>(<span><span>"</span>H<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6832" data-line-number="6832"></td>
        <td id="LC6832">        }</td>
      </tr>
      <tr>
        <td id="L6833" data-line-number="6833"></td>
        <td id="LC6833">        <span>if</span> (varDsc-&gt;<span>lvLclFieldExpr</span>)</td>
      </tr>
      <tr>
        <td id="L6834" data-line-number="6834"></td>
        <td id="LC6834">        {</td>
      </tr>
      <tr>
        <td id="L6835" data-line-number="6835"></td>
        <td id="LC6835">            <span>printf</span>(<span><span>"</span>F<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6836" data-line-number="6836"></td>
        <td id="LC6836">        }</td>
      </tr>
      <tr>
        <td id="L6837" data-line-number="6837"></td>
        <td id="LC6837">        <span>if</span> (varDsc-&gt;<span>lvLclBlockOpAddr</span>)</td>
      </tr>
      <tr>
        <td id="L6838" data-line-number="6838"></td>
        <td id="LC6838">        {</td>
      </tr>
      <tr>
        <td id="L6839" data-line-number="6839"></td>
        <td id="LC6839">            <span>printf</span>(<span><span>"</span>B<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6840" data-line-number="6840"></td>
        <td id="LC6840">        }</td>
      </tr>
      <tr>
        <td id="L6841" data-line-number="6841"></td>
        <td id="LC6841">        <span>if</span> (varDsc-&gt;<span>lvLiveAcrossUCall</span>)</td>
      </tr>
      <tr>
        <td id="L6842" data-line-number="6842"></td>
        <td id="LC6842">        {</td>
      </tr>
      <tr>
        <td id="L6843" data-line-number="6843"></td>
        <td id="LC6843">            <span>printf</span>(<span><span>"</span>U<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6844" data-line-number="6844"></td>
        <td id="LC6844">        }</td>
      </tr>
      <tr>
        <td id="L6845" data-line-number="6845"></td>
        <td id="LC6845">        <span>if</span> (varDsc-&gt;<span>lvIsMultiRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L6846" data-line-number="6846"></td>
        <td id="LC6846">        {</td>
      </tr>
      <tr>
        <td id="L6847" data-line-number="6847"></td>
        <td id="LC6847">            <span>printf</span>(<span><span>"</span>A<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6848" data-line-number="6848"></td>
        <td id="LC6848">        }</td>
      </tr>
      <tr>
        <td id="L6849" data-line-number="6849"></td>
        <td id="LC6849">        <span>if</span> (varDsc-&gt;<span>lvIsMultiRegRet</span>)</td>
      </tr>
      <tr>
        <td id="L6850" data-line-number="6850"></td>
        <td id="LC6850">        {</td>
      </tr>
      <tr>
        <td id="L6851" data-line-number="6851"></td>
        <td id="LC6851">            <span>printf</span>(<span><span>"</span>R<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6852" data-line-number="6852"></td>
        <td id="LC6852">        }</td>
      </tr>
      <tr>
        <td id="L6853" data-line-number="6853"></td>
        <td id="LC6853">#<span>ifdef</span> JIT32_GCENCODER</td>
      </tr>
      <tr>
        <td id="L6854" data-line-number="6854"></td>
        <td id="LC6854">        <span>if</span> (varDsc-&gt;<span>lvPinned</span>)</td>
      </tr>
      <tr>
        <td id="L6855" data-line-number="6855"></td>
        <td id="LC6855">            <span>printf</span>(<span><span>"</span>P<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6856" data-line-number="6856"></td>
        <td id="LC6856">#<span>endif</span> <span><span>//</span> JIT32_GCENCODER</span></td>
      </tr>
      <tr>
        <td id="L6857" data-line-number="6857"></td>
        <td id="LC6857">        <span>printf</span>(<span><span>"</span>]<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6858" data-line-number="6858"></td>
        <td id="LC6858">    }</td>
      </tr>
      <tr>
        <td id="L6859" data-line-number="6859"></td>
        <td id="LC6859">
</td>
      </tr>
      <tr>
        <td id="L6860" data-line-number="6860"></td>
        <td id="LC6860">    <span>if</span> (varDsc-&gt;<span>lvIsMultiRegArg</span>)</td>
      </tr>
      <tr>
        <td id="L6861" data-line-number="6861"></td>
        <td id="LC6861">    {</td>
      </tr>
      <tr>
        <td id="L6862" data-line-number="6862"></td>
        <td id="LC6862">        <span>printf</span>(<span><span>"</span> multireg-arg<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6863" data-line-number="6863"></td>
        <td id="LC6863">    }</td>
      </tr>
      <tr>
        <td id="L6864" data-line-number="6864"></td>
        <td id="LC6864">    <span>if</span> (varDsc-&gt;<span>lvIsMultiRegRet</span>)</td>
      </tr>
      <tr>
        <td id="L6865" data-line-number="6865"></td>
        <td id="LC6865">    {</td>
      </tr>
      <tr>
        <td id="L6866" data-line-number="6866"></td>
        <td id="LC6866">        <span>printf</span>(<span><span>"</span> multireg-ret<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6867" data-line-number="6867"></td>
        <td id="LC6867">    }</td>
      </tr>
      <tr>
        <td id="L6868" data-line-number="6868"></td>
        <td id="LC6868">    <span>if</span> (varDsc-&gt;<span>lvMustInit</span>)</td>
      </tr>
      <tr>
        <td id="L6869" data-line-number="6869"></td>
        <td id="LC6869">    {</td>
      </tr>
      <tr>
        <td id="L6870" data-line-number="6870"></td>
        <td id="LC6870">        <span>printf</span>(<span><span>"</span> must-init<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6871" data-line-number="6871"></td>
        <td id="LC6871">    }</td>
      </tr>
      <tr>
        <td id="L6872" data-line-number="6872"></td>
        <td id="LC6872">    <span>if</span> (varDsc-&gt;<span>lvAddrExposed</span>)</td>
      </tr>
      <tr>
        <td id="L6873" data-line-number="6873"></td>
        <td id="LC6873">    {</td>
      </tr>
      <tr>
        <td id="L6874" data-line-number="6874"></td>
        <td id="LC6874">        <span>printf</span>(<span><span>"</span> addr-exposed<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6875" data-line-number="6875"></td>
        <td id="LC6875">    }</td>
      </tr>
      <tr>
        <td id="L6876" data-line-number="6876"></td>
        <td id="LC6876">    <span>if</span> (varDsc-&gt;<span>lvHasLdAddrOp</span>)</td>
      </tr>
      <tr>
        <td id="L6877" data-line-number="6877"></td>
        <td id="LC6877">    {</td>
      </tr>
      <tr>
        <td id="L6878" data-line-number="6878"></td>
        <td id="LC6878">        <span>printf</span>(<span><span>"</span> ld-addr-op<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6879" data-line-number="6879"></td>
        <td id="LC6879">    }</td>
      </tr>
      <tr>
        <td id="L6880" data-line-number="6880"></td>
        <td id="LC6880">    <span>if</span> (varDsc-&gt;<span>lvVerTypeInfo</span>.<span>IsThisPtr</span>())</td>
      </tr>
      <tr>
        <td id="L6881" data-line-number="6881"></td>
        <td id="LC6881">    {</td>
      </tr>
      <tr>
        <td id="L6882" data-line-number="6882"></td>
        <td id="LC6882">        <span>printf</span>(<span><span>"</span> this<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6883" data-line-number="6883"></td>
        <td id="LC6883">    }</td>
      </tr>
      <tr>
        <td id="L6884" data-line-number="6884"></td>
        <td id="LC6884">    <span>if</span> (varDsc-&gt;<span>lvPinned</span>)</td>
      </tr>
      <tr>
        <td id="L6885" data-line-number="6885"></td>
        <td id="LC6885">    {</td>
      </tr>
      <tr>
        <td id="L6886" data-line-number="6886"></td>
        <td id="LC6886">        <span>printf</span>(<span><span>"</span> pinned<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6887" data-line-number="6887"></td>
        <td id="LC6887">    }</td>
      </tr>
      <tr>
        <td id="L6888" data-line-number="6888"></td>
        <td id="LC6888">    <span>if</span> (varDsc-&gt;<span>lvStackByref</span>)</td>
      </tr>
      <tr>
        <td id="L6889" data-line-number="6889"></td>
        <td id="LC6889">    {</td>
      </tr>
      <tr>
        <td id="L6890" data-line-number="6890"></td>
        <td id="LC6890">        <span>printf</span>(<span><span>"</span> stack-byref<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6891" data-line-number="6891"></td>
        <td id="LC6891">    }</td>
      </tr>
      <tr>
        <td id="L6892" data-line-number="6892"></td>
        <td id="LC6892">    <span>if</span> (varDsc-&gt;<span>lvClassHnd</span> != <span>nullptr</span>)</td>
      </tr>
      <tr>
        <td id="L6893" data-line-number="6893"></td>
        <td id="LC6893">    {</td>
      </tr>
      <tr>
        <td id="L6894" data-line-number="6894"></td>
        <td id="LC6894">        <span>printf</span>(<span><span>"</span> class-hnd<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6895" data-line-number="6895"></td>
        <td id="LC6895">    }</td>
      </tr>
      <tr>
        <td id="L6896" data-line-number="6896"></td>
        <td id="LC6896">    <span>if</span> (varDsc-&gt;<span>lvClassIsExact</span>)</td>
      </tr>
      <tr>
        <td id="L6897" data-line-number="6897"></td>
        <td id="LC6897">    {</td>
      </tr>
      <tr>
        <td id="L6898" data-line-number="6898"></td>
        <td id="LC6898">        <span>printf</span>(<span><span>"</span> exact<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6899" data-line-number="6899"></td>
        <td id="LC6899">    }</td>
      </tr>
      <tr>
        <td id="L6900" data-line-number="6900"></td>
        <td id="LC6900">    <span>if</span> (varDsc-&gt;<span>lvLiveInOutOfHndlr</span>)</td>
      </tr>
      <tr>
        <td id="L6901" data-line-number="6901"></td>
        <td id="LC6901">    {</td>
      </tr>
      <tr>
        <td id="L6902" data-line-number="6902"></td>
        <td id="LC6902">        <span>printf</span>(<span><span>"</span> EH-live<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6903" data-line-number="6903"></td>
        <td id="LC6903">    }</td>
      </tr>
      <tr>
        <td id="L6904" data-line-number="6904"></td>
        <td id="LC6904">#<span>ifndef</span> TARGET_64BIT</td>
      </tr>
      <tr>
        <td id="L6905" data-line-number="6905"></td>
        <td id="LC6905">    <span>if</span> (varDsc-&gt;<span>lvStructDoubleAlign</span>)</td>
      </tr>
      <tr>
        <td id="L6906" data-line-number="6906"></td>
        <td id="LC6906">        <span>printf</span>(<span><span>"</span> double-align<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6907" data-line-number="6907"></td>
        <td id="LC6907">#<span>endif</span> <span><span>//</span> !TARGET_64BIT</span></td>
      </tr>
      <tr>
        <td id="L6908" data-line-number="6908"></td>
        <td id="LC6908">    <span>if</span> (varDsc-&gt;<span>lvOverlappingFields</span>)</td>
      </tr>
      <tr>
        <td id="L6909" data-line-number="6909"></td>
        <td id="LC6909">    {</td>
      </tr>
      <tr>
        <td id="L6910" data-line-number="6910"></td>
        <td id="LC6910">        <span>printf</span>(<span><span>"</span> overlapping-fields<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6911" data-line-number="6911"></td>
        <td id="LC6911">    }</td>
      </tr>
      <tr>
        <td id="L6912" data-line-number="6912"></td>
        <td id="LC6912">
</td>
      </tr>
      <tr>
        <td id="L6913" data-line-number="6913"></td>
        <td id="LC6913">    <span>if</span> (compGSReorderStackLayout &amp;&amp; !varDsc-&gt;<span>lvRegister</span>)</td>
      </tr>
      <tr>
        <td id="L6914" data-line-number="6914"></td>
        <td id="LC6914">    {</td>
      </tr>
      <tr>
        <td id="L6915" data-line-number="6915"></td>
        <td id="LC6915">        <span>if</span> (varDsc-&gt;<span>lvIsPtr</span>)</td>
      </tr>
      <tr>
        <td id="L6916" data-line-number="6916"></td>
        <td id="LC6916">        {</td>
      </tr>
      <tr>
        <td id="L6917" data-line-number="6917"></td>
        <td id="LC6917">            <span>printf</span>(<span><span>"</span> ptr<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6918" data-line-number="6918"></td>
        <td id="LC6918">        }</td>
      </tr>
      <tr>
        <td id="L6919" data-line-number="6919"></td>
        <td id="LC6919">        <span>if</span> (varDsc-&gt;<span>lvIsUnsafeBuffer</span>)</td>
      </tr>
      <tr>
        <td id="L6920" data-line-number="6920"></td>
        <td id="LC6920">        {</td>
      </tr>
      <tr>
        <td id="L6921" data-line-number="6921"></td>
        <td id="LC6921">            <span>printf</span>(<span><span>"</span> unsafe-buffer<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6922" data-line-number="6922"></td>
        <td id="LC6922">        }</td>
      </tr>
      <tr>
        <td id="L6923" data-line-number="6923"></td>
        <td id="LC6923">    }</td>
      </tr>
      <tr>
        <td id="L6924" data-line-number="6924"></td>
        <td id="LC6924">    <span>if</span> (varDsc-&gt;<span>lvIsStructField</span>)</td>
      </tr>
      <tr>
        <td id="L6925" data-line-number="6925"></td>
        <td id="LC6925">    {</td>
      </tr>
      <tr>
        <td id="L6926" data-line-number="6926"></td>
        <td id="LC6926">        LclVarDsc* parentvarDsc = &amp;lvaTable[varDsc-&gt;<span>lvParentLcl</span>];</td>
      </tr>
      <tr>
        <td id="L6927" data-line-number="6927"></td>
        <td id="LC6927">#<span>if</span> !defined(TARGET_64BIT)</td>
      </tr>
      <tr>
        <td id="L6928" data-line-number="6928"></td>
        <td id="LC6928">        <span>if</span> (<span>varTypeIsLong</span>(parentvarDsc))</td>
      </tr>
      <tr>
        <td id="L6929" data-line-number="6929"></td>
        <td id="LC6929">        {</td>
      </tr>
      <tr>
        <td id="L6930" data-line-number="6930"></td>
        <td id="LC6930">            <span>bool</span> isLo = (lclNum == parentvarDsc-&gt;<span>lvFieldLclStart</span>);</td>
      </tr>
      <tr>
        <td id="L6931" data-line-number="6931"></td>
        <td id="LC6931">            <span>printf</span>(<span><span>"</span> V%02u.%s(offs=0x%02x)<span>"</span></span>, varDsc-&gt;<span>lvParentLcl</span>, isLo ? <span><span>"</span>lo<span>"</span></span> : <span><span>"</span>hi<span>"</span></span>, isLo ? <span>0</span> : <span>genTypeSize</span>(TYP_INT));</td>
      </tr>
      <tr>
        <td id="L6932" data-line-number="6932"></td>
        <td id="LC6932">        }</td>
      </tr>
      <tr>
        <td id="L6933" data-line-number="6933"></td>
        <td id="LC6933">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L6934" data-line-number="6934"></td>
        <td id="LC6934">#<span>endif</span> <span><span>//</span> !defined(TARGET_64BIT)</span></td>
      </tr>
      <tr>
        <td id="L6935" data-line-number="6935"></td>
        <td id="LC6935">        {</td>
      </tr>
      <tr>
        <td id="L6936" data-line-number="6936"></td>
        <td id="LC6936">            CORINFO_CLASS_HANDLE typeHnd = parentvarDsc-&gt;<span>lvVerTypeInfo</span>.<span>GetClassHandle</span>();</td>
      </tr>
      <tr>
        <td id="L6937" data-line-number="6937"></td>
        <td id="LC6937">            CORINFO_FIELD_HANDLE fldHnd  = info.<span>compCompHnd</span>-&gt;<span>getFieldInClass</span>(typeHnd, varDsc-&gt;<span>lvFldOrdinal</span>);</td>
      </tr>
      <tr>
        <td id="L6938" data-line-number="6938"></td>
        <td id="LC6938">
</td>
      </tr>
      <tr>
        <td id="L6939" data-line-number="6939"></td>
        <td id="LC6939">            <span>printf</span>(<span><span>"</span> V%02u.%s(offs=0x%02x)<span>"</span></span>, varDsc-&gt;<span>lvParentLcl</span>, <span>eeGetFieldName</span>(fldHnd), varDsc-&gt;<span>lvFldOffset</span>);</td>
      </tr>
      <tr>
        <td id="L6940" data-line-number="6940"></td>
        <td id="LC6940">
</td>
      </tr>
      <tr>
        <td id="L6941" data-line-number="6941"></td>
        <td id="LC6941">            lvaPromotionType promotionType = <span>lvaGetPromotionType</span>(parentvarDsc);</td>
      </tr>
      <tr>
        <td id="L6942" data-line-number="6942"></td>
        <td id="LC6942">            <span>switch</span> (promotionType)</td>
      </tr>
      <tr>
        <td id="L6943" data-line-number="6943"></td>
        <td id="LC6943">            {</td>
      </tr>
      <tr>
        <td id="L6944" data-line-number="6944"></td>
        <td id="LC6944">                <span>case</span> PROMOTION_TYPE_NONE:</td>
      </tr>
      <tr>
        <td id="L6945" data-line-number="6945"></td>
        <td id="LC6945">                    <span>printf</span>(<span><span>"</span> P-NONE<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6946" data-line-number="6946"></td>
        <td id="LC6946">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L6947" data-line-number="6947"></td>
        <td id="LC6947">                <span>case</span> PROMOTION_TYPE_DEPENDENT:</td>
      </tr>
      <tr>
        <td id="L6948" data-line-number="6948"></td>
        <td id="LC6948">                    <span>printf</span>(<span><span>"</span> P-DEP<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6949" data-line-number="6949"></td>
        <td id="LC6949">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L6950" data-line-number="6950"></td>
        <td id="LC6950">                <span>case</span> PROMOTION_TYPE_INDEPENDENT:</td>
      </tr>
      <tr>
        <td id="L6951" data-line-number="6951"></td>
        <td id="LC6951">                    <span>printf</span>(<span><span>"</span> P-INDEP<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6952" data-line-number="6952"></td>
        <td id="LC6952">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L6953" data-line-number="6953"></td>
        <td id="LC6953">            }</td>
      </tr>
      <tr>
        <td id="L6954" data-line-number="6954"></td>
        <td id="LC6954">        }</td>
      </tr>
      <tr>
        <td id="L6955" data-line-number="6955"></td>
        <td id="LC6955">    }</td>
      </tr>
      <tr>
        <td id="L6956" data-line-number="6956"></td>
        <td id="LC6956">
</td>
      </tr>
      <tr>
        <td id="L6957" data-line-number="6957"></td>
        <td id="LC6957">    <span>if</span> (varDsc-&gt;<span>lvReason</span> != <span>nullptr</span>)</td>
      </tr>
      <tr>
        <td id="L6958" data-line-number="6958"></td>
        <td id="LC6958">    {</td>
      </tr>
      <tr>
        <td id="L6959" data-line-number="6959"></td>
        <td id="LC6959">        <span>printf</span>(<span><span>"</span> <span>\"</span>%s<span>\"</span><span>"</span></span>, varDsc-&gt;<span>lvReason</span>);</td>
      </tr>
      <tr>
        <td id="L6960" data-line-number="6960"></td>
        <td id="LC6960">    }</td>
      </tr>
      <tr>
        <td id="L6961" data-line-number="6961"></td>
        <td id="LC6961">
</td>
      </tr>
      <tr>
        <td id="L6962" data-line-number="6962"></td>
        <td id="LC6962">    <span>printf</span>(<span><span>"</span><span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6963" data-line-number="6963"></td>
        <td id="LC6963">}</td>
      </tr>
      <tr>
        <td id="L6964" data-line-number="6964"></td>
        <td id="LC6964">
</td>
      </tr>
      <tr>
        <td id="L6965" data-line-number="6965"></td>
        <td id="LC6965"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L6966" data-line-number="6966"></td>
        <td id="LC6966"><span>*</span></td>
      </tr>
      <tr>
        <td id="L6967" data-line-number="6967"></td>
        <td id="LC6967"><span>*  dump the lvaTable</span></td>
      </tr>
      <tr>
        <td id="L6968" data-line-number="6968"></td>
        <td id="LC6968"><span><span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L6969" data-line-number="6969"></td>
        <td id="LC6969">
</td>
      </tr>
      <tr>
        <td id="L6970" data-line-number="6970"></td>
        <td id="LC6970"><span>void</span> <span>Compiler::lvaTableDump</span>(FrameLayoutState curState)</td>
      </tr>
      <tr>
        <td id="L6971" data-line-number="6971"></td>
        <td id="LC6971">{</td>
      </tr>
      <tr>
        <td id="L6972" data-line-number="6972"></td>
        <td id="LC6972">    <span>if</span> (curState == NO_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6973" data-line-number="6973"></td>
        <td id="LC6973">    {</td>
      </tr>
      <tr>
        <td id="L6974" data-line-number="6974"></td>
        <td id="LC6974">        curState = lvaDoneFrameLayout;</td>
      </tr>
      <tr>
        <td id="L6975" data-line-number="6975"></td>
        <td id="LC6975">        <span>if</span> (curState == NO_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6976" data-line-number="6976"></td>
        <td id="LC6976">        {</td>
      </tr>
      <tr>
        <td id="L6977" data-line-number="6977"></td>
        <td id="LC6977">            <span><span>//</span> Still no layout? Could be a bug, but just display the initial layout</span></td>
      </tr>
      <tr>
        <td id="L6978" data-line-number="6978"></td>
        <td id="LC6978">            curState = INITIAL_FRAME_LAYOUT;</td>
      </tr>
      <tr>
        <td id="L6979" data-line-number="6979"></td>
        <td id="LC6979">        }</td>
      </tr>
      <tr>
        <td id="L6980" data-line-number="6980"></td>
        <td id="LC6980">    }</td>
      </tr>
      <tr>
        <td id="L6981" data-line-number="6981"></td>
        <td id="LC6981">
</td>
      </tr>
      <tr>
        <td id="L6982" data-line-number="6982"></td>
        <td id="LC6982">    <span>if</span> (curState == INITIAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6983" data-line-number="6983"></td>
        <td id="LC6983">    {</td>
      </tr>
      <tr>
        <td id="L6984" data-line-number="6984"></td>
        <td id="LC6984">        <span>printf</span>(<span><span>"</span>; Initial<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6985" data-line-number="6985"></td>
        <td id="LC6985">    }</td>
      </tr>
      <tr>
        <td id="L6986" data-line-number="6986"></td>
        <td id="LC6986">    <span>else</span> <span>if</span> (curState == PRE_REGALLOC_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6987" data-line-number="6987"></td>
        <td id="LC6987">    {</td>
      </tr>
      <tr>
        <td id="L6988" data-line-number="6988"></td>
        <td id="LC6988">        <span>printf</span>(<span><span>"</span>; Pre-RegAlloc<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6989" data-line-number="6989"></td>
        <td id="LC6989">    }</td>
      </tr>
      <tr>
        <td id="L6990" data-line-number="6990"></td>
        <td id="LC6990">    <span>else</span> <span>if</span> (curState == REGALLOC_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6991" data-line-number="6991"></td>
        <td id="LC6991">    {</td>
      </tr>
      <tr>
        <td id="L6992" data-line-number="6992"></td>
        <td id="LC6992">        <span>printf</span>(<span><span>"</span>; RegAlloc<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6993" data-line-number="6993"></td>
        <td id="LC6993">    }</td>
      </tr>
      <tr>
        <td id="L6994" data-line-number="6994"></td>
        <td id="LC6994">    <span>else</span> <span>if</span> (curState == TENTATIVE_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6995" data-line-number="6995"></td>
        <td id="LC6995">    {</td>
      </tr>
      <tr>
        <td id="L6996" data-line-number="6996"></td>
        <td id="LC6996">        <span>printf</span>(<span><span>"</span>; Tentative<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L6997" data-line-number="6997"></td>
        <td id="LC6997">    }</td>
      </tr>
      <tr>
        <td id="L6998" data-line-number="6998"></td>
        <td id="LC6998">    <span>else</span> <span>if</span> (curState == FINAL_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L6999" data-line-number="6999"></td>
        <td id="LC6999">    {</td>
      </tr>
      <tr>
        <td id="L7000" data-line-number="7000"></td>
        <td id="LC7000">        <span>printf</span>(<span><span>"</span>; Final<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7001" data-line-number="7001"></td>
        <td id="LC7001">    }</td>
      </tr>
      <tr>
        <td id="L7002" data-line-number="7002"></td>
        <td id="LC7002">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7003" data-line-number="7003"></td>
        <td id="LC7003">    {</td>
      </tr>
      <tr>
        <td id="L7004" data-line-number="7004"></td>
        <td id="LC7004">        <span>printf</span>(<span><span>"</span>UNKNOWN FrameLayoutState!<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7005" data-line-number="7005"></td>
        <td id="LC7005">        <span>unreached</span>();</td>
      </tr>
      <tr>
        <td id="L7006" data-line-number="7006"></td>
        <td id="LC7006">    }</td>
      </tr>
      <tr>
        <td id="L7007" data-line-number="7007"></td>
        <td id="LC7007">
</td>
      </tr>
      <tr>
        <td id="L7008" data-line-number="7008"></td>
        <td id="LC7008">    <span>printf</span>(<span><span>"</span> local variable assignments<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7009" data-line-number="7009"></td>
        <td id="LC7009">    <span>printf</span>(<span><span>"</span>;<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7010" data-line-number="7010"></td>
        <td id="LC7010">
</td>
      </tr>
      <tr>
        <td id="L7011" data-line-number="7011"></td>
        <td id="LC7011">    <span>unsigned</span>   lclNum;</td>
      </tr>
      <tr>
        <td id="L7012" data-line-number="7012"></td>
        <td id="LC7012">    LclVarDsc* varDsc;</td>
      </tr>
      <tr>
        <td id="L7013" data-line-number="7013"></td>
        <td id="LC7013">
</td>
      </tr>
      <tr>
        <td id="L7014" data-line-number="7014"></td>
        <td id="LC7014">    <span><span>//</span> Figure out some sizes, to help line things up</span></td>
      </tr>
      <tr>
        <td id="L7015" data-line-number="7015"></td>
        <td id="LC7015">
</td>
      </tr>
      <tr>
        <td id="L7016" data-line-number="7016"></td>
        <td id="LC7016">    <span>size_t</span> refCntWtdWidth = <span>6</span>; <span><span>//</span> Use 6 as the minimum width</span></td>
      </tr>
      <tr>
        <td id="L7017" data-line-number="7017"></td>
        <td id="LC7017">
</td>
      </tr>
      <tr>
        <td id="L7018" data-line-number="7018"></td>
        <td id="LC7018">    <span>if</span> (curState != INITIAL_FRAME_LAYOUT) <span><span>//</span> don't need this info for INITIAL_FRAME_LAYOUT</span></td>
      </tr>
      <tr>
        <td id="L7019" data-line-number="7019"></td>
        <td id="LC7019">    {</td>
      </tr>
      <tr>
        <td id="L7020" data-line-number="7020"></td>
        <td id="LC7020">        <span>for</span> (lclNum = <span>0</span>, varDsc = lvaTable; lclNum &lt; lvaCount; lclNum++, varDsc++)</td>
      </tr>
      <tr>
        <td id="L7021" data-line-number="7021"></td>
        <td id="LC7021">        {</td>
      </tr>
      <tr>
        <td id="L7022" data-line-number="7022"></td>
        <td id="LC7022">            <span>size_t</span> width = <span>strlen</span>(<span>refCntWtd2str</span>(varDsc-&gt;<span>lvRefCntWtd</span>()));</td>
      </tr>
      <tr>
        <td id="L7023" data-line-number="7023"></td>
        <td id="LC7023">            <span>if</span> (width &gt; refCntWtdWidth)</td>
      </tr>
      <tr>
        <td id="L7024" data-line-number="7024"></td>
        <td id="LC7024">            {</td>
      </tr>
      <tr>
        <td id="L7025" data-line-number="7025"></td>
        <td id="LC7025">                refCntWtdWidth = width;</td>
      </tr>
      <tr>
        <td id="L7026" data-line-number="7026"></td>
        <td id="LC7026">            }</td>
      </tr>
      <tr>
        <td id="L7027" data-line-number="7027"></td>
        <td id="LC7027">        }</td>
      </tr>
      <tr>
        <td id="L7028" data-line-number="7028"></td>
        <td id="LC7028">    }</td>
      </tr>
      <tr>
        <td id="L7029" data-line-number="7029"></td>
        <td id="LC7029">
</td>
      </tr>
      <tr>
        <td id="L7030" data-line-number="7030"></td>
        <td id="LC7030">    <span><span>//</span> Do the actual output</span></td>
      </tr>
      <tr>
        <td id="L7031" data-line-number="7031"></td>
        <td id="LC7031">
</td>
      </tr>
      <tr>
        <td id="L7032" data-line-number="7032"></td>
        <td id="LC7032">    <span>for</span> (lclNum = <span>0</span>, varDsc = lvaTable; lclNum &lt; lvaCount; lclNum++, varDsc++)</td>
      </tr>
      <tr>
        <td id="L7033" data-line-number="7033"></td>
        <td id="LC7033">    {</td>
      </tr>
      <tr>
        <td id="L7034" data-line-number="7034"></td>
        <td id="LC7034">        <span>lvaDumpEntry</span>(lclNum, curState, refCntWtdWidth);</td>
      </tr>
      <tr>
        <td id="L7035" data-line-number="7035"></td>
        <td id="LC7035">    }</td>
      </tr>
      <tr>
        <td id="L7036" data-line-number="7036"></td>
        <td id="LC7036">
</td>
      </tr>
      <tr>
        <td id="L7037" data-line-number="7037"></td>
        <td id="LC7037">    <span><span>//</span>-------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7038" data-line-number="7038"></td>
        <td id="LC7038">    <span><span>//</span> Display the code-gen temps</span></td>
      </tr>
      <tr>
        <td id="L7039" data-line-number="7039"></td>
        <td id="LC7039">
</td>
      </tr>
      <tr>
        <td id="L7040" data-line-number="7040"></td>
        <td id="LC7040">    <span>assert</span>(codeGen-&gt;<span>regSet</span>.<span>tmpAllFree</span>());</td>
      </tr>
      <tr>
        <td id="L7041" data-line-number="7041"></td>
        <td id="LC7041">    <span>for</span> (TempDsc* temp = codeGen-&gt;<span>regSet</span>.<span>tmpListBeg</span>(); temp != <span>nullptr</span>; temp = codeGen-&gt;<span>regSet</span>.<span>tmpListNxt</span>(temp))</td>
      </tr>
      <tr>
        <td id="L7042" data-line-number="7042"></td>
        <td id="LC7042">    {</td>
      </tr>
      <tr>
        <td id="L7043" data-line-number="7043"></td>
        <td id="LC7043">        <span>printf</span>(<span><span>"</span>;  TEMP_%02u %26s%*s%7s  -&gt; <span>"</span></span>, -temp-&gt;<span>tdTempNum</span>(), <span><span>"</span> <span>"</span></span>, refCntWtdWidth, <span><span>"</span> <span>"</span></span>,</td>
      </tr>
      <tr>
        <td id="L7044" data-line-number="7044"></td>
        <td id="LC7044">               <span>varTypeName</span>(temp-&gt;<span>tdTempType</span>()));</td>
      </tr>
      <tr>
        <td id="L7045" data-line-number="7045"></td>
        <td id="LC7045">        <span>int</span> offset = temp-&gt;<span>tdTempOffs</span>();</td>
      </tr>
      <tr>
        <td id="L7046" data-line-number="7046"></td>
        <td id="LC7046">        <span>printf</span>(<span><span>"</span> [%2s%1s0x%02X]<span>\n</span><span>"</span></span>, <span>isFramePointerUsed</span>() ? STR_FPBASE : STR_SPBASE, (offset &lt; <span>0</span> ? <span><span>"</span>-<span>"</span></span> : <span><span>"</span>+<span>"</span></span>),</td>
      </tr>
      <tr>
        <td id="L7047" data-line-number="7047"></td>
        <td id="LC7047">               (offset &lt; <span>0</span> ? -offset : offset));</td>
      </tr>
      <tr>
        <td id="L7048" data-line-number="7048"></td>
        <td id="LC7048">    }</td>
      </tr>
      <tr>
        <td id="L7049" data-line-number="7049"></td>
        <td id="LC7049">
</td>
      </tr>
      <tr>
        <td id="L7050" data-line-number="7050"></td>
        <td id="LC7050">    <span>if</span> (curState &gt;= TENTATIVE_FRAME_LAYOUT)</td>
      </tr>
      <tr>
        <td id="L7051" data-line-number="7051"></td>
        <td id="LC7051">    {</td>
      </tr>
      <tr>
        <td id="L7052" data-line-number="7052"></td>
        <td id="LC7052">        <span>printf</span>(<span><span>"</span>;<span>\n</span><span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7053" data-line-number="7053"></td>
        <td id="LC7053">        <span>printf</span>(<span><span>"</span>; Lcl frame size = %d<span>\n</span><span>"</span></span>, compLclFrameSize);</td>
      </tr>
      <tr>
        <td id="L7054" data-line-number="7054"></td>
        <td id="LC7054">    }</td>
      </tr>
      <tr>
        <td id="L7055" data-line-number="7055"></td>
        <td id="LC7055">}</td>
      </tr>
      <tr>
        <td id="L7056" data-line-number="7056"></td>
        <td id="LC7056">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L7057" data-line-number="7057"></td>
        <td id="LC7057">
</td>
      </tr>
      <tr>
        <td id="L7058" data-line-number="7058"></td>
        <td id="LC7058"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L7059" data-line-number="7059"></td>
        <td id="LC7059"><span> *</span></td>
      </tr>
      <tr>
        <td id="L7060" data-line-number="7060"></td>
        <td id="LC7060"><span> *  Conservatively estimate the layout of the stack frame.</span></td>
      </tr>
      <tr>
        <td id="L7061" data-line-number="7061"></td>
        <td id="LC7061"><span> *</span></td>
      </tr>
      <tr>
        <td id="L7062" data-line-number="7062"></td>
        <td id="LC7062"><span> *  This function is only used before final frame layout. It conservatively estimates the</span></td>
      </tr>
      <tr>
        <td id="L7063" data-line-number="7063"></td>
        <td id="LC7063"><span> *  number of callee-saved registers that must be saved, then calls lvaAssignFrameOffsets().</span></td>
      </tr>
      <tr>
        <td id="L7064" data-line-number="7064"></td>
        <td id="LC7064"><span> *  To do final frame layout, the callee-saved registers are known precisely, so</span></td>
      </tr>
      <tr>
        <td id="L7065" data-line-number="7065"></td>
        <td id="LC7065"><span> *  lvaAssignFrameOffsets() is called directly.</span></td>
      </tr>
      <tr>
        <td id="L7066" data-line-number="7066"></td>
        <td id="LC7066"><span> *</span></td>
      </tr>
      <tr>
        <td id="L7067" data-line-number="7067"></td>
        <td id="LC7067"><span> *  Returns the (conservative, that is, overly large) estimated size of the frame,</span></td>
      </tr>
      <tr>
        <td id="L7068" data-line-number="7068"></td>
        <td id="LC7068"><span> *  including the callee-saved registers. This is only used by the emitter during code</span></td>
      </tr>
      <tr>
        <td id="L7069" data-line-number="7069"></td>
        <td id="LC7069"><span> *  generation when estimating the size of the offset of instructions accessing temps,</span></td>
      </tr>
      <tr>
        <td id="L7070" data-line-number="7070"></td>
        <td id="LC7070"><span> *  and only if temps have a larger offset than variables.</span></td>
      </tr>
      <tr>
        <td id="L7071" data-line-number="7071"></td>
        <td id="LC7071"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7072" data-line-number="7072"></td>
        <td id="LC7072">
</td>
      </tr>
      <tr>
        <td id="L7073" data-line-number="7073"></td>
        <td id="LC7073"><span>unsigned</span> <span>Compiler::lvaFrameSize</span>(FrameLayoutState curState)</td>
      </tr>
      <tr>
        <td id="L7074" data-line-number="7074"></td>
        <td id="LC7074">{</td>
      </tr>
      <tr>
        <td id="L7075" data-line-number="7075"></td>
        <td id="LC7075">    <span>assert</span>(curState &lt; FINAL_FRAME_LAYOUT);</td>
      </tr>
      <tr>
        <td id="L7076" data-line-number="7076"></td>
        <td id="LC7076">
</td>
      </tr>
      <tr>
        <td id="L7077" data-line-number="7077"></td>
        <td id="LC7077">    <span>unsigned</span> result;</td>
      </tr>
      <tr>
        <td id="L7078" data-line-number="7078"></td>
        <td id="LC7078">
</td>
      </tr>
      <tr>
        <td id="L7079" data-line-number="7079"></td>
        <td id="LC7079">    <span><span>/*</span> Layout the stack frame conservatively.</span></td>
      </tr>
      <tr>
        <td id="L7080" data-line-number="7080"></td>
        <td id="LC7080"><span>       Assume all callee-saved registers are spilled to stack <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7081" data-line-number="7081"></td>
        <td id="LC7081">
</td>
      </tr>
      <tr>
        <td id="L7082" data-line-number="7082"></td>
        <td id="LC7082">    compCalleeRegsPushed = CNT_CALLEE_SAVED;</td>
      </tr>
      <tr>
        <td id="L7083" data-line-number="7083"></td>
        <td id="LC7083">
</td>
      </tr>
      <tr>
        <td id="L7084" data-line-number="7084"></td>
        <td id="LC7084">#<span>if</span> defined(TARGET_ARMARCH)</td>
      </tr>
      <tr>
        <td id="L7085" data-line-number="7085"></td>
        <td id="LC7085">    <span>if</span> (compFloatingPointUsed)</td>
      </tr>
      <tr>
        <td id="L7086" data-line-number="7086"></td>
        <td id="LC7086">        compCalleeRegsPushed += CNT_CALLEE_SAVED_FLOAT;</td>
      </tr>
      <tr>
        <td id="L7087" data-line-number="7087"></td>
        <td id="LC7087">
</td>
      </tr>
      <tr>
        <td id="L7088" data-line-number="7088"></td>
        <td id="LC7088">    compCalleeRegsPushed++; <span><span>//</span> we always push LR.  See genPushCalleeSavedRegisters</span></td>
      </tr>
      <tr>
        <td id="L7089" data-line-number="7089"></td>
        <td id="LC7089">#<span>elif</span> defined(TARGET_AMD64)</td>
      </tr>
      <tr>
        <td id="L7090" data-line-number="7090"></td>
        <td id="LC7090">    <span>if</span> (compFloatingPointUsed)</td>
      </tr>
      <tr>
        <td id="L7091" data-line-number="7091"></td>
        <td id="LC7091">    {</td>
      </tr>
      <tr>
        <td id="L7092" data-line-number="7092"></td>
        <td id="LC7092">        compCalleeFPRegsSavedMask = RBM_FLT_CALLEE_SAVED;</td>
      </tr>
      <tr>
        <td id="L7093" data-line-number="7093"></td>
        <td id="LC7093">    }</td>
      </tr>
      <tr>
        <td id="L7094" data-line-number="7094"></td>
        <td id="LC7094">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7095" data-line-number="7095"></td>
        <td id="LC7095">    {</td>
      </tr>
      <tr>
        <td id="L7096" data-line-number="7096"></td>
        <td id="LC7096">        compCalleeFPRegsSavedMask = RBM_NONE;</td>
      </tr>
      <tr>
        <td id="L7097" data-line-number="7097"></td>
        <td id="LC7097">    }</td>
      </tr>
      <tr>
        <td id="L7098" data-line-number="7098"></td>
        <td id="LC7098">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L7099" data-line-number="7099"></td>
        <td id="LC7099">
</td>
      </tr>
      <tr>
        <td id="L7100" data-line-number="7100"></td>
        <td id="LC7100">#<span>if</span> DOUBLE_ALIGN</td>
      </tr>
      <tr>
        <td id="L7101" data-line-number="7101"></td>
        <td id="LC7101">    <span>if</span> (<span>genDoubleAlign</span>())</td>
      </tr>
      <tr>
        <td id="L7102" data-line-number="7102"></td>
        <td id="LC7102">    {</td>
      </tr>
      <tr>
        <td id="L7103" data-line-number="7103"></td>
        <td id="LC7103">        <span><span>//</span> X86 only - account for extra 4-byte pad that may be created by "and  esp, -8"  instruction</span></td>
      </tr>
      <tr>
        <td id="L7104" data-line-number="7104"></td>
        <td id="LC7104">        compCalleeRegsPushed++;</td>
      </tr>
      <tr>
        <td id="L7105" data-line-number="7105"></td>
        <td id="LC7105">    }</td>
      </tr>
      <tr>
        <td id="L7106" data-line-number="7106"></td>
        <td id="LC7106">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L7107" data-line-number="7107"></td>
        <td id="LC7107">
</td>
      </tr>
      <tr>
        <td id="L7108" data-line-number="7108"></td>
        <td id="LC7108">#<span>ifdef</span> TARGET_XARCH</td>
      </tr>
      <tr>
        <td id="L7109" data-line-number="7109"></td>
        <td id="LC7109">    <span><span>//</span> Since FP/EBP is included in the SAVED_REG_MAXSZ we need to</span></td>
      </tr>
      <tr>
        <td id="L7110" data-line-number="7110"></td>
        <td id="LC7110">    <span><span>//</span> subtract 1 register if codeGen-&gt;isFramePointerUsed() is true.</span></td>
      </tr>
      <tr>
        <td id="L7111" data-line-number="7111"></td>
        <td id="LC7111">    <span>if</span> (codeGen-&gt;<span>isFramePointerUsed</span>())</td>
      </tr>
      <tr>
        <td id="L7112" data-line-number="7112"></td>
        <td id="LC7112">    {</td>
      </tr>
      <tr>
        <td id="L7113" data-line-number="7113"></td>
        <td id="LC7113">        compCalleeRegsPushed--;</td>
      </tr>
      <tr>
        <td id="L7114" data-line-number="7114"></td>
        <td id="LC7114">    }</td>
      </tr>
      <tr>
        <td id="L7115" data-line-number="7115"></td>
        <td id="LC7115">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L7116" data-line-number="7116"></td>
        <td id="LC7116">
</td>
      </tr>
      <tr>
        <td id="L7117" data-line-number="7117"></td>
        <td id="LC7117">    <span>lvaAssignFrameOffsets</span>(curState);</td>
      </tr>
      <tr>
        <td id="L7118" data-line-number="7118"></td>
        <td id="LC7118">
</td>
      </tr>
      <tr>
        <td id="L7119" data-line-number="7119"></td>
        <td id="LC7119">    <span>unsigned</span> calleeSavedRegMaxSz = CALLEE_SAVED_REG_MAXSZ;</td>
      </tr>
      <tr>
        <td id="L7120" data-line-number="7120"></td>
        <td id="LC7120">#<span>if</span> defined(TARGET_ARMARCH)</td>
      </tr>
      <tr>
        <td id="L7121" data-line-number="7121"></td>
        <td id="LC7121">    <span>if</span> (compFloatingPointUsed)</td>
      </tr>
      <tr>
        <td id="L7122" data-line-number="7122"></td>
        <td id="LC7122">    {</td>
      </tr>
      <tr>
        <td id="L7123" data-line-number="7123"></td>
        <td id="LC7123">        calleeSavedRegMaxSz += CALLEE_SAVED_FLOAT_MAXSZ;</td>
      </tr>
      <tr>
        <td id="L7124" data-line-number="7124"></td>
        <td id="LC7124">    }</td>
      </tr>
      <tr>
        <td id="L7125" data-line-number="7125"></td>
        <td id="LC7125">    calleeSavedRegMaxSz += REGSIZE_BYTES; <span><span>//</span> we always push LR.  See genPushCalleeSavedRegisters</span></td>
      </tr>
      <tr>
        <td id="L7126" data-line-number="7126"></td>
        <td id="LC7126">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L7127" data-line-number="7127"></td>
        <td id="LC7127">
</td>
      </tr>
      <tr>
        <td id="L7128" data-line-number="7128"></td>
        <td id="LC7128">    result = compLclFrameSize + calleeSavedRegMaxSz;</td>
      </tr>
      <tr>
        <td id="L7129" data-line-number="7129"></td>
        <td id="LC7129">    <span>return</span> result;</td>
      </tr>
      <tr>
        <td id="L7130" data-line-number="7130"></td>
        <td id="LC7130">}</td>
      </tr>
      <tr>
        <td id="L7131" data-line-number="7131"></td>
        <td id="LC7131">
</td>
      </tr>
      <tr>
        <td id="L7132" data-line-number="7132"></td>
        <td id="LC7132"><span><span>//</span>------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L7133" data-line-number="7133"></td>
        <td id="LC7133"><span><span>//</span> lvaGetSPRelativeOffset: Given a variable, return the offset of that</span></td>
      </tr>
      <tr>
        <td id="L7134" data-line-number="7134"></td>
        <td id="LC7134"><span><span>//</span> variable in the frame from the stack pointer. This number will be positive,</span></td>
      </tr>
      <tr>
        <td id="L7135" data-line-number="7135"></td>
        <td id="LC7135"><span><span>//</span> since the stack pointer must be at a lower address than everything on the</span></td>
      </tr>
      <tr>
        <td id="L7136" data-line-number="7136"></td>
        <td id="LC7136"><span><span>//</span> stack.</span></td>
      </tr>
      <tr>
        <td id="L7137" data-line-number="7137"></td>
        <td id="LC7137"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7138" data-line-number="7138"></td>
        <td id="LC7138"><span><span>//</span> This can't be called for localloc functions, since the stack pointer</span></td>
      </tr>
      <tr>
        <td id="L7139" data-line-number="7139"></td>
        <td id="LC7139"><span><span>//</span> varies, and thus there is no fixed offset to a variable from the stack pointer.</span></td>
      </tr>
      <tr>
        <td id="L7140" data-line-number="7140"></td>
        <td id="LC7140"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7141" data-line-number="7141"></td>
        <td id="LC7141"><span><span>//</span> Arguments:</span></td>
      </tr>
      <tr>
        <td id="L7142" data-line-number="7142"></td>
        <td id="LC7142"><span><span>//</span>    varNum - the variable number</span></td>
      </tr>
      <tr>
        <td id="L7143" data-line-number="7143"></td>
        <td id="LC7143"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7144" data-line-number="7144"></td>
        <td id="LC7144"><span><span>//</span> Return Value:</span></td>
      </tr>
      <tr>
        <td id="L7145" data-line-number="7145"></td>
        <td id="LC7145"><span><span>//</span>    The offset.</span></td>
      </tr>
      <tr>
        <td id="L7146" data-line-number="7146"></td>
        <td id="LC7146">
</td>
      </tr>
      <tr>
        <td id="L7147" data-line-number="7147"></td>
        <td id="LC7147"><span>int</span> <span>Compiler::lvaGetSPRelativeOffset</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L7148" data-line-number="7148"></td>
        <td id="LC7148">{</td>
      </tr>
      <tr>
        <td id="L7149" data-line-number="7149"></td>
        <td id="LC7149">    <span>assert</span>(!compLocallocUsed);</td>
      </tr>
      <tr>
        <td id="L7150" data-line-number="7150"></td>
        <td id="LC7150">    <span>assert</span>(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);</td>
      </tr>
      <tr>
        <td id="L7151" data-line-number="7151"></td>
        <td id="LC7151">    <span>assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L7152" data-line-number="7152"></td>
        <td id="LC7152">    <span>const</span> LclVarDsc* varDsc = lvaTable + varNum;</td>
      </tr>
      <tr>
        <td id="L7153" data-line-number="7153"></td>
        <td id="LC7153">    <span>assert</span>(varDsc-&gt;<span>lvOnFrame</span>);</td>
      </tr>
      <tr>
        <td id="L7154" data-line-number="7154"></td>
        <td id="LC7154">    <span>int</span> spRelativeOffset;</td>
      </tr>
      <tr>
        <td id="L7155" data-line-number="7155"></td>
        <td id="LC7155">
</td>
      </tr>
      <tr>
        <td id="L7156" data-line-number="7156"></td>
        <td id="LC7156">    <span>if</span> (varDsc-&gt;<span>lvFramePointerBased</span>)</td>
      </tr>
      <tr>
        <td id="L7157" data-line-number="7157"></td>
        <td id="LC7157">    {</td>
      </tr>
      <tr>
        <td id="L7158" data-line-number="7158"></td>
        <td id="LC7158">        <span><span>//</span> The stack offset is relative to the frame pointer, so convert it to be</span></td>
      </tr>
      <tr>
        <td id="L7159" data-line-number="7159"></td>
        <td id="LC7159">        <span><span>//</span> relative to the stack pointer (which makes no sense for localloc functions).</span></td>
      </tr>
      <tr>
        <td id="L7160" data-line-number="7160"></td>
        <td id="LC7160">        spRelativeOffset = varDsc-&gt;<span>lvStkOffs</span> + codeGen-&gt;<span>genSPtoFPdelta</span>();</td>
      </tr>
      <tr>
        <td id="L7161" data-line-number="7161"></td>
        <td id="LC7161">    }</td>
      </tr>
      <tr>
        <td id="L7162" data-line-number="7162"></td>
        <td id="LC7162">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7163" data-line-number="7163"></td>
        <td id="LC7163">    {</td>
      </tr>
      <tr>
        <td id="L7164" data-line-number="7164"></td>
        <td id="LC7164">        spRelativeOffset = varDsc-&gt;<span>lvStkOffs</span>;</td>
      </tr>
      <tr>
        <td id="L7165" data-line-number="7165"></td>
        <td id="LC7165">    }</td>
      </tr>
      <tr>
        <td id="L7166" data-line-number="7166"></td>
        <td id="LC7166">
</td>
      </tr>
      <tr>
        <td id="L7167" data-line-number="7167"></td>
        <td id="LC7167">    <span>assert</span>(spRelativeOffset &gt;= <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L7168" data-line-number="7168"></td>
        <td id="LC7168">    <span>return</span> spRelativeOffset;</td>
      </tr>
      <tr>
        <td id="L7169" data-line-number="7169"></td>
        <td id="LC7169">}</td>
      </tr>
      <tr>
        <td id="L7170" data-line-number="7170"></td>
        <td id="LC7170">
</td>
      </tr>
      <tr>
        <td id="L7171" data-line-number="7171"></td>
        <td id="LC7171"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L7172" data-line-number="7172"></td>
        <td id="LC7172"><span> *</span></td>
      </tr>
      <tr>
        <td id="L7173" data-line-number="7173"></td>
        <td id="LC7173"><span> *  Return the caller-SP-relative stack offset of a local/parameter.</span></td>
      </tr>
      <tr>
        <td id="L7174" data-line-number="7174"></td>
        <td id="LC7174"><span> *  Requires the local to be on the stack and frame layout to be complete.</span></td>
      </tr>
      <tr>
        <td id="L7175" data-line-number="7175"></td>
        <td id="LC7175"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7176" data-line-number="7176"></td>
        <td id="LC7176">
</td>
      </tr>
      <tr>
        <td id="L7177" data-line-number="7177"></td>
        <td id="LC7177"><span>int</span> <span>Compiler::lvaGetCallerSPRelativeOffset</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L7178" data-line-number="7178"></td>
        <td id="LC7178">{</td>
      </tr>
      <tr>
        <td id="L7179" data-line-number="7179"></td>
        <td id="LC7179">    <span>assert</span>(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);</td>
      </tr>
      <tr>
        <td id="L7180" data-line-number="7180"></td>
        <td id="LC7180">    <span>assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L7181" data-line-number="7181"></td>
        <td id="LC7181">    LclVarDsc* varDsc = lvaTable + varNum;</td>
      </tr>
      <tr>
        <td id="L7182" data-line-number="7182"></td>
        <td id="LC7182">    <span>assert</span>(varDsc-&gt;<span>lvOnFrame</span>);</td>
      </tr>
      <tr>
        <td id="L7183" data-line-number="7183"></td>
        <td id="LC7183">
</td>
      </tr>
      <tr>
        <td id="L7184" data-line-number="7184"></td>
        <td id="LC7184">    <span>return</span> <span>lvaToCallerSPRelativeOffset</span>(varDsc-&gt;<span>lvStkOffs</span>, varDsc-&gt;<span>lvFramePointerBased</span>);</td>
      </tr>
      <tr>
        <td id="L7185" data-line-number="7185"></td>
        <td id="LC7185">}</td>
      </tr>
      <tr>
        <td id="L7186" data-line-number="7186"></td>
        <td id="LC7186">
</td>
      </tr>
      <tr>
        <td id="L7187" data-line-number="7187"></td>
        <td id="LC7187"><span>int</span> <span>Compiler::lvaToCallerSPRelativeOffset</span>(<span>int</span> offset, <span>bool</span> isFpBased) <span>const</span></td>
      </tr>
      <tr>
        <td id="L7188" data-line-number="7188"></td>
        <td id="LC7188">{</td>
      </tr>
      <tr>
        <td id="L7189" data-line-number="7189"></td>
        <td id="LC7189">    <span>assert</span>(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);</td>
      </tr>
      <tr>
        <td id="L7190" data-line-number="7190"></td>
        <td id="LC7190">
</td>
      </tr>
      <tr>
        <td id="L7191" data-line-number="7191"></td>
        <td id="LC7191">    <span>if</span> (isFpBased)</td>
      </tr>
      <tr>
        <td id="L7192" data-line-number="7192"></td>
        <td id="LC7192">    {</td>
      </tr>
      <tr>
        <td id="L7193" data-line-number="7193"></td>
        <td id="LC7193">        offset += codeGen-&gt;<span>genCallerSPtoFPdelta</span>();</td>
      </tr>
      <tr>
        <td id="L7194" data-line-number="7194"></td>
        <td id="LC7194">    }</td>
      </tr>
      <tr>
        <td id="L7195" data-line-number="7195"></td>
        <td id="LC7195">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7196" data-line-number="7196"></td>
        <td id="LC7196">    {</td>
      </tr>
      <tr>
        <td id="L7197" data-line-number="7197"></td>
        <td id="LC7197">        offset += codeGen-&gt;<span>genCallerSPtoInitialSPdelta</span>();</td>
      </tr>
      <tr>
        <td id="L7198" data-line-number="7198"></td>
        <td id="LC7198">    }</td>
      </tr>
      <tr>
        <td id="L7199" data-line-number="7199"></td>
        <td id="LC7199">
</td>
      </tr>
      <tr>
        <td id="L7200" data-line-number="7200"></td>
        <td id="LC7200">    <span>return</span> offset;</td>
      </tr>
      <tr>
        <td id="L7201" data-line-number="7201"></td>
        <td id="LC7201">}</td>
      </tr>
      <tr>
        <td id="L7202" data-line-number="7202"></td>
        <td id="LC7202">
</td>
      </tr>
      <tr>
        <td id="L7203" data-line-number="7203"></td>
        <td id="LC7203"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L7204" data-line-number="7204"></td>
        <td id="LC7204"><span> *</span></td>
      </tr>
      <tr>
        <td id="L7205" data-line-number="7205"></td>
        <td id="LC7205"><span> *  Return the Initial-SP-relative stack offset of a local/parameter.</span></td>
      </tr>
      <tr>
        <td id="L7206" data-line-number="7206"></td>
        <td id="LC7206"><span> *  Requires the local to be on the stack and frame layout to be complete.</span></td>
      </tr>
      <tr>
        <td id="L7207" data-line-number="7207"></td>
        <td id="LC7207"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7208" data-line-number="7208"></td>
        <td id="LC7208">
</td>
      </tr>
      <tr>
        <td id="L7209" data-line-number="7209"></td>
        <td id="LC7209"><span>int</span> <span>Compiler::lvaGetInitialSPRelativeOffset</span>(<span>unsigned</span> varNum)</td>
      </tr>
      <tr>
        <td id="L7210" data-line-number="7210"></td>
        <td id="LC7210">{</td>
      </tr>
      <tr>
        <td id="L7211" data-line-number="7211"></td>
        <td id="LC7211">    <span>assert</span>(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);</td>
      </tr>
      <tr>
        <td id="L7212" data-line-number="7212"></td>
        <td id="LC7212">    <span>assert</span>(varNum &lt; lvaCount);</td>
      </tr>
      <tr>
        <td id="L7213" data-line-number="7213"></td>
        <td id="LC7213">    LclVarDsc* varDsc = lvaTable + varNum;</td>
      </tr>
      <tr>
        <td id="L7214" data-line-number="7214"></td>
        <td id="LC7214">    <span>assert</span>(varDsc-&gt;<span>lvOnFrame</span>);</td>
      </tr>
      <tr>
        <td id="L7215" data-line-number="7215"></td>
        <td id="LC7215">
</td>
      </tr>
      <tr>
        <td id="L7216" data-line-number="7216"></td>
        <td id="LC7216">    <span>return</span> <span>lvaToInitialSPRelativeOffset</span>(varDsc-&gt;<span>lvStkOffs</span>, varDsc-&gt;<span>lvFramePointerBased</span>);</td>
      </tr>
      <tr>
        <td id="L7217" data-line-number="7217"></td>
        <td id="LC7217">}</td>
      </tr>
      <tr>
        <td id="L7218" data-line-number="7218"></td>
        <td id="LC7218">
</td>
      </tr>
      <tr>
        <td id="L7219" data-line-number="7219"></td>
        <td id="LC7219"><span><span>//</span> Given a local variable offset, and whether that offset is frame-pointer based, return its offset from Initial-SP.</span></td>
      </tr>
      <tr>
        <td id="L7220" data-line-number="7220"></td>
        <td id="LC7220"><span><span>//</span> This is used, for example, to figure out the offset of the frame pointer from Initial-SP.</span></td>
      </tr>
      <tr>
        <td id="L7221" data-line-number="7221"></td>
        <td id="LC7221"><span>int</span> <span>Compiler::lvaToInitialSPRelativeOffset</span>(<span>unsigned</span> offset, <span>bool</span> isFpBased)</td>
      </tr>
      <tr>
        <td id="L7222" data-line-number="7222"></td>
        <td id="LC7222">{</td>
      </tr>
      <tr>
        <td id="L7223" data-line-number="7223"></td>
        <td id="LC7223">    <span>assert</span>(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);</td>
      </tr>
      <tr>
        <td id="L7224" data-line-number="7224"></td>
        <td id="LC7224">#<span>ifdef</span> TARGET_AMD64</td>
      </tr>
      <tr>
        <td id="L7225" data-line-number="7225"></td>
        <td id="LC7225">    <span>if</span> (isFpBased)</td>
      </tr>
      <tr>
        <td id="L7226" data-line-number="7226"></td>
        <td id="LC7226">    {</td>
      </tr>
      <tr>
        <td id="L7227" data-line-number="7227"></td>
        <td id="LC7227">        <span><span>//</span> Currently, the frame starts by pushing ebp, ebp points to the saved ebp</span></td>
      </tr>
      <tr>
        <td id="L7228" data-line-number="7228"></td>
        <td id="LC7228">        <span><span>//</span> (so we have ebp pointer chaining). Add the fixed-size frame size plus the</span></td>
      </tr>
      <tr>
        <td id="L7229" data-line-number="7229"></td>
        <td id="LC7229">        <span><span>//</span> size of the callee-saved regs (not including ebp itself) to find Initial-SP.</span></td>
      </tr>
      <tr>
        <td id="L7230" data-line-number="7230"></td>
        <td id="LC7230">
</td>
      </tr>
      <tr>
        <td id="L7231" data-line-number="7231"></td>
        <td id="LC7231">        <span>assert</span>(codeGen-&gt;<span>isFramePointerUsed</span>());</td>
      </tr>
      <tr>
        <td id="L7232" data-line-number="7232"></td>
        <td id="LC7232">        offset += codeGen-&gt;<span>genSPtoFPdelta</span>();</td>
      </tr>
      <tr>
        <td id="L7233" data-line-number="7233"></td>
        <td id="LC7233">    }</td>
      </tr>
      <tr>
        <td id="L7234" data-line-number="7234"></td>
        <td id="LC7234">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7235" data-line-number="7235"></td>
        <td id="LC7235">    {</td>
      </tr>
      <tr>
        <td id="L7236" data-line-number="7236"></td>
        <td id="LC7236">        <span><span>//</span> The offset is correct already!</span></td>
      </tr>
      <tr>
        <td id="L7237" data-line-number="7237"></td>
        <td id="LC7237">    }</td>
      </tr>
      <tr>
        <td id="L7238" data-line-number="7238"></td>
        <td id="LC7238">#<span>else</span>  <span><span>//</span> !TARGET_AMD64</span></td>
      </tr>
      <tr>
        <td id="L7239" data-line-number="7239"></td>
        <td id="LC7239">    <span>NYI</span>(<span><span>"</span>lvaToInitialSPRelativeOffset<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7240" data-line-number="7240"></td>
        <td id="LC7240">#<span>endif</span> <span><span>//</span> !TARGET_AMD64</span></td>
      </tr>
      <tr>
        <td id="L7241" data-line-number="7241"></td>
        <td id="LC7241">
</td>
      </tr>
      <tr>
        <td id="L7242" data-line-number="7242"></td>
        <td id="LC7242">    <span>return</span> offset;</td>
      </tr>
      <tr>
        <td id="L7243" data-line-number="7243"></td>
        <td id="LC7243">}</td>
      </tr>
      <tr>
        <td id="L7244" data-line-number="7244"></td>
        <td id="LC7244">
</td>
      </tr>
      <tr>
        <td id="L7245" data-line-number="7245"></td>
        <td id="LC7245"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7246" data-line-number="7246"></td>
        <td id="LC7246">
</td>
      </tr>
      <tr>
        <td id="L7247" data-line-number="7247"></td>
        <td id="LC7247">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L7248" data-line-number="7248"></td>
        <td id="LC7248"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L7249" data-line-number="7249"></td>
        <td id="LC7249"><span> *  Pick a padding size at "random" for the local.</span></td>
      </tr>
      <tr>
        <td id="L7250" data-line-number="7250"></td>
        <td id="LC7250"><span> *  0 means that it should not be converted to a GT_LCL_FLD</span></td>
      </tr>
      <tr>
        <td id="L7251" data-line-number="7251"></td>
        <td id="LC7251"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7252" data-line-number="7252"></td>
        <td id="LC7252">
</td>
      </tr>
      <tr>
        <td id="L7253" data-line-number="7253"></td>
        <td id="LC7253"><span>static</span> <span>unsigned</span> <span>LCL_FLD_PADDING</span>(<span>unsigned</span> lclNum)</td>
      </tr>
      <tr>
        <td id="L7254" data-line-number="7254"></td>
        <td id="LC7254">{</td>
      </tr>
      <tr>
        <td id="L7255" data-line-number="7255"></td>
        <td id="LC7255">    <span><span>//</span> Convert every 2nd variable</span></td>
      </tr>
      <tr>
        <td id="L7256" data-line-number="7256"></td>
        <td id="LC7256">    <span>if</span> (lclNum % <span>2</span>)</td>
      </tr>
      <tr>
        <td id="L7257" data-line-number="7257"></td>
        <td id="LC7257">    {</td>
      </tr>
      <tr>
        <td id="L7258" data-line-number="7258"></td>
        <td id="LC7258">        <span>return</span> <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L7259" data-line-number="7259"></td>
        <td id="LC7259">    }</td>
      </tr>
      <tr>
        <td id="L7260" data-line-number="7260"></td>
        <td id="LC7260">
</td>
      </tr>
      <tr>
        <td id="L7261" data-line-number="7261"></td>
        <td id="LC7261">    <span><span>//</span> Pick a padding size at "random"</span></td>
      </tr>
      <tr>
        <td id="L7262" data-line-number="7262"></td>
        <td id="LC7262">    <span>unsigned</span> size = lclNum % <span>7</span>;</td>
      </tr>
      <tr>
        <td id="L7263" data-line-number="7263"></td>
        <td id="LC7263">
</td>
      </tr>
      <tr>
        <td id="L7264" data-line-number="7264"></td>
        <td id="LC7264">    <span>return</span> size;</td>
      </tr>
      <tr>
        <td id="L7265" data-line-number="7265"></td>
        <td id="LC7265">}</td>
      </tr>
      <tr>
        <td id="L7266" data-line-number="7266"></td>
        <td id="LC7266">
</td>
      </tr>
      <tr>
        <td id="L7267" data-line-number="7267"></td>
        <td id="LC7267"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L7268" data-line-number="7268"></td>
        <td id="LC7268"><span> *</span></td>
      </tr>
      <tr>
        <td id="L7269" data-line-number="7269"></td>
        <td id="LC7269"><span> *  Callback for fgWalkAllTreesPre()</span></td>
      </tr>
      <tr>
        <td id="L7270" data-line-number="7270"></td>
        <td id="LC7270"><span> *  Convert as many GT_LCL_VAR's to GT_LCL_FLD's</span></td>
      </tr>
      <tr>
        <td id="L7271" data-line-number="7271"></td>
        <td id="LC7271"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7272" data-line-number="7272"></td>
        <td id="LC7272">
</td>
      </tr>
      <tr>
        <td id="L7273" data-line-number="7273"></td>
        <td id="LC7273"><span><span>/*</span> static <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7274" data-line-number="7274"></td>
        <td id="LC7274"><span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L7275" data-line-number="7275"></td>
        <td id="LC7275"><span>    The stress mode does 2 passes.</span></td>
      </tr>
      <tr>
        <td id="L7276" data-line-number="7276"></td>
        <td id="LC7276"><span></span></td>
      </tr>
      <tr>
        <td id="L7277" data-line-number="7277"></td>
        <td id="LC7277"><span>    In the first pass we will mark the locals where we CAN't apply the stress mode.</span></td>
      </tr>
      <tr>
        <td id="L7278" data-line-number="7278"></td>
        <td id="LC7278"><span>    In the second pass we will do the appropiate morphing wherever we've not determined we can't do it.</span></td>
      </tr>
      <tr>
        <td id="L7279" data-line-number="7279"></td>
        <td id="LC7279"><span><span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7280" data-line-number="7280"></td>
        <td id="LC7280">Compiler::fgWalkResult <span>Compiler::lvaStressLclFldCB</span>(GenTree** pTree, fgWalkData* data)</td>
      </tr>
      <tr>
        <td id="L7281" data-line-number="7281"></td>
        <td id="LC7281">{</td>
      </tr>
      <tr>
        <td id="L7282" data-line-number="7282"></td>
        <td id="LC7282">    GenTree*   tree = *pTree;</td>
      </tr>
      <tr>
        <td id="L7283" data-line-number="7283"></td>
        <td id="LC7283">    genTreeOps oper = tree-&gt;<span>OperGet</span>();</td>
      </tr>
      <tr>
        <td id="L7284" data-line-number="7284"></td>
        <td id="LC7284">    GenTree*   lcl;</td>
      </tr>
      <tr>
        <td id="L7285" data-line-number="7285"></td>
        <td id="LC7285">
</td>
      </tr>
      <tr>
        <td id="L7286" data-line-number="7286"></td>
        <td id="LC7286">    <span>switch</span> (oper)</td>
      </tr>
      <tr>
        <td id="L7287" data-line-number="7287"></td>
        <td id="LC7287">    {</td>
      </tr>
      <tr>
        <td id="L7288" data-line-number="7288"></td>
        <td id="LC7288">        <span>case</span> GT_LCL_VAR:</td>
      </tr>
      <tr>
        <td id="L7289" data-line-number="7289"></td>
        <td id="LC7289">        <span>case</span> GT_LCL_VAR_ADDR:</td>
      </tr>
      <tr>
        <td id="L7290" data-line-number="7290"></td>
        <td id="LC7290">            lcl = tree;</td>
      </tr>
      <tr>
        <td id="L7291" data-line-number="7291"></td>
        <td id="LC7291">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L7292" data-line-number="7292"></td>
        <td id="LC7292">
</td>
      </tr>
      <tr>
        <td id="L7293" data-line-number="7293"></td>
        <td id="LC7293">        <span>case</span> GT_ADDR:</td>
      </tr>
      <tr>
        <td id="L7294" data-line-number="7294"></td>
        <td id="LC7294">            <span>if</span> (tree-&gt;<span>AsOp</span>()-&gt;<span>gtOp1</span>-&gt;<span>gtOper</span> != GT_LCL_VAR)</td>
      </tr>
      <tr>
        <td id="L7295" data-line-number="7295"></td>
        <td id="LC7295">            {</td>
      </tr>
      <tr>
        <td id="L7296" data-line-number="7296"></td>
        <td id="LC7296">                <span>return</span> WALK_CONTINUE;</td>
      </tr>
      <tr>
        <td id="L7297" data-line-number="7297"></td>
        <td id="LC7297">            }</td>
      </tr>
      <tr>
        <td id="L7298" data-line-number="7298"></td>
        <td id="LC7298">            lcl = tree-&gt;<span>AsOp</span>()-&gt;<span>gtOp1</span>;</td>
      </tr>
      <tr>
        <td id="L7299" data-line-number="7299"></td>
        <td id="LC7299">            <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L7300" data-line-number="7300"></td>
        <td id="LC7300">
</td>
      </tr>
      <tr>
        <td id="L7301" data-line-number="7301"></td>
        <td id="LC7301">        <span>default</span>:</td>
      </tr>
      <tr>
        <td id="L7302" data-line-number="7302"></td>
        <td id="LC7302">            <span>return</span> WALK_CONTINUE;</td>
      </tr>
      <tr>
        <td id="L7303" data-line-number="7303"></td>
        <td id="LC7303">    }</td>
      </tr>
      <tr>
        <td id="L7304" data-line-number="7304"></td>
        <td id="LC7304">
</td>
      </tr>
      <tr>
        <td id="L7305" data-line-number="7305"></td>
        <td id="LC7305">    <span>noway_assert</span>(lcl-&gt;<span>OperIs</span>(GT_LCL_VAR, GT_LCL_VAR_ADDR));</td>
      </tr>
      <tr>
        <td id="L7306" data-line-number="7306"></td>
        <td id="LC7306">
</td>
      </tr>
      <tr>
        <td id="L7307" data-line-number="7307"></td>
        <td id="LC7307">    Compiler* <span>const</span>  pComp      = ((lvaStressLclFldArgs*)data-&gt;<span>pCallbackData</span>)-&gt;<span>m_pCompiler</span>;</td>
      </tr>
      <tr>
        <td id="L7308" data-line-number="7308"></td>
        <td id="LC7308">    <span>const</span> <span>bool</span>       bFirstPass = ((lvaStressLclFldArgs*)data-&gt;<span>pCallbackData</span>)-&gt;<span>m_bFirstPass</span>;</td>
      </tr>
      <tr>
        <td id="L7309" data-line-number="7309"></td>
        <td id="LC7309">    <span>const</span> <span>unsigned</span>   lclNum     = lcl-&gt;<span>AsLclVarCommon</span>()-&gt;<span>GetLclNum</span>();</td>
      </tr>
      <tr>
        <td id="L7310" data-line-number="7310"></td>
        <td id="LC7310">    var_types        type       = lcl-&gt;<span>TypeGet</span>();</td>
      </tr>
      <tr>
        <td id="L7311" data-line-number="7311"></td>
        <td id="LC7311">    LclVarDsc* <span>const</span> varDsc     = pComp-&gt;<span>lvaGetDesc</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L7312" data-line-number="7312"></td>
        <td id="LC7312">
</td>
      </tr>
      <tr>
        <td id="L7313" data-line-number="7313"></td>
        <td id="LC7313">    <span>if</span> (varDsc-&gt;<span>lvNoLclFldStress</span>)</td>
      </tr>
      <tr>
        <td id="L7314" data-line-number="7314"></td>
        <td id="LC7314">    {</td>
      </tr>
      <tr>
        <td id="L7315" data-line-number="7315"></td>
        <td id="LC7315">        <span><span>//</span> Already determined we can't do anything for this var</span></td>
      </tr>
      <tr>
        <td id="L7316" data-line-number="7316"></td>
        <td id="LC7316">        <span>return</span> WALK_SKIP_SUBTREES;</td>
      </tr>
      <tr>
        <td id="L7317" data-line-number="7317"></td>
        <td id="LC7317">    }</td>
      </tr>
      <tr>
        <td id="L7318" data-line-number="7318"></td>
        <td id="LC7318">
</td>
      </tr>
      <tr>
        <td id="L7319" data-line-number="7319"></td>
        <td id="LC7319">    <span>if</span> (bFirstPass)</td>
      </tr>
      <tr>
        <td id="L7320" data-line-number="7320"></td>
        <td id="LC7320">    {</td>
      </tr>
      <tr>
        <td id="L7321" data-line-number="7321"></td>
        <td id="LC7321">        <span><span>//</span> Ignore arguments and temps</span></td>
      </tr>
      <tr>
        <td id="L7322" data-line-number="7322"></td>
        <td id="LC7322">        <span>if</span> (varDsc-&gt;<span>lvIsParam</span> || lclNum &gt;= pComp-&gt;<span>info</span>.<span>compLocalsCount</span>)</td>
      </tr>
      <tr>
        <td id="L7323" data-line-number="7323"></td>
        <td id="LC7323">        {</td>
      </tr>
      <tr>
        <td id="L7324" data-line-number="7324"></td>
        <td id="LC7324">            varDsc-&gt;<span>lvNoLclFldStress</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7325" data-line-number="7325"></td>
        <td id="LC7325">            <span>return</span> WALK_SKIP_SUBTREES;</td>
      </tr>
      <tr>
        <td id="L7326" data-line-number="7326"></td>
        <td id="LC7326">        }</td>
      </tr>
      <tr>
        <td id="L7327" data-line-number="7327"></td>
        <td id="LC7327">
</td>
      </tr>
      <tr>
        <td id="L7328" data-line-number="7328"></td>
        <td id="LC7328">        <span><span>//</span> Fix for lcl_fld stress mode</span></td>
      </tr>
      <tr>
        <td id="L7329" data-line-number="7329"></td>
        <td id="LC7329">        <span>if</span> (varDsc-&gt;<span>lvKeepType</span>)</td>
      </tr>
      <tr>
        <td id="L7330" data-line-number="7330"></td>
        <td id="LC7330">        {</td>
      </tr>
      <tr>
        <td id="L7331" data-line-number="7331"></td>
        <td id="LC7331">            varDsc-&gt;<span>lvNoLclFldStress</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7332" data-line-number="7332"></td>
        <td id="LC7332">            <span>return</span> WALK_SKIP_SUBTREES;</td>
      </tr>
      <tr>
        <td id="L7333" data-line-number="7333"></td>
        <td id="LC7333">        }</td>
      </tr>
      <tr>
        <td id="L7334" data-line-number="7334"></td>
        <td id="LC7334">
</td>
      </tr>
      <tr>
        <td id="L7335" data-line-number="7335"></td>
        <td id="LC7335">        <span><span>//</span> Can't have GC ptrs in TYP_BLK.</span></td>
      </tr>
      <tr>
        <td id="L7336" data-line-number="7336"></td>
        <td id="LC7336">        <span>if</span> (!<span>varTypeIsArithmetic</span>(type))</td>
      </tr>
      <tr>
        <td id="L7337" data-line-number="7337"></td>
        <td id="LC7337">        {</td>
      </tr>
      <tr>
        <td id="L7338" data-line-number="7338"></td>
        <td id="LC7338">            varDsc-&gt;<span>lvNoLclFldStress</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7339" data-line-number="7339"></td>
        <td id="LC7339">            <span>return</span> WALK_SKIP_SUBTREES;</td>
      </tr>
      <tr>
        <td id="L7340" data-line-number="7340"></td>
        <td id="LC7340">        }</td>
      </tr>
      <tr>
        <td id="L7341" data-line-number="7341"></td>
        <td id="LC7341">
</td>
      </tr>
      <tr>
        <td id="L7342" data-line-number="7342"></td>
        <td id="LC7342">        <span><span>//</span> The noway_assert in the second pass below, requires that these types match, or we have a TYP_BLK</span></td>
      </tr>
      <tr>
        <td id="L7343" data-line-number="7343"></td>
        <td id="LC7343">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7344" data-line-number="7344"></td>
        <td id="LC7344">        <span>if</span> ((varDsc-&gt;<span>lvType</span> != lcl-&gt;<span>gtType</span>) &amp;&amp; (varDsc-&gt;<span>lvType</span> != TYP_BLK))</td>
      </tr>
      <tr>
        <td id="L7345" data-line-number="7345"></td>
        <td id="LC7345">        {</td>
      </tr>
      <tr>
        <td id="L7346" data-line-number="7346"></td>
        <td id="LC7346">            varDsc-&gt;<span>lvNoLclFldStress</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7347" data-line-number="7347"></td>
        <td id="LC7347">            <span>return</span> WALK_SKIP_SUBTREES;</td>
      </tr>
      <tr>
        <td id="L7348" data-line-number="7348"></td>
        <td id="LC7348">        }</td>
      </tr>
      <tr>
        <td id="L7349" data-line-number="7349"></td>
        <td id="LC7349">
</td>
      </tr>
      <tr>
        <td id="L7350" data-line-number="7350"></td>
        <td id="LC7350">        <span><span>//</span> Weed out "small" types like TYP_BYTE as we don't mark the GT_LCL_VAR</span></td>
      </tr>
      <tr>
        <td id="L7351" data-line-number="7351"></td>
        <td id="LC7351">        <span><span>//</span> node with the accurate small type. If we bash lvaTable[].lvType,</span></td>
      </tr>
      <tr>
        <td id="L7352" data-line-number="7352"></td>
        <td id="LC7352">        <span><span>//</span> then there will be no indication that it was ever a small type.</span></td>
      </tr>
      <tr>
        <td id="L7353" data-line-number="7353"></td>
        <td id="LC7353">        var_types varType = varDsc-&gt;<span>TypeGet</span>();</td>
      </tr>
      <tr>
        <td id="L7354" data-line-number="7354"></td>
        <td id="LC7354">        <span>if</span> (varType != TYP_BLK &amp;&amp; <span>genTypeSize</span>(varType) != <span>genTypeSize</span>(<span>genActualType</span>(varType)))</td>
      </tr>
      <tr>
        <td id="L7355" data-line-number="7355"></td>
        <td id="LC7355">        {</td>
      </tr>
      <tr>
        <td id="L7356" data-line-number="7356"></td>
        <td id="LC7356">            varDsc-&gt;<span>lvNoLclFldStress</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7357" data-line-number="7357"></td>
        <td id="LC7357">            <span>return</span> WALK_SKIP_SUBTREES;</td>
      </tr>
      <tr>
        <td id="L7358" data-line-number="7358"></td>
        <td id="LC7358">        }</td>
      </tr>
      <tr>
        <td id="L7359" data-line-number="7359"></td>
        <td id="LC7359">
</td>
      </tr>
      <tr>
        <td id="L7360" data-line-number="7360"></td>
        <td id="LC7360">        <span><span>//</span> Offset some of the local variable by a "random" non-zero amount</span></td>
      </tr>
      <tr>
        <td id="L7361" data-line-number="7361"></td>
        <td id="LC7361">        <span>unsigned</span> padding = <span>LCL_FLD_PADDING</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L7362" data-line-number="7362"></td>
        <td id="LC7362">        <span>if</span> (padding == <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L7363" data-line-number="7363"></td>
        <td id="LC7363">        {</td>
      </tr>
      <tr>
        <td id="L7364" data-line-number="7364"></td>
        <td id="LC7364">            varDsc-&gt;<span>lvNoLclFldStress</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7365" data-line-number="7365"></td>
        <td id="LC7365">            <span>return</span> WALK_SKIP_SUBTREES;</td>
      </tr>
      <tr>
        <td id="L7366" data-line-number="7366"></td>
        <td id="LC7366">        }</td>
      </tr>
      <tr>
        <td id="L7367" data-line-number="7367"></td>
        <td id="LC7367">    }</td>
      </tr>
      <tr>
        <td id="L7368" data-line-number="7368"></td>
        <td id="LC7368">    <span>else</span></td>
      </tr>
      <tr>
        <td id="L7369" data-line-number="7369"></td>
        <td id="LC7369">    {</td>
      </tr>
      <tr>
        <td id="L7370" data-line-number="7370"></td>
        <td id="LC7370">        <span><span>//</span> Do the morphing</span></td>
      </tr>
      <tr>
        <td id="L7371" data-line-number="7371"></td>
        <td id="LC7371">        <span>noway_assert</span>((varDsc-&gt;<span>lvType</span> == lcl-&gt;<span>gtType</span>) || (varDsc-&gt;<span>lvType</span> == TYP_BLK));</td>
      </tr>
      <tr>
        <td id="L7372" data-line-number="7372"></td>
        <td id="LC7372">        var_types varType = varDsc-&gt;<span>TypeGet</span>();</td>
      </tr>
      <tr>
        <td id="L7373" data-line-number="7373"></td>
        <td id="LC7373">
</td>
      </tr>
      <tr>
        <td id="L7374" data-line-number="7374"></td>
        <td id="LC7374">        <span><span>//</span> Calculate padding</span></td>
      </tr>
      <tr>
        <td id="L7375" data-line-number="7375"></td>
        <td id="LC7375">        <span>unsigned</span> padding = <span>LCL_FLD_PADDING</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L7376" data-line-number="7376"></td>
        <td id="LC7376">
</td>
      </tr>
      <tr>
        <td id="L7377" data-line-number="7377"></td>
        <td id="LC7377">#<span>ifdef</span> TARGET_ARMARCH</td>
      </tr>
      <tr>
        <td id="L7378" data-line-number="7378"></td>
        <td id="LC7378">        <span><span>//</span> We need to support alignment requirements to access memory on ARM ARCH</span></td>
      </tr>
      <tr>
        <td id="L7379" data-line-number="7379"></td>
        <td id="LC7379">        <span>unsigned</span> alignment = <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L7380" data-line-number="7380"></td>
        <td id="LC7380">        pComp-&gt;<span>codeGen</span>-&gt;<span>InferOpSizeAlign</span>(lcl, &amp;alignment);</td>
      </tr>
      <tr>
        <td id="L7381" data-line-number="7381"></td>
        <td id="LC7381">        alignment = <span>roundUp</span>(alignment, TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L7382" data-line-number="7382"></td>
        <td id="LC7382">        padding   = <span>roundUp</span>(padding, alignment);</td>
      </tr>
      <tr>
        <td id="L7383" data-line-number="7383"></td>
        <td id="LC7383">#<span>endif</span> <span><span>//</span> TARGET_ARMARCH</span></td>
      </tr>
      <tr>
        <td id="L7384" data-line-number="7384"></td>
        <td id="LC7384">
</td>
      </tr>
      <tr>
        <td id="L7385" data-line-number="7385"></td>
        <td id="LC7385">        <span><span>//</span> Change the variable to a TYP_BLK</span></td>
      </tr>
      <tr>
        <td id="L7386" data-line-number="7386"></td>
        <td id="LC7386">        <span>if</span> (varType != TYP_BLK)</td>
      </tr>
      <tr>
        <td id="L7387" data-line-number="7387"></td>
        <td id="LC7387">        {</td>
      </tr>
      <tr>
        <td id="L7388" data-line-number="7388"></td>
        <td id="LC7388">            varDsc-&gt;<span>lvExactSize</span> = <span>roundUp</span>(padding + pComp-&gt;<span>lvaLclSize</span>(lclNum), TARGET_POINTER_SIZE);</td>
      </tr>
      <tr>
        <td id="L7389" data-line-number="7389"></td>
        <td id="LC7389">            varDsc-&gt;<span>lvType</span>      = TYP_BLK;</td>
      </tr>
      <tr>
        <td id="L7390" data-line-number="7390"></td>
        <td id="LC7390">            pComp-&gt;<span>lvaSetVarAddrExposed</span>(lclNum);</td>
      </tr>
      <tr>
        <td id="L7391" data-line-number="7391"></td>
        <td id="LC7391">        }</td>
      </tr>
      <tr>
        <td id="L7392" data-line-number="7392"></td>
        <td id="LC7392">
</td>
      </tr>
      <tr>
        <td id="L7393" data-line-number="7393"></td>
        <td id="LC7393">        tree-&gt;<span>gtFlags</span> |= GTF_GLOB_REF;</td>
      </tr>
      <tr>
        <td id="L7394" data-line-number="7394"></td>
        <td id="LC7394">
</td>
      </tr>
      <tr>
        <td id="L7395" data-line-number="7395"></td>
        <td id="LC7395">        <span><span>/*</span> Now morph the tree appropriately <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7396" data-line-number="7396"></td>
        <td id="LC7396">        <span>if</span> (oper == GT_LCL_VAR)</td>
      </tr>
      <tr>
        <td id="L7397" data-line-number="7397"></td>
        <td id="LC7397">        {</td>
      </tr>
      <tr>
        <td id="L7398" data-line-number="7398"></td>
        <td id="LC7398">            <span><span>/*</span> Change lclVar(lclNum) to lclFld(lclNum,padding) <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7399" data-line-number="7399"></td>
        <td id="LC7399">
</td>
      </tr>
      <tr>
        <td id="L7400" data-line-number="7400"></td>
        <td id="LC7400">            tree-&gt;<span>ChangeOper</span>(GT_LCL_FLD);</td>
      </tr>
      <tr>
        <td id="L7401" data-line-number="7401"></td>
        <td id="LC7401">            tree-&gt;<span>AsLclFld</span>()-&gt;<span>SetLclOffs</span>(padding);</td>
      </tr>
      <tr>
        <td id="L7402" data-line-number="7402"></td>
        <td id="LC7402">        }</td>
      </tr>
      <tr>
        <td id="L7403" data-line-number="7403"></td>
        <td id="LC7403">        <span>else</span> <span>if</span> (oper == GT_LCL_VAR_ADDR)</td>
      </tr>
      <tr>
        <td id="L7404" data-line-number="7404"></td>
        <td id="LC7404">        {</td>
      </tr>
      <tr>
        <td id="L7405" data-line-number="7405"></td>
        <td id="LC7405">            tree-&gt;<span>ChangeOper</span>(GT_LCL_FLD_ADDR);</td>
      </tr>
      <tr>
        <td id="L7406" data-line-number="7406"></td>
        <td id="LC7406">            tree-&gt;<span>AsLclFld</span>()-&gt;<span>SetLclOffs</span>(padding);</td>
      </tr>
      <tr>
        <td id="L7407" data-line-number="7407"></td>
        <td id="LC7407">        }</td>
      </tr>
      <tr>
        <td id="L7408" data-line-number="7408"></td>
        <td id="LC7408">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L7409" data-line-number="7409"></td>
        <td id="LC7409">        {</td>
      </tr>
      <tr>
        <td id="L7410" data-line-number="7410"></td>
        <td id="LC7410">            <span><span>/*</span> Change addr(lclVar) to addr(lclVar)+padding <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7411" data-line-number="7411"></td>
        <td id="LC7411">
</td>
      </tr>
      <tr>
        <td id="L7412" data-line-number="7412"></td>
        <td id="LC7412">            <span>noway_assert</span>(oper == GT_ADDR);</td>
      </tr>
      <tr>
        <td id="L7413" data-line-number="7413"></td>
        <td id="LC7413">            GenTree* paddingTree = pComp-&gt;<span>gtNewIconNode</span>(padding);</td>
      </tr>
      <tr>
        <td id="L7414" data-line-number="7414"></td>
        <td id="LC7414">            GenTree* newAddr     = pComp-&gt;<span>gtNewOperNode</span>(GT_ADD, tree-&gt;<span>gtType</span>, tree, paddingTree);</td>
      </tr>
      <tr>
        <td id="L7415" data-line-number="7415"></td>
        <td id="LC7415">
</td>
      </tr>
      <tr>
        <td id="L7416" data-line-number="7416"></td>
        <td id="LC7416">            *pTree = newAddr;</td>
      </tr>
      <tr>
        <td id="L7417" data-line-number="7417"></td>
        <td id="LC7417">
</td>
      </tr>
      <tr>
        <td id="L7418" data-line-number="7418"></td>
        <td id="LC7418">            lcl-&gt;<span>gtType</span> = TYP_BLK;</td>
      </tr>
      <tr>
        <td id="L7419" data-line-number="7419"></td>
        <td id="LC7419">        }</td>
      </tr>
      <tr>
        <td id="L7420" data-line-number="7420"></td>
        <td id="LC7420">    }</td>
      </tr>
      <tr>
        <td id="L7421" data-line-number="7421"></td>
        <td id="LC7421">
</td>
      </tr>
      <tr>
        <td id="L7422" data-line-number="7422"></td>
        <td id="LC7422">    <span>return</span> WALK_SKIP_SUBTREES;</td>
      </tr>
      <tr>
        <td id="L7423" data-line-number="7423"></td>
        <td id="LC7423">}</td>
      </tr>
      <tr>
        <td id="L7424" data-line-number="7424"></td>
        <td id="LC7424">
</td>
      </tr>
      <tr>
        <td id="L7425" data-line-number="7425"></td>
        <td id="LC7425"><span><span>/*</span>***************************************************************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7426" data-line-number="7426"></td>
        <td id="LC7426">
</td>
      </tr>
      <tr>
        <td id="L7427" data-line-number="7427"></td>
        <td id="LC7427"><span>void</span> <span>Compiler::lvaStressLclFld</span>()</td>
      </tr>
      <tr>
        <td id="L7428" data-line-number="7428"></td>
        <td id="LC7428">{</td>
      </tr>
      <tr>
        <td id="L7429" data-line-number="7429"></td>
        <td id="LC7429">    <span>if</span> (!<span>compStressCompile</span>(STRESS_LCL_FLDS, <span>5</span>))</td>
      </tr>
      <tr>
        <td id="L7430" data-line-number="7430"></td>
        <td id="LC7430">    {</td>
      </tr>
      <tr>
        <td id="L7431" data-line-number="7431"></td>
        <td id="LC7431">        <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L7432" data-line-number="7432"></td>
        <td id="LC7432">    }</td>
      </tr>
      <tr>
        <td id="L7433" data-line-number="7433"></td>
        <td id="LC7433">
</td>
      </tr>
      <tr>
        <td id="L7434" data-line-number="7434"></td>
        <td id="LC7434">    lvaStressLclFldArgs Args;</td>
      </tr>
      <tr>
        <td id="L7435" data-line-number="7435"></td>
        <td id="LC7435">    Args.<span>m_pCompiler</span>  = <span>this</span>;</td>
      </tr>
      <tr>
        <td id="L7436" data-line-number="7436"></td>
        <td id="LC7436">    Args.<span>m_bFirstPass</span> = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7437" data-line-number="7437"></td>
        <td id="LC7437">
</td>
      </tr>
      <tr>
        <td id="L7438" data-line-number="7438"></td>
        <td id="LC7438">    <span><span>//</span> Do First pass</span></td>
      </tr>
      <tr>
        <td id="L7439" data-line-number="7439"></td>
        <td id="LC7439">    <span>fgWalkAllTreesPre</span>(lvaStressLclFldCB, &amp;Args);</td>
      </tr>
      <tr>
        <td id="L7440" data-line-number="7440"></td>
        <td id="LC7440">
</td>
      </tr>
      <tr>
        <td id="L7441" data-line-number="7441"></td>
        <td id="LC7441">    <span><span>//</span> Second pass</span></td>
      </tr>
      <tr>
        <td id="L7442" data-line-number="7442"></td>
        <td id="LC7442">    Args.<span>m_bFirstPass</span> = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L7443" data-line-number="7443"></td>
        <td id="LC7443">    <span>fgWalkAllTreesPre</span>(lvaStressLclFldCB, &amp;Args);</td>
      </tr>
      <tr>
        <td id="L7444" data-line-number="7444"></td>
        <td id="LC7444">}</td>
      </tr>
      <tr>
        <td id="L7445" data-line-number="7445"></td>
        <td id="LC7445">
</td>
      </tr>
      <tr>
        <td id="L7446" data-line-number="7446"></td>
        <td id="LC7446">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
      <tr>
        <td id="L7447" data-line-number="7447"></td>
        <td id="LC7447">
</td>
      </tr>
      <tr>
        <td id="L7448" data-line-number="7448"></td>
        <td id="LC7448"><span><span>/*</span>****************************************************************************</span></td>
      </tr>
      <tr>
        <td id="L7449" data-line-number="7449"></td>
        <td id="LC7449"><span> *</span></td>
      </tr>
      <tr>
        <td id="L7450" data-line-number="7450"></td>
        <td id="LC7450"><span> *  A little routine that displays a local variable bitset.</span></td>
      </tr>
      <tr>
        <td id="L7451" data-line-number="7451"></td>
        <td id="LC7451"><span> *  'set' is mask of variables that have to be displayed</span></td>
      </tr>
      <tr>
        <td id="L7452" data-line-number="7452"></td>
        <td id="LC7452"><span> *  'allVars' is the complete set of interesting variables (blank space is</span></td>
      </tr>
      <tr>
        <td id="L7453" data-line-number="7453"></td>
        <td id="LC7453"><span> *    inserted if its corresponding bit is not in 'set').</span></td>
      </tr>
      <tr>
        <td id="L7454" data-line-number="7454"></td>
        <td id="LC7454"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7455" data-line-number="7455"></td>
        <td id="LC7455">
</td>
      </tr>
      <tr>
        <td id="L7456" data-line-number="7456"></td>
        <td id="LC7456">#<span>ifdef</span> DEBUG</td>
      </tr>
      <tr>
        <td id="L7457" data-line-number="7457"></td>
        <td id="LC7457"><span>void</span> <span>Compiler::lvaDispVarSet</span>(VARSET_VALARG_TP set)</td>
      </tr>
      <tr>
        <td id="L7458" data-line-number="7458"></td>
        <td id="LC7458">{</td>
      </tr>
      <tr>
        <td id="L7459" data-line-number="7459"></td>
        <td id="LC7459">    VARSET_TP <span>allVars</span>(<span>VarSetOps::MakeEmpty</span>(<span>this</span>));</td>
      </tr>
      <tr>
        <td id="L7460" data-line-number="7460"></td>
        <td id="LC7460">    <span>lvaDispVarSet</span>(set, allVars);</td>
      </tr>
      <tr>
        <td id="L7461" data-line-number="7461"></td>
        <td id="LC7461">}</td>
      </tr>
      <tr>
        <td id="L7462" data-line-number="7462"></td>
        <td id="LC7462">
</td>
      </tr>
      <tr>
        <td id="L7463" data-line-number="7463"></td>
        <td id="LC7463"><span>void</span> <span>Compiler::lvaDispVarSet</span>(VARSET_VALARG_TP set, VARSET_VALARG_TP allVars)</td>
      </tr>
      <tr>
        <td id="L7464" data-line-number="7464"></td>
        <td id="LC7464">{</td>
      </tr>
      <tr>
        <td id="L7465" data-line-number="7465"></td>
        <td id="LC7465">    <span>printf</span>(<span><span>"</span>{<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7466" data-line-number="7466"></td>
        <td id="LC7466">
</td>
      </tr>
      <tr>
        <td id="L7467" data-line-number="7467"></td>
        <td id="LC7467">    <span>bool</span> needSpace = <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L7468" data-line-number="7468"></td>
        <td id="LC7468">
</td>
      </tr>
      <tr>
        <td id="L7469" data-line-number="7469"></td>
        <td id="LC7469">    <span>for</span> (<span>unsigned</span> <span>index</span> = <span>0</span>; <span>index</span> &lt; lvaTrackedCount; <span>index</span>++)</td>
      </tr>
      <tr>
        <td id="L7470" data-line-number="7470"></td>
        <td id="LC7470">    {</td>
      </tr>
      <tr>
        <td id="L7471" data-line-number="7471"></td>
        <td id="LC7471">        <span>if</span> (<span>VarSetOps::IsMember</span>(<span>this</span>, set, <span>index</span>))</td>
      </tr>
      <tr>
        <td id="L7472" data-line-number="7472"></td>
        <td id="LC7472">        {</td>
      </tr>
      <tr>
        <td id="L7473" data-line-number="7473"></td>
        <td id="LC7473">            <span>unsigned</span>   lclNum;</td>
      </tr>
      <tr>
        <td id="L7474" data-line-number="7474"></td>
        <td id="LC7474">            LclVarDsc* varDsc;</td>
      </tr>
      <tr>
        <td id="L7475" data-line-number="7475"></td>
        <td id="LC7475">
</td>
      </tr>
      <tr>
        <td id="L7476" data-line-number="7476"></td>
        <td id="LC7476">            <span><span>/*</span> Look for the matching variable <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L7477" data-line-number="7477"></td>
        <td id="LC7477">
</td>
      </tr>
      <tr>
        <td id="L7478" data-line-number="7478"></td>
        <td id="LC7478">            <span>for</span> (lclNum = <span>0</span>, varDsc = lvaTable; lclNum &lt; lvaCount; lclNum++, varDsc++)</td>
      </tr>
      <tr>
        <td id="L7479" data-line-number="7479"></td>
        <td id="LC7479">            {</td>
      </tr>
      <tr>
        <td id="L7480" data-line-number="7480"></td>
        <td id="LC7480">                <span>if</span> ((varDsc-&gt;<span>lvVarIndex</span> == <span>index</span>) &amp;&amp; varDsc-&gt;<span>lvTracked</span>)</td>
      </tr>
      <tr>
        <td id="L7481" data-line-number="7481"></td>
        <td id="LC7481">                {</td>
      </tr>
      <tr>
        <td id="L7482" data-line-number="7482"></td>
        <td id="LC7482">                    <span>break</span>;</td>
      </tr>
      <tr>
        <td id="L7483" data-line-number="7483"></td>
        <td id="LC7483">                }</td>
      </tr>
      <tr>
        <td id="L7484" data-line-number="7484"></td>
        <td id="LC7484">            }</td>
      </tr>
      <tr>
        <td id="L7485" data-line-number="7485"></td>
        <td id="LC7485">
</td>
      </tr>
      <tr>
        <td id="L7486" data-line-number="7486"></td>
        <td id="LC7486">            <span>if</span> (needSpace)</td>
      </tr>
      <tr>
        <td id="L7487" data-line-number="7487"></td>
        <td id="LC7487">            {</td>
      </tr>
      <tr>
        <td id="L7488" data-line-number="7488"></td>
        <td id="LC7488">                <span>printf</span>(<span><span>"</span> <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7489" data-line-number="7489"></td>
        <td id="LC7489">            }</td>
      </tr>
      <tr>
        <td id="L7490" data-line-number="7490"></td>
        <td id="LC7490">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L7491" data-line-number="7491"></td>
        <td id="LC7491">            {</td>
      </tr>
      <tr>
        <td id="L7492" data-line-number="7492"></td>
        <td id="LC7492">                needSpace = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7493" data-line-number="7493"></td>
        <td id="LC7493">            }</td>
      </tr>
      <tr>
        <td id="L7494" data-line-number="7494"></td>
        <td id="LC7494">
</td>
      </tr>
      <tr>
        <td id="L7495" data-line-number="7495"></td>
        <td id="LC7495">            <span>printf</span>(<span><span>"</span>V%02u<span>"</span></span>, lclNum);</td>
      </tr>
      <tr>
        <td id="L7496" data-line-number="7496"></td>
        <td id="LC7496">        }</td>
      </tr>
      <tr>
        <td id="L7497" data-line-number="7497"></td>
        <td id="LC7497">        <span>else</span> <span>if</span> (<span>VarSetOps::IsMember</span>(<span>this</span>, allVars, <span>index</span>))</td>
      </tr>
      <tr>
        <td id="L7498" data-line-number="7498"></td>
        <td id="LC7498">        {</td>
      </tr>
      <tr>
        <td id="L7499" data-line-number="7499"></td>
        <td id="LC7499">            <span>if</span> (needSpace)</td>
      </tr>
      <tr>
        <td id="L7500" data-line-number="7500"></td>
        <td id="LC7500">            {</td>
      </tr>
      <tr>
        <td id="L7501" data-line-number="7501"></td>
        <td id="LC7501">                <span>printf</span>(<span><span>"</span> <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7502" data-line-number="7502"></td>
        <td id="LC7502">            }</td>
      </tr>
      <tr>
        <td id="L7503" data-line-number="7503"></td>
        <td id="LC7503">            <span>else</span></td>
      </tr>
      <tr>
        <td id="L7504" data-line-number="7504"></td>
        <td id="LC7504">            {</td>
      </tr>
      <tr>
        <td id="L7505" data-line-number="7505"></td>
        <td id="LC7505">                needSpace = <span>true</span>;</td>
      </tr>
      <tr>
        <td id="L7506" data-line-number="7506"></td>
        <td id="LC7506">            }</td>
      </tr>
      <tr>
        <td id="L7507" data-line-number="7507"></td>
        <td id="LC7507">
</td>
      </tr>
      <tr>
        <td id="L7508" data-line-number="7508"></td>
        <td id="LC7508">            <span>printf</span>(<span><span>"</span>   <span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7509" data-line-number="7509"></td>
        <td id="LC7509">        }</td>
      </tr>
      <tr>
        <td id="L7510" data-line-number="7510"></td>
        <td id="LC7510">    }</td>
      </tr>
      <tr>
        <td id="L7511" data-line-number="7511"></td>
        <td id="LC7511">
</td>
      </tr>
      <tr>
        <td id="L7512" data-line-number="7512"></td>
        <td id="LC7512">    <span>printf</span>(<span><span>"</span>}<span>"</span></span>);</td>
      </tr>
      <tr>
        <td id="L7513" data-line-number="7513"></td>
        <td id="LC7513">}</td>
      </tr>
      <tr>
        <td id="L7514" data-line-number="7514"></td>
        <td id="LC7514">
</td>
      </tr>
      <tr>
        <td id="L7515" data-line-number="7515"></td>
        <td id="LC7515">#<span>endif</span> <span><span>//</span> DEBUG</span></td>
      </tr>
</tbody></table>

  

  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>