<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Random Thoughts - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Random Thoughts - linksfor.dev(s)"/>
    <meta property="og:description" content="Warranty void."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://vcsjones.dev/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Random Thoughts</title>
<div class="readable">
        <h1>Random Thoughts</h1>
            <div>Reading time: 24-30 minutes</div>
        <div>Posted here: 09 Aug 2019</div>
        <p><a href="https://vcsjones.dev/">https://vcsjones.dev/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
      <div>
        <div>
  <ul>
     
      <li>
        <span>Oct 7, 2019</span>
        
        <h2>
          <a href="https://vcsjones.dev/2019/10/07/key-formats-dotnet-3/">Import and Export RSA Key Formats in .NET Core 3</a>
        </h2>
        
        <p>.NET Core 3.0 introduced over a dozen new APIs for importing and exporting RSA
keys in different formats. Many of them are a variant of another with a slightly
different API, but they are extremely useful for working with private and public
keys from other systems that work with encoding keys.</p>

<p>RSA keys can be encoded in a variety of different ways, depending on if the key
is public or private or protected with a password. Different programs will
import or export RSA keys in a different format, etc.</p>

<p>Often times RSA keys can be described as “PEM” encoded, but that is already
ambiguous as to how the key is actually encoded. PEM takes the form of:</p>

<div><div><pre><code>-----BEGIN LABEL-----
content
-----END LABEL-----
</code></pre></div></div>

<p>The content between the labels is base64 encoded. The one that is
probably the most often seen is BEGIN RSA PRIVATE KEY, which is frequently used
in web servers like nginx, apache, etc:</p>

<div><div><pre><code>-----BEGIN RSA PRIVATE KEY-----
MII...
-----END RSA PRIVATE KEY-----
</code></pre></div></div>

<p>The base64-encoded text is an RSAPrivateKey from the <a href="https://tools.ietf.org/html/rfc3447#appendix-A.1.2">PKCS#1 spec</a>, which is
just an ASN.1 SEQUENCE of integers that make up the RSA key. The corresponding
.NET Core 3 API for this is <code>ImportRSAPrivateKey</code>, or one of its overloads.
If your key is “PEM” encoded, you need to find the base64 text between the label
BEGIN and END headers, base64 decode it, and pass to <code>ImportRSAPrivateKey</code>.
There is currently an <a href="https://github.com/dotnet/corefx/issues/37748">API proposal</a> to make reading PEM files easier.
If your private key is DER encoded, then that just means you can read the
content directly as bytes in to <code>ImportRSAPrivateKey</code>.</p>

<p>Here is an example:</p>

<div><div><pre><code><span>var</span> <span>privateKey</span> <span>=</span> <span>"MII..."</span><span>;</span> <span>//Get just the base64 content.</span>
<span>var</span> <span>privateKeyBytes</span> <span>=</span> <span>Convert</span><span>.</span><span>FromBase64String</span><span>(</span><span>privateKey</span><span>);</span>
<span>using</span> <span>var</span> <span>rsa</span> <span>=</span> <span>RSA</span><span>.</span><span>Create</span><span>();</span>
<span>rsa</span><span>.</span><span>ImportRSAPrivateKey</span><span>(</span><span>privateKeyBytes</span><span>,</span> <span>out</span> <span>_</span><span>);</span>
</code></pre></div></div>

<p>When using openssl, the <code>openssl rsa</code> commands typically output RSAPrivateKey
PKCS#1 private keys, for example <code>openssl genrsa</code>.</p>

<p>A different format for a private key is PKCS#8. Unlike the RSAPrivateKey from
PKCS#1, a PKCS#8 encoded key can represent other kinds of keys than RSA. As
such, the PEM label for a PKCS#8 key is “BEGIN PRIVATE KEY” (note the lack of
“RSA” there). The key itself contains an AlgorithmIdentifer of what kind of key
it is.</p>

<p>PKCS#8 keys can also be encrypted protected, too. In that case, the PEM
label will be “BEGIN ENCRYPTED PRIVATE KEY”.</p>

<p>.NET Core 3 has APIs for both of these. Unencrypted PKCS#8 keys can be imported
with <code>ImportPkcs8PrivateKey</code>, and encrypted PKCS#8 keys can be imported with
<code>ImportEncryptedPkcs8PrivateKey</code>. Their usage is similar to <code>ImportRSAPrivateKey</code>.</p>

<p>Public keys have similar behavior. A PEM encoded key that has the label
“BEGIN RSA PUBLIC KEY” should use <code>ImportRSAPublicKey</code>. Also like private keys,
the public key has a format that self-describes the algorithm of the key called
a Subject Public Key Info (SPKI) which is used heavily in X509 and many other
standards. The PEM header for this is “BEGIN PUBLIC KEY”, and
<code>ImportSubjectPublicKeyInfo</code> is the correct way to import these.</p>

<p>All of these APIs have export versions of themselves as well, so if you are
trying to export a key from .NET Core 3 to a particular format, you’ll need to
use the correct export API.</p>

<p>To summarize each PEM label and API pairing:</p>

<ol>
  <li>“BEGIN RSA PRIVATE KEY” =&gt; <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importrsaprivatekey?view=netcore-3.0"><code>RSA.ImportRSAPrivateKey</code></a></li>
  <li>“BEGIN PRIVATE KEY” =&gt; <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importpkcs8privatekey?view=netcore-3.0"><code>RSA.ImportPkcs8PrivateKey</code></a></li>
  <li>“BEGIN ENCRYPTED PRIVATE KEY” =&gt; <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importencryptedpkcs8privatekey?view=netcore-3.0"><code>RSA.ImportEncryptedPkcs8PrivateKey</code></a></li>
  <li>“BEGIN RSA PUBLIC KEY” =&gt; <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importrsapublickey?view=netcore-3.0"><code>RSA.ImportRSAPublicKey</code></a></li>
  <li>“BEGIN PUBLIC KEY” =&gt; <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importsubjectpublickeyinfo?view=netcore-3.0"><code>RSA.ImportSubjectPublicKeyInfo</code></a></li>
</ol>

<p>One gotcha with openssl is to pay attention to the output of the key format.
A common enough task from openssl is “Given this PEM-encoded RSA private key, give
me a PEM encoded public-key” and is often enough done like this:</p>

<div><div><pre><code>openssl rsa <span>-in</span> key.pem <span>-pubout</span>
</code></pre></div></div>

<p>Even if key.pem is a PKCS#1 RSAPrivateKey (“BEGIN RSA PRIVATE KEY”), the <code>-pubout</code>
option will output a SPKI (“BEGIN PUBLIC KEY”), not an RSAPublicKey
(“BEGIN RSA PUBLIC KEY”). For that, you would need to use <code>-RSAPublicKey_out</code>
instead of <code>-pubout</code>. The openssl <code>pkey</code> commands will also typically give you
PKCS#8 or SPKI formatted keys.</p>


        
      </li>
     
      <li>
        <span>Jul 18, 2019</span>
        
        <h2>
          <a href="https://vcsjones.dev/2019/07/18/sometimes-valid-rsa-dotnet/">Sometimes valid RSA signatures in .NET</a>
        </h2>
        
        <p>One of the nice things about .NET Core being open source is following along with
some of the issues that people report. I tend to keep an eye on System.Security
tagged issues, since those tend to be at the intersection of things that
interest me and things I can maybe help with.</p>

<p>A user <a href="https://github.com/dotnet/corefx/issues/34202">filed an issue</a> where .NET Framework considered a CMS valid, and .NET
Core did not. This didn’t entirely surprise me. In the .NET Framework, the
<code>SignedCms</code> class is heavily backed by Windows’ handling of CMS/PKCS#7. In .NET
Core, the implementation is managed (sans the cryptography). The managed
implementation adheres somewhat strictly to the CMS specification. As other issues
have noticed, Windows’, thus .NET Framework’s, implementation was a little more
relaxed in some ways.</p>

<p>This turned out not to be one of those cases. The CMS part was actually working
just fine. What was failing was RSA itself. The core of the issue was that
different implementations of RSA disagreed on the RSA signature’s validity.</p>

<p>That seems pretty strange!</p>

<p>When I talk about different implementations on Windows, I am usually referring
to CAPI vs CNG, or <code>RSACryptoServiceProvider</code> and <code>RSACng</code>, respectively. For
now, I’m keeping this post to the .NET Framework. We’ll bring .NET Core in to
the discussion later.</p>

<p>There are two implementations because, well, Windows has two of them. CNG, or
“Cryptography API: Next Generation” is the newer of the two and is intended to
be future of cryptographic primitives on Windows. It shipped in Windows Vista,
and offers functionality that CAPI cannot do. An example of that is PSS RSA
signatures.</p>

<p>.NET Framework exposes these implementations as <code>RSACryptoServiceProvider</code> and
<code>RSACng</code>. They <em>should</em> be interchangable, and CNG implementations should be
used going forward. However, there is one corner case where the old, CAPI
implementation considers a signature valid while the CNG one does not.</p>

<p>The issue can be demonstrated like so:</p>

<div><div><pre><code><span>byte</span><span>[]</span> <span>n</span> <span>=</span> <span>new</span> <span>byte</span><span>[]</span> <span>{</span> <span>...</span> <span>};</span>
<span>byte</span><span>[]</span> <span>e</span> <span>=</span> <span>new</span> <span>byte</span><span>[]</span> <span>{</span> <span>...</span> <span>};</span>
<span>byte</span><span>[]</span> <span>signature</span> <span>=</span> <span>new</span> <span>byte</span><span>[]</span> <span>{</span> <span>...</span> <span>};</span>
<span>var</span> <span>digest</span> <span>=</span> <span>new</span> <span>byte</span><span>[]</span> <span>{</span>
    <span>0x68</span><span>,</span> <span>0xB4</span><span>,</span> <span>0xF9</span><span>,</span> <span>0x26</span><span>,</span> <span>0x34</span><span>,</span> <span>0x31</span><span>,</span> <span>0x25</span><span>,</span> <span>0xDD</span><span>,</span>
    <span>0x26</span><span>,</span> <span>0x50</span><span>,</span> <span>0x13</span><span>,</span> <span>0x68</span><span>,</span> <span>0xC1</span><span>,</span> <span>0x99</span><span>,</span> <span>0x26</span><span>,</span> <span>0x71</span><span>,</span>
    <span>0x19</span><span>,</span> <span>0xA2</span><span>,</span> <span>0xDE</span><span>,</span> <span>0x81</span><span>,</span> 
<span>};</span>
<span>using</span> <span>(</span><span>var</span> <span>rsa</span> <span>=</span> <span>new</span> <span>RSACng</span><span>())</span>
<span>{</span>
    <span>rsa</span><span>.</span><span>ImportParameters</span><span>(</span><span>new</span> <span>RSAParameters</span> <span>{</span>
        <span>Modulus</span> <span>=</span> <span>n</span><span>,</span>
        <span>Exponent</span> <span>=</span> <span>e</span>
    <span>});</span>
    <span>var</span> <span>valid</span> <span>=</span> <span>rsa</span><span>.</span><span>VerifyHash</span><span>(</span><span>digest</span><span>,</span> <span>signature</span><span>,</span> <span>HashAlgorithmName</span><span>.</span><span>SHA1</span><span>,</span>
                               <span>RSASignaturePadding</span><span>.</span><span>Pkcs1</span><span>);</span>
    <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>valid</span><span>);</span>
<span>}</span>
<span>using</span> <span>(</span><span>var</span> <span>rsa</span> <span>=</span> <span>new</span> <span>RSACryptoServiceProvider</span><span>())</span>
<span>{</span>
    <span>rsa</span><span>.</span><span>ImportParameters</span><span>(</span><span>new</span> <span>RSAParameters</span> <span>{</span>
        <span>Modulus</span> <span>=</span> <span>n</span><span>,</span>
        <span>Exponent</span> <span>=</span> <span>e</span>
    <span>});</span>
    <span>var</span> <span>valid</span> <span>=</span> <span>rsa</span><span>.</span><span>VerifyHash</span><span>(</span><span>digest</span><span>,</span> <span>signature</span><span>,</span> <span>HashAlgorithmName</span><span>.</span><span>SHA1</span><span>,</span>
                               <span>RSASignaturePadding</span><span>.</span><span>Pkcs1</span><span>);</span>
    <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>valid</span><span>);</span>
<span>}</span>
</code></pre></div></div>



<p>When used with one of the curious signatures that exhibits this behavior, such
as the one in the GitHub link, the first result will be false, and the second
will be true.</p>

<p>Nothing jumped out at me as being problematic. The signature padding is PKCS,
the public exponent is the very typical 67,537, and the RSA key is sensible in
size.</p>

<p>To make it stranger, this signature came off the timestamp of Firefox’s own
signed installer. So why are the results different?</p>

<p>Jeremy Barton from Microsoft on .NET Core made the observation that the padding
in the RSA signature itself is incorrect, but in a way that CAPI tollerates and
CNG does not, at least by default. Let’s look at the raw signature. To do that,
we need the public key and signature on disk, and we can poke at them with OpenSSL.</p>

<p>Using the command:</p>

<div><div><pre><code>openssl rsautl <span>-verify</span> <span>-in</span> sig.bin <span>-inkey</span> key.der <span>\</span>
    <span>-pubin</span> <span>-hexdump</span> <span>-raw</span> <span>-keyform</span> der
</code></pre></div></div>

<p>We get the following output:</p>

<pre>0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00d0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00e0 - ff ff ff ff ff ff ff ff-ff ff ff 00 68 b4 f9 26
00f0 - 34 31 25 dd 26 50 13 68-c1 99 26 71 19 a2 de 81
</pre>

<p>This is a PKCS#1 v1.5 padded signature, as indicated by by starting with 00 01.
The digest at the end can be seen, <code>68 b4 f9 26 ... 19 a2 de 81</code> which matches
the digest above, so we know that the signature is for the right digest.</p>

<p>What is not correct in this signature is how the digest is encoded. The signature
contains the bare digest. It <em>should</em> be encoded as an ASN.1 sequence along
with the AlgorithmIdentifer of the digest:</p>

<div><div><pre><code>DigestInfo ::= SEQUENCE {
	digestAlgorithm AlgorithmIdentifier,
	digest OCTET STRING
}
</code></pre></div></div>

<p>This goes back all the way to <a href="ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-1.asc">a document</a> (warning: link is to an ftp:// site)
written in 1993 by RSA labratories explaining how PKCS#1 v1.5 works,and was
standardized in to <a href="https://tools.ietf.org/html/rfc2313">an RFC</a> in 1998.</p>

<p>The RSA signature we have only contains the raw digest. It is not part of a
<code>DigestInfo</code>. If the digest were properly encoded, it would look something like
this:</p>

<pre>0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00d0 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 21 30
00e0 - 09 06 05 2b 0e 03 02 1a-05 00 04 14 68 b4 f9 26
00f0 - 34 31 25 dd 26 50 13 68-c1 99 26 71 19 a2 de 81
</pre>

<p>The signature now includes <code>DigestInfo</code> along with the OID 1.3.14.3.2.26 to
indicate that the digest is SHA1.</p>

<p>At this point we know what the difference is, and the original specification in
part 10.1.2 makes it fairly clear that the “data” should be a digest and should
be encoded as DigestInfo, not a bare digest.</p>

<p>The source of this signature is from Verisign's timestamp authority at
http://timestamp.verisign.com/​scripts/​timstamp.dll. After checking with
someone at DigiCert (now running this TSA), it was launched in May 1995.</p>

<p>I suspect that the TSA is old enough that the implementation was made before the
specification was complete or simply got the specification wrong and no one
noticed. Bringing this back to CNG and CAPI, CNG can validate this signatures, but you
must explicitly tell CNG that the signature does not have an object identifier.
<a href="https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-_bcrypt_pkcs1_padding_info"><code>BCRYPT_PKCS1_PADDING_INFO</code>’s</a> documentation has the detail there, but gist
of it is</p>

<blockquote>
  <p>If there is no OID in the signature, then verification fails unless this
member is NULL.</p>
</blockquote>

<p>This would be used with <code>{B,N}CryptVerifySignature</code>. To bring this back around
to the .NET Framework, how do we use <code>RSACng</code> and give <code>null</code> in for the
padding algorithm? The short answer is: you cannot. If you try, you will get
an explicit <code>ArgumentException</code> saying that the hash algorithm name cannot be
null.</p>

<p>For .NET Framework, this solution “keep using <code>RSACryptoServiceProvider</code>”. If
you need to validate these signatures, chances are you do not need to use CNG’s
newer capabilities like PSS since these malformed signatures appear to be coming
from old systems. Higher level things like <code>SignedCms</code> and <code>SignedXml</code> use
<code>RSACryptoServiceProvider</code> by default, so they will continue to work.</p>

<p>To bring in .NET Core, the situation is a little more difficult. If you are
using <code>SignedCms</code> like so:</p>

<div><div><pre><code><span>var</span> <span>signedCms</span> <span>=</span> <span>new</span> <span>SignedCms</span><span>();</span>
<span>signedCms</span><span>.</span><span>Decode</span><span>(</span><span>File</span><span>.</span><span>ReadAllBytes</span><span>(</span><span>"cms-with-sig.bin"</span><span>));</span>
<span>signedCms</span><span>.</span><span>CheckSignature</span><span>(</span><span>true</span><span>);</span>
</code></pre></div></div>

<p>This will start throwing when you migrate to .NET Core. .NET Core will use CNG
when run on Windows to validate RSA signatures for <code>SignedCms</code> and <code>SignedXml</code>.
This is currently not configurable, either. When used with <code>SignedCms</code>, it
ultimately calls the <code>X509Certificate2.GetRSAPublicKey()</code> extension method,
and that will <a href="https://github.com/dotnet/corefx/blob/b26339b6f6c7537875c70b5f3c8af376d0bbded5/src/System.Security.Cryptography.X509Certificates/src/Internal/Cryptography/Pal.Windows/X509Pal.PublicKey.cs#L43">always</a> return an implementation based on CNG.</p>

<p>If you are using <code>SignedCms</code> on .NET Core and need to validate a CMS that is
signed with these problematic signatures, you are currently out of luck using
in-the-box components. As far as other platforms go, both macOS and Linux
environments for .NET Core will agree with CNG - that the signature is invalid.</p>

<p>The good news is, these signatures are not easy to come by. So far, only the
old Verisign timestamp authority is known to have produced signatures like this.</p>


        
      </li>
     
      <li>
        <span>Feb 1, 2019</span>
        
        <h2>
          <a href="https://vcsjones.dev/2019/02/01/csharp-readonly-span-bytes-static/">C# ReadOnlySpan<byte> and static data</byte></a>
        </h2>
        
        <p>Since C# 7 there have been a lot of point releases that contain all kinds of
goodies. Many of them are performance focused, such as safe stack allocations
using <code>Span&lt;T&gt;</code>, or interoperability with improvements to <code>fixed</code>.</p>

<p>One that I love, but is not documented well, is some special treatment
that <code>ReadOnlySpan&lt;byte&gt;</code> gets when its contents are known at compile time.</p>

<p>Here’s an example of a lookup table I used to aide with hex encoding that uses
a <code>byte[]</code>:</p>

<div><div><pre><code><span>private</span> <span>static</span> <span>byte</span><span>[]</span> <span>LookupTable</span> <span>=&gt;</span> <span>new</span> <span>byte</span><span>[]</span> <span>{</span>
    <span>(</span><span>byte</span><span>)</span><span>'0'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'1'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'2'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'3'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'4'</span><span>,</span>
    <span>(</span><span>byte</span><span>)</span><span>'5'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'6'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'7'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'8'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'9'</span><span>,</span>
    <span>(</span><span>byte</span><span>)</span><span>'A'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'B'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'C'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'D'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'E'</span><span>,</span>
    <span>(</span><span>byte</span><span>)</span><span>'F'</span><span>,</span>
<span>};</span>
</code></pre></div></div>

<p>This binary data has to get stored <em>somewhere</em> in our produced library. If we
use <code>dumpbin</code> we can see it in the .text section of the binary.</p>

<div><div><pre><code>dumpbin /RAWDATA /SECTION:.text mylib.dll
</code></pre></div></div>

<p>Right at the bottom, we see:</p>

<div><div><pre><code>00402A40: 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46  0123456789ABCDEF
</code></pre></div></div>

<p>I won’t go into the a lot of the details on how this data is compiled into the
<code>.text</code> section, but at this point we need to get that data into the array
somehow.</p>

<p>If we look at the jit assembly of <code>LookupTable</code>, we see:</p>

<div><div><pre><code>sub rsp, 0x28
vzeroupper
mov rcx, 0x7ffc4638746a
mov edx, 0x10
call 0x7ffc49b52630
mov rdx, 0x1b51450099c
lea rcx, [rax+0x10]
vmovdqu xmm0, [rdx]
vmovdqu [rcx], xmm0
add rsp, 0x28
ret
</code></pre></div></div>

<p>Where <code>0x7ffc49b52630</code> is <code>InitializeArray</code>.</p>

<p>With an array, our property leans on <code>InitializeArray</code>, the source of which is
<a href="https://github.com/dotnet/coreclr/blob/a28b25aacdcd2adb0fdfa70bd869f53ba6565976/src/classlibnative/bcltype/arraynative.cpp#L1377">in the CoreCLR</a>. For little-endian platforms, it boils down to a <code>memcpy</code>
from a runtime field handle.</p>

<p>Indeed, with a debugger we finally see:</p>

<div><div><pre><code>00007ffd`b18b701a e831a40e00       call    coreclr!memcpy (00007ffd`b19a1450)
</code></pre></div></div>

<p>Dumping <code>@rdx L10</code> yields:</p>

<div><div><pre><code>000001f0`4c552a90  30 31 32 33 34 35 36 37-38 39 41 42 43 44 45 46  0123456789ABCDEF
</code></pre></div></div>

<p>So that was a very long-winded way of saying that when using arrays, initializing
a field or variable with bytes results in <code>memcpy</code> from the image into the array,
which results in more data on the heap.</p>

<p>Now, starting in 7.3, we can avoid that <code>memcpy</code> when using <code>ReadOnlySpan&lt;byte&gt;</code>.</p>

<div><div><pre><code><span>private</span> <span>static</span> <span>ReadOnlySpan</span><span>&lt;</span><span>byte</span><span>&gt;</span> <span>LookupTable</span> <span>=&gt;</span> <span>new</span> <span>byte</span><span>[]</span> <span>{</span>
    <span>(</span><span>byte</span><span>)</span><span>'0'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'1'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'2'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'3'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'4'</span><span>,</span>
    <span>(</span><span>byte</span><span>)</span><span>'5'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'6'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'7'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'8'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'9'</span><span>,</span>
    <span>(</span><span>byte</span><span>)</span><span>'A'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'B'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'C'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'D'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'E'</span><span>,</span>
    <span>(</span><span>byte</span><span>)</span><span>'F'</span><span>,</span>
<span>};</span>
</code></pre></div></div>

<p>Looking at the jit assembly:</p>

<div><div><pre><code>mov eax, 0x10
xor edx, edx
mov r8, 0x1b5144c0968
mov [rcx], rdx
mov [rcx+0x8], r8
mov [rcx+0x10], eax
mov rax, rcx
ret
</code></pre></div></div>

<p>We see that there is <code>mov r8, 0x1b5144c0968</code>. The contents of <code>0x1b5144c0968</code>
are:</p>

<div><div><pre><code>000001b5`144c0968  30 31 32 33 34 35 36 37-38 39 41 42 43 44 45 46  0123456789ABCDEF
</code></pre></div></div>

<p>So we see that the method is now returning the data directly and
omitting the <code>memcpy</code> entirely, so our <code>ReadOnlySpan&lt;byte&gt;</code> is pointing directly
to the <code>.text</code> section.</p>

<p>This works for property getters as shown above, but also as the return of a
method:</p>

<div><div><pre><code><span>ReadOnlySpan</span><span>&lt;</span><span>byte</span><span>&gt;</span> <span>GetBytes</span><span>()</span> <span>{</span>
    <span>return</span> <span>new</span> <span>byte</span><span>[]</span> <span>{</span> <span>...</span> <span>};</span>
<span>}</span>
</code></pre></div></div>

<p>Which works similar to the getter of the property. In addition, this also works
for locals in a method body as well:</p>

<div><div><pre><code><span>void</span> <span>Write200Ok</span><span>(</span><span>Stream</span> <span>s</span><span>)</span> <span>{</span>
    <span>ReadOnlySpan</span><span>&lt;</span><span>byte</span><span>&gt;</span> <span>data</span> <span>=</span> <span>new</span> <span>byte</span><span>[]</span> <span>{</span>
        <span>(</span><span>byte</span><span>)</span><span>'H'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'T'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'T'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'P'</span><span>,</span>
        <span>(</span><span>byte</span><span>)</span><span>'/'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'1'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'.'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'1'</span><span>,</span>
        <span>(</span><span>byte</span><span>)</span><span>' '</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'2'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'0'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'0'</span><span>,</span>
        <span>(</span><span>byte</span><span>)</span><span>' '</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'O'</span><span>,</span> <span>(</span><span>byte</span><span>)</span><span>'K'</span>
    <span>};</span>
    <span>s</span><span>.</span><span>Write</span><span>(</span><span>data</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Which also produces a reasonable JIT disassembly:</p>

<div><div><pre><code>sub     rsp, 0x38
xor     eax, eax
mov     qword ptr [rsp+0x28], rax
mov     qword ptr [rsp+0x30], rax
mov     rcx, 0x1e595b42ade
mov     eax, 0x0F
lea     r8, [rsp+0x28]
mov     qword ptr [r8], rcx
mov     dword ptr [r8+8], eax
mov     rcx, rdx
lea     rdx, [rsp+0x28]
cmp     dword ptr [rcx], ecx
call    0x7ff89ede10c8 (Stream.Write(System.ReadOnlySpan`1&lt;Byte&gt;), mdToken: 0000000006000001)
add     rsp, 0x38
ret
</code></pre></div></div>

<p>Here we see  <code>mov rcx, 0x1e595b42ade</code> which moves the address of the static
 data directly in to the register with no additional work to create a byte array.</p>

<p>These optimizations currently only works with <code>ReadOnlySpan&lt;byte&gt;</code> right now.
Other types will continue to use <code>InitializeArray</code> due to needing to handle
different platforms and how they handle endianness.</p>


        
      </li>
     
      <li>
        <span>Jan 30, 2019</span>
        
        <h2>
          <a href="https://vcsjones.dev/2019/01/30/csharp-8-using-declarations/">C# 8 using declarations</a>
        </h2>
        
        <p>Visual Studio 2019 preview 2 was released a few days ago and I took the time
to install it. Visual Studio itself is actually rather uninteresting to me,
however the inclusion of the next C# 8 preview got my attention. I glanced at
the feature highlights and posted “looks nice” on Twitter.</p>

<p>Predictably, I got a few responses like “I’m not sure I like that”, and there is
always a guarantee that if F# has a similar feature, an F# developer will appear
and tell you F# has had this feature for 600 years.</p>

<p>The one I like a lot is using declarations. This allows a local to automatically
be disposed at the end of the block. Essentially, it hides the <code>try</code>/<code>finally</code>
or the <code>using() {...}</code>. The .NET team’s blog kind of gave a bad example of this,
so I’ll use one from <a href="https://github.com/vcsjones/FiddlerCert">Open OPC SignTool</a>. Here is the original snippet:</p>

<div><div><pre><code><span>private</span> <span>static</span> <span>X509Certificate2</span> <span>GetCertificateFromCertificateStore</span><span>(</span><span>string</span> <span>sha1</span><span>)</span>
<span>{</span>
    <span>using</span> <span>(</span><span>var</span> <span>store</span> <span>=</span> <span>new</span> <span>X509Store</span><span>(</span><span>StoreName</span><span>.</span><span>My</span><span>,</span> <span>StoreLocation</span><span>.</span><span>LocalMachine</span><span>))</span>
    <span>{</span>
        <span>store</span><span>.</span><span>Open</span><span>(</span><span>OpenFlags</span><span>.</span><span>OpenExistingOnly</span> <span>|</span> <span>OpenFlags</span><span>.</span><span>ReadOnly</span><span>);</span>
        <span>var</span> <span>certificates</span> <span>=</span> <span>store</span><span>.</span><span>Certificates</span><span>.</span><span>Find</span><span>(</span><span>X509FindType</span><span>.</span><span>FindByThumbprint</span><span>,</span> <span>sha1</span><span>,</span> <span>false</span><span>);</span>
        <span>return</span> <span>certificates</span><span>.</span><span>Count</span> <span>&gt;</span> <span>0</span> <span>?</span> <span>certificates</span><span>[</span><span>0</span><span>]</span> <span>:</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>A <code>using var</code> can make this:</p>

<div><div><pre><code><span>private</span> <span>static</span> <span>X509Certificate2</span> <span>GetCertificateFromCertificateStore</span><span>(</span><span>string</span> <span>sha1</span><span>)</span>
<span>{</span>
    <span>using</span> <span>var</span> <span>store</span> <span>=</span> <span>new</span> <span>X509Store</span><span>(</span><span>StoreName</span><span>.</span><span>My</span><span>,</span> <span>StoreLocation</span><span>.</span><span>LocalMachine</span><span>);</span>
    <span>store</span><span>.</span><span>Open</span><span>(</span><span>OpenFlags</span><span>.</span><span>OpenExistingOnly</span> <span>|</span> <span>OpenFlags</span><span>.</span><span>ReadOnly</span><span>);</span>
    <span>var</span> <span>certificates</span> <span>=</span> <span>store</span><span>.</span><span>Certificates</span><span>.</span><span>Find</span><span>(</span><span>X509FindType</span><span>.</span><span>FindByThumbprint</span><span>,</span> <span>sha1</span><span>,</span> <span>false</span><span>);</span>
    <span>return</span> <span>certificates</span><span>.</span><span>Count</span> <span>&gt;</span> <span>0</span> <span>?</span> <span>certificates</span><span>[</span><span>0</span><span>]</span> <span>:</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>This has the same effect of <code>store</code> having <code>Dispose</code> called on it at the end of
the method. The benefit here being that there is less indentation and braces.
This keeps me focused on the code that matters. I don’t care when <code>store</code> is
disposed in the method, I can just observe that it has a <code>using</code> modifier on the
local and be assured that <code>Dispose</code> will be called.</p>

<p>This isn’t the same as garbage collection or finalizers. Both of those are non-
deterministic, and can lead to unexpected program behavior. That’s less so in
the case of <code>X509Store</code>, so let’s look at another example:</p>

<div><div><pre><code><span>using</span> <span>Stream</span> <span>stream</span> <span>=</span> <span>entry</span><span>.</span><span>Open</span><span>();</span>
<span>var</span> <span>xmlDocument</span> <span>=</span> <span>XDocument</span><span>.</span><span>Load</span><span>(</span><span>stream</span><span>,</span> <span>LoadOptions</span><span>.</span><span>PreserveWhitespace</span><span>);</span>
<span>return</span> <span>new</span> <span>OpcRelationships</span><span>(</span><span>location</span><span>,</span> <span>xmlDocument</span><span>,</span> <span>readOnlyMode</span><span>);</span>
</code></pre></div></div>

<p>Not disposing a stream that is backed by a file can cause access errors later in
software that might try to open that file again - it is already open, so not
only is it a bad idea it leave streams to the GC, it is just simply incorrect.</p>

<p>However again <code>using</code> on the local ensures it is deterministically closed.</p>

<p><em>When</em> it gets disposed I can see being slightly unclear to the developer. The
quick explanation is when the local is no longer reachable, not when it is last
used. The C# 8 above gets compiled roughly to:</p>

<div><div><pre><code><span>var</span> <span>stream</span> <span>=</span> <span>entry</span><span>.</span><span>Open</span><span>();</span>
<span>try</span>
<span>{</span>
    <span>var</span> <span>xmlDocument</span> <span>=</span> <span>XDocument</span><span>.</span><span>Load</span><span>(</span><span>stream</span><span>,</span> <span>LoadOptions</span><span>.</span><span>PreserveWhitespace</span><span>);</span>
    <span>return</span> <span>new</span> <span>OpcRelationships</span><span>(</span><span>location</span><span>,</span> <span>xmlDocument</span><span>,</span> <span>readOnlyMode</span><span>);</span>
<span>}</span>
<span>finally</span>
<span>{</span>
    <span>if</span> <span>(</span><span>stream</span> <span>!=</span> <span>null</span><span>)</span>
    <span>{</span>
        <span>((</span><span>IDisposable</span><span>)</span><span>stream</span><span>).</span><span>Dispose</span><span>();</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The disposal is done after the return, when the local is no longer reachable,
not after <code>XDocument</code> is created.</p>

<p>I find this very helpful to keep code readable. This doesn’t work when you need
fine control over when <code>Dispose</code> is called. A place where this does not work
well is when the <code>Dispose</code> pattern is used for scopes, such as logging. The
AzureSignTool project has code similar to this in <code>SignCommand</code>:</p>

<div><div><pre><code><span>var</span> <span>logger</span> <span>=</span> <span>loggerFactory</span><span>.</span><span>CreateLogger</span><span>&lt;</span><span>SignCommand</span><span>&gt;();</span>
<span>Parallel</span><span>.</span><span>ForEach</span><span>(</span><span>AllFiles</span><span>,</span> <span>options</span><span>,</span> <span>()</span> <span>=&gt;</span> <span>(</span><span>succeeded</span><span>:</span> <span>0</span><span>,</span> <span>failed</span><span>:</span> <span>0</span><span>),</span> <span>(</span><span>filePath</span><span>,</span> <span>pls</span><span>,</span> <span>state</span><span>)</span> <span>=&gt;</span>
<span>{</span>
    <span>using</span> <span>(</span><span>var</span> <span>loopScope</span> <span>=</span> <span>logger</span><span>.</span><span>BeginScope</span><span>(</span><span>"File: {Id}"</span><span>,</span> <span>filePath</span><span>))</span>
    <span>{</span>
        <span>logger</span><span>.</span><span>LogInformation</span><span>(</span><span>"Signing file."</span><span>);</span>
        <span>//Sign the file. omit a bunch of other code.</span>
        <span>logger</span><span>.</span><span>LogInformation</span><span>(</span><span>"Done signing the file."</span><span>);</span>
    <span>}</span>
    <span>logger</span><span>.</span><span>LogDebug</span><span>(</span><span>"Incrementing success count."</span><span>);</span>
    <span>return</span> <span>(</span><span>state</span><span>.</span><span>succeeded</span> <span>+</span> <span>1</span><span>,</span> <span>state</span><span>.</span><span>failed</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Here, we cannot change this to a <code>using var</code> because then the <code>LogDebug</code> would
be inside of that logging scope, which it wasn’t before. This is a place where
we continue to want <code>Dispose</code> to be called at a different time from the when
<code>loopScope</code> would no longer be in scope.</p>

<p>My impression from C# developers is that they do not tend to call <code>Dispose</code> 
on resources as soon as it can be disposed, just at a reasonable point in the
same method. Most developers do not write this code:</p>

<div><div><pre><code><span>public</span> <span>bool</span> <span>MightBeExe</span><span>(</span><span>string</span> <span>filePath</span><span>)</span>
<span>{</span>
    <span>var</span> <span>firstBytes</span> <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>2</span><span>];</span>
    <span>int</span> <span>bytesRead</span><span>;</span>
    <span>using</span> <span>(</span><span>var</span> <span>file</span> <span>=</span> <span>File</span><span>.</span><span>Open</span><span>(</span><span>filePath</span><span>,</span> <span>FileMode</span><span>.</span><span>Open</span><span>))</span>
    <span>{</span>
        <span>bytesRead</span> <span>=</span> <span>file</span><span>.</span><span>Read</span><span>(</span><span>firstBytes</span><span>,</span> <span>0</span><span>,</span> <span>2</span><span>);</span>
    <span>}</span>
    <span>return</span> <span>bytesRead</span> <span>==</span> <span>2</span> <span>&amp;&amp;</span> <span>firstBytes</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>(</span><span>byte</span><span>)</span><span>'M'</span> <span>&amp;&amp;</span> <span>firstBytes</span><span>[</span><span>1</span><span>]</span> <span>==</span> <span>(</span><span>byte</span><span>)</span><span>'Z'</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>They will instead write something like:</p>

<div><div><pre><code><span>public</span> <span>bool</span> <span>MightBeExe</span><span>(</span><span>string</span> <span>filePath</span><span>)</span>
<span>{</span>
    <span>using</span> <span>(</span><span>var</span> <span>file</span> <span>=</span> <span>File</span><span>.</span><span>Open</span><span>(</span><span>filePath</span><span>,</span> <span>FileMode</span><span>.</span><span>Open</span><span>))</span>
    <span>{</span>
        <span>var</span> <span>firstBytes</span> <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>2</span><span>];</span>
        <span>var</span> <span>bytesRead</span> <span>=</span> <span>file</span><span>.</span><span>Read</span><span>(</span><span>firstBytes</span><span>,</span> <span>0</span><span>,</span> <span>2</span><span>);</span>
        <span>return</span> <span>bytesRead</span> <span>==</span> <span>2</span> <span>&amp;&amp;</span> <span>firstBytes</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>(</span><span>byte</span><span>)</span><span>'M'</span> <span>&amp;&amp;</span> <span>firstBytes</span><span>[</span><span>1</span><span>]</span> <span>==</span> <span>(</span><span>byte</span><span>)</span><span>'Z'</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Which is a perfect candidate for <code>using var</code>:</p>

<div><div><pre><code><span>public</span> <span>bool</span> <span>MightBeExe</span><span>(</span><span>string</span> <span>filePath</span><span>)</span>
<span>{</span>
    <span>using</span> <span>var</span> <span>file</span> <span>=</span> <span>File</span><span>.</span><span>Open</span><span>(</span><span>filePath</span><span>,</span> <span>FileMode</span><span>.</span><span>Open</span><span>);</span>
    <span>var</span> <span>firstBytes</span> <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>2</span><span>];</span>
    <span>var</span> <span>bytesRead</span> <span>=</span> <span>file</span><span>.</span><span>Read</span><span>(</span><span>firstBytes</span><span>,</span> <span>0</span><span>,</span> <span>2</span><span>);</span>
    <span>return</span> <span>bytesRead</span> <span>==</span> <span>2</span> <span>&amp;&amp;</span> <span>firstBytes</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>(</span><span>byte</span><span>)</span><span>'M'</span> <span>&amp;&amp;</span> <span>firstBytes</span><span>[</span><span>1</span><span>]</span> <span>==</span> <span>(</span><span>byte</span><span>)</span><span>'Z'</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>There are of course some reasonable limitations to this feature. For example,
it cannot be combined with out-variables.</p>

<div><div><pre><code><span>if</span> <span>(</span><span>Crypto32</span><span>.</span><span>CryptEncodeObjectEx</span><span>(</span>
    <span>// other stuff</span>
    <span>out</span> <span>var</span> <span>handle</span><span>,</span>
    <span>ref</span> <span>size</span><span>)</span>
<span>)</span>
<span>{</span>
    <span>using</span> <span>(</span><span>handle</span><span>)</span>
    <span>{</span>
        <span>// Do stuff</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This does not work:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>Crypto32</span><span>.</span><span>CryptEncodeObjectEx</span><span>(</span>
    <span>// other stuff</span>
    <span>out</span> <span>using</span> <span>var</span> <span>handle</span><span>,</span>
    <span>ref</span> <span>size</span><span>)</span>
<span>)</span>
<span>{</span>
    <span>// Do stuff</span>
<span>}</span>
</code></pre></div></div>

<p>Jared Parsons said <a href="https://twitter.com/jaredpar/status/1088832515861663744">on Twitter</a> that C# folks thought of this, and decided
that it had “Too much confusion about ownership.” Thinking about it myself, I
agree, so it’s nice that the feature is limited in that regard.</p>

<p>Another limitation is that the variable cannot be reassigned. For example:</p>

<div><div><pre><code><span>using</span> <span>var</span> <span>stream</span> <span>=</span> <span>entry</span><span>.</span><span>Open</span><span>();</span>
<span>stream</span> <span>=</span> <span>entry2</span><span>.</span><span>Open</span><span>();</span>
</code></pre></div></div>

<p>This will produce error CS1656, “Cannot assign to ‘stream’ because it is a
‘using variable’”.</p>

<p>All in all, I very much like this small feature in C# 8. It has reasonable guard
rails on it from doing something too weird like re-assigning to it, while giving
the benefit of less blocks, braces, indentation.</p>


        
      </li>
     
      <li>
        <span>Oct 23, 2018</span>
        
        <h2>
          <a href="https://vcsjones.dev/2018/10/23/random-integers-dotnet-core/">Secure Random Integers in .NET Core 3</a>
        </h2>
        
        <p>.NET Core 3.0 is tentatively <a href="https://apisof.net/catalog/System.Security.Cryptography.RandomNumberGenerator.GetInt32(Int32,Int32)">set to include</a> a new API for <em>securely</em>
generating a random integer bound to a specific range.</p>

<p>I won’t be shy in admitting that it was something <a href="https://github.com/dotnet/corefx/issues/30873">I pushed for</a> and made the
initial attempt <a href="https://github.com/dotnet/corefx/pull/31243">at implementing</a>, though it’s unfair to say that I
implemented it by myself given all of the outstanding feedback I got on the
initial pull request (thanks Levi and Jeremy!)</p>

<p>It’s been known for a while that <code>System.Random</code> shouldn’t be used when
cryptographic randomness is required. Despite that, there wasn’t anything built
in to .NET that made creating bounded random integers easy. You could either
use <code>System.Random</code> and hope for the best, or use a CSPRNG like
<code>RandomNumberGenerator</code> that gave back raw bytes, which requires some thought on
how to to properly convert it to a random integer without introducing any kind
of bias.</p>

<p>Starting in .NET Core 3.0, you’ll be able to do:</p>

<div><div><pre><code><span>var</span> <span>min</span> <span>=</span> <span>1</span><span>;</span>
<span>var</span> <span>max</span> <span>=</span> <span>1</span><span>_000</span><span>;</span>
<span>var</span> <span>randomNumber</span> <span>=</span> <span>RandomNumberGenerator</span><span>.</span><span>GetInt32</span><span>(</span><span>min</span><span>,</span> <span>max</span><span>);</span>
</code></pre></div></div>

<p>If you need this before .NET Core 3, well, <a href="https://github.com/dotnet/corefx/pull/31243">the source</a> is right there. It
can be adapted with a bit of effort to work on the .NET Framework as well as other
environments that don’t have <code>Span&lt;T&gt;</code>.</p>


        
      </li>
    
  </ul>

  
  
  
</div>

      </div>
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>