<!DOCTYPE html>
<html lang="en">
<head>
    <title>
I made a NES emulator in Rust using generators - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="I made a NES emulator in Rust using generators - linksfor.dev(s)"/>
    <meta property="og:description" content="This article was written using Rust 1.40 nightly (518deda77) with unstable features. Certain unstable features may have been changed or removed since."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://kyle.space/posts/i-made-a-nes-emulator/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - I made a NES emulator in Rust using generators</title>
<div class="readable">
        <h1>I made a NES emulator in Rust using generators</h1>
            <div>Reading time: 35-45 minutes</div>
        <div>Posted here: 23 May 2020</div>
        <p><a href="https://kyle.space/posts/i-made-a-nes-emulator/">https://kyle.space/posts/i-made-a-nes-emulator/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><article>  <div> <p><em>This article was written using Rust 1.40 nightly (518deda77) with unstable features. Certain unstable features may have been changed or removed since.</em></p> <p>Emulators are cool! They help <a href="https://www.hardcoregamer.com/2014/12/30/scott-pilgrim-vs-the-world-the-game-delisted-from-xbox-live-and-psn/126681/">preserve games</a>, <a href="https://arstechnica.com/gaming/2019/04/hd-emulation-mod-makes-mode-7-snes-games-look-like-new/">improve games</a>, and <a href="https://www.engadget.com/2019/09/01/retroarch-emulator-ai-translation/">help make games more accessible</a>. On top of that, making an emulator is a cathartic and satisfying technical challenge!</p> <p>So, I took this challenge myself and came out the other end with a pretty limited NES emulator, which I call <a href="https://github.com/kylewlacy/lochnes">Lochnes</a>. It’s not very good at actually emulating most games, but I’m pretty happy with the guts of the thing and I learned a lot a long the way. I figured it might be worthwhile to share my approach, which might help or inspire others on their own emulation venture!</p> <p>But before we get to that, let’s talk some emulator theory…</p>   <p>The idea of simulating <em>a whole computer</em> sounds pretty scary! But, it’s really not that bad when we try to visualize what our emulator actually needs to do:</p> <p><img src="https://kyle.space/posts/i-made-a-nes-emulator/frame-diagram.png" alt="Each frame of emulation takes the player's input and the previous frame's state, and produces the new state and some output"></p> <p>So basically, for each frame that we run, we take the current state and the player’s current input, we do some work, then we output some video/audio and produce the new state for the next frame. The “state” we care about includes everything in the NES, which includes the registers for the CPU, PPU, and APU; the NES’s built-in RAM; and any ROM/RAM included in the game cartridge (yes, cartridges can include RAM!)</p>  <p>Unfortunately, the diagram I gave above is a bit of a simplification for our purposes. Specifically, we need to do some work each frame that deals with the CPU, PPU, and APU state. Each one is a separate component that does a specific job:</p> <ul> <li><strong>CPU</strong>: Hopefully you’re familiar with the concept of a CPU! In the NES, it’s a derivative of the <a href="https://en.wikipedia.org/wiki/MOS_Technology_6502">MOS 6502</a> (the Apple II, Atari 2600, Commodore 64, and others all used 6502-like CPUs as well). This is the <em>only</em> directly-programmable thing in the NES– to use the other components, you would go through the CPU first (hence “central” processing unit).</li> <li><strong>PPU</strong>: The Picture Processing Unit, does the pixels and such. It outputs at a resolution of 256×240 pixels, uses 8×8 pixel tiles, and supports like 55 different colors. Annoyingly, it outputs colors directly as NTSC signals rather than using some sort of RGB-to-NTSC conversion, meaning there is no “definitive” color mapping from NES color codes to RGB colors (this is why the game will often have different colors in different emulators).</li> <li><strong>APU</strong>: The Audio Processing Unit, does some basic bleeps and bloops. It also does some frame timing stuff I think? But I don’t know much about it beyond that because I haven’t implemented it in my emulator yet! Basically you don’t <em>need</em> to implement it for (some? many? most?) games if you just care about drawing to the screen. Fun fact: the <a href="https://wiki.nesdev.com/w/index.php/Category:Expansion_audio">Japanese Famicom gave games some control over how the APU produced sound</a>, which is why the Japanese releases for games like Castlevania III <a href="https://youtu.be/14rPeAy6gDA">sound better</a>. Supposedly the American NES still has the hardware for this, but the connection isn’t wired up to the cartridge slot.</li> </ul> <p>Well, that’s all well and good, but <strong>all three of these components run at different speeds!</strong> They all share the same master clock, but each component’s clock divides the master clock by some amount. Or, as another diagram:</p> <p><img src="https://kyle.space/posts/i-made-a-nes-emulator/clock-diagram.png" alt="The CPU, PPU, and APU each do some work in parallel"></p> <p>So, if we look at a timeline of CPU clock cycles, multiple PPU cycles are crammed into a single CPU clock cycle! This makes sense though, because there are 4 master clock cycles per PPU cycle, and 12 master clock cycles per CPU cycle (meaning: 12 master clock cycles = 3 PPU cycles = 1 CPU cycle). <span>[edit: thanks to <a href="https://www.reddit.com/r/programming/comments/dk2l5k/i_made_a_nes_emulator_in_rust_using_generators/f4d2upv/">/u/silverslayer33</a> for the correction]</span></p> <p>As we can also see in the above diagram, different CPU operations also have different clock timings. That means that, if we want an accurate emulator, we will need to switch between emulating the CPU and emulating the PPU mid-instruction.</p> <p>Before we cross that bridge though, let’s start simple.</p>  <p>So, I brewed up a very simple sample ROM from the following 6502 assembly:</p> <div><pre><code><table><tbody><tr><td data-line-number="1"><span>1</span></td><td><pre><span>lda</span> <span>#$05</span>     <span>; Load 0x05 into the A register (LDA = LoaD A)</span></pre></td></tr><tr><td data-line-number="2"><span>2</span></td><td><pre><span>adc</span> <span>#$06</span>     <span>; Add 0x06 to A (ADC = ADd with Carry)</span></pre></td></tr><tr><td data-line-number="3"><span>3</span></td><td><pre><span>tax</span>          <span>; Copy A to X (TAX = Transfer A to X)</span></pre></td></tr><tr><td data-line-number="4"><span>4</span></td><td><pre><span>stx</span> <span>$0001</span>    <span>; Store the value in X to address $0001 (STX = STore X)</span></pre></td></tr><tr><td data-line-number="5"><span>5</span></td><td><pre><span>lda</span> <span>$0001</span>    <span>; Load the value in $0001 into A (LDA = LoaD A)</span></pre></td></tr><tr><td data-line-number="6"><span>6</span></td><td><pre><span>stop</span><span>:</span></pre></td></tr><tr><td data-line-number="7"><span>7</span></td><td><pre>    <span>jmp</span> <span>stop</span> <span>; Go to "stop" repeatedly, as an endless loop (JMP = JuMP)</span></pre></td></tr><tr><td data-line-number="8"><span>8</span></td><td><pre><span>; Because the above line loops forever, our code will essentially end here</span></pre></td></tr></tbody></table></code></pre></div> <p>…and the same assembly, but annotated with the 6502 machine code bytes, and with labels that correspond to memory locations:</p> <div><pre><code><table><tbody><tr><td data-line-number="1"><span>1</span></td><td><pre><span>a8000</span><span>:</span> <span>lda</span> <span>#$<span>05</span></span>   <span>; <span>A9</span> <span>05</span></span></pre></td></tr><tr><td data-line-number="2"><span>2</span></td><td><pre><span>a8002</span><span>:</span> <span>adc</span> <span>#$<span>06</span></span>   <span>; <span>69</span> <span>06</span></span></pre></td></tr><tr><td data-line-number="3"><span>3</span></td><td><pre><span>a8004</span><span>:</span> <span>tax</span>        <span>; <span>AA</span></span></pre></td></tr><tr><td data-line-number="4"><span>4</span></td><td><pre><span>a8005</span><span>:</span> <span>stx</span> <span>$<span>0001</span></span>  <span>; <span>86</span> <span>01</span></span></pre></td></tr><tr><td data-line-number="5"><span>5</span></td><td><pre><span>a8007</span><span>:</span> <span>lda</span> <span>$<span>0001</span></span>  <span>; <span>A5</span> <span>01</span></span></pre></td></tr><tr><td data-line-number="6"><span>6</span></td><td><pre><span>a8009</span><span>:</span> <span>jmp</span> <span>a<span>80</span><span>09</span></span>  <span>; <span>4C</span> <span>09</span> <span>80</span></span></pre></td></tr></tbody></table></code></pre></div> <p>(If you want to play along at home, you can get this as a standard NES ROM here: <a href="https://kyle.space/posts/i-made-a-nes-emulator/sample.nes"><code>sample.nes</code></a>)</p> <p>I won’t go in-depth about 6502 assembly, but there’s a few important things I should point out:</p> <ul> <li>An instruction is broken up into an opcode (1 byte) followed by an optional operand (1 or 2 bytes, or 0 bytes if no operand). Therefore, instructions are between 1 and 3 bytes long</li> <li>The operand for an instruction is encoded as little-endian (which is why <code>jmp a8009</code> has the bytes <code>09 80</code>– this is the little-endian encoding for the address <code>$8009</code>)</li> <li>A single instruction can map to a few different opcodes. For example, <code>lda #$05</code> uses the opcode <code>A9</code> and <code>lda $0001</code> uses the opcode <code>A5</code></li> <li>Some instructions have special opcodes when dealing with addresses between <code>$0000</code> and <code>$00FF</code> (which is why <code>stx $0001</code> and <code>lda $0001</code> both get encoded as 2 bytes instead of 3). This is called “zero-page addressing”</li> </ul> <p>And, a few notes about the ROM file itself:</p> <p>The first 16 bytes make up the <a href="https://wiki.nesdev.com/w/index.php/INES#iNES_file_format">iNES ROM header</a>. It specifies how the ROM should get loaded into memory and what the rest of the ROM contains. We’re going to ignore most of this for now: our ROM uses the <a href="https://wiki.nesdev.com/w/index.php/NROM">NROM mapper</a> with 16 KiB of PRG-ROM (“program ROM”– the stuff for the CPU) and no CHR-ROM (“character ROM”– static data used for drawing with the PPU).</p> <p>The rest of the ROM (16 KiB) make up the PRG-ROM, which is the part that gets loaded for the CPU. Since our actual code only takes up 12 bytes, most of this is padding. However, the last 6 bytes specify the <a href="https://en.wikibooks.org/wiki/NES_Programming/Initializing_the_NES#Interrupt_Vectors">interrupt vectors</a>. There are 3 interrupt vectors, but for now we just care about the reset vector: this tells the NES what address to start execution at. Since the first instruction of our little sample program is at <code>$8000</code>, we include the bytes <code>00 80</code> for the reset vector. We zero out the other 2 vectors, so the last 6 bytes of our ROM are <code>00 00 00 80 00 00</code> (the reset vector is the 2nd of the 3 interrupt vectors, so it’s in the middle).</p>  <p>With that out of the way, we should be able to start doing some basic emulation! Using what we talked about, here are some simple data structures to represent our NES state:</p> <div><pre><code><span>struct</span> <span>Nes</span> <span>{</span>
    <span>cpu</span><span>:</span> <span>Cpu</span><span>,</span>
    <span>ram</span><span>:</span> <span>[</span><span>u8</span><span>;</span> <span>0x0800</span><span>],</span> <span>// The NES has 2 KiB of built-in RAM</span>
    <span>rom</span><span>:</span> <span>Rom</span><span>,</span>
    <span>// TODO: PPU</span>
    <span>// TODO: APU</span>
<span>}</span>

<span>struct</span> <span>Rom</span> <span>{</span>
    <span>prg_rom</span><span>:</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span> <span>// Our ROM only has PRG-ROM, so we'll leave it at that</span>
<span>}</span>

<span>#[derive(Debug)]</span>
<span>struct</span> <span>Cpu</span> <span>{</span>
    <span>pc</span><span>:</span> <span>u16</span><span>,</span>
    <span>a</span><span>:</span> <span>u8</span><span>,</span>
    <span>x</span><span>:</span> <span>u8</span><span>,</span>
    <span>y</span><span>:</span> <span>u8</span><span>,</span>
    <span>s</span><span>:</span> <span>u8</span><span>,</span>
    <span>p</span><span>:</span> <span>u8</span><span>,</span>
<span>}</span>
</code></pre></div> <p>I included the other 3 <a href="https://wiki.nesdev.com/w/index.php/CPU_registers">CPU registers</a> we didn’t cover, but we aren’t using them in our sample ROM, so whatever. Hopefully the rest is pretty uncontroversial.</p> <p>With that, let’s load our ROM:</p> <div><pre><code><span>use</span> <span>std</span><span>::</span><span>fs</span><span>;</span>
<span>use</span> <span>std</span><span>::</span><span>io</span><span>::</span><span>Read</span><span>;</span>

<span>impl</span> <span>Nes</span> <span>{</span>
    <span>fn</span> <span>from_rom</span><span>(</span><span>rom</span><span>:</span> <span>Rom</span><span>)</span> <span>-&gt;</span> <span>Self</span> <span>{</span>
        <span>// Convert the 2 bytes at offset 0x3FFC / 0x3FFD</span>
        <span>// to a u16 to get PC</span>
        <span>// NOTE: This only works for NROM ROMs with</span>
        <span>// a size of 16 KiB!</span>
        <span>let</span> <span>pc_bytes</span> <span>=</span> <span>&amp;</span><span>rom</span><span>.prg_rom</span><span>[</span><span>0x3FFC</span><span>..=</span><span>0x3FFD</span><span>];</span>
        <span>let</span> <span>pc</span> <span>=</span>
            <span>(</span><span>pc_bytes</span><span>[</span><span>0</span><span>]</span> <span>as</span> <span>u16</span><span>)</span>
            <span>|</span> <span>((</span><span>pc_bytes</span><span>[</span><span>1</span><span>]</span> <span>as</span> <span>u16</span><span>)</span> <span>&lt;&lt;</span> <span>8</span><span>);</span>

        <span>// See http://wiki.nesdev.com/w/index.php/CPU_power_up_state</span>
        <span>let</span> <span>cpu</span> <span>=</span> <span>Cpu</span> <span>{</span> <span>pc</span><span>,</span> <span>a</span><span>:</span> <span>0</span><span>,</span> <span>x</span><span>:</span> <span>0</span><span>,</span> <span>y</span><span>:</span> <span>0</span><span>,</span> <span>s</span><span>:</span> <span>0xFD</span><span>,</span> <span>p</span><span>:</span> <span>0x34</span> <span>};</span>
        <span>let</span> <span>ram</span> <span>=</span> <span>[</span><span>0</span><span>;</span> <span>0x0800</span><span>];</span>

        <span>Nes</span> <span>{</span> <span>cpu</span><span>,</span> <span>ram</span><span>,</span> <span>rom</span> <span>}</span>
    <span>}</span>
<span>}</span>

<span>impl</span> <span>Rom</span> <span>{</span>
    <span>fn</span> <span>from_file</span><span>(</span><span>filename</span><span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>-&gt;</span> <span>Rom</span> <span>{</span>
        <span>let</span> <span>rom_file</span> <span>=</span> <span>fs</span><span>::</span><span>File</span><span>::</span><span>open</span><span>(</span><span>filename</span><span>)</span><span>.unwrap</span><span>();</span>

        <span>// Skip the first 10 bytes, read 16 KiB for our PRG-ROM</span>
        <span>// TODO: Actually parse the ROM header!</span>
        <span>let</span> <span>prg_rom</span><span>:</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>=</span> <span>rom_file</span>
            <span>.bytes</span><span>()</span>
            <span>.skip</span><span>(</span><span>10</span><span>)</span>
            <span>.take</span><span>(</span><span>16_384</span><span>)</span>
            <span>.collect</span><span>::</span><span>&lt;</span><span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span> <span>_</span><span>&gt;&gt;</span><span>()</span>
            <span>.unwrap</span><span>();</span>

        <span>Rom</span> <span>{</span> <span>prg_rom</span> <span>}</span>
    <span>}</span>
<span>}</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>rom</span> <span>=</span> <span>Rom</span><span>::</span><span>from_file</span><span>(</span><span>"sample.nes"</span><span>);</span>
    <span>let</span> <span>mut</span> <span>nes</span> <span>=</span> <span>Nes</span><span>::</span><span>from_rom</span><span>(</span><span>rom</span><span>);</span>

    <span>nes</span><span>.run</span><span>();</span>
<span>}</span>
</code></pre></div> <p>(<a href="https://play.rust-lang.org/?version=nightly&amp;gist=1a9fe81398fe64ed5cdcb5957d90cb12">Rust Playground ▶</a>)</p> <p>So far so good. To do some basic emulation, we’ll need the following:</p> <ul> <li><code>nes.run()</code>: The function that actually parses our CPU opcodes and does work in an infinite loop</li> <li><code>nes.read_u8(addr: u16)</code>: A function that takes a 16-bit address reads the byte at that address</li> <li><code>nes.read_u16(addr: u16)</code>: A function that takes a 16-bit address, reads 2 bytes starting at that address, and converts it to a <code>u16</code></li> <li><code>nes.write_u8(addr: u16, value: u8)</code>: A function that takes a 16-bit address and write this value at that address</li> </ul> <p>Let’s start with our read and write functions. If we check the Nesdev articles on <a href="http://wiki.nesdev.com/w/index.php/CPU_memory_map">the CPU memory map</a> and <a href="http://wiki.nesdev.com/w/index.php/NROM#Banks">the NROM memory banks</a>, we can see that reads/writes map to different parts of our NES state. For example, writing to <code>$0002</code> maps to the third byte of internal RAM, so it should set <code>nes.ram[2]</code>; reading from <code>$8000</code> maps to the <em>first</em> byte of PRG-ROM, so it should return the value of <code>nes.rom.prg_rom[0]</code>. In code:</p> <div><pre><code><span>impl</span> <span>Nes</span> <span>{</span>
    <span>fn</span> <span>read_u8</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>addr</span><span>:</span> <span>u16</span><span>)</span> <span>-&gt;</span> <span>u8</span> <span>{</span>
        <span>match</span> <span>addr</span> <span>{</span>
            <span>// RAM (mirrored every 0x0800 bytes)</span>
            <span>0x0000</span><span>..=</span><span>0x07FF</span> <span>=&gt;</span> <span>{</span>
                <span>let</span> <span>ram_offset</span> <span>=</span> <span>(</span><span>addr</span> <span>as</span> <span>usize</span><span>)</span> <span>%</span> <span>self</span><span>.ram</span><span>.len</span><span>();</span>
                <span>self</span><span>.ram</span><span>[</span><span>ram_offset</span><span>]</span>
            <span>}</span>
            <span>// PRG-ROM (mirrored to fill all 32 KiB)</span>
            <span>0x8000</span><span>..=</span><span>0xFFFF</span> <span>=&gt;</span> <span>{</span>
                <span>let</span> <span>rom_len</span> <span>=</span> <span>self</span><span>.rom.prg_rom</span><span>.len</span><span>();</span>
                <span>let</span> <span>rom_offset</span> <span>=</span> <span>(</span><span>addr</span> <span>as</span> <span>usize</span> <span>-</span> <span>0x8000</span><span>)</span> <span>%</span> <span>rom_len</span><span>;</span>
                <span>self</span><span>.rom.prg_rom</span><span>[</span><span>rom_offset</span><span>]</span>
            <span>}</span>
            <span>_</span> <span>=&gt;</span> <span>{</span>
                <span>unimplemented!</span><span>(</span><span>"Read from ${:04X}"</span><span>,</span> <span>addr</span><span>);</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>// This is the same logic we used in `Nes::from_rom`, so</span>
    <span>// we could refactor this</span>
    <span>fn</span> <span>read_u16</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>addr</span><span>:</span> <span>u16</span><span>)</span> <span>-&gt;</span> <span>u16</span> <span>{</span>
        <span>let</span> <span>lo</span> <span>=</span> <span>self</span><span>.read_u8</span><span>(</span><span>addr</span><span>);</span>
        <span>let</span> <span>hi</span> <span>=</span> <span>self</span><span>.read_u8</span><span>(</span><span>addr</span><span>.wrapping_add</span><span>(</span><span>1</span><span>));</span>

        <span>(</span><span>lo</span> <span>as</span> <span>u16</span><span>)</span> <span>|</span> <span>((</span><span>hi</span> <span>as</span> <span>u16</span><span>)</span> <span>&lt;&lt;</span> <span>8</span><span>)</span>
    <span>}</span>

    <span>fn</span> <span>write_u8</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>addr</span><span>:</span> <span>u16</span><span>,</span> <span>value</span><span>:</span> <span>u8</span><span>)</span> <span>{</span>
        <span>match</span> <span>addr</span> <span>{</span>
            <span>// RAM (mirrored every 0x0800 bytes)</span>
            <span>0x0000</span><span>..=</span><span>0x07FF</span> <span>=&gt;</span> <span>{</span>
                <span>let</span> <span>ram_offset</span> <span>=</span> <span>(</span><span>addr</span> <span>as</span> <span>usize</span><span>)</span> <span>%</span> <span>self</span><span>.ram</span><span>.len</span><span>();</span>
                <span>self</span><span>.ram</span><span>[</span><span>ram_offset</span><span>]</span> <span>=</span> <span>value</span><span>;</span>
            <span>}</span>
            <span>// PRG-ROM (writes are ignored for NROM)</span>
            <span>0x8000</span><span>..=</span><span>0xFFFF</span> <span>=&gt;</span> <span>{</span> <span>}</span>
            <span>_</span> <span>=&gt;</span> <span>{</span>
                <span>unimplemented!</span><span>(</span><span>"Write to ${:04X}"</span><span>,</span> <span>addr</span><span>);</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div> <p>So now we have enough to finally emulate the CPU for our sample ROM!</p> <div><pre><code><span>impl</span> <span>Nes</span> <span>{</span>
    <span>// ...</span>

    <span>fn</span> <span>run</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
        <span>loop</span> <span>{</span>
            <span>let</span> <span>pc</span> <span>=</span> <span>self</span><span>.cpu.pc</span><span>;</span>
            <span>let</span> <span>opcode</span> <span>=</span> <span>self</span><span>.read_u8</span><span>(</span><span>pc</span><span>);</span>

            <span>let</span> <span>next_pc</span><span>;</span>
            <span>match</span> <span>opcode</span> <span>{</span>
                <span>// LDA:</span>
                <span>//   Load immediate value into A</span>
                <span>0xA9</span> <span>=&gt;</span> <span>{</span>
                    <span>let</span> <span>value</span> <span>=</span>
                        <span>self</span><span>.read_u8</span><span>(</span><span>pc</span><span>.wrapping_add</span><span>(</span><span>1</span><span>));</span>
                    <span>self</span><span>.cpu.a</span> <span>=</span> <span>value</span><span>;</span>
                    <span>next_pc</span> <span>=</span> <span>pc</span><span>.wrapping_add</span><span>(</span><span>2</span><span>);</span>
                <span>}</span>
                <span>// ADC:</span>
                <span>//   Add immediate value to A</span>
                <span>0x69</span> <span>=&gt;</span> <span>{</span>
                    <span>let</span> <span>value</span> <span>=</span>
                        <span>self</span><span>.read_u8</span><span>(</span><span>pc</span><span>.wrapping_add</span><span>(</span><span>1</span><span>));</span>
                    <span>self</span><span>.cpu.a</span> <span>=</span>
                        <span>self</span><span>.cpu.a</span><span>.wrapping_add</span><span>(</span><span>value</span><span>);</span>
                    <span>next_pc</span> <span>=</span> <span>pc</span><span>.wrapping_add</span><span>(</span><span>2</span><span>);</span>
                <span>}</span>
                <span>// TAX:</span>
                <span>//   Transfer A to X</span>
                <span>0xAA</span> <span>=&gt;</span> <span>{</span>
                    <span>self</span><span>.cpu.x</span> <span>=</span> <span>self</span><span>.cpu.a</span><span>;</span>
                    <span>next_pc</span> <span>=</span> <span>pc</span><span>.wrapping_add</span><span>(</span><span>1</span><span>);</span>
                <span>}</span>
                <span>// STX:</span>
                <span>//   Store X to address between</span>
                <span>//   $0000 and $00FF</span>
                <span>0x86</span> <span>=&gt;</span> <span>{</span>
                    <span>let</span> <span>addr_lo</span> <span>=</span>
                        <span>self</span><span>.read_u8</span><span>(</span><span>pc</span><span>.wrapping_add</span><span>(</span><span>1</span><span>));</span>
                    <span>// Between $0000 and $00FFF:</span>
                    <span>let</span> <span>addr</span> <span>=</span> <span>addr_lo</span> <span>as</span> <span>u16</span><span>;</span>
                    <span>self</span><span>.write_u8</span><span>(</span><span>addr</span><span>,</span> <span>self</span><span>.cpu.x</span><span>);</span>
                    <span>next_pc</span> <span>=</span> <span>pc</span><span>.wrapping_add</span><span>(</span><span>2</span><span>);</span>
                <span>}</span>
                <span>// LDA:</span>
                <span>//   Load A from address between</span>
                <span>//   $0000 and $00FF</span>
                <span>0xA5</span> <span>=&gt;</span> <span>{</span>
                    <span>let</span> <span>addr_lo</span> <span>=</span>
                        <span>self</span><span>.read_u8</span><span>(</span><span>pc</span><span>.wrapping_add</span><span>(</span><span>1</span><span>));</span>
                    <span>// Between $0000 and $00FF:</span>
                    <span>let</span> <span>addr</span> <span>=</span> <span>addr_lo</span> <span>as</span> <span>u16</span><span>;</span>
                    <span>self</span><span>.cpu.a</span> <span>=</span> <span>self</span><span>.read_u8</span><span>(</span><span>addr</span><span>);</span>
                    <span>next_pc</span> <span>=</span> <span>pc</span><span>.wrapping_add</span><span>(</span><span>2</span><span>);</span>
                <span>}</span>
                <span>// JMP:</span>
                <span>//   Jump to address by changing PC</span>
                <span>0x4C</span> <span>=&gt;</span> <span>{</span>
                    <span>let</span> <span>target</span> <span>=</span>
                        <span>self</span><span>.read_u16</span><span>(</span><span>pc</span><span>.wrapping_add</span><span>(</span><span>1</span><span>));</span>
                    <span>// Set PC to the address we just read:</span>
                    <span>next_pc</span> <span>=</span> <span>target</span><span>;</span>
                <span>}</span>
                <span>_</span> <span>=&gt;</span> <span>{</span>
                    <span>unimplemented!</span><span>(</span><span>"Opcode {:02X}"</span><span>,</span> <span>opcode</span><span>);</span>
                <span>}</span>
            <span>}</span>

            <span>self</span><span>.cpu.pc</span> <span>=</span> <span>next_pc</span><span>;</span>

            <span>// Some nice debug output so we can see</span>
            <span>// the CPU state after every cycle</span>
            <span>println!</span><span>(</span><span>"Opcode: {:02X}"</span><span>,</span> <span>opcode</span><span>);</span>
            <span>println!</span><span>(</span><span>"CPU State: {:02X?}"</span><span>,</span> <span>self</span><span>.cpu</span><span>);</span>
            <span>println!</span><span>(</span><span>"-----------------"</span><span>);</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div> <p>(<a href="https://play.rust-lang.org/?version=nightly&amp;gist=556808cf6f793d7e48bca7ba056f5581">Rust Playground ▶</a>)</p> <p>(This code uses one very nice underappreciated Rust feature! We have line that just says <code>let next_pc;</code>, which will hold the new address of <code>PC</code>. By making an <em>uninitialized and immutable</em> variable, <strong>we force each match branch to set <code>next_pc</code> exactly once!</strong> I just think that’s beautiful…)</p> <p>So there we have it! We have a very basic but functional NES emulator, which emulates the CPU to run a ROM, and it supports 5 different opcodes!</p> <p>Well… kind of. There are a few things wrong in our above code. Most importantly, we aren’t setting the <code>P</code> register (which a lot of different opcodes change). Also, <code>ADC</code> doesn’t handle carrying at all. Third, and this is the hard part, <strong>we are ignoring cycles!</strong></p>  <p>To reiterate, our CPU is just one component of our emulator. While it’s running, the PPU and APU are both doing their own thing. To top it off, the NES’s CPU and PPU have <em>very</em> precise timings, which some games lean heavily on. Even simple games can have major issues if your timing is too far off!</p> <p>But it gets worse. It’s not sufficient to “pause” emulation for a few cycles between instructions. Specifically, the 6502 performs memory reads and writes on <em>specific</em> instruction cycles.</p> <p>For a concrete example, let’s look at the <code>STX</code> opcode with zero-page addressing (opcode <code>A5</code>, something like <code>STX $0001</code>). This opcode takes <strong>3</strong> cycles, which work like this:</p> <ul> <li><strong>Cycle 1</strong>: Read the opcode from <code>PC</code>, then increment <code>PC</code></li> <li><strong>Cycle 2</strong>: Read the zero-page address by reading <code>PC</code>, then increment <code>PC</code> again</li> <li><strong>Cycle 3</strong>: Write the value of <code>X</code> to the address that we read in cycle 2</li> </ul> <p>(As with everything else, <a href="http://nesdev.com/6502_cpu.txt">there’s a Nesdev page for that</a> (which also includes cycle timings for <em>all</em> opcodes, including unofficial ones!))</p> <p>It can be really hard to get an observable difference here, but <em>in theory</em> a game could read from some volatile memory address that changes values <em>between</em> cycles… yikes! So, if we were interested in writing a fully accurate emulator, we’d have to solve this.</p> <p>And, while Lochnes isn’t fully accurate, I did solve this particular problem using a pretty cool tool!</p>  <p>At the time of writing, generators are an unstable Rust feature. But, they are perfect for our use case! They let you write closures that use the <code>yield</code> keyword, which can be used for all sorts of things. For example, if we wanted to print the Fibonacci sequence, we could pretty easily express this with generators:</p> <div><pre><code><span>#![feature(generators,</span> <span>generator_trait)]</span>

<span>use</span> <span>std</span><span>::</span><span>pin</span><span>::</span><span>Pin</span><span>;</span>
<span>use</span> <span>std</span><span>::</span><span>ops</span><span>::{</span><span>Generator</span><span>,</span> <span>GeneratorState</span><span>};</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>// This is our generator (it's a closure that</span>
    <span>// uses the `yield` keyword)</span>
    <span>let</span> <span>mut</span> <span>fib</span> <span>=</span> <span>||</span> <span>{</span>
        <span>let</span> <span>mut</span> <span>a</span> <span>=</span> <span>0</span><span>;</span>
        <span>let</span> <span>mut</span> <span>b</span> <span>=</span> <span>1</span><span>;</span>

        <span>loop</span> <span>{</span>
            <span>yield</span> <span>b</span><span>;</span>
            <span>let</span> <span>new_a</span> <span>=</span> <span>b</span><span>;</span>
            <span>let</span> <span>new_b</span> <span>=</span> <span>a</span> <span>+</span> <span>b</span><span>;</span>
            <span>a</span> <span>=</span> <span>new_a</span><span>;</span>
            <span>b</span> <span>=</span> <span>new_b</span><span>;</span>
        <span>}</span>
    <span>};</span>

    <span>// Only get the first 10 Fibonacci numbers</span>
    <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>10</span> <span>{</span>
        <span>// Repeatedly call `resume` on our generator</span>
        <span>// to get the values that get yielded</span>
        <span>match</span> <span>Pin</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>mut</span> <span>fib</span><span>)</span><span>.resume</span><span>()</span> <span>{</span>
            <span>GeneratorState</span><span>::</span><span>Yielded</span><span>(</span><span>n</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>println!</span><span>(</span><span>"{}"</span><span>,</span> <span>n</span><span>);</span> <span>}</span>
            <span>GeneratorState</span><span>::</span><span>Complete</span><span>(</span><span>_</span><span>)</span> <span>=&gt;</span> <span>{</span>
                <span>// If our generator returned, we could</span>
                <span>// handle that here</span>
                <span>unreachable!</span><span>();</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>println!</span><span>(</span><span>"Done"</span><span>);</span>
<span>}</span>
</code></pre></div> <p>(<a href="https://play.rust-lang.org/?version=nightly&amp;gist=db5db39e7c2236e27733cecc2622c901">Rust Playground ▶</a>)</p> <p>…okay, <em>using</em> generators is real ugly, and there are definitely more idiomatic ways of iterating through the Fibonacci sequence in Rust, but hopefully you can appreciate the power of <code>yield</code>! We can use it to “suspend” our function with some intermediate value then “resume” it later (or we can just use it to stop execution after some time, like in this case)</p> <p>So, let’s try dropping in generators with what we have so we can iterate on it:</p> <div><pre><code><span>#![feature(generators,</span> <span>generator_trait)]</span>

<span>use</span> <span>std</span><span>::</span><span>pin</span><span>::</span><span>Pin</span><span>;</span>
<span>use</span> <span>std</span><span>::</span><span>ops</span><span>::{</span><span>Generator</span><span>,</span> <span>GeneratorState</span><span>};</span>

<span>impl</span> <span>Nes</span> <span>{</span>
    <span>// Instead of doing work, `run` returns a generator</span>
    <span>// that can be resumed repeatedly (it doesn't do anything</span>
    <span>// until the first time `.resume()` gets called).</span>
    <span>//</span>
    <span>// We need the lifetime here because our generator</span>
    <span>// borrows `self`-- after all, calling `.resume()` is</span>
    <span>// supposed to update the emulator's state!</span>
    <span>fn</span> <span>run</span><span>&lt;</span><span>'a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>'a</span> <span>mut</span> <span>self</span><span>)</span>
        <span>-&gt;</span> <span>impl</span> <span>Generator</span><span>&lt;</span><span>Yield</span> <span>=</span> <span>(),</span> <span>Return</span> <span>=</span> <span>()</span><span>&gt;</span> <span>+</span> <span>'a</span>
    <span>{</span>
        <span>// Nice shorthand for creating a looping generator</span>
        <span>// (parsed as `(move || { loop { ... }})`). We need</span>
        <span>// `move` here because the closure keeps the</span>
        <span>// reference to `self`</span>
        <span>move</span> <span>||</span> <span>loop</span> <span>{</span>
            <span>let</span> <span>pc</span> <span>=</span> <span>self</span><span>.cpu.pc</span><span>;</span>

            <span>// ... the rest of our old `run` function ...</span>

            <span>// "Yield" to stop for a cycle. For now, we pretend</span>
            <span>// that every instruction takes one cycle</span>
            <span>yield</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>fn</span> <span>main</span><span>()</span> <span>{</span>
    <span>let</span> <span>rom</span> <span>=</span> <span>Rom</span><span>::</span><span>from_file</span><span>(</span><span>"sample.nes"</span><span>);</span>
    <span>let</span> <span>mut</span> <span>nes</span> <span>=</span> <span>Nes</span><span>::</span><span>from_rom</span><span>(</span><span>rom</span><span>);</span>

    <span>let</span> <span>mut</span> <span>nes_run</span> <span>=</span> <span>nes</span><span>.run</span><span>();</span>
    <span>loop</span> <span>{</span>
        <span>match</span> <span>Pin</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>mut</span> <span>nes_run</span><span>)</span><span>.resume</span><span>()</span> <span>{</span>
            <span>GeneratorState</span><span>::</span><span>Yielded</span><span>(())</span> <span>=&gt;</span> <span>{</span>
                <span>println!</span><span>(</span><span>"&gt; Cycle"</span><span>);</span>
            <span>}</span>
            <span>GeneratorState</span><span>::</span><span>Complete</span><span>(</span><span>_</span><span>)</span> <span>=&gt;</span> <span>{</span>
                <span>// Stop running if our `run` generator stops</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div> <p>(<a href="https://play.rust-lang.org/?version=nightly&amp;gist=f22e3a24547eb0a6ba7bea4b565284cb">Rust Playground ▶</a>)</p> <p>If we run this, we’ll see <code>&gt; Cycle</code> is printed between each instruction. That’s not right though, because each instruction takes multiple cycles! In fact, on the 6502, all instructions take at least 2 cycles.</p> <p>Instead of going in-depth on how each instruction works, let’s look at our friend <code>STX</code> again. Remember, this is how the cycles play out:</p> <ul> <li><strong>Cycle 1</strong>: Read the opcode from <code>PC</code>, then increment <code>PC</code></li> <li><strong>Cycle 2</strong>: Read the zero-page address by reading <code>PC</code>, then increment <code>PC</code> again</li> <li><strong>Cycle 3</strong>: Write the value of <code>X</code> to the address that we read in cycle 2</li> </ul> <p>…and the same thing in code:</p> <div><pre><code><span>impl</span> <span>Nes</span> <span>{</span>
    <span>fn</span> <span>run</span><span>&lt;</span><span>'a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>'a</span> <span>mut</span> <span>self</span><span>)</span>
        <span>-&gt;</span> <span>impl</span> <span>Generator</span><span>&lt;</span><span>Yield</span> <span>=</span> <span>(),</span> <span>Return</span> <span>=</span> <span>()</span><span>&gt;</span> <span>+</span> <span>'a</span>
    <span>{</span>
        <span>move</span> <span>||</span> <span>loop</span> <span>{</span>
            <span>// Cycle 1:</span>
            <span>//   Read the opcode from PC, then increment PC</span>
            <span>let</span> <span>opcode</span> <span>=</span> <span>self</span><span>.read_u8</span><span>(</span><span>self</span><span>.cpu.pc</span><span>);</span>
            <span>self</span><span>.cpu.pc</span> <span>=</span> <span>self</span><span>.cpu.pc</span><span>.wrapping_add</span><span>(</span><span>1</span><span>);</span>
            <span>yield</span><span>;</span>

            <span>// Now we have our opcode, so match on it again</span>
            <span>match</span> <span>opcode</span> <span>{</span>
                <span>// STX:</span>
                <span>//   Store X to address between</span>
                <span>//   $0000 and $00FF</span>
                <span>0x86</span> <span>=&gt;</span> <span>{</span>
                    <span>// Cycle 2:</span>
                    <span>//   Read the zero-page address by</span>
                    <span>//   reading PC, then increment PC again</span>
                    <span>let</span> <span>addr_lo</span> <span>=</span> <span>self</span><span>.read_u8</span><span>(</span><span>self</span><span>.cpu.pc</span><span>);</span>
                    <span>let</span> <span>addr</span> <span>=</span> <span>addr_lo</span> <span>as</span> <span>u16</span><span>;</span>
                    <span>self</span><span>.cpu.pc</span> <span>=</span> <span>self</span><span>.cpu.pc</span><span>.wrapping_add</span><span>(</span><span>1</span><span>);</span>
                    <span>yield</span><span>;</span>

                    <span>// Cycle 3:</span>
                    <span>//   Write the value of X to the address</span>
                    <span>//   that we read in cycle 2</span>
                    <span>self</span><span>.write_u8</span><span>(</span><span>addr</span><span>,</span> <span>self</span><span>.cpu.x</span><span>);</span>
                    <span>yield</span><span>;</span>

                    <span>// NOTE: Because we already incremented PC,</span>
                    <span>// we don't have `next_pc` any more</span>
                <span>}</span>
                <span>// ... other opcodes ...</span>
            <span>}</span>

            <span>// NOTE: Now all are yields are above this point</span>

            <span>// Some nice debug output so we can see what we're doing</span>
            <span>println!</span><span>(</span><span>"Opcode: {:02X}"</span><span>,</span> <span>opcode</span><span>);</span>
            <span>println!</span><span>(</span><span>"CPU State: {:02X}"</span><span>,</span> <span>self</span><span>.cpu</span><span>);</span>
            <span>println!</span><span>(</span><span>"-----------------"</span><span>);</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div> <p>(<a href="https://play.rust-lang.org/?version=nightly&amp;gist=4c3602b5d410baddc86417006a92c85b">Rust Playground ▶</a>)</p> <p>Repeat with our other opcodes and <em>voilà</em>! We now have cycle-accurate emulation of 6502 instructions, and one that handles volatile memory reads at that! We can observe this by running our code and counting the number of cycles between each instruction:</p> <div><pre><code>&gt; Cycle
&gt; Cycle
Opcode: A9
CPU State: Cpu { pc: 8002, a: 05, x: 00, y: 00, s: FD, p: 34 }
-----------------
&gt; Cycle
&gt; Cycle
Opcode: 69
CPU State: Cpu { pc: 8004, a: 0B, x: 00, y: 00, s: FD, p: 34 }
-----------------
&gt; Cycle
&gt; Cycle
Opcode: AA
CPU State: Cpu { pc: 8005, a: 0B, x: 0B, y: 00, s: FD, p: 34 }
-----------------
&gt; Cycle
&gt; Cycle
&gt; Cycle
Opcode: 86
CPU State: Cpu { pc: 8007, a: 0B, x: 0B, y: 00, s: FD, p: 34 }
-----------------
&gt; Cycle
&gt; Cycle
&gt; Cycle
Opcode: A5
CPU State: Cpu { pc: 8009, a: 0B, x: 0B, y: 00, s: FD, p: 34 }
-----------------
</code></pre></div> <p>If you compare the number of cycles for each instruction to, say, <a href="http://www.obelisk.me.uk/6502/reference.html">Andrew Jacobs’ 6502 instruction reference page</a>, we should see that the number of cycles line up! (Hint: Ctrl+F and search for <code>$A5</code> to find the entry for opcode <code>A5</code>… in this case <code>A5</code> should take 3 cycles, which is exactly how many times <code>&gt; Cycle</code> gets printed)</p>  <p>Before we pat ourselves on the back too hard, let’s revisit <em>why</em> we needed to deal with cycles at all: we need to precisely time how the CPU runs alongside the PPU and APU. So let’s actually exercise our newfound cycle freedom to lay the foundation for PPU emulation.</p> <p>Let’s do a minor refactor first, by separating <code>nes.run()</code> from the CPU emulation code.</p> <div><pre><code><span>impl</span> <span>Nes</span> <span>{</span>
    <span>fn</span> <span>run_cpu</span><span>&lt;</span><span>'a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>'a</span> <span>mut</span> <span>self</span><span>)</span>
        <span>-&gt;</span> <span>impl</span> <span>Generator</span><span>&lt;</span><span>Yield</span> <span>=</span> <span>(),</span> <span>Return</span> <span>=</span> <span>()</span><span>&gt;</span> <span>+</span> <span>'a</span>
    <span>{</span>
        <span>move</span> <span>||</span> <span>loop</span> <span>{</span>
            <span>let</span> <span>opcode</span> <span>=</span> <span>self</span><span>.read_u8</span><span>(</span><span>self</span><span>.cpu.pc</span><span>);</span>
            <span>// ... everything in our old `run` function ...</span>
        <span>}</span>
    <span>}</span>

    <span>fn</span> <span>run</span><span>&lt;</span><span>'a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>'a</span> <span>mut</span> <span>self</span><span>)</span>
        <span>-&gt;</span> <span>impl</span> <span>Generator</span><span>&lt;</span><span>Yield</span> <span>=</span> <span>(),</span> <span>Return</span> <span>=</span> <span>()</span><span>&gt;</span> <span>+</span> <span>'a</span>
    <span>{</span>
        <span>let</span> <span>mut</span> <span>run_cpu</span> <span>=</span> <span>self</span><span>.run_cpu</span><span>();</span>

        <span>move</span> <span>||</span> <span>loop</span> <span>{</span>
            <span>// Step the CPU for one cycle</span>
            <span>match</span> <span>Pin</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>mut</span> <span>run_cpu</span><span>)</span><span>.resume</span><span>()</span> <span>{</span>
                <span>GeneratorState</span><span>::</span><span>Yielded</span><span>(())</span> <span>=&gt;</span> <span>{</span> <span>}</span>
                <span>GeneratorState</span><span>::</span><span>Complete</span><span>(</span><span>_</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>break</span><span>;</span> <span>}</span>
            <span>}</span>

            <span>// Yield one NES cycle</span>
            <span>yield</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div> <p>(<a href="https://play.rust-lang.org/?version=nightly&amp;gist=81e58a9a28927bd3d46d75178d560f2c">Rust Playground ▶</a>)</p> <p>Now we have more control with how our CPU runs versus the NES as a whole. With that out of the way…</p> <p>…uhh, let’s talk about the PPU. As it turns out, emulating the PPU is actually really hard, so we’re not going to do all that right now. Instead, we’ll emulate one small thing the PPU <em>does</em> do: it sets the NMI flag on the CPU.</p> <p>To make a long story short, the NMI (or non-maskable interrupt) flag tells the CPU to stop whatever it’s doing and handle an important event. In the NES, it’s used specifically to signal when VBlank (vertical blanking) starts, which is the small window of time where the CPU can safely talk to the PPU to update graphics data. VBlank– and, consequently, NMI– happen at the end of each frame.</p> <p>So basically, the PPU will set the NMI flag to <code>true</code> once per frame, and the CPU will set it back to <code>false</code> immediately (indicating that the CPU handled the NMI). ez-pz, let’s do this:</p> <div><pre><code><span>struct</span> <span>Cpu</span> <span>{</span>
    <span>// ...</span>
    <span>nmi</span><span>:</span> <span>bool</span><span>,</span> <span>// Set to false initially</span>
<span>}</span>

<span>impl</span> <span>Nes</span> <span>{</span>
    <span>fn</span> <span>run</span><span>&lt;</span><span>'a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>'a</span> <span>mut</span> <span>self</span><span>)</span>
        <span>-&gt;</span> <span>impl</span> <span>Generator</span><span>&lt;</span><span>Yield</span> <span>=</span> <span>(),</span> <span>Return</span> <span>=</span> <span>()</span><span>&gt;</span> <span>+</span> <span>'a</span>
    <span>{</span>
        <span>let</span> <span>mut</span> <span>run_cpu</span> <span>=</span> <span>self</span><span>.run_cpu</span><span>();</span>
        <span>let</span> <span>mut</span> <span>run_ppu</span> <span>=</span> <span>self</span><span>.run_ppu</span><span>();</span>

        <span>move</span> <span>||</span> <span>loop</span> <span>{</span>
            <span>// Step the CPU for one cycle</span>
            <span>match</span> <span>Pin</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>mut</span> <span>run_cpu</span><span>)</span><span>.resume</span><span>()</span> <span>{</span>
                <span>GeneratorState</span><span>::</span><span>Yielded</span><span>(())</span> <span>=&gt;</span> <span>{</span> <span>}</span>
                <span>GeneratorState</span><span>::</span><span>Complete</span><span>(</span><span>_</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>break</span><span>;</span> <span>}</span>
            <span>}</span>

            <span>// Step the PPU for 3 cycles (the PPU</span>
            <span>// is 3x faster than the CPU)</span>
            <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>3</span> <span>{</span>
                <span>match</span> <span>Pin</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>mut</span> <span>run_ppu</span><span>)</span><span>.resume</span><span>()</span> <span>{</span>
                    <span>GeneratorState</span><span>::</span><span>Yielded</span><span>(())</span> <span>=&gt;</span> <span>{</span> <span>}</span>
                    <span>GeneratorState</span><span>::</span><span>Complete</span><span>(</span><span>_</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>break</span><span>;</span> <span>}</span>
                <span>}</span>
            <span>}</span>

            <span>// We ran both the CPU and PPU,</span>
            <span>// so yield one NES cycle</span>
            <span>yield</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>fn</span> <span>run_cpu</span><span>&lt;</span><span>'a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>'a</span> <span>mut</span> <span>self</span><span>)</span>
        <span>-&gt;</span> <span>impl</span> <span>Generator</span><span>&lt;</span><span>Yield</span> <span>=</span> <span>(),</span> <span>Return</span> <span>=</span> <span>()</span><span>&gt;</span> <span>+</span> <span>'a</span>
    <span>{</span>
        <span>move</span> <span>||</span> <span>loop</span> <span>{</span>
            <span>if</span> <span>self</span><span>.cpu.nmi</span> <span>{</span>
                <span>// NOTE: It's intentional that this</span>
                <span>// check happens on the cycle before</span>
                <span>// the next instruction executes!</span>

                <span>// TODO: Read NMI interrupt vector</span>
                <span>// from address $FFFE, then set PC</span>
                <span>println!</span><span>(</span><span>"=== NMI! ==="</span><span>);</span>
                <span>self</span><span>.cpu.nmi</span> <span>=</span> <span>false</span><span>;</span>
            <span>}</span>

            <span>let</span> <span>opcode</span> <span>=</span> <span>self</span><span>.read_u8</span><span>(</span><span>self</span><span>.cpu.pc</span><span>);</span>
            <span>// ... same as before ...</span>
        <span>}</span>
    <span>}</span>

    <span>fn</span> <span>run_ppu</span><span>&lt;</span><span>'a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>'a</span> <span>mut</span> <span>self</span><span>)</span>
        <span>-&gt;</span> <span>impl</span> <span>Generator</span><span>&lt;</span><span>Yield</span> <span>=</span> <span>(),</span> <span>Return</span> <span>=</span> <span>()</span><span>&gt;</span> <span>+</span> <span>'a</span>
    <span>{</span>
        <span>move</span> <span>||</span> <span>loop</span> <span>{</span>
            <span>for</span> <span>_</span><span>frame</span> <span>in</span> <span>0</span><span>..</span> <span>{</span>
                <span>// - Each PPU cycle produces 1 pixel</span>
                <span>// - Each line lasts 341 cycles (256 visible)</span>
                <span>// - Each frame lasts 262 lines (240 visible)</span>
                <span>const</span> <span>PPU_CYCLES_PER_FRAME</span><span>:</span> <span>u32</span> <span>=</span> <span>341</span> <span>*</span> <span>262</span><span>;</span>
                <span>for</span> <span>cycle</span> <span>in</span> <span>0</span><span>..</span><span>PPU_CYCLES_PER_FRAME</span> <span>{</span>
                    <span>// NMI starts at the *second* cycle!</span>
                    <span>if</span> <span>cycle</span> <span>==</span> <span>1</span> <span>{</span>
                        <span>self</span><span>.cpu.nmi</span> <span>=</span> <span>true</span><span>;</span>
                    <span>}</span>

                    <span>// TODO: Output pixels</span>

                    <span>yield</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div> <p>(<a href="https://play.rust-lang.org/?version=nightly&amp;gist=f588156f361a266baa8abb7019a6af05">Rust Playground ▶</a>?)</p> <p>So basically, this code should:</p> <ul> <li>Run <code>run_ppu</code> in parallel with <code>run_cpu</code>, running 3 PPU cycles for each CPU cycle</li> <li>Set the <code>nmi</code> flag to <code>true</code> on the second cycle of each frame in <code>run_ppu</code></li> <li>Set the <code>nmi</code> flag to <code>false</code> between instructions in <code>run_cpu</code></li> </ul> <p>Pretty straightforward, right? <code>rustc</code> disagrees:</p> <div><pre><code>error[E0499]: cannot borrow `*self` as mutable more than once at a time
   --&gt; src/main.rs:96:27
    |
92  |       fn run&lt;'a&gt;(&amp;'a mut self)
    |              -- lifetime `'a` defined here
...
95  |           let mut run_cpu = self.run_cpu();
    |                             ---- first mutable borrow occurs here
96  |           let mut run_ppu = self.run_ppu();
    |                             ^^^^ second mutable borrow occurs here
97  |
98  | /         move || loop {
99  | |             // Step the CPU for one cycle
100 | |             match Pin::new(&amp;mut run_cpu).resume() {
101 | |                 GeneratorState::Yielded(()) =&gt; { }
...   |
116 | |             yield;
117 | |         }
    | |_________- returning this value requires that `*self` is borrowed for `'a`
</code></pre></div> <p>(dammit we almost got to the end of this article without any weird compiler errors)</p>  <p>Let’s try to break this down. So <code>run_cpu</code> is a generator that mutably borrows <code>nes</code> because it needs to update the CPU’s registers each time it runs. <code>run_ppu</code> is a generator that mutably borrows <code>nes</code> because it needs to set the CPU’s <code>nmi</code> field once per frame.</p> <p>I think this is actually a really good example of where Rust’s borrow checker shines! We need to update the same structure from two different “threads”, even though those “threads” are generators that run on a single OS thread. I think a common misconception of Rust’s borrow checker is that it <em>only</em> exists for multi-threading, but <a href="https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/">manishearth has a great article that gives some examples where the borrow checker is useful in single-threaded code</a>. I think the above code is another good example: we are <em>literally</em> threading the execution of our code between the CPU and PPU, and we need to use the right primitives to ensure we don’t have any data races!</p> <p>(A natural consequence of this is that we could easily run the CPU and PPU on different threads by using multi-threaded primitives like <code>RwLock</code>!)</p> <p>So, we need shared mutability, we’re running on a single thread, we’re dealing with <code>Copy</code> types (<code>u8</code>, etc.), and we don’t need to hold references to the values? <a href="https://doc.rust-lang.org/1.5.0/book/choosing-your-guarantees.html#cellt">That sounds perfect for <code>Cell</code></a>!</p> <p>There’s a few different ways you could slice it, but I think the easiest is just to update all our fields to use <code>Cell&lt;u8&gt;</code> instead of <code>u8</code>, etc. where possible. Note that we should skip changing <code>prg_rom</code> since we don’t need to mutate it! Here’s what our updated structures look like:</p> <div><pre><code><span>use</span> <span>std</span><span>::</span><span>cell</span><span>::</span><span>Cell</span><span>;</span>

<span>struct</span> <span>Nes</span> <span>{</span>
    <span>cpu</span><span>:</span> <span>Cpu</span><span>,</span>
    <span>ram</span><span>:</span> <span>Cell</span><span>&lt;</span><span>[</span><span>u8</span><span>;</span> <span>0x0800</span><span>]</span><span>&gt;</span><span>,</span>
    <span>rom</span><span>:</span> <span>Rom</span><span>,</span>
    <span>// TODO: PPU</span>
    <span>// TODO: APU</span>
<span>}</span>

<span>struct</span> <span>Rom</span> <span>{</span>
    <span>prg_rom</span><span>:</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span>
<span>}</span>

<span>#[derive(Debug)]</span>
<span>struct</span> <span>Cpu</span> <span>{</span>
    <span>pc</span><span>:</span> <span>Cell</span><span>&lt;</span><span>u16</span><span>&gt;</span><span>,</span>
    <span>a</span><span>:</span> <span>Cell</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span>
    <span>x</span><span>:</span> <span>Cell</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span>
    <span>y</span><span>:</span> <span>Cell</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span>
    <span>s</span><span>:</span> <span>Cell</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span>
    <span>p</span><span>:</span> <span>Cell</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span>
    <span>nmi</span><span>:</span> <span>Cell</span><span>&lt;</span><span>bool</span><span>&gt;</span><span>,</span>
<span>}</span>
</code></pre></div> <p>…then we change <code>write_u8</code>, <code>run</code>, <code>run_cpu</code>, and <code>run_ppu</code> to take <code>&amp;self</code> instead of <code>&amp;mut self</code>, and then we use <code>.get()</code> / <code>.set()</code> to read/write the cell values. A small sample of the changes:</p> <div><pre><code><span>impl</span> <span>Nes</span> <span>{</span>
    <span>fn</span> <span>run_cpu</span><span>&lt;</span><span>'a</span><span>&gt;</span><span>(</span><span>&amp;</span><span>'a</span> <span>self</span><span>)</span> <span>-&gt;</span> <span>impl</span> <span>Generator</span><span>&lt;</span><span>Yield</span> <span>=</span> <span>(),</span> <span>Return</span> <span>=</span> <span>()</span><span>&gt;</span> <span>+</span> <span>'a</span> <span>{</span>
        <span>move</span> <span>||</span> <span>loop</span> <span>{</span>
            <span>// Keep in mind the difference between calling</span>
            <span>// `.get()` in an expression versus saving it in</span>
            <span>// a variable for later! They seem equivalent, but</span>
            <span>// if the PPU or some other code changes the value</span>
            <span>// in the meantime, you'll be using stale data!</span>
            <span>if</span> <span>self</span><span>.cpu.nmi</span><span>.get</span><span>()</span> <span>{</span>
                <span>// TODO: Read NMI interrupt vector</span>
                <span>// from address $FFFE, then set PC</span>
                <span>println!</span><span>(</span><span>"=== NMI! ==="</span><span>);</span>
                <span>self</span><span>.cpu.nmi</span><span>.set</span><span>(</span><span>false</span><span>);</span>
            <span>}</span>

            <span>let</span> <span>opcode</span> <span>=</span> <span>self</span><span>.read_u8</span><span>(</span><span>self</span><span>.cpu.pc</span><span>.get</span><span>());</span>
            <span>// ...</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div> <p>(<a href="https://play.rust-lang.org/?version=nightly&amp;gist=6319ddb4a3d106b370d354fda1d1cd42">Rust Playground ▶</a>)</p> <p>Then, like magic, we see “<code>=== NMI! ===</code>” appear out of thin air in our CPU generator:</p> <div><pre><code>&gt; Cycle
&gt; Cycle
Opcode: A9
CPU State: Cpu { pc: Cell { value: 8002 }, a: Cell { value: 05 }, x: Cell { value: 00 }, y: Cell { value: 00 }, s: Cell { value: FD }, p: Cell { value: 34 }, nmi: Cell { value: true } }
-----------------
=== NMI! ===
&gt; Cycle
&gt; Cycle
</code></pre></div> <p>Which is exactly what we expect! This is essentially how our execution is playing out:</p> <ul> <li><code>nes_run.resume()</code>: <ul> <li>1 CPU cycle: <ul> <li><code>cpu_run.resume()</code>: Execute cycle 1 of opcode <code>A9</code></li> </ul></li> <li>3 PPU cycles: <ul> <li><code>ppu_run.resume()</code>: (do nothing)</li> <li><code>ppu_run.resume()</code>: <strong>Set <code>nmi</code> to true</strong></li> <li><code>ppu_run.resume()</code>: (do nothing)</li> </ul></li> </ul></li> <li><code>nes_run.resume()</code>: <ul> <li>1 CPU cycle: <ul> <li><code>cpu_run.resume()</code>: Execute cycle 2 of opcode <code>A9</code></li> </ul></li> <li>3 PPU cycles: <ul> <li><code>ppu_run.resume()</code>: (do nothing)</li> <li><code>ppu_run.resume()</code>: (do nothing)</li> <li><code>ppu_run.resume()</code>: (do nothing)</li> </ul></li> </ul></li> <li><code>nes_run.resume()</code>: <ul> <li>1 CPU cycle: <ul> <li><code>cpu_run.resume()</code>: <strong>NMI is true, so handle it</strong>; Execute cycle 1 of opcode <code>69</code></li> </ul></li> <li>3 PPU cycles <ul> <li><code>ppu_run.resume()</code>: (do nothing)</li> <li><code>ppu_run.resume()</code>: (do nothing)</li> <li><code>ppu_run.resume()</code>: (do nothing)</li> </ul></li> </ul></li> </ul>  <p>So, that about wraps up what I had to say on <a href="https://github.com/kylewlacy/lochnes">Lochnes</a> and Rust generators. Of course, generators aren’t the only way to structure an emulator– I’m not even aware of other emulators that take a similar approach, so I imagine it’s in a small minority (or maybe it stands alone, who knows? Not me because I didn’t bother looking into it!) So, a few closing thoughts…</p> <h2>Generators let you do really cool things for free</h2> <p>In our example, we just called <code>run_nes.resume()</code> in a loop, but what happens when you <em>don’t</em> call it in a loop? What if, instead, you read a command on the command line, run <code>.resume()</code> a few times, and repeat? Well, you basically got an interacive debugger for free! You could write commands to print registers or memory address, step in/out/over different instructions, set breakpoints, or run until a breakpoint hits. Writing a debugger using a generator like that becomes basically free. I didn’t get around to implementing a debugger proper in Lochnes, but I had some prototype debugging code while I was… well… debugging.</p> <p>We also only ever used <code>yield;</code> with no value, but like in the fibonacci example, we could just as easily yield some value as well. In Lochnes, yielding isn’t <em>just</em> used for cycles: it’s also used to halt emulation during VBlank, and it’s used whenever controller inputs need to be read. I used an enum to indicate <em>why</em> the generator yielded, which allows the caller to do something in response. A generator is like a callback but in reverse!</p> <p>The whole reason I went with generators at all was for one goal: clarity. When I was first writing the cycle-accurate code, I was reading a text document that said things like “Cycle 1: Read opcode, increment PC”, etc. for each CPU cycle. After writing the code with generators, I felt it was very clear how each statement in the document mapped to a line of code, where each cycle was separated by a <code>yield</code>. I have a hard time imagining a clearer way of expressing the exact cycle timings of 6502 instructions in code <em>along with their behavior</em> (although I’m <em>definitely</em> not saying there’s no better way to do it)! Or, maybe said more concretely: the main differences between our naïve CPU emulation and our cycle-accurate one were some <code>yields</code> and the use of <code>.get()</code> and <code>.set()</code>. I think this is very comparable to <code>async</code>/<code>await</code>, where a big appeal is how similar using <code>await</code> looks to straight procedural code.</p> <h2>Lochnes is just fast enough (and not nearly as fast as I wanted)</h2> <p>Hopefully it’s no major surprise that Lochnes <em>isn’t</em> the fastest NES emulator avaiable. Even with my 6th-gen i7 desktop machine, each frame takes about 11ms to run, meaning it’s slightly faster than real-time. It’s actually only single-threaded, so that limits how much performance you’d get with a newer CPU (I also tried it on a 2017 MacBook Pro and got similar performance even though the desktop has more computing juice). I suspect there’s <em>a lot</em> of low-hanging fruit in optimizing Lochnes, but I suspect performance is actually a <em>downside</em> of using generators in this context.</p> <p>Under the hood, generators just get compiled to a big state machine function, where the generator value itself holds the state (the local variables in the generator as well as which yield point it’s at). I haven’t really looked into it, but I suspect Rust’s generator implementation is fairly simple, and that dealing with a <code>match</code> statement with hundereds of opcodes (and, as a result, hundereds of <code>yield</code> points) leads to code that’s too hard for LLVM to really trim down.</p> <p>Also, I have to wonder what kinds of algorithmic improvements I’m missing out on because of generators? If I went with a manual state machine approach, would it be easier to optimize by-hand?</p> <h2>My generator wishlist</h2> <ol> <li><strong>Stability!</strong> Generators are still unstable, so Lochnes can only run on nightly Rust as a result!</li> <li><strong><code>.resume()</code> should take a value.</strong> Just like how you can use <code>yield</code> with a value that gets returned by <code>.resume()</code>, you should be able to use <code>.resume()</code> with a value that gets returned by <code>yield</code>! I think this would allow for even more cool uses of generators (imagine if something like <a href="https://play.rust-lang.org/?version=nightly&amp;gist=6b53dea38d8ac5422ada10f7f264a9fe">this</a> worked)! As-is, you can kind of work around this by using interior mutability (I did this in a few places), but it would be neat as a native feature of generators.</li> <li><strong>I want <code>#[derive(...)]</code> annotations on closures.</strong> One problem with using generators for my emulator is that I can’t serialize/deserialize all the state! That means that, if I want to implement save states for Lochnes, I would need to take special care that I can get back to the same generator state after saving/loading. Generators turn into structs under-the-hood, so adding <code>#[derive(Serialize)]</code> or similar could work in theory. I’m not really sure if this would actually be practical though…</li> </ol> <h2>Useful resources for writing a NES emulator</h2> <ul> <li><a href="https://wiki.nesdev.com/">Nesdev</a> is <strong>the single greatest resource</strong> if you’re trying to write an NES emulator or a NES game. Even if the wiki doesn’t have the level-of-detail you need, it will certainly have a link to a page that does! There were a couple of times when Nesdev was actually down when I was working on Lochnes, and it basically prevented me from making any progress… anyway, here’s some pages that I found extra useful during development: <ul> <li><a href="https://wiki.nesdev.com/w/index.php/CPU_memory_map">CPU memory map</a> and <a href="https://wiki.nesdev.com/w/index.php/PPU_memory_map">PPU memory map</a></li> <li><a href="https://wiki.nesdev.com/w/index.php/Mapper#iNES_1.0_mapper_grid">iNES mappers</a> and <a href="https://wiki.nesdev.com/w/index.php/NROM#Banks">NROM banks</a></li> <li><a href="https://wiki.nesdev.com/w/index.php/INES#iNES_file_format">iNES file format</a></li> <li><a href="https://wiki.nesdev.com/w/index.php/PPU_frame_timing">PPU frame timing</a></li> <li><a href="http://nesdev.com/6502_cpu.txt">CPU cycle timing</a> (it’s not on the wiki proper– for some reason it’s just a standalone text document)</li> </ul></li> <li>Andrew Jacobs’ <a href="http://www.obelisk.me.uk/6502/">6502 reference</a> <ul> <li><a href="http://www.obelisk.me.uk/6502/reference.html">6502 instruction reference page</a>: Includes a detailed reference on the meaning of all the official 6502 opcodes</li> <li><a href="http://www.obelisk.me.uk/6502/addressing.html">6502 addressing modes</a>: Describes how each of the addressing modes works</li> </ul></li> <li><a href="https://github.com/christopherpow/nes-test-roms">This big git repo of various NES test ROMs</a>. I included this as a submodule in Lochnes to write some integration tests around all the 6502 opcodes. I used <a href="https://github.com/christopherpow/nes-test-roms/tree/master/nes_instr_test"><code>nes_instr_test</code></a> by Shay Green (a.k.a. Blargg) to start off</li> <li><a href="https://www.mesen.ca/">Mesen</a>: A really, <em>really</em> good NES emulator. It has an amazing built-in debugger (including a visual debugger for the PPU!), and is well-known for being very accurate. Also, it has rewinding and really good Netplay!</li> <li><a href="https://ghidra-sre.org/">Ghidra</a>: An open-source reverse engineering tool from the NSA, with disassembly and static analysis tools that I hear are very comparable to IDA Pro. It has out-of-the-box support for 6502 assembly, but unfortunately doesn’t include anything by default for loading NES ROMs. I wrote a very hacky and barebones Ghidra plugin for loading NES ROMs called “<a href="https://github.com/kylewlacy/GhidraNes">GhidraNes</a>”, but it doesn’t work very well yet (plus I haven’t written anything about installing or using it… which sucks becuase I’ve forgotten how to install and use it)</li> </ul> <h2>Gallery of failure</h2> <p>One of the fun things about writing an emulator is seeing the things that <em>almost</em> work… the pixellated vomit from an off-by-one error in your rendering code, or a typo in an instruction that cascades into failure. If you’ve just spent 6 hours staring at 6502 disassembly and <em>thought</em> the code should <em>finally</em> work this time, then it’s a horrifying experience. Otherwise, it’s just a fun little artifact of working on an emulator :)</p> <p><img alt="NES game rendered in a terminal..." src="https://kyle.space/posts/i-made-a-nes-emulator/gallery-1.png"> <span>(This was the first time I got rendering working in Lochnes!)</span></p> <p><img alt="Mega Man in a collapsed ruin" src="https://kyle.space/posts/i-made-a-nes-emulator/gallery-2.png"> <span>(This level looks a bit different…)</span></p> <p><img alt="Donkey Kong in a neon rave" src="https://kyle.space/posts/i-made-a-nes-emulator/gallery-3.png"> <span>(It’s actually kinda hard to get all the NES color pallete stuff right)</span></p> <p><img alt="Mega Man left his face in his other pants" src="https://kyle.space/posts/i-made-a-nes-emulator/gallery-4.png"> <span>(I accidentally made a creepypasta)</span></p> <hr> <p>Thanks to <a href="https://www.reddit.com/user/silverslayer33">/u/silverslayer33</a>, <a href="https://www.reddit.com/user/slavox">/u/slavox</a>, and <a href="https://www.reddit.com/user/BrunoValads">/u/BrunoValads</a> for corrections!</p> </div> </article></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>