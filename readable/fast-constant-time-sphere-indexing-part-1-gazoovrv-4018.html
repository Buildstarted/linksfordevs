<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Gazoo.vrv - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Gazoo.vrv - linksfor.dev(s)"/>
    <meta property="article:author" content="Don Williamson"/>
    <meta property="og:description" content="Don Williamson, Consultant Game Technology Programmer/Director of Celtoys"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://donw.io/post/sphere-indexing/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Gazoo.vrv</title>
<div class="readable">
        <h1>Gazoo.vrv</h1>
            <div>by Don Williamson</div>
            <div>Reading time: 12-16 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="http://donw.io/post/sphere-indexing/">http://donw.io/post/sphere-indexing/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section>
        <p>The problem statement is: Assuming a triangle-subdivided sphere, map any 3D point on or above it to a triangle index in constant-time, without using recursion, table lookups or complicated branching logic. Even better; make it so simple you can use it in a pixel shader. This is useful for when your playing field is on/above a sphere and you have some lookup tables you want to reference based on player/camera position.</p>

<p>This is typically an offline problem considered in map projections of planets and their skies. It allows you to map the sphere surface to a 2D domain and perform all manner of simulations on it. As such, there are a lot of complicated solutions that give great results with expensive requirements. One example is <a href="http://healpix.sourceforge.net/">HEALPix</a> but we need something far simpler.</p>

<p>A more recent development in the realtime world is <a href="https://www.irit.fr/~David.Vanderhaeghe/M2IGAI-CO/2016-g1/docs/spherical_fibonacci_mapping.pdf">Spherical Fibonacci Mapping</a>. This will map any point on the sphere to its closest Spherical Fibonacci point in constant-time but may not be fast enough.</p>

<p>The view below shows an interactive result of this post:</p>













<div>
			<div>
				<div>
					<canvas height="500" tabindex="1" width="432"></canvas>
						<p>Control Mode
							<label><span>Fly</span></label>
							<label><span>Rotate</span></label>
						</p>
					
					<p><span>Rotate: LMB, Move: WSAD</span></p>
				</div>

				
			</div>
		</div>



<p>The index of each triangle is calculated in the fragment shader using only the 3D world position and then mapped to an arbitrary colour:</p>

<pre><code><span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>int</span> tri_index <span>=</span> <span>GetTriangleIndex</span><span>(</span>ls_Position<span>)</span><span>;</span>
    tri_index <span>=</span> <span>int</span><span>(</span><span>mod</span><span>(</span><span>float</span><span>(</span>tri_index<span>)</span><span>,</span> <span>8.0</span><span>)</span><span>)</span><span>;</span>

    vec3 debug_colour<span>;</span>
    <span>if</span> <span>(</span>tri_index <span>==</span> <span>0</span><span>)</span> debug_colour <span>=</span> <span>vec3</span><span>(</span><span>0.7</span><span>,</span> <span>0.5</span><span>,</span> <span>0.2</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>tri_index <span>==</span> <span>1</span><span>)</span> debug_colour <span>=</span> <span>vec3</span><span>(</span><span>0.6</span><span>,</span> <span>0.7</span><span>,</span> <span>0.2</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>tri_index <span>==</span> <span>2</span><span>)</span> debug_colour <span>=</span> <span>vec3</span><span>(</span><span>0.2</span><span>,</span> <span>0.7</span><span>,</span> <span>0.2</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>tri_index <span>==</span> <span>3</span><span>)</span> debug_colour <span>=</span> <span>vec3</span><span>(</span><span>0.2</span><span>,</span> <span>0.7</span><span>,</span> <span>0.6</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>tri_index <span>==</span> <span>4</span><span>)</span> debug_colour <span>=</span> <span>vec3</span><span>(</span><span>0.2</span><span>,</span> <span>0.5</span><span>,</span> <span>0.7</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>tri_index <span>==</span> <span>5</span><span>)</span> debug_colour <span>=</span> <span>vec3</span><span>(</span><span>0.3</span><span>,</span> <span>0.2</span><span>,</span> <span>0.7</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>tri_index <span>==</span> <span>6</span><span>)</span> debug_colour <span>=</span> <span>vec3</span><span>(</span><span>0.7</span><span>,</span> <span>0.2</span><span>,</span> <span>0.7</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>tri_index <span>==</span> <span>7</span><span>)</span> debug_colour <span>=</span> <span>vec3</span><span>(</span><span>0.7</span><span>,</span> <span>0.2</span><span>,</span> <span>0.3</span><span>)</span><span>;</span>

    gl_FragColor <span>=</span> <span>vec4</span><span>(</span>glColour <span>+</span> debug_colour <span>*</span> <span>1.1</span><span>,</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>

<p>We will be implementing <code>GetTriangleIndex</code> with a configurable sphere subdivision count.</p>

<h5 id="subdividing-the-sphere">Subdividing the Sphere</h5>

<p>Each triangle on the sphere should be as close to equal area as possible, with minimal angular distortion for a balanced distribution. A good approximation is to start with an <a href="http://en.wikipedia.org/wiki/Octahedron">Octahedron</a> and subdivide its edges, creating 4 new triangles for each triangle, until the required density is met.</p>

<p>Three of the many ways of performing this subdivision are:</p>

<ol>
<li>Each subdivision pass splits edges at their midpoint. Project the split onto the sphere after each pass.</li>
<li>Split edges at the midpoint but project onto the sphere only once after all passes complete.</li>
<li>Split edges using a <a href="https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/">Vector Slerp</a> with no sphere projection required.</li>
</ol>

<p>The three techniques are implemented below (<em>the code to the right can be edited live</em>):</p>


<div>
			<div>
				<div>
					<canvas height="500" tabindex="1" width="432"></canvas>
						<p>Control Mode
							<label><span>Fly</span></label>
							<label><span>Rotate</span></label>
						</p>
					<p>Status: OK</p>
					<p><span>Rotate: LMB, Move: WSAD</span></p>
				</div>

				
			</div>
		</div>



<p><br>
Notable is that methods 1 and 3 result in the same subdivision, however it's the second that we'll be using. It suffers from slight contraction at the poles but is an acceptable trade-off as it allows the technique to work without any non-uniform direction remapping.</p>

<h5 id="initial-mapping-method">Initial Mapping Method</h5>

<p>Assuming a point floating above the unit sphere, the basic method is:</p>

<ol>
<li>Identify which octant of the Octahedron the point faces.</li>
<li>Cast a ray from the query point to the Octahedron origin and find an intersection point with the Octahedron face.</li>
<li>Construct a basis in the plane of the face and project the intersection point into 2D, relative to bottom-left face point.</li>
<li>Calculate triangle column and row indices the point lies within. This is made simple due to the resultant subdivision containing equilateral triangles.</li>
<li>Combine these indices with the octant index to give a unique index for the final triangle.</li>
</ol>

<p>The Octahedron looks like this with colour-coded octant indices from 0 to 8:</p>


<div>
			<div>
				<div>
					<canvas height="500" tabindex="1" width="432"></canvas>
						<p>Control Mode
							<label><span>Fly</span></label>
							<label><span>Rotate</span></label>
						</p>
					
					<p><span>Rotate: LMB, Move: WSAD</span></p><div tabindex="0"><p><span><span><span><math><semantics><mrow><mi>t</mi><mi>r</mi><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">tri_1</annotation></semantics></math></span></span></span></p><p><span><span><span><math><semantics><mrow><mi>t</mi><mi>r</mi><msub><mi>i</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">tri_4</annotation></semantics></math></span></span></span></p><p><span><span><span><math><semantics><mrow><mi>t</mi><mi>r</mi><msub><mi>i</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">tri_5</annotation></semantics></math></span></span></span></p><p><span><span><span><math><semantics><mrow><mi>t</mi><mi>r</mi><msub><mi>i</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">tri_6</annotation></semantics></math></span></span></span></p></div>
				</div>

				
			</div>
		</div>



<p>Finding the octant index from a unit sphere point is a simple case of inspecting the signs of its individual elements, as this point is also a direction from the octahedron:</p>

<pre><code>ivec3 side<span>;</span>
side<span>.</span>x <span>=</span> P<span>.</span>x <span>&gt;=</span> <span>0.0</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>;</span>
side<span>.</span>y <span>=</span> P<span>.</span>y <span>&gt;=</span> <span>0.0</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>;</span>
side<span>.</span>z <span>=</span> P<span>.</span>z <span>&gt;=</span> <span>0.0</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>;</span>
<span>int</span> octant_index <span>=</span> side<span>.</span>x <span>+</span> side<span>.</span>y <span>*</span> <span>2</span> <span>+</span> side<span>.</span>z <span>*</span> <span>4</span><span>;</span>
</code></pre>

<p>Given that the backward raycast undoes the final projection of any subdivided points on to the sphere, we end up back on a uniformly subdivided plane of the octahedron face. This can be visualised:</p>


<div>
			<div>
				<div>
					<canvas height="500" tabindex="1" width="432"></canvas>
						<p>Control Mode
							<label><span>Fly</span></label>
							<label><span>Rotate</span></label>
						</p>
					
					<p><span>Rotate: LMB, Move: WSAD</span></p>
				</div>

				
			</div>
		</div>



<p>In order to intersect the ray with the face plane, the normal and a point on the plane need to be determined. The face normal is derived easily from face sidedness:</p>

<pre><code>vec3 face_dir <span>=</span> <span>vec3</span><span>(</span>side<span>)</span> <span>*</span> <span>2.0</span> <span>-</span> <span>1.0</span><span>;</span>
vec3 plane_normal <span>=</span> <span>normalize</span><span>(</span>face_dir<span>)</span><span>;</span>
</code></pre>

<p>The calculation of <code>octant_index</code> can be further simplified by moving the multiplcations to the side select and accounting for scale in the <code>face_dir</code> calculation:</p>

<pre><code>
ivec3 side<span>;</span>
side<span>.</span>x <span>=</span> P<span>.</span>x <span>&gt;=</span> <span>0.0</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>;</span>
side<span>.</span>y <span>=</span> P<span>.</span>y <span>&gt;=</span> <span>0.0</span> <span>?</span> <span>2</span> <span>:</span> <span>0</span><span>;</span>
side<span>.</span>z <span>=</span> P<span>.</span>z <span>&gt;=</span> <span>0.0</span> <span>?</span> <span>4</span> <span>:</span> <span>0</span><span>;</span>
<span>int</span> octant_index <span>=</span> side<span>.</span>x <span>+</span> side<span>.</span>y <span>+</span> side<span>.</span>z<span>;</span>


vec3 face_dir <span>=</span> <span>vec3</span><span>(</span>side<span>)</span> <span>*</span> <span>vec3</span><span>(</span><span>2.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.5</span><span>)</span> <span>-</span> <span>1.0</span><span>;</span>
</code></pre>

<p>A point in the plane can be taken from one of the 3 triangle vertices in this octant. We're going to need all 3 vertices later in the function so we might as well calcuate them up front here. As we're on the unit octahedron, these points come simply from the face direction as they're already in the range <span><span><span><span><math><semantics><mrow><mo>[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[-1, 1]</annotation></semantics></math></span></span></span></span>:</p>

<pre><code>


vec3 v0 <span>=</span> <span>vec3</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> face_dir<span>.</span>z<span>)</span><span>;</span>
vec3 v1 <span>=</span> <span>vec3</span><span>(</span>face_dir<span>.</span>x<span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>


vec3 v2 <span>=</span> <span>vec3</span><span>(</span><span>0</span><span>,</span> face_dir<span>.</span>y<span>,</span> <span>0</span><span>)</span><span>;</span>
</code></pre>

<p>The intersection point <span><span><span><span><math><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span></span></span></span> on the octahedron face can then be calculated. Start with the equations of a ray and plane:</p>

<p><span><span><span><span><span><math><semantics><mrow><mi>R</mi><mo>=</mo><mi>P</mi><mo>+</mo><mover accent="true"><mrow><mi>D</mi></mrow><mo>⃗</mo></mover><mi>t</mi></mrow><annotation encoding="application/x-tex">R = P + \vec{D}t</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>R</mi><mo>)</mo><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(V - R).\vec{N} = 0</annotation></semantics></math></span></span></span></span></span></p>

<p>where <span><span><span><span><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span></span></span></span> is an arbitrary point in 3D, <span><span><span><span><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span></span></span></span> is the ray origin, <span><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>D</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{D}</annotation></semantics></math></span></span></span></span> is the ray direction, <span><span><span><span><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span></span></span></span> is distance along the ray, <span><span><span><span><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span></span></span></span> is a point on the plane and <span><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{N}</annotation></semantics></math></span></span></span></span> is the plane normal. Substitute <span><span><span><span><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span></span></span></span> in the plane equation with the ray and make <span><span><span><span><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span></span></span></span> the subject:</p>

<p><span><span><span><span><span><math><semantics><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>P</mi><mo>−</mo><mover accent="true"><mrow><mi>D</mi></mrow><mo>⃗</mo></mover><mi>t</mi><mo>)</mo><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(V - P - \vec{D}t).\vec{N} = 0</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>P</mi><mo>)</mo><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover><mo>=</mo><mover accent="true"><mrow><mi>D</mi></mrow><mo>⃗</mo></mover><mi>t</mi><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">(V - P).\vec{N} = \vec{D}t.\vec{N}</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>P</mi><mo>)</mo><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow><mrow><mover accent="true"><mrow><mi>D</mi></mrow><mo>⃗</mo></mover><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow></mfrac></mrow><annotation encoding="application/x-tex">t =\frac{(V - P).\vec{N}}{\vec{D}.\vec{N}}</annotation></semantics></math></span></span></span></span></span></p>

<p>This can be put back into the ray equation to solve for <span><span><span><span><math><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span></span></span></span>:</p>

<p><span><span><span><span><span><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>P</mi><mo>+</mo><mover accent="true"><mrow><mi>D</mi></mrow><mo>⃗</mo></mover><mi>t</mi></mrow><annotation encoding="application/x-tex">I = P + \vec{D}t</annotation></semantics></math></span></span></span></span></span></p>

<p>As the ray direction is toward the octahedron origin, it's equal to the normalised <span><span><span><span><math><semantics><mrow><mo>−</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">-P</annotation></semantics></math></span></span></span></span>, so:</p>

<p><span><span><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>P</mi></mrow><mo>^</mo></mover><mo>=</mo><mfrac><mrow><mi>P</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>P</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\hat{P} = \frac{P}{|P|}</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>P</mi><mo>)</mo><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow><mrow><mo>−</mo><mover accent="true"><mrow><mi>P</mi></mrow><mo>^</mo></mover><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow></mfrac></mrow><annotation encoding="application/x-tex">t =\frac{(V - P).\vec{N}}{-\hat{P}.\vec{N}}</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>P</mi><mo>−</mo><mover accent="true"><mrow><mi>P</mi></mrow><mo>^</mo></mover><mi>t</mi></mrow><annotation encoding="application/x-tex">I = P - \hat{P}t</annotation></semantics></math></span></span></span></span></span></p>

<p>This can be simplified a little by substituting for <span><span><span><span><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span></span></span></span>:</p>

<p><span><span><span><span><span><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>P</mi><mo>−</mo><mover accent="true"><mrow><mi>P</mi></mrow><mo>^</mo></mover><mrow><mfrac><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>P</mi><mo>)</mo><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow><mrow><mo>−</mo><mover accent="true"><mrow><mi>P</mi></mrow><mo>^</mo></mover><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow></mfrac></mrow></mrow><annotation encoding="application/x-tex">I = P - \hat{P} { \frac{(V - P).\vec{N}}{ -\hat{P}.\vec{N} } }</annotation></semantics></math></span></span></span></span></span></p>

<p>and substituting for <span><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>P</mi></mrow><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{P}</annotation></semantics></math></span></span></span></span> to see that the normalisation cancels and is not needed:</p>

<p><span><span><span><span><span><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>P</mi><mo>−</mo><mfrac><mrow><mi>P</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>P</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mrow><mfrac><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>P</mi><mo>)</mo><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow><mrow><mo>−</mo><mfrac><mrow><mi>P</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>P</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow></mfrac></mrow></mrow><annotation encoding="application/x-tex">I = P - \frac{P}{|P|} { \frac{(V - P).\vec{N}}{ -\frac{P}{|P|}.\vec{N} } }</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>P</mi><mo>−</mo><mfrac><mrow><mi>P</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">∣</mi><mi>P</mi><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>P</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mrow><mfrac><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>P</mi><mo>)</mo><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow><mrow><mo>−</mo><mi>P</mi><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow></mfrac></mrow></mrow><annotation encoding="application/x-tex">I = P - \frac{P.|P|}{|P|} { \frac{(V - P).\vec{N}}{ -P.\vec{N} } }</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>P</mi><mo>−</mo><mi>P</mi><mrow><mfrac><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>P</mi><mo>)</mo><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow><mrow><mo>−</mo><mi>P</mi><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow></mfrac></mrow></mrow><annotation encoding="application/x-tex">I = P - P { \frac{(V - P).\vec{N}}{ -P.\vec{N} } }</annotation></semantics></math></span></span></span></span></span></p>

<p>The negation of the numerator/denominator also cancels:</p>

<p><span><span><span><span><span><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>P</mi><mo>+</mo><mi>P</mi><mrow><mfrac><mrow><mo>(</mo><mi>V</mi><mo>−</mo><mi>P</mi><mo>)</mo><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow><mrow><mi>P</mi><mi mathvariant="normal">.</mi><mover accent="true"><mrow><mi>N</mi></mrow><mo>⃗</mo></mover></mrow></mfrac></mrow></mrow><annotation encoding="application/x-tex">I = P + P { \frac{(V - P).\vec{N}}{ P.\vec{N} } }</annotation></semantics></math></span></span></span></span></span></p>

<p>leading to the code:</p>

<pre><code><span>float</span> d <span>=</span> <span>dot</span><span>(</span>v0 <span>-</span> P<span>,</span> plane_normal<span>)</span> <span>/</span> <span>dot</span><span>(</span>P<span>,</span> plane_normal<span>)</span><span>;</span>
vec3 point_on_plane <span>=</span> P <span>+</span> P <span>*</span> d<span>;</span>
</code></pre>

<p>As a bonus the calculation of the plane normal using the face direction length similarly factors out. This allows use of the raw face direction instead of having to normalise it as already done above:</p>

<pre><code><span>float</span> d <span>=</span> <span>dot</span><span>(</span>v0 <span>-</span> P<span>,</span> face_direction<span>)</span> <span>/</span> <span>dot</span><span>(</span>P<span>,</span> face_direction<span>)</span><span>;</span>
vec3 point_on_plane <span>=</span> P <span>+</span> P <span>*</span> d<span>;</span>
</code></pre>

<p>This point then needs to be projected to 2D on the plane, requiring a completed basis. The red and green unit vectors below are the vectors required, as the blue vector is the plane normal. These vectors must originate from one of the tetrahedron vertices for the 2D projection co-ordinates to remain positive:</p>


<div>
			<div>
				<div>
					<canvas height="500" tabindex="1" width="432"></canvas>
						<p>Control Mode
							<label><span>Fly</span></label>
							<label><span>Rotate</span></label>
						</p>
					
					<p><span>Rotate: LMB, Move: WSAD</span></p><div tabindex="0"><p><span><span><span><math><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span></span></span></p><p><span><span><span><math><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span></span></span></p><p><span><span><span><math><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span></span></span></p><p><span><span><span><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span></span></span></p><p><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>X</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{X}</annotation></semantics></math></span></span></span></p><p><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>Y</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{Y}</annotation></semantics></math></span></span></span></p></div>
				</div>

				
			</div>
		</div>



<p>Getting the basis vectors can be achieved starting with the midpoint of the meridian edge, <span><span><span><span><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span></span></span></span>, as a temporary origin and then shifting them to <span><span><span><span><math><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span></span></span></span>:</p>

<p><span><span><span><span><span><math><semantics><mrow><mi>O</mi><mo>=</mo><mo>(</mo><msub><mi>v</mi><mn>0</mn></msub><mo>+</mo><msub><mi>v</mi><mn>1</mn></msub><mo>)</mo><mo>∗</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">O = (v_0 + v_1) * 0.5</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>X</mi></mrow><mo>⃗</mo></mover><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>v</mi><mn>1</mn></msub><mo>−</mo><mi>O</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vec{X} = |v_1 - O|</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>Y</mi></mrow><mo>⃗</mo></mover><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>v</mi><mn>2</mn></msub><mo>−</mo><mi>O</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\vec{Y} = |v_2 - O|</annotation></semantics></math></span></span></span></span></span></p>

<pre><code>
vec3 O <span>=</span> <span>(</span>v0 <span>+</span> v1<span>)</span> <span>*</span> <span>0.5</span><span>;</span>
vec3 X <span>=</span> <span>normalize</span><span>(</span>v1 <span>-</span> O<span>)</span><span>;</span>
vec3 Y <span>=</span> <span>normalize</span><span>(</span>v2 <span>-</span> O<span>)</span><span>;</span>
</code></pre>

<p>This requires two normalisations that can be avoided by taking advantage of the fact that the octahedron is circumscribed by the unit sphere. All octahedron side lengths are thus equal to the hypotenuse of a right-triangle with side lengths of <span><span><span><span><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span></span></span></span>.</p>


<div>
			<div>
				<div>
					<canvas height="500" tabindex="1" width="432"></canvas>
						<p>Control Mode
							<label><span>Fly</span></label>
							<label><span>Rotate</span></label>
						</p>
					
					<p><span>Rotate: LMB, Move: WSAD</span></p>
				</div>

				
			</div>
		</div>



<p><span><span><span><span><span><math><semantics><mrow><msub><mi>l</mi><mi>m</mi></msub><mo>=</mo><msqrt><mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">l_m = \sqrt{1^2 + 1^2}</annotation></semantics></math></span></span></span></span></span></p>

<p>The vector <span><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>X</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{X}</annotation></semantics></math></span></span></span></span> is half this size since it's calculated using the edge midpoint as its origin:</p>

<p><span><span><span><span><span><math><semantics><mrow><msub><mi>l</mi><mi>x</mi></msub><mo>=</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>5</mn><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow><annotation encoding="application/x-tex">l_x = 0.5 \sqrt{2}</annotation></semantics></math></span></span></span></span></span></p>

<p>So just divide by this length to normalise <span><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>X</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{X}</annotation></semantics></math></span></span></span></span>. Or just use a multiply of the inverse:</p>

<p><span><span><span><span><span><math><semantics><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><msub><mi>l</mi><mi>x</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn></mrow><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{l_x} = \frac{2}{\sqrt{2}}</annotation></semantics></math></span></span></span></span></span></p>

<p>The length of <span><span><span><span><math><semantics><mrow><mover accent="true"><mrow><mi>Y</mi></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{Y}</annotation></semantics></math></span></span></span></span> is then equal to the height of the initial octahedron triangle:</p>

<p><span><span><span><span><span><math><semantics><mrow><msubsup><mi>l</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><msubsup><mi>l</mi><mi>y</mi><mn>2</mn></msubsup><mo>+</mo><msup><msqrt><mrow><mn>2</mn></mrow></msqrt><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">l_x^2 = l_y^2 + \sqrt{2}^2</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><msup><msqrt><mrow><mn>2</mn></mrow></msqrt><mn>2</mn></msup><mo>=</mo><msubsup><mi>l</mi><mi>y</mi><mn>2</mn></msubsup><mo>+</mo><mo>(</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>5</mn><msqrt><mrow><mn>2</mn></mrow></msqrt><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sqrt{2}^2 = l_y^2 + (0.5 \sqrt{2})^2</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mn>2</mn><mo>=</mo><msubsup><mi>l</mi><mi>y</mi><mn>2</mn></msubsup><mo>+</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">2 = l_y^2 + 0.5</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><msub><mi>l</mi><mi>y</mi></msub><mo>=</mo><msqrt><mrow><mn>1</mn><mi mathvariant="normal">.</mi><mn>5</mn></mrow></msqrt></mrow><annotation encoding="application/x-tex">l_y = \sqrt{1.5}</annotation></semantics></math></span></span></span></span></span></p>

<p><span><span><span><span><span><math><semantics><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><msub><mi>l</mi><mi>y</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><msqrt><mrow><mn>1</mn><mi mathvariant="normal">.</mi><mn>5</mn></mrow></msqrt></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{l_y} = \frac{1}{\sqrt{1.5}}</annotation></semantics></math></span></span></span></span></span></p>

<p>This neatly reduces to:</p>

<pre><code>
<span>float</span> inv_oct_side_len <span>=</span> <span>2.0</span> <span>/</span> <span>sqrt</span><span>(</span><span>2.0</span><span>)</span><span>;</span>


<span>float</span> inv_oct_tri_height <span>=</span> <span>1.0</span> <span>/</span> <span>sqrt</span><span>(</span><span>1.5</span><span>)</span><span>;</span>


vec3 O <span>=</span> <span>(</span>v0 <span>+</span> v1<span>)</span> <span>*</span> <span>0.5</span><span>;</span>
vec3 X <span>=</span> <span>(</span>v1 <span>-</span> O<span>)</span> <span>*</span> inv_oct_side_len<span>;</span>
vec3 Y <span>=</span> <span>(</span>v2 <span>-</span> O<span>)</span> <span>*</span> inv_oct_tri_height<span>;</span>
</code></pre>

<p>The constructed basis can now be used to project onto the plane, relative to the intended origin <span><span><span><span><math><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span></span></span></span>:</p>

<pre><code>
vec2 uv<span>;</span>
uv<span>.</span>x <span>=</span> <span>dot</span><span>(</span>point_on_plane <span>-</span> v0<span>,</span> X<span>)</span><span>;</span>
uv<span>.</span>y <span>=</span> <span>dot</span><span>(</span>point_on_plane <span>-</span> v0<span>,</span> Y<span>)</span><span>;</span>
</code></pre>

<p><code>uv</code> gives us an effective distance of the point along each axis.</p>

<p>The penultimate step is to map this 2D position to a unique triangle index on the face:</p>


<div>
			<div>
				<div>
					<canvas height="500" tabindex="1" width="432"></canvas>
						<p>Control Mode
							<label><span>Fly</span></label>
							<label><span>Rotate</span></label>
						</p>
					
					<p><span>Rotate: LMB, Move: WSAD</span></p>
				</div>

				
			</div>
		</div>



<p>There are 8 rows in the above face and 8 triangles with their base touching the bottom edge. Given a subdivision depth <span><span><span><span><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span></span></span></span>, the row index is simply:</p>

<p><span><span><span><span><span><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mo>=</mo><mrow><mo fence="true">⌊</mo><mrow><mfrac><mrow><msub><mi>l</mi><mi>y</mi></msub></mrow><mrow><msup><mn>2</mn><mi>d</mi></msup></mrow></mfrac></mrow><mo fence="true">⌋</mo></mrow></mrow><annotation encoding="application/x-tex">row = \left \lfloor{\frac{l_y}{2^d}}\right \rfloor</annotation></semantics></math></span></span></span></span></span></p>

<p>where <span><span><span><span><math><semantics><mrow><mi>d</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d=0</annotation></semantics></math></span></span></span></span> represents no subdivision. Calculating the triangle index within a row is slightly more involved. The method works by splitting each triangle in half and mapping rectangles over the top:</p>


<div>
			<div>
				<div>
					<canvas height="500" tabindex="1" width="432"></canvas>
						<p>Control Mode
							<label><span>Fly</span></label>
							<label><span>Rotate</span></label>
						</p>
					
					<p><span>Rotate: LMB, Move: WSAD</span></p>
				</div>

				
			</div>
		</div>



<p>Treat the rectangles in pairs where the first triangle has a rising diagonal (left-to-right) and the second triangle has a falling diagonal. Find where the point is within the rectangle it falls upon (<span><span><span><span><math><semantics><mrow><mo>{</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>∣</mo><mn>0</mn><mo>≤</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>&lt;</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{u,v \mid 0 \le u,v &lt; 1 \}</annotation></semantics></math></span></span></span></span>) and the following rules determine which half of the sub-triangle the point is in:</p>

<ul>
<li>For even rectangles, if <span><span><span><span><math><semantics><mrow><mi>v</mi><mo>−</mo><mi>u</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v - u &gt; 0</annotation></semantics></math></span></span></span></span> the point is in the top sub-triangle.</li>
<li>For odd triangles, if <span><span><span><span><math><semantics><mrow><mi>u</mi><mo>+</mo><mi>v</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">u + v &lt; 1</annotation></semantics></math></span></span></span></span> the point is in the bottom sub-triangle.</li>
</ul>

<p>You can then use that decision to shift the rectangle index down by one to correct to the triangle index within the row:</p>

<pre><code>
<span>float</span> sub_tri_edge_len <span>=</span> inv_oct_side_len <span>/</span> <span>16</span><span>;</span>
uv<span>.</span>x <span>=</span> uv<span>.</span>x <span>/</span> sub_tri_edge_len<span>;</span>


uv<span>.</span>y <span>=</span> <span>(</span>uv<span>.</span>y <span>*</span> inv_oct_tri_height<span>)</span> <span>*</span> <span>8</span><span>;</span>


<span>int</span> x <span>=</span> <span>int</span><span>(</span>uv<span>.</span>x<span>)</span><span>;</span>
<span>int</span> y <span>=</span> <span>int</span><span>(</span>uv<span>.</span>y<span>)</span><span>;</span>


<span>float</span> u <span>=</span> uv<span>.</span>x <span>-</span> <span>float</span><span>(</span>x<span>)</span><span>;</span>
<span>float</span> v <span>=</span> uv<span>.</span>y <span>-</span> <span>float</span><span>(</span>y<span>)</span><span>;</span>




<span>if</span> <span>(</span><span>and</span><span>(</span>x<span>,</span> <span>1</span><span>)</span> <span>!=</span> <span>and</span><span>(</span>y<span>,</span> <span>1</span><span>)</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span>u <span>+</span> v <span>&lt;</span> <span>1.0</span><span>)</span>
        x<span>--</span><span>;</span>
<span>}</span>
<span>else</span>
<span>{</span>
    <span>if</span> <span>(</span>v <span>-</span> u <span>&gt;</span> <span>0.0</span><span>)</span>
        x<span>--</span><span>;</span>
<span>}</span>
</code></pre>

<p>The <code>and</code> function here is a terrible little workaround function for GLSL in WebGL 1 that can't do bitwise integer arithmetic. It's available in the final example below.</p>

<p>The triangle row and index now need to be turned into a linear triangle index within the octant and that's trivially achieved by treating the octant as a grid and ignoring indices outside the octant triangle. The grid width is a function of the subdivision depth, noting that one less triangle than rectangles can be stored:</p>

<p><span><span><span><span><span><math><semantics><mrow><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>w</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mo>=</mo><msup><mn>2</mn><mi>d</mi></msup><mo>∗</mo><mn>2</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gridwidth = 2^d * 2 - 1</annotation></semantics></math></span></span></span></span></span></p>

<p>Which can then be combined with the octant index to give the final linear index:</p>

<pre><code>








<span>return</span> octant_index <span>*</span> <span>15</span> <span>*</span> <span>15</span> <span>+</span> y <span>*</span> <span>15</span> <span>+</span> x<span>;</span>
</code></pre>

<p>The resultant code can be seen and edited below. Setting <code>depth</code> to something high like 6 highlights the difference in projected area between big triangles in the middle of an octant and and small triangles on the edge.</p>


<div>
			<div>
				<div>
					<canvas height="500" tabindex="1" width="432"></canvas>
						<p>Control Mode
							<label><span>Fly</span></label>
							<label><span>Rotate</span></label>
						</p>
					<p>Status: OK</p>
					<p><span>Rotate: LMB, Move: WSAD</span></p>
				</div>

				
			</div>
		</div>



<p>While this code is pretty fast (pixel-shader fast, even) it can be optimised much more. These optimisations will be covered in a further post.</p>

<p>Thanks to <a href="https://twitter.com/rompa69">Mark Wayland</a>, <a href="https://twitter.com/sopyer">Mykhailo Parfeniuk</a>, <a href="https://twitter.com/raegnar">Randall Rauwendaal</a>, <a href="https://twitter.com/mike_ducker">Mike Ducker</a> and <a href="https://twitter.com/questorInter">Kai Jouran</a> for optimisations, fixes, suggestions and proof-reading.</p>

<p>The code for this <a href="https://github.com/dwilliamson/donw.io">website</a> and <a href="https://github.com/dwilliamson/donw.io/blob/master/static/js/sandbox.js">sandbox</a> is open-source on Github. I will be hacking on the sandbox code over the next few weeks to try and simplify things a little; the result of which may make its way to its own repo.</p>

    </section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>