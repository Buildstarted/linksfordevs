<!DOCTYPE html>
<html lang="en">
<head>
    <title>
pre.uumu/README.md at master &#xB7; uucidl/pre.uumu &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>pre.uumu/README.md at master · uucidl/pre.uumu · GitHub</h1><div><div id="" class="markdown-body entry-content p-3 p-md-6"><p>Per Vognsen designed the <a href="/uucidl/pre.uumu/blob/master/xxxx_mu.h">Mu API</a> as an alternative to libraries like SDL,
SML. I find myself agreeing with many of its design decisions.</p><p>He documented it at:</p><p>He also responded with another iteration called Noir: <a href="https://github.com/pervognsen/bitwise/blob/master/noir/noir/noir.ion">https://github.com/pervognsen/bitwise/blob/master/noir/noir/noir.ion</a></p><h2><a id="user-content-goals-and-pinciples" class="anchor" aria-hidden="true" href="#goals-and-pinciples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Goals and pinciples</h2><p>His goals:</p><ul><li><p>minimal platform layer for multimedia apps (in terms of binary/source size)</p></li><li><p>not industrial-strengh, but excellent for small apps</p></li><li><p>experiment with API design:</p><ul><li>good, ritual-free, defaults</li><li>eschews the many granular calls these libraries tend to have to
set it up or get information from it</li><li>instead, provide data in/out through datastructure and a minimal set of functions</li><li>dialogue between the app and the library as if the library was a
resumable coroutine, to minimize callbacks, which disrupt normal
code flow</li></ul></li><li><p>extension API with media file loading (image, sound, video)</p></li></ul><p>This is achieved with a global datastructure, whose entries serve as
much as possible as both input and output.</p><p>Precompute redundant data that is most often useful to users, rather
than doing it lazilly and potentially too often. Even if that's
increasing the surface area of the API.</p><p>Provide state of controls rather than exposing an event queue to its
users, since since multimedia applications would anyway have to
sample/refresh at a high enough rate anyway.</p><p>In cases where naïve state-capture would lose events, such as for text,
the API prepares buffers of prepared data representing the aggregate
input between two frames.</p><p>Compromises:</p><p>As of stream #2, audio has been implemented via a callback, pulling
samples regularly from the high priority audio thread.</p><h2><a id="user-content-is-this-an-alternative-to-sdl" class="anchor" aria-hidden="true" href="#is-this-an-alternative-to-sdl"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Is this an alternative to SDL?</h2><p>You could see it like that, however this idea is more useful as a seed
for your own application's platform layer. It's a reusable idea first,
and an implementation second.</p><p>Take it, add more things to the Mu structure as needed by your
application.</p><h2><a id="user-content-experiments-to-try" class="anchor" aria-hidden="true" href="#experiments-to-try"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Experiments to try:</h2><ul><li>The input/output struct is plain old data (if you except the
platform specific handles) ; which means it should be trivial to
record sequence of values to replay back the application eventually.</li></ul><h2><a id="user-content-some-other-personal-comments" class="anchor" aria-hidden="true" href="#some-other-personal-comments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Some other personal comments:</h2><p>A push API for audio is certainly possible, however I personally think
if it make sense, it should prevent gaps in audio as the result of a
late frame. It does simplify the usual, simple cases because it
removes the need for thread-safe code.</p><p>Another comment I can make is that the choice of int16_t for audio
samples, while convenient for mixing in samples coming from audio
files, make synthesis cases less natural. It's easier and less error
prone to use float within the 0..1 interval as a generic
representation of audio samples.</p><p>@todo @idea in the same spirit of the redundant converted time values
found in the main part of the api, it would be logical to precompute
the number of frames of interleaved samples and put it in the
audiobuffer structure</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>