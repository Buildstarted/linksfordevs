<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Optimizing string.Count all the way from LINQ to hardware accelerated vectorized instructions - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Optimizing string.Count all the way from LINQ to hardware accelerated vectorized instructions - linksfor.dev(s)"/>
    <meta property="article:author" content="Sergio Pedri"/>
    <meta property="og:description" content="A technical deep dive into SIMD accelerated C# APIs to speedup simple loop iterations"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@SergioPedri/optimizing-string-count-all-the-way-from-linq-to-hardware-accelerated-vectorized-instructions-186816010ad9?sk=6c6b238e37671afe22c42af804092ab6"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Optimizing string.Count all the way from LINQ to hardware accelerated vectorized instructions</title>
<div class="readable">
        <h1>Optimizing string.Count all the way from LINQ to hardware accelerated vectorized instructions</h1>
            <div>by Sergio Pedri</div>
            <div>Reading time: 8-10 minutes</div>
        <div>Posted here: 09 Jan 2020</div>
        <p><a href="https://medium.com/@SergioPedri/optimizing-string-count-all-the-way-from-linq-to-hardware-accelerated-vectorized-instructions-186816010ad9?sk=6c6b238e37671afe22c42af804092ab6">https://medium.com/@SergioPedri/optimizing-string-count-all-the-way-from-linq-to-hardware-accelerated-vectorized-instructions-186816010ad9?sk=6c6b238e37671afe22c42af804092ab6</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@SergioPedri?source=post_page-----186816010ad9----------------------"><img alt="Sergio Pedri" src="https://miro.medium.com/fit/c/48/48/2*4A0Ew4nTA1aRMrwd3-ciZg.png" width="48" height="48"></a></p></div></div></div></div></div></div><div><div><div><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*AeOmNaYA1IURQ1mPcWdmWA.png?q=20" width="1400" height="700" role="presentation"></p><p><img width="1400" height="700" role="presentation" src="https://miro.medium.com/max/1400/1*AeOmNaYA1IURQ1mPcWdmWA.png"></p></div></div></div></div><figcaption data-selectable-paragraph="">C# language — background image by Sai Kiran Anagani on Unsplash</figcaption></figure></div></div></div><div><div><p id="e388" data-selectable-paragraph=""><span>I</span> have always been very interested in code optimizations, even when achieving the best possible execution time is not really necessary — I consider trying to improve my code and squeezing out as much performance as possible to be both fun and a useful learning exercise.</p><p id="5080" data-selectable-paragraph="">I have recently rewritten a simple method to count the number of occurrences of a given <strong>char</strong> into a <strong>string</strong>, and in doing so I also had a chance to experiment with vectorized instructions, which is something that I had always considered fascinating but that I had never taken the time to read up on well enough to actually use them in my own code.</p><p id="3b6c" data-selectable-paragraph="">This blog post is a brief introduction to the world of vectorized instructions in C#, and it is meant to be accessible for developers that have never really used them before on their own, just like I had not until today. The code that is included in this post is by no means anything extremely advanced — I’m just sharing the steps I personally took in optimizing this specific algorithm, and what I learnt along the way.</p><blockquote><p>If you happen to have never spent much time optimizing code, I hope this post will make you even a tiny bit more interested in this topic!</p></blockquote></div></div></section><hr><section><div><div><p id="15c1" data-selectable-paragraph=""><span>T</span>he first implementation that everyone will probably come up with when implementing a similar algorithm (myself included) uses the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.count?view=netcore-3.1#System_Linq_Enumerable_Count__1_System_Collections_Generic_IEnumerable___0__System_Func___0_System_Boolean__" target="_blank" rel="noopener nofollow"><strong>Count&lt;T&gt;(IEnumerable&lt;T&gt;, Func&lt;T, bool&gt;)</strong></a> API from the <strong>System.Linq</strong> namespace. This API is very helpful as it provides an easy way to solve this problem, which is extremely compact to write and still reasonably fast. We just need to invoke this method with a function that checks each character in our <strong>string</strong> against the one we are looking for:</p><figure><div></div></figure><p id="32fb" data-selectable-paragraph="">This works just fine and has the big advantage of being virtually impossible to get wrong — once this method is implemented you likely will never find a bug coming from this piece of code, which is certainly a plus when working with larger projects. But, there are two major drawbacks:</p><ul><li id="93f4" data-selectable-paragraph=""><strong>Memory allocation</strong>: the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.func-2?view=netcore-3.1" target="_blank" rel="noopener nofollow"><strong>Func&lt;T, TResult&gt;</strong></a> instance we’re using in this method is generating a closure, since it’s capturing our parameter <strong>char c</strong> from the caller method. If you’re not familiar with closures, you can read up more on them in my other blog post, <a target="_blank" rel="noopener" href="https://medium.com/@SergioPedri/optimizing-reflection-with-dynamic-code-generation-6e15cef4b1a2">here</a>. Suffice to say, it involves the runtime allocating an <strong>object</strong> every time we use this method, which causes unnecessary memory usage and <a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals" target="_blank" rel="noopener nofollow">GC pressure</a>. Additionally, we’re also allocating memory for the <strong>string</strong> iterator that the LINQ method is working on.</li><li id="ee3c" data-selectable-paragraph=""><strong>Slow execution</strong>: the LINQ method we’re using goes over all the characters through the iterator, which is much slower than doing the same with a traditional <strong>for</strong> loop. In this case we’re also invoking our <strong>Func&lt;T, TResult&gt;</strong> delegate for each individual character, which again has a higher overhead compared to simply comparing each character directly.</li></ul></div></div></section><hr><section><div><div><p id="c80f" data-selectable-paragraph=""><span>L</span>et’s leave the user friendly land of functional programming and go back to a classic, imperative style implementation of our algorithm:</p><figure><div></div></figure><p id="4414" data-selectable-paragraph="">First, there is an interesting optimization that the C# compiler is doing for us: the <strong>string</strong> type (together with <strong>T[]</strong> arrays) is treated in a special way when used in a <strong>foreach</strong> loop, and results in that code being transformed into a classic <strong>for</strong> loop. This has the advantage of being easier to write for us, since we don’t have to deal with manual indexing of characters in the <strong>string</strong>, while still having exactly the same performance as a classic loop. Plus, since the compiler knows we are iterating exactly within the bounds of the input <strong>string</strong>, it will emit a nicely optimized assembly code with no unnecessary <a href="https://en.wikipedia.org/wiki/Bounds_checking" target="_blank" rel="noopener nofollow">bounds checks</a>. This implementation is much faster than the LINQ version, and with it the memory allocation problem has already been solved entirely.</p></div></div></section><hr><section><div><div><p id="37c2" data-selectable-paragraph=""><span>T</span>he previous implementation has one bottleneck: each loop iteration has one <a href="https://en.wikipedia.org/wiki/Branch_(computer_science)" target="_blank" rel="noopener nofollow">conditional branch</a>, specifically that <strong>if</strong> statement on line 7. Branches should always be kept at a minimum in high performance code, and for a more in-depth explanation of the rationale behind this I highly suggest reading up this <a href="https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array" target="_blank" rel="noopener nofollow">StackOverflow question and answer</a>. To sum it up, the CPU will try to anticipate what the result of a branch instruction will be, and every time it gets it wrong there will be a relatively high performance penalty. Luckily, in this case we can just completely remove that branch by leveraging how <strong>bool</strong> variables are stored in memory during execution.</p><p id="8aa5" data-selectable-paragraph=""><em>From this point on, the snippets will make use of </em><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref" target="_blank" rel="noopener nofollow"><strong><em>ref</em></strong></a><em> variables and methods from the </em><a href="https://mattwarren.org/2016/09/14/Subverting-.NET-Type-Safety-with-System.Runtime.CompilerServices.Unsafe/" target="_blank" rel="noopener nofollow"><strong><em>Unsafe</em></strong></a><em> and </em><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal?view=netcore-3.1" target="_blank" rel="noopener nofollow"><strong><em>MemoryMarshal</em></strong></a><em> class. I have added detailed comments over every single line to make it easy to follow, but if you want to go more in depth on this feel free to read up </em><a target="_blank" rel="noopener" href="https://medium.com/@SergioPedri/optimizing-reflection-with-dynamic-code-generation-6e15cef4b1a2"><em>my previous blog post</em></a><em> or the official MS docs.</em></p><figure><div></div></figure><p id="7c79" data-selectable-paragraph="">This is another welcome improvement, but we are not quite there yet. This is about as fast as we can get without delving into more advanced techniques. And it is now time to do just that, by adding vectorization.</p><p id="d884" data-selectable-paragraph=""><em>Some of you might correctly point out that this latest implementation might still be improved by adding </em><a href="https://en.wikipedia.org/wiki/Loop_unrolling" target="_blank" rel="noopener nofollow"><em>loop unrolling</em></a><em>. That is certainly true, but for the purposes of this post we will leave that part out.</em></p></div></div></section><hr><section><div><div><p id="7106" data-selectable-paragraph=""><span>V</span>ectorized instructions, often called <a href="https://en.wikipedia.org/wiki/SIMD" target="_blank" rel="noopener nofollow"><strong>SIMD instructions</strong></a> (single instruction multiple data) are instructions that leverage special registers in modern CPUs to speedup certain types of operations. These registers can hold a series of values next to each other, so that a single operation can be executed on all of them at the same time.</p><p id="5040" data-selectable-paragraph="">One important thing to note is that the size of a SIMD register depends on the specific processor, and that it also influences the number of values it can hold at any time. To be precise, there are different SIMD instructions that work on different SIMD registers, each of a specific size, but the C# APIs we will use provide a nice abstraction over this and expose these registers to us as a vector type that can vary in size depending on the specific device we are executing our code on. For instance, it we have 128 bits registers at our disposal, we will be able to store either 2 <strong>double</strong> values (64 bits each), or 4 <strong>int</strong> or <strong>float</strong> values (32 bits each), 8 <strong>ushort</strong> or <strong>short</strong> values (16 bits each) or 16 <strong>byte</strong> or <strong>sbyte</strong> values (8 bits each). SIMD registers might also not be available at all, so we should always manually check whether that’s the case before executing our vectorized code.</p><p id="0f16" data-selectable-paragraph="">Suppose we had two <strong>int[]</strong> arrays and we wanted to write to another <strong>int[]</strong> array of the same size the sum of each pair of values. Instead of going through each element one by one, we could load a chunk of consecutive values from each array into two separate SIMD registers, sum those registers together in a single instruction, and then copy that resulting register to the right location into the <strong>int[]</strong> array to return from the method. The type we need is <a href="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.vector-1?view=netcore-3.1" target="_blank" rel="noopener nofollow"><strong>Vector&lt;T&gt;</strong></a>, which represents a SIMD register with elements of a given type. Here is a sample with both the traditional implementation of this algorithm using a <strong>for</strong> loop, and one using the <strong>Vector</strong> and <strong>Vector&lt;T&gt;</strong> APIs:</p><figure><div></div></figure><p id="feef" data-selectable-paragraph="">With this proof of concept, we can now move on to an implementation of our original <strong>Count</strong> method that leverages the power of SIMD instructions.</p></div></div></section><hr><section><div><div><p id="af73" data-selectable-paragraph=""><span>B</span>ack to our original problem, there is a small complication: the <strong>Vector&lt;T&gt;</strong> type does not have an API that just counts the number of occurrences of a value in a SIMD register — we will have to implement this ourselves. Luckily, this only requires a couple of bit operations on top of the basic SIMD structure we have used in our previous <strong>SumSimd</strong> method:</p><figure><div></div></figure></div></div></section><hr><section><div><div><p id="0a59" data-selectable-paragraph=""><span>H</span>ere are the results when running the 4 different <strong>Count</strong> implementations on a sample text (a 200 lines document with the code for the 4 <strong>Count</strong> versions described above) and looking for the <strong>‘\n’</strong> character. Each implementation has been executed in a loop with <strong>N</strong> iterations each time, to minimize variations.</p><figure><div></div></figure><p id="3b5c" data-selectable-paragraph="">We can see that the SIMD-powered <strong>Count</strong> implementation is <strong>110x</strong> faster than the LINQ version, and <strong>13x</strong> faster than the <strong>foreach</strong> version. Additionally, we can see that both the <strong>foreach</strong> and SIMD versions use no memory at all, whereas the LINQ version allocates 120 bytes of memory for each individual invocation.</p><p id="a52a" data-selectable-paragraph="">Whether or not these improvements are worth the time and effort is entirely up to you (especially since even the LINQ version is still only taking a few microseconds to run), but the speedup is indeed noticeable at least on paper, and doing all of this was definitely a fun experiment!</p></div></div></section><hr><section><div><div><p id="b577" data-selectable-paragraph=""><span>As</span> with my previous blog post, I have added links to every single API that I have used across all the code snippets, if you want to read up more about them. I hope you enjoyed reading this post, please let me know if you spot any mistakes in any of the method implementations!</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>