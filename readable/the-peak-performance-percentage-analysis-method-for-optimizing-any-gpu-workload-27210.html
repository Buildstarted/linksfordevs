<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Peak-Performance-Percentage Analysis Method for Optimizing Any GPU Workload | NVIDIA Developer Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The Peak-Performance-Percentage Analysis Method for Optimizing Any GPU Workload | NVIDIA Developer Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="View all posts by Louis Bavoil"/>
    <meta property="og:description" content="Figuring out how to reduce the GPU frame time of a rendering application on PC is challenging for even the most experienced PC game developers. In this blog post, we describe a performance triage&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.nvidia.com/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The Peak-Performance-Percentage Analysis Method for Optimizing Any GPU Workload | NVIDIA Developer Blog</title>
<div class="readable">
        <h1>The Peak-Performance-Percentage Analysis Method for Optimizing Any GPU Workload | NVIDIA Developer Blog</h1>
            <div>by View all posts by Louis Bavoil</div>
            <div>Reading time: 48-61 minutes</div>
        <div>Posted here: 22 Jun 2019</div>
        <p><a href="https://devblogs.nvidia.com/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/">https://devblogs.nvidia.com/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="pf-post-view">
    <div>

                  <article id="post-12004">
                

                <div>
                  <p>Figuring out how to reduce the GPU frame time of a rendering application on PC is challenging for even the most experienced PC game developers. In this blog post, we describe a performance triage method we’ve been using internally at NVIDIA to let us figure out the main performance limiters of any given GPU workload (also known as perf marker or call range), using NVIDIA-specific hardware metrics.</p>
<p>Our performance triage method does not start from assumptions or knowledge about what is being rendered on the GPU. Instead, it starts solely from hardware metrics, letting us know how well the whole GPU is utilized, what hardware units and sub-units are limiting the performance,&nbsp;and how close they are running to their respective maximum throughputs (also known as “Speed Of Light” or ”SOL”). Assuming that the application does not use <u><a href="http://32ipi028l5q82yhj72224m8j.wpengine.netdna-cdn.com/wp-content/uploads/2017/03/GDC2017-Asynchronous-Compute-Deep-Dive.pdf" target="_blank" rel="noopener">asynchronous compute</a></u>&nbsp;nor <u><a href="https://docs.microsoft.com/en-us/windows/desktop/direct3d12/user-mode-heap-synchronization" target="_blank" rel="noopener">asynchronous copy queues</a></u>,&nbsp;this hardware-centric information can then be mapped back to what the graphics API and shaders are doing, providing guidance on how to improve the GPU performance of any given workload, as shown in figure 1:</p>
<figure id="attachment_11995" aria-labelledby="figcaption_attachment_11995"><a href="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8-1024x246.png" alt="GPU performance data flow" width="1024" height="246" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8-1024x246.png 1024w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8-300x72.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8-768x184.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8-625x150.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8-500x120.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8-160x38.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8-362x87.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8-458x110.png 458w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-8.png 1242w" sizes="(max-width: 1024px) 100vw, 1024px"></a><figcaption id="figcaption_attachment_11995">Figure 1. Data flow through the graphics pipeline.</figcaption></figure>
<ol>
<li>If no GPU unit has a high throughput (compared to its SOL), then we strive to improve the achieved throughput of at least one unit.</li>
<li>If some GPU unit has a high throughput (compared to its SOL), then we figure out how to remove work from that unit.</li>
</ol>
<p>The hardware metrics per GPU workload can be captured by our <u><a href="https://developer.nvidia.com/perfworks" target="_blank" rel="noopener">PerfWorks</a></u>&nbsp;library on all NVIDIA&nbsp;GPUs&nbsp;starting from the <u><a href="https://en.wikipedia.org/wiki/Kepler_(microarchitecture)" target="_blank" rel="noopener">Kepler</a></u>&nbsp;architecture<a target="_blank" rel="noopener">[1]</a>&nbsp;(so <u><a href="https://developer.nvidia.com/maxwell-compute-architecture" target="_blank" rel="noopener">Maxwell</a></u>, <u><a href="https://www.nvidia.com/en-us/geforce/products/10series/architecture/" target="_blank" rel="noopener">Pascal</a></u>, <u><a href="https://www.nvidia.com/en-us/data-center/volta-gpu-architecture/" target="_blank" rel="noopener">Volta</a></u>&nbsp;and <u><a href="https://www.nvidia.com/en-us/geforce/turing/" target="_blank" rel="noopener">Turing</a></u>&nbsp;GPUs are supported). Although the PerfWorks headers are not public yet, the library can be used today via publicly available tools: the Range Profiler of <u><a href="https://developer.nvidia.com/nsight-visual-studio-edition" target="_blank" rel="noopener">Nsight Visual Studio Edition</a></u>&nbsp;and <u><a href="https://developer.nvidia.com/nsight-graphics" target="_blank" rel="noopener">Nsight Graphics</a></u>&nbsp;for DX12, DX11, Vulkan, and OpenGL 4.6 (GL Turing support planned for SIGGRAPH’19), as well as Microsoft’s “<u><a href="https://blogs.msdn.microsoft.com/pix/2017/01/17/introducing-pix-on-windows-beta/" target="_blank" rel="noopener">PIX on Windows”</a></u>&nbsp;for DX12.</p>
<h2>Table of Contents</h2>
<p><a href="#step1">Step 1</a>: Capturing a Frame with Nsight Graphics<br>
<a href="#step2">Step 2</a>: Breaking Down the GPU Frame Time<br>
<a href="#step3">Step 3</a>: Profiling a GPU Workload<br>
<a href="#step4">Step 4</a>: Inspecting the Top SOLs<br>
&nbsp; &nbsp; &nbsp;<a href="#4.1">4.1</a>. The Per-Unit SOL% Metrics<br>
&nbsp; &nbsp; &nbsp;<a href="#4.2">4.2</a>. The “Top SOL Units”<br>
<a href="#step5">Step 5</a>: Understand the Performance Limiters<br>
&nbsp; &nbsp; &nbsp;<a href="#5.1">5.1</a>. If the Top SOL% is Low<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#5.1.1">5.1.1</a>. The “Graphics/Compute Idle%” metric<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#5.1.2">5.1.2</a>. The “SM Active%” metric<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#5.1.3">5.1.3</a>. GPU Trace<br>
&nbsp; &nbsp; &nbsp;<a href="#5.2">5.2</a>. If the Top SOL Unit is the SM<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#5.2.1">5.2.1</a>. Case 1: “SM SOL%” &gt; 80%<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#5.2.2">5.2.2</a>. Case 2: “SM SOL%” &lt; 60%<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#5.2.3">5.2.3</a>. Case 3: “SM SOL%” in [60,80]<br>
&nbsp; &nbsp; &nbsp;<a href="#5.3">5.3</a>. If the Top SOL unit is not the SM<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#5.3.1">5.3.1</a>. If the Top SOL unit is TEX, L2, or VRAM<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#5.3.2">5.3.2</a>. If the Top SOL unit is CROP or ZROP<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#5.3.3">5.3.3</a>. If the Top SOL unit is PD<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#5.3.4">5.3.4</a>. If the Top SOL unit is VAF<br>
<a href="#summary">Summary</a><br>
<a href="#appendix1">Appendix</a>: Performance Triage Examples<br>
&nbsp; &nbsp; &nbsp;<a href="#example1">Example 1</a>: TEX-Interface Limited Workload<br>
&nbsp; &nbsp; &nbsp;<a href="#example2">Example 2</a>: Math-Limited Workload<br>
&nbsp; &nbsp; &nbsp;<a href="#example3">Example 3</a>: Tex-Latency Limited Workload<br>
<a href="#appendix2">Appendix</a>: Optimizing Ray-Marching Loops</p>
<h2 id="step1">Step 1: Capturing a Frame with Nsight Graphics</h2>
<p>Capturing a frame for non-UWP (Universal Windows Platform) applications can be done by launching <u><a href="https://developer.nvidia.com/nsight-graphics" target="_blank" rel="noopener">Nsight Graphics</a></u>, creating a Project, and then going to Activity -&gt; Generate C++ Capture, filling in the Application Executable path, and clicking “Launch”, as you see in figure 2.</p>
<figure id="attachment_11990" aria-labelledby="figcaption_attachment_11990"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-4-625x454.png" alt="NSight frame capture setup" width="625" height="454" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-4-625x454.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-4-300x218.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-4-768x558.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-4-413x300.png 413w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-4-124x90.png 124w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-4-362x263.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-4-151x110.png 151w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-4-1024x744.png 1024w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-4.png 1062w" sizes="(max-width: 625px) 100vw, 625px"><figcaption id="figcaption_attachment_11990">Figure 2.&nbsp;Launching an EXE for capturing frames using <u><a href="https://developer.nvidia.com/nsight-graphics" target="_blank" rel="noopener">Nsight Graphics</a></u>.</figcaption></figure>
<p>The next steps after launching your game include:</p>
<ol>
<li>Proceed to the location in-game you want to capture</li>
<li>Press <strong>CTRL-Z</strong>&nbsp;to show the Nsight HUD in the top-right section of the screen, and</li>
<li>Press <strong>S</strong><strong>pace</strong>&nbsp;to export the current frame to a Visual Studio C++ project in &nbsp;C:\Users\…\Documents\NVIDIA Nsight Graphics\…</li>
</ol>
<p>You can click on “<strong>Resume</strong>” to keep playing your game and possibly capture more frames.</p>
<p>NOTE: You can also profile your application “live” via Activity -&gt; Frame Profiler,&nbsp;but we recommend you always save your captures to disk and archive them so you can return to them later on. At NVIDIA, we treat performance analysis as a scientific process where we provide all the reproducible&nbsp; data (frame captures, etc.) associated with our analysis and encourage colleagues to reproduce and review our results. In our experience, capturing frames before &amp; after a performance optimization attempt has been made (be it successful or not) is also good practice, enabling analysis of how the hardware metrics have changed and learn from the results.</p>
<p>Once you have exported a frame to C++, you can find the capture in the Nsight Project Explorer and click on Build to build an EXE from the capture, as shown in figure 3.</p>
<figure id="attachment_11997" aria-labelledby="figcaption_attachment_11997"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-10-1024x429.png" alt="Nsignt building an EXE file from a capture" width="1024" height="429" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-10-1024x429.png 1024w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-10-300x126.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-10-768x322.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-10-625x262.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-10-500x210.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-10-160x67.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-10-362x152.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-10-262x110.png 262w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-10.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption id="figcaption_attachment_11997">Figure 3. Building a Nsight frame EXE within Nsight Graphics.</figcaption></figure>
<p>Our next step is launching the Range Profiler on a frame-capture EXE by clicking on Frame -&gt; Run -&gt; Connect -&gt; Frame Profiler.</p>
<p>NOTE: For DX12 traces, the Nsight Range Profiler flattens all DX12 queues into a single DIRECT queue during its profiling, to avoid asynchronous commands possibly biasing the performance metrics of other workloads executing concurrently on the GPU. If you want to analyze the overlap of async COMPUTE or COPY queues with your DIRECT queue, you can use our GPU Trace tool which ships with Nsight Graphics.</p>
<h2 id="step2">Step 2: Breaking Down the GPU Frame Time</h2>
<p>Once you’ve launched the Range Profiler on a given frame, you can hit CTRL-Z and Space again to actually profile the frame.</p>
<p>A top-down view of the GPU times is a great way to figure out what perf markers / workloads&nbsp;are the most expensive in a frame. For a <u><a href="https://developer.nvidia.com/shadowworks" target="_blank" rel="noopener">HBAO+</a></u>&nbsp;DX11 test app,&nbsp;rendering SSAO in 4K on a GeForce GTX 2080, the GPU-frame-time breakdown looks like this in the Range Profiler View, as shown in figure 4:</p>
<figure id="attachment_14995" aria-labelledby="figcaption_attachment_14995"><a href="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1.png" alt="" width="1749" height="356" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1.png 1749w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1-300x61.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1-768x156.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1-625x127.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1-500x102.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1-160x33.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1-362x74.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1-540x110.png 540w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-4-Example-GPU-frame-time-breakdown-in-the-Nsight-Range-Profiler.-1-1024x208.png 1024w" sizes="(max-width: 1749px) 100vw, 1749px"></a><figcaption id="figcaption_attachment_14995">Figure 4. Example GPU-frame-time breakdown in the Nsight Range Profiler.</figcaption></figure>
<p>In the “<strong>Perf Markers</strong>” row, the Range Profiler shows&nbsp;the elapsed GPU time per workload measured via D3D timestamp queries, as well as the percentage of the GPU frame time (with the Present call excluded) that each workload is taking.&nbsp;In this example,&nbsp;it’s immediately obvious which workload is most expensive in this frame: “DrawCoarseAOPS”, taking 40.5% of the GPU frame time.</p>
<p>NOTE: Since release 5.5 of Nsight: Visual Studio Edition, the Range Profiler effectively calls SetStablePowerState(TRUE/FALSE) before/after profiling any Range, using an internal driver API that works on all Windows versions (not just Windows 10) and does not require the OS to be in “Developer Mode”. So you should not need to worry about locking your GPU Core clock when using the Nsight Range Profiler.</p>
<p>NOTE: To repro this result, you can download version 3.1 of the HBAO+ source code from <u><a href="https://developer.nvidia.com/shadowworks" target="_blank" rel="noopener">GitHub</a></u>&nbsp;and then run the “SampleApp_D3D11” project in Visual Studio. To make the RenderAO call emit perf markers, you can define ENABLE_PERF_MARKERS=1 in GFSDK_SSAO_D3D11 -&gt; Project Properties -&gt; C/C+ -&gt; Preprocessor. For the record, figure 4 shows what the frame looks like:</p>
<figure id="attachment_11991" aria-labelledby="figcaption_attachment_11991"><a href="https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog-1024x576.png" alt="HBAO example figure" width="1024" height="576" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog-1024x576.png 1024w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog-300x169.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog-768x432.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog-625x352.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog-500x281.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog-160x90.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog-362x204.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog-196x110.png 196w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/HBAO_Blog.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"></a><figcaption id="figcaption_attachment_11991">Figure 5. Looking at HBAO.</figcaption></figure>
<h2 id="step3">Step 3: Profiling a GPU Workload</h2>
<p>Now we are in the Range Profiler, let’s invoke the Range Profiler on the “DrawCoarseAOPS” workload from Step 2 (by profiling only this call range, and nothing else) by clicking on the “DrawCoarseAOPS” box, shown in figure 6:</p>
<figure id="attachment_14996" aria-labelledby="figcaption_attachment_14996"><a href="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload.png" alt="" width="1523" height="309" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload.png 1523w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload-300x61.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload-768x156.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload-625x127.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload-500x101.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload-160x32.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload-362x73.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload-542x110.png 542w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-6.-Launching-the-Nsight-Range-Profiler-for-a-given-workload-1024x208.png 1024w" sizes="(max-width: 1523px) 100vw, 1523px"></a><figcaption id="figcaption_attachment_14996">Figure 6. Launching the Nsight Range Profiler for a given workload.</figcaption></figure>
<p>The Range Profiler injects<a href="https://developer.nvidia.com/perfworks" target="_blank" rel="noopener">&nbsp;</a><u><a href="https://developer.nvidia.com/perfworks" target="_blank" rel="noopener">PerfWorks</a></u>&nbsp;calls inside the Nsight frame capture and collects a set of PerfWorks metrics for the specified workload. Once the profiling is complete, it shows the collected metrics in a new section below the Range Profiler View.</p>
<h2 id="step4">Step 4: Inspecting the Top SOLs</h2>
<p>We start by inspecting the performance metrics from the Range Profiler for that range. This is just a view of PerfWorks metrics for the current workload. By hovering the mouse over any of the metrics, the actual Perfworks metric name gets displayed in a tooltip as you can see in figure 7:</p>
<figure id="attachment_14997" aria-labelledby="figcaption_attachment_14997"><a href="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1.png" alt="" width="1741" height="526" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1.png 1741w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1-300x91.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1-768x232.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1-625x189.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1-500x151.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1-160x48.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1-362x109.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1-364x110.png 364w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-7.-Nsight-Range-Profiler-tooltip-showing-PerfWorks-metric-names-and-descriptions.-1-1024x309.png 1024w" sizes="(max-width: 1741px) 100vw, 1741px"></a><figcaption id="figcaption_attachment_14997">Figure 7. Nsight Range Profiler tooltip showing PerfWorks metric names and descriptions.</figcaption></figure>
<h3 id="4.1">4.1. The Per-Unit SOL% Metrics</h3>
<p>The first top-level metrics to look at for each workload are the per-unit SOL% metrics of the GPU. These convey how close each unit is to its maximum theoretical throughput or Speed Of Light (SOL).&nbsp;At a high level, one can imagine the per-unit SOL% metric as a ratio of achieved throughput to SOL throughput. However, for units with multiple sub-units or concurrent data paths, the per-unit SOL% is the MAX over all the sub-SOL-metrics of all sub-units &amp; data paths.</p>
<p>NOTE: If you are not familiar with the names of the units in our GPUs, please check out this blog post&nbsp;which gives a high-level overview of how the logical graphics pipeline maps to GPU units in our GPU architectures: “<u><a href="https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline" target="_blank" rel="noopener">Life of a triangle – NVIDIA’s logical pipeline</a></u>”, as well as slides 7-25 from this GTC 2016 presentation: “<u><a href="http://on-demand.gputechconf.com/gtc/2016/presentation/s6138-christoph-kubisch-pierre-boudier-gpu-driven-rendering.pdf" target="_blank" rel="noopener">GPU-driven rendering</a></u>”, and my <a href="https://developer.nvidia.com/video/GDC-19/NSIGHT_GPU_TRACE">GDC 2019 talk</a>. In this context:</p>
<ul>
<li>PD (Primitive Distributor) does index-buffer loads and distributes primitives across the chip.</li>
<li>VAF (Vertex Attribute Fetch) does vertex-buffer loads (before the vertex shader gets launched).</li>
<li>SM (Streaming Multiprocessor) runs the shaders.
<ul>
<li>And on Turing GPUs, the main SM sub-pipes are:
<ul>
<li>FMA: fp32 {FADD,FMUL,FMAD, …} ops + int {IMUL, IMAD} ops</li>
<li>ALU: integer &amp; logic ops</li>
<li>FP16: FP16 ops executed in pairs</li>
<li>SFU: transcendental ops (rsqrt, cos/sin, etc.)</li>
</ul>
</li>
</ul>
</li>
<li>TEX performs SRV fetches (and UAV accesses, since <u><a href="https://developer.nvidia.com/maxwell-compute-architecture" target="_blank" rel="noopener">Maxwell</a></u>).</li>
<li>VPC (Viewport Culling) does the viewport transform, frustum culling, and perspective correction of attributes.</li>
<li>L2 is the Level-2 cache attached to each VRAM memory partition.</li>
<li>CROP does color writes &amp; blending to render targets.</li>
<li>ZROP does depth-stencil testing.</li>
<li>VRAM (“Memory” in the Range Diagram)&nbsp;is the GPU video memory.</li>
</ul>
<p>NOTE: A simplified view of the graphics pipeline and its mapping to GPU units can be found within the Nsight Range Profiler results, by selecting “Range Diagram” in the Pipeline Overview. In this diagram, the per-unit SOL% values are displayed as green bars, shown in figure 8:</p>
<figure id="attachment_11998" aria-labelledby="figcaption_attachment_11998"><a href="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11-1024x214.png" alt="Nsight Range Finder Profiler simplified pipeline overview image" width="1024" height="214" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11-1024x214.png 1024w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11-300x63.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11-768x160.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11-625x130.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11-500x104.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11-160x33.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11-362x76.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11-527x110.png 527w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-11.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"></a><figcaption id="figcaption_attachment_11998">Figure 8. Nsight Range Profiler: Pipeline Overview -&gt; Range Diagram.</figcaption></figure>
<p>As you can see in Figure 8, a GPU today is not a simple linear pipeline (A→B→C→…), but rather a network of interconnected units (SM↔TEX↔L2, SM→CROP↔L2, etc). Simple “bottleneck” calculations, which rely on fixed upstream and downstream interfaces for each unit, are not sufficient to reason about GPU performance. Therefore, in doing our analysis, we primarily look at each unit’s SOL% metric to determine units and/or issues limiting performance. The next section will discuss this approach&nbsp;in detail.</p>
<h3 id="4.2">4.2. The “Top SOL&nbsp;Units”</h3>
<p>In our performance triage method, we always start by looking at the top 5 SOL units&nbsp;and their associated SOL% metrics. These are the top 5 hardware units that limit the GPU performance of this workload. The Nsight Range Profiler shows the top 5 SOL% metrics (aka “Top SOLs”) in the Pipeline Overview – Summary section, shown in figure 9:</p>
<figure id="attachment_13484" aria-labelledby="figcaption_attachment_13484"><a href="https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9.png" alt="" width="1593" height="320" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9.png 1593w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9-300x60.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9-768x154.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9-625x126.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9-500x100.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9-160x32.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9-362x73.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9-548x110.png 548w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/New_Fig9-1024x206.png 1024w" sizes="(max-width: 1593px) 100vw, 1593px"></a><figcaption id="figcaption_attachment_13484">Figure 9. Example of “Top SOLs” in the Range Profiler -&gt; Pipeline Overview.</figcaption></figure>
<h4>Case 1: Top SOL% &gt; 80%</h4>
<p>If the top SOL% value is &gt; 80%, then we know that the profiled workload is running very efficiently (close to max throughput) on the GPU, and to speed it up one should try removing work from the top SOL&nbsp;unit, possibly shifting it to another unit. For example, for workloads with the SM as top SOL unit with SOL% &gt; 80%, one can try skipping groups of instructions opportunistically, or consider moving certain computations to lookup tables.</p>
<h4>Case 2: Top SOL% &lt; 60%</h4>
<p>If the top SOL% value is &lt; 60%, this means the&nbsp;top SOL unit and all other GPU units with lower SOL% are under-utilized (idle cycles), running inefficiently (stall cycles), or not hitting their fast paths due to the specifics of the workload they are given. Examples of these situations include:</p>
<ul>
<li>The app being partly CPU limited (see Section <a href="#5.1.1">5.1.1</a>).</li>
<li>Lots of Wait For Idle commands or Graphics&lt;-&gt;Compute switches draining the GPU pipeline repeatedly (see Section <a href="#5.1.2">5.1.2</a>).</li>
<li>TEX fetching from a texture object with a format, dimensionality, or filter mode that makes it run at reduced throughput by design&nbsp;(see these <u><a href="http://www.hardware.fr/articles/948-9/performances-theoriques-pixels.html" target="_blank" rel="noopener">synthetic benchmarks</a></u>&nbsp;for GTX 1080). For instance, a 50% TEX SOL% is expected when sampling a 3D texture with tri-linear filtering.</li>
<li>Memory-subsystem inefficiencies, such as poor cache hit rates in the TEX or L2 units, sparse VRAM accesses causing a low VRAM SOL%, and VB/IB/CB/TEX&nbsp;fetches from system memory instead of GPU VRAM.</li>
<li>Input Assembly fetching a 32-bit index buffer (half-rate compared to 16-bit indices).</li>
</ul>
<p>NOTE: In this case, we can use the top SOL% value to derive an upper bound on the maximum gain that can be achieved on this workload by reducing inefficiencies: if a given workload is running at 50% of its SOL, and by assuming that one can increase the SOL% up to 90% by reducing internal inefficiencies, we know the max expected gain on the workload is 90/50 = 1.8x = 80%.</p>
<h4>Case 3: Top SOL% in [60, 80]</h4>
<p>In this case (gray zone), we follow the approaches from both Case 1 (high Top SOL%) and Case 2 (low Top SOL%).</p>
<p>NOTE: The per-unit SOL% metrics are all defined relative to the elapsed GPU cycles (wall clock), which may be different from the active cycles (cycles where that hardware unit is not idle). The main reason we define them relative to elapsed cycles and not per-unit active cycles&nbsp;is to make SOL% metrics&nbsp;comparable, by giving them all a common denominator. Another benefit of defining them relative to elapsed cycles is that any GPU idle cycles that limit the overall GPU performance are reported as a low top SOL% value for that workload (top-level metric in our SOL-guided triage).</p>
<h2 id="step5">Step 5:&nbsp;Understand the Performance Limiters</h2>
<p>Having done the previous step, we know what the Top SOLs (GPU unit names and associated percentage of max throughput for elapsed cycles) are for each workload of interest. We know that the top-SOL GPU units are limiting the performance of the workload being studied because these are the units that are running the closest to their maximum throughput. We now need to understand what is limiting the performance of these top-SOL units.</p>
<h3 id="5.1">5.1. If the Top SOL% is Low</h3>
<p>As outlined above in Section <a href="#4.2">4.2</a>, there are multiple possible causes for this. We often refer to these as pathologies. And as with real-life patients, a workload may suffer from multiple pathologies simultaneously. We start by inspecting the values of the following metrics: the “<strong>Graphics/Compute Idle%</strong>” and the “<strong>SM Active %</strong>”.</p>
<h4 id="5.1.1">5.1.1. The “Graphics/Compute Idle%” metric</h4>
<p>The “<strong>Graphics/Compute Idle%</strong>” metric is the percentage of the GPU elapsed cycles during which the whole Graphics &amp; Compute hardware pipeline was fully idle for the current workload. These are the GPU cycles during which the graphics/compute pipeline is empty, either because the CPU is not feeding commands fast enough to the GPU or because the application is using the synchronous Copy Engine (which can happen when using Copy calls on a DIRECT queue or immediate context). Note that pipeline drains caused by Wait For Idle commands are not counted as “Graphics/Compute Idle”.</p>
<p>In this case, we recommend to measure the total elapsed CPU time per workload spent on the following CPU calls, and then try to minimize the most expensive ones:</p>
<p>For DX11:</p>
<ul>
<li>Flush{,1}</li>
<li>Map</li>
<li>UpdateSubresource{,1}</li>
</ul>
<p>For DX12:</p>
<ul>
<li>Wait</li>
<li>ExecuteCommandLists</li>
</ul>
<p>For DX11 and DX12:</p>
<ul>
<li>Any Create or Release calls</li>
</ul>
<p>DX11 Notes:</p>
<ul>
<li>ID3D11DeviceContext::Flush&nbsp;forces a command-buffer kickoff, which may require the Flush() call to stall on the CPU.</li>
<li>Calling ID3D11DeviceContext::Map on a STAGING resource can cause a CPU stall due to resource contention, when mapping the same staging resource in consecutive frames. In this case, the Map call in the current frame must wait internally until the previous frame (which is using the same resource) has been processed before returning.</li>
<li>Calling ID3D11DeviceContext::Map with DX11_MAP_WRITE_DISCARD can cause a CPU stall due to the driver running out of&nbsp;versioning&nbsp;space.&nbsp;That is because each time a Map(WRITE_DISCARD) call is performed, our driver returns a new pointer to a fixed-size&nbsp;memory pool. If the driver runs out of versioning space, the Map call stalls.</li>
</ul>
<p>DX12 Notes:</p>
<ul>
<li>Each ExecuteCommandLists (ECL) call has some GPU idle overhead associated with it, for kicking off a new command buffer. So, to reduce GPU idle time, we recommend batching all your command lists into as few ECL calls as possible, unless you really want command-buffer kickoffs to happen at certain points in the frame (for example, to reduce input latency in VR apps with a single frame in flight).</li>
<li>When an application calls ID3D12CommandQueue::Wait on a fence,&nbsp;the OS (Windows 10) holds off submitting new command buffers to the GPU for that command queue until the Wait call returns.</li>
</ul>
<p>NOTE: The CPU and GPU times per API call are measured by Nsight and presented in the API Statistics View each time the Range Profiler is launched, shown in figure 10:</p>
<figure id="attachment_12002" aria-labelledby="figcaption_attachment_12002"><a href="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15-1024x718.png" alt="CPU and GPU times per API call range finder screenshot" width="1024" height="718" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15-1024x718.png 1024w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15-300x210.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15-768x539.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15-625x438.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15-428x300.png 428w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15-128x90.png 128w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15-362x254.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15-157x110.png 157w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-15.png 1353w" sizes="(max-width: 1024px) 100vw, 1024px"></a><figcaption id="figcaption_attachment_12002">Figure 10. CPU &amp; GPU times per API call in the Range Profiler.</figcaption></figure>
<h4 id="5.1.2">5.1.2. The “SM Active%” metric</h4>
<p>The “<strong>SM Active%</strong>” metric reports the percentage of GPU elapsed cycles with at least 1 warp&nbsp;(32 threads) active for each SM instance, averaged across all of the SM instances. Note that warps that are waiting on memory requests to come back are accounted as “active” / in flight.</p>
<p>For a full-screen quad or a compute shader workload, the SM should be active for more than&nbsp;95%&nbsp;of the workload. If not, there may be back-to-back serialized Dispatch calls with low amount of threads per call which are insufficient to fill all the SMs on the GPU, or there may be imbalances between the SMs, with some SMs being idle (no active warp) while others are active (at least one active warp).</p>
<p>If for any geometry-rendering workload, the SM Active% is below 90%, you know it may be possible to get a ~10% performance gain on this workload&nbsp;by overlapping asynchronous Compute work with it. On DX12 and Vulkan, this can be done by using a Compute-only queue. Note that it’s also possible to get a speedup from async compute even if the SM Active% is close to 100%, because the SMs may be tracked as active, but may be able to take on more active warps.</p>
<p>Another reason why the “SM Active%” may be below 90% for any workload is frequent <strong>GPU pipeline drains</strong>&nbsp;(Wait For Idle commands, aka WFIs), which can be caused by:</p>
<ul>
<li>Frequent Compute&lt;-&gt;Graphics switches in the same DX11 context or in the same DX12 queue.
<ul>
<li><strong>Problem</strong>: Switching between Draw and Dispatch calls in the same hardware queue causes a GPU WFI to be executed. Also, performing non-CS state-setting&nbsp;calls in a compute-only workload (e.g. mapping a constant buffer which is&nbsp;bound to both CS and graphics shader stages) can result in WFI being executed.</li>
<li><strong>Solution</strong>: Batch all Compute work and do NOT interleave graphics and compute API calls, including Map(WRITE_DISCARD) calls on “sticky” resources that are bound on all shader stages.</li>
</ul>
</li>
</ul>
<ul>
<li>On DX11,&nbsp;multiple render calls with the same UAV bound and no “UAV overlap” hints provided to our driver.
<ul>
<li><strong>Problem</strong>: Subsequent render calls having a bound UAV in common are conservatively separated by GPU WFI commands&nbsp;injected by our driver, to prevent any data hazards.</li>
<li><strong>Solution</strong>: The&nbsp;following calls can be used to disable the insertion of UAV-related WFI commands:&nbsp;NvAPI_D3D11_{Begin,End}UAVOverlap or NvAPI_D3D11_BeginUAVOverlapEx.</li>
<li>Note that on DX12,&nbsp;OpenGL&nbsp;&amp; Vulkan, the UAV-related WFIs are explicitly controlled by the application using explicit API calls (ResourceBarrier,&nbsp; vkCmdPipelineBarrier, or glMemoryBarrier).</li>
</ul>
</li>
</ul>
<ul>
<li>On DX12, ResourceBarrier calls with little work in between the barriers.
<ul>
<li><strong>Problem</strong>: Each batch of back-to-back ResourceBarrier calls on a given queue can cause all of the GPU work on that queue to be drained.</li>
<li><strong>Solution</strong>: To minimize the performance impact of ResourceBarrier calls, it is important to minimize the number of locations in the frame where ResourceBarrier calls are performed.</li>
</ul>
</li>
</ul>
<ul>
<li>Hundreds of state changes in workloads using tessellation shaders and/or geometry shader (except for GSs that were created as pass-through Fast GSs, using <u><a href="http://docs.nvidia.com/gameworks/content/gameworkslibrary/coresdk/nvapi/group__dx.html" target="_blank" rel="noopener">NVAPI</a></u>&nbsp;for DX11 &amp; DX12, or <u><a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_geometry_shader_passthrough.txt" target="_blank" rel="noopener">NV_geometry_shader_passthrough</a></u>&nbsp;for GL).
<ul>
<li><strong>Problem: </strong>Having a lot of state changes with HS &amp; DS active can cause the SMs to be drained, for shader scheduling reasons.</li>
<li><strong>Solution: </strong>Minimize the number of state changes (including resource bindings) in workloads that have tessellation shaders.</li>
</ul>
</li>
</ul>

<h4 id="5.1.3">5.1.3. GPU Trace</h4>
<p>For DX12 applications on Turing GPUs (GTX 16 series and RTX 20 series), you can use our new GPU Trace tool (figure 11) which is part of Nsight Graphics. GPU Trace is a low-level profiler that runs on a live application, and gives insights on how the frame is being executed over time. It captures the following metrics and visualizes them on a timeline (and as summary values per workload):</p>
<ul>
<li>The Top SOL% metrics (in the “Unit Throughputs” section):
<ul>
<li>Per GPU unit (SM, L1TEX, L2, VRAM, PD, VAF, PES+VPC, RASTER, PROP, ZROP, CROP)</li>
<li>Per SM sub-unit (SM FMA Pipe, SM ALU Pipe, SM SFU Pipe, SM FP16+Tensor Pipe, SM Issue Active)</li>
</ul>
</li>
</ul>
<ul>
<li>The % of the elapsed cycles that a given part of the GPU is active:
<ul>
<li>“GPU Active” // Graphics/Compute pipeline or Copy Engine active</li>
<li>“Async Copy Engine Active”</li>
<li>“Sync Copy Engine Active”</li>
<li>“GR Active” // Graphics/Compute pipeline active</li>
</ul>
</li>
</ul>
<ul>
<li>The SM Occupancy (% of active warp slots per elapsed cycle) for
<ul>
<li>Vertex/Tessellation/Geometry Warps</li>
<li>Pixel Warps</li>
<li>Compute Warps</li>
<li>Unused Warp Slots on Active SM</li>
<li>Unused Warp Slots on Idle SM</li>
</ul>
</li>
</ul>
<ul>
<li>L2 Read Hit Rates</li>
</ul>
<p>See my GDC 2019 presentation for more about how GPU Trace metrics can be used to optimize the GPU work of DX12/DXR applications: <a href="https://news.developer.nvidia.com/what-is-limiting-your-rendering-performance/">https://news.developer.nvidia.com/what-is-limiting-your-rendering-performance/</a></p>
<figure id="attachment_15007" aria-labelledby="figcaption_attachment_15007"><a href="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace.png" alt="" width="3397" height="1518" srcset="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace.png 3397w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace-300x134.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace-768x343.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace-625x279.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace-500x223.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace-160x71.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace-362x162.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace-246x110.png 246w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig11_gpu_trace-1024x458.png 1024w" sizes="(max-width: 3397px) 100vw, 3397px"></a><figcaption id="figcaption_attachment_15007">Figure 11. Nsight Graphics: GPU Trace in action.</figcaption></figure>
<p>To use it, just launch your application via Activity -&gt; GPU Trace, and then click on “Generate GPU Trace Capture”&nbsp;within Nsight, and finally Open the trace.</p>
<h3 id="5.2">5.2. If&nbsp;the Top SOL Unit is the SM</h3>
<p>If the SM is the top SOL unit (or close, in terms of SOL%), we analyze the value of the SM SOL% metric in the “Top SOLs (Throughputs For Elapsed Cycles)”.</p>
<figure id="attachment_14999" aria-labelledby="figcaption_attachment_14999"><a href="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-%E2%80%9CTop-SOLs%E2%80%9D-provided-by-the-Range-Profiler.-1.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-%E2%80%9CTop-SOLs%E2%80%9D-provided-by-the-Range-Profiler.-1.png" alt="" width="1558" height="218" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-“Top-SOLs”-provided-by-the-Range-Profiler.-1.png 1558w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-“Top-SOLs”-provided-by-the-Range-Profiler.-1-300x42.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-“Top-SOLs”-provided-by-the-Range-Profiler.-1-768x107.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-“Top-SOLs”-provided-by-the-Range-Profiler.-1-625x87.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-“Top-SOLs”-provided-by-the-Range-Profiler.-1-500x70.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-“Top-SOLs”-provided-by-the-Range-Profiler.-1-160x22.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-“Top-SOLs”-provided-by-the-Range-Profiler.-1-362x51.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-“Top-SOLs”-provided-by-the-Range-Profiler.-1-786x110.png 786w, https://devblogs.nvidia.com/wp-content/uploads/2018/11/Figure-12.-Example-of-“Top-SOLs”-provided-by-the-Range-Profiler.-1-1024x143.png 1024w" sizes="(max-width: 1558px) 100vw, 1558px"></a><figcaption id="figcaption_attachment_14999">Figure 12. Example of “Top SOLs” provided by the Range Profiler. The SM SOL% value is useful for determining whether a given workload is partly limited by the “SM Occupancy” (Active Warps per Elapsed Cycle”).</figcaption></figure>
<h4 id="5.2.1">5.2.1. Case 1: “SM SOL%” &gt; 80%</h4>
<p>If the SM is the top SOL unit and “<strong>SM&nbsp;SOL%”</strong> is greater than 80%,&nbsp;then the current workload is mainly limited by the SM scheduler issue rate, and therefore increasing the SM occupancy would not improve performance significantly (at least no more than a 5% gain on the workload).</p>
<p>In this case, the next step of the performance triage process is figuring out what kind of instructions are saturating the bandwidth of the SM scheduler. Typically, that’s the math instructions (FP32 or integer ops), but that can also be memory instructions such as texture fetches or shared-memory accesses.</p>
<p>Since Nsight Graphics 2019.3, the following SM sub-SOL metrics can be queried in the User Metrics section of the Range Profiler, for Turing GPUs:</p>
<ul>
<li>sm__inst_executed.avg.pct_of_peak_sustained_elapsed // the total # of warp instructions executed</li>
<li>sm__issue_active.avg.pct_of_peak_sustained_elapsed // the total # of cycles where an SM scheduler issued an instruction</li>
<li>sm__pipe_shared_cycles_active_realtime.avg.pct_of_peak_sustained_elapsed // the total # of cycles where the shared pipe was active (fp16+tensor)</li>
<li>sm__inst_executed_pipe_alu_realtime.avg.pct_of_peak_sustained_elapsed // the total # of warp instructions executed by the ALU pipe</li>
<li>sm__inst_executed_pipe_fma_realtime.avg.pct_of_peak_sustained_elapsed // the total # of warp instructions executed by the FMA pipe</li>
<li>sm__inst_executed_pipe_xu_realtime.avg.pct_of_peak_sustained_elapsed // the total # of warp instructions executed by the SFU/XU pipe</li>
<li>sm__inst_executed_pipe_ipa_realtime.avg.pct_of_peak_sustained_elapsed</li>
<li>sm__inst_executed_pipe_l1tex_realtime.avg.pct_of_peak_sustained_elapsed&nbsp;&nbsp;&nbsp;</li>
</ul>
<h3><span>Notes:</span></h3>
<ul>
<li>The FMA pipe can execute fp32 {FADD, FMUL, FMAD, …} ops + int {IMUL, IMAD} ops.</li>
<li>The ALU pipe can execute integer and logic ops.</li>
<li>The shared pipe can execute FP16 ops executed in pairs, or Tensor Core ops.</li>
<li>The SFU/XU pipe can execute transcendental ops (rsqrt, cos/sin, etc.), type conversions and miscellaneous operations such as FLO (find leading) and FRND (fp round).</li>
</ul>
<p>The first thing to do when “SM SOL%” is high is to query all of the above SM sub-SOL metrics and sort them in decreasing order and analyze the “Top SM sub-SOL%” metric, which is the SM sub-metric with the highest value. If the “Top SM sub-SOL%” is greater than 60%, then the performance of the current workload is partly limited by that SM sub-unit and removing work from it (possibly moving the work to another SM sub-unit) should produce a speedup.</p>
<h4 id="5.2.2">5.2.2. Case 2:&nbsp;“SM SOL%” &lt; 60%</h4>
<p>As described <u><a href="http://on-demand.gputechconf.com/gtc/2013/presentations/S3466-Programming-Guidelines-GPU-Architecture.pdf#page=15" target="_blank" rel="noopener">on slide 15</a></u>&nbsp;in this <u><a href="http://on-demand.gputechconf.com/gtc/2013/video/S3466-Performance-Optimization-Guidelines-GPU-Architecture-Details.mp4" target="_blank" rel="noopener">GTC 2013 talk</a></u>&nbsp;on the 14th&nbsp;minute, when a given warp instruction cannot be issued (because its operands are not ready or because the pipeline sub-unit it needs for execution is not ready — we call this a warp stall), then the SM instruction scheduler tries to hide latency by switching to a different active warp. So there are two ways one can help the SM scheduler issue more instructions per SM active cycle:</p>
<p>1) Increasing the SM occupancy (number of active warps the scheduler can switch to) and<br>
2) Reducing the SM issue-stall latencies (so warps stay in the stalled state for fewer cycles).</p>
<p><strong>Approach 1: Increasing the SM Occupancy</strong></p>
<p>If the SM is the top SOL unit (or close), “<strong>SM&nbsp;SOL%”</strong> &lt; 60%, then increasing the SM occupancy&nbsp;(active warps per elapsed cycle FOOTNOTE[sm__warps_active.avg.pct_of_peak_sustained_elapsed on Turing]) should improve performance. To increase the SM occupancy, one must first figure out what is limiting it.</p>
<p>Since Nsight Graphics 2019.3, the following hardware metrics are available in the Range Profiler in the User Metrics section:</p>
<p>For pixel shaders:</p>
<ul>
<li>tpc__warp_launch_cycles_stalled_shader_ps_reason_ooo_warp_completion.avg.pct_of_peak_sustained_elapsed // the total # of cycles where PS warp launch was stalled on out-of-order warp completion (non-exclusively)</li>
<li>tpc__warp_launch_cycles_stalled_shader_ps_reason_register_allocation.avg.pct_of_peak_sustained_elapsed // the total # of cycles where PS warp launch was stalled due to register allocation (non-exclusively)</li>
</ul>
<p>For compute shaders:</p>
<ul>
<li>tpc__warp_launch_cycles_stalled_shader_cs_reason_register_allocation.avg.pct_of_peak_sustained_elapsed // the total # of cycles where CS warp launch was stalled due to register allocation (non-exclusively)</li>
<li>tpc__warp_launch_cycles_stalled_shader_cs_reason_cta_allocation.avg.pct_of_peak_sustained_elapsed // the total # of cycles where CS warp launch was stalled due to cta allocation (non-exclusively)</li>
<li>tpc__warp_launch_cycles_stalled_shader_cs_reason_shmem_allocation.avg.pct_of_peak_sustained_elapsed // the total # of cycles where CS warp launch was stalled due to shared-mem allocation (non-exclusively)</li>
</ul>
<p>These are the % of elapsed cycles where an SM controller was unable to launch a warp due to reason X. You can query all of them and sort them in decreasing order. The first one is the top occupancy limiter for the current workload.</p>
<p>The most common SM-occupancy limiter for pixel and compute shaders is the number of hardware registers per thread used by the shader.</p>
<p>The impact of hardware register count on the maximum theoretical occupancy (number of active warps per active cycles) is available in our CUDA Occupancy Calculator. Figure 13 outlines theoretical occupancy graphs for “Compute Capability” 7.5, which includes all Turing GPUs (RTX 20 series, GTX 16 series and TITAN RTX):</p>
<figure id="attachment_15005" aria-labelledby="figcaption_attachment_15005"><a href="https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure-13-Graph-from-the-CUDA-Occupancy-Calculator.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure-13-Graph-from-the-CUDA-Occupancy-Calculator.png" alt="" width="745" height="489" srcset="https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure-13-Graph-from-the-CUDA-Occupancy-Calculator.png 745w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure-13-Graph-from-the-CUDA-Occupancy-Calculator-300x197.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure-13-Graph-from-the-CUDA-Occupancy-Calculator-625x410.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure-13-Graph-from-the-CUDA-Occupancy-Calculator-457x300.png 457w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure-13-Graph-from-the-CUDA-Occupancy-Calculator-137x90.png 137w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure-13-Graph-from-the-CUDA-Occupancy-Calculator-362x238.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure-13-Graph-from-the-CUDA-Occupancy-Calculator-168x110.png 168w" sizes="(max-width: 745px) 100vw, 745px"></a><figcaption id="figcaption_attachment_15005">Figure 13. Graph from the CUDA Occupancy Calculator for “Compute Capability” 7.5.</figcaption></figure>
<p>Other than registers, the following resources can also limit the SM occupancy on GPUs:</p>
<ul>
<li>For graphics shaders:
<ul>
<li>The total size of the Vertex Shader&nbsp;output attributes.</li>
<li>The total size of the Pixel Shader&nbsp;input attributes.</li>
<li>The total sizes of the input &amp; output attributes of the HS, DS or GS.</li>
<li>For Pixel Shaders, out-of-order completion of pixel warps (typically due to dynamic control flow such as dynamic loops or early-exit branches). Note that CSs do not have this issue as much, since CS thread groups can complete in arbitrary order. See slide 39 from our GDC 2016 talk on “<u><a href="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/GDC16/GDC16_gthomas_adunn_Practical_DX12.pdf" target="_blank" rel="noopener">Practical DirectX 12</a></u>” by Gareth Thomas &amp; Alex Dunn.</li>
</ul>
</li>
</ul>
<ul>
<li>For compute shaders:
<ul>
<li>The thread-group size can directly impact the SM occupancy since warps of a thread group launch on the SM in an all-or-none fashion (i.e. all warps of a thread-group have the necessary resources available and will launch together, or none will). The larger the thread-group size, the coarser the quantization of resources like shared memory and register file. While some algorithms may genuinely require large thread groups, in all other cases, developers should try to restrict thread-group sizes to 128 or 64 threads as much as possible. That’s because thread groups of size 128 or 64 threads give the most flexibility to our shader compiler in picking the best possible register target for a shader program.</li>
<li>The total number of shared-memory bytes allocated per thread group can also directly impact the SM occupancy.</li>
<li>Out-of-order warp completion within thread groups can limit occupancy, if one warp completes much earlier than other warps in the same thread group. If the thread group size is greater than 64, lowering it to 64 should help if warps have uneven latencies.</li>
<li>GPU Wait For Idle (WFI) commands can limit the occupancy if there are not enough warps to fill in all of the SMs between consecutive WFIs. In this case, reducing the number of API-level WFI commands (e.g. UAV ResourceBarrier calls on DX12) so that more thread groups can execute in parallel may help.</li>
<li>Finally, for sequences of Dispatch calls with short shaders (e.g. a TEX instruction and a couple of math instructions), the SM occupancy may be limited by the thread-group launch rate in upstream units. In this case, merging consecutive Dispatch calls may help.</li>
</ul>
</li>
</ul>
<p>NOTE: There are actually two approaches to reducing thread-group sizes:</p>
<ul>
<li>Approach 1: Lowering the thread-group size by a factor of N and simultaneously increasing grid launch dimensions by N. See above.</li>
<li>Approach 2: Merging the work of N&gt;=2 threads into a single thread. This allows sharing common data between the N merged threads via registers, or performing reductions in registers instead of in shared memory with atomic ops (e.g. <u><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471413(v=vs.85).aspx" target="_blank" rel="noopener">InterlockedMin</a></u>&nbsp;in HLSL). Besides, this approach also has the advantage of automatically amortizing thread-group-uniform operations across the N merged threads. However, one should be wary of the likelihood of register bloat from this approach.</li>
</ul>
<p>To reduce the total number of registers allocated for a given shader, one can look at the DX shader assembly and study&nbsp;the number of registers used&nbsp;in&nbsp;each branch of the shader. The hardware needs to allocate registers for the most register-hungry branch, and the warps that skip that branch run with a sub-optimal SM occupancy.</p>
<p>For full-screen passes (pixel or compute shaders), a typical way to address this problem is to run a pre-pass that classifies the pixels into different regions and run different shader permutations for each region:</p>
<ul>
<li>For compute shaders, this SIGGRAPH 2016 presentation describes a solution using DispatchIndirect calls to apply specialized compute shaders&nbsp;to different tiles on screen, with a variable number of thread blocks per shader permutation:<br>
“<u><a href="http://advances.realtimerendering.com/s2016/s16_ramy_final.pptx" target="_blank" rel="noopener">Deferred Lighting in Uncharted 4</a></u>”&nbsp;– Ramy El Garawany (Naughty Dog).</li>
<li>For pixel shaders, a different specialization approach can be used: a full-screen stencil buffer can be filled up in a pre-pass to classify the pixels. Then, multiple draw calls can be performed efficiently, by relying on the stencil test to happen before the pixel-shader execution (which should be done automatically by our driver), and using stencil tests that discard the pixels that the current shader permutation does not touch. This GDC 2013 presentation uses this approach to optimize MSAA deferred rendering: “<u><a href="http://www.crytek.com/cryengine/presentations/the-rendering-technologies-of-crysis-3" target="_blank" rel="noopener">The Rendering Technologies of Crysis 3</a></u>” –&nbsp;Tiago Sousa, Carsten Wenzel, Chris Raine (Crytek).</li>
</ul>
<p>Finally, to better understand the SM occupancy limitedness of a given compute shader, you can use our <u><a href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#calculating-occupancy" target="_blank" rel="noopener">CUDA Occupancy Calculator</a></u>&nbsp;spreadsheet, available in the latest <a href="https://docs.nvidia.com/cuda/index.html" target="_blank" rel="noopener">CUDA Toolkit</a>. To use it, just fill in the <u><a href="https://en.wikipedia.org/wiki/CUDA" target="_blank" rel="noopener">CUDA Compute Capability</a></u>&nbsp;for your GPU, as well as the resource usage for your shader (thread-group size, register count from the&nbsp;Nsight Graphics Shader View, and shared-memory size in bytes).</p>
<p><strong>Approach 2: Reducing the SM issue-stall latencies</strong></p>
<p>There is another way to increase the SM SOL% other than increasing the SM occupancy: by reducing the number of SM issue-stall cycles. These are the SM active cycles between instruction issue cycles during which a warp instruction is stalled, due to one of its operands not being ready or due to resource contention on the datapath that this instruction needs to be executed on.</p>
<p>The PerfWorks metrics smsp__warp_cycles_per_issue_stall_{reason} show the avg cycles between instruction issues that a warp is stalled for {reason}. The PerfWorks metric smsp__warp_stall_{reason}_pct is the % of active warps stalled for that reason per cycle. These metrics are exposed in the User Metrics section of the Range Profiler, as well as in the SM Overview Summary section of the profiler, sorted in decreasing order. Amongst these possible warp-stall reasons, the following are common:</p>
<ol>
<li>The “smsp__warp_stall_long_scoreboard_pct” PerfWorks metric is the percentage of active warps that were stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, tex) operation.</li>
<li>The “smsp__warp_stall_barrier_pct” PerfWorks metric is the percentage of active warps that were stalled waiting for sibling warps at a thread-group barrier. In this case, lowering the thread-group size may improve performance, which can sometimes be done by making each thread process multiple input elements.</li>
</ol>
<p>If SM SOL% is lower than 80% and “smsp__warp_stall_long_scoreboard_pct” is the top warp-stall reason, then you know that the shader is TEX-latency limited. This means that most of the stall cycles are coming from the dependencies with texture fetch results, In this case:</p>
<ol>
<li>If the shader contains a loop for which the number of iterations can be known at shader compilation time (possibly by using different shader permutations per loop count), then try forcing FXC to fully unroll the loop by using the <u><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb509602(v=vs.85).aspx" target="_blank" rel="noopener">[unroll]</a></u>&nbsp;loop attribute in the HLSL.</li>
<li>If your shader is doing a dynamic loop that cannot be fully unrolled (e.g. a ray-marching loop), try batching the texture-fetch instructions to reduce the number of TEX-dependency stalls (by grouping independent texture fetches in batches of 2 to 4 back-to-back instructions at the HLSL level).<br>
See the “Optimizing Ray-Marching Loops” Appendix.</li>
<li>If your shader is iterating through all of the MSAA sub-samples per pixel for a given texture, fetch all of the sub-samples together, in a single batch of TEX instructions for that texture. Since the MSAA sub-samples are stored next to each other in VRAM, fetching them together maximizes the TEX hit rate.</li>
<li>If the texture loads are based on a conditional, that most of the time is expected to be true (e.g if (idx &lt; maxidx) loadData(idx)), consider enforcing the load and clamping the coordinate ( loadData(min(idx,maxidx-1)) ).</li>
<li>Try reducing the TEX latency by improving the TEX and L2 cache hit rates. The TEX &amp; L2 hit rates can be improved by tweaking sampling patterns to make adjacent pixels/threads fetch more adjacent texels, by using mipmaps if applicable, as well as by reducing texture dimensions &amp; using more compact texture formats.</li>
<li>Try reducing the number of executed TEX instructions (possibly using branches per texture instruction, which get compiled as TEX instruction predicates, see the FXAA 3.11 HLSL for an example, e.g.: “if(!doneN) lumaEndN = FxaaLuma(…);”).</li>
</ol>
<h4 id="5.2.3">5.2.3. Case 3: “SM SOL%” in [60,80]</h4>
<p>In this case, we follow the approaches from both Case 1 (high SM throughput) and Case 2 (low SM throughput).</p>
<h3 id="5.3">5.3. If the Top SOL unit is not the SM</h3>
<h4 id="5.3.1">5.3.1. If the Top SOL unit is TEX, L2,&nbsp;or VRAM</h4>
<p>If the top SOL unit is not the SM but is one of the memory-subsystem units (TEX-L1, L2,&nbsp;and VRAM), then it’s possible that the root cause of the poor performance is TEX or L2 cache thrashing caused by a non-GPU-friendly access pattern (typically, with adjacent threads in a warp accessing far-apart memory). In this case, the top limiting unit may be TEX or L2,&nbsp;but the root cause may be in the shaders executed by the SM,&nbsp;so it’s worth triaging the SM performance using the method from Section <a href="#5.2">5.2</a> (if the Top SOL unit is the SM).</p>
<p>If the top SOL unit is the VRAM, and its SOL% value is not poor (&gt;60%), then this workload is VRAM-throughput limited and merging it with another pass should speedup the frame. A typical example is merging a gamma-correction pass with another post-processing pass.</p>
<h4 id="5.3.2">5.3.2. If the Top SOL unit is CROP or ZROP</h4>
<p>If CROP is the Top SOL unit, you can try using smaller render target format (e.g R11G11B10F instead of RGBA16F), and if you are using Multiple Render Targets, you can try reducing the number of render targets. Also, killing pixels in the pixel shader more aggressively may be worth it (for instance, for certain transparency effects, discarding pixels that have less than 1% opacity). See this blog post for more possible strategies for optimizing transparency rendering: “<u><a href="https://developer.nvidia.com/content/transparency-or-translucency-rendering" target="_blank" rel="noopener">Transparency (or Translucency) Rendering</a></u>”.</p>
<p>If ZROP is the Top SOL unit, you can try using a smaller depth format (e.g. D16 instead of D24X8 for shadow maps, or D24S8 instead of D32S8), as well as drawing opaque objects more in front-to-back order so that ZCULL (coarse-granularity depth test) has a chance to discard more pixels before ZROP &amp; the pixel shader get invoked.</p>
<h4 id="5.3.3">5.3.3. If the Top SOL unit is PD</h4>
<p>As mentioned earlier, PD does index-buffer loads, to gather the input indices of the vertices. If PD is the Top SOL unit, you can try using 16-bit index buffers instead of 32-bit ones. If that does not increase the PD SOL%, you can then try optimizing geometry for vertex reuse and locality.</p>
<h4 id="5.3.4">5.3.4. If the Top SOL unit is VAF</h4>
<p>In this case, reducing the number of vertex-shader input attributes should help.<br>
Also, separating out the position stream from the rest of the attributes may be beneficial for z-only or shadow map rendering.</p>
<h2 id="summary">Summary</h2>
<p>To wrap up, our SOL-guided performance triage method does the following, for any given GPU workload:</p>
<ul>
<li>Check the “<strong>Top SOL%”</strong>&nbsp;value (Section <a href="https://devblogs.nvidia.com/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/#4.2">4.2</a>).
<ul>
<li>If &gt; 80% =&gt; (A) try removing work from the top SOL unit (Section <a href="#5.2.1">5.2.1</a>).</li>
<li>If &lt; 60% =&gt; (B) try increasing the top SOL% (Sections <a href="https://devblogs.nvidia.com/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/#5.2.2">5.2.2</a> and <a href="https://devblogs.nvidia.com/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/#5.1">5.1</a>). If the SM is the top SOL unit, try increasing the SM occupancy (number of active warps in flight) and reducing the number of SM issue-stall cycles (Section <a href="https://devblogs.nvidia.com/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/#5.2.2">5.2.2</a>).</li>
<li>Else do both (A) and (B).</li>
</ul>
</li>
<li>If some other unit is the Top SOL unit, try reducing the amount of work sent to this unit. (see Section <a href="#5.3">5.3</a>).</li>
</ul>
<p>To use this method, all you need to have is&nbsp;<u><a href="https://developer.nvidia.com/nsight-visual-studio-edition" target="_blank" rel="noopener">Nsight Visual Studio Edition</a></u>&nbsp;or&nbsp;<u><a href="https://developer.nvidia.com/nsight-graphics" target="_blank" rel="noopener">Nsight Graphics</a></u>, as well as the latest available graphics drivers installed.</p>
<h2 id="appendix1">Appendix: Performance&nbsp;Triage Examples</h2>
<h3 id="example1">Example 1: TEX-Throughput Limited Workload</h3>
<p>The HBAO+ “DrawBlurXPS” full-screen pixel shader workload running on GTX 1660 @ 1530 Mhz has the following metrics in the Nsight Range Profiler:</p>
<ul>
<li>Top SOLs: TEX:86.5% | SM:68.0% | CROP:37.9% | VRAM:25.2%</li>
<li>Graphics/Compute Idle: 0.0%</li>
<li>SM Active: 98.7%</li>
<li>SM Occupancy (FOOTNOTE[sm__warps_active.avg.pct_of_peak_sustained_elapsed on Turing]): 95.9%</li>
<li>TEX hit rate: 91.6%</li>
<li>L2 hit rate: 75.0%&nbsp;</li>
</ul>
<p>Analysis:</p>
<ul>
<li>Because the top SOL unit is TEX and the TEX SOL% is greater than 80%, we know that the workload is mainly limited by the throughput of the TEX unit.</li>
<li>“Graphics/Compute Idle” is 0.0% =&gt; not CPU limited (see Section <a href="https://devblogs.nvidia.com/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/#5.1.1">5.1.1</a>).</li>
<li>“SM Active” &gt; 95% =&gt; no SM idleness issue (see Section <a href="https://devblogs.nvidia.com/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/#5.1.2">5.1.2</a>).</li>
<li>The TEX hit rate is great (&gt; 90%) and the L2 hit rate is OK (&gt;70%).</li>
</ul>
<p><strong>Conclusion</strong><strong>:</strong>&nbsp;This workload is primarily TEX-throughput limted and the only way to speed it up significantly is to&nbsp;reduce the number of executed TEX instructions (e.g. by using Gather instructions to do 4 single-channel loads in one TEX instruction, or by calculating multiple output values per thread and sharing texture samples via registers).</p>
<h3 id="example2">Example 2: Math-Limited workload</h3>
<p>The HBAO+ “DrawCoarseAOPS” workload has the following metrics in the Range Profiler on GTX 1060 @ 1506 Mhz:</p>
<ul>
<li>Graphics/Compute Idle: 0.0% =&gt; not CPU limited (see section <a href="#5.1.1">5.1.1</a>)</li>
<li>SM Active: 99.0% =&gt; no SM idleness issue (see section <a href="#5.2.2">5.1.2</a>)</li>
<li>Top SOLs:</li>
<li>SM:92.4% | TEX:81.7% | L2:50.0% | VRAM:32.6% | CROP:7.2%</li>
<li>Top SM sub-SOL metric: pipe_fma_cycles_active:92.4%</li>
</ul>
<p>Top SOL analysis:</p>
<ul>
<li>The top SOL unit is the SM, which is running at 92% of its maximum throughput.</li>
<li>The top SM sub-SOL unit is the SM FMA pipe (see Section 5.2.1).</li>
<li>The second SOL unit is TEX, right behind the SM, with TEX SOL% at 82%.</li>
<li>The other SOL units (L2, VRAM and CROP) are more than 20% behind SM and TEX, so we know that the workload is mainly limited by the SM-FMA and TEX throughputs.</li>
</ul>
<p>Now, let’s make the following thought experiment: if the TEX unit in this GPU was somehow made infinitely fast, the workload would still be limited by the SM at 92%&nbsp;of the SM SOL. Some of that work is typically texture fetches from shaders, so if the TEX unit was made infinitely fast and the SM was initially limited by the TEX latency, the SM SOL may increase. But because 95% is as high as SOL% values get in practice, we know that there is no way the SM SOL% can increase significantly by making any other units go faster (or process less work), and therefore we know that the only way to speedup this workload significantly is to figure out what are the internal performance limiters within the SM.</p>
<p>In this workload, the FMA-pipe SM sub-SOL metric is 92%. This indicates that the performance limiter of this workload is the FMA-pipe throughput, and the only way to speed it up is by removing FMA-pipe instructions (fp32 {FADD, FMUL, FMAD, …} ops or int {IMUL,IMAD} ops).</p>
<p>Additional analysis:</p>
<ol>
<li>Because “SM Throughput for Active Cycles” &gt; 80%, we know that the workload is not significantly limited by the SM occupancy,&nbsp;that is,&nbsp;increasing the number of active warps per active cycles would not significantly improve performance.</li>
<li>The Warp Stall reasons do not matter since the performance is&nbsp;mainly issue-throughput limited (“SM Throughput For Active Cycles” &gt; 80%), and not warp-latency limited.</li>
<li>We can infer that the performance is not primarily limited by the TEX unit, otherwise we would have the TEX SOL% value being much closer to the SM SOL% value.</li>
</ol>
<p><strong>Conclusion: </strong>This workload is primarily limited by the number of math instructions (FP32 ops and/or integer ops and/or other math ops such as rsqrt, pow, cos/sin, etc) in the shader.&nbsp;To speed it up, one needs to find a way to somehow shade less pixels or execute less math instructions per pixel.</p>
<h3 id="example3">Example 3: TEX-Latency Limited workload</h3>
<p>Now, let’s take a look at the “Advanced Motion Blur” DX11 SDK sample from <u><a href="https://github.com/NVIDIAGameWorks/D3DSamples" target="_blank" rel="noopener">https://github.com/NVIDIAGameWorks/D3DSamples</a></u></p>
<figure id="attachment_11992" aria-labelledby="figcaption_attachment_11992"><img src="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-5-1024x576.png" alt="Advanced motion blur example" width="1024" height="576" srcset="https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-5-1024x576.png 1024w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-5-300x169.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-5-768x432.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-5-625x352.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-5-500x281.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-5-160x90.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-5-362x204.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-5-196x110.png 196w, https://devblogs.nvidia.com/wp-content/uploads/2018/09/pasted-image-0-5.png 1600w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption id="figcaption_attachment_11992">Figure 15. Advanced motion blur example.</figcaption></figure>
<p>By default, the app is running in 720p windowed mode. To make it start in 4K full-screen&nbsp;mode, I’ve made the following edit in main.cpp:</p>
<pre><span>#if 0</span>
<span>     deviceParams.startfull-screen = false;</span>
<span>     deviceParams.backBufferWidth = 1280;</span>
<span>     deviceParams.backBufferHeight = 720;</span>
<span>#else</span>
     deviceParams.startfull-screen = <span>true</span>;
     deviceParams.backBufferWidth = 3840;
     deviceParams.backBufferHeight = 2160;
<span>#</span><span>endif</span>
</pre>
<p>Next, we can manually insert a workload marker in main.cpp, which will be intercepted by NSight and become a “Perf Marker” Range in the Range Profiler:</p>
<pre><span>if</span> (g_view_mode == VIEW_MODE_FINAL
{
     D3DPERF_BeginEvent(0x0, <span>L"</span><span>Final Pass</span><span>"</span>);
<span>     //...</span>
     ctx --&gt; Draw(6,0)
     D3DPERF_EndEvent();
}
</pre>
<p>And finally we can profile this workload using the Nsight Range Profiler. On GTX 1060 @ 1506 Mhz, the Range Profiler provides the following metrics:</p>
<ul>
<li>Top SOLs: SM:39.4% | TEX:35.9% | VRAM:21.6% | L2:19.7% | CROP:18.4%</li>
<li>GPU Elapsed Time: 0.15 ms</li>
<li>GPU Idle: 0.0%</li>
<li>SM Active: 89.0%</li>
<li>SM Active Min/Max Delta: 14.2%</li>
<li>SM Occupancy (FOOTNOTE[sm__warps_active.avg.pct_of_peak_sustained_elapsed on Turing]): 53.4%</li>
<li>Top Warp Stall Reason: Long Scoreboard: 72.5%</li>
<li>TEX hit rate: 78.4%</li>
<li>L2 hit rate: 65.0%</li>
</ul>
<p>Analysis:</p>
<ul>
<li>“Graphics/Compute Idle” is 0.0% =&gt; not CPU limited (see section 5.1.1)</li>
<li>The “SM Active” (average) metric is lower than 95%, which is low for a full-screen pixel shader pass. The “SM Active Min/Max Delta” is relatively high which means some SMs are idle while other SMs are active during this workload execution. This may be caused by very uneven warp latencies.</li>
<li>The top SOL% units are SM and TEX.</li>
<li>The top SOL% value is below 60%, so this workload is running inefficiently on the GPU.</li>
<li>The workload is completely <strong>TEX-</strong><strong>latency limited</strong>&nbsp;because “SM Throughput for Active Cycles” is far below 60%, the top warp-stall reason is the Long Scoreboard, and that Warp Stall Long Scoreboard% is&nbsp; much higher than 10%.</li>
<li>The workload is also <strong>SM-occupancy limited </strong>(meaning having more active warps in flight should improve performance), since the top SOL unit is the SM and “SM SOL%” &lt; 80% (see section <a href="#5.2.2">5.2.2</a>).</li>
<li>The TEX hit rate is good, but the L2 hit rate is quite poor (&lt;70%).</li>
</ul>
<h4>Experiment: Removing the Early Exit</h4>
<p>From Section <a href="#5.2.2">5.2.2</a>, we know that for workloads with the SM as top SOL unit, “SM SOL%” &lt; 80% and “SM Throughput for Active Cycles” &lt; 60%, and “Long Scoreboard” is the top warp-stall reason, the performance may be limited by:</p>
<ul>
<li>High TEX latencies (due to not having enough Instruction Level Parallelism to hide the instruction latencies), and/or</li>
<li>Low SM occupancy (due to not having enough active warps to hide the issue stalls).</li>
</ul>
<p>Let us determine the main cause of&nbsp;the low SM occupancy first. To do so, we can query the following warp cant-launch reason metrics for pixel shaders, in the User Metrics section of the Range Profiler:</p>
<ul>
<li>“tpc__warp_launch_cycles_stalled_shader_ps_reason_ooo_warp_completion.avg.pct_of_peak_sustained_elapsed”: 56.3%</li>
<li>“tpc__warp_launch_cycles_stalled_shader_ps_reason_register_allocation.avg.pct_of_peak_sustained_elapsed”: 0.0%</li>
</ul>
<p>Therefore, the main occupancy limiter is “shader_ps_reason_ooo_warp_completion” which means that pixel-shader warps are completing out-of-order compared to their launch order. This happens when pixel shaders running on the same SM have variable warp latencies.</p>
<p>We know that this pixel shader has an early-exit branch, and by outputting a debug color if the branch is taken, we can see that most of the pixels are taking the early exit. To verify that the early-exit branch is actually limiting the occupancy, let us do the experiment of simply removing it from the pixel shader&nbsp;(ps_gather.hlsl):</p>
<pre><span>#if 0</span>
<span>     // If the velocities are too short, we simply show the color texel and exit</span>
<span>     if (TempNX &lt; HALF_VELOCITY_CUTOFF)</span>
<span>     {</span>
<span>           return CX;</span>
<span>     }</span>
<span>#endif</span>
</pre>
<div><table>
<caption>Table 1. New metrics&nbsp;with the early-exit branch removed.</caption>
<tbody>
<tr>
<td>Metric</td>
<td>New value</td>
<td>Old value</td>
<td>New / Old</td>
</tr>
<tr>
<td>GPU Elapsed Time</td>
<td><strong>0.79 ms</strong></td>
<td>0.15 ms</td>
<td>5.27x</td>
</tr>
<tr>
<td>Top SOL[0]</td>
<td>SM:67.1%</td>
<td>SM:39.4%</td>
<td>1.70x</td>
</tr>
<tr>
<td>Top SOL[1]</td>
<td><strong>TEX:85.8%</strong></td>
<td>TEX:35.9%</td>
<td>2.39x</td>
</tr>
<tr>
<td>SM Active</td>
<td><strong>99.4%</strong></td>
<td>89.0%</td>
<td>1.12x</td>
</tr>
<tr>
<td>SM Active Min/Max Delta</td>
<td><strong>0.6%</strong></td>
<td>14.2%</td>
<td>0.04x</td>
</tr>
<tr>
<td>SM Occupancy</td>
<td><strong>95.0%</strong></td>
<td>53.4%</td>
<td>1.78x</td>
</tr>
<tr>
<td>SM Warp Launch Stall Reason: Pixel-Shader OOO Warp Completion</td>
<td><strong>0.2%</strong></td>
<td><strong>56.4%</strong></td>
<td>0.00x</td>
</tr>
<tr>
<td>SM Issue Stall Reason: <br>
Long Scoreboard</td>
<td>62.4%</td>
<td>72.5%</td>
<td>0.86x</td>
</tr>
<tr>
<td>TEX hit rate</td>
<td>76.8%</td>
<td>78.4%</td>
<td>0.98x</td>
</tr>
<tr>
<td>L2 hit rate</td>
<td><strong>96.2%</strong></td>
<td>65.0%</td>
<td>1.48x</td>
</tr>
</tbody>
</table></div>
<p>We see that the new workload is<strong>&nbsp;</strong>still <strong>SM-occupancy limited, </strong>but the occupancy (95%) is reaching the hardware limit. And even with this almost-maxed-out occupancy, we see that the workload is still <strong>TEX-latency limited</strong>.</p>
<p>Obviously, the workload has become 5x slower due to the removal of the early exit,&nbsp;but that’s OK: we’ve confirmed that the initial implementation had very poor top SOL% value and a poor SM occupancy due to the variable pixel-shader warp latencies.</p>
<p>Conclusion:</p>
<p>The main reason for the poor SM occupancy in this workload is that the pixel-shader has an early-exit. Moving this pixel shader to a compute shader can alleviate this problem&nbsp;(warps that complete sooner than others within a given thread group would still limit the SM occupancy), but would also add some overhead for writing out the results via UAV write instructions. Implementing the full-screen pass with a pixel classification pass followed by a DispatchIndirect call that launches threads only for the “complex pixels” would be more efficient.</p>
<p>Alternatively, using the stencil-masking approach described in Section <a href="#5.2.2">5.2.2</a> should also help in this case, as it would make the full-screen pixel shader process the complex pixels only and all of these pixels would complete in launch order.</p>
<h2 id="appendix2">Appendix: Optimizing Ray-Marching Loops</h2>
<p>As mentioned in Section <a href="#5.2.2">5.2.2</a> (“reducing the SM issue-stall latencies”), dynamic loops<a target="_blank" rel="noopener">[2]</a>&nbsp;containing TEX instructions can be limited by the latency of the TEX instructions and the fact that there are no independent instructions that can be scheduled from the same warp (no instruction level parallelism), and that the number of active warps in the SM is insufficient to fully hide the TEX latency.</p>
<p>This happens commonly in ray-marching dynamic loops, which are typically used in <u><a href="https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/ScreenSpaceReflection/" target="_blank" rel="noopener">Screen-Space Reflections</a></u>&nbsp;(SSR) shaders, as well as <u><a href="https://www.gdcvault.com/play/1023002/Low-Complexity-High-Fidelity-INSIDE" target="_blank" rel="noopener">ray-marched volumetric lighting</a></u>.</p>
<p>A typical SSR ray-marching loop with early exit looks like this in HLSL:</p>
<pre><span>float</span> MinHitT = 1.0;
<span>float</span> RayT = Jitter * Step + Step;

[loop] <span>for</span> ( <span>int</span> i = 0; i &lt; NumSteps; i++ )
{
     float3 RayUVZ = RayStartUVZ + RaySpanUVZ * RayT;
<span>     float</span> SampleDepth = Texture.SampleLevel( Sampler, RayUVZ.xy, GetMipLevel(i) ).r;

<span>     float</span> HitT = GetRayHitT(RayT, RayUVZ, SampleDepth, Tolerance);
     [branch] <span>if</span> (HitT &lt; 1.0)
     {
          MinHitT = HitT;
<span>          break</span>;
     }

     RayT += Step;
}
</pre>
<p>By&nbsp;partially unrolling&nbsp;the loop 2 times and placing the texture-fetch instructions back-to-back in the HLSL, the batches of independent texture instructions can be executed together in parallel, and the latency of the second fetch can be partly hidden by the latency of the first one.</p>
<p>The resulting HLSL then looks like this, assuming that NumSteps is a multiple of 2:</p>
<pre><span>float</span> MinHitT = 1.0;
<span>float</span> RayT = Jitter * Step + Step;
[loop] <span>for</span> ( <span>int</span> i = 0; i &lt; NumSteps; i += 2 )
{
<span>     float</span> RayT_0 = RayT;
<span>     float</span> RayT_1 = RayT + Step;

     float3 RayUVZ_0 = RayStartUVZ + RaySpanUVZ * RayT_0;
     float3 RayUVZ_1 = RayStartUVZ + RaySpanUVZ * RayT_1;

<span>     // batch texture instructions to better hide their latencies</span>
<span>     float</span> SampleDepth_0 = Texture.SampleLevel( Sampler, RayUVZ_0.xy, GetMipLevel(i+0) ).r;
<span>     float</span> SampleDepth_1 = Texture.SampleLevel( Sampler, RayUVZ_1.xy, GetMipLevel(i+1) ).r;

<span>     float</span> HitT_0 = GetRayHitT(RayT_0, RayUVZ_0, SampleDepth_0, Tolerance);
<span>     float</span> HitT_1 = GetRayHitT(RayT_1, RayUVZ_1, SampleDepth_1, Tolerance);

     [branch] <span>if</span> (HitT_0 &lt; 1.0 || HitT_1 &lt; 1.0)
     {
          MinHitT = <span>min</span>(HitT_0, HitT_1);
<span>          break</span>;
     }

     RayT += Step * 2.0;
}
</pre>
<p>By implementing the above optimization on a SSR test app in 4K on GTX 1080 @ 1607 Mhz, the elapsed GPU time on the SSR workload went from 0.54 ms to 0.42 ms (29% speedup on the workload). By going further and batching 4 texture fetches instead of 2, the GPU time went down to 0.33 ms (64% speedup on the workload: 0.54 -&gt; 0.33 ms / frame).</p>

<p>This blog post would not have been possible without the help of Marc Blackstein, Ram Rangan, and Zhen Yang who have taught me &amp; NVIDIA’s DevTech group the SOL-guided performance triage method presented in this blog post.</p>
<p>I would like to thank the following NVIDIAns for their valuable expertise and feedback:</p>
<ul>
<li>Avinash Baliga</li>
<li>Iain Cantlay</li>
<li>Jon Jansen</li>
<li>Alfred Junklewitz</li>
<li>Jeff Kiel</li>
<li>Justin Kim</li>
<li>Christoph Kubisch</li>
<li>Axel Mamode</li>
<li>Patrick Neill</li>
<li>Suryakant Patidar</li>
<li>Aurelio Reis</li>
<li>Mathias Schott</li>
<li>Greg Smith</li>
<li>John Spitzer</li>
<li>Nick Stam</li>
<li>Fabian Thuering</li>
<li>Yury Uralsky</li>
</ul>
<p><a target="_blank" rel="noopener">[1]</a>&nbsp;As can be found on <u><a href="https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units" target="_blank" rel="noopener">wikipedia</a></u>, the GeForce 600 and 700 series are mostly Kepler, the 900 series is Maxwell, the 1000 series is Pascal, TITAN V is Volta, and the RTX 20 and GTX 16 series are Turing.</p>
<p><a target="_blank" rel="noopener">[2]</a>&nbsp;Dynamic loops are loops whose iteration counts are not known at HLSL compilation time.</p>

                    

                    
                </div>
            </article>
        
    </div>
</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>