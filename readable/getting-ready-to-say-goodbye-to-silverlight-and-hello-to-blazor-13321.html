<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Getting ready to say goodbye to Silverlight and hello to Blazor - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Getting ready to say goodbye to Silverlight and hello to Blazor - linksfor.dev(s)"/>
    <meta property="article:author" content="Louis Hendricks"/>
    <meta property="og:description" content="What I didn&#x2019;t know at the time was that the December 9th release of Silverlight 5 in 2011 would be the final release of my then favorite&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@haywireiv/getting-ready-to-say-goodbye-to-silverlight-and-hello-to-blazor-477d5ca88a32"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Getting ready to say goodbye to Silverlight and hello to Blazor</title>
<div class="readable">
        <h1>Getting ready to say goodbye to Silverlight and hello to Blazor</h1>
            <div>by Louis Hendricks</div>
            <div>Reading time: 8-10 minutes</div>
        <div>Posted here: 06 Apr 2019</div>
        <p><a href="https://medium.com/@haywireiv/getting-ready-to-say-goodbye-to-silverlight-and-hello-to-blazor-477d5ca88a32">https://medium.com/@haywireiv/getting-ready-to-say-goodbye-to-silverlight-and-hello-to-blazor-477d5ca88a32</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><p id="93f8" data-selectable-paragraph="">This is not everything that’s needed to build an application, this is just most of the parts that I need for modifying my system that is already in place. This is also aimed at my specific application needs but there should be enough information for anyone already using Silverlight and WCF to implement this. Here is step by step how I did everything mentioned above.</p><p id="1034" data-selectable-paragraph="">I created a Web API project using .Net Core 2.1 in Visual Studio 2019. The Web API are the Silverlight client are going to have different origins so I added CORS code to configuration in Startup.cs (allowing everything from everywhere for testing):</p><pre><span id="6090" data-selectable-paragraph="">services.AddCors(options =&gt;</span><span id="56ab" data-selectable-paragraph="">{</span><span id="9dc9" data-selectable-paragraph="">options.AddPolicy("EnableCORS", builder =&gt;</span><span id="67dd" data-selectable-paragraph="">{</span><span id="e01a" data-selectable-paragraph="">builder.AllowAnyOrigin().AllowAnyHeader().AllowAnyMethod()<br>.AllowCredentials().Build();</span><span id="6eea" data-selectable-paragraph="">});</span><span id="578f" data-selectable-paragraph="">});</span></pre><p id="9927" data-selectable-paragraph="">Accompanied by adding it to the configure method:</p><pre><span id="29b8" data-selectable-paragraph="">app.UseCors("EnableCORS");</span></pre><p id="13e8" data-selectable-paragraph="">Silverlight also refuses to access any services from a different origin so to make Silverlight happy I needed to make the server give it a <code>clientaccesspolicy.xml</code> file. This file needs to be right under the wwwroot folder and will look like so when there are no restrictions in place:</p><pre><span id="b6b2" data-selectable-paragraph="">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span id="d7aa" data-selectable-paragraph="">&lt;access-policy&gt;</span><span id="39c6" data-selectable-paragraph="">&lt;cross-domain-access&gt;</span><span id="8583" data-selectable-paragraph="">&lt;policy&gt;</span><span id="8f83" data-selectable-paragraph="">&lt;allow-from http-request-headers="*"&gt;</span><span id="864d" data-selectable-paragraph="">&lt;domain uri="*"/&gt;</span><span id="6f30" data-selectable-paragraph="">&lt;domain uri="http://*"/&gt;</span><span id="45f6" data-selectable-paragraph="">&lt;domain uri="https://*"/&gt;</span><span id="16c4" data-selectable-paragraph="">&lt;/allow-from&gt;</span><span id="0794" data-selectable-paragraph="">&lt;grant-to&gt;</span><span id="5c4d" data-selectable-paragraph="">&lt;resource path="/" include-subpaths="true"/&gt;</span><span id="73cf" data-selectable-paragraph="">&lt;/grant-to&gt;</span><span id="0ad1" data-selectable-paragraph="">&lt;/policy&gt;</span><span id="e94b" data-selectable-paragraph="">&lt;/cross-domain-access&gt;</span><span id="a844" data-selectable-paragraph="">&lt;/access-policy&gt;</span></pre><p id="a55e" data-selectable-paragraph="">An interesting thing to note was that this actually didn’t work as originally written with just &lt;domain uri=”*”/&gt; in the file. I had to add the two additional domain entries to get it to work. By default .Net Core is not going to serve this file up. In order to have it become accessible to the client I had to add the following line of code to Configure in Startup.cs:</p><pre><span id="3519" data-selectable-paragraph="">app.UseStaticFiles();</span></pre><p id="f3b5" data-selectable-paragraph="">With that set up I then moved on to configuring Authentication on the server. I added the following code to the ConfigureServices method in Startup.cs and then did a few Quick Actions to resolve the dependencies:</p><pre><span id="dff2" data-selectable-paragraph="">//security key</span><span id="31ef" data-selectable-paragraph="">string securityKey = "Never put your secret key in your code because that would be bad";</span><span id="bd24" data-selectable-paragraph="">//symmetric security key</span><span id="7acb" data-selectable-paragraph="">var symmetricSecurityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(securityKey));</span><span id="7608" data-selectable-paragraph="">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><span id="7bf5" data-selectable-paragraph="">.AddJwtBearer(options =&gt;</span><span id="d5f7" data-selectable-paragraph="">{</span><span id="a14c" data-selectable-paragraph="">options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters</span><span id="738d" data-selectable-paragraph="">{</span><span id="763d" data-selectable-paragraph="">ValidateIssuer = true,</span><span id="639e" data-selectable-paragraph="">ValidateAudience = true,</span><span id="bc72" data-selectable-paragraph="">ValidateIssuerSigningKey = true,</span><span id="f476" data-selectable-paragraph="">ValidIssuer = "lou.com",</span><span id="b1a4" data-selectable-paragraph="">ValidAudience = "readers",</span><span id="fb7c" data-selectable-paragraph="">IssuerSigningKey = symmetricSecurityKey</span><span id="0b6a" data-selectable-paragraph="">};</span><span id="1dc8" data-selectable-paragraph="">}</span><span id="19a2" data-selectable-paragraph="">);</span></pre><p id="2399" data-selectable-paragraph="">To make that work I then added a line in Configure as well:</p><pre><span id="28d8" data-selectable-paragraph="">app.UseAuthentication();</span></pre><p id="a8a3" data-selectable-paragraph="">Because I was building a test environment to see if I could actually get everything to work I worked on the default ValuesController that gets created by the Web API template. The first thing I did was add an [Authorize] attribute directly below the [ApiController] attribute on the ValuesController class. Next I created a test class with another test class that I would pass back and forth to see if my REST calls and serialization and deserialization would actually work. I called my class Foo() and gave it two public string properties and nested another class Bar() with a public string property inside of it. I then set up this method in the ValuesController for my Silverlight client to attempt to call:</p><pre><span id="2178" data-selectable-paragraph="">// POST api/values/RetrieveFooFromServer</span><span id="caef" data-selectable-paragraph="">[HttpPost("[action]")]</span><span id="a643" data-selectable-paragraph="">public ActionResult&lt;Foo&gt; RetrieveFooFromServer([FromBody] Foo value)</span><span id="5cc1" data-selectable-paragraph="">{</span><span id="43e6" data-selectable-paragraph="">try</span><span id="7b68" data-selectable-paragraph="">{</span><span id="b8d3" data-selectable-paragraph="">Foo result = new Foo();</span><span id="bfc6" data-selectable-paragraph="">result.Bar = value.Bar + " received";</span><span id="659b" data-selectable-paragraph="">result.Ear.Car = "We are nested";</span><span id="599a" data-selectable-paragraph="">return Ok(result);</span><span id="2dbf" data-selectable-paragraph="">}</span><span id="c392" data-selectable-paragraph="">catch</span><span id="25f6" data-selectable-paragraph="">{</span><span id="f5a5" data-selectable-paragraph="">return BadRequest();</span><span id="195a" data-selectable-paragraph="">}</span><span id="3ff8" data-selectable-paragraph="">}</span></pre><p id="1619" data-selectable-paragraph="">A direct port of my existing business logic will result in all of my WCF service calls needing to be [HttpPost(“[action]”)] to named methods and receiving and returning C# classes so this is what I tested. At this point all of the configuration is done on the server side although it’s not testable as is because I don’t have code to generate my JWT yet.</p></div></div></section><section><div><div><p id="68d6" data-selectable-paragraph="">The next step was to have my ASP.Net web page pass a JWT bearer token to the Silverlight client after the user signs in. I opened up NuGet package manager and added the following package to the Web project:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*_dZxFLgGmeoAwYav4W5yWw.png?q=20" width="855" height="221" role="presentation"></p><p><img width="855" height="221" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">System.IdentityModel.Tokens.Jwt</figcaption></figure><p id="e049" data-selectable-paragraph="">This then pulled down a few more packages as dependencies. I then put the following code to generate my JWT into a service method in one of my WCF services that returns a string so that the Silverlight client could retrieve the token after the user logged in:</p><pre><span id="70e4" data-selectable-paragraph="">//return queryString + " Success";</span><span id="7790" data-selectable-paragraph="">//security key</span><span id="f307" data-selectable-paragraph="">string securityKey = "Never put your secret key in your code because that would be bad";</span><span id="2a0f" data-selectable-paragraph="">//symmetric security key</span><span id="299c" data-selectable-paragraph="">var symmetricSecurityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(securityKey));</span><span id="cc57" data-selectable-paragraph="">//credentials for signing token</span><span id="df34" data-selectable-paragraph="">var signingCredentials = new SigningCredentials(symmetricSecurityKey, SecurityAlgorithms.HmacSha256Signature);</span><span id="d1ca" data-selectable-paragraph="">//add claims</span><span id="409e" data-selectable-paragraph="">var claims = new List&lt;Claim&gt;();</span><span id="3d3a" data-selectable-paragraph="">claims.Add(new Claim(ClaimTypes.Role, "User"));</span><span id="b815" data-selectable-paragraph="">//create token</span><span id="6db2" data-selectable-paragraph="">var token = new JwtSecurityToken(</span><span id="4521" data-selectable-paragraph="">issuer: "lou.com",</span><span id="362a" data-selectable-paragraph="">audience: "readers",</span><span id="8fde" data-selectable-paragraph="">expires: DateTime.Now.AddHours(1),</span><span id="c1b1" data-selectable-paragraph="">signingCredentials: signingCredentials,</span><span id="f89a" data-selectable-paragraph="">claims: claims</span><span id="579a" data-selectable-paragraph="">);<br></span><span id="4156" data-selectable-paragraph="">//return token</span><span id="c05a" data-selectable-paragraph="">return new JwtSecurityTokenHandler().WriteToken(token);</span></pre><p id="0f44" data-selectable-paragraph="">At this point I can log into my Silverlight client and pull down the JWT bearer token from the server to my client. The last step is to actually make the REST call to Web API from Silverlight.</p><p id="38c8" data-selectable-paragraph="">I think I downloaded seven different REST packages from NuGet and I think I managed to fail to get at least five of them to communicate with the server. Most of the packages are either no longer being developed or have dropped support for Silverlight at this point. The one that worked for me and gave me clean, readable code was RestSharp. Starting with version 106.0.0 Silverlight support was dropped but I was able to pull 105.2.3 down from NuGet and it works.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*KFb1UJT06i6nzKv9OWNUTA.png?q=20" width="779" height="265" role="presentation"></p><p><img width="779" height="265" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">RestSharp 105.2.3</figcaption></figure><p id="791c" data-selectable-paragraph="">Following code examples I read online I wound up building two methods, one to build the request and one with generics to execute the result and retrieve the return value. The code looks like this:</p><pre><span id="d869" data-selectable-paragraph="">static async Task&lt;string&gt; TestRestSharpWebAPICall(string token)</span><span id="a7cd" data-selectable-paragraph="">{</span><span id="6d4d" data-selectable-paragraph="">Foo foo = new SilverlightAsyncTest.Foo();</span><span id="e2c9" data-selectable-paragraph="">var request = new RestRequest("/api/values/RetrieveFooFromServer", Method.POST);</span><span id="c3b5" data-selectable-paragraph="">request.RequestFormat = DataFormat.Json;</span><span id="e42a" data-selectable-paragraph="">request.AddParameter("Authorization", "Bearer " + token, ParameterType.HttpHeader);</span><span id="ed3d" data-selectable-paragraph="">request.AddJsonBody(foo);</span><span id="fcd3" data-selectable-paragraph="">Foo result = await ExecuteAsync&lt;Foo&gt;(request);</span><span id="7ff9" data-selectable-paragraph="">return result.Bar;</span><span id="b98b" data-selectable-paragraph="">}</span><span id="c901" data-selectable-paragraph="">static Task&lt;T&gt; ExecuteAsync&lt;T&gt;(RestRequest request) where T : new()</span><span id="cfd7" data-selectable-paragraph="">{</span><span id="5106" data-selectable-paragraph="">var client = new RestClient("https://localhost:44311");</span><span id="c1ed" data-selectable-paragraph="">var taskCompletionSource = new TaskCompletionSource&lt;T&gt;();</span><span id="ac45" data-selectable-paragraph="">client.ExecuteAsync&lt;T&gt;(request, (response) =&gt; taskCompletionSource.SetResult(response.Data));</span><span id="b842" data-selectable-paragraph="">return taskCompletionSource.Task;</span><span id="983e" data-selectable-paragraph="">}</span></pre><p id="4cd7" data-selectable-paragraph="">In the var request statement in the test method I put in the /api/values/RetrieveFooFromServer path for the ValuesController that was configured in the Web API project. In the var client statement in ExecuteAsync&lt;t&gt;() I put localhost along with the port that the WebAPI client was being run on when I started debugging it in Visual Studio.</p><p id="9087" data-selectable-paragraph="">When I got to the point where all of this was complete and in place I was able to launch the Web API from Visual Studio 2019 then launch the Silverlight client from Visual Studio 15 and have it call the Web API successfully and submit the object and retrieve an object back. None of this worked on the first try and I did a lot of reading and a lot of trial and error but I now have a working configuration which is what I have presented in this article. The next step for me is to put it in place in my development environment with real business cases and proper settings and security. Once that passes some tests I can start converting my systems over to Web API and prepping for the eventual release of Blazor 1.0 (or going with my fallback plan of Angular).</p></div></div></section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>