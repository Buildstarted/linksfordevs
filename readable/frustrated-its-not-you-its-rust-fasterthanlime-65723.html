<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Frustrated? It&#x27;s not you, it&#x27;s Rust - fasterthanli.me - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Frustrated? It&#x27;s not you, it&#x27;s Rust - fasterthanli.me - linksfor.dev(s)"/>
    <meta property="og:description" content="Learning Rust is... an experience. An emotional journey. I&#x27;ve rarely been&#xA;more frustrated than in my first few months of trying to learn Rust. What makes it worse is that it doe..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://fasterthanli.me/articles/frustrated-its-not-you-its-rust"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Frustrated? It&#x27;s not you, it&#x27;s Rust - fasterthanli.me</title>
<div class="readable">
        <h1>Frustrated? It&#x27;s not you, it&#x27;s Rust - fasterthanli.me</h1>
            <div>Reading time: 54-69 minutes</div>
        <div>Posted here: 16 Aug 2020</div>
        <p><a href="https://fasterthanli.me/articles/frustrated-its-not-you-its-rust">https://fasterthanli.me/articles/frustrated-its-not-you-its-rust</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
  

  <p>Learning Rust is... an experience. An emotional journey. I've rarely been
more frustrated than in my first few months of trying to learn Rust.</p>
<p>What makes it worse is that it doesn't matter how much prior experience you
have, <a href="https://fasterthanli.me/articles/i-am-a-java-csharp-c-or-cplusplus-dev-time-to-do-some-rust">in Java, C#, C or
C++</a> or
otherwise - it'll still be unnerving.</p>
<p>In fact, <em>more</em> experience probably makes it worse! The habits have settled
in deeper, and there's a certain expectation that, by now, you should be able
to get that done in a shorter amount of time.</p>
<p>Maybe, after years of successfully shipping code, you don't have quite the
same curiosity, the same candor and willingness to feel "lost" that you did
back when you started.</p>
<p>Learning Rust makes you feel like a beginner again - why is this so hard?
This doesn't feel like it should be that hard. I've done similar things
before. I know what I want. Now I just need to... make it happen.</p>
<p>I'm going to keep including introductions like these in all my beginner-level
articles, because they're very important: if you're picking up Rust, expect
roadblocks. Telling you that "you'll be up to speed in no time" would be a
flat out lie, and I'm <a href="https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride">not big on
lying</a>.</p>
<p>There is, however, a very good reason learning is so hard. When you switch
from another language to Rust, you're not switching from French to Spanish -
you're not just learning new vocabulary, so that you can say the same things,
only they're spelled and pronounced different.</p>
<p>You're learning new vocabulary <em>and</em> learning to talk about topics you've
never had to discuss before. You're learning a completely new communication
style. And speech (spoken or written) is so fundamental to so many of us,
<em>starting over</em> is extremely unsettling.</p>
<p>You encounter problems that you cannot frame using any of your prior
knowledge. Writing Rust involves playing by a set of rules, that you won't be
able to describe by analogy to other languages. Which adds another level of
difficulty on top: often, you won't even be able to <em>describe</em> what's wrong,
to get some help.</p>
<p>General-purpose search engines are <em>fairly useless</em> when it comes to solving
Rust issues. Your best bet is pretty much the Rust compiler itself, and its
diagnostics. That, or, biting the bullet and accepting that you'll have to
go back and read some more beginner-level material before you can come back
to what it is you were trying to do, and have an "ahAH!" moment.</p>
<p>The compiler can only go so far, though - because not only is it, too,
confronted with the difficulty of explaining concepts that have no equivalent
in other languages, but also: it's working from your code, not your mind.</p>
<p>And when you take what's in your mind and put it into code, well, details get
lost - and while those may not matter in other languages, in Rust, they
matter very much.</p>
<p>You see, the crux of the problem is...</p>
<h2>You're smarter than Rust</h2>
<p>I'm not kidding!</p>
<p>This is especially true if you've done a lot of dynamic typing / weak typing work.</p>
<p>Coming from a language such as Python, Ruby, or JavaScript, you're used to writing
functions that look like this:</p>
<pre><p>Rust code</p><p><code><i>// (not actually valid Rust)</i>

<i>fn</i> <i>add</i><i>(</i><i>a</i>, <i>b</i><i>)</i> {
    a + b
}
</code></p></pre>
<p>And when you have a function like that, you know to only call it on things
that can be added together. Numbers, for example. And you know better than to
try and call it with something like... objects, or dictionaries, because then
the result might be nonsensical.</p>
<div>

<p>In JavaScript, for example, the following:</p>
<pre><p>JavaScript code</p><p><code><i>console</i><i>.</i><i>log</i><i>(</i><i>{</i><i>}</i> <i>+</i> <i>{</i><i>}</i><i>)</i><i>;</i>
</code></p></pre>
<p>Prints:</p>
<pre><p><code>[object Object][object Object]
</code></p></pre></div>
<p>Rust, however, is not that smart. First off, it really wants everything to
have a type:</p>
<pre><p>Rust code</p><p><code><i>// (does not compile)</i>

<i>fn</i> <i>add</i><i>(</i><i>a</i>: <i>TypeA</i>, <i>b</i>: <i>TypeB</i><i>)</i> -&gt; <i>TypeResult</i> {
    a + b
}
</code></p></pre>
<p>And we can't just conjure types out of thin air.</p>
<p>We can pick an existing type, like <code>i32</code>:</p>
<pre><p>Rust code</p><p><code><i>// works fine!</i>

<i>fn</i> <i>add</i><i>(</i><i>a</i>: <i>i32</i>, <i>b</i>: <i>i32</i><i>)</i> -&gt; <i>i32</i> {
    a + b
}
</code></p></pre>
<p>But if we want to make our <code>add</code> function work for any two things that can be
added, we have to make our function <em>generic</em> - which is its own rabbit hole.</p>
<pre><p>Rust code</p><p><code><i>// (still doesn't compile)</i>

<i>fn</i> <i>add</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>a</i>: <i>T</i>, <i>b</i>: <i>T</i><i>)</i> -&gt; <i>T</i> {
    a + b
}
</code></p></pre>
<p>But that example still doesn't compile:</p>
<pre><p><code>error[E0369]: cannot add `T` to `T`
 --&gt; src/main.rs:6:7
  |
6 |     a + b
  |     - ^ - T
  |     |
  |     T
  |
help: consider restricting type parameter `T`
  |
5 | fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T {
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></p></pre>
<p>The "help" section there is right on the money - the core of the issue is
that Rust won't let us add two things, unless it knows <em>for sure</em> that
they can be added.</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>ops<i>::</i>Add<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>"ten = {}"</i>, add<i>(</i><i>4</i>, <i>6</i><i>)</i><i>)</i><i>;</i>
}

<i>fn</i> <i>add</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>a</i>: <i>T</i>, <i>b</i>: <i>T</i><i>)</i> -&gt; <i>T</i>
<i>where</i>
    <i>T</i>: <i>Add</i><i>&lt;</i><i>Output</i> = <i>T</i><i>&gt;</i>,
{
    a + b
}
</code></p></pre><div>

<p>Whoa hey, that escalated quickly. What's all that syntax?</p>
</div>
<p>Don't worry about it for now.</p>
<p>Now that we've followed directions, it works, finally:</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
ten = 10
</code></p></pre>
<p>So - you're smarter than Rust. Rust only knows exactly what you tell it. And
you better be clear about what you mean, too!</p>
<p>But there's an upside: spending the time to carefully describe to Rust what
it is you mean, prevents a lot of errors. It prevents <em>entire classes</em> of
errors.</p>
<p>In that simple example, it's fairly obvious: since Rust doesn't have implicit
coercion of all types to <code>string</code> by default, you'll never end up with an
accidental <code>[object Object][object Object]</code>.</p>
<p>And, most importantly, if you were to publish your <code>add</code> function as part of a
<code>crate</code> (an npm package, a gem, an.. egg? or a wheel? y'all, is Python alright?), no one
else could end up with an accidental <code>[object Object][object Object]</code>, too.</p>
<p>Because the types are not just advisory - they're part of the interface of
your library, even when it's used as part of another project.</p>
<div>

<p><code>add() only takes values that can be added together</code> is an
<strong>invariant</strong>.</p>
<p>If you're used to more dynamic / weakly-typed languages, you've been
"maintaining invariants" for a long time - possibly without ever having to
use the word "invariant".</p>
<p>You can also call it an "assumption" - for the entire duration of a call to
<code>add</code>, we <em>assume</em> that <code>a</code> and <code>b</code> can be added together. It's an
"invariant", in the sense that it can never change. If at some point, either
<code>a</code> or <code>b</code> become values that <em>cannot</em> be added together, then our code will
be wrong.</p>
<p>There is a more technical term for "wrong", too - maintaining invariants is
maintaining "soundness". Code that breaks invariants is called "unsound".</p>
<p>In Rust, instead of keeping invariants in mind, we keep them directly in the
code. This allows the compiler to enforce them at compile time.</p>
<p>You can also think of an invariant as a "permanent assertion". C code, for
example, tends to contain a lot of runtime assertions - if we reached this
part of the code, then "ptr" must not be NULL.</p>
<p>The prize, though, is to try and prevent invalid programs from compiling in
the first place - to catch the problem as early as possible. And to only
resort to runtime errors for problems that are too hard to describe, or for
situation involving uncontrolled user input.</p>
</div>
<h2>Rust won't guess, but it <em>will</em> deduce</h2>
<p>You may be taking issue at that previous example. You may find yourself
wanting to argue that a function like this:</p>
<pre><p>Rust code</p><p><code><i>// (again, does not compile)</i>

<i>fn</i> <i>add</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>a</i>: <i>T</i>, <i>b</i>: <i>T</i><i>)</i> -&gt; <i>T</i> {
    a + b
}
</code></p></pre>
<p>...has all the information required for Rust to constrain the type <code>T</code>
itself, so that <code>add</code> can only be called with values that can be added
together.</p>
<p>After all, Rust is able to deduce some things by itself. If you do:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>get_some_numbers</i><i>(</i><i>)</i> -&gt; <i>Vec</i><i>&lt;</i><i>usize</i><i>&gt;</i> {
    <i>vec</i><i>!</i><i>[</i><i>1</i>, <i>2</i>, <i>3</i><i>]</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> v = <i>get_some_numbers</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>...then Rust is able to tell that <code>v</code> is of type <code>Vec&lt;usize&gt;</code>.</p>
<p>You don't have to spell it out, like this:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>get_some_numbers</i><i>(</i><i>)</i> -&gt; <i>Vec</i><i>&lt;</i><i>usize</i><i>&gt;</i> {
    <i>vec</i><i>!</i><i>[</i><i>1</i>, <i>2</i>, <i>3</i><i>]</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>// this `let` binding now has an explicit type:</i>
    <i>let</i> v: <i>Vec</i><i>&lt;</i><i>usize</i><i>&gt;</i> = <i>get_some_numbers</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>Rust also knows about other things.</p>
<p>For example, this C program compiles fine:</p>
<pre><p>C code</p><p><code><i>#include</i> <i>&lt;stdint.h&gt;</i>
<i>#include</i> <i>&lt;stdio.h&gt;</i>

<i>char</i> <i>*</i><i>humanize_number</i>(<i>size_t</i> <i>n</i>) {
    <i>switch</i> (<i>n</i>) {
        <i>case</i> 0:
            <i>return</i> <i>"zero"</i>;
        <i>case</i> 1:
            <i>return</i> <i>"one"</i>;
        <i>case</i> 2:
            <i>return</i> <i>"two"</i>;
    }
}

<i>int</i> <i>main</i>() {
    <i>printf</i>(<i>"0 = %s
"</i>, <i>humanize_number</i>(0));
    <i>printf</i>(<i>"1 = %s
"</i>, <i>humanize_number</i>(1));
    <i>printf</i>(<i>"2 = %s
"</i>, <i>humanize_number</i>(2));
    <i>printf</i>(<i>"3 = %s
"</i>, <i>humanize_number</i>(3));
    <i>return</i> 0;
}
</code></p></pre>
<p>And crashes at runtime:</p>
<pre><p>Shell session</p><p><code>$ gcc main.c -o main &amp;&amp; ./main
0 = zero
1 = one
2 = two
[1]    148103 segmentation fault (core dumped)  ./main
</code></p></pre>
<p>The C compiler <em>knows</em> something is wrong with this code. If we
ask its opinion with <code>-Wall</code>, it'll tell us:</p>
<pre><p>Shell session</p><p><code>$ gcc -Wall main.c -o main
main.c: In function ‘humanize_number’:
main.c:13:1: warning: control reaches end of non-void function [-Wreturn-type]
   13 | }
      | ^
</code></p></pre>
<p>A similar Rust program will simply not compile:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>"0 = {}"</i>, humanize_number<i>(</i><i>0</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>"1 = {}"</i>, humanize_number<i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>"2 = {}"</i>, humanize_number<i>(</i><i>2</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>"3 = {}"</i>, humanize_number<i>(</i><i>3</i><i>)</i><i>)</i><i>;</i>
}

<i>fn</i> <i>humanize_number</i><i>(</i><i>n</i>: <i>usize</i><i>)</i> -&gt; <i>&amp;</i><i>'</i><i>static</i> <i>str</i> {
    <i>match</i> n {
        <i>0</i> =&gt; <i>"zero"</i>,
        <i>1</i> =&gt; <i>"one"</i>,
        <i>2</i> =&gt; <i>"two"</i>,
    }
}
</code></p></pre><pre><p><code>error[E0004]: non-exhaustive patterns: `_` not covered
 --&gt; src/main.rs:9:11
  |
9 |     match n {
  |           ^ pattern `_` not covered
  |
  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
  = note: the matched value is of type `usize`
</code></p></pre>
<p>Even if no one ever called <code>humanize_number</code> with a value other than <code>0</code>,
<code>1</code>, or <code>2</code>, it wouldn't matter to Rust. It simply won't let you compile
that code as-is.</p>
<p>Since values of type <code>usize</code> can range from 0 to 4 billion (on 32-bit), or 0
to 18 quintillion (that's 18 billion billion), it wants you to make sure
<em>every case</em> is handled.</p>
<p>Either by stopping the program yourself:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>humanize_number</i><i>(</i><i>n</i>: <i>usize</i><i>)</i> -&gt; <i>&amp;</i><i>'</i><i>static</i> <i>str</i> {
    <i>match</i> n {
        <i>0</i> =&gt; <i>"zero"</i>,
        <i>1</i> =&gt; <i>"one"</i>,
        <i>2</i> =&gt; <i>"two"</i>,
        _ =&gt; <i>panic</i><i>!</i><i>(</i><i>"n is too large"</i><i>)</i>,
    }
}
</code></p></pre>
<p>Or returning a fallback value:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>humanize_number</i><i>(</i><i>n</i>: <i>usize</i><i>)</i> -&gt; <i>&amp;</i><i>'</i><i>static</i> <i>str</i> {
    <i>match</i> n {
        <i>0</i> =&gt; <i>"zero"</i>,
        <i>1</i> =&gt; <i>"one"</i>,
        <i>2</i> =&gt; <i>"two"</i>,
        _ =&gt; <i>"a big number"</i>,
    }
}
</code></p></pre>
<p>Or by choosing a return type that lets us signal a failure condition:</p>
<pre><p>Rust code</p><p><code><i>struct</i> <i>NumberTooBig</i><i>;</i>

<i>fn</i> <i>humanize_number</i><i>(</i><i>n</i>: <i>usize</i><i>)</i> -&gt; <i>Result</i><i>&lt;</i><i>&amp;</i><i>'</i><i>static</i> <i>str</i>, <i>NumberTooBig</i><i>&gt;</i> {
    <i>match</i> n {
        <i>0</i> =&gt; Ok<i>(</i><i>"zero"</i><i>)</i>,
        <i>1</i> =&gt; Ok<i>(</i><i>"one"</i><i>)</i>,
        <i>2</i> =&gt; Ok<i>(</i><i>"two"</i><i>)</i>,
        _ =&gt; Err<i>(</i>NumberTooBig<i>)</i>,
    }
}
</code></p></pre>
<p>...which will force the caller to handle that case themselves:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>"0 = {}"</i>, humanize_number<i>(</i><i>0</i><i>)</i>.unwrap_or<i>(</i><i>"a big number"</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>"1 = {}"</i>, humanize_number<i>(</i><i>1</i><i>)</i>.unwrap_or<i>(</i><i>"a big number"</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>"2 = {}"</i>, humanize_number<i>(</i><i>2</i><i>)</i>.unwrap_or<i>(</i><i>"a big number"</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>"3 = {}"</i>, humanize_number<i>(</i><i>3</i><i>)</i>.unwrap_or<i>(</i><i>"a big number"</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
0 = zero
1 = one
2 = two
3 = a big number
</code></p></pre>
<p>Why doesn't Rust want to let us write code that works in some cases, but no
others? Because an immediate segmentation fault is kind of the best we can
hope for in that case.</p>
<p>The problem becomes much more serious if we actually store the result of
<code>humanize_number</code> somewhere, and use it later. Or if we end up passsing it to
a function that expects a valid string. All sorts of invariant will be broken
then, and who knows what could happen?</p>

<p>Yeah. Or leak private customer data. Or have a surgery robot go haywire. Lots
of bad things could happen.</p>
<p>But that doesn't answer our original question: why can Rust deduce the type of
<code>v</code> here:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>// deduced to be of type `Vec&lt;u8&gt;`</i>
    <i>let</i> v = <i>vec</i><i>!</i><i>[</i><i>0u8</i>, <i>3u8</i>, <i>5u8</i><i>]</i><i>;</i>
}
</code></p></pre>
<p>...but it won't deduce the bounds on type <code>T</code> here:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>add</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>a</i>: <i>T</i>, <i>b</i>: <i>T</i><i>)</i> -&gt; <i>T</i> {
    a + b
}
</code></p></pre>
<p>Well, for starters - specifying types and bounds on those types is not just
useful for <em>callers</em> of a function.</p>
<p>ie., it doesn't only prevent this:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>ops<i>::</i>Add<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a = <i>vec</i><i>!</i><i>[</i><i>0</i>, <i>1</i><i>]</i><i>;</i>
    <i>let</i> b = <i>vec</i><i>!</i><i>[</i><i>2</i>, <i>3</i><i>]</i><i>;</i>
    <i>// !!! calling `add` on values that can't be added together</i>
    <i>let</i> c = <i>add</i><i>(</i>a, b<i>)</i><i>;</i>
}

<i>fn</i> <i>add</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>a</i>: <i>T</i>, <i>b</i>: <i>T</i><i>)</i> -&gt; <i>T</i>
<i>where</i>
    <i>T</i>: <i>Add</i><i>&lt;</i><i>Output</i> = <i>T</i><i>&gt;</i>,
{
    a + b
}
</code></p></pre><pre><p><code>error[E0277]: cannot add `std::vec::Vec&lt;{integer}&gt;` to `std::vec::Vec&lt;{integer}&gt;`
  --&gt; src/main.rs:6:13
   |
6  |     let c = add(a, b);
   |             ^^^ no implementation for `std::vec::Vec&lt;{integer}&gt; + std::vec::Vec&lt;{integer}&gt;`
...
9  | fn add&lt;T&gt;(a: T, b: T) -&gt; T
   |    --- required by a bound in this
10 | where
11 |     T: Add&lt;Output = T&gt;,
   |        --------------- required by this bound in `add`
   |
   = help: the trait `std::ops::Add` is not implemented for `std::vec::Vec&lt;{integer}&gt;`
</code></p></pre>
<p>It's also useful within the callee - ie., the function we're writing:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>ops<i>::</i>Add<i>;</i>

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> fourteen = <i>add</i><i>(</i><i>7</i>, <i>7</i><i>)</i><i>;</i>
    <i>dbg</i><i>!</i><i>(</i>fourteen<i>)</i><i>;</i>
}

<i>fn</i> <i>add</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>a</i>: <i>T</i>, <i>b</i>: <i>T</i><i>)</i> -&gt; <i>T</i>
<i>where</i>
    <i>T</i>: <i>Add</i><i>&lt;</i><i>Output</i> = <i>T</i><i>&gt;</i>,
{
    <i>// subtracting b from a, but we only asked for types</i>
    <i>// that we can add!</i>
    a - b
}
</code></p></pre><pre><p><code>cargo check --quiet
error[E0369]: cannot subtract `T` from `T`
  --&gt; src/main.rs:12:7
   |
12 |     a - b
   |     - ^ - T
   |     |
   |     T
   |
help: consider further restricting this bound
   |
10 |     T: Add&lt;Output = T&gt; + std::ops::Sub&lt;Output = T&gt;,
   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></p></pre>
<p>But the <em>real</em> reason is to avoid constructs that are <strong>undecidable</strong>.</p>
<p>We're getting dangerously close to flirting with academic papers at this
point, so let's go for an example immediately.</p>
<p>Rust has an <code>Into</code> trait, that describes the ability of a type to be
converted to another type. It's distinct from casting (the <code>as</code> operator);
you actually have to call the <code>into()</code> method:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a: <i>u8</i> = <i>255</i><i>;</i>

    <i>let</i> b: <i>u16</i> = a<i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> c: <i>u32</i> = a<i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> d: <i>u64</i> = a<i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>

    <i>dbg</i><i>!</i><i>(</i>a, b, c, d<i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
[src/main.rs:8] a = 255
[src/main.rs:8] b = 255
[src/main.rs:8] c = 255
[src/main.rs:8] d = 255
</code></p></pre>
<p>In this code sample, <code>a</code> is an unsigned 8-bit integer, and we convert it to
an unsigned 16-bit integer, an unsigned 32-bit integer and an unsigned 64-bit
integer, all using the same method: <code>Into::into</code>.</p>
<p>Which means that <code>Into::into</code> can return different types, not only depending
on what type the receiver is (it's an <code>u8</code> in all three calls), but also
depending on <em>what type is expected</em>.</p>
<p>In other words, <code>Into::into</code> is "generic over its return type".</p>
<p>But now we have a conundrum.</p>

<p>An, uh, "opportunity to get into trouble".</p>
<p>Consider the following code:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> a: <i>u8</i> = <i>255</i><i>;</i>

    <i>let</i> b = a<i>.</i><i>into</i><i>(</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>"b = {}"</i>, b<i>)</i><i>;</i>
}
</code></p></pre>
<p>What should the type of <code>b</code> be?</p>
<p>The Rust compiler is wondering, as well:</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
error[E0282]: type annotations needed
 --&gt; src/main.rs:4:9
  |
4 |     let b = a.into();
  |         ^ consider giving `b` a type
</code></p></pre>
<p>Clearly, we need a type, let's call it <code>B</code>, for which there exists
<code>impl Into&lt;B&gt; for A</code>, and also <code>impl Display for B</code>, since we
use it in a <code>println!</code> call.</p>
<p>But there are multiple such types - <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>i16</code>,
<code>i32</code>, <code>i64</code> and <code>i128</code> would all work great.</p>
<div>

<p>Note that <code>i8</code> would <em>not</em> work, as it cannot represent all possible <code>u8</code>
values. In that case, we'd have to use the
<a href="https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html">TryInto</a>
trait, which represents the ability to "try to convert", a fallible operation.</p>
</div>
<p>So which one should be used? <strong>Rust refuses to guess</strong>.</p>
<p>Since we're on the topic of integer types, there is one notable exception to
that rule. In this code:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> v = <i>vec</i><i>!</i><i>[</i><i>1</i>, <i>2</i>, <i>3</i><i>]</i><i>;</i>
}
</code></p></pre>
<p>We get a <code>Vec&lt;i32&gt;</code>. Integer literals are not a specific type, they're
<code>{integer}</code>. If a specific type is expected, then they can become <code>u64</code>,
<code>i8</code>, or whatever else - but if not, it defaults to <code>i32</code>. Floating point
literals (like <code>0.0</code>) will default to <code>f64</code>, and <code>!</code> (the "never" return
type) <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3a84d0d29d299af467061ee71d35d999">coerces to <code>()</code></a>.</p>
<p>For everything else, we need to spell things out.</p>
<div>

<p>The Rust compiler has a lot of knowledge about types, their possible values,
and the things they're capable of (to a large extent: the traits they
implement).</p>
<p>It uses that knowledge all the time, to deduce the type of variable bindings,
of literals, and type arguments (the <code>T</code> in <code>fn add&lt;T&gt;</code>).</p>
<p>However, there is a limit to the amount of deducing the Rust compiler will
do. When it's starting to look too much like guessing, it will ask for
more explicit instructions - type annotations.</p>
</div>
<h2>Beyond integer types</h2>
<p>Consider the following example program:</p>
<pre><p>Rust code</p><p><code><i>// (doesn't compile)</i>

<i>struct</i> <i>Wolf</i> {}

<i>impl</i> <i>Wolf</i> {
    <i>fn</i> <i>greet</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>println</i><i>!</i><i>(</i><i>"awoooo"</i><i>)</i><i>;</i>
    }
}

<i>struct</i> <i>Lizard</i> {}

<i>impl</i> <i>Lizard</i> {
    <i>fn</i> <i>greet</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>println</i><i>!</i><i>(</i><i>"*chirp chirp*"</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>acquire_pet</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>comfy</i>: <i>bool</i><i>)</i> -&gt; <i>T</i> {
    <i>if</i> comfy {
        <i>Wolf</i> {}
    } <i>else</i> {
        <i>Lizard</i> {}
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> pet = <i>acquire_pet</i><i>(</i><i>true</i><i>)</i><i>;</i>
    pet<i>.</i><i>greet</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>(Yeah, <a href="https://www.youtube.com/watch?v=ZFCkKfU8k0Y">lizards make noise</a>).</p>
<p>This doesn't compile. One of the errors is as follows:</p>
<pre><p><code>error[E0282]: type annotations needed                            
  --&gt; src/main.rs:27:5          
   |                            
26 |     let pet = acquire_pet(true);                            
   |         --- consider giving `pet` a type                    
27 |     pet.greet();           
   |     ^^^ cannot infer type  
   |                            
   = note: type must be known at this point    
</code></p></pre>
<p>...but even if we do give <code>pet</code> a type:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> pet: <i>Wolf</i> = <i>acquire_pet</i><i>(</i><i>true</i><i>)</i><i>;</i>
    pet<i>.</i><i>greet</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>...we're still left with those errors:</p>
<pre><p><code>error[E0308]: mismatched types
  --&gt; src/main.rs:19:9
   |
17 | fn acquire_pet&lt;T&gt;(comfy: bool) -&gt; T {
   |                -                  - expected `T` because of return type
   |                |
   |                this type parameter
18 |     if comfy {
19 |         Wolf {}
   |         ^^^^^^^ expected type parameter `T`, found struct `Wolf`
   |
   = note: expected type parameter `T`
                      found struct `Wolf`

error[E0308]: mismatched types
  --&gt; src/main.rs:21:9
   |
17 | fn acquire_pet&lt;T&gt;(comfy: bool) -&gt; T {
   |                -                  - expected `T` because of return type
   |                |
   |                this type parameter
...
21 |         Lizard {}
   |         ^^^^^^^^^ expected type parameter `T`, found struct `Lizard`
   |
   = note: expected type parameter `T`
                      found struct `Lizard`
</code></p></pre>
<p>What's the problem now? <code>acquire_pet</code> is generic - clearly it can return
different types. We call it with <code>true</code>, so clearly, it should return a
<code>Wolf</code>, and we also expect a <code>Wolf</code> (that's the type we gave our <code>pet</code>
binding in the <code>main</code> function).</p>
<p>What gives?</p>
<p>Well, this particular case is decidable, but what happens if we do this?</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>ask_comfy_preference</i><i>(</i><i>)</i> -&gt; <i>bool</i> {
    <i>println</i><i>!</i><i>(</i><i>"Do you like comfy pets? (yes or no)"</i><i>)</i><i>;</i>
    <i>let</i> <i>mut</i> answer = <i>String</i><i>::</i><i>new</i><i>(</i><i>)</i><i>;</i>
    std<i>::</i>io<i>::</i><i>stdin</i><i>(</i><i>)</i><i>.</i><i>read_line</i><i>(</i><i>&amp;</i><i>mut</i> answer<i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>match</i> answer<i>.</i><i>trim</i><i>(</i><i>)</i> {
        <i>"yes"</i> =&gt; <i>true</i>,
        <i>"no"</i> =&gt; <i>false</i>,
        _ =&gt; {
            <i>panic</i><i>!</i><i>(</i><i>"Sorry, I did not understand your answer: {:?}"</i>, answer<i>)</i><i>;</i>
        }
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> comfy = <i>ask_comfy_preference</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> pet = <i>acquire_pet</i><i>(</i>comfy<i>)</i><i>;</i>
    pet<i>.</i><i>greet</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>Now the type of <code>pet</code> depends on user input. This would be no problem at all
in a language with dynamic typing. But here, there's no duck to quack or walk
like.</p>
<p>It doesn't matter that both <code>Wolf</code> and <code>Lizard</code> both have a <code>greet</code> method.
Their <em>structural similarity</em> is not at all relevant.</p>
<p>The only thing that matters is the <em>contracts</em> various parts of the code have
agreed to uphold.</p>
<p>There is a type in the Rust standard library that lets us return "anything".
Well, it's a trait: <a href="https://doc.rust-lang.org/stable/std/any/trait.Any.html">Any</a>.</p>
<pre><p>Rust code</p><p><code><i>// bad code ahoy</i>

<i>fn</i> <i>acquire_pet</i><i>(</i><i>comfy</i>: <i>bool</i><i>)</i> -&gt; <i>dyn</i> std<i>::</i>any<i>::</i><i>Any</i> {
    <i>if</i> comfy {
        <i>Wolf</i> {}
    } <i>else</i> {
        <i>Lizard</i> {}
    }
}
</code></p></pre><div>

<p>The <code>dyn</code> keyword is needed here since the <a href="https://doc.rust-lang.org/edition-guide/rust-2018/trait-system/dyn-trait-for-trait-objects.html">2018 Rust
Edition</a>.</p>
<p>In <code>dyn T</code>, <code>T</code> is the trait (just a contract - a list of methods, some
characteristics etc.) and <code>dyn T</code> is a "trait object", which contains both:</p>
<ul>
<li>An object for which the trait <code>T</code> is implemented</li>
<li>A vtable containing the address of each method required by <code>T</code>,
implemented for that object's type.</li>
</ul>
</div>
<p>This doesn't work - we can't just use a trait as a return type like that.</p>
<p>Trying to compile that code gives you a <em>lot</em> of advice.</p>
<p>Among those, it says: "if all the returned values were of the same type you
could use <code>impl std::any::Any</code> as the return type".</p>
<p>If? Aren't they? Let's try it:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>acquire_pet</i><i>(</i><i>comfy</i>: <i>bool</i><i>)</i> -&gt; <i>impl</i> std<i>::</i>any<i>::</i><i>Any</i> {
    <i>if</i> comfy {
        <i>Wolf</i> {}
    } <i>else</i> {
        <i>Lizard</i> {}
    }
}
</code></p></pre>
<p>In this version, we promise to return a concrete type that implements <code>Any</code>.
We just don't want to name it. This is handy in a lot of cases.</p>
<p>But it doesn't solve our problem:</p>
<pre><p>Rust code</p><p><code>cargo check --quiet
error<i>[</i>E0308<i>]</i>: `<i>if</i>` and `<i>else</i>` have incompatible types
  --&gt; src/main<i>.</i><i>rs</i>:<i>21</i>:<i>9</i>
   |
<i>18</i> | /     <i>if</i> comfy {
<i>19</i> | |         <i>Wolf</i> {}
   | |         ------- expected because of this
<i>20</i> | |     } <i>else</i> {
<i>21</i> | |         <i>Lizard</i> {}
   | |         ^^^^^^^^^ expected <i>struct</i> `Wolf`, found <i>struct</i> `Lizard`
<i>22</i> | |     }
   | |_____- `<i>if</i>` and `<i>else</i>` have incompatible types
</code></p></pre>
<p>Because even though we're not specifying the concrete return type (just that
it should implement the <code>Any</code> trait), the compiler should still be able to
figure it out, given the function's signature (its argument types), and the
code that's inside it.</p>
<p>And right now, it can't figure out if the concrete type should be <code>struct Wolf</code>, or <code>struct Lizard</code>.</p>
<p>The compiler did suggest two actual solutions, though: to either return a
boxed trait object instead, or to make an enum with a variant for each
returned type.</p>
<p>We'll go with the first one:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>acquire_pet</i><i>(</i><i>comfy</i>: <i>bool</i><i>)</i> -&gt; <i>Box</i><i>&lt;</i><i>dyn</i> std<i>::</i>any<i>::</i><i>Any</i><i>&gt;</i> {
    <i>if</i> comfy {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Wolf</i> {}<i>)</i>
    } <i>else</i> {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Lizard</i> {}<i>)</i>
    }
}
</code></p></pre>
<p>See, the problem with returning "a Wolf" or "a Lizard" is that those types
may have completely different sizes.</p>
<p>So when program execution reaches this point:</p>
<pre><p>Rust code</p><p><code>    <i>let</i> pet = <i>acquire_pet</i><i>(</i>comfy<i>)</i><i>;</i>
</code></p></pre>
<p>...we should reserve enough memory to store the pet, on the stack.</p>
<div>

<p>Or, with suitable optimizations, part of it can even be stored
in registers.</p>
</div>
<p>Right. Point is, we need to know what the actual type is - how big it is,
what kind of fields it has, etc.</p>
<p>But if we return a <code>Box&lt;dyn Any&gt;</code>, we're simply returning the <em>address</em> of a
value whose type implements Any. <code>Box&lt;T&gt;</code> is just a pointer, and we know
the size of that (4 bytes on 32-bit, 8 bytes on 64-bit).</p>
<p>But our program still doesn't compile (a recurring theme...):</p>
<pre><p><code>error[E0599]: no method named `greet` found for struct `std::boxed::Box&lt;dyn std::any::Any&gt;` in the current scope
  --&gt; src/main.rs:40:9
   |
40 |     pet.greet();
   |         ^^^^^ method not found in `std::boxed::Box&lt;dyn std::any::Any&gt;`
</code></p></pre>
<p>This time though, the answer is clear - we're returning the address of
something that implements <code>Any</code>.</p>
<p>But <code>Any</code> doesn't promise anything!</p>
<p>Its only required method is <code>type_id</code>, so we can do that:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> comfy = <i>ask_comfy_preference</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> pet = <i>acquire_pet</i><i>(</i>comfy<i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>"We got a {:?}"</i>, pet.type_id<i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
Do you like comfy pets? (yes or no)
yes
We got a TypeId { t: 13993700938491603631 }
$ cargo run --quiet
Do you like comfy pets? (yes or no)
no
We got a TypeId { t: 8639049246320250335 }
</code></p></pre>
<p>Another thing we can do is try to <em>downcast</em> the resulting value into a
specific concrete type, like <code>Wolf</code> or <code>Lizard</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> comfy = <i>ask_comfy_preference</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> pet = <i>acquire_pet</i><i>(</i>comfy<i>)</i><i>;</i>

    <i>if</i> <i>let</i> Some<i>(</i>wolf<i>)</i> = pet<i>.</i><i>downcast_ref</i><i>::</i><i>&lt;</i><i>Wolf</i><i>&gt;</i><i>(</i><i>)</i> {
        wolf<i>.</i><i>greet</i><i>(</i><i>)</i><i>;</i>
    } <i>else</i> <i>if</i> <i>let</i> Some<i>(</i>lizard<i>)</i> = pet<i>.</i><i>downcast_ref</i><i>::</i><i>&lt;</i><i>Lizard</i><i>&gt;</i><i>(</i><i>)</i> {
        lizard<i>.</i><i>greet</i><i>(</i><i>)</i><i>;</i>
    } <i>else</i> {
        <i>println</i><i>!</i><i>(</i><i>"we don't know about this friend yet"</i><i>)</i><i>;</i>
    }
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
Do you like comfy pets? (yes or no)
yes
awoooo
</code></p></pre>
<p>As things stand, we're asking for <em>less</em> than we need.</p>
<p>What we need is for <code>acquire_pet</code> to promise it'll return <em>something</em> with a
<code>greet</code> method. And we can express that by making a trait:</p>
<pre><p>Rust code</p><p><code><i>trait</i> <i>Greet</i> {
    <i>fn</i> <i>greet</i><i>(</i><i>&amp;</i><i>self</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>And implementing it for <code>Wolf</code> and <code>Lizard</code>:</p>
<pre><p>Rust code</p><p><code><i>impl</i> <i>Greet</i> <i>for</i> <i>Wolf</i> {
    <i>fn</i> <i>greet</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>println</i><i>!</i><i>(</i><i>"awoooo"</i><i>)</i><i>;</i>
    }
}

<i>impl</i> <i>Greet</i> <i>for</i> <i>Lizard</i> {
    <i>fn</i> <i>greet</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> {
        <i>println</i><i>!</i><i>(</i><i>"*chirp chirp*"</i><i>)</i><i>;</i>
    }
}
</code></p></pre>
<p>And then changing the signature of <code>acquire_pet</code> to promise we'll return
something that implements <code>Greet</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>acquire_pet</i><i>(</i><i>comfy</i>: <i>bool</i><i>)</i> -&gt; <i>Box</i><i>&lt;</i><i>dyn</i> <i>Greet</i><i>&gt;</i> {
    <i>if</i> comfy {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Wolf</i> {}<i>)</i>
    } <i>else</i> {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Lizard</i> {}<i>)</i>
    }
}
</code></p></pre>
<p>And finally, this version of <code>main</code> works:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> comfy = <i>ask_comfy_preference</i><i>(</i><i>)</i><i>;</i>
    <i>let</i> pet = <i>acquire_pet</i><i>(</i>comfy<i>)</i><i>;</i>
    pet<i>.</i><i>greet</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>We can even get fancy with bounds: we can ask for values that can be greeted
and <em>also</em> cloned.</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>greet_clones</i><i>&lt;</i><i>P</i><i>&gt;</i><i>(</i><i>pet</i>: <i>&amp;</i><i>P</i><i>)</i>
<i>where</i>
    <i>P</i>: <i>Clone</i> + <i>Greet</i>,
{
    <i>for</i> _ <i>in</i> <i>0</i>..<i>3</i> {
        <i>let</i> clone = pet<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>
        clone<i>.</i><i>greet</i><i>(</i><i>)</i><i>;</i>
    }
}
</code></p></pre>
<p>To get this to work, we'll have to implement <code>Clone</code> on our <code>Wolf</code> and
<code>Lizard</code> types. This can be done easily with the <code>derive</code> attribute,
which generates the <code>impl Clone for T</code> block for us, as long as all our
fields are also <code>Clone</code>:</p>
<pre><p>Rust code</p><p><code><i>#<i>[</i>derive<i>(</i>Clone<i>)</i><i>]</i></i>
<i>struct</i> <i>Wolf</i> {}

<i>#<i>[</i>derive<i>(</i>Clone<i>)</i><i>]</i></i>
<i>struct</i> <i>Lizard</i> {}
</code></p></pre>
<p>And now, we can do this:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> wolf = <i>Wolf</i> {}<i>;</i>
    <i>greet_clones</i><i>(</i><i>&amp;</i>wolf<i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
awoooo
awoooo
awoooo
</code></p></pre>
<p>But, and this is what I'm getting to, we can't do this:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> pet = <i>acquire_pet</i><i>(</i><i>ask_comfy_preference</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>greet_clones</i><i>(</i>pet<i>.</i><i>as_ref</i><i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
error[E0277]: the trait bound `dyn Greet: std::clone::Clone` is not satisfied
  --&gt; src/main.rs:59:18
   |
33 | fn greet_clones&lt;P&gt;(pet: &amp;P)
   |    ------------ required by a bound in this
34 | where
35 |     P: Clone + Greet,
   |        ----- required by this bound in `greet_clones`
...
59 |     greet_clones(pet.as_ref());
   |                  ^^^^^^^^^^^^ the trait `std::clone::Clone` is not implemented for `dyn Greet`
</code></p></pre>
<p>...because <code>acquire_pet</code> only promises to return something that implements
<code>Greet</code>, not <code>Clone</code>! Even though it (currently) only ever returns values of
types that implement both.</p>
<p>So, we can constrain our <code>acquire_pet</code> method further - we can tell the Rust
compiler more about our intentions:</p>
<pre><p>Rust code</p><p><code><i>// (doesn't actually work)</i>

<i>fn</i> <i>acquire_pet</i><i>(</i><i>comfy</i>: <i>bool</i><i>)</i> -&gt; <i>Box</i><i>&lt;</i><i>dyn</i> <i>Greet</i> + <i>Clone</i><i>&gt;</i> {
    <i>if</i> comfy {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Wolf</i> {}<i>)</i>
    } <i>else</i> {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Lizard</i> {}<i>)</i>
    }
}
</code></p></pre>
<p>Well, that particular way doesn't work:</p>
<pre><p><code>error[E0225]: only auto traits can be used as additional traits in a trait object
  --&gt; src/main.rs:25:48
   |
25 | fn acquire_pet(comfy: bool) -&gt; Box&lt;dyn Greet + Clone&gt; {
   |                                        -----   ^^^^^
   |                                        |       |
   |                                        |       additional non-auto trait
   |                                        |       trait alias used in trait object type (additional use)
   |                                        first non-auto trait
   |                                        trait alias used in trait object type (first use)
</code></p></pre>
<p>But we can can find a way:</p>
<pre><p>Rust code</p><p><code><i>// (still doesn't work)</i>

<i>trait</i> <i>GreetClone</i>: <i>Greet</i> + <i>Clone</i> {}

<i>fn</i> <i>acquire_pet</i><i>(</i><i>comfy</i>: <i>bool</i><i>)</i> -&gt; <i>Box</i><i>&lt;</i><i>dyn</i> <i>GreetClone</i><i>&gt;</i> {
    <i>if</i> comfy {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Wolf</i> {}<i>)</i>
    } <i>else</i> {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Lizard</i> {}<i>)</i>
    }
}
</code></p></pre>
<p>Unless that way doesn't work either:</p>
<pre><p><code>cargo run --quiet
error[E0038]: the trait `GreetClone` cannot be made into an object
  --&gt; src/main.rs:27:32
   |
25 | trait GreetClone: Greet + Clone {}
   |       ----------          ----- ...because it requires `Self: Sized`
   |       |
   |       this trait cannot be made into an object...
26 | 
27 | fn acquire_pet(comfy: bool) -&gt; Box&lt;dyn GreetClone&gt; {
   |                                ^^^^^^^^^^^^^^^^^^^ the trait `GreetClone` cannot be made into an object
</code></p></pre>
<p>And to understand why, we have to do some more thinking.</p>
<h2>Unsized types and trait objects</h2>
<p>We've seen before that this doesn't work:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>acquire_pet</i><i>(</i><i>comfy</i>: <i>bool</i><i>)</i> -&gt; <i>dyn</i> std<i>::</i>any<i>::</i><i>Any</i> {
    <i>if</i> comfy {
        <i>Wolf</i> {}
    } <i>else</i> {
        <i>Lizard</i> {}
    }
}
</code></p></pre>
<p>Because in that code, we <em>have to know</em> how much memory to reserve for <code>pet</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> pet = <i>acquire_pet</i><i>(</i><i>true</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>And now that our intuition about this exists, we can learn about the
vocabulary we need to express that constraint: "locals" (such as <code>pet</code>)
cannot be "unsized". And "trait objects" (<code>dyn T</code>) are "unsized".</p>
<p>How is this relevant to <code>Clone</code>?</p>
<p>Well, let's try to make our own <code>MyClone</code> trait:</p>
<pre><p>Rust code</p><p><code><i>trait</i> <i>MyClone</i> {
    <i>fn</i> <i>my_clone</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Self</i><i>;</i>
}
</code></p></pre>
<p><code>my_clone</code> takes a <em>reference</em> to a value. References are actually pointers,
and we've seen that pointers are sized. If it took <code>self</code> by value, then it
wouldn't really be cloning, as it would destroy the value we're trying to
clone in the first place.</p>
<p>But it returns <code>Self</code>. If <code>Wolf</code> implements <code>MyClone</code>, then <code>wolf.my_clone()</code>
returns a <code>Wolf</code>.</p>
<p>So, <code>Wolf</code> has a certain size, we can build a value of type <code>Wolf</code> on the stack:</p>
<pre><p>Rust code</p><p><code><i>let</i> wolf = <i>Wolf</i> {}<i>;</i>
</code></p></pre>
<p>We can also "box it", ie. store it on the heap, and just hold a pointer to it:</p>
<pre><p>Rust code</p><p><code><i>let</i> wolf = <i>Box</i><i>::</i><i>new</i><i>(</i><i>Wolf</i> {}<i>)</i><i>;</i>
</code></p></pre>
<p>That's all fine. We can even call <code>.my_clone()</code> on it:</p>
<pre><p>Rust code</p><p><code><i>let</i> wolf = <i>Box</i><i>::</i><i>new</i><i>(</i><i>Wolf</i> {}<i>)</i><i>;</i>
<i>let</i> wolf2 = wolf<i>.</i><i>as_ref</i><i>(</i><i>)</i><i>.</i><i>my_clone</i><i>(</i><i>)</i><i>;</i>
</code></p></pre>
<p>What's <em>not</em> fine is if we hide the concrete type. If <em>all we know</em>
about what's inside the <code>Box</code> is that it implements <code>MyClone</code>.</p>
<pre><p>Rust code</p><p><code><i>impl</i> <i>MyClone</i> <i>for</i> <i>Wolf</i> {
    <i>fn</i> <i>my_clone</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Self</i> {
        <i>// luckily `Wolf` has no fields right now,</i>
        <i>// so our implementation is trivial - just</i>
        <i>// construct another wolf.</i>
        <i>Self</i> {}
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> pet = <i>Box</i><i>::</i><i>new</i><i>(</i><i>Wolf</i> {}<i>)</i> <i>as</i> <i>Box</i><i>&lt;</i><i>dyn</i> <i>MyClone</i><i>&gt;</i><i>;</i>
    <i>let</i> pet2 = pet<i>.</i><i>my_clone</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>This makes the Rust compiler very flustered.</p>
<p>It's trying to tell us a lot of things at the same time:</p>
<pre><p><code>error[E0038]: the trait `MyClone` cannot be made into an object                            
  --&gt; src/main.rs:70:36                      
   |                                                                                       
31 | trait MyClone {                                                                       
   |       ------- this trait cannot be made into an object...                                                                                                                         
32 |     fn my_clone(&amp;self) -&gt; Self;                                                       
   |                           ---- ...because method `my_clone` references the `Self` type in its return type                                                                         
...                                                                                                                                                                                    
70 |     let pet = Box::new(Wolf {}) as Box&lt;dyn MyClone&gt;;                                  
   |                                    ^^^^^^^^^^^^^^^^ the trait `MyClone` cannot be made into an object                                                                             
   |                                                                                                                                                                                   
   = help: consider moving `my_clone` to another trait           
</code></p></pre>
<p>This says: due to the way the <code>MyClone</code> trait is defined, we can <em>never</em> hold
on to values of type <code>dyn MyClone</code>. Even through a <code>Box</code>.</p>
<p>We then have two other instances of that particular error (highlighting different
parts of the code), and then this:</p>
<pre><p>Rust code</p><p><code>error<i>[</i>E0277<i>]</i>: the size <i>for</i> values of <i>type</i> `<i>dyn</i> MyClone` cannot be known at <i>compilation</i><i></i> time                                                                                            
  --&gt; src/main<i>.</i><i>rs</i>:<i>71</i>:<i>9</i>                       
   |                                         
<i>71</i> |     let pet2 = pet<i>.</i><i>my_clone</i><i>(</i><i>)</i><i>;</i>                                                        
   |         ^^^^ doesn<i>'</i>t have a size known at compile-time                                
   |                                         
   = help: the <i>trait</i> `std<i>::</i>marker<i>::</i><i>Sized</i>` is not implemented <i>for</i> `<i>dyn</i> MyClone`                                                                                                         
   = note: to learn more, visit &lt;<i>https</i>:<i>//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;                                               </i>
   = <i>note</i>: all local variables must have a statically known <i>size</i>                                                                                                                       
   = <i>help</i>: unsized locals are <i>gated</i> <i>as</i> an unstable <i>feature</i>           
</code></p></pre>
<p>We've <em>just now</em> learned what this means. We cannot have "unsized locals".
We must know how much memory to reserve for a local.</p>
<p>It also suggests we implement the marker trait <code>Sized</code> for <code>MyClone</code>.</p>
<p>Well, we can do that:</p>
<pre><p>Rust code</p><p><code><i>trait</i> <i>MyClone</i>: <i>Sized</i> {
    <i>fn</i> <i>my_clone</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Self</i><i>;</i>
}
</code></p></pre>
<p>And then we get slightly different variants of the same error, like:</p>
<pre><p><code>error[E0038]: the trait `MyClone` cannot be made into an object
  --&gt; src/main.rs:70:36                                                                 
   |                             
31 | trait MyClone: Sized {
   |       -------  ----- ...because it requires `Self: Sized`
   |       |
   |       this trait cannot be made into an object...          
...
70 |     let pet = Box::new(Wolf {}) as Box&lt;dyn MyClone&gt;;
   |                                    ^^^^^^^^^^^^^^^^ the trait `MyClone` cannot be made into an object

error: the `my_clone` method cannot be invoked on a trait object
  --&gt; src/main.rs:71:20
   |
31 | trait MyClone: Sized {
   |                ----- this has a `Sized` requirement
...
71 |     let pet2 = pet.my_clone();
   |                    ^^^^^^^^
</code></p></pre>
<p>Does this mean we can <em>never</em> invoke <code>my_clone</code>? No, we still can!</p>
<p>This is perfectly fine:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> pet = <i>Wolf</i> {}<i>;</i>
    <i>let</i> pet2 = pet<i>.</i><i>my_clone</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>And so is this:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> pet = <i>Box</i><i>::</i><i>new</i><i>(</i><i>Wolf</i> {}<i>)</i><i>;</i>
    <i>let</i> pet2 = pet<i>.</i><i>my_clone</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>We just cannot invoke it on a "trait object", a value of type <code>dyn MyClone</code>.</p>
<p>And this is the exact error we had with our <code>GreetClone</code> trait:</p>
<pre><p>Rust code</p><p><code><i>trait</i> <i>GreetClone</i>: <i>Greet</i> + <i>MyClone</i> {}

<i>fn</i> <i>acquire_pet</i><i>(</i><i>comfy</i>: <i>bool</i><i>)</i> -&gt; <i>Box</i><i>&lt;</i><i>dyn</i> <i>GreetClone</i><i>&gt;</i> {
    <i>if</i> comfy {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Wolf</i> {}<i>)</i>
    } <i>else</i> {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Lizard</i> {}<i>)</i>
    }
}
</code></p></pre><pre><p><code>cargo run --quiet
error[E0038]: the trait `GreetClone` cannot be made into an object
  --&gt; src/main.rs:27:32
   |
25 | trait GreetClone: Greet + Clone {}
   |       ----------          ----- ...because it requires `Self: Sized`
   |       |
   |       this trait cannot be made into an object...
26 | 
27 | fn acquire_pet(comfy: bool) -&gt; Box&lt;dyn GreetClone&gt; {
   |                                ^^^^^^^^^^^^^^^^^^^ the trait `GreetClone` cannot be made into an object
</code></p></pre>
<p>The whole problem is that we're trying to return <code>Self</code>, which might have any
size, depending on which concrete type is implementing <code>MyClone</code>.</p>
<p>If we're willing to get our hands dirty... there's a way around it. We can
definitely get around Rust's limitations and return a pointer to some value
on the heap.</p>
<pre><p>Rust code</p><p><code><i>trait</i> <i>MyClone</i> {
    <i>unsafe</i> <i>fn</i> <i>clone_ptr</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>*</i><i>mut</i> <i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>And of course, we have to implement it for both <code>Wolf</code> and <code>Lizard</code>:</p>
<pre><p>Rust code</p><p><code><i>impl</i> <i>MyClone</i> <i>for</i> <i>Wolf</i> {
    <i>unsafe</i> <i>fn</i> <i>clone_ptr</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>*</i><i>mut</i> <i>(</i><i>)</i> {
        <i>Box</i><i>::</i><i>into_raw</i><i>(</i><i>Box</i><i>::</i><i>new</i><i>(</i><i>self</i><i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i><i>)</i> <i>as</i> <i>_</i>
    }
}

<i>impl</i> <i>MyClone</i> <i>for</i> <i>Lizard</i> {
    <i>unsafe</i> <i>fn</i> <i>clone_ptr</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>*</i><i>mut</i> <i>(</i><i>)</i> {
        <i>Box</i><i>::</i><i>into_raw</i><i>(</i><i>Box</i><i>::</i><i>new</i><i>(</i><i>self</i><i>.</i><i>clone</i><i>(</i><i>)</i><i>)</i><i>)</i> <i>as</i> <i>_</i>
    }
}
</code></p></pre>
<p>And since we don't actually want to be dealing with raw pointers, we can make
a helper method, in another trait, which we'll implement automatically for
all types that also implement <code>MyClone</code> - even unsized types.</p>
<pre><p>Rust code</p><p><code><i>trait</i> <i>MyCloneExt</i> {
    <i>fn</i> <i>clone_box</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Box</i><i>&lt;</i><i>Self</i><i>&gt;</i><i>;</i>
}

<i>impl</i><i>&lt;</i><i>T</i><i>&gt;</i> <i>MyCloneExt</i> <i>for</i> <i>T</i>
<i>where</i>
    <i>T</i>: <i>MyClone</i> + ?<i>Sized</i>,
{
    <i>fn</i> <i>clone_box</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>Box</i><i>&lt;</i><i>Self</i><i>&gt;</i> {
        <i>// avert your gaze for a few lines...</i>
        <i>let</i> <i>mut</i> fat_ptr = <i>self</i> <i>as</i> <i>*</i><i>const</i> <i>Self</i><i>;</i>
        <i>unsafe</i> {
            <i>let</i> data_ptr = <i>&amp;</i><i>mut</i> fat_ptr <i>as</i> <i>*</i><i>mut</i> <i>*</i><i>const</i> <i>T</i> <i>as</i> <i>*</i><i>mut</i> <i>*</i><i>mut</i> <i>(</i><i>)</i><i>;</i>
            <i>assert_eq</i><i>!</i><i>(</i>*data_ptr <i>as</i> *<i>const</i> <i>(</i><i>)</i>, <i>self</i> <i>as</i> *<i>const</i> T <i>as</i> *<i>const</i> <i>(</i><i>)</i><i>)</i><i>;</i>
            <i>*</i>data_ptr = &lt;<i>T</i> <i>as</i> <i>MyClone</i>&gt;<i>::</i><i>clone_ptr</i><i>(</i><i>self</i><i>)</i><i>;</i>
        }
        <i>// ...there we go</i>
        <i>unsafe</i> { <i>Box</i><i>::</i><i>from_raw</i><i>(</i>fat_ptr <i>as</i> <i>*</i><i>mut</i> <i>Self</i><i>)</i> }
    }
}
</code></p></pre>
<p>This is <em>fairly advanced</em> trickery, so, don't worry about it too much.</p>
<p>Point is - now, <code>MyClone</code> is "trait object safe" (it doesn't require <code>Sized</code>,
it doesn't refer to <code>Self</code>), so we can use it as a super trait of <code>GreetClone</code>:</p>
<pre><p>Rust code</p><p><code><i>trait</i> <i>GreetClone</i>: <i>Greet</i> + <i>MyClone</i> {}
</code></p></pre>
<p>And then use the trait object type <code>dyn GreetClone</code> as a return type in <code>acquire_pet</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>acquire_pet</i><i>(</i><i>comfy</i>: <i>bool</i><i>)</i> -&gt; <i>Box</i><i>&lt;</i><i>dyn</i> <i>GreetClone</i><i>&gt;</i> {
    <i>if</i> comfy {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Wolf</i> {}<i>)</i>
    } <i>else</i> {
        <i>Box</i><i>::</i><i>new</i><i>(</i><i>Lizard</i> {}<i>)</i>
    }
}
</code></p></pre>
<p>Then change <code>greet_clones</code> to take <code>MyClone + Greet</code> rather than <code>Clone + Greet</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>greet_clones</i><i>&lt;</i><i>P</i><i>&gt;</i><i>(</i><i>pet</i>: <i>&amp;</i><i>P</i><i>)</i>
<i>where</i>
    <i>P</i>: <i>MyClone</i> + <i>Greet</i> + ?<i>Sized</i>,
{
    <i>for</i> _ <i>in</i> <i>0</i>..<i>3</i> {
        <i>let</i> clone = pet<i>.</i><i>clone_box</i><i>(</i><i>)</i><i>;</i>
        clone<i>.</i><i>greet</i><i>(</i><i>)</i><i>;</i>
    }
}
</code></p></pre>
<p>And finally, at long last, use it from <code>main</code>:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> pet = <i>acquire_pet</i><i>(</i><i>ask_comfy_preference</i><i>(</i><i>)</i><i>)</i><i>;</i>
    <i>greet_clones</i><i>(</i>pet<i>.</i><i>as_ref</i><i>(</i><i>)</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
Do you like comfy pets? (yes or no)
yes
awoooo
awoooo
awoooo
</code></p></pre>
<p>I didn't come up with all this trickery by myself: it's straight from the
<a href="https://github.com/dtolnay/dyn-clone">dyn-clone crate</a>, which you should
just use in case you need to do <em>this particular thing</em>.</p>
<p>Let me repeat this: <strong>you don't have to come up with trickery like that by
yourself</strong>. I just chose this particularly gnarly example to demonstrate
that, really, I mean it: it's not you, it's Rust.</p>
<div>

<p>Rust needs to be confident that invariants will not be violated. It needs to
be convinced that your code is sound.</p>
<p>In some cases it gets tricky. Tricky enough to warrant using an additional
crate just so you don't have to deal with the dirty details yourself.</p>
<p>In particular, data structures are especially difficult to implement in Rust,
and that's one of the things experienced developers (who are used to just
roll their own in other languages) end up finding out sooner rather than
later.</p>
</div>
<h2>Lifetimes</h2>
<p>I know, I know, I <a href="https://fasterthanli.me/articles/i-am-a-java-csharp-c-or-cplusplus-dev-time-to-do-some-rust">just wrote about
lifetimes</a>,
and <a href="https://fasterthanli.me/articles/declarative-memory-management">again before that</a> and <a href="https://fasterthanli.me/articles/working-with-strings-in-rust">again
before that</a>. But lifetimes are one
of the concepts of Rust that underpin the entire language.</p>
<p>And everyone understands lifetimes in their own time - there's not one single
explanation that'll work for everyone. I could keep making up explanations my
whole life, and there'd still be folks who don't quite see it yet.</p>
<p>This time, I'm trying it from the angle: "you're smarter than Rust".</p>
<p>Take this C99 program:</p>
<pre><p>C code</p><p><code><i>#include</i> <i>&lt;stdio.h&gt;</i>
<i>#include</i> <i>&lt;pthread.h&gt;</i>
<i>#include</i> <i>&lt;unistd.h&gt;</i>

<i>struct</i> <i>State</i> {
    <i>int</i> <i>a</i>;
    <i>int</i> <i>b</i>;
};

<i>void</i> <i>*</i><i>t1_work</i>(<i>void</i> <i>*</i><i>arg</i>) {
    <i>struct</i> <i>State</i> <i>*</i><i>state</i> = (<i>struct</i> <i>State</i><i>*</i>) <i>arg</i>;

    <i>while</i> (<i>state</i><i>-&gt;</i><i>a</i> <i>!=</i> 0) {
        <i>printf</i>(<i>"a = %d
"</i>, <i>state</i><i>-&gt;</i><i>a</i>);
        <i>state</i><i>-&gt;</i><i>a</i><i>--</i>;
        <i>sleep</i>(1);
    }
    <i>return</i> <i>NULL</i>;
}

<i>void</i> <i>*</i><i>t2_work</i>(<i>void</i> <i>*</i><i>arg</i>) {
    <i>struct</i> <i>State</i> <i>*</i><i>state</i> = (<i>struct</i> <i>State</i><i>*</i>) <i>arg</i>;

    <i>while</i> (<i>state</i><i>-&gt;</i><i>b</i> <i>!=</i> 0) {
        <i>printf</i>(<i>"b = %d
"</i>, <i>state</i><i>-&gt;</i><i>b</i>);
        <i>state</i><i>-&gt;</i><i>b</i><i>--</i>;
        <i>sleep</i>(1);
    }
    <i>return</i> <i>NULL</i>;
}

<i>int</i> <i>main</i>() {
    <i>struct</i> <i>State</i> <i>state</i> = { .<i>a</i> = 3, .<i>b</i> = 3 };

    <i>pthread_t</i> <i>t1</i>, <i>t2</i>;
    <i>pthread_create</i>(<i>&amp;</i><i>t1</i>, <i>NULL</i>, <i>t1_work</i>, <i>&amp;</i><i>state</i>);
    <i>pthread_create</i>(<i>&amp;</i><i>t2</i>, <i>NULL</i>, <i>t2_work</i>, <i>&amp;</i><i>state</i>);

    <i>pthread_join</i>(<i>t1</i>, <i>NULL</i>);
    <i>pthread_join</i>(<i>t2</i>, <i>NULL</i>);

    <i>return</i> 0;
}
</code></p></pre>
<p>The code is a tad verbose, but the idea is: we have one global <code>struct State</code>
instance, and we let two threads operate on it.</p>
<p>The program compiles and runs fine.</p>
<pre><p>Shell session</p><p><code>$ gcc -Wall main.c -o main -lpthread &amp;&amp; ./main
a = 3
b = 3
b = 2
a = 2
b = 1
a = 1
</code></p></pre>
<p>We can do a literal translation of that program to Rust, using raw pointers:</p>
<pre><p>Rust code</p><p><code><i>// oh god, please don't copy paste this</i>

<i>use</i> std<i>::</i>{thread, time<i>::</i>Duration}<i>;</i>

<i>struct</i> <i>State</i> {
    <i>a</i>: <i>i32</i>,
    <i>b</i>: <i>i32</i>,
}

<i>fn</i> <i>t1_work</i><i>(</i><i>arg</i>: <i>usize</i><i>)</i> {
    <i>let</i> state = arg <i>as</i> <i>*</i><i>mut</i> <i>State</i><i>;</i>

    <i>while</i> <i>unsafe</i> { <i>(</i><i>*</i>state<i>)</i><i>.</i><i>a</i> } != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"a = {}"</i>, <i>unsafe</i> { <i>(</i>*state<i>)</i>.a }<i>)</i><i>;</i>
        <i>unsafe</i> { <i>(</i><i>*</i>state<i>)</i><i>.</i><i>a</i> -= <i>1</i> }<i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>t2_work</i><i>(</i><i>arg</i>: <i>usize</i><i>)</i> {
    <i>let</i> state = arg <i>as</i> <i>*</i><i>mut</i> <i>State</i><i>;</i>

    <i>while</i> <i>unsafe</i> { <i>(</i><i>*</i>state<i>)</i><i>.</i><i>b</i> } != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"b = {}"</i>, <i>unsafe</i> { <i>(</i>*state<i>)</i>.b }<i>)</i><i>;</i>
        <i>unsafe</i> { <i>(</i><i>*</i>state<i>)</i><i>.</i><i>b</i> -= <i>1</i> }<i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> state = <i>State</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>3</i> }<i>;</i>
    <i>let</i> state_ptr = <i>&amp;</i><i>mut</i> state <i>as</i> <i>*</i><i>mut</i> <i>_</i> <i>as</i> <i>usize</i><i>;</i>

    <i>let</i> t1 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t1_work</i><i>(</i>state_ptr<i>)</i><i>)</i><i>;</i>
    <i>let</i> t2 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t2_work</i><i>(</i>state_ptr<i>)</i><i>)</i><i>;</i>

    t1<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    t2<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>And it'll work exactly the same way:</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
a = 3
b = 3
a = 2
b = 2
a = 1
b = 1
</code></p></pre>
<p>But that is <em>unsafe Rust</em>. It's not what you would want to write, if you
wanted to benefit from the memory safety guarantees that Rust offer.</p>
<p>Because, for example, things like that might happen:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> state_ptr = {
        <i>let</i> <i>mut</i> state = <i>State</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>3</i> }<i>;</i>
        <i>&amp;</i><i>mut</i> state <i>as</i> <i>*</i><i>mut</i> <i>_</i> <i>as</i> <i>usize</i>
    }<i>;</i>

    <i>// `state_ptr` is now dangling</i>
    <i>let</i> t1 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t1_work</i><i>(</i>state_ptr<i>)</i><i>)</i><i>;</i>
    <i>let</i> t2 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t2_work</i><i>(</i>state_ptr<i>)</i><i>)</i><i>;</i>

    t1<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    t2<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>Want to see what a release build of that version shows?</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet --release

</code></p></pre>
<p>Nothing.</p>
<p>If I run it in GDB, it shows me nonsense, like:</p>
<pre><p><code>[New Thread 0x7ffff7d7f700 (LWP 178699)]
a = -9808
[New Thread 0x7ffff7b7e700 (LWP 178700)]
b = 32767
[Thread 0x7ffff7b7e700 (LWP 178700) exited]
[Thread 0x7ffff7d7f700 (LWP 178699) exited]
</code></p></pre>
<p>Or, instead of silent data corruption, you could have a data race:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> state = <i>State</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>3</i> }<i>;</i>
    <i>let</i> state_ptr = <i>&amp;</i><i>mut</i> state <i>as</i> <i>*</i><i>mut</i> <i>_</i> <i>as</i> <i>usize</i><i>;</i>

    <i>let</i> t1 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t1_work</i><i>(</i>state_ptr<i>)</i><i>)</i><i>;</i>
    <i>// look closely...</i>
    <i>let</i> t2 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t1_work</i><i>(</i>state_ptr<i>)</i><i>)</i><i>;</i>

    t1<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    t2<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
a = 3
a = 2
a = 1
a = 1
a = -1
a = -2
a = -3
a = -3
a = -5
a = -5
a = -7
a = -7
^C
</code></p></pre>
<p>I was lucky to see the elusive data race the first time I ran it. But the
second time...</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
a = 3
a = 2
a = 1
</code></p></pre>
<p>Everything appeared to work fine.</p>
<p>So - that's not safe Rust. Safe Rust ensures memory safety <em>and</em> prevents
data races, which we've just seen examples of.</p>
<p>So for example, if we remove some of the naughty from the code:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>t1_work</i><i>(</i><i>state</i>: <i>*</i><i>mut</i> <i>State</i><i>)</i> {
    <i>// omitted</i>
}

<i>fn</i> <i>t2_work</i><i>(</i><i>state</i>: <i>*</i><i>mut</i> <i>State</i><i>)</i> {
    <i>// omitted</i>
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> state = <i>State</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>3</i> }<i>;</i>
    <i>// was `usize`, now a `*mut State`</i>
    <i>let</i> state_ptr = <i>&amp;</i><i>mut</i> state <i>as</i> <i>*</i><i>mut</i> <i>_</i><i>;</i>

    <i>let</i> t1 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t1_work</i><i>(</i>state_ptr<i>)</i><i>)</i><i>;</i>
    <i>let</i> t2 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t1_work</i><i>(</i>state_ptr<i>)</i><i>)</i><i>;</i>

    t1<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    t2<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>...then the compiler has enough information to avert the disaster.
It's not a number (<code>usize</code>) we're passing... it's a pointer!</p>
<p>And you can't just send pointers to other threads willy-nilly.</p>
<pre><p><code>error[E0277]: `*mut State` cannot be sent between threads safely                                                                                                      
   --&gt; src/main.rs:29:14                                                           
    |                                    
29  |     let t1 = thread::spawn(move || t1_work(state_ptr));                                                                                                         
    |              ^^^^^^^^^^^^^ -------------------------- within this `[closure@src/main.rs:29:28: 29:54 state_ptr:*mut State]`                                     
    |              |                     
    |              `*mut State` cannot be sent between threads safely                                                                                                 
    |                                    
   ::: /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/thread/mod.rs:616:8                                              
    |                                    
616 |     F: Send + 'static,             
    |        ---- required by this bound in `std::thread::spawn`                                                                                                      
    |                                    
    = help: within `[closure@src/main.rs:29:28: 29:54 state_ptr:*mut State]`, the trait `std::marker::Send` is not implemented for `*mut State`                       
    = note: required because it appears within the type `[closure@src/main.rs:29:28: 29:54 state_ptr:*mut State]`    
</code></p></pre>
<p>What you <em>can</em> send is a <code>Mutex</code>.</p>
<pre><p>Rust code</p><p><code><i>// (this doesn't work)</i>

<i>use</i> std<i>::</i>{sync<i>::</i>Mutex, thread, time<i>::</i>Duration}<i>;</i>

<i>struct</i> <i>State</i> {
    <i>a</i>: <i>i32</i>,
    <i>b</i>: <i>i32</i>,
}

<i>fn</i> <i>t1_work</i><i>(</i><i>state</i>: <i>&amp;</i><i>Mutex</i><i>&lt;</i><i>&amp;</i><i>mut</i> <i>State</i><i>&gt;</i><i>)</i> {
    <i>let</i> <i>mut</i> state = state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>while</i> state<i>.</i><i>a</i> != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"a = {}"</i>, state.a<i>)</i><i>;</i>
        state<i>.</i><i>a</i> -= <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>t2_work</i><i>(</i><i>state</i>: <i>&amp;</i><i>Mutex</i><i>&lt;</i><i>&amp;</i><i>mut</i> <i>State</i><i>&gt;</i><i>)</i> {
    <i>let</i> <i>mut</i> state = state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>while</i> state<i>.</i><i>b</i> != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"b = {}"</i>, state.b<i>)</i><i>;</i>
        state<i>.</i><i>b</i> -= <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> state = <i>State</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>3</i> }<i>;</i>
    <i>let</i> m = <i>Mutex</i><i>::</i><i>new</i><i>(</i><i>&amp;</i><i>mut</i> state<i>)</i><i>;</i>

    <i>let</i> t1 = thread<i>::</i><i>spawn</i><i>(</i>|| <i>t1_work</i><i>(</i><i>&amp;</i>m<i>)</i><i>)</i><i>;</i>
    <i>let</i> t2 = thread<i>::</i><i>spawn</i><i>(</i>|| <i>t2_work</i><i>(</i><i>&amp;</i>m<i>)</i><i>)</i><i>;</i>

    t1<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    t2<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>But then we have other issues:</p>
<pre><p><code>error[E0597]: `state` does not live long enough                                                                                                                             
  --&gt; src/main.rs:30:24                                                                                                                                                     
   |                                                                                                                                                                        
30 |     let m = Mutex::new(&amp;mut state);                                                                                                                                    
   |             -----------^^^^^^^^^^-                                                                                                                                     
   |             |          |                                                                                                                                               
   |             |          borrowed value does not live long enough                                                                                                        
   |             argument requires that `state` is borrowed for `'static`                                                                                                   
...                                                                                                                                                                         
37 | }                                                                                                                                                                      
   | - `state` dropped here while still borrowed                                                                                                                            
                                           
error[E0373]: closure may outlive the current function, but it borrows `m`, which is owned by the current function
  --&gt; src/main.rs:32:28
   |
32 |     let t1 = thread::spawn(|| t1_work(&amp;m));
   |                            ^^          - `m` is borrowed here
   |                            |
   |                            may outlive borrowed value `m`
   |
note: function requires argument type to outlive `'static`
  --&gt; src/main.rs:32:14
   |
32 |     let t1 = thread::spawn(|| t1_work(&amp;m));
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `m` (and any other referenced variables), use the `move` keyword
   |
32 |     let t1 = thread::spawn(move || t1_work(&amp;m));
   |                            ^^^^^^^
</code></p></pre>
<p>Why does this happen? Because we don't respect the contract that
<code>thread::spawn</code> asks for.</p>
<p><code>thread::spawn</code> takes a function, and intends to run it til death do us part.
So, it wants that function to have the lifetime <code>'static</code>, in other words, it
wants it to "never die".</p>
<p>But the function we're passing to <code>thread::spawn</code> is a closure, and it borrows
(captures a reference to) some locals from <code>main</code>.</p>
<p>Again - we're smarter than Rust here. Or, more accurately: we have more
knowledge. We know that we wait for both threads to finish before returning
from <code>main</code>.</p>

<p>What's that?</p>
<div>

<p>Nothing, nothing, keep going.</p>
</div>
<p>So, since we know that, we can kick some doors down and have it our way:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>t1_work</i><i>(</i><i>state</i>: <i>TrustMeItsFine</i><i>)</i> {
    <i>// omitted</i>
}

<i>fn</i> <i>t2_work</i><i>(</i><i>state</i>: <i>TrustMeItsFine</i><i>)</i> {
    <i>// omitted</i>
}

<i>struct</i> <i>TrustMeItsFine</i><i>(</i><i>*</i><i>const</i> <i>Mutex</i><i>&lt;</i><i>&amp;</i><i>'</i><i>static</i> <i>mut</i> <i>State</i><i>&gt;</i><i>)</i><i>;</i>

<i>impl</i> std<i>::</i>ops<i>::</i><i>Deref</i> <i>for</i> <i>TrustMeItsFine</i> {
    <i>type</i> <i>Target</i> = <i>Mutex</i><i>&lt;</i><i>&amp;</i><i>'</i><i>static</i> <i>mut</i> <i>State</i><i>&gt;</i><i>;</i>

    <i>fn</i> <i>deref</i><i>(</i><i>&amp;</i><i>self</i><i>)</i> -&gt; <i>&amp;</i>Self<i>::</i><i>Target</i> {
        <i>unsafe</i> { <i>self</i><i>.</i><i>0</i><i>.</i><i>as_ref</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i> }
    }
}

<i>unsafe</i> <i>impl</i> <i>Send</i> <i>for</i> <i>TrustMeItsFine</i> {}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>"Doing the work..."</i><i>)</i><i>;</i>
    <i>work</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>"Waiting a bit..."</i><i>)</i><i>;</i>
    thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>2</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>"Okay, bye now!"</i><i>)</i><i>;</i>
}

<i>fn</i> <i>work</i><i>(</i><i>)</i> {
    <i>let</i> state = <i>Box</i><i>::</i><i>leak</i><i>(</i><i>Box</i><i>::</i><i>new</i><i>(</i><i>State</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>3</i> }<i>)</i><i>)</i><i>;</i>
    <i>let</i> m = <i>Mutex</i><i>::</i><i>new</i><i>(</i>state<i>)</i><i>;</i>

    <i>let</i> t1_arg = TrustMeItsFine<i>(</i><i>&amp;</i>m <i>as</i> <i>*</i><i>const</i> <i>_</i><i>)</i><i>;</i>
    <i>let</i> t1 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t1_work</i><i>(</i>t1_arg<i>)</i><i>)</i><i>;</i>
    <i>let</i> t2_arg = TrustMeItsFine<i>(</i><i>&amp;</i>m <i>as</i> <i>*</i><i>const</i> <i>_</i><i>)</i><i>;</i>
    <i>let</i> t2 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t2_work</i><i>(</i>t2_arg<i>)</i><i>)</i><i>;</i>

    t1<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    t2<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>This works perfectly fine!</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
Doing the work...
a = 3
a = 2
a = 1
b = 3
b = 2
b = 1
Waiting a bit...
Okay, bye now!
</code></p></pre>
<p>Because we know exactly what our code does, we don't have to follow
Rust's rigid rules, and we can just..</p>
<div>

<p>Hoooooold on.</p>
<p>Hold on a minute.</p>
</div>
<p>What?</p>
<div>

<p>You said "since we wait for both threads to end" (via <code>join</code>), then
we're fine.</p>
<p>Are you sure about that?</p>
</div>
<p>Well yeah, look:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>work</i><i>(</i><i>)</i> {
    <i>let</i> state = <i>Box</i><i>::</i><i>leak</i><i>(</i><i>Box</i><i>::</i><i>new</i><i>(</i><i>State</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>3</i> }<i>)</i><i>)</i><i>;</i>
    <i>// the Mutex is constructed here:</i>
    <i>let</i> m = <i>Mutex</i><i>::</i><i>new</i><i>(</i>state<i>)</i><i>;</i>

    <i>let</i> t1_arg = TrustMeItsFine<i>(</i><i>&amp;</i>m <i>as</i> <i>*</i><i>const</i> <i>_</i><i>)</i><i>;</i>
    <i>let</i> t1 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t1_work</i><i>(</i>t1_arg<i>)</i><i>)</i><i>;</i>
    <i>let</i> t2_arg = TrustMeItsFine<i>(</i><i>&amp;</i>m <i>as</i> <i>*</i><i>const</i> <i>_</i><i>)</i><i>;</i>
    <i>let</i> t2 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t2_work</i><i>(</i>t2_arg<i>)</i><i>)</i><i>;</i>

    <i>// we're waiting for both threads here:</i>
    t1<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    t2<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>// and here, the Mutex is freed</i>
}
</code></p></pre>
<p>Looks okay to me?</p>
<div>

<p>Yeah, but consider this:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>t1_work</i><i>(</i><i>state</i>: <i>TrustMeItsFine</i><i>)</i> {
    <i>panic</i><i>!</i><i>(</i><i>"uh oh"</i><i>)</i><i>;</i>

    <i>let</i> <i>mut</i> state = state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>while</i> state<i>.</i><i>a</i> != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"a = {}"</i>, state.a<i>)</i><i>;</i>
        state<i>.</i><i>a</i> -= <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}
</code></p></pre></div>
<p>So what? The entire app will just crash and burn as soon as we <code>panic</code>.</p>
<div>

<p>And now this:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>println</i><i>!</i><i>(</i><i>"Doing the work..."</i><i>)</i><i>;</i>
    std<i>::</i>panic<i>::</i><i>catch_unwind</i><i>(</i>|| {
        <i>work</i><i>(</i><i>)</i><i>;</i>
    }<i>)</i><i>.</i><i>ok</i><i>(</i><i>)</i><i>;</i>

    <i>println</i><i>!</i><i>(</i><i>"Waiting a bit..."</i><i>)</i><i>;</i>
    thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>2</i><i>)</i><i>)</i><i>;</i>
    <i>println</i><i>!</i><i>(</i><i>"Okay, bye now!"</i><i>)</i><i>;</i>
}
</code></p></pre></div>
<p>Oh.</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
Doing the work...
thread '&lt;unnamed&gt;' panicked at 'uh oh', src/main.rs:11:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
b = 3
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Any', src/main.rs:64:5
Waiting a bit...
b = 21849
[1]    185366 segmentation fault (core dumped)  cargo run --quiet
</code></p></pre>
<p>Uh oh.</p>
<p>Yeah okay maybe Rust has a point.</p>
<p>Maybe we shouldn't be trusted, and maybe it's <em>not</em> fine. And that's a
recurring theme when writing <code>unsafe</code> code.</p>
<p>So let's just not write <code>unsafe</code> code.</p>
<p>We have a couple of options here. We could make our <code>state</code> reference-counted,
so that as long as either thread it's alive, it'll be alive.</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>{
    sync<i>::</i>{Arc, Mutex},
    thread,
    time<i>::</i>Duration,
}<i>;</i>

<i>struct</i> <i>State</i> {
    <i>a</i>: <i>i32</i>,
    <i>b</i>: <i>i32</i>,
}

<i>fn</i> <i>t1_work</i><i>(</i><i>state</i>: <i>Arc</i><i>&lt;</i><i>Mutex</i><i>&lt;</i><i>State</i><i>&gt;</i><i>&gt;</i><i>)</i> {
    <i>let</i> <i>mut</i> state = state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>while</i> state<i>.</i><i>a</i> != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"a = {}"</i>, state.a<i>)</i><i>;</i>
        state<i>.</i><i>a</i> -= <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>t2_work</i><i>(</i><i>state</i>: <i>Arc</i><i>&lt;</i><i>Mutex</i><i>&lt;</i><i>State</i><i>&gt;</i><i>&gt;</i><i>)</i> {
    <i>let</i> <i>mut</i> state = state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>

    <i>while</i> state<i>.</i><i>b</i> != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"b = {}"</i>, state.b<i>)</i><i>;</i>
        state<i>.</i><i>b</i> -= <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>work</i><i>(</i><i>)</i> {
    <i>let</i> state1 = <i>Arc</i><i>::</i><i>new</i><i>(</i><i>Mutex</i><i>::</i><i>new</i><i>(</i><i>State</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>3</i> }<i>)</i><i>)</i><i>;</i>
    <i>let</i> state2 = state1<i>.</i><i>clone</i><i>(</i><i>)</i><i>;</i>

    <i>let</i> t1 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t1_work</i><i>(</i>state1<i>)</i><i>)</i><i>;</i>
    <i>let</i> t2 = thread<i>::</i><i>spawn</i><i>(</i><i>move</i> || <i>t2_work</i><i>(</i>state2<i>)</i><i>)</i><i>;</i>

    t1<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
    t2<i>.</i><i>join</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}

<i>// omitted: main</i>
</code></p></pre>
<p>And now, there's no compiler errors left (and no <code>unsafe</code> code, either!)</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
Doing the work...
a = 3
a = 2
a = 1
b = 3
b = 2
b = 1
Waiting a bit...
Okay, bye now!
</code></p></pre>
<p>Of course, uh, this is not really what we were going for. We have a single
lock for the entire <code>State</code>, and we acquire it for the <em>entire duration</em>
of either thread's life.</p>
<p>We could fix it like that:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>t1_work</i><i>(</i><i>state</i>: <i>Arc</i><i>&lt;</i><i>Mutex</i><i>&lt;</i><i>State</i><i>&gt;</i><i>&gt;</i><i>)</i> {
    <i>while</i> state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>.</i><i>a</i> != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"a = {}"</i>, state.lock<i>(</i><i>)</i>.unwrap<i>(</i><i>)</i>.a<i>)</i><i>;</i>
        state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>.</i><i>a</i> -= <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>t2_work</i><i>(</i><i>state</i>: <i>Arc</i><i>&lt;</i><i>Mutex</i><i>&lt;</i><i>State</i><i>&gt;</i><i>&gt;</i><i>)</i> {
    <i>while</i> state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>.</i><i>b</i> != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"b = {}"</i>, state.lock<i>(</i><i>)</i>.unwrap<i>(</i><i>)</i>.b<i>)</i><i>;</i>
        state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>.</i><i>b</i> -= <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}
</code></p></pre>
<p>And, although a bit verbose, it works:</p>
<pre><p>Shell session</p><p><code>$ cargo run --quiet
Doing the work...
b = 3
a = 3
b = 2
a = 2
b = 1
a = 1
Waiting a bit...
Okay, bye now!
</code></p></pre>
<p>But now; well, not now, but <em>later</em>, when we increase the number of threads,
we're going to have a "lock contention" problem.</p>
<p>Even though we're only locking the <code>Mutex</code> whenever we actually need to read
from, or write to it, that's still a <em>lot</em> of locking for a single lock. If we
have a couple hundred threads, and if we remove the sleep, we're definitely
going to start feeling it.</p>
<p>So, what can we do? Use <a href="https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicI32.html">AtomicI32</a>? Seems a bit silly there, doesn't it?</p>
<p>Here's my proposal: The first thing we want to be able to do is to have our
worker threads <em>borrow</em> from the state. Borrow mutably, even.</p>
<p>There is a crate for that, and its name is <a href="https://lib.rs/crates/crossbeam">crossbeam</a>.</p>
<pre><p>Shell session</p><p><code>$ cargo add crossbeam
    Updating 'https://github.com/rust-lang/crates.io-index' index
      Adding crossbeam v0.7.3 to dependencies
</code></p></pre><pre><p>Rust code</p><p><code><i>fn</i> <i>t1_work</i><i>(</i><i>state</i>: <i>&amp;</i><i>Mutex</i><i>&lt;</i><i>&amp;</i><i>mut</i> <i>State</i><i>&gt;</i><i>)</i> {
    <i>// omitted (same code)</i>
}

<i>fn</i> <i>t2_work</i><i>(</i><i>state</i>: <i>&amp;</i><i>Mutex</i><i>&lt;</i><i>&amp;</i><i>mut</i> <i>State</i><i>&gt;</i><i>)</i> {
    <i>// same here</i>
}

<i>fn</i> <i>work</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> state = <i>State</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>3</i> }<i>;</i>
    <i>let</i> m = <i>Mutex</i><i>::</i><i>new</i><i>(</i><i>&amp;</i><i>mut</i> state<i>)</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>t1_work</i><i>(</i><i>&amp;</i>m<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>t2_work</i><i>(</i><i>&amp;</i>m<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>How does this differ from <code>std::thread::spawn</code>? Well, now our threads are
<em>scoped</em>. We know that when <code>crossbeam::scope</code> returns, *all the threads we've
<em>spawned</em> will have terminated. Even if some of them panic.</p>
<p>So, threads in a crossbeam scope can borrow from their environment (here,
from one of main's locals).</p>
<p>Now, we no longer need an <code>std::sync::Arc</code> - we no longer do any reference
counting. Which means our program is more efficient. Hurray!</p>
<p>We still have a bunch of locking though:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>t1_work</i><i>(</i><i>state</i>: <i>&amp;</i><i>Mutex</i><i>&lt;</i><i>&amp;</i><i>mut</i> <i>State</i><i>&gt;</i><i>)</i> {
    <i>while</i> state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>.</i><i>a</i> != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"a = {}"</i>, state.lock<i>(</i><i>)</i>.unwrap<i>(</i><i>)</i>.a<i>)</i><i>;</i>
        state<i>.</i><i>lock</i><i>(</i><i>)</i><i>.</i><i>unwrap</i><i>(</i><i>)</i><i>.</i><i>a</i> -= <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}
</code></p></pre>
<p>How do we fix that?</p>
<p>Well - we know in our heart that <code>t1_work</code> only ever accesses <code>state.a</code> and
<code>t2_work</code> only accesses <code>state.b</code>... but we haven't told the Rust compiler
that.</p>
<div>

<p>But again, can't it see it?</p>
</div>
<p>It can see it from the contents of <code>t1_work</code> and the contents of <code>t2_work</code>,
but it isn't using that information to deduce anything. Because <code>t1_work</code>
might actually be in another crate - and then all we have to go by is its
type signature.</p>
<p>So, what if, instead of taking a mutable reference to the entire <code>State</code>,
we only took a mutable reference to the fields we wanted?</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>t1_work</i><i>(</i><i>a</i>: <i>&amp;</i><i>mut</i> <i>i32</i><i>)</i> {
    <i>while</i> <i>*</i>a != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"a = {}"</i>, a<i>)</i><i>;</i>
        <i>*</i>a -= <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>t2_work</i><i>(</i><i>b</i>: <i>&amp;</i><i>mut</i> <i>i32</i><i>)</i> {
    <i>while</i> <i>*</i>b != <i>0</i> {
        <i>println</i><i>!</i><i>(</i><i>"b = {}"</i>, b<i>)</i><i>;</i>
        <i>*</i>b -= <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}
</code></p></pre>
<p>Then we wouldn't even need a <code>Mutex</code>, since we can borrow mutably <em>non-overlapping
parts of <code>state</code></em> at the same time:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>work</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> state = <i>State</i> { <i>a</i>: <i>3</i>, <i>b</i>: <i>3</i> }<i>;</i>
    <i>// this is fine</i>
    <i>let</i> a = <i>&amp;</i><i>mut</i> state<i>.</i><i>a</i><i>;</i>
    <i>// this is also fine</i>
    <i>let</i> b = <i>&amp;</i><i>mut</i> state<i>.</i><i>b</i><i>;</i>
    <i>// there's nothing left to borrow from `state` at this point</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>t1_work</i><i>(</i>a<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>t2_work</i><i>(</i>b<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre>
<p>Note that this approach generalizes well. For example, let's say we need to borrow
multiple fields from our <code>State</code> struct:</p>
<pre><p>Rust code</p><p><code><i>use</i> std<i>::</i>{thread, time<i>::</i>Duration}<i>;</i>

<i>struct</i> <i>State</i> {
    <i>a</i>: <i>i32</i>,
    <i>b</i>: <i>i32</i>,
    <i>max</i>: <i>i32</i>,
}

<i>fn</i> <i>work</i><i>(</i><i>name</i>: <i>&amp;</i><i>str</i>, <i>counter</i>: <i>&amp;</i><i>mut</i> <i>i32</i>, <i>max</i>: <i>&amp;</i><i>i32</i><i>)</i> {
    <i>while</i> <i>*</i>counter &lt; <i>*</i>max {
        <i>println</i><i>!</i><i>(</i><i>"{} = {}"</i>, name, counter<i>)</i><i>;</i>
        <i>*</i>counter += <i>1</i><i>;</i>
        thread<i>::</i><i>sleep</i><i>(</i><i>Duration</i><i>::</i><i>from_secs</i><i>(</i><i>1</i><i>)</i><i>)</i><i>;</i>
    }
}

<i>fn</i> <i>main</i><i>(</i><i>)</i> {
    <i>let</i> <i>mut</i> state = <i>State</i> { <i>a</i>: <i>0</i>, <i>b</i>: <i>0</i>, <i>max</i>: <i>3</i> }<i>;</i>
    <i>let</i> a = <i>&amp;</i><i>mut</i> state<i>.</i><i>a</i><i>;</i>
    <i>let</i> b = <i>&amp;</i><i>mut</i> state<i>.</i><i>b</i><i>;</i>
    <i>let</i> max = <i>&amp;</i>state<i>.</i><i>max</i><i>;</i>

    crossbeam<i>::</i><i>scope</i><i>(</i>|s| {
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>work</i><i>(</i><i>"a"</i>, a, max<i>)</i><i>)</i><i>;</i>
        s<i>.</i><i>spawn</i><i>(</i>|_| <i>work</i><i>(</i><i>"b"</i>, b, max<i>)</i><i>)</i><i>;</i>
    }<i>)</i>
    <i>.</i><i>unwrap</i><i>(</i><i>)</i><i>;</i>
}
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo run --quiet
b = 0
a = 0
b = 1
a = 1
b = 2
a = 2
</code></p></pre><div>

<p>In Rust, we don't tend to think of "state" as a monolith. It's not just one
big class (or one big struct) that everything feeds back into.</p>
<p>Because the amount of "valid Rust programs" (programs that compile) is
severely limited by Rust's rules: lifetimes, marker traits, etc., it is often
necessary to rethink the structure of a program just to get it to compile.</p>
<p>It's an essential part of "thinking in Rust".</p>
<p>In many cases, splitting application state in several separate structs helps
a lot. More granularity helps expressing the actual lifetime constraints needed
for the program to borrow-check.</p>
</div>
<h2>Foundational learning takes time</h2>
<p>Finally, I'd like to leave you with some words of encouragement.</p>
<p>Even if you try you darndest to learn Rust, and focus real hard, chances are,
it'll take you some time (and a few tries) to "get it".</p>
<p>And is there really such a thing as "getting it"? Rust is an entirely new
type of game. There's definitely a pro scene already, but there is still much
to be done. The language is evolving, and we, collectively, haven't yet
figured out everything that new way of thinking unlocks.</p>
<p>So smart small, don't get discouraged, and just keep at it!</p>

</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>