<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Database basics: writing a SQL database from scratch in Go - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Database basics: writing a SQL database from scratch in Go - linksfor.dev(s)"/>
    <meta property="og:description" content="Database basics: writing a SQL database from scratch in Go"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://notes.eatonphil.com/database-basics.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Database basics: writing a SQL database from scratch in Go</title>
<div class="readable">
        <h1>Database basics: writing a SQL database from scratch in Go</h1>
            <div>Reading time: 28-36 minutes</div>
        <div>Posted here: 13 Apr 2020</div>
        <p><a href="https://notes.eatonphil.com/database-basics.html">https://notes.eatonphil.com/database-basics.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
      <div>
        <p>
  Next in database basics:
  <!-- forgive me, for I have sinned -->
  <br>
  <a href="https://notes.eatonphil.com/database-basics-expressions-and-where.html">Database basics (2): binary expressions and WHERE filters</a>
</p><p>In this series we'll write a rudimentary database from
scratch in Go. Project source code is available on
<a href="https://github.com/eatonphil/gosql">Github</a>.</p>
<p>In this first post we'll build enough of a parser to run some simple
<code>CREATE</code>, <code>INSERT</code>, and <code>SELECT</code>
queries. Then we'll build an in-memory backend
supporting <code>TEXT</code> and <code>INT</code> types and write a
basic REPL.</p>
<p>We'll be able to support the following interaction:</p>
<pre><code>$ go run *.go
Welcome to gosql.
# <span>CREATE</span> <span>TABLE</span> <span>users</span> (<span>id</span> <span>INT</span>, <span>name</span> <span>TEXT</span>);
ok
# <span>INSERT</span> <span>INTO</span> <span>users</span> <span>VALUES</span> (<span>1</span>, <span>'Phil'</span>);
ok
# <span>SELECT</span> <span>id</span>, <span>name</span> <span>FROM</span> <span>users</span>;
| id | name |
====================
| 1 |  Phil |
ok
# <span>INSERT</span> <span>INTO</span> <span>users</span> <span>VALUES</span> (<span>2</span>, <span>'Kate'</span>);
ok
# <span>SELECT</span> <span>name</span>, <span>id</span> <span>FROM</span> <span>users</span>;
| name | id |
====================
| Phil |  1 |
| Kate |  2 |
ok
</code></pre>
<p>The first stage will be to map a SQL source into a list of tokens
(lexing). Then we'll call parse functions to find individual SQL
statements (such as <code>SELECT</code>). These parse functions will
in turn call their own helper functions to find patterns of
recursively parseable chunks, keywords, symbols (like parenthesis),
identifiers (like a table name), and numeric or string literals.</p>
<p>Then, we'll write an in-memory backend to do operations based on an
AST. Finally, we'll write a REPL to accept SQL from a CLI and pass it
to the in-memory backend.</p>
<div><p>
  This post assumes a basic understanding of parsing concepts. We
  won't skip any code, but also won't go into great detail on why we
  structure the way we do.
  </p><p>
  
  For a simpler introduction to parsing and parsing concepts,
  see <a href="https://notes.eatonphil.com/writing-a-simple-json-parser.html">this post on
  parsing JSON</a>.
</p></div><h3 id="lexing">Lexing</h3><p>The lexer is responsible for finding every distinct group of
characters in source code: tokens. This will consist primarily of
identifiers, numbers, strings, and symbols.</p>
<p>The gist of the logic will be to pass control to a helper function for
each kind of token. If the helper function succeeds in finding a
token, it will return true and the location for the lexer to start at
next. It will continue doing this until it reaches the end of the
source.</p>
<p>First off, we'll define a few types and constants for use
in <code>lexer.go</code>:</p>
<pre><code><span>package gosql

<span>import</span> (<span>
    <span>"fmt"</span>
    <span>"strings"</span>
</span>)

type location <span>struct</span> </span>{
    line <span>uint</span>
    col  <span>uint</span>
}

<span>type keyword <span>string</span>

<span>const</span> (<span>
    selectKeyword keyword = <span>"select"</span>
    fromKeyword   keyword = <span>"from"</span>
    asKeyword     keyword = <span>"as"</span>
    tableKeyword  keyword = <span>"table"</span>
    createKeyword keyword = <span>"create"</span>
    insertKeyword keyword = <span>"insert"</span>
    intoKeyword   keyword = <span>"into"</span>
    valuesKeyword keyword = <span>"values"</span>
    intKeyword    keyword = <span>"int"</span>
    textKeyword   keyword = <span>"text"</span>
</span>)

type symbol <span>string</span>

<span>const</span> (<span>
    semicolonSymbol  symbol = <span>";"</span>
    asteriskSymbol   symbol = <span>"*"</span>
    commaSymbol      symbol = <span>","</span>
    leftparenSymbol  symbol = <span>"("</span>
    rightparenSymbol symbol = <span>")"</span>
</span>)

type tokenKind <span>uint</span>

<span>const</span> (<span>
    keywordKind tokenKind = iota
    symbolKind
    identifierKind
    stringKind
    numericKind
</span>)

type token <span>struct</span> </span>{
    <span>value</span> <span>string</span>
    kind  tokenKind
    loc   location
}

type cursor <span>struct</span> {
    pointer <span>uint</span>
    loc     location
}

func (t *token) <span>equals</span>(other *token) <span>bool</span> {
    <span>return</span> t.<span>value</span> == other.<span>value</span> &amp;&amp; t.kind == other.kind
}

<span>type lexer <span>func</span>(<span><span>string</span>, cursor</span>) (<span>*token, cursor, <span>bool</span></span>)
</span></code></pre>
<p>Next we'll write out the main loop:</p>
<pre><code><span>func <span>lex</span>(<span>source <span>string</span></span>) (<span>[]*token, error</span>) </span>{
    tokens := []*token{}
    cur := cursor{}

lex:
    <span>for</span> cur.pointer &lt; <span>uint</span>(len(source)) {
        lexers := []lexer{lexKeyword, lexSymbol, lexString, lexNumeric, lexIdentifier}
        <span>for</span> _, l := range lexers {
            <span>if</span> token, newCursor, ok := l(source, cur); ok {
                cur = newCursor

                
                <span>if</span> token != nil {
                    tokens = append(tokens, token)
                }

                <span>continue</span> lex
            }
        }

        hint := <span>""</span>
        <span><span>if</span> <span>len</span>(<span>tokens</span>) &gt; 0 </span>{
            hint = <span>" after "</span> + tokens[len(tokens)<span>-1</span>].<span>value</span>
        }
        <span>return</span> nil, fmt.Errorf(<span>"Unable to lex token%s, at %d:%d"</span>, hint, cur.loc.line, cur.loc.col)
    }

    <span>return</span> tokens, nil
}
</code></pre>
<p>Then we'll write a helper for each kind of fundemental token.</p>
<h4 id="analyzing-numbers">Analyzing numbers</h4><p>Numbers are the most complex. So we'll refer to the <a href="https://www.postgresql.org/docs/current/sql-syntax-lexical.html">PostgreSQL
documentation (section
4.1.2.6)</a>
for what constitutes a valid number.</p>
<pre><code><span>func <span>lexNumeric</span>(<span>source <span>string</span>, ic cursor</span>) (<span>*token, cursor, <span>bool</span></span>) </span>{
    cur := ic

    periodFound := <span>false</span>
    expMarkerFound := <span>false</span>

    <span>for</span> ; cur.pointer &lt; <span>uint</span>(len(source)); cur.pointer++ {
        c := source[cur.pointer]
        cur.loc.col++

        isDigit := c &gt;= <span>'0'</span> &amp;&amp; c &lt;= <span>'9'</span>
        isPeriod := c == <span>'.'</span>
        isExpMarker := c == <span>'e'</span>

        
        <span>if</span> cur.pointer == ic.pointer {
            <span>if</span> !isDigit &amp;&amp; !isPeriod {
                <span>return</span> nil, ic, <span>false</span>
            }

            periodFound = isPeriod
            <span>continue</span>
        }

        <span>if</span> isPeriod {
            <span>if</span> periodFound {
                <span>return</span> nil, ic, <span>false</span>
            }

            periodFound = <span>true</span>
            <span>continue</span>
        }

        <span>if</span> isExpMarker {
            <span>if</span> expMarkerFound {
                <span>return</span> nil, ic, <span>false</span>
            }

            
            periodFound = <span>true</span>
            expMarkerFound = <span>true</span>

            
            <span>if</span> cur.pointer == <span>uint</span>(len(source)<span>-1</span>) {
                <span>return</span> nil, ic, <span>false</span>
            }

            cNext := source[cur.pointer+<span>1</span>]
            <span>if</span> cNext == <span>'-'</span> || cNext == <span>'+'</span> {
                cur.pointer++
                cur.loc.col++
            }

            <span>continue</span>
        }

        <span>if</span> !isDigit {
            <span>break</span>
        }
    }

    
    <span>if</span> cur.pointer == ic.pointer {
        <span>return</span> nil, ic, <span>false</span>
    }

    <span>return</span> &amp;token{
        <span>value</span>: source[ic.pointer:cur.pointer],
        loc:   ic.loc,
        kind:  numericKind,
    }, cur, <span>true</span>
}
</code></pre>
<h4 id="analyzing-strings">Analyzing strings</h4><p>Strings must start and end with a single apostrophe. They can contain
a single apostophe if it is followed by another single
apostrophe. We'll put this kind of character delimited lexing logic
into a helper function so we can use it again when analyzing
identifiers.</p>
<pre><code><span>func <span>lexCharacterDelimited</span>(<span>source <span>string</span>, ic cursor, delimiter <span>byte</span></span>) (<span>*token, cursor, <span>bool</span></span>) </span>{
    cur := <span>ic

    <span>if</span> <span>len</span>(<span>source[cur.pointer:]</span>) </span>== <span>0</span> {
        <span>return</span> nil, ic, <span>false</span>
    }

    <span>if</span> source[cur.pointer] != delimiter {
        <span>return</span> nil, ic, <span>false</span>
    }

    cur.loc.col++
    cur.pointer++

    <span>var</span> <span>value</span> []<span>byte</span>
    <span>for</span> ; cur.pointer &lt; <span>uint</span>(len(source)); cur.pointer++ {
        c := source[cur.pointer]

        <span>if</span> c == delimiter {
            
            <span>if</span> cur.pointer+<span>1</span> &gt;= <span>uint</span>(len(source)) || source[cur.pointer+<span>1</span>] != delimiter {
                <span>return</span> &amp;token{
                    <span>value</span>: <span>string</span>(<span>value</span>),
                    loc:   ic.loc,
                    kind:  stringKind,
                }, cur, <span>true</span>
            } <span>else</span> {
                <span>value</span> = append(<span>value</span>, delimiter)
                cur.pointer++
                cur.loc.col++
            }
        }

        <span>value</span> = append(<span>value</span>, c)
        cur.loc.col++
    }

    <span>return</span> nil, ic, <span>false</span>
}

<span>func <span>lexString</span>(<span>source <span>string</span>, ic cursor</span>) (<span>*token, cursor, <span>bool</span></span>) </span>{
    <span>return</span> lexCharacterDelimited(source, ic, <span>'''</span>)
}
</code></pre>
<h4 id="analyzing-symbols-and-keywords">Analyzing symbols and keywords</h4><p>Symbols and keywords come from a fixed set of strings, so they're easy
to compare against. Whitespace should be thrown away.</p>
<pre><code><span>func <span>lexSymbol</span>(<span>source <span>string</span>, ic cursor</span>) (<span>*token, cursor, <span>bool</span></span>) </span>{
    c := source[ic.pointer]
    cur := ic
    cur.loc.col++
    cur.pointer++

    <span>switch</span> c {
    
    <span>case</span> <span>'
'</span>:
        cur.loc.line++
        cur.loc.col = <span>0</span>
        fallthrough
    <span>case</span> <span>'	'</span>:
        fallthrough
    <span>case</span> <span>' '</span>:
        <span>return</span> nil, cur, <span>true</span>

    
    <span>case</span> <span>','</span>:
        fallthrough
    <span>case</span> <span>'('</span>:
        fallthrough
    <span>case</span> <span>')'</span>:
        fallthrough
    <span>case</span> <span>';'</span>:
        fallthrough
    <span>case</span> <span>'*'</span>:
        <span>break</span>

    
    <span>default</span>:
        <span>return</span> nil, ic, <span>false</span>
    }

    <span>return</span> &amp;token{
        <span>value</span>: <span>string</span>(c),
        loc:   ic.loc,
        kind:  symbolKind,
    }, cur, <span>true</span>
}
</code></pre>
<h4 id="analyzing-identifiers">Analyzing identifiers</h4><p>An identifier is either a double-quoted string or a group of
characters starting with an alphabetical character and possibly
containing numbers and underscores.</p>
<pre><code><span>func <span>lexIdentifier</span>(<span>source <span>string</span>, ic cursor</span>) (<span>*token, cursor, <span>bool</span></span>) </span>{
    
    <span>if</span> token, newCursor, ok := lexCharacterDelimited(source, ic, <span>'"'</span>); ok {
        <span>return</span> token, newCursor, <span>true</span>
    }

    cur := ic

    c := source[cur.pointer]
    
    isAlphabetical := (c &gt;= <span>'A'</span> &amp;&amp; c &lt;= <span>'Z'</span>) || (c &gt;= <span>'a'</span> &amp;&amp; c &lt;= <span>'z'</span>)
    <span>if</span> !isAlphabetical {
        <span>return</span> nil, ic, <span>false</span>
    }
    cur.pointer++
    cur.loc.col++

    <span>value</span> := []<span>byte</span>{c}
    <span>for</span> ; cur.pointer &lt; <span>uint</span>(len(source)); cur.pointer++ {
        c = source[cur.pointer]

        
        isAlphabetical := (c &gt;= <span>'A'</span> &amp;&amp; c &lt;= <span>'Z'</span>) || (c &gt;= <span>'a'</span> &amp;&amp; c &lt;= <span>'z'</span>)
        isNumeric := c &gt;= <span>'0'</span> &amp;&amp; c &lt;= <span>'9'</span>
        <span>if</span> isAlphabetical || isNumeric || c == <span>'$'</span> || c == <span>'_'</span> {
            <span>value</span> = append(<span>value</span>, c)
            cur.loc.col++
            <span>continue</span>
        }

        <span>break</span>
    }

    <span><span>if</span> <span>len</span>(<span><span>value</span></span>) </span>== <span>0</span> {
        <span>return</span> nil, ic, <span>false</span>
    }

    <span>return</span> &amp;token{
        
        <span>value</span>: strings.ToLower(<span>string</span>(<span>value</span>)),
        loc:   ic.loc,
        kind:  identifierKind,
    }, cur, <span>true</span>
}
</code></pre>
<p>And that's it for the lexer! If you copy
<a href="https://github.com/eatonphil/gosql/blob/master/lexer_test.go">lexer_test.go</a>
from the main project, the tests should now pass.</p>
<h3 id="ast-model">AST model</h3><p>At the highest level, an AST is a collection of statements:</p>
<pre><code><span>package</span> main

type Ast struct {
    <span>Statements</span> []*Statement
}
</code></pre>
<p>A statement, for now, is one of <code>INSERT</code>,
<code>CREATE</code>, or <code>SELECT</code>:</p>
<pre><code><span>type AstKind <span>uint</span>

<span>const</span> (<span>
    SelectKind AstKind = iota
    CreateTableKind
    InsertKind
</span>)

type Statement <span>struct</span> </span>{
    SelectStatement      *SelectStatement
    CreateTableStatement *CreateTableStatement
    InsertStatement      *InsertStatement
    Kind                 AstKind
}
</code></pre>
<h4 id="insert">INSERT</h4><p>An insert statement, for now, has a table name and a list of values to
insert:</p>
<pre><code><span>type</span> InsertStatement struct {
    <span>table</span>  token
    values *[]*expression
}
</code></pre>
<p>An expression is a literal token or (in the future) a function call or
inline operation:</p>
<pre><code><span>type expressionKind <span>uint</span>

<span>const</span> (<span>
    literalKind expressionKind = iota
</span>)

type expression <span>struct</span> </span>{
    literal *token
    kind    expressionKind
}
</code></pre>
<h4 id="create">CREATE</h4><p>A create statement, for now, has a table name and a list of column
names and types:</p>
<pre><code><span>type</span> columnDefinition struct {
    <span>name</span>     token
    datatype token
}

type CreateTableStatement struct {
    <span>name</span> token
    cols *[]*columnDefinition
}
</code></pre>
<h4 id="select">SELECT</h4><p>A select statement, for now, has a table name and a list of column
names:</p>
<pre><code>type SelectStatement <span>struct</span> {
    item []*expression
    <span>from</span> token
}
</code></pre>
<p>And that's it for the AST.</p>
<h3 id="parsing">Parsing</h3><p>The <code>Parse</code> entrypoint will take a list of tokens and
attempt to parse statements, separated by a semi-colon, until it
reaches the last token.</p>
<p>In general our strategy will be to increment and pass around a cursor
containing the current position of unparsed tokens. Each helper will
return the new cursor that the caller should start from.</p>
<pre><code><span>package main

<span>import</span> (<span>
    <span>"errors"</span>
    <span>"fmt"</span>
</span>)

func <span>tokenFromKeyword</span>(<span>k keyword</span>) token </span>{
    <span>return</span> token{
        kind:  keywordKind,
        <span>value</span>: <span>string</span>(k),
    }
}

<span>func <span>tokenFromSymbol</span>(<span>s symbol</span>) token </span>{
    <span>return</span> token{
        kind:  symbolKind,
        <span>value</span>: <span>string</span>(s),
    }
}

<span>func <span>expectToken</span>(<span>tokens []*token, cursor <span>uint</span>, t token</span>) <span>bool</span> </span>{
    <span>if</span> cursor &gt;= <span>uint</span>(len(tokens)) {
        <span>return</span> <span>false</span>
    }

    <span>return</span> t.<span>equals</span>(tokens[cursor])
}

<span>func <span>helpMessage</span>(<span>tokens []*token, cursor <span>uint</span>, msg <span>string</span></span>) </span>{
    <span>var</span> c *token
    <span>if</span> cursor &lt; <span>uint</span>(len(tokens)) {
        c = tokens[cursor]
    } <span>else</span> {
        c = tokens[cursor<span>-1</span>]
    }

    fmt.Printf(<span>"[%d,%d]: %s, got: %s
"</span>, c.loc.line, c.loc.col, msg, c.<span>value</span>)
}

<span>func <span>Parse</span>(<span>source <span>string</span></span>) (<span>*Ast, error</span>) </span>{
    tokens, err := lex(source)
    <span>if</span> err != nil {
        <span>return</span> nil, err
    }

    a := Ast{}
    cursor := <span>uint</span>(<span>0</span>)
    <span>for</span> cursor &lt; <span>uint</span>(len(tokens)) {
        stmt, newCursor, ok := parseStatement(tokens, cursor, tokenFromSymbol(semicolonSymbol))
        <span>if</span> !ok {
            helpMessage(tokens, cursor, <span>"Expected statement"</span>)
            <span>return</span> nil, errors.New(<span>"Failed to parse, expected statement"</span>)
        }
        cursor = newCursor

        a.Statements = append(a.Statements, stmt)

        atLeastOneSemicolon := <span><span>false</span>
        <span>for</span> <span>expectToken</span>(<span>tokens, cursor, tokenFromSymbol(semicolonSymbol</span>)) </span>{
            cursor++
            atLeastOneSemicolon = <span>true</span>
        }

        <span>if</span> !atLeastOneSemicolon {
            helpMessage(tokens, cursor, <span>"Expected semi-colon delimiter between statements"</span>)
            <span>return</span> nil, errors.New(<span>"Missing semi-colon between statements"</span>)
        }
    }

    <span>return</span> &amp;a, nil
}
</code></pre>
<h4 id="parsing-statements">Parsing statements</h4><p>Each statement will be one of <code>INSERT</code>,
<code>CREATE</code>, or <code>SELECT</code>. The
<code>parseStatement</code> helper will call a helper on each of these
statement types and return <code>true</code> if one of them succeeds
in parsing.</p>
<pre><code><span>func <span>parseStatement</span>(<span>tokens []*token, initialCursor <span>uint</span>, delimiter token</span>) (<span>*Statement, <span>uint</span>, <span>bool</span></span>) </span>{
    cursor := initialCursor

    
    semicolonToken := tokenFromSymbol(semicolonSymbol)
    slct, newCursor, ok := parseSelectStatement(tokens, cursor, semicolonToken)
    <span>if</span> ok {
        <span>return</span> &amp;Statement{
            Kind:            SelectKind,
            SelectStatement: slct,
        }, newCursor, <span>true</span>
    }

    
    inst, newCursor, ok := parseInsertStatement(tokens, cursor, semicolonToken)
    <span>if</span> ok {
        <span>return</span> &amp;Statement{
            Kind:            InsertKind,
            InsertStatement: inst,
        }, newCursor, <span>true</span>
    }

    
    crtTbl, newCursor, ok := parseCreateTableStatement(tokens, cursor, semicolonToken)
    <span>if</span> ok {
        <span>return</span> &amp;Statement{
            Kind:                 CreateTableKind,
            CreateTableStatement: crtTbl,
        }, newCursor, <span>true</span>
    }

    <span>return</span> nil, initialCursor, <span>false</span>
}
</code></pre>
<h4 id="parsing-select-statements">Parsing select statements</h4><p>Parsing <code>SELECT</code> statements is easy. We'll look for the
following token pattern:</p>
<ol>
<li><code>SELECT</code></li>
<li><code>$expression [, ...]</code></li>
<li><code>FROM</code></li>
<li><code>$table-name</code></li>
</ol>
<p>Sketching that out we get:</p>
<pre><code><span>func <span>parseSelectStatement</span>(<span>tokens []*token, initialCursor <span>uint</span>, delimiter token</span>) (<span>*SelectStatement, <span>uint</span>, <span>bool</span></span>) </span>{
    cursor := initialCursor
    <span>if</span> !expectToken(tokens, cursor, tokenFromKeyword(selectKeyword)) {
        <span>return</span> nil, initialCursor, <span>false</span>
    }
    cursor++

    slct := SelectStatement{}

    exps, newCursor, ok := parseExpressions(tokens, cursor, []token{tokenFromKeyword(fromKeyword), delimiter})
    <span>if</span> !ok {
        <span>return</span> nil, initialCursor, <span>false</span>
    }

    slct.item = *exps
    cursor = <span>newCursor

    <span>if</span> <span>expectToken</span>(<span>tokens, cursor, tokenFromKeyword(fromKeyword</span>)) </span>{
        cursor++

        <span>from</span>, newCursor, ok := parseToken(tokens, cursor, identifierKind)
        <span>if</span> !ok {
            helpMessage(tokens, cursor, <span>"Expected FROM token"</span>)
            <span>return</span> nil, initialCursor, <span>false</span>
        }

        slct.<span>from</span> = *<span>from</span>
        cursor = newCursor
    }

    <span>return</span> &amp;slct, cursor, <span>true</span>
}
</code></pre>
<p>The <code>parseToken</code> helper will look for a token of a
particular token kind.</p>
<pre><code><span>func <span>parseToken</span>(<span>tokens []*token, initialCursor <span>uint</span>, kind tokenKind</span>) (<span>*token, <span>uint</span>, <span>bool</span></span>) </span>{
    cursor := initialCursor

    <span>if</span> cursor &gt;= <span>uint</span>(len(tokens)) {
        <span>return</span> nil, initialCursor, <span>false</span>
    }

    current := tokens[cursor]
    <span>if</span> current.kind == kind {
        <span>return</span> current, cursor + <span>1</span>, <span>true</span>
    }

    <span>return</span> nil, initialCursor, <span>false</span>
}
</code></pre>
<p>The <code>parseExpressions</code> helper will look for tokens
separated by a comma until a delimiter is found. It will use existing
helpers plus <code>parseExpression</code>.</p>
<pre><code><span>func <span>parseExpressions</span>(<span>tokens []*token, initialCursor <span>uint</span>, delimiters []token</span>) (<span>*[]*expression, <span>uint</span>, <span>bool</span></span>) </span>{
    cursor := initialCursor

    exps := []*expression{}
outer:
    <span>for</span> {
        <span>if</span> cursor &gt;= <span>uint</span>(len(tokens)) {
            <span>return</span> nil, initialCursor, <span>false</span>
        }

        
        current := tokens[cursor]
        <span>for</span> _, delimiter := range delimiters {
            <span>if</span> delimiter.<span>equals</span>(current) {
                <span>break</span> outer
            }
        }

        
        <span><span>if</span> <span>len</span>(<span>exps</span>) &gt; 0 </span>{
            <span>if</span> !expectToken(tokens, cursor, tokenFromSymbol(commaSymbol)) {
                helpMessage(tokens, cursor, <span>"Expected comma"</span>)
                <span>return</span> nil, initialCursor, <span>false</span>
            }

            cursor++
        }

        
        exp, newCursor, ok := parseExpression(tokens, cursor, tokenFromSymbol(commaSymbol))
        <span>if</span> !ok {
            helpMessage(tokens, cursor, <span>"Expected expression"</span>)
            <span>return</span> nil, initialCursor, <span>false</span>
        }
        cursor = newCursor

        exps = append(exps, exp)
    }

    <span>return</span> &amp;exps, cursor, <span>true</span>
}
</code></pre>
<p>The <code>parseExpression</code> helper (for now) will look for a
numeric, string, or identifier token.</p>
<pre><code><span>func <span>parseExpression</span>(<span>tokens []*token, initialCursor <span>uint</span>, _ token</span>) (<span>*expression, <span>uint</span>, <span>bool</span></span>) </span>{
    cursor := initialCursor

    kinds := []tokenKind{identifierKind, numericKind, stringKind}
    <span>for</span> _, kind := range kinds {
        t, newCursor, ok := parseToken(tokens, cursor, kind)
        <span>if</span> ok {
            <span>return</span> &amp;expression{
                literal: t,
                kind:    literalKind,
            }, newCursor, <span>true</span>
        }
    }

    <span>return</span> nil, initialCursor, <span>false</span>
}
</code></pre>
<p>And that's it for parsing a <code>SELECT</code> statement!</p>
<h4 id="parsing-insert-statements">Parsing insert statements</h4><p>We'll look for the following token pattern:</p>
<ol>
<li><code>INSERT</code></li>
<li><code>INTO</code></li>
<li><code>$table-name</code></li>
<li><code>VALUES</code></li>
<li><code>(</code></li>
<li><code>$expression [, ...]</code></li>
<li><code>)</code></li>
</ol>
<p>With the existing helpers, this is straightforward to sketch out:</p>
<pre><code>func parseInsertStatement(tokens []*token, initialCursor uint, delimiter token) (*InsertStatement, uint, <span>bool</span>) {
    cursor := initialCursor

    
    <span>if</span> !expectToken(tokens, cursor, tokenFromKeyword(insertKeyword)) {
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor++

    
    <span>if</span> !expectToken(tokens, cursor, tokenFromKeyword(intoKeyword)) {
        helpMessage(tokens, cursor, <span>"Expected into"</span>)
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor++

    
    table, newCursor, ok := parseToken(tokens, cursor, identifierKind)
    <span>if</span> !ok {
        helpMessage(tokens, cursor, <span>"Expected table name"</span>)
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor = newCursor

    
    <span>if</span> !expectToken(tokens, cursor, tokenFromKeyword(valuesKeyword)) {
        helpMessage(tokens, cursor, <span>"Expected VALUES"</span>)
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor++

    
    <span>if</span> !expectToken(tokens, cursor, tokenFromSymbol(leftparenSymbol)) {
        helpMessage(tokens, cursor, <span>"Expected left paren"</span>)
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor++

    
    values, newCursor, ok := parseExpressions(tokens, cursor, []token{tokenFromSymbol(rightparenSymbol)})
    <span>if</span> !ok {
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor = newCursor

    
    <span>if</span> !expectToken(tokens, cursor, tokenFromSymbol(rightparenSymbol)) {
        helpMessage(tokens, cursor, <span>"Expected right paren"</span>)
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor++

    <span>return</span> &amp;InsertStatement{
        table:  *table,
        values: values,
    }, cursor, <span>true</span>
}
</code></pre>
<p>And that's it for parsing an <code>INSERT</code> statement!</p>
<h4 id="parsing-create-statements">Parsing create statements</h4><p>Finally, for create statements we'll look for the following token
pattern:</p>
<ol>
<li><code>CREATE</code></li>
<li><code>$table-name</code></li>
<li><code>(</code></li>
<li><code>[$column-name $column-type [, ...]]</code></li>
<li><code>)</code></li>
</ol>
<p>Sketching that out with a new <code>parseColumnDefinitions</code>
helper we get:</p>
<pre><code>func parseCreateTableStatement(tokens []*token, initialCursor uint, delimiter token) (*CreateTableStatement, uint, <span>bool</span>) {
    cursor := initialCursor

    <span>if</span> !expectToken(tokens, cursor, tokenFromKeyword(createKeyword)) {
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor++

    <span>if</span> !expectToken(tokens, cursor, tokenFromKeyword(tableKeyword)) {
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor++

    name, newCursor, ok := parseToken(tokens, cursor, identifierKind)
    <span>if</span> !ok {
        helpMessage(tokens, cursor, <span>"Expected table name"</span>)
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor = newCursor

    <span>if</span> !expectToken(tokens, cursor, tokenFromSymbol(leftparenSymbol)) {
        helpMessage(tokens, cursor, <span>"Expected left parenthesis"</span>)
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor++

    cols, newCursor, ok := parseColumnDefinitions(tokens, cursor, tokenFromSymbol(rightparenSymbol))
    <span>if</span> !ok {
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor = newCursor

    <span>if</span> !expectToken(tokens, cursor, tokenFromSymbol(rightparenSymbol)) {
        helpMessage(tokens, cursor, <span>"Expected right parenthesis"</span>)
        <span>return</span> <span>nil</span>, initialCursor, <span>false</span>
    }
    cursor++

    <span>return</span> &amp;CreateTableStatement{
        name: *name,
        cols: cols,
    }, cursor, <span>true</span>
}
</code></pre>
<p>The <code>parseColumnDefinitions</code> helper will look column names
followed by column types separated by a comma and ending with some
delimiter:</p>
<pre><code><span>func <span>parseColumnDefinitions</span>(<span>tokens []*token, initialCursor <span>uint</span>, delimiter token</span>) (<span>*[]*columnDefinition, <span>uint</span>, <span>bool</span></span>) </span>{
    cursor := initialCursor

    cds := []*columnDefinition{}
    <span>for</span> {
        <span>if</span> cursor &gt;= <span>uint</span>(len(tokens)) {
            <span>return</span> nil, initialCursor, <span>false</span>
        }

        
        current := tokens[cursor]
        <span>if</span> delimiter.<span>equals</span>(current) {
            <span>break</span>
        }

        
        <span><span>if</span> <span>len</span>(<span>cds</span>) &gt; 0 </span>{
            <span>if</span> !expectToken(tokens, cursor, tokenFromSymbol(commaSymbol)) {
                helpMessage(tokens, cursor, <span>"Expected comma"</span>)
                <span>return</span> nil, initialCursor, <span>false</span>
            }

            cursor++
        }

        
        id, newCursor, ok := parseToken(tokens, cursor, identifierKind)
        <span>if</span> !ok {
            helpMessage(tokens, cursor, <span>"Expected column name"</span>)
            <span>return</span> nil, initialCursor, <span>false</span>
        }
        cursor = newCursor

        
        ty, newCursor, ok := parseToken(tokens, cursor, keywordKind)
        <span>if</span> !ok {
            helpMessage(tokens, cursor, <span>"Expected column type"</span>)
            <span>return</span> nil, initialCursor, <span>false</span>
        }
        cursor = newCursor

        cds = append(cds, &amp;columnDefinition{
            name:     *id,
            datatype: *ty,
        })
    }

    <span>return</span> &amp;cds, cursor, <span>true</span>
}
</code></pre>
<p>And that's it for parsing! If you copy
<a href="https://github.com/eatonphil/gosql/blob/master/parser_test.go">parser_test.go</a>
from the main project, the tests should now pass.</p>
<h3 id="an-in-memory-backend">An in-memory backend</h3><p>Our in-memory backend should conform to a general backend interface
that allows a user to create, select, and insert data:</p>
<pre><code>package main

import <span>"errors"</span>

<span>type ColumnType <span>uint</span>

<span>const</span> (<span>
    TextType ColumnType = iota
    IntType
</span>)

type Cell <span>interface</span> </span>{
    AsText() <span><span>string</span>
    <span>AsInt</span>(<span></span>) int32
}

type Results <span>struct</span> </span>{
    Columns []<span>struct</span> {
        Type ColumnType
        Name <span>string</span>
    }
    Rows [][]Cell
}

<span>var</span> (
    ErrTableDoesNotExist  = errors.New(<span>"Table does not exist"</span>)
    ErrColumnDoesNotExist = errors.New(<span>"Column does not exist"</span>)
    ErrInvalidSelectItem  = errors.New(<span>"Select item is not valid"</span>)
    ErrInvalidDatatype    = errors.New(<span>"Invalid datatype"</span>)
    ErrMissingValues      = errors.New(<span>"Missing values"</span>)
)

type Backend <span>interface</span> {
    CreateTable(*CreateTableStatement) <span>error
    <span>Insert</span>(<span>*InsertStatement</span>) error
    <span>Select</span>(<span>*SelectStatement</span>) (<span>*Results, error</span>)
}
</span></code></pre>
<p>This leaves us room in the future for a disk-backed backend.</p>
<h4 id="memory-layout">Memory layout</h4><p>Our in-memory backend should store a list of tables. Each table
will have a list of columns and rows. Each column will have a name and
type. Each row will have a list of byte arrays.</p>
<pre><code><span>package main

<span>import</span> (<span>
    <span>"bytes"</span>
    <span>"encoding/binary"</span>
    <span>"fmt"</span>
    <span>"strconv"</span>
</span>)

type MemoryCell []<span>byte</span>

<span>func</span> (<span>mc MemoryCell</span>) <span>AsInt</span>(<span></span>) int32 </span>{
    <span>var</span> i int32
    err := binary.Read(bytes.NewBuffer(mc), binary.BigEndian, &amp;i)
    <span>if</span> err != nil {
        panic(err)
    }

    <span>return</span> i
}

func (mc MemoryCell) AsText() <span>string</span> {
    <span>return</span> <span>string</span>(mc)
}

type table <span>struct</span> {
    columns     []<span>string</span>
    columnTypes []ColumnType
    rows        [][]MemoryCell
}

type MemoryBackend <span>struct</span> {
    tables map[<span>string</span>]*table
}

<span>func <span>NewMemoryBackend</span>(<span></span>) *MemoryBackend </span>{
    <span>return</span> &amp;MemoryBackend{
        tables: map[<span>string</span>]*table{},
    }
}
</code></pre>
<h4 id="implementing-create-table-support">Implementing create table support</h4><p>When creating a table, we'll make a new entry in the backend tables
map. Then we'll create columns as specified by the AST.</p>
<pre><code>func (mb *MemoryBackend) CreateTable(crt *CreateTableStatement) error {
    t := table{}
    mb.tables[crt.name.<span>value</span>] = &amp;t
    <span>if</span> crt.cols == nil {

        <span>return</span> nil
    }

    <span>for</span> _, col := range *crt.cols {
        t.columns = append(t.columns, col.name.<span>value</span>)

        <span>var</span> dt ColumnType
        <span>switch</span> col.datatype.<span>value</span> {
        <span>case</span> <span>"int"</span>:
            dt = IntType
        <span>case</span> <span>"text"</span>:
            dt = TextType
        <span>default</span>:
            <span>return</span> ErrInvalidDatatype
        }

        t.columnTypes = append(t.columnTypes, dt)
    }

    <span>return</span> nil
}
</code></pre>
<h4 id="implementing-insert-support">Implementing insert support</h4><p>Keeping things simple, we'll assume the value passed can be correctly
mapped to the type of the column specified.</p>
<p>We'll reference a helper for mapper values to internal storage,
<code>tokenToCell</code>.</p>
<pre><code>func (mb *MemoryBackend) Insert(inst *InsertStatement) error {
    table, ok := mb.tables[inst.table.<span>value</span>]
    <span>if</span> !ok {
        <span>return</span> ErrTableDoesNotExist
    }

    <span>if</span> inst.values == nil {
        <span>return</span> nil
    }

    row := []MemoryCell{}

    <span><span>if</span> <span>len</span>(<span>*inst.values</span>) !</span>= len(table.columns) {
        <span>return</span> ErrMissingValues
    }

    <span>for</span> _, <span>value</span> := range *inst.values {
        <span>if</span> <span>value</span>.kind != literalKind {
            fmt.Println(<span>"Skipping non-literal."</span>)
            <span>continue</span>
        }

        row = append(row, mb.tokenToCell(<span>value</span>.literal))
    }

    table.rows = append(table.rows, row)
    <span>return</span> nil
}
</code></pre>
<p>The <code>tokenToCell</code> helper will write numbers as binary bytes
and will write strings as bytes:</p>
<pre><code>
func (mb *MemoryBackend) tokenToCell(t *token) MemoryCell {
    <span>if</span> t.kind == numericKind {
        buf := <span>new</span>(bytes.Buffer)
        i, err := strconv.Atoi(t.<span>value</span>)
        <span>if</span> err != nil {
            panic(err)
        }

        err = binary.Write(buf, binary.BigEndian, int32(i))
        <span>if</span> err != nil {
            panic(err)
        }
        <span>return</span> MemoryCell(buf.Bytes())
    }

    <span>if</span> t.kind == stringKind {
        <span>return</span> MemoryCell(t.<span>value</span>)
    }

    <span>return</span> nil
}
</code></pre>
<h4 id="implementing-select-support">Implementing select support</h4><p>Finally, for select we'll iterate over each row in the table and
return the cells according to the columns specified by the AST.</p>
<pre><code>func (mb *MemoryBackend) Select(slct *SelectStatement) (*Results, error) {
    table, ok := mb.tables[slct.from.table]
    <span>if</span> !ok {
        <span>return</span> nil, ErrTableDoesNotExist
    }

    results := [][]Cell{}
    columns := []<span>struct</span> {
        Type ColumnType
        Name <span>string</span>
    }{}

    <span>for</span> i, row := range table.rows {
        result := []Cell{}
        isFirstRow := i == <span>0</span>

        <span>for</span> _, <span>exp</span> := range slct.item {
            <span>if</span> <span>exp</span>.kind != literalKind {
                
                fmt.Println(<span>"Skipping non-literal expression."</span>)
                <span>continue</span>
            }

            lit := <span>exp</span>.literal
            <span>if</span> lit.kind == identifierKind {
                found := <span>false</span>
                <span>for</span> i, tableCol := range table.columns {
                    <span>if</span> tableCol == lit.value {
                        <span>if</span> isFirstRow {
                            columns = append(columns, <span>struct</span> {
                                Type ColumnType
                                Name <span>string</span>
                            }{
                                Type: table.columnTypes[i],
                                Name: lit.value,
                            })
                        }

                        result = append(result, row[i])
                        found = <span>true</span>
                        <span>break</span>
                    }
                }

                <span>if</span> !found {
                    <span>return</span> nil, ErrColumnDoesNotExist
                }

                <span>continue</span>
            }

            <span>return</span> nil, ErrColumnDoesNotExist
        }

        results = append(results, result)
    }

    <span>return</span> &amp;Results{
        Columns: columns,
        Rows:    results,
    }, nil
}
</code></pre>
<h3 id="the-repl">The REPL</h3><p>At last, we're ready to wrap the parser and in-memory backend in a
REPL. The most complex part is displaying the table of results from a
select query.</p>
<pre><code>package main

import (
    <span>"bufio"</span>
    <span>"fmt"</span>
    <span>"os"</span>
    <span>"strings"</span>

    <span>"github.com/eatonphil/gosql"</span>
)

func main() {
    mb := gosql.NewMemoryBackend()

    reader := bufio.NewReader(os.Stdin)
    fmt.Println(<span>"Welcome to gosql."</span>)
    <span>for</span> {
        fmt.Print(<span>"# "</span>)
        text, err := reader.ReadString(<span>'
'</span>)
        text = strings.Replace(text, <span>"
"</span>, <span>""</span>, <span>-1</span>)

        ast, err := gosql.Parse(text)
        <span>if</span> err != <span>nil</span> {
            panic(err)
        }

        <span>for</span> _, stmt := range ast.Statements {
            <span>switch</span> stmt.Kind {
            <span>case</span> gosql.CreateTableKind:
                err = mb.CreateTable(ast.Statements[<span>0</span>].CreateTableStatement)
                <span>if</span> err != <span>nil</span> {
                    panic(err)
                }
                fmt.Println(<span>"ok"</span>)
            <span>case</span> gosql.InsertKind:
                err = mb.Insert(stmt.InsertStatement)
                <span>if</span> err != <span>nil</span> {
                    panic(err)
                }

                fmt.Println(<span>"ok"</span>)
            <span>case</span> gosql.SelectKind:
                results, err := mb.Select(stmt.SelectStatement)
                <span>if</span> err != <span>nil</span> {
                    panic(err)
                }

                <span>for</span> _, col := range results.Columns {
                    fmt.Printf(<span>"| %s "</span>, col.Name)
                }
                fmt.Println(<span>"|"</span>)

                <span>for</span> i := <span>0</span>; i &lt; <span>20</span>; i++ {
                    fmt.Printf(<span>"="</span>)
                }
                fmt.Println()

                <span>for</span> _, result := range results.Rows {
                    fmt.Printf(<span>"|"</span>)

                    <span>for</span> i, cell := range result {
                        typ := results.Columns[i].Type
                        s := <span>""</span>
                        <span>switch</span> typ {
                        <span>case</span> gosql.IntType:
                            s = fmt.Sprintf(<span>"%d"</span>, cell.AsInt())
                        <span>case</span> gosql.TextType:
                            s = cell.AsText()
                        }

                        fmt.Printf(<span>" %s | "</span>, s)
                    }

                    fmt.Println()
                }

                fmt.Println(<span>"ok"</span>)
            }
        }
    }
}
</code></pre>
<p>Putting it all together:</p>
<pre><code>$ go run *.go
Welcome to gosql.

ok

ok

| id | name |
====================
| 1 |  Phil |
ok

ok

| name | id |
====================
| Phil |  1 |
| Kate |  2 |
ok
</code></pre>
<p>And we've got a very simple SQL database!</p>
<p>Next up we'll get into filtering, sorting, and indexing.</p>
<h4 id="further-reading">Further reading</h4><ul>
<li><a href="https://notes.eatonphil.com/writing-a-simple-json-parser.html">Writing a simple JSON parser</a><ul>
<li>This post goes into a little more detail about the theory and basics of parsing.</li>
</ul>
</li>
<li><a href="https://www.goodreads.com/book/show/617120.Database_Systems">Database Systems: A Practical Approach to Design, Implementation and Management</a><ul>
<li>A giant book, but an excellent and very easy introduction to database theory.</li>
</ul>
</li>
</ul>
<p>Please reply on Twitter with questions or comments.</p>
<twitter-widget id="twitter-widget-0" data-tweet-id="1237522975143776256"></twitter-widget> 

      </div>
      
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>