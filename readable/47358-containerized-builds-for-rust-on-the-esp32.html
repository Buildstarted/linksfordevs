<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Containerized builds for Rust on the ESP32 -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Containerized builds for Rust on the ESP32</h1>
    <div class="body" id="article-body"> <p>The <a href="https://en.wikipedia.org/wiki/ESP32">ESP32</a> &quot;is a series of low-cost, low-power system on a chip microcontrollers with integrated Wi-Fi and dual-mode Bluetooth&quot;, I&apos;ve bought a few of these recently for personal projects, the very low power draw and low cost, paired with Wi-Fi and dual-mode Bluetooth capabilites make it extremely attractive for a wide range of projects.</p> <p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--r6Eptm49--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/mx9erz41di8y5h4u6zwr.jpeg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--r6Eptm49--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/mx9erz41di8y5h4u6zwr.jpeg" alt="ESP32 Chip"></a></p> <p>I&apos;ve previously worked the ESP32&apos;s predecessor, the <a href="https://en.wikipedia.org/wiki/ESP8266">ESP8266</a>, both devices have a RISC CPU that runs an ISA called Xtensa.</p> <p>This was a few years back and I was programming most of my embedded projects in C, Since then I fell in love with Rust and have been using it for a few projects, especially ones which are relatively close to hardware, such as programming an ESP32, so last week when I started looking programming the device I checked to see if I could target it with rust.</p> <h2> <a href="#compiling-rust-for-the-xtensa-isa" class="anchor"> </a> Compiling Rust for the Xtensa ISA
</h2> <p>For this to work, LLVM would need to support an Xtensa backend, in LLVM a Frontend takes some higher level language such as C,Fortran, Ada or Rust and emits LLVM-IR AST, LLVM then has optimisers that work on LLVM-IR, and finally a Backend accepts LLVM-IR and emits architecture specific <em>(x86_64/ARM/PowerPC/etc)</em> instructions.</p> <p>Unfortunately, LLVM upstream does not currently support an Xtensa ISA backend, so the rust compiler does not support Xtensa out of the box, fortunately <a href="https://github.com/espressif/llvm-xtensa">there is a LLVM fork</a> by Espressif implementing support for Xtensa, and thanks to the awesome work of <a href="https://mabez.dev/">Scott Mabin (MabezDev)</a> there is a <a href="https://github.com/MabezDev/rust-xtensa">fork of the Rust compiler toolchain</a> supporting Xtensa. With these two components already prepared all you need to do is build LLVM and the compiler and do a bit of environment setup and you&apos;re ready to go!</p> <p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--tqTmD__N--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/http://4.bp.blogspot.com/-WDcl2mtJ8Do/UWnL-S-FgiI/AAAAAAAAAn0/3LTWx4a32XY/s1600/clang.gif" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--tqTmD__N--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/http://4.bp.blogspot.com/-WDcl2mtJ8Do/UWnL-S-FgiI/AAAAAAAAAn0/3LTWx4a32XY/s1600/clang.gif" alt="Clang Frontend/Backend design"></a></p> <p>There is a great <a href="http://quickhack.net/nom/blog/2019-05-14-build-rust-environment-for-esp32.html">blog post</a> by Yoshinari Nomura explaining exactly what you need to do, while the process is relatively straightforward there are quite a few dependencies and a few pitfalls that made me spend a few hours getting it to work properly for me.</p> <p>I work from a few different computers, and considering the time it takes to build LLVM and the compiler I decided to create a Docker image with the build environment.</p> <h2> <a href="#building-for-the-esp32-with-docker" class="anchor"> </a> Building for the ESP32 with Docker
</h2> <p>I&apos;ve built a Dockerfile that builds the environment (LLVM and the compiler) for out-of-the-box compilation.</p> <p>a quick disclaimer about the image is that it is a local build I pushed to Docker Hub and it was not built by Docker Hub due to the build taking too long and timing out, you do not need to trust the image, and you can build the Dockerfile yourself (and possibly push it to Docker Hub yourself). be aware that pushed images that were not built by Docker Hub from the Dockerfile can essentially be anything.</p> <p>You can now build your Rust ESP32 project with a single command if you have Docker installed, If you&apos;re looking for a baseline for your project you can use <a href="https://github.com/MabezDev/xtensa-rust-quickstart">xtensa-rust-quickstart</a> also by MabezDev, note that you do not need to use <em>setenv</em> inside the project as everything is already set up properly in the machine.</p> <p>all you need to is <code>docker run -v $PWD:/code mtnmts/rust-esp32</code></p> <p>The image expects the project to be mounted at <code>/code</code> (your Cargo.toml should be at <code>/code/Cargo.toml</code>) inside the container.</p> <p>The image is quite heavy, if you would like to create a slimmed down version you can fork it and remove some of the intermediate build artifacts (such as LLVM).</p> <p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--zIPaDSVo--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/dvajg7qfwz0gq0brlp3m.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--zIPaDSVo--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/dvajg7qfwz0gq0brlp3m.png" alt="Containerized Build Demo"></a><br>
And that&apos;s it, <a href="https://github.com/mtnmts/rust-esp32-container">Dockerfile is here</a> if you&apos;re interested.</p> <p>My main desktop is running Windows, but i do most of my programming work in Linux under WSL2, I wanted to be able to program the ESP32 from within WSL2, to do this I forwarded the serial port to the WSL2 VM.</p> <p>First, you will need <a href="http://www.dest-unreach.org/socat/">socat for Windows</a>, there is an unofficial build of the sources over at <a href="https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/">SourceForge</a> if you don&apos;t want it yourself.</p> <p>If you don&apos;t already know it, Find the serial port assigned to your device <em>COM[1-9]</em></p> <p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Gj9Ke7Xk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/3pylb02uphj0pi31v2bx.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Gj9Ke7Xk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/3pylb02uphj0pi31v2bx.png" alt="Device Manager Image, Finding the correct COM Port"></a></p> <p>Looking in &quot;Device Manager&quot; should be indicative</p> <p>Next, run <em>socat</em> and set it to tunnel the COM port to TCP, do note that <code>/dev/ttyS3</code> is not a mistake, even though there is no such device (or file system hierarchy) on Windows, this is the syntax that <em>socat</em> expects on Windows, the number (3 in my case) is the COM port number.</p> <div class="highlight"><pre class="highlight plaintext"><code> socat -d TCP4-LISTEN:1337,reuseaddr,fork /dev/ttyS3
</code></pre></div> <p>From there you can forward the port in many different ways to your WSL2/Linux instance, I use Tunnelier&apos;s S2C port forwarding for this, Putty can probably do this too.</p> <p><em>esptool</em> supports flashing over TCP, the syntax is <code>--port socket://&lt;host&gt;:&lt;port&gt;</code></p> <p>more information on remote serial ports programming for <em>esptool</em> can be found <a href="https://github.com/espressif/esptool/wiki/Remote-Serial-Ports">here</a>.</p> <h3> <a href="#thanks" class="anchor"> </a> Thanks
</h3> <ul>
<li><p>Everyone who worked on getting Rust on the ESP32 going, especially MabezDev, and to Yoshinari Nomura for his blog post explaining how to set up the environment</p></li>
<li><p>Espressif for creating the LLVM fork supporting your architecture!</p></li>
</ul> <p>Happy Hacking!</p> <h3> <a href="#anecdotes" class="anchor"> </a> Anecdotes
</h3> <ul>
<li>First time I programmed the device I stupidly guessed I should flash to 0x0, that didn&apos;t work so I guessed <em>again</em> and flashed <em>0x1000</em> ,That wrote over the bootloader (<em>yikes</em>). Luckily I had the same board twice so I read the flash off the second one and re-flashed the first one, I highly recommend you backup your original flash!</li>
<li>(The correct flash offset ended up being <em>0x10000</em>)</li>
</ul> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>