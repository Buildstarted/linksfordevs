<!DOCTYPE html>
<html lang="en">
<head>
    <title>
.NET Debugging: 6 techniques you need in your arsenal -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>.NET Debugging: 6 techniques you need in your arsenal</h1>
    <section class="post-content single-post-content"> <p>Debugging. It&#x2019;s one of the most time-consuming ways of finding a bug.</p> <p>As a senior .NET developer, I can tell you that it&#x2019;s best to avoid the necessity for debugging altogether by writing <a href="https://raygun.com/blog/solid-design-principles/">clean code</a> that&#x2019;s covered by automated tests. If you&#x2019;re a senior developer yourself, you probably already know this. And if you&#x2019;re a junior developer, now you know it too!</p> <p>However, the world isn&#x2019;t binary. There&#x2019;s a lot of gray between the white and black that people usually like to see.</p> <p>Maybe you have a third-party system that&#x2019;s not behaving as expected. Perhaps you have production data that doesn&#x2019;t quite match what was specified. Simply put, we&#x2019;re talking about highly complex tasks, and it&#x2019;s impossible to think about every edge case, even when you do have automated testing in place.</p> <p>The following techniques are some of the more advanced ones I use when the need arises to actually do some .NET debugging.</p> <div class="alert alert-primary"> </div> <h2 id="tip-1-use-object-exporter">Tip 1: Use object exporter</h2> <p>During debugging, it&#x2019;s often necessary to inspect the current object instances. Visual Studio supports the <code>DebuggerDisplay</code> attribute, which allows you to specify a special display of the object&#x2019;s contents in the debugger.</p> <p>While this can be helpful, it&#x2019;s also a lot of effort to add these attributes to all relevant classes. Also, it still might not contain the information that you need in a specific debugging situation.</p> <p>If it&#x2019;s just a simple object, that&#x2019;s not really a problem. Just expand it and inspect the properties.</p> <p>However, if you&#x2019;re working with arrays, this becomes tedious very quickly.
Oftentimes, it&#x2019;s necessary to find a specific set of elements in the array. The Visual Studio debugger does support LINQ in general, but there are a lot of problems that make this a frustrating experience. The LINQ namespaces aren&#x2019;t always in scope, so it&#x2019;s necessary to use the static methods syntax instead of the extension methods syntax. Or the debugger just displays an error because it can&#x2019;t evaluate the expression for different reasons.</p> <p>So sometimes, it would be nice to just dump the complete object into a plain text format.</p> <p>That&#x2019;s what Object Exporter is for. It&#x2019;s a Visual Studio extension, and you can install it manually from the <a href="https://marketplace.visualstudio.com/items?itemName=OmarElabd.ObjectExporter">Visual Studio Marketplace</a>. Or you can install it from within Visual Studio via <strong>Tools</strong> -&gt; <strong>Extensions and Updates</strong>. Please make sure that you select <strong>Online</strong> in the tree view to the left before you search for the extension.</p> <p>It can export an object in different formats, namely JSON, XML, and C#. It&#x2019;s also possible to export custom expressions. This is very helpful if you just want to export a subtree of an object graph.</p> <p>This export can then easily be searched, simplifying inspection of complex object instances. You can also easily store it, for example, as an input for automated tests or simply to compare it with results from a future debugging session.</p> <p>Please be aware that Object Exporter currently doesn&#x2019;t support VS 2019.</p> <h2 id="tip-2-load-pdb-with-resharper">Tip 2: Load PDB With ReSharper</h2> <p>Have you ever gotten an exception inside a third-party library that you were using and couldn&#x2019;t figure out why this exception occurred?</p> <p>And to top it off, was it a closed-source library without a PDB file, making it so you couldn&#x2019;t step into the code of the library? If so, you probably thought, &#x201C;Now what?&#x201D;
A simple solution is to let <a href="https://www.jetbrains.com/resharper/">ReSharper</a> create the PDB file for you. ReSharper is also a Visual Studio extension, but unlike Object Exporter, ReSharper is a commercial extension.</p> <p>To let <a href="https://raygun.com/blog/resharperfeatures/">ReSharper</a> create the PDF file, you need to open the <strong>Modules</strong> window via <strong>Debug</strong> -&gt; <strong>Windows</strong> -&gt; <strong>Modules</strong>. Then, locate the assembly that you want to generate the PDB file for and right-click on it.</p> <p>Select the option <strong>Load Symbols</strong> with <strong>ReSharper Decompiler</strong>:</p> <p><img src="/blog/images/net-debugging/decompiler.png" alt="select the load symbols for debugging .net"></p> <p>Depending on the size of the assembly, it can take up to a few minutes for the PDB to be generated and loaded. There will be no visual indication of this process in the <strong>Modules</strong> window. If you&#x2019;re wondering what&#x2019;s happening, you can open the <strong>PDB Generation Status</strong> window via <strong>ReSharper</strong> -&gt; <strong>Windows</strong>:</p> <p><img src="/blog/images/net-debugging/done.png" alt="Done window when debugging .net"></p> <p>Please be aware that the <strong>Modules</strong> window might not update once the PDB file has been loaded, so it&#x2019;ll continue to show <strong>Cannot find or open the PDB file</strong>, even though the file was loaded.</p> <p>Once the PDB has been loaded, you can navigate the assembly&#x2019;s source code and even set <a href="https://www.techopedia.com/definition/3754/breakpoint-c">breakpoints</a> in it. The source code you&#x2019;re seeing isn&#x2019;t original. Instead, it&#x2019;s a reconstructed interpretation of the assembly&#x2019;s <a href="https://www.techopedia.com/definition/24290/intermediate-language-il-net">IL</a> code. So this solution comes with the drawbacks that decompilation has: constructs that can&#x2019;t be correctly decompiled, as well as verbose and sometimes unnecessarily complex code.
Still, this is a helpful feature of ReSharper, and it&#x2019;s solved quite a few debugging challenges for me in the past.</p> <p>During debugging, you need to evaluate expressions all the time. As long as these expressions don&#x2019;t change the state of the system, all is fine.</p> <p>However, oftentimes, evaluating an expression causes a side effect.</p> <p>For example, if you&#x2019;re evaluating a property with lazy initialization, it&#x2019;ll actually initialize that property in the context of the debugged code. This can lead to strange problems during debugging. I remember one particular debugging session where this led me on an hours-long investigation into an entirely unrelated and wrong direction.
Had I just known the following little tip back then!</p> <p>Had I just known the following little tip back then!
To prevent side effects when evaluating an expression, simply append <code>, nse</code> to it. So if you want to watch <code>o.MyProperty</code>, add the following to the <code>Watch</code> window:</p> <p><code>o.MyProperty, nse</code></p> <p>This will execute the expression in a special sandbox, preventing any changes to the state of the debugged application.
See the following demonstration for an example of how to use <code>, nse</code>:</p> <p><img src="/blog/images/net-debugging/nse.gif" alt="Using nse when debugging .net"></p> <h2 id="tip-4-freeze-multithreaded-applications">Tip 4: Freeze multithreaded applications</h2> <p>Next on our list of .NET debugging tips, we&#x2019;re going to talk about multi-threaded applications.</p> <p>Debugging multi-threaded applications can be a real pain, especially if multiple threads are executing the same code. Breakpoints will be hit by each thread, and single-stepping will switch between threads. It&#x2019;s very easy to lose orientation and concentration like this. Wouldn&#x2019;t it be great if it were possible to tell Visual Studio that you want to debug just this one thread and not switch to other threads that are currently executing the same code?</p> <p>Well, turns out, there <em>is</em> a way to do this.</p> <p>Open the <strong>Threads</strong> window via <strong>Debug</strong> -&gt; <strong>Windows</strong> -&gt; <strong>Threads</strong>. This window shows all threads of the current application. Double-clicking a thread switches to it. Right-clicking a thread shows different options, one of which is <strong>Freeze</strong>:</p> <p><img src="/blog/images/net-debugging/threads.png" alt="Using threads and freeze functions when debugging .net"></p> <p>As the name suggests, this freezes the execution of that particular thread.
To use this feature in our scenario, you can set a breakpoint at the beginning of the code that you want to debug.</p> <p>When the breakpoint is hit, use the <strong>Threads</strong> window to freeze all threads for the current location except one. You can now debug this one thread and single-step through the code without thread switches interrupting your concentration. You can also set breakpoints and be sure they&#x2019;ll be hit for the correct thread.</p> <p>If you want to continue running the program after you&#x2019;ve debugged the code in the thread, you should unfreeze&#x2014;or <strong>Thaw</strong>&#x2014;the other threads so they can perform their work as well.</p> <h2 id="tip-5-use-object-id">Tip 5: Use Object ID</h2> <p>Object IDs are a feature of the Visual Studio Debugger that has several helpful use cases.</p> <p>One such use case is that object IDs basically allow you to make a certain object instance globally available during debugging. This lets you compare it to other instances at a code location where the instance wouldn&#x2019;t be available otherwise.</p> <p>Another use case is to compare object identities. Imagine a scenario where you&#x2019;re debugging an app that uses a dependency injection container. This app contains two classes that are receiving an instance of a service class via their constructors. The service instance resembles the way by which the two classes can communicate with each other. However, this coordination doesn&#x2019;t work for some reason. One reason for this issue could be that the two classes aren&#x2019;t receiving the same instance of the service class.</p> <p>Object ID can easily identify this issue.</p> <p>To use it, add a breakpoint at the constructors of the two classes. When the breakpoint gets hit in the first class, right-click the service instance in the Locals window and choose <strong>Make Object ID</strong>. When the breakpoint in the second class gets hit, check if the instance shows the object ID. If so, they&#x2019;re the exact same instance.</p> <p><img src="/blog/images/net-debugging/breakpoint-example.gif" alt="Using threads and freeze functions when debugging .net"></p> <p>If not, they&#x2019;re different instances, and you&#x2019;ve found the reason for the bug: a problem with the <a href="https://stackoverflow.com/questions/50718586/what-is-a-di-container">DI container&#x2019;s</a> configuration.</p> <h2 id="tip-6-make-sure-you-re-getting-stack-traces">Tip 6: Make sure you&#x2019;re getting stack traces</h2> <p>If you&#x2019;re lucky and the bug in your system surfaces as an exception and not just as an incorrect value somewhere, a stack trace is the simplest way to get started with your debugging. It pinpoints the problematic location and how it was reached. This usually leads to rather quick results, so the last tip I have for you is to make sure that you&#x2019;re getting these stack traces.</p> <p>And there&#x2019;s actually a lot that can prevent this!</p> <p>First of all, when you catch an exception and rethrow it, never ever use <code>throw ex;</code>. Instead, use <code>throw;</code> . The first variant loses the original stack trace and therefore masks the original error location.</p> <p>Second, always log all unexpected <a href="https://raygun.com/blog/errors-and-exceptions/">exceptions</a> with full details. The easiest way to do this is to simply call <code>ToString()</code> on the exception. This will include the stack trace.</p> <p>And third and finally, ensure that you have easy access to these logs. It&#x2019;s a bad idea to keep logs only in files on the server, as oftentimes we developers won&#x2019;t have direct access to production systems, especially in established corporations. Also, flat log files are rather hard to analyze.</p> <p>The solution to these problems is an <a href="https://raygun.com/platform/crash-reporting">error monitoring service</a> like Raygun, which your application writes the errors to. It&#x2019;s responsible for collecting error logs from all of your applications in one central place. It also allows you to group, filter, search, and analyze the exceptions in a simple way. And you can do all of that without having to ask anyone for access to the production servers.</p> <p><img src="/blog/images/net-debugging/crash-reporting-stack-trace.png" alt="Raygun Crash Reporting can help you with debugging"></p> <h2 id="conclusion">Conclusion</h2> <p>Debugging is a necessary part of every developer&#x2019;s work. I hope that you now feel stocked with some good debugging tools for .NET applications. I suggest you try the outlined techniques today and familiarize yourself with them. I&#x2019;m sure this will improve the productivity of your next debugging session. And maybe it&#x2019;ll even be a little bit more fun!</p> </section>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>