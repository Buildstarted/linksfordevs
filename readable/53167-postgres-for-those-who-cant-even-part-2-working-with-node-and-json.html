<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Postgres For Those Who Can&#x2019;t Even, Part 2 &#x2013; Working with Node and JSON -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Postgres For Those Who Can&#x2019;t Even, Part 2 &#x2013; Working with Node and JSON</h1>
    <div class="wp-block-jetpack-markdown"><p>This is part 2 of a series of posts I&#x2019;m doing for a friend who&#x2019;s a JavaScript developer that, according to him, knows next to nothing about Postgres. <a href="https://rob.conery.io/2020/01/24/postgresql-for-those-who-cant-even-part-1/">You can read part 1 right here</a>.</p>
<p>I <a href="https://rob.conery.io/category/postgres/">write a lot about Postgres</a>, but I don&#x2019;t think I&#x2019;ve written enough about how to get started from the absolute beginning, so that&#x2019;s what we&#x2019;re doing here.</p>
<p>In this post, I&#x2019;m continuing with his questions to me &#x2013; but this time it has less to do with the database side of things and more to do with Node and how you can use Postgres for fun and profit. Let&#x2019;s roll.</p>
<h2>How should I structure my code?</h2>
<p>This question has more to do with your preferences or what your company/boss have set up. I can show you how <em>I</em> do things, but your situation is probably a lot different.</p>
<p>OK, enough prevaricating. Here&#x2019;s what I&#x2019;ve done in the past with super simple projects that where I&#x2019;m just musing around.</p>
<p><strong>Give PG It&#x2019;s Own Module</strong>
I like putting all my code inside of a <code>lib</code> directory, and then inside there I&#x2019;ll create a a <code>pg</code> directory with specific connection things etc for Postgres. It looks like this:</p>
<p><img src="https://paper-attachments.dropbox.com/s_30B0209EA5A4D093DB15C347247819FD01F943B96E3D94DDBA52EFBEEF183D14_1580766887619_shot_49.jpg" alt></p>
<p>You&#x2019;ll also notice I have a <code>.env</code> file, which is something that goes into every single project of mine. It&#x2019;s a file that holds environmental variables that I&#x2019;ll be using in my project. In this case, I <em>do not want</em> my connection string hardcoded anywhere &#x2013; so I pop it into a <code>.env</code> file where it&#x2019;s loaded automatically by my shell (zshell and, for those interested, I use the <code>dotenv</code> plugin with <a href="https://ohmyz.sh/">Oh-My-Zsh)</a>.</p>
<p>There&#x2019;s a single file inside of the <code>lib/pg</code> directory called <code>runner.js</code>, and it has one job: <em>run the raw SQL queries</em> using pg-promise:</p>
<pre><code class="language-js">const pgp = require(&apos;pg-promise&apos;)({});
const db = pgp(process.env.DATABASE_URL);

exports.query = async function(sql, args){
  const res =  await db.any(sql, args);
  return res;
}
exports.one = async function(sql, args){
  const res =  await db.oneOrNone(sql, args);
  return res;
}
exports.execute = async function(sql, args){
  const res =  await db.none(sql, args);
  return res;
}
exports.close = async function(){
  await db.$pool.end();
  return true;
}
</code></pre>
<p>I usually have 3 flavors of query runners:</p>
<ul>
<li>One that will return 0 to <em>n</em> records</li>
<li>One that will return a single record</li>
<li>One that executes a &#x201C;passthrough&#x201D; query that doesn&#x2019;t return a result</li>
</ul>
<p>I also like to have one that closes the connections down. Normally you wouldn&#x2019;t call this in your code because the driver (which is pg-promise in this case) manages this for you and you want to be sure you draw on its pool of connections &#x2013; don&#x2019;t spin your own. That said, sometimes you might want to run a script or two, maybe some integration tests might hit the DB &#x2013; either way a graceful shutdown is nice to have.</p>
<p>We can use this code in the rest of our app:</p>
<pre><code class="language-js">const pg = require(&quot;./lib/pg/runner&quot;);

pg.query(&quot;select * from master_plan limit 10&quot;)
  .then(console.log)
  .catch(console.error)
  .finally(pg.close)
</code></pre>
<p>Neat! It works well but yes, we&#x2019;ll end up with SQL all over our code so let&#x2019;s fix that.</p>
<p><strong>A Little Bit of Abstraction</strong></p>
<p>The nice thing about Node is that your modules can be single files, or you can expand them to be quite complex &#x2013; without breaking the code that depends on them. I don&#x2019;t want my app code to think about the SQL that needs to be written &#x2013; I&#x2019;d rather just offer a method that gives the data I want. In that case, I&#x2019;ll create an <code>index.js</code> file for my <code>pg</code> module, which returns a single method for my query called <code>masterPlan</code>:</p>
<pre><code class="language-js">const runner = require(&quot;./runner&quot;);
exports.masterPlan = function(limit=10){
  return runner.query(`select * from master_plan limit ${limit}`)
}
exports.shutDown = function(){
  runner.close();
}
</code></pre>
<p>The <code>runner</code> here is the same runner that I used before, this time it&#x2019;s in the same directory as the calling code. I&#x2019;ve exposed two methods on the index as that&#x2019;s all I need for right now. This is kind of like a <a href="https://dev.to/kylegalbraith/getting-familiar-with-the-awesome-repository-pattern--1ao3">Repository Pattern</a>, which comes with a few warnings attached.</p>
<p>People have been arguing about data access for decades. What patterns to use, how those patterns fit into the larger app you&#x2019;re building, etc, etc, etc. It&#x2019;s really annoying.</p>
<p><em>Applications always start small</em> and then grow. That&#x2019;s where the issues come in. The Repository Pattern looks nice and seems wonderful until you find yourself writing <code>Orders.getByCustomer</code> and <code>Customer.getOrders</code>, wondering if this is really what you wanted to do with your life.</p>
<p>This is a rabbit hole I don&#x2019;t want to go down further so, I&#x2019;ll kindly suggest that if you have a simple app with 10-20 total queries, this level of control and simplicity of approach might work really well. If your app will grow (which I&#x2019;m sure it will whether you think so or not), it&#x2019;s probably a good idea to use some kind of library or relational mapper (ORM), which I&#x2019;ll get to in just a minute.</p>
<h2>How do I put JSON in it?</h2>
<p>One of the fun things about Node is that you can work with JSON everywhere. It&#x2019;s fun, I think, to not worry about data types, migrations, and relational theory when you&#x2019;re trying to get your app off the ground.</p>
<p>The neat thing about Postgres is that it supports this and it&#x2019;s blazing fast. Let&#x2019;s see how you can set this up with Postgres.</p>
<h3>Saving a JSONB Document</h3>
<p>Postgres has native support for binary JSON using a datatype called &#x201C;JSONB&#x201D;. It behaves just like JSON but you can&#x2019;t have duplicate keys. It&#x2019;s also super fast because you can index it in a variety of ways.</p>
<p>Since we&#x2019;re going to store our data in a JSONB field, we can create a &#x201C;meta&#x201D; table in Postgres that will hold that data. All we need is a primary key, a timestamp and the field to hold the JSON:</p>
<pre><code class="language-js">create table my_document_table(
  id serial primary key,
  doc jsonb not null,
  created_at timestamp not null default now()
);
</code></pre>
<p>We can now save data to it using a query like this:</p>
<pre><code class="language-js">insert into my_document_table(doc)
values(&apos;{&quot;name&quot;:&quot;Burke Holland&quot;}&apos;);
</code></pre>
<p>And <em>yuck</em>. Why would anyone want to do something like this? Writing delimited JSON by hand is gross, let&#x2019;s be good programmers and wrap this in a function:</p>
<pre><code class="language-js">const runner = require(&quot;./runner&quot;);
//in pg/index.js
exports.saveDocument = async function(doc){
  const sql = &quot;insert into my_document_table (doc) values ($1)&quot;;
  const res = await runner.one(sql, [doc]);
  return res;
}
</code></pre>
<p>This works really well, primarily because our Node driver (pg-promise) understands how to translate JavaScript objects into something Postgres can deal with. We just pass that in as an argument.</p>
<p>But we can do better than this, don&#x2019;t you think?</p>
<h3>Sprinkling Some Magical Abstraction</h3>
<p>One of the cool things about using a NoSQL system is that you can create a document table on the fly. We can do that easily with Postgres but we just need to tweak our <code>saveDocument</code> function a bit. In fact we need to <em>tweak a lot of things</em>.</p>
<p>Let&#x2019;s be good programmers and create a brand new file called <code>jsonb.js</code> inside our <code>pg</code> directory, right next to our <code>runner.js</code> file. The first thing we&#x2019;ll do is to create a way to save <em>any</em> document and, if we get an error about a table not existing, we&#x2019;ll create it on the fly!</p>
<pre><code class="language-js">exports.save = async function(tableName, doc){
  const sql = `insert into ${tableName} (doc) values ($1) returning *`;
  try{
    const newDoc = await runner.one(sql, [doc]);
    doc.id = newDoc.id;
    return doc;
  }catch(err){
    if(err.message.indexOf(&quot;does not exist&quot;) &gt; 0){
      //create the table on the fly
      await this.createDocTable(tableName);
      return this.save(tableName,doc);
    }
  }
}

exports.createDocTable = async function(tableName){
  await runner.query(`
    create table ${tableName}(
    id serial primary key,
    doc jsonb not null,
    created_at timestamp not null default now()
  )`);
  await runner.query(`
    create index idx_json_${tableName} 
    on ${tableName} 
    USING GIN (doc jsonb_path_ops)
  `);
}
</code></pre>
<p>We have two groovy functions that we can use to save a document to Postgres with the sweetness of a typical NoSQL, friction-free experience. A few things to note about this code:</p>
<ul>
<li>We&#x2019;re catching a specific error when a table doesn&#x2019;t exist in the database. There&#x2019;s probably a better way to do that, so feel free to play around. If there&#x2019;s an error, we&#x2019;re creating the table and then calling the <code>save</code> function one more time.</li>
<li>The <code>createDocTable</code> function also pops an index on the table which uses <code>jsonb_path_ops</code>. That argument tells Postgres to index <em>every key</em> in the document. This might not be what you want, but indexing is a good thing for smaller documents.</li>
<li>We&#x2019;re using a fun clause at the end of our <code>insert</code> SQL statement, specifically <code>returning *</code> which will return the entire, newly-created record, which we can then pass on to our calling code.</li>
</ul>
<p>Let&#x2019;s see if it works!</p>
<pre><code class="language-js">//index.js of our project
docs.save(&quot;customers&quot;, {name: &quot;Mavis&quot;, email: &quot;<a href="/cdn-cgi/l/email-protection" class="__cf_email__">[email&#xA0;protected]</a>&quot;})
  .then(console.log)
  .catch(console.err)
  .finally(pg.shutDown);
</code></pre>
<p><img src="https://paper-attachments.dropbox.com/s_30B0209EA5A4D093DB15C347247819FD01F943B96E3D94DDBA52EFBEEF183D14_1580852000207_shot_51.jpg" alt></p>
<p>Well look at that would ya! It works a treat.</p>
<p>But what about updates and deletes? Deleting a document is a simple SQL statement:</p>
<pre><code class="language-js">exports.delete = async function(id) {
  const sql = `delete from ${tableName} where id=$1`;
  await runner.execute(sql, [id]);
  return true;
};
</code></pre>
<p>You can decide what to return from here if you want, I&#x2019;m just returning <code>true</code>. Updating is a different matter, however.</p>
<h3>Updating an existing JSONB document</h3>
<p>One of the problems with JSONB and Postgres in the past (&lt; 9.5) was that in order to update a document you had to wholesale update it &#x2013; a &#x201C;partial&#x201D; update wasn&#x2019;t possible. With Postgres 9.5 that changed with the <code>jsonb_set</code> method, which requires a key and a JSONB element.</p>
<p>So, if we wanted to change Mavis&#x2019;s email address, we could use this SQL statement:</p>
<pre><code class="language-sql">update customers set doc = jsonb_set(doc, &apos;{&quot;email&quot;}&apos;, &apos;&quot;<a href="/cdn-cgi/l/email-protection" class="__cf_email__">[email&#xA0;protected]</a>&quot;&apos;)
where id = 1; 
</code></pre>
<p>That syntax is weird, don&#x2019;t you think? I do. It&#x2019;s just not very intuitive as you need to pass an &#x201C;array literal&#x201D; to define the key and a string value as the new value.</p>
<p>To me it&#x2019;s simpler to just concatenate a new value and do a wholesale save. It&#x2019;s nice to know that a partial update is <em>possible</em> if you need it, but overall I&#x2019;ve never had a problem just running a complete update like this:</p>
<pre><code class="language-js">exports.modify = async function(tableName, id = 0, update = {}) {
  if (!tableName) return;
  const sql = `update customers SET
              doc = (doc || $1) 
              where id = $2 returning *; `;
  const res = await runner.one(sql, [update, id]);
  return res;
};
</code></pre>
<p>The <code>||</code> operator that you see there is the JSONB concatenation operator which will update an existing key in a document or add one if it&#x2019;s not there. Give it a shot! See if it updates as you expect.</p>
<h3>Querying a JSONB document by ID</h3>
<p>This is the nice thing about using a relational system like Postgres: querying by <code>id</code> <em>is just a simple SQL statement.</em> Let&#x2019;s create a new function for our <code>jsonb</code> module called <code>get</code>, which will return a document by ID:</p>
<pre><code class="language-js">exports.get = async function(tableName, id=0){
  const sql = `select * from ${tableName} where id=$1`;
  const record = await runner.one(sql, [id]);
  const doc = record.doc;
  doc.id = record.id;
  return doc;
}
</code></pre>
<p>Simple enough! You&#x2019;ll notice that i&#x2019;m adding the <code>id</code> of the row in Postgres to the document itself. I could drop that into the document itself, if I wanted, but it&#x2019;s simple enough to tack it on as you see. In fact, I think I&#x2019;d like to ensure the <code>created_at</code> timestamp is on too, so let&#x2019;s formalize this with some transformations:</p>
<pre><code class="language-js">const transformRecord = function(record){
  if(record){
    const doc = record.doc;
    doc.createdAt = record.created_at;
    doc.id = record.id;
    return doc;
  }else{
    return null;
  }
}
const transformSet = function(res){
  if(res === null || res === []) return res;
  const out = [];
  for(let record of res){
    const doc = transformRecord(record);
    out.push(doc)
  }
  return out;
}
</code></pre>
<p>This will take the raw record from Postgres and turn it into something a bit more usable.</p>
<h3>Querying a document using criteria</h3>
<p>We can pull data out of our database using an id, but we need another way to query if we&#x2019;re going to use this properly.</p>
<p>You can query documents in Postgres using a special operator: <code>@&gt;</code>. There are other operators, but this is the one we&#x2019;ll need for 1) querying specific keys and 2) making sure we use an index. There are all kinds of operators and functions for JSONB within Postgres and you can <a href="https://www.postgresql.org/docs/12/functions-json.html">read more about them here</a>.</p>
<p>To query a document for a given key, you can do something like this:</p>
<pre><code class="language-sql">select * from customers
where doc @&gt; &apos;{&quot;name&quot;:&quot;Burke Holland&quot;}&apos;;
</code></pre>
<p>This query is simply for documents where the key/value <code>{name:</code> <code>&quot;``Burke Holland``&quot;``}</code> exists. That critieria is simply JSON, which means we can pass that right through to our driver&#x2026; and behold:</p>
<pre><code class="language-js">exports.find = async function(tableName, criteria){
  const sql = `select * from ${tableName} where doc @&gt; $1`;
  const record = await runner.query(sql, [criteria]);
  return transformSet(record);
}
</code></pre>
<p>Let&#x2019;s run this and see if it works:</p>
<pre><code class="language-js">docs.find(&quot;customers&quot;, {email: &quot;<a href="/cdn-cgi/l/email-protection" class="__cf_email__">[email&#xA0;protected]</a>&quot;})
  .then(console.log)
  .catch(console.err)
  .finally(pg.shutDown);
</code></pre>
<p><img src="https://paper-attachments.dropbox.com/s_30B0209EA5A4D093DB15C347247819FD01F943B96E3D94DDBA52EFBEEF183D14_1580852939679_shot_52.jpg" alt></p>
<p>Hey that&#x2019;s pretty swell! You don&#x2019;t need to use dedicated JSON operators to query a JSONB document in Postgres. If you&#x2019;re comfortable with SQL, you can just execute a regular old query and it works just fine:</p>
<pre><code class="language-sql">select * from customers
where (doc -&gt;&gt; &apos;name&apos;) ilike &apos;Mav%&apos;
</code></pre>
<p>Here, we&#x2019;re pulling the <code>name</code> key from the document using the JSON text selector (<code>-&gt;&gt;</code>), and then doing a fuzzy comparison using <code>ilike</code> (case-insensitive comparison). This works pretty well but it can&#x2019;t use the index we setup and that might make your DBA mad.</p>
<p>That doesn&#x2019;t mean you can&#x2019;t index it &#x2013; you can!</p>
<pre><code class="language-sql">create index idx_customer_name 
on customers((doc -&gt;&gt; &apos;name&apos;));
</code></pre>
<p>Works just like any other index!</p>
<h3>Play around, have some fun&#x2026;</h3>
<p>I <a href="https://gist.github.com/robconery/93aaec861fdf0cf3f5ff3f30f1cf11d5">made a gist</a> out of all of this if you want to goof around. There are things to add, like updates/partial updates, and I encourage you to play and have a good time.</p>
<p>If you&#x2019;re wondering, however, if someone, somewhere, might have baked this stuff into a toolset&#x2026; indeed! They did&#x2026;</p>
<h2>Are there any ORM-like tools in it? What do you recommend?</h2>
<p>So here&#x2019;s the thing: if you&#x2019;re coming to this post from a Java/C#/Enterprise-y background, the &#x201C;ORM&#x201D; tools in the Node world are going to look &#x2026; well a bit different. I don&#x2019;t know the reason why and I could pontificate about Node in the enterprise or how Node&#x2019;s moduling system pushes the idea of isolation&#x2026; but&#x2026; let&#x2019;s just skip all of that OK?</p>
<p>The bottom line is this: you can do data access with Node, but if you&#x2019;re looking for an industrial strength thing to rival Entity Framework you might be dissapointed. With that said &#x2013; let&#x2019;s have a look&#x2026;</p>
<h3>My favorite: MassiveJS</h3>
<p>I am 100% completely biased when it comes to <a href="https://massivejs.org/">MassiveJS</a> because&#x2026; well <em>I created it</em> along with my friend <a href="https://www.openmymind.net/">Karl Seguin</a> back in 2011 or so. The idea was to build a simple data access tool that would help you avoid writing too much SQL. It morphed into something much, much fun.</p>
<p>With version 2 I devoted Massive to Postgres completely and was joined by the current owner of the project, <a href="https://di.nmfay.com/about">Dian Fay</a>. I can&#x2019;t say enough good things about Dian &#x2013; she&#x2019;s amazing at every level and has turned this little project into something quite amazing. Devoting Massive 100% to Postgres freed us up to do all kinds of cool things &#x2013; including one of the things I love most: <a href="https://massivejs.org/docs/working-with-documents">document storage</a>.</p>
<p>The code you read above was inspired by the work we did with JSONB and Massive. You can have a fully-functioning document storage solution that kicks MongoDB in the face in terms of speed, fuzzy searches, full-text indexing, ACID guarantees and a whole lot more. Massive gives you the same, simple document API and frictionless experience you get with Mongo with a much better database engine underneath.</p>
<p>To work with Massive, you create an instance of your database which reads in all of your tables and then allows you to query them as if they were properties (the examples below are taken from the documentation):</p>
<pre><code class="language-js">const massive = require(&apos;massive&apos;);

const db = await massive({
  host: &apos;localhost&apos;,
  port: 5432,
  database: &apos;appdb&apos;,
  user: &apos;appuser&apos;,
  password: &apos;apppwd&apos;,
  ssl: false,
  poolSize: 10
});

//save will update or insert based on the presence of an
//ID field
let test = await db.tests.save({
  version: 1,
  name: &apos;homepage&apos;
});

// retrieve active tests 21-30
const tests = await db.tests.find({is_active: true}, {
  offset: 20,
  limit: 10
});
</code></pre>
<p><a href="https://massivejs.org/docs/working-with-documents">Working with documents</a> looks much the same as the relational stuff above, but it&#x2019;s stored as JSON:</p>
<pre><code class="language-js">const report = await db.saveDoc(&apos;reports&apos;, {
  title: &apos;Week 12 Throughput&apos;,
  lines: [{
    name: &apos;1 East&apos;,
    numbers: [5, 4, 6, 6, 4]
  }, {
    name: &apos;2 East&apos;,
    numbers: [4, 4, 4, 3, 7]
  }]
});
</code></pre>
<p>Finally, the thing I love most about the project is what Dian has done with the documentation (linked above). She goes into detail about every aspect of the tool &#x2013; even <a href="https://massivejs.org/docs/framework-examples">how to use it with popular web frameworks</a>.</p>
<h3>Sequelize</h3>
<p>One of the more popular data access tools &#x2013; let&#x2019;s call it a full on ORM &#x2013; is <a href="https://sequelize.org/v5/">Sequelize</a>. This tool is a traditional ORM in every sense in that it allows you create classes and save them to multiple different <a href="https://sequelize.org/v5/manual/dialects.html">storage engines</a>, including Postgres, MySQL/MariaDB SQLite and SQL Server. It&#x2019;s <em>kind of not an ORM</em> though because there is no mapping (the &quot;M&quot;) that you can do aside from a direct 1:1, ActiveRecord style. For that, you can project what you need using <code>map</code> and I&#x2019;ll just leave that discussion right there.</p>
<p>If you&#x2019;ve used ActiveRecord (Rails or the pattern itself) before then you&#x2019;ll probably feel really comfortable with Sequelize. I used it once on a project and found its use straightforward and simple to understand. <a href="https://sequelize.org/v5/manual/getting-started.html">Getting started</a> was also straightforward, as with any ORM, and the only question is how well an ActiveRecord pattern fits your project&#x2019;s needs <strong>both now and into the future</strong>. That&#x2019;s for you to decide and this is where I hit the architectural eject button again (even though I did once before which didn&#x2019;t seem to work).</p>
<p>Let&#x2019;s have a look at some of the examples that come from the documentation.</p>
<p>Connecting is straightforward:</p>
<pre><code class="language-js">const Sequelize = require(&apos;sequelize&apos;);
const sequelize = new Sequelize(&apos;postgres://user:<a href="/cdn-cgi/l/email-protection" class="__cf_email__">[email&#xA0;protected]</a>:5432/dbname&apos;);
</code></pre>
<p>Declaring a &#x201C;model&#x201D; in Sequelize is matter of creating a class and extending from <code>Sequelize.Model</code> or using a built-in definition method. I prefer the latter:</p>
<pre><code class="language-js">const User = sequelize.define(&apos;user&apos;, {
  // attributes
  firstName: {
    type: Sequelize.STRING,
    allowNull: false
  },
  lastName: {
    type: Sequelize.STRING
    // allowNull defaults to true
  }
}, {
  // options
});
</code></pre>
<p>Sequelize is capable of using this model definition and generating, or &quot;sychronizing&quot; your database just like Django&#x2019;s ORM does. That&#x2019;s really helpful in the early days of your project or if you just hate migrations as much as I do.</p>
<p>Sequelize is an outstanding data tool that allows you to work with your database in a seamless way. It has powerful queries and can handle some pretty intense filtering:</p>
<pre><code class="language-js">Project.findOne({
  where: {
    name: &apos;a project&apos;,
    [Op.not]: [
      { id: [1,2,3] },
      { array: { [Op.contains]: [3,4,5] } }
    ]
  }
}); 
</code></pre>
<p>If you&#x2019;ve worked with Rails and ActiveRecord Sequelize should feel familiar when it comes to associations, hooks and scopes:</p>
<pre><code class="language-js">class User extends Model { }
User.init({
  name: Sequelize.STRING,
  email: Sequelize.STRING
},
  {
    hooks: {
      beforeValidate: (user, options) =&gt; {
        user.mood = &apos;happy&apos;;
      },
      afterValidate: (user, options) =&gt; {
        user.username = &apos;Toni&apos;;
      }
    },
  sequelize,
  modelName: &apos;user&apos;
});
class Project extends Model { }
Project.init({name: Sequelize.STRING}, {
  scopes: {
    deleted: {
      where: {
        deleted: true
      }
    },
    sequelize,
    modelName: &apos;project&apos;
  }
});
User.hasOne(Project);
</code></pre>
<p>And there you have it. The documentation for Sequelize is very complete as well, with examples and SQL translations so you know what query will be produced for every call.</p>
<h3>But what about&#x2026;?</h3>
<p>There are so many tools out there that can help you with Node and data access and I&#x2019;m sure I&#x2019;ve left a few off, so feel free to add your favorite in the comments. Please be sure it works with Postgres AND please be sure to indicate why you like it!</p>
<h2>Postgres is neat and all but how do I deploy my database?</h2>
<p>Great question! That will have to be a topic for Part 3, unfortunately as this post is quite long and I have a lot of ideas. We&#x2019;ll go simple and low fidelity with a simple docker container push, and then look at some of the hosted, industrial strength solutions out there &#x2013; including <a href="https://azure.microsoft.com/en-us/services/postgresql/">Azure&#x2019;s Managed Postgres offering!</a></p>
</div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>