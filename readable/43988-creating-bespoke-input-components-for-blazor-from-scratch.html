<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Creating Bespoke Input Components for Blazor from Scratch -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Creating Bespoke Input Components for Blazor from Scratch</h1>
    <div class="post-content"> <p>In my last post, we looked at how we could build custom input components on top of <code>InputBase</code>. Using <code>InputBase</code> saves us loads of extra work by managing all of the interactions with the <code>EditForm</code> component and the validation system, which is excellent.</p><p>However, sometimes, there are situations where we want or need to have a bit more control over how our input components behave. In this post, we are going to look at how we can build input components from scratch.</p><h2 id="why-build-from-scratch">Why build from scratch?</h2><p>When you consider all the functionality that we get from Blazor&apos;s out-of-the-box input components. Plus, the ability to make customisations using the <code>InputBase</code> class that we looked at last time. Why would we want to build input components from scratch?</p><p>The biggest reason I&apos;ve found so far is the ability to use input components outside of an <code>EditForm</code> component. Any input component which uses InputBase has to be inside of an <code>EditForm</code> component; otherwise, an exception is thrown. That&apos;s because of a check in the <code>OnParametersSet</code> method of <code>InputBase</code>. It checks for an <code>EditContext</code> which is cascaded down via the <code>EditForm</code> component.</p><pre><code class="language-csharp">if (CascadedEditContext == null)
{
    throw new InvalidOperationException($&quot;{GetType()} requires a cascading parameter &quot; + $&quot;of type {nameof(Forms.EditContext)}. For example, you can use {GetType().FullName} inside &quot; + $&quot;an {nameof(EditForm)}.&quot;);
}
</code></pre>
<p>Building from scratch is also beneficial if you&apos;re looking to have total control over how your component acts. By creating everything yourself, you&apos;ll be able to tailor every detail to work precisely the way you want. For example, you could create an <code>EditForm</code> replacement, and that could require you to build custom input components.</p><h2 id="building-from-scratch">Building from scratch</h2><p>We&apos;re going to build a simple text input component which can be used both inside or outside an <code>EditForm</code> component. Text inputs are quite useful components to be able to use both inside a form for any text-based entry. But are equally useful outside of a form for things like search boxes where validation isn&apos;t necessarily a concern.</p><pre><code class="language-csharp">&lt;input value=&quot;@Value&quot; @oninput=&quot;HandleInput&quot; /&gt;

@code {
    [Parameter] public string Value { get; set; }
    [Parameter] public EventCallback&lt;string&gt; ValueChanged { get; set; }

    private async Task HandleInput(ChangeEventArgs args)
    {
        await ValueChanged.InvokeAsync(args.Value.ToString());
    }
}
</code></pre>
<p>This is the basic setup of our <code>CustomInputText</code> component. We have set up a couple of parameters, <code>Value</code> and <code>ValueChanged</code>. These allow us to use Blazor&apos;s <code>bind</code> directive when consuming the control. We&apos;ve hooked onto the input controls <code>oninput</code> event, and every time it fires the <code>HandleInput</code> event invokes the <code>ValueChanged</code> <code>EventCallback</code> to update the value for the consumer.</p><h2 id="working-as-part-of-editform">Working as part of EditForm</h2><p>For an input component to work with EditForm, it has to integrate with <code>EditContext</code>. <code>EditContext</code> is the brain of a Blazor form; it holds all of the metadata regarding the state of the form. Things like whether a field has been modified. Is it valid? As well as a collection of all of the current validation messages.</p><p><code>EditContext</code> is also responsible for raising events to signal that field values have been changed, or that an attempt has been made to submit the form. This triggers the validation aspect of the form.</p><h3 id="integrating-with-editcontext">Integrating with EditContext</h3><p>To integrate with EditContext, we need to add a <code>CascadingParameter</code> to our component requesting it; then we need to create a <code>FieldIdentifier</code>.</p><p>The <code>FieldIdentifier</code> class uniquely identifies a specific field or property in the form. To create an instance, we need to pass in an expression which identifies the field our component is handling. To get this expression, we can add another parameter to our component called <code>ValueExpression</code>. Blazor populates this expression for us based on a convention in a similar way to two-way binding using <code>Value</code> and <code>ValueChanged</code>.</p><pre><code class="language-csharp">[Parameter] public Expression&lt;Func&lt;string&gt;&gt; ValueExpression { get; set; }
</code></pre>
<p>Now we have an expression we can create an instance of <code>FieldIdentifier</code>; we&apos;ll do this in the <code>OnInitialized</code> life cycle method.</p><pre><code class="language-csharp">protected override void OnInitialized()
{
    _fieldIdentifier = FieldIdentifier.Create(ValueExpression);
}
</code></pre>
<p>We need to tell the <code>EditContext</code> when the value of our field has been updated. This will trigger any validation logic that needs to run against our field. We do this by calling the <code>NotifyFieldChanged</code> method on the <code>EditContext</code>.</p><pre><code class="language-csharp">private async Task HandleInput(ChangeEventArgs args)
{
    await ValueChanged.InvokeAsync(args.Value.ToString());
    CascadedEditContext?.NotifyFieldChanged(_fieldIdentifier);
}
</code></pre>
<p>Once the field has been validated it will be marked as either valid or invalid. We can use this value to assign CSS classes to the component and style it appropriately. To access these values we can use the following code.</p><pre><code class="language-csharp">private string _fieldCssClasses =&gt; _editContext?.FieldCssClass(_fieldIdentifier) ?? &quot;&quot;;
</code></pre>
<p>This going to set the <code>_fieldCssClasses</code> field to some combination of <code>modified</code> <code>valid</code> or <code>invalid</code>, depending on the fields current state. </p><p>The final component looks like this.</p><pre><code class="language-csharp">&lt;input class=&quot;_fieldCssClasses&quot; value=&quot;@Value&quot; @oninput=&quot;HandleInput&quot; /&gt;

@code {

    private FieldIdentifier _fieldIdentifier;
    private string _fieldCssClasses =&gt; CascadedEditContext?.FieldCssClass(_fieldIdentifier) ?? &quot;&quot;;

    [CascadingParameter] private EditContext CascadedEditContext { get; set; }

    [Parameter] public string Value { get; set; }
    [Parameter] public EventCallback&lt;string&gt; ValueChanged { get; set; }
    [Parameter] public Expression&lt;Func&lt;string&gt;&gt; ValueExpression { get; set; }

    protected override void OnInitialized()
    {
        _fieldIdentifier = FieldIdentifier.Create(ValueExpression);
    }

    private async Task HandleInput(ChangeEventArgs args)
    {
        await ValueChanged.InvokeAsync(args.Value.ToString());
        CascadedEditContext?.NotifyFieldChanged(_fieldIdentifier);
    }

}
</code></pre>
<h2 id="working-without-editform">Working without EditForm</h2><p>Actually, we&apos;ve already covered this one. You may have noticed on the last code snippet that we used the null-conditional operator (<code>?.</code>) when calling the <code>NotifyFieldChanged</code> method. The reason for this is that if the <code>EditContext</code> is <code>null</code>, then the method won&apos;t be called.</p><p>Why would the <code>EditContext</code> be <code>null</code>? If the control wasn&apos;t inside of an <code>EditForm</code> component. That simple check will allow the control to work outside of an <code>EditForm</code> component without any issue.</p><h3 id="what-are-the-costs">What are the costs?</h3><p>When we use this component without the <code>EditForm</code> component we will no longer be able to use the standard validation mechanisms. Depending on your use case this may or may not matter. </p><p>For the use cases I&apos;ve had, it doesn&apos;t matter, things such as site searches or date pickers, things where I can use default values or not have to care. You could, of course, deal with this manually if you choose. You&apos;re in complete control of the component after all. </p><p>For example, we could add a <code>Required</code> parameter to the component. When this is true, we can check if there is an <code>EditContext</code>. If there isn&apos;t, we can set a private variable to show an error message if the current value is empty.</p><pre><code class="language-csharp">&lt;input class=&quot;_fieldCssClasses&quot; value=&quot;@Value&quot; @oninput=&quot;HandleInput&quot; /&gt;

@if (_showValidation)
{
    &lt;div class=&quot;validation-message&quot;&gt;You must provide a name&lt;/div&gt;
}

@code {

    private FieldIdentifier _fieldIdentifier;
    private string _fieldCssClasses =&gt; CascadedEditContext?.FieldCssClass(_fieldIdentifier) ?? &quot;&quot;;
    private bool _showValidation;

    [CascadingParameter] private EditContext CascadedEditContext { get; set; }

    [Parameter] public string Value { get; set; }
    [Parameter] public EventCallback&lt;string&gt; ValueChanged { get; set; }
    [Parameter] public Expression&lt;Func&lt;string&gt;&gt; ValueExpression { get; set; }
    [Parameter] public bool Required { get; set; }

    protected override void OnInitialized()
    {
        _fieldIdentifier = FieldIdentifier.Create(ValueExpression);
    }

    private async Task HandleInput(ChangeEventArgs args)
    {
        await ValueChanged.InvokeAsync(args.Value.ToString());

        if (CascadedEditContext != null)
        {
            CascadedEditContext.NotifyFieldChanged(_fieldIdentifier);
        }
        else if (Required)
        {
            _showValidation = string.IsNullOrWhiteSpace(args.Value.ToString());
        }
    }

}
</code></pre>
<p>If we don&apos;t want the error message to be hardcoded, that&apos;s cool too; we can add a parameter for the error message so that it can be passed in. The point here is that you can customise the behaviour as much as you like based on your needs.</p><p>In this post, we&apos;ve looked at how we can build bespoke input components that work inside and outside of the <code>EditForm</code> component. We started by looking at why we would want to do this in the first place. Then we looked at how to integrate with the built in forms and validation system of Blazor. As well as how to make the component work without that system. Finally, we talked about some of the trade off of working outside of <code>EditForm</code>.</p> <div class="coffee-button"> <a class="bmc-button" href="https://www.buymeacoffee.com/chrissainty"> <img src="https://bmc-cdn.nyc3.digitaloceanspaces.com/BMC-button-images/BMC-btn-logo.svg" alt="Buy me a coffee"> <span>Buy me a coffee</span> </a> </div> <div class="post-tags"> Tagged in: <a href="/blazor/">Blazor</a> | <a href="/forms/">Forms</a> | <a href="/blazor-server-side/">Blazor (Server)</a> | <a href="/blazor-client-side/">Blazor (WebAssembly)</a> </div> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>