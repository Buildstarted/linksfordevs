<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Verified cryptographic provider a triple threat - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Verified cryptographic provider a triple threat - linksfor.dev(s)"/>
    <meta property="article:author" content="Nikhil Swamy&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Principal Researcher"/>
    <meta property="og:description" content="Working toward provably secure online communications requires a strong foundation on which to build protocols. Enter EverCrypt, a fully verified cryptographic provider offering a comprehensive suite of algorithms, agility, and multiplexing capabilities"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.microsoft.com/en-us/research/blog/evercrypt-cryptographic-provider-offers-developers-greater-security-assurances/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Verified cryptographic provider a triple threat</title>
<div class="readable">
        <h1>Verified cryptographic provider a triple threat</h1>
            <div>by Nikhil Swamy&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Principal Researcher</div>
            <div>Reading time: 8-10 minutes</div>
        <div>Posted here: 06 Apr 2019</div>
        <p><a href="https://www.microsoft.com/en-us/research/blog/evercrypt-cryptographic-provider-offers-developers-greater-security-assurances/">https://www.microsoft.com/en-us/research/blog/evercrypt-cryptographic-provider-offers-developers-greater-security-assurances/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
					<article data-bi-name="blog post">

						

						

						<section data-bi-name="social share">
							

						</section>

						<section>
							<p><img src="https://www.microsoft.com/en-us/research/uploads/prod/2019/03/Evercrypt_Blog_Site_01_2019_BlogHeader_cropped-002-1024x328.png" alt="" width="1024" height="328" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2019/03/Evercrypt_Blog_Site_01_2019_BlogHeader_cropped-002-1024x328.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2019/03/Evercrypt_Blog_Site_01_2019_BlogHeader_cropped-002-300x96.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2019/03/Evercrypt_Blog_Site_01_2019_BlogHeader_cropped-002-768x246.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2019/03/Evercrypt_Blog_Site_01_2019_BlogHeader_cropped-002.png 1401w" sizes="(max-width: 1024px) 100vw, 1024px"></p>
<p><em><a href="https://project-everest.github.io/">Project Everest</a> is a multiyear collaborative effort focused on building a verified, secure communications stack designed to improve the security of HTTPS, a key internet safeguard. This post, about the high-performance industrial-grade <a href="https://github.com/project-everest/hacl-star/blob/fstar-master/README.EverCrypt.md">EverCrypt cryptographic provider</a>, is the second in a series exploring the groundbreaking work, which is available on <a href="https://github.com/project-everest">GitHub</a> now.</em></p>
<p>If you’re reading this blog post right now, you’re likely using HTTPS, the most popular application of the Transport Layer Security (TLS) protocol. In fact, if you’ve logged in to a website, checked your email, ordered a product, or banked online today, you’ve used it. Just check out the URL in your address bar. An internet standard, TLS powers most secure communications over the internet, ensuring all clients and servers can interoperate with each other.</p>
<p>Delivering an implementation of TLS that guarantees with mathematical certainty your communications will be confidential and protected is a vast and ambitious effort. Like the building of a pyramid, it requires a strong foundation. Such an implementation needs successive verified software layers, beginning with the raw cryptographic algorithms, followed by a cryptographic provider. A crucially important component, the cryptographic provider orchestrates these standalone algorithms into a unified collection to meet the security needs of the protocol. Today, we’re happy to introduce the first fully verified cryptographic provider.</p>
<p><a href="https://github.com/project-everest/hacl-star/blob/fstar-master/README.EverCrypt.md">EverCrypt</a>—developed and verified by the <a href="https://project-everest.github.io/">Project Everest</a> team—offers the same features, convenience, and performance as popular existing cryptographic libraries without the bugs that leave protocols and applications vulnerable. Usable by verified and unverified clients alike, EverCrypt emphasizes both multiplatform support and high performance. We accomplish this by producing both platform-agnostic C code and optimized assembly code for specific hardware targets through the combination of two components of Project Everest: the <a href="https://github.com/project-everest/hacl-star/blob/fstar-master/README.HACL.md">HACL*</a> cryptographic library developed jointly between <a href="http://prosecco.gforge.inria.fr/">Inria</a> and Microsoft Research and the <a href="https://github.com/project-everest/hacl-star/blob/fstar-master/README.Vale.md">Vale-Crypto library</a> of assembly primitives developed collectively between Microsoft Research and <a href="https://www.andrew.cmu.edu/user/bparno/">Carnegie Mellon University</a>.</p>
<h3>The case for verification</h3>
<p>Historically, writing a high-quality, trustworthy cryptographic library has been a difficult task, and many of the bugs found in security applications like TLS turn out to be in this underlying layer. These bugs are often a result of extremely complex cryptographic implementations that have been designed to achieve maximum performance. For each algorithm, there are dozens of implementations, each hand-tuned to a specific platform so the implementation can leverage vector or crypto-specific instructions. This practice—known as implementation multiplexing—allows a library to provide high-performance implementations on popular hardware platforms while still providing a fallback implementation that’ll work on any platform. For instance, one may find <a href="https://github.com/openssl/openssl/blob/master/crypto/aes/asm/aesni-x86_64.pl#L1176">several versions of the AES block cipher</a>, some using SSE, AVX, or NEON, or even the dedicated AES-NI collection of instructions.</p>
<p>In light of this complexity, it’s no surprise existing crypto libraries have bugs. After all, who among us can truly scrutinize half a dozen slightly different assembly implementations and spot a bug—for example, a forgotten carry-bit propagation—that testing has an infinitesimally small chance of finding?</p>
<p>The research community has recognized this as an urgent issue and over the past few years has produced several verified implementations of individual algorithms. While these developments have advanced our understanding of the research area, they do not provide the kind of industrial-grade features developers have come to expect from popular established libraries such as <a href="https://docs.microsoft.com/en-us/windows/desktop/seccng/cng-portal">Microsoft Windows Cryptography API: Next Generation</a>, <a href="https://wiki.openssl.org/index.php/Libcrypto_API">OpenSSL’s libcrypto</a>, or <a href="https://download.libsodium.org/doc/">libsodium</a>.</p>
<h3>A high-performance industrial-grade provider—minus the bugs</h3>
<p>To meet the needs and expectations of programmers today, a cryptographic library should possess three features:</p>
<ul>
<li><strong>Comprehensiveness</strong>: Application developers want a single library that covers all of the functionality they’ll need—asymmetric and symmetric encryption and signing, hashing, and key derivation, at the very least.</li>
<li><strong>Agility</strong>: A modern cryptographic library should provide multiple algorithms for the same functionality and all of the algorithms should employ a single unified API to make it simple to change algorithms if one is broken.</li>
<li><strong>Multiplexing capabilities</strong>: The library should support multiplexing but make these choices automatically rather than force the developer to do so.</li>
</ul>
<p>With EverCrypt, we deliver this and more. EverCrypt comprises a comprehensive suite of algorithms that includes <a href="https://github.com/project-everest/hacl-star/blob/fstar-master/README.EverCrypt.md">block ciphers, elliptic curves, and hash functions</a>. To build cryptographically agile applications, developers can use the EverCrypt interface to easily switch from the algorithm SHA2-256 to SHA3-512, for instance. As far as multiplexing, we’ve designed EverCrypt to choose the best implementations based on the features of the processor it’s running on. And we’ve verified the entire provider, which distinguishes it from other libraries available today.</p>
<h3>Performance <em>and</em> safety</h3>
<p>By using the <a href="https://fstar-lang.org/">F* programming language</a> for all our verification results, we’ve enabled EverCrypt to perform verified implementation multiplexing and algorithmic agility. No matter which implementation or algorithm is called, the same cryptographic guarantees apply. For verified clients of EverCrypt, the details of multiplexing and agility are intentionally hidden, providing a clean interface that serves as a robust foundation for the subsequent layer of the pyramid. Our TLS implementation sits right above EverCrypt, and the careful design of EverCrypt directly benefits and supports the verification efforts taking place in the TLS layer.</p>
<p>Under the EverCrypt hood, we bring together HACL* and Vale-Crypto, both of which are written using domain-specific languages based on F*. HACL* is written in <a href="https://github.com/FStarLang/kremlin">Low*</a> for verified low-level C implementations, while Vale-Crypto is written in <a href="https://github.com/project-everest/vale">Vale</a> for verified assembly implementations. Both are verified for memory safety, correctness, and side-channel resistance. Crucially, Vale and Low* algorithms are shown to implement the same specifications, meaning that the two can be brought together under the EverCrypt provider interface. The two languages can interoperate—mundane, noncritical parts of an algorithm are written once in Low*, leaving more time to write and verify performance-critical code in Vale.</p>
<p>Thanks to the mixture of C and assembly code, the verification effort doesn’t compromise performance. EverCrypt operates on par with, or better than, many existing offerings.</p>
<h3>EverCrypt—TLS and beyond</h3>
<p>We built EverCrypt for our TLS implementation, but we designed the provider to be useful for a wide range of software beyond TLS, from disk encryption to instant messaging. As of this writing, several other clients use EverCrypt for their cryptographic needs.</p>
<p>As part of the work we’re doing with Project Everest, we have one verified client written in F*: a <a href="https://github.com/project-everest/hacl-star/tree/fstar-master/secure_api/merkle_tree">Merkle tree library</a> usable for blockchains. Outside of Project Everest, clients include Mozilla Firefox; the WireGuard VPN; the upcoming Zinc crypto library for the Linux kernel; the MirageOS unikernel; and the Tezos blockchain. Parts of EverCrypt have been used for over a year within Microsoft in support of implementing the QUIC protocol. These clients are usually written in C and are not themselves verified; however, because they use a verified cryptographic provider, they’re reducing their attack surface and improving their security and reliability.</p>
<p>As tools improve and the scope of verification expands, we hope that EverCrypt will not only show that large-scale verified libraries are attainable but also that there now exist viable alternatives to legacy libraries. With EverCrypt, developers no longer have to compromise performance for security, and it is our aspiration that many more software projects start using EverCrypt for greater assurance.</p>
						</section>
					</article><!--/.msr-post-article-->
					</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>