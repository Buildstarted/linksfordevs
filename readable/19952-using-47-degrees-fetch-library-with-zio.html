<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using 47 Degree&#x27;s Fetch library with ZIO -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Using 47 Degree's Fetch library with ZIO</h1><div><div class="post-content" itemprop="articleBody"><p>This post has accompanying source code on Github:</p><p>This post is an update to an ongoing series. See previous post here:</p><h2 id="fetch-10">Fetch 1.0</h2><p>47 Degrees create and maintain a useful library called Fetch, “A library for Simple &amp; Efficient data access in Scala and Scala.js”, which I’ve written about before, and recently reached version 1.0. You can check the full releases notes here:</p><p>There are a few interesting changes in this release but most notable is the move to using Cats Effect. Previously, Fetch operated under the hood using <code class="language-plaintext highlighter-rouge">FetchMonadError</code>, a monadic type which you can implement in order to manage how your Fetch is interpreted at runtime. Twitter Futures, vanilla Scala Future’s and Monix Task were supported.</p><p>As functional programming libraries start to standardise on a common API for effects, it makes it possible for library authors to implement their code in terms of a generic effect type, and then for the user, who may also be attached to a particular library, to provide their runtime and effect of choice.</p><p>Another interesting change which I haven’t checked out yet, but is something I felt lacking from the pre-1.0 library was the ability to fetch potentially missing items. Rather than get an error if an item does not exist you can specify that it is optional.</p><p>Still present are the former features such as logging and caching, though oddly the ability to run a fetch with a cache and a log at the same time has been removed.</p><h2 id="conversion-to-use-cats-effect">Conversion to use Cats Effect</h2><p>Step one of upgrading my code (a simple Hacker News API client) to use Fetch 1.0 was to update the DataSources that specify what things can be fetched and how.</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span><span class="nc">HNItemSource</span><span class="k">extends</span><span class="nc">Data</span><span class="o">[</span><span class="kt">HNItemID</span>, <span class="kt">HNItem</span><span class="o">]</span><span class="o">{</span><span class="k">override</span><span class="k">def</span><span class="nf">name</span><span class="k">=</span><span class="s">"item"</span><span class="k">def</span><span class="nf">source</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">ConcurrentEffect</span><span class="o">]</span><span class="k">=</span><span class="k">new</span><span class="nc">DataSource</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">HNItemID</span>, <span class="kt">HNItem</span><span class="o">]</span><span class="o">{</span><span class="k">override</span><span class="k">def</span><span class="nf">data</span><span class="k">=</span><span class="nc">HNItemSource</span><span class="k">override</span><span class="k">def</span><span class="nf">CF</span><span class="k">=</span><span class="nc">ConcurrentEffect</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span><span class="k">override</span><span class="k">def</span><span class="nf">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span><span class="kt">HNItemID</span><span class="o">)</span><span class="k">:</span><span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">HNItem</span><span class="o">]]</span><span class="k">=</span><span class="nv">CF</span><span class="o">.</span><span class="py">delay</span><span class="o">(</span><span class="nv">HNFetch</span><span class="o">.</span><span class="py">getItemSync</span><span class="o">(</span><span class="n">id</span><span class="o">).</span><span class="py">toOption</span><span class="o">)</span><span class="o">}</span><span class="o">}</span><span class="k">def</span><span class="nf">getItem</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">ConcurrentEffect</span><span class="o">](</span><span class="n">id</span><span class="k">:</span><span class="kt">HNItemID</span><span class="o">)</span><span class="k">:</span><span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">HNItem</span><span class="o">]</span><span class="k">=</span><span class="nc">Fetch</span><span class="o">(</span><span class="n">id</span><span class="o">,</span><span class="nv">HNItemSource</span><span class="o">.</span><span class="py">source</span><span class="o">)</span></code></pre></div></div><p>The interesting changes from the original code are that we are passing in a higher kinded type F which must implement ConcurrentEffect from Cats. We also have a new type Data which wraps the DataSource’s familiar from the previous version.</p><p>Now the file <a href="https://github.com/justinhj/hnfetch/blob/zio-cats-effect/src/main/scala/justinhj/hnfetch/HNDataSources.scala">HNDataSources.scala</a> is updated to use generic effects we can implement the program using Zio, Cats Effect and any other compatible effect library.</p><p>In <a href="https://github.com/justinhj/hnfetch/blob/zio-cats-effect/src/main/scala/examples/FrontPageWithFetchCats.scala">FrontPageWithFetchCats.scala</a> I’ve ported the previous version which used Monix Task to use Cats Effect. This process was straightforward because of the similarities between Monix and Cats.</p><h2 id="using-zio">Using ZIO</h2><p>Making the conversion to ZIO is a similar process except in the process I also modified the program to use Zio’s new environment. This enables me to use Console replace all the println and readline code, and used ZIO’s API to make the code a bit clearer than the original. If I wasn’t sharing the code between Cats and Zio it would be better to add things like the Http retrieval and Json parsing as environments, so that they can be swapped out for testing performance of different libraries and for testing purposes.</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span><span class="nv">cache</span><span class="k">=</span><span class="nv">InMemoryCache</span><span class="o">.</span><span class="py">from</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">HNItemID</span>, <span class="kt">HNItem</span><span class="o">]()</span><span class="k">val</span><span class="nv">program</span><span class="k">=</span><span class="o">(</span><span class="nf">for</span><span class="o">(</span><span class="n">items</span><span class="k">&lt;-</span><span class="nv">ZIO</span><span class="o">.</span><span class="py">absolve</span><span class="o">(</span><span class="nf">getTopItems</span><span class="o">().</span><span class="py">mapError</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">getMessage</span><span class="o">));</span><span class="k">_</span><span class="k">&lt;-</span><span class="nf">showPagesLoop</span><span class="o">(</span><span class="n">items</span><span class="o">,</span><span class="n">cache</span><span class="o">)</span><span class="o">)</span><span class="nf">yield</span><span class="o">()).</span><span class="py">foldM</span><span class="o">(</span><span class="n">err</span><span class="k">=&gt;</span><span class="nf">printError</span><span class="o">(</span><span class="nv">err</span><span class="o">.</span><span class="py">toString</span><span class="o">),</span><span class="k">_</span><span class="k">=&gt;</span><span class="nv">ZIO</span><span class="o">.</span><span class="py">succeed</span><span class="o">(()))</span><span class="nv">runtime</span><span class="o">.</span><span class="py">unsafeRun</span><span class="o">(</span><span class="n">program</span><span class="o">)</span></code></pre></div></div><p>Since <code class="language-plaintext highlighter-rouge">getTopItems</code> handles errors using <code class="language-plaintext highlighter-rouge">Either[String, A]</code> I use a couple of ZIO’s functions to map that to <code class="language-plaintext highlighter-rouge">ZIO[Env, String, A]</code>.</p><p>We are now using, on the surface, ZIO’s runtime and types, to call into Fetch and have it do work for us even though there is no explicit support for Scalaz in general, and ZIO in particular, in the Fetch library. Quite magical! All we need to make this work is some implicit conversion that lets ZIO take care of converting our ZIO structures to and and from Cats Effect ones:</p><p><a href="https://github.com/justinhj/hnfetch/blob/zio-cats-effect/src/main/scala/examples/FrontPageWithFetchZio.scala">FrontPageWithFetchZio.scala</a></p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span><span class="nn">scalaz.zio.interop.catz._</span><span class="k">import</span><span class="nn">scalaz.zio.interop.catz.implicits._</span></code></pre></div></div><p>You can read about this in ZIO’s documentation here: <a href="https://scalaz.github.io/scalaz-zio/interop/catseffect.html">ZIO Cats Effect interop</a></p><h2 id="combinators---sequence-and-traverse">Combinators - sequence and traverse</h2><p>As discussed in the Fetch documentation you can use the combinators <code class="language-plaintext highlighter-rouge">traverse</code> and <code class="language-plaintext highlighter-rouge">sequence</code> to combine fetch’s together. In the Cats Effect version we can fetch many items at once by constructing each invidual fetch (which has type <code class="language-plaintext highlighter-rouge">Fetch[F, A</code>) and adding them to a list. We then need to convert <code class="language-plaintext highlighter-rouge">List[Fetch[F, A]</code> to <code class="language-plaintext highlighter-rouge">Fetch[F, List[A]]</code>. This is done as follows:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span><span class="nv">pageOfItems</span><span class="k">=</span><span class="nv">hNItemIDList</span><span class="o">.</span><span class="py">slice</span><span class="o">(</span><span class="n">startPage</span><span class="o">*</span><span class="n">numItemsPerPage</span><span class="o">,</span><span class="n">startPage</span><span class="o">*</span><span class="n">numItemsPerPage</span><span class="o">+</span><span class="n">numItemsPerPage</span><span class="o">)</span><span class="k">val</span><span class="nv">fetchItems</span><span class="k">:</span><span class="kt">Fetch</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">HNItem</span><span class="o">]]</span><span class="k">=</span><span class="nv">pageOfItems</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span><span class="n">getItem</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span><span class="nv">Fetch</span><span class="o">.</span><span class="py">runCache</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">fetchItems</span><span class="o">,</span><span class="n">cache</span><span class="o">)</span></code></pre></div></div><p>Now although I can run simple fetch’s using ZIO interop without having to do much work, it’s not as easy to use traverse with Scalaz and ZIO. I did spend some time trying but it appears that the reason this works in my Cats Effect code is that fetch itself implements a Monad for Fetch and that Monad is implemented in terms of Cats. In order to use the combinators without Cats you need to either reimplement the Fetch Monad, or at least enough operations to support traverse (applicative and pure), and then it will be fine.</p><p>Rather than go to those lengths, for the purposes of just making this work I implemented a helper function in the DataSources file, which uses Cats and returns the appropriate data structure which can then be used by ZIO when the Fetch executes.</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span><span class="nf">getMultipleItems</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span><span class="kt">ConcurrentEffect</span><span class="o">](</span><span class="n">ids</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">HNItemID</span><span class="o">],</span><span class="n">cache</span><span class="k">:</span><span class="kt">DataCache</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="o">(</span><span class="k">implicit</span><span class="n">cs</span><span class="k">:</span><span class="kt">ContextShift</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span><span class="n">timer</span><span class="k">:</span><span class="kt">Timer</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">=</span><span class="o">{</span><span class="k">val</span><span class="nv">fetchItems</span><span class="k">:</span><span class="kt">Fetch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">HNItem</span><span class="o">]]</span><span class="k">=</span><span class="nv">ids</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span><span class="n">getItem</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="nv">Fetch</span><span class="o">.</span><span class="py">runCache</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">fetchItems</span><span class="o">,</span><span class="n">cache</span><span class="o">)</span><span class="o">}</span></code></pre></div></div><h2 id="conclusion">Conclusion</h2><p>The experience of porting code to use Cats Effect and ZIO with a library that uses an effect type as it’s API was quite straightforward, and I find this style promising for the future, particularly as effects get more features and hopefully more standardised. It can get interesting to mentally juggle which typeclasses and data types you are using at any particular part of the program.</p><p>Thanks for reading!</p><p>Copyright (C) 2019 Justin-Heyes-Jones - All Rights Reserved</p></div><p>
    Tags:
    
      scala  
    
      functional programming  
    
      zio  
    
      Hacker News  
    
      Hacker News API  
    
      47 Degrees  
    
      Fetch  
    
  </p></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>