<!DOCTYPE html>
<html lang="en">
<head>
    <title>
(Heads up) Switch to SHA256 &#xB7; Issue #612 &#xB7; ethereum/eth2.0-specs &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>(Heads up) Switch to SHA256 · Issue #612 · ethereum/eth2.0-specs · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>Just thought I'd weigh in with some thoughts. It seems that this problem can be viewed via one of two lenses:</p><ul><li>Compatibility</li><li>Future-proofing</li></ul><p><strong>Compatibility</strong>: The advantages to using <code>SHA256</code> for the sake of compatibility are clear, as are are the implementation/speed advantages over Keccak (e.g. Intel's instruction sets). Backwards compatibility is the reason <code>blake2b</code> has been decided against for Eth2.0, however there are <a href="https://github.com/ethereum/EIPs/issues/152" data-hovercard-type="issue" data-hovercard-url="/ethereum/EIPs/issues/152/hovercard">some indicators</a> that suggest Eth1 will eventually be able to compute <code>blake2b</code> efficiently, at which point it would make a lot of sense for Eth2.0 to use <code>blake2b</code>.<br>While maintaining backwards compatibility is clearly essential, I believe one of the Eth2.0 project goals is to pave the way for a better Ethereum overall; which I think means that it should exert a positive influence on Eth1. If we think that <code>blake2b</code> is a better function, I would hope that Eth1 can adapt in due course.<br>From my understanding, the main reason that using a hashing algorithm which is inefficient in Eth1, such as <code>blake2b</code>, is that it inhibits the ability to move data/ether from Eth2.0 back into Eth1; i.e. it prevents Eth1 from reading/verifying the Eth2.0 state. I imagine that regardless of the hash function, Eth1 will require an update before it can perform verification in any case, and so introducing a more efficient hash function in the same update will be comparatively easier. Also, this would only need to happen once Eth2.0 is well established, and Eth1 decides to support it.</p><p><strong>Future-Proofing</strong>: Since Bitcoin's PoW mechanism uses <code>SHA256</code>, the global potential/expected hashes-per-second rate for <code>SHA256</code> is far higher than any other hash function. There exist clear incentives for developing faster hashing, and more sophisticated attacks for, <code>SHA256</code>; demonstrated so far by Bitcoin's <a href="https://www.blockchain.com/en/charts/hash-rate?timespan=2years" rel="nofollow">historical hashrate</a>. I think that this increases the likelihood of hash collisions in the long-term. As such, I don't think it's a good long-term strategy to depend solely on <code>SHA256</code>. <code>Keccak256</code> however, does not currently suffer from this issue, and so I would consider it <em>slightly</em> more future-proof than <code>SHA256</code>, but much less than <code>blake2b</code>.<br>I also don't believe the <a href="https://en.wikipedia.org/wiki/Length_extension_attack" rel="nofollow"><em>length-extension attack</em></a> is a disadvantage of <code>SHA256</code> in our use case, reasons for which <a href="https://github.com/tendermint/iavl/issues/38#issuecomment-386602511" data-hovercard-type="issue" data-hovercard-url="/tendermint/iavl/issues/38/hovercard">have been explained</a> by <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/zmanian/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/zmanian">@zmanian</a>.</p><p>Personally, I feel the goal of choosing the correct technology with good future-proofing is more important than maintaining compatibility. In this case, I think <code>blake2b</code> is the best choice, and I can understand why Polkadot made this choice. However, if we have collectively decided to <em>not</em> use <code>blake2b</code>, then I don't think the future-proofness of <code>Keccak256</code> outweighs the compatibility advantages of <code>SHA256</code>.</p><p>I think <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/benjaminion/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/benjaminion">@benjaminion</a>'s suggestion of using <a href="https://multiformats.io/multihash/" rel="nofollow">multihash</a> is a fantastic one. The implementation overhead for supporting multiple hashes in this format is negligible and it means we get the ultimate flexibility in choosing hash functions on-the-fly. I imagine that this would mean particular blocks or shards could select a hash function according to their goals. Maybe, in the beginning, only certain blocks need to be verified by Eth1, and those blocks can simply choose <code>SHA256</code>, while others can choose <code>blake2b</code>, thereby having selective interoperability and allowing us to adjust the slider between compatibility/future-proofing as we go. It also means that if vulnerabilities are discovered in any hashing algorithm, deprecating a function would be considerably easier. Further, multihash is maintained by Protocol Labs, so I assume it would have good support in libp2p.</p><p><strong>Summary</strong>:<br>I prefer:</p><ol><li><code>blake2b</code></li><li><code>SHA256</code></li><li><code>Keccak256</code></li></ol><p>But I don't think we should choose now and we should instead support multihash and allow any secure hashing algorithm.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>